{
    "topic": "demonstrates the concept of converting a value between 0 and 1 to an R",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "import warnings\n",
        "warnings.warn(\"\"\"\n",
        "    Warning: This file makes use of\n",
        "    ContinualAnimation, which has since\n",
        "    been deprecated\n",
        "\"\"\")\n",
        "\n",
        "import time\n",
        "\n",
        "import mpmath\n",
        "mpmath.mp.dps = 7\n",
        "\n",
        "\n",
        "# Warning, this file uses ContinualChangingDecimal,\n",
        "# which has since been been deprecated.  Use a mobject\n",
        "# updater instead\n",
        "\n",
        "\n",
        "# Useful constants to play around with\n",
        "UL = UP + LEFT\n",
        "UR = UP + RIGHT\n",
        "DL = DOWN + LEFT\n",
        "DR = DOWN + RIGHT\n",
        "standard_rect = np.array([UL, UR, DR, DL])\n",
        "\n",
        "# Used in EquationSolver2d, and a few other places\n",
        "border_stroke_width = 10\n",
        "\n",
        "# Used for clockwise circling in some scenes\n",
        "cw_circle = Circle(color = WHITE).stretch(-1, 0)\n",
        "\n",
        "# Used when walker animations are on black backgrounds, in EquationSolver2d and PiWalker\n",
        "WALKER_LIGHT_COLOR = GREY_D\n",
        "\n",
        "ODOMETER_RADIUS = 1.5\n",
        "ODOMETER_STROKE_WIDTH = 20\n",
        "\n",
        "# TODO/WARNING: There's a lot of refactoring and cleanup to be done in this code,\n",
        "# (and it will be done, but first I'll figure out what I'm doing with all this...)\n",
        "# -SR\n",
        "\n",
        "# This turns counterclockwise revs into their color. Beware, we use CCW angles \n",
        "# in all display code, but generally think in this video's script in terms of \n",
        "# CW angles\n",
        "def rev_to_rgba(alpha):\n",
        "    alpha = (0.5 - alpha) % 1 # For convenience, to go CW from red on left instead of CCW from right\n",
        "    # 0 is red, 1/6 is yellow, 1/3 is green, 2/3 is blue\n",
        "    hue_list = [0, 0.5/6.0, 1/6.0, 1.1/6.0, 2/6.0, 3/6.0, 4/6.0, 5/6.0]\n",
        "    num_hues = len(hue_list)\n",
        "    start_index = int(np.floor(num_hues * alpha)) % num_hues\n",
        "    end_index = (start_index + 1) % num_hues\n",
        "    beta = (alpha % (1.0/num_hues)) * num_hues\n",
        "\n",
        "    start_hue = hue_list[start_index]\n",
        "    end_hue = hue_list[end_index]\n",
        "    if end_hue < start_hue:\n",
        "        end_hue = end_hue + 1\n",
        "    hue = interpolate(start_hue, end_hue, beta)\n",
        "\n",
        "    return color_to_rgba(Color(hue = hue, saturation = 1, luminance = 0.5))\n",
        "\n",
        "    # alpha = alpha % 1\n",
        "    # colors = colorslist\n",
        "    # num_colors = len(colors)\n",
        "    # beta = (alpha % (1.0/num_colors)) * num_colors\n",
        "    # start_index = int(np.floor(num_colors * alpha)) % num_colors\n",
        "    # end_index = (start_index + 1) % num_colors\n",
        "\n",
        "    # return interpolate(colors[start_index], colors[end_index], beta)\n",
        "\n",
        "def rev_to_color(alpha):\n",
        "    return rgba_to_color(rev_to_rgba(alpha))\n",
        "\n",
        "def point_to_rev(xxx_todo_changeme6, allow_origin = False):\n",
        "    # Warning: np.arctan2 would happily discontinuously returns the value 0 for (0, 0), due to \n",
        "    # design choices in the underlying atan2 library call, but for our purposes, this is \n",
        "    # illegitimate, and all winding number calculations must be set up to avoid this\n",
        "    (x, y) = xxx_todo_changeme6\n",
        "    if not(allow_origin) and (x, y) == (0, 0):\n",
        "        print(\"Error! Angle of (0, 0) computed!\")\n",
        "        return\n",
        "    return fdiv(np.arctan2(y, x), TAU)\n",
        "\n",
        "def point_to_size(xxx_todo_changeme7):\n",
        "    (x, y) = xxx_todo_changeme7\n",
        "    return np.sqrt(x**2 + y**2)\n",
        "\n",
        "# rescaled_size goes from 0 to 1 as size goes from 0 to infinity\n",
        "# The exact method is arbitrarily chosen to make pleasing color map\n",
        "# brightness levels\n",
        "def point_to_rescaled_size(p):\n",
        "    base_size = point_to_size(p)\n",
        "\n",
        "    return np.sqrt(fdiv(base_size, base_size + 1))\n",
        "\n",
        "def point_to_rgba(point):\n",
        "    rev = point_to_rev(point, allow_origin = True)\n",
        "    rgba = rev_to_rgba(rev)\n",
        "    rescaled_size = point_to_rescaled_size(point)\n",
        "    return rgba * [rescaled_size, rescaled_size, rescaled_size, 1] # Preserve alpha\n",
        "\n",
        "positive_color = rev_to_color(0)\n",
        "negative_color = rev_to_color(0.5)\n",
        "neutral_color = rev_to_color(0.25)\n",
        "        \n",
        "class EquationSolver1d(GraphScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "    \"camera_config\" : \n",
        "        {\n",
        "            \"use_z_coordinate_for_display_order\": True,\n",
        "        },\n",
        "    \"func\" : lambda x : x,\n",
        "    \"targetX\" : 0,\n",
        "    \"targetY\" : 0,\n",
        "    \"initial_lower_x\" : 0,\n",
        "    \"initial_upper_x\" : 10,\n",
        "    \"num_iterations\" : 10,\n",
        "    \"iteration_at_which_to_start_zoom\" : None,\n",
        "    \"graph_label\" : None,\n",
        "    \"show_target_line\" : True,\n",
        "    \"base_line_y\" : 0, # The y coordinate at which to draw our x guesses\n",
        "    \"show_y_as_deviation\" : False, # Displays y-values as deviations from target,\n",
        "    }\n",
        "\n",
        "    def drawGraph(self):\n",
        "        self.setup_axes()\n",
        "        self.graph = self.get_graph(self.func)\n",
        "        self.add(self.graph)\n",
        "\n",
        "        if self.graph_label != None:\n",
        "            curve_label = self.get_graph_label(self.graph, self.graph_label, \n",
        "                x_val = 4, direction = LEFT)\n",
        "            curve_label.shift(LEFT)\n",
        "            self.add(curve_label)\n",
        "        \n",
        "        if self.show_target_line:\n",
        "            target_line_object = DashedLine(\n",
        "                self.coords_to_point(self.x_min, self.targetY), \n",
        "                self.coords_to_point(self.x_max, self.targetY),\n",
        "                dash_length = 0.1)\n",
        "            self.add(target_line_object)\n",
        "\n",
        "            target_label_num = 0 if self.show_y_as_deviation else self.targetY\n",
        "            target_line_label = OldTex(\"y = \" + str(target_label_num))\n",
        "            target_line_label.next_to(target_line_object.get_left(), UP + RIGHT)\n",
        "            self.add(target_line_label)\n",
        "\n",
        "        self.wait() # Give us time to appreciate the graph\n",
        "\n",
        "        if self.show_target_line:\n",
        "            self.play(FadeOut(target_line_label)) # Reduce clutter\n",
        "\n",
        "        print(\"For reference, graphOrigin: \", self.coords_to_point(0, 0))\n",
        "        print(\"targetYPoint: \", self.coords_to_point(0, self.targetY))\n",
        "\n",
        "    # This is a mess right now (first major animation coded), \n",
        "    # but it works; can be refactored later or never\n",
        "    def solveEquation(self):\n",
        "        # Under special conditions, used in GuaranteedZeroScene, we let the \n",
        "        # \"lower\" guesses actually be too high, or vice versa, and color \n",
        "        # everything accordingly\n",
        "\n",
        "        def color_by_comparison(val, ref):\n",
        "            if val > ref:\n",
        "                return positive_color\n",
        "            elif val < ref:\n",
        "                return negative_color\n",
        "            else:\n",
        "                return neutral_color\n",
        "\n",
        "        lower_color = color_by_comparison(self.func(self.initial_lower_x), self.targetY)\n",
        "        upper_color = color_by_comparison(self.func(self.initial_upper_x), self.targetY)\n",
        "\n",
        "        if self.show_y_as_deviation:\n",
        "            y_bias = -self.targetY\n",
        "        else:\n",
        "            y_bias = 0\n",
        "\n",
        "        startBrace = OldTex(\"|\", stroke_width = 10) #Tex(\"[\") # Not using [ and ] because they end up crossing over \n",
        "        startBrace.set_color(lower_color)\n",
        "        endBrace = startBrace.copy().stretch(-1, 0)\n",
        "        endBrace.set_color(upper_color)\n",
        "        genericBraces = Group(startBrace, endBrace)\n",
        "        #genericBraces.scale(1.5)\n",
        "\n",
        "        leftBrace = startBrace.copy()\n",
        "        rightBrace = endBrace.copy()\n",
        "        xBraces = Group(leftBrace, rightBrace)\n",
        "\n",
        "        downBrace = startBrace.copy()\n",
        "        upBrace = endBrace.copy()\n",
        "        yBraces = Group(downBrace, upBrace)\n",
        "        yBraces.rotate(TAU/4)\n",
        "\n",
        "        lowerX = self.initial_lower_x\n",
        "        lowerY = self.func(lowerX)\n",
        "        upperX = self.initial_upper_x\n",
        "        upperY = self.func(upperX)\n",
        "\n",
        "        leftBrace.move_to(self.coords_to_point(lowerX, self.base_line_y)) #, aligned_edge = RIGHT)\n",
        "        leftBraceLabel = DecimalNumber(lowerX)\n",
        "        leftBraceLabel.next_to(leftBrace, DOWN + LEFT, buff = SMALL_BUFF)\n",
        "        leftBraceLabelAnimation = ContinualChangingDecimal(leftBraceLabel, \n",
        "            lambda alpha : self.point_to_coords(leftBrace.get_center())[0],\n",
        "            tracked_mobject = leftBrace)\n",
        "        \n",
        "        rightBrace.move_to(self.coords_to_point(upperX, self.base_line_y)) #, aligned_edge = LEFT)\n",
        "        rightBraceLabel = DecimalNumber(upperX)\n",
        "        rightBraceLabel.next_to(rightBrace, DOWN + RIGHT, buff = SMALL_BUFF)\n",
        "        rightBraceLabelAnimation = ContinualChangingDecimal(rightBraceLabel, \n",
        "            lambda alpha : self.point_to_coords(rightBrace.get_center())[0],\n",
        "            tracked_mobject = rightBrace)\n",
        "\n",
        "        downBrace.move_to(self.coords_to_point(0, lowerY)) #, aligned_edge = UP)\n",
        "        downBraceLabel = DecimalNumber(lowerY)\n",
        "        downBraceLabel.next_to(downBrace, LEFT + DOWN, buff = SMALL_BUFF)\n",
        "        downBraceLabelAnimation = ContinualChangingDecimal(downBraceLabel, \n",
        "            lambda alpha : self.point_to_coords(downBrace.get_center())[1] + y_bias,\n",
        "            tracked_mobject = downBrace)\n",
        "        \n",
        "        upBrace.move_to(self.coords_to_point(0, upperY)) #, aligned_edge = DOWN)\n",
        "        upBraceLabel = DecimalNumber(upperY)\n",
        "        upBraceLabel.next_to(upBrace, LEFT + UP, buff = SMALL_BUFF)\n",
        "        upBraceLabelAnimation = ContinualChangingDecimal(upBraceLabel, \n",
        "            lambda alpha : self.point_to_coords(upBrace.get_center())[1] + y_bias,\n",
        "            tracked_mobject = upBrace)\n",
        "\n",
        "        lowerDotPoint = self.input_to_graph_point(lowerX, self.graph)\n",
        "        lowerDotXPoint = self.coords_to_point(lowerX, self.base_line_y)\n",
        "        lowerDotYPoint = self.coords_to_point(0, self.func(lowerX))\n",
        "        lowerDot = Dot(lowerDotPoint + OUT, color = lower_color)\n",
        "        upperDotPoint = self.input_to_graph_point(upperX, self.graph)\n",
        "        upperDot = Dot(upperDotPoint + OUT, color = upper_color)\n",
        "        upperDotXPoint = self.coords_to_point(upperX, self.base_line_y)\n",
        "        upperDotYPoint = self.coords_to_point(0, self.func(upperX))\n",
        "\n",
        "        lowerXLine = Line(lowerDotXPoint, lowerDotPoint, color = lower_color)\n",
        "        upperXLine = Line(upperDotXPoint, upperDotPoint, color = upper_color)\n",
        "        lowerYLine = Line(lowerDotPoint, lowerDotYPoint, color = lower_color)\n",
        "        upperYLine = Line(upperDotPoint, upperDotYPoint, color = upper_color)\n",
        "\n",
        "        x_guess_line = Line(lowerDotXPoint, upperDotXPoint, color = WHITE, stroke_width = 10)\n",
        "        \n",
        "\n",
        "        lowerGroup = Group(\n",
        "            lowerDot, \n",
        "            leftBrace, downBrace,\n",
        "            lowerXLine, lowerYLine,\n",
        "            x_guess_line\n",
        "        )\n",
        "        \n",
        "        upperGroup = Group(\n",
        "            upperDot, \n",
        "            rightBrace, upBrace,\n",
        "            upperXLine, upperYLine,\n",
        "            x_guess_line\n",
        "        )\n",
        "\n",
        "        initialLowerXDot = Dot(lowerDotXPoint + OUT, color = lower_color)\n",
        "        initialUpperXDot = Dot(upperDotXPoint + OUT, color = upper_color)\n",
        "        initialLowerYDot = Dot(lowerDotYPoint + OUT, color = lower_color)\n",
        "        initialUpperYDot = Dot(upperDotYPoint + OUT, color = upper_color)\n",
        "\n",
        "        # All the initial adds and ShowCreations are here now:\n",
        "        self.play(FadeIn(initialLowerXDot), FadeIn(leftBrace), FadeIn(leftBraceLabel))\n",
        "        self.add_foreground_mobjects(initialLowerXDot, leftBrace)\n",
        "        self.add(leftBraceLabelAnimation)\n",
        "        self.play(ShowCreation(lowerXLine))\n",
        "        self.add_foreground_mobject(lowerDot)\n",
        "        self.play(ShowCreation(lowerYLine))\n",
        "        self.play(FadeIn(initialLowerYDot), FadeIn(downBrace), FadeIn(downBraceLabel))\n",
        "        self.add_foreground_mobjects(initialLowerYDot, downBrace)\n",
        "        self.add(downBraceLabelAnimation)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(initialUpperXDot), FadeIn(rightBrace), FadeIn(rightBraceLabel))\n",
        "        self.add_foreground_mobjects(initialUpperXDot, rightBrace)\n",
        "        self.add(rightBraceLabelAnimation)\n",
        "        self.play(ShowCreation(upperXLine))\n",
        "        self.add_foreground_mobject(upperDot)\n",
        "        self.play(ShowCreation(upperYLine))\n",
        "        self.play(FadeIn(initialUpperYDot), FadeIn(upBrace), FadeIn(upBraceLabel))\n",
        "        self.add_foreground_mobjects(initialUpperYDot, upBrace)\n",
        "        self.add(upBraceLabelAnimation)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(x_guess_line))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for i in range(self.num_iterations):\n",
        "            if i == self.iteration_at_which_to_start_zoom:\n",
        "                self.activate_zooming()\n",
        "                self.little_rectangle.move_to(\n",
        "                    self.coords_to_point(self.targetX, self.targetY))\n",
        "                inverseZoomFactor = 1/float(self.zoom_factor)\n",
        "                self.play(\n",
        "                    lowerDot.scale, inverseZoomFactor,\n",
        "                    upperDot.scale, inverseZoomFactor)\n",
        "\n",
        "\n",
        "            def makeUpdater(xAtStart, fixed_guess_x):\n",
        "                def updater(group, alpha):\n",
        "                    dot, xBrace, yBrace, xLine, yLine, guess_line = group\n",
        "                    newX = interpolate(xAtStart, midX, alpha)\n",
        "                    newY = self.func(newX)\n",
        "                    graphPoint = self.input_to_graph_point(newX, \n",
        "                            self.graph)\n",
        "                    dot.move_to(graphPoint)\n",
        "                    xAxisPoint = self.coords_to_point(newX, self.base_line_y)\n",
        "                    xBrace.move_to(xAxisPoint)\n",
        "                    yAxisPoint = self.coords_to_point(0, newY)\n",
        "                    yBrace.move_to(yAxisPoint)\n",
        "                    xLine.put_start_and_end_on(xAxisPoint, graphPoint)\n",
        "                    yLine.put_start_and_end_on(yAxisPoint, graphPoint)\n",
        "                    fixed_guess_point = self.coords_to_point(fixed_guess_x, self.base_line_y)\n",
        "                    guess_line.put_start_and_end_on(xAxisPoint, fixed_guess_point)\n",
        "                    return group\n",
        "                return updater\n",
        "\n",
        "            midX = (lowerX + upperX)/float(2)\n",
        "            midY = self.func(midX)\n",
        "\n",
        "            # If we run with an interval whose endpoints start off with same sign,\n",
        "            # then nothing after this branching can be trusted to do anything reasonable\n",
        "            # in terms of picking branches or assigning colors\n",
        "            in_negative_branch = midY < self.targetY\n",
        "            sign_color = negative_color if in_negative_branch else positive_color\n",
        "\n",
        "            midCoords = self.coords_to_point(midX, midY)\n",
        "            midColor = neutral_color\n",
        "            # Hm... even the z buffer isn't helping keep this above x_guess_line\n",
        "\n",
        "            midXBrace = startBrace.copy() # Had start and endBrace been asymmetric, we'd do something different here\n",
        "            midXBrace.set_color(midColor)\n",
        "            midXBrace.move_to(self.coords_to_point(midX, self.base_line_y) + OUT)\n",
        "\n",
        "            # We only actually add this much later\n",
        "            midXPoint = Dot(self.coords_to_point(midX, self.base_line_y) + OUT, color = sign_color)\n",
        "\n",
        "            x_guess_label_caption = OldTexText(\"New guess: x = \", fill_color = midColor)\n",
        "            x_guess_label_num = DecimalNumber(midX, fill_color = midColor)\n",
        "            x_guess_label_num.move_to(0.9 * FRAME_Y_RADIUS * DOWN)\n",
        "            x_guess_label_caption.next_to(x_guess_label_num, LEFT)\n",
        "            x_guess_label = Group(x_guess_label_caption, x_guess_label_num)\n",
        "            y_guess_label_caption = OldTexText(\", y = \", fill_color = midColor)\n",
        "            y_guess_label_num = DecimalNumber(midY, fill_color = sign_color)\n",
        "            y_guess_label_caption.next_to(x_guess_label_num, RIGHT)\n",
        "            y_guess_label_num.next_to(y_guess_label_caption, RIGHT)\n",
        "            y_guess_label = Group(y_guess_label_caption, y_guess_label_num)\n",
        "            guess_labels = Group(x_guess_label, y_guess_label)\n",
        "\n",
        "            self.play(\n",
        "                ReplacementTransform(leftBrace.copy(), midXBrace),\n",
        "                ReplacementTransform(rightBrace.copy(), midXBrace),\n",
        "                FadeIn(x_guess_label))\n",
        "\n",
        "            self.add_foreground_mobject(midXBrace)\n",
        "\n",
        "            midXLine = DashedLine(\n",
        "                self.coords_to_point(midX, self.base_line_y), \n",
        "                midCoords, \n",
        "                color = midColor\n",
        "            )\n",
        "            self.play(ShowCreation(midXLine))\n",
        "            midDot = Dot(midCoords, color = sign_color)\n",
        "            if(self.iteration_at_which_to_start_zoom != None and \n",
        "                i >= self.iteration_at_which_to_start_zoom):\n",
        "                midDot.scale(inverseZoomFactor)\n",
        "            self.add(midDot)\n",
        "            midYLine = DashedLine(midCoords, self.coords_to_point(0, midY), color = sign_color)\n",
        "            self.play(\n",
        "                ShowCreation(midYLine), \n",
        "                FadeIn(y_guess_label),\n",
        "                ApplyMethod(midXBrace.set_color, sign_color),\n",
        "                ApplyMethod(midXLine.set_color, sign_color),\n",
        "                run_time = 0.25\n",
        "            )\n",
        "            midYPoint = Dot(self.coords_to_point(0, midY), color = sign_color)\n",
        "            self.add(midXPoint, midYPoint)\n",
        "\n",
        "            if in_negative_branch:\n",
        "                self.play(\n",
        "                    UpdateFromAlphaFunc(lowerGroup, \n",
        "                        makeUpdater(lowerX, \n",
        "                            fixed_guess_x = upperX\n",
        "                        )\n",
        "                    ),\n",
        "                    FadeOut(guess_labels),\n",
        "                )\n",
        "                lowerX = midX\n",
        "                lowerY = midY\n",
        "\n",
        "            else:\n",
        "                self.play(\n",
        "                    UpdateFromAlphaFunc(upperGroup, \n",
        "                        makeUpdater(upperX, \n",
        "                            fixed_guess_x = lowerX\n",
        "                        )\n",
        "                    ),\n",
        "                    FadeOut(guess_labels),\n",
        "                )\n",
        "                upperX = midX\n",
        "                upperY = midY\n",
        "            #mid_group = Group(midXLine, midDot, midYLine) Removing groups doesn't flatten as expected?\n",
        "            self.remove(midXLine, midDot, midYLine, midXBrace)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "    def construct(self):\n",
        "        self.drawGraph()\n",
        "        self.solveEquation()\n",
        "\n",
        "# Returns the value with the same fractional component as x, closest to m\n",
        "def resit_near(x, m):\n",
        "    frac_diff = (x - m) % 1\n",
        "    if frac_diff > 0.5:\n",
        "        frac_diff -= 1\n",
        "    return m + frac_diff\n",
        "\n",
        "# TODO?: Perhaps use modulus of (uniform) continuity instead of num_checkpoints, calculating \n",
        "# latter as needed from former?\n",
        "#\n",
        "# \"cheap\" argument only used for diagnostic testing right now\n",
        "def make_alpha_winder(func, start, end, num_checkpoints, cheap = False):\n",
        "    check_points = [None for i in range(num_checkpoints)]\n",
        "    check_points[0] = func(start)\n",
        "    step_size = fdiv(end - start, num_checkpoints)\n",
        "    for i in range(num_checkpoints - 1):\n",
        "        check_points[i + 1] = \\\n",
        "        resit_near(\n",
        "            func(start + (i + 1) * step_size),\n",
        "            check_points[i])\n",
        "    def return_func(alpha):\n",
        "        if cheap:\n",
        "            return alpha # A test to see if this func is responsible for slowdown\n",
        "\n",
        "        index = np.clip(0, num_checkpoints - 1, int(alpha * num_checkpoints))\n",
        "        x = interpolate(start, end, alpha)\n",
        "        if cheap:\n",
        "            return check_points[index] # A more principled test that at least returns a reasonable answer\n",
        "        else:\n",
        "            return resit_near(func(x), check_points[index])\n",
        "    return return_func\n",
        "\n",
        "# The various inconsistent choices of what datatype to use where are a bit of a mess,\n",
        "# but I'm more keen to rush this video out now than to sort this out.\n",
        "\n",
        "def complex_to_pair(c):\n",
        "    return np.array((c.real, c.imag))\n",
        "\n",
        "def plane_func_from_complex_func(f):\n",
        "    return lambda x_y4 : complex_to_pair(f(complex(x_y4[0],x_y4[1])))\n",
        "\n",
        "def point3d_func_from_plane_func(f):\n",
        "    def g(xxx_todo_changeme):\n",
        "        (x, y, z) = xxx_todo_changeme\n",
        "        f_val = f((x, y))\n",
        "        return np.array((f_val[0], f_val[1], 0))\n",
        "    return g\n",
        "\n",
        "def point3d_func_from_complex_func(f):\n",
        "    return point3d_func_from_plane_func(plane_func_from_complex_func(f))\n",
        "\n",
        "def plane_zeta(xxx_todo_changeme8):\n",
        "    (x, y) = xxx_todo_changeme8\n",
        "    CLAMP_SIZE = 1000\n",
        "    z = complex(x, y)\n",
        "    try:\n",
        "        answer = mpmath.zeta(z)\n",
        "    except ValueError:\n",
        "        return (CLAMP_SIZE, 0)\n",
        "    if abs(answer) > CLAMP_SIZE:\n",
        "        answer = answer/abs(answer) * CLAMP_SIZE\n",
        "    return (float(answer.real), float(answer.imag))\n",
        "\n",
        "def rescaled_plane_zeta(xxx_todo_changeme9):\n",
        "    (x, y) = xxx_todo_changeme9\n",
        "    return plane_zeta((x/FRAME_X_RADIUS, 8*y))\n",
        "\n",
        "# Returns a function from 2-ples to 2-ples\n",
        "# This function is specified by a list of (x, y, z) tuples, \n",
        "# and has winding number z (or total of all specified z) around each (x, y)\n",
        "#\n",
        "# Can also pass in (x, y) tuples, interpreted as (x, y, 1)\n",
        "def plane_func_by_wind_spec(*specs):\n",
        "    def embiggen(p):\n",
        "        if len(p) == 3:\n",
        "            return p\n",
        "        elif len(p) == 2:\n",
        "            return (p[0], p[1], 1)\n",
        "        else:\n",
        "            print(\"Error in plane_func_by_wind_spec embiggen!\")\n",
        "    specs = list(map(embiggen, specs))\n",
        "\n",
        "    pos_specs = [x_y_z for x_y_z in specs if x_y_z[2] > 0]\n",
        "    neg_specs = [x_y_z1 for x_y_z1 in specs if x_y_z1[2] < 0]\n",
        "\n",
        "    neg_specs_made_pos = [(x_y_z2[0], x_y_z2[1], -x_y_z2[2]) for x_y_z2 in neg_specs]\n",
        "\n",
        "    def poly(c, root_specs):\n",
        "        return np.prod([(c - complex(x, y))**z for (x, y, z) in root_specs])\n",
        "\n",
        "    def complex_func(c):\n",
        "        return poly(c, pos_specs) * np.conjugate(poly(c, neg_specs_made_pos))\n",
        "    \n",
        "    return plane_func_from_complex_func(complex_func)\n",
        "\n",
        "def scale_func(func, scale_factor):\n",
        "    return lambda x : func(x) * scale_factor\n",
        "\n",
        "# Used in Initial2dFunc scenes, VectorField scene, and ExamplePlaneFunc\n",
        "example_plane_func_spec = [(-3, -1.3, 2), (0.1, 0.2, 1), (2.8, -2, -1)]\n",
        "example_plane_func = plane_func_by_wind_spec(*example_plane_func_spec)\n",
        "\n",
        "empty_animation = EmptyAnimation()\n",
        "\n",
        "class WalkerAnimation(Animation):\n",
        "    CONFIG = {\n",
        "        \"walk_func\" : None, # Must be initialized to use\n",
        "        \"remover\" : True,\n",
        "        \"rate_func\" : None,\n",
        "        \"coords_to_point\" : None\n",
        "    }\n",
        "\n",
        "    def __init__(self, walk_func, val_func, coords_to_point, \n",
        "        show_arrows = True, scale_arrows = False,\n",
        "        **kwargs):\n",
        "        self.walk_func = walk_func\n",
        "        self.val_func = val_func\n",
        "        self.coords_to_point = coords_to_point\n",
        "        self.compound_walker = VGroup()\n",
        "        self.show_arrows = show_arrows\n",
        "        self.scale_arrows = scale_arrows\n",
        "\n",
        "        if \"walker_stroke_color\" in kwargs:\n",
        "            walker_stroke_color = kwargs[\"walker_stroke_color\"]\n",
        "        else:\n",
        "            walker_stroke_color = BLACK\n",
        "\n",
        "        base_walker = Dot().scale(5 * 0.35).set_stroke(walker_stroke_color, 2) # PiCreature().scale(0.8 * 0.35)\n",
        "        self.compound_walker.walker = base_walker\n",
        "        if show_arrows:\n",
        "            self.compound_walker.arrow = Arrow(ORIGIN, 0.5 * RIGHT, buff = 0)\n",
        "            self.compound_walker.arrow.match_style(self.compound_walker.walker)\n",
        "        self.compound_walker.digest_mobject_attrs()\n",
        "        Animation.__init__(self, self.compound_walker, **kwargs)\n",
        "\n",
        "    # Perhaps abstract this out into an \"Animation updating from original object\" class\n",
        "    def interpolate_submobject(self, submobject, starting_submobject, alpha):\n",
        "        submobject.set_points(starting_submobject.get_points())\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        Animation.interpolate_mobject(self, alpha)\n",
        "        cur_x, cur_y = cur_coords = self.walk_func(alpha)\n",
        "        cur_point = self.coords_to_point(cur_x, cur_y)\n",
        "        self.mobject.shift(cur_point - self.mobject.walker.get_center())\n",
        "        val = self.val_func(cur_coords)\n",
        "        rev = point_to_rev(val)\n",
        "        self.mobject.walker.set_fill(rev_to_color(rev))\n",
        "        if self.show_arrows:\n",
        "            self.mobject.arrow.set_fill(rev_to_color(rev))\n",
        "            self.mobject.arrow.rotate(\n",
        "                rev * TAU, \n",
        "                about_point = self.mobject.arrow.get_start()\n",
        "            )\n",
        "\n",
        "            if self.scale_arrows:\n",
        "                size = point_to_rescaled_size(val)\n",
        "                self.mobject.arrow.scale(\n",
        "                    size * 0.3, # Hack constant; we barely use this feature right now\n",
        "                    about_point = self.mobject.arrow.get_start()\n",
        "                )\n",
        "\n",
        "def walker_animation_with_display(\n",
        "    walk_func, \n",
        "    val_func, \n",
        "    coords_to_point, \n",
        "    number_update_func = None,\n",
        "    show_arrows = True,\n",
        "    scale_arrows = False,\n",
        "    num_decimal_places = 1,\n",
        "    include_background_rectangle = True,\n",
        "    **kwargs\n",
        "    ):\n",
        "    \n",
        "    walker_anim = WalkerAnimation(\n",
        "        walk_func = walk_func, \n",
        "        val_func = val_func, \n",
        "        coords_to_point = coords_to_point,\n",
        "        show_arrows = show_arrows,\n",
        "        scale_arrows = scale_arrows,\n",
        "        **kwargs)\n",
        "    walker = walker_anim.compound_walker.walker\n",
        "\n",
        "    if number_update_func != None:\n",
        "        display = DecimalNumber(0, \n",
        "            num_decimal_places = num_decimal_places, \n",
        "            fill_color = WHITE if include_background_rectangle else BLACK,\n",
        "            include_background_rectangle = include_background_rectangle)\n",
        "        if include_background_rectangle:\n",
        "            display.background_rectangle.fill_opacity = 0.5\n",
        "            display.background_rectangle.fill_color = GREY\n",
        "            display.background_rectangle.scale(1.2)\n",
        "        displaycement = 0.5 * DOWN # How about that pun, eh?\n",
        "        # display.move_to(walker.get_center() + displaycement)\n",
        "        display.next_to(walker, DOWN+RIGHT, SMALL_BUFF)\n",
        "        display_anim = ChangingDecimal(display, \n",
        "            number_update_func, \n",
        "            tracked_mobject = walker_anim.compound_walker.walker,\n",
        "            **kwargs)\n",
        "        anim_group = AnimationGroup(walker_anim, display_anim, rate_func=linear)\n",
        "        return anim_group\n",
        "    else:\n",
        "        return walker_anim\n",
        "\n",
        "def LinearWalker(\n",
        "    start_coords, \n",
        "    end_coords, \n",
        "    coords_to_point, \n",
        "    val_func, \n",
        "    number_update_func = None, \n",
        "    show_arrows = True,\n",
        "    scale_arrows = False,\n",
        "    include_background_rectangle = True,\n",
        "    **kwargs\n",
        "    ):\n",
        "    walk_func = lambda alpha : interpolate(start_coords, end_coords, alpha)\n",
        "    return walker_animation_with_display(\n",
        "        walk_func = walk_func, \n",
        "        coords_to_point = coords_to_point, \n",
        "        val_func = val_func,\n",
        "        number_update_func = number_update_func,\n",
        "        show_arrows = show_arrows,\n",
        "        scale_arrows = scale_arrows,\n",
        "        include_background_rectangle = include_background_rectangle,\n",
        "        **kwargs)\n",
        "\n",
        "class ColorMappedByFuncScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"func\" : lambda p : p,\n",
        "        \"num_plane\" : NumberPlane(),\n",
        "        \"show_num_plane\" : True,\n",
        "\n",
        "        \"show_output\" : False,\n",
        "\n",
        "        \"hide_background\" : False #Background used for color mapped objects, not as background\n",
        "    }\n",
        "\n",
        "    def short_path_to_long_path(self, filename_with_ext):\n",
        "        return self.get_image_file_path(filename_with_ext)\n",
        "\n",
        "    def setup(self):\n",
        "        # The composition of input_to_pos and pos_to_color \n",
        "        # is to be equal to func (which turns inputs into colors)\n",
        "        # However, depending on whether we are showing input or output (via a MappingCamera),\n",
        "        # we color the background using either func or the identity map\n",
        "        if self.show_output:\n",
        "            self.input_to_pos_func = self.func\n",
        "            self.pos_to_color_func = lambda p : p\n",
        "        else:\n",
        "            self.input_to_pos_func = lambda p : p\n",
        "            self.pos_to_color_func = self.func\n",
        "\n",
        "        self.pixel_pos_to_color_func = lambda x_y3 : self.pos_to_color_func(\n",
        "            self.num_plane.point_to_coords_cheap(np.array([x_y3[0], x_y3[1], 0]))\n",
        "        )\n",
        "\n",
        "        jitter_val = 0.1\n",
        "        line_coords = np.linspace(-10, 10) + jitter_val\n",
        "        func_hash_points = it.product(line_coords, line_coords)\n",
        "\n",
        "        def mini_hasher(p):\n",
        "            rgba = point_to_rgba(self.pixel_pos_to_color_func(p))\n",
        "            if rgba[3] != 1.0:\n",
        "                print(\"Warning! point_to_rgba assigns fractional alpha\", rgba[3])\n",
        "            return tuple(rgba)\n",
        "\n",
        "        to_hash = tuple(mini_hasher(p) for p in func_hash_points)\n",
        "        func_hash = hash(to_hash)\n",
        "        # We hash just based on output image\n",
        "        # Thus, multiple scenes with same output image can re-use it\n",
        "        # without recomputation\n",
        "        full_hash = hash((func_hash, self.camera.get_pixel_width()))\n",
        "        self.background_image_file = self.short_path_to_long_path(\n",
        "            \"color_mapped_bg_hash_\" + str(full_hash) + \".png\"\n",
        "        )\n",
        "        self.in_background_pass = not os.path.exists(self.background_image_file)\n",
        "\n",
        "        print(\"Background file: \" + self.background_image_file)\n",
        "        if self.in_background_pass:\n",
        "            print(\"The background file does not exist yet; this will be a background creation + video pass\")\n",
        "        else:\n",
        "            print(\"The background file already exists; this will only be a video pass\")\n",
        "\n",
        "    def construct(self):\n",
        "        if self.in_background_pass:\n",
        "            self.camera.set_background_from_func(\n",
        "                lambda x_y: point_to_rgba(\n",
        "                    self.pixel_pos_to_color_func(\n",
        "                        (x_y[0], x_y[1])\n",
        "                    )\n",
        "                )\n",
        "            )\n",
        "            self.save_image(self.background_image_file, mode=\"RGBA\")\n",
        "\n",
        "        if self.hide_background:\n",
        "            # Clearing background\n",
        "            self.camera.background_image = None\n",
        "        else:\n",
        "            # Even if we just computed the background, we switch to the file now\n",
        "            self.camera.background_image = self.background_image_file\n",
        "        self.camera.init_background()\n",
        "\n",
        "        if self.show_num_plane:\n",
        "            self.num_plane.fade()\n",
        "            self.add(self.num_plane)\n",
        "\n",
        "class PureColorMap(ColorMappedByFuncScene):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedByFuncScene.construct(self)\n",
        "        self.wait()\n",
        "\n",
        "# This sets self.background_image_file, but does not display it as the background\n",
        "class ColorMappedObjectsScene(ColorMappedByFuncScene):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False,\n",
        "        \"hide_background\" : True,\n",
        "    }\n",
        "\n",
        "class PiWalker(ColorMappedByFuncScene):\n",
        "    CONFIG = {\n",
        "        \"walk_coords\" : [],\n",
        "        \"step_run_time\" : 1,\n",
        "        \"scale_arrows\" : False,\n",
        "        \"display_wind\" : True,\n",
        "        \"wind_reset_indices\" : [],\n",
        "        \"display_size\" : False,\n",
        "        \"display_odometer\" : False,\n",
        "        \"color_foreground_not_background\" : False,\n",
        "        \"show_num_plane\" : False,\n",
        "        \"draw_lines\" : True,\n",
        "        \"num_checkpoints\" : 10,\n",
        "        \"num_decimal_places\" : 1,\n",
        "        \"include_background_rectangle\" : False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedByFuncScene.construct(self)\n",
        "\n",
        "        if self.color_foreground_not_background or self.display_odometer:\n",
        "            # Clear background\n",
        "            self.camera.background_image = None\n",
        "            self.camera.init_background()\n",
        "\n",
        "        num_plane = self.num_plane\n",
        "\n",
        "        walk_coords = self.walk_coords\n",
        "        points = [num_plane.coords_to_point(x, y) for x, y in walk_coords]\n",
        "        polygon = Polygon(*points, color = WHITE)\n",
        "        if self.color_foreground_not_background:\n",
        "            polygon.stroke_width = border_stroke_width\n",
        "            polygon.color_using_background_image(self.background_image_file)\n",
        "        total_run_time = len(points) * self.step_run_time\n",
        "        polygon_anim = ShowCreation(polygon, run_time = total_run_time, rate_func=linear)\n",
        "        walker_anim = empty_animation\n",
        "\n",
        "        start_wind = 0\n",
        "        for i in range(len(walk_coords)):\n",
        "            start_coords = walk_coords[i]\n",
        "            end_coords = walk_coords[(i + 1) % len(walk_coords)]\n",
        "            \n",
        "            # We need to do this roundabout default argument thing to get the closure we want,\n",
        "            # so the next iteration changing start_coords, end_coords doesn't change this closure\n",
        "            val_alpha_func = lambda a, start_coords = start_coords, end_coords = end_coords : self.func(interpolate(start_coords, end_coords, a))\n",
        "\n",
        "            if self.display_wind:\n",
        "                clockwise_val_func = lambda p : -point_to_rev(self.func(p))\n",
        "                alpha_winder = make_alpha_winder(clockwise_val_func, start_coords, end_coords, self.num_checkpoints)\n",
        "                number_update_func = lambda alpha, alpha_winder = alpha_winder, start_wind = start_wind: alpha_winder(alpha) - alpha_winder(0) + start_wind\n",
        "                start_wind = 0 if i + 1 in self.wind_reset_indices else number_update_func(1)\n",
        "            elif self.display_size:\n",
        "                # We need to do this roundabout default argument thing to get the closure we want,\n",
        "                # so the next iteration changing val_alpha_func doesn't change this closure\n",
        "                number_update_func = lambda a, val_alpha_func = val_alpha_func : point_to_rescaled_size(val_alpha_func(a)) # We only use this for diagnostics\n",
        "            else:\n",
        "                number_update_func = None\n",
        "\n",
        "            new_anim = LinearWalker(\n",
        "                start_coords = start_coords, \n",
        "                end_coords = end_coords,\n",
        "                coords_to_point = num_plane.coords_to_point,\n",
        "                val_func = self.func,\n",
        "                remover = (i < len(walk_coords) - 1),\n",
        "                show_arrows = not self.show_output,\n",
        "                scale_arrows = self.scale_arrows,\n",
        "                number_update_func = number_update_func,\n",
        "                run_time = self.step_run_time,\n",
        "                walker_stroke_color = WALKER_LIGHT_COLOR if self.color_foreground_not_background else BLACK,\n",
        "                num_decimal_places = self.num_decimal_places,\n",
        "                include_background_rectangle = self.include_background_rectangle,\n",
        "            )\n",
        "\n",
        "            if self.display_odometer:\n",
        "                # Discard above animation and show an odometer instead\n",
        "\n",
        "                # We need to do this roundabout default argument thing to get the closure we want,\n",
        "                # so the next iteration changing val_alpha_func doesn't change this closure\n",
        "                rev_func = lambda a, val_alpha_func = val_alpha_func : point_to_rev(val_alpha_func(a))\n",
        "                base_arrow = Arrow(ORIGIN, RIGHT, buff = 0)\n",
        "                new_anim = FuncRotater(base_arrow, \n",
        "                    rev_func = rev_func,\n",
        "                    run_time = self.step_run_time,\n",
        "                    rate_func=linear,\n",
        "                    remover = i < len(walk_coords) - 1,\n",
        "                )\n",
        "\n",
        "            walker_anim = Succession(walker_anim, new_anim)\n",
        "\n",
        "        # TODO: Allow smooth paths instead of breaking them up into lines, and \n",
        "        # use point_from_proportion to get points along the way\n",
        "\n",
        "        if self.display_odometer:\n",
        "            color_wheel = Circle(radius = ODOMETER_RADIUS)\n",
        "            color_wheel.stroke_width = ODOMETER_STROKE_WIDTH\n",
        "            color_wheel.color_using_background_image(self.short_path_to_long_path(\"pure_color_map.png\")) # Manually inserted here; this is unclean\n",
        "            self.add(color_wheel)\n",
        "            self.play(walker_anim)\n",
        "        else:\n",
        "            if self.draw_lines:\n",
        "                self.play(polygon_anim, walker_anim)\n",
        "            else:\n",
        "                # (Note: Turns out, play is unhappy playing empty_animation, as had been\n",
        "                # previous approach to this toggle; should fix that)\n",
        "                self.play(walker_anim)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class PiWalkerRect(PiWalker):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : -1,\n",
        "        \"start_y\" : 1,\n",
        "        \"walk_width\" : 2,\n",
        "        \"walk_height\" : 2,\n",
        "        \"func\" : plane_func_from_complex_func(lambda c: c**2),\n",
        "        \"double_up\" : False,\n",
        "\n",
        "        # New default for the scenes using this:\n",
        "        \"display_wind\" : True\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        TL = np.array((self.start_x, self.start_y))\n",
        "        TR = TL + (self.walk_width, 0)\n",
        "        BR = TR + (0, -self.walk_height)\n",
        "        BL = BR + (-self.walk_width, 0)\n",
        "        self.walk_coords = [TL, TR, BR, BL]\n",
        "        if self.double_up:\n",
        "            self.walk_coords = self.walk_coords + self.walk_coords\n",
        "        PiWalker.setup(self)\n",
        "\n",
        "class PiWalkerCircle(PiWalker):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 1,\n",
        "        \"num_steps\" : 100,\n",
        "        \"step_run_time\" : 0.01\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        r = self.radius\n",
        "        N = self.num_steps\n",
        "        self.walk_coords = [r * np.array((np.cos(i * TAU/N), np.sin(i * TAU/N))) for i in range(N)]\n",
        "        PiWalker.setup(self)\n",
        "\n",
        "def split_interval(xxx_todo_changeme10):\n",
        "    (a, b) = xxx_todo_changeme10\n",
        "    mid = (a + b)/2.0\n",
        "    return ((a, mid), (mid, b))\n",
        "\n",
        "# I am surely reinventing some wheel here, but what's done is done...\n",
        "class RectangleData():\n",
        "    def __init__(self, x_interval, y_interval):\n",
        "        self.rect = (x_interval, y_interval)\n",
        "\n",
        "    def get_top_left(self):\n",
        "        return np.array((self.rect[0][0], self.rect[1][1]))\n",
        "\n",
        "    def get_top_right(self):\n",
        "        return np.array((self.rect[0][1], self.rect[1][1]))\n",
        "\n",
        "    def get_bottom_right(self):\n",
        "        return np.array((self.rect[0][1], self.rect[1][0]))\n",
        "\n",
        "    def get_bottom_left(self):\n",
        "        return np.array((self.rect[0][0], self.rect[1][0]))\n",
        "\n",
        "    def get_top(self):\n",
        "        return (self.get_top_left(), self.get_top_right())\n",
        "\n",
        "    def get_right(self):\n",
        "        return (self.get_top_right(), self.get_bottom_right())\n",
        "\n",
        "    def get_bottom(self):\n",
        "        return (self.get_bottom_right(), self.get_bottom_left())\n",
        "\n",
        "    def get_left(self):\n",
        "        return (self.get_bottom_left(), self.get_top_left())\n",
        "\n",
        "    def get_center(self):\n",
        "        return interpolate(self.get_top_left(), self.get_bottom_right(), 0.5)\n",
        "\n",
        "    def get_width(self):\n",
        "        return self.rect[0][1] - self.rect[0][0]\n",
        "\n",
        "    def get_height(self):\n",
        "        return self.rect[1][1] - self.rect[1][0]\n",
        "\n",
        "    def splits_on_dim(self, dim):\n",
        "        x_interval = self.rect[0]\n",
        "        y_interval = self.rect[1]\n",
        "\n",
        "        # TODO: Can refactor the following; will do later\n",
        "        if dim == 0:\n",
        "            return_data = [RectangleData(new_interval, y_interval) for new_interval in split_interval(x_interval)]\n",
        "        elif dim == 1:\n",
        "            return_data = [RectangleData(x_interval, new_interval) for new_interval in split_interval(y_interval)[::-1]]        \n",
        "        else: \n",
        "            print(\"RectangleData.splits_on_dim passed illegitimate dimension!\")\n",
        "\n",
        "        return tuple(return_data)\n",
        "\n",
        "    def split_line_on_dim(self, dim):\n",
        "        x_interval = self.rect[0]\n",
        "        y_interval = self.rect[1]\n",
        "\n",
        "        if dim == 0:\n",
        "            sides = (self.get_top(), self.get_bottom())\n",
        "        elif dim == 1:\n",
        "            sides = (self.get_left(), self.get_right())\n",
        "        else:\n",
        "            print(\"RectangleData.split_line_on_dim passed illegitimate dimension!\")\n",
        "\n",
        "        return tuple([mid(x, y) for (x, y) in sides])\n",
        "\n",
        "\n",
        "class EquationSolver2dNode(object):\n",
        "    def __init__(self, first_anim, children = []):\n",
        "        self.first_anim = first_anim\n",
        "        self.children = children\n",
        "\n",
        "    def depth(self):\n",
        "        if len(self.children) == 0:\n",
        "            return 0\n",
        "\n",
        "        return 1 + max([n.depth() for n in self.children])\n",
        "\n",
        "    def nodes_at_depth(self, n):\n",
        "        if n == 0:\n",
        "            return [self]\n",
        "\n",
        "        # Not the efficient way to flatten lists, because Python + is linear in list size,\n",
        "        # but we have at most two children, so no big deal here\n",
        "        return sum([c.nodes_at_depth(n - 1) for c in self.children], [])\n",
        "\n",
        "    # This is definitely NOT the efficient way to do BFS, but I'm just trying to write something\n",
        "    # quick without thinking that gets the job done on small instances for now\n",
        "    def hacky_bfs(self):\n",
        "        depth = self.depth()\n",
        "\n",
        "        # Not the efficient way to flatten lists, because Python + is linear in list size,\n",
        "        # but this IS hacky_bfs...\n",
        "        return sum([self.nodes_at_depth(i) for i in range(depth + 1)], [])\n",
        "\n",
        "    def display_in_series(self):\n",
        "        return Succession(self.first_anim, *[n.display_in_series() for n in self.children])\n",
        "\n",
        "    def display_in_parallel(self):\n",
        "        return Succession(self.first_anim, AnimationGroup(*[n.display_in_parallel() for n in self.children]))\n",
        "\n",
        "    def display_in_bfs(self):\n",
        "        bfs_nodes = self.hacky_bfs()\n",
        "        return Succession(*[n.first_anim for n in bfs_nodes])\n",
        "\n",
        "    def play_in_bfs(self, scene, border_anim):\n",
        "        bfs_nodes = self.hacky_bfs()\n",
        "        print(\"Number of nodes: \", len(bfs_nodes))\n",
        "\n",
        "        if len(bfs_nodes) < 1:\n",
        "            print(\"Less than 1 node! Aborting!\")\n",
        "            return\n",
        "\n",
        "        scene.play(bfs_nodes[0].first_anim, border_anim)\n",
        "        for node in bfs_nodes[1:]:\n",
        "            scene.play(node.first_anim)\n",
        "\n",
        "class EquationSolver2d(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\" : {\"use_z_coordinate_for_display_order\": True},\n",
        "        \"initial_lower_x\" : -5,\n",
        "        \"initial_upper_x\" : 5,\n",
        "        \"initial_lower_y\" : -3,\n",
        "        \"initial_upper_y\" : 3,\n",
        "        \"num_iterations\" : 0,\n",
        "        \"num_checkpoints\" : 10,\n",
        "\n",
        "        # Should really merge this into one enum-style variable\n",
        "        \"display_in_parallel\" : False,\n",
        "        \"display_in_bfs\" : False,\n",
        "\n",
        "        \"use_fancy_lines\" : True,\n",
        "        \"line_color\" : WHITE, # Only used for non-fancy lines\n",
        "        \n",
        "\n",
        "        # TODO: Consider adding a \"find_all_roots\" flag, which could be turned off \n",
        "        # to only explore one of the two candidate subrectangles when both are viable\n",
        "\n",
        "        # Walker settings\n",
        "        \"show_arrows\" : True,\n",
        "        \"scale_arrows\" : False,\n",
        "\n",
        "        # Special case settings\n",
        "        # These are used to hack UhOhScene, where we display different colors than \n",
        "        # are actually, secretly, guiding the evolution of the EquationSolver2d\n",
        "        #\n",
        "        # replacement_background_image_file has to be manually configured\n",
        "        \"show_winding_numbers\" : True,\n",
        "\n",
        "        # Used for UhOhScene; \n",
        "        \"manual_wind_override\" : None,\n",
        "\n",
        "        \"show_cursor\" : True,\n",
        "\n",
        "        \"linger_parameter\" : 0.5,\n",
        "\n",
        "        \"use_separate_plays\" : False,\n",
        "\n",
        "        \"use_cheap_winding_numbers\" : False, # To use this, make num_checkpoints large\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        if self.num_iterations == 0:\n",
        "            print(\"You forgot to set num_iterations (maybe you meant to subclass something other than EquationSolver2d directly?)\")\n",
        "            return\n",
        "\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "        num_plane = self.num_plane\n",
        "\n",
        "        clockwise_val_func = lambda p : -point_to_rev(self.func(p))\n",
        "\n",
        "        base_line = Line(UP, RIGHT, stroke_width = border_stroke_width, color = self.line_color)\n",
        "\n",
        "        if self.use_fancy_lines:\n",
        "            base_line.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        def match_style_with_bg(obj1, obj2):\n",
        "            obj1.match_style(obj2)\n",
        "            bg = obj2.get_background_image_file()\n",
        "            if bg != None:\n",
        "                obj1.color_using_background_image(bg)\n",
        "\n",
        "        run_time_base = 1\n",
        "        run_time_with_lingering = run_time_base + self.linger_parameter\n",
        "        base_rate = lambda t : t\n",
        "        linger_rate = squish_rate_func(lambda t : t, 0, \n",
        "                        fdiv(run_time_base, run_time_with_lingering))\n",
        "\n",
        "        cursor_base = OldTexText(\"?\")\n",
        "        cursor_base.scale(2)\n",
        "\n",
        "        # Helper functions for manual_wind_override\n",
        "        def head(m):\n",
        "            if m == None:\n",
        "                return None\n",
        "            return m[0]\n",
        "\n",
        "        def child(m, i):\n",
        "            if m == None or m == 0:\n",
        "                return None\n",
        "            return m[i + 1]\n",
        "\n",
        "        def Animate2dSolver(cur_depth, rect, dim_to_split, \n",
        "            sides_to_draw = [0, 1, 2, 3], \n",
        "            manual_wind_override = None):\n",
        "            print(\"Solver at depth: \" + str(cur_depth))\n",
        "\n",
        "            if cur_depth >= self.num_iterations:\n",
        "                return EquationSolver2dNode(empty_animation)\n",
        "\n",
        "            def draw_line_return_wind(start, end, start_wind, should_linger = False, draw_line = True):\n",
        "                alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints, cheap = self.use_cheap_winding_numbers)\n",
        "                a0 = alpha_winder(0)\n",
        "                rebased_winder = lambda alpha: alpha_winder(alpha) - a0 + start_wind\n",
        "                colored_line = Line(num_plane.coords_to_point(*start) + IN, num_plane.coords_to_point(*end) + IN)\n",
        "                match_style_with_bg(colored_line, base_line)\n",
        "\n",
        "                walker_anim = LinearWalker(\n",
        "                    start_coords = start, \n",
        "                    end_coords = end,\n",
        "                    coords_to_point = num_plane.coords_to_point,\n",
        "                    val_func = self.func, # Note: This is the image func, and not logic_func\n",
        "                    number_update_func = rebased_winder if self.show_winding_numbers else None,\n",
        "                    remover = True,\n",
        "                    walker_stroke_color = WALKER_LIGHT_COLOR,\n",
        "\n",
        "                    show_arrows = self.show_arrows,\n",
        "                    scale_arrows = self.scale_arrows,\n",
        "                )\n",
        "                \n",
        "                if should_linger: # Do we need an \"and not self.display_in_parallel\" here?\n",
        "                    run_time = run_time_with_lingering\n",
        "                    rate_func = linger_rate\n",
        "                else:\n",
        "                    run_time = run_time_base\n",
        "                    rate_func = base_rate\n",
        "\n",
        "                opt_line_anim = ShowCreation(colored_line) if draw_line else empty_animation\n",
        "\n",
        "                line_draw_anim = AnimationGroup(\n",
        "                    opt_line_anim, \n",
        "                    walker_anim,\n",
        "                    run_time = run_time,\n",
        "                    rate_func = rate_func)\n",
        "                return (line_draw_anim, rebased_winder(1))\n",
        "\n",
        "            wind_so_far = 0\n",
        "            anim = empty_animation\n",
        "            sides = [\n",
        "                rect.get_top(), \n",
        "                rect.get_right(), \n",
        "                rect.get_bottom(), \n",
        "                rect.get_left()\n",
        "            ]\n",
        "            for (i, (start, end)) in enumerate(sides):\n",
        "                (next_anim, wind_so_far) = draw_line_return_wind(start, end, wind_so_far, \n",
        "                    should_linger = i == len(sides) - 1,\n",
        "                    draw_line = i in sides_to_draw)\n",
        "                anim = Succession(anim, next_anim)\n",
        "\n",
        "            if self.show_cursor:\n",
        "                cursor = cursor_base.copy()\n",
        "                center_x, center_y = rect.get_center()\n",
        "                width = rect.get_width()\n",
        "                height = rect.get_height()\n",
        "                \n",
        "                cursor.move_to(num_plane.coords_to_point(center_x, center_y) + 10 * IN)\n",
        "                cursor.scale(min(width, height))\n",
        "\n",
        "                # Do a quick FadeIn, wait, and quick FadeOut on the cursor, matching rectangle-drawing time\n",
        "                cursor_anim = Succession(\n",
        "                    FadeIn(cursor, run_time = 0.1),\n",
        "                    Animation(cursor, run_time = 3.8), \n",
        "                    FadeOut(cursor, run_time = 0.1)\n",
        "                )\n",
        "\n",
        "                anim = AnimationGroup(anim, cursor_anim)\n",
        "\n",
        "            override_wind = head(manual_wind_override)\n",
        "            if override_wind != None:\n",
        "                total_wind = override_wind\n",
        "            else:\n",
        "                total_wind = round(wind_so_far)\n",
        "\n",
        "            if total_wind == 0:\n",
        "                coords = [\n",
        "                    rect.get_top_left(), \n",
        "                    rect.get_top_right(), \n",
        "                    rect.get_bottom_right(), \n",
        "                    rect.get_bottom_left()\n",
        "                ]\n",
        "                points = np.array([num_plane.coords_to_point(x, y) for (x, y) in coords]) + 3 * IN\n",
        "                # TODO: Maybe use diagonal lines or something to fill in rectangles indicating\n",
        "                # their \"Nothing here\" status?\n",
        "                # Or draw a large X or something\n",
        "                fill_rect = polygonObject = Polygon(*points, fill_opacity = 0.8, color = GREY_D)\n",
        "                return EquationSolver2dNode(Succession(anim, FadeIn(fill_rect)))\n",
        "            else:\n",
        "                (sub_rect1, sub_rect2) = rect.splits_on_dim(dim_to_split)\n",
        "                if dim_to_split == 0:\n",
        "                    sub_rect_and_sides = [(sub_rect1, 1), (sub_rect2, 3)]\n",
        "                else:\n",
        "                    sub_rect_and_sides = [(sub_rect1, 2), (sub_rect2, 0)]\n",
        "                children = [\n",
        "                    Animate2dSolver(\n",
        "                        cur_depth = cur_depth + 1,\n",
        "                        rect = sub_rect,\n",
        "                        dim_to_split = 1 - dim_to_split,\n",
        "                        sides_to_draw = [side_to_draw],\n",
        "                        manual_wind_override = child(manual_wind_override, index)\n",
        "                    )\n",
        "                    for (index, (sub_rect, side_to_draw)) in enumerate(sub_rect_and_sides)\n",
        "                ]\n",
        "                mid_line_coords = rect.split_line_on_dim(dim_to_split)\n",
        "                mid_line_points = [num_plane.coords_to_point(x, y)  + 2 * IN for (x, y) in mid_line_coords]\n",
        "                mid_line = DashedLine(*mid_line_points)\n",
        "\n",
        "                return EquationSolver2dNode(Succession(anim, ShowCreation(mid_line)), children)\n",
        "\n",
        "        lower_x = self.initial_lower_x\n",
        "        upper_x = self.initial_upper_x\n",
        "        lower_y = self.initial_lower_y\n",
        "        upper_y = self.initial_upper_y\n",
        "\n",
        "        x_interval = (lower_x, upper_x)\n",
        "        y_interval = (lower_y, upper_y)\n",
        "\n",
        "        rect = RectangleData(x_interval, y_interval)\n",
        "\n",
        "        print(\"Starting to compute anim\")\n",
        "\n",
        "        node = Animate2dSolver(\n",
        "            cur_depth = 0, \n",
        "            rect = rect,\n",
        "            dim_to_split = 0,\n",
        "            sides_to_draw = [],\n",
        "            manual_wind_override = self.manual_wind_override\n",
        "        )\n",
        "\n",
        "        print(\"Done computing anim\")\n",
        "\n",
        "        if self.display_in_parallel:\n",
        "            anim = node.display_in_parallel()\n",
        "        elif self.display_in_bfs:\n",
        "            anim = node.display_in_bfs()\n",
        "        else:\n",
        "            anim = node.display_in_series()\n",
        "\n",
        "        # Keep timing details here in sync with details above\n",
        "        rect_points = [\n",
        "            rect.get_top_left(), \n",
        "            rect.get_top_right(), \n",
        "            rect.get_bottom_right(), \n",
        "            rect.get_bottom_left(),\n",
        "        ]\n",
        "        border = Polygon(*[num_plane.coords_to_point(*x) + IN for x in rect_points])\n",
        "        match_style_with_bg(border, base_line)\n",
        "\n",
        "        rect_time_without_linger = 4 * run_time_base\n",
        "        rect_time_with_linger = 3 * run_time_base + run_time_with_lingering\n",
        "        def rect_rate(alpha):\n",
        "            time_in = alpha * rect_time_with_linger\n",
        "            if time_in < 3 * run_time_base:\n",
        "                return fdiv(time_in, 4 * run_time_base)\n",
        "            else:\n",
        "                time_in_last_leg = time_in - 3 * run_time_base\n",
        "                alpha_in_last_leg = fdiv(time_in_last_leg, run_time_with_lingering)\n",
        "                return interpolate(0.75, 1, linger_rate(alpha_in_last_leg))\n",
        "\n",
        "        border_anim = ShowCreation(\n",
        "            border, \n",
        "            run_time = rect_time_with_linger, \n",
        "            rate_func = rect_rate\n",
        "        )\n",
        "\n",
        "        print(\"About to do the big Play; for reference, the current time is \", time.strftime(\"%H:%M:%S\"))\n",
        "\n",
        "        if self.use_separate_plays:\n",
        "            node.play_in_bfs(self, border_anim)\n",
        "        else:\n",
        "            self.play(anim, border_anim)\n",
        "\n",
        "        print(\"All done; for reference, the current time is \", time.strftime(\"%H:%M:%S\"))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "# TODO: Perhaps have option for bullets (pulses) to fade out and in at ends of line, instead of \n",
        "# jarringly popping out and in?\n",
        "#\n",
        "# TODO: Perhaps have bullets change color corresponding to a function of their coordinates?\n",
        "# This could involve some merging of functoinality with PiWalker\n",
        "class LinePulser(ContinualAnimation):\n",
        "    def __init__(self, line, bullet_template, num_bullets, pulse_time, output_func = None, **kwargs):\n",
        "        self.line = line\n",
        "        self.num_bullets = num_bullets\n",
        "        self.pulse_time = pulse_time\n",
        "        self.bullets = [bullet_template.copy() for i in range(num_bullets)]\n",
        "        self.output_func = output_func\n",
        "        ContinualAnimation.__init__(self, VGroup(*self.bullets), **kwargs)\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        alpha = self.external_time % self.pulse_time\n",
        "        start = self.line.get_start()\n",
        "        end = self.line.get_end()\n",
        "        for i in range(self.num_bullets):\n",
        "            position = interpolate(start, end, \n",
        "                fdiv((i + alpha),(self.num_bullets)))\n",
        "            self.bullets[i].move_to(position)\n",
        "            if self.output_func:\n",
        "                position_2d = (position[0], position[1])\n",
        "                rev = point_to_rev(self.output_func(position_2d))\n",
        "                color = rev_to_color(rev)\n",
        "                self.bullets[i].set_color(color)\n",
        "\n",
        "class ArrowCircleTest(Scene):\n",
        "    def construct(self):\n",
        "        circle_radius = 3\n",
        "        circle = Circle(radius = circle_radius, color = WHITE)\n",
        "        self.add(circle)\n",
        "\n",
        "        base_arrow = Arrow(circle_radius * 0.7 * RIGHT, circle_radius * 1.3 * RIGHT)\n",
        "\n",
        "        def rev_rotate(x, revs):\n",
        "            x.rotate(revs * TAU, about_point = ORIGIN)\n",
        "            x.set_color(rev_to_color(revs))\n",
        "            return x\n",
        "\n",
        "        num_arrows = 8 * 3\n",
        "\n",
        "        # 0.5 - fdiv below so as to get a clockwise rotation from left\n",
        "        arrows = [rev_rotate(base_arrow.copy(), 0.5 - (fdiv(i, num_arrows))) for i in range(num_arrows)]\n",
        "        arrows_vgroup = VGroup(*arrows)\n",
        "\n",
        "        self.play(ShowCreation(arrows_vgroup), run_time = 2.5, rate_func=linear)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class FuncRotater(Animation):\n",
        "    CONFIG = {\n",
        "        \"rev_func\" : lambda x : x, # Func from alpha to CCW revolutions,\n",
        "    }\n",
        "\n",
        "    # Perhaps abstract this out into an \"Animation updating from original object\" class\n",
        "    def interpolate_submobject(self, submobject, starting_submobject, alpha):\n",
        "        submobject.set_points(starting_submobject.get_points())\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        Animation.interpolate_mobject(self, alpha)\n",
        "        angle_revs = self.rev_func(alpha)\n",
        "        self.mobject.rotate(\n",
        "            angle_revs * TAU, \n",
        "            about_point = ORIGIN\n",
        "        )\n",
        "        self.mobject.set_color(rev_to_color(angle_revs))\n",
        "\n",
        "class TestRotater(Scene):\n",
        "    def construct(self):\n",
        "        test_line = Line(ORIGIN, RIGHT)\n",
        "        self.play(FuncRotater(\n",
        "            test_line,\n",
        "            rev_func = lambda x : x % 0.25,\n",
        "            run_time = 10))\n",
        "\n",
        "# TODO: Be careful about clockwise vs. counterclockwise convention throughout!\n",
        "# Make sure this is correct everywhere in resulting video.\n",
        "class OdometerScene(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        # \"func\" : lambda p : 100 * p # Full coloring, essentially\n",
        "        \"rotate_func\" : lambda x : 2 * np.sin(2 * x * TAU), # This is given in terms of CW revs\n",
        "        \"run_time\" : 40,\n",
        "        \"dashed_line_angle\" : None,\n",
        "        \"biased_display_start\" : None,\n",
        "        \"pure_odometer_background\" : False\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        radius = ODOMETER_RADIUS\n",
        "        circle = Circle(center = ORIGIN, radius = radius)\n",
        "        circle.stroke_width = ODOMETER_STROKE_WIDTH\n",
        "        circle.color_using_background_image(self.background_image_file)\n",
        "        self.add(circle)\n",
        "\n",
        "        if self.pure_odometer_background:\n",
        "            # Just display this background circle, for compositing in Premiere with PiWalker odometers\n",
        "            self.wait()\n",
        "            return\n",
        "\n",
        "        if self.dashed_line_angle:\n",
        "            dashed_line = DashedLine(ORIGIN, radius * RIGHT)\n",
        "            # Clockwise rotation\n",
        "            dashed_line.rotate(-self.dashed_line_angle * TAU, about_point = ORIGIN)\n",
        "            self.add(dashed_line)\n",
        "        \n",
        "        num_display = DecimalNumber(0, include_background_rectangle = False)\n",
        "        num_display.move_to(2 * DOWN)\n",
        "\n",
        "        caption = OldTexText(\"turns clockwise\")\n",
        "        caption.next_to(num_display, DOWN)\n",
        "        self.add(caption)\n",
        "\n",
        "        display_val_bias = 0\n",
        "        if self.biased_display_start != None:\n",
        "            display_val_bias = self.biased_display_start - self.rotate_func(0)\n",
        "        display_func = lambda alpha : self.rotate_func(alpha) + display_val_bias\n",
        "\n",
        "        base_arrow = Arrow(ORIGIN, RIGHT, buff = 0)\n",
        "\n",
        "        self.play(\n",
        "            FuncRotater(base_arrow, rev_func = lambda x : -self.rotate_func(x)),\n",
        "            ChangingDecimal(num_display, display_func),\n",
        "            run_time = self.run_time,\n",
        "            rate_func=linear)\n",
        "\n",
        "#############\n",
        "# Above are mostly general tools; here, we list, in order, finished or near-finished scenes\n",
        "\n",
        "class FirstSqrtScene(EquationSolver1d):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 2.5,\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 2.5**2,\n",
        "        \"graph_origin\" : 2.5*DOWN + 5.5*LEFT,\n",
        "        \"x_axis_width\" : 12,\n",
        "        \"zoom_factor\" : 3,\n",
        "        \"zoomed_canvas_center\" : 2.25 * UP + 1.75 * LEFT,\n",
        "        \"func\" : lambda x : x**2,\n",
        "        \"targetX\" : np.sqrt(2),\n",
        "        \"targetY\" : 2,\n",
        "        \"initial_lower_x\" : 1,\n",
        "        \"initial_upper_x\" : 2,\n",
        "        \"num_iterations\" : 5,\n",
        "        \"iteration_at_which_to_start_zoom\" : 3,\n",
        "        \"graph_label\" : \"y = x^2\",\n",
        "        \"show_target_line\" : True,\n",
        "        \"x_tick_frequency\" : 0.25\n",
        "    }\n",
        "\n",
        "class TestFirstSqrtScene(FirstSqrtScene):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 1,\n",
        "    }\n",
        "\n",
        "FirstSqrtSceneConfig = FirstSqrtScene.CONFIG\n",
        "shiftVal = FirstSqrtSceneConfig[\"targetY\"]\n",
        "\n",
        "class SecondSqrtScene(FirstSqrtScene):\n",
        "        CONFIG = {\n",
        "            \"graph_label\" : FirstSqrtSceneConfig[\"graph_label\"] + \" - \" + str(shiftVal),\n",
        "            \"show_y_as_deviation\" : True,\n",
        "        }\n",
        "\n",
        "class TestSecondSqrtScene(SecondSqrtScene):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 1\n",
        "    }\n",
        "\n",
        "class GuaranteedZeroScene(SecondSqrtScene):\n",
        "     CONFIG = {\n",
        "        # Manual config values, not automatically synced to anything above\n",
        "        \"initial_lower_x\" : 1.75,\n",
        "        \"initial_upper_x\" : 2\n",
        "     }\n",
        "\n",
        "class TestGuaranteedZeroScene(GuaranteedZeroScene):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 1\n",
        "    }\n",
        "\n",
        "# TODO: Pi creatures intrigued\n",
        "\n",
        "class RewriteEquation(Scene):\n",
        "    def construct(self):\n",
        "        # Can maybe use get_center() to perfectly center Groups before and after transform\n",
        "\n",
        "        f_old = OldTex(\"f(x)\")\n",
        "        f_new = f_old.copy()\n",
        "        equals_old = OldTex(\"=\")\n",
        "        equals_old_2 = equals_old.copy()\n",
        "        equals_new = equals_old.copy()\n",
        "        g_old = OldTex(\"g(x)\")\n",
        "        g_new = g_old.copy()\n",
        "        minus_new = OldTex(\"-\")\n",
        "        zero_new = OldTex(\"0\")\n",
        "        f_old.next_to(equals_old, LEFT)\n",
        "        g_old.next_to(equals_old, RIGHT)\n",
        "        minus_new.next_to(g_new, LEFT)\n",
        "        f_new.next_to(minus_new, LEFT)\n",
        "        equals_new.next_to(g_new, RIGHT)\n",
        "        zero_new.next_to(equals_new, RIGHT)\n",
        "\n",
        "        # where_old = OldTexText(\"Where does \")\n",
        "        # where_old.next_to(f_old, LEFT)\n",
        "        # where_new = where_old.copy()\n",
        "        # where_new.next_to(f_new, LEFT)\n",
        "        \n",
        "        # qmark_old = OldTexText(\"?\")\n",
        "        # qmark_old.next_to(g_old, RIGHT)\n",
        "        # qmark_new = qmark_old.copy()\n",
        "        # qmark_new.next_to(zero_new, RIGHT)\n",
        "        \n",
        "        self.add(f_old, equals_old, equals_old_2, g_old) #, where_old, qmark_old)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(f_old, f_new),\n",
        "            ReplacementTransform(equals_old, equals_new), \n",
        "            ReplacementTransform(g_old, g_new), \n",
        "            ReplacementTransform(equals_old_2, minus_new),\n",
        "            ShowCreation(zero_new),\n",
        "            # ReplacementTransform(where_old, where_new),\n",
        "            # ReplacementTransform(qmark_old, qmark_new),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SignsExplanation(Scene):\n",
        "    def construct(self):\n",
        "        num_line = NumberLine()\n",
        "        largest_num = 10\n",
        "        num_line.add_numbers(*list(range(-largest_num, largest_num + 1)))\n",
        "        self.add(num_line)\n",
        "        self.wait()\n",
        "\n",
        "        pos_num = 3\n",
        "        neg_num = -pos_num\n",
        "\n",
        "        pos_arrow = Arrow(\n",
        "                num_line.number_to_point(0), \n",
        "                num_line.number_to_point(pos_num),\n",
        "                buff = 0,\n",
        "                color = positive_color)\n",
        "        neg_arrow = Arrow(\n",
        "                num_line.number_to_point(0), \n",
        "                num_line.number_to_point(neg_num),\n",
        "                buff = 0,\n",
        "                color = negative_color)\n",
        "\n",
        "        plus_sign = OldTex(\"+\", fill_color = positive_color)\n",
        "        minus_sign = OldTex(\"-\", fill_color = negative_color)\n",
        "\n",
        "        plus_sign.next_to(pos_arrow, UP)\n",
        "        minus_sign.next_to(neg_arrow, UP)\n",
        "        \n",
        "        #num_line.add_numbers(pos_num)\n",
        "        self.play(ShowCreation(pos_arrow), FadeIn(plus_sign))\n",
        "\n",
        "        #num_line.add_numbers(neg_num)\n",
        "        self.play(ShowCreation(neg_arrow), FadeIn(minus_sign))\n",
        "\n",
        "class VectorField(Scene):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"granularity\" : 10,\n",
        "        \"arrow_scale_factor\" : 0.1,\n",
        "        \"normalized_arrow_scale_factor\" : 5\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        num_plane = NumberPlane()\n",
        "        self.add(num_plane)\n",
        "\n",
        "        x_min, y_min = num_plane.point_to_coords(FRAME_X_RADIUS * LEFT + FRAME_Y_RADIUS * UP)\n",
        "        x_max, y_max = num_plane.point_to_coords(FRAME_X_RADIUS * RIGHT + FRAME_Y_RADIUS * DOWN)\n",
        "\n",
        "        x_points = np.linspace(x_min, x_max, self.granularity)\n",
        "        y_points = np.linspace(y_min, y_max, self.granularity)\n",
        "        points = it.product(x_points, y_points)\n",
        "\n",
        "        sized_arrows = Group()\n",
        "        unsized_arrows = Group()\n",
        "        for (x, y) in points:\n",
        "            output = self.func((x, y))\n",
        "            output_size = np.sqrt(sum(output**2))\n",
        "            normalized_output = output * fdiv(self.normalized_arrow_scale_factor, output_size) # Assume output has nonzero size here\n",
        "            arrow = Vector(output * self.arrow_scale_factor)\n",
        "            normalized_arrow = Vector(normalized_output * self.arrow_scale_factor)\n",
        "            arrow.move_to(num_plane.coords_to_point(x, y))\n",
        "            normalized_arrow.move_to(arrow)\n",
        "            sized_arrows.add(arrow)\n",
        "            unsized_arrows.add(normalized_arrow)\n",
        "\n",
        "        self.add(sized_arrows)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ReplacementTransform(sized_arrows, unsized_arrows))\n",
        "        self.wait()\n",
        "\n",
        "class HasItsLimitations(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\" : {\"use_z_coordinate_for_display_order\": True},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        num_line = NumberLine()\n",
        "        num_line.add_numbers()\n",
        "        self.add(num_line)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # We arrange to go from 2 to 4, a la the squaring in FirstSqrtScene\n",
        "        base_point = num_line.number_to_point(2) + OUT\n",
        "\n",
        "        dot_color = ORANGE\n",
        "\n",
        "        DOT_Z = OUT\n",
        "        # Note: This z-buffer value is needed for our static scenes, but is\n",
        "        # not sufficient for everything, in that we still need to use \n",
        "        # the foreground_mobjects trick during animations.\n",
        "        # At some point, we should figure out how to have animations\n",
        "        # play well with z coordinates.\n",
        "        \n",
        "        input_dot = Dot(base_point + DOT_Z, color = dot_color)\n",
        "        input_label = OldTexText(\"Input\", fill_color = dot_color)\n",
        "        input_label.next_to(input_dot, UP + LEFT)\n",
        "        input_label.add_background_rectangle()\n",
        "        self.add_foreground_mobject(input_dot)\n",
        "        self.add(input_label)\n",
        "\n",
        "        curved_arrow = Arc(0, color = MAROON_E)\n",
        "        curved_arrow.set_bound_angles(np.pi, 0)\n",
        "        curved_arrow.init_points()\n",
        "        curved_arrow.add_tip()\n",
        "        curved_arrow.move_arc_center_to(base_point + RIGHT)\n",
        "        # Could do something smoother, with arrowhead moving along partial arc?\n",
        "        self.play(ShowCreation(curved_arrow))\n",
        "\n",
        "        output_dot = Dot(base_point + 2 * RIGHT + DOT_Z, color = dot_color)\n",
        "        output_label = OldTexText(\"Output\", fill_color = dot_color)\n",
        "        output_label.next_to(output_dot, UP + RIGHT)\n",
        "        output_label.add_background_rectangle()\n",
        "\n",
        "        self.add_foreground_mobject(output_dot)\n",
        "        self.add(output_label)\n",
        "        self.wait()\n",
        "\n",
        "        num_plane = NumberPlane()\n",
        "        num_plane.add_coordinates()\n",
        "\n",
        "        new_base_point = base_point + 2 * UP\n",
        "        new_input_dot = input_dot.copy().move_to(new_base_point)\n",
        "        new_input_label = input_label.copy().next_to(new_input_dot, UP + LEFT)\n",
        "        \n",
        "        new_curved_arrow = Arc(0).match_style(curved_arrow)\n",
        "        new_curved_arrow.set_bound_angles(np.pi * 3/4, 0)\n",
        "        new_curved_arrow.init_points()\n",
        "        new_curved_arrow.add_tip()\n",
        "\n",
        "        input_diff = input_dot.get_center() - curved_arrow.get_points()[0]\n",
        "        output_diff = output_dot.get_center() - curved_arrow.get_points()[-1]\n",
        "\n",
        "        new_curved_arrow.shift((new_input_dot.get_center() - new_curved_arrow.get_points()[0]) - input_diff)\n",
        "\n",
        "        new_output_dot = output_dot.copy().move_to(new_curved_arrow.get_points()[-1] + output_diff)\n",
        "        new_output_label = output_label.copy().next_to(new_output_dot, UP + RIGHT)\n",
        "\n",
        "        dot_objects = Group(input_dot, input_label, output_dot, output_label, curved_arrow)\n",
        "        new_dot_objects = Group(new_input_dot, new_input_label, new_output_dot, new_output_label, new_curved_arrow)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(num_line), FadeIn(num_plane), \n",
        "            ReplacementTransform(dot_objects, new_dot_objects),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.add_foreground_mobject(new_dot_objects)\n",
        "\n",
        "        complex_plane = ComplexPlane()\n",
        "        complex_plane.add_coordinates()\n",
        "        \n",
        "        # This looks a little wonky and we may wish to do a crossfade in Premiere instead\n",
        "        self.play(FadeOut(num_plane), FadeIn(complex_plane))\n",
        "\n",
        "        self.wait()\n",
        "        \n",
        "\n",
        "class ComplexPlaneIs2d(Scene):\n",
        "    def construct(self):\n",
        "        com_plane = ComplexPlane()\n",
        "        self.add(com_plane)\n",
        "        # TODO: Add labels to axes, specific complex points\n",
        "        self.wait()\n",
        "\n",
        "class NumberLineScene(Scene):\n",
        "    def construct(self):\n",
        "        num_line = NumberLine()\n",
        "        self.add(num_line)\n",
        "        # TODO: Add labels, arrows, specific points\n",
        "        self.wait()\n",
        "\n",
        "        border_color = PURPLE_E\n",
        "        inner_color = RED\n",
        "        stroke_width = 10\n",
        "\n",
        "        left_point = num_line.number_to_point(-1)\n",
        "        right_point = num_line.number_to_point(1)\n",
        "        # TODO: Make this line a thin rectangle\n",
        "        interval_1d = Line(left_point, right_point, \n",
        "            stroke_color = inner_color, stroke_width = stroke_width)\n",
        "        rect_1d = Rectangle(stroke_width = 0, fill_opacity = 1, fill_color = inner_color)\n",
        "        rect_1d.replace(interval_1d)\n",
        "        rect_1d.stretch_to_fit_height(SMALL_BUFF)\n",
        "        left_dot = Dot(left_point, stroke_width = stroke_width, color = border_color)\n",
        "        right_dot = Dot(right_point, stroke_width = stroke_width, color = border_color)\n",
        "        endpoints_1d = VGroup(left_dot, right_dot)\n",
        "        full_1d = VGroup(rect_1d, endpoints_1d)\n",
        "        self.play(ShowCreation(full_1d))\n",
        "        self.wait()\n",
        "\n",
        "        # TODO: Can polish the morphing above; have dots become left and right sides, and \n",
        "        # only then fill in the top and bottom\n",
        "\n",
        "        num_plane = NumberPlane()\n",
        "\n",
        "        random_points = [UP + LEFT, UP + RIGHT, DOWN + RIGHT, DOWN + LEFT]\n",
        "\n",
        "        border_2d = Polygon(\n",
        "            *random_points,\n",
        "            stroke_color = border_color,\n",
        "            stroke_width = stroke_width)\n",
        "\n",
        "        filling_2d = Polygon(\n",
        "            *random_points,\n",
        "            fill_color = inner_color,\n",
        "            fill_opacity = 0.8,\n",
        "            stroke_width = stroke_width)\n",
        "        full_2d = VGroup(filling_2d, border_2d)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(num_line), \n",
        "            FadeIn(num_plane),\n",
        "            ReplacementTransform(full_1d, full_2d))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class Initial2dFuncSceneBase(Scene):\n",
        "    CONFIG = {\n",
        "        \"func\" : point3d_func_from_complex_func(lambda c : c**2 - c**3/5 + 1)\n",
        "        # We don't use example_plane_func because, unfortunately, the sort of examples\n",
        "        # which are good for demonstrating our color mapping haven't turned out to be\n",
        "        # good for visualizing in this manner; the gridlines run over themselves multiple \n",
        "        # times in too confusing a fashion\n",
        "    }\n",
        "\n",
        "    def show_planes(self):\n",
        "        print(\"Error! Unimplemented (pure virtual) show_planes\")\n",
        "\n",
        "    def shared_construct(self):\n",
        "        points = [LEFT + DOWN, RIGHT + DOWN, LEFT + UP, RIGHT + UP]\n",
        "        for i in range(len(points) - 1):\n",
        "            line = Line(points[i], points[i + 1], color = RED)\n",
        "            self.obj_draw(line)\n",
        "\n",
        "        def wiggle_around(point):\n",
        "             radius = 0.2\n",
        "             small_circle = cw_circle.copy()\n",
        "             small_circle.scale(radius)\n",
        "             small_circle.move_to(point + radius * RIGHT)\n",
        "             small_circle.set_color(RED)\n",
        "             self.obj_draw(small_circle)\n",
        "\n",
        "        wiggle_around(points[-1])\n",
        "\n",
        "    def obj_draw(self, input_object):\n",
        "        self.play(ShowCreation(input_object))\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_planes()\n",
        "        self.shared_construct()\n",
        "\n",
        "# Alternative to the below, using MappingCameras, but no morphing animation\n",
        "class Initial2dFuncSceneWithoutMorphing(Initial2dFuncSceneBase):\n",
        "\n",
        "    def setup(self):\n",
        "        left_camera = Camera(**self.camera_config)\n",
        "        right_camera = MappingCamera(\n",
        "            mapping_func = self.func,\n",
        "            **self.camera_config)\n",
        "        split_screen_camera = SplitScreenCamera(left_camera, right_camera, **self.camera_config)\n",
        "        self.camera = split_screen_camera\n",
        "\n",
        "    def show_planes(self):\n",
        "        self.num_plane = NumberPlane()\n",
        "        self.num_plane.prepare_for_nonlinear_transform()\n",
        "        #num_plane.fade()\n",
        "        self.add(self.num_plane)\n",
        "\n",
        "# Alternative to the above, manually implementing split screen with a morphing animation\n",
        "class Initial2dFuncSceneMorphing(Initial2dFuncSceneBase):\n",
        "    CONFIG = {\n",
        "        \"num_needed_anchor_curves\" : 10,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        split_line = DashedLine(FRAME_Y_RADIUS * UP, FRAME_Y_RADIUS * DOWN)\n",
        "        self.num_plane = NumberPlane(x_radius = FRAME_X_RADIUS/2)\n",
        "        self.num_plane.to_edge(LEFT, buff = 0)\n",
        "        self.num_plane.prepare_for_nonlinear_transform()\n",
        "        self.add(self.num_plane, split_line)\n",
        "\n",
        "    def squash_onto_left(self, object):\n",
        "        object.shift(FRAME_X_RADIUS/2 * LEFT)\n",
        "\n",
        "    def squash_onto_right(self, object):\n",
        "        object.shift(FRAME_X_RADIUS/2 * RIGHT)\n",
        "\n",
        "    def obj_draw(self, input_object):\n",
        "        output_object = input_object.copy()\n",
        "        if input_object.get_num_curves() < self.num_needed_anchor_curves:\n",
        "            input_object.insert_n_curves(self.num_needed_anchor_curves)\n",
        "        output_object.apply_function(self.func)\n",
        "        self.squash_onto_left(input_object)\n",
        "        self.squash_onto_right(output_object)\n",
        "        self.play(\n",
        "            ShowCreation(input_object), \n",
        "            ShowCreation(output_object)\n",
        "            )\n",
        "\n",
        "    def show_planes(self):\n",
        "        right_plane = self.num_plane.copy()\n",
        "        right_plane.center()\n",
        "        right_plane.prepare_for_nonlinear_transform()\n",
        "        right_plane.apply_function(self.func)\n",
        "        right_plane.shift(FRAME_X_RADIUS/2 * RIGHT)\n",
        "        self.right_plane = right_plane\n",
        "        crappy_cropper = FullScreenFadeRectangle(fill_opacity = 1)\n",
        "        crappy_cropper.stretch_to_fit_width(FRAME_X_RADIUS)\n",
        "        crappy_cropper.to_edge(LEFT, buff = 0)\n",
        "        self.play(\n",
        "            ReplacementTransform(self.num_plane.copy(), right_plane),\n",
        "            FadeIn(crappy_cropper), \n",
        "            Animation(self.num_plane),\n",
        "            run_time = 3\n",
        "        )\n",
        "\n",
        "class DemonstrateColorMapping(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False,\n",
        "        \"show_full_color_map\" : True\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        # Doing this in Premiere now instead\n",
        "        # output_plane_label = OldTexText(\"Output Plane\", color = WHITE)\n",
        "        # output_plane_label.move_to(3 * UP)\n",
        "        # self.add_foreground_mobject(output_plane_label)\n",
        "\n",
        "        if self.show_full_color_map:\n",
        "            bright_background = Rectangle(width = 2 * FRAME_X_RADIUS + 1, height = 2 * FRAME_Y_RADIUS + 1, fill_opacity = 1)\n",
        "            bright_background.color_using_background_image(self.background_image_file)\n",
        "            dim_background = bright_background.copy()\n",
        "            dim_background.fill_opacity = 0.3\n",
        "            \n",
        "            background = bright_background.copy()\n",
        "            self.add(background)\n",
        "            self.wait()\n",
        "            self.play(ReplacementTransform(background, dim_background))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        ray = Line(ORIGIN, 10 * LEFT)\n",
        "\n",
        "\n",
        "        circle = cw_circle.copy()\n",
        "        circle.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        scale_up_factor = 5\n",
        "        scale_down_factor = 20\n",
        "        self.play(ApplyMethod(circle.scale, fdiv(1, scale_down_factor)))\n",
        "\n",
        "        self.play(ApplyMethod(circle.scale, scale_up_factor * scale_down_factor))\n",
        "\n",
        "        self.play(ApplyMethod(circle.scale, fdiv(1, scale_up_factor)))\n",
        "\n",
        "        self.wait()\n",
        "        self.remove(circle)\n",
        "\n",
        "        ray = Line(ORIGIN, 10 * LEFT)\n",
        "        ray.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        self.play(ShowCreation(ray))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Rotating(ray, about_point = ORIGIN, radians = -TAU/2))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Rotating(ray, about_point = ORIGIN, radians = -TAU/2))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        if self.show_full_color_map:\n",
        "            self.play(ReplacementTransform(background, bright_background))\n",
        "            self.wait()\n",
        "\n",
        "# Everything in this is manually kept in sync with WindingNumber_G/TransitionFromPathsToBoundaries\n",
        "class LoopSplitScene(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-2, 0, 2), (2, 0, 1)\n",
        "        ),\n",
        "        \"use_fancy_lines\" : True,\n",
        "    }\n",
        "\n",
        "    def PulsedLine(self, \n",
        "        start, end, \n",
        "        bullet_template, \n",
        "        num_bullets = 4, \n",
        "        pulse_time = 1, \n",
        "        **kwargs):\n",
        "        line = Line(start, end, color = WHITE, stroke_width = 4, **kwargs)\n",
        "        if self.use_fancy_lines:\n",
        "            line.color_using_background_image(self.background_image_file)\n",
        "        anim = LinePulser(\n",
        "            line = line, \n",
        "            bullet_template = bullet_template, \n",
        "            num_bullets = num_bullets, \n",
        "            pulse_time = pulse_time, \n",
        "            output_func = self.func,\n",
        "            **kwargs)\n",
        "        return (line, VMobject(*anim.bullets), anim)\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        scale_factor = 2\n",
        "        shift_term = 0\n",
        "\n",
        "        # TODO: Change all this to use a wider than tall loop, made of two squares\n",
        "\n",
        "        # Original loop\n",
        "        tl = (UP + 2 * LEFT) * scale_factor\n",
        "        tm = UP * scale_factor\n",
        "        tr = (UP + 2 * RIGHT) * scale_factor\n",
        "        bl = (DOWN + 2 * LEFT) * scale_factor\n",
        "        bm = DOWN * scale_factor\n",
        "        br = (DOWN + 2 * RIGHT) * scale_factor\n",
        "\n",
        "        top_line = Line(tl, tr) # Invisible; only used for surrounding circle\n",
        "        bottom_line = Line(br, bl) # Invisible; only used for surrounding circle\n",
        "\n",
        "        stroke_width = top_line.stroke_width\n",
        "\n",
        "        default_bullet = PiCreature()\n",
        "        default_bullet.scale(0.15)\n",
        "\n",
        "        def pl(a, b):\n",
        "            return self.PulsedLine(a, b, default_bullet)\n",
        "\n",
        "        def indicate_circle(x, double_horizontal_stretch = False):\n",
        "            circle = Circle(color = WHITE, radius = 2 * np.sqrt(2))\n",
        "            circle.move_to(x.get_center())\n",
        "\n",
        "            if x.get_slope() == 0:\n",
        "                circle.stretch(0.2, 1)\n",
        "                if double_horizontal_stretch:\n",
        "                    circle.stretch(2, 0)\n",
        "            else:\n",
        "                circle.stretch(0.2, 0)\n",
        "            return circle\n",
        "\n",
        "        tl_line_trip = pl(tl, tm)\n",
        "        midline_left_trip = pl(tm, bm)\n",
        "        bl_line_trip = pl(bm, bl)\n",
        "        left_line_trip = pl(bl, tl)\n",
        "\n",
        "        left_square_trips = [tl_line_trip, midline_left_trip, bl_line_trip, left_line_trip]\n",
        "        left_square_lines = [x[0] for x in left_square_trips]\n",
        "        left_square_lines_vmobject = VMobject(*left_square_lines)\n",
        "        left_square_bullets = [x[1] for x in left_square_trips]\n",
        "        left_square_anims = [x[2] for x in left_square_trips]\n",
        "\n",
        "        tr_line_trip = pl(tm, tr)\n",
        "        right_line_trip = pl(tr, br)\n",
        "        br_line_trip = pl(br, bm)\n",
        "        midline_right_trip = pl(bm, tm)\n",
        "\n",
        "        right_square_trips = [tr_line_trip, right_line_trip, br_line_trip, midline_right_trip]\n",
        "        right_square_lines = [x[0] for x in right_square_trips]\n",
        "        right_square_lines_vmobject = VMobject(*right_square_lines)\n",
        "        right_square_bullets = [x[1] for x in right_square_trips]\n",
        "        right_square_anims = [x[2] for x in right_square_trips]\n",
        "\n",
        "        midline_trips = [midline_left_trip, midline_right_trip]\n",
        "        midline_lines = [x[0] for x in midline_trips]\n",
        "        midline_lines_vmobject = VMobject(*midline_lines)\n",
        "        midline_bullets = [x[1] for x in midline_trips]\n",
        "        midline_anims = [x[1] for x in midline_trips]\n",
        "\n",
        "        left_line = left_line_trip[0]\n",
        "        right_line = right_line_trip[0]\n",
        "\n",
        "        for b in left_square_bullets + right_square_bullets:\n",
        "            b.set_fill(opacity = 0)\n",
        "\n",
        "        faded = 0.3\n",
        "\n",
        "        # Workaround for FadeOut/FadeIn not playing well with ContinualAnimations due to \n",
        "        # Transforms making copies no longer identified with the ContinualAnimation's tracked mobject\n",
        "        def bullet_fade(start, end, mob):\n",
        "            return UpdateFromAlphaFunc(mob, lambda m, a : m.set_fill(opacity = interpolate(start, end, a)))\n",
        "\n",
        "        def bullet_list_fade(start, end, bullet_list):\n",
        "            return [bullet_fade(start, end, b) for b in bullet_list]\n",
        "\n",
        "        def line_fade(start, end, mob):\n",
        "            return UpdateFromAlphaFunc(mob, lambda m, a : m.set_stroke(width = interpolate(start, end, a) * stroke_width))\n",
        "\n",
        "        def play_combined_fade(start, end, lines_vmobject, bullets):\n",
        "            self.play(\n",
        "                line_fade(start, end, lines_vmobject), \n",
        "                *bullet_list_fade(start, end, bullets)\n",
        "            )\n",
        "\n",
        "        def play_fade_left(start, end):\n",
        "            play_combined_fade(start, end, left_square_lines_vmobject, left_square_bullets)\n",
        "\n",
        "        def play_fade_right(start, end):\n",
        "            play_combined_fade(start, end, right_square_lines_vmobject, right_square_bullets)\n",
        "\n",
        "        def play_fade_mid(start, end):\n",
        "            play_combined_fade(start, end, midline_lines_vmobject, midline_bullets)\n",
        "\n",
        "        def flash_circles(circles):\n",
        "            self.play(LaggedStartMap(FadeIn, VGroup(circles)))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(VGroup(circles)))\n",
        "            self.wait()\n",
        "\n",
        "        self.add(left_square_lines_vmobject, right_square_lines_vmobject)\n",
        "        self.remove(*midline_lines)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(midline_lines[0]))\n",
        "        self.add(midline_lines_vmobject)\n",
        "        self.wait()\n",
        "\n",
        "        self.add(*left_square_anims)\n",
        "        self.play(line_fade(1, faded, right_square_lines_vmobject), *bullet_list_fade(0, 1, left_square_bullets))\n",
        "        self.wait()\n",
        "        flash_circles([indicate_circle(l) for l in left_square_lines])\n",
        "        self.play(line_fade(faded, 1, right_square_lines_vmobject), *bullet_list_fade(1, 0, left_square_bullets))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(*right_square_anims)\n",
        "        self.play(line_fade(1, faded, left_square_lines_vmobject), *bullet_list_fade(0, 1, right_square_bullets))\n",
        "        self.wait()\n",
        "        flash_circles([indicate_circle(l) for l in right_square_lines])\n",
        "        self.play(line_fade(faded, 1, left_square_lines_vmobject), *bullet_list_fade(1, 0, right_square_bullets))\n",
        "        self.wait()\n",
        "        \n",
        "        self.play(*bullet_list_fade(0, 1, left_square_bullets + right_square_bullets))\n",
        "        self.wait()\n",
        "\n",
        "        outside_circlers = [\n",
        "            indicate_circle(left_line), \n",
        "            indicate_circle(right_line), \n",
        "            indicate_circle(top_line, double_horizontal_stretch = True), \n",
        "            indicate_circle(bottom_line, double_horizontal_stretch = True)\n",
        "        ]\n",
        "        flash_circles(outside_circlers)\n",
        "\n",
        "        inner_circle = indicate_circle(midline_lines[0])\n",
        "        self.play(FadeIn(inner_circle))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(inner_circle), line_fade(1, 0, midline_lines_vmobject), *bullet_list_fade(1, 0, midline_bullets))\n",
        "        self.wait()\n",
        "        \n",
        "        # Repeat for effect, goes well with narration\n",
        "        self.play(FadeIn(inner_circle), line_fade(0, 1, midline_lines_vmobject), *bullet_list_fade(0, 1, midline_bullets))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(inner_circle), line_fade(1, 0, midline_lines_vmobject), *bullet_list_fade(1, 0, midline_bullets))\n",
        "        self.wait()\n",
        "\n",
        "# TODO: Perhaps do extra illustration of zooming out and winding around a large circle, \n",
        "# to illustrate relation between degree and large-scale winding number\n",
        "class FundThmAlg(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec((1, 2), (-1, 1.5), (-1, 1.5)),\n",
        "        \"num_iterations\" : 2,\n",
        "    }\n",
        "\n",
        "class SolveX5MinusXMinus1(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c : c**5 - c - 1),\n",
        "        \"num_iterations\" : 10,\n",
        "        \"show_cursor\" : True,\n",
        "        \"display_in_bfs\" : True,\n",
        "    }\n",
        "\n",
        "class PureColorMapOfX5Thing(PureColorMap):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c : c**5 - c - 1),\n",
        "    }\n",
        "\n",
        "class X5ThingWithRightHalfGreyed(SolveX5MinusXMinus1):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 3,\n",
        "        \"manual_wind_override\" : (1, None, (1, (0, None, None), (0, None, None)))\n",
        "    }\n",
        "\n",
        "class SolveX5MinusXMinus1_5Iterations(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c : c**5 - c - 1),\n",
        "        \"num_iterations\" : 5,\n",
        "        \"show_cursor\" : True,\n",
        "        \"display_in_bfs\" : True,\n",
        "        \"manual_wind_override\" : (None, None, (None, (0, None, None), (0, None, None)))\n",
        "    }\n",
        "\n",
        "class X5_Monster_Red_Lines(SolveX5MinusXMinus1_5Iterations):\n",
        "    CONFIG = {\n",
        "        \"use_separate_plays\" : True,\n",
        "        \"use_fancy_lines\" : False,\n",
        "        \"line_color\" : RED,\n",
        "    }\n",
        "\n",
        "class X5_Monster_Green_Lines(X5_Monster_Red_Lines):\n",
        "    CONFIG = {\n",
        "        \"line_color\" : GREEN,\n",
        "    }\n",
        "\n",
        "class X5_Monster_Red_Lines_Long(X5_Monster_Red_Lines):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 6\n",
        "    }\n",
        "\n",
        "class X5_Monster_Green_Lines_Long(X5_Monster_Green_Lines):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 6\n",
        "    }\n",
        "\n",
        "class X5_Monster_Red_Lines_Little_More(X5_Monster_Red_Lines_Long):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 7\n",
        "    }\n",
        "\n",
        "class X5_Monster_Green_Lines_Little_More(X5_Monster_Green_Lines_Long):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 7\n",
        "    }\n",
        "\n",
        "class X5_Monster_Red_Lines_No_Numbers(X5_Monster_Red_Lines):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 3,\n",
        "        \"show_winding_numbers\" : False,\n",
        "    }\n",
        "\n",
        "class X5_Monster_Green_Lines_No_Numbers(X5_Monster_Green_Lines):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 3,\n",
        "        \"show_winding_numbers\" : False,\n",
        "    }\n",
        "\n",
        "class SolveX5MinusXMinus1_3Iterations(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c : c**5 - c - 1),\n",
        "        \"num_iterations\" : 3,\n",
        "        \"show_cursor\" : True,\n",
        "        \"display_in_bfs\" : True,\n",
        "    }\n",
        "\n",
        "class Diagnostic(SolveX5MinusXMinus1_3Iterations):\n",
        "    CONFIG = {\n",
        "        # I think the combination of these two makes things slow\n",
        "        \"use_separate_plays\" : not False, # This one isn't important to set any particular way, so let's leave it like this\n",
        "        \"use_fancy_lines\" : True, \n",
        "\n",
        "        # This causes a small slowdown (before rendering, in particular), but not the big one, I think\n",
        "        \"show_winding_numbers\" : True,\n",
        "\n",
        "        # This doesn't significantly matter for rendering time, I think\n",
        "        \"camera_config\" : {\"use_z_coordinate_for_display_order\" : True}\n",
        "    }\n",
        "\n",
        "# All above flags False (meaning not db = False): just under 30 it/s\n",
        "# not db = True: 30\n",
        "# use_fancy_lines = True: 30 at first (if scene.play(bfs_nodes[0].first_anim, border_anim is off), but then drops to 3 (or drops right away if that simultaneous play is on)\n",
        "# use_z_coordinate = True: 30\n",
        "# show_winding_numbers = True: 10\n",
        "# winding AND use_fancy_lines: 10\n",
        "# not db AND fancy_lines AND z_coords = true, winding = false: 3. Not 30, but 3. Slow.\n",
        "# db AND use_fancy: 3. Slow.\n",
        "# fancy AND z_coords: 30. Fast. [Hm, this may have been a mistake; fancy and z_coords is now slow?]\n",
        "# fancy, winding, AND z_coords, but not (not db): 10\n",
        "# not db, winding, AND z_coords, but not fancy: 10\n",
        "\n",
        "# class DiagnosticB(Diagnostic):\n",
        "#     CONFIG = {\n",
        "#         \"num_iterations\" : 3,\n",
        "#         #\"num_checkpoints\" : 100,\n",
        "#         #\"show_winding_numbers\" : False,\n",
        "#         #\"use_cheap_winding_numbers\" : True,\n",
        "#     }\n",
        "\n",
        "class SolveX5MinusXMinus1Parallel(SolveX5MinusXMinus1):\n",
        "    CONFIG = {\n",
        "        \"display_in_parallel\" : True\n",
        "    }\n",
        "\n",
        "class SolveX5MinusXMinus1BFS(SolveX5MinusXMinus1):\n",
        "    CONFIG = {\n",
        "        \"display_in_bfs\" : True\n",
        "    }\n",
        "\n",
        "class PreviewClip(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"num_iterations\" : 5,\n",
        "        \"display_in_parallel\" : True,\n",
        "        \"use_fancy_lines\" : True,\n",
        "    }\n",
        "\n",
        "class ParallelClip(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-3, -1.3, 2), (0.1, 0.2, 1), (2.8, -2, 1)\n",
        "        ),\n",
        "        \"num_iterations\" : 5,\n",
        "        \"display_in_parallel\" : True,\n",
        "    }\n",
        "\n",
        "class EquationSolver2dMatchBreakdown(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec(\n",
        "            (-2, 0.3, 2), (2, -0.2, 1) # Not an exact match, because our breakdown function has a zero along midlines...\n",
        "        ),\n",
        "        \"num_iterations\" : 5,\n",
        "        \"display_in_parallel\" : True,\n",
        "        \"show_cursor\" : True\n",
        "    }\n",
        "\n",
        "class EquationSolver2dMatchBreakdown_parallel(EquationSolver2dMatchBreakdown):\n",
        "    CONFIG = {\n",
        "        \"display_in_parallel\" : True,\n",
        "        \"display_in_bfs\" : False,\n",
        "    }\n",
        "\n",
        "class EquationSolver2dMatchBreakdown_bfs(EquationSolver2dMatchBreakdown):\n",
        "    CONFIG = {\n",
        "        \"display_in_parallel\" : False,\n",
        "        \"display_in_bfs\" : True,\n",
        "    }\n",
        "\n",
        "class QuickPreview(PreviewClip):\n",
        "    CONFIG = {\n",
        "        \"num_iterations\" : 3,\n",
        "        \"display_in_parallel\" : False,\n",
        "        \"display_in_bfs\" : True,\n",
        "        \"show_cursor\" : True\n",
        "    }\n",
        "\n",
        "class LongEquationSolver(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"num_iterations\" : 10,\n",
        "        \"display_in_bfs\" : True,\n",
        "        \"linger_parameter\" : 0.4,\n",
        "        \"show_cursor\" : True,\n",
        "    }\n",
        "\n",
        "class QuickPreviewUnfancy(LongEquationSolver):\n",
        "    CONFIG = {\n",
        "        # \"use_fancy_lines\" : False,\n",
        "    }\n",
        "\n",
        "# TODO: Borsuk-Ulam visuals\n",
        "# Note: May want to do an ordinary square scene, then MappingCamera it into a circle\n",
        "# class BorsukUlamScene(PiWalker):\n",
        "\n",
        "# 3-way scene of \"Good enough\"-illustrating odometers; to be composed in Premiere\n",
        "left_func = lambda x : x**2 - x + 1\n",
        "diff_func = lambda x : np.cos(1.4 * (x - 0.1) * (np.log(x + 0.1) - 0.3) * TAU)/2.1\n",
        "\n",
        "class LeftOdometer(OdometerScene):\n",
        "    CONFIG = {\n",
        "        \"rotate_func\" : left_func,\n",
        "        \"biased_display_start\" : 0\n",
        "    }\n",
        "\n",
        "class RightOdometer(OdometerScene):\n",
        "    CONFIG = {\n",
        "        \"rotate_func\" : lambda x : left_func(x) + diff_func(x),\n",
        "        \"biased_display_start\" : 0\n",
        "    }\n",
        "\n",
        "class DiffOdometer(OdometerScene):\n",
        "    CONFIG = {\n",
        "        \"rotate_func\" : diff_func,\n",
        "        \"dashed_line_angle\" : 0.5,\n",
        "        \"biased_display_start\" : 0\n",
        "    }\n",
        "\n",
        "class CombineInterval(Scene):\n",
        "    def construct(self):\n",
        "        plus_sign = OldTex(\"+\", fill_color = positive_color)\n",
        "        minus_sign = OldTex(\"-\", fill_color = negative_color)\n",
        "\n",
        "        left_point = Dot(LEFT, color = positive_color)\n",
        "        right_point = Dot(RIGHT, color = negative_color)\n",
        "        line1 = Line(LEFT, RIGHT)\n",
        "        interval1 = Group(line1, left_point, right_point)\n",
        "\n",
        "        plus_sign.next_to(left_point, UP)\n",
        "        minus_sign.next_to(right_point, UP)\n",
        "\n",
        "        self.add(interval1, plus_sign, minus_sign)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            CircleIndicate(plus_sign),\n",
        "            CircleIndicate(minus_sign),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        mid_point = Dot(ORIGIN, color = GREY)\n",
        "\n",
        "        question_mark = OldTex(\"?\", fill_color = GREY)\n",
        "        plus_sign_copy = plus_sign.copy()\n",
        "        minus_sign_copy = minus_sign.copy()\n",
        "        new_signs = Group(question_mark, plus_sign_copy, minus_sign_copy)\n",
        "        for sign in new_signs: sign.next_to(mid_point, UP)\n",
        "\n",
        "        self.play(FadeIn(mid_point), FadeIn(question_mark))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(mid_point.set_color, positive_color),\n",
        "            ReplacementTransform(question_mark, plus_sign_copy),\n",
        "        )\n",
        "        self.play(\n",
        "            CircleIndicate(plus_sign_copy),\n",
        "            CircleIndicate(minus_sign),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(mid_point.set_color, negative_color),\n",
        "            ReplacementTransform(plus_sign_copy, minus_sign_copy),\n",
        "        )\n",
        "        self.play(\n",
        "            CircleIndicate(minus_sign_copy),\n",
        "            CircleIndicate(plus_sign),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class CombineInterval2(Scene):\n",
        "    def construct(self):\n",
        "        plus_sign = OldTex(\"+\", fill_color = positive_color)\n",
        "\n",
        "        def make_interval(a, b):\n",
        "            line = Line(a, b)\n",
        "            start_dot = Dot(a, color = positive_color)\n",
        "            end_dot = Dot(b, color = positive_color)\n",
        "            start_sign = plus_sign.copy().next_to(start_dot, UP)\n",
        "            end_sign = plus_sign.copy().next_to(end_dot, UP)\n",
        "            return Group(start_sign, end_sign, line, start_dot, end_dot)\n",
        "\n",
        "        def pair_indicate(a, b):\n",
        "            self.play(\n",
        "                CircleIndicate(a),\n",
        "                CircleIndicate(b)\n",
        "            )\n",
        "\n",
        "        left_interval = make_interval(2 * LEFT, LEFT)\n",
        "        right_interval = make_interval(RIGHT, 2 * RIGHT)\n",
        "\n",
        "        self.play(FadeIn(left_interval), FadeIn(right_interval))\n",
        "\n",
        "        pair_indicate(left_interval[0], left_interval[1])\n",
        "\n",
        "        pair_indicate(right_interval[0], right_interval[1])\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(left_interval.shift, RIGHT),\n",
        "            ApplyMethod(right_interval.shift, LEFT),\n",
        "        )\n",
        "\n",
        "        pair_indicate(left_interval[0], right_interval[1])\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "tiny_loop_func = scale_func(plane_func_by_wind_spec((-1, -2), (1, 1), (1, 1)), 0.3)\n",
        "\n",
        "class TinyLoopScene(ColorMappedByFuncScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : tiny_loop_func,\n",
        "        \"show_num_plane\" : False,\n",
        "        \"loop_point\" : ORIGIN,\n",
        "        \"circle_scale\" : 0.7\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedByFuncScene.construct(self)\n",
        "\n",
        "        circle = cw_circle.copy()\n",
        "        circle.scale(self.circle_scale)\n",
        "        circle.move_to(self.loop_point)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "\n",
        "class TinyLoopInInputPlaneAroundNonZero(TinyLoopScene):\n",
        "    CONFIG = {\n",
        "        \"loop_point\" : 0.5 * RIGHT\n",
        "    }\n",
        "\n",
        "class TinyLoopInInputPlaneAroundZero(TinyLoopScene):\n",
        "    CONFIG = {\n",
        "        \"loop_point\" : UP + RIGHT\n",
        "    }\n",
        "\n",
        "class TinyLoopInOutputPlaneAroundNonZero(TinyLoopInInputPlaneAroundNonZero):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : MappingCamera,\n",
        "        \"camera_config\" : {\"mapping_func\" : point3d_func_from_plane_func(tiny_loop_func)},\n",
        "        \"show_output\" : True,\n",
        "        \"show_num_plane\" : False,\n",
        "    }\n",
        "\n",
        "class TinyLoopInOutputPlaneAroundZero(TinyLoopInInputPlaneAroundZero):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : MappingCamera,\n",
        "        \"camera_config\" : {\"mapping_func\" : point3d_func_from_plane_func(tiny_loop_func)},\n",
        "        \"show_output\" : True,\n",
        "        \"show_num_plane\" : False,\n",
        "    }\n",
        "\n",
        "class BorderOf2dRegionScene(Scene):\n",
        "    def construct(self):\n",
        "        num_plane = NumberPlane()\n",
        "        self.add(num_plane)\n",
        "\n",
        "        points = standard_rect + 1.5 * UP + 2 * RIGHT\n",
        "        interior = Polygon(*points, fill_color = neutral_color, fill_opacity = 1, stroke_width = 0)\n",
        "        self.play(FadeIn(interior))\n",
        "\n",
        "        border = Polygon(*points, color = negative_color, stroke_width = border_stroke_width)\n",
        "        self.play(ShowCreation(border))\n",
        "\n",
        "big_loop_no_zeros_func = lambda x_y5 : complex_to_pair(np.exp(complex(10, x_y5[1] * np.pi)))\n",
        "\n",
        "class BigLoopNoZeros(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : big_loop_no_zeros_func\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "        points = 3 * np.array([UL, UR, DR, DL])\n",
        "        polygon = Polygon(*points)\n",
        "        polygon.color_using_background_image(self.background_image_file)\n",
        "        self.play(ShowCreation(polygon))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        polygon2 = polygon.copy()\n",
        "        polygon2.fill_opacity = 1\n",
        "        self.play(FadeIn(polygon2))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class ExamplePlaneFunc(ColorMappedByFuncScene):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False,\n",
        "        \"func\" : example_plane_func\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedByFuncScene.construct(self)\n",
        "\n",
        "        radius = 0.5\n",
        "\n",
        "        def circle_point(point):\n",
        "            circle = cw_circle.copy().scale(radius).move_to(point)\n",
        "            self.play(ShowCreation(circle))\n",
        "            return circle\n",
        "\n",
        "        def circle_spec(spec):\n",
        "            point = spec[0] * RIGHT + spec[1] * UP\n",
        "            return circle_point(point)\n",
        "\n",
        "        nonzero_point = ORIGIN # Manually chosen, not auto-synced with example_plane_func\n",
        "        nonzero_point_circle = circle_point(nonzero_point)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(nonzero_point_circle))\n",
        "        self.wait()\n",
        "\n",
        "        zero_circles = Group()\n",
        "\n",
        "        for spec in example_plane_func_spec:\n",
        "            zero_circles.add(circle_spec(spec))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # TODO: Fix the code in Fade to automatically propagate correctly \n",
        "        # to subobjects, even with special vectorized object handler. \n",
        "        # Also, remove the special handling from FadeOut, have it implemented\n",
        "        # solely through Fade.\n",
        "        #\n",
        "        # But for now, I'll just take care of this stuff myself here.\n",
        "        # self.play(*[FadeOut(zero_circle) for zero_circle in zero_circles])\n",
        "        self.play(FadeOut(zero_circles))\n",
        "        self.wait()\n",
        "\n",
        "        # We can reuse our nonzero point from before for \"Output doesn't go through ever color\"\n",
        "        # Do re-use in Premiere\n",
        "\n",
        "        # We can also re-use the first of our zero-circles for \"Output does go through every color\",\n",
        "        # but just in case it would be useful, here's another one, all on its own\n",
        "\n",
        "        specific_spec_index = 0\n",
        "        temp_circle = circle_spec(example_plane_func_spec[specific_spec_index])\n",
        "        self.play(FadeOut(temp_circle))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class PiWalkerExamplePlaneFunc(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False,\n",
        "        \"func\" : example_plane_func,\n",
        "        # These are just manually entered, not \n",
        "        # automatically kept in sync with example_plane_func:\n",
        "        \"start_x\" : -4,\n",
        "        \"start_y\" : 3,\n",
        "        \"walk_width\" : 8,\n",
        "        \"walk_height\" : 6,\n",
        "    }\n",
        "\n",
        "class NoticeHowOnThisLoop(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"show_num_plane\" : False,\n",
        "        \"func\" : example_plane_func,\n",
        "        # These are just manually entered, not \n",
        "        # automatically kept in sync with example_plane_func:\n",
        "        \"start_x\" : 0.5,\n",
        "        \"start_y\" : -0.5,\n",
        "        \"walk_width\" : -1, # We trace from bottom-right clockwise on this one, to start at a red point\n",
        "        \"walk_height\" : -1,\n",
        "    }\n",
        "\n",
        "class ButOnThisLoopOverHere(NoticeHowOnThisLoop):\n",
        "    CONFIG = {\n",
        "        # These are just manually entered, not \n",
        "        # automatically kept in sync with example_plane_func:\n",
        "        \"start_x\" : -1,\n",
        "        \"start_y\" : 0,\n",
        "        \"walk_width\" : 1,\n",
        "        \"walk_height\" : 1,\n",
        "    }\n",
        "\n",
        "class PiWalkerExamplePlaneFuncWithScaling(PiWalkerExamplePlaneFunc):\n",
        "    CONFIG = {\n",
        "        \"scale_arrows\" : True,\n",
        "        \"display_size\" : True,\n",
        "    }\n",
        "\n",
        "class TinyLoopOfBasicallySameColor(PureColorMap):\n",
        "    def construct(self):\n",
        "        PureColorMap.construct(self)\n",
        "        radius = 0.5\n",
        "        circle = cw_circle.copy().scale(radius).move_to(UP + RIGHT)\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "\n",
        "def uhOhFunc(xxx_todo_changeme11):\n",
        "    (x, y) = xxx_todo_changeme11\n",
        "    x = -np.clip(x, -5, 5)/5\n",
        "    y = -np.clip(y, -3, 3)/3\n",
        "\n",
        "    alpha = 0.5 # Most things will return green\n",
        "\n",
        "    # These next three things should really be abstracted into some \"Interpolated triangle\" function\n",
        "\n",
        "    if x >= 0 and y >= x and y <= 1:\n",
        "        alpha = interpolate(0.5, 1, y - x)\n",
        "\n",
        "    if x < 0 and y >= -2 * x and y <= 1:\n",
        "        alpha = interpolate(0.5, 1, y + 2 * x)\n",
        "\n",
        "    if x >= -1 and y >= 2 * (x + 1) and y <= 1:\n",
        "        alpha = interpolate(0.5, 0, y - 2 * (x + 1))\n",
        "\n",
        "    return complex_to_pair(100 * np.exp(complex(0, TAU * (0.5 - alpha))))\n",
        "\n",
        "class UhOhFuncTest(PureColorMap):\n",
        "    CONFIG = {\n",
        "        \"func\" : uhOhFunc\n",
        "    }\n",
        "\n",
        "\n",
        "class UhOhScene(EquationSolver2d):\n",
        "    CONFIG = {\n",
        "        \"func\" : uhOhFunc,\n",
        "        \"manual_wind_override\" : (1, None, (1, None, (1, None, None))), # Tailored to UhOhFunc above\n",
        "        \"show_winding_numbers\" : False,\n",
        "        \"num_iterations\" : 5,\n",
        "    }\n",
        "\n",
        "class UhOhSceneWithWindingNumbers(UhOhScene):\n",
        "    CONFIG = {\n",
        "        \"show_winding_numbers\" : True,\n",
        "    }\n",
        "\n",
        "class UhOhSceneWithWindingNumbersNoOverride(UhOhSceneWithWindingNumbers):\n",
        "    CONFIG = {\n",
        "        \"manual_wind_override\" : None,\n",
        "        \"num_iterations\" : 2\n",
        "    }\n",
        "\n",
        "class UhOhSalientStill(ColorMappedObjectsScene):\n",
        "    CONFIG = {\n",
        "        \"func\" : uhOhFunc\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        ColorMappedObjectsScene.construct(self)\n",
        "\n",
        "        new_up = 3 * UP\n",
        "        new_left = 5 * LEFT\n",
        "\n",
        "        thin_line = Line(UP, RIGHT, color = WHITE)\n",
        "\n",
        "        main_points = [new_left + new_up, new_up, ORIGIN, new_left]\n",
        "        polygon = Polygon(*main_points, stroke_width = border_stroke_width)\n",
        "        thin_polygon = polygon.copy().match_style(thin_line)\n",
        "        polygon.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        midline = Line(new_up + 0.5 * new_left, 0.5 * new_left, stroke_width = border_stroke_width)\n",
        "        thin_midline = midline.copy().match_style(thin_line)\n",
        "        midline.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        self.add(polygon, midline)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        everything_filler = FullScreenFadeRectangle(fill_opacity = 1)\n",
        "        everything_filler.color_using_background_image(self.background_image_file)\n",
        "\n",
        "        thin_white_copy = Group(thin_polygon, thin_midline)\n",
        "\n",
        "        self.play(FadeIn(everything_filler), FadeIn(thin_white_copy))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# TODO: Brouwer's fixed point theorem visuals\n",
        "# class BFTScene(Scene):\n",
        "\n",
        "# TODO: Pi creatures wide-eyed in amazement\n",
        "\n",
        "#################\n",
        "\n",
        "# TODOs, from easiest to hardest:\n",
        "\n",
        "# Minor fiddling with little things in each animation; placements, colors, timing, text\n",
        "\n",
        "# Initial odometer scene (simple once previous Pi walker scene is decided upon)\n",
        "\n",
        "# Writing new Pi walker scenes by parametrizing general template\n",
        "\n",
        "# (All the above are basically trivial tinkering at this point)\n",
        "\n",
        "# ----\n",
        "\n",
        "# Pi creature emotion stuff\n",
        "\n",
        "# BFT visuals\n",
        "\n",
        "# Borsuk-Ulam visuals\n",
        "\n",
        "####################\n",
        "\n",
        "# Random test scenes and test functions go here:\n",
        "\n",
        "def rect_to_circle(xxx_todo_changeme12):\n",
        "    (x, y, z) = xxx_todo_changeme12\n",
        "    size = np.sqrt(x**2 + y**2)\n",
        "    max_abs_size = max(abs(x), abs(y))\n",
        "    return fdiv(np.array((x, y, z)) * max_abs_size, size)\n",
        "\n",
        "class MapPiWalkerRect(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : MappingCamera,\n",
        "        \"camera_config\" : {\"mapping_func\" : rect_to_circle},\n",
        "        \"show_output\" : True\n",
        "    }\n",
        "\n",
        "class ShowBack(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "         \"func\" : plane_func_by_wind_spec((1, 2), (-1, 1.5), (-1, 1.5))\n",
        "    }\n",
        "\n",
        "class PiWalkerOdometerTest(PiWalkerExamplePlaneFunc):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True\n",
        "    }\n",
        "\n",
        "class PiWalkerFancyLineTest(PiWalkerExamplePlaneFunc):\n",
        "    CONFIG = {\n",
        "        \"color_foreground_not_background\" : True\n",
        "    }\n",
        "\n",
        "class NotFoundScene(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"SCENE NOT FOUND!\"))\n",
        "        self.wait()\n",
        "\n",
        "criticalStripYScale = 100\n",
        "criticalStrip = Axes(x_min = -0.5, x_max = 1.5, x_axis_config = {\"unit_size\" : FRAME_X_RADIUS, \n",
        "    \"number_at_center\" : 0.5}, \n",
        "    y_min = -criticalStripYScale, y_max = criticalStripYScale, \n",
        "    y_axis_config = {\"unit_size\" : fdiv(FRAME_Y_RADIUS, criticalStripYScale)})\n",
        "\n",
        "class ZetaViz(PureColorMap):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_zeta,\n",
        "        #\"num_plane\" : criticalStrip,\n",
        "        \"show_num_plane\" : True\n",
        "    }\n",
        "\n",
        "class TopLabel(Scene):\n",
        "    CONFIG = {\n",
        "        \"text\" : \"Text\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        label = OldTexText(self.text)\n",
        "        label.move_to(3 * UP)\n",
        "        self.add(label)\n",
        "        self.wait()\n",
        "\n",
        "# This is a giant hack that doesn't handle rev wrap-around correctly; should use \n",
        "# make_alpha_winder instead\n",
        "class SpecifiedWinder(PiWalker):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 0,\n",
        "        \"start_y\" : 0,\n",
        "        \"x_wind\" : 1, # Assumed positive\n",
        "        \"y_wind\" : 1, # Assumed positive\n",
        "        \"step_size\" : 0.1\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        rev_func = lambda p : point_to_rev(self.func(p))\n",
        "        start_pos = np.array((self.start_x, self.start_y))\n",
        "        cur_pos = start_pos.copy()\n",
        "        start_rev = rev_func(start_pos)\n",
        "\n",
        "        mid_rev = start_rev\n",
        "        while (abs(mid_rev - start_rev) < self.x_wind):\n",
        "            cur_pos += (self.step_size, 0)\n",
        "            mid_rev = rev_func(cur_pos)\n",
        "\n",
        "        print(\"Reached \", cur_pos, \", with rev \", mid_rev - start_rev)\n",
        "        mid_pos = cur_pos.copy()\n",
        "\n",
        "        end_rev = mid_rev\n",
        "        while (abs(end_rev - mid_rev) < self.y_wind):\n",
        "            cur_pos -= (0, self.step_size)\n",
        "            end_rev = rev_func(cur_pos)\n",
        "\n",
        "        end_pos = cur_pos.copy()\n",
        "\n",
        "        print(\"Reached \", cur_pos, \", with rev \", end_rev - mid_rev)\n",
        "\n",
        "        self.walk_coords = [start_pos, mid_pos, end_pos]\n",
        "        print(\"Walk coords: \", self.walk_coords)\n",
        "        PiWalker.setup(self)\n",
        "\n",
        "class OneFifthTwoFifthWinder(SpecifiedWinder):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"start_x\" : -2.0,\n",
        "        \"start_y\" : 1.0,\n",
        "        \"x_wind\" : 0.2,\n",
        "        \"y_wind\" : 0.2,\n",
        "        \"step_size\" : 0.01,\n",
        "        \"show_num_plane\" : False,\n",
        "        \"step_run_time\" : 6,\n",
        "        \"num_decimal_places\" : 2,\n",
        "    }\n",
        "\n",
        "class OneFifthOneFifthWinderWithReset(OneFifthTwoFifthWinder):\n",
        "    CONFIG = {\n",
        "        \"wind_reset_indices\" : [1]\n",
        "    }\n",
        "\n",
        "class OneFifthTwoFifthWinderOdometer(OneFifthTwoFifthWinder):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class ForwardBackWalker(PiWalker):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"walk_coords\" : [np.array((-2, 1)), np.array((1, 1))],\n",
        "        \"step_run_time\" : 3,\n",
        "    }\n",
        "\n",
        "class ForwardBackWalkerOdometer(ForwardBackWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class PureOdometerBackground(OdometerScene):\n",
        "    CONFIG = {\n",
        "        \"pure_odometer_background\" : True\n",
        "    }\n",
        "\n",
        "class CWColorWalk(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"func\" : example_plane_func,\n",
        "        \"start_x\" : example_plane_func_spec[0][0] - 1,\n",
        "        \"start_y\" : example_plane_func_spec[0][1] + 1,\n",
        "        \"walk_width\" : 2,\n",
        "        \"walk_height\" : 2,\n",
        "        \"draw_lines\" : False,\n",
        "        \"display_wind\" : False,\n",
        "        \"step_run_time\" : 2\n",
        "    }\n",
        "\n",
        "class CWColorWalkOdometer(CWColorWalk):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class CCWColorWalk(CWColorWalk):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : example_plane_func_spec[2][0] - 1,\n",
        "        \"start_y\" : example_plane_func_spec[2][1] + 1,\n",
        "    }\n",
        "\n",
        "class CCWColorWalkOdometer(CCWColorWalk):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class ThreeTurnWalker(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c: c**3 * complex(1, 1)**3),\n",
        "        \"double_up\" : True,\n",
        "        \"wind_reset_indices\" : [4]\n",
        "    }\n",
        "\n",
        "class ThreeTurnWalkerOdometer(ThreeTurnWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class FourTurnWalker(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec((0, 0, 4))\n",
        "    }\n",
        "\n",
        "class FourTurnWalkerOdometer(FourTurnWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class OneTurnWalker(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_from_complex_func(lambda c : np.exp(c) + c)\n",
        "    }\n",
        "\n",
        "class OneTurnWalkerOdometer(OneTurnWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class ZeroTurnWalker(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"func\" : plane_func_by_wind_spec((2, 2, 1), (-1, 2, -1))\n",
        "    }\n",
        "\n",
        "class ZeroTurnWalkerOdometer(ZeroTurnWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "class NegOneTurnWalker(PiWalkerRect):\n",
        "    CONFIG = {\n",
        "        \"step_run_time\" : 2,\n",
        "        \"func\" : plane_func_by_wind_spec((0, 0, -1))\n",
        "    }\n",
        "\n",
        "class NegOneTurnWalkerOdometer(NegOneTurnWalker):\n",
        "    CONFIG = {\n",
        "        \"display_odometer\" : True,\n",
        "    }\n",
        "\n",
        "# FIN"
    ]
}