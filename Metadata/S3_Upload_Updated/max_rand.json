{
    "topic": "The mathematical concept being demonstrated is the concept of randomness and its relationship to probability theory. The code",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class Randomize(Animation):\n",
        "    def __init__(self, value_tracker, frequency=8, rand_func=random.random, final_value=None, **kwargs):\n",
        "        self.value_tracker = value_tracker\n",
        "        self.rand_func = rand_func\n",
        "        self.frequency = frequency\n",
        "        self.final_value = final_value if final_value is not None else rand_func()\n",
        "\n",
        "        self.last_alpha = 0\n",
        "        self.running_tally = 0\n",
        "        super().__init__(value_tracker, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        if not self.new_step(alpha):\n",
        "            return\n",
        "\n",
        "        value = self.rand_func() if alpha < 1 else self.final_value\n",
        "        self.value_tracker.set_value(value)\n",
        "\n",
        "    def new_step(self, alpha):\n",
        "        d_alpha = alpha - self.last_alpha\n",
        "        self.last_alpha = alpha\n",
        "        self.running_tally += self.frequency * d_alpha * self.run_time\n",
        "        if self.running_tally > 1:\n",
        "            self.running_tally = self.running_tally % 1\n",
        "            return True\n",
        "        return False\n",
        "\n",
        "\n",
        "class TrackingDots(Animation):\n",
        "    def __init__(self, point_func, fade_factor=0.95, radius=0.25, color=YELLOW, **kwargs):\n",
        "        self.point_func = point_func\n",
        "        self.fade_factor = fade_factor\n",
        "        self.dots = GlowDot(point_func(), color=color, radius=radius)\n",
        "        kwargs.update(remover=True)\n",
        "        super().__init__(self.dots, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        opacities = self.dots.get_opacities()\n",
        "        point = self.point_func()\n",
        "        if not np.isclose(self.dots.get_end(), point).all():\n",
        "            self.dots.add_point(point)\n",
        "            opacities = np.hstack([opacities, [1]])\n",
        "        opacities *= self.fade_factor\n",
        "        self.dots.set_opacity(opacities)\n",
        "\n",
        "\n",
        "def get_random_var_label_group(axis, label_name, color=GREY, initial_value=None, font_size=36, direction=None):\n",
        "    if initial_value is None:\n",
        "        initial_value = random.uniform(*axis.x_range[:2])\n",
        "    tracker = ValueTracker(initial_value)\n",
        "    tip = ArrowTip(angle=90 * DEGREES)\n",
        "    tip.set_height(0.15)\n",
        "    tip.set_fill(color)\n",
        "    tip.rotate(-axis.get_angle())\n",
        "    if direction is None:\n",
        "        direction = np.round(rotate_vector(UP, -axis.get_angle()), 1)\n",
        "    tip.add_updater(lambda m: m.move_to(axis.n2p(tracker.get_value()), direction))\n",
        "    label = Tex(label_name, font_size=font_size)\n",
        "    label.set_color(color)\n",
        "    label.set_backstroke(BLACK, 5)\n",
        "    label.always.next_to(tip, -direction, buff=0.1)\n",
        "\n",
        "    return Group(tracker, tip, label)\n",
        "\n",
        "\n",
        "class MaxProcess(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up intervals\n",
        "        intervals = VGroup(UnitInterval() for _ in range(3))\n",
        "        intervals.set_width(3)\n",
        "        intervals.arrange(DOWN, buff=2.5)\n",
        "        intervals.shift(2 * LEFT)\n",
        "        intervals[1].shift(0.5 * UP)\n",
        "        for interval in intervals:\n",
        "            interval.add_numbers(np.arange(0, 1.1, 0.2), font_size=16, buff=0.1, direction=UP)\n",
        "            interval.numbers.set_opacity(0.75)\n",
        "\n",
        "        colors = [BLUE, YELLOW, GREEN]\n",
        "        x1_group, x2_group, max_group = groups = Group(\n",
        "            get_random_var_label_group(interval, \"\", color=color)\n",
        "            for interval, color in zip(intervals, colors)\n",
        "        )\n",
        "        x1_tracker, x1_tip, x1_label = x1_group\n",
        "        x2_tracker, x2_tip, x2_label = x2_group\n",
        "        max_tracker, max_tip, max_label = max_group\n",
        "        max_tracker.add_updater(lambda m: m.set_value(max(x1_tracker.get_value(), x2_tracker.get_value())))\n",
        "\n",
        "        self.add(intervals)\n",
        "        self.add(groups)\n",
        "\n",
        "        # Add labels\n",
        "        tex_to_color = {\"x_1\": BLUE, \"x_2\": YELLOW}\n",
        "        labels = VGroup(\n",
        "            Tex(tex + R\"\\rightarrow 0.00\", t2c=tex_to_color)\n",
        "            for tex in [\n",
        "                R\"x_1 = \\text{rand}()\",\n",
        "                R\"x_2 = \\text{rand}()\",\n",
        "                R\"\\max(x_1, x_2)\",\n",
        "            ]\n",
        "        )\n",
        "        for label, group, interval in zip(labels, groups, intervals):\n",
        "            label.next_to(interval, RIGHT, buff=0.5)\n",
        "            num = label.make_number_changeable(\"0.00\")\n",
        "            num.tracker = group[0]\n",
        "            num.add_updater(lambda m: m.set_value(m.tracker.get_value()))\n",
        "\n",
        "        self.add(labels)\n",
        "\n",
        "        # Add rectangles\n",
        "        top_rect = SurroundingRectangle(intervals[:2], buff=0.25)\n",
        "        top_rect.stretch(1.1, 1)\n",
        "        top_rect.set_stroke(WHITE, 2)\n",
        "        top_rect.set_fill(GREY_E, 1)\n",
        "\n",
        "        arrow = Vector(1.5 * DOWN, thickness=5)\n",
        "        arrow.next_to(top_rect, DOWN)\n",
        "        arrow_label = Text(\"max\", font_size=60)\n",
        "        arrow_label.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.add(top_rect, intervals, groups)\n",
        "        self.add(arrow, arrow_label)\n",
        "\n",
        "        # Line\n",
        "        def get_line():\n",
        "            x1 = x1_tracker.get_value()\n",
        "            x2 = x2_tracker.get_value()\n",
        "            tip = x1_tip if x1 > x2 else x2_tip\n",
        "            line = DashedLine(max_tip.get_top(), tip.get_top())\n",
        "            line.set_stroke(GREY, 2, opacity=0.5)\n",
        "            return line\n",
        "\n",
        "        line = always_redraw(get_line)\n",
        "        self.add(line)\n",
        "\n",
        "        # Animate\n",
        "        self.play(\n",
        "            Randomize(x1_tracker, frequency=4, run_time=30),\n",
        "            Randomize(x2_tracker, frequency=4, run_time=30),\n",
        "            TrackingDots(x1_tip.get_top, color=BLUE),\n",
        "            TrackingDots(x2_tip.get_top, color=YELLOW),\n",
        "            TrackingDots(max_tip.get_top, color=GREEN),\n",
        "        )\n",
        "\n",
        "\n",
        "class SqrtProcess(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # A fair bit of copy pasting from above\n",
        "        # Set up intervals\n",
        "        intervals = VGroup(UnitInterval() for _ in range(2))\n",
        "        intervals.set_width(3)\n",
        "        intervals.arrange(DOWN, buff=3.5)\n",
        "        intervals.shift(2 * LEFT)\n",
        "        for interval in intervals:\n",
        "            interval.add_numbers(np.arange(0, 1.1, 0.2), font_size=16, buff=0.1, direction=UP)\n",
        "            interval.numbers.set_opacity(0.75)\n",
        "\n",
        "        colors = [BLUE, TEAL]\n",
        "        x_group, sqrt_group = groups = Group(\n",
        "            get_random_var_label_group(interval, \"\", color=color)\n",
        "            for interval, color in zip(intervals, colors)\n",
        "        )\n",
        "        x_tracker, x_tip, x_label = x_group\n",
        "        sqrt_tracker, sqrt_tip, sqrt_label = sqrt_group\n",
        "        sqrt_tracker.add_updater(lambda m: m.set_value(math.sqrt(x_tracker.get_value())))\n",
        "\n",
        "        self.add(intervals)\n",
        "        self.add(groups)\n",
        "\n",
        "        # Add labels\n",
        "        tex_to_color = {\"x\": BLUE}\n",
        "        labels = VGroup(\n",
        "            Tex(tex + R\"\\rightarrow 0.00\", t2c=tex_to_color)\n",
        "            for tex in [\n",
        "                R\"x = \\text{rand}()\",\n",
        "                R\"\\sqrt{x}\",\n",
        "            ]\n",
        "        )\n",
        "        for label, group, interval in zip(labels, groups, intervals):\n",
        "            label.next_to(interval, RIGHT, buff=0.5)\n",
        "            num = label.make_number_changeable(\"0.00\")\n",
        "            num.tracker = group[0]\n",
        "            num.add_updater(lambda m: m.set_value(m.tracker.get_value()))\n",
        "\n",
        "        self.add(labels)\n",
        "\n",
        "        # Big arrow\n",
        "        arrow = Arrow(*intervals, buff=0.5, thickness=5)\n",
        "        label = Text(R\"sqrt\", font_size=60)\n",
        "        label.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.add(arrow, label)\n",
        "\n",
        "        # Animate\n",
        "        self.play(\n",
        "            Randomize(x_tracker, frequency=4, run_time=30),\n",
        "            TrackingDots(x_tip.get_top, color=colors[0]),\n",
        "            TrackingDots(sqrt_tip.get_top, color=colors[1]),\n",
        "        )\n",
        "\n",
        "\n",
        "class SquareAndSquareRoot(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        lines = VGroup(\n",
        "            Tex(R\"\\left(\\frac{1}{2}\\right)^2 = \\frac{1}{4}\"),\n",
        "            Tex(R\"\\sqrt{\\frac{1}{4}} = \\frac{1}{2}\"),\n",
        "        )\n",
        "        lines.scale(1.5)\n",
        "\n",
        "        self.play(FadeIn(lines[0]))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingStrings(\n",
        "            *lines,\n",
        "            matched_pairs=[(lines[0][\"2\"][1], lines[1][R\"\\sqrt\"][0])],\n",
        "            path_arc=PI / 2,\n",
        "        ))\n",
        "\n",
        "\n",
        "class GawkAtEquivalence(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        expr = VGroup(\n",
        "            Text(\"max(rand(), rand())\"),\n",
        "            Tex(R\"\\updownarrow\", font_size=90),\n",
        "            Text(\"sqrt(rand())\"),\n",
        "        )\n",
        "        expr.arrange(DOWN)\n",
        "        expr.to_edge(UP)\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.add(expr)\n",
        "        self.play(randy.change(\"confused\", expr))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change(\"maybe\", expr))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VisualizeMaxOfPairCDF(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup axes and trackers\n",
        "        axes = Axes((0, 1, 0.1), (0, 1, 0.1), width=6, height=6)\n",
        "        axes.add_coordinate_labels(\n",
        "            (0, 0.5, 1.0), (0.5, 1.0),\n",
        "            excluding=[],\n",
        "            num_decimal_places=1,\n",
        "            buff=0.15,\n",
        "            font_size=16\n",
        "        )\n",
        "        x1_tracker, x1_tip, x1_label = get_random_var_label_group(axes.x_axis, \"x_1\", BLUE, 0.7)\n",
        "        x2_tracker, x2_tip, x2_label = get_random_var_label_group(axes.y_axis, \"x_2\", YELLOW, 0.3)\n",
        "        tex_to_color = {\"x_1\": BLUE, \"x_2\": YELLOW}\n",
        "\n",
        "        # Show x1\n",
        "        self.add(axes.x_axis)\n",
        "        self.play(\n",
        "            FadeIn(x1_tip),\n",
        "            FadeIn(x1_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Randomize(x1_tracker, run_time=8),\n",
        "            TrackingDots(x1_tip.get_top, run_time=10, color=BLUE),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight a given range\n",
        "        eq = Tex(R\"P(a < x_1 < b) = b - a\")\n",
        "        rect = SurroundingRectangle(axes.x_axis.ticks)\n",
        "        rect.set_fill(BLUE, 0.5)\n",
        "        rect.set_stroke(WHITE, 0)\n",
        "        rect.stretch(0.25, 0)\n",
        "        rect.move_to(x1_tip.get_top())\n",
        "        eq.next_to(rect, UP)\n",
        "        eq.shift((rect.get_x() - eq[\"x_1\"].get_x()) * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(eq, 0.25 * UP)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            FadeOut(eq),\n",
        "        )\n",
        "\n",
        "        # Show x2\n",
        "        self.play(\n",
        "            FadeIn(axes.y_axis),\n",
        "            Write(x2_tip),\n",
        "            Write(x2_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Randomize(x2_tracker, run_time=8, final_value=0.48),\n",
        "            TrackingDots(x2_tip.get_right, run_time=10, color=YELLOW),\n",
        "        )\n",
        "\n",
        "        # Show the pair inside the square\n",
        "        def get_xy_point():\n",
        "            return axes.c2p(x1_tracker.get_value(), x2_tracker.get_value())\n",
        "\n",
        "        v_line = Line().set_stroke(WHITE, 1, 0.5)\n",
        "        h_line = Line().set_stroke(WHITE, 1, 0.5)\n",
        "        v_line.f_always.put_start_and_end_on(x1_tip.get_top, get_xy_point)\n",
        "        h_line.f_always.put_start_and_end_on(x2_tip.get_right, get_xy_point)\n",
        "\n",
        "        xy_dot = Dot(radius=0.05)\n",
        "        xy_dot.f_always.move_to(get_xy_point)\n",
        "        xy_dot.update()\n",
        "\n",
        "        coord_label = Tex(\"(x_1, x_2)\", t2c=tex_to_color, font_size=36)\n",
        "        coord_label.always.next_to(xy_dot, UR, SMALL_BUFF)\n",
        "        coord_label.update()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            ShowCreation(h_line),\n",
        "            FadeIn(xy_dot),\n",
        "            FadeIn(coord_label[0::3]),\n",
        "            FadeTransform(x1_label.copy(), coord_label[\"x_1\"], remover=True),\n",
        "            FadeTransform(x2_label.copy(), coord_label[\"x_2\"], remover=True),\n",
        "        )\n",
        "        self.add(coord_label)\n",
        "        self.wait()\n",
        "\n",
        "        # Randomize it\n",
        "        big_square = Square()\n",
        "        big_square.set_fill(GREY_E, 1)\n",
        "        big_square.set_stroke(GREY_D, 1)\n",
        "        big_square.replace(Line(axes.c2p(0, 0), axes.c2p(1, 1)))\n",
        "\n",
        "        self.add(big_square, *self.mobjects)\n",
        "        self.play(\n",
        "            FadeIn(big_square, run_time=2),\n",
        "            Randomize(x2_tracker, run_time=6, frequency=8, final_value=0.69),\n",
        "            Randomize(x1_tracker, run_time=6, frequency=8, final_value=0.42),\n",
        "            TrackingDots(get_xy_point, run_time=9, fade_factor=0.97, color=GREEN),\n",
        "        )\n",
        "\n",
        "        # Bring up max(x1, x2), show where its true\n",
        "        max_expr = Tex(R\"\\max(x_1, x_2) = 0.7\", t2c=tex_to_color)\n",
        "        max_expr.to_corner(UR)\n",
        "\n",
        "        max_lines = VGroup(\n",
        "            Line(axes.c2p(0.7, 0.7), axes.c2p(0.7, 0)),\n",
        "            Line(axes.c2p(0.7, 0.7), axes.c2p(0, 0.7)),\n",
        "        )\n",
        "        max_lines.set_stroke(GREEN, 3)\n",
        "\n",
        "        self.play(FadeIn(max_expr, UP))\n",
        "        self.play(\n",
        "            x1_tracker.animate.set_value(0.7),\n",
        "            x2_tracker.animate.set_value(0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "        for tracker, line in zip([x2_tracker, x1_tracker], max_lines):\n",
        "            self.add(line, xy_dot)\n",
        "            self.play(\n",
        "                tracker.animate.set_value(0),\n",
        "                ShowCreation(line),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.play(tracker.animate.set_value(0.7), run_time=3)\n",
        "            self.wait()\n",
        "\n",
        "        # Ask about probability\n",
        "        prob_eq = Tex(R\"P(\\max(x_1, x_2) = 0.7)\", t2c=tex_to_color)\n",
        "        prob_ineq = Tex(R\"P(\\max(x_1, x_2) \\le 0.7)\", t2c=tex_to_color)\n",
        "        gen_prob_ineq = Tex(R\"P(\\max(x_1, x_2) \\le R)\", t2c=tex_to_color)\n",
        "        cdf_expr = Tex(R\"P(\\max(x_1, x_2) \\le R) = R^2\", t2c=tex_to_color)\n",
        "        for tex in [prob_eq, prob_ineq, gen_prob_ineq, cdf_expr]:\n",
        "            tex.to_corner(UR)\n",
        "            tex.shift(0.5 * UP)\n",
        "\n",
        "        words = Text(\"Not helpful\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(prob_eq, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingStrings(max_expr, prob_eq),\n",
        "            self.frame.animate.move_to(0.5 * UP),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            max_lines.animate.set_stroke(width=0.1).set_anim_args(rate_func=there_and_back),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Go from P(x = r) to P(x <= r)\n",
        "        eq_rect = SurroundingRectangle(prob_eq[\"=\"])\n",
        "        eq_rect.set_color(RED)\n",
        "\n",
        "        inner_lines = VGroup(\n",
        "            max_lines.copy().scale(sf, about_point=axes.get_origin()).set_stroke(width=2, opacity=0.5)\n",
        "            for sf in np.linspace(1, 0, 100)\n",
        "        )\n",
        "        inner_square = Square()\n",
        "        inner_square.set_fill(GREEN, 0.35)\n",
        "        inner_square.set_stroke(GREEN, 0)\n",
        "        inner_square.replace(max_lines)\n",
        "\n",
        "        self.play(FadeTransform(words, eq_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(prob_eq, prob_ineq, key_map={\"=\": R\"\\le\"}),\n",
        "            eq_rect.animate.surround(prob_ineq[R\"\\le\"]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (ReplacementTransform(max_lines.copy().set_stroke(opacity=0), mlc)\n",
        "                for mlc in inner_lines),\n",
        "                lag_ratio=0.01,\n",
        "                run_time=8\n",
        "            ),\n",
        "            Animation(xy_dot),\n",
        "            FadeOut(eq_rect),\n",
        "        )\n",
        "        self.add(inner_lines, inner_square, h_line, v_line, xy_dot, coord_label)\n",
        "        self.play(\n",
        "            FadeIn(inner_square),\n",
        "            FadeOut(inner_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Randomize(x1_tracker, run_time=4, frequency=8, final_value=0.38),\n",
        "            Randomize(x2_tracker, run_time=4, frequency=8, final_value=0.42),\n",
        "            TrackingDots(get_xy_point, run_time=6, fade_factor=0.97, color=GREEN),\n",
        "        )\n",
        "\n",
        "        # Describe CDF\n",
        "        self.play(TransformMatchingStrings(prob_ineq, gen_prob_ineq, key_map={\"0.7\": \"R\"}, run_time=1))\n",
        "        self.play(TransformMatchingStrings(gen_prob_ineq, cdf_expr, run_time=1))\n",
        "        self.play(\n",
        "            VGroup(inner_square, max_lines).animate.scale(0.5, about_edge=DL).set_anim_args(rate_func=there_and_back),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Make way\n",
        "        shift_value = 3 * RIGHT\n",
        "        self.play(\n",
        "            cdf_expr.animate.shift(5 * RIGHT + UP),\n",
        "            self.frame.animate.shift(4.5 * RIGHT).scale(1.2),\n",
        "        )\n",
        "\n",
        "        # Comapare to the sqrt case\n",
        "        sqrt_lines = VGroup(\n",
        "            Tex(R\"P(\\sqrt{x_1} \\le R)\", t2c=tex_to_color),\n",
        "            Tex(R\"P(x_1 \\le R^2)\", t2c=tex_to_color),\n",
        "            Tex(R\"= R^2\", t2c=tex_to_color),\n",
        "        )\n",
        "        sqrt_lines.arrange(DOWN, buff=1.0, aligned_edge=LEFT)\n",
        "        sqrt_lines.next_to(cdf_expr, DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        sqrt_lines[2].next_to(sqrt_lines[1], RIGHT)\n",
        "        mid_eq = Tex(\"=\").rotate(90 * DEGREES).move_to(sqrt_lines[:2])\n",
        "\n",
        "        self.play(Write(sqrt_lines[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(sqrt_lines[0].copy(), sqrt_lines[1]),\n",
        "            Write(mid_eq),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(sqrt_lines[2]))\n",
        "        self.wait()\n",
        "\n",
        "        # Go to three dimensions\n",
        "        frame = self.frame\n",
        "        axes3d = ThreeDAxes((0, 1, 0.1), (0, 1, 0.1), (0, 1, 0.1))\n",
        "        axes3d.set_width(axes.x_axis.get_length())\n",
        "        axes3d.shift(axes.get_origin() - axes3d.get_origin())\n",
        "        z_axis = axes3d.z_axis\n",
        "        z_axis.set_width(axes.x_axis.ticks.get_height(), stretch=True)\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(-1 * DEGREES)\n",
        "\n",
        "        # self.add(cdf_expr, Point())\n",
        "        self.remove(cdf_expr, sqrt_lines, mid_eq)\n",
        "        frame.center()\n",
        "        self.play(\n",
        "            # FadeOut(sqrt_lines),\n",
        "            # FadeOut(mid_eq),\n",
        "            # cdf_expr.animate.fix_in_frame().center().to_edge(UP),\n",
        "            # FadeOut(cdf_expr),\n",
        "            Write(axes3d.z_axis),\n",
        "            frame.animate.reorient(26, 74, 0, (-0.42, 0.83, 1.66), 10.11),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Add cube\n",
        "        tex_to_color[\"x_3\"] = RED\n",
        "        new_cdf_expr = Tex(R\"P(\\max(x_1, x_2, x_3) \\le R) = R^3\", t2c=tex_to_color)\n",
        "        new_cdf_expr.fix_in_frame()\n",
        "        new_cdf_expr.move_to(cdf_expr, RIGHT)\n",
        "\n",
        "        width = inner_square.get_width()\n",
        "        cube = VGroup(\n",
        "            inner_square.copy().shift(width * OUT),\n",
        "            inner_square.copy().rotate(PI / 2, LEFT, about_edge=UP),\n",
        "            inner_square.copy().rotate(PI / 2, UP, about_edge=RIGHT),\n",
        "            inner_square.copy().rotate(PI / 2, DOWN, about_edge=LEFT),\n",
        "            inner_square.copy().rotate(PI / 2, RIGHT, about_edge=DOWN),\n",
        "        )\n",
        "        cube.set_stroke(GREEN, 3)\n",
        "        cube.set_fill(GREEN, 0.2)\n",
        "        cube.save_state()\n",
        "        cube.stretch(0, 2, about_edge=IN)\n",
        "        cube.set_fill(opacity=0)\n",
        "        cube[0].set_fill(opacity=0.35)\n",
        "\n",
        "        x3_tracker, x3_tip, x3_label = get_random_var_label_group(z_axis, \"x_3\", color=RED, direction=RIGHT)\n",
        "        x3_tracker.set_value(0.2)\n",
        "        VGroup(x3_tip, x3_label).rotate(PI / 2, RIGHT)\n",
        "        x3_tip.rotate(PI / 2, UP)\n",
        "\n",
        "        def get_xzy_point():\n",
        "            return axes3d.c2p(\n",
        "                x1_tracker.get_value(),\n",
        "                x2_tracker.get_value(),\n",
        "                x3_tracker.get_value(),\n",
        "            )\n",
        "\n",
        "        xyz_dot = TrueDot().make_3d()\n",
        "        xyz_dot.add_updater(lambda m: m.move_to(get_xzy_point()))\n",
        "\n",
        "        self.remove(max_lines)\n",
        "        self.remove(inner_square)\n",
        "        self.play(\n",
        "            FadeIn(x3_tip),\n",
        "            FadeIn(x3_label),\n",
        "            Restore(cube),\n",
        "            # FadeTransform(cdf_expr, new_cdf_expr, time_span=(1, 2)),\n",
        "            FadeOut(h_line),\n",
        "            FadeOut(v_line),\n",
        "            FadeOut(coord_label),\n",
        "            FadeTransform(Group(xy_dot), xyz_dot),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Randomize(x1_tracker, run_time=16),\n",
        "            Randomize(x2_tracker, run_time=16),\n",
        "            Randomize(x3_tracker, run_time=16),\n",
        "            TrackingDots(get_xzy_point, run_time=20, color=GREEN, radius=0.15),\n",
        "        )\n",
        "\n",
        "\n",
        "class MaxOfThreeTex(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        expr = TexText(R\"max(rand(), rand(), rand()) $\\leftrightarrow$ rand()$^{1 / 3}$\")\n",
        "        expr[\"rand()\"].set_submobject_colors_by_gradient(BLUE, YELLOW, RED, BLUE)\n",
        "        self.play(Write(expr))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Arrows(InteractiveScene):\n",
        "    def construct(self):\n",
        "        arrows = Vector(DOWN, thickness=5).replicate(3)\n",
        "        arrows.arrange(RIGHT, buff=1.0)\n",
        "        arrows.set_fill(YELLOW)\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows))\n",
        "        self.wait()\n"
    ]
}