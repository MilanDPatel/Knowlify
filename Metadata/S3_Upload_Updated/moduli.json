{
    "topic": "the concept of a moduli space for triangles up to similarity.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class TriangleModuliSpace(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"background_image\": \"chalkboard\",\n",
        "        },\n",
        "        \"degen_color\": GREEN_D,\n",
        "        \"x1_color\": GREEN_B,\n",
        "        \"y1_color\": RED,\n",
        "        \"x_eq_y_color\": YELLOW,\n",
        "        \"right_color\": TEAL,\n",
        "        \"obtuse_color\": PINK,\n",
        "        \"acute_color\": GREEN,\n",
        "        \"triangle_fill_opacity\": 0.5,\n",
        "        \"random_seed\": 0,\n",
        "        \"example_triangle_width\": 6,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.plane = NumberPlane(\n",
        "            axis_config={\n",
        "                \"unit_size\": 2,\n",
        "            }\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_meaning_of_similar()\n",
        "        self.show_xy_rule()\n",
        "\n",
        "    def show_meaning_of_similar(self):\n",
        "        # Setup titles\n",
        "        title = OldTexText(\"Space\", \" of all \", \"triangles\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        subtitle = OldTexText(\"up to similarity.\")\n",
        "        subtitle.scale(1.5)\n",
        "        subtitle.next_to(title, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        question = OldTexText(\"What \", \"is \", \"a\\\\\\\\\", \"moduli \", \"space\", \"?\")\n",
        "        question.scale(2)\n",
        "\n",
        "        # Setup all triangles\n",
        "        all_triangles, tri_classes = self.get_triangles_and_classes()\n",
        "        tri_classes[2][1].scale(0.5)\n",
        "        tri_classes[2][1].scalar *= 0.5\n",
        "\n",
        "        all_triangles.to_edge(DOWN)\n",
        "\n",
        "        # Triangles pop up...\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, question),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                question.get_part_by_tex(\"space\"),\n",
        "                title.get_part_by_tex(\"Space\"),\n",
        "            ),\n",
        "            FadeOut(question[:-2]),\n",
        "            FadeOut(question[-1]),\n",
        "            FadeIn(title[1:]),\n",
        "            LaggedStartMap(\n",
        "                DrawBorderThenFill, all_triangles,\n",
        "                rate_func=bezier([0, 0, 1.5, 1, 1]),\n",
        "                run_time=5,\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # ...Then divide into classes\n",
        "        tri_classes.generate_target()\n",
        "        colors = Color(BLUE).range_to(Color(RED), len(tri_classes))\n",
        "        for group, color in zip(tri_classes.target, colors):\n",
        "            group.arrange(DOWN)\n",
        "            group.set_color(color)\n",
        "        tri_classes.target.arrange(RIGHT, buff=1.25, aligned_edge=UP)\n",
        "        tri_classes.target.scale(0.85)\n",
        "        tri_classes.target.to_corner(DL)\n",
        "        max_width = max([tc.get_width() for tc in tri_classes.target])\n",
        "        height = tri_classes.target.get_height() + 0.5\n",
        "        rects = VGroup(*[\n",
        "            Rectangle(\n",
        "                height=height,\n",
        "                width=max_width + 0.25,\n",
        "                stroke_width=2,\n",
        "            ).move_to(tri_class, UP)\n",
        "            for tri_class in tri_classes.target\n",
        "        ])\n",
        "        rects.shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        # Dumb shifts\n",
        "        # tri_classes.target[1][2].shift(0.25 * UP)\n",
        "        tri_classes.target[2].scale(0.9, about_edge=UP)\n",
        "        tri_classes.target[2][2].shift(0.2 * UP)\n",
        "        tri_classes.target[3][0].shift(0.5 * DOWN)\n",
        "        tri_classes.target[3][1].shift(1.0 * DOWN)\n",
        "        tri_classes.target[3][2].shift(1.2 * DOWN)\n",
        "        tri_classes.target[4][1:].shift(0.7 * UP)\n",
        "\n",
        "        # Dots\n",
        "        per_class_dots = VGroup(*[\n",
        "            OldTex(\"\\\\vdots\").move_to(\n",
        "                tri_class\n",
        "            ).set_y(rects.get_bottom()[1] + 0.4)\n",
        "            for tri_class in tri_classes.target\n",
        "        ])\n",
        "        all_class_dots = OldTex(\"\\\\dots\").next_to(\n",
        "            rects, RIGHT, MED_SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(subtitle),\n",
        "            MoveToTarget(tri_classes),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, rects),\n",
        "            Write(per_class_dots),\n",
        "            Write(all_class_dots),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Similar\n",
        "\n",
        "        tri1 = tri_classes[2][1]\n",
        "        tri2 = tri_classes[2][2]\n",
        "        tri1.save_state()\n",
        "        tri2.save_state()\n",
        "\n",
        "        sim_sign = OldTex(\"\\\\sim\")\n",
        "        sim_sign.set_width(1)\n",
        "        sim_sign.move_to(midpoint(rects.get_top(), TOP))\n",
        "        sim_sign.shift(0.25 * DOWN)\n",
        "\n",
        "        similar_word = OldTexText(\"Similar\")\n",
        "        similar_word.scale(1.5)\n",
        "        similar_word.move_to(sim_sign)\n",
        "        similar_word.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(VGroup(title, subtitle), UP),\n",
        "            tri1.next_to, sim_sign, LEFT, 0.75,\n",
        "            tri2.next_to, sim_sign, RIGHT, 0.75,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(sim_sign),\n",
        "            Write(similar_word, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move into place\n",
        "        tri1_copy = tri1.copy()\n",
        "        self.play(\n",
        "            tri1_copy.next_to, tri2,\n",
        "            RIGHT, LARGE_BUFF,\n",
        "            path_arc=90 * DEGREES,\n",
        "        )\n",
        "        self.play(Rotate(tri1_copy, tri2.angle - tri1.angle))\n",
        "        self.play(tri1_copy.scale, tri2.scalar / tri1.scalar)\n",
        "        self.play(\n",
        "            tri1_copy.move_to, tri2,\n",
        "        )\n",
        "        tri1_copy.set_color(YELLOW)\n",
        "        self.play(\n",
        "            FadeOut(tri1_copy),\n",
        "            rate_func=rush_from,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show non-similar example\n",
        "        not_similar_word = OldTexText(\"Not \", \"Similar\")\n",
        "        not_similar_word.scale(1.5)\n",
        "        not_similar_word.move_to(similar_word)\n",
        "        not_similar_word.set_color(RED)\n",
        "\n",
        "        sim_cross = Line(DL, UR)\n",
        "        sim_cross.set_color(RED)\n",
        "        sim_cross.match_width(sim_sign)\n",
        "        sim_cross.move_to(sim_sign)\n",
        "        sim_cross.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        tri3 = tri_classes[1][2]\n",
        "        tri3.save_state()\n",
        "        tri3.generate_target()\n",
        "        tri3.target.move_to(tri2, LEFT)\n",
        "\n",
        "        tri1_copy = tri1.copy()\n",
        "\n",
        "        self.play(\n",
        "            Restore(tri2),\n",
        "            MoveToTarget(tri3),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                similar_word[0],\n",
        "                not_similar_word[1],\n",
        "            ),\n",
        "            GrowFromCenter(not_similar_word[0]),\n",
        "            ShowCreation(sim_cross),\n",
        "        )\n",
        "        self.play(tri1_copy.move_to, tri3)\n",
        "        self.play(Rotate(tri1_copy, 90 * DEGREES))\n",
        "        self.play(\n",
        "            tri1_copy.match_height, tri3,\n",
        "            tri1_copy.move_to, tri3, RIGHT,\n",
        "        )\n",
        "        self.play(WiggleOutThenIn(tri1_copy, n_wiggles=10))\n",
        "        self.play(FadeOut(tri1_copy))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # Back to classes\n",
        "        new_title = OldTexText(\"Space of all\\\\\\\\\", \"Similarity classes\")\n",
        "        new_title.scale(1.5)\n",
        "        new_title[1].set_color(YELLOW)\n",
        "        new_title.to_edge(UP)\n",
        "        new_title_underline = Line(LEFT, RIGHT)\n",
        "        new_title_underline.match_width(new_title[1])\n",
        "        new_title_underline.match_color(new_title[1])\n",
        "        new_title_underline.next_to(new_title, DOWN, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            Restore(tri1),\n",
        "            Restore(tri2),\n",
        "            Restore(tri3),\n",
        "            FadeOut(not_similar_word),\n",
        "            FadeOut(sim_sign),\n",
        "            FadeOut(sim_cross),\n",
        "            FadeIn(new_title[1], UP),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(new_title_underline),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, rects,\n",
        "                lambda m: (m.set_stroke, YELLOW, 5),\n",
        "                rate_func=there_and_back,\n",
        "                run_time=1,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(new_title[0]))\n",
        "        self.wait()\n",
        "\n",
        "        # Show abstract space\n",
        "        blob = ThoughtBubble()[-1]\n",
        "        blob.set_height(2)\n",
        "        blob.to_corner(UR)\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(color=tri.get_color()).move_to(\n",
        "                self.get_triangle_x(tri) * RIGHT +\n",
        "                self.get_triangle_y(tri) * UP,\n",
        "            )\n",
        "            for tri_class in tri_classes\n",
        "            for tri in tri_class[0]\n",
        "        ])\n",
        "        dots.space_out_submobjects(2)\n",
        "        dots.move_to(blob)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(blob),\n",
        "            new_title.shift, LEFT,\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    tri_class.copy().set_fill(opacity=0),\n",
        "                    dot\n",
        "                )\n",
        "                for tri_class, dot in zip(tri_classes, dots)\n",
        "            ],\n",
        "            run_time=3,\n",
        "            lag_ratio=0.3,\n",
        "        ))\n",
        "\n",
        "        # Isolate one triangle\n",
        "\n",
        "        tri = tri_classes[0][0]\n",
        "        verts = tri.get_vertices()\n",
        "        angle = PI + angle_of_vector(verts[1] - verts[2])\n",
        "\n",
        "        self.play(\n",
        "            tri.rotate, -angle,\n",
        "            tri.set_width, self.example_triangle_width,\n",
        "            tri.center,\n",
        "            FadeOut(tri_classes[0][1:]),\n",
        "            FadeOut(tri_classes[1:]),\n",
        "            FadeOut(rects),\n",
        "            FadeOut(per_class_dots),\n",
        "            FadeOut(all_class_dots),\n",
        "            FadeOut(blob),\n",
        "            FadeOut(dots),\n",
        "            FadeOut(new_title),\n",
        "        )\n",
        "\n",
        "        self.triangle = tri\n",
        "\n",
        "    def show_xy_rule(self):\n",
        "        unit_factor = 4.0\n",
        "\n",
        "        if hasattr(self, \"triangle\"):\n",
        "            triangle = self.triangle\n",
        "        else:\n",
        "            triangle = self.get_triangles_and_classes()[0][0]\n",
        "            verts = triangle.get_vertices()\n",
        "            angle = PI + angle_of_vector(verts[1] - verts[2])\n",
        "            triangle.rotate(-angle)\n",
        "            triangle.set_width(self.example_triangle_width)\n",
        "            triangle.center()\n",
        "            self.add(triangle)\n",
        "\n",
        "        side_trackers = VGroup(*[Line() for x in range(3)])\n",
        "        side_trackers.set_stroke(width=0, opacity=0)\n",
        "        side_trackers.triangle = triangle\n",
        "\n",
        "        def update_side_trackers(st):\n",
        "            verts = st.triangle.get_vertices()\n",
        "            st[0].put_start_and_end_on(verts[0], verts[1])\n",
        "            st[1].put_start_and_end_on(verts[1], verts[2])\n",
        "            st[2].put_start_and_end_on(verts[2], verts[0])\n",
        "\n",
        "        side_trackers.add_updater(update_side_trackers)\n",
        "\n",
        "        def get_length_labels():\n",
        "            result = VGroup()\n",
        "            for line in side_trackers:\n",
        "                vect = normalize(line.get_vector())\n",
        "                perp_vect = rotate_vector(vect, -90 * DEGREES)\n",
        "                perp_vect = np.round(perp_vect, 1)\n",
        "                label = DecimalNumber(line.get_length() / unit_factor)\n",
        "                label.move_to(line.get_center())\n",
        "                label.next_to(line.get_center(), perp_vect, buff=0.15)\n",
        "                result.add(label)\n",
        "            return result\n",
        "\n",
        "        side_labels = always_redraw(get_length_labels)\n",
        "\n",
        "        b_label, c_label, a_label = side_labels\n",
        "        b_side, c_side, a_side = side_trackers\n",
        "\n",
        "        # Rescale\n",
        "        self.add(side_trackers)\n",
        "        self.play(LaggedStartMap(FadeIn, side_labels, lag_ratio=0.3, run_time=1))\n",
        "        self.add(side_labels)\n",
        "        self.wait()\n",
        "        self.play(triangle.set_width, unit_factor)\n",
        "        self.play(ShowCreationThenFadeAround(c_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Label x and y\n",
        "        x_label = OldTex(\"x\")\n",
        "        y_label = OldTex(\"y\")\n",
        "        xy_labels = VGroup(x_label, y_label)\n",
        "        xy_labels.scale(1.5)\n",
        "\n",
        "        x_color = self.x1_color\n",
        "        y_color = self.y1_color\n",
        "\n",
        "        x_label[0].set_color(x_color)\n",
        "        y_label[0].set_color(y_color)\n",
        "\n",
        "        # side_labels.clear_updaters()\n",
        "        for var, num, vect in zip(xy_labels, [b_label, a_label], [DR, DL]):\n",
        "            buff = 0.15\n",
        "            var.move_to(num, vect)\n",
        "            var.brace = Brace(num, UP)\n",
        "            var.brace.num = num\n",
        "            var.brace.add_updater(\n",
        "                lambda m: m.next_to(m.num, UP, buff=buff)\n",
        "            )\n",
        "            var.add_updater(\n",
        "                lambda m: m.next_to(m.brace, UP, buff=buff)\n",
        "            )\n",
        "\n",
        "            var.suspend_updating()\n",
        "            var.brace.suspend_updating()\n",
        "            self.play(\n",
        "                FadeIn(var, DOWN),\n",
        "                Write(var.brace, run_time=1),\n",
        "                # MoveToTarget(num)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show plane\n",
        "        to_move = VGroup(\n",
        "            triangle,\n",
        "            side_labels,\n",
        "            x_label,\n",
        "            x_label.brace,\n",
        "            y_label,\n",
        "            y_label.brace,\n",
        "        )\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min=-0.25,\n",
        "            x_max=1.5,\n",
        "            y_min=-0.25,\n",
        "            y_max=1.5,\n",
        "            axis_config={\n",
        "                \"tick_frequency\": 0.25,\n",
        "                \"unit_size\": 3,\n",
        "            }\n",
        "        )\n",
        "        x_axis = axes.x_axis\n",
        "        y_axis = axes.y_axis\n",
        "\n",
        "        x_axis.add(OldTex(\"x\", color=x_color).next_to(x_axis, RIGHT))\n",
        "        y_axis.add(OldTex(\"y\", color=y_color).next_to(y_axis, UP))\n",
        "\n",
        "        for axis, vect in [(x_axis, DOWN), (y_axis, LEFT)]:\n",
        "            axis.add_numbers(\n",
        "                0.5, 1.0,\n",
        "                direction=vect,\n",
        "                num_decimal_places=1,\n",
        "            )\n",
        "\n",
        "        axes.to_corner(DR, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            to_move.to_corner, UL, {\"buff\": LARGE_BUFF},\n",
        "            to_move.shift, MED_LARGE_BUFF * DOWN,\n",
        "            Write(axes),\n",
        "        )\n",
        "\n",
        "        # Show coordinates\n",
        "        coords = VGroup(b_label.copy(), a_label.copy())\n",
        "\n",
        "        x_coord, y_coord = coords\n",
        "        x_coord.add_updater(lambda m: m.set_value(b_side.get_length() / unit_factor))\n",
        "        y_coord.add_updater(lambda m: m.set_value(a_side.get_length() / unit_factor))\n",
        "\n",
        "        def get_coord_values():\n",
        "            return [c.get_value() for c in coords]\n",
        "\n",
        "        def get_ms_point():\n",
        "            return axes.c2p(*get_coord_values())\n",
        "\n",
        "        dot = always_redraw(\n",
        "            lambda: triangle.copy().set_width(0.1).move_to(get_ms_point())\n",
        "        )\n",
        "\n",
        "        y_line = always_redraw(\n",
        "            lambda: DashedLine(\n",
        "                x_axis.n2p(x_coord.get_value()),\n",
        "                get_ms_point(),\n",
        "                color=y_color,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "        )\n",
        "        x_line = always_redraw(\n",
        "            lambda: DashedLine(\n",
        "                y_axis.n2p(y_coord.get_value()),\n",
        "                get_ms_point(),\n",
        "                color=x_color,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        coord_label = OldTex(\"(\", \"0.00\", \",\", \"0.00\", \")\")\n",
        "        cl_buff = 0\n",
        "        coord_label.next_to(dot, UR, buff=cl_buff)\n",
        "        for i, coord in zip([1, 3], coords):\n",
        "            coord.generate_target()\n",
        "            coord.target.replace(coord_label[i], dim_to_match=0)\n",
        "            coord_label[i].set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(x_coord),\n",
        "            MoveToTarget(y_coord),\n",
        "            FadeIn(coord_label),\n",
        "            ReplacementTransform(triangle.copy().set_fill(opacity=0), dot),\n",
        "        )\n",
        "        coord_label.add(*coords)\n",
        "        coord_label.add_updater(lambda m: m.next_to(dot, UR, buff=cl_buff))\n",
        "        self.add(x_label, y_label, dot)\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            ShowCreation(y_line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Adjust triangle\n",
        "        tip_tracker = VectorizedPoint(triangle.get_points()[0])\n",
        "\n",
        "        def update_triangle(tri):\n",
        "            point = tip_tracker.get_location()\n",
        "            tri.get_points()[0] = point\n",
        "            tri.get_points()[-1] = point\n",
        "            tri.make_jagged()\n",
        "\n",
        "        triangle.add_updater(update_triangle)\n",
        "\n",
        "        self.add(tip_tracker)\n",
        "        self.play(tip_tracker.shift, 0.5 * LEFT + 1.0 * UP)\n",
        "        self.play(tip_tracker.shift, 2.0 * DOWN)\n",
        "        self.play(tip_tracker.shift, 1.5 * RIGHT)\n",
        "        self.play(tip_tracker.shift, 1.0 * LEFT + 1.0 * UP)\n",
        "        self.wait()\n",
        "\n",
        "        # Show box\n",
        "        t2c = {\"x\": x_color, \"y\": y_color}\n",
        "        ineq1 = OldTex(\"0\", \"\\\\le \", \"x\", \"\\\\le\", \"1\", tex_to_color_map=t2c)\n",
        "        ineq2 = OldTex(\"0\", \"\\\\le \", \"y\", \"\\\\le\", \"1\", tex_to_color_map=t2c)\n",
        "\n",
        "        ineqs = VGroup(ineq1, ineq2)\n",
        "        ineqs.scale(1.5)\n",
        "        ineqs.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        ineqs.next_to(triangle, DOWN, buff=1.5)\n",
        "\n",
        "        box = Square(\n",
        "            fill_color=GREY_D,\n",
        "            fill_opacity=0.75,\n",
        "            stroke_color=GREY_B,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        box.replace(Line(axes.c2p(0, 0), axes.c2p(1, 1)))\n",
        "        box_outline = box.copy()\n",
        "        box_outline.set_fill(opacity=0)\n",
        "        box_outline.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.add(box, axes, x_line, y_line, coord_label, dot)\n",
        "        self.play(\n",
        "            FadeIn(box),\n",
        "            LaggedStartMap(FadeInFromDown, ineqs)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(box_outline)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # x >= y slice\n",
        "        region = Polygon(\n",
        "            axes.c2p(0, 0),\n",
        "            axes.c2p(1, 0),\n",
        "            axes.c2p(1, 1),\n",
        "            fill_color=GREY_BROWN,\n",
        "            fill_opacity=0.75,\n",
        "            stroke_color=GREY_BROWN,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        region_outline = region.copy()\n",
        "        region_outline.set_fill(opacity=0)\n",
        "        region_outline.set_stroke(YELLOW, 3)\n",
        "\n",
        "        x_eq_y_line = Line(axes.c2p(0, 0), axes.c2p(1, 1))\n",
        "        x_eq_y_line.set_stroke(self.x_eq_y_color, 2)\n",
        "        x_eq_y_label = OldTex(\"x=y\", tex_to_color_map=t2c)\n",
        "        x_eq_y_label.next_to(x_eq_y_line.get_end(), LEFT, MED_LARGE_BUFF)\n",
        "        x_eq_y_label.shift(0.75 * DL)\n",
        "\n",
        "        ineq = OldTex(\"0\", \"\\\\le\", \"y\", \"\\\\le\", \"x\", \"\\\\le\", \"1\")\n",
        "        ineq.set_color_by_tex(\"x\", x_color)\n",
        "        ineq.set_color_by_tex(\"y\", y_color)\n",
        "        ineq.scale(1.5)\n",
        "        ineq.move_to(ineqs, LEFT)\n",
        "\n",
        "        self.add(region, axes, x_line, y_line, coord_label, dot)\n",
        "        self.play(\n",
        "            FadeIn(region),\n",
        "            ShowCreation(x_eq_y_line),\n",
        "            # FadeInFromDown(x_eq_y_label),\n",
        "            Transform(ineq1[:2], ineq[:2], remover=True),\n",
        "            Transform(ineq1[2:], ineq[4:], remover=True),\n",
        "            Transform(ineq2[:4], ineq[:4], remover=True),\n",
        "            Transform(ineq2[4:], ineq[6:], remover=True),\n",
        "        )\n",
        "        self.add(ineq)\n",
        "        self.play(ShowCreationThenFadeOut(region_outline))\n",
        "        self.wait()\n",
        "\n",
        "        # x + y <= 1 slice\n",
        "        xpy1_line = Line(axes.c2p(0, 1), axes.c2p(1, 0))\n",
        "        xpy1_line.set_stroke(GREEN, 2)\n",
        "        xpy1_label = OldTex(\"x+y=1\", tex_to_color_map=t2c)\n",
        "        xpy1_label.next_to(xpy1_line.get_start(), RIGHT, MED_LARGE_BUFF)\n",
        "        xpy1_label.shift(0.75 * DR)\n",
        "\n",
        "        xpy1_ineq = OldTex(\"1 \\\\le x + y\", tex_to_color_map=t2c)\n",
        "        xpy1_ineq.scale(1.5)\n",
        "        xpy1_ineq.next_to(ineq, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        ms_region = Polygon(\n",
        "            axes.c2p(1, 0),\n",
        "            axes.c2p(0.5, 0.5),\n",
        "            axes.c2p(1, 1),\n",
        "            fill_color=BLUE_E,\n",
        "            fill_opacity=0.75,\n",
        "            stroke_width=0,\n",
        "        )\n",
        "        ms_outline = ms_region.copy()\n",
        "        ms_outline.set_fill(opacity=0)\n",
        "        ms_outline.set_stroke(YELLOW, 2)\n",
        "\n",
        "        tt_line = Line(DOWN, UP, color=WHITE)\n",
        "        tt_line.set_height(0.25)\n",
        "        tt_line.add_updater(lambda m: m.move_to(tip_tracker))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(xpy1_line),\n",
        "            # FadeIn(xpy1_label, DOWN),\n",
        "            FadeIn(xpy1_ineq, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            tip_tracker.set_y, triangle.get_bottom()[1] + 0.01,\n",
        "            FadeIn(tt_line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(ms_region, axes, x_line, y_line, coord_label, dot)\n",
        "        self.play(\n",
        "            FadeIn(ms_region),\n",
        "            region.set_fill, GREY_D,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move tip around\n",
        "        self.play(\n",
        "            tip_tracker.shift, UP + RIGHT,\n",
        "            FadeOut(tt_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(tip_tracker.shift, 0.5 * DOWN + LEFT, run_time=2)\n",
        "        self.wait()\n",
        "        self.play(tip_tracker.shift, UP + 0.7 * LEFT, run_time=2)\n",
        "        self.wait()\n",
        "        equilateral_point = triangle.get_bottom() + unit_factor * 0.5 * np.sqrt(3) * UP\n",
        "        self.play(\n",
        "            tip_tracker.move_to,\n",
        "            equilateral_point,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label as moduli space\n",
        "        ms_words = OldTexText(\"Moduli\\\\\\\\\", \"Space\")\n",
        "        ms_words.scale(1.5)\n",
        "        ms_words.next_to(ms_region, RIGHT, buff=0.35)\n",
        "        ms_arrow = Arrow(\n",
        "            ms_words[1].get_corner(DL),\n",
        "            ms_region.get_center(),\n",
        "            path_arc=-90 * DEGREES,\n",
        "            buff=0.1,\n",
        "        )\n",
        "        # ms_arrow.rotate(-10 * DEGREES)\n",
        "        ms_arrow.shift(0.1 * RIGHT)\n",
        "        ms_arrow.scale(0.95)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ms_words, LEFT),\n",
        "        )\n",
        "        self.play(ShowCreation(ms_arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Show right triangles\n",
        "        alpha = np.arcsin(0.8)\n",
        "        vect = rotate_vector(0.6 * unit_factor * LEFT, -alpha)\n",
        "        new_tip = triangle.get_corner(DR) + vect\n",
        "\n",
        "        elbow = VMobject()\n",
        "        elbow.start_new_path(RIGHT)\n",
        "        elbow.add_line_to(UR)\n",
        "        elbow.add_line_to(UP)\n",
        "\n",
        "        elbow.rotate(3 * TAU / 4 - alpha, about_point=ORIGIN)\n",
        "        elbow.scale(0.2, about_point=ORIGIN)\n",
        "        elbow.shift(new_tip)\n",
        "\n",
        "        elbow_circle = Circle()\n",
        "        elbow_circle.replace(elbow)\n",
        "        elbow_circle.scale(3)\n",
        "        elbow_circle.move_to(new_tip)\n",
        "        elbow_circle.set_stroke(self.right_color, 3)\n",
        "\n",
        "        right_words = OldTexText(\"Right triangle\")\n",
        "        right_words.scale(1.5)\n",
        "        right_words.set_color(self.right_color)\n",
        "        right_words.next_to(triangle, DOWN, buff=1.5)\n",
        "\n",
        "        ineqs = VGroup(ineq, xpy1_ineq)\n",
        "\n",
        "        self.play(\n",
        "            tip_tracker.move_to, new_tip,\n",
        "            FadeOut(ms_words),\n",
        "            FadeOut(ms_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(elbow),\n",
        "            FadeIn(right_words, UP),\n",
        "            FadeOut(ineqs, DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(elbow_circle),\n",
        "        )\n",
        "\n",
        "        # Show circular arc\n",
        "        pythag_eq = OldTex(\"x^2 + y^2\", \"=\", \"1\", tex_to_color_map=t2c)\n",
        "        pythag_eq.scale(1.5)\n",
        "        pythag_eq.next_to(right_words, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        arc = Arc(\n",
        "            start_angle=90 * DEGREES,\n",
        "            angle=-90 * DEGREES,\n",
        "            color=self.right_color,\n",
        "        )\n",
        "        arc.replace(box)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pythag_eq, UP),\n",
        "        )\n",
        "        self.add(arc, arc)\n",
        "        self.play(ShowCreation(arc))\n",
        "        self.wait()\n",
        "\n",
        "        # Acute region\n",
        "        arc_piece = VMobject()\n",
        "        arc_piece.pointwise_become_partial(arc, 0.5, 1.0)\n",
        "\n",
        "        acute_region = VMobject()\n",
        "        acute_region.start_new_path(axes.c2p(1, 1))\n",
        "        acute_region.add_line_to(arc_piece.get_start())\n",
        "        acute_region.append_vectorized_mobject(arc_piece)\n",
        "        acute_region.add_line_to(axes.c2p(1, 1))\n",
        "        acute_region.set_fill(self.acute_color, 1)\n",
        "        acute_region.set_stroke(width=0)\n",
        "\n",
        "        obtuse_region = VMobject()\n",
        "        obtuse_region.start_new_path(axes.c2p(1, 0))\n",
        "        obtuse_region.add_line_to(axes.c2p(0.5, 0.5))\n",
        "        obtuse_region.add_line_to(arc_piece.get_start())\n",
        "        obtuse_region.append_vectorized_mobject(arc_piece)\n",
        "        obtuse_region.set_fill(self.obtuse_color, 1)\n",
        "        obtuse_region.set_stroke(width=0)\n",
        "\n",
        "        acute_words = OldTexText(\"Acute triangle\")\n",
        "        acute_words.set_color(self.acute_color)\n",
        "        obtuse_words = OldTexText(\"Obtuse triangle\")\n",
        "        obtuse_words.set_color(self.obtuse_color)\n",
        "        for words in [acute_words, obtuse_words]:\n",
        "            words.scale(1.5)\n",
        "            words.move_to(right_words)\n",
        "\n",
        "        eq = pythag_eq[-2]\n",
        "        gt = OldTex(\">\").replace(eq)\n",
        "        gt.set_color(self.acute_color)\n",
        "        lt = OldTex(\"<\").replace(eq)\n",
        "        lt.set_color(self.obtuse_color)\n",
        "\n",
        "        self.add(acute_region, coord_label, x_line, y_line, xpy1_line, x_eq_y_line, dot)\n",
        "        self.play(\n",
        "            tip_tracker.shift, 0.5 * UP,\n",
        "            coord_label.set_opacity, 0,\n",
        "            FadeOut(elbow),\n",
        "            FadeIn(acute_region),\n",
        "            FadeOut(right_words, UP),\n",
        "            FadeOut(eq, UP),\n",
        "            FadeIn(acute_words, DOWN),\n",
        "            FadeIn(gt, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(tip_tracker.shift, 0.5 * RIGHT)\n",
        "        self.wait()\n",
        "        self.add(obtuse_region, coord_label, x_line, y_line, xpy1_line, x_eq_y_line, dot)\n",
        "        self.play(\n",
        "            tip_tracker.shift, 1.5 * DOWN,\n",
        "            FadeIn(obtuse_region),\n",
        "            FadeOut(acute_words, DOWN),\n",
        "            FadeOut(gt, DOWN),\n",
        "            FadeIn(obtuse_words, UP),\n",
        "            FadeIn(lt, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(tip_tracker.shift, 0.5 * LEFT)\n",
        "        self.play(tip_tracker.shift, 0.5 * DOWN)\n",
        "        self.play(tip_tracker.shift, 0.5 * RIGHT)\n",
        "        self.play(tip_tracker.shift, 0.5 * UP)\n",
        "        self.wait()\n",
        "\n",
        "        # Ambient changes\n",
        "        self.play(\n",
        "            FadeOut(obtuse_words),\n",
        "            FadeOut(pythag_eq[:-2]),\n",
        "            FadeOut(pythag_eq[-1]),\n",
        "            FadeOut(lt),\n",
        "        )\n",
        "        self.play(\n",
        "            tip_tracker.move_to, equilateral_point + 0.25 * DL,\n",
        "            path_arc=30 * DEGREES,\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_triangles_and_classes(self):\n",
        "        original_triangles = VGroup(*[\n",
        "            self.get_random_triangle()\n",
        "            for x in range(5)\n",
        "        ])\n",
        "        original_triangles.submobjects[4] = self.get_random_triangle()  # Hack\n",
        "        all_triangles = VGroup()\n",
        "        tri_classes = VGroup()\n",
        "        for triangle in original_triangles:\n",
        "            all_triangles.add(triangle)\n",
        "            tri_class = VGroup()\n",
        "            tri_class.add(triangle)\n",
        "            for x in range(2):\n",
        "                tri_copy = triangle.copy()\n",
        "                angle = TAU * np.random.random()\n",
        "                scalar = 0.25 + 1.5 * np.random.random()\n",
        "\n",
        "                tri_copy.rotate(angle - tri_copy.angle)\n",
        "                tri_copy.angle = angle\n",
        "                tri_copy.scale(scalar / tri_copy.scalar)\n",
        "                tri_copy.scalar = scalar\n",
        "\n",
        "                all_triangles.add(tri_copy)\n",
        "                tri_class.add(tri_copy)\n",
        "            tri_classes.add(tri_class)\n",
        "\n",
        "        colors = Color(BLUE).range_to(Color(RED), len(all_triangles))\n",
        "        for triangle, color in zip(all_triangles, colors):\n",
        "            # triangle.set_color(random_bright_color())\n",
        "            triangle.set_color(color)\n",
        "\n",
        "        all_triangles.shuffle()\n",
        "        all_triangles.arrange_in_grid(3, 5, buff=MED_LARGE_BUFF)\n",
        "        all_triangles.set_height(6)\n",
        "        sf = 1.25\n",
        "        all_triangles.stretch(sf, 0)\n",
        "        for triangle in all_triangles:\n",
        "            triangle.stretch(1 / sf, 0)\n",
        "        # all_triangles.next_to(title, DOWN)\n",
        "        all_triangles.to_edge(DOWN, LARGE_BUFF)\n",
        "\n",
        "        return all_triangles, tri_classes\n",
        "\n",
        "    def get_random_triangle(self, x=None, y=None):\n",
        "        y = np.random.random()\n",
        "        x = y + np.random.random()\n",
        "        if x + y <= 1:\n",
        "            diff = 1 - (x + y)\n",
        "            x += diff\n",
        "            y += diff\n",
        "        tri = self.get_triangle(x, y)\n",
        "        tri.angle = TAU * np.random.random()\n",
        "        tri.scalar = 0.25 + np.random.random() * 1.5\n",
        "\n",
        "        tri.rotate(tri.angle)\n",
        "        tri.scale(tri.scalar)\n",
        "        return tri\n",
        "\n",
        "    def get_triangle(self, x, y):\n",
        "        # Enforce assumption that x > y\n",
        "        if y > x:\n",
        "            raise Exception(\"Please ensure x >= y.  Thank you.\")\n",
        "        plane = self.plane\n",
        "\n",
        "        # Heron\n",
        "        s = (1 + x + y) / 2.0\n",
        "        area = np.sqrt(s * (s - 1.0) * (s - x) * (s - y))\n",
        "        beta = np.arcsin(2 * area / x)\n",
        "        tip_point = RIGHT + rotate_vector(x * LEFT, -beta)\n",
        "\n",
        "        color = self.get_triangle_color(x, y)\n",
        "        return Polygon(\n",
        "            plane.c2p(0, 0),\n",
        "            plane.c2p(1, 0),\n",
        "            plane.c2p(*tip_point[:2]),\n",
        "            color=color,\n",
        "            fill_opacity=self.triangle_fill_opacity,\n",
        "        )\n",
        "\n",
        "    def get_triangle_color(self, x, y):\n",
        "        epsilon = 1e-4\n",
        "        if x + y == 1:\n",
        "            return self.x_eq_y_color\n",
        "        elif x == 1:\n",
        "            return self.x1_color\n",
        "        elif y == 1:\n",
        "            return self.y1_color\n",
        "        elif np.abs(x**2 + y**2 - 1) < epsilon:\n",
        "            return self.right_color\n",
        "        elif x**2 + y**2 < 1:\n",
        "            return self.obtuse_color\n",
        "        elif x**2 + y**2 > 1:\n",
        "            return self.acute_color\n",
        "        assert(False)  # Should not get here\n",
        "\n",
        "    def get_triangle_xy(self, triangle):\n",
        "        A, B, C = triangle.get_start_anchors()[:3]\n",
        "        a = get_norm(B - C)\n",
        "        b = get_norm(C - A)\n",
        "        c = get_norm(A - B)\n",
        "        sides = np.array(sorted([a, b, c]))\n",
        "        sides = sides / np.max(sides)\n",
        "        return sides[1], sides[0]\n",
        "\n",
        "    def get_triangle_x(self, triangle):\n",
        "        return self.get_triangle_xy(triangle)[0]\n",
        "\n",
        "    def get_triangle_y(self, triangle):\n",
        "        return self.get_triangle_xy(triangle)[1]\n",
        "\n",
        "\n",
        "class Credits(Scene):\n",
        "    def construct(self):\n",
        "        items = VGroup(\n",
        "            OldTexText(\"Written by\\\\\\\\Jayadev Athreya\"),\n",
        "            OldTexText(\"Illustrated and Narrated by\\\\\\\\Grant Sanderson\"),\n",
        "            OldTexText(\n",
        "                \"3Blue1Brown\\\\\\\\\",\n",
        "                \"\\\\copyright {} Copyright 2019\\\\\\\\\",\n",
        "                \"www.3blue1brown.com\\\\\\\\\",\n",
        "            ),\n",
        "        )\n",
        "        items.arrange(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        items[-1].set_color(GREY_B)\n",
        "        items[-1].scale(0.8, about_edge=UP)\n",
        "        items[-1].to_edge(DOWN)\n",
        "\n",
        "        self.add(items[-1])\n",
        "        self.play(LaggedStartMap(FadeInFromDown, items[:-1]))\n",
        "        self.wait()\n"
    ]
}