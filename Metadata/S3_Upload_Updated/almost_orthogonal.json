{
    "topic": "demonstrates the concept of orthogonal vectors and their relationship with each other. Specifically, it shows",
    "code": [
        "import torch\n",
        "import matplotlib.pyplot as plt\n",
        "from tqdm import tqdm\n",
        "\n",
        "# List of vectors in some dimension, with many\n",
        "# more vectors than there are dimensions\n",
        "num_vectors = 10000\n",
        "vector_len = 100\n",
        "big_matrix = torch.randn(num_vectors, vector_len)\n",
        "big_matrix /= big_matrix.norm(p=2, dim=1, keepdim=True)  # Normalize\n",
        "big_matrix.requires_grad_(True)\n",
        "\n",
        "# Set up an Optimization loop to create nearly-perpendicular vectors\n",
        "optimizer = torch.optim.Adam([big_matrix], lr=0.01)\n",
        "num_steps = 250\n",
        "\n",
        "losses = []\n",
        "\n",
        "dot_diff_cutoff = 0.01\n",
        "big_id = torch.eye(num_vectors, num_vectors)\n",
        "\n",
        "for step_num in tqdm(range(num_steps)):\n",
        "    optimizer.zero_grad()\n",
        "\n",
        "    dot_products = big_matrix @ big_matrix.T\n",
        "    # Punish deviation from orthogonal\n",
        "    diff = dot_products - big_id\n",
        "    loss = (diff.abs() - dot_diff_cutoff).relu().sum()\n",
        "\n",
        "    # Extra incentive to keep rows normalized\n",
        "    loss += num_vectors * diff.diag().pow(2).sum()\n",
        "\n",
        "    loss.backward()\n",
        "    optimizer.step()\n",
        "    losses.append(loss.item())\n",
        "\n",
        "# Loss curve\n",
        "plt.plot(losses)\n",
        "plt.grid(1)\n",
        "plt.show()\n",
        "\n",
        "# Angle distribution\n",
        "dot_products = big_matrix @ big_matrix.T\n",
        "norms = torch.sqrt(torch.diag(dot_products))\n",
        "normed_dot_products = dot_products / torch.outer(norms, norms)\n",
        "angles_degrees = torch.rad2deg(torch.acos(normed_dot_products.detach()))\n",
        "# Use this to ignore self-orthogonality.\n",
        "self_orthogonality_mask = ~(torch.eye(num_vectors, num_vectors).bool())\n",
        "plt.hist(angles_degrees[self_orthogonality_mask].numpy().ravel(), bins=1000, range=(80, 100))\n",
        "plt.grid(1)\n",
        "plt.show()\n"
    ]
}