{
    "topic": "The mathematical concept being demonstrated is the projection of a 3D object onto a 2D plane",
    "code": [
        "from manim_imports_ext import *\n",
        "import scipy.spatial\n",
        "\n",
        "\n",
        "# Helpers\n",
        "def project_to_xy_plane(p1, p2):\n",
        "    \"\"\"\n",
        "    Draw a line from source to p1 to p2.  Where does it\n",
        "    intersect the xy plane?\n",
        "    \"\"\"\n",
        "    x1, y1, z1 = p1\n",
        "    x2, y2, z2 = p2\n",
        "    if z2 < z1:\n",
        "        z2 = z1 + 1e-2  # TODO, bad hack\n",
        "    vect = p2 - p1\n",
        "    return p1 - (z2 / vect[2]) * vect\n",
        "\n",
        "\n",
        "def flat_project(point):\n",
        "    # return [*point[:2], 0]\n",
        "    return [*point[:2], 0.05 * point[2]]  # TODO\n",
        "\n",
        "\n",
        "def get_pre_shadow(mobject, opacity):\n",
        "    result = mobject.deepcopy()\n",
        "    if isinstance(result, Group) and all((isinstance(sm, VMobject) for sm in mobject)):\n",
        "        result = VGroup(*result)\n",
        "    result.clear_updaters()\n",
        "\n",
        "    for sm in result.family_members_with_points():\n",
        "        color = interpolate_color(sm.get_color(), BLACK, opacity)\n",
        "        sm.set_color(color)\n",
        "        sm.set_opacity(opacity)\n",
        "        if isinstance(sm, VMobject):\n",
        "            sm.set_stroke(\n",
        "                interpolate_color(sm.get_stroke_color(), BLACK, opacity)\n",
        "            )\n",
        "        sm.set_gloss(sm.get_gloss() * 0.5)\n",
        "        sm.set_shadow(0)\n",
        "        sm.set_reflectiveness(0)\n",
        "    return result\n",
        "\n",
        "\n",
        "def update_shadow(shadow, mobject, light_source):\n",
        "    lp = light_source.get_center() if light_source is not None else None\n",
        "\n",
        "    def project(point):\n",
        "        if lp is None:\n",
        "            return flat_project(point)\n",
        "        else:\n",
        "            return project_to_xy_plane(lp, point)\n",
        "\n",
        "    for sm, mm in zip(shadow.family_members_with_points(), mobject.family_members_with_points()):\n",
        "        sm.set_points(np.apply_along_axis(project, 1, mm.get_points()))\n",
        "        if isinstance(sm, VMobject) and sm.get_unit_normal()[2] < 0:\n",
        "            sm.reverse_points()\n",
        "        if isinstance(sm, VMobject):\n",
        "            sm.set_fill(opacity=mm.get_fill_opacity())\n",
        "        else:\n",
        "            sm.set_opacity(mm.get_opacity())\n",
        "\n",
        "\n",
        "def get_shadow(mobject, light_source=None, opacity=0.7):\n",
        "    shadow = get_pre_shadow(mobject, opacity)\n",
        "    shadow.add_updater(lambda s: update_shadow(s, mobject, light_source))\n",
        "    return shadow\n",
        "\n",
        "\n",
        "def get_area(shadow):\n",
        "    return 0.5 * sum(\n",
        "        get_norm(sm.get_area_vector())\n",
        "        for sm in shadow.get_family()\n",
        "    )\n",
        "\n",
        "\n",
        "def get_convex_hull(mobject):\n",
        "    points = mobject.get_all_points()\n",
        "    hull = scipy.spatial.ConvexHull(points[:, :2])\n",
        "    return points[hull.vertices]\n",
        "\n",
        "\n",
        "def sort_to_camera(mobject, camera_frame):\n",
        "    cl = camera_frame.get_implied_camera_location()\n",
        "    mobject.sort(lambda p: -get_norm(p - cl))\n",
        "    return mobject\n",
        "\n",
        "\n",
        "def cube_sdf(point, cube):\n",
        "    c = cube.get_center()\n",
        "    vect = point - c\n",
        "    face_vects = [face.get_center() - c for face in cube]\n",
        "    return max(*(\n",
        "        abs(np.dot(fv, vect) / np.dot(fv, fv))\n",
        "        for fv in face_vects\n",
        "    )) - 1\n",
        "\n",
        "\n",
        "def is_in_cube(point, cube):\n",
        "    return cube_sdf(point, cube) < 0\n",
        "\n",
        "\n",
        "def get_overline(mob):\n",
        "    overline = Underline(mob).next_to(mob, UP, buff=0.05)\n",
        "    overline.set_stroke(WHITE, 2)\n",
        "    return overline\n",
        "\n",
        "\n",
        "def get_key_result(solid_name, color=BLUE):\n",
        "    eq = OldTex(\n",
        "        \"\\\\text{Area}\\\\big(\\\\text{Shadow}(\\\\text{\" + solid_name + \"})\\\\big)\",\n",
        "        \"=\",\n",
        "        \"\\\\frac{1}{2}\", \"{c}\", \"\\\\cdot\",\n",
        "        \"(\\\\text{Surface area})\",\n",
        "        tex_to_color_map={\n",
        "            \"\\\\text{Shadow}\": GREY_B,\n",
        "            f\"\\\\text{{{solid_name}}}\": color,\n",
        "            \"\\\\text{Solid}\": BLUE,\n",
        "            \"{c}\": RED,\n",
        "        }\n",
        "    )\n",
        "    eq.add_to_back(get_overline(eq[:5]))\n",
        "    return eq\n",
        "\n",
        "\n",
        "def get_surface_area(solid):\n",
        "    return sum(get_norm(f.get_area_vector()) for f in solid)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class ShadowScene(ThreeDScene):\n",
        "    object_center = [0, 0, 3]\n",
        "    frame_center = [0, 0, 2]\n",
        "    area_label_center = [0, -1.5, 0]\n",
        "    surface_area = 6.0\n",
        "    num_reorientations = 10\n",
        "    plane_dims = (20, 20)\n",
        "    plane_style = {\n",
        "        \"stroke_width\": 0,\n",
        "        \"fill_color\": GREY_A,\n",
        "        \"fill_opacity\": 0.5,\n",
        "        \"gloss\": 0.5,\n",
        "        \"shadow\": 0.2,\n",
        "    }\n",
        "    limited_plane_extension = 0\n",
        "    object_style = {\n",
        "        \"stroke_color\": WHITE,\n",
        "        \"stroke_width\": 0.5,\n",
        "        \"fill_color\": BLUE_E,\n",
        "        \"fill_opacity\": 0.7,\n",
        "        \"reflectiveness\": 0.3,\n",
        "        \"gloss\": 0.1,\n",
        "        \"shadow\": 0.5,\n",
        "    }\n",
        "    inf_light = False\n",
        "    glow_radius = 10\n",
        "    glow_factor = 10\n",
        "    area_label_center = [-2, -1, 0]\n",
        "    unit_size = 2\n",
        "\n",
        "    def setup(self):\n",
        "        self.camera.frame.reorient(-30, 75)\n",
        "        self.camera.frame.move_to(self.frame_center)\n",
        "        self.add_plane()\n",
        "        self.add_solid()\n",
        "        self.add_shadow()\n",
        "        self.setup_light_source()\n",
        "\n",
        "    def add_plane(self):\n",
        "        width, height = self.plane_dims\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            x_range=(-width // 2, width // 2, 2),\n",
        "            y_range=(-height // 2, height // 2, 2),\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_B,\n",
        "                \"stroke_width\": 1,\n",
        "            },\n",
        "            faded_line_ratio=4,\n",
        "        )\n",
        "        grid.shift(-grid.get_origin())\n",
        "        grid.set_width(width)\n",
        "        grid.axes.match_style(grid.background_lines)\n",
        "        grid.set_flat_stroke(True)\n",
        "        grid.insert_n_curves(3)\n",
        "\n",
        "        plane = Rectangle()\n",
        "        plane.replace(grid, stretch=True)\n",
        "        plane.set_style(**self.plane_style)\n",
        "        plane.set_stroke(width=0)\n",
        "        if self.limited_plane_extension > 0:\n",
        "            plane.set_height(height // 2 + self.limited_plane_extension, about_edge=UP, stretch=True)\n",
        "        self.plane = plane\n",
        "\n",
        "        plane.add(grid)\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_solid(self):\n",
        "        self.solid = self.get_solid()\n",
        "        self.solid.move_to(self.object_center)\n",
        "        self.add(self.solid)\n",
        "\n",
        "    def get_solid(self):\n",
        "        cube = VCube()\n",
        "        cube.deactivate_depth_test()\n",
        "        cube.set_height(2)\n",
        "        cube.set_style(**self.object_style)\n",
        "        # Wrap in group so that strokes and fills\n",
        "        # are rendered in separate passes\n",
        "        cube = self.cube = Group(*cube)\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        return cube\n",
        "\n",
        "    def add_shadow(self):\n",
        "        light_source = None if self.inf_light else self.camera.light_source\n",
        "        shadow = get_shadow(self.solid, light_source)\n",
        "\n",
        "        self.add(shadow, self.solid)\n",
        "        self.shadow = shadow\n",
        "\n",
        "    def setup_light_source(self):\n",
        "        self.light = self.camera.light_source\n",
        "        if self.inf_light:\n",
        "            self.light.move_to(100 * OUT)\n",
        "        else:\n",
        "            glow = self.glow = TrueDot(\n",
        "                radius=self.glow_radius,\n",
        "                glow_factor=self.glow_factor,\n",
        "            )\n",
        "            glow.set_color(interpolate_color(YELLOW, WHITE, 0.5))\n",
        "            glow.add_updater(lambda m: m.move_to(self.light))\n",
        "            self.add(glow)\n",
        "\n",
        "    def sort_to_camera(self, mobject):\n",
        "        return sort_to_camera(mobject, self.camera.frame)\n",
        "\n",
        "    def get_shadow_area_label(self):\n",
        "        text = OldTexText(\"Shadow area: \")\n",
        "        decimal = DecimalNumber(100)\n",
        "\n",
        "        label = VGroup(text, decimal)\n",
        "        label.arrange(RIGHT)\n",
        "        label.move_to(self.area_label_center - decimal.get_center())\n",
        "        label.fix_in_frame()\n",
        "        label.set_backstroke()\n",
        "        decimal.add_updater(lambda d: d.set_value(\n",
        "            get_area(self.shadow) / (self.unit_size**2)\n",
        "        ).set_backstroke())\n",
        "        return label\n",
        "\n",
        "    def begin_ambient_rotation(self, mobject, speed=0.2, about_point=None, initial_axis=[1, 1, 1]):\n",
        "        mobject.rot_axis = np.array(initial_axis)\n",
        "\n",
        "        def update_mob(mob, dt):\n",
        "            mob.rotate(speed * dt, mob.rot_axis, about_point=about_point)\n",
        "            mob.rot_axis = rotate_vector(mob.rot_axis, speed * dt, OUT)\n",
        "            return mob\n",
        "        mobject.add_updater(update_mob)\n",
        "        return mobject\n",
        "\n",
        "    def get_shadow_outline(self, stroke_width=1):\n",
        "        outline = VMobject()\n",
        "        outline.set_stroke(WHITE, stroke_width)\n",
        "        outline.add_updater(lambda m: m.set_points_as_corners(get_convex_hull(self.shadow)).close_path())\n",
        "        return outline\n",
        "\n",
        "    def get_light_lines(self, outline=None, n_lines=100, only_vertices=False):\n",
        "        if outline is None:\n",
        "            outline = self.get_shadow_outline()\n",
        "\n",
        "        def update_lines(lines):\n",
        "            lp = self.light.get_center()\n",
        "            if only_vertices:\n",
        "                points = outline.get_vertices()\n",
        "            else:\n",
        "                points = [outline.pfp(a) for a in np.linspace(0, 1, n_lines)]\n",
        "            for line, point in zip(lines, points):\n",
        "                if self.inf_light:\n",
        "                    line.set_points_as_corners([point + 10 * OUT, point])\n",
        "                else:\n",
        "                    line.set_points_as_corners([lp, point])\n",
        "\n",
        "        line = Line(IN, OUT)\n",
        "        light_lines = line.replicate(n_lines)\n",
        "        light_lines.set_stroke(YELLOW, 0.5, 0.1)\n",
        "        light_lines.add_updater(update_lines)\n",
        "        return light_lines\n",
        "\n",
        "    def random_toss(self, mobject=None, angle=TAU, about_point=None, meta_speed=5, **kwargs):\n",
        "        if mobject is None:\n",
        "            mobject = self.solid\n",
        "\n",
        "        mobject.rot_axis = normalize(np.random.random(3))\n",
        "        mobject.rot_time = 0\n",
        "\n",
        "        def update(mob, time):\n",
        "            dt = time - mob.rot_time\n",
        "            mob.rot_time = time\n",
        "            mob.rot_axis = rotate_vector(mob.rot_axis, meta_speed * dt, normalize(np.random.random(3)))\n",
        "            mob.rotate(angle * dt, mob.rot_axis, about_point=about_point)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(mobject, update),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def randomly_reorient(self, solid=None, about_point=None):\n",
        "        solid = self.solid if solid is None else solid\n",
        "        solid.rotate(\n",
        "            random.uniform(0, TAU),\n",
        "            axis=normalize(np.random.uniform(-1, 1, 3)),\n",
        "            about_point=about_point,\n",
        "        )\n",
        "        return solid\n",
        "\n",
        "    def init_frame_rotation(self, factor=0.0025, max_speed=0.01):\n",
        "        frame = self.camera.frame\n",
        "        frame.d_theta = 0\n",
        "\n",
        "        def update_frame(frame, dt):\n",
        "            frame.d_theta += -factor * frame.get_theta()\n",
        "            frame.increment_theta(clip(\n",
        "                factor * frame.d_theta,\n",
        "                -max_speed * dt,\n",
        "                max_speed * dt\n",
        "            ))\n",
        "\n",
        "        frame.add_updater(update_frame)\n",
        "        return frame\n",
        "\n",
        "\n",
        "class SimpleWriting(Scene):\n",
        "    text = \"\"\n",
        "    font = \"Better Grade\"\n",
        "    color = WHITE\n",
        "    font_size = 48\n",
        "\n",
        "    def construct(self):\n",
        "        words = Text(self.text, font=self.font, font_size=self.font_size)\n",
        "        words.set_color(self.color)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AliceName(SimpleWriting):\n",
        "    text = \"Alice\"\n",
        "    font_size = 72\n",
        "\n",
        "\n",
        "class BobName(SimpleWriting):\n",
        "    text = \"Bob\"\n",
        "    font = \"Kalam\"\n",
        "\n",
        "\n",
        "class BobWords(SimpleWriting):\n",
        "    font = \"Kalam\"\n",
        "    font_size = 24\n",
        "    words1 = \"Embraces calculations\"\n",
        "    words2 = \"Loves specifics\"\n",
        "\n",
        "    def construct(self):\n",
        "        words = VGroup(*(\n",
        "            Text(text, font=self.font, font_size=self.font_size)\n",
        "            for text in (self.words1, self.words2)\n",
        "        ))\n",
        "        words.arrange(DOWN)\n",
        "\n",
        "        for word in words:\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class AliceWords(BobWords):\n",
        "    font = \"Better Grade\"\n",
        "    words1 = \"Procrastinates calculations\"\n",
        "    words2 = \"Seeks generality\"\n",
        "    font_size = 48\n",
        "\n",
        "\n",
        "class AskAboutConditions(SimpleWriting):\n",
        "    text = \"Which properties matter?\"\n",
        "\n",
        "\n",
        "class IntroduceShadow(ShadowScene):\n",
        "    area_label_center = [-2.5, -2, 0]\n",
        "    plane_dims = (28, 20)\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        light = self.light\n",
        "        light.move_to([0, 0, 20])\n",
        "        self.add(light)\n",
        "        cube = self.solid\n",
        "        cube.scale(0.945)  # Hack to make the appropriate area 1\n",
        "        shadow = self.shadow\n",
        "        outline = self.get_shadow_outline()\n",
        "        frame = self.camera.frame\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.01 * dt))  # Ambient rotation\n",
        "        area_label = self.get_shadow_area_label()\n",
        "        light_lines = self.get_light_lines(outline)\n",
        "\n",
        "        # Question\n",
        "        question = OldTexText(\n",
        "            \"Puzzle: Find the average\\\\\\\\area of a cube's shadow\",\n",
        "            font_size=48,\n",
        "        )\n",
        "        question.to_corner(UL)\n",
        "        question.fix_in_frame()\n",
        "        subquestion = Text(\"(Averaged over all orientations)\")\n",
        "        subquestion.match_width(question)\n",
        "        subquestion.next_to(question, DOWN, MED_LARGE_BUFF)\n",
        "        subquestion.set_fill(BLUE_D)\n",
        "        subquestion.fix_in_frame()\n",
        "        subquestion.set_backstroke()\n",
        "\n",
        "        # Introductory animations\n",
        "        self.shadow.update()\n",
        "        self.play(\n",
        "            FadeIn(question, UP),\n",
        "            *(\n",
        "                LaggedStartMap(DrawBorderThenFill, mob, lag_ratio=0.1, run_time=3)\n",
        "                for mob in (cube, shadow)\n",
        "            )\n",
        "        )\n",
        "        self.random_toss(run_time=3, angle=TAU)\n",
        "\n",
        "        # Change size and orientation\n",
        "        outline.update()\n",
        "        area_label.update()\n",
        "        self.play(\n",
        "            FadeIn(area_label),\n",
        "            ShowCreation(outline),\n",
        "        )\n",
        "        self.play(\n",
        "            cube.animate.scale(0.5),\n",
        "            run_time=2,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.random_toss(run_time=2, angle=PI)\n",
        "        self.wait()\n",
        "        self.begin_ambient_rotation(cube)\n",
        "        self.play(FadeIn(subquestion, 0.5 * DOWN))\n",
        "        self.wait(7)\n",
        "\n",
        "        # Where is the light?\n",
        "        light_comment = Text(\"Where is the light?\")\n",
        "        light_comment.set_color(YELLOW)\n",
        "        light_comment.to_corner(UR)\n",
        "        light_comment.set_backstroke()\n",
        "        light_comment.fix_in_frame()\n",
        "\n",
        "        cube.clear_updaters()\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(cube))\n",
        "        self.play(\n",
        "            FadeIn(light_comment, 0.5 * UP),\n",
        "            light.animate.next_to(cube, OUT, buff=1.5),\n",
        "            run_time=2,\n",
        "        )\n",
        "        light_lines.update()\n",
        "        self.play(\n",
        "            ShowCreation(light_lines, lag_ratio=0.01, run_time=3),\n",
        "        )\n",
        "        self.play(\n",
        "            light.animate.shift(1.0 * IN),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            light.animate.shift(4 * RIGHT),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(light, PI, about_point=light.get_z() * OUT),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(light.animate.shift(4 * RIGHT), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        # Light straight above\n",
        "        self.play(\n",
        "            frame.animate.set_height(12).set_z(4),\n",
        "            light.animate.set_z(10),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(light.animate.move_to(75 * OUT), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_height(8).set_z(2),\n",
        "            LaggedStart(*map(FadeOut, (question, subquestion, light_comment))),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Flat projection\n",
        "        verts = np.array([*cube[0].get_vertices(), *cube[5].get_vertices()])\n",
        "        vert_dots = DotCloud(verts)\n",
        "        vert_dots.set_glow_factor(0.5)\n",
        "        vert_dots.set_color(WHITE)\n",
        "        proj_dots = vert_dots.copy()\n",
        "        proj_dots.apply_function(flat_project)\n",
        "        proj_dots.set_color(GREY_B)\n",
        "        vert_proj_lines = VGroup(*(\n",
        "            DashedLine(*pair)\n",
        "            for pair in zip(verts, proj_dots.get_points())\n",
        "        ))\n",
        "        vert_proj_lines.set_stroke(WHITE, 1, 0.5)\n",
        "\n",
        "        point = verts[np.argmax(verts[:, 0])]\n",
        "        xyz_label = OldTex(\"(x, y, z)\")\n",
        "        xy0_label = OldTex(\"(x, y, 0)\")\n",
        "        for label in xyz_label, xy0_label:\n",
        "            label.rotate(PI / 2, RIGHT)\n",
        "            label.set_backstroke()\n",
        "        xyz_label.next_to(point, RIGHT)\n",
        "        xy0_label.next_to(flat_project(point), RIGHT)\n",
        "\n",
        "        vert_dots.save_state()\n",
        "        vert_dots.set_glow_factor(5)\n",
        "        vert_dots.set_radius(0.5)\n",
        "        vert_dots.set_opacity(0)\n",
        "        self.play(\n",
        "            Restore(vert_dots),\n",
        "            Write(xyz_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                cube.deepcopy().clear_updaters().set_opacity(0.5),\n",
        "                shadow.deepcopy().clear_updaters().set_opacity(0),\n",
        "                remover=True\n",
        "            ),\n",
        "            TransformFromCopy(vert_dots, proj_dots),\n",
        "            TransformFromCopy(xyz_label, xy0_label),\n",
        "            *map(ShowCreation, vert_proj_lines),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(LaggedStart(*map(FadeOut, (\n",
        "            vert_dots, vert_proj_lines, proj_dots,\n",
        "            xyz_label, xy0_label\n",
        "        ))))\n",
        "\n",
        "        # Square projection\n",
        "        top_face = cube[np.argmax([f.get_z() for f in cube])]\n",
        "        normal_vect = top_face.get_unit_normal()\n",
        "        theta = np.arccos(normal_vect[2])\n",
        "        axis = normalize(rotate_vector([*normal_vect[:2], 0], PI / 2, OUT))\n",
        "\n",
        "        self.play(Rotate(cube, -theta, axis))\n",
        "        top_face = cube[np.argmax([f.get_z() for f in cube])]\n",
        "        verts = top_face.get_vertices()\n",
        "        vect = verts[3] - verts[2]\n",
        "        angle = angle_of_vector(vect)\n",
        "        self.play(Rotate(cube, -angle, OUT))\n",
        "        self.wait()\n",
        "\n",
        "        corner = cube.get_corner(DL + OUT)\n",
        "        edge_lines = VGroup(\n",
        "            Line(corner, cube.get_corner(DR + OUT)),\n",
        "            Line(corner, cube.get_corner(UL + OUT)),\n",
        "            Line(corner, cube.get_corner(DL + IN)),\n",
        "        )\n",
        "        edge_lines.set_stroke(RED, 2)\n",
        "        s_labels = OldTex(\"s\").replicate(3)\n",
        "        s_labels.set_color(RED)\n",
        "        s_labels.rotate(PI / 2, RIGHT)\n",
        "        s_labels.set_stroke(BLACK, 3, background=True)\n",
        "        for label, line, vect in zip(s_labels, edge_lines, [OUT, LEFT, LEFT]):\n",
        "            label.next_to(line, vect, buff=SMALL_BUFF)\n",
        "        s_labels[1].next_to(edge_lines[1], OUT)\n",
        "        s_labels[2].next_to(edge_lines[2], LEFT)\n",
        "\n",
        "        s_squared = OldTex(\"s^2\")\n",
        "        s_squared.match_style(s_labels[0])\n",
        "        s_squared.move_to(self.shadow)\n",
        "\n",
        "        frame.generate_target()\n",
        "        frame.target.reorient(10, 60)\n",
        "        frame.target.set_height(6.5)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, edge_lines),\n",
        "            LaggedStartMap(FadeIn, s_labels, scale=2),\n",
        "            MoveToTarget(frame, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(s_labels[:2], s_squared),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        rect = SurroundingRectangle(area_label)\n",
        "        rect.fix_in_frame()\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "        s_eq = OldTex(\"s = 1\")\n",
        "        s_eq.next_to(area_label, DOWN)\n",
        "        s_eq.set_color(RED)\n",
        "        s_eq.set_stroke(BLACK, 3, background=True)\n",
        "        s_eq.fix_in_frame()\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeIn(s_eq, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, (\n",
        "            rect, s_eq, *edge_lines, *s_labels, s_squared,\n",
        "        ))))\n",
        "        self.wait()\n",
        "\n",
        "        # Hexagonal orientation\n",
        "        axis = UL\n",
        "        angle = np.arccos(1 / math.sqrt(3))\n",
        "        area_label.suspend_updating()\n",
        "        self.play(\n",
        "            Rotate(cube, -angle, axis),\n",
        "            frame.animate.reorient(-10, 70),\n",
        "            ChangeDecimalToValue(area_label[1], math.sqrt(3)),\n",
        "            UpdateFromFunc(area_label[1], lambda m: m.fix_in_frame()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add(area_label)\n",
        "\n",
        "        diagonal = Line(cube.get_nadir(), cube.get_zenith())\n",
        "        diagonal.set_stroke(WHITE, 2)\n",
        "        diagonal.scale(2)\n",
        "        diagonal.move_to(ORIGIN, IN)\n",
        "        self.add(diagonal, cube)\n",
        "        self.play(ShowCreation(diagonal))\n",
        "\n",
        "        self.wait(2)\n",
        "        frame.save_state()\n",
        "        cube_opacity = cube[0].get_fill_opacity()\n",
        "        cube.save_state()\n",
        "        angle = angle_of_vector(outline.get_anchors()[-1] - outline.get_anchors()[-2])\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0),\n",
        "            cube.animate.rotate(-angle).set_opacity(0.2),\n",
        "            run_time=3,\n",
        "        )\n",
        "        frame.suspend_updating()\n",
        "        outline_copy = outline.copy().clear_updaters()\n",
        "        outline_copy.set_stroke(RED, 5)\n",
        "        title = Text(\"Regular hexagon\")\n",
        "        title.set_color(RED)\n",
        "        title.next_to(outline_copy, UP)\n",
        "        title.set_backstroke()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(outline_copy),\n",
        "            Write(title, run_time=1),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            Restore(frame),\n",
        "            cube.animate.set_opacity(cube_opacity).rotate(angle),\n",
        "            run_time=3,\n",
        "        )\n",
        "        frame.resume_updating()\n",
        "\n",
        "        hex_area_label = OldTex(\"\\\\sqrt{3} s^2\")\n",
        "        hex_area_label.set_color(RED)\n",
        "        hex_area_label.move_to(self.shadow)\n",
        "        hex_area_label.shift(0.35 * DOWN)\n",
        "        self.play(Write(hex_area_label))\n",
        "        self.wait(10)\n",
        "        area_label.resume_updating()\n",
        "        self.play(\n",
        "            Uncreate(diagonal),\n",
        "            FadeOut(hex_area_label),\n",
        "            Rotate(cube, 4, RIGHT)\n",
        "        )\n",
        "\n",
        "        # Talk about averages\n",
        "        light_lines.clear_updaters()\n",
        "        self.begin_ambient_rotation(cube)\n",
        "        self.play(\n",
        "            FadeOut(light_lines),\n",
        "            FadeIn(question, 0.5 * UP),\n",
        "            ApplyMethod(frame.set_height, 8, run_time=2)\n",
        "        )\n",
        "        self.play(FadeIn(subquestion, 0.5 * UP))\n",
        "        self.wait(7)\n",
        "\n",
        "        cube.clear_updaters()\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        samples = VGroup(VectorizedPoint())\n",
        "        samples.to_corner(UR)\n",
        "        samples.shift(1.5 * LEFT)\n",
        "        self.add(samples)\n",
        "        for x in range(9):\n",
        "            self.random_toss()\n",
        "            sample = area_label[1].copy()\n",
        "            sample.clear_updaters()\n",
        "            sample.fix_in_frame()\n",
        "            self.play(\n",
        "                sample.animate.next_to(samples, DOWN),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            samples.add(sample)\n",
        "\n",
        "        v_dots = OldTex(\"\\\\vdots\")\n",
        "        v_dots.next_to(samples, DOWN)\n",
        "        v_dots.fix_in_frame()\n",
        "        samples.add(v_dots)\n",
        "        brace = Brace(samples, LEFT)\n",
        "        brace.fix_in_frame()\n",
        "        brace.next_to(samples, LEFT, SMALL_BUFF)\n",
        "        text = OldTexText(\n",
        "            \"Take the mean.\", \"\\\\\\\\What does that\\\\\\\\approach?\",\n",
        "            font_size=30\n",
        "        )\n",
        "        text[0].shift(MED_SMALL_BUFF * UP)\n",
        "        text.next_to(brace, LEFT)\n",
        "        text.fix_in_frame()\n",
        "        VGroup(text, brace).set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(text),\n",
        "            Write(v_dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for x in range(10):\n",
        "            self.random_toss()\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class AskAboutAveraging(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        sts = self.students\n",
        "        tch = self.teacher\n",
        "\n",
        "        self.play_student_changes(\n",
        "            \"maybe\", \"thinking\", \"erm\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[self.teacher.change(\"raise_right_hand\", self.screen)]\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            PiCreatureBubbleIntroduction(\n",
        "                sts[2], OldTexText(\"What does that\\\\\\\\mean, exactly?\"),\n",
        "                target_mode=\"hesitant\",\n",
        "                look_at=self.screen,\n",
        "                bubble_config={\"direction\": LEFT}\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                sts[0].change(\"confused\", self.screen),\n",
        "                sts[1].change(\"pondering\", self.screen),\n",
        "                tch.change(\"tease\", sts[2].eyes),\n",
        "            )\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.student_says(\n",
        "            \"Can we do an experiment?\",\n",
        "            target_mode=\"raise_left_hand\",\n",
        "            index=1,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.student_says(\n",
        "            OldTexText(\"But what defines a\\\\\\\\``random'' toss?\"),\n",
        "            look_at=self.screen,\n",
        "            target_mode=\"hesitant\",\n",
        "            index=2,\n",
        "            added_anims=[\n",
        "                self.teacher.change(\"guilty\"),\n",
        "                self.students[0].change(\"erm\"),\n",
        "            ]\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(LaggedStart(\n",
        "            self.students[0].change(\"pondering\", self.screen),\n",
        "            self.students[1].change(\"maybe\", self.screen),\n",
        "            self.teacher.change(\"tease\", self.screen),\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.teacher_says(OldTexText(\"Hold off until\\\\\\\\the end\"))\n",
        "        self.wait(3)\n",
        "        self.play_student_changes(\n",
        "            \"thinking\", \"tease\", \"pondering\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[self.teacher.change(\"tease\", self.students)]\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class MeanCalculation(Scene):\n",
        "    def construct(self):\n",
        "        values = [1.55, 1.33, 1.46, 1.34, 1.50, 1.26, 1.42, 1.54, 1.51]\n",
        "        nums = VGroup(*(\n",
        "            DecimalNumber(x)\n",
        "            for x in values\n",
        "        ))\n",
        "        nums.arrange(DOWN, aligned_edge=LEFT)\n",
        "        nums.to_corner(UR, buff=LARGE_BUFF).shift(0.5 * LEFT)\n",
        "\n",
        "        self.add(nums)\n",
        "\n",
        "        mean_label = Text(\"Mean\", font_size=36)\n",
        "        mean_label.set_color(GREEN)\n",
        "        mean_label.set_backstroke()\n",
        "        mean_arrow = Vector(0.25 * UR)\n",
        "        mean_arrow.match_color(mean_label)\n",
        "        mean_arrow.next_to(mean_label, UR, SMALL_BUFF)\n",
        "        mean_label.add(mean_arrow)\n",
        "\n",
        "        for n in range(len(nums)):\n",
        "            brace = Brace(nums[:n + 1], LEFT, buff=SMALL_BUFF)\n",
        "            mean = DecimalNumber(np.mean(values[:n + 1]))\n",
        "            mean.next_to(brace, LEFT)\n",
        "            mean.match_color(mean_label)\n",
        "            VGroup(brace, mean).set_backstroke()\n",
        "            mean_label.next_to(mean, DL, SMALL_BUFF)\n",
        "\n",
        "            self.add(brace, mean, mean_label)\n",
        "            self.wait(0.5)\n",
        "            self.remove(brace, mean)\n",
        "        self.add(brace, mean)\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class DescribeSO3(ShadowScene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.set_z(1)\n",
        "        frame.reorient(0)\n",
        "        cube = self.solid\n",
        "        cube.set_opacity(0.95)\n",
        "        cube.move_to(ORIGIN)\n",
        "        self.remove(self.plane)\n",
        "        self.remove(self.shadow)\n",
        "\n",
        "        x_point = VectorizedPoint(cube.get_right())\n",
        "        y_point = VectorizedPoint(cube.get_top())\n",
        "        z_point = VectorizedPoint(cube.get_zenith())\n",
        "        cube.add(x_point, y_point, z_point)\n",
        "\n",
        "        def get_matrix():\n",
        "            return np.array([\n",
        "                x_point.get_center(),\n",
        "                y_point.get_center(),\n",
        "                z_point.get_center(),\n",
        "            ]).T\n",
        "\n",
        "        def get_mat_mob():\n",
        "            matrix = DecimalMatrix(\n",
        "                get_matrix(),\n",
        "                element_to_mobject_config=dict(\n",
        "                    num_decimal_places=2,\n",
        "                    edge_to_fix=LEFT,\n",
        "                    include_sign=True,\n",
        "                ),\n",
        "                h_buff=2.0,\n",
        "                element_alignment_corner=LEFT,\n",
        "            )\n",
        "            matrix.fix_in_frame()\n",
        "            matrix.set_height(1.25)\n",
        "            brackets = matrix.get_brackets()\n",
        "            brackets[1].move_to(brackets[0].get_center() + 3.45 * RIGHT)\n",
        "            matrix.to_corner(UL)\n",
        "            return matrix\n",
        "\n",
        "        matrix = always_redraw(get_mat_mob)\n",
        "        self.add(matrix)\n",
        "\n",
        "        # Space of orientations\n",
        "        self.begin_ambient_rotation(cube, speed=0.4)\n",
        "        self.wait(2)\n",
        "\n",
        "        question = Text(\"What is the space of all orientations?\")\n",
        "        question.to_corner(UR)\n",
        "        question.fix_in_frame()\n",
        "        SO3 = OldTex(\"SO(3)\")\n",
        "        SO3.next_to(question, DOWN)\n",
        "        SO3.set_color(BLUE)\n",
        "        SO3.fix_in_frame()\n",
        "\n",
        "        self.play(Write(question))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(SO3, DOWN))\n",
        "        self.wait(2)\n",
        "        self.play(SO3.animate.next_to(matrix, DOWN, MED_LARGE_BUFF))\n",
        "        self.wait(5)\n",
        "\n",
        "        new_question = Text(\n",
        "            \"What probability distribution are we placing\\n\"\n",
        "            \"on the space of all orientations?\",\n",
        "            t2c={\"probability distribution\": YELLOW},\n",
        "            t2s={\"probability distribution\": ITALIC},\n",
        "        )\n",
        "        new_question.match_width(question)\n",
        "        new_question.move_to(question, UP)\n",
        "        new_question.fix_in_frame()\n",
        "\n",
        "        n = len(\"the space of all orientations?\")\n",
        "        self.play(\n",
        "            FadeTransform(question[-n:], new_question[-n:]),\n",
        "            FadeOut(question[:-n]),\n",
        "            FadeIn(new_question[:-n]),\n",
        "        )\n",
        "        self.wait()\n",
        "        cube.clear_updaters()\n",
        "\n",
        "        N = 15\n",
        "        cube_field = cube.get_grid(N, N)\n",
        "        cube_field.set_height(10)\n",
        "\n",
        "        for n, c in enumerate(cube_field):\n",
        "            c.rotate(PI * (n // N) / N, axis=RIGHT)\n",
        "            c.rotate(PI * (n % N) / N, axis=UP)\n",
        "            for face in c:\n",
        "                face.set_stroke(width=0)\n",
        "            self.sort_to_camera(c)\n",
        "\n",
        "        matrix.clear_updaters()\n",
        "        self.play(\n",
        "            FadeTransform(cube, cube_field[0]),\n",
        "            LaggedStartMap(FadeIn, cube_field, run_time=15, lag_ratio=0.1)\n",
        "        )\n",
        "        self.add(cube_field)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PauseAndPonder(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"The goal is\\\\\\\\not speed.\"),\n",
        "            added_anims=[self.change_students(\n",
        "                \"tease\", \"well\", \"pondering\",\n",
        "                look_at=self.screen\n",
        "            )]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.teacher, target_mode=\"tease\"),\n",
        "            PiCreatureBubbleIntroduction(\n",
        "                self.students[2],\n",
        "                Lightbulb(),\n",
        "                bubble_type=ThoughtBubble,\n",
        "                bubble_creation_class=lambda m: FadeIn(m, lag_ratio=0.1),\n",
        "                bubble_config=dict(\n",
        "                    height=3,\n",
        "                    width=3,\n",
        "                    direction=LEFT,\n",
        "                ),\n",
        "                target_mode=\"thinking\",\n",
        "                look_at=self.screen,\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"Pause and ponder!\",\n",
        "            target_mode=\"well\",\n",
        "            added_anims=[self.change_students(\n",
        "                \"pondering\", \"tease\", \"thinking\"\n",
        "            )],\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class StartSimple(Scene):\n",
        "    def construct(self):\n",
        "        # Words\n",
        "        title = Text(\"Universal problem-solving advice\")\n",
        "        title.set_width(FRAME_WIDTH - 4)\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(BLUE)\n",
        "        title.set_backstroke()\n",
        "        line = Underline(title, buff=-0.035)\n",
        "        line.set_width(FRAME_WIDTH - 1)\n",
        "        line.set_color(BLUE_B)\n",
        "        line.set_stroke(width=[0, 3, 3, 3, 0])\n",
        "        line.insert_n_curves(101)\n",
        "\n",
        "        words = Text(\n",
        "            \"Start with the simplest non-trivial\\n\"\n",
        "            \"variant of the problem you can.\"\n",
        "        )\n",
        "        words.next_to(line, DOWN, MED_SMALL_BUFF)\n",
        "        rect = BackgroundRectangle(words, fill_opacity=1, buff=SMALL_BUFF)\n",
        "        words.set_backstroke(width=5)\n",
        "\n",
        "        # Shapes\n",
        "        cube = VCube()\n",
        "        cube.deactivate_depth_test()\n",
        "        cube.set_color(BLUE_E)\n",
        "        cube.set_opacity(0.75)\n",
        "        cube.set_stroke(WHITE, 0.5, 0.5)\n",
        "        cube.set_height(2)\n",
        "        cube.rotate(PI / 4, [1, 2, 0])\n",
        "        cube.sort(lambda p: p[2])\n",
        "        cube = Group(*cube)\n",
        "        cube.set_gloss(1)\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        face = cube[np.argmax([f.get_z() for f in cube])].copy()\n",
        "        group = Group(cube, arrow, face)\n",
        "        group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        group.next_to(words, DOWN, LARGE_BUFF)\n",
        "        group.set_width(2)\n",
        "        group.to_edge(RIGHT)\n",
        "        group.set_y(0)\n",
        "\n",
        "        self.camera.light_source.set_x(-4)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(title, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(words, lag_ratio=0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(words.get_part_by_text(\"non-trivial\"), run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*map(DrawBorderThenFill, cube)),\n",
        "            ShowCreation(arrow),\n",
        "            TransformFromCopy(cube[-1], face)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class FocusOnOneFace(ShadowScene):\n",
        "    inf_light = True\n",
        "    limited_plane_extension = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # Some random tumbling\n",
        "        cube = self.solid\n",
        "        shadow = self.shadow\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        words = VGroup(\n",
        "            Text(\"Just one orientation\"),\n",
        "            Text(\"Just one face\"),\n",
        "        )\n",
        "        words.fix_in_frame()\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        words.to_corner(UL)\n",
        "        average_words = Text(\"Average over all orientations\")\n",
        "        average_words.move_to(words[0], LEFT)\n",
        "        average_words.fix_in_frame()\n",
        "        self.add(average_words)\n",
        "\n",
        "        self.random_toss(run_time=3, rate_func=linear)\n",
        "        self.play(\n",
        "            FadeIn(words[0], 0.75 * UP),\n",
        "            FadeOut(average_words, 0.75 * UP),\n",
        "            run_time=0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Just one face\n",
        "        cube.update()\n",
        "        index = np.argmax([f.get_z() for f in cube])\n",
        "        face = cube[index]\n",
        "        prev_opacity = face.get_fill_opacity()\n",
        "        cube.generate_target(use_deepcopy=True)\n",
        "        cube.target.clear_updaters()\n",
        "        cube.target.space_out_submobjects(2, about_point=face.get_center())\n",
        "        cube.target.set_opacity(0)\n",
        "        cube.target[index].set_opacity(prev_opacity)\n",
        "\n",
        "        self.shadow.set_stroke(width=0)\n",
        "        self.play(\n",
        "            MoveToTarget(cube),\n",
        "            FadeIn(words[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-10, 65),\n",
        "            FlashAround(words[1], rate_func=squish_rate_func(smooth, 0.2, 0.5)),\n",
        "            FlashAround(words[0], rate_func=squish_rate_func(smooth, 0.5, 0.8)),\n",
        "            run_time=5,\n",
        "        )\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.01 * dt))\n",
        "\n",
        "        self.solid = face\n",
        "        self.remove(shadow)\n",
        "        self.add_shadow()\n",
        "        shadow = self.shadow\n",
        "\n",
        "        # Ask about area\n",
        "        area_q = Text(\"Area?\")\n",
        "        area_q.add_updater(lambda m: m.move_to(shadow))\n",
        "        self.play(Write(area_q))\n",
        "        self.wait()\n",
        "\n",
        "        # Orient straight up\n",
        "        unit_normal = face.get_unit_normal()\n",
        "        axis = rotate_vector(normalize([*unit_normal[:2], 0]), PI / 2, OUT)\n",
        "        angle = np.arccos(unit_normal[2])\n",
        "        face.generate_target()\n",
        "        face.target.rotate(-angle, axis)\n",
        "        face.target.move_to(3 * OUT)\n",
        "        face.target.rotate(-PI / 4, OUT)\n",
        "        self.play(MoveToTarget(face))\n",
        "\n",
        "        light_lines = self.get_light_lines(n_lines=4, outline=shadow, only_vertices=True)\n",
        "        light_lines.set_stroke(YELLOW, 1, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_phi(70 * DEGREES),\n",
        "            FadeIn(light_lines, lag_ratio=0.5),\n",
        "            TransformFromCopy(face, face.deepcopy().set_opacity(0).set_z(0), remover=True),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Rotate(face, PI / 2, UP),\n",
        "            FadeOut(area_q, scale=0),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Rotate(face, -PI / 3, UP),\n",
        "            UpdateFromAlphaFunc(light_lines, lambda m, a: m.set_opacity(0.5 * (1 - a)), remover=True),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show normal vector\n",
        "        z_axis = VGroup(\n",
        "            Line(ORIGIN, face.get_center()),\n",
        "            Line(face.get_center(), 10 * OUT),\n",
        "        )\n",
        "        z_axis.set_stroke(WHITE, 1)\n",
        "\n",
        "        normal_vect = Vector()\n",
        "        get_fc = face.get_center\n",
        "\n",
        "        def get_un():\n",
        "            return face.get_unit_normal(recompute=True)\n",
        "\n",
        "        def get_theta():\n",
        "            return np.arccos(get_un()[2])\n",
        "\n",
        "        normal_vect.add_updater(lambda v: v.put_start_and_end_on(\n",
        "            get_fc(), get_fc() + get_un(),\n",
        "        ))\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            start_angle=PI / 2,\n",
        "            angle=-get_theta(),\n",
        "            radius=0.5,\n",
        "            stroke_width=2,\n",
        "        ).rotate(PI / 2, RIGHT, about_point=ORIGIN).shift(get_fc()))\n",
        "        theta = OldTex(\"\\\\theta\", font_size=30)\n",
        "        theta.set_backstroke()\n",
        "        theta.rotate(PI / 2, RIGHT)\n",
        "        theta.add_updater(lambda m: m.move_to(\n",
        "            get_fc() + 1.3 * (arc.pfp(0.5) - get_fc())\n",
        "        ))\n",
        "        theta.add_updater(lambda m: m.set_width(min(0.123, max(0.01, arc.get_width()))))\n",
        "\n",
        "        self.play(ShowCreation(normal_vect))\n",
        "        self.wait()\n",
        "        self.add(z_axis[0], face, z_axis[1], normal_vect)\n",
        "        self.play(*map(FadeIn, z_axis))\n",
        "        self.play(\n",
        "            FadeIn(theta, 0.5 * OUT), ShowCreation(arc),\n",
        "        )\n",
        "\n",
        "        # Vary Theta\n",
        "        frame.reorient(2)\n",
        "        face.rotate(-35 * DEGREES, get_un(), about_point=face.get_center())\n",
        "        self.play(\n",
        "            Rotate(face, 50 * DEGREES, UP),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "        # Show shadow area in the corner\n",
        "        axes = Axes(\n",
        "            (0, 180, 22.5), (0, 1, 0.25),\n",
        "            width=5,\n",
        "            height=2,\n",
        "            axis_config={\n",
        "                \"include_tip\": False,\n",
        "                \"tick_size\": 0.05,\n",
        "                \"numbers_to_exclude\": [],\n",
        "            },\n",
        "        )\n",
        "        axes.to_corner(UR, buff=MED_SMALL_BUFF)\n",
        "        axes.x_axis.add_numbers([0, 45, 90, 135, 180], unit=\"^\\\\circ\")\n",
        "        y_label = OldTexText(\"Shadow's area\", font_size=24)\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, MED_SMALL_BUFF)\n",
        "        y_label.set_backstroke()\n",
        "        ly_label = OldTex(\"s^2\", font_size=24)\n",
        "        ly_label.next_to(axes.y_axis.get_top(), LEFT, SMALL_BUFF)\n",
        "        ly_label.shift(0.05 * UP)\n",
        "        axes.add(y_label, ly_label)\n",
        "        axes.fix_in_frame()\n",
        "\n",
        "        graph = axes.get_graph(\n",
        "            lambda x: math.cos(x * DEGREES),\n",
        "            x_range=(0, 90),\n",
        "        )\n",
        "        graph.set_stroke(RED, 3)\n",
        "        graph.fix_in_frame()\n",
        "\n",
        "        question = Text(\"Can you guess?\", font_size=36)\n",
        "        question.to_corner(UR)\n",
        "        question.set_color(RED)\n",
        "\n",
        "        dot = Dot(color=RED)\n",
        "        dot.scale(0.5)\n",
        "        dot.move_to(axes.c2p(0, 1))\n",
        "        dot.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes),\n",
        "            Rotate(face, -get_theta(), UP, run_time=2),\n",
        "        )\n",
        "        self.play(FadeIn(dot, shift=2 * UP + RIGHT))\n",
        "        self.wait(2)\n",
        "        self.add(graph, axes)\n",
        "        self.play(\n",
        "            UpdateFromFunc(dot, lambda d: d.move_to(graph.get_end())),\n",
        "            ShowCreation(graph),\n",
        "            Rotate(face, PI / 2, UP),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(frame.animate.reorient(45), run_time=2)\n",
        "        self.play(frame.animate.reorient(5), run_time=4)\n",
        "\n",
        "        # Show vertical plane\n",
        "        plane = Rectangle(width=self.plane.get_width(), height=5)\n",
        "        plane.insert_n_curves(100)\n",
        "        plane.set_fill(WHITE, 0.25)\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.apply_depth_test()\n",
        "\n",
        "        plane.rotate(PI / 2, RIGHT)\n",
        "        plane.move_to(ORIGIN, IN)\n",
        "        plane.save_state()\n",
        "        plane.stretch(0, 2, about_edge=IN)\n",
        "\n",
        "        face.apply_depth_test()\n",
        "        z_axis.apply_depth_test()\n",
        "        self.shadow.apply_depth_test()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(*words, graph, axes, dot)),\n",
        "            Restore(plane, run_time=3)\n",
        "        )\n",
        "        self.play(Rotate(face, -60 * DEGREES, UP, run_time=2))\n",
        "\n",
        "        # Slice up face\n",
        "        face_copy = face.deepcopy()\n",
        "        face_copy.rotate(-get_theta(), UP)\n",
        "        face_copy.move_to(ORIGIN)\n",
        "\n",
        "        n_slices = 25\n",
        "        rects = Rectangle().replicate(n_slices)\n",
        "        rects.arrange(DOWN, buff=0)\n",
        "        rects.replace(face_copy, stretch=True)\n",
        "        slices = VGroup(*(Intersection(face_copy, rect) for rect in rects))\n",
        "        slices.match_style(face_copy)\n",
        "        slices.set_stroke(width=0)\n",
        "        slices.rotate(get_theta(), UP)\n",
        "        slices.move_to(face)\n",
        "        slices.apply_depth_test()\n",
        "        slices.save_state()\n",
        "        slice_outlines = slices.copy()\n",
        "        slice_outlines.set_stroke(RED, 1)\n",
        "        slice_outlines.set_fill(opacity=0)\n",
        "        slice_outlines.deactivate_depth_test()\n",
        "\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.set_euler_angles(PI / 2, get_theta()),\n",
        "            FadeOut(VGroup(theta, arc)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(ShowCreation(slice_outlines, lag_ratio=0.05))\n",
        "\n",
        "        self.remove(face)\n",
        "        self.add(slices)\n",
        "        self.remove(self.shadow)\n",
        "        self.solid = slices\n",
        "        self.add_shadow()\n",
        "        self.shadow.set_stroke(width=0)\n",
        "        self.add(normal_vect, plane, slice_outlines)\n",
        "\n",
        "        slices.insert_n_curves(10)\n",
        "        slices.generate_target()\n",
        "        for sm in slices.target:\n",
        "            sm.stretch(0.5, 1)\n",
        "        self.play(\n",
        "            MoveToTarget(slices),\n",
        "            FadeOut(slice_outlines),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Focus on one slice\n",
        "        long_slice = slices[len(slices) // 2].deepcopy()\n",
        "        line = Line(long_slice.get_corner(LEFT + OUT), long_slice.get_corner(RIGHT + IN))\n",
        "        line.scale(0.97)\n",
        "        line.set_stroke(BLUE, 3)\n",
        "\n",
        "        frame.generate_target()\n",
        "        frame.target.reorient(0, 90)\n",
        "        frame.target.set_height(6)\n",
        "        frame.target.move_to(2.5 * OUT)\n",
        "        self.shadow.clear_updaters()\n",
        "        self.play(\n",
        "            MoveToTarget(frame),\n",
        "            *map(FadeIn, (theta, arc)),\n",
        "            FadeOut(plane),\n",
        "            FadeOut(slices),\n",
        "            FadeOut(self.shadow),\n",
        "            FadeIn(line),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Analyze slice\n",
        "        shadow = line.copy()\n",
        "        shadow.stretch(0, 2, about_edge=IN)\n",
        "        shadow.set_stroke(BLUE_E)\n",
        "        vert_line = Line(line.get_start(), shadow.get_start())\n",
        "        vert_line.set_stroke(GREY_B, 3)\n",
        "\n",
        "        shadow_label = Text(\"Shadow\")\n",
        "        shadow_label.set_fill(BLUE_E)\n",
        "        shadow_label.set_backstroke()\n",
        "        shadow_label.rotate(PI / 2, RIGHT)\n",
        "        shadow_label.next_to(shadow, IN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(line, shadow),\n",
        "            FadeIn(shadow_label, 0.5 * IN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(vert_line))\n",
        "        self.wait()\n",
        "\n",
        "        top_theta_group = VGroup(\n",
        "            z_axis[1].copy(),\n",
        "            arc.copy().clear_updaters(),\n",
        "            theta.copy().clear_updaters(),\n",
        "            Line(*normal_vect.get_start_and_end()).match_style(z_axis[1].copy()),\n",
        "        )\n",
        "        self.play(\n",
        "            top_theta_group.animate.move_to(line.get_start(), LEFT + IN)\n",
        "        )\n",
        "\n",
        "        elbow = Elbow(angle=-get_theta())\n",
        "        elbow.set_stroke(WHITE, 2)\n",
        "        ul_arc = Arc(\n",
        "            radius=0.4,\n",
        "            start_angle=-get_theta(),\n",
        "            angle=-(PI / 2 - get_theta())\n",
        "        )\n",
        "        ul_arc.match_style(elbow)\n",
        "        supl = OldTex(\"90^\\\\circ - \\\\theta\", font_size=24)\n",
        "        supl.next_to(ul_arc, DOWN, SMALL_BUFF, aligned_edge=LEFT)\n",
        "        supl.set_backstroke()\n",
        "        supl[0][:3].shift(SMALL_BUFF * RIGHT / 2)\n",
        "\n",
        "        ul_angle_group = VGroup(elbow, ul_arc, supl)\n",
        "        ul_angle_group.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "        ul_angle_group.shift(line.get_start())\n",
        "\n",
        "        dr_arc = Arc(\n",
        "            radius=0.4,\n",
        "            start_angle=PI,\n",
        "            angle=-get_theta(),\n",
        "        )\n",
        "        dr_arc.match_style(ul_arc)\n",
        "        dr_arc.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "        dr_arc.shift(line.get_end())\n",
        "        dr_theta = OldTex(\"\\\\theta\", font_size=24)\n",
        "        dr_theta.rotate(PI / 2, RIGHT)\n",
        "        dr_theta.next_to(dr_arc, LEFT, SMALL_BUFF)\n",
        "        dr_theta.shift(SMALL_BUFF * OUT / 2)\n",
        "\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.play(\n",
        "            ShowCreation(ul_arc),\n",
        "            FadeTransform(top_theta_group[2].copy(), supl),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(ul_arc, dr_arc),\n",
        "            TransformFromCopy(supl[0][4].copy().set_stroke(width=0), dr_theta[0][0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight lower right\n",
        "        rect = Rectangle(0.8, 0.5)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        rect.rotate(PI / 2, RIGHT)\n",
        "        rect.move_to(dr_theta, LEFT).shift(SMALL_BUFF * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            top_theta_group.animate.fade(0.8),\n",
        "            ul_angle_group.animate.fade(0.8),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show cosine\n",
        "        cos_formula = OldTex(\n",
        "            \"\\\\cos(\\\\theta)\", \"=\",\n",
        "            \"{\\\\text{Length of }\", \"\\\\text{shadow}\",\n",
        "            \"\\\\over\",\n",
        "            \"\\\\text{Length of }\", \"\\\\text{slice}\"\n",
        "            \"}\",\n",
        "        )\n",
        "        cos_formula[2:].scale(0.75, about_edge=LEFT)\n",
        "        cos_formula.to_corner(UR)\n",
        "        cos_formula.fix_in_frame()\n",
        "\n",
        "        lower_formula = OldTex(\n",
        "            \"\\\\text{shadow}\", \"=\",\n",
        "            \"\\\\cos(\\\\theta)\", \"\\\\cdot\", \"\\\\text{slice}\"\n",
        "        )\n",
        "        lower_formula.match_width(cos_formula)\n",
        "        lower_formula.next_to(cos_formula, DOWN, MED_LARGE_BUFF)\n",
        "        lower_formula.fix_in_frame()\n",
        "\n",
        "        for tex in cos_formula, lower_formula:\n",
        "            tex.set_color_by_tex(\"shadow\", BLUE_D)\n",
        "            tex.set_color_by_tex(\"slice\", BLUE_B)\n",
        "\n",
        "        self.play(Write(cos_formula))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(\n",
        "            VGroup(*(cos_formula[i].copy() for i in [0, 1, 3, 6])),\n",
        "            lower_formula,\n",
        "            path_arc=PI / 4,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Bring full face back\n",
        "        frame.generate_target()\n",
        "        frame.target.reorient(20, 75)\n",
        "        frame.target.set_height(6)\n",
        "        frame.target.set_z(2)\n",
        "\n",
        "        line_shadow = get_shadow(line)\n",
        "        line_shadow.set_stroke(BLUE_E, opacity=0.5)\n",
        "\n",
        "        self.solid = face\n",
        "        self.add_shadow()\n",
        "        self.add(z_axis[0], face, z_axis[1], line, normal_vect, theta, arc)\n",
        "        self.play(\n",
        "            MoveToTarget(frame, run_time=5),\n",
        "            FadeIn(face, run_time=3),\n",
        "            FadeIn(self.shadow, run_time=3),\n",
        "            FadeIn(line_shadow, run_time=3),\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                top_theta_group, ul_angle_group, rect,\n",
        "                dr_theta, dr_arc,\n",
        "                vert_line, shadow, shadow_label,\n",
        "            ]), run_time=4),\n",
        "        )\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.01 * dt))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show perpendicular\n",
        "        perp = Line(\n",
        "            face.pfp(binary_search(\n",
        "                lambda a: face.pfp(a)[2],\n",
        "                face.get_center()[2], 0, 0.5,\n",
        "            )),\n",
        "            face.pfp(binary_search(\n",
        "                lambda a: face.pfp(a)[2],\n",
        "                face.get_center()[2], 0.5, 1.0,\n",
        "            )),\n",
        "        )\n",
        "        perp.set_stroke(RED, 3)\n",
        "        perp_shadow = get_shadow(perp)\n",
        "        perp_shadow.set_stroke(RED_E, 3, opacity=0.2)\n",
        "\n",
        "        self.add(perp, normal_vect, arc)\n",
        "        self.play(\n",
        "            ShowCreation(perp),\n",
        "            ShowCreation(perp_shadow),\n",
        "        )\n",
        "        face.add(line)\n",
        "        self.play(Rotate(face, 45 * DEGREES, UP), run_time=3)\n",
        "        self.play(Rotate(face, -55 * DEGREES, UP), run_time=3)\n",
        "        self.play(Rotate(face, 20 * DEGREES, UP), run_time=2)\n",
        "\n",
        "        # Give final area formula\n",
        "        final_formula = OldTex(\n",
        "            \"\\\\text{Area}(\", \"\\\\text{shadow}\", \")\",\n",
        "            \"=\",\n",
        "            \"|\", \"\\\\cos(\\\\theta)\", \"|\", \"s^2\"\n",
        "        )\n",
        "        final_formula.set_color_by_tex(\"shadow\", BLUE_D)\n",
        "        final_formula.match_width(lower_formula)\n",
        "        final_formula.next_to(lower_formula, DOWN, MED_LARGE_BUFF)\n",
        "        final_formula.fix_in_frame()\n",
        "        final_formula.get_parts_by_tex(\"|\").set_opacity(0)\n",
        "        final_formula.set_stroke(BLACK, 3, background=True)\n",
        "        rect = SurroundingRectangle(final_formula)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        rect.fix_in_frame()\n",
        "\n",
        "        self.play(Write(final_formula))\n",
        "        self.play(ShowCreation(rect))\n",
        "        final_formula.add(rect)\n",
        "        self.wait(10)\n",
        "\n",
        "        # Absolute value\n",
        "        face.remove(line)\n",
        "        self.play(\n",
        "            frame.animate.shift(0.5 * DOWN + RIGHT).reorient(10),\n",
        "            LaggedStart(*map(FadeOut, [cos_formula, lower_formula])),\n",
        "            FadeIn(graph),\n",
        "            FadeIn(axes),\n",
        "            FadeOut(line),\n",
        "            FadeOut(line_shadow),\n",
        "            FadeOut(perp),\n",
        "            FadeOut(perp_shadow),\n",
        "            final_formula.animate.shift(2 * DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(face, PI / 2 - get_theta(), UP),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        new_graph = axes.get_graph(\n",
        "            lambda x: math.cos(x * DEGREES),\n",
        "            (90, 180),\n",
        "        )\n",
        "        new_graph.match_style(graph)\n",
        "        new_graph.fix_in_frame()\n",
        "        self.play(\n",
        "            Rotate(face, PI / 2, UP),\n",
        "            ShowCreation(new_graph),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(face, -PI / 4, UP),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        alt_normal = normal_vect.copy()\n",
        "        alt_normal.clear_updaters()\n",
        "        alt_normal.rotate(PI, UP, about_point=face.get_center())\n",
        "        alt_normal.set_color(YELLOW)\n",
        "\n",
        "        self.add(alt_normal, face, normal_vect, arc, theta)\n",
        "        self.play(ShowCreation(alt_normal))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(alt_normal))\n",
        "\n",
        "        new_graph.generate_target()\n",
        "        new_graph.target.flip(RIGHT)\n",
        "        new_graph.target.move_to(graph.get_end(), DL)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(new_graph),\n",
        "            final_formula.get_parts_by_tex(\"|\").animate.set_opacity(1),\n",
        "        )\n",
        "        self.play(\n",
        "            final_formula.animate.next_to(axes, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Rotate(face, -PI / 2, UP), run_time=5)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class NotQuiteRight(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        self.teacher_says(\n",
        "            \"Not quite right...\",\n",
        "            target_mode=\"hesitant\",\n",
        "            bubble_config={\"height\": 3, \"width\": 4},\n",
        "            added_anims=[\n",
        "                self.change_students(\n",
        "                    \"pondering\", \"thinking\", \"erm\",\n",
        "                    look_at=self.screen,\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class DiscussLinearity(Scene):\n",
        "    def construct(self):\n",
        "        # Set background\n",
        "        background = FullScreenRectangle()\n",
        "        self.add(background)\n",
        "        panels = Rectangle(4, 4).replicate(3)\n",
        "        panels.set_fill(BLACK, 1)\n",
        "        panels.set_stroke(WHITE, 2)\n",
        "        panels.set_height(FRAME_HEIGHT - 1)\n",
        "        panels.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        panels.set_width(FRAME_WIDTH - 1)\n",
        "        panels.center()\n",
        "        self.add(panels)\n",
        "\n",
        "        # Arrows\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(\n",
        "                p1.get_top(), p2.get_top(), path_arc=-0.6 * PI\n",
        "            ).scale(0.75, about_edge=DOWN)\n",
        "            for p1, p2 in zip(panels, panels[1:])\n",
        "        ))\n",
        "        arrows.space_out_submobjects(0.8)\n",
        "        arrows.rotate(PI, RIGHT, about_point=panels.get_center())\n",
        "        arrow_labels = VGroup(\n",
        "            Text(\"Rotation\", font_size=30),\n",
        "            Text(\"Flat projection\", font_size=30),\n",
        "        )\n",
        "        arrow_labels.set_backstroke()\n",
        "        for arrow, label in zip(arrows, arrow_labels):\n",
        "            label.next_to(arrow.pfp(0.5), UP, buff=0.35)\n",
        "\n",
        "        shape_labels = VGroup(\n",
        "            Text(\"Some shape\"),\n",
        "            Text(\"Any shape\"),\n",
        "        )\n",
        "        shape_labels.next_to(panels[0].get_top(), UP, SMALL_BUFF)\n",
        "\n",
        "        # self.play(Write(shape_labels[0], run_time=1))\n",
        "        # self.wait()\n",
        "\n",
        "        for arrow, label in zip(arrows, arrow_labels):\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                FadeIn(label, lag_ratio=0.1)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Linear!\n",
        "        lin_text = Text(\n",
        "            \"Both are linear transformations!\",\n",
        "            t2c={\"linear\": YELLOW}\n",
        "        )\n",
        "        lin_text.next_to(panels, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(lin_text, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Stretch words\n",
        "        uniform_words = Text(\"Uniform stretching here\", font_size=36).replicate(2)\n",
        "        for words, panel in zip(uniform_words, panels[0::2]):\n",
        "            words.next_to(panel.get_top(), DOWN, SMALL_BUFF)\n",
        "            words.set_color(YELLOW)\n",
        "            words.set_backstroke()\n",
        "            self.play(\n",
        "                FadeIn(words, lag_ratio=0.1),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Transition\n",
        "        lin_part = lin_text.get_part_by_text(\"linear\")\n",
        "        lin_copies = lin_part.copy().replicate(2)\n",
        "        lin_copies.scale(0.6)\n",
        "        for lin_copy, arrow in zip(lin_copies, arrows):\n",
        "            lin_copy.next_to(arrow.pfp(0.5), DOWN, buff=0.15)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(lin_part.replicate(2), lin_copies),\n",
        "            LaggedStart(\n",
        "                FadeOut(lin_text, lag_ratio=0.1),\n",
        "                *map(FadeOut, uniform_words)\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Areas\n",
        "        area_labels = VGroup(\n",
        "            Text(\"Area(shape)\", t2c={\"shape\": BLUE}),\n",
        "            Text(\"Area(shadow)\", t2c={\"shadow\": BLUE_E}),\n",
        "        )\n",
        "        area_exprs = VGroup(\n",
        "            OldTex(\"A\").set_color(BLUE),\n",
        "            OldTex(\"(\\\\text{some factor})\", \"\\\\cdot \", \"A\"),\n",
        "        )\n",
        "        area_exprs[1][2].set_color(BLUE)\n",
        "        area_exprs[1][0].set_color(GREY_C)\n",
        "        equals = VGroup()\n",
        "        for label, expr, panel in zip(area_labels, area_exprs, panels[0::2]):\n",
        "            label.match_x(panel)\n",
        "            label.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "            eq = OldTex(\"=\")\n",
        "            eq.rotate(PI / 2)\n",
        "            eq.next_to(label, DOWN, buff=0.15)\n",
        "            equals.add(eq)\n",
        "            expr.next_to(eq, DOWN, buff=0.15)\n",
        "\n",
        "        self.play(\n",
        "            *map(Write, area_labels),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            *(FadeIn(eq, 0.5 * DOWN) for eq in equals),\n",
        "            *(FadeIn(expr, DOWN) for expr in area_exprs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        f_rot = OldTex(\"f(\\\\text{Rot})\")\n",
        "        f_rot.set_color(GREY_B)\n",
        "        times_A = area_exprs[1][1:]\n",
        "        f_rot.next_to(times_A, LEFT, buff=0.2)\n",
        "        times_A.generate_target()\n",
        "        VGroup(f_rot, times_A.target).match_x(panels[2])\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(area_exprs[1][0], f_rot),\n",
        "            MoveToTarget(times_A)\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(f_rot, run_time=2))\n",
        "        self.wait(1)\n",
        "\n",
        "        # Determinant\n",
        "        factor = area_exprs[1].get_part_by_tex('factor')\n",
        "        rect = SurroundingRectangle(factor, buff=SMALL_BUFF)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        rot = Matrix([[\"v_1\", \"w_1\"], [\"v_2\", \"w_2\"], [\"v_3\", \"w_3\"]], h_buff=1.0)\n",
        "        rot.set_column_colors(GREEN, RED)\n",
        "        proj = Matrix([[\"1\", \"0\", \"0\"], [\"0\", \"1\", \"0\"]], h_buff=0.6)\n",
        "        prod = VGroup(proj, rot)\n",
        "        prod.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        prod.set_height(0.8)\n",
        "        det = OldTex(\n",
        "            \"\\\\text{det}\", \"\\\\Big(\", \"\\\\Big)\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{det}\": YELLOW,\n",
        "                # \"rot\": BLUE_D,\n",
        "                # \"proj\": BLUE_B,\n",
        "            },\n",
        "            font_size=36\n",
        "        )\n",
        "        det[1:].match_height(prod, stretch=True)\n",
        "        det.to_edge(UP)\n",
        "        prod.next_to(det[1], RIGHT, SMALL_BUFF)\n",
        "        det[2].next_to(prod, RIGHT, SMALL_BUFF)\n",
        "        det.add(prod)\n",
        "        det.center().to_edge(UP, buff=0.25)\n",
        "        det_rect = SurroundingRectangle(det, buff=SMALL_BUFF)\n",
        "        det_rect.set_stroke(YELLOW, 1)\n",
        "\n",
        "        rot_brace = Brace(rot, DOWN, buff=SMALL_BUFF)\n",
        "        details = Text(\"Need to work out rotation matrix...\", font_size=20)\n",
        "        details.next_to(rot_brace, DOWN, SMALL_BUFF)\n",
        "        details.set_color(GREY_A)\n",
        "\n",
        "        arrow = Arrow(rect.get_corner(UL), det.get_right())\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            FadeTransform(rect.copy(), det_rect),\n",
        "            FadeTransform(factor.copy(), det),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(det_rect),\n",
        "            GrowFromCenter(rot_brace),\n",
        "            FadeIn(details),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, (\n",
        "            *det, rot_brace, details\n",
        "        )), lag_ratio=0.3, run_time=2))\n",
        "\n",
        "        # Any shape\n",
        "        ind_words = Text(\"Independent of the shape!\", font_size=30)\n",
        "        ind_words.move_to(det)\n",
        "        ind_words.set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            arrow.animate.match_points(Arrow(factor.get_corner(UL), ind_words.get_corner(DR))),\n",
        "            Write(ind_words, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, (ind_words, arrow, rect))))\n",
        "        self.wait()\n",
        "\n",
        "        # Cross out right\n",
        "        cross = Cross(VGroup(equals[1], f_rot, times_A))\n",
        "        cross.insert_n_curves(20)\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class Matrices(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        kw = {\n",
        "            \"v_buff\": 0.7,\n",
        "            \"bracket_v_buff\": 0.15,\n",
        "            \"bracket_h_buff\": 0.15,\n",
        "        }\n",
        "        matrices = VGroup(\n",
        "            Matrix([[\"v_1\", \"w_1\"], [\"v_2\", \"w_2\"], [\"v_3\", \"w_3\"]], h_buff=1.0, **kw),\n",
        "            Matrix([[\"1\", \"0\", \"0\"], [\"0\", \"1\", \"0\"]], h_buff=0.6, **kw),\n",
        "        )\n",
        "        matrices.set_color(GREY_A)\n",
        "        matrices[0].set_column_colors(GREEN, RED)\n",
        "        matrices.arrange(LEFT, buff=SMALL_BUFF)\n",
        "        matrices.scale(0.5)\n",
        "        mat_product = matrices[:2].copy()\n",
        "\n",
        "        vectors = VGroup(\n",
        "            Matrix([[\"x_0\"], [\"y_0\"]], **kw),\n",
        "            Matrix([[\"x_1\"], [\"y_1\"], [\"z_1\"]], **kw),\n",
        "            Matrix([[\"x_2\"], [\"y_2\"]], **kw),\n",
        "        )\n",
        "\n",
        "        for vect, x in zip(vectors, [-6, 0, 6]):\n",
        "            vect.set_x(x)\n",
        "            vect.set_y(2.5)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Arrow(vectors[0], vectors[1]),\n",
        "            Arrow(vectors[1], vectors[2]),\n",
        "            Arrow(vectors[0], vectors[2]),\n",
        "        )\n",
        "\n",
        "        for mat, arrow in zip((*matrices[:2], mat_product), arrows):\n",
        "            mat.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        # Animations\n",
        "        self.add(vectors[0])\n",
        "        for i in range(2):\n",
        "            self.play(\n",
        "                FadeTransform(vectors[i].copy(), vectors[i + 1]),\n",
        "                ShowCreation(arrows[i]),\n",
        "                FadeIn(matrices[i], 0.5 * RIGHT)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Transform(arrows[0], arrows[2]),\n",
        "            Transform(arrows[1], arrows[2]),\n",
        "            Transform(matrices, mat_product),\n",
        "            FadeOut(vectors[1], scale=0),\n",
        "        )\n",
        "\n",
        "\n",
        "class DefineDeterminant(Scene):\n",
        "    def construct(self):\n",
        "        # Planes\n",
        "        plane = NumberPlane((-2, 2), (-3, 3))\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        planes = VGroup(plane, plane.deepcopy())\n",
        "        planes[0].to_edge(LEFT, buff=0)\n",
        "        planes[1].to_edge(RIGHT, buff=0)\n",
        "        planes[1].set_stroke(GREY_A, 1, 0.5)\n",
        "        planes[1].faded_lines.set_opacity(0)\n",
        "\n",
        "        titles = VGroup(\n",
        "            Text(\"Input\"),\n",
        "            Text(\"Output\"),\n",
        "        )\n",
        "        for title, plane in zip(titles, planes):\n",
        "            title.next_to(plane.get_top(), DOWN)\n",
        "            title.add_background_rectangle()\n",
        "\n",
        "        self.add(planes)\n",
        "\n",
        "        # Area\n",
        "        square = Square()\n",
        "        square.set_stroke(YELLOW, 2)\n",
        "        square.set_fill(YELLOW, 0.5)\n",
        "        square.replace(Line(planes[0].c2p(-1, -1), planes[0].c2p(1, 1)))\n",
        "        area_label = OldTexText(\"Area\", \"=\", \"$A$\")\n",
        "        area_label.set_color_by_tex(\"$A$\", YELLOW)\n",
        "        area_label.next_to(square, UP)\n",
        "        area_label.add_background_rectangle()\n",
        "        self.play(\n",
        "            DrawBorderThenFill(square),\n",
        "            FadeIn(area_label, 0.25 * UP, rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Arrow\n",
        "        arrow = Arrow(*planes)\n",
        "        arrow_label = Text(\"Linear transformation\", font_size=30)\n",
        "        arrow_label.next_to(arrow, UP)\n",
        "        mat_mob = Matrix([[\"a\", \"b\"], [\"c\", \"d\"]], h_buff=0.7, v_buff=0.7)\n",
        "        mat_mob.set_height(0.7)\n",
        "        mat_mob.next_to(arrow, DOWN)\n",
        "\n",
        "        # Apply matrix\n",
        "        matrix = [\n",
        "            [0.5, 0.4],\n",
        "            [0.25, 0.75],\n",
        "        ]\n",
        "\n",
        "        for mob in planes[0], square:\n",
        "            mob.output = mob.deepcopy()\n",
        "            mob.output.apply_matrix(matrix, about_point=planes[0].c2p(0, 0))\n",
        "            mob.output.move_to(planes[1].get_center())\n",
        "\n",
        "        planes[0].output.set_stroke(width=1, opacity=1)\n",
        "        planes[0].output.faded_lines.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(planes[0].copy().fade(1), planes[0].output, run_time=2),\n",
        "            ReplacementTransform(square.copy().fade(1), square.output, run_time=2),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(arrow_label, 0.25 * RIGHT),\n",
        "            FadeIn(mat_mob, 0.25 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # New area\n",
        "        new_area_label = OldTex(\n",
        "            \"\\\\text{Area} = \", \"{c}\", \"\\\\cdot\", \"{A}\",\n",
        "            tex_to_color_map={\n",
        "                \"{c}\": RED,\n",
        "                \"{A}\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        new_area_label.add_background_rectangle()\n",
        "        new_area_label.next_to(square.output, UP)\n",
        "        new_area_label.shift(0.5 * RIGHT)\n",
        "\n",
        "        mmc = mat_mob.copy()\n",
        "        mmc.scale(1.5)\n",
        "        det = VGroup(get_det_text(mmc), mmc)\n",
        "        det.set_height(new_area_label.get_height() * 1.2)\n",
        "        det.move_to(new_area_label.get_part_by_tex(\"c\"), RIGHT)\n",
        "        det.match_y(new_area_label[-1])\n",
        "        det_name = OldTexText(\"``Determinant''\", font_size=36)\n",
        "        det_name.next_to(det, UP, MED_LARGE_BUFF)\n",
        "        det_name.set_color(RED)\n",
        "        det_name.add_background_rectangle()\n",
        "\n",
        "        self.play(FadeTransform(area_label.copy(), new_area_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(mat_mob.copy(), det),\n",
        "            FadeTransform(new_area_label.get_part_by_tex(\"c\"), det_name),\n",
        "            new_area_label[1].animate.next_to(det, LEFT, SMALL_BUFF).match_y(new_area_label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AmbientShapeRotationPreimage(ShadowScene):\n",
        "    inf_light = False\n",
        "    display_mode = \"preimage_only\"  # Or \"full_3d\" or \"shadow_only\"\n",
        "    rotate_in_3d = True\n",
        "    only_show_shadow = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        display_mode = self.display_mode\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(6)\n",
        "        light = self.light\n",
        "        light.move_to(75 * OUT)\n",
        "\n",
        "        shape = self.solid\n",
        "        fc = 2.5 * OUT\n",
        "        shape.move_to(fc)\n",
        "\n",
        "        self.solid.rotate(-0.5 * PI)\n",
        "        self.solid.insert_n_curves(20)\n",
        "        preimage = self.solid.deepcopy()\n",
        "        preimage.move_to(ORIGIN)\n",
        "        rotated = self.solid\n",
        "\n",
        "        self.remove(self.shadow)\n",
        "        shadow = rotated.deepcopy()\n",
        "        shadow.set_fill(interpolate_color(BLUE_E, BLACK, 0.5), 0.7)\n",
        "        shadow.set_stroke(BLACK, 1)\n",
        "\n",
        "        def update_shadow(shadow):\n",
        "            shadow.set_points(\n",
        "                np.apply_along_axis(\n",
        "                    lambda p: project_to_xy_plane(self.light.get_center(), p),\n",
        "                    1, rotated.get_points()\n",
        "                )\n",
        "            )\n",
        "            shadow.refresh_triangulation()\n",
        "            return shadow\n",
        "\n",
        "        shadow.add_updater(update_shadow)\n",
        "\n",
        "        rotated.axis_tracker = VectorizedPoint(RIGHT)\n",
        "        rotated.angle_tracker = ValueTracker(0)\n",
        "        rotated.rot_speed_tracker = ValueTracker(0.15)\n",
        "\n",
        "        def update_rotated(mob, dt):\n",
        "            mob.set_points(preimage.get_points())\n",
        "            mob.shift(fc)\n",
        "            mob.refresh_triangulation()\n",
        "            axis = mob.axis_tracker.get_location()\n",
        "            angle = mob.angle_tracker.get_value()\n",
        "            speed = mob.rot_speed_tracker.get_value()\n",
        "            mob.axis_tracker.rotate(speed * dt, axis=OUT, about_point=ORIGIN)\n",
        "            mob.angle_tracker.increment_value(speed * dt)\n",
        "            mob.rotate(angle, axis, about_point=fc)\n",
        "            return rotated\n",
        "\n",
        "        rotated.add_updater(update_rotated)\n",
        "\n",
        "        # Conditionals\n",
        "        if display_mode == \"full_3d\":\n",
        "            preimage.set_opacity(0)\n",
        "            self.add(shadow)\n",
        "            self.add(rotated)\n",
        "\n",
        "            z_axis = VGroup(\n",
        "                Line(ORIGIN, fc),\n",
        "                Line(fc, 10 * OUT),\n",
        "            )\n",
        "            z_axis.set_stroke(WHITE, 1)\n",
        "            self.add(z_axis[0], rotated, z_axis[1])\n",
        "\n",
        "            orientation_arrows = VGroup(\n",
        "                Vector(RIGHT, stroke_color=RED_D),\n",
        "                Vector(UP, stroke_color=GREEN_D),\n",
        "                Vector(OUT, stroke_color=BLUE_D),\n",
        "            )\n",
        "\n",
        "            orientation_arrows.set_stroke(opacity=0.85)\n",
        "            orientation_arrows.shift(fc)\n",
        "            orientation_arrows.save_state()\n",
        "            orientation_arrows.add_updater(lambda m: m.restore().rotate(\n",
        "                rotated.angle_tracker.get_value(),\n",
        "                rotated.axis_tracker.get_location(),\n",
        "            ))\n",
        "            orientation_arrows.add_updater(lambda m: m.shift(fc - m[0].get_start()))\n",
        "            orientation_arrows.apply_depth_test()\n",
        "            self.add(orientation_arrows)\n",
        "\n",
        "            proj_lines = always_redraw(lambda: VGroup(*(\n",
        "                Line(\n",
        "                    rotated.pfp(a),\n",
        "                    flat_project(rotated.pfp(a))\n",
        "                ).set_stroke(WHITE, 0.5, 0.2)\n",
        "                for a in np.linspace(0, 1, 100)\n",
        "            )))\n",
        "            self.add(proj_lines)\n",
        "\n",
        "            frame.reorient(20, 70)\n",
        "            self.init_frame_rotation()\n",
        "            # frame_speed = -0.02\n",
        "            # frame.add_updater(lambda f, dt: f.increment_theta(frame_speed * dt))\n",
        "        elif display_mode == \"shadow_only\":\n",
        "            frame.reorient(0, 0)\n",
        "            frame.set_height(3)\n",
        "            rotated.set_opacity(0)\n",
        "            preimage.set_opacity(0)\n",
        "            self.glow.set_opacity(0.2)\n",
        "            self.add(rotated)\n",
        "            self.add(shadow)\n",
        "        elif display_mode == \"preimage_only\":\n",
        "            self.glow.set_opacity(0)\n",
        "            self.remove(self.plane)\n",
        "            self.add(preimage)\n",
        "            frame.reorient(0, 0)\n",
        "            frame.set_height(3)\n",
        "            rotated.set_opacity(0)\n",
        "\n",
        "        # Just hang around\n",
        "        self.wait(15)\n",
        "\n",
        "        # Change to cat\n",
        "        cat = SVGMobject(\"cat_outline\").family_members_with_points()[0]\n",
        "        dog = SVGMobject(\"dog_outline\").family_members_with_points()[0]\n",
        "        dog.insert_n_curves(87)\n",
        "        for mob in cat, dog:\n",
        "            mob.match_style(preimage)\n",
        "            mob.replace(preimage, dim_to_match=0)\n",
        "        pass\n",
        "\n",
        "        # Stretch\n",
        "        self.play(rotated.rot_speed_tracker.animate.set_value(0))\n",
        "        rotated.rot_speed = 0\n",
        "        for axis, diag in zip((0, 1, 0, 1), (False, False, True, True)):\n",
        "            preimage.generate_target()\n",
        "            if diag:\n",
        "                preimage.target.rotate(PI / 4)\n",
        "            preimage.target.stretch(2, axis)\n",
        "            if diag:\n",
        "                preimage.target.rotate(-PI / 4)\n",
        "            self.play(\n",
        "                MoveToTarget(preimage),\n",
        "                rate_func=there_and_back,\n",
        "                run_time=4\n",
        "            )\n",
        "        self.wait(5)\n",
        "        self.play(rotated.rot_speed_tracker.animate.set_value(0.1))\n",
        "\n",
        "        # Change shape\n",
        "        cat = SVGMobject(\"cat_outline\").family_members_with_points()[0]\n",
        "        dog = SVGMobject(\"dog_outline\").family_members_with_points()[0]\n",
        "        dog.insert_n_curves(87)\n",
        "        for mob in cat, dog:\n",
        "            mob.match_style(preimage)\n",
        "            mob.replace(preimage, dim_to_match=0)\n",
        "        self.play(Transform(preimage, cat, run_time=4))\n",
        "        cat.insert_n_curves(87)\n",
        "        preimage.become(cat)\n",
        "        self.wait(2)\n",
        "\n",
        "        # More shape changes\n",
        "        self.play(\n",
        "            preimage.animate.scale(2),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            preimage.animate.become(dog),\n",
        "            path_arc=PI,\n",
        "            rate_func=there_and_back_with_pause,  # Or rather, with paws...\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Bring light source closer\n",
        "        self.play(rotated.rot_speed_tracker.animate.set_value(0))\n",
        "        anims = [\n",
        "            light.animate.move_to(4 * OUT)\n",
        "        ]\n",
        "\n",
        "        angle = rotated.angle_tracker.get_value()\n",
        "        angle_anim = rotated.angle_tracker.animate.set_value(np.round(angle / TAU, 0) * TAU)\n",
        "\n",
        "        if self.display_mode == \"full_3d\":\n",
        "            light_lines = self.get_light_lines(shadow)\n",
        "            lso = light_lines[0].get_stroke_opacity()\n",
        "            pso = proj_lines[0].get_stroke_opacity()\n",
        "            proj_lines.clear_updaters()\n",
        "            anims += [\n",
        "                UpdateFromAlphaFunc(proj_lines, lambda m, a: m.set_stroke(opacity=pso * (1 - a))),\n",
        "                UpdateFromAlphaFunc(light_lines, lambda m, a: m.set_stroke(opacity=lso * a)),\n",
        "                angle_anim,\n",
        "                frame.animate.reorient(20, 70).set_height(8),\n",
        "            ]\n",
        "            frame.clear_updaters()\n",
        "        if self.display_mode == \"shadow_only\":\n",
        "            anims += [\n",
        "                frame.animate.set_height(10),\n",
        "                angle_anim,\n",
        "            ]\n",
        "        self.play(*anims, run_time=4)\n",
        "        self.wait()\n",
        "        rotated.axis_tracker.move_to(UP)\n",
        "        self.play(\n",
        "            rotated.angle_tracker.animate.set_value(70 * DEGREES + TAU),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            preimage.animate.stretch(1.5, 0),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=5,\n",
        "        )\n",
        "        anims = [rotated.axis_tracker.animate.move_to(RIGHT)]\n",
        "        if self.display_mode == \"full_3d\":\n",
        "            anims.append(frame.animate.reorient(-20, 70))\n",
        "        self.play(*anims, run_time=2)\n",
        "        self.play(\n",
        "            preimage.animate.stretch(2, 1),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=7,\n",
        "        )\n",
        "\n",
        "        # More ambient motion\n",
        "        self.play(rotated.rot_speed_tracker.animate.set_value(0.1))\n",
        "        self.wait(30)\n",
        "\n",
        "    def get_solid(self):\n",
        "        face = Square(side_length=2)\n",
        "        face.set_fill(BLUE, 0.5)\n",
        "        face.set_stroke(WHITE, 1)\n",
        "        return face\n",
        "\n",
        "\n",
        "class AmbientShapeRotationFull3d(AmbientShapeRotationPreimage):\n",
        "    display_mode = \"full_3d\"\n",
        "\n",
        "\n",
        "class AmbientShapeRotationShadowOnly(AmbientShapeRotationPreimage):\n",
        "    display_mode = \"shadow_only\"\n",
        "\n",
        "\n",
        "class IsntThatObvious(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        self.student_says(\n",
        "            OldTexText(\"Isn't that obvious?\"),\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "                \"direction\": LEFT,\n",
        "            },\n",
        "            target_mode=\"angry\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[LaggedStart(\n",
        "                self.teacher.change(\"guilty\"),\n",
        "                self.students[0].change(\"pondering\", self.screen),\n",
        "                self.students[1].change(\"erm\", self.screen),\n",
        "            )]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.students[0].change(\"hesitant\"),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class StretchLabel(Scene):\n",
        "    def construct(self):\n",
        "        label = VGroup(\n",
        "            Vector(0.5 * LEFT),\n",
        "            OldTex(\"1.5 \\\\times\"),\n",
        "            Vector(0.5 * RIGHT)\n",
        "        )\n",
        "        label.set_color(YELLOW)\n",
        "        label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            *map(ShowCreation, label[::2]),\n",
        "            Write(label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WonderAboutAverage(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.look(RIGHT)\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, OldTexText(\"How do you think\\\\\\\\about this average\"),\n",
        "            target_mode=\"confused\",\n",
        "            run_time=2\n",
        "        ))\n",
        "        for x in range(2):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class SingleFaceRandomRotation(ShadowScene):\n",
        "    initial_wait_time = 0\n",
        "    inf_light = True\n",
        "    n_rotations = 1\n",
        "    total_time = 60\n",
        "    plane_dims = (8, 8)\n",
        "    frame_rot_speed = 0.02\n",
        "    theta0 = -20 * DEGREES\n",
        "    CONFIG = {\"random_seed\": 0}\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        np.random.seed(self.random_seed)\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(5.0)\n",
        "        frame.set_z(1.75)\n",
        "        frame.set_theta(self.theta0)\n",
        "        face = self.solid\n",
        "        face.shift(0.25 * IN)\n",
        "        fc = face.get_center()\n",
        "        z_axis = self.z_axis = VGroup(Line(ORIGIN, fc), Line(fc, 10 * OUT))\n",
        "        z_axis.set_stroke(WHITE, 0.5)\n",
        "        self.add(z_axis[0], face, z_axis[1])\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Line(ORIGIN, RIGHT, color=RED_D),\n",
        "            Line(ORIGIN, UP, color=GREEN_D),\n",
        "            VGroup(\n",
        "                Vector(OUT, stroke_width=4, stroke_color=BLACK),\n",
        "                Vector(OUT, stroke_width=3, stroke_color=BLUE_D),\n",
        "            )\n",
        "        )\n",
        "        arrows[:2].set_stroke(width=2)\n",
        "        arrows.set_stroke(opacity=0.8)\n",
        "        arrows.shift(fc)\n",
        "        arrows.set_stroke(opacity=0.8)\n",
        "        face.add(arrows[:2])\n",
        "\n",
        "        face = Group(face, arrows[2])\n",
        "        face.add_updater(lambda m: self.sort_to_camera(face))\n",
        "        self.face = self.solid = face\n",
        "\n",
        "        arrow_shadow = get_shadow(arrows)\n",
        "        arrow_shadow.set_stroke(width=1)\n",
        "        arrow_shadow[2].set_stroke(width=[1, 1, 4, 0])\n",
        "        self.add(arrow_shadow)\n",
        "\n",
        "        self.add(z_axis[0], face, z_axis[1])\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        face = self.face\n",
        "\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(self.frame_rot_speed * dt))\n",
        "        self.wait(self.initial_wait_time)\n",
        "        for x in range(self.n_rotations):\n",
        "            self.random_toss(\n",
        "                face,\n",
        "                about_point=fc,\n",
        "                angle=3 * PI,\n",
        "                # run_time=1.5,\n",
        "                run_time=8,\n",
        "                rate_func=smooth,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.wait(self.total_time - 2 - self.initial_wait_time)\n",
        "\n",
        "    def get_solid(self):\n",
        "        face = Square(side_length=2)\n",
        "        face.set_fill(BLUE_E, 0.75)\n",
        "        face.set_stroke(WHITE, 0.5)\n",
        "        return face\n",
        "\n",
        "\n",
        "class RandomRotations1(SingleFaceRandomRotation):\n",
        "    initial_wait_time = 1\n",
        "    theta0 = -30 * DEGREES\n",
        "    CONFIG = {\"random_seed\": 10}\n",
        "\n",
        "\n",
        "class RandomRotations2(SingleFaceRandomRotation):\n",
        "    initial_wait_time = 1.5\n",
        "    theta0 = -25 * DEGREES\n",
        "    CONFIG = {\"random_seed\": 4}\n",
        "\n",
        "\n",
        "class RandomRotations3(SingleFaceRandomRotation):\n",
        "    initial_wait_time = 2\n",
        "    theta0 = -20 * DEGREES\n",
        "    CONFIG = {\"random_seed\": 5}\n",
        "\n",
        "\n",
        "class RandomRotations4(SingleFaceRandomRotation):\n",
        "    initial_wait_time = 2.5\n",
        "    theta0 = -15 * DEGREES\n",
        "    CONFIG = {\"random_seed\": 6}\n",
        "\n",
        "\n",
        "class AverageFaceShadow(SingleFaceRandomRotation):\n",
        "    inf_light = True\n",
        "    plane_dims = (16, 8)\n",
        "    n_samples = 50\n",
        "\n",
        "    def construct(self):\n",
        "        # Random shadows\n",
        "        self.camera.frame.set_height(6)\n",
        "        face = self.face\n",
        "        shadow = self.shadow\n",
        "        shadow.add_updater(lambda m: m.set_fill(BLACK, 0.25))\n",
        "        shadow.update()\n",
        "        point = face[0].get_center()\n",
        "        shadows = VGroup()\n",
        "        n_samples = self.n_samples\n",
        "        self.remove(self.z_axis)\n",
        "\n",
        "        self.init_frame_rotation()\n",
        "        self.add(shadows)\n",
        "        for n in range(n_samples):\n",
        "            self.randomly_reorient(face, about_point=point)\n",
        "            if n == n_samples - 1:\n",
        "                normal = next(\n",
        "                    sm.get_unit_normal()\n",
        "                    for sm in face.family_members_with_points()\n",
        "                    if isinstance(sm, VMobject) and sm.get_fill_opacity() > 0\n",
        "                )\n",
        "                mat = z_to_vector(normal)\n",
        "            #     face.apply_matrix(np.linalg.inv(mat), about_point=point)\n",
        "            shadow.update()\n",
        "            sc = shadow.copy()\n",
        "            sc.clear_updaters()\n",
        "            shadows.add(sc)\n",
        "            shadows.set_fill(BLACK, 1.5 / len(shadows))\n",
        "            shadows.set_stroke(opacity=10 / len(shadows))\n",
        "            self.wait(0.1)\n",
        "\n",
        "        # Fade out shadow\n",
        "        self.remove(shadow)\n",
        "        sc = shadow.copy().clear_updaters()\n",
        "        self.play(FadeOut(sc))\n",
        "        self.wait()\n",
        "\n",
        "        # Scaling\n",
        "        self.play(\n",
        "            face.animate.scale(0.5, about_point=point),\n",
        "            shadows.animate.scale(0.5, about_point=ORIGIN),\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        for axis in [0, 1]:\n",
        "            self.play(\n",
        "                face.animate.stretch(2, axis, about_point=point),\n",
        "                shadows.animate.stretch(2, axis, about_point=ORIGIN),\n",
        "                run_time=3,\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Ambient rotations 106 plays\n",
        "        self.play(\n",
        "            self.camera.frame.animate.reorient(-10).shift(2 * LEFT),\n",
        "        )\n",
        "        self.add(shadow)\n",
        "        for n in range(100):\n",
        "            self.randomly_reorient(face, about_point=point)\n",
        "            self.wait(0.2)\n",
        "\n",
        "\n",
        "class AverageCatShadow(AverageFaceShadow):\n",
        "    n_samples = 50\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.replace_face()\n",
        "\n",
        "    def replace_face(self):\n",
        "        face = self.face\n",
        "\n",
        "        shape = self.get_shape().family_members_with_points()[0]\n",
        "        shape.match_style(face[0])\n",
        "        shape.replace(face[0])\n",
        "\n",
        "        face[0].set_points(shape.get_points())\n",
        "        face[0].set_gloss(0.25)\n",
        "        face[0][0].set_gloss(0)\n",
        "\n",
        "        self.solid = face\n",
        "        self.remove(self.shadow)\n",
        "        self.add_shadow()\n",
        "\n",
        "    def get_shape(self):\n",
        "        return SVGMobject(\"cat_outline\")\n",
        "\n",
        "\n",
        "class AveragePentagonShadow(AverageCatShadow):\n",
        "    def get_shape(self):\n",
        "        return RegularPolygon(5)\n",
        "\n",
        "\n",
        "class AverageShadowAnnotation(Scene):\n",
        "    def construct(self):\n",
        "        # Many shadows\n",
        "        many_shadows = Text(\"Many shadows\")\n",
        "        many_shadows.move_to(3 * DOWN)\n",
        "\n",
        "        self.play(Write(many_shadows))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Formula\n",
        "        # shape_name = \"2d shape\"\n",
        "        shape_name = \"Square\"\n",
        "        t2c = {\n",
        "            \"Shadow\": GREY_B,\n",
        "            shape_name: BLUE,\n",
        "            \"$c$\": RED,\n",
        "        }\n",
        "        formula = VGroup(\n",
        "            OldTexText(\n",
        "                f\"Area(Shadow({shape_name}))\",\n",
        "                tex_to_color_map=t2c,\n",
        "            ),\n",
        "            OldTex(\"=\").rotate(PI / 2),\n",
        "            OldTexText(\n",
        "                \"$c$\", \" $\\\\cdot$\", f\"(Area({shape_name}))\",\n",
        "                tex_to_color_map=t2c\n",
        "            )\n",
        "        )\n",
        "        overline = get_overline(formula[0])\n",
        "        formula[0].add(overline)\n",
        "        formula.arrange(DOWN)\n",
        "        formula.to_corner(UL)\n",
        "\n",
        "        self.play(FadeTransform(many_shadows, formula[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VShowPassingFlash(\n",
        "                overline.copy().insert_n_curves(100).set_stroke(YELLOW, 5),\n",
        "                time_width=0.75,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(formula[1]),\n",
        "            FadeIn(formula[2], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Append half\n",
        "        half = OldTex(\"\\\\frac{1}{2}\")\n",
        "        half.set_color(RED)\n",
        "        c = formula[2].get_part_by_tex(\"$c$\")\n",
        "        half.move_to(c, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(c, 0.5 * UP),\n",
        "            FadeIn(half, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AlicesFaceAverage(Scene):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        background = FullScreenRectangle()\n",
        "        self.add(background)\n",
        "\n",
        "        panels = Rectangle(2, 2.5).replicate(5)\n",
        "        panels.set_stroke(WHITE, 1)\n",
        "        panels.set_fill(BLACK, 1)\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        panels.replace_submobject(3, dots)\n",
        "        panels.arrange(RIGHT, buff=0.25)\n",
        "        panels.set_width(FRAME_WIDTH - 1)\n",
        "        panels.move_to(2 * DOWN, DOWN)\n",
        "        self.add(panels)\n",
        "        panels = VGroup(*panels[:-2], panels[-1])\n",
        "\n",
        "        # Label the rotations\n",
        "        indices = [\"1\", \"2\", \"3\", \"n\"]\n",
        "        rot_labels = VGroup(*(\n",
        "            OldTex(f\"R_{i}\") for i in indices\n",
        "        ))\n",
        "        for label, panel in zip(rot_labels, panels):\n",
        "            label.set_height(0.3)\n",
        "            label.next_to(panel, DOWN)\n",
        "\n",
        "        rot_words = Text(\"Sequence of random rotations\")\n",
        "        rot_words.next_to(rot_labels, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(rot_words, run_time=2))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, rot_labels,\n",
        "            shift=0.25 * DOWN,\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the shadow areas\n",
        "        font_size = 30\n",
        "        fra_labels = VGroup(*(\n",
        "            OldTex(\n",
        "                f\"f(R_{i})\", \"\\\\cdot \", \"A\",\n",
        "                tex_to_color_map={\"A\": BLUE},\n",
        "                font_size=font_size\n",
        "            )\n",
        "            for i in indices\n",
        "        ))\n",
        "\n",
        "        DARK_BLUE = interpolate_color(BLUE_D, BLUE_E, 0.5)\n",
        "        area_shadow_labels = VGroup(*(\n",
        "            OldTex(\n",
        "                \"\\\\text{Area}(\", \"\\\\text{Shadow}_\" + i, \")\",\n",
        "                tex_to_color_map={\"\\\\text{Shadow}_\" + i: DARK_BLUE},\n",
        "                font_size=font_size\n",
        "            )\n",
        "            for i in indices\n",
        "        ))\n",
        "        s_labels = VGroup(*(\n",
        "            OldTex(\n",
        "                f\"S_{i}\", \"=\",\n",
        "                tex_to_color_map={f\"S_{i}\": DARK_BLUE},\n",
        "                font_size=font_size\n",
        "            )\n",
        "            for i in indices\n",
        "        ))\n",
        "        label_arrows = VGroup()\n",
        "\n",
        "        for fra, area, s_label, panel in zip(fra_labels, area_shadow_labels, s_labels, panels):\n",
        "            fra.next_to(panel, UP, SMALL_BUFF)\n",
        "            area.next_to(fra, UP)\n",
        "            area.to_edge(UP, buff=LARGE_BUFF)\n",
        "            label_arrows.add(Arrow(area, fra, buff=0.2, stroke_width=3))\n",
        "\n",
        "            fra.generate_target()\n",
        "            eq = VGroup(s_label, fra.target)\n",
        "            eq.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            eq.move_to(fra, DOWN)\n",
        "\n",
        "        self.add(area_shadow_labels)\n",
        "        self.add(fra_labels)\n",
        "        self.add(label_arrows)\n",
        "\n",
        "        lr = 0.2\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, area_shadow_labels, lag_ratio=lr),\n",
        "            LaggedStartMap(ShowCreation, label_arrows, lag_ratio=lr),\n",
        "            LaggedStartMap(FadeIn, fra_labels, shift=DOWN, lag_ratio=lr),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(area, area_s)\n",
        "                for area, area_s in zip(area_shadow_labels, s_labels)\n",
        "            ), lag_ratio=lr),\n",
        "            LaggedStartMap(MoveToTarget, fra_labels, lag_ratio=lr),\n",
        "            LaggedStartMap(Uncreate, label_arrows, lag_ratio=lr),\n",
        "        )\n",
        "\n",
        "        # Show average\n",
        "        sample_average = OldTex(\n",
        "            \"\\\\text{Sample average}\", \"=\",\n",
        "            \"\\\\frac{1}{n}\", \"\\\\left(\",\n",
        "            \"f(R_1)\", \"\\\\cdot \", \"A\", \"+\",\n",
        "            \"f(R_2)\", \"\\\\cdot \", \"A\", \"+\",\n",
        "            \"f(R_3)\", \"\\\\cdot \", \"A\", \"+\",\n",
        "            \"\\\\cdots \",\n",
        "            \"f(R_n)\", \"\\\\cdot \", \"A\",\n",
        "            \"\\\\right)\",\n",
        "            font_size=font_size\n",
        "        )\n",
        "        sample_average.set_color_by_tex(\"A\", BLUE)\n",
        "        sample_average.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        for tex in [\"\\\\left\", \"\\\\right\"]:\n",
        "            part = sample_average.get_part_by_tex(tex)\n",
        "            part.scale(1.5)\n",
        "            part.stretch(1.5, 1)\n",
        "\n",
        "        self.play(FadeIn(sample_average[:2]))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                fra_labels.copy(),\n",
        "                sample_average[4:-1]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(VGroup(*sample_average[2:4], sample_average[-1]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Factor out A\n",
        "        sample_average.generate_target()\n",
        "        cdots = sample_average.target.get_parts_by_tex(\"\\\\cdot\", substring=False)\n",
        "        As = sample_average.target.get_parts_by_tex(\"A\", substring=False)\n",
        "        new_pieces = VGroup(*(\n",
        "            sm for sm in sample_average.target\n",
        "            if sm.get_tex() not in [\"A\", \"\\\\cdot\"]\n",
        "        ))\n",
        "        new_A = As[0].copy()\n",
        "        new_cdot = cdots[0].copy()\n",
        "        new_pieces.insert_submobject(2, new_cdot)\n",
        "        new_pieces.insert_submobject(2, new_A)\n",
        "        new_pieces.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        new_pieces.move_to(sample_average)\n",
        "        for group, target in (As, new_A), (cdots, new_cdot):\n",
        "            for sm in group:\n",
        "                sm.replace(target)\n",
        "            group[1:].set_opacity(0)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *(\n",
        "                FlashAround(mob, time_width=3)\n",
        "                for mob in sample_average.get_parts_by_tex(\"A\")\n",
        "            ),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.play(MoveToTarget(sample_average, path_arc=-PI / 5))\n",
        "        self.wait()\n",
        "\n",
        "        # True average\n",
        "        brace = Brace(new_pieces[4:], DOWN, buff=SMALL_BUFF, font_size=30)\n",
        "        lim = OldTex(\"n \\\\to \\\\infty\", font_size=30)\n",
        "        lim.next_to(brace, DOWN)\n",
        "        VGroup(brace, lim).set_color(YELLOW)\n",
        "        sample = sample_average[0][:len(\"Sample\")]\n",
        "        cross = Cross(sample)\n",
        "        cross.insert_n_curves(20)\n",
        "        cross.scale(1.5)\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(sample_average[2:], run_time=3, time_width=1.5)\n",
        "        )\n",
        "        self.play(\n",
        "            FlashUnder(sample_average[:2], color=RED),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(lim, 0.25 * DOWN),\n",
        "            ShowCreation(cross)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                *fra_labels, *s_labels, *panels, dots, *rot_labels, rot_words\n",
        "            ]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Some constant\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(new_pieces[4:], brace, lim),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        rect.set_stroke(YELLOW, 1)\n",
        "        rect.stretch(0.98, 0)\n",
        "        words = Text(\"Some constant\")\n",
        "        words.next_to(rect, DOWN)\n",
        "        subwords = Text(\"Independent of the size and shape of the 2d piece\")\n",
        "        subwords.scale(0.5)\n",
        "        subwords.next_to(words, DOWN)\n",
        "        subwords.set_fill(GREY_A)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(words, 0.25 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(subwords))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ManyShadows(SingleFaceRandomRotation):\n",
        "    plane_dims = (4, 4)\n",
        "    limited_plane_extension = 2\n",
        "\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        self.camera.frame.reorient(0, 0)\n",
        "\n",
        "        plane = self.plane\n",
        "        face = self.solid\n",
        "        shadow = self.shadow\n",
        "\n",
        "        n_rows = 3\n",
        "        n_cols = 10\n",
        "\n",
        "        planes = plane.replicate(n_rows * n_cols)\n",
        "        for n, plane in zip(it.count(1), planes):\n",
        "            face.rotate(angle=random.uniform(0, TAU), axis=normalize(np.random.uniform(-1, 1, 3)))\n",
        "            shadow.update()\n",
        "            sc = shadow.deepcopy()\n",
        "            sc.clear_updaters()\n",
        "            sc.set_fill(interpolate_color(BLUE_E, BLACK, 0.5), 0.75)\n",
        "            plane.set_gloss(0)\n",
        "            plane.add_to_back(sc)\n",
        "            area = DecimalNumber(get_norm(sc.get_area_vector() / 4.0), font_size=56)\n",
        "            label = VGroup(OldTex(f\"f(R_{n}) = \"), area)\n",
        "            label.arrange(RIGHT)\n",
        "            label.set_width(0.8 * plane.get_width())\n",
        "            label.next_to(plane, UP, SMALL_BUFF)\n",
        "            label.set_color(WHITE)\n",
        "            plane.add(label)\n",
        "\n",
        "        planes.arrange_in_grid(n_rows, n_cols, buff=LARGE_BUFF)\n",
        "        planes.set_width(15)\n",
        "        planes.to_edge(DOWN)\n",
        "        planes.update()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    FadeIn(plane, scale=1.1)\n",
        "                    for plane in planes\n",
        "                ),\n",
        "                lag_ratio=0.6, run_time=10\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class ComingUp(VideoWrapper):\n",
        "    title = \"Bob will compute this directly\"\n",
        "    wait_time = 10\n",
        "    animate_boundary = False\n",
        "\n",
        "\n",
        "class AllPossibleOrientations(ShadowScene):\n",
        "    inf_light = True\n",
        "    limited_plane_extension = 6\n",
        "    plane_dims = (12, 8)\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-20, 80)\n",
        "        frame.set_height(5)\n",
        "        frame.d_theta = 0\n",
        "\n",
        "        def update_frame(frame, dt):\n",
        "            frame.d_theta += -0.0025 * frame.get_theta()\n",
        "            frame.increment_theta(clip(0.0025 * frame.d_theta, -0.01 * dt, 0.01 * dt))\n",
        "\n",
        "        frame.add_updater(update_frame)\n",
        "        face = self.solid\n",
        "        square, normal_vect = face\n",
        "        normal_vect.set_flat_stroke()\n",
        "        self.solid = square\n",
        "        self.remove(self.shadow)\n",
        "        self.add_shadow()\n",
        "        self.shadow.deactivate_depth_test()\n",
        "        self.solid = face\n",
        "        fc = square.get_center().copy()\n",
        "\n",
        "        # Sphere points\n",
        "        sphere = Sphere(radius=1)\n",
        "        sphere.set_color(GREY_E, 0.7)\n",
        "        sphere.move_to(fc)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "\n",
        "        n_lat_lines = 40\n",
        "        theta_step = PI / n_lat_lines\n",
        "        sphere_points = np.array([\n",
        "            sphere.uv_func(phi, theta + theta_step * (phi / TAU))\n",
        "            for theta in np.arange(0, PI, theta_step)\n",
        "            for phi in np.linspace(\n",
        "                0, TAU, int(2 * n_lat_lines * math.sin(theta)) + 1\n",
        "            )\n",
        "        ])\n",
        "        sphere_points[:, 2] *= -1\n",
        "        original_sphere_points = sphere_points.copy()\n",
        "        sphere_points += fc\n",
        "\n",
        "        sphere_dots = DotCloud(sphere_points)\n",
        "        sphere_dots.set_radius(0.0125)\n",
        "        sphere_dots.set_glow_factor(0.5)\n",
        "        sphere_dots.make_3d()\n",
        "        sphere_dots.apply_depth_test()\n",
        "        sphere_dots.add_updater(lambda m: m)\n",
        "\n",
        "        sphere_lines = VGroup(*(\n",
        "            Line(sphere.get_center(), p)\n",
        "            for p in sphere_dots.get_points()\n",
        "        ))\n",
        "        sphere_lines.set_stroke(WHITE, 1, 0.05)\n",
        "\n",
        "        sphere_words = OldTexText(\"All normal vectors = Sphere\")\n",
        "        uniform_words = OldTexText(\"All points equally likely\")\n",
        "        for words in [sphere_words, uniform_words]:\n",
        "            words.fix_in_frame()\n",
        "            words.to_edge(UP)\n",
        "\n",
        "        # Trace sphere\n",
        "        N = len(original_sphere_points)\n",
        "        self.play(FadeIn(sphere_words))\n",
        "        self.play(\n",
        "            ShowCreation(sphere_dots),\n",
        "            ShowIncreasingSubsets(sphere_lines),\n",
        "            UpdateFromAlphaFunc(\n",
        "                face,\n",
        "                lambda m, a: m.apply_matrix(\n",
        "                    rotation_between_vectors(\n",
        "                        normal_vect.get_vector(),\n",
        "                        original_sphere_points[int(a * (N - 1))],\n",
        "                    ),\n",
        "                    about_point=fc\n",
        "                )\n",
        "            ),\n",
        "            run_time=30,\n",
        "            rate_func=smooth,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(sphere_words, UP),\n",
        "            FadeIn(uniform_words, UP),\n",
        "        )\n",
        "        last_dot = Mobject()\n",
        "        for x in range(20):\n",
        "            point = random.choice(sphere_points)\n",
        "            dot = TrueDot(\n",
        "                point,\n",
        "                radius=1,\n",
        "                glow_factor=10,\n",
        "                color=YELLOW,\n",
        "            )\n",
        "            self.add(dot)\n",
        "            self.play(\n",
        "                face.animate.apply_matrix(rotation_between_vectors(\n",
        "                    normal_vect.get_vector(),\n",
        "                    point - fc\n",
        "                ), about_point=fc),\n",
        "                FadeOut(last_dot, run_time=0.25),\n",
        "                FadeIn(dot),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "            self.wait(0.25)\n",
        "            last_dot = dot\n",
        "        self.play(FadeOut(last_dot))\n",
        "        self.wait()\n",
        "\n",
        "        # Sphere itself\n",
        "        sphere_mesh = SurfaceMesh(sphere, resolution=(21, 11))\n",
        "        sphere_mesh.set_stroke(BLUE_E, 1, 1)\n",
        "        for sm in sphere_mesh.get_family():\n",
        "            sm.uniforms[\"anti_alias_width\"] = 0\n",
        "        v1 = normal_vect.get_vector()\n",
        "        normal_vect.scale(0.99, about_point=fc)\n",
        "        v2 = DR + OUT\n",
        "        frame.reorient(-5)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                face, angle_between_vectors(v1, v2),\n",
        "                axis=normalize(cross(v1, v2))\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                self.plane, lambda m, a: square.scale(0.9).set_opacity(0.5 - a * 0.5)\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(sphere_mesh, lag_ratio=0.5),\n",
        "            FadeIn(sphere),\n",
        "            sphere_dots.animate.set_radius(0),\n",
        "            FadeOut(sphere_lines),\n",
        "            frame.animate.reorient(0),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(sphere_dots)\n",
        "\n",
        "        # Show patch\n",
        "        def get_patch(u, v, delta_u=0.05, delta_v=0.1):\n",
        "            patch = ParametricSurface(\n",
        "                sphere.uv_func,\n",
        "                u_range=(u * TAU, (u + delta_u) * TAU),\n",
        "                v_range=(v * PI, (v + delta_v) * PI),\n",
        "            )\n",
        "            patch.shift(fc)\n",
        "            patch.set_color(YELLOW, 0.75)\n",
        "            patch.always_sort_to_camera(self.camera)\n",
        "            return patch\n",
        "\n",
        "        patch = get_patch(0.85, 0.6)\n",
        "        self.add(patch, sphere)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(patch),\n",
        "            frame.animate.reorient(10, 75),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Probability expression\n",
        "        patch_copy = patch.deepcopy()\n",
        "        sphere_copy = sphere.deepcopy()\n",
        "        sphere_copy.set_color(GREY_D, 0.7)\n",
        "        for mob in patch_copy, sphere_copy:\n",
        "            mob.apply_matrix(frame.get_inverse_camera_rotation_matrix())\n",
        "            mob.fix_in_frame()\n",
        "            mob.center()\n",
        "        patch_copy2 = patch_copy.copy()\n",
        "\n",
        "        prob = Group(*Tex(\n",
        "            \"P(\", \"0.\", \")\", \"=\", \"{Num \", \"\\\\over \", \"Den}\",\n",
        "            font_size=60\n",
        "        ))\n",
        "        prob.fix_in_frame()\n",
        "        prob.to_corner(UR)\n",
        "        prob.shift(DOWN)\n",
        "        for i, mob in [(1, patch_copy), (4, patch_copy2), (6, sphere_copy)]:\n",
        "            mob.replace(prob[i], dim_to_match=1)\n",
        "            prob.replace_submobject(i, mob)\n",
        "        sphere_copy.scale(3, about_edge=UP)\n",
        "\n",
        "        self.play(FadeIn(prob, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        for i in (4, 6):\n",
        "            self.play(ShowCreationThenFadeOut(\n",
        "                SurroundingRectangle(prob[i], stroke_width=2).fix_in_frame()\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        # Many patches\n",
        "        patches = Group(\n",
        "            get_patch(0.65, 0.5),\n",
        "            get_patch(0.55, 0.8),\n",
        "            get_patch(0.85, 0.8),\n",
        "            get_patch(0.75, 0.4, 0.1, 0.2),\n",
        "        )\n",
        "\n",
        "        patch.deactivate_depth_test()\n",
        "        self.add(sphere, patch)\n",
        "        for new_patch in patches:\n",
        "            self.play(\n",
        "                Transform(patch, new_patch),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Non-specified orientation\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, (sphere, sphere_mesh, patch, *prob, uniform_words)))\n",
        "        )\n",
        "        self.play(\n",
        "            square.animate.set_fill(opacity=0.5),\n",
        "            frame.animate.reorient(-30),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(square, TAU, normal_vect.get_vector()),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show theta\n",
        "        def get_normal():\n",
        "            return normal_vect.get_vector()\n",
        "\n",
        "        def get_theta():\n",
        "            return np.arccos(get_normal()[2] / get_norm(get_normal()))\n",
        "\n",
        "        def get_arc():\n",
        "            result = Arc(PI / 2, -get_theta(), radius=0.25)\n",
        "            result.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "            result.rotate(angle_of_vector([*get_normal()[:2], 0]), OUT, about_point=ORIGIN)\n",
        "            result.shift(fc)\n",
        "            result.set_stroke(WHITE, 1)\n",
        "            result.apply_depth_test()\n",
        "            return result\n",
        "\n",
        "        arc = always_redraw(get_arc)\n",
        "\n",
        "        theta = OldTex(\"\\\\theta\", font_size=20)\n",
        "        theta.rotate(PI / 2, RIGHT)\n",
        "        theta.set_backstroke(width=2)\n",
        "        theta.add_updater(lambda m: m.next_to(arc.pfp(0.5), OUT + RIGHT, buff=0.05))\n",
        "\n",
        "        z_axis = Line(ORIGIN, 10 * OUT)\n",
        "        z_axis.set_stroke(WHITE, 1)\n",
        "        z_axis.apply_depth_test()\n",
        "\n",
        "        self.add(z_axis, face, theta, arc)\n",
        "        self.play(\n",
        "            ShowCreation(z_axis),\n",
        "            ShowCreation(arc),\n",
        "            FadeIn(theta, 0.5 * OUT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show shadow area\n",
        "        shadow_area = OldTexText(\"Shadow area =\", \"$|\\\\cos(\\\\theta)|s^2$\")\n",
        "        shadow_area.fix_in_frame()\n",
        "        shadow_area.to_edge(RIGHT)\n",
        "        shadow_area.set_y(-3)\n",
        "        shadow_area.set_backstroke()\n",
        "\n",
        "        self.play(\n",
        "            Write(shadow_area, run_time=3),\n",
        "            Rotate(face, TAU, normal_vect.get_vector(), run_time=10),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        shadow_area[1].generate_target()\n",
        "        shadow_area[1].target.to_corner(UR, buff=MED_LARGE_BUFF)\n",
        "        shadow_area[1].target.shift(LEFT)\n",
        "        brace = Brace(shadow_area[1].target, DOWN)\n",
        "        brace_text = OldTexText(\"How do you average this\\\\\\\\over the sphere?\", font_size=36)\n",
        "        brace_text.next_to(brace, DOWN, SMALL_BUFF)\n",
        "        brace.fix_in_frame()\n",
        "        brace_text.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            MoveToTarget(shadow_area[1]),\n",
        "            FadeOut(shadow_area[0]),\n",
        "            square.animate.set_fill(opacity=0),\n",
        "        )\n",
        "        face.generate_target()\n",
        "        face.target[1].set_length(0.98, about_point=fc)\n",
        "        sphere.set_opacity(0.35)\n",
        "        sphere_mesh.set_stroke(width=0.5)\n",
        "        self.play(\n",
        "            MoveToTarget(face),\n",
        "            FadeIn(brace_text, 0.5 * DOWN),\n",
        "            Write(sphere_mesh, run_time=2, stroke_width=1),\n",
        "            FadeIn(sphere),\n",
        "        )\n",
        "\n",
        "        # Sum expression\n",
        "        def update_theta_ring(ring):\n",
        "            theta = get_theta()\n",
        "            phi = angle_of_vector([*get_normal()[:2], 0])\n",
        "            ring.set_width(max(2 * 1.01 * math.sin(theta), 1e-3))\n",
        "            ring.rotate(phi - angle_of_vector([*ring.get_start()[:2], 0]))\n",
        "            ring.move_to(fc + math.cos(theta) * OUT)\n",
        "            return ring\n",
        "\n",
        "        theta_ring = Circle()\n",
        "        theta_ring.set_stroke(YELLOW, 2)\n",
        "        theta_ring.apply_depth_test()\n",
        "        theta_ring.uniforms[\"anti_alias_width\"] = 0\n",
        "\n",
        "        loose_sum = OldTex(\n",
        "            \"\\\\sum_{\\\\theta \\\\in [0, \\\\pi]}\",\n",
        "            \"P(\\\\theta)\",\n",
        "            \"\\\\cdot \",\n",
        "            \"|\\\\cos(\\\\theta)|s^2\"\n",
        "        )\n",
        "        loose_sum.fix_in_frame()\n",
        "        loose_sum.next_to(brace_text, DOWN, LARGE_BUFF)\n",
        "        loose_sum.to_edge(RIGHT)\n",
        "        prob_words = OldTexText(\"How likely is a given value of $\\\\theta$?\", font_size=36)\n",
        "        prob_words.fix_in_frame()\n",
        "        prob_words.next_to(loose_sum[1], DOWN)\n",
        "        prob_words.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        finite_words = Text(\"If finite...\")\n",
        "        finite_words.next_to(brace_text, DOWN, LARGE_BUFF).fix_in_frame()\n",
        "        self.add(finite_words)\n",
        "        face.rotate(-angle_of_vector([*get_normal()[:2], 0]))\n",
        "        face.shift(fc - normal_vect.get_start())\n",
        "        for d_theta in (*[-0.2] * 10, *[0.2] * 10):\n",
        "            face.rotate(d_theta, np.cross(get_normal(), OUT), about_point=fc)\n",
        "            self.wait(0.25)\n",
        "\n",
        "        self.play(\n",
        "            Write(loose_sum.get_part_by_tex(\"P(\\\\theta)\")),\n",
        "            FadeIn(prob_words, 0.5 * DOWN),\n",
        "            FadeOut(finite_words),\n",
        "            ApplyMethod(frame.set_x, 1, run_time=2)\n",
        "        )\n",
        "        update_theta_ring(theta_ring)\n",
        "        self.add(theta_ring, sphere)\n",
        "        self.play(\n",
        "            Rotate(face, TAU, OUT, about_point=fc, run_time=4),\n",
        "            ShowCreation(theta_ring, run_time=4),\n",
        "        )\n",
        "        theta_ring.add_updater(update_theta_ring)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(shadow_area[1].copy(), loose_sum.get_part_by_tex(\"cos\")),\n",
        "            Write(loose_sum.get_part_by_tex(\"\\\\cdot\")),\n",
        "            FadeOut(prob_words, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(loose_sum[0], run_time=2),\n",
        "            run_time=3,\n",
        "        )\n",
        "        face.rotate(get_theta(), axis=np.cross(get_normal(), OUT), about_point=fc)\n",
        "        for x in np.arange(0.2, PI, 0.2):\n",
        "            face.rotate(0.2, UP, about_point=fc)\n",
        "            self.wait(0.5)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Continuous\n",
        "        sum_brace = Brace(loose_sum[0], DOWN, buff=SMALL_BUFF)\n",
        "        continuum = OldTexText(\"Continuum\\\\\\\\(uncountably infinite)\", font_size=36)\n",
        "        continuum.next_to(sum_brace, DOWN, SMALL_BUFF)\n",
        "        zero = OldTex('0')\n",
        "        zero.next_to(loose_sum[1], DOWN, buff=1.5)\n",
        "        zero.shift(1.5 * RIGHT)\n",
        "        zero_arrow = Arrow(loose_sum[1], zero, buff=SMALL_BUFF)\n",
        "        nonsense_brace = Brace(loose_sum, UP)\n",
        "        nonsense = nonsense_brace.get_text(\"Not really a sensible expression\", font_size=36)\n",
        "\n",
        "        for mob in [sum_brace, continuum, zero, zero_arrow, nonsense_brace, nonsense]:\n",
        "            mob.fix_in_frame()\n",
        "            mob.set_color(YELLOW)\n",
        "        VGroup(nonsense_brace, nonsense).set_color(RED)\n",
        "\n",
        "        face.start_time = self.time\n",
        "        face.clear_updaters()\n",
        "        face.add_updater(lambda f, dt: f.rotate(\n",
        "            angle=0.25 * dt * math.cos(0.1 * (self.time - f.start_time)),\n",
        "            axis=np.cross(get_normal(), OUT),\n",
        "            about_point=fc,\n",
        "        ).shift(fc - f[1].get_start()))\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(sum_brace),\n",
        "            FadeIn(continuum, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            ShowCreation(zero_arrow),\n",
        "            GrowFromPoint(zero, zero_arrow.get_start()),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        inf_sum_group = VGroup(\n",
        "            nonsense_brace, nonsense,\n",
        "            sum_brace, continuum,\n",
        "            zero_arrow, zero,\n",
        "            loose_sum,\n",
        "        )\n",
        "        top_part = inf_sum_group[:2]\n",
        "        top_part.set_opacity(0)\n",
        "        self.play(\n",
        "            inf_sum_group.animate.to_corner(UR),\n",
        "            FadeOut(VGroup(brace, brace_text, shadow_area[1])),\n",
        "            run_time=2,\n",
        "        )\n",
        "        top_part.set_fill(opacity=1)\n",
        "        self.play(\n",
        "            GrowFromCenter(nonsense_brace),\n",
        "            Write(nonsense),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "        # Swap for an integral\n",
        "        integral = OldTex(\n",
        "            \"\\\\int_0^\\\\pi \",\n",
        "            \"p(\\\\theta)\",\n",
        "            \"\\\\cdot \",\n",
        "            \"|\\\\cos(\\\\theta)| s^2\",\n",
        "            \"d\\\\theta\",\n",
        "        )\n",
        "        integral.shift(loose_sum[-1].get_right() - integral[-1].get_right())\n",
        "        integral.fix_in_frame()\n",
        "\n",
        "        self.play(LaggedStart(*map(FadeOut, inf_sum_group[:-1])))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                loose_sum[0], integral[0],\n",
        "                fade_transform_mismatches=True,\n",
        "\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransformPieces(loose_sum[1:4], integral[1:4]),\n",
        "            Write(integral[4])\n",
        "        )\n",
        "        self.wait(5)\n",
        "        face.clear_updaters()\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show 2d slice\n",
        "        back_half_sphere = Sphere(u_range=(0, PI))\n",
        "        back_half_sphere.match_color(sphere)\n",
        "        back_half_sphere.set_opacity(sphere.get_opacity())\n",
        "        back_half_sphere.shift(fc)\n",
        "        back_half_mesh = SurfaceMesh(back_half_sphere, resolution=(11, 11))\n",
        "        back_half_mesh.set_stroke(BLUE_D, 1, 0.75)\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(TEAL, 1)\n",
        "        circle.rotate(PI / 2, RIGHT)\n",
        "        circle.move_to(fc)\n",
        "\n",
        "        frame.clear_updaters()\n",
        "        theta_ring.deactivate_depth_test()\n",
        "        theta_ring.uniforms.pop(\"anti_alias_width\")\n",
        "        theta_ring.set_stroke(width=1)\n",
        "        self.play(\n",
        "            FadeOut(sphere),\n",
        "            sphere_mesh.animate.set_stroke(opacity=0.25),\n",
        "            FadeIn(circle),\n",
        "            theta_ring.animate.set_stroke(width=1),\n",
        "            frame.animate.reorient(-6, 87).set_height(4),\n",
        "            integral.animate.set_height(0.5).set_opacity(0).to_corner(UR),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.remove(integral)\n",
        "\n",
        "        # Finite sample\n",
        "        def get_tick_marks(theta_samples, tl=0.05):\n",
        "            return VGroup(*(\n",
        "                Line((1 - tl / 2) * p, (1 + tl / 2) * p).shift(fc)\n",
        "                for theta in theta_samples\n",
        "                for p in [np.array([math.sin(theta), 0, math.cos(theta)])]\n",
        "            )).set_stroke(YELLOW, 1)\n",
        "\n",
        "        factor = 1\n",
        "        theta_samples = np.linspace(0, PI, factor * sphere_mesh.resolution[0])\n",
        "        dtheta = theta_samples[1] - theta_samples[0]\n",
        "        tick_marks = get_tick_marks(theta_samples)\n",
        "\n",
        "        def set_theta(face, theta):\n",
        "            face.apply_matrix(rotation_between_vectors(\n",
        "                normal_vect.get_vector(), OUT\n",
        "            ), about_point=fc)\n",
        "            face.rotate(theta, UP, about_point=fc)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(tick_marks[:-1]),\n",
        "            UpdateFromAlphaFunc(\n",
        "                face, lambda f, a: set_theta(face, theta_samples[int(a * (len(theta_samples) - 2))])\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.add(tick_marks)\n",
        "        self.wait(2)\n",
        "\n",
        "        tsi = factor * 6  # theta sample index\n",
        "        dt_line = Line(tick_marks[tsi].get_center(), tick_marks[tsi + 1].get_center())\n",
        "        dt_brace = Brace(\n",
        "            Line(ORIGIN, RIGHT), UP\n",
        "        )\n",
        "        dt_brace.scale(0.5)\n",
        "        dt_brace.set_width(dt_line.get_length(), stretch=True)\n",
        "        dt_brace.rotate(PI / 2, RIGHT)\n",
        "        dt_brace.rotate(theta_samples[tsi], UP)\n",
        "        dt_brace.move_to(dt_line)\n",
        "        dt_brace.shift(SMALL_BUFF * normalize(dt_line.get_center() - fc))\n",
        "        dt_label = OldTex(\"\\\\Delta\\\\theta\", font_size=24)\n",
        "        dt_label.rotate(PI / 2, RIGHT)\n",
        "        dt_label.next_to(dt_brace, OUT + RIGHT, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            Write(dt_brace),\n",
        "            Write(dt_label),\n",
        "            run_time=1,\n",
        "        )\n",
        "        sphere.set_opacity(0.1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(10, 70),\n",
        "            Rotate(face, -get_theta() + theta_samples[tsi], UP, about_point=fc),\n",
        "            sphere_mesh.animate.set_stroke(opacity=0.5),\n",
        "            FadeIn(sphere),\n",
        "            run_time=3\n",
        "        )\n",
        "        frame.add_updater(update_frame)\n",
        "        self.wait()\n",
        "\n",
        "        # Latitude band\n",
        "        def get_band(index):\n",
        "            band = Sphere(\n",
        "                u_range=(0, TAU), v_range=theta_samples[index:index + 2],\n",
        "                prefered_creation_axis=1,\n",
        "            )\n",
        "            band.set_color(YELLOW, 0.5)\n",
        "            band.stretch(-1, 2, about_point=ORIGIN)\n",
        "            band.shift(fc)\n",
        "            return band\n",
        "\n",
        "        band = get_band(tsi)\n",
        "\n",
        "        self.add(band, sphere_mesh, sphere)\n",
        "        self.play(\n",
        "            ShowCreation(band),\n",
        "            Rotate(face, dtheta, UP, about_point=fc),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(Rotate(face, -dtheta, UP, about_point=fc), run_time=3)\n",
        "        self.wait(2)\n",
        "\n",
        "        area_question = Text(\"Area of this band?\")\n",
        "        area_question.set_color(YELLOW)\n",
        "        area_question.fix_in_frame()\n",
        "        area_question.set_y(1.75)\n",
        "        area_question.to_edge(RIGHT, buff=2.5)\n",
        "        self.play(Write(area_question))\n",
        "        self.wait()\n",
        "\n",
        "        random_points = [sphere.pfp(random.random()) - fc for x in range(30)]\n",
        "        random_points.append(normal_vect.get_end() - fc)\n",
        "        glow_dots = Group(*(TrueDot(p) for p in random_points))\n",
        "        for dot in glow_dots:\n",
        "            dot.shift(fc)\n",
        "            dot.set_radius(0.2)\n",
        "            dot.set_color(BLUE)\n",
        "            dot.set_glow_factor(2)\n",
        "\n",
        "        theta_ring.suspend_updating()\n",
        "        last_dot = VectorizedPoint()\n",
        "        for dot in glow_dots:\n",
        "            face.apply_matrix(rotation_between_vectors(\n",
        "                get_normal(), dot.get_center() - fc,\n",
        "            ), about_point=fc)\n",
        "            self.add(dot)\n",
        "            self.play(FadeOut(last_dot), run_time=0.25)\n",
        "            last_dot = dot\n",
        "        self.play(FadeOut(last_dot))\n",
        "        self.wait()\n",
        "\n",
        "        # Find the area of the band\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-7.5, 78),\n",
        "            sphere_mesh.animate.set_stroke(opacity=0.2),\n",
        "            band.animate.set_opacity(0.2),\n",
        "        )\n",
        "\n",
        "        one = OldTex(\"1\", font_size=24)\n",
        "        one.rotate(PI / 2, RIGHT)\n",
        "        one.next_to(normal_vect.get_center(), IN + RIGHT, buff=0.05)\n",
        "        radial_line = Line(\n",
        "            [0, 0, normal_vect.get_end()[2]],\n",
        "            normal_vect.get_end()\n",
        "        )\n",
        "        radial_line.set_stroke(BLUE, 2)\n",
        "        r_label = OldTex(\"r\", font_size=20)\n",
        "        sin_label = OldTex(\"\\\\sin(\\\\theta)\", font_size=16)\n",
        "        for label in r_label, sin_label:\n",
        "            label.rotate(PI / 2, RIGHT)\n",
        "            label.next_to(radial_line, OUT, buff=0.05)\n",
        "            label.set_color(BLUE)\n",
        "            label.set_backstroke()\n",
        "\n",
        "        self.play(Write(one))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(normal_vect, radial_line),\n",
        "            FadeTransform(one.copy(), r_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(r_label, sin_label))\n",
        "        self.wait()\n",
        "\n",
        "        band_area = OldTex(\"2\\\\pi \\\\sin(\\\\theta)\", \"\\\\Delta\\\\theta\")\n",
        "        band_area.next_to(area_question, DOWN, LARGE_BUFF)\n",
        "        band_area.set_backstroke()\n",
        "        band_area.fix_in_frame()\n",
        "        circ_label, dt_copy = band_area\n",
        "        circ_brace = Brace(circ_label, DOWN, buff=SMALL_BUFF)\n",
        "        circ_words = circ_brace.get_text(\"Circumference\")\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.rotate(PI / 2)\n",
        "        approx.move_to(midpoint(band_area.get_top(), area_question.get_bottom()))\n",
        "        VGroup(circ_brace, circ_words, approx).set_backstroke().fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(10, 60),\n",
        "        )\n",
        "        theta_ring.update()\n",
        "        self.play(\n",
        "            ShowCreation(theta_ring),\n",
        "            Rotate(face, TAU, OUT, about_point=fc),\n",
        "            FadeIn(circ_label, 0.5 * DOWN, rate_func=squish_rate_func(smooth, 0, 0.5)),\n",
        "            GrowFromCenter(circ_brace),\n",
        "            Write(circ_words),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(frame.animate.reorient(-5, 75))\n",
        "        self.play(FadeTransform(area_question[-1], approx))\n",
        "        area_question.remove(area_question[-1])\n",
        "        self.play(Write(dt_copy))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Probability of falling in band\n",
        "        prob = OldTex(\n",
        "            \"P(\\\\text{Vector} \\\\text{ in } \\\\text{Band})\", \"=\",\n",
        "            \"{2\\\\pi \\\\sin(\\\\theta) \\\\Delta\\\\theta\", \"\\\\over\", \" 4\\\\pi}\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Vector}\": GREY_B,\n",
        "                \"\\\\text{Band}\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        prob.fix_in_frame()\n",
        "        prob.to_edge(RIGHT)\n",
        "        prob.set_y(1)\n",
        "        prob.set_backstroke()\n",
        "        numer = prob.get_part_by_tex(\"\\\\sin\")\n",
        "        numer_rect = SurroundingRectangle(numer, buff=0.05)\n",
        "        numer_rect.set_stroke(YELLOW, 1)\n",
        "        numer_rect.fix_in_frame()\n",
        "        area_question.generate_target()\n",
        "        area_question.target.match_width(numer_rect)\n",
        "        area_question.target.next_to(numer_rect, UP, SMALL_BUFF)\n",
        "        denom_rect = SurroundingRectangle(prob.get_part_by_tex(\"4\\\\pi\"), buff=0.05)\n",
        "        denom_rect.set_stroke(BLUE, 2)\n",
        "        denom_rect.fix_in_frame()\n",
        "        denom_label = OldTexText(\"Surface area of\\\\\\\\a unit sphere\")\n",
        "        denom_label.scale(area_question.target[0].get_height() / denom_label[0][0].get_height())\n",
        "        denom_label.set_color(BLUE)\n",
        "        denom_label.next_to(denom_rect, DOWN, SMALL_BUFF)\n",
        "        denom_label.fix_in_frame()\n",
        "\n",
        "        i = prob.index_of_part_by_tex(\"sin\")\n",
        "        self.play(\n",
        "            FadeTransform(band_area, prob.get_part_by_tex(\"sin\"), remover=True),\n",
        "            MoveToTarget(area_question),\n",
        "            FadeIn(prob[:i]),\n",
        "            FadeIn(prob[i + 1:]),\n",
        "            FadeIn(numer_rect),\n",
        "            *map(FadeOut, [approx, circ_brace, circ_words]),\n",
        "            frame.animate.set_x(1.5),\n",
        "        )\n",
        "        self.add(prob)\n",
        "        self.remove(band_area)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(denom_rect),\n",
        "            FadeIn(denom_label, 0.5 * DOWN),\n",
        "        )\n",
        "        sc = sphere.copy().flip(UP).scale(1.01).set_color(BLUE, 0.5)\n",
        "        self.add(sc, sphere_mesh)\n",
        "        self.play(ShowCreation(sc), run_time=3)\n",
        "        self.play(FadeOut(sc))\n",
        "        self.wait()\n",
        "\n",
        "        # Expression for average\n",
        "        sphere_group = Group(\n",
        "            sphere, sphere_mesh, theta_ring, band,\n",
        "            circle, radial_line, sin_label, one, tick_marks,\n",
        "            dt_brace, dt_label,\n",
        "        )\n",
        "\n",
        "        average_eq = OldTex(\n",
        "            \"\\\\text{Average shadow} \\\\\\\\\",\n",
        "            \"\\\\sum_{\\\\theta}\",\n",
        "            \"{2\\\\pi\", \"\\\\sin(\\\\theta)\", \" \\\\Delta\\\\theta\", \"\\\\over\", \" 4\\\\pi}\",\n",
        "            \"\\\\cdot\", \"|\\\\cos(\\\\theta)|\", \"s^2\"\n",
        "        )\n",
        "        average_eq.fix_in_frame()\n",
        "        average_eq.move_to(prob).to_edge(UP)\n",
        "        average_eq[0].scale(1.25)\n",
        "        average_eq[0].shift(MED_SMALL_BUFF * UP)\n",
        "        average_eq[0].match_x(average_eq[1:])\n",
        "\n",
        "        new_prob = average_eq[2:7]\n",
        "        prob_rect = SurroundingRectangle(new_prob)\n",
        "        prob_rect.set_stroke(YELLOW, 2)\n",
        "        prob_rect.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(average_eq[:1]),\n",
        "            FadeIn(prob_rect),\n",
        "            prob[:5].animate.match_width(prob_rect).next_to(prob_rect, DOWN, buff=0.15),\n",
        "            FadeTransform(prob[-3:], new_prob),\n",
        "            *map(FadeOut, [prob[5], numer_rect, denom_rect, area_question, denom_label])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(sphere_group),\n",
        "            FadeIn(average_eq[-3:]),\n",
        "            UpdateFromAlphaFunc(face, lambda f, a: f[0].set_fill(opacity=0.5 * a))\n",
        "        )\n",
        "        self.wait()\n",
        "        band.set_opacity(0.5)\n",
        "        bands = Group(*(get_band(i) for i in range(len(theta_samples) - 1)))\n",
        "        sphere_mesh.set_stroke(opacity=0.5)\n",
        "        self.add(sphere_mesh, sphere, bands)\n",
        "        self.play(\n",
        "            FadeIn(average_eq[1]),\n",
        "            UpdateFromAlphaFunc(face, lambda f, a: f[0].set_fill(opacity=0.5 * (1 - a))),\n",
        "            FadeIn(sphere),\n",
        "            FadeIn(tick_marks),\n",
        "            FadeIn(sphere_mesh),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, bands,\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.5,\n",
        "                run_time=8,\n",
        "                remover=True\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Simplify\n",
        "        average2 = OldTex(\n",
        "            \"{2\\\\pi\", \"\\\\over\", \"4\\\\pi}\", \"s^2\",\n",
        "            \"\\\\sum_{\\\\theta}\",\n",
        "            \"\\\\sin(\\\\theta)\", \"\\\\Delta\\\\theta\",\n",
        "            \"\\\\cdot\", \"|\\\\cos(\\\\theta)|\"\n",
        "        )\n",
        "        average2.fix_in_frame()\n",
        "        average2.move_to(average_eq[1:], RIGHT)\n",
        "        half = OldTex(\"1 \\\\over 2\")\n",
        "        pre_half = average2[:3]\n",
        "        half.move_to(pre_half, RIGHT)\n",
        "        half_rect = SurroundingRectangle(pre_half, buff=SMALL_BUFF)\n",
        "        half_rect.set_stroke(RED, 1)\n",
        "        VGroup(half, half_rect).fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(prob_rect),\n",
        "            FadeOut(prob[:5]),\n",
        "            *(\n",
        "                FadeTransform(average_eq[i], average2[j], path_arc=10 * DEGREES)\n",
        "                for i, j in [\n",
        "                    (1, 4),\n",
        "                    (2, 0),\n",
        "                    (3, 5),\n",
        "                    (4, 6),\n",
        "                    (5, 1),\n",
        "                    (6, 2),\n",
        "                    (7, 7),\n",
        "                    (8, 8),\n",
        "                    (9, 3),\n",
        "                ]\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(ShowCreation(half_rect))\n",
        "        self.play(\n",
        "            FadeTransform(pre_half, half),\n",
        "            FadeOut(half_rect),\n",
        "        )\n",
        "        sin, dt, dot, cos = average2[5:]\n",
        "        tail = VGroup(cos, dot, sin, dt)\n",
        "        tail.generate_target()\n",
        "        tail.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        tail.target.move_to(tail, LEFT)\n",
        "        tail.target[-1].align_to(sin[0], DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(tail, path_arc=PI / 2),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        integral = OldTex(\"\\\\int_0^\\\\pi \")\n",
        "        integral.next_to(tail, LEFT, SMALL_BUFF)\n",
        "        integral.fix_in_frame()\n",
        "        dtheta = OldTex(\"d\\\\theta\").fix_in_frame()\n",
        "        dtheta.move_to(tail[-1], LEFT)\n",
        "\n",
        "        average_copy = VGroup(half, average2[3:]).copy()\n",
        "        average_copy.set_backstroke()\n",
        "        self.play(\n",
        "            VGroup(half, average2[3]).animate.next_to(integral, LEFT, SMALL_BUFF),\n",
        "            FadeTransform(average2[4], integral),\n",
        "            FadeTransform(tail[-1], dtheta),\n",
        "            average_copy.animate.shift(2.5 * DOWN),\n",
        "            frame.animate.set_phi(80 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreationThenFadeOut(SurroundingRectangle(average_copy[1][-3]).fix_in_frame()),\n",
        "            ShowCreationThenFadeOut(SurroundingRectangle(dtheta).fix_in_frame()),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # The limit\n",
        "        brace = Brace(average_copy, UP, buff=SMALL_BUFF)\n",
        "        brace_text = brace.get_text(\n",
        "            \"What does this approach for finer subdivisions?\",\n",
        "            font_size=30\n",
        "        )\n",
        "        arrow = Arrow(integral.get_bottom(), brace_text)\n",
        "        VGroup(brace, brace_text, arrow).set_color(YELLOW).fix_in_frame()\n",
        "        brace_text.set_backstroke()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(brace_text, lag_ratio=0.1)\n",
        "        )\n",
        "\n",
        "        for n in range(1, 4):\n",
        "            new_ticks = get_tick_marks(\n",
        "                np.linspace(0, PI, sphere_mesh.resolution[0] * 2**n),\n",
        "                tl=0.05 / n\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(new_ticks),\n",
        "                FadeOut(tick_marks),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.wait()\n",
        "            tick_marks = new_ticks\n",
        "\n",
        "        # Make room for computation\n",
        "        face[0].set_fill(BLUE_D, opacity=0.75)\n",
        "        face[0].set_stroke(WHITE, 0.5, 1)\n",
        "        rect = Rectangle(fill_color=BLACK, fill_opacity=1, stroke_width=0)\n",
        "        rect.replace(self.plane, stretch=True)\n",
        "        rect.stretch(4 / 12, dim=0, about_edge=RIGHT)\n",
        "        rect.scale(1.01)\n",
        "        top_line = VGroup(half, average2[3], integral, tail[:-1], dtheta)\n",
        "        self.add(face[0], sphere)\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [arrow, brace_text, brace, average_copy])),\n",
        "            # UpdateFromAlphaFunc(face, lambda f, a: f[0].set_fill(opacity=0.5 * a)),\n",
        "            GrowFromCenter(face[0], remover=True),\n",
        "            frame.animate.set_height(6).set_x(3.5),\n",
        "            FadeIn(rect),\n",
        "            FadeOut(tick_marks),\n",
        "            top_line.animate.set_width(4).to_edge(UP).to_edge(RIGHT, buff=LARGE_BUFF),\n",
        "            FadeOut(average_eq[0], UP),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.add(face, sphere)\n",
        "        self.begin_ambient_rotation(face, about_point=fc, speed=0.1)\n",
        "\n",
        "        # Computation\n",
        "        new_lines = VGroup(\n",
        "            OldTex(\"{1 \\\\over 2} s^2 \\\\cdot 2 \\\\int_0^{\\\\pi / 2} \\\\cos(\\\\theta)\\\\sin(\\\\theta)\\\\,d\\\\theta\"),\n",
        "            OldTex(\"{1 \\\\over 2} s^2 \\\\cdot \\\\int_0^{\\\\pi / 2} \\\\sin(2\\\\theta)\\\\,d\\\\theta\"),\n",
        "            OldTex(\"{1 \\\\over 2} s^2 \\\\cdot \\\\left[ -\\\\frac{1}{2} \\\\cos(2\\\\theta) \\\\right]_0^{\\\\pi / 2}\"),\n",
        "            OldTex(\"{1 \\\\over 2} s^2 \\\\cdot \\\\left(-\\\\left(-\\\\frac{1}{2}\\\\right) - \\\\left(-\\\\frac{1}{2}\\\\right)\\\\right)\"),\n",
        "            OldTex(\"{1 \\\\over 2} s^2\"),\n",
        "        )\n",
        "        new_lines.scale(top_line.get_height() / new_lines[0].get_height())\n",
        "        kw = {\"buff\": 0.35, \"aligned_edge\": LEFT}\n",
        "        new_lines.arrange(DOWN, **kw)\n",
        "        new_lines.next_to(top_line, DOWN, **kw)\n",
        "        new_lines.fix_in_frame()\n",
        "\n",
        "        annotations = VGroup(\n",
        "            OldTexText(\"To avoid the annoying absolute value, just\\\\\\\\cover the northern hemisphere and double it.\"),\n",
        "            OldTexText(\"Trig identity: $\\\\sin(2\\\\theta) = 2\\\\cos(\\\\theta)\\\\sin(\\\\theta)$\"),\n",
        "            OldTexText(\"Antiderivative\"),\n",
        "            OldTexText(\"Try not to get lost in\\\\\\\\the sea of negatives...\"),\n",
        "            OldTexText(\"Whoa, that turned out nice!\"),\n",
        "        )\n",
        "        annotations.fix_in_frame()\n",
        "        annotations.set_color(YELLOW)\n",
        "        annotations.scale(0.5)\n",
        "\n",
        "        rect = SurroundingRectangle(new_lines[-1], buff=SMALL_BUFF)\n",
        "        rect.set_stroke(YELLOW, 2).fix_in_frame()\n",
        "\n",
        "        for note, line in zip(annotations, new_lines):\n",
        "            note.next_to(line, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, new_lines, lag_ratio=0.7),\n",
        "            LaggedStartMap(FadeIn, annotations, lag_ratio=0.7),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait(20)\n",
        "        self.play(\n",
        "            new_lines[:-1].animate.set_opacity(0.5),\n",
        "            annotations[:-1].animate.set_opacity(0.5),\n",
        "            ShowCreation(rect),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_solid(self):\n",
        "        face = Square(side_length=2)\n",
        "        face.set_fill(BLUE, 0.5)\n",
        "        face.set_stroke(width=0)\n",
        "        normal = Vector(OUT)\n",
        "        normal.shift(2e-2 * OUT)\n",
        "        face = VGroup(face, normal)\n",
        "        face.set_stroke(background=True)\n",
        "        face.apply_depth_test()\n",
        "        return face\n",
        "\n",
        "\n",
        "class AskAboutAverageCosValue(AllPossibleOrientations):\n",
        "    def construct(self):\n",
        "        self.remove(self.solid)\n",
        "        self.remove(self.shadow)\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(5)\n",
        "        frame.reorient(-5, 80)\n",
        "        frame.shift(2 * RIGHT)\n",
        "        self.init_frame_rotation()\n",
        "\n",
        "        # Copy pasting from above...not great\n",
        "        fc = 3 * OUT\n",
        "        sphere = Sphere(radius=1)\n",
        "        sphere.set_color(GREY_E, 0.25)\n",
        "        sphere.move_to(fc)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "\n",
        "        sphere_mesh = SurfaceMesh(sphere, resolution=(21, 11))\n",
        "        sphere_mesh.set_stroke(BLUE_E, 1, 0.5)\n",
        "\n",
        "        for sm in sphere_mesh.get_family():\n",
        "            sm.uniforms[\"anti_alias_width\"] = 0\n",
        "\n",
        "        self.add(sphere, sphere_mesh)\n",
        "\n",
        "        normal_vect = Arrow(sphere.get_center(), sphere.pfp(0.2), buff=0)\n",
        "\n",
        "        def randomly_place_vect():\n",
        "            theta = random.uniform(0.1, PI - 0.1)\n",
        "            phi = random.uniform(-PI / 4, PI / 4) + random.choice([0, PI])\n",
        "            point = fc + np.array([\n",
        "                math.sin(theta) * math.cos(phi),\n",
        "                math.sin(theta) * math.sin(phi),\n",
        "                math.cos(theta),\n",
        "            ])\n",
        "            normal_vect.put_start_and_end_on(sphere.get_center(), point)\n",
        "\n",
        "        def get_normal():\n",
        "            return normal_vect.get_vector()\n",
        "\n",
        "        def get_theta():\n",
        "            return np.arccos(get_normal()[2] / get_norm(get_normal()))\n",
        "\n",
        "        def get_arc():\n",
        "            result = Arc(PI / 2, -get_theta(), radius=0.25)\n",
        "            result.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n",
        "            result.rotate(angle_of_vector([*get_normal()[:2], 0]), OUT, about_point=ORIGIN)\n",
        "            result.shift(fc)\n",
        "            result.set_stroke(WHITE, 1)\n",
        "            result.apply_depth_test()\n",
        "            return result\n",
        "\n",
        "        arc = always_redraw(get_arc)\n",
        "\n",
        "        theta = OldTex(\"\\\\theta\", font_size=20)\n",
        "        theta.rotate(PI / 2, RIGHT)\n",
        "        theta.set_backstroke(width=2)\n",
        "        theta.add_updater(lambda m: m.next_to(\n",
        "            arc.pfp(0.5), arc.pfp(0.5) - fc, buff=0.05)\n",
        "        )\n",
        "\n",
        "        z_axis = Line(ORIGIN, 10 * OUT)\n",
        "        z_axis.set_stroke(WHITE, 1)\n",
        "        z_axis.apply_depth_test()\n",
        "\n",
        "        self.add(z_axis, normal_vect, arc, theta)\n",
        "        self.add(sphere_mesh, sphere)\n",
        "\n",
        "        # Show random samples\n",
        "        question = OldTexText(\"What's the mean?\")\n",
        "        question.to_corner(UR)\n",
        "        question.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        question.fix_in_frame()\n",
        "        arrow = Arrow(question, question.get_center() + DOWN)\n",
        "        arrow.fix_in_frame()\n",
        "\n",
        "        values = VGroup()\n",
        "        lhss = VGroup()\n",
        "\n",
        "        self.add(question, arrow)\n",
        "\n",
        "        for n in range(15):\n",
        "            randomly_place_vect()\n",
        "            lhs = OldTex(\"|\\\\cos(\\\\theta_{\" + str(n + 1) + \"})| = \", font_size=30)\n",
        "            value = DecimalNumber(abs(math.cos(get_theta())), font_size=30)\n",
        "            value.next_to(values, DOWN)\n",
        "            for mob in lhs, value:\n",
        "                mob.fix_in_frame()\n",
        "                mob.set_backstroke()\n",
        "            values.add(value)\n",
        "            values.next_to(arrow, DOWN)\n",
        "            lhs.next_to(value, LEFT, buff=SMALL_BUFF)\n",
        "            lhss.add(lhs)\n",
        "\n",
        "            self.add(values, lhss)\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class ThreeCamps(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        # Setup\n",
        "        teacher = self.teacher\n",
        "        students = self.students\n",
        "\n",
        "        image = ImageMobject(\"Shadows_Integral_Intro\")\n",
        "        image.center().set_height(FRAME_HEIGHT)\n",
        "        image.generate_target()\n",
        "        image.target.replace(self.screen)\n",
        "        self.screen.set_stroke(WHITE, 1)\n",
        "        self.screen.save_state()\n",
        "        self.screen.replace(image).set_stroke(width=0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                student.change(\"pondering\", image.target)\n",
        "                for student in students\n",
        "            ), run_time=2, lag_ratio=0.2),\n",
        "            teacher.change(\"tease\")\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reactions\n",
        "        phrases = [\n",
        "            Text(\"How fun!\", font_size=40),\n",
        "            Text(\"Wait, what?\", font_size=40),\n",
        "            Text(\"Okay give\\nme a sec...\", font_size=35),\n",
        "        ]\n",
        "        modes = [\"hooray\", \"erm\", \"confused\"]\n",
        "        heights = np.linspace(2.0, 2.5, 3)\n",
        "        for student, phrase, mode, height in zip(reversed(students), phrases, modes, heights):\n",
        "            self.play(\n",
        "                PiCreatureSays(\n",
        "                    student, phrase, target_mode=mode,\n",
        "                    look_at=image,\n",
        "                    bubble_config={\n",
        "                        \"direction\": LEFT,\n",
        "                        \"width\": 3,\n",
        "                        \"height\": height,\n",
        "                    },\n",
        "                    bubble_type=ThoughtBubble,\n",
        "                    run_time=2\n",
        "                )\n",
        "            )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Let's go over the definition\n",
        "        integral = OldTex(\"\\\\int_0^\\\\pi \\\\dots d\\\\theta\")\n",
        "        integral.move_to(self.hold_up_spot, DOWN)\n",
        "        brace = Brace(integral, UP)\n",
        "        words = OldTexText(\"Let's go over the definition\", font_size=36)\n",
        "        words.next_to(brace, UP, SMALL_BUFF)\n",
        "        words2 = OldTexText(\"It can't hurt, right?\", font_size=36)\n",
        "        words2.move_to(words)\n",
        "        VGroup(brace, words, words2).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeOut(VGroup(student.bubble, student.bubble.content))\n",
        "                for student in reversed(students)\n",
        "            )),\n",
        "            LaggedStart(*(\n",
        "                student.change(\"pondering\", integral)\n",
        "                for student in students\n",
        "            )),\n",
        "            FadeIn(integral, UP),\n",
        "            teacher.change(\"raise_right_hand\", integral),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            words.animate.shift(0.75 * UP).set_opacity(0.5),\n",
        "            FadeIn(words2, 0.2 * UP),\n",
        "            LaggedStart(\n",
        "                self.teacher.change(\"shruggie\"),\n",
        "                self.students[0].change(\"sassy\", words2),\n",
        "                self.students[1].change(\"thinking\", words2),\n",
        "                self.students[2].change(\"well\", words2),\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(self.teacher.change(\"speaking\", words2))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ParticularValuesUnhelpfulOverlay(Scene):\n",
        "    def construct(self):\n",
        "        # Particular value\n",
        "        expr = OldTex(\"P(\\\\theta =\", \"\\\\pi / 4\", \")\", \"=\", \"0\")\n",
        "        expr.set_color_by_tex(\"\\\\pi / 4\", YELLOW)\n",
        "        brace = Brace(expr.get_part_by_tex(\"\\\\pi / 4\"), UP, buff=SMALL_BUFF)\n",
        "        brace.stretch(0.5, 1, about_edge=DOWN)\n",
        "        words = Text(\"Some specific value\", font_size=24)\n",
        "        words.next_to(brace, UP, SMALL_BUFF)\n",
        "        VGroup(brace, words).set_color(YELLOW)\n",
        "        VGroup(expr, brace, words).to_corner(UR)\n",
        "\n",
        "        self.play(FadeIn(expr, lag_ratio=1))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(words, shift=0.2 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Unhelpful\n",
        "        question = OldTexText(\"What are you going\\\\\\\\to do with that?\", font_size=24)\n",
        "        question.next_to(expr, DOWN, LARGE_BUFF)\n",
        "        arrow = Arrow(question, expr.get_part_by_tex(\"0\"), buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # New expr\n",
        "        range_expr = OldTex(\n",
        "            \"P(\\\\pi / 4 < \\\\theta < \\\\pi / 4 + \\\\Delta\\\\theta) > 0\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\pi / 4\": YELLOW,\n",
        "                \"\\\\Delta\\\\theta\": GREY_A,\n",
        "            },\n",
        "            font_size=40\n",
        "        )\n",
        "        range_expr.move_to(expr, RIGHT)\n",
        "        new_brace = Brace(range_expr.slice_by_tex(\"\\\\pi / 4\", \")\"), UP, buff=SMALL_BUFF)\n",
        "        new_words = Text(\"Range of values\", font_size=24)\n",
        "        new_words.next_to(new_brace, UP, SMALL_BUFF)\n",
        "        VGroup(new_brace, new_words).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question),\n",
        "            FadeOut(arrow),\n",
        "            TransformMatchingShapes(expr, range_expr),\n",
        "            FadeTransform(brace, new_brace),\n",
        "            FadeTransform(words, new_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SurfaceAreaOfSphere(Scene):\n",
        "    def construct(self):\n",
        "        sphere = Sphere(radius=3)\n",
        "        sphere.set_color(BLUE_E, 1)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "        sphere.rotate(5 * DEGREES, OUT)\n",
        "        sphere.rotate(80 * DEGREES, LEFT)\n",
        "        sphere.move_to(0.5 * DOWN)\n",
        "\n",
        "        sphere_mesh = SurfaceMesh(sphere)\n",
        "        sphere_mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{Surface area} = 4\\\\pi R^2\",\n",
        "            tex_to_color_map={\n",
        "                \"R\": YELLOW,\n",
        "                \"\\\\text{Surface area}\": BLUE,\n",
        "            },\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.add(equation, sphere, sphere_mesh)\n",
        "        self.play(\n",
        "            Write(sphere_mesh, lag_ratio=0.02, stroke_width=1),\n",
        "            ShowCreation(sphere, rate_func=squish_rate_func(smooth, 0.25, 1)),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntegralOverlay(Scene):\n",
        "    def construct(self):\n",
        "        integral = OldTex(\"\\\\int_0^\\\\pi\")\n",
        "        integral.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(integral, run_time=2))\n",
        "        self.play(integral.animate.set_color(WHITE))\n",
        "        self.play(LaggedStart(*(\n",
        "            FlashAround(sm, time_width=3)\n",
        "            for sm in integral[0][:0:-1]\n",
        "        ), lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AlicesInsights(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Alice's insights\", font_size=72)\n",
        "        title.to_edge(UP)\n",
        "        title.set_backstroke()\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "        underline.scale(1.5)\n",
        "        underline.insert_n_curves(50)\n",
        "        underline.set_stroke(WHITE, width=[0, *4 * [3], 0], opacity=1)\n",
        "        self.add(underline, title)\n",
        "\n",
        "        kw = dict(\n",
        "            t2c={\n",
        "                \"double cover\": YELLOW,\n",
        "                \"mean\": RED,\n",
        "                \"means\": RED,\n",
        "                \"sum\": BLUE,\n",
        "                \"Sum\": BLUE,\n",
        "                \"Average\": RED,\n",
        "            }\n",
        "        )\n",
        "        insights = VGroup(\n",
        "            Text(\"1. The face shadows double cover the cube shadow\", **kw),\n",
        "            # Text(\"2. The mean of the sum is the sum of the means\", **kw),\n",
        "            Text(\"2. Average(Sum(Face shadows)) = Sum(Average(Face shadow))\", **kw),\n",
        "            Text(\"3. Use a sphere to deduce the unknown constant\", **kw),\n",
        "        )\n",
        "        insights.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        insights.next_to(underline, DOWN, LARGE_BUFF)\n",
        "        insights.to_edge(LEFT)\n",
        "\n",
        "        self.play(LaggedStart(*(\n",
        "            FadeIn(insight[:2], 0.25 * DOWN)\n",
        "            for insight in insights\n",
        "        )))\n",
        "        self.wait()\n",
        "        for insight in insights:\n",
        "            self.play(FadeIn(insight[2:], lag_ratio=0.1))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class HalfBathedInLight(ShadowScene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(12)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(0.05 * dt))\n",
        "        cube = self.solid\n",
        "        light = self.light\n",
        "        light.next_to(cube, OUT, 2)\n",
        "        self.add(light)\n",
        "        self.remove(self.plane)\n",
        "        self.shadow.add_updater(lambda m: m.set_opacity(0))\n",
        "        cube.move_to(OUT)\n",
        "        cube.set_opacity(0.95)\n",
        "        cube.rotate(PI / 2, DL)\n",
        "        # cube.add_updater(lambda m: self.sort_to_camera(cube))\n",
        "        cube.update()\n",
        "        cube.clear_updaters()\n",
        "\n",
        "        light_lines = self.get_light_lines()\n",
        "        light_lines.add_updater(lambda m: m.set_stroke(YELLOW, 2))\n",
        "        self.add(light_lines, light)\n",
        "\n",
        "        self.wait(2)\n",
        "        for s, color in zip([slice(3, None), slice(0, 3)], [WHITE, GREY_D]):\n",
        "            cube.generate_target()\n",
        "            sorted_cube = Group(*cube.target)\n",
        "            sorted_cube.sort(lambda p: p[2])\n",
        "            sorted_cube[s].space_out_submobjects(2)\n",
        "            sorted_cube[s].set_color(color)\n",
        "            self.play(\n",
        "                MoveToTarget(cube),\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                run_time=3,\n",
        "            )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class TwoToOneCover(ShadowScene):\n",
        "    inf_light = True\n",
        "    plane_dims = (20, 12)\n",
        "    limited_plane_extension = 8\n",
        "    highlighted_face_color = YELLOW\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-20, 75)\n",
        "        frame.set_z(3)\n",
        "        self.init_frame_rotation()\n",
        "\n",
        "        cube = self.solid\n",
        "        for face in cube:\n",
        "            face.set_fill(opacity=0.9)\n",
        "            face.set_reflectiveness(0.1)\n",
        "            face.set_gloss(0.2)\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        cube.rotate(PI / 3, normalize([3, 4, 5]))\n",
        "        shadow = self.shadow\n",
        "        outline = self.get_shadow_outline()\n",
        "\n",
        "        # Inequality\n",
        "        ineq = self.get_top_expression(\"$<$\")\n",
        "        ineq.fix_in_frame()\n",
        "\n",
        "        lhs = ineq.slice_by_tex(None, \"<\")\n",
        "        lt = ineq.get_part_by_tex(\"<\")\n",
        "        rhs = ineq.slice_by_tex(\"sum\", None)\n",
        "        af_label = ineq[-7:]\n",
        "        lhs.save_state()\n",
        "        lhs.set_x(0)\n",
        "\n",
        "        # Shadow of the cube\n",
        "        wireframe = cube.copy()\n",
        "        for face in wireframe:\n",
        "            face.set_fill(opacity=0)\n",
        "            face.set_stroke(WHITE, 1)\n",
        "        wireframe_shadow = wireframe.copy()\n",
        "        wireframe_shadow.apply_function(flat_project)\n",
        "        wireframe_shadow.set_gloss(0)\n",
        "        wireframe_shadow.set_reflectiveness(0)\n",
        "        wireframe_shadow.set_shadow(0)\n",
        "        for face in wireframe_shadow:\n",
        "            face.set_stroke(GREY_D, 1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(wireframe, lag_ratio=0.1),\n",
        "            Write(lhs[2:-1])\n",
        "        )\n",
        "        self.play(TransformFromCopy(wireframe, wireframe_shadow))\n",
        "        self.play(*map(FadeOut, (wireframe, wireframe_shadow)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(lhs[:2]), FadeIn(lhs[-1]),\n",
        "            Write(outline),\n",
        "            VShowPassingFlash(\n",
        "                outline.copy().set_stroke(YELLOW, 4),\n",
        "                time_width=1.5\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show faces and shadows\n",
        "        cube.save_state()\n",
        "        faces, face_shadows = self.get_faces_and_face_shadows()\n",
        "        faces[:3].set_opacity(0.1)\n",
        "        face_shadow_lines = VGroup(*(\n",
        "            VGroup(*(\n",
        "                Line(v1, v2)\n",
        "                for v1, v2 in zip(f.get_vertices(), fs.get_vertices())\n",
        "            ))\n",
        "            for f, fs in zip(faces, face_shadows)\n",
        "        ))\n",
        "        face_shadow_lines.set_stroke(YELLOW, 0.5, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            Restore(lhs),\n",
        "            FadeIn(af_label, shift=0.5 * RIGHT)\n",
        "        )\n",
        "        self.play(\n",
        "            *(\n",
        "                LaggedStart(*(\n",
        "                    VFadeInThenOut(sm)\n",
        "                    for sm in reversed(mobject)\n",
        "                ), lag_ratio=0.5, run_time=6)\n",
        "                for mobject in [faces, face_shadows, face_shadow_lines]\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(cube.space_out_submobjects, 1.7, rate_func=there_and_back_with_pause, run_time=8),\n",
        "            ApplyMethod(frame.reorient, 20, run_time=8),\n",
        "            Write(lt),\n",
        "            Write(rhs[0]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show a given pair of faces\n",
        "        face_pair = Group(faces[3], faces[5]).copy()\n",
        "        face_pair[1].set_color(RED)\n",
        "        face_pair.save_state()\n",
        "        fp_shadow = get_shadow(face_pair)\n",
        "\n",
        "        self.add(fp_shadow)\n",
        "        self.play(\n",
        "            FadeOut(cube),\n",
        "            *map(VFadeOut, shadow),\n",
        "            FadeOut(outline),\n",
        "            *map(Write, face_pair),\n",
        "        )\n",
        "        self.wait(1)\n",
        "        self.play(Rotate(\n",
        "            face_pair, PI / 2, DOWN,\n",
        "            about_point=cube.get_center(),\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.random_toss(face_pair, about_point=cube.get_center(), run_time=6)\n",
        "        fp_shadow.clear_updaters()\n",
        "        self.play(\n",
        "            FadeIn(cube),\n",
        "            *map(VFadeIn, shadow),\n",
        "            FadeOut(face_pair, scale=0),\n",
        "            FadeOut(fp_shadow, scale=0),\n",
        "        )\n",
        "        self.add(shadow)\n",
        "\n",
        "        # Half of sum\n",
        "        new_expression = self.get_top_expression(\" = \", \"$\\\\displaystyle \\\\frac{1}{2}$\")\n",
        "        new_expression.fix_in_frame()\n",
        "        eq_half = VGroup(\n",
        "            new_expression.get_part_by_tex(\"=\"),\n",
        "            new_expression.get_part_by_tex(\"frac\"),\n",
        "        )\n",
        "\n",
        "        cube.save_state()\n",
        "        cube.generate_target(use_deepcopy=True)\n",
        "        cube.target.clear_updaters()\n",
        "        z_sorted_faces = Group(*sorted(list(cube.target), key=lambda f: f.get_z()))\n",
        "        z_sorted_faces[:3].shift(2 * LEFT)\n",
        "        z_sorted_faces[3:].shift(2 * RIGHT)\n",
        "\n",
        "        cube.clear_updaters()\n",
        "        self.play(\n",
        "            MoveToTarget(cube),\n",
        "            ApplyMethod(frame.reorient, 0, run_time=2)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lt, UP),\n",
        "            Write(eq_half),\n",
        "            ReplacementTransform(rhs, new_expression[-len(rhs):]),\n",
        "            ReplacementTransform(lhs, new_expression[:len(lhs)]),\n",
        "        )\n",
        "        self.remove(ineq)\n",
        "        self.add(new_expression)\n",
        "        self.wait(2)\n",
        "        anims = []\n",
        "        for part in z_sorted_faces:\n",
        "            pc = part.copy()\n",
        "            pc.set_fill(YELLOW, 0.25)\n",
        "            pc_shadow = get_shadow(pc)\n",
        "            pc_shadow.clear_updaters()\n",
        "            pc_shadow.match_style(pc)\n",
        "            lines = VGroup(*(\n",
        "                Line(v, flat_project(v))\n",
        "                for v in pc.get_vertices()\n",
        "            ))\n",
        "            lines.set_stroke(YELLOW, 1, 0.1)\n",
        "            anims.append(AnimationGroup(\n",
        "                VFadeInThenOut(pc),\n",
        "                VFadeInThenOut(pc_shadow),\n",
        "                VFadeInThenOut(lines),\n",
        "            ))\n",
        "        self.play(LaggedStart(*anims, lag_ratio=0.4, run_time=6))\n",
        "        self.play(Restore(cube))\n",
        "\n",
        "        # Show the double cover\n",
        "        shadow_point = shadow.get_bottom() + [0.5, 0.75, 0]\n",
        "        dot = GlowDot(shadow_point)\n",
        "        line = DashedLine(\n",
        "            shadow_point + 5 * OUT, shadow_point,\n",
        "            dash_length=0.025\n",
        "        )\n",
        "        line.set_stroke(YELLOW, 1)\n",
        "\n",
        "        def update_line(line):\n",
        "            line.move_to(dot.get_center(), IN)\n",
        "            for dash in line:\n",
        "                dist = cube_sdf(dash.get_center(), cube)\n",
        "                dash.set_stroke(\n",
        "                    opacity=interpolate(0.1, 1.0, clip(10 * dist, -0.5, 0.5) + 0.5)\n",
        "                )\n",
        "                dash.inside = (dist < 0)\n",
        "\n",
        "        line.add_updater(update_line)\n",
        "\n",
        "        entry_point = next(dash for dash in line if dash.inside).get_center()\n",
        "        exit_point = next(dash for dash in reversed(line) if dash.inside).get_center()\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(point + RIGHT, point, buff=0.1)\n",
        "            for point in (entry_point, exit_point)\n",
        "        ))\n",
        "\n",
        "        self.play(ShowCreation(line, rate_func=rush_into))\n",
        "        self.play(FadeIn(dot, scale=10, rate_func=rush_from, run_time=0.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                dot, TAU,\n",
        "                about_point=ORIGIN,\n",
        "                run_time=6,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        for arrow in arrows:\n",
        "            self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrows))\n",
        "\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        self.random_toss(cube, angle=1.5 * TAU, run_time=8)\n",
        "\n",
        "        # Just show wireframe\n",
        "        cube.save_state()\n",
        "        cube.generate_target()\n",
        "        for sm in cube.target:\n",
        "            sm.set_fill(opacity=0)\n",
        "            sm.set_stroke(WHITE, 2)\n",
        "        outline = self.get_shadow_outline()\n",
        "        outline.rotate(PI)\n",
        "        self.play(\n",
        "            MoveToTarget(cube),\n",
        "            dot.animate.move_to(outline.get_start())\n",
        "        )\n",
        "        self.play(MoveAlongPath(dot, outline, run_time=8))\n",
        "        self.wait(2)\n",
        "        self.play(Restore(cube))\n",
        "        self.play(dot.animate.move_to(outline.get_center()), run_time=2)\n",
        "\n",
        "        # Make room for equation animations\n",
        "        # Start here for new scene\n",
        "        area_label = self.get_shadow_area_label()\n",
        "        area_label.shift(1.75 * DOWN + 2.25 * RIGHT)\n",
        "        area_label[0].scale(0, about_edge=RIGHT)\n",
        "        area_label.scale(0.7)\n",
        "        outline.update()\n",
        "        line.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(dot),\n",
        "            FadeOut(line),\n",
        "            ShowCreation(outline),\n",
        "            VFadeIn(area_label),\n",
        "        )\n",
        "\n",
        "        # Single out a face\n",
        "        self.remove(new_expression)\n",
        "        self.wait(2)\n",
        "        face = cube[np.argmax([f.get_z() for f in cube])].copy()\n",
        "        face.set_color(YELLOW)\n",
        "        face_shadow = get_shadow(face)\n",
        "        face_shadow_area = DecimalNumber(get_norm(face_shadow.get_area_vector()) / (self.unit_size**2))\n",
        "        face_shadow_area.scale(0.65)\n",
        "        face_shadow_area.move_to(area_label)\n",
        "        face_shadow_area.shift(flat_project(face.get_center() - cube.get_center()))\n",
        "        face_shadow_area.shift(SMALL_BUFF * UR)\n",
        "        face_shadow_area.fix_in_frame()\n",
        "\n",
        "        cube.save_state()\n",
        "        self.remove(cube)\n",
        "        self.play(\n",
        "            *(\n",
        "                f.animate.set_fill(opacity=0)\n",
        "                for f in cube\n",
        "            ),\n",
        "            FadeOut(outline),\n",
        "            FadeOut(area_label),\n",
        "            Write(face),\n",
        "            FadeIn(face_shadow),\n",
        "            FadeIn(face_shadow_area),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Restore(cube),\n",
        "            *map(FadeOut, (face, face_shadow, face_shadow_area)),\n",
        "            *map(FadeIn, (outline, area_label)),\n",
        "        )\n",
        "\n",
        "        # Show simple rotations\n",
        "        for x in range(2):\n",
        "            self.random_toss(cube)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        # Many random orientations\n",
        "        for x in range(40):\n",
        "            self.randomly_reorient(cube)\n",
        "            self.wait(0.25)\n",
        "\n",
        "        # Show sum of faces again (play 78)\n",
        "        self.random_toss(cube, 2 * TAU, run_time=8, meta_speed=10)\n",
        "        self.wait()\n",
        "\n",
        "        cube.save_state()\n",
        "        sff = 1.5\n",
        "        self.play(\n",
        "            VFadeOut(outline),\n",
        "            VFadeOut(area_label),\n",
        "            cube.animate.space_out_submobjects(sff)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.random_toss(cube, angle=PI)\n",
        "            self.wait()\n",
        "        self.play(cube.animate.space_out_submobjects(1 / sff))\n",
        "\n",
        "        # Mean shadow of a single face\n",
        "        cube_style = cube[0].get_style()\n",
        "\n",
        "        def isolate_face_anims(i, color=YELLOW):\n",
        "            return (\n",
        "                shadow.animate.set_fill(\n",
        "                    interpolate_color(color, BLACK, 0.75)\n",
        "                ),\n",
        "                *(\n",
        "                    f.animate.set_fill(\n",
        "                        color if f is cube[i] else BLUE,\n",
        "                        0.75 if f is cube[i] else 0,\n",
        "                    )\n",
        "                    for f in cube\n",
        "                )\n",
        "            )\n",
        "\n",
        "        def tour_orientations():\n",
        "            self.random_toss(cube, 2 * TAU, run_time=5, meta_speed=10)\n",
        "\n",
        "        self.play(*isolate_face_anims(5))\n",
        "        tour_orientations()\n",
        "        for i, color in ((4, GREEN), (3, RED)):\n",
        "            self.play(\n",
        "                *isolate_face_anims(i, color),\n",
        "            )\n",
        "            tour_orientations()\n",
        "        cube.update()\n",
        "        self.play(\n",
        "            *(\n",
        "                f.animate.set_style(**cube_style)\n",
        "                for f in cube\n",
        "            ),\n",
        "            shadow.animate.set_fill(interpolate_color(BLUE, BLACK, 0.85)),\n",
        "            VFadeIn(outline),\n",
        "            VFadeIn(area_label),\n",
        "        )\n",
        "        self.add(cube)\n",
        "\n",
        "        # Ambient rotation\n",
        "        self.add(cube)\n",
        "        self.begin_ambient_rotation(cube, speed=0.4)\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_top_expression(self, *mid_tex, n_faces=6):\n",
        "        t2c = {\n",
        "            \"Shadow\": GREY_B,\n",
        "            \"Cube\": BLUE_D,\n",
        "            \"Face$_j$\": YELLOW,\n",
        "        }\n",
        "        ineq = OldTexText(\n",
        "            \"Area(Shadow(Cube))\",\n",
        "            *mid_tex,\n",
        "            \" $\\\\displaystyle \\\\sum_{j=1}^\" + f\"{{{n_faces}}}\" + \"$ \",\n",
        "            \"Area(Shadow(Face$_j$))\",\n",
        "            tex_to_color_map=t2c,\n",
        "            isolate=[\"(\", \")\"],\n",
        "        )\n",
        "        ineq.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        return ineq\n",
        "\n",
        "    def get_faces_and_face_shadows(self):\n",
        "        faces = self.solid.deepcopy()\n",
        "        VGroup(*faces).set_fill(self.highlighted_face_color)\n",
        "\n",
        "        shadows = get_pre_shadow(faces, opacity=0.7)\n",
        "        shadows.apply_function(flat_project)\n",
        "        return faces, shadows\n",
        "\n",
        "\n",
        "class ConvexityPrelude(Scene):\n",
        "    def construct(self):\n",
        "        square = Square(side_length=3)\n",
        "        square.rotate(-PI / 4)\n",
        "        square.flip()\n",
        "        square.set_stroke(BLUE, 2)\n",
        "\n",
        "        points = [square.pfp(1 / 8), square.pfp(7 / 8)]\n",
        "\n",
        "        beam = VGroup(\n",
        "            Line(points[0] + 3 * UP, points[0], stroke_width=3),\n",
        "            Line(points[0], points[1], stroke_width=2),\n",
        "            Line(points[1], points[1] + 3 * DOWN, stroke_width=1),\n",
        "        )\n",
        "\n",
        "        beam.set_stroke(YELLOW)\n",
        "\n",
        "        words = OldTexText(\"2 intersections\\\\\\\\\", \"(almost always)\")\n",
        "        words[1].scale(0.7, about_edge=UP).set_color(GREY_B)\n",
        "        words.to_edge(LEFT)\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(words[0].get_right(), point)\n",
        "            for point in points\n",
        "        ))\n",
        "\n",
        "        dots = GlowDot()\n",
        "        dots.set_points(points)\n",
        "        dots.set_color(WHITE)\n",
        "        dots.set_radius(0.2)\n",
        "        dots.set_glow_factor(3)\n",
        "\n",
        "        self.add(square)\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            ShowCreation(beam),\n",
        "            FadeIn(arrows, lag_ratio=0.7),\n",
        "            FadeIn(dots, lag_ratio=0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        question1 = Text(\"Why is this true?\")\n",
        "        question2 = Text(\"Is this true for all shapes?\")\n",
        "        question2.next_to(question1, DOWN, aligned_edge=LEFT)\n",
        "        VGroup(question1, question2).to_corner(UR)\n",
        "\n",
        "        self.play(Write(question1, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(question2, 0.25 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Convexity\n",
        "        square.generate_target()\n",
        "        convex_shapes = VGroup(\n",
        "            square.target,\n",
        "            RegularPolygon(5, color=TEAL),\n",
        "            Rectangle(2, 1, color=TEAL_E),\n",
        "            RegularPolygon(6, color=GREEN),\n",
        "            Circle(color=GREEN_B),\n",
        "        )\n",
        "        convex_shapes[2].apply_matrix([[1, 0.5], [0, 1]])\n",
        "        convex_shapes[3].shift(2 * RIGHT).apply_complex_function(np.exp)\n",
        "        convex_shapes[3].make_jagged()\n",
        "        for shape in convex_shapes:\n",
        "            shape.set_height(1)\n",
        "            shape.set_stroke(width=2)\n",
        "        convex_shapes.arrange(DOWN)\n",
        "        convex_shapes.set_height(6)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        h_line.set_y(3)\n",
        "        VGroup(v_line, h_line).set_stroke(WHITE, 2)\n",
        "        convex_title = Text(\"Convex\")\n",
        "        non_convex_title = Text(\"Non-convex\")\n",
        "        for title, vect in zip([convex_title, non_convex_title], [LEFT, RIGHT]):\n",
        "            title.scale(1.5)\n",
        "            title.next_to(h_line, UP)\n",
        "            title.shift(vect * FRAME_WIDTH / 4)\n",
        "\n",
        "        convex_shapes.next_to(h_line, DOWN)\n",
        "        convex_shapes.match_x(convex_title)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(square),\n",
        "            FadeIn(convex_shapes[1:], lag_ratio=0.5),\n",
        "            FadeTransform(beam, v_line),\n",
        "            ShowCreation(h_line),\n",
        "            FadeIn(convex_title),\n",
        "            LaggedStart(*map(FadeOut, (\n",
        "                dots, arrows, words,\n",
        "                question1, question2,\n",
        "            ))),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Non-convex shapes\n",
        "        pi = OldTex(\"\\\\pi\").family_members_with_points()[0]\n",
        "        pent = RegularPolygon(5)\n",
        "        pent.set_points_as_corners([ORIGIN, *pent.get_vertices()[1:], ORIGIN])\n",
        "        n_mob = OldTex(\"N\").family_members_with_points()[0]\n",
        "        nc_shapes = VGroup(pi, pent, n_mob)\n",
        "        nc_shapes.set_fill(opacity=0)\n",
        "        nc_shapes.set_stroke(width=2)\n",
        "        nc_shapes.set_submobject_colors_by_gradient(RED, PINK)\n",
        "        for shape in nc_shapes:\n",
        "            shape.set_height(1)\n",
        "        nc_shapes.arrange(DOWN)\n",
        "        nc_shapes.replace(convex_shapes, dim_to_match=1)\n",
        "        nc_shapes.match_x(non_convex_title)\n",
        "\n",
        "        self.play(\n",
        "            Write(non_convex_title, run_time=1),\n",
        "            LaggedStartMap(FadeIn, nc_shapes),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class DefineConvexity(Scene):\n",
        "    def construct(self):\n",
        "        # Shape\n",
        "        definition = \"A set is convex if the line connecting any\\n\"\\\n",
        "                     \"two points within it is contained in the set\"\n",
        "        set_color = BLUE\n",
        "        line_color = GREEN\n",
        "        title = Text(\n",
        "            definition,\n",
        "            t2c={\n",
        "                \"convex\": set_color,\n",
        "                \"line connecting any\\ntwo points\": line_color,\n",
        "            },\n",
        "            t2s={\"convex\": ITALIC},\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        title.set_opacity(0.2)\n",
        "\n",
        "        shape = Square(4.5)\n",
        "        shape.set_fill(set_color, 0.25)\n",
        "        shape.set_stroke(set_color, 2)\n",
        "        shape.next_to(title, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(\n",
        "            title.get_part_by_text(\"A set is convex\").animate.set_opacity(1),\n",
        "            Write(shape)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show two points\n",
        "        line = Line(shape.pfp(0.1), shape.pfp(0.5))\n",
        "        line.scale(0.7)\n",
        "        line.set_stroke(line_color, 2)\n",
        "        dots = DotCloud(line.get_start_and_end())\n",
        "        dots.set_color(line_color)\n",
        "        dots.make_3d(0.5)\n",
        "        dots.save_state()\n",
        "        dots.set_radius(0)\n",
        "        dots.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            title[definition.index(\"if\"):definition.index(\"is\", 16)].animate.set_opacity(1),\n",
        "            Restore(dots),\n",
        "        )\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            title[definition.index(\"is\", 16):].animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "        # Alternate places\n",
        "        dots.add_updater(lambda m: m.set_points(line.get_start_and_end()))\n",
        "\n",
        "        def show_sample_lines(n=5):\n",
        "            for x in range(5):\n",
        "                self.play(\n",
        "                    line.animate.put_start_and_end_on(\n",
        "                        shape.pfp(random.random()),\n",
        "                        shape.pfp(random.random()),\n",
        "                    ).scale(random.random(), about_point=shape.get_center())\n",
        "                )\n",
        "                self.wait(0.5)\n",
        "\n",
        "        show_sample_lines()\n",
        "\n",
        "        # Letter \u03c0\n",
        "        def tex_to_shape(tex):\n",
        "            result = OldTex(tex).family_members_with_points()[0]\n",
        "            result.match_style(shape)\n",
        "            result.match_height(shape)\n",
        "            result.move_to(shape)\n",
        "            result_points = result.get_points().copy()\n",
        "            index = np.argmax([np.dot(p, UR) for p in result_points])\n",
        "            index = 3 * (index // 3)\n",
        "            result.set_points([*result_points[index:], *result_points[:index]])\n",
        "            return result\n",
        "\n",
        "        pi = tex_to_shape(\"\\\\pi\")\n",
        "        letter_c = tex_to_shape(\"\\\\textbf{C}\")\n",
        "        letter_c.insert_n_curves(50)\n",
        "\n",
        "        line.generate_target()\n",
        "        line.target.put_start_and_end_on(*(\n",
        "            pi.get_boundary_point(v) for v in (DL, DR)\n",
        "        ))\n",
        "        line.target.scale(0.9)\n",
        "        not_convex_label = Text(\"Not convex!\", color=RED)\n",
        "        not_convex_label.next_to(pi, LEFT)\n",
        "\n",
        "        shape.insert_n_curves(100)\n",
        "        self.play(\n",
        "            Transform(shape, pi, path_arc=PI / 2),\n",
        "            MoveToTarget(line),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(not_convex_label, scale=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        shape.insert_n_curves(80)\n",
        "        self.play(\n",
        "            Transform(shape, letter_c),\n",
        "            line.animate.put_start_and_end_on(*(\n",
        "                letter_c.pfp(a) for a in (0, 0.5)\n",
        "            )),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            line,\n",
        "            lambda l, a: l.put_start_and_end_on(\n",
        "                letter_c.pfp(0.4 * a), l.get_end()\n",
        "            ),\n",
        "            run_time=6,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Polygon\n",
        "        convex_label = OldTexText(\"Convex \\\\ding{51}\")\n",
        "        convex_label.set_color(YELLOW)\n",
        "        convex_label.move_to(not_convex_label)\n",
        "        polygon = RegularPolygon(7)\n",
        "        polygon.match_height(shape)\n",
        "        polygon.move_to(shape)\n",
        "        polygon.match_style(shape)\n",
        "\n",
        "        self.remove(not_convex_label)\n",
        "        self.play(\n",
        "            FadeTransform(shape, polygon),\n",
        "            line.animate.put_start_and_end_on(\n",
        "                polygon.get_vertices()[1],\n",
        "                polygon.get_vertices()[-1],\n",
        "            ),\n",
        "            TransformMatchingShapes(not_convex_label.copy(), convex_label),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        polygon.generate_target()\n",
        "        new_tip = 2 * line.get_center() - polygon.get_start()\n",
        "        polygon.target.set_points_as_corners([\n",
        "            new_tip, *polygon.get_vertices()[1:], new_tip\n",
        "        ])\n",
        "        self.play(\n",
        "            MoveToTarget(polygon),\n",
        "            TransformMatchingShapes(convex_label, not_convex_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show light beam\n",
        "        beam = DashedLine(ORIGIN, FRAME_WIDTH * RIGHT)\n",
        "        beam.set_stroke(YELLOW, 1)\n",
        "        beam.next_to(line, DOWN, MED_SMALL_BUFF)\n",
        "        flash_line = Line(beam.get_start(), beam.get_end())\n",
        "        flash_line.set_stroke(YELLOW, 5)\n",
        "        flash_line.insert_n_curves(100)\n",
        "        self.play(\n",
        "            ShowCreation(beam),\n",
        "            VShowPassingFlash(flash_line),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NonConvexDoughnut(ShadowScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.remove(self.solid, self.shadow)\n",
        "        torus = Torus()\n",
        "        torus.set_width(4)\n",
        "        torus.set_z(3)\n",
        "        torus.set_color(BLUE_D)\n",
        "        torus.set_opacity(0.7)\n",
        "        torus.set_reflectiveness(0)\n",
        "        torus.set_shadow(0.5)\n",
        "        torus.always_sort_to_camera(self.camera)\n",
        "\n",
        "        shadow = get_shadow(torus)\n",
        "        shadow.always_sort_to_camera(self.camera)\n",
        "\n",
        "        self.add(torus)\n",
        "        self.add(shadow)\n",
        "        self.play(ShowCreation(torus), run_time=2)\n",
        "        self.play(Rotate(torus, PI / 2, LEFT), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Light beam\n",
        "        dot = GlowDot(0.25 * LEFT)\n",
        "        line = DashedLine(dot.get_center(), dot.get_center() + 10 * OUT)\n",
        "        line.set_stroke(YELLOW, 1)\n",
        "        line_shadow = line.copy().set_stroke(opacity=0.1)\n",
        "\n",
        "        self.add(line, torus, line_shadow)\n",
        "        self.play(\n",
        "            FadeIn(dot),\n",
        "            ShowCreation(line),\n",
        "            ShowCreation(line_shadow),\n",
        "            ApplyMethod(frame.reorient, 20, run_time=7)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowGridSum(TwoToOneCover):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.clear()\n",
        "        shape_name = \"Cube\"\n",
        "        n_faces = 6\n",
        "        # shape_name = \"Dodec.\"\n",
        "        # n_faces = 12\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(0, 0)\n",
        "        frame.move_to(ORIGIN)\n",
        "        equation = self.get_top_expression(\" = \", \"$\\\\displaystyle \\\\frac{1}{2}$\", n_faces=n_faces)\n",
        "        self.add(equation)\n",
        "\n",
        "        lhs = equation.slice_by_tex(None, \"=\")\n",
        "        summand = equation.slice_by_tex(\"sum\", None)[1:]\n",
        "\n",
        "        # Abbreviate\n",
        "        t2c = {\n",
        "            f\"\\\\text{{{shape_name}}}\": BLUE,\n",
        "            \"\\\\text{F}_j\": YELLOW,\n",
        "            \"\\\\text{Face}\": YELLOW,\n",
        "            \"\\\\text{Total}\": GREEN,\n",
        "            \"S\": GREY_B,\n",
        "            \"{c}\": RED,\n",
        "        }\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": t2c\n",
        "        }\n",
        "        lhs.alt1 = OldTex(f\"S(\\\\text{{{shape_name}}})\", **kw)\n",
        "        summand.alt1 = OldTex(\"S(\\\\text{F}_j)\", **kw)\n",
        "\n",
        "        def get_s_cube_term(i=\"i\"):\n",
        "            return OldTex(f\"S\\\\big(R_{{{i}}}\", f\"(\\\\text{{{shape_name}}})\\\\big)\", **kw)\n",
        "\n",
        "        def get_s_f_term(i=\"i\", j=\"j\"):\n",
        "            result = OldTex(\n",
        "                f\"S\\\\big(R_{{{i}}}\",\n",
        "                \"(\", \"\\\\text{F}_{\" + str(j) + \"}\", \")\",\n",
        "                \"\\\\big)\",\n",
        "                **kw\n",
        "            )\n",
        "            result[3].set_color(YELLOW)\n",
        "            return result\n",
        "\n",
        "        lhs.alt2 = get_s_cube_term(1)\n",
        "        summand.alt2 = get_s_f_term(1)\n",
        "\n",
        "        for mob, vect in (lhs, RIGHT), (summand, LEFT):\n",
        "            mob.brace = Brace(mob, DOWN, buff=SMALL_BUFF)\n",
        "            mob.alt1.next_to(mob.brace, DOWN)\n",
        "            self.play(\n",
        "                GrowFromCenter(mob.brace),\n",
        "                FadeIn(mob.alt1, shift=0.5 * DOWN),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(mob.brace, scale=0.5),\n",
        "                FadeOut(mob, shift=0.5 * UP),\n",
        "                mob.alt1.animate.move_to(mob, vect),\n",
        "            )\n",
        "            mob.alt2.move_to(mob, vect)\n",
        "        self.wait()\n",
        "\n",
        "        for mob in lhs, summand:\n",
        "            self.play(TransformMatchingShapes(mob.alt1, mob.alt2))\n",
        "            self.wait()\n",
        "\n",
        "        # Add up many rotations\n",
        "        lhss = VGroup(\n",
        "            get_s_cube_term(1),\n",
        "            get_s_cube_term(2),\n",
        "            get_s_cube_term(3),\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            get_s_cube_term(\"n\"),\n",
        "        )\n",
        "        buff = 0.6\n",
        "        lhss.arrange(DOWN, buff=buff)\n",
        "        lhss.move_to(lhs.alt2, UP)\n",
        "\n",
        "        self.remove(lhs.alt2)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                ReplacementTransform(lhs.alt2.copy(), target)\n",
        "                for target in lhss\n",
        "            )),\n",
        "            frame.animate.set_height(10, about_edge=UP),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show empirical mean\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(lhss.get_width() + 0.75)\n",
        "        h_line.next_to(lhss, DOWN, MED_SMALL_BUFF, aligned_edge=RIGHT)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.align_to(h_line, LEFT).shift(0.1 * RIGHT)\n",
        "        plus.match_y(lhss[-1])\n",
        "        total = Text(\"Total\", font_size=60)\n",
        "        total.set_color(GREEN)\n",
        "        total.next_to(h_line, DOWN, buff=0.35)\n",
        "        total.match_x(lhss)\n",
        "\n",
        "        mean_sa = OldTex(\n",
        "            f\"S(\\\\text{{{shape_name}}})\", \"=\", \"\\\\frac{1}{n}\",\n",
        "            \"\\\\sum_{i=1}^n S\\\\big(R_i(\" + f\"\\\\text{{{shape_name}}})\\\\big)\",\n",
        "            **kw,\n",
        "        )\n",
        "\n",
        "        mean_sa.add_to_back(get_overline(mean_sa.slice_by_tex(None, \"=\")))\n",
        "        mean_sa.next_to(total, DOWN, LARGE_BUFF, aligned_edge=RIGHT)\n",
        "\n",
        "        corner_rect = SurroundingRectangle(mean_sa, buff=0.25)\n",
        "        corner_rect.set_stroke(WHITE, 2)\n",
        "        corner_rect.set_fill(GREY_E, 1)\n",
        "        corner_rect.move_to(frame, DL)\n",
        "        corner_rect.shift(0.025 * UR)\n",
        "        mean_sa.move_to(corner_rect)\n",
        "\n",
        "        sum_part = mean_sa.slice_by_tex(\"sum\")\n",
        "        sigma = sum_part[0]\n",
        "        sigma.save_state()\n",
        "        lhss_rect = SurroundingRectangle(lhss)\n",
        "        lhss_rect.set_stroke(BLUE, 2)\n",
        "        sigma.next_to(lhss_rect, LEFT)\n",
        "        sum_group = VGroup(lhss, lhss_rect)\n",
        "\n",
        "        self.play(\n",
        "            Write(lhss_rect),\n",
        "            Write(sigma),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(corner_rect, sigma)\n",
        "        self.play(\n",
        "            FadeIn(corner_rect),\n",
        "            *(\n",
        "                FadeTransform(term.copy(), sum_part[1:])\n",
        "                for term in lhss\n",
        "            ),\n",
        "            Restore(sigma),\n",
        "        )\n",
        "        self.play(Write(mean_sa.get_part_by_tex(\"frac\")))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(mean_sa.slice_by_tex(None, \"frac\")),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Create grid\n",
        "        sf = get_s_f_term\n",
        "        grid_terms = [\n",
        "            [sf(1, 1), sf(1, 2), OldTex(\"\\\\dots\"), sf(1, n_faces)],\n",
        "            [sf(2, 1), sf(2, 2), OldTex(\"\\\\dots\"), sf(2, n_faces)],\n",
        "            [sf(3, 1), sf(3, 2), OldTex(\"\\\\dots\"), sf(3, n_faces)],\n",
        "            [Tex(\"\\\\vdots\"), OldTex(\"\\\\vdots\"), OldTex(\"\\\\ddots\"), OldTex(\"\\\\vdots\")],\n",
        "            [sf(\"n\", 1), sf(\"n\", 2), OldTex(\"\\\\dots\"), sf(\"n\", n_faces)],\n",
        "        ]\n",
        "        grid = VGroup(*(VGroup(*row) for row in grid_terms))\n",
        "        for lhs, row in zip(lhss, grid):\n",
        "            for i in range(len(row) - 1, 0, -1):\n",
        "                is_dots = \"dots\" in row[0].get_tex()\n",
        "                sym = VectorizedPoint() if is_dots else OldTex(\"+\")\n",
        "                row.insert_submobject(i, sym)\n",
        "            row.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            for m1, m2 in zip(row, grid[0]):\n",
        "                m1.match_x(m2)\n",
        "                m1.match_y(lhs)\n",
        "            if not is_dots:\n",
        "                parens = OldTex(\"[]\", font_size=72)[0]\n",
        "                parens.set_stroke(width=2)\n",
        "                parens.set_color(BLUE_B)\n",
        "                parens[0].next_to(row, LEFT, buff=SMALL_BUFF)\n",
        "                parens[1].next_to(row, RIGHT, buff=SMALL_BUFF)\n",
        "                row.add(*parens)\n",
        "                eq_half = OldTex(\"=\", \"\\\\frac{1}{2}\")\n",
        "                eq_half[1].match_height(parens)\n",
        "                eq_half.next_to(parens[0], LEFT, MED_SMALL_BUFF)\n",
        "                row.add(*eq_half)\n",
        "\n",
        "        grid.set_x(frame.get_right()[0] - 1.5, RIGHT)\n",
        "\n",
        "        self.remove(summand.alt2)\n",
        "        self.play(\n",
        "            sum_group.animate.set_x(grid.get_left()[0] - MED_SMALL_BUFF, RIGHT),\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(\n",
        "                    equation.get_part_by_tex(\"frac\"),\n",
        "                    equation.get_part_by_tex(\"=\"),\n",
        "                ),\n",
        "                grid[0][-4:],\n",
        "            ),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(summand.alt2.copy(), part)\n",
        "                for part in grid[0][0:7:2]\n",
        "            )),\n",
        "            FadeOut(equation.get_part_by_tex(\"sum\"), scale=0.25),\n",
        "            Write(grid[0][1:7:2]),  # Plus signs\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeTransform(grid[0].copy(), grid[1]))\n",
        "        self.play(FadeTransform(grid[1].copy(), grid[2]))\n",
        "        self.play(FadeTransform(grid[2].copy(), grid[4]), FadeIn(grid[3]))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Average along columns\n",
        "        cols = VGroup(*(\n",
        "            VGroup(*(row[i] for row in grid)).copy()\n",
        "            for i in [0, 2, 6]\n",
        "        ))\n",
        "        col_rects = VGroup(*(\n",
        "            SurroundingRectangle(col, buff=SMALL_BUFF)\n",
        "            for col in cols\n",
        "        ))\n",
        "        col_rects.set_stroke(YELLOW, 1)\n",
        "\n",
        "        mean_face = OldTex(\"S(\\\\text{Face})\", **kw)\n",
        "        mean_face.add_to_back(get_overline(mean_face))\n",
        "        mean_face.next_to(grid, DOWN, buff=2)\n",
        "        mean_face_words = OldTexText(\"Average shadow\\\\\\\\of one face\")\n",
        "        mean_face_words.move_to(mean_face, UP)\n",
        "\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(rect.get_bottom(), mean_face)\n",
        "            for rect in col_rects\n",
        "        ))\n",
        "        arrow_labels = OldTex(\"\\\\frac{1}{n} \\\\sum \\\\cdots\", font_size=30).replicate(3)\n",
        "        for arrow, label in zip(arrows, arrow_labels):\n",
        "            vect = rotate_vector(normalize(arrow.get_vector()), PI / 2)\n",
        "            label.next_to(arrow.pfp(0.5), vect, SMALL_BUFF)\n",
        "\n",
        "        self.add(cols[0])\n",
        "        self.play(\n",
        "            grid.animate.set_opacity(0.4),\n",
        "            ShowCreation(col_rects[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrows[0]),\n",
        "            FadeIn(arrow_labels[0]),\n",
        "            FadeIn(mean_face_words, DR),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mean_face_words.animate.scale(0.7).next_to(mean_face, DOWN, MED_LARGE_BUFF),\n",
        "            FadeIn(mean_face, scale=2),\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in [1, 2]:\n",
        "            self.play(\n",
        "                FadeOut(cols[i - 1]),\n",
        "                FadeIn(cols[i]),\n",
        "                *(\n",
        "                    ReplacementTransform(group[i - 1], group[i])\n",
        "                    for group in (col_rects, arrows, arrow_labels)\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        # Reposition\n",
        "        frame.generate_target()\n",
        "        frame.target.align_to(total, DOWN)\n",
        "        frame.target.shift(0.5 * DOWN)\n",
        "        frame.target.scale(1.15)\n",
        "        frame.target.align_to(lhss, LEFT).shift(0.25 * LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            VGroup(corner_rect, mean_sa).animate.scale(1.25).move_to(\n",
        "                frame.target, UL\n",
        "            ).shift(0.1 * DR),\n",
        "            MoveToTarget(frame),\n",
        "            FadeOut(mean_face_words),\n",
        "            FadeOut(mean_face),\n",
        "            grid.animate.set_opacity(1),\n",
        "            *(\n",
        "                FadeOut(group[-1])\n",
        "                for group in (cols, col_rects, arrows, arrow_labels)\n",
        "            ),\n",
        "            run_time=3\n",
        "        ))\n",
        "        mean_sa.refresh_bounding_box()  # ??\n",
        "\n",
        "        # Show final result\n",
        "        rhss = VGroup(\n",
        "            OldTex(\"=\", \"\\\\frac{1}{2}\", \"\\\\sum_{j=1}^\" + f\"{{{n_faces}}}\", \" S(\\\\text{F}_j})\", **kw),\n",
        "            OldTex(\"=\", \"\\\\frac{1}{2}\", \"\\\\sum_{j=1}^\" + f\"{{{n_faces}}}\", \" {c}\", \"\\\\cdot \", \"A(\\\\text{F}_j)\", **kw),\n",
        "            OldTex(\"=\", \"\\\\frac{1}{2}\", \"{c}\", \"\\\\cdot \", \"(\\\\text{Surface area})\", **kw),\n",
        "        )\n",
        "        rhss[0].add(get_overline(rhss[0].slice_by_tex(\"S\")))\n",
        "        rhss[2][-2].set_color(WHITE)\n",
        "\n",
        "        rhss.arrange(RIGHT)\n",
        "        rhss.next_to(mean_sa, RIGHT)\n",
        "\n",
        "        corner_rect.generate_target()\n",
        "        corner_rect.target.set_width(\n",
        "            frame.get_width() - 0.2,\n",
        "            stretch=True,\n",
        "            about_edge=LEFT,\n",
        "        )\n",
        "\n",
        "        grid_rect = SurroundingRectangle(grid, buff=SMALL_BUFF)\n",
        "        grid_rect.set_stroke(YELLOW, 1)\n",
        "        grid_rect.set_fill(YELLOW, 0.25)\n",
        "\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(mean_sa.slice_by_tex(\"frac\")),\n",
        "            SurroundingRectangle(rhss[0][1:])\n",
        "        )\n",
        "        for rect in rects:\n",
        "            rect.match_height(corner_rect.target, stretch=True)\n",
        "            rect.match_y(corner_rect.target)\n",
        "        rects[0].set_color(BLUE)\n",
        "        rects[1].set_color(YELLOW)\n",
        "        rects.set_stroke(width=2)\n",
        "        rects.set_fill(opacity=0.25)\n",
        "\n",
        "        rows_first = Text(\"Rows first\")\n",
        "        rows_first.next_to(rects[0], DOWN)\n",
        "        rows_first.match_color(rects[0])\n",
        "        cols_first = Text(\"Columns first\")\n",
        "        cols_first.next_to(rects[1], DOWN)\n",
        "        cols_first.match_color(rects[1])\n",
        "\n",
        "        self.add(corner_rect, mean_sa)\n",
        "        self.play(\n",
        "            MoveToTarget(corner_rect),\n",
        "            Write(rhss[0])\n",
        "        )\n",
        "        self.add(grid_rect, grid)\n",
        "        self.play(VFadeInThenOut(grid_rect, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(rects[0]),\n",
        "            Write(rows_first),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(rects[1]),\n",
        "            Write(cols_first),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, (\n",
        "            *rects, rows_first, cols_first\n",
        "        ))))\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(rhss[0].copy(), rhss[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(rhss[1].copy(), rhss[2]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        key_part = rhss[2][1:]\n",
        "        final_rect = SurroundingRectangle(key_part)\n",
        "        final_rect.set_stroke(YELLOW, 1)\n",
        "        self.play(\n",
        "            corner_rect.animate.set_stroke(width=0).scale(1.1),\n",
        "            FlashAround(key_part, time_width=1.5),\n",
        "            FadeIn(final_rect),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "\n",
        "class LimitBrace(Scene):\n",
        "    def construct(self):\n",
        "        brace = Brace(Line().set_width(3), UP)\n",
        "        tex = brace.get_tex(\"n \\\\to \\\\infty\")\n",
        "        VGroup(brace, tex).set_color(TEAL)\n",
        "        VGroup(brace, tex).set_backstroke()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(tex, shift=0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FromRowsToColumns(Scene):\n",
        "    def construct(self):\n",
        "        n = 5\n",
        "        grid = Dot().get_grid(n, n, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        grids = grid.get_grid(1, 2, buff=3)\n",
        "\n",
        "        buff = 0.2\n",
        "        row_rects = VGroup(*(\n",
        "            SurroundingRectangle(grids[0][k:k + n], buff=buff)\n",
        "            for k in range(0, n * n, n)\n",
        "        ))\n",
        "        col_rects = VGroup(*(\n",
        "            SurroundingRectangle(grids[1][k::n], buff=buff)\n",
        "            for k in range(n)\n",
        "        ))\n",
        "        rects = VGroup(row_rects, col_rects)\n",
        "        rects.set_fill(opacity=0.25)\n",
        "        rects.set_stroke(width=2)\n",
        "        row_rects.set_color(BLUE)\n",
        "        col_rects.set_color(YELLOW)\n",
        "\n",
        "        # plus_template = OldTex(\"+\")\n",
        "        # plus_template.match_height(grids[0][0])\n",
        "        # for grid in grids:\n",
        "        #     plusses = VGroup()\n",
        "        #     for k, dot in enumerate(grid):\n",
        "        #         if k % n != n - 1:\n",
        "        #             pc = plus_template.copy()\n",
        "        #             pc.move_to(midpoint(dot.get_center(), grid[k + 1].get_center()))\n",
        "        #             plusses.add(pc)\n",
        "        #     grid.add(plusses)\n",
        "\n",
        "        arrow = Arrow(grids[0], grids[1], buff=0.5)\n",
        "\n",
        "        self.add(grids[0])\n",
        "        self.play(FadeIn(row_rects, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(grids[0], grids[1]),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.play(FadeIn(col_rects, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ComplainAboutProgress(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"Wait, is that all\\\\\\\\we've accomplished?\"),\n",
        "            target_mode=\"angry\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"guilty\", \"erm\",\n",
        "            look_at=self.students[2].eyes,\n",
        "            added_anims=[self.teacher.change(\"guilty\")],\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SupposedlyObviousProportionality(ShadowScene):\n",
        "    solid_name = \"Cube\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        cube = self.solid\n",
        "        shadow = self.shadow\n",
        "        frame = self.camera.frame\n",
        "        frame.set_z(3)\n",
        "        frame.reorient(-20, 80)\n",
        "        self.init_frame_rotation()\n",
        "        light = self.light\n",
        "        light.next_to(cube, OUT, 50)\n",
        "        equation = get_key_result(self.solid_name)\n",
        "        equation.fix_in_frame()\n",
        "        equation.to_edge(UP)\n",
        "        self.add(equation)\n",
        "\n",
        "        # Rotation\n",
        "        self.begin_ambient_rotation(cube)\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about constant\n",
        "        question = OldTexText(\n",
        "            \"What is $c$?!\",\n",
        "            font_size=72,\n",
        "            tex_to_color_map={\"$c$\": RED}\n",
        "        )\n",
        "        question.fix_in_frame()\n",
        "        question.next_to(equation, DOWN, LARGE_BUFF)\n",
        "        question.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        c_arrow = Arrow(\n",
        "            equation.get_part_by_tex(\"{c}\"),\n",
        "            question.get_corner(UL),\n",
        "        )\n",
        "        c_arrow.set_color(RED)\n",
        "        c_arrow.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(c_arrow),\n",
        "            Write(question)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # \"Obvious\"\n",
        "        obvious_words = OldTexText(\"Isn't this obvious?\", font_size=36)\n",
        "        obvious_words.set_color(GREY_A)\n",
        "        obvious_words.match_y(question)\n",
        "        obvious_words.to_edge(LEFT)\n",
        "        obvious_arrow = Arrow(\n",
        "            obvious_words, equation.get_corner(DL) + RIGHT\n",
        "        )\n",
        "        VGroup(obvious_words, obvious_arrow).fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(question, obvious_words),\n",
        "            ReplacementTransform(c_arrow, obvious_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 2d quantities\n",
        "        cube.clear_updaters()\n",
        "\n",
        "        shadow_label = OldTexText(\"2D\")\n",
        "        shadow_label.move_to(shadow)\n",
        "        face_labels = VGroup()\n",
        "        for face in cube[3:]:\n",
        "            lc = shadow_label.copy()\n",
        "            normal = face.get_unit_normal()\n",
        "            lc.rotate(angle_of_vector(flat_project(normal)) + PI / 2)\n",
        "            lc.apply_matrix(\n",
        "                rotation_between_vectors(OUT, normal)\n",
        "            )\n",
        "            lc.move_to(face)\n",
        "            face.label = lc\n",
        "            face_labels.add(lc)\n",
        "\n",
        "        self.play(\n",
        "            Write(shadow_label),\n",
        "            Write(face_labels),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        scalars = [cube, face_labels, shadow_label]\n",
        "        self.play(\n",
        "            *(\n",
        "                mob.animate.scale(0.5)\n",
        "                for mob in scalars\n",
        "            ),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            *(\n",
        "                mob.animate.stretch(2, 0)\n",
        "                for mob in scalars\n",
        "            ),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # No not really\n",
        "        no_words = Text(\"No, not really\", font_size=30)\n",
        "        no_words.set_color(RED)\n",
        "        no_words.fix_in_frame()\n",
        "        no_words.next_to(obvious_words, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(no_words, 0.25 * DOWN),\n",
        "            FadeOut(shadow_label),\n",
        "            FadeOut(face_labels),\n",
        "        )\n",
        "\n",
        "        # Move light\n",
        "        self.play(\n",
        "            light.animate.next_to(cube, OUT + RIGHT, 2),\n",
        "            run_time=4,\n",
        "            rate_func=rush_from,\n",
        "        )\n",
        "        for s in (1.5, 0.25, 2 / 0.75):\n",
        "            self.play(\n",
        "                cube.animate.scale(s),\n",
        "                run_time=2,\n",
        "            )\n",
        "\n",
        "        # To finish\n",
        "        cube.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        self.begin_ambient_rotation(cube)\n",
        "        self.play(\n",
        "            light.animate.next_to(cube, OUT, 50),\n",
        "            LaggedStart(*map(FadeOut, (\n",
        "                no_words, obvious_words, obvious_arrow,\n",
        "            ))),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(33)\n",
        "\n",
        "\n",
        "class LurkingAssumption(VideoWrapper):\n",
        "    title = \"There's a subtle hidden assumption...\"\n",
        "    wait_time = 4\n",
        "    animate_boundary = False\n",
        "\n",
        "\n",
        "class WhatIsC(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"What is $c$?!\",\n",
        "            tex_to_color_map={\"$c$\": RED},\n",
        "            font_size=72,\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.play(FlashUnder(words, color=RED))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BobsFinalAnswer(Scene):\n",
        "    def construct(self):\n",
        "        answer = OldTex(\n",
        "            \"S(\\\\text{Cube})\", \"=\",\n",
        "            \"\\\\frac{1}{2}\", \"\\\\cdot\", \"{\\\\frac{1}{2}}\",\n",
        "            \"(\\\\text{Surface area})\", \"=\",\n",
        "            \"\\\\frac{1}{4} \\\\big(6s^2\\\\big)\", \"=\",\n",
        "            \"\\\\frac{3}{2} s^2\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Cube}\": BLUE,\n",
        "                \"{\\\\frac{1}{2}}\": RED,\n",
        "            }\n",
        "        )\n",
        "        answer.add_to_back(get_overline(answer[:3]))\n",
        "        equals = answer.get_parts_by_tex(\"=\")\n",
        "        eq_indices = list(map(answer.index_of_part, equals))\n",
        "\n",
        "        eq1 = answer[:eq_indices[1]].deepcopy()\n",
        "        eq2 = answer[:eq_indices[2]].deepcopy()\n",
        "        eq3 = answer.deepcopy()\n",
        "        for eq in eq1, eq2, eq3:\n",
        "            eq.to_edge(RIGHT)\n",
        "            eq.shift(1.25 * UP)\n",
        "\n",
        "        self.play(FadeIn(eq1, DOWN))\n",
        "        self.wait()\n",
        "        for m1, m2 in (eq1, eq2), (eq2, eq3):\n",
        "            self.play(\n",
        "                FadeIn(m2[len(m1):]),\n",
        "                m1.animate.move_to(m2, LEFT),\n",
        "            )\n",
        "            self.remove(m1)\n",
        "            self.add(m2)\n",
        "            self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(eq3[-1])\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FlashAround(eq3[-1], stroke_width=5, time_width=1.5, run_time=1.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowSeveralConvexShapes(Scene):\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(0, 70)\n",
        "\n",
        "        dodec = Dodecahedron()\n",
        "        dodec.set_fill(BLUE_D)\n",
        "\n",
        "        spike = VGroup()\n",
        "        hexagon = RegularPolygon(6)\n",
        "        spike.add(hexagon)\n",
        "        for v1, v2 in adjacent_pairs(hexagon.get_vertices()):\n",
        "            spike.add(Polygon(v1, v2, 2 * OUT))\n",
        "        spike.set_fill(BLUE_E)\n",
        "\n",
        "        blob = Group(Sphere())\n",
        "        blob.stretch(0.5, 0)\n",
        "        blob.stretch(0.5, 1)\n",
        "        blob.set_color(BLUE_E)\n",
        "        blob.apply_function(\n",
        "            lambda p: [*(2 - p[2]) * p[:2], p[2]]\n",
        "        )\n",
        "        blob.set_color(BLUE_E)\n",
        "\n",
        "        cylinder = Group(Cylinder())\n",
        "        cylinder.set_color(GREY_BROWN)\n",
        "        cylinder.rotate(PI / 4, UP)\n",
        "\n",
        "        examples = Group(*(\n",
        "            Group(*mob)\n",
        "            for mob in (dodec, spike, blob, cylinder)\n",
        "        ))\n",
        "\n",
        "        for ex in examples:\n",
        "            ex.set_depth(2)\n",
        "            ex.deactivate_depth_test()\n",
        "            ex.set_gloss(0.5)\n",
        "            ex.set_shadow(0.5)\n",
        "            ex.set_reflectiveness(0.2)\n",
        "            ex.rotate(20 * DEGREES, OUT)\n",
        "            sort_to_camera(ex, self.camera.frame)\n",
        "            for sm in ex:\n",
        "                if isinstance(sm, VMobject):\n",
        "                    sm.set_stroke(WHITE, 1)\n",
        "                    sm.set_fill(opacity=0.9)\n",
        "                else:\n",
        "                    sm.always_sort_to_camera(self.camera)\n",
        "\n",
        "        examples.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(*(\n",
        "            LaggedStartMap(Write, ex, run_time=1)\n",
        "            if isinstance(ex[0], VMobject)\n",
        "            else ShowCreation(ex[0])\n",
        "            for ex in examples\n",
        "        ), lag_ratio=0.5, run_time=8))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KeyResult(Scene):\n",
        "    def construct(self):\n",
        "        eq1, eq2 = [\n",
        "            get_key_result(word)\n",
        "            for word in (\"Cube\", \"Solid\")\n",
        "        ]\n",
        "        VGroup(eq1, eq2).to_edge(UP)\n",
        "\n",
        "        self.play(FadeIn(eq1, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        cube_underline = Underline(eq2.get_part_by_tex(\"Solid\"), buff=0.05)\n",
        "        cube_underline.set_stroke(BLUE, 1)\n",
        "        general_words = Text(\"Assume convex\", font_size=36)\n",
        "        general_words.set_color(BLUE)\n",
        "        general_words.next_to(cube_underline, DOWN, buff=1.0)\n",
        "        general_words.shift(LEFT)\n",
        "        general_arrow = Arrow(general_words, cube_underline.get_center(), buff=0.1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(cube_underline),\n",
        "            FadeIn(general_words),\n",
        "            ShowCreation(general_arrow),\n",
        "            FadeTransformPieces(eq1, eq2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        const_rect = SurroundingRectangle(VGroup(\n",
        "            eq.get_part_by_tex(\"frac\"),\n",
        "            eq.get_part_by_tex(\"{c}\")\n",
        "        ), buff=SMALL_BUFF)\n",
        "        const_rect.set_stroke(RED, 1)\n",
        "\n",
        "        const_words = Text(\"Universal constant!\", font_size=36)\n",
        "        const_words.set_color(RED)\n",
        "        const_words.match_y(general_words)\n",
        "        const_words.set_x(const_rect.get_x() + 1)\n",
        "        const_arrow = Arrow(const_words, const_rect, buff=0.1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(const_rect),\n",
        "            FadeIn(const_words),\n",
        "            ShowCreation(const_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShadowsOfDodecahedron(ShadowScene):\n",
        "    inf_light = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.camera.frame.set_height(7)\n",
        "        self.camera.frame.shift(OUT)\n",
        "        dodec = self.solid\n",
        "        dodec.scale(5 / dodec[0].get_arc_length())\n",
        "        outline = self.get_shadow_outline()\n",
        "        area = DecimalNumber(font_size=36)\n",
        "        area.move_to(outline)\n",
        "        area.add_updater(lambda m: m.set_value(get_norm(outline.get_area_vector()) / (self.unit_size**2)))\n",
        "        area.add_updater(lambda m: m.fix_in_frame())\n",
        "        area.move_to(3.15 * DOWN)\n",
        "\n",
        "        self.init_frame_rotation()\n",
        "\n",
        "        ssf = 1.5\n",
        "        self.wait()\n",
        "        self.play(dodec.animate.space_out_submobjects(ssf))\n",
        "        self.play(Rotate(dodec, PI, axis=RIGHT, run_time=6))\n",
        "        self.play(dodec.animate.space_out_submobjects(1 / ssf))\n",
        "        self.begin_ambient_rotation(dodec)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(outline),\n",
        "            VFadeIn(area),\n",
        "        )\n",
        "\n",
        "        # Add dot and line\n",
        "        dot = GlowDot(0.5 * DR)\n",
        "        line = DashedLine(10 * OUT, ORIGIN)\n",
        "        line.set_stroke(YELLOW, 1)\n",
        "\n",
        "        def dodec_sdf(point):\n",
        "            return max(*(\n",
        "                np.dot(point - pent.get_center(), pent.get_unit_normal())\n",
        "                for pent in dodec\n",
        "            ))\n",
        "\n",
        "        def update_line(line):\n",
        "            line.move_to(dot.get_center(), IN)\n",
        "            for dash in line:\n",
        "                dist = dodec_sdf(dash.get_center())\n",
        "                dash.set_stroke(\n",
        "                    opacity=interpolate(0.1, 1.0, clip(10 * dist, -0.5, 0.5) + 0.5)\n",
        "                )\n",
        "                dash.inside = (dist < 0)\n",
        "\n",
        "        line.add_updater(update_line)\n",
        "\n",
        "        self.play(ShowCreation(line, rate_func=rush_into))\n",
        "        self.play(FadeIn(dot, rate_func=rush_from))\n",
        "\n",
        "        # Just wait\n",
        "        for n in range(8):\n",
        "            self.play(dot.animate.move_to(midpoint(\n",
        "                outline.get_center(),\n",
        "                outline.pfp(random.random()),\n",
        "            )), run_time=5)\n",
        "\n",
        "    def get_solid(self):\n",
        "        solid = self.get_solid_no_style()\n",
        "        solid.set_stroke(WHITE, 1)\n",
        "        solid.set_fill(self.solid_fill_color, 0.8)\n",
        "        solid.set_gloss(0.1)\n",
        "        solid.set_shadow(0.4)\n",
        "        solid.set_reflectiveness(0.4)\n",
        "        group = Group(*solid)\n",
        "        group.deactivate_depth_test()\n",
        "        group.add_updater(lambda m: self.sort_to_camera(m))\n",
        "        return group\n",
        "\n",
        "    def get_solid_no_style(self):\n",
        "        dodec = Dodecahedron()\n",
        "        dodec.scale((32 / get_surface_area(dodec))**0.5)\n",
        "        return dodec\n",
        "\n",
        "\n",
        "class AmbientDodecahedronShadow(ShadowsOfDodecahedron):\n",
        "    solid_name = \"Dodecahedron\"\n",
        "    solid_fill_color = BLUE_E\n",
        "    name_color = BLUE_D\n",
        "\n",
        "    def construct(self):\n",
        "        self.camera.frame.reorient(20, 80)\n",
        "        self.camera.frame.set_z(3)\n",
        "\n",
        "        eq = get_key_result(self.solid_name, color=self.name_color)\n",
        "        eq.to_edge(UP)\n",
        "        eq.fix_in_frame()\n",
        "        self.add(eq)\n",
        "\n",
        "        self.init_frame_rotation()\n",
        "        self.play(LaggedStart(*map(Write, self.solid)))\n",
        "        self.add(self.solid)\n",
        "\n",
        "        outline = self.get_shadow_outline()\n",
        "        area_label = self.get_shadow_area_label()\n",
        "        # area_label.scale(0.7)\n",
        "        area_label.move_to(2.75 * DOWN).to_edge(LEFT)\n",
        "        area_label.add_updater(lambda m: m.fix_in_frame())\n",
        "        surface_area = get_surface_area(self.solid)\n",
        "        surface_area /= (self.unit_size**2)\n",
        "        sa_label = VGroup(Text(\"Surface area: \"), DecimalNumber(surface_area))\n",
        "        sa_label.arrange(RIGHT)\n",
        "        sa_label.match_y(area_label)\n",
        "        sa_label.to_edge(RIGHT)\n",
        "        sa_label.set_backstroke()\n",
        "        sa_label.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            *map(VFadeIn, (outline, area_label, sa_label))\n",
        "        )\n",
        "        self.add(outline)\n",
        "        self.add(area_label)\n",
        "\n",
        "        self.begin_ambient_rotation(self.solid, about_point=self.solid.get_center())\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class AmbientTriPrismSum(AmbientDodecahedronShadow):\n",
        "    solid_name = \"Triangular Prism\"\n",
        "    solid_fill_color = interpolate_color(TEAL_E, BLACK, 0.25)\n",
        "    name_color = TEAL_D\n",
        "\n",
        "    def get_solid_no_style(self):\n",
        "        triangle = RegularPolygon(3)\n",
        "        tri1, tri2 = triangle.replicate(2)\n",
        "        tri2.shift(3 * OUT)\n",
        "        sides = []\n",
        "        verts1 = tri1.get_anchors()\n",
        "        verts2 = tri2.get_anchors()\n",
        "        for (a, b), (c, d) in zip(adjacent_pairs(verts1), adjacent_pairs(verts2)):\n",
        "            sides.append(Polygon(a, b, d, c))\n",
        "        result = VGroup(tri1, *sides, tri2)\n",
        "        result.scale((16 / get_surface_area(result))**0.5)\n",
        "        return result\n",
        "\n",
        "\n",
        "class AmbientPyramidSum(AmbientDodecahedronShadow):\n",
        "    solid_name = \"Pyramid\"\n",
        "    solid_fill_color = GREY_BROWN\n",
        "    name_color = interpolate_color(GREY_BROWN, WHITE, 0.5)\n",
        "\n",
        "    def get_solid_no_style(self):\n",
        "        base = Square(side_length=1)\n",
        "        result = VGroup(base)\n",
        "        for v1, v2 in adjacent_pairs(base.get_vertices()):\n",
        "            result.add(Polygon(v1, v2, math.sqrt(3) * OUT / 2))\n",
        "        result.set_height(2)\n",
        "        return result\n",
        "\n",
        "\n",
        "class AmbientCubeWithLabels(AmbientDodecahedronShadow):\n",
        "    solid_name = \"Cube\"\n",
        "\n",
        "    def get_solid_no_style(self):\n",
        "        return VCube()\n",
        "\n",
        "\n",
        "class DodecahedronFaceSum(Scene):\n",
        "    def construct(self):\n",
        "        expr = OldTexText(\n",
        "            \"Area(Shadow(Dodecahedron))\", \"=\",\n",
        "            \"$\\\\displaystyle \\\\frac{1}{2}$\",\n",
        "            \" $\\\\displaystyle \\\\sum_{j=1}^{12}$ \",\n",
        "            \"Area(Shadow(Face$_j$))\",\n",
        "            tex_to_color_map={\n",
        "                \"Shadow\": GREY_B,\n",
        "                \"Dodecahedron\": BLUE_D,\n",
        "                \"Face$_j$\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        expr.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(expr.slice_by_tex(None, \"=\"))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(expr.slice_by_tex(\"=\"), shift=0.25 * UP))\n",
        "        self.wait()\n",
        "        self.play(FlashAround(expr.get_part_by_tex(\"frac\"), run_time=2))\n",
        "        self.play(FlashUnder(expr[-5:], run_time=2))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SphereShadow(ShadowScene):\n",
        "    inf_light = True\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(7)\n",
        "        frame.shift(OUT)\n",
        "        sphere = self.solid\n",
        "        shadow = self.shadow\n",
        "        # shadow[1].always_sort_to_camera(self.camera)\n",
        "        shadow_circle = Circle()\n",
        "        shadow_circle.set_fill(BLACK, 0.8)\n",
        "        shadow_circle.replace(shadow)\n",
        "        shadow_circle.set_stroke(WHITE, 1)\n",
        "        self.add(shadow_circle)\n",
        "\n",
        "        self.begin_ambient_rotation(\n",
        "            sphere, speed=0.3,\n",
        "            initial_axis=[-1, -1, 0.5]\n",
        "        )\n",
        "        self.wait(60)\n",
        "\n",
        "    def get_solid(self):\n",
        "        ep = 1e-3\n",
        "        sphere = Sphere(\n",
        "            radius=1.5,\n",
        "            u_range=(ep, TAU - ep),\n",
        "            v_range=(ep, PI - ep),\n",
        "        )\n",
        "        sphere = TexturedSurface(sphere, \"EarthTextureMap\", \"NightEarthTextureMap\")\n",
        "        sphere.set_opacity(1)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(WHITE, 0.5, 0.25)\n",
        "        return Group(sphere, mesh)\n",
        "\n",
        "\n",
        "class SphereInfo(Scene):\n",
        "    def construct(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{c}\": RED,\n",
        "                \"=\": WHITE,\n",
        "                \"R\": BLUE\n",
        "            },\n",
        "            \"font_size\": 36\n",
        "        }\n",
        "        shadow = OldTex(\"\\\\text{Average shadow area} = \\\\pi R^2\", **kw)\n",
        "        surface = OldTex(\"\\\\text{Surface area} = 4 \\\\pi R^2\", **kw)\n",
        "        conclusion = OldTex(\"\\\\frac{1}{2}\", \"{c}\", \"=\", \"\\\\frac{1}{4}\", **kw)\n",
        "\n",
        "        eqs = VGroup(shadow, surface, conclusion)\n",
        "        eqs.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        for eq in eqs:\n",
        "            eq.shift(eq.get_part_by_tex(\"=\").get_x() * LEFT)\n",
        "        eqs.to_corner(UR)\n",
        "\n",
        "        for eq in eqs[:2]:\n",
        "            eq[0].set_color(GREY_A)\n",
        "\n",
        "        for eq in eqs:\n",
        "            self.play(FadeIn(eq, lag_ratio=0.1))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(eqs[2].animate.scale(2, about_edge=UP))\n",
        "        rect = SurroundingRectangle(eqs[2])\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PiRSquared(Scene):\n",
        "    def construct(self):\n",
        "        form = OldTex(\"\\\\pi R^2\")[0]\n",
        "        form[1].set_color(BLUE)\n",
        "        self.play(Write(form))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SwapConstantForFourth(Scene):\n",
        "    def construct(self):\n",
        "        eq = get_key_result(\"Dodecahedron\")\n",
        "        eq.to_edge(UP)\n",
        "        parts = VGroup(\n",
        "            eq.get_part_by_tex(\"frac\"),\n",
        "            eq.get_part_by_tex(\"{c}\")\n",
        "        )\n",
        "        fourth = OldTex(\"\\\\frac{1}{4}\")\n",
        "        fourth.move_to(parts, LEFT)\n",
        "        fourth.set_color(RED)\n",
        "\n",
        "        self.add(eq)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(parts, UP),\n",
        "            FadeIn(fourth, UP),\n",
        "            eq.slice_by_tex(\"\\\\cdot\").animate.next_to(fourth, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ButSpheresAreSmooth(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"But spheres don't\\\\\\\\have flat faces!\"),\n",
        "            target_mode=\"angry\",\n",
        "            index=2,\n",
        "            added_anims=[self.teacher.change(\"guilty\")]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"hesitant\", \"angry\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class RepeatedRelation(Scene):\n",
        "    def construct(self):\n",
        "        # Relations\n",
        "        relation = VGroup(\n",
        "            Text(\"Average shadow\"),\n",
        "            OldTex(\"=\").rotate(PI / 2),\n",
        "            OldTex(\"\\\\frac{1}{2}\", \"c\", \"\\\\cdot (\", \"\\\\text{Surface area}\", \")\")\n",
        "        )\n",
        "        relation[0].set_color(GREY_A)\n",
        "        relation[2][1].set_color(RED)\n",
        "        relation[2][3].set_color(BLUE)\n",
        "        relation.arrange(DOWN)\n",
        "        relation.scale(0.6)\n",
        "        repeats = relation.get_grid(1, 4, buff=0.8)\n",
        "        repeats.to_edge(LEFT, buff=MED_LARGE_BUFF)\n",
        "        repeats.shift(0.5 * DOWN)\n",
        "\n",
        "        for repeat in repeats:\n",
        "            self.play(FadeIn(repeat[0], lag_ratio=0.1))\n",
        "            self.play(\n",
        "                Write(repeat[1]),\n",
        "                FadeIn(repeat[2], 0.5 * DOWN)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Limit\n",
        "        limit = OldTex(\n",
        "            \"\\\\lim_{|F| \\\\to 0}\",\n",
        "            \"\\\\left(\", \"{\\\\text{Average shadow}\", \"\\\\over \", \"\\\\text{Surface area}}\", \"\\\\right)\",\n",
        "            \"=\", \"\\\\frac{1}{2}\", \"{c}\",\n",
        "        )\n",
        "        limit.set_color_by_tex(\"Average shadow\", GREY_A)\n",
        "        limit.set_color_by_tex(\"Surface area\", BLUE)\n",
        "        limit.set_color_by_tex(\"{c}\", RED)\n",
        "        limit.move_to(2.5 * DOWN)\n",
        "        limit.match_x(repeats)\n",
        "\n",
        "        new_rhs = OldTex(\"=\", \"{\\\\pi R^2\", \"\\\\over\", \"4\\\\pi R^2}\")\n",
        "        new_rhs.set_color_by_tex(\"\\\\pi R^2\", GREY_A)\n",
        "        new_rhs.set_color_by_tex(\"4\\\\pi R^2\", BLUE)\n",
        "        new_rhs.move_to(limit.get_part_by_tex(\"=\"), LEFT)\n",
        "\n",
        "        self.play(Write(limit))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            limit.slice_by_tex(\"=\").animate.next_to(new_rhs, RIGHT),\n",
        "            GrowFromCenter(new_rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleCross(Scene):\n",
        "    def construct(self):\n",
        "        lines = VGroup(\n",
        "            Line(UP, DOWN).set_height(FRAME_HEIGHT),\n",
        "            Line(LEFT, RIGHT).set_width(FRAME_WIDTH),\n",
        "        )\n",
        "        self.play(ShowCreation(lines, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Not needed?\n",
        "class AmbientCubeTurningIntoNewShapes(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class PopularizaitonVsDoing(Scene):\n",
        "    def construct(self):\n",
        "        # Words\n",
        "        popular = Text(\"Popularization of math\")\n",
        "        doing = Text(\"Doing math\")\n",
        "        words = VGroup(popular, doing)\n",
        "        words.arrange(DOWN, buff=3)\n",
        "        words.move_to(UP)\n",
        "\n",
        "        self.play(FadeIn(popular, UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                popular.get_part_by_text(\"math\"),\n",
        "                doing.get_part_by_text(\"math\"),\n",
        "            ),\n",
        "            Write(doing[:len(\"Doing\")])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bars\n",
        "        width = 8\n",
        "        bar = Rectangle(width, 0.5)\n",
        "        bar.set_stroke(WHITE, 1)\n",
        "        bar.next_to(popular, DOWN)\n",
        "        left_bar, right_bar = bar.replicate(2)\n",
        "        left_bar.set_fill(BLUE_E, 1)\n",
        "        right_bar.set_fill(RED_E, 1)\n",
        "        left_bar.stretch(0.5, 0, about_edge=LEFT)\n",
        "        right_bar.stretch(0.5, 0, about_edge=RIGHT)\n",
        "\n",
        "        left_brace = always_redraw(lambda: Brace(left_bar, DOWN, buff=SMALL_BUFF))\n",
        "        right_brace = always_redraw(lambda: Brace(right_bar, DOWN, buff=SMALL_BUFF))\n",
        "        left_label = Text(\"Insights\", font_size=30, color=GREY_B)\n",
        "        right_label = Text(\"Computations\", font_size=30, color=GREY_B)\n",
        "        always(left_label.next_to, left_brace, DOWN, SMALL_BUFF)\n",
        "        always(right_label.next_to, right_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        bar_group = VGroup(\n",
        "            bar,\n",
        "            left_bar, right_bar,\n",
        "            left_brace, right_brace,\n",
        "            left_label, right_label,\n",
        "        )\n",
        "\n",
        "        def set_bar_alpha(alpha, **kwargs):\n",
        "            self.play(\n",
        "                left_bar.animate.set_width(alpha * width, about_edge=LEFT, stretch=True),\n",
        "                right_bar.animate.set_width((1 - alpha) * width, about_edge=RIGHT, stretch=True),\n",
        "                **kwargs\n",
        "            )\n",
        "\n",
        "        self.play(FadeIn(bar_group, lag_ratio=0.1))\n",
        "        set_bar_alpha(0.95, run_time=2)\n",
        "        self.wait()\n",
        "        self.add(bar_group.deepcopy().clear_updaters())\n",
        "        self.play(\n",
        "            bar_group.animate.shift(doing.get_center() - popular.get_center())\n",
        "        )\n",
        "        set_bar_alpha(0.05, run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class MultipleMathematicalBackgrounds(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"$\\\\le$ High school\"),\n",
        "            OldTexText(\"$\\\\approx$ Undergrad\"),\n",
        "            OldTexText(\"$\\\\ge$ Ph.D.\"),\n",
        "        )\n",
        "        for student, label in zip(self.students, labels):\n",
        "            label.scale(0.7)\n",
        "            label.next_to(student, UP)\n",
        "\n",
        "        words = OldTexText(\"Explanation doesn't vary\\\\\\\\with backgrounds\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        lines = VGroup(*(\n",
        "            DashedLine(words, label, buff=0.5)\n",
        "            for label in labels\n",
        "        ))\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\"),\n",
        "            self.change_students(\n",
        "                \"pondering\", \"thinking\", \"pondering\",\n",
        "                look_at=self.teacher.eyes,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, labels, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            self.teacher.change(\"dejected\").look(UP),\n",
        "            self.change_students(\"hesitant\", \"well\", \"thinking\"),\n",
        "            LaggedStartMap(FadeOut, lines, scale=0.5),\n",
        "            FadeOut(words, DOWN),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Different levels\n",
        "        kw = {\"font_size\": 30}\n",
        "        methods = VGroup(\n",
        "            OldTexText(\"Calculus\\\\\\\\primer\", **kw),\n",
        "            OldTexText(\"Quickly show\\\\\\\\key steps\", **kw),\n",
        "            OldTexText(\"Describe as a\\\\\\\\measure on SO(3)\", **kw),\n",
        "        )\n",
        "        new_lines = VGroup()\n",
        "        colors = [GREEN_B, GREEN_C, GREEN_D]\n",
        "        for method, label, color in zip(methods, labels, colors):\n",
        "            method.move_to(label)\n",
        "            method.shift(2.5 * UP)\n",
        "            method.set_color(color)\n",
        "            line = DashedLine(method, label, buff=0.25)\n",
        "            line.set_stroke(color, 2)\n",
        "            new_lines.add(line)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\"),\n",
        "            self.change_students(\n",
        "                \"erm\", \"pondering\", \"thinking\",\n",
        "                look_at=self.students.get_center() + 4 * UP\n",
        "            ),\n",
        "            LaggedStartMap(FadeIn, methods, lag_ratio=0.5),\n",
        "            LaggedStartMap(ShowCreation, new_lines, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class WatchingAVideo(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DL)\n",
        "        screen = ScreenRectangle(height=5)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.to_corner(UR)\n",
        "\n",
        "        def blink_wait(n=1):\n",
        "            for x in range(n):\n",
        "                self.wait()\n",
        "                self.play(Blink(randy))\n",
        "                self.wait()\n",
        "\n",
        "        self.add(screen)\n",
        "        self.add(randy)\n",
        "        self.play(randy.change(\"pondering\", screen))\n",
        "        blink_wait()\n",
        "        self.play(randy.change(\"thinking\", screen))\n",
        "        blink_wait()\n",
        "        self.play(randy.change(\"hesitant\", screen))\n",
        "        blink_wait(2)\n",
        "\n",
        "\n",
        "class CleverProofExample(Scene):\n",
        "    def construct(self):\n",
        "        initial_sum = OldTex(\"1^2 + 2^2 + 3^2 + \\\\cdots + n^2\")\n",
        "        tripple_tris, final_tri = self.get_triangle_sums()\n",
        "\n",
        "        initial_sum.set_width(10)\n",
        "        self.play(FadeIn(initial_sum, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        tripple_tris.set_width(10)\n",
        "        tripple_tris.to_edge(DOWN, buff=2)\n",
        "        tris = tripple_tris[0]\n",
        "        tri = tris[0]\n",
        "        tri.save_state()\n",
        "        tri.set_height(4)\n",
        "        tri.center().to_edge(DOWN, buff=1)\n",
        "        self.play(\n",
        "            initial_sum.animate.set_width(8).to_edge(UP),\n",
        "            FadeIn(tri, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(tri),\n",
        "            FadeIn(tripple_tris[1:])\n",
        "        )\n",
        "        for i in (0, 1):\n",
        "            bt1 = tris[i].copy()\n",
        "            bt1.generate_target()\n",
        "            bt1.target.rotate(120 * DEGREES)\n",
        "            bt1.target.replace(tris[i + 1])\n",
        "            bt1.target.set_opacity(0)\n",
        "            tris[i + 1].save_state()\n",
        "            tris[i + 1].rotate(-120 * DEGREES)\n",
        "            tris[i + 1].replace(tris[i])\n",
        "            tris[i + 1].set_opacity(0)\n",
        "            self.play(\n",
        "                MoveToTarget(bt1, remover=True),\n",
        "                Restore(tris[i + 1])\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        final_tri.set_height(3)\n",
        "        final_tri.move_to(tripple_tris, UP)\n",
        "        initial_sum.generate_target()\n",
        "        eq = OldTex(\"=\").scale(2)\n",
        "        tripple_tris.generate_target()\n",
        "        top_row = VGroup(initial_sum.target, eq, tripple_tris.target)\n",
        "        top_row.arrange(RIGHT, buff=0.5)\n",
        "        top_row.set_width(FRAME_WIDTH - 1)\n",
        "        top_row.center().to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(initial_sum),\n",
        "            FadeIn(eq),\n",
        "            MoveToTarget(tripple_tris),\n",
        "            FadeTransform(tripple_tris.copy(), final_tri)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        final1 = OldTex(\"= \\\\frac{2n + 1}{3} (1 + 2 + 3 + \\\\cdots + n)\")\n",
        "        final2 = OldTex(\"= \\\\frac{2n + 1}{3} \\\\frac{(n + 1)n}{2}\")\n",
        "        final3 = OldTex(\"= \\\\frac{(2n + 1)(n + 1)(n)}{6}\")\n",
        "        final_tri.generate_target()\n",
        "        final_tri.target.set_height(2).to_edge(LEFT)\n",
        "        for final in (final1, final2, final3):\n",
        "            final.next_to(final_tri.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(final_tri),\n",
        "            Write(final1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(final1, UP),\n",
        "            FadeIn(final2, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(final2, UP),\n",
        "            FadeIn(final3, UP),\n",
        "        )\n",
        "        self.play(VGroup(final_tri, final3).animate.set_x(0))\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "    def get_triangle_sums(self):\n",
        "        dl_dots = OldTex(\"\\\\vdots\").rotate(-30 * DEGREES)\n",
        "        dr_dots = OldTex(\"\\\\vdots\").rotate(30 * DEGREES)\n",
        "        blank = Integer(0).set_opacity(0)\n",
        "        n = OldTex(\"n\")\n",
        "        np1 = OldTex(\"(2n + 1)\")\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        tri1 = VGroup(\n",
        "            Integer(1).replicate(1),\n",
        "            Integer(2).replicate(2),\n",
        "            Integer(3).replicate(3),\n",
        "            VGroup(dl_dots, blank.copy(), blank.copy(), dr_dots),\n",
        "            VGroup(n.copy(), n.copy(), dots, n.copy(), n.copy()),\n",
        "        )\n",
        "        tri2 = VGroup(\n",
        "            n.replicate(1),\n",
        "            VGroup(dl_dots, n).copy(),\n",
        "            VGroup(Integer(3), blank, dr_dots).copy(),\n",
        "            VGroup(Integer(2), Integer(3), dots, n).copy(),\n",
        "            VGroup(Integer(1), Integer(2), Integer(3), dots, n).copy(),\n",
        "        )\n",
        "        tri3 = VGroup(\n",
        "            n.replicate(1),\n",
        "            VGroup(n, dr_dots).copy(),\n",
        "            VGroup(dl_dots, blank, Integer(3)).copy(),\n",
        "            VGroup(n, dots, Integer(3), Integer(2)).copy(),\n",
        "            VGroup(n, dots, Integer(3), Integer(2), Integer(1)).copy(),\n",
        "        )\n",
        "\n",
        "        sum_tri = VGroup(\n",
        "            np1.replicate(1),\n",
        "            np1.replicate(2),\n",
        "            np1.replicate(3),\n",
        "            VGroup(dl_dots, *blank.replicate(6), dr_dots).copy(),\n",
        "            VGroup(np1.copy(), np1.copy(), dots.copy(), np1.copy(), np1.copy()),\n",
        "        )\n",
        "\n",
        "        tris = VGroup(tri1, tri2, tri3)\n",
        "        for tri in (*tris, sum_tri):\n",
        "            for row in tri:\n",
        "                row.arrange(RIGHT, buff=0.5)\n",
        "            tri.arrange(DOWN, buff=0.5)\n",
        "        tris.arrange(RIGHT, buff=2.0)\n",
        "        tris.set_width(6)\n",
        "        plusses = VGroup(\n",
        "            OldTex(\"+\").move_to(tris[:2]),\n",
        "            OldTex(\"+\").move_to(tris[1:]),\n",
        "        )\n",
        "        parens = OldTex(\"()\")[0]\n",
        "        parens.stretch(2, 1)\n",
        "        parens.match_height(tris)\n",
        "        parens[0].next_to(tris, LEFT)\n",
        "        parens[1].next_to(tris, RIGHT)\n",
        "\n",
        "        frac = OldTex(\"\\\\frac{1}{3}\")\n",
        "        frac.next_to(parens, LEFT)\n",
        "\n",
        "        lhs = VGroup(tris, frac, parens, plusses)\n",
        "\n",
        "        parens_copy = parens.copy()\n",
        "        sum_tri.match_height(lhs)\n",
        "        sum_tri.move_to(tris, LEFT)\n",
        "        parens_copy[1].next_to(sum_tri, RIGHT)\n",
        "\n",
        "        rhs = VGroup(frac.copy(), sum_tri, parens_copy)\n",
        "        rhs.next_to(lhs, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        # eq = OldTex(\"=\")\n",
        "        # eq.next_to(rhs, LEFT)\n",
        "\n",
        "        return VGroup(lhs, rhs)\n",
        "\n",
        "\n",
        "class BlendOfMindsets(Scene):\n",
        "    def construct(self):\n",
        "        Text(\"Calculate specifics\")\n",
        "        Text(\"Understand generalities\")\n",
        "        Text(\"You need both\")\n",
        "\n",
        "\n",
        "class ListernerEmail(Scene):\n",
        "    def construct(self):\n",
        "        # Letter\n",
        "        rect = Rectangle(4, 7)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(\"#060606\", 1)\n",
        "        lines = Line(LEFT, RIGHT).get_grid(15, 1)\n",
        "        lines.set_width(0.8 * rect.get_width())\n",
        "        lines.arrange(DOWN)\n",
        "        lines.set_height(0.7 * rect.get_height(), stretch=True)\n",
        "        for n in [3, 8, -1]:\n",
        "            lines[n].stretch(0.5, 0, about_edge=LEFT)\n",
        "            if n > 0:\n",
        "                lines[n + 1].set_opacity(0)\n",
        "        lines.move_to(rect)\n",
        "\n",
        "        salutation = Text(\"Hi Prof. Kontorovich,\", font_size=30)\n",
        "        salutation.next_to(lines, UP, aligned_edge=LEFT)\n",
        "        lines.shift(0.2 * DOWN)\n",
        "\n",
        "        letter = VGroup(rect, lines, salutation)\n",
        "\n",
        "        self.add(rect)\n",
        "        self.play(\n",
        "            Write(salutation, run_time=1),\n",
        "            ShowCreation(lines, rate_func=linear, run_time=3, lag_ratio=0.5),\n",
        "        )\n",
        "        self.add(letter)\n",
        "        self.wait()\n",
        "        self.play(letter.animate.to_edge(LEFT))\n",
        "\n",
        "        # Phrases\n",
        "        phrases = VGroup(\n",
        "            Text(\"I\u2019m a PhD student...\"),\n",
        "            Text(\n",
        "                \"...I had noticed my mathematical capabilities\\n\"\n",
        "                \"starting to fade (to which I attributed getting\\n\"\n",
        "                \"older and not being as sharp)...\"\n",
        "            ),\n",
        "            Text(\n",
        "                \"...I realized that the entire problem, for me at least,\\n\"\n",
        "                \"was entirely about my lack of problems and drills.\"\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        phrases.arrange(DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        phrases.set_width(8)\n",
        "        phrases.next_to(letter, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        highlights = VGroup()\n",
        "        for i, w in [(0, 1), (5, 3), (11, 2.5)]:\n",
        "            hrect = Rectangle(w, 0.1)\n",
        "            hrect.set_stroke(width=0)\n",
        "            hrect.set_fill(YELLOW, 0.5)\n",
        "            hrect.move_to(lines[i], LEFT)\n",
        "            highlights.add(hrect)\n",
        "\n",
        "        highlights[0].shift(1.5 * RIGHT)\n",
        "        highlights[2].align_to(lines, RIGHT)\n",
        "\n",
        "        hlines = VGroup()\n",
        "\n",
        "        for highlight, phrase in zip(highlights, phrases):\n",
        "            hlines.add(VGroup(\n",
        "                DashedLine(highlight.get_corner(UR), phrase.get_corner(UL), buff=0.1),\n",
        "                DashedLine(highlight.get_corner(DR), phrase.get_corner(DL), buff=0.1),\n",
        "            ))\n",
        "        hlines.set_stroke(YELLOW, 1)\n",
        "\n",
        "        for i in range(3):\n",
        "            self.play(\n",
        "                FadeIn(highlights[i]),\n",
        "                *map(ShowCreation, hlines[i]),\n",
        "                GrowFromPoint(phrases[i], highlights[i].get_right())\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class FamousMathematicians(Scene):\n",
        "    im_height = 3.5\n",
        "\n",
        "    def construct(self):\n",
        "        # Portraits\n",
        "        images = Group(\n",
        "            ImageMobject(\"Newton\"),\n",
        "            ImageMobject(\"Euler\"),\n",
        "            ImageMobject(\"Gauss\"),\n",
        "            ImageMobject(\"Fourier\"),\n",
        "            ImageMobject(\"Riemann_cropped\"),\n",
        "            ImageMobject(\"Cauchy\"),\n",
        "            ImageMobject(\"Noether\"),\n",
        "            ImageMobject(\"Ramanujan\"),\n",
        "        )\n",
        "        names = VGroup(\n",
        "            Text(\"Isaac Newton\"),\n",
        "            Text(\"Leonhard Euler\"),\n",
        "            Text(\"Carl Friedrich Gauss\"),\n",
        "            Text(\"Joseph Fourier\"),\n",
        "            Text(\"Bernhard Riemann\"),\n",
        "            Text(\"Augustin Cauchy\"),\n",
        "            Text(\"Emmy Noether\"),\n",
        "            Text(\"Srinivasa Ramanujan\"),\n",
        "        )\n",
        "        im_groups = Group()\n",
        "        for im, name in zip(images, names):\n",
        "            im.set_height(self.im_height)\n",
        "            name.scale(0.6)\n",
        "            name.set_color(GREY_A)\n",
        "            name.next_to(im, DOWN)\n",
        "            im_groups.add(Group(im, name))\n",
        "\n",
        "        # im_groups.arrange(RIGHT, aligned_edge=UP, buff=LARGE_BUFF)\n",
        "        im_groups.arrange_in_grid(2, 4, aligned_edge=UP, buff=LARGE_BUFF)\n",
        "        im_groups.set_width(FRAME_WIDTH - 2)\n",
        "        im_groups.to_edge(LEFT)\n",
        "        dots = OldTex(\"\\\\dots\", font_size=72).replicate(2)\n",
        "        dots[0].next_to(images[-5], RIGHT, MED_LARGE_BUFF)\n",
        "        dots[1].next_to(images[-1], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeIn, (*im_groups, dots)), lag_ratio=0.25),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            im_groups[0].animate.set_height(6).center().to_edge(LEFT),\n",
        "            LaggedStart(*(\n",
        "                FadeOut(mob, DR)\n",
        "                for mob in (*im_groups[1:], dots)\n",
        "            ), lag_ratio=0.25),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Papers (do in editor)\n",
        "\n",
        "\n",
        "class InventingMath(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class AmbientHourglass(ShadowScene):\n",
        "    inf_light = True\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.set_z(3)\n",
        "\n",
        "        self.init_frame_rotation()\n",
        "        self.remove(self.solid, self.shadow)\n",
        "\n",
        "        qint_func = bezier([0, 1, -1.25, 1, 0])\n",
        "\n",
        "        def func(u, v):\n",
        "            qf = qint_func(v)\n",
        "            x = qf * math.cos(u)\n",
        "            y = qf * math.sin(u)\n",
        "            x = np.sign(x) * abs(x)**0.5\n",
        "            y = np.sign(y) * abs(y)**0.5\n",
        "            return [x, y, 0.5 - v]\n",
        "\n",
        "        ep = 1e-6\n",
        "        hourglass = ParametricSurface(func, (0, TAU), (0 + ep, 1 - ep))\n",
        "\n",
        "        hourglass.set_depth(2)\n",
        "        hourglass.set_z(3)\n",
        "        hourglass.set_color(BLUE_D)\n",
        "        hourglass.set_opacity(0.5)\n",
        "        hourglass.set_reflectiveness(0.1)\n",
        "        hourglass.set_gloss(0.1)\n",
        "        hourglass.set_shadow(0.5)\n",
        "        hourglass.always_sort_to_camera(self.camera)\n",
        "        mesh = SurfaceMesh(hourglass)\n",
        "        mesh.set_flat_stroke(False)\n",
        "        mesh.set_stroke(BLUE_B, 0.2, 0.5)\n",
        "        mesh_shadow = mesh.copy()\n",
        "        mesh_shadow.deactivate_depth_test()\n",
        "        solid_group = Group(mesh_shadow, hourglass, mesh)\n",
        "\n",
        "        shadow = self.shadow = get_shadow(solid_group)\n",
        "        shadow[1].always_sort_to_camera(self.camera)\n",
        "\n",
        "        self.add(solid_group, shadow)\n",
        "\n",
        "        for x in range(30):\n",
        "            self.random_toss(solid_group)\n",
        "            self.wait()\n",
        "\n",
        "        self.begin_ambient_rotation(\n",
        "            solid_group,\n",
        "            speed=0.5,\n",
        "            initial_axis=[1, 0, 1],\n",
        "        )\n",
        "        self.wait(35)\n",
        "\n",
        "\n",
        "class QuantifyConvexity(Scene):\n",
        "    def construct(self):\n",
        "        # Ask question\n",
        "        nonconvex = Text(\"Non-convex\")\n",
        "        nonconvex.to_edge(UP)\n",
        "        nonconvex.set_color(RED)\n",
        "        question = Text(\"Can we quantify this?\")\n",
        "        question.next_to(nonconvex, DOWN, buff=1.5)\n",
        "        question.to_edge(LEFT)\n",
        "        arrow = Arrow(question, nonconvex.get_corner(DL))\n",
        "\n",
        "        self.play(Write(nonconvex))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(question, 0.5 * DOWN),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Binary choice\n",
        "        double_arrow = OldTex(\"\\\\leftrightarrow\")\n",
        "        double_arrow.move_to(nonconvex)\n",
        "        convex = Text(\"Convex\")\n",
        "        convex.set_color(GREEN)\n",
        "        convex.next_to(double_arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            nonconvex.animate.next_to(double_arrow, LEFT),\n",
        "            Write(double_arrow),\n",
        "            FadeIn(convex, shift=0.25 * RIGHT),\n",
        "            Uncreate(arrow),\n",
        "            FadeOut(question, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Spectrum\n",
        "        interval = UnitInterval(width=7)\n",
        "        interval.add_numbers()\n",
        "        interval.to_corner(UL, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(double_arrow, interval),\n",
        "            convex.animate.scale(0.5).next_to(interval.n2p(1), UP),\n",
        "            nonconvex.animate.scale(0.5).next_to(interval.n2p(0), UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fraction\n",
        "        shadow = get_key_result(\"Solid\").slice_by_tex(None, \"=\")\n",
        "        shadow.add(shadow[0].copy())\n",
        "        shadow.remove(shadow[0])\n",
        "        four_shadow = VGroup(OldTex(\"4 \\\\cdot\"), shadow)\n",
        "        four_shadow.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        sa = Text(\"Surface area\")\n",
        "        frac = VGroup(\n",
        "            four_shadow,\n",
        "            Line().match_width(four_shadow).set_stroke(width=2),\n",
        "            sa\n",
        "        )\n",
        "        frac.arrange(DOWN)\n",
        "        frac.set_width(3)\n",
        "        frac.to_corner(UR)\n",
        "        frac.match_y(interval)\n",
        "\n",
        "        self.play(Write(shadow))\n",
        "        self.play(FadeIn(four_shadow[0]))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(frac[1]))\n",
        "        self.play(FadeIn(sa))\n",
        "        self.wait()\n",
        "\n",
        "        # Dot\n",
        "        dot = GlowDot()\n",
        "        dot.scale(2)\n",
        "        dot.move_to(interval.n2p(1))\n",
        "\n",
        "        self.play(FadeIn(dot, RIGHT))\n",
        "        self.wait()\n",
        "        self.play(dot.animate.move_to(interval.n2p(0.6)), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GoalsOfMath(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = Text(\"The goal of math\\nis to answer questions\")\n",
        "        words.move_to(self.hold_up_spot, DOWN)\n",
        "        words.to_edge(RIGHT, buff=2.0)\n",
        "        aq = words.get_part_by_text(\"answer questions\")\n",
        "        aq.set_color(BLUE)\n",
        "        dni = Text(\n",
        "            \"develop new ideas\",\n",
        "            t2c={\"new ideas\": YELLOW},\n",
        "            t2s={\"new ideas\": ITALIC},\n",
        "        )\n",
        "        dni.move_to(aq, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\", words),\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=words),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.add(aq, self.teacher)\n",
        "        self.play(\n",
        "            aq.animate.shift(0.5 * DOWN).set_opacity(0.2),\n",
        "            Write(dni),\n",
        "            self.teacher.change(\"well\", words),\n",
        "            self.change_students(*3 * [\"thinking\"], look_at=words)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class InfatuationWithGenerality(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"Why are mathematicians\\\\\\\\obsessed with abstractions?\"),\n",
        "            index=0,\n",
        "            added_anims=[\n",
        "                self.students[1].change(\"tease\"),\n",
        "                self.students[2].change(\"pondering\"),\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change(\"well\"),\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class NumberphileFrame(VideoWrapper):\n",
        "    animate_boundary = True\n",
        "    title = \"Bertrand's Paradox (with Numberphile)\"\n",
        "    title_config = {\n",
        "        \"font_size\": 48\n",
        "    }\n",
        "    wait_time = 16\n",
        "\n",
        "\n",
        "class ByLine(Scene):\n",
        "    def construct(self):\n",
        "        lines = VGroup(\n",
        "            OldTexText(\"Artwork by\\\\\\\\\", \"Kurt Bruns\"),\n",
        "            OldTexText(\"Music by\\\\\\\\\", \"Vince Rubinetti\"),\n",
        "            OldTexText(\"Other stuff\\\\\\\\\", \"Grant Sanderson\"),\n",
        "        )\n",
        "        for line in lines:\n",
        "            line[0].set_color(GREY_B)\n",
        "            line[1].scale(1.2, about_edge=UP)\n",
        "\n",
        "        lines.arrange(DOWN, buff=1.5)\n",
        "        self.add(lines)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ThumbnailBackground(ShadowScene):\n",
        "    plane_dims = (32, 20)\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(0)\n",
        "        cube = self.solid\n",
        "        cube.set_shadow(0.5)\n",
        "        light = self.light\n",
        "\n",
        "        light.next_to(cube, OUT, buff=2)\n",
        "        light.shift(2 * LEFT)\n",
        "\n",
        "        light.move_to(50 * OUT)\n",
        "\n",
        "        gc = self.glow.replicate(10)\n",
        "        gc.set_opacity(0.3)\n",
        "        gc.clear_updaters()\n",
        "        gc.arrange(RIGHT).match_width(cube)\n",
        "        gc.move_to(6 * OUT)\n",
        "        self.add(gc)\n",
        "\n",
        "        outline = self.get_shadow_outline()\n",
        "        light_lines = self.get_light_lines(outline)\n",
        "        self.add(outline, light_lines)\n",
        "        self.randomly_reorient(cube)\n",
        "        self.randomly_reorient(cube)\n",
        "        self.wait()\n"
    ]
}