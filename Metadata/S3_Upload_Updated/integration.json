{
    "topic": "The mathematical concept being demonstrated is the integration of a constant function over a given interval. The code creates",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.laplace.exponentials import *\n",
        "\n",
        "\n",
        "def z_to_color(z, sat=0.5, lum=0.5):\n",
        "    angle = math.atan2(z.imag, z.real)\n",
        "    return Color(hsl=(angle / TAU, sat, lum))\n",
        "\n",
        "\n",
        "def get_complex_graph(\n",
        "    s_plane,\n",
        "    func,\n",
        "    min_real=None,\n",
        "    pole_buff=1e-3,\n",
        "    color_by_phase=True,\n",
        "    opacity=0.7,\n",
        "    shading=(0.1, 0.1, 0.1),\n",
        "    resolution=(301, 301),\n",
        "    saturation=0.5,\n",
        "    luminance=0.5,\n",
        "    face_sort_direction=UP,\n",
        "    mesh_resolution=(61, 61),\n",
        "    mesh_stroke_style=dict(\n",
        "        color=WHITE,\n",
        "        width=1,\n",
        "        opacity=0.15\n",
        "    )\n",
        "):\n",
        "    u_range = list(s_plane.x_range[:2])\n",
        "    v_range = list(s_plane.y_range[:2])\n",
        "\n",
        "    if min_real is not None:\n",
        "        u_range[0] = min_real + pole_buff\n",
        "\n",
        "    unit_size = s_plane.x_axis.get_unit_size()\n",
        "    graph = ParametricSurface(\n",
        "        lambda u, v: [\n",
        "            *s_plane.c2p(u, v)[:2],\n",
        "            unit_size * abs(func(complex(u, v)))\n",
        "        ],\n",
        "        u_range=u_range,\n",
        "        v_range=v_range,\n",
        "        resolution=resolution\n",
        "    )\n",
        "    graph.set_shading(*shading)\n",
        "\n",
        "    if color_by_phase:\n",
        "        graph.color_by_uv_function(\n",
        "            lambda u, v: z_to_color(func(complex(u, v)), sat=saturation, lum=luminance)\n",
        "        )\n",
        "\n",
        "    graph.set_opacity(opacity)\n",
        "    graph.sort_faces_back_to_front(face_sort_direction)\n",
        "\n",
        "    # Add mesh\n",
        "    mesh = SurfaceMesh(graph, resolution=mesh_resolution)\n",
        "    mesh.set_stroke(**mesh_stroke_style)\n",
        "\n",
        "    return Group(graph, mesh)\n",
        "\n",
        "\n",
        "class IntegrateConstant(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes and graph\n",
        "        axes = Axes((0, 100), (0, 2, 0.25), width=100, height=3)\n",
        "        axes.add_coordinate_labels(num_decimal_places=2, font_size=20)\n",
        "        axes.to_corner(DL)\n",
        "\n",
        "        graph = axes.get_graph(lambda t: 1)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        graph_label = Tex(R\"f(t) = 1\")\n",
        "        graph_label.next_to(graph, UP)\n",
        "        graph_label.to_edge(RIGHT)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph, graph_label)\n",
        "\n",
        "        # Integral\n",
        "        t_tracker = ValueTracker(0.01)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        v_tracker = ValueTracker(1)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(v_tracker.get_value() * dt))\n",
        "\n",
        "        integral = Tex(R\"\\int^{0.01}_0 1 \\, dt = 0.01\", font_size=72)\n",
        "        integral.to_edge(UP, buff=3.0)\n",
        "        integral[\"1\"].set_color(BLUE)\n",
        "        decimals = integral.make_number_changeable(\"0.01\", replace_all=True)\n",
        "        decimals[0].scale(0.5, about_edge=LEFT)\n",
        "        integral[2].scale(0.5, about_edge=LEFT)\n",
        "        integral[:3].shift(0.5 * RIGHT)\n",
        "        integral.set_scale_stroke_with_zoom(True)\n",
        "        for dec in decimals:\n",
        "            dec.add_updater(lambda m: m.set_value(get_t()))\n",
        "\n",
        "        rect = Rectangle()\n",
        "        rect.set_fill(BLUE, 0.5)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_z_index(-1)\n",
        "        x_unit = axes.x_axis.get_unit_size()\n",
        "        y_unit = axes.y_axis.get_unit_size()\n",
        "        origin = axes.get_origin()\n",
        "        rect.add_updater(\n",
        "            lambda m: m.set_shape(get_t() * x_unit, y_unit).move_to(origin, DL)\n",
        "        )\n",
        "\n",
        "        integral.fix_in_frame()\n",
        "\n",
        "        self.add(rect, integral, t_tracker)\n",
        "\n",
        "        # Grow\n",
        "        v_tracker.set_value(1)\n",
        "        self.play(\n",
        "            v_tracker.animate.set_value(12),\n",
        "            self.frame.animate.reorient(0, 0, 0, (42.64, 14.41, 0.0), 58.35).set_anim_args(time_span=(6, 15)),\n",
        "            run_time=20\n",
        "        )\n",
        "\n",
        "\n",
        "class IntegrateRealExponential(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add integral expression\n",
        "        t2c = {R\"{s}\": YELLOW}\n",
        "        integral = Tex(R\"\\int^\\infty_0 e^{\\minus {s}t} dt\", t2c=t2c)\n",
        "        integral.set_x(1)\n",
        "        integral.to_edge(UP)\n",
        "        integral.save_state()\n",
        "        integral.scale(1.5, about_edge=UP)\n",
        "        self.add(integral)\n",
        "\n",
        "        # Add the graph of e^{-st}\n",
        "        max_x = 15\n",
        "        unit_size = 4\n",
        "        axes = Axes((0, max_x, 0.25), (0, 1, 0.25), unit_size=unit_size)\n",
        "        axes.to_edge(DL, buff=1.0)\n",
        "        axes.add_coordinate_labels(num_decimal_places=2, font_size=20)\n",
        "\n",
        "        def exp_func(t):\n",
        "            return np.exp(-get_s() * t)\n",
        "\n",
        "        s_tracker = ValueTracker(1)\n",
        "        get_s = s_tracker.get_value\n",
        "        graph = axes.get_graph(np.exp)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        axes.bind_graph_to_func(graph, exp_func)\n",
        "\n",
        "        graph_label = Tex(R\"e^{\\minus {s}t}\", t2c=t2c, font_size=72)\n",
        "        graph_label.next_to(axes.y_axis.get_top(), UR).shift(0.5 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes),\n",
        "            TransformFromCopy(integral[R\"e^{\\minus {s}t}\"], graph_label),\n",
        "            ShowCreation(graph, suspend_mobject_updating=True, run_time=3),\n",
        "            Restore(integral),\n",
        "        )\n",
        "\n",
        "        # Add a slider for s\n",
        "        s_slider = Slider(s_tracker, x_range=(0, 5), var_name=\"s\")\n",
        "        s_slider.scale(1.5)\n",
        "        s_slider.to_edge(UP, buff=MED_LARGE_BUFF)\n",
        "        s_slider.align_to(axes.c2p(0, 0), LEFT)\n",
        "\n",
        "        self.play(VFadeIn(s_slider))\n",
        "        for value in [5, 0.25, 1]:\n",
        "            self.play(\n",
        "                s_tracker.animate.set_value(value),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show integral as area\n",
        "        equals = Tex(R\"=\", font_size=72).rotate(90 * DEG)\n",
        "        equals.next_to(integral, DOWN)\n",
        "        area_word = Text(\"Area\", font_size=60)\n",
        "        area_word.next_to(equals, DOWN)\n",
        "\n",
        "        area = axes.get_area_under_graph(graph)\n",
        "\n",
        "        def update_area(area):\n",
        "            area.become(axes.get_area_under_graph(graph))\n",
        "\n",
        "        arrow = Arrow(area_word.get_corner(DL), axes.c2p(0.75, 0.5), thickness=4)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                Animation(graph.copy(), remover=True),\n",
        "                Write(equals),\n",
        "                FadeIn(area_word, DOWN),\n",
        "                GrowArrow(arrow),\n",
        "                UpdateFromFunc(area, update_area),\n",
        "                lag_ratio=0.25\n",
        "            ),\n",
        "            ShowCreation(graph, suspend_mobject_updating=True, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Try altenrate s value\n",
        "        frame = self.frame\n",
        "\n",
        "        area.clear_updaters()\n",
        "        area.add_updater(update_area)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-0.2),\n",
        "            frame.animate.reorient(0, 0, 0, (16.79, 7.82, 0.0), 28.01).set_anim_args(time_span=(2, 5)),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Show area = 1 from s = 1\n",
        "        simple_integral = Tex(R\"\\int^\\infty_0 e^{\\minus t} dt\")\n",
        "        simple_integral.move_to(integral)\n",
        "        simple_exp = Tex(R\"e^{\\minus t}\")\n",
        "        simple_exp.move_to(graph_label)\n",
        "\n",
        "        anti_deriv = Tex(R\"=\\big[\\minus e^{\\minus t} \\big]^\\infty_0\")\n",
        "        simple_rhs = Tex(R\"=0 - (\\minus 1)\")\n",
        "        anti_deriv.next_to(simple_integral, RIGHT)\n",
        "        simple_rhs.next_to(anti_deriv, RIGHT)\n",
        "\n",
        "        equals_one = Tex(R\"= 1\", font_size=60)\n",
        "        equals_one.next_to(area_word)\n",
        "\n",
        "        area_one_label = Tex(R\"1\", font_size=60)\n",
        "        area_one_label.move_to(axes.c2p(0.35, 0.35))\n",
        "        area_one_label.set_z_index(1)\n",
        "\n",
        "        self.remove(integral, graph_label)\n",
        "        self.play(\n",
        "            TransformMatchingTex(integral.copy(), simple_integral),\n",
        "            TransformMatchingTex(graph_label.copy(), simple_exp),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingTex(simple_integral.copy(), anti_deriv, run_time=1.5, path_arc=30 * DEG),\n",
        "        )\n",
        "        rect_kw = dict(buff=0.05, stroke_width=1.5)\n",
        "        self.play(\n",
        "            FadeIn(simple_rhs[:2], time_span=(0, 1)),\n",
        "            VFadeInThenOut(SurroundingRectangle(anti_deriv[R\"\\minus e^{\\minus t}\"], **rect_kw)),\n",
        "            VFadeInThenOut(SurroundingRectangle(anti_deriv[R\"\\infty\"], **rect_kw)),\n",
        "            VFadeInThenOut(SurroundingRectangle(simple_rhs[:2], **rect_kw)),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(simple_rhs[2:], time_span=(0, 1)),\n",
        "            VFadeInThenOut(SurroundingRectangle(anti_deriv[R\"\\minus e^{\\minus t}\"], **rect_kw)),\n",
        "            VFadeInThenOut(SurroundingRectangle(anti_deriv[R\"0\"], **rect_kw)),\n",
        "            VFadeInThenOut(SurroundingRectangle(simple_rhs[2:], **rect_kw)),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(simple_rhs.copy(), equals_one, run_time=1))\n",
        "        self.play(TransformFromCopy(equals_one[\"1\"], area_one_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Comapre to unit square\n",
        "        square = Polygon(\n",
        "            axes.c2p(0, 1),\n",
        "            axes.c2p(1, 1),\n",
        "            axes.c2p(1, 0),\n",
        "            axes.c2p(0, 0),\n",
        "        )\n",
        "        square.set_stroke(WHITE, 3)\n",
        "        square.set_fill(BLUE, 0.0)\n",
        "\n",
        "        area_s_tracker = ValueTracker(get_s())\n",
        "        area_x_max_tracker = ValueTracker(graph.x_range[1])\n",
        "        squishy_area = always_redraw(  # Currently unused\n",
        "            lambda: axes.get_area_under_graph(axes.get_graph(\n",
        "                lambda t: np.exp(-area_s_tracker.get_value() * t),\n",
        "                x_range=(0, area_x_max_tracker.get_value())\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        tail_area = axes.get_area_under_graph(graph, x_range=(1, 6))\n",
        "        tail_area.set_fill(RED_E, 0.75)\n",
        "        corner_area = axes.get_graph(lambda t: np.exp(-get_s() * t), (0, 1))\n",
        "        corner_area.add_line_to(axes.c2p(1, 1))\n",
        "        corner_area.add_line_to(axes.c2p(0, 1))\n",
        "        corner_area.match_style(tail_area)\n",
        "        corner_area.set_z_index(-2)\n",
        "\n",
        "        area_one_label.save_state()\n",
        "\n",
        "        self.play(FadeIn(tail_area))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(square),\n",
        "            FadeIn(corner_area),\n",
        "            area_one_label.animate.move_to(square),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(square),\n",
        "            FadeOut(corner_area),\n",
        "            FadeOut(tail_area),\n",
        "            Restore(area_one_label),\n",
        "            FadeOut(anti_deriv),\n",
        "            FadeOut(simple_rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show squishing the area\n",
        "        stretch_label = VGroup(\n",
        "            TexText(R\"Squish by $\\frac{1}{s}$\", t2c=t2c),\n",
        "            Vector(2 * LEFT, thickness=5, fill_color=YELLOW)\n",
        "        )\n",
        "        stretch_label.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        stretch_label.move_to(axes.c2p(0.5, 0.5))\n",
        "\n",
        "        area_word.set_z_index(1)\n",
        "        area_word.target = area_word.generate_target()\n",
        "        area_word.target.move_to(axes.c2p(0.6, 0.33))\n",
        "\n",
        "        rhs = Tex(R\"= \\frac{1}{s}\", t2c=t2c, font_size=60)\n",
        "        rhs.next_to(area_word.target, RIGHT)\n",
        "\n",
        "        area.set_z_index(-1)\n",
        "        area.add_updater(update_area)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformMatchingTex(simple_integral, integral, run_time=1),\n",
        "            FadeIn(graph_label, 0.5 * DOWN),\n",
        "            FadeOut(simple_exp, 0.5 * DOWN),\n",
        "            FadeOut(equals_one, 0.5 * DOWN),\n",
        "            FadeOut(area_one_label),\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(5).set_anim_args(run_time=8),\n",
        "            FadeIn(stretch_label, 1.5 * LEFT, time_span=(1, 5)),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(stretch_label),\n",
        "                MoveToTarget(area_word),\n",
        "                FadeTransform(stretch_label[0][-3:].copy(), rhs[1:]),\n",
        "                FadeTransform(stretch_label[1].copy(), rhs[0]),\n",
        "                FadeOut(equals),\n",
        "                run_time=2,\n",
        "                lag_ratio=0.1\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Show area value\n",
        "        dec_rhs = Tex(R\"= 1.00\", font_size=60)\n",
        "        dec_rhs.make_number_changeable(\"1.00\").add_updater(lambda m: m.set_value(1 / get_s()))\n",
        "        dec_rhs.always.next_to(rhs, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(dec_rhs),\n",
        "            s_tracker.animate.set_value(0.01).set_anim_args(run_time=12, rate_func=bezier([0, 1, 1, 1])),\n",
        "            self.frame.animate.reorient(0, 0, 0, (15.36, 0, 0.0), 30).set_anim_args(time_span=(6, 11)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(area_word, rhs).animate.next_to(axes.c2p(0, 0), UR, MED_LARGE_BUFF).set_anim_args(time_span=(1, 3)),\n",
        "            s_tracker.animate.set_value(0.75),\n",
        "            VFadeOut(dec_rhs, time_span=(2, 4)),\n",
        "            self.frame.animate.to_default_state(),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Averages over intervals\n",
        "        v_lines = VGroup(\n",
        "            DashedLine(axes.c2p(0, 0), axes.c2p(0, 1.25)),\n",
        "            DashedLine(axes.c2p(1, 0), axes.c2p(1, 1.25)),\n",
        "        )\n",
        "        v_lines.set_stroke(WHITE, 1)\n",
        "\n",
        "        unit_int = Tex(R\"\\int^1_0 e^{\\minus {s}t} dt\", t2c=t2c, font_size=60)\n",
        "        unit_int.move_to(v_lines, UP)\n",
        "\n",
        "        graph_for_unit_area = axes.get_graph(exp_func)\n",
        "        graph_for_unit_area.set_stroke(width=0)\n",
        "        unit_int_area = always_redraw(\n",
        "            lambda: axes.get_area_under_graph(graph_for_unit_area, (0, 1))\n",
        "        )\n",
        "        avg_value = exp_func(np.linspace(0, 1, 1000)).mean()\n",
        "\n",
        "        def slosh_rate_func(t, cycles=3):\n",
        "            return min(smooth(2 * cycles * t), 1) + 0.7 * math.sin(cycles * TAU * t) * (t - 1)**2\n",
        "\n",
        "        self.remove(integral)\n",
        "        area.clear_updaters()\n",
        "        self.play(\n",
        "            *map(FadeOut, [area_word, rhs, graph_label, s_slider]),\n",
        "            *map(ShowCreation, v_lines),\n",
        "            TransformMatchingTex(integral.copy(), unit_int),\n",
        "            FadeOut(area),\n",
        "            FadeIn(unit_int_area, time_span=(0.5, 1), suspend_mobject_updating=True),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                graph_for_unit_area,\n",
        "                axes.get_graph(lambda t: avg_value).set_stroke(width=0),\n",
        "                run_time=3,\n",
        "                rate_func=slosh_rate_func,\n",
        "            ),\n",
        "        )\n",
        "        unit_int_area.suspend_updating()\n",
        "\n",
        "        # Show average\n",
        "        avg_label1 = self.get_avg_label(unit_int_area, 0, 1)\n",
        "        avg_label1.save_state()\n",
        "        avg_label1.space_out_submobjects(0.5)\n",
        "        avg_label1.set_opacity(0)\n",
        "        self.play(Restore(avg_label1))\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize that it's a unit interval\n",
        "        frame = self.frame\n",
        "        unit_line = Line(axes.c2p(0, 0), axes.c2p(1, 0))\n",
        "        unit_line.set_stroke(YELLOW, 5)\n",
        "        brace = Brace(unit_line, DOWN, buff=MED_LARGE_BUFF)\n",
        "        unit_label = brace.get_tex(\"1\", buff=MED_SMALL_BUFF, font_size=72)\n",
        "        unit_group = VGroup(brace, unit_line, unit_label)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(unit_line),\n",
        "            FadeIn(unit_label, 0.25 * DOWN),\n",
        "            frame.animate.set_y(-1.5),\n",
        "            run_time=1.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Area = height\n",
        "        height_line = Line(unit_int_area.get_corner(DL), unit_int_area.get_corner(UL))\n",
        "        height_line.set_stroke(RED, 5)\n",
        "\n",
        "        area_eq_height = TexText(R\"= Area = Width $\\times$ Height\", t2c={\"Area\": BLUE, \"Height\": RED, \"Width\": YELLOW})\n",
        "        area_eq_height.next_to(unit_int, RIGHT)\n",
        "        fade_rect = BackgroundRectangle(area_eq_height, buff=0.25, fill_opacity=1)\n",
        "        fade_rect.stretch(2, 1, about_edge=DOWN)\n",
        "\n",
        "        sample_dots = DotCloud([axes.c2p(a, exp_func(a)) for a in np.linspace(0, 1, 30)])\n",
        "        sample_dots.set_color(WHITE)\n",
        "        sample_dots.set_glow_factor(2)\n",
        "        sample_dots.set_radius(0.15)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            FadeIn(area_eq_height),\n",
        "            ShowCreation(height_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            area_eq_height[R\"Width $\\times$\"].animate.set_opacity(0),\n",
        "            area_eq_height[R\"Height\"].animate.move_to(area_eq_height[\"Width\"], UL),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(unit_int, run_time=2, time_width=1.5))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(sample_dots))\n",
        "        self.play(sample_dots.animate.stretch(0, 1).match_y(axes.c2p(0, avg_value)), rate_func=lambda t: slosh_rate_func(t, 2), run_time=3)\n",
        "        self.play(FadeOut(sample_dots), FadeOut(height_line), FadeOut(area_eq_height))\n",
        "\n",
        "        # Average over next interval\n",
        "        v_lines2 = v_lines.copy()\n",
        "        v_lines2.move_to(axes.c2p(1, 0), DL)\n",
        "        unit_int2 = Tex(R\"\\int^2_1 e^{\\minus {s}t} dt\", t2c=t2c, font_size=60)\n",
        "        unit_int2.move_to(v_lines2, UP)\n",
        "\n",
        "        area2_graph = graph.copy().clear_updaters().set_stroke(width=0)\n",
        "        pile2 = always_redraw(lambda: axes.get_area_under_graph(area2_graph, (1, 2)))\n",
        "        avg_value2 = get_norm(pile2.get_area_vector()) / (axes.x_axis.get_unit_size()**2)\n",
        "        avg_label2 = self.get_avg_label(\n",
        "            pile2.copy().set_height(axes.y_axis.get_unit_size() * avg_value2, stretch=True, about_edge=DOWN),\n",
        "            1, 2\n",
        "        )\n",
        "\n",
        "        self.add(v_lines[0])\n",
        "        self.play(\n",
        "            TransformFromCopy(v_lines, v_lines2, path_arc=-20 * DEG),\n",
        "            TransformMatchingTex(\n",
        "                unit_int.copy(),\n",
        "                unit_int2,\n",
        "                path_arc=-20 * DEG,\n",
        "                run_time=1,\n",
        "                key_map={\"0\": \"1\", \"1\": 2},\n",
        "            ),\n",
        "            FadeIn(pile2, suspend_mobject_updating=True),\n",
        "            unit_group.animate.match_x(pile2),\n",
        "        )\n",
        "        self.play(\n",
        "            area2_graph.animate.stretch(0, 1).match_y(axes.y_axis.n2p(avg_value2)).set_anim_args(\n",
        "                rate_func=slosh_rate_func,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            FadeIn(avg_label2)\n",
        "        )\n",
        "        pile2.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        # Show all integrals\n",
        "        new_groups = VGroup()\n",
        "        piles = VGroup(unit_int_area, pile2)\n",
        "        avg_labels = VGroup(avg_label1, avg_label2)\n",
        "\n",
        "        for n in range(2, 6):\n",
        "            new_v_lines = v_lines.copy()\n",
        "            new_v_lines.move_to(axes.c2p(n, 0), DL)\n",
        "            new_unit_int = Tex(Rf\"\\int^{n + 1}_{n} \" + R\"e^{\\minus {s}t} dt\", t2c=t2c, font_size=60)\n",
        "            if n == 5:\n",
        "                new_unit_int = Tex(R\"\\cdots\", font_size=90)\n",
        "            new_unit_int.match_y(unit_int)\n",
        "            new_unit_int.match_x(new_v_lines)\n",
        "            s = get_s()\n",
        "            avg_y = np.mean([np.exp(-s * t) for t in np.arange(n, n + 1, 1e-3)])\n",
        "            new_pile = pile2.copy().clear_updaters()\n",
        "            new_pile.set_height(avg_y * axes.y_axis.get_unit_size(), stretch=True)\n",
        "            new_pile.move_to(axes.c2p(n, 0), DL)\n",
        "            new_avg_label = self.get_avg_label(new_pile, n, n + 1)\n",
        "\n",
        "            new_group = VGroup(new_v_lines, new_unit_int, new_pile, new_avg_label)\n",
        "            new_groups.add(new_group)\n",
        "            piles.add(new_pile)\n",
        "            avg_labels.add(new_avg_label)\n",
        "\n",
        "        big_brace = Brace(VGroup(unit_int, new_groups[-1][1]), UP, font_size=90, buff=LARGE_BUFF)\n",
        "        integral.set_height(3)\n",
        "        integral.next_to(big_brace, UP, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(0, 0, 0, (5.34, 2.63, 0.0), 13.89),\n",
        "            LaggedStartMap(FadeIn, new_groups, lag_ratio=0.75),\n",
        "            FadeOut(unit_group, time_span=(0, 2)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(big_brace),\n",
        "            FadeIn(integral),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show adding all the heights\n",
        "        height_vects = VGroup(\n",
        "            Arrow(pile.get_bottom(), pile.get_top(), buff=0, thickness=6, fill_color=RED)\n",
        "            for pile in piles\n",
        "        )\n",
        "\n",
        "        equals = Tex(R\"=\", font_size=120)\n",
        "        equals.move_to(integral).shift(RIGHT)\n",
        "\n",
        "        stacked_vects = height_vects.copy()\n",
        "        stacked_vects.arrange(UP, buff=SMALL_BUFF)\n",
        "        stacked_vects.scale(0.9)\n",
        "        stacked_vects.next_to(equals, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, avg_labels, lag_ratio=0.2),\n",
        "            LaggedStartMap(FadeIn, height_vects, lag_ratio=0.2),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(height_vects, stacked_vects, lag_ratio=0.05, run_time=2),\n",
        "            integral.animate.next_to(equals, LEFT, LARGE_BUFF),\n",
        "            Write(equals),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_avg_label(self, pile, start=0, end=1, font_size=30):\n",
        "        word = Text(f\"Average over [{start}, {end}]\", font_size=font_size)\n",
        "        word.move_to(pile)\n",
        "        word.set_max_height(pile.get_height() / 4)\n",
        "        buff = min(SMALL_BUFF, 0.05 * pile.get_height())\n",
        "        arrows = VGroup(\n",
        "            Arrow(word.get_top() + buff * UP, pile.get_top(), buff=0),\n",
        "            Arrow(word.get_bottom() + buff * DOWN, pile.get_bottom(), buff=0),\n",
        "        )\n",
        "        return VGroup(word, arrows)\n",
        "\n",
        "\n",
        "class IntegrateComplexExponential(SPlane):\n",
        "    staggered_path_colors = [MAROON_B, MAROON_C]\n",
        "    t_max = 100  # For dynamic path and vector sum.  Change to 100 for final render\n",
        "    initial_s = 0.2 + 1j\n",
        "    s_label_config = dict(\n",
        "        hide_zero_components_on_complex=False,\n",
        "        include_sign=True,\n",
        "        num_decimal_places=1,\n",
        "    )\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        # Trackers\n",
        "        self.s_tracker = ComplexValueTracker(self.initial_s)\n",
        "        self.t_tracker = ValueTracker(0)\n",
        "        get_s = self.s_tracker.get_value\n",
        "        get_t = self.t_tracker.get_value\n",
        "\n",
        "        def exp_func(t):\n",
        "            return np.exp(-get_s() * t)\n",
        "\n",
        "        self.exp_func = exp_func\n",
        "\n",
        "    def construct(self):\n",
        "        # Trackers\n",
        "        s_tracker = self.s_tracker\n",
        "        t_tracker = self.t_tracker\n",
        "        exp_func = self.exp_func\n",
        "        t2c = self.tex_to_color_map\n",
        "\n",
        "        get_s = self.s_tracker.get_value\n",
        "        get_t = self.t_tracker.get_value\n",
        "\n",
        "        # Add s plane\n",
        "        s_plane, s_dot, s_label, s_plane_label = s_group = self.get_s_group()\n",
        "        self.add(*s_group)\n",
        "\n",
        "        # Add exp plane\n",
        "        exp_plane = self.get_exp_plane()\n",
        "        exp_plane.set_width(6)\n",
        "        exp_plane.next_to(s_plane, RIGHT, buff=1.0)\n",
        "        exp_plane.add_coordinate_labels(font_size=16)\n",
        "        exp_plane.axes.set_stroke(width=1)\n",
        "        exp_plane_label = Tex(R\"e^{\\minus st}\", font_size=72, t2c=t2c)\n",
        "        exp_plane_label.next_to(exp_plane, UP)\n",
        "\n",
        "        output_dot, output_label = self.get_output_dot_and_label(exp_plane, lambda: -get_s(), get_t, label_direction=DR, s_tex=R\"\\minus s\")\n",
        "        output_label.set_z_index(1)\n",
        "        output_label_added_shift = Point(ORIGIN)\n",
        "        output_label.add_updater(lambda m: m.shift(output_label_added_shift.get_center()))\n",
        "\n",
        "        self.add(exp_plane, exp_plane_label, output_dot, output_label)\n",
        "\n",
        "        # Show inital path\n",
        "        path = always_redraw(lambda: self.get_output_path(exp_plane, exp_func, 0, 20))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(path, suspend_mobject_updating=True),\n",
        "            t_tracker.animate.set_value(path.t_range[1]),\n",
        "            rate_func=linear,\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.2 - 1j),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-0.2 + 1j),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=6,\n",
        "        )\n",
        "\n",
        "        path.suspend_updating()\n",
        "\n",
        "        # Fadeable transition to the start\n",
        "        path_ghost = path.copy().set_stroke(opacity=0.4)\n",
        "        self.wait()\n",
        "        t_tracker.set_value(0)\n",
        "        self.remove(path)\n",
        "        self.add(path_ghost)\n",
        "        self.wait()\n",
        "\n",
        "        # Show [0, 1]\n",
        "        subpath_0 = self.get_output_path(exp_plane, exp_func, 0, 1, stroke_color=self.staggered_path_colors[0])\n",
        "        avg_vect0 = self.get_mean_vector(exp_plane, exp_func, 0, 1)\n",
        "        many_points = self.get_sample_dots(subpath_0)\n",
        "        avg_dot0 = TrueDot(avg_vect0.get_end(), color=RED)\n",
        "\n",
        "        int_tex0 = Tex(R\"\\int^1_0 e^{\\minus st} dt\", t2c=t2c, font_size=48)\n",
        "        int_tex0.next_to(exp_plane.n2p(1), UP, MED_SMALL_BUFF)\n",
        "        int_tex0.set_backstroke(BLACK, 5)\n",
        "\n",
        "        self.play(FadeIn(int_tex0, 0.25 * UP))\n",
        "        self.play(\n",
        "            t_tracker.animate.set_value(1),\n",
        "            ShowCreation(subpath_0),\n",
        "            rate_func=linear,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(many_points))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(many_points, avg_dot0))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(avg_vect0),\n",
        "            int_tex0.animate.set_height(0.75).next_to(avg_vect0.get_center(), UR, buff=SMALL_BUFF)\n",
        "        )\n",
        "        self.play(FadeOut(avg_dot0))\n",
        "        self.wait()\n",
        "\n",
        "        # Bring in integral plane\n",
        "        lil_exp_plane = self.get_exp_plane(x_range=(-1, 1))\n",
        "        lil_exp_plane.set_width(3)\n",
        "        lil_exp_plane.move_to(exp_plane, UR).shift(0.5 * UP + 0.75 * LEFT)\n",
        "        lil_exp_plane.save_state()\n",
        "        lil_exp_plane.axes.set_stroke(width=1)\n",
        "\n",
        "        int_plane = self.get_exp_plane()\n",
        "        int_plane.set_width(3)\n",
        "        int_plane.next_to(lil_exp_plane, DOWN, MED_LARGE_BUFF)\n",
        "        int_plane.axes.set_stroke(width=1)\n",
        "        int_plane.add_coordinate_labels(font_size=12)\n",
        "\n",
        "        to_upper = lil_exp_plane.get_center() - exp_plane.get_center()\n",
        "        to_lower = int_plane.get_center() - exp_plane.get_center()\n",
        "\n",
        "        int_plane_label = Tex(R\"\\int^\\infty_0 e^{\\minus st} dt\", t2c=t2c, font_size=48)\n",
        "        int_plane_label.next_to(int_plane, LEFT, aligned_edge=UP)\n",
        "\n",
        "        lower_avg_vect0 = self.get_mean_vector(int_plane, exp_func, 0, 1, thickness=1, fill_color=self.staggered_path_colors[0])\n",
        "\n",
        "        self.play(\n",
        "            exp_plane.animate.move_to(lil_exp_plane.saved_state).set_opacity(0),\n",
        "            FadeIn(lil_exp_plane, to_upper),\n",
        "            VGroup(path_ghost, subpath_0, avg_vect0).animate.shift(to_upper),\n",
        "            int_tex0.animate.scale(0.5, about_point=exp_plane.n2p(0)).shift(to_lower),\n",
        "            TransformFromCopy(avg_vect0, lower_avg_vect0),\n",
        "            FadeIn(int_plane),\n",
        "            exp_plane_label.animate.next_to(lil_exp_plane, LEFT, aligned_edge=UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add the next few arrows\n",
        "        avg_vects = VGroup(avg_vect0)\n",
        "        lower_avg_vects = VGroup(lower_avg_vect0)\n",
        "        subpaths = VGroup(subpath_0)\n",
        "        int_texs = VGroup(int_tex0)\n",
        "        shifts = [\n",
        "            0.8 * LEFT + 0.1 * DOWN,\n",
        "            LEFT,\n",
        "            0.2 * LEFT + 0.4 * UP,\n",
        "            0.4 * UP,\n",
        "        ]\n",
        "\n",
        "        def get_subpath(n):\n",
        "            result = self.get_output_path(exp_plane, exp_func, n, n + 1, stroke_width=3)\n",
        "            result.set_stroke(self.staggered_path_colors[n % 2])\n",
        "            return result\n",
        "\n",
        "        for n in range(1, 5):\n",
        "            subpath_n = get_subpath(n)\n",
        "            sample_points = self.get_sample_dots(subpath_n)\n",
        "            avg_vect, lower_avg_vect = [\n",
        "                self.get_mean_vector(plane, exp_func, n, n + 1, thickness=thickness)\n",
        "                for plane, thickness in [(exp_plane, 3), (int_plane, 1)]\n",
        "            ]\n",
        "            lower_avg_vect.set_fill(self.staggered_path_colors[n % 2], border_width=0.5)\n",
        "            lower_avg_vect.set_stroke(width=0)\n",
        "            lower_avg_vect.put_start_on(lower_avg_vects[-1].get_end())\n",
        "            avg_dot = sample_points.copy().set_points([avg_vect.get_end()])\n",
        "\n",
        "            int_tex = Tex(Rf\"\\int_{n}^{n + 1} e^{{\\minus s t}} dt\", t2c=t2c)\n",
        "            int_tex.match_height(int_tex0)\n",
        "            int_tex.scale(1.0 - 0.15 * n)\n",
        "            int_tex.next_to(lower_avg_vect.get_center(), rotate_vector(lower_avg_vect.get_vector(), 90 * DEG), buff=SMALL_BUFF)\n",
        "\n",
        "            self.play(\n",
        "                t_tracker.animate.set_value(n + 1),\n",
        "                ShowCreation(subpath_n),\n",
        "                output_label_added_shift.animate.move_to(shifts[n - 1]),\n",
        "                ShowCreation(sample_points),\n",
        "                run_time=2,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            self.play(\n",
        "                avg_vects[-1].animate.set_fill(opacity=0.5).set_stroke(width=0),\n",
        "                GrowArrow(avg_vect),\n",
        "                Transform(sample_points, avg_dot),\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(sample_points),\n",
        "                TransformFromCopy(avg_vect, lower_avg_vect),\n",
        "                FadeIn(int_tex),\n",
        "            )\n",
        "\n",
        "            avg_vects.add(avg_vect)\n",
        "            lower_avg_vects.add(lower_avg_vect)\n",
        "            subpaths.add(subpath_n)\n",
        "            int_texs.add(int_tex)\n",
        "\n",
        "        # Show numerous more\n",
        "        for n in range(5, 20):\n",
        "            subpath = get_subpath(n)\n",
        "            avg_vect = self.get_mean_vector(exp_plane, exp_func, n, n + 1, thickness=3)\n",
        "            lower_avg_vect = self.get_mean_vector(int_plane, exp_func, n, n + 1, thickness=1)\n",
        "            lower_avg_vect.set_fill(self.staggered_path_colors[n % 2], border_width=0.5)\n",
        "            lower_avg_vect.set_stroke(width=0)\n",
        "            lower_avg_vect.put_start_on(lower_avg_vects[-1].get_end())\n",
        "\n",
        "            anims = [\n",
        "                ShowCreation(subpath, rate_func=linear),\n",
        "                t_tracker.animate.set_value(n + 1).set_anim_args(rate_func=linear),\n",
        "                FadeIn(avg_vect),\n",
        "            ]\n",
        "            if n == 5:\n",
        "                anims.append(avg_vects.animate.set_opacity(0.25).set_stroke(width=0))\n",
        "            else:\n",
        "                anims.append(avg_vects[-1].animate.set_opacity(0.25).set_stroke(width=0))\n",
        "                anims.append(TransformFromCopy(avg_vects[-1], lower_avg_vects[-1]))\n",
        "            self.play(*anims)\n",
        "\n",
        "            avg_vects.add(avg_vect)\n",
        "            lower_avg_vects.add(lower_avg_vect)\n",
        "            subpaths.add(subpath)\n",
        "\n",
        "            self.add(avg_vects, subpaths, *lower_avg_vects[:-1])\n",
        "\n",
        "        # Show the full integral\n",
        "        int_dot = Group(TrueDot(radius=0.025), GlowDot())\n",
        "        int_dot.set_color(MAROON_B)\n",
        "        int_dot.move_to(int_plane.n2p(1 / get_s()))\n",
        "        int_rect = SurroundingRectangle(int_plane_label)\n",
        "        int_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeTransform(int_tex, int_plane_label)\n",
        "                for int_tex in int_texs),\n",
        "                lag_ratio=0.025,\n",
        "                group_type=Group,\n",
        "            ),\n",
        "            *map(FadeOut, [output_label, output_dot, avg_vects]),\n",
        "        )\n",
        "        self.play(ShowCreation(int_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            int_rect.animate.surround(int_dot[0], buff=0),\n",
        "            FadeIn(int_dot),\n",
        "        )\n",
        "        self.play(FadeOut(int_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Make the diagram dynamic\n",
        "        staggered_path = self.get_dynamic_output_path(exp_plane, exp_func)\n",
        "        int_pieces = self.get_dynamic_vector_sum(int_plane, exp_func)\n",
        "        int_dot.add_updater(lambda m: m.move_to(int_plane.n2p(1.0 / get_s())))\n",
        "\n",
        "        dynamic_pieces = Group(staggered_path, int_pieces)\n",
        "\n",
        "        self.play(FlashAround(Group(s_label, s_dot), time_width=1.5, run_time=2))\n",
        "        self.remove(path_ghost, subpaths, lower_avg_vects)\n",
        "        self.add(staggered_path, int_pieces, int_dot)\n",
        "\n",
        "        # Move around the path\n",
        "        s_rect = int_rect.copy()\n",
        "\n",
        "        self.play(s_tracker.animate.set_value(0.2 - 1j), run_time=6)\n",
        "        self.wait()\n",
        "        self.play(s_tracker.animate.set_value(1), run_time=4)\n",
        "        s_rect.surround(Group(s_label))\n",
        "        self.play(ShowCreation(s_rect))\n",
        "        self.play(s_rect.animate.surround(int_dot[0], buff=0))\n",
        "        self.play(FadeOut(s_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Approach zero, then go vertical\n",
        "        frame = self.frame\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.1).set_anim_args(rate_func=bezier([0, 1, 1, 1])),\n",
        "            frame.animate.reorient(0, 0, 0, (2.75, 0, 0.0), 11).set_anim_args(time_span=(2, 8)),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.1 + 2j),\n",
        "            frame.animate.to_default_state(),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(0.1 - 2j), run_time=5)\n",
        "        self.wait()\n",
        "        self.play(s_tracker.animate.set_value(0.2 + 1j), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize output\n",
        "        int_vect = self.get_vector(int_plane, 1 / get_s(), thickness=2, fill_color=WHITE)\n",
        "        int_vect.set_stroke(width=0).set_fill(border_width=0.5)\n",
        "        rect = SurroundingRectangle(int_plane_label)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        int_vect_outline = int_vect.copy().set_fill(opacity=0).set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(int_dot[0], buff=0),\n",
        "            int_pieces.animate.set_fill(opacity=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(int_vect),\n",
        "            FadeOut(rect),\n",
        "            FadeOut(int_dot),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Plot it\n",
        "        frame = self.frame\n",
        "        s_plane_group = Group(s_plane, s_dot, s_label, s_plane_label)\n",
        "        s_label.set_flat_stroke(True)\n",
        "        s_plane.set_flat_stroke(False)\n",
        "        s_plane_group.save_state()\n",
        "        s_plane_group.center()\n",
        "        self.remove(s_plane_group)\n",
        "\n",
        "        for mob in self.get_mobjects():\n",
        "            mob.fix_in_frame()\n",
        "            mob.set_z_index(2)\n",
        "\n",
        "        right_rect = FullScreenRectangle()\n",
        "        right_rect.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "        right_rect.set_width(lil_exp_plane.get_width() + 2, about_edge=RIGHT, stretch=True)\n",
        "        v_line = DashedLine(right_rect.get_corner(DL), right_rect.get_corner(UL))\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "        right_pannel = VGroup(right_rect, v_line)\n",
        "        right_pannel.fix_in_frame()\n",
        "        right_pannel.set_z_index(1)\n",
        "        self.add(right_pannel)\n",
        "\n",
        "        def get_output_magnitude(s):\n",
        "            return abs(1.0 / s)\n",
        "\n",
        "        z_line = Line(ORIGIN, OUT)\n",
        "        z_line.set_stroke(WHITE, 2)\n",
        "\n",
        "        unit_size = s_plane.x_axis.get_unit_size()\n",
        "        z_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            s_plane.n2p(get_s()),\n",
        "            s_plane.n2p(get_s()) + unit_size * get_output_magnitude(get_s()) * OUT,\n",
        "        ))\n",
        "\n",
        "        out_dot = Group(TrueDot(), GlowDot())\n",
        "        out_dot.set_color(TEAL)\n",
        "        out_dot.f_always.move_to(z_line.get_end)\n",
        "\n",
        "        traced_graph = TracedPath(z_line.get_end, stroke_color=TEAL)\n",
        "        traced_graph.update()\n",
        "\n",
        "        int_vect.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                int_plane.n2p(0),\n",
        "                int_plane.n2p(1.0 / get_s()),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        pre_z_line = Line(int_vect.get_start(), int_vect.get_end())\n",
        "        pre_z_line.set_stroke(WHITE, 5)\n",
        "        pre_z_line.set_z_index(2)\n",
        "\n",
        "        new_exp_plane_label = exp_plane_label.copy().scale(0.5).next_to(lil_exp_plane, RIGHT, aligned_edge=UP)\n",
        "        new_int_plane_label = int_plane_label.copy().scale(0.5).next_to(int_plane, RIGHT, SMALL_BUFF, aligned_edge=UP)\n",
        "\n",
        "        s_plane_group.restore()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-3, 68, 0, (1.43, 0.51, -0.28), 6.50),\n",
        "            s_plane_group.animate.center(),\n",
        "            ReplacementTransform(pre_z_line, z_line),\n",
        "            FadeOut(exp_plane_label, time_span=(1, 2)),\n",
        "            FadeIn(new_exp_plane_label, time_span=(1, 2)),\n",
        "            FadeOut(int_plane_label, time_span=(1, 2)),\n",
        "            FadeIn(new_int_plane_label, time_span=(1, 2)),\n",
        "            VFadeIn(v_line, time_span=(2, 3)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(out_dot, time_span=(0, 1)),\n",
        "            frame.animate.reorient(8, 64, 0, (1.43, 0.51, -0.28), 6.50),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        self.add(traced_graph)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.2 - 2j),\n",
        "            frame.animate.reorient(25, 87, 0, (3.18, 1.73, 2.63), 11.08).set_anim_args(time_span=(1, 7.5)),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(0.4 - 2j))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.4 + 2j),\n",
        "            frame.animate.reorient(44, 81, 0, (3.16, 1.71, 2.63), 11.08),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(0.6 + 2j))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.6 - 2j),\n",
        "            frame.animate.reorient(66, 89, 0, (3.31, 2.07, 2.96), 9.69),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(0.8 - 2j))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.8 + 2j),\n",
        "            frame.animate.reorient(22, 84, 0, (2.56, 1.53, 1.72), 10.14),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(1.0 + 2j))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.0 - 2j),\n",
        "            frame.animate.reorient(22, 84, 0, (2.56, 1.53, 1.72), 10.14),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        traced_graph.suspend_updating()\n",
        "\n",
        "        # Add the graph\n",
        "        graph = get_complex_graph(s_plane, lambda s: 1.0 / s, min_real=0)[0]\n",
        "        graph.set_shading(0.1, 0.1, 0)\n",
        "        graph.save_state()\n",
        "        graph.set_color(GREY_B)\n",
        "        mesh = SurfaceMesh(graph, resolution=(11, 21))\n",
        "        mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "        for line in mesh:\n",
        "            if line.get_z(IN) < 0:\n",
        "                mesh.remove(line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            ShowCreation(mesh, lag_ratio=1e-2, time_span=(1, 4)),\n",
        "            VFadeOut(traced_graph),\n",
        "            frame.animate.reorient(34, 74, 0, (2.02, 1.44, 1.88), 9.87),\n",
        "            out_dot.animate.set_color(WHITE),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.1 - 0.1j),\n",
        "            frame.animate.reorient(38, 82, 0, (2.84, 2.62, 4.72), 14.21).set_anim_args(time_span=(0, 6)),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(s_tracker.animate.set_value(0.5 - 0.1j), run_time=5)\n",
        "        self.play(frame.animate.reorient(26, 72, 0, (2.33, 1.59, 1.91), 10.76), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.5 - 1j),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Explain color\n",
        "        hue_circle = Circle(radius=1.5 * int_plane.x_axis.get_unit_size())\n",
        "        hue_circle.set_color_by_proportion(lambda h: Color(hsl=(h, 0.5, 0.5)))\n",
        "        hue_circle.set_stroke(width=5)\n",
        "        hue_circle.move_to(int_plane)\n",
        "        hue_circle.fix_in_frame().set_z_index(2)\n",
        "\n",
        "        brace = LineBrace(int_vect, direction=UP, buff=0)\n",
        "        brace.set_fill(border_width=1)\n",
        "        brace.set_z_index(2).fix_in_frame()\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(brace))\n",
        "\n",
        "        self.play(ShowCreation(hue_circle, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(graph, time_span=(0, 1)),\n",
        "            frame.animate.reorient(29, 72, 0, (1.79, 1.9, 1.65), 11.21),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(0.5 + 1j), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        # Show negative real part\n",
        "        left_plane = Rectangle()\n",
        "        left_plane.set_stroke(width=0).set_fill(RED, 0.5)\n",
        "        left_plane.replace(s_plane, stretch=True)\n",
        "        left_plane.stretch(0.5, 0, about_edge=LEFT)\n",
        "        left_plane.save_state()\n",
        "        left_plane.stretch(0, 0, about_edge=RIGHT)\n",
        "\n",
        "        staggered_path.set_clip_plane(RIGHT, -v_line.get_x())\n",
        "        int_pieces.set_clip_plane(RIGHT, -v_line.get_x())\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-38, 70, 5, (3.17, 1.96, -0.36), 9.16),\n",
        "            FadeOut(hue_circle),\n",
        "            Restore(left_plane, time_span=(3, 5)),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move to negative real\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-0.5),\n",
        "            VFadeOut(z_line, time_span=(0, 1.5)),\n",
        "            FadeOut(out_dot, time_span=(0, 1.5)),\n",
        "            VFadeOut(int_vect, time_span=(0, 1.0)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(-0.1 - 1j).set_anim_args(run_time=3))\n",
        "        self.play(\n",
        "            *(\n",
        "                plane.animate.scale(0.1, about_point=plane.n2p(0))\n",
        "                for plane in [exp_plane, lil_exp_plane, int_plane]\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(staggered_path, suspend_mobject_updating=True),\n",
        "            ShowIncreasingSubsets(int_pieces, suspend_mobject_updating=True),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                s_tracker,\n",
        "                lambda m, a: m.set_value(complex(\n",
        "                    -0.1 - math.sin(PI * a),\n",
        "                    interpolate(-1, 1, a)\n",
        "                ))\n",
        "            ),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            *(\n",
        "                plane.animate.scale(10, about_point=plane.n2p(0)).set_anim_args(time_span=(2, 4))\n",
        "                for plane in [exp_plane, lil_exp_plane, int_plane]\n",
        "            ),\n",
        "            s_tracker.animate.set_value(1j),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(FadeIn(z_line), FadeIn(out_dot))\n",
        "        self.wait()\n",
        "\n",
        "        # Show imaginary input\n",
        "        self.remove(staggered_path, int_pieces)\n",
        "        int_pieces.set_fill(opacity=1)\n",
        "        t_tracker.set_value(0)\n",
        "        output_dot.fix_in_frame().set_z_index(2)\n",
        "        output_label.add_updater(lambda m: m.fix_in_frame().set_z_index(2))\n",
        "        self.play(\n",
        "            FadeIn(output_dot),\n",
        "            VFadeIn(output_label),\n",
        "            left_plane.animate.set_fill(opacity=0.2),\n",
        "        )\n",
        "        max_n = 25\n",
        "        self.play(\n",
        "            ShowCreation(staggered_path[:max_n].set_z_index(2)),\n",
        "            ShowIncreasingSubsets(int_pieces[:max_n].set_z_index(2), int_func=np.floor),\n",
        "            t_tracker.animate.set_value(max_n).set_anim_args(time_span=(max_n / (max_n + 1), max_n)),\n",
        "            rate_func=linear,\n",
        "            run_time=max_n\n",
        "        )\n",
        "        self.play(\n",
        "            VFadeOut(output_label),\n",
        "            FadeOut(output_dot),\n",
        "            t_tracker.animate.set_value(max_n + 1).set_anim_args(rate_func=linear),\n",
        "            ShowIncreasingSubsets(int_pieces[max_n:].set_z_index(2)),\n",
        "            FadeIn(staggered_path[max_n:].set_z_index(2))\n",
        "        )\n",
        "\n",
        "        # Show the limiting value\n",
        "        self.add(staggered_path, int_pieces)\n",
        "        self.add(int_vect)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.1 + 1j),\n",
        "            int_pieces.animate.set_fill(opacity=0.75),\n",
        "            VFadeIn(int_vect),\n",
        "            FadeOut(left_plane),\n",
        "            run_time=2\n",
        "        )\n",
        "        rect = SurroundingRectangle(int_vect).set_z_index(2)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1j),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move along imaginary line\n",
        "        boundary = TracedPath(z_line.get_end, stroke_color=RED, stroke_width=3)\n",
        "\n",
        "        self.add(boundary, out_dot)\n",
        "        self.play(s_tracker.animate.set_value(2j), run_time=3)\n",
        "        self.play(s_tracker.animate.set_value(0.1j), run_time=3)\n",
        "        self.play(s_tracker.animate.set_value(1j), run_time=3)\n",
        "        boundary.clear_updaters()\n",
        "        self.play(FadeOut(boundary))\n",
        "\n",
        "        # Show this as 1 / s\n",
        "        int_equation = Tex(R\"\\int^\\infty_0 e^{\\minus st} dt = \\frac{1}{s}\", t2c=t2c)\n",
        "        int_equation.to_edge(UP).shift(LEFT)\n",
        "        int_equation.fix_in_frame()\n",
        "        lhs_mover = new_int_plane_label.copy()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 85, 1, (5.32, 3.46, 3.69), 13.49),\n",
        "            s_tracker.animate.set_value(0.2 + 1j),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            lhs_mover.animate.replace(int_equation[:-4]),\n",
        "            Write(int_equation[-4:], time_span=(0.75, 1.75)),\n",
        "        )\n",
        "        self.remove(lhs_mover)\n",
        "        self.add(int_equation)\n",
        "        self.wait()\n",
        "\n",
        "        # Look closely at s = i again\n",
        "        int_plane_rect = SurroundingRectangle(int_plane)\n",
        "        int_plane_rect.fix_in_frame()\n",
        "        int_plane_rect.set_stroke(YELLOW, 5).insert_n_curves(100)\n",
        "        int_plane_rect.set_z_index(3)\n",
        "        int_plane_rect.scale(0.5, about_edge=DOWN).scale(1.1)\n",
        "\n",
        "        i_eq = Tex(R\"\\frac{1}{i} = -i\")\n",
        "        i_eq.next_to(int_equation[-3:], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        i_eq.fix_in_frame()\n",
        "\n",
        "        left_arrow = Vector(LEFT).set_color(YELLOW)\n",
        "        left_arrow.next_to(s_plane.n2p(0.4 + 1j), DOWN)\n",
        "\n",
        "        self.play(s_tracker.animate.set_value(0.2 - 1j), run_time=6)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.5 + 1j),\n",
        "            frame.animate.reorient(-49, 79, 0, (6.24, 2.45, -0.13), 10.06),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(left_arrow, time_span=(0, 1)),\n",
        "            VShowPassingFlash(int_plane_rect, time_width=1.5, time_span=(4, 7)),\n",
        "            Write(i_eq, time_span=(10, 12)),\n",
        "            s_tracker.animate.set_value(1j),\n",
        "            run_time=15\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 85, 1, (5.32, 3.46, 3.69), 13.49),\n",
        "            FadeOut(i_eq),\n",
        "            FadeOut(left_arrow),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Ambient s movement\n",
        "        for z in [0.2 - 1j, 1 - 1j, 1 + 1j, 0.2 + 1j]:\n",
        "            self.play(s_tracker.animate.set_value(z), run_time=6)\n",
        "\n",
        "        # Talk again about the left plane\n",
        "        full_plane = Rectangle().set_stroke(width=0).set_fill(RED, 0.5)\n",
        "        full_plane.replace(s_plane, stretch=True)\n",
        "        full_plane.set_fill(GREEN, 0.5)\n",
        "\n",
        "        left_plane = full_plane.copy()\n",
        "        left_plane.set_fill(RED, 0.5)\n",
        "        left_plane.stretch(0.5, 0, about_edge=LEFT)\n",
        "        left_plane.save_state()\n",
        "        left_plane.stretch(0, 0, about_edge=RIGHT)\n",
        "\n",
        "        equation_rect = SurroundingRectangle(int_equation)\n",
        "        equation_rect.set_stroke(YELLOW, 2)\n",
        "        equation_rect.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            Restore(left_plane),\n",
        "            frame.animate.reorient(-36, 79, 4, (7.71, 2.4, 1.86), 15.36),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(equation_rect))\n",
        "        self.wait()\n",
        "        self.play(equation_rect.animate.surround(int_equation[R\"\\frac{1}{s}\"], buff=SMALL_BUFF))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(left_plane, full_plane)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Describe continuation\n",
        "        lhs_rect = SurroundingRectangle(int_equation[:-4])\n",
        "        rhs_rect = SurroundingRectangle(int_equation[-3:])\n",
        "        VGroup(lhs_rect, rhs_rect).fix_in_frame().set_stroke(YELLOW, 2)\n",
        "\n",
        "        def pole_func(s):\n",
        "            if s != 0:\n",
        "                return 1.0 / s\n",
        "            return 100\n",
        "\n",
        "        extended_graph = get_complex_graph(s_plane, pole_func)\n",
        "        extended_mesh = SurfaceMesh(extended_graph, resolution=(21, 21))\n",
        "        extended_mesh.remove(*(line for line in extended_mesh if line.get_z(IN) < 0))\n",
        "        extended_mesh.set_stroke(WHITE, 0.5, 0.15)\n",
        "        extended_mesh.shift(1e-2 * OUT)\n",
        "\n",
        "        self.add(extended_graph, graph, extended_mesh, mesh)\n",
        "        self.play(\n",
        "            FadeOut(graph, 1e-2 * IN),\n",
        "            FadeIn(extended_graph),\n",
        "            FadeOut(mesh),\n",
        "            FadeIn(extended_mesh),\n",
        "            frame.animate.reorient(0, 85, 0, (5.32, 3.46, 3.69), 13.49).set_anim_args(run_time=5),\n",
        "            FadeOut(full_plane),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-17, 62, 9, (6.29, -0.4, 3.75), 13.87),\n",
        "            FadeOut(equation_rect),\n",
        "            run_time=5\n",
        "        )\n",
        "        curr_s = complex(get_s())\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(s_tracker, lambda m, a: m.set_value(curr_s * np.exp(a * TAU * 1j))),\n",
        "            run_time=30,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Discuss pole (Mostly with overlays)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-36, 83, 1, (5.84, -1.06, 3.19), 10.63),\n",
        "            s_tracker.animate.set_value(0.1 + 0.1j),\n",
        "            run_time=20\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (1.95, 0.95, -0.0), 15.34),\n",
        "            s_tracker.animate.set_value(1e-3).set_anim_args(time_span=(0, 5)),\n",
        "            extended_mesh.animate.set_stroke(opacity=0),\n",
        "            VFadeOut(int_vect, time_span=(0, 7)),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(frame.animate.reorient(0, 83, 0, (5.18, 4.04, 3.15), 14.50), run_time=10)\n",
        "\n",
        "    def get_s_group(self):\n",
        "        s_plane = self.get_s_plane()\n",
        "        s_plane.set_width(6)\n",
        "        s_plane.to_corner(DL)\n",
        "        s_plane.axes.set_stroke(width=1)\n",
        "\n",
        "        s_dot, s_label = self.get_s_dot_and_label(s_plane, get_s=self.s_tracker.get_value)\n",
        "        s_plane_label = Tex(R\"s\", t2c=self.tex_to_color_map, font_size=72)\n",
        "        s_plane_label.next_to(s_plane, UP)\n",
        "\n",
        "        s_group = Group(s_plane, s_dot, s_label, s_plane_label)\n",
        "        return s_group\n",
        "\n",
        "    def get_output_path(self, plane, func, t_min=0, t_max=20, stroke_color=TEAL, stroke_width=2, step_size=1e-1):\n",
        "        return ParametricCurve(\n",
        "            lambda t: plane.n2p(func(t)),\n",
        "            t_range=[t_min, t_max, step_size],\n",
        "            stroke_color=stroke_color,\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "\n",
        "    def get_vector(self, plane, value, backstroke_width=2, **kwargs):\n",
        "        vect = Arrow(plane.n2p(0), plane.n2p(value), buff=0, **kwargs)\n",
        "        vect.set_backstroke(BLACK, width=backstroke_width)\n",
        "        return vect\n",
        "\n",
        "    def get_mean_vector(self, plane, func, t_min, t_max, thickness=3, fill_color=RED, n_samples=1000, **kwargs):\n",
        "        x_range = np.linspace(t_min, t_max, n_samples)\n",
        "        x_mean = np.mean(func(x_range))\n",
        "        return self.get_vector(plane, x_mean, thickness=thickness, fill_color=fill_color, **kwargs)\n",
        "        return vect\n",
        "\n",
        "    def get_sample_dots(self, subpath, n_samples=20, radius=0.05, glow_factor=0.5, color=RED):\n",
        "        return DotCloud(\n",
        "            [subpath.pfp(a) for a in np.linspace(0, 1, n_samples)],\n",
        "            radius=radius,\n",
        "            glow_factor=glow_factor,\n",
        "            color=color\n",
        "        )\n",
        "\n",
        "    def get_dynamic_output_path(self, plane, func, stroke_width=3, step_size=1e-2):\n",
        "        t_range = list(range(0, self.t_max))\n",
        "        t_samples = [np.arange(t, t + 1 + step_size, step_size) for t in t_range]\n",
        "        path = VGroup(VMobject() for t in t_range)\n",
        "\n",
        "        def update_path(path):\n",
        "            for piece, samples in zip(path, t_samples):\n",
        "                piece.set_points_as_corners(plane.n2p(func(samples)))\n",
        "            return path\n",
        "\n",
        "        path.add_updater(update_path)\n",
        "        for piece, color in zip(path, it.cycle(self.staggered_path_colors)):\n",
        "            piece.set_stroke(color, stroke_width)\n",
        "\n",
        "        return path\n",
        "\n",
        "    def get_dynamic_vector_sum(self, plane, func, thickness=1, backstroke_width=0, n_samples=100, border_width=0.5):\n",
        "        t_range = list(range(0, self.t_max))\n",
        "        vects = VGroup(\n",
        "            self.get_vector(\n",
        "                plane, 1,\n",
        "                thickness=thickness,\n",
        "                backstroke_width=backstroke_width,\n",
        "                fill_color=color,\n",
        "            )\n",
        "            for t, color in zip(t_range, it.cycle(self.staggered_path_colors))\n",
        "        )\n",
        "        vects.set_fill(border_width=border_width)\n",
        "        t_samples = [np.linspace(t, t + 1, n_samples) for t in t_range]\n",
        "\n",
        "        def update_vects(vects):\n",
        "            avg_values = [0] + [func(samples).mean() for samples in t_samples]\n",
        "            end_values = np.cumsum(avg_values)\n",
        "            end_points = plane.n2p(end_values)\n",
        "            for vect, p0, p1 in zip(vects, end_points, end_points[1:]):\n",
        "                vect.put_start_and_end_on(p0, p1)\n",
        "            return vect\n",
        "\n",
        "        vects.add_updater(update_vects)\n",
        "\n",
        "        return vects\n",
        "\n",
        "\n",
        "class BreakDownLaplaceTransform(IntegrateComplexExponential):\n",
        "    func_tex = R\"e^{1.5 {t}}\"\n",
        "    initial_s = 2 + 1j\n",
        "    s_plane_x_range = (-3, 3)\n",
        "    s_label_font_size = 24\n",
        "    t_max = 100  # For dynamic path and vector sum.  Change to 100 for final render\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_core_pieces()\n",
        "\n",
        "        frame = self.frame\n",
        "        s_tracker = self.s_tracker\n",
        "        exp_plane, int_plane = self.output_planes\n",
        "\n",
        "        # Talk through the parts\n",
        "        frame.reorient(0, 52, 0, (-0.69, 0.41, 0.56), 10.93)\n",
        "        int_rect = SurroundingRectangle(int_plane.label)\n",
        "        int_rect.set_stroke(YELLOW, 2)\n",
        "        int_rect.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(20, 68, 0, (-0.45, 0.24, 0.17), 6.28),\n",
        "            s_tracker.animate.set_value(1.6 - 1j),\n",
        "            ShowCreation(int_rect, time_span=(4, 5)),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(int_rect.animate.surround(exp_plane.label))\n",
        "        self.draw_upper_plot(draw_time=8)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.6),\n",
        "            frame.animate.reorient(24, 65, 0, (-0.35, 1.85, 1.61), 11.20),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.501),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Alternate pan to pole\n",
        "        self.clear()\n",
        "        to_add = Group(self.s_group, self.graph_tracer, self.graph)\n",
        "        to_add.shift(-self.s_group[0].n2p(0))\n",
        "        self.add(to_add)\n",
        "\n",
        "        frame.reorient(-35, 84, 0, (-1.14, 1.42, 4.73), 14.55)\n",
        "        self.s_tracker.set_value(1 + 1j)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 43, 0, (-0.42, 0.6, 2.1), 9.91),\n",
        "            self.s_tracker.animate.set_value(1.5001),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "    def add_core_pieces(self):\n",
        "        # Planes and their contenst\n",
        "        s_group = self.get_s_group()\n",
        "        s_plane = s_group[0]\n",
        "        s_plane.faded_lines.set_opacity(0)\n",
        "\n",
        "        output_planes = self.get_output_planes()\n",
        "        exp_plane, int_plane = output_planes\n",
        "\n",
        "        right_rect = FullScreenRectangle()\n",
        "        right_rect.set_fill(BLACK, 1)\n",
        "        right_rect.set_width(RIGHT_SIDE[0] - output_planes.get_left()[0] + SMALL_BUFF, stretch=True, about_edge=RIGHT)\n",
        "\n",
        "        # Dynamic pieces\n",
        "        output_path = self.get_dynamic_output_path(exp_plane, self.inner_func)\n",
        "        vect_sum = self.get_dynamic_vector_sum(int_plane, self.inner_func)\n",
        "        integral_vect = self.get_integral_vect(int_plane)\n",
        "\n",
        "        for mob in [output_path, vect_sum, integral_vect]:\n",
        "            mob.set_clip_plane(RIGHT, -exp_plane.get_x(LEFT))\n",
        "\n",
        "        graph_tracer = self.get_graph_tracer(s_plane)\n",
        "\n",
        "        graph = get_complex_graph(s_plane, self.transformed_func)\n",
        "\n",
        "        # Add everything\n",
        "        right_group = VGroup(right_rect, output_planes, output_path, vect_sum)\n",
        "        right_group.fix_in_frame()\n",
        "        right_group.set_scale_stroke_with_zoom(True)\n",
        "\n",
        "        self.add(\n",
        "            s_group,\n",
        "            graph_tracer,\n",
        "            graph,\n",
        "            right_rect,\n",
        "            output_planes,\n",
        "            output_path,\n",
        "            vect_sum,\n",
        "            integral_vect,\n",
        "        )\n",
        "\n",
        "        self.s_group = s_group\n",
        "        self.output_planes = output_planes\n",
        "        self.output_path = output_path\n",
        "        self.vect_sum = vect_sum\n",
        "        self.integral_vect = integral_vect\n",
        "        self.graph_tracer = graph_tracer\n",
        "        self.graph = graph\n",
        "\n",
        "    def get_integral_vect(self, int_plane):\n",
        "        vect = Vector(RIGHT, fill_color=WHITE, thickness=2)\n",
        "        dot = GlowDot(color=PINK)\n",
        "        origin = int_plane.n2p(0)\n",
        "\n",
        "        vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            origin, int_plane.n2p(self.transformed_func(self.s_tracker.get_value()))\n",
        "        ))\n",
        "        dot.f_always.move_to(vect.get_end)\n",
        "\n",
        "        group = Group(vect, dot)\n",
        "        group.fix_in_frame()\n",
        "        return group\n",
        "\n",
        "    def get_graph_tracer(self, s_plane):\n",
        "        v_line = Line(ORIGIN, OUT).set_stroke(WHITE, 3)\n",
        "        graph_dot = Group(TrueDot(), GlowDot())\n",
        "        graph_dot.set_color(TEAL)\n",
        "\n",
        "        group = Group(v_line, graph_dot)\n",
        "        s_plane_unit = s_plane.x_axis.get_unit_size()\n",
        "\n",
        "        def update_tracer(group):\n",
        "            s = self.s_tracker.get_value()\n",
        "            s_point = s_plane.n2p(s)\n",
        "            int_value = self.transformed_func(s)\n",
        "\n",
        "            line, dot = group\n",
        "            line.put_start_and_end_on(s_point, s_point + s_plane_unit * abs(int_value) * OUT)\n",
        "            dot.move_to(line.get_end())\n",
        "\n",
        "        group.add_updater(update_tracer)\n",
        "        return group\n",
        "\n",
        "    def get_output_planes(self, width=3, edge_buff=2.5):\n",
        "        exp_plane = self.get_exp_plane(x_range=(-1, 1))\n",
        "        exp_plane.set_width(width)\n",
        "        exp_plane.axes.set_stroke(width=1)\n",
        "        exp_plane.to_corner(UP, MED_LARGE_BUFF)\n",
        "        exp_plane.to_edge(RIGHT, buff=edge_buff)\n",
        "\n",
        "        int_plane = self.get_exp_plane()\n",
        "        int_plane.set_width(width)\n",
        "        int_plane.move_to(exp_plane).to_edge(DOWN)\n",
        "        int_plane.axes.set_stroke(width=1)\n",
        "        int_plane.add_coordinate_labels(font_size=12)\n",
        "\n",
        "        kw = dict(t2c=self.tex_to_color_map)\n",
        "        exp_plane.label = Tex(self.func_tex, R\"e^{\\minus {s} {t}}\", **kw)\n",
        "        exp_plane.label.next_to(exp_plane, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        int_plane.label = Tex(R\"\\int^\\infty_0 \" + self.func_tex + R\"e^{\\minus {s} {t}} d{t}\", **kw)\n",
        "        int_plane.label.scale(0.6)\n",
        "        int_plane.label.next_to(int_plane, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        planes = VGroup(exp_plane, int_plane)\n",
        "        for plane in planes:\n",
        "            plane.add(plane.label)\n",
        "\n",
        "        return planes\n",
        "\n",
        "    def func(self, t):\n",
        "        return np.exp(1.5 * t)\n",
        "\n",
        "    def inner_func(self, t):\n",
        "        return self.func(t) * np.exp(-self.s_tracker.get_value() * t)\n",
        "\n",
        "    def transformed_func(self, s):\n",
        "        return np.divide(1.0, (s - 1.5))\n",
        "\n",
        "    def draw_upper_plot(self, draw_time=12, rate_multiple=2):\n",
        "        exp_plane = self.output_planes[0]\n",
        "        n_pieces = int(rate_multiple * draw_time)\n",
        "        path_copy = VMobject()\n",
        "        path_copy.fix_in_frame()\n",
        "        path_copy.start_new_path(self.output_path[0].get_start())\n",
        "        for part in self.output_path[:n_pieces]:\n",
        "            path_copy.append_vectorized_mobject(part)\n",
        "\n",
        "        tracing_vect = Vector(fill_color=YELLOW)\n",
        "        tracing_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            exp_plane.n2p(0),\n",
        "            path_copy.get_end(),\n",
        "        ))\n",
        "        tracing_vect.fix_in_frame()\n",
        "\n",
        "        vect_sum_copy = self.vect_sum.copy()[:n_pieces]\n",
        "        vect_sum_copy.clear_updaters()\n",
        "        self.remove(self.output_path, self.vect_sum, self.integral_vect)\n",
        "\n",
        "        self.add(tracing_vect)\n",
        "        self.play(\n",
        "            ShowCreation(path_copy),\n",
        "            ShowIncreasingSubsets(self.vect_sum[:n_pieces], int_func=np.ceil),\n",
        "            run_time=draw_time,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.remove(path_copy, tracing_vect)\n",
        "        self.add(self.output_path, self.vect_sum, self.integral_vect)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LaplaceTransformOfCos(BreakDownLaplaceTransform):\n",
        "    func_tex = R\"\\cos(t)\"\n",
        "    s_label_config = dict(\n",
        "        hide_zero_components_on_complex=True,\n",
        "        include_sign=True,\n",
        "        num_decimal_places=2,\n",
        "    )\n",
        "    t_max = 200  # For dynamic path and vector sum.\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_core_pieces()\n",
        "\n",
        "        frame = self.frame\n",
        "        s_tracker = self.s_tracker\n",
        "\n",
        "        # Pan around, and highlight the two poles\n",
        "        frame.reorient(0, 0, 0, (-0.44, -0.47, 0.0), 8.00)\n",
        "        self.play(\n",
        "            frame.animate.reorient(28, 69, 0, (-0.42, 0.29, 1.36), 7.45),\n",
        "            s_tracker.animate.set_value(0.02 + 1j),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-38, 81, 0, (-0.24, 0.38, 1.05), 8.77),\n",
        "            s_tracker.animate.set_value(0.02 - 1j),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(13, 72, 0, (-1.41, 0.26, 1.11), 7.37),\n",
        "            s_tracker.animate.set_value(0.1 + 0.57j),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        # Further panning\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 31, 0, (-1.08, -0.52, 0.3), 7.37),\n",
        "            s_tracker.animate.set_value(0.01 + 1j),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.2 - 1j),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(21, 71, 0, (-1.48, -0.28, 0.8), 5.07),\n",
        "            s_tracker.animate.set_value(0.5 + 1j),\n",
        "            run_time=20\n",
        "        )\n",
        "\n",
        "        # Highlight the integral (Start here)\n",
        "        exp_plane, int_plane = self.output_planes\n",
        "        int_rect = SurroundingRectangle(int_plane.label, buff=SMALL_BUFF)\n",
        "        int_rect.set_stroke(YELLOW, 2)\n",
        "        int_rect.fix_in_frame()\n",
        "\n",
        "        self.play(ShowCreation(int_rect))\n",
        "        self.wait()\n",
        "        self.play(int_rect.animate.surround(exp_plane.label, buff=SMALL_BUFF))\n",
        "        self.wait()\n",
        "\n",
        "        # Draw the upper plot\n",
        "        self.draw_upper_plot()\n",
        "\n",
        "        # Move s to 0.2i\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.2j),\n",
        "            self.graph[0].animate.set_opacity(0.5),\n",
        "            self.graph[1].animate.set_stroke(opacity=0.05),\n",
        "            frame.animate.reorient(0, 15, 0, (-1.05, -1.03, 0.59), 4.66),\n",
        "            run_time=4,\n",
        "        )\n",
        "\n",
        "        # Trace the path\n",
        "        t_tracker = self.t_tracker\n",
        "        t_tracker.set_value(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        get_s = s_tracker.get_value\n",
        "\n",
        "        output_path = self.output_path\n",
        "        vect_sum = self.vect_sum\n",
        "        int_vect = self.integral_vect\n",
        "        exp_vect = Arrow(exp_plane.n2p(0), exp_plane.n2p(1), buff=0)\n",
        "        exp_vect.set_fill(YELLOW)\n",
        "        exp_vect.fix_in_frame()\n",
        "        exp_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            exp_plane.n2p(0),\n",
        "            exp_plane.n2p(np.exp(-get_s() * get_t())),\n",
        "        ))\n",
        "        full_vect = exp_vect.copy().clear_updaters()\n",
        "        full_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            exp_plane.n2p(0),\n",
        "            exp_plane.n2p(self.func(get_t()) * np.exp(-get_s() * get_t())),\n",
        "        ))\n",
        "\n",
        "        t_label = Tex(R\"{t} = 0.0\", t2c=self.tex_to_color_map)\n",
        "        t_label.next_to(exp_plane.label, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        t_label.make_number_changeable(\"0.0\").f_always.set_value(t_tracker.get_value)\n",
        "        t_label.fix_in_frame()\n",
        "\n",
        "        output_path_copy = VMobject()\n",
        "        output_path_copy.start_new_path(self.output_path[0].get_start())\n",
        "        output_path_copy.fix_in_frame()\n",
        "        for part in output_path:\n",
        "            output_path_copy.append_vectorized_mobject(part)\n",
        "        partial_path = output_path_copy.copy()\n",
        "        partial_path.fix_in_frame()\n",
        "        partial_path.add_updater(lambda m: m.pointwise_become_partial(\n",
        "            output_path_copy, 0, get_t() / self.t_max\n",
        "        ))\n",
        "\n",
        "        vect_sum_copy = vect_sum.copy()\n",
        "        vect_sum_copy.clear_updaters()\n",
        "        growing_vect_sum = VGroup(*vect_sum_copy)\n",
        "        growing_vect_sum.fix_in_frame()\n",
        "\n",
        "        def update_growing_sum(group):\n",
        "            group.set_submobjects(vect_sum_copy.submobjects[:int(get_t())])\n",
        "            if len(group) == 0:\n",
        "                return\n",
        "            group[:-1].set_fill(opacity=0.35, border_width=0.5)\n",
        "            group[-1].set_fill(opacity=1, border_width=2)\n",
        "\n",
        "        growing_vect_sum.add_updater(update_growing_sum)\n",
        "\n",
        "        t_tracker.clear_updaters()\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        self.play(\n",
        "            int_rect.animate.surround(exp_plane.label[-4:], SMALL_BUFF),\n",
        "            FadeOut(output_path, suspend_mobject_updating=True),\n",
        "            FadeOut(vect_sum, suspend_mobject_updating=True),\n",
        "            FadeOut(int_vect, suspend_mobject_updating=True),\n",
        "            FadeIn(exp_vect),\n",
        "            FadeIn(t_label),\n",
        "        )\n",
        "        self.add(t_tracker)\n",
        "        self.wait(12)\n",
        "        self.add(partial_path)\n",
        "        self.play(\n",
        "            int_rect.animate.surround(exp_plane.label, SMALL_BUFF),\n",
        "            exp_vect.animate.set_fill(opacity=0.25),\n",
        "            VFadeIn(full_vect),\n",
        "        )\n",
        "        self.wait(12)\n",
        "        self.add(growing_vect_sum)\n",
        "        self.play(int_rect.animate.surround(int_plane.label, buff=SMALL_BUFF))\n",
        "        self.wait(20)\n",
        "        self.play(\n",
        "            frame.animate.reorient(25, 55, 0, (-0.91, -0.76, 0.83), 5.93),\n",
        "            self.graph[0].animate.set_opacity(0.7),\n",
        "            self.graph[1].animate.set_stroke(opacity=0.1),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(5)\n",
        "        growing_vect_sum.clear_updaters()\n",
        "        self.play(\n",
        "            VFadeOut(growing_vect_sum),\n",
        "            VFadeOut(partial_path),\n",
        "            VFadeOut(t_label),\n",
        "            VFadeOut(exp_vect),\n",
        "            VFadeOut(full_vect),\n",
        "            VFadeOut(int_rect),\n",
        "            VFadeIn(output_path),\n",
        "            VFadeIn(vect_sum),\n",
        "            FadeIn(int_vect)\n",
        "        )\n",
        "\n",
        "        # Add a small real part, increase imaginary\n",
        "        self.play(\n",
        "            s_tracker.animate.increment_value(0.05),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.draw_upper_plot(draw_time=12, rate_multiple=6)\n",
        "        self.play(\n",
        "            s_tracker.animate.increment_value(0.8j),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.draw_upper_plot(draw_time=12, rate_multiple=4)\n",
        "        self.play(\n",
        "            s_tracker.animate.increment_value(-0.03),\n",
        "            frame.animate.reorient(29, 78, 0, (-0.48, 0.16, 2.64), 10.00),\n",
        "            run_time=7,\n",
        "        )\n",
        "\n",
        "        # Walk the imaginary line\n",
        "        self.play(s_tracker.animate.increment_value(0.05), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(s_tracker.animate.increment_value(1.3j), run_time=20)\n",
        "        self.play(s_tracker.animate.increment_value(-0.5j), run_time=10)\n",
        "        self.play(s_tracker.animate.increment_value(1), run_time=6)\n",
        "        self.play(s_tracker.animate.increment_value(-0.8), run_time=6)\n",
        "        self.play(s_tracker.animate.increment_value(-0.2j), run_time=6)\n",
        "        self.play(s_tracker.animate.set_value(0.2j), run_time=3)\n",
        "\n",
        "        # Pan\n",
        "        self.play(frame.animate.reorient(-50, 67, 5, (0.47, -1.1, 1.08), 11.24), run_time=10)\n",
        "\n",
        "    def func(self, t):\n",
        "        return np.cos(t)\n",
        "\n",
        "    def transformed_func(self, s):\n",
        "        return np.divide(s, s**2 + 1**2)\n"
    ]
}