{
    "topic": "The mathematical concept being demonstrated is the quadratic formula, which is used to solve quadratic equations of the",
    "code": [
        "from manim_imports_ext import *\n",
        "import math\n",
        "\n",
        "\n",
        "class StreamIntro(Scene):\n",
        "    def construct(self):\n",
        "        # Add logo\n",
        "        logo = Logo()\n",
        "        spikes = VGroup(*[\n",
        "            spike\n",
        "            for layer in logo.spike_layers\n",
        "            for spike in layer\n",
        "        ])\n",
        "        self.add(*logo.family_members_with_points())\n",
        "\n",
        "        # Add label\n",
        "        label = OldTexText(\"The lesson will\\\\\\\\begin shortly\")\n",
        "        label.scale(2)\n",
        "        label.next_to(logo, DOWN)\n",
        "        self.add(label)\n",
        "\n",
        "        self.camera.frame.move_to(DOWN)\n",
        "\n",
        "        for spike in spikes:\n",
        "            point = spike.get_start()\n",
        "            spike.angle = angle_of_vector(point)\n",
        "\n",
        "        anims = []\n",
        "        for spike in spikes:\n",
        "            anims.append(Rotate(\n",
        "                spike, spike.angle * 28 * 2,\n",
        "                about_point=ORIGIN,\n",
        "                rate_func=linear,\n",
        "            ))\n",
        "        self.play(*anims, run_time=60 * 5)\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class OldStreamIntro(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.set_height(2)\n",
        "        morty.to_corner(DL)\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"The lesson will\\\\\\\\begin soon.\",\n",
        "            bubble_config={\n",
        "                \"height\": 2,\n",
        "                \"width\": 3,\n",
        "            },\n",
        "            target_mode=\"hooray\",\n",
        "        ))\n",
        "        bound = AnimatedBoundary(morty.bubble.content, max_stroke_width=1)\n",
        "        self.add(bound, morty.bubble, morty.bubble.content)\n",
        "        self.remove(morty.bubble.content)\n",
        "        morty.bubble.set_fill(opacity=0)\n",
        "\n",
        "        self.camera.frame.scale(0.6, about_edge=DL)\n",
        "\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(5)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(3)\n",
        "        return\n",
        "\n",
        "        text = OldTexText(\"The lesson will\\\\\\\\begin soon.\")\n",
        "        text.set_height(1.5)\n",
        "        text.to_corner(DL, buff=LARGE_BUFF)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class QuadraticFormula(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{-b \\\\pm \\\\sqrt{b^2 - 4ac}}{2a}\",\n",
        "        )\n",
        "        formula.next_to(self.students, UP, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        self.add(formula)\n",
        "\n",
        "        self.play_student_changes(\n",
        "            \"angry\", \"tired\", \"sad\",\n",
        "            look_at=formula,\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"It doesn't have\\\\\\\\to be this way.\",\n",
        "            bubble_config={\n",
        "                \"width\": 4,\n",
        "                \"height\": 3,\n",
        "            }\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"erm\",\n",
        "            look_at=formula\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class SimplerQuadratic(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\"m \\\\pm \\\\sqrt{m^2 - p}\")\n",
        "        tex.set_stroke(BLACK, 12, background=True)\n",
        "        tex.scale(1.5)\n",
        "        self.add(tex)\n",
        "\n",
        "\n",
        "class CosGraphs(Scene):\n",
        "    def construct(self):\n",
        "        axes = Axes(\n",
        "            x_min=-0.75 * TAU,\n",
        "            x_max=0.75 * TAU,\n",
        "            y_min=-1.5,\n",
        "            y_max=1.5,\n",
        "            x_axis_config={\n",
        "                \"tick_frequency\": PI / 4,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            y_axis_config={\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"include_tip\": False,\n",
        "                \"unit_size\": 1.5,\n",
        "            }\n",
        "        )\n",
        "\n",
        "        graph1 = axes.get_graph(np.cos)\n",
        "        graph2 = axes.get_graph(lambda x: np.cos(x)**2)\n",
        "\n",
        "        graph1.set_stroke(YELLOW, 5)\n",
        "        graph2.set_stroke(BLUE, 5)\n",
        "\n",
        "        label1 = OldTex(\"\\\\cos(x)\")\n",
        "        label2 = OldTex(\"\\\\cos^2(x)\")\n",
        "\n",
        "        label1.match_color(graph1)\n",
        "        label1.set_height(0.75)\n",
        "        label1.next_to(axes.input_to_graph_point(-PI, graph1), DOWN)\n",
        "\n",
        "        label2.match_color(graph2)\n",
        "        label2.set_height(0.75)\n",
        "        label2.next_to(axes.input_to_graph_point(PI, graph2), UP)\n",
        "\n",
        "        for mob in [graph1, graph2, label1, label2]:\n",
        "            mc = mob.copy()\n",
        "            mc.set_stroke(BLACK, 10, background=True)\n",
        "            self.add(mc)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph1)\n",
        "        self.add(graph2)\n",
        "        self.add(label1)\n",
        "        self.add(label2)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class SineWave(Scene):\n",
        "    def construct(self):\n",
        "        w_axes = self.get_wave_axes()\n",
        "        square, circle, c_axes = self.get_edge_group()\n",
        "\n",
        "        self.add(w_axes)\n",
        "        self.add(square, circle, c_axes)\n",
        "\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        c_dot = Dot(color=YELLOW)\n",
        "        c_line = Line(DOWN, UP, color=GREEN)\n",
        "        w_dot = Dot(color=YELLOW)\n",
        "        w_line = Line(DOWN, UP, color=GREEN)\n",
        "\n",
        "        def update_c_dot(dot, axes=c_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            dot.move_to(axes.c2p(\n",
        "                np.cos(theta),\n",
        "                np.sin(theta),\n",
        "            ))\n",
        "\n",
        "        def update_c_line(line, axes=c_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            x = np.cos(theta)\n",
        "            y = np.sin(theta)\n",
        "            if y == 0:\n",
        "                y = 1e-6\n",
        "            line.put_start_and_end_on(\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x, y),\n",
        "            )\n",
        "\n",
        "        def update_w_dot(dot, axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            dot.move_to(axes.c2p(theta, np.sin(theta)))\n",
        "\n",
        "        def update_w_line(line, axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            x = theta\n",
        "            y = np.sin(theta)\n",
        "            if y == 0:\n",
        "                y = 1e-6\n",
        "            line.put_start_and_end_on(\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x, y),\n",
        "            )\n",
        "\n",
        "        def get_partial_circle(circle=circle, tracker=theta_tracker):\n",
        "            result = circle.copy()\n",
        "            theta = tracker.get_value()\n",
        "            result.pointwise_become_partial(\n",
        "                circle, 0, clip(theta / TAU, 0, 1),\n",
        "            )\n",
        "            result.set_stroke(RED, width=3)\n",
        "            return result\n",
        "\n",
        "        def get_partial_wave(axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            graph = axes.get_graph(np.sin, x_min=0, x_max=theta, step_size=0.025)\n",
        "            graph.set_stroke(BLUE, 3)\n",
        "            return graph\n",
        "\n",
        "        def get_h_line(axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            return Line(\n",
        "                axes.c2p(0, 0),\n",
        "                axes.c2p(theta, 0),\n",
        "                stroke_color=RED\n",
        "            )\n",
        "\n",
        "        c_dot.add_updater(update_c_dot)\n",
        "        c_line.add_updater(update_c_line)\n",
        "        w_dot.add_updater(update_w_dot)\n",
        "        w_line.add_updater(update_w_line)\n",
        "        partial_circle = always_redraw(get_partial_circle)\n",
        "        partial_wave = always_redraw(get_partial_wave)\n",
        "        h_line = always_redraw(get_h_line)\n",
        "\n",
        "        self.add(partial_circle)\n",
        "        self.add(partial_wave)\n",
        "        self.add(h_line)\n",
        "        self.add(c_line, c_dot)\n",
        "        self.add(w_line, w_dot)\n",
        "\n",
        "        sin_label = OldTex(\n",
        "            \"\\\\sin\\\\left(\\\\theta\\\\right)\",\n",
        "            tex_to_color_map={\"\\\\theta\": RED}\n",
        "        )\n",
        "        sin_label.next_to(w_axes.get_top(), UR)\n",
        "        self.add(sin_label)\n",
        "\n",
        "        self.play(\n",
        "            theta_tracker.set_value, 1.25 * TAU,\n",
        "            run_time=15,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    def get_wave_axes(self):\n",
        "        wave_axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=1.25 * TAU,\n",
        "            y_min=-1.0,\n",
        "            y_max=1.0,\n",
        "            x_axis_config={\n",
        "                \"tick_frequency\": TAU / 8,\n",
        "                \"unit_size\": 1.0,\n",
        "            },\n",
        "            y_axis_config={\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"include_tip\": False,\n",
        "                \"unit_size\": 1.5,\n",
        "            }\n",
        "        )\n",
        "        wave_axes.y_axis.add_numbers(\n",
        "            -1, 1, num_decimal_places=1\n",
        "        )\n",
        "        wave_axes.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        pairs = [\n",
        "            (PI / 2, \"\\\\frac{\\\\pi}{2}\"),\n",
        "            (PI, \"\\\\pi\"),\n",
        "            (3 * PI / 2, \"\\\\frac{3\\\\pi}{2}\"),\n",
        "            (2 * PI, \"2\\\\pi\"),\n",
        "        ]\n",
        "        syms = VGroup()\n",
        "        for val, tex in pairs:\n",
        "            sym = OldTex(tex)\n",
        "            sym.scale(0.5)\n",
        "            sym.next_to(wave_axes.c2p(val, 0), DOWN, MED_SMALL_BUFF)\n",
        "            syms.add(sym)\n",
        "        wave_axes.add(syms)\n",
        "\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.set_color(RED)\n",
        "        theta.next_to(wave_axes.x_axis.get_end(), UP)\n",
        "        wave_axes.add(theta)\n",
        "\n",
        "        return wave_axes\n",
        "\n",
        "    def get_edge_group(self):\n",
        "        axes_max = 1.25\n",
        "        radius = 1.5\n",
        "        axes = Axes(\n",
        "            x_min=-axes_max,\n",
        "            x_max=axes_max,\n",
        "            y_min=-axes_max,\n",
        "            y_max=axes_max,\n",
        "            axis_config={\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"include_tip\": False,\n",
        "                \"big_tick_numbers\": [-1, 1],\n",
        "                \"tick_size\": 0.05,\n",
        "                \"unit_size\": radius,\n",
        "            },\n",
        "        )\n",
        "        axes.to_edge(LEFT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        background = SurroundingRectangle(axes, buff=MED_SMALL_BUFF)\n",
        "        background.set_stroke(WHITE, 1)\n",
        "        background.set_fill(GREY_E, 1)\n",
        "\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.move_to(axes)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "\n",
        "        nums = VGroup()\n",
        "        for u in 1, -1:\n",
        "            num = Integer(u)\n",
        "            num.set_height(0.2)\n",
        "            num.set_stroke(BLACK, 3, background=True)\n",
        "            num.next_to(axes.c2p(u, 0), DOWN + u * RIGHT, SMALL_BUFF)\n",
        "            nums.add(num)\n",
        "\n",
        "        axes.add(nums)\n",
        "\n",
        "        return background, circle, axes\n",
        "\n",
        "\n",
        "class CosWave(SineWave):\n",
        "    CONFIG = {\n",
        "        \"include_square\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        w_axes = self.get_wave_axes()\n",
        "        square, circle, c_axes = self.get_edge_group()\n",
        "\n",
        "        self.add(w_axes)\n",
        "        self.add(square, circle, c_axes)\n",
        "\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        c_dot = Dot(color=YELLOW)\n",
        "        c_line = Line(DOWN, UP, color=GREEN)\n",
        "        w_dot = Dot(color=YELLOW)\n",
        "        w_line = Line(DOWN, UP, color=GREEN)\n",
        "\n",
        "        def update_c_dot(dot, axes=c_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            dot.move_to(axes.c2p(\n",
        "                np.cos(theta),\n",
        "                np.sin(theta),\n",
        "            ))\n",
        "\n",
        "        def update_c_line(line, axes=c_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            x = np.cos(theta)\n",
        "            y = np.sin(theta)\n",
        "            line.set_points_as_corners([\n",
        "                axes.c2p(0, y),\n",
        "                axes.c2p(x, y),\n",
        "            ])\n",
        "\n",
        "        def update_w_dot(dot, axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            dot.move_to(axes.c2p(theta, np.cos(theta)))\n",
        "\n",
        "        def update_w_line(line, axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            x = theta\n",
        "            y = np.cos(theta)\n",
        "            if y == 0:\n",
        "                y = 1e-6\n",
        "            line.set_points_as_corners([\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x, y),\n",
        "            ])\n",
        "\n",
        "        def get_partial_circle(circle=circle, tracker=theta_tracker):\n",
        "            result = circle.copy()\n",
        "            theta = tracker.get_value()\n",
        "            result.pointwise_become_partial(\n",
        "                circle, 0, clip(theta / TAU, 0, 1),\n",
        "            )\n",
        "            result.set_stroke(RED, width=3)\n",
        "            return result\n",
        "\n",
        "        def get_partial_wave(axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            graph = axes.get_graph(np.cos, x_min=0, x_max=theta, step_size=0.025)\n",
        "            graph.set_stroke(PINK, 3)\n",
        "            return graph\n",
        "\n",
        "        def get_h_line(axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            return Line(\n",
        "                axes.c2p(0, 0),\n",
        "                axes.c2p(theta, 0),\n",
        "                stroke_color=RED\n",
        "            )\n",
        "\n",
        "        def get_square(line=c_line):\n",
        "            square = Square()\n",
        "            square.set_stroke(WHITE, 1)\n",
        "            square.set_fill(MAROON_B, opacity=0.5)\n",
        "            square.match_width(line)\n",
        "            square.move_to(line, DOWN)\n",
        "            return square\n",
        "\n",
        "        def get_square_graph(axes=w_axes, tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            graph = axes.get_graph(\n",
        "                lambda x: np.cos(x)**2, x_min=0, x_max=theta, step_size=0.025\n",
        "            )\n",
        "            graph.set_stroke(MAROON_B, 3)\n",
        "            return graph\n",
        "\n",
        "        c_dot.add_updater(update_c_dot)\n",
        "        c_line.add_updater(update_c_line)\n",
        "        w_dot.add_updater(update_w_dot)\n",
        "        w_line.add_updater(update_w_line)\n",
        "        h_line = always_redraw(get_h_line)\n",
        "        partial_circle = always_redraw(get_partial_circle)\n",
        "        partial_wave = always_redraw(get_partial_wave)\n",
        "\n",
        "        self.add(partial_circle)\n",
        "        self.add(partial_wave)\n",
        "        self.add(h_line)\n",
        "        self.add(c_line, c_dot)\n",
        "        self.add(w_line, w_dot)\n",
        "\n",
        "        if self.include_square:\n",
        "            self.add(always_redraw(get_square))\n",
        "            self.add(always_redraw(get_square_graph))\n",
        "\n",
        "        cos_label = OldTex(\n",
        "            \"\\\\cos\\\\left(\\\\theta\\\\right)\",\n",
        "            tex_to_color_map={\"\\\\theta\": RED}\n",
        "        )\n",
        "        cos_label.next_to(w_axes.get_top(), UR)\n",
        "        self.add(cos_label)\n",
        "\n",
        "        self.play(\n",
        "            theta_tracker.set_value, 1.25 * TAU,\n",
        "            run_time=15,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "\n",
        "class CosSquare(CosWave):\n",
        "    CONFIG = {\n",
        "        \"include_square\": True\n",
        "    }\n",
        "\n",
        "\n",
        "class ComplexNumberPreview(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(axis_config={\"stroke_width\": 4})\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        z = complex(2, 1)\n",
        "        dot = Dot()\n",
        "        dot.move_to(plane.n2p(z))\n",
        "        label = OldTex(\"2+i\")\n",
        "        label.set_color(YELLOW)\n",
        "        dot.set_color(YELLOW)\n",
        "        label.next_to(dot, UR, SMALL_BUFF)\n",
        "        label.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        line = Line(plane.n2p(0), plane.n2p(z))\n",
        "        arc = Arc(start_angle=0, angle=np.log(z).imag, radius=0.5)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(line, arc)\n",
        "        self.add(dot)\n",
        "        self.add(label)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class ComplexMultiplication(Scene):\n",
        "    def construct(self):\n",
        "        # Add plane\n",
        "        plane = ComplexPlane()\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        z = complex(2, 1)\n",
        "        z_dot = Dot(color=PINK)\n",
        "        z_dot.move_to(plane.n2p(z))\n",
        "        z_label = OldTex(\"z\")\n",
        "        z_label.next_to(z_dot, UR, buff=0.5 * SMALL_BUFF)\n",
        "        z_label.match_color(z_dot)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(z_dot)\n",
        "        self.add(z_label)\n",
        "\n",
        "        # Show 1\n",
        "        one_vect = Vector(RIGHT)\n",
        "        one_vect.set_color(YELLOW)\n",
        "        one_vect.target = Vector(plane.n2p(z))\n",
        "        one_vect.target.match_style(one_vect)\n",
        "\n",
        "        z_rhs = OldTex(\"=\", \"z \\\\cdot 1\")\n",
        "        z_rhs[1].match_color(one_vect)\n",
        "        z_rhs.next_to(z_label, RIGHT, 1.5 * SMALL_BUFF, aligned_edge=DOWN)\n",
        "        z_rhs.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        one_label, i_label = [l for l in plane.coordinate_labels if l.get_value() == 1]\n",
        "\n",
        "        self.play(GrowArrow(one_vect))\n",
        "        self.wait()\n",
        "        self.add(one_vect, z_dot)\n",
        "        self.play(\n",
        "            MoveToTarget(one_vect),\n",
        "            TransformFromCopy(one_label, z_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show i\n",
        "        i_vect = Vector(UP, color=GREEN)\n",
        "        zi_point = plane.n2p(z * complex(0, 1))\n",
        "        i_vect.target = Vector(zi_point)\n",
        "        i_vect.target.match_style(i_vect)\n",
        "        i_vect_label = OldTex(\"z \\\\cdot i\")\n",
        "        i_vect_label.match_color(i_vect)\n",
        "        i_vect_label.set_stroke(BLACK, 3, background=True)\n",
        "        i_vect_label.next_to(zi_point, UL, SMALL_BUFF)\n",
        "\n",
        "        self.play(GrowArrow(i_vect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(i_vect),\n",
        "            TransformFromCopy(i_label, i_vect_label),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(one_vect, i_vect.target, path_arc=-90 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transform plane\n",
        "        plane.generate_target()\n",
        "        for mob in plane.target.family_members_with_points():\n",
        "            if isinstance(mob, Line):\n",
        "                mob.set_stroke(GREY, opacity=0.5)\n",
        "        new_plane = ComplexPlane(faded_line_ratio=0)\n",
        "\n",
        "        self.remove(plane)\n",
        "        self.add(plane, new_plane, *self.mobjects)\n",
        "\n",
        "        new_plane.generate_target()\n",
        "        new_plane.target.apply_complex_function(lambda w, z=z: w * z)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(plane),\n",
        "            MoveToTarget(new_plane),\n",
        "            run_time=6,\n",
        "            rate_func=there_and_back_with_pause\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show Example Point\n",
        "        w = complex(2, -1)\n",
        "        w_dot = Dot(plane.n2p(w), color=WHITE)\n",
        "        one_vects = VGroup(*[Vector(RIGHT) for x in range(2)])\n",
        "        one_vects.arrange(RIGHT, buff=0)\n",
        "        one_vects.move_to(plane.n2p(0), LEFT)\n",
        "        one_vects.set_color(YELLOW)\n",
        "        new_i_vect = Vector(DOWN)\n",
        "        new_i_vect.move_to(plane.n2p(2), UP)\n",
        "        new_i_vect.set_color(GREEN)\n",
        "        vects = VGroup(*one_vects, new_i_vect)\n",
        "        vects.set_opacity(0.8)\n",
        "\n",
        "        w_group = VGroup(*vects, w_dot)\n",
        "        w_group.target = VGroup(\n",
        "            one_vect.copy().set_opacity(0.8),\n",
        "            one_vect.copy().shift(plane.n2p(z)).set_opacity(0.8),\n",
        "            i_vect.copy().rotate(PI, about_point=ORIGIN).shift(2 * plane.n2p(z)).set_opacity(0.8),\n",
        "            Dot(plane.n2p(w * z), color=WHITE)\n",
        "        )\n",
        "\n",
        "        self.play(FadeInFromLarge(w_dot))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(vects))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(plane),\n",
        "            MoveToTarget(new_plane),\n",
        "            MoveToTarget(w_group),\n",
        "            run_time=2,\n",
        "            path_arc=np.log(z).imag,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotatePiCreature(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(mode=\"thinking\")\n",
        "        randy.set_height(6)\n",
        "\n",
        "        plane = ComplexPlane(x_min=-12, x_max=12)\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        self.camera.frame.move_to(3 * RIGHT)\n",
        "\n",
        "        self.add(randy)\n",
        "        self.wait()\n",
        "        self.play(Rotate(randy, 30 * DEGREES, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(Rotate(randy, -30 * DEGREES))\n",
        "\n",
        "        self.add(plane, randy)\n",
        "        self.play(\n",
        "            ShowCreation(plane),\n",
        "            randy.set_opacity, 0.75,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dots = VGroup()\n",
        "        for mob in randy.family_members_with_points():\n",
        "            for point in mob.get_anchors():\n",
        "                dot = Dot(point)\n",
        "                dot.set_height(0.05)\n",
        "                dots.add(dot)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(dots))\n",
        "        self.wait()\n",
        "\n",
        "        label = VGroup(\n",
        "            OldTex(\"(x + iy)\"),\n",
        "            Vector(DOWN),\n",
        "            OldTex(\"(\\\\cos(30^\\\\circ) + i\\\\sin(30^\\\\circ))\", \"(x + iy)\"),\n",
        "        )\n",
        "        label[2][0].set_color(YELLOW)\n",
        "        label.arrange(DOWN)\n",
        "        label.to_corner(DR)\n",
        "        label.shift(3 * RIGHT)\n",
        "\n",
        "        for mob in label:\n",
        "            mob.add_background_rectangle()\n",
        "\n",
        "        self.play(FadeIn(label))\n",
        "        self.wait()\n",
        "\n",
        "        randy.add(dots)\n",
        "        self.play(Rotate(randy, 30 * DEGREES), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExpMeaning(Scene):\n",
        "    CONFIG = {\n",
        "        \"include_circle\": True\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Plane\n",
        "        plane = ComplexPlane(y_min=-6, y_max=6)\n",
        "        plane.shift(1.5 * DOWN)\n",
        "        plane.add_coordinates()\n",
        "        if self.include_circle:\n",
        "            circle = Circle(radius=1)\n",
        "            circle.set_stroke(RED, 1)\n",
        "            circle.move_to(plane.n2p(0))\n",
        "            plane.add(circle)\n",
        "\n",
        "        # Equation\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{exp}(i\\\\theta) = \",\n",
        "            \"1 + \",\n",
        "            \"i\\\\theta + \",\n",
        "            \"{(i\\\\theta)^2 \\\\over 2} + \",\n",
        "            \"{(i\\\\theta)^3 \\\\over 6} + \",\n",
        "            \"{(i\\\\theta)^4 \\\\over 24} + \",\n",
        "            \"\\\\cdots\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\theta\": YELLOW,\n",
        "                \"i\": GREEN,\n",
        "            },\n",
        "        )\n",
        "        equation.add_background_rectangle(buff=MED_SMALL_BUFF, opacity=1)\n",
        "        equation.to_edge(UL, buff=0)\n",
        "\n",
        "        # Label\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        theta_label = VGroup(\n",
        "            OldTex(\"\\\\theta = \"),\n",
        "            DecimalNumber(0, num_decimal_places=4)\n",
        "        )\n",
        "        theta_decimal = theta_label[1]\n",
        "        theta_decimal.add_updater(\n",
        "            lambda m, tt=theta_tracker: m.set_value(tt.get_value())\n",
        "        )\n",
        "        theta_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        theta_label.set_color(YELLOW)\n",
        "        theta_label.add_to_back(BackgroundRectangle(\n",
        "            theta_label,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "            fill_opacity=1,\n",
        "        ))\n",
        "        theta_label.next_to(equation, DOWN, aligned_edge=LEFT, buff=0)\n",
        "\n",
        "        # Vectors\n",
        "        def get_vectors(n_vectors=20, plane=plane, tracker=theta_tracker):\n",
        "            last_tip = plane.n2p(0)\n",
        "            z = complex(0, tracker.get_value())\n",
        "            vects = VGroup()\n",
        "            colors = color_gradient([GREEN, YELLOW, RED], 6)\n",
        "            for i, color in zip(range(n_vectors), it.cycle(colors)):\n",
        "                vect = Vector(complex_to_R3(z**i / math.factorial(i)))\n",
        "                vect.set_color(color)\n",
        "                vect.shift(last_tip)\n",
        "                last_tip = vect.get_end()\n",
        "                vects.add(vect)\n",
        "            return vects\n",
        "\n",
        "        vectors = always_redraw(get_vectors)\n",
        "        dot = Dot()\n",
        "        dot.set_height(0.03)\n",
        "        dot.add_updater(lambda m, vs=vectors: m.move_to(vs[-1].get_end()))\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(vectors)\n",
        "        self.add(dot)\n",
        "        self.add(equation)\n",
        "        self.add(theta_label)\n",
        "\n",
        "        self.play(\n",
        "            theta_tracker.set_value, 1,\n",
        "            run_time=3,\n",
        "            rate_func=smooth,\n",
        "        )\n",
        "        self.wait()\n",
        "        for target in PI, TAU:\n",
        "            self.play(\n",
        "                theta_tracker.set_value, target,\n",
        "                run_time=10,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class ExpMeaningWithoutCircle(ExpMeaning):\n",
        "    CONFIG = {\n",
        "        \"include_circle\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class PositionAndVelocityExample(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane()\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class EulersFormula(Scene):\n",
        "    def construct(self):\n",
        "        kw = {\"tex_to_color_map\": {\"\\\\theta\": YELLOW}}\n",
        "        formula = OldTex(\n",
        "            \"&e^{i\\\\theta} = \\\\\\\\ &\\\\cos\\\\left(\\\\theta\\\\right) + i\\\\cdot\\\\sin\\\\left(\\\\theta\\\\right)\",\n",
        "        )[0]\n",
        "        formula[:4].scale(2, about_edge=UL)\n",
        "        formula[:4].shift(SMALL_BUFF * RIGHT + MED_LARGE_BUFF * UP)\n",
        "        VGroup(formula[2], formula[8], formula[17]).set_color(YELLOW)\n",
        "        formula.scale(1.5)\n",
        "        formula.set_stroke(BLACK, 5, background=True)\n",
        "        self.add(formula)\n",
        "\n",
        "\n",
        "class EtoILimit(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"\\\\lim_{n \\\\to \\\\infty} \\\\left(1 + \\\\frac{it}{n}\\\\right)^n\",\n",
        "        )[0]\n",
        "        VGroup(tex[3], tex[12], tex[14]).set_color(YELLOW)\n",
        "        tex[9].set_color(BLUE)\n",
        "        tex.scale(1.5)\n",
        "        tex.set_stroke(BLACK, 5, background=True)\n",
        "        # self.add(tex)\n",
        "\n",
        "        text = OldTexText(\"Interest rate\\\\\\\\of \", \"$\\\\sqrt{-1}$\")\n",
        "        text[1].set_color(BLUE) \n",
        "        text.scale(1.5)\n",
        "        text.set_stroke(BLACK, 5, background=True)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class ImaginaryInterestRates(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(x_min=-20, x_max=20, y_min=-20, y_max=20)\n",
        "        plane.add_coordinate_labels()\n",
        "        circle = Circle(radius=1)\n",
        "        circle.set_stroke(YELLOW, 1)\n",
        "        self.add(plane, circle)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.generate_target()\n",
        "        frame.target.set_width(25)\n",
        "        frame.target.move_to(8 * RIGHT + 2 * DOWN)\n",
        "\n",
        "        dt_tracker = ValueTracker(1)\n",
        "\n",
        "        def get_vectors(tracker=dt_tracker, plane=plane, T=8):\n",
        "            dt = tracker.get_value()\n",
        "            last_z = 1\n",
        "            vects = VGroup()\n",
        "            for t in np.arange(0, T, dt):\n",
        "                next_z = last_z + complex(0, 1) * last_z * dt\n",
        "                vects.add(Arrow(\n",
        "                    plane.n2p(last_z),\n",
        "                    plane.n2p(next_z),\n",
        "                    buff=0,\n",
        "                ))\n",
        "                last_z = next_z\n",
        "            vects.set_submobject_colors_by_gradient(YELLOW, GREEN, BLUE)\n",
        "            return vects\n",
        "\n",
        "        vects = get_vectors()\n",
        "\n",
        "        line = Line()\n",
        "        line.add_updater(lambda m, v=vects: m.put_start_and_end_on(\n",
        "            ORIGIN, v[-1].get_start() if len(v) > 0 else RIGHT,\n",
        "        ))\n",
        "\n",
        "        self.add(line)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(\n",
        "                vects,\n",
        "                rate_func=linear,\n",
        "                int_func=np.ceil,\n",
        "            ),\n",
        "            MoveToTarget(\n",
        "                frame,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "            ),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(line))\n",
        "\n",
        "        self.remove(vects)\n",
        "        vects = always_redraw(get_vectors)\n",
        "        self.add(vects)\n",
        "        self.play(\n",
        "            Restore(frame),\n",
        "            dt_tracker.set_value, 0.2,\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(dt_tracker.set_value, 0.01, run_time=3)\n",
        "        vects.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        theta_tracker = ValueTracker(0)\n",
        "\n",
        "        def get_arc(tracker=theta_tracker):\n",
        "            theta = tracker.get_value()\n",
        "            arc = Arc(\n",
        "                radius=1,\n",
        "                stroke_width=3,\n",
        "                stroke_color=RED,\n",
        "                start_angle=0,\n",
        "                angle=theta\n",
        "            )\n",
        "            return arc\n",
        "\n",
        "        arc = always_redraw(get_arc)\n",
        "        dot = Dot()\n",
        "        dot.add_updater(lambda m, arc=arc: m.move_to(arc.get_end()))\n",
        "\n",
        "        label = VGroup(\n",
        "            DecimalNumber(0, num_decimal_places=3),\n",
        "            OldTexText(\"Years\")\n",
        "        )\n",
        "        label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        label.move_to(3 * LEFT + 1.5 * UP)\n",
        "\n",
        "        label[0].set_color(RED)\n",
        "        label[0].add_updater(lambda m, tt=theta_tracker: m.set_value(tt.get_value()))\n",
        "\n",
        "        self.add(BackgroundRectangle(label), label, arc, dot)\n",
        "        for n in range(1, 5):\n",
        "            target = n * PI / 2\n",
        "            self.play(\n",
        "                theta_tracker.set_value, target,\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class Logs(Scene):\n",
        "    def construct(self):\n",
        "        log = OldTex(\n",
        "            \"&\\\\text{log}(ab) = \\\\\\\\ &\\\\text{log}(a) + \\\\text{log}(b)\",\n",
        "            tex_to_color_map={\"a\": BLUE, \"b\": YELLOW},\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        \n",
        "        log.scale(1.5)\n",
        "        log.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.add(log)\n",
        "\n",
        "\n",
        "class LnX(Scene):\n",
        "    def construct(self):\n",
        "        sym = OldTex(\"\\\\ln(x)\")\n",
        "        sym.scale(3)\n",
        "        sym.shift(UP)\n",
        "        sym.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        word = OldTexText(\"Natural?\")\n",
        "        word.scale(1.5)\n",
        "        word.set_color(YELLOW)\n",
        "        word.set_stroke(BLACK, 5, background=True)\n",
        "        word.next_to(sym, DOWN, buff=0.5)\n",
        "        arrow = Arrow(word.get_top(), sym[0][1].get_bottom())\n",
        "\n",
        "        self.add(sym, word, arrow)\n",
        "\n",
        "\n",
        "class HarmonicSum(Scene):\n",
        "    def construct(self):\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=13,\n",
        "            y_min=0,\n",
        "            y_max=1.25,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 4,\n",
        "                \"tick_frequency\": 0.25,\n",
        "            }\n",
        "        )\n",
        "        axes.to_corner(DL, buff=1)\n",
        "        axes.x_axis.add_numbers()\n",
        "        axes.y_axis.add_numbers(\n",
        "            *np.arange(0.25, 1.25, 0.25),\n",
        "            num_decimal_places=2,\n",
        "        )\n",
        "        self.add(axes)\n",
        "\n",
        "        graph = axes.get_graph(lambda x: 1 / x, x_min=0.1, x_max=15)\n",
        "        graph_fill = graph.copy()\n",
        "        graph_fill.add_line_to(axes.c2p(15, 0))\n",
        "        graph_fill.add_line_to(axes.c2p(1, 0))\n",
        "        graph_fill.add_line_to(axes.c2p(1, 1))\n",
        "        graph.set_stroke(WHITE, 3)\n",
        "        graph_fill.set_fill(BLUE_E, 0.5)\n",
        "        graph_fill.set_stroke(width=0)\n",
        "        self.add(graph, graph_fill)\n",
        "\n",
        "        bars = VGroup()\n",
        "        bar_labels = VGroup()\n",
        "        for x in range(1, 15):\n",
        "            line = Line(axes.c2p(x, 0), axes.c2p(x + 1, 1 / x))\n",
        "            bar = Rectangle()\n",
        "            bar.set_fill(GREEN_E, 1)\n",
        "            bar.replace(line, stretch=True)\n",
        "            bars.add(bar)\n",
        "\n",
        "            label = OldTex(f\"1 \\\\over {x}\")\n",
        "            label.set_height(0.7)\n",
        "            label.next_to(bar, UP, SMALL_BUFF)\n",
        "            bar_labels.add(label)\n",
        "\n",
        "        bars.set_submobject_colors_by_gradient(GREEN_C, GREEN_E)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "        bars.set_fill(opacity=0.25)\n",
        "\n",
        "        self.add(bars)\n",
        "        self.add(bar_labels)\n",
        "\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class PowerTower(Scene):\n",
        "    def construct(self):\n",
        "        mob = OldTex(\"4 = x^{x^{{x^{x^{x^{\\cdot^{\\cdot^{\\cdot}}}}}}}}\")\n",
        "        mob[0][-1].shift(0.1 * DL)\n",
        "        mob[0][-2].shift(0.05 * DL)\n",
        "\n",
        "        mob.set_height(4)\n",
        "        mob.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.add(mob)\n",
        "\n",
        "\n",
        "class ItoTheI(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\"i^i\")\n",
        "        # tex = OldTex(\"\\\\sqrt{-1}^{\\\\sqrt{-1}}\")\n",
        "        tex.set_height(3)\n",
        "        tex.set_stroke(BLACK, 8, background=True)\n",
        "        self.add(tex)\n",
        "\n",
        "\n",
        "class ComplexExponentialPlay(Scene):\n",
        "    def setup(self):\n",
        "        self.transform_alpha = 0\n",
        "\n",
        "    def construct(self):\n",
        "        # Plane\n",
        "        plane = ComplexPlane(\n",
        "            x_min=-2 * FRAME_WIDTH,\n",
        "            x_max=2 * FRAME_WIDTH,\n",
        "            y_min=-2 * FRAME_HEIGHT,\n",
        "            y_max=2 * FRAME_HEIGHT,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "\n",
        "        # R Dot\n",
        "        r_dot = Dot(color=YELLOW)\n",
        "\n",
        "        def update_r_dot(dot, point_tracker=self.mouse_drag_point):\n",
        "            point = point_tracker.get_location()\n",
        "            if abs(point[0]) < 0.1:\n",
        "                point[0] = 0\n",
        "            if abs(point[1]) < 0.1:\n",
        "                point[1] = 0\n",
        "            dot.move_to(point)\n",
        "\n",
        "        r_dot.add_updater(update_r_dot)\n",
        "        self.mouse_drag_point.move_to(plane.n2p(1))\n",
        "\n",
        "        # Transformed sample dots\n",
        "        def func(z, dot=r_dot, plane=plane):\n",
        "            r = plane.p2n(dot.get_center())\n",
        "            result = np.exp(r * z)\n",
        "            if abs(result) > 20:\n",
        "                result *= 20 / abs(result)\n",
        "            return result\n",
        "\n",
        "        sample_dots = VGroup()\n",
        "        dot_template = Dot(radius=0.05)\n",
        "        dot_template.set_opacity(0.8)\n",
        "        spacing = 0.05\n",
        "        for x in np.arange(-7, 7, spacing):\n",
        "            dot = dot_template.copy()\n",
        "            dot.set_color(TEAL)\n",
        "            dot.z = x\n",
        "            dot.move_to(plane.n2p(dot.z))\n",
        "            sample_dots.add(dot)\n",
        "        for y in np.arange(-6, 6, spacing):\n",
        "            dot = dot_template.copy()\n",
        "            dot.set_color(MAROON)\n",
        "            dot.z = complex(0, y)\n",
        "            dot.move_to(plane.n2p(dot.z))\n",
        "            sample_dots.add(dot)\n",
        "\n",
        "        special_values = [1, complex(0, 1), -1, complex(0, -1)]\n",
        "        special_dots = VGroup(*[\n",
        "            list(filter(lambda d: abs(d.z - x) < 0.01, sample_dots))[0]\n",
        "            for x in special_values\n",
        "        ])\n",
        "        for dot in special_dots:\n",
        "            dot.set_fill(opacity=1)\n",
        "            dot.scale(1.2)\n",
        "            dot.set_stroke(WHITE, 2)\n",
        "\n",
        "        sample_dots.save_state()\n",
        "\n",
        "        def update_sample(sample, f=func, plane=plane, scene=self):\n",
        "            sample.restore()\n",
        "            sample.apply_function_to_submobject_positions(\n",
        "                lambda p: interpolate(\n",
        "                    p,\n",
        "                    plane.n2p(f(plane.p2n(p))),\n",
        "                    scene.transform_alpha,\n",
        "                )\n",
        "            )\n",
        "            return sample\n",
        "\n",
        "        sample_dots.add_updater(update_sample)\n",
        "\n",
        "        # Sample lines\n",
        "        x_line = Line(plane.n2p(plane.x_min), plane.n2p(plane.x_max))\n",
        "        y_line = Line(plane.n2p(plane.y_min), plane.n2p(plane.y_max))\n",
        "        y_line.rotate(90 * DEGREES)\n",
        "        x_line.set_color(GREEN)\n",
        "        y_line.set_color(PINK)\n",
        "        axis_lines = VGroup(x_line, y_line)\n",
        "        for line in axis_lines:\n",
        "            line.insert_n_curves(50)\n",
        "        axis_lines.save_state()\n",
        "\n",
        "        def update_axis_liens(lines=axis_lines, f=func, plane=plane, scene=self):\n",
        "            lines.restore()\n",
        "            lines.apply_function(\n",
        "                lambda p: interpolate(\n",
        "                    p,\n",
        "                    plane.n2p(f(plane.p2n(p))),\n",
        "                    scene.transform_alpha,\n",
        "                )\n",
        "            )\n",
        "            lines.make_smooth()\n",
        "\n",
        "        axis_lines.add_updater(update_axis_liens)\n",
        "\n",
        "        # Labels\n",
        "        labels = VGroup(\n",
        "            OldTex(\"f(1)\"),\n",
        "            OldTex(\"f(i)\"),\n",
        "            OldTex(\"f(-1)\"),\n",
        "            OldTex(\"f(-i)\"),\n",
        "        )\n",
        "        for label, dot in zip(labels, special_dots):\n",
        "            label.set_height(0.3)\n",
        "            label.match_color(dot)\n",
        "            label.set_stroke(BLACK, 3, background=True)\n",
        "            label.add_background_rectangle(opacity=0.5)\n",
        "\n",
        "        def update_labels(labels, dots=special_dots, scene=self):\n",
        "            for label, dot in zip(labels, dots):\n",
        "                label.next_to(dot, UR, 0.5 * SMALL_BUFF)\n",
        "                label.set_opacity(self.transform_alpha)\n",
        "\n",
        "        labels.add_updater(update_labels)\n",
        "\n",
        "        # Titles\n",
        "        title = OldTex(\n",
        "            \"f(x) =\", \"\\\\text{exp}(r\\\\cdot x)\",\n",
        "            tex_to_color_map={\"r\": YELLOW}\n",
        "        )\n",
        "        title.to_corner(UL)\n",
        "        title.set_stroke(BLACK, 5, background=True)\n",
        "        brace = Brace(title[1:], UP, buff=SMALL_BUFF)\n",
        "        e_pow = OldTex(\"e^{rx}\", tex_to_color_map={\"r\": YELLOW})\n",
        "        e_pow.add_background_rectangle()\n",
        "        e_pow.next_to(brace, UP, buff=SMALL_BUFF)\n",
        "        title.add(brace, e_pow)\n",
        "\n",
        "        r_eq = VGroup(\n",
        "            OldTex(\"r=\", tex_to_color_map={\"r\": YELLOW}),\n",
        "            DecimalNumber(1)\n",
        "        )\n",
        "        r_eq.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        r_eq.next_to(title, DOWN, aligned_edge=LEFT)\n",
        "        r_eq[0].set_stroke(BLACK, 5, background=True)\n",
        "        r_eq[1].set_color(YELLOW)\n",
        "        r_eq[1].add_updater(lambda m: m.set_value(plane.p2n(r_dot.get_center())))\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(r_eq)\n",
        "\n",
        "        # self.add(axis_lines)\n",
        "        self.add(sample_dots)\n",
        "        self.add(r_dot)\n",
        "        self.add(labels)\n",
        "\n",
        "        # Animations\n",
        "        def update_transform_alpha(mob, alpha, scene=self):\n",
        "            scene.transform_alpha = alpha\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(10)\n",
        "        r_dot.clear_updaters()\n",
        "        r_dot.move_to(plane.n2p(1))\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                VectorizedPoint(),\n",
        "                update_transform_alpha,\n",
        "            )\n",
        "        )\n",
        "        self.play(r_dot.move_to, plane.n2p(2))\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(PI))\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(np.log(2)))\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(complex(0, np.log(2))), path_arc=90 * DEGREES, run_time=2)\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(complex(0, PI / 2)))\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(np.log(2)), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(frame.set_height, 14)\n",
        "        self.play(r_dot.move_to, plane.n2p(complex(np.log(2), PI)), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(r_dot.move_to, plane.n2p(complex(np.log(2), TAU)), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "    def on_mouse_scroll(self, point, offset):\n",
        "        frame = self.camera.frame\n",
        "        if self.zoom_on_scroll:\n",
        "            factor = 1 + np.arctan(10 * offset[1])\n",
        "            frame.scale(factor, about_point=ORIGIN)\n",
        "        else:\n",
        "            self.transform_alpha = clip(self.transform_alpha + 5 * offset[1], 0, 1)\n",
        "\n",
        "\n",
        "class LDMEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"scroll_time\": 20,\n",
        "    }\n",
        "\n",
        "\n",
        "class ProbDiagram(Scene):\n",
        "    def construct(self):\n",
        "        square = Square(side_length=1)\n",
        "        square.move_to(ORIGIN, DL)\n",
        "        square.set_stroke(width=0)\n",
        "        square.set_fill(BLUE_E, 1)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(1.5)\n",
        "        frame.move_to(square)\n",
        "\n",
        "        tri = Polygon(ORIGIN, UP, UR)\n",
        "        tri.set_fill(BLUE_E, 1)\n",
        "        tri.set_stroke(width=0)\n",
        "\n",
        "        tris = VGroup(tri)\n",
        "        N = 1000\n",
        "        for n in range(1, N):\n",
        "            tri = Polygon(\n",
        "                ORIGIN,\n",
        "                RIGHT + UP / n,\n",
        "                RIGHT + UP / (n + 1),\n",
        "            )\n",
        "            tri.set_stroke(width=0)\n",
        "            color = BLUE_E if (n % 2 == 0) else RED_D\n",
        "            tri.set_fill(color, 1)\n",
        "            tris.add(tri)\n",
        "\n",
        "        self.add(tris)\n"
    ]
}