{
    "topic": "The mathematical concept being demonstrated is the connection between primes and the distribution of prime numbers.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.lost_lecture import GeometryProofLand\n",
        "from _2018.quaternions import SpecialThreeDScene\n",
        "from _2018.uncertainty import Flash\n",
        "\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(self.hold_up_spot)),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"angry\", \"sassy\", \"pleading\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        movements = []\n",
        "        for student in self.students:\n",
        "            student.center_tracker = VectorizedPoint()\n",
        "            student.center_tracker.move_to(student)\n",
        "            student.center_tracker.save_state()\n",
        "            student.add_updater(\n",
        "                lambda m: m.move_to(m.center_tracker)\n",
        "            )\n",
        "            always_shift(\n",
        "                student.center_tracker,\n",
        "                direction=DOWN + 3 * LEFT,\n",
        "                rate=1.5 * random.random()\n",
        "            )\n",
        "            movements.append(student.center_tracker)\n",
        "        self.add(*movements)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"sad\", \"concerned_musician\",\n",
        "            look_at=10 * LEFT + 2 * DOWN\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"Wait, wait, wait!\",\n",
        "            target_mode=\"surprised\"\n",
        "        )\n",
        "        self.remove(*movements)\n",
        "        self.play(\n",
        "            self.change_students(*3 * [\"hesitant\"]),\n",
        "            *[\n",
        "                Restore(student.center_tracker)\n",
        "                for student in self.students\n",
        "            ]\n",
        "        )\n",
        "\n",
        "\n",
        "class StudentsWatching(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\n",
        "                *3 * [\"thinking\"],\n",
        "                look_at=self.screen\n",
        "            ),\n",
        "            VFadeIn(self.pi_creatures, run_time=2)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class UnexpectedConnection(Scene):\n",
        "    def construct(self):\n",
        "        primes = OldTex(\n",
        "            \"2,\", \"3,\", \"5,\", \"7,\", \"11,\", \"13,\", \"17,\", \"\\\\dots\"\n",
        "        )\n",
        "        primes.move_to(2.5 * UP)\n",
        "\n",
        "        circle = Circle(\n",
        "            color=YELLOW,\n",
        "            stroke_width=1,\n",
        "            radius=1.5,\n",
        "        )\n",
        "        circle.shift(1.5 * DOWN)\n",
        "        center = circle.get_center()\n",
        "        center_dot = Dot(center)\n",
        "        radius = Line(center, circle.get_right())\n",
        "        radius.set_stroke(WHITE, 3)\n",
        "\n",
        "        arrow = DoubleArrow(primes, circle)\n",
        "        arrow.tip[1].shift(SMALL_BUFF * UP)\n",
        "        arrow.save_state()\n",
        "        arrow.rotate(90 * DEGREES)\n",
        "        arrow.scale(1.5)\n",
        "        arrow.fade(1)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{\\\\pi^2}{6} = \\\\prod_{p \\\\text{ prime}}\"\n",
        "            \"\\\\frac{1}{1 - p^{-2}}\"\n",
        "        )\n",
        "        formula.next_to(arrow.get_center(), RIGHT)\n",
        "\n",
        "        def get_arc():\n",
        "            angle = radius.get_angle()\n",
        "            return Arc(\n",
        "                start_angle=0,\n",
        "                angle=angle,\n",
        "                radius=circle.radius,\n",
        "                stroke_color=YELLOW,\n",
        "                stroke_width=5\n",
        "            ).shift(center)\n",
        "\n",
        "        arc = always_redraw(get_arc)\n",
        "\n",
        "        decimal = DecimalNumber(0)\n",
        "        decimal.add_updater(\n",
        "            lambda d: d.move_to(interpolate(\n",
        "                radius.get_start(),\n",
        "                radius.get_end(),\n",
        "                1.5,\n",
        "            )),\n",
        "        )\n",
        "        decimal.add_updater(\n",
        "            lambda d: d.set_value(radius.get_angle())\n",
        "        )\n",
        "        pi = OldTex(\"\\\\pi\")\n",
        "        pi.scale(2)\n",
        "        pi.next_to(circle, LEFT)\n",
        "\n",
        "        self.add(circle, radius, center_dot, decimal, arc)\n",
        "        self.play(\n",
        "            Rotate(radius, PI - 1e-7, about_point=center),\n",
        "            LaggedStartMap(FadeInFromDown, primes),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.remove(decimal)\n",
        "        self.add(pi)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(arrow),\n",
        "            FadeIn(formula, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MapOfVideo(MovingCameraScene):\n",
        "    def construct(self):\n",
        "        images = Group(\n",
        "            ImageMobject(\"NecklaceThumbnail\"),\n",
        "            ImageMobject(\"BorsukUlamThumbnail\"),\n",
        "            ImageMobject(\"TopologyProofThumbnail\"),\n",
        "            ImageMobject(\"ContinuousNecklaceThumbnail\"),\n",
        "            ImageMobject(\"NecklaceSphereAssociationThumbnail\")\n",
        "        )\n",
        "        for image in images:\n",
        "            rect = SurroundingRectangle(image, buff=0)\n",
        "            rect.set_stroke(WHITE, 3)\n",
        "            image.add(rect)\n",
        "\n",
        "        image_line = Group(*images[:2], *images[3:])\n",
        "        image_line.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        images[2].next_to(image_line, DOWN, buff=1.5)\n",
        "        images.set_width(FRAME_WIDTH - 1)\n",
        "        images.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Arrow(images[0], images[1], buff=SMALL_BUFF),\n",
        "            Arrow(\n",
        "                images[1].get_corner(DR) + 0.5 * LEFT,\n",
        "                images[2].get_top() + 0.5 * LEFT,\n",
        "            ),\n",
        "            Arrow(\n",
        "                images[2].get_top() + 0.5 * RIGHT,\n",
        "                images[3].get_corner(DL) + 0.5 * RIGHT,\n",
        "            ),\n",
        "            Arrow(images[3], images[4], buff=SMALL_BUFF),\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, images, run_time=4))\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows))\n",
        "        self.wait()\n",
        "        group = Group(images, arrows)\n",
        "        for image in images:\n",
        "            group.save_state()\n",
        "            group.generate_target()\n",
        "            group.target.shift(-image.get_center())\n",
        "            group.target.scale(\n",
        "                FRAME_WIDTH / image.get_width(),\n",
        "                about_point=ORIGIN,\n",
        "            )\n",
        "\n",
        "            self.play(MoveToTarget(group, run_time=3))\n",
        "            self.wait()\n",
        "            self.play(Restore(group, run_time=3))\n",
        "\n",
        "    def get_curved_arrow(self, *points):\n",
        "        line = VMobject()\n",
        "        line.set_points(points)\n",
        "        tip = Arrow(points[-2], points[-1], buff=SMALL_BUFF).tip\n",
        "        line.pointwise_become_partial(line, 0, 0.9)\n",
        "        line.add(tip)\n",
        "        return line\n",
        "\n",
        "\n",
        "class MathIsDeep(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Math\", \"is\", \"deep\"\n",
        "        )\n",
        "        words.scale(2)\n",
        "        words.to_edge(UP)\n",
        "        math = words[0].copy()\n",
        "        math[1].remove(math[1][1])\n",
        "        math.set_fill(opacity=0)\n",
        "        math.set_stroke(width=0, background=True)\n",
        "        numbers = [13, 1, 20, 8]\n",
        "        num_mobs = VGroup(*[Integer(d) for d in numbers])\n",
        "        num_mobs.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        num_mobs.next_to(math, DOWN, buff=1.5)\n",
        "        num_mobs.set_color(YELLOW)\n",
        "        top_arrows = VGroup(*[\n",
        "            Arrow(c.get_bottom(), n.get_top())\n",
        "            for c, n in zip(math, num_mobs)\n",
        "        ])\n",
        "        n_sum = Integer(sum(numbers))\n",
        "        n_sum.scale(1.5)\n",
        "        n_sum.next_to(num_mobs, DOWN, buff=1.5)\n",
        "        low_arrows = VGroup(*[\n",
        "            Arrow(n.get_bottom(), n_sum.get_top())\n",
        "            for n in num_mobs\n",
        "        ])\n",
        "        VGroup(top_arrows, low_arrows).set_color(WHITE)\n",
        "\n",
        "        n_sum_border = n_sum.deepcopy()\n",
        "        n_sum_border.set_fill(opacity=0)\n",
        "        n_sum_border.set_stroke(YELLOW, width=1)\n",
        "        n_sum_border.set_stroke(width=0, background=True)\n",
        "\n",
        "        # pre_num_mobs = num_mobs.copy()\n",
        "        # for pn, letter in zip(pre_num_mobs, math):\n",
        "        #     pn.fade(1)\n",
        "        #     pn.set_color(RED)\n",
        "        #     pn.move_to(letter)\n",
        "        # num_mobs[1].add_subpath(num_mobs[1].get_points())\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, words,\n",
        "                scale_factor=1.5,\n",
        "                run_time=0.6,\n",
        "                lag_ratio=0.6,\n",
        "            ),\n",
        "            self.pi_creature.change, \"pondering\"\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(math, num_mobs),\n",
        "            *map(GrowArrow, top_arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(num_mobs, VGroup(n_sum)),\n",
        "            self.pi_creature.change, \"thinking\",\n",
        "            *map(GrowArrow, low_arrows),\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreationThenDestruction, n_sum_border))\n",
        "        self.play(Blink(self.pi_creature))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MinimizeSharding(Scene):\n",
        "    def construct(self):\n",
        "        piece_groups = VGroup(*[\n",
        "            VGroup(*[\n",
        "                self.get_piece()\n",
        "                for x in range(3)\n",
        "            ]).arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            for y in range(4)\n",
        "        ]).arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(piece_groups)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.space_out_submobjects, 0.7)\n",
        "            for mob in piece_groups\n",
        "        ])\n",
        "        self.wait()\n",
        "        group1 = piece_groups[:2]\n",
        "        group2 = piece_groups[2:]\n",
        "        self.play(\n",
        "            group1.arrange, DOWN,\n",
        "            group1.next_to, ORIGIN, LEFT, LARGE_BUFF,\n",
        "            group2.arrange, DOWN,\n",
        "            group2.next_to, ORIGIN, RIGHT, LARGE_BUFF,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_piece(self):\n",
        "        jagged_spots = [\n",
        "            ORIGIN, 2 * UP + RIGHT, 4 * UP + LEFT, 6 * UP,\n",
        "        ]\n",
        "        corners = list(it.chain(\n",
        "            jagged_spots,\n",
        "            [6 * UP + 10 * RIGHT],\n",
        "            [\n",
        "                p + 10 * RIGHT\n",
        "                for p in reversed(jagged_spots)\n",
        "            ],\n",
        "            [ORIGIN]\n",
        "        ))\n",
        "        piece = VMobject().set_points_as_corners(corners)\n",
        "        piece.set_width(1)\n",
        "        piece.center()\n",
        "        piece.set_stroke(WHITE, width=0.5)\n",
        "        piece.set_fill(BLUE, opacity=1)\n",
        "        return piece\n",
        "\n",
        "\n",
        "class Antipodes(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"``Antipodes''\")\n",
        "        word.set_width(FRAME_WIDTH - 1)\n",
        "        word.set_color(MAROON_B)\n",
        "        self.play(Write(word))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TopologyWordBreak(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"Topology\")\n",
        "        word.scale(2)\n",
        "        colors = [BLUE, YELLOW, RED]\n",
        "        classes = VGroup(*[VGroup() for x in range(3)])\n",
        "        for letter in word:\n",
        "            genus = len(letter.submobjects)\n",
        "            letter.target_color = colors[genus]\n",
        "            letter.generate_target()\n",
        "            letter.target.set_color(colors[genus])\n",
        "            classes[genus].add(letter.target)\n",
        "        signs = VGroup()\n",
        "        for group in classes:\n",
        "            new_group = VGroup()\n",
        "            for elem in group[:-1]:\n",
        "                new_group.add(elem)\n",
        "                sign = OldTex(\"\\\\simeq\")\n",
        "                new_group.add(sign)\n",
        "                signs.add(sign)\n",
        "            new_group.add(group[-1])\n",
        "            group.submobjects = list(new_group.submobjects)\n",
        "            group.arrange(RIGHT)\n",
        "\n",
        "        word[2].target.shift(0.1 * DOWN)\n",
        "        word[7].target.shift(0.1 * DOWN)\n",
        "\n",
        "        classes.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        classes.shift(2 * RIGHT)\n",
        "\n",
        "        genus_labels = VGroup(*[\n",
        "            OldTexText(\"Genus %d:\" % d).scale(1.5).next_to(\n",
        "                classes[d], LEFT, MED_LARGE_BUFF\n",
        "            )\n",
        "            for d in range(3)\n",
        "        ])\n",
        "        genus_labels.shift(SMALL_BUFF * UP)\n",
        "\n",
        "        self.play(Write(word))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, word,\n",
        "            lambda m: (m.set_color, m.target_color),\n",
        "            run_time=1\n",
        "        ))\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, word),\n",
        "            LaggedStartMap(FadeIn, signs),\n",
        "            LaggedStartMap(FadeInFromDown, genus_labels),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class TopologyProofLand(GeometryProofLand):\n",
        "    CONFIG = {\n",
        "        \"text\": \"Topology proof land\"\n",
        "    }\n",
        "\n",
        "\n",
        "class GreenLine(Scene):\n",
        "    def construct(self):\n",
        "        self.add(Line(LEFT, RIGHT, color=GREEN))\n",
        "\n",
        "\n",
        "class Thief(Scene):\n",
        "    def construct(self):\n",
        "        self.play(Write(OldTexText(\"Thief\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FunctionGInSymbols(Scene):\n",
        "    def construct(self):\n",
        "        p_tex = \"\\\\vec{\\\\textbf{p}}\"\n",
        "        neg_p_tex = \"-\\\\vec{\\\\textbf{p}}\"\n",
        "\n",
        "        def color_tex(tex_mob):\n",
        "            pairs = [\n",
        "                (p_tex, YELLOW),\n",
        "                (neg_p_tex, RED),\n",
        "                (\"{g}\", GREEN),\n",
        "            ]\n",
        "            for tex, color in pairs:\n",
        "                tex_mob.set_color_by_tex(\n",
        "                    tex, color, substring=False\n",
        "                )\n",
        "\n",
        "        f_of_p = OldTex(\"f\", \"(\", p_tex, \")\")\n",
        "        f_of_p.shift(2.5 * LEFT + 2.5 * UP)\n",
        "        f_of_neg_p = OldTex(\"f\", \"(\", neg_p_tex, \")\")\n",
        "        g_of_p = OldTex(\"g\", \"(\", p_tex, \")\")\n",
        "        g_of_p[0].set_color(YELLOW)\n",
        "        for mob in f_of_p, f_of_neg_p, g_of_p:\n",
        "            color_tex(mob)\n",
        "        dec_rhs = DecimalMatrix([[-0.9], [0.5]])\n",
        "        dec_rhs.next_to(f_of_p, RIGHT)\n",
        "        minus = OldTex(\"-\")\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(f_of_p, RIGHT)\n",
        "        zero_zero = IntegerMatrix([[0], [0]])\n",
        "\n",
        "        for matrix in dec_rhs, zero_zero:\n",
        "            matrix.space_out_submobjects(0.8)\n",
        "            matrix.brackets.scale(0.9)\n",
        "            matrix.next_to(equals, RIGHT)\n",
        "\n",
        "        f_of_neg_p.next_to(equals, RIGHT)\n",
        "\n",
        "        f = f_of_p.get_part_by_tex(\"f\")\n",
        "        p = f_of_p.get_part_by_tex(p_tex)\n",
        "        f_brace = Brace(f, UP, buff=SMALL_BUFF)\n",
        "        f_brace.add(f_brace.get_text(\"Continuous function\"))\n",
        "        p_brace = Brace(p, DOWN, buff=SMALL_BUFF)\n",
        "        p_brace.add(p_brace.get_text(\"Sphere point\").match_color(p))\n",
        "\n",
        "        f_of_p.save_state()\n",
        "        f_of_p.space_out_submobjects(2)\n",
        "        f_of_p.scale(2)\n",
        "        f_of_p.fade(1)\n",
        "\n",
        "        self.play(f_of_p.restore)\n",
        "        self.play(GrowFromCenter(f_brace))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(p_brace))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(equals),\n",
        "            Write(dec_rhs),\n",
        "            FadeOut(f_brace),\n",
        "            FadeOut(p_brace),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(WiggleOutThenIn(f))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dec_rhs, DOWN),\n",
        "            FadeInFromDown(f_of_neg_p)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Rearrange\n",
        "        f_of_neg_p.generate_target()\n",
        "        f_of_p.generate_target()\n",
        "        group = VGroup(f_of_p.target, minus, f_of_neg_p.target)\n",
        "        group.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        group.next_to(equals, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(f_of_p, path_arc=PI),\n",
        "            MoveToTarget(f_of_neg_p, path_arc=-PI),\n",
        "            FadeInFromLarge(minus),\n",
        "            FadeIn(zero_zero, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Define g\n",
        "        def_eq = OldTex(\":=\")\n",
        "        def_eq.next_to(f_of_p, LEFT)\n",
        "        g_of_p.next_to(def_eq, LEFT)\n",
        "        rect = SurroundingRectangle(VGroup(g_of_p, f_of_neg_p))\n",
        "        rect.set_stroke(width=1)\n",
        "        seeking_text = OldTex(\n",
        "            \"\\\\text{Looking for }\", p_tex, \"\\\\text{ where}\"\n",
        "        )\n",
        "        color_tex(seeking_text)\n",
        "        seeking_text.next_to(zero_zero, DOWN, MED_LARGE_BUFF)\n",
        "        seeking_text.to_edge(LEFT)\n",
        "        g_equals_zero = VGroup(\n",
        "            g_of_p.copy(), equals, zero_zero\n",
        "        )\n",
        "        g_equals_zero.generate_target()\n",
        "        g_equals_zero.target.arrange(RIGHT, SMALL_BUFF)\n",
        "        g_equals_zero.target.next_to(seeking_text, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromLarge(g_of_p),\n",
        "            FadeIn(def_eq, LEFT)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(seeking_text),\n",
        "            MoveToTarget(g_equals_zero)\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "        # Show g is odd\n",
        "        g_of_neg_p = OldTex(\"{g}\", \"(\", neg_p_tex, \")\")\n",
        "        eq2 = OldTex(\"=\")\n",
        "        rhs = OldTex(\n",
        "            \"f\", \"(\", neg_p_tex, \")\", \"-\",\n",
        "            \"f\", \"(\", p_tex, \")\", \"=\",\n",
        "            \"-\", \"{g}\", \"(\", p_tex, \")\",\n",
        "        )\n",
        "        for mob in g_of_neg_p, rhs:\n",
        "            color_tex(mob)\n",
        "        g_of_neg_p.next_to(g_of_p, DOWN, aligned_edge=LEFT, buff=LARGE_BUFF)\n",
        "        eq2.next_to(g_of_neg_p, RIGHT, SMALL_BUFF)\n",
        "        rhs.next_to(eq2, RIGHT, SMALL_BUFF)\n",
        "        neg_g_of_p = rhs[-5:]\n",
        "        neg_g_of_p.save_state()\n",
        "        neg_g_of_p.next_to(eq2, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(g_of_neg_p),\n",
        "            FadeIn(eq2),\n",
        "            FadeIn(neg_g_of_p),\n",
        "            VGroup(seeking_text, g_equals_zero).shift, 1.5 * DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(g_of_neg_p[2]))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(neg_g_of_p))\n",
        "        self.wait()\n",
        "        self.play(neg_g_of_p.restore)\n",
        "        rects = VGroup(*map(SurroundingRectangle, [f_of_p, f_of_neg_p]))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, rects,\n",
        "            lag_ratio=0.8\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(f_of_p, rhs[5:9]),\n",
        "            TransformFromCopy(f_of_neg_p, rhs[:4]),\n",
        "            FadeIn(rhs[4]),\n",
        "            FadeIn(rhs[-6]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FunctionGInputSpace(SpecialThreeDScene):\n",
        "    def setup(self):\n",
        "        self.init_tracked_point()\n",
        "\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.set_fill(BLUE_E, opacity=0.5)\n",
        "        self.sphere = sphere\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-120 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.02)\n",
        "\n",
        "        self.init_dot()\n",
        "\n",
        "        self.add(ThreeDAxes())\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_input_dot()\n",
        "        self.show_start_path()\n",
        "        self.show_antipodal_point()\n",
        "        self.show_equator()\n",
        "        self.deform_towards_north_pole()\n",
        "\n",
        "    def show_input_dot(self):\n",
        "        sphere = self.sphere\n",
        "        dot = self.dot\n",
        "        point_mob = self.tracked_point\n",
        "        start_point = self.get_start_point()\n",
        "\n",
        "        arrow = Arrow(\n",
        "            start_point + (LEFT + OUT + UP), start_point,\n",
        "            color=BLUE,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "        )\n",
        "        arrow.rotate(90 * DEGREES, axis=arrow.get_vector())\n",
        "        arrow.add_to_back(arrow.copy().set_stroke(BLACK, 5))\n",
        "\n",
        "        p_label = self.p_label = OldTex(\"\\\\vec{\\\\textbf{p}}\")\n",
        "        p_label.set_color(YELLOW)\n",
        "        p_label.next_to(arrow.get_start(), OUT, buff=0.3)\n",
        "        p_label.set_shade_in_3d(True)\n",
        "\n",
        "        self.play(Write(sphere, run_time=3))\n",
        "        self.add(dot)\n",
        "        self.add_fixed_orientation_mobjects(p_label)\n",
        "        self.play(\n",
        "            point_mob.move_to, start_point,\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(p_label, IN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            arrow.scale, 0, {\"about_point\": arrow.get_end()},\n",
        "            p_label.next_to, dot, OUT + LEFT, SMALL_BUFF\n",
        "        )\n",
        "        p_label.add_updater(lambda p: p.next_to(dot, OUT + LEFT, SMALL_BUFF))\n",
        "        self.wait(4)\n",
        "\n",
        "    def show_start_path(self):\n",
        "        path = self.get_start_path()\n",
        "        self.draw_path(path, uncreate=True)\n",
        "        self.wait()\n",
        "\n",
        "    def show_antipodal_point(self):\n",
        "        path = self.get_antipodal_path()\n",
        "        end_dot = always_redraw(\n",
        "            lambda: self.get_dot(\n",
        "                path[-1].point_from_proportion(1)\n",
        "            ).set_color(RED)\n",
        "        )\n",
        "\n",
        "        neg_p = OldTex(\"-\\\\vec{\\\\textbf{p}}\")\n",
        "        neg_p.add_updater(\n",
        "            lambda p: p.next_to(end_dot, UP + RIGHT + IN)\n",
        "        )\n",
        "        neg_p.set_color(RED)\n",
        "        neg_p.set_shade_in_3d(True)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=100 * DEGREES,\n",
        "            theta=30 * DEGREES,\n",
        "            added_anims=[ShowCreation(path)],\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_fixed_orientation_mobjects(neg_p)\n",
        "        self.play(\n",
        "            FadeInFromLarge(end_dot),\n",
        "            Write(neg_p)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-120 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(7)\n",
        "        # Flip\n",
        "        self.move_camera(\n",
        "            phi=100 * DEGREES,\n",
        "            theta=30 * DEGREES,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(7)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-120 * DEGREES,\n",
        "            added_anims=[\n",
        "                FadeOut(end_dot),\n",
        "                FadeOut(neg_p),\n",
        "                FadeOut(path),\n",
        "            ],\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "    def show_equator(self):\n",
        "        point_mob = self.tracked_point\n",
        "        equator = self.get_lat_line()\n",
        "\n",
        "        self.play(point_mob.move_to, equator[0].point_from_proportion(0))\n",
        "        self.play(ShowCreation(equator, run_time=4))\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                Rotate(point_mob, PI, about_point=ORIGIN, axis=OUT),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(self.dot),\n",
        "            FadeOut(self.p_label),\n",
        "        )\n",
        "\n",
        "        self.equator = equator\n",
        "\n",
        "    def deform_towards_north_pole(self):\n",
        "        equator = self.equator\n",
        "\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            equator,\n",
        "            lambda m, a: m.become(self.get_lat_line(a * PI / 2)),\n",
        "            run_time=16\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def init_tracked_point(self):\n",
        "        self.tracked_point = VectorizedPoint([0, 0, 2])\n",
        "        self.tracked_point.add_updater(\n",
        "            lambda p: p.move_to(2 * normalize(p.get_center()))\n",
        "        )\n",
        "        self.add(self.tracked_point)\n",
        "\n",
        "    def init_dot(self):\n",
        "        self.dot = always_redraw(\n",
        "            lambda: self.get_dot(self.tracked_point.get_center())\n",
        "        )\n",
        "\n",
        "    def get_start_path(self):\n",
        "        path = ParametricCurve(\n",
        "            lambda t: np.array([\n",
        "                -np.sin(TAU * t + TAU / 4),\n",
        "                np.cos(2 * TAU * t + TAU / 4),\n",
        "                0\n",
        "            ]),\n",
        "            color=RED\n",
        "        )\n",
        "        path.scale(0.5)\n",
        "        path.shift(0.5 * OUT)\n",
        "        path.rotate(60 * DEGREES, RIGHT, about_point=ORIGIN)\n",
        "        path.shift(\n",
        "            self.get_start_point() - path.point_from_proportion(0)\n",
        "        )\n",
        "        path.apply_function(lambda p: 2 * normalize(p))\n",
        "        return path\n",
        "\n",
        "    def get_antipodal_path(self):\n",
        "        start = self.get_start_point()\n",
        "        path = ParametricCurve(\n",
        "            lambda t: 2.03 * np.array([\n",
        "                0,\n",
        "                np.sin(PI * t),\n",
        "                np.cos(PI * t),\n",
        "            ]),\n",
        "            color=YELLOW\n",
        "        )\n",
        "        path.apply_matrix(z_to_vector(start))\n",
        "\n",
        "        dashed_path = DashedVMobject(path)\n",
        "        dashed_path.set_shade_in_3d(True)\n",
        "\n",
        "        return dashed_path\n",
        "\n",
        "    def get_lat_line(self, lat=0):\n",
        "        equator = ParametricCurve(lambda t: 2.03 * np.array([\n",
        "            np.cos(lat) * np.sin(TAU * t),\n",
        "            np.cos(lat) * (-np.cos(TAU * t)),\n",
        "            np.sin(lat)\n",
        "        ]))\n",
        "        equator.rotate(-90 * DEGREES)\n",
        "        dashed_equator = DashedVMobject(\n",
        "            equator,\n",
        "            num_dashes=40,\n",
        "            color=RED,\n",
        "        )\n",
        "        dashed_equator.set_shade_in_3d(True)\n",
        "        return dashed_equator\n",
        "\n",
        "    def draw_path(self, path,\n",
        "                  run_time=4,\n",
        "                  dot_follow=True,\n",
        "                  uncreate=False,\n",
        "                  added_anims=None\n",
        "                  ):\n",
        "        added_anims = added_anims or []\n",
        "        point_mob = self.tracked_point\n",
        "        anims = [ShowCreation(path)]\n",
        "        if dot_follow:\n",
        "            anims.append(UpdateFromFunc(\n",
        "                point_mob,\n",
        "                lambda p: p.move_to(path.point_from_proportion(1))\n",
        "            ))\n",
        "        self.add(path, self.dot)\n",
        "        self.play(*anims, run_time=run_time)\n",
        "\n",
        "        if uncreate:\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                Uncreate(path),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "    def modify_path(self, path):\n",
        "        return path\n",
        "\n",
        "    def get_start_point(self):\n",
        "        return 2 * normalize([-1, -1, 1])\n",
        "\n",
        "    def get_dot(self, point):\n",
        "        dot = Dot(color=WHITE)\n",
        "        dot.shift(2.05 * OUT)\n",
        "        dot.apply_matrix(z_to_vector(normalize(point)))\n",
        "        dot.set_shade_in_3d(True)\n",
        "        return dot\n",
        "\n",
        "\n",
        "class FunctionGOutputSpace(FunctionGInputSpace):\n",
        "    def construct(self):\n",
        "        self.show_input_dot()\n",
        "        self.show_start_path()\n",
        "        self.show_antipodal_point()\n",
        "        self.show_equator()\n",
        "        self.deform_towards_north_pole()\n",
        "\n",
        "    def setup(self):\n",
        "        axes = self.axes = Axes(\n",
        "            x_min=-2.5,\n",
        "            x_max=2.5,\n",
        "            y_min=-2.5,\n",
        "            y_max=2.5,\n",
        "            axis_config={'unit_size': 1.5}\n",
        "        )\n",
        "        for axis in axes:\n",
        "            numbers = list(range(-2, 3))\n",
        "            numbers.remove(0)\n",
        "            axis.add_numbers(*numbers)\n",
        "\n",
        "        self.init_tracked_point()\n",
        "        self.init_dot()\n",
        "\n",
        "    def show_input_dot(self):\n",
        "        axes = self.axes\n",
        "        dot = self.dot\n",
        "        point_mob = self.tracked_point\n",
        "\n",
        "        point_mob.move_to(self.get_start_point())\n",
        "        self.add(dot)\n",
        "        self.update_mobjects(0)\n",
        "        self.remove(dot)\n",
        "\n",
        "        p_tex = \"\\\\vec{\\\\textbf{p}}\"\n",
        "        fp_label = self.fp_label = OldTex(\"f(\", p_tex, \")\")\n",
        "        fp_label.set_color_by_tex(p_tex, YELLOW)\n",
        "\n",
        "        self.play(Write(axes, run_time=3))\n",
        "        self.wait(3)\n",
        "        dc = dot.copy()\n",
        "        self.play(\n",
        "            FadeIn(dc, 2 * UP, remover=True),\n",
        "            UpdateFromFunc(fp_label, lambda fp: fp.next_to(dc, UL, SMALL_BUFF))\n",
        "        )\n",
        "        self.add(dot)\n",
        "        fp_label.add_updater(\n",
        "            lambda fp: fp.next_to(dot, UL, SMALL_BUFF)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def draw_path(self, path,\n",
        "                  run_time=4,\n",
        "                  dot_follow=True,\n",
        "                  uncreate=False,\n",
        "                  added_anims=None\n",
        "                  ):\n",
        "        added_anims = added_anims or []\n",
        "        point_mob = self.tracked_point\n",
        "        shadow_path = path.deepcopy().fade(1)\n",
        "        flat_path = self.modify_path(path)\n",
        "        anims = [\n",
        "            ShowCreation(flat_path),\n",
        "            ShowCreation(shadow_path),\n",
        "        ]\n",
        "        if dot_follow:\n",
        "            anims.append(UpdateFromFunc(\n",
        "                point_mob,\n",
        "                lambda p: p.move_to(shadow_path.point_from_proportion(1))\n",
        "            ))\n",
        "        self.add(flat_path, self.dot)\n",
        "        self.play(*anims, run_time=run_time)\n",
        "\n",
        "        if uncreate:\n",
        "            self.wait()\n",
        "            self.remove(shadow_path)\n",
        "            self.play(\n",
        "                Uncreate(flat_path),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "    def show_antipodal_point(self):\n",
        "        dot = self.dot\n",
        "        pre_path = VMobject().set_points_smoothly([\n",
        "            ORIGIN, DOWN, DOWN + 2 * RIGHT,\n",
        "            3 * RIGHT + 0.5 * UP, 0.5 * RIGHT, ORIGIN\n",
        "        ])\n",
        "        pre_path.rotate(-45 * DEGREES, about_point=ORIGIN)\n",
        "        pre_path.shift(dot.get_center())\n",
        "        path = DashedVMobject(pre_path)\n",
        "\n",
        "        fp_label = self.fp_label\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(fp_label, RIGHT, SMALL_BUFF)\n",
        "        f_neg_p = OldTex(\"f(\", \"-\\\\vec{\\\\textbf{p}}\", \")\")\n",
        "        f_neg_p[1].set_color(RED)\n",
        "        f_neg_p.next_to(equals, RIGHT)\n",
        "\n",
        "        gp_label = OldTex(\"g\", \"(\", \"\\\\vec{\\\\textbf{p}}\", \")\")\n",
        "        gp_label[0].set_color(GREEN)\n",
        "        gp_label[2].set_color(YELLOW)\n",
        "        gp_label.add_updater(lambda m: m.next_to(dot, UL, SMALL_BUFF))\n",
        "        self.gp_label = gp_label\n",
        "        # gp_label.next_to(Dot(ORIGIN), UL, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(path, run_time=4))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(f_neg_p),\n",
        "        )\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            FadeOut(VGroup(path, equals, f_neg_p))\n",
        "        )\n",
        "        dot.clear_updaters()\n",
        "        self.add(fp_label, gp_label)\n",
        "        gp_label.set_background_stroke(width=0)\n",
        "        self.play(\n",
        "            dot.move_to, ORIGIN,\n",
        "            VFadeOut(fp_label),\n",
        "            VFadeIn(gp_label),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            dot.move_to, self.odd_func(self.get_start_point())\n",
        "        )\n",
        "        # Flip, 2 second for flip, 7 seconds after\n",
        "        path = self.get_antipodal_path()\n",
        "        path.apply_function(self.odd_func)\n",
        "        end_dot = Dot(color=RED)\n",
        "        end_dot.move_to(path[-1].point_from_proportion(1))\n",
        "        g_neg_p = OldTex(\n",
        "            \"g\", \"(\", \"-\\\\vec{\\\\textbf{p}}\", \")\"\n",
        "        )\n",
        "        g_neg_p[0].set_color(GREEN)\n",
        "        g_neg_p[2].set_color(RED)\n",
        "        g_neg_p.next_to(end_dot, UR, SMALL_BUFF)\n",
        "        reflection_line = DashedLine(\n",
        "            dot.get_center(), end_dot.get_center(),\n",
        "            stroke_width=0,\n",
        "        )\n",
        "        vector = Vector(dot.get_center())\n",
        "\n",
        "        self.play(ShowCreation(path, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(reflection_line, run_time=2),\n",
        "            TransformFromCopy(dot, end_dot),\n",
        "            ReplacementTransform(\n",
        "                gp_label.deepcopy().clear_updaters(), g_neg_p\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(vector))\n",
        "        self.play(Rotate(vector, angle=PI, about_point=ORIGIN))\n",
        "        self.play(FadeOut(vector))\n",
        "        self.play(\n",
        "            FadeOut(end_dot),\n",
        "            FadeOut(g_neg_p),\n",
        "            FadeOut(path),\n",
        "        )\n",
        "\n",
        "    def show_equator(self):\n",
        "        dot = self.dot\n",
        "        point_mob = self.tracked_point\n",
        "        equator = self.get_lat_line()\n",
        "        flat_eq = equator.deepcopy().apply_function(self.odd_func)\n",
        "        equator.fade(1)\n",
        "\n",
        "        equator_start = equator[0].point_from_proportion(0)\n",
        "\n",
        "        # To address\n",
        "        self.play(\n",
        "            point_mob.move_to, equator_start,\n",
        "            dot.move_to, self.odd_func(equator_start)\n",
        "        )\n",
        "        dot.add_updater(lambda m: m.move_to(\n",
        "            self.odd_func(point_mob.get_center())\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(equator),\n",
        "            ShowCreation(flat_eq),\n",
        "            run_time=4,\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                Rotate(point_mob, PI, about_point=ORIGIN, axis=OUT),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(self.dot),\n",
        "            FadeOut(self.gp_label),\n",
        "        )\n",
        "\n",
        "        self.equator = equator\n",
        "        self.flat_eq = flat_eq\n",
        "\n",
        "    def deform_towards_north_pole(self):\n",
        "        equator = self.equator\n",
        "        flat_eq = self.flat_eq\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                equator,\n",
        "                lambda m, a: m.become(self.get_lat_line(a * PI / 2)).set_stroke(width=0),\n",
        "                run_time=16\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                flat_eq,\n",
        "                lambda m: m.become(\n",
        "                    equator.deepcopy().apply_function(self.odd_func).set_stroke(\n",
        "                        color=RED, width=3\n",
        "                    )\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "    #\n",
        "\n",
        "    def func(self, point):\n",
        "        x, y, z = point\n",
        "        return 0.5 * self.axes.coords_to_point(\n",
        "            2 * x + 0.5 * y + z,\n",
        "            2 * y - 0.5 * np.sin(PI * x) + z**2 + 1 - x,\n",
        "        )\n",
        "\n",
        "    def odd_func(self, point):\n",
        "        return (self.func(point) - self.func(-point)) / 2\n",
        "\n",
        "    def get_dot(self, point):\n",
        "        return Dot(self.func(point))\n",
        "\n",
        "    def modify_path(self, path):\n",
        "        path.apply_function(self.func)\n",
        "        return path\n",
        "\n",
        "\n",
        "class RotationOfEquatorGraphInOuputSpace(FunctionGOutputSpace):\n",
        "    def construct(self):\n",
        "        self.add(self.axes)\n",
        "        equator = self.get_lat_line(0)\n",
        "        equator.remove(*equator[len(equator) // 2:])\n",
        "\n",
        "        flat_eq = equator.copy().apply_function(self.odd_func)\n",
        "        vector = Vector(flat_eq[0].point_from_proportion(0))\n",
        "        vector_copy = vector.copy().fade(0.5)\n",
        "\n",
        "        self.add(flat_eq)\n",
        "        self.add(flat_eq.copy())\n",
        "        self.wait()\n",
        "        self.play(FadeIn(vector))\n",
        "        self.add(vector_copy)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                VGroup(flat_eq, vector),\n",
        "                PI, about_point=ORIGIN, run_time=5\n",
        "        ))\n",
        "        self.play(FadeOut(vector), FadeOut(vector_copy))\n",
        "\n",
        "\n",
        "class WriteInputSpace(Scene):\n",
        "    def construct(self):\n",
        "        self.play(Write(OldTexText(\"Input space\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WriteOutputSpace(Scene):\n",
        "    def construct(self):\n",
        "        self.play(Write(OldTexText(\"Output space\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LineScene(Scene):\n",
        "    def construct(self):\n",
        "        self.add(DashedLine(5 * LEFT, 5 * RIGHT, color=WHITE))\n",
        "\n",
        "\n",
        "class ShowFlash(Scene):\n",
        "    def construct(self):\n",
        "        dot = Dot(ORIGIN, color=YELLOW)\n",
        "        dot.set_stroke(width=0)\n",
        "        dot.set_fill(opacity=0)\n",
        "        self.play(Flash(dot, flash_radius=0.8, line_length=0.6, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WaitForIt(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Wait for it\", \"$\\\\dots$\", arg_separator=\"\")\n",
        "        words.scale(2)\n",
        "        self.add(words[0])\n",
        "        self.play(Write(words[1], run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DrawSphere(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.shift(IN)\n",
        "        question = OldTexText(\"What \\\\emph{is} a sphere?\")\n",
        "        question.set_width(FRAME_WIDTH - 3)\n",
        "        question.to_edge(UP)\n",
        "        self.move_camera(phi=70 * DEGREES, run_time=0)\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.add_fixed_in_frame_mobjects(question)\n",
        "        self.play(\n",
        "            Write(sphere),\n",
        "            FadeInFromDown(question)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class DivisionOfUnity(Scene):\n",
        "    def construct(self):\n",
        "        factor = 2\n",
        "        line = Line(factor * LEFT, factor * RIGHT)\n",
        "        lower_brace = Brace(line, DOWN)\n",
        "        lower_brace.add(lower_brace.get_text(\"1\"))\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(0.2 * UP, 0.2 * DOWN).shift(factor * v)\n",
        "            for v in [LEFT, 0.3 * LEFT, 0.1 * RIGHT, RIGHT]\n",
        "        ])\n",
        "        upper_braces = VGroup(*[\n",
        "            Brace(VGroup(vl1, vl2), UP)\n",
        "            for vl1, vl2 in zip(v_lines[:-1], v_lines[1:])\n",
        "        ])\n",
        "        colors = color_gradient([GREEN, BLUE], 3)\n",
        "        for i, color, brace in zip(it.count(1), colors, upper_braces):\n",
        "            label = brace.get_tex(\"x_%d^2\" % i)\n",
        "            label.set_color(color)\n",
        "            brace.add(label)\n",
        "\n",
        "        self.add(line, lower_brace)\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, v_lines[1:3],\n",
        "            lag_ratio=0.8,\n",
        "            run_time=1\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            GrowFromCenter, upper_braces\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeDSpace(ThreeDScene):\n",
        "    def construct(self):\n",
        "        axes = ThreeDAxes()\n",
        "        self.add(axes)\n",
        "        self.set_camera_orientation(phi=70 * DEGREES, theta=-130 * DEGREES)\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "        density = 1\n",
        "        radius = 3\n",
        "        lines = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Line(\n",
        "                    radius * IN, radius * OUT,\n",
        "                    stroke_color=WHITE,\n",
        "                    stroke_width=1,\n",
        "                    stroke_opacity=0.5,\n",
        "                ).shift(x * RIGHT + y * UP)\n",
        "                for x in np.arange(-radius, radius + density, density)\n",
        "                for y in np.arange(-radius, radius + density, density)\n",
        "            ]).rotate(n * 120 * DEGREES, axis=[1, 1, 1])\n",
        "            for n in range(3)\n",
        "        ])\n",
        "\n",
        "        self.play(Write(lines))\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class NecklaceSphereConnectionTitle(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Necklace Sphere Association\")\n",
        "        text.set_width(FRAME_WIDTH - 1)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class BorsukEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Ali Yahya\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Crypticswarm\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Shelby Doolittle\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek Dai\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Guido Gambardella\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mark Govea\",\n",
        "            \"Vecht \",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk Werklund\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Felipe Diniz\",\n",
        "        ],\n",
        "        \"n_patron_columns\": 2,\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        sphere = ParametricSurface(\n",
        "            func=lambda u, v: 2 * np.array([\n",
        "                np.cos(v) * np.sin(u) + 0.2 * np.cos(3 * u),\n",
        "                np.sin(v) * np.sin(u),\n",
        "                np.cos(u) + 0.2 * np.sin(4 * v) - 0.3 * np.cos(3 * u)\n",
        "            ]),\n",
        "            resolution=(24, 48),\n",
        "            u_min=0.001,\n",
        "            u_max=PI - 0.001,\n",
        "            v_min=0,\n",
        "            v_max=TAU,\n",
        "        )\n",
        "        sphere.rotate(70 * DEGREES, DOWN)\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "        # randy = Randolph(mode=\"telepath\")\n",
        "        # eyes = VGroup(randy.eyes, randy.pupils)\n",
        "        # eyes.scale(3.5)\n",
        "        # eyes.rotate(90 * DEGREES, RIGHT)\n",
        "        # eyes.next_to(sphere, OUT, buff=0)\n",
        "\n",
        "        self.add(sphere)\n"
    ]
}