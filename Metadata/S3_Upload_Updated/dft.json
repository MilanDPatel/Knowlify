{
    "topic": "demonstrates the concept of the Discrete Fourier Transform (DFT) and its application",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class IntroduceDFT(Scene):\n",
        "    def construct(self):\n",
        "        # Create signal\n",
        "        N = 8\n",
        "        np.random.seed(2)\n",
        "        signal = 3 * np.random.random(N)\n",
        "        signal[signal < 0.5] = 0.5\n",
        "\n",
        "        axes = Axes(\n",
        "            (0, 8),\n",
        "            (0, 2, 0.5),\n",
        "            width=12,\n",
        "            height=4,\n",
        "        )\n",
        "        axes.x_axis.add_numbers()\n",
        "        axes.y_axis.add_numbers(excluding=[0], num_decimal_places=1)\n",
        "\n",
        "        vectors = VGroup(*(\n",
        "            Arrow(axes.c2p(x, 0), axes.c2p(x, signal[x]), buff=0)\n",
        "            for x in range(N)\n",
        "        ))\n",
        "        vectors.set_submobject_colors_by_gradient(BLUE, YELLOW)\n",
        "        vectors.set_stroke(BLACK, 2, background=True)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(LaggedStartMap(GrowArrow, vectors, lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        # Label signal\n",
        "        s_title = OldTexText(\"List of value: \", \"$s$\", font_size=72)\n",
        "        s_title.to_edge(UP)\n",
        "        self.play(FadeIn(s_title, UP))\n",
        "        self.wait()\n",
        "\n",
        "        s_labels = VGroup(*(\n",
        "            OldTex(\"s\", f\"[{x}]\")\n",
        "            for x in range(N)\n",
        "        ))\n",
        "        for label, vector in zip(s_labels, vectors):\n",
        "            label.next_to(vector, UP, SMALL_BUFF)\n",
        "            label.match_color(vector)\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "        s_labels[0].shift(MED_SMALL_BUFF * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, s_labels),\n",
        "            LaggedStart(*(\n",
        "                Transform(s_title[1].copy(), label[1].copy(), remover=True)\n",
        "                for label in s_labels\n",
        "            )),\n",
        "            lag_ratio=0.3,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show zeroth DFT element\n",
        "        s_labels.generate_target()\n",
        "        plusses = VGroup()\n",
        "        rhs = VGroup()\n",
        "        for label in s_labels.target:\n",
        "            plus = OldTex(\"+\")\n",
        "            label.next_to(plusses, RIGHT, buff=0.3)\n",
        "            plus.next_to(label, buff=0.3)\n",
        "            plusses.add(plus)\n",
        "            rhs.add(label, plus)\n",
        "        plusses[-1].scale(0)\n",
        "        lhs = OldTex(\"\\\\hat s\", \"[0]\", \"=\")\n",
        "        lhs.to_corner(UL)\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(s_title, UP),\n",
        "            Write(lhs),\n",
        "            Write(plusses),\n",
        "            MoveToTarget(s_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        vectors.generate_target()\n",
        "        vectors.target.rotate(-90 * DEGREES)\n",
        "        vectors.target.arrange(RIGHT, buff=0)\n",
        "        vectors.target.set_width(FRAME_WIDTH - 3)\n",
        "        vectors.target.move_to(DOWN)\n",
        "        self.play(\n",
        "            FadeOut(axes),\n",
        "            MoveToTarget(vectors),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add plane\n",
        "        plane = ComplexPlane(x_range=(-2, 2), y_range=(-2, 2))\n",
        "        plane.set_height(5)\n",
        "        plane.to_edge(DOWN)\n",
        "        plane.add_coordinate_labels()\n",
        "        plane.coordinate_labels[1].scale(0)\n",
        "\n",
        "        sf = signal[0] * get_norm(plane.n2p(1) - plane.n2p(0)) / vectors[0].get_length()\n",
        "        vectors.generate_target()\n",
        "        for n, vector in enumerate(vectors.target):\n",
        "            vector.scale(sf)\n",
        "            vector.set_angle(-n * TAU / N)\n",
        "            vector.shift(plane.n2p(0) - vector.get_start())\n",
        "\n",
        "        self.add(plane, vectors)\n",
        "        self.play(\n",
        "            Write(plane),\n",
        "            MoveToTarget(vectors),\n",
        "        )\n",
        "\n",
        "        # Write first DFT term\n",
        "        lhs1 = OldTex(\"\\\\hat s\", \"[1]\", \"=\")\n",
        "        lhs1.next_to(lhs, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        rhs1 = VGroup()\n",
        "        for n, s_term, plus in zip(it.count(), rhs[0::2], rhs[1::2]):\n",
        "            new_s = s_term.copy()\n",
        "            new_plus = plus.copy()\n",
        "            top_clump = VGroup(s_term, plus)\n",
        "            zeta = OldTex(f\"\\\\zeta^{{{n}}}\")\n",
        "            zeta.add_background_rectangle()\n",
        "            clump = VGroup(new_s, zeta, new_plus)\n",
        "            clump.arrange(RIGHT, buff=0.15)\n",
        "            clump.match_width(top_clump)\n",
        "            clump.scale(1.1)\n",
        "            clump.next_to(top_clump, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "            rhs1.add(*clump)\n",
        "            for term in clump:\n",
        "                term.save_state()\n",
        "            new_s.replace(s_term)\n",
        "            new_plus.replace(plus)\n",
        "            zeta.replace(plus)\n",
        "            zeta.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(lhs, lhs1),\n",
        "            *map(Restore, rhs1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Define zeta\n",
        "        zeta = np.exp(complex(0, TAU / N))\n",
        "        zeta_power_vectors = VGroup(*(\n",
        "            Arrow(plane.n2p(0), plane.n2p(zeta**(-n)), buff=0)\n",
        "            for n in range(N)\n",
        "        ))\n",
        "        zeta_power_vectors.set_fill(GREY_B)\n",
        "\n",
        "        unit_circle = Circle(\n",
        "            radius=get_norm(plane.n2p(1) - plane.n2p(0)),\n",
        "        )\n",
        "        unit_circle.move_to(plane)\n",
        "        unit_circle.set_stroke(YELLOW, 2)\n",
        "\n",
        "        zeta_label = OldTex(\n",
        "            \"\\\\zeta = e^{-2\\\\pi i / N}\"\n",
        "        )\n",
        "        zeta_label.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            vectors.set_opacity, 0.1,\n",
        "            FadeIn(unit_circle),\n",
        "            FadeIn(zeta_power_vectors[1]),\n",
        "            Write(zeta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        zeta_powers = rhs1[1::3].copy()\n",
        "        for z_power, vect in zip(zeta_powers, zeta_power_vectors):\n",
        "            z_power.generate_target()\n",
        "            z_power.target.next_to(\n",
        "                vect,\n",
        "                np.round(vect.get_vector(), 2),\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "\n",
        "        kw = {\n",
        "            \"lag_ratio\": 0.5,\n",
        "            \"run_time\": 3,\n",
        "        }\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, zeta_powers, **kw),\n",
        "            LaggedStartMap(FadeIn, zeta_power_vectors, **kw),\n",
        "            Animation(zeta_power_vectors[1].copy(), remover=True),\n",
        "            plane.coordinate_labels.set_opacity, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(zeta_powers),\n",
        "            FadeOut(zeta_power_vectors),\n",
        "            vectors.set_opacity, 1,\n",
        "            plane.coordinate_labels.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show cosine example\n",
        "        cos_signal = np.cos(np.arange(0, TAU, TAU / N)) + 1.5\n",
        "        sin_signal = np.sin(np.arange(0, TAU, TAU / N)) + 1.5\n",
        "        neg_cos_signal = -np.sin(np.arange(0, TAU, TAU / N)) + 1.5\n",
        "\n",
        "        side_axes = Axes(\n",
        "            (0, 8), (0, 3),\n",
        "            width=3,\n",
        "            height=2,\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        side_axes.to_edge(LEFT)\n",
        "        side_axes.x_axis.add_numbers(height=0.2)\n",
        "        side_vectors = VGroup(*(\n",
        "            Arrow(\n",
        "                side_axes.c2p(x, 0),\n",
        "                side_axes.c2p(x, cos_signal[x]),\n",
        "                buff=0,\n",
        "                thickness=0.05\n",
        "            )\n",
        "            for x in range(N)\n",
        "        ))\n",
        "        side_vectors.match_style(vectors)\n",
        "        side_vectors.set_stroke(background=True)\n",
        "\n",
        "        vectors.generate_target()\n",
        "        for x, vect in enumerate(vectors.target):\n",
        "            vect.put_start_and_end_on(\n",
        "                plane.n2p(0),\n",
        "                plane.n2p(cos_signal[x] * zeta**(-x)),\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(vectors),\n",
        "            FadeIn(side_axes),\n",
        "            FadeIn(side_vectors),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        def change_signal(new_signal, omega=1):\n",
        "            side_vectors.generate_target()\n",
        "            vectors.generate_target()\n",
        "            for x, sv, v in zip(it.count(), side_vectors.target, vectors.target):\n",
        "                sv.put_start_and_end_on(\n",
        "                    side_axes.c2p(x, 0),\n",
        "                    side_axes.c2p(x, new_signal[x]),\n",
        "                )\n",
        "                v.put_start_and_end_on(\n",
        "                    plane.n2p(0),\n",
        "                    plane.n2p(new_signal[x] * zeta**(-omega * x)),\n",
        "                )\n",
        "            self.play(\n",
        "                MoveToTarget(vectors),\n",
        "                MoveToTarget(side_vectors),\n",
        "            )\n",
        "\n",
        "        change_signal(sin_signal)\n",
        "        self.wait()\n",
        "        change_signal(neg_cos_signal)\n",
        "        self.wait()\n",
        "        change_signal(signal)\n",
        "        self.wait()\n",
        "\n",
        "        # Write second DFT term\n",
        "        lhs2 = OldTex(\"\\\\hat s\", \"[2]\", \"=\")\n",
        "        lhs2.next_to(lhs1, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        rhs2 = rhs1.copy()\n",
        "        rhs2.next_to(lhs2, RIGHT)\n",
        "        for n, z_term in enumerate(rhs2[1::3]):\n",
        "            new_exp = Integer(2 * n)\n",
        "            new_exp.match_height(z_term[1][1])\n",
        "            new_exp.move_to(z_term[1][1], DL)\n",
        "            z_term[1].replace_submobject(1, new_exp)\n",
        "\n",
        "        plane_group = VGroup(\n",
        "            plane,\n",
        "            vectors,\n",
        "            unit_circle,\n",
        "        )\n",
        "        self.add(plane_group)\n",
        "        self.play(\n",
        "            TransformFromCopy(lhs1, lhs2),\n",
        "            TransformFromCopy(rhs1, rhs2),\n",
        "            plane_group.scale, 0.8, {\"about_edge\": DOWN},\n",
        "            zeta_label.shift, DOWN,\n",
        "            FadeOut(side_axes),\n",
        "            FadeOut(side_vectors),\n",
        "        )\n",
        "        self.add(vectors)\n",
        "\n",
        "        anims = []\n",
        "        for n, vect in enumerate(vectors):\n",
        "            anims.append(Rotate(\n",
        "                vect,\n",
        "                -n * TAU / N,\n",
        "                about_point=plane.n2p(0),\n",
        "            ))\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "        for n in range(N):\n",
        "            rhs2.generate_target()\n",
        "            rhs2.target.set_opacity(0.25)\n",
        "            rhs2.target[3 * n:3 * (n + 1)].set_opacity(1)\n",
        "\n",
        "            vectors.generate_target()\n",
        "            vectors.target.set_opacity(0.1)\n",
        "            vectors.target[n].set_opacity(1)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(rhs2),\n",
        "                MoveToTarget(vectors),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            vectors.set_opacity, 1,\n",
        "            rhs2.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show cos(2x) example\n",
        "        cos2x_signal = np.cos(2 * np.arange(0, TAU, TAU / N)) + 1.5\n",
        "        sin2x_signal = np.sin(2 * np.arange(0, TAU, TAU / N)) + 1.5\n",
        "\n",
        "        VGroup(side_axes, side_vectors).shift(DOWN)\n",
        "        self.play(\n",
        "            FadeIn(side_axes),\n",
        "            FadeIn(side_vectors),\n",
        "        )\n",
        "        self.wait()\n",
        "        change_signal(cos2x_signal, omega=2)\n",
        "        self.wait()\n",
        "        change_signal(sin2x_signal, omega=2)\n",
        "        self.wait()\n",
        "        change_signal(signal, omega=2)\n",
        "        self.play(*map(FadeOut, (side_axes, side_vectors)))\n",
        "        self.wait()\n",
        "\n",
        "        # Show general formula\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(lhs2[:-1], DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"\\\\hat s[f] = \"\n",
        "            \"\\\\sum_{n=0}^{N - 1} s[n] \\\\zeta^{f \\\\cdot n}\"\n",
        "        )\n",
        "        formula.next_to(dots, DOWN)\n",
        "        formula.align_to(lhs2, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(dots),\n",
        "            FadeIn(formula, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Cycle through\n",
        "        omega_label = VGroup(\n",
        "            OldTex(\"f = \", font_size=72),\n",
        "            Integer(2),\n",
        "        )\n",
        "        omega_label.arrange(RIGHT)\n",
        "        omega_label.next_to(plane, LEFT, MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "\n",
        "        self.play(FadeIn(omega_label))\n",
        "\n",
        "        for omega in range(3, 8):\n",
        "            anims = []\n",
        "            for n, vect in enumerate(vectors):\n",
        "                anims.append(Rotate(\n",
        "                    vect,\n",
        "                    -n * TAU / N,\n",
        "                    about_point=plane.n2p(0),\n",
        "                ))\n",
        "            new_count = omega_label[1].copy()\n",
        "            new_count.set_value(omega)\n",
        "            self.play(\n",
        "                *anims,\n",
        "                FadeIn(new_count, 0.5 * UP),\n",
        "                FadeOut(omega_label[1], 0.5 * UP)\n",
        "            )\n",
        "            omega_label.replace_submobject(1, new_count)\n",
        "            self.wait()\n"
    ]
}