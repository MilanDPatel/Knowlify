{
    "topic": "demonstrates the concept of a closed loop or cycle in mathematics.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class ClosedLoopScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"loop_anchor_points\" : [\n",
        "            3*RIGHT,\n",
        "            2*RIGHT+UP,\n",
        "            3*RIGHT + 3*UP,\n",
        "            UP,\n",
        "            2*UP+LEFT,\n",
        "            2*LEFT + 2*UP,\n",
        "            3*LEFT,\n",
        "            2*LEFT+DOWN,\n",
        "            3*LEFT+2*DOWN,\n",
        "            2*DOWN+RIGHT,\n",
        "            LEFT+DOWN,\n",
        "        ],\n",
        "        \"square_vertices\" : [\n",
        "            2*RIGHT+UP,\n",
        "            2*UP+LEFT,\n",
        "            2*LEFT+DOWN,\n",
        "            2*DOWN+RIGHT\n",
        "        ],\n",
        "        \"rect_vertices\" : [\n",
        "            0*RIGHT + 1*UP,\n",
        "            -1*RIGHT +  2*UP,\n",
        "            -3*RIGHT +  0*UP,\n",
        "            -2*RIGHT + -1*UP,\n",
        "        ],\n",
        "        \"dot_color\" : YELLOW,\n",
        "        \"connecting_lines_color\" : BLUE,\n",
        "        \"pair_colors\" : [MAROON_B, PURPLE_B],\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.dots = VGroup()\n",
        "        self.connecting_lines = VGroup()\n",
        "        self.add_loop()\n",
        "\n",
        "    def add_loop(self):\n",
        "        self.loop = self.get_default_loop()\n",
        "        self.add(self.loop)\n",
        "\n",
        "    def get_default_loop(self):\n",
        "        loop = VMobject()\n",
        "        loop.set_points_smoothly(\n",
        "            self.loop_anchor_points + [self.loop_anchor_points[0]]\n",
        "        )\n",
        "        return loop\n",
        "\n",
        "    def get_square(self):\n",
        "        return Polygon(*self.square_vertices)\n",
        "\n",
        "    def get_rect_vertex_dots(self, square = False):\n",
        "        if square:\n",
        "            vertices = self.square_vertices\n",
        "        else:\n",
        "            vertices = self.rect_vertices\n",
        "        dots = VGroup(*[Dot(v) for v in vertices])\n",
        "        dots.set_color(self.dot_color)\n",
        "        return dots\n",
        "\n",
        "    def get_rect_alphas(self, square = False):\n",
        "        #Inefficient and silly, but whatever.\n",
        "        dots = self.get_rect_vertex_dots(square = square)\n",
        "        return self.get_dot_alphas(dots)\n",
        "\n",
        "    def add_dot(self, dot):\n",
        "        self.add_dots(dot)\n",
        "\n",
        "    def add_dots(self, *dots):\n",
        "        self.dots.add(*dots)\n",
        "        self.add(self.dots)\n",
        "\n",
        "    def add_rect_dots(self, square = False):\n",
        "        self.add_dots(*self.get_rect_vertex_dots(square = square))\n",
        "\n",
        "    def add_dots_at_alphas(self, *alphas):\n",
        "        self.add_dots(*[\n",
        "            Dot(\n",
        "                self.loop.point_from_proportion(alpha), \n",
        "                color = self.dot_color\n",
        "            )\n",
        "            for alpha in alphas\n",
        "        ])\n",
        "\n",
        "    def add_connecting_lines(self, cyclic = False):\n",
        "        if cyclic:\n",
        "            pairs = adjacent_pairs(self.dots)\n",
        "        else:\n",
        "            n_pairs = len(list(self.dots))/2\n",
        "            pairs = list(zip(self.dots[:n_pairs], self.dots[n_pairs:]))\n",
        "        for d1, d2 in pairs:\n",
        "            line = Line(d1.get_center(), d2.get_center())\n",
        "            line.start_dot = d1 \n",
        "            line.end_dot = d2\n",
        "            line.update_anim = UpdateFromFunc(\n",
        "                line,\n",
        "                lambda l : l.put_start_and_end_on(\n",
        "                    l.start_dot.get_center(),\n",
        "                    l.end_dot.get_center()\n",
        "                )\n",
        "            )\n",
        "            line.set_color(d1.get_color())\n",
        "            self.connecting_lines.add(line)\n",
        "        if cyclic:\n",
        "            self.connecting_lines.set_color(self.connecting_lines_color)\n",
        "            self.connecting_lines.set_stroke(width = 6)\n",
        "        self.add(self.connecting_lines, self.dots)\n",
        "\n",
        "    def get_line_anims(self):\n",
        "        return [\n",
        "            line.update_anim\n",
        "            for line in self.connecting_lines\n",
        "        ] + [Animation(self.dots)]\n",
        "\n",
        "    def get_dot_alphas(self, dots = None, precision = 0.005):\n",
        "        if dots == None:\n",
        "            dots = self.dots\n",
        "        alphas = []\n",
        "        alpha_range = np.arange(0, 1, precision)\n",
        "        loop_points = np.array(list(map(self.loop.point_from_proportion, alpha_range)))\n",
        "        for dot in dots:\n",
        "            vects = loop_points - dot.get_center()\n",
        "            norms = np.apply_along_axis(get_norm, 1, vects)\n",
        "            index = np.argmin(norms)\n",
        "            alphas.append(alpha_range[index])\n",
        "        return alphas\n",
        "\n",
        "    def let_dots_wonder(self, run_time = 5, random_seed = None, added_anims = []):\n",
        "        if random_seed is not None:\n",
        "            np.random.seed(random_seed)\n",
        "        start_alphas = self.get_dot_alphas()\n",
        "        alpha_rates = 0.05 + 0.1*np.random.random(len(list(self.dots)))\n",
        "        def generate_rate_func(start, rate):\n",
        "            return lambda t : (start + t*rate*run_time)%1\n",
        "        anims = [\n",
        "            MoveAlongPath(\n",
        "                dot,\n",
        "                self.loop,\n",
        "                rate_func = generate_rate_func(start, rate)\n",
        "            )\n",
        "            for dot, start, rate in zip(self.dots, start_alphas, alpha_rates)\n",
        "        ]\n",
        "        anims += self.get_line_anims()\n",
        "        anims += added_anims\n",
        "        self.play(*anims, run_time = run_time)\n",
        "\n",
        "    def move_dots_to_alphas(self, alphas, run_time = 3):\n",
        "        assert(len(alphas) == len(list(self.dots)))\n",
        "        start_alphas = self.get_dot_alphas()\n",
        "        def generate_rate_func(start_alpha, alpha):\n",
        "            return lambda t : interpolate(start_alpha, alpha, smooth(t))\n",
        "        anims = [\n",
        "            MoveAlongPath(\n",
        "                dot, self.loop,\n",
        "                rate_func = generate_rate_func(sa, a),\n",
        "                run_time = run_time,\n",
        "            )\n",
        "            for dot, sa, a in zip(self.dots, start_alphas, alphas)\n",
        "        ]\n",
        "        anims += self.get_line_anims()\n",
        "        self.play(*anims)\n",
        "\n",
        "    def transform_loop(self, target_loop, added_anims = [], **kwargs):\n",
        "        alphas = self.get_dot_alphas()\n",
        "        dot_anims = []\n",
        "        for dot, alpha in zip(self.dots, alphas):\n",
        "            dot.generate_target()\n",
        "            dot.target.move_to(target_loop.point_from_proportion(alpha))\n",
        "            dot_anims.append(MoveToTarget(dot))\n",
        "        self.play(\n",
        "            Transform(self.loop, target_loop),\n",
        "            *dot_anims + self.get_line_anims() + added_anims,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def set_color_dots_by_pair(self):\n",
        "        n_pairs = len(list(self.dots))/2\n",
        "        for d1, d2, c in zip(self.dots[:n_pairs], self.dots[n_pairs:], self.pair_colors):\n",
        "            VGroup(d1, d2).set_color(c)\n",
        "\n",
        "    def find_square(self):\n",
        "        alpha_quads = list(it.combinations(\n",
        "            np.arange(0, 1, 0.02) , 4\n",
        "        ))\n",
        "        quads = np.array([\n",
        "            [\n",
        "                self.loop.point_from_proportion(alpha)\n",
        "                for alpha in quad\n",
        "            ]\n",
        "            for quad in alpha_quads\n",
        "        ])\n",
        "        scores = self.square_scores(quads)\n",
        "        index = np.argmin(scores)\n",
        "        return quads[index]\n",
        "\n",
        "    def square_scores(self, all_quads):\n",
        "        midpoint_diffs = np.apply_along_axis(\n",
        "            get_norm, 1,\n",
        "            0.5*(all_quads[:,0] + all_quads[:,2]) - 0.5*(all_quads[:,1] + all_quads[:,3])\n",
        "        )\n",
        "        vects1 = all_quads[:,0] - all_quads[:,2]\n",
        "        vects2 = all_quads[:,1] - all_quads[:,3]\n",
        "        distances1 = np.apply_along_axis(get_norm, 1, vects1)\n",
        "        distances2 = np.apply_along_axis(get_norm, 1, vects2)\n",
        "        distance_diffs = np.abs(distances1 - distances2)\n",
        "        midpoint_diffs /= distances1\n",
        "        distance_diffs /= distances2\n",
        "\n",
        "        buffed_d1s = np.repeat(distances1, 3).reshape(vects1.shape)\n",
        "        buffed_d2s = np.repeat(distances2, 3).reshape(vects2.shape)\n",
        "        unit_v1s = vects1/buffed_d1s\n",
        "        unit_v2s = vects2/buffed_d2s\n",
        "        dots = np.abs(unit_v1s[:,0]*unit_v2s[:,0] + unit_v1s[:,1]*unit_v2s[:,1] + unit_v1s[:,2]*unit_v2s[:,2])\n",
        "\n",
        "        return midpoint_diffs + distance_diffs + dots\n",
        "\n",
        "\n",
        "#############################\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(self.get_teacher().change_mode, \"hooray\")\n",
        "        self.random_blink()\n",
        "        self.teacher_says(\"\")\n",
        "        for pi in self.get_students():\n",
        "            pi.generate_target()\n",
        "            pi.target.change_mode(\"happy\")            \n",
        "            pi.target.look_at(self.get_teacher().bubble)\n",
        "        self.play(*list(map(MoveToTarget, self.get_students())))\n",
        "        self.random_blink(3)\n",
        "        self.teacher_says(\n",
        "            \"Here's why \\\\\\\\ I'm excited...\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        for pi in self.get_students():\n",
        "            pi.target.look_at(self.get_teacher().eyes)\n",
        "        self.play(*list(map(MoveToTarget, self.get_students())))\n",
        "        self.wait()\n",
        "\n",
        "class WhenIWasAKid(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        children = self.get_children()\n",
        "        speaker = self.get_speaker()\n",
        "\n",
        "        self.prepare_everyone(children, speaker)\n",
        "        self.state_excitement(children, speaker)\n",
        "        self.students = children\n",
        "        self.teacher = speaker\n",
        "        self.run_class()\n",
        "        self.grow_up()\n",
        "\n",
        "    def state_excitement(self, children, speaker):\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            Here's why \n",
        "            I'm excited!\n",
        "            \"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "        speaker.look_at(children)\n",
        "        me = children[-1]\n",
        "        self.play(\n",
        "            FadeOut(self.get_students()),\n",
        "            FadeOut(self.get_teacher().bubble),\n",
        "            FadeOut(self.get_teacher().bubble.content),\n",
        "            Transform(self.get_teacher(), me)\n",
        "        )\n",
        "        self.remove(self.get_teacher())\n",
        "        self.add(me)\n",
        "        self.play(*list(map(FadeIn, children[:-1] + [speaker])))\n",
        "        self.random_blink()\n",
        "\n",
        "    def run_class(self):\n",
        "        children = self.students\n",
        "        speaker = self.teacher\n",
        "        title = OldTexText(\"Topology\")\n",
        "        title.to_edge(UP)\n",
        "        pi1, pi2, pi3, me = children\n",
        "\n",
        "        self.random_blink()\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            Math! Excitement!\n",
        "            You are the future!\n",
        "            \"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play(\n",
        "            pi1.look_at, pi2.eyes,\n",
        "            pi1.change_mode, \"erm\",\n",
        "            pi2.look_at, pi1.eyes,\n",
        "            pi2.change_mode, \"surprised\",\n",
        "        )\n",
        "        self.play(\n",
        "            pi3.look_at, me.eyes,\n",
        "            pi3.change_mode, \"sassy\",\n",
        "            me.look_at, pi3.eyes,\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change_mode, \"speaking\",\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            FadeOut(self.teacher.bubble.content),\n",
        "        )\n",
        "        self.play(Write(title))\n",
        "        self.random_blink()\n",
        "        \n",
        "        self.play(pi1.change_mode, \"raise_right_hand\")\n",
        "        self.random_blink()\n",
        "        self.play(\n",
        "            pi2.change_mode, \"confused\",\n",
        "            pi3.change_mode, \"happy\",\n",
        "            pi2.look_at, pi3.eyes,\n",
        "            pi3.look_at, pi2.eyes,\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.play(me.change_mode, \"pondering\")\n",
        "        self.wait()\n",
        "        self.random_blink(2)\n",
        "        self.play(pi1.change_mode, \"raise_left_hand\")\n",
        "        self.wait()\n",
        "        self.play(pi2.change_mode, \"erm\")\n",
        "        self.random_blink()\n",
        "        self.student_says(\n",
        "            \"How is this math?\",\n",
        "            index = -1,\n",
        "            target_mode = \"pleading\",\n",
        "            width = 5, \n",
        "            height = 3,\n",
        "            direction = RIGHT\n",
        "        )\n",
        "        self.play(\n",
        "            pi1.change_mode, \"pondering\",\n",
        "            pi2.change_mode, \"pondering\",\n",
        "            pi3.change_mode, \"pondering\",\n",
        "        )\n",
        "        self.play(speaker.change_mode, \"pondering\")\n",
        "        self.random_blink()\n",
        "\n",
        "    def grow_up(self):\n",
        "        me = self.students[-1]\n",
        "        self.students.remove(me)\n",
        "        morty = Mortimer(mode = \"pondering\")\n",
        "        morty.flip()\n",
        "        morty.move_to(me, aligned_edge = DOWN)\n",
        "        morty.to_edge(LEFT)\n",
        "        morty.look(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Transform(me, morty),\n",
        "            *list(map(FadeOut, [\n",
        "                self.students, self.teacher,\n",
        "                me.bubble, me.bubble.content\n",
        "            ]))\n",
        "        )\n",
        "        self.remove(me)\n",
        "        self.add(morty)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(morty.change_mode, \"hooray\")\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def prepare_everyone(self, children, speaker):\n",
        "        self.everyone = list(children) + [speaker]\n",
        "        for pi in self.everyone:\n",
        "            pi.bubble = None\n",
        "\n",
        "    def get_children(self):\n",
        "        colors = [MAROON_E, YELLOW_D, PINK, GREY_BROWN]\n",
        "        children = VGroup(*[\n",
        "            BabyPiCreature(color = color)\n",
        "            for color in colors\n",
        "        ])\n",
        "        children.arrange(RIGHT)\n",
        "        children.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        children.to_edge(LEFT)\n",
        "        return children\n",
        "\n",
        "    def get_speaker(self):\n",
        "        speaker = Mathematician(mode = \"happy\")\n",
        "        speaker.flip()\n",
        "        speaker.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        speaker.to_edge(RIGHT)\n",
        "        return speaker\n",
        "\n",
        "    def get_pi_creatures(self):\n",
        "        if hasattr(self, \"everyone\"):\n",
        "            return self.everyone\n",
        "        else:\n",
        "            return TeacherStudentsScene.get_pi_creatures(self)\n",
        "\n",
        "class FormingTheMobiusStrip(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class DrawLineOnMobiusStrip(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class MugIntoTorus(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class DefineInscribedSquareProblem(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.draw_loop()\n",
        "        self.cycle_through_shapes()\n",
        "        self.ask_about_rectangles()\n",
        "\n",
        "    def draw_loop(self):\n",
        "        self.title = OldTexText(\"Inscribed\", \"square\", \"problem\")\n",
        "        self.title.to_edge(UP)\n",
        "\n",
        "        #Draw loop\n",
        "        self.remove(self.loop)\n",
        "        self.play(Write(self.title))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            self.loop, \n",
        "            run_time = 5, \n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.add_rect_dots(square = True)\n",
        "        self.play(ShowCreation(self.dots, run_time = 2))\n",
        "        self.wait()\n",
        "        self.add_connecting_lines(cyclic = True)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                self.connecting_lines,\n",
        "                lag_ratio = 0,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Animation(self.dots)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def cycle_through_shapes(self):\n",
        "        circle = Circle(radius = 2.5, color = WHITE)\n",
        "        ellipse = circle.copy()\n",
        "        ellipse.stretch(1.5, 0)\n",
        "        ellipse.stretch(0.7, 1)\n",
        "        ellipse.rotate(-np.pi/2)\n",
        "        ellipse.set_height(4)\n",
        "        pi_loop = OldTex(\"\\\\pi\")[0]\n",
        "        pi_loop.set_fill(opacity = 0)\n",
        "        pi_loop.set_stroke(\n",
        "            color = WHITE,\n",
        "            width = DEFAULT_STROKE_WIDTH\n",
        "        )\n",
        "        pi_loop.set_height(4)\n",
        "        randy = Randolph()\n",
        "        randy.look(DOWN)\n",
        "        randy.set_width(pi_loop.get_width())\n",
        "        randy.move_to(pi_loop, aligned_edge = DOWN)\n",
        "        randy.body.set_fill(opacity = 0)\n",
        "        randy.mouth.set_stroke(width = 0)\n",
        "\n",
        "        self.transform_loop(circle)\n",
        "        self.remove(self.loop)\n",
        "        self.loop = circle\n",
        "        self.add(self.loop, self.connecting_lines, self.dots)\n",
        "        self.wait()\n",
        "        odd_eigths = np.linspace(1./8, 7./8, 4)\n",
        "        self.move_dots_to_alphas(odd_eigths)\n",
        "        self.wait()\n",
        "        for nudge in 0.1, -0.1, 0:\n",
        "            self.move_dots_to_alphas(odd_eigths+nudge)\n",
        "        self.wait()\n",
        "        self.transform_loop(ellipse)\n",
        "        self.wait()\n",
        "        nudge = 0.055\n",
        "        self.move_dots_to_alphas(\n",
        "            odd_eigths + [nudge, -nudge, nudge, -nudge]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.transform_loop(pi_loop)\n",
        "        self.let_dots_wonder()\n",
        "        randy_anims = [\n",
        "            FadeIn(randy),\n",
        "            Animation(randy),            \n",
        "            Blink(randy),\n",
        "            Animation(randy),         \n",
        "            Blink(randy),\n",
        "            Animation(randy),\n",
        "            Blink(randy, rate_func = smooth)\n",
        "        ]\n",
        "        for anim in randy_anims:\n",
        "            self.let_dots_wonder(\n",
        "                run_time = 1.5,\n",
        "                random_seed = 0,\n",
        "                added_anims = [anim]\n",
        "            )\n",
        "        self.remove(randy)\n",
        "        self.transform_loop(self.get_default_loop())\n",
        "\n",
        "    def ask_about_rectangles(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "        morty.to_edge(RIGHT)\n",
        "\n",
        "        new_title = OldTexText(\"Inscribed\", \"rectangle\", \"problem\")\n",
        "        new_title.set_color_by_tex(\"rectangle\", YELLOW)\n",
        "        new_title.to_edge(UP)\n",
        "        rect_dots = self.get_rect_vertex_dots()\n",
        "        rect_alphas = self.get_dot_alphas(rect_dots)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(morty.change_mode, \"speaking\")\n",
        "        self.play(Transform(self.title, new_title))\n",
        "        self.move_dots_to_alphas(rect_alphas)\n",
        "        self.wait()\n",
        "        self.play(morty.change_mode, \"hooray\")\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.connecting_lines))\n",
        "        self.connecting_lines = VGroup()\n",
        "        self.play(morty.change_mode, \"plain\")\n",
        "\n",
        "        dot_pairs = [\n",
        "            VGroup(self.dots[i], self.dots[j])\n",
        "            for i, j in [(0, 2), (1, 3)]\n",
        "        ]\n",
        "        pair_colors = MAROON_B, PURPLE_B\n",
        "        diag_lines = [\n",
        "            Line(d1.get_center(), d2.get_center(), color = c)\n",
        "            for (d1, d2), c in zip(dot_pairs, pair_colors)\n",
        "        ]\n",
        "\n",
        "        for pair, line in zip(dot_pairs, diag_lines):\n",
        "            self.play(\n",
        "                FadeIn(line),\n",
        "                pair.set_color, line.get_color(),\n",
        "            )\n",
        "\n",
        "class RectangleProperties(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(color = BLUE)\n",
        "        vertex_dots = VGroup(*[\n",
        "            Dot(anchor, color = YELLOW)\n",
        "            for anchor in rect.get_anchors_and_handles()[0]\n",
        "        ])\n",
        "        dot_pairs = [\n",
        "            VGroup(vertex_dots[i], vertex_dots[j])\n",
        "            for i, j in [(0, 2), (1, 3)]\n",
        "        ]\n",
        "        colors = [MAROON_B, PURPLE_B]\n",
        "        diag_lines = [\n",
        "            Line(d1.get_center(), d2.get_center(), color = c)\n",
        "            for (d1, d2), c in zip(dot_pairs, colors)\n",
        "        ]\n",
        "        braces = [Brace(rect).next_to(ORIGIN, DOWN) for x in range(2)]\n",
        "        for brace, line in zip(braces, diag_lines):\n",
        "            brace.stretch_to_fit_width(line.get_length())\n",
        "            brace.rotate(line.get_angle())\n",
        "        a, b, c, d = labels = VGroup(*[\n",
        "            OldTex(s).next_to(dot, dot.get_center(), buff = SMALL_BUFF)\n",
        "            for s, dot in zip(\"abcd\", vertex_dots)\n",
        "        ])\n",
        "        midpoint = Dot(ORIGIN, color = RED)\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(vertex_dots),\n",
        "            Write(labels)\n",
        "        )\n",
        "        self.wait()\n",
        "        mob_lists = [\n",
        "            (a, c, dot_pairs[0]),\n",
        "            (b, d, dot_pairs[1]),\n",
        "        ]\n",
        "        for color, mob_list in zip(colors, mob_lists):\n",
        "            self.play(*[\n",
        "                ApplyMethod(mob.set_color, color)\n",
        "                for mob in mob_list\n",
        "            ])\n",
        "            self.wait()\n",
        "        for line, brace in zip(diag_lines, braces):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(brace)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(FadeOut(brace))\n",
        "        self.play(FadeIn(midpoint))\n",
        "        self.wait()\n",
        "\n",
        "class PairOfPairBecomeRectangle(Scene):\n",
        "    def construct(self):\n",
        "        dots = VGroup(\n",
        "            Dot(4*RIGHT+0.5*DOWN, color = MAROON_B),\n",
        "            Dot(5*RIGHT+3*UP, color = MAROON_B),\n",
        "            Dot(LEFT+0.1*DOWN, color = PURPLE_B),\n",
        "            Dot(2*LEFT+UP, color = PURPLE_B)\n",
        "        )\n",
        "        labels = VGroup()\n",
        "        for dot, char in zip(dots, \"acbd\"):\n",
        "            label = OldTex(char)\n",
        "            y_coord = dot.get_center()[1]\n",
        "            label.next_to(dot, np.sign(dot.get_center()[1])*UP)\n",
        "            label.set_color(dot.get_color())\n",
        "            labels.add(label)\n",
        "        lines = [\n",
        "            Line(\n",
        "                dots[i].get_center(), \n",
        "                dots[j].get_center(), \n",
        "                color = dots[i].get_color()\n",
        "            )\n",
        "            for i, j in [(0, 1), (2, 3)]\n",
        "        ]\n",
        "        groups = [\n",
        "            VGroup(dots[0], dots[1], labels[0], labels[1], lines[0]),\n",
        "            VGroup(dots[2], dots[3], labels[2], labels[3], lines[1]),\n",
        "        ]\n",
        "        midpoint = Dot(LEFT, color = RED)\n",
        "\n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"Common midpoint\",\n",
        "            \"Same distance apart\",\n",
        "            \"$\\\\Downarrow$\",\n",
        "            \"Rectangle\",\n",
        "        ])))\n",
        "        words.arrange(DOWN)\n",
        "        words.to_edge(RIGHT)\n",
        "        words[-1].set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(dots),\n",
        "            Write(labels)\n",
        "        )\n",
        "        self.play(*list(map(ShowCreation, lines)))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                group.shift, \n",
        "                -group[-1].get_center()+midpoint.get_center()\n",
        "            )\n",
        "            for group in groups\n",
        "        ])\n",
        "        self.play(\n",
        "            ShowCreation(midpoint),\n",
        "            Write(words[0])\n",
        "        )\n",
        "        factor = lines[0].get_length()/lines[1].get_length()        \n",
        "        grower = groups[1].copy()\n",
        "        new_line = grower[-1]\n",
        "        new_line.scale(factor)\n",
        "        grower[0].move_to(new_line.get_start())\n",
        "        grower[2].next_to(grower[0], DOWN)\n",
        "        grower[1].move_to(new_line.get_end())\n",
        "        grower[3].next_to(grower[1], UP)\n",
        "\n",
        "        self.play(Transform(groups[1], grower))\n",
        "        self.play(Write(words[1]))\n",
        "        self.wait()\n",
        "\n",
        "        rectangle = Polygon(*[\n",
        "            dots[i].get_center()\n",
        "            for i in (0, 2, 1, 3)\n",
        "        ])\n",
        "        rectangle.set_color(BLUE)\n",
        "        self.play(\n",
        "            ShowCreation(rectangle),\n",
        "            Animation(dots)\n",
        "        )\n",
        "        self.play(*list(map(Write, words[2:])))\n",
        "        self.wait()\n",
        "\n",
        "class SearchForRectangleOnLoop(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.add_dots_at_alphas(*np.linspace(0.2, 0.8, 4))\n",
        "        self.set_color_dots_by_pair()\n",
        "        rect_alphas = self.get_rect_alphas()\n",
        "\n",
        "        self.play(ShowCreation(self.dots))\n",
        "        self.add_connecting_lines()\n",
        "        self.play(ShowCreation(self.connecting_lines))\n",
        "        self.let_dots_wonder(2)\n",
        "        self.move_dots_to_alphas(rect_alphas)\n",
        "\n",
        "        midpoint = Dot(\n",
        "            center_of_mass([d.get_center() for d in self.dots]),\n",
        "            color = RED\n",
        "        )\n",
        "        self.play(ShowCreation(midpoint))\n",
        "        self.wait()\n",
        "        angles = [line.get_angle() for line in self.connecting_lines]\n",
        "        angle_mean = np.mean(angles)\n",
        "        self.play(\n",
        "            *[\n",
        "                ApplyMethod(line.rotate, angle_mean-angle)\n",
        "                for line, angle in zip(self.connecting_lines, angles)\n",
        "            ] + [Animation(midpoint)],\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.add(self.connecting_lines.copy(), midpoint)\n",
        "        self.connecting_lines = VGroup()\n",
        "        self.wait()\n",
        "        self.add_connecting_lines(cyclic = True)\n",
        "        self.play(\n",
        "            ShowCreation(self.connecting_lines), \n",
        "            Animation(self.dots)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class DeclareFunction(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.add_dots_at_alphas(0.2, 0.8)\n",
        "        self.set_color_dots_by_pair()        \n",
        "        self.add_connecting_lines()\n",
        "        VGroup(\n",
        "            self.loop, self.dots, self.connecting_lines\n",
        "        ).scale(0.7).to_edge(LEFT).shift(DOWN)\n",
        "        arrow = Arrow(LEFT, RIGHT).next_to(self.loop)\n",
        "        self.add(arrow)\n",
        "\n",
        "        self.add_tex()\n",
        "        self.let_dots_wonder(10)\n",
        "\n",
        "    def add_tex(self):\n",
        "        tex = OldTex(\"f\", \"(A, B)\", \"=\", \"(x, y, z)\")\n",
        "        tex.to_edge(UP)\n",
        "        tex.shift(LEFT)\n",
        "\n",
        "        ab_brace = Brace(tex[1])\n",
        "        xyz_brace = Brace(tex[-1], RIGHT)\n",
        "        ab_brace.add(ab_brace.get_text(\"Pair of points on the loop\"))\n",
        "        xyz_brace.add(xyz_brace.get_text(\"Point in 3d space\"))\n",
        "        ab_brace.set_color_by_gradient(MAROON_B, PURPLE_B)\n",
        "        xyz_brace.set_color(BLUE)\n",
        "\n",
        "        self.add(tex)\n",
        "        self.play(Write(ab_brace))\n",
        "        self.wait()\n",
        "        self.play(Write(xyz_brace))\n",
        "        self.wait()\n",
        "\n",
        "class DefinePairTo3dFunction(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class LabelMidpoint(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Midpoint $M$\")\n",
        "        words.set_color(RED)\n",
        "        words.scale(2)\n",
        "        self.play(Write(words, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "class LabelDistance(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Distance $d$\")\n",
        "        words.set_color(MAROON_B)\n",
        "        words.scale(2)\n",
        "        self.play(Write(words, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "class DrawingOneLineOfTheSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class FunctionSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class PointPairApprocahingEachother3D(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class InputPairToFunction(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\"f(X, X)\", \"=X\")\n",
        "        tex.set_color_by_tex(\"=X\", BLUE)\n",
        "        tex.scale(2)\n",
        "        self.play(Write(tex[0]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(tex[1]))\n",
        "        self.wait(2)\n",
        "\n",
        "class WigglePairUnderSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass        \n",
        "\n",
        "class WriteContinuous(Scene):\n",
        "    def construct(self):\n",
        "        self.play(Write(OldTexText(\"Continuous\").scale(2)))\n",
        "        self.wait(2)\n",
        "\n",
        "class DistinctPairCollisionOnSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class PairsOfPointsOnLoop(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.add_dots_at_alphas(0.2, 0.5)\n",
        "        self.dots.set_color(MAROON_B)\n",
        "        self.add_connecting_lines()\n",
        "        self.let_dots_wonder(run_time = 10)\n",
        "\n",
        "class PairOfRealsToPlane(Scene):\n",
        "    def construct(self):\n",
        "        r1, r2 = numbers = -3, 2\n",
        "        colors = GREEN, RED\n",
        "        dot1, dot2 = dots = VGroup(*[Dot(color = c) for c in colors])\n",
        "        for dot, number in zip(dots, numbers):\n",
        "            dot.move_to(number*RIGHT)\n",
        "        pair_label = OldTex(\"(\", str(r1), \",\", str(r2), \")\")\n",
        "        for number, color in zip(numbers, colors):\n",
        "            pair_label.set_color_by_tex(str(number), color)\n",
        "        pair_label.next_to(dots, UP, buff = 2)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(pair_label[i], dot, color = dot.get_color())\n",
        "            for i, dot in zip([1, 3], dots)\n",
        "        ])\n",
        "        two_d_point = Dot(r1*RIGHT + r2*UP, color = YELLOW)\n",
        "        pair_label.add_background_rectangle()\n",
        "\n",
        "        x_axis = NumberLine(color = BLUE)\n",
        "        y_axis = NumberLine(color = BLUE)\n",
        "        plane = NumberPlane().fade()\n",
        "\n",
        "        self.add(x_axis, y_axis, dots, pair_label)\n",
        "        self.play(ShowCreation(arrows, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            pair_label.next_to, two_d_point, UP+LEFT, SMALL_BUFF,\n",
        "            Rotate(y_axis, np.pi/2),\n",
        "            Rotate(dot2, np.pi/2),\n",
        "            FadeOut(arrows)\n",
        "        )\n",
        "        lines = VGroup(*[\n",
        "            DashedLine(dot, two_d_point, color = dot.get_color())\n",
        "            for dot in dots\n",
        "        ])\n",
        "        self.play(*list(map(ShowCreation, lines)))\n",
        "        self.play(ShowCreation(two_d_point))\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        self.play(\n",
        "            FadeIn(plane), \n",
        "            Animation(everything),\n",
        "            Animation(dot2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SeekSurfaceForPairs(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.loop.to_edge(LEFT)\n",
        "        self.add_dots_at_alphas(0.2, 0.3)\n",
        "        self.set_color_dots_by_pair()        \n",
        "        self.add_connecting_lines()\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT).next_to(self.loop)\n",
        "        words = OldTexText(\"Some 2d surface\")\n",
        "        words.next_to(arrow, RIGHT)\n",
        "\n",
        "        anims = [\n",
        "            ShowCreation(arrow),\n",
        "            Write(words)\n",
        "        ]\n",
        "        for anim in anims:\n",
        "            self.let_dots_wonder(\n",
        "                random_seed = 1,\n",
        "                added_anims = [anim],\n",
        "                run_time = anim.run_time\n",
        "            )\n",
        "        self.let_dots_wonder(random_seed = 1, run_time = 10)\n",
        "\n",
        "class AskAbouPairType(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            Do you mean ordered\n",
        "            or unordered pairs?\n",
        "        \"\"\")\n",
        "        self.play(*[\n",
        "            ApplyMethod(self.get_students()[i].change_mode, \"confused\")\n",
        "            for i in (0, 2)\n",
        "        ])\n",
        "        self.random_blink(3)\n",
        "\n",
        "class DefineOrderedPair(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Ordered pairs\")\n",
        "        title.to_edge(UP)\n",
        "        subtitle = OldTex(\n",
        "            \"(\", \"a\", \",\", \"b\", \")\", \n",
        "            \"\\\\ne\", \n",
        "            \"(\", \"b\", \",\", \"a\", \")\"\n",
        "        )\n",
        "        labels_start = VGroup(subtitle[1], subtitle[3])\n",
        "        labels_end = VGroup(subtitle[9], subtitle[7])\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        colors = GREEN, RED\n",
        "        for char, color in zip(\"ab\", colors):\n",
        "            subtitle.set_color_by_tex(char, color)\n",
        "        self.loop.next_to(subtitle, DOWN)\n",
        "        self.add(title, subtitle)\n",
        "\n",
        "        self.add_dots_at_alphas(0.5, 0.6)\n",
        "        dots = self.dots\n",
        "        for dot, color, char in zip(dots, colors, \"ab\"):\n",
        "            dot.set_color(color)\n",
        "            label = OldTex(char)\n",
        "            label.set_color(color)\n",
        "            label.next_to(dot, RIGHT, buff = SMALL_BUFF)\n",
        "            dot.label = label\n",
        "        self.dots[1].label.shift(0.3*UP)\n",
        "        first = OldTexText(\"First\")\n",
        "        first.next_to(self.dots[0], UP+2*LEFT, LARGE_BUFF)\n",
        "        arrow = Arrow(first.get_bottom(), self.dots[0], color = GREEN)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(label.copy(), dot.label)\n",
        "            for label, dot in zip(labels_start, dots)\n",
        "        ])\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(*[d.label for d in dots])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(first),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class DefineUnorderedPair(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Unordered pairs\")\n",
        "        title.to_edge(UP)\n",
        "        subtitle = OldTex(\n",
        "            \"\\\\{a,b\\\\}\",\n",
        "            \"=\",\n",
        "            \"\\\\{b,a\\\\}\",\n",
        "        )\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        for char in \"ab\":\n",
        "            subtitle.set_color_by_tex(char, PURPLE_B)\n",
        "        self.loop.next_to(subtitle, DOWN)\n",
        "        self.add(title, subtitle)\n",
        "\n",
        "        self.add_dots_at_alphas(0.5, 0.6)\n",
        "        dots = self.dots\n",
        "        dots.set_color(PURPLE_B)\n",
        "\n",
        "        labels = VGroup(*[subtitle[i].copy() for i in (0, 2)])\n",
        "        for label, vect in zip(labels, [LEFT, RIGHT]):\n",
        "            label.next_to(dots, vect, LARGE_BUFF)\n",
        "        arrows = [\n",
        "            Arrow(*pair, color = PURPLE_B)\n",
        "            for pair in it.product(labels, dots)\n",
        "        ]\n",
        "        arrow_pairs = [VGroup(*arrows[:2]), VGroup(*arrows[2:])]\n",
        "\n",
        "        for label, arrow_pair in zip(labels, arrow_pairs):\n",
        "            self.play(*list(map(FadeIn, [label, arrow_pair])))\n",
        "            self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                dots[0].move_to, dots[1],\n",
        "                dots[1].move_to, dots[0],\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class BeginWithOrdered(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            One must know order\n",
        "            before he can ignore it.\n",
        "        \"\"\")\n",
        "        self.random_blink(3)\n",
        "\n",
        "class DeformToInterval(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        interval = UnitInterval(color = WHITE)\n",
        "        interval.shift(2*DOWN)\n",
        "        numbers = interval.get_number_mobjects(0, 1)\n",
        "        line = Line(interval.get_left(), interval.get_right())\n",
        "        line.insert_n_curves(self.loop.get_num_curves())\n",
        "        line.make_smooth()\n",
        "\n",
        "        self.loop.scale(0.7)\n",
        "        self.loop.to_edge(UP)\n",
        "        original_loop = self.loop.copy()\n",
        "        cut_loop = self.loop.copy()\n",
        "        cut_loop.get_points()[0] += 0.3*(UP+RIGHT)\n",
        "        cut_loop.get_points()[-1] += 0.3*(DOWN+RIGHT)\n",
        "\n",
        "        #Unwrap loop\n",
        "        self.transform_loop(cut_loop, path_arc = np.pi)\n",
        "        self.wait()\n",
        "        self.transform_loop(\n",
        "            line,\n",
        "            run_time = 3,\n",
        "            path_arc = np.pi/2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(interval))\n",
        "        self.play(Write(numbers))\n",
        "        self.wait()\n",
        "\n",
        "        #Follow points\n",
        "        self.loop = original_loop.copy()\n",
        "        self.play(FadeIn(self.loop))\n",
        "        self.add(original_loop)\n",
        "        self.add_dots_at_alphas(*np.linspace(0, 1, 20))\n",
        "        self.dots.set_color_by_gradient(BLUE, MAROON_C, BLUE)\n",
        "        dot_at_1 = self.dots[-1]\n",
        "        dot_at_1.generate_target()\n",
        "        dot_at_1.target.move_to(interval.get_right())\n",
        "        dots_copy = self.dots.copy()\n",
        "        fading_dots = VGroup(*list(self.dots)+list(dots_copy))\n",
        "        end_dots = VGroup(\n",
        "            self.dots[0], self.dots[-1],\n",
        "            dots_copy[0], dots_copy[-1]\n",
        "        )\n",
        "        fading_dots.remove(*end_dots)\n",
        "\n",
        "        self.play(Write(self.dots))\n",
        "        self.add(dots_copy)\n",
        "        self.wait()\n",
        "        self.transform_loop(\n",
        "            line, \n",
        "            added_anims = [MoveToTarget(dot_at_1)],\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.loop = original_loop\n",
        "        self.dots = dots_copy\n",
        "        dot_at_1 = self.dots[-1]\n",
        "        dot_at_1.target.move_to(cut_loop.get_points()[-1])\n",
        "        self.transform_loop(\n",
        "            cut_loop,\n",
        "            added_anims = [MoveToTarget(dot_at_1)]\n",
        "        )\n",
        "        self.wait()\n",
        "        fading_dots.generate_target()\n",
        "        fading_dots.target.set_fill(opacity = 0.3)\n",
        "        self.play(MoveToTarget(fading_dots))\n",
        "        self.play(\n",
        "            end_dots.shift, 0.2*UP, \n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class RepresentPairInUnitSquare(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        interval = UnitInterval(color = WHITE)\n",
        "        interval.shift(2.5*DOWN)\n",
        "        interval.shift(LEFT)\n",
        "        numbers = interval.get_number_mobjects(0, 1)\n",
        "        line = Line(interval.get_left(), interval.get_right())\n",
        "        line.insert_n_curves(self.loop.get_num_curves())\n",
        "        line.make_smooth()\n",
        "        vert_interval = interval.copy()\n",
        "        square = Square()\n",
        "        square.set_width(interval.get_width())\n",
        "        square.set_stroke(width = 0)\n",
        "        square.set_fill(color = BLUE, opacity = 0.3)\n",
        "        square.move_to(\n",
        "            interval.get_left(),\n",
        "            aligned_edge = DOWN+LEFT\n",
        "        )\n",
        "\n",
        "        right_words = VGroup(*[\n",
        "            OldTexText(\"Pair of\\\\\\\\ loop points\"),\n",
        "            OldTex(\"\\\\Downarrow\"),\n",
        "            OldTexText(\"Point in \\\\\\\\ unit square\")\n",
        "        ])\n",
        "        right_words.arrange(DOWN)\n",
        "        right_words.to_edge(RIGHT)\n",
        "\n",
        "        dot_coords = (0.3, 0.7)\n",
        "        self.loop.scale(0.7)\n",
        "        self.loop.to_edge(UP)\n",
        "        self.add_dots_at_alphas(*dot_coords)\n",
        "        self.dots.set_color_by_gradient(GREEN, RED)\n",
        "\n",
        "        self.play(\n",
        "            Write(self.dots),\n",
        "            Write(right_words[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.transform_loop(line)\n",
        "        self.play(\n",
        "            ShowCreation(interval),\n",
        "            Write(numbers),\n",
        "            Animation(self.dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Rotate(mob, np.pi/2, about_point = interval.get_left())\n",
        "            for mob in (vert_interval, self.dots[1])\n",
        "        ])\n",
        "\n",
        "        #Find interior point\n",
        "        point = self.dots[0].get_center()[0]*RIGHT\n",
        "        point += self.dots[1].get_center()[1]*UP\n",
        "        inner_dot = Dot(point, color = YELLOW)\n",
        "        dashed_lines = VGroup(*[\n",
        "            DashedLine(dot, inner_dot, color = dot.get_color())\n",
        "            for dot in self.dots\n",
        "        ])\n",
        "        self.play(ShowCreation(dashed_lines))\n",
        "        self.play(ShowCreation(inner_dot))\n",
        "        self.play(\n",
        "            FadeIn(square),\n",
        "            Animation(self.dots),\n",
        "            *list(map(Write, right_words[1:]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Shift point in square\n",
        "\n",
        "        movers = list(dashed_lines)+list(self.dots)+[inner_dot]\n",
        "        for mob in movers:\n",
        "            mob.generate_target()\n",
        "        shift_vals = [\n",
        "            RIGHT+DOWN, \n",
        "            LEFT+DOWN, \n",
        "            LEFT+2*UP,\n",
        "            3*DOWN,\n",
        "            2*RIGHT+UP,\n",
        "            RIGHT+UP,\n",
        "            3*LEFT+3*DOWN\n",
        "        ]\n",
        "        for shift_val in shift_vals:\n",
        "            inner_dot.target.shift(shift_val)\n",
        "            self.dots[0].target.shift(shift_val[0]*RIGHT)\n",
        "            self.dots[1].target.shift(shift_val[1]*UP)\n",
        "            for line, dot in zip(dashed_lines, self.dots):\n",
        "                line.target.put_start_and_end_on(\n",
        "                    dot.target.get_center(), \n",
        "                    inner_dot.target.get_center()\n",
        "                )\n",
        "            self.play(*list(map(MoveToTarget, movers)))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [dashed_lines, self.dots])))\n",
        "\n",
        "class EdgesOfSquare(Scene):\n",
        "    def construct(self):\n",
        "        square = self.add_square()\n",
        "        x_edges, y_edges = self.get_edges(square)\n",
        "        label_groups = self.get_coordinate_labels(square)\n",
        "        arrow_groups = self.get_arrows(x_edges, y_edges)\n",
        "\n",
        "        for edge in list(x_edges) + list(y_edges):\n",
        "            self.play(ShowCreation(edge))\n",
        "        self.wait()\n",
        "        for label_group in label_groups:\n",
        "            for label in label_group[:3]:\n",
        "                self.play(FadeIn(label))\n",
        "            self.wait()\n",
        "            self.play(Write(VGroup(*label_group[3:])))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(VGroup(*label_groups)))\n",
        "        for arrows in arrow_groups:\n",
        "            self.play(ShowCreation(arrows, run_time = 2))\n",
        "            self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                n.next_to,\n",
        "                square.get_corner(vect+LEFT),\n",
        "                LEFT,\n",
        "                MED_SMALL_BUFF,\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            for n, vect in zip(self.numbers, [DOWN, UP])\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def add_square(self):\n",
        "        interval = UnitInterval(color = WHITE)\n",
        "        interval.shift(2.5*DOWN)\n",
        "        bottom_left = interval.get_left()\n",
        "        for tick in interval.tick_marks:\n",
        "            height = tick.get_height()\n",
        "            tick.scale(0.5)\n",
        "            tick.shift(height*DOWN/4.)\n",
        "        self.numbers = interval.get_number_mobjects(0, 1)\n",
        "        vert_interval = interval.copy()\n",
        "        vert_interval.rotate(np.pi, axis = UP+RIGHT, about_point = bottom_left)\n",
        "        square = Square()\n",
        "        square.set_width(interval.get_width())\n",
        "        square.set_stroke(width = 0)\n",
        "        square.set_fill(color = BLUE, opacity = 0.3)\n",
        "        square.move_to(\n",
        "            bottom_left,\n",
        "            aligned_edge = DOWN+LEFT\n",
        "        )\n",
        "        self.add(interval, self.numbers, vert_interval, square)\n",
        "        return square\n",
        "\n",
        "    def get_edges(self, square):\n",
        "        y_edges = VGroup(*[\n",
        "            Line(\n",
        "                square.get_corner(vect+LEFT),\n",
        "                square.get_corner(vect+RIGHT),\n",
        "            )\n",
        "            for vect in (DOWN, UP)\n",
        "        ])\n",
        "        y_edges.set_color(BLUE)\n",
        "        x_edges = VGroup(*[\n",
        "            Line(\n",
        "                square.get_corner(vect+DOWN),\n",
        "                square.get_corner(vect+UP),\n",
        "            )\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        x_edges.set_color(MAROON_B)\n",
        "        return x_edges, y_edges\n",
        "\n",
        "    def get_coordinate_labels(self, square):\n",
        "        alpha_range = np.arange(0, 1.1, 0.1)\n",
        "        dot_groups = [\n",
        "            VGroup(*[\n",
        "                Dot(interpolate(\n",
        "                    square.get_corner(DOWN+vect),\n",
        "                    square.get_corner(UP+vect),\n",
        "                    alpha\n",
        "                ))\n",
        "                for alpha in alpha_range\n",
        "            ])\n",
        "            for vect in (LEFT, RIGHT)            \n",
        "        ]\n",
        "        for group in dot_groups:\n",
        "            group.set_color_by_gradient(YELLOW, PURPLE_B)\n",
        "        label_groups = [\n",
        "            VGroup(*[\n",
        "                OldTex(\"(%s, %s)\"%(a, b)).scale(0.7)\n",
        "                for b in alpha_range\n",
        "            ])\n",
        "            for a in (0, 1)\n",
        "        ]\n",
        "        for dot_group, label_group in zip(dot_groups, label_groups):\n",
        "            for dot, label in zip(dot_group, label_group):\n",
        "                label[1].set_color(MAROON_B)\n",
        "                label.next_to(dot, RIGHT*np.sign(dot.get_center()[0]))\n",
        "                label.add(dot)\n",
        "        return label_groups\n",
        "\n",
        "    def get_arrows(self, x_edges, y_edges):\n",
        "        alpha_range = np.linspace(0, 1, 4)\n",
        "        return [\n",
        "            VGroup(*[\n",
        "                VGroup(*[\n",
        "                    Arrow(\n",
        "                        edge.point_from_proportion(a1),\n",
        "                        edge.point_from_proportion(a2),\n",
        "                        buff = 0\n",
        "                    )\n",
        "                    for a1, a2 in zip(alpha_range, alpha_range[1:])\n",
        "                ])\n",
        "                for edge in edges\n",
        "            ]).set_color(edges.get_color())\n",
        "            for edges in (x_edges, y_edges)\n",
        "        ]\n",
        "\n",
        "class EndpointsGluedTogether(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        interval = UnitInterval(color = WHITE)\n",
        "        interval.shift(2*DOWN)\n",
        "        numbers = interval.get_number_mobjects(0, 1)\n",
        "        line = Line(interval.get_left(), interval.get_right())\n",
        "        line.insert_n_curves(self.loop.get_num_curves())\n",
        "        line.make_smooth()\n",
        "\n",
        "        self.loop.scale(0.7)\n",
        "        self.loop.to_edge(UP)\n",
        "        original_loop = self.loop\n",
        "        self.remove(original_loop)\n",
        "\n",
        "        self.loop = line\n",
        "        dots = VGroup(*[\n",
        "            Dot(line.get_bounding_box_point(vect))\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        dots.set_color(BLUE)\n",
        "\n",
        "        self.add(interval, dots)\n",
        "        self.play(dots.rotate, np.pi/20, rate_func = wiggle)\n",
        "        self.wait()\n",
        "        self.transform_loop(\n",
        "            original_loop,\n",
        "            added_anims = [\n",
        "                ApplyMethod(dot.move_to, original_loop.get_points()[0])\n",
        "                for dot in dots\n",
        "            ],\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class WrapUpToTorus(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class TorusPlaneAnalogy(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        top_arrow = DoubleArrow(LEFT, RIGHT)\n",
        "        top_arrow.to_edge(UP, buff = 2*LARGE_BUFF)\n",
        "        single_pointed_top_arrow = Arrow(LEFT, RIGHT)\n",
        "        single_pointed_top_arrow.to_edge(UP, buff = 2*LARGE_BUFF)        \n",
        "        low_arrow = DoubleArrow(LEFT, RIGHT).shift(2*DOWN)\n",
        "        self.loop.scale(0.5)\n",
        "        self.loop.next_to(top_arrow, RIGHT)\n",
        "        self.loop.shift_onto_screen()\n",
        "        self.add_dots_at_alphas(0.3, 0.5)\n",
        "        self.dots.set_color_by_gradient(GREEN, RED)\n",
        "\n",
        "        plane = NumberPlane()\n",
        "        plane.scale(0.3).next_to(low_arrow, LEFT)\n",
        "        number_line = NumberLine()\n",
        "        number_line.scale(0.3)\n",
        "        number_line.next_to(low_arrow, RIGHT)\n",
        "        number_line.add(\n",
        "            Dot(number_line.number_to_point(3), color = GREEN),\n",
        "            Dot(number_line.number_to_point(-2), color = RED),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(single_pointed_top_arrow))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(top_arrow))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(plane))\n",
        "        self.play(ShowCreation(low_arrow))\n",
        "        self.play(ShowCreation(number_line))\n",
        "        self.wait()\n",
        "\n",
        "class WigglingPairOfPoints(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        alpha_pairs = [\n",
        "            (0.4, 0.6),\n",
        "            (0.42, 0.62),\n",
        "        ]\n",
        "        self.add_dots_at_alphas(*alpha_pairs[-1])\n",
        "        self.add_connecting_lines()\n",
        "        self.dots.set_color_by_gradient(GREEN, RED)\n",
        "        self.connecting_lines.set_color(YELLOW)\n",
        "        for x, pair in zip(list(range(20)), it.cycle(alpha_pairs)):\n",
        "            self.move_dots_to_alphas(pair, run_time = 0.3)\n",
        "\n",
        "\n",
        "class WigglingTorusPoint(Scene):\n",
        "        def construct(self):\n",
        "            pass    \n",
        "\n",
        "class WhatAboutUnordered(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What about \\\\\\\\ unordered pairs?\"\n",
        "        )\n",
        "        self.play(self.get_teacher().change_mode, \"pondering\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class TrivialPairCollision(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.loop.to_edge(RIGHT)\n",
        "        self.add_dots_at_alphas(0.35, 0.55)\n",
        "        self.dots.set_color_by_gradient(BLUE, YELLOW)\n",
        "        a, b = self.dots\n",
        "        a_label = OldTex(\"a\").next_to(a, RIGHT)\n",
        "        a_label.set_color(a.get_color())\n",
        "        b_label = OldTex(\"b\").next_to(b, LEFT)\n",
        "        b_label.set_color(b.get_color())\n",
        "        line = Line(\n",
        "            a.get_corner(DOWN+LEFT),\n",
        "            b.get_corner(UP+RIGHT),\n",
        "            color = MAROON_B\n",
        "        )\n",
        "        midpoint = Dot(self.dots.get_center(), color = RED)\n",
        "        randy = Randolph(mode = \"pondering\")\n",
        "        randy.next_to(self.loop, LEFT, aligned_edge = DOWN)\n",
        "        randy.look_at(b)\n",
        "        self.add(randy)\n",
        "\n",
        "        for label in a_label, b_label:\n",
        "            self.play(\n",
        "                Write(label, run_time = 1),\n",
        "                randy.look_at, label\n",
        "            )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        swappers = [a, b, a_label, b_label]\n",
        "        for mob in swappers:\n",
        "            mob.save_state()\n",
        "        self.play(\n",
        "            a.move_to, b,\n",
        "            b.move_to, a,\n",
        "            a_label.next_to, b, LEFT,\n",
        "            b_label.next_to, a, RIGHT,\n",
        "            randy.look_at, a,\n",
        "            path_arc = np.pi\n",
        "        )\n",
        "        self.play(ShowCreation(midpoint))\n",
        "        self.play(ShowCreation(line), Animation(midpoint))\n",
        "        self.play(randy.change_mode, \"erm\", randy.look_at, b)\n",
        "        self.play(\n",
        "            randy.look_at, a,\n",
        "            *[m.restore for m in swappers],\n",
        "            path_arc = -np.pi\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class NotHelpful(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "        bubble = morty.get_bubble(SpeechBubble, width = 4, height = 3)\n",
        "        bubble.write(\"Not helpful!\")\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            FadeIn(bubble),\n",
        "            FadeIn(bubble.content),\n",
        "            morty.change_mode, \"angry\",\n",
        "            morty.look, OUT\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class FoldUnitSquare(EdgesOfSquare):\n",
        "    def construct(self):    \n",
        "        self.add_triangles()\n",
        "        self.add_arrows()\n",
        "        self.show_points_to_glue()\n",
        "        self.perform_fold()\n",
        "        self.show_singleton_pairs()\n",
        "        self.ask_about_gluing()\n",
        "        self.clarify_edge_gluing()\n",
        "\n",
        "    def add_triangles(self):\n",
        "        square = self.add_square()\n",
        "        triangles = VGroup(*[\n",
        "            Polygon(*[square.get_corner(vect) for vect in vects])\n",
        "            for vects in [\n",
        "                (DOWN+LEFT, UP+RIGHT, UP+LEFT),            \n",
        "                (DOWN+LEFT, UP+RIGHT, DOWN+RIGHT),\n",
        "            ]\n",
        "        ])\n",
        "        triangles.set_stroke(width = 0)\n",
        "        triangles.set_fill(\n",
        "            color = square.get_color(), \n",
        "            opacity = square.get_fill_opacity()\n",
        "        )\n",
        "        self.remove(square)\n",
        "        self.square = square\n",
        "        self.add(triangles)\n",
        "        self.triangles = triangles\n",
        "\n",
        "    def add_arrows(self):\n",
        "        start_arrows = VGroup()\n",
        "        end_arrows = VGroup()\n",
        "        colors = MAROON_B, BLUE\n",
        "        for a in 0, 1:        \n",
        "            for color in colors:\n",
        "                b_range = np.linspace(0, 1, 4)\n",
        "                for b1, b2 in zip(b_range, b_range[1:]):\n",
        "                    arrow = Arrow(\n",
        "                        self.get_point_from_coords(a, b1),\n",
        "                        self.get_point_from_coords(a, b2),\n",
        "                        buff = 0,\n",
        "                        color = color\n",
        "                    )\n",
        "                    if color is BLUE:\n",
        "                        arrow.rotate(\n",
        "                            -np.pi/2, \n",
        "                            about_point = self.square.get_center()\n",
        "                        )\n",
        "                    if (a is 0):\n",
        "                        start_arrows.add(arrow)\n",
        "                    else:\n",
        "                        end_arrows.add(arrow)\n",
        "        self.add(start_arrows, end_arrows)\n",
        "        self.start_arrows = start_arrows\n",
        "        self.end_arrows = VGroup(*list(end_arrows[3:])+list(end_arrows[:3])).copy()\n",
        "        self.end_arrows.set_color(\n",
        "            color_gradient([MAROON_B, BLUE], 3)[1]\n",
        "        )\n",
        "\n",
        "    def show_points_to_glue(self):\n",
        "        colors = YELLOW, MAROON_B, PINK\n",
        "        pairs = [(0.2, 0.3), (0.5, 0.7), (0.25, 0.6)]\n",
        "        unit = self.square.get_width()\n",
        "\n",
        "        start_dots = VGroup()\n",
        "        end_dots = VGroup()\n",
        "        for (x, y), color in zip(pairs, colors):\n",
        "            old_x_line, old_y_line = None, None\n",
        "            for (a, b) in (x, y), (y, x):\n",
        "                point = self.get_point_from_coords(a, b)\n",
        "                dot = Dot(point)\n",
        "                dot.set_color(color)\n",
        "                if color == colors[-1]:\n",
        "                    s = \"(x, y)\" if a < b else \"(y, x)\"\n",
        "                    label = OldTex(s)\n",
        "                else:\n",
        "                    label = OldTex(\"(%.01f, %.01f)\"%(a, b))\n",
        "                vect = UP+RIGHT if a < b else DOWN+RIGHT\n",
        "                label.next_to(dot, vect, buff = SMALL_BUFF)\n",
        "\n",
        "                self.play(*list(map(FadeIn, [dot, label])))\n",
        "                x_line = Line(point+a*unit*LEFT, point)\n",
        "                y_line = Line(point+b*unit*DOWN, point)\n",
        "                x_line.set_color(GREEN)\n",
        "                y_line.set_color(RED)\n",
        "                if old_x_line is None:\n",
        "                    self.play(ShowCreation(x_line), Animation(dot))\n",
        "                    self.play(ShowCreation(y_line), Animation(dot))\n",
        "                    old_x_line, old_y_line = y_line, x_line\n",
        "                else:\n",
        "                    self.play(Transform(old_x_line, x_line), Animation(dot))\n",
        "                    self.play(Transform(old_y_line, y_line), Animation(dot))\n",
        "                    self.remove(old_x_line, old_y_line)\n",
        "                    self.add(x_line, y_line, dot)\n",
        "                self.wait(2)\n",
        "                self.play(FadeOut(label))\n",
        "                if a < b:\n",
        "                    start_dots.add(dot)\n",
        "                else:\n",
        "                    end_dots.add(dot)\n",
        "            self.play(*list(map(FadeOut, [x_line, y_line])))\n",
        "        self.start_dots, self.end_dots = start_dots, end_dots\n",
        "\n",
        "    def perform_fold(self):\n",
        "        diag_line = DashedLine(\n",
        "            self.square.get_corner(DOWN+LEFT),\n",
        "            self.square.get_corner(UP+RIGHT),\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(diag_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(*self.triangles),\n",
        "            Transform(self.start_dots, self.end_dots),\n",
        "            Transform(self.start_arrows, self.end_arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.diag_line = diag_line\n",
        "\n",
        "    def show_singleton_pairs(self):\n",
        "        xs = [0.7, 0.4, 0.5]\n",
        "        old_label = None\n",
        "        old_dot = None\n",
        "        for x in xs:\n",
        "            point = self.get_point_from_coords(x, x)\n",
        "            dot = Dot(point)\n",
        "            if x is xs[-1]:\n",
        "                label = OldTex(\"(x, x)\")\n",
        "            else:\n",
        "                label = OldTex(\"(%.1f, %.1f)\"%(x, x))\n",
        "            label.next_to(dot, UP+LEFT, buff = SMALL_BUFF)\n",
        "            VGroup(dot, label).set_color(RED)\n",
        "            if old_label is None:\n",
        "                self.play(\n",
        "                    ShowCreation(dot),\n",
        "                    Write(label)\n",
        "                )\n",
        "                old_label = label\n",
        "                old_dot = dot\n",
        "            else:\n",
        "                self.play(\n",
        "                    Transform(old_dot, dot),\n",
        "                    Transform(old_label, label),\n",
        "                )\n",
        "            self.wait()\n",
        "        #Some strange bug necesitating this\n",
        "        self.remove(old_label)\n",
        "        self.add(label)\n",
        "\n",
        "    def ask_about_gluing(self):\n",
        "        keepers = VGroup(\n",
        "            self.triangles[0],\n",
        "            self.start_arrows,\n",
        "            self.diag_line\n",
        "        ).copy()\n",
        "        faders = VGroup(*self.get_mobjects())\n",
        "        randy = Randolph()\n",
        "        randy.next_to(ORIGIN, DOWN)\n",
        "        bubble = randy.get_bubble(height = 4, width = 6)\n",
        "        bubble.write(\"How do you \\\\\\\\ glue those arrows?\")\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(faders),\n",
        "            Animation(keepers)\n",
        "        )\n",
        "        self.play(\n",
        "            keepers.scale, 0.6,\n",
        "            keepers.shift, 4*RIGHT + UP,\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, keepers,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.randy = randy\n",
        "\n",
        "    def clarify_edge_gluing(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot(self.get_point_from_coords(*coords), radius = 0.1)\n",
        "            for coords in [\n",
        "                (0.1, 0),\n",
        "                (1, 0.1),\n",
        "                (0.9, 0),\n",
        "                (1, 0.9),\n",
        "            ]\n",
        "        ])\n",
        "        dots.scale(0.6)\n",
        "        dots.shift(4*RIGHT + UP)\n",
        "        for dot in dots[:2]:\n",
        "            dot.set_color(YELLOW)\n",
        "            self.play(\n",
        "                ShowCreation(dot),\n",
        "                self.randy.look_at, dot\n",
        "            )\n",
        "        self.wait()\n",
        "        for dot in dots[2:]:\n",
        "            dot.set_color(MAROON_B)\n",
        "            self.play(\n",
        "                ShowCreation(dot),\n",
        "                self.randy.look_at, dot\n",
        "            )\n",
        "        self.play(Blink(self.randy))\n",
        "        self.wait()\n",
        "\n",
        "    def get_point_from_coords(self, x, y):\n",
        "        left, right, bottom, top = [\n",
        "            self.triangles.get_edge_center(vect)\n",
        "            for vect in (LEFT, RIGHT, DOWN, UP)\n",
        "        ]\n",
        "        x_point = interpolate(left, right, x)\n",
        "        y_point = interpolate(bottom, top, y)\n",
        "        return x_point[0]*RIGHT + y_point[1]*UP\n",
        "\n",
        "class PrepareForMobiusStrip(Scene):\n",
        "    def construct(self):\n",
        "        self.add_triangles()\n",
        "        self.perform_cut()\n",
        "        self.rearrange_pieces()\n",
        "\n",
        "    def add_triangles(self):\n",
        "        triangles = VGroup(\n",
        "            Polygon(\n",
        "                DOWN+LEFT,\n",
        "                DOWN+RIGHT,\n",
        "                ORIGIN,\n",
        "            ),\n",
        "            Polygon(\n",
        "                DOWN+RIGHT,\n",
        "                UP+RIGHT,          \n",
        "                ORIGIN,\n",
        "            ),\n",
        "        )\n",
        "        triangles.set_fill(color = BLUE, opacity = 0.6)\n",
        "        triangles.set_stroke(width = 0)\n",
        "        triangles.center()\n",
        "        triangles.scale(2)\n",
        "        arrows_color = color_gradient([PINK, BLUE], 3)[1]\n",
        "        for tri in triangles:\n",
        "            anchors = tri.get_anchors_and_handles()[0]\n",
        "            alpha_range = np.linspace(0, 1, 4)\n",
        "            arrows = VGroup(*[\n",
        "                Arrow(\n",
        "                    interpolate(anchors[0], anchors[1], a),\n",
        "                    interpolate(anchors[0], anchors[1], b),\n",
        "                    buff = 0,\n",
        "                    color = arrows_color\n",
        "                )\n",
        "                for a, b in zip(alpha_range, alpha_range[1:])\n",
        "            ])\n",
        "            tri.original_arrows = arrows\n",
        "            tri.add(arrows)\n",
        "            i, j, k = (0, 2, 1) if tri is triangles[0] else (1, 2, 0)\n",
        "            dashed_line = DashedLine(\n",
        "                anchors[i], anchors[j], \n",
        "                color = RED\n",
        "            )\n",
        "            tri.add(dashed_line)\n",
        "\n",
        "            #Add but don't draw cut_arrows\n",
        "            start, end = anchors[j], anchors[k]\n",
        "            cut_arrows = VGroup(*[\n",
        "                Arrow(\n",
        "                    interpolate(start, end, a),\n",
        "                    interpolate(start, end, b),\n",
        "                    buff = 0,\n",
        "                    color = YELLOW\n",
        "                )\n",
        "                for a, b in zip(alpha_range, alpha_range[1:])\n",
        "            ])\n",
        "            tri.cut_arrows = cut_arrows\n",
        "        self.add(triangles)\n",
        "        self.triangles = triangles\n",
        "\n",
        "    def perform_cut(self):\n",
        "        tri1, tri2 = self.triangles\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(tri1.cut_arrows))\n",
        "        for tri in self.triangles:\n",
        "            tri.add(tri.cut_arrows)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            tri1.shift, (DOWN+LEFT)/2.,\n",
        "            tri2.shift, (UP+RIGHT)/2.,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def rearrange_pieces(self):\n",
        "        tri1, tri2 = self.triangles\n",
        "        self.play(\n",
        "            tri1.rotate, np.pi, UP+RIGHT,\n",
        "            tri1.next_to, ORIGIN, RIGHT,\n",
        "            tri2.next_to, ORIGIN, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(tri.shift, tri.get_points()[0][0]*LEFT)\n",
        "            for tri in self.triangles\n",
        "        ])\n",
        "        self.play(*[\n",
        "            FadeOut(tri.original_arrows)\n",
        "            for tri in self.triangles\n",
        "        ])\n",
        "        for tri in self.triangles:\n",
        "            tri.remove(tri.original_arrows)\n",
        "        self.wait()\n",
        "        # self.play(*[\n",
        "        #     ApplyMethod(tri.rotate, -np.pi/4)\n",
        "        #     for tri in self.triangles\n",
        "        # ])\n",
        "        # self.wait()\n",
        "\n",
        "class FoldToMobius(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class MobiusPlaneAnalogy(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        top_arrow = Arrow(LEFT, RIGHT)\n",
        "        top_arrow.to_edge(UP, buff = 2*LARGE_BUFF)\n",
        "        low_arrow = Arrow(LEFT, RIGHT).shift(2*DOWN)\n",
        "        self.loop.scale(0.5)\n",
        "        self.loop.next_to(top_arrow, RIGHT)\n",
        "        self.loop.shift_onto_screen()\n",
        "        self.add_dots_at_alphas(0.3, 0.5)\n",
        "        self.dots.set_color(PURPLE_B)\n",
        "\n",
        "        plane = NumberPlane()\n",
        "        plane.scale(0.3).next_to(low_arrow, LEFT)\n",
        "        number_line = NumberLine()\n",
        "        number_line.scale(0.3)\n",
        "        number_line.next_to(low_arrow, RIGHT)\n",
        "        number_line.add(\n",
        "            Dot(number_line.number_to_point(3), color = GREEN),\n",
        "            Dot(number_line.number_to_point(-2), color = RED),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(top_arrow))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(plane))\n",
        "        self.play(ShowCreation(low_arrow))\n",
        "        self.play(ShowCreation(number_line))\n",
        "        self.wait()\n",
        "\n",
        "class DrawRightArrow(Scene):\n",
        "    CONFIG = {\n",
        "        \"tex\" : \"\\\\Rightarrow\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        arrow = OldTex(self.tex)\n",
        "        arrow.scale(4)\n",
        "        self.play(Write(arrow))\n",
        "        self.wait()\n",
        "\n",
        "class DrawLeftrightArrow(DrawRightArrow):\n",
        "    CONFIG = {\n",
        "        \"tex\" : \"\\\\Leftrightarrow\"\n",
        "    }\n",
        "\n",
        "class MobiusToPairToSurface(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.loop.scale(0.5)\n",
        "        self.loop.next_to(ORIGIN, RIGHT)\n",
        "        self.loop.to_edge(UP)\n",
        "        self.add_dots_at_alphas(0.4, 0.6)\n",
        "        self.dots.set_color(MAROON_B)\n",
        "        self.add_connecting_lines()\n",
        "        strip_dot = Dot().next_to(self.loop, LEFT, buff = 2*LARGE_BUFF)\n",
        "        surface_dot = Dot().next_to(self.loop, DOWN, buff = 2*LARGE_BUFF)\n",
        "\n",
        "        top_arrow = Arrow(strip_dot, self.loop)\n",
        "        right_arrow = Arrow(self.loop, surface_dot)\n",
        "        diag_arrow = Arrow(strip_dot, surface_dot)\n",
        "\n",
        "        randy = self.randy = Randolph(mode = \"pondering\")\n",
        "        randy.next_to(ORIGIN, DOWN+LEFT)\n",
        "\n",
        "        self.look_at(strip_dot)\n",
        "        self.play(\n",
        "            ShowCreation(top_arrow),\n",
        "            randy.look_at, self.loop\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(strip_dot, surface_dot)\n",
        "        self.play(ShowCreation(diag_arrow))\n",
        "        self.play(Blink(randy))\n",
        "        self.look_at(strip_dot, self.loop)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(right_arrow),\n",
        "            randy.look_at, surface_dot\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"happy\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def look_at(self, *things):\n",
        "        for thing in things:\n",
        "            self.play(self.randy.look_at, thing)\n",
        "\n",
        "class MapMobiusStripOntoSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class StripMustIntersectItself(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            The strip must \n",
        "            intersect itself\n",
        "            during this process\n",
        "            \"\"\",\n",
        "            width = 4\n",
        "        )\n",
        "        dot = Dot(2*UP + 4*LEFT)\n",
        "        for student in self.get_students():\n",
        "            student.generate_target()\n",
        "            student.target.change_mode(\"pondering\")\n",
        "            student.target.look_at(dot)\n",
        "        self.play(*list(map(MoveToTarget, self.get_students())))\n",
        "        self.random_blink(4)\n",
        "\n",
        "class PairOfMobiusPointsLandOnEachother(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class ThatsTheProof(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            Bada boom\n",
        "            bada bang!\n",
        "            \"\"\",\n",
        "            target_mode = \"hooray\",\n",
        "            width = 4\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.random_blink()\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"sassy\", \"erm\"\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            If you trust\n",
        "            the mobius strip \n",
        "            fact...\n",
        "            \"\"\",\n",
        "            target_mode = \"guilty\",            \n",
        "            width = 4,\n",
        "        )\n",
        "        self.random_blink()\n",
        "\n",
        "class TryItYourself(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            It's actually an\n",
        "            edifying exercise.\n",
        "        \"\"\")\n",
        "        self.random_blink()\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink(2)\n",
        "\n",
        "        pi = self.get_students()[1]\n",
        "        bubble = pi.get_bubble(\n",
        "            \"thought\", \n",
        "            width = 4, height = 4,\n",
        "            direction = RIGHT\n",
        "        )\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "        bubble.write(\"Orientation seem\\\\\\\\ to matter...\")\n",
        "        self.play(\n",
        "            FadeIn(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.random_blink(3)\n",
        "\n",
        "class OneMoreAnimation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            One more animation,\n",
        "            but first...\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink()\n",
        "\n",
        "class PatreonThanks(Scene):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Loo Yu Jun\",\n",
        "            \"Tom\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Juan Batiz-Benet\",\n",
        "            \"Markus Persson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk Werklund\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"PatrickJMT  \",\n",
        "            \"Felipe Diniz\",\n",
        "        ]\n",
        "    }\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "\n",
        "        n_patrons = len(self.specific_patrons)\n",
        "        special_thanks = OldTexText(\"Special thanks to:\")\n",
        "        special_thanks.set_color(YELLOW)\n",
        "        special_thanks.shift(2*UP)\n",
        "\n",
        "        left_patrons = VGroup(*list(map(TexText, \n",
        "            self.specific_patrons[:n_patrons/2]\n",
        "        )))\n",
        "        right_patrons = VGroup(*list(map(TexText, \n",
        "            self.specific_patrons[n_patrons/2:]\n",
        "        )))\n",
        "        for patrons, vect in (left_patrons, LEFT), (right_patrons, RIGHT):\n",
        "            patrons.arrange(DOWN, aligned_edge = LEFT)\n",
        "            patrons.next_to(special_thanks, DOWN)\n",
        "            patrons.to_edge(vect, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(morty.change_mode, \"gracious\")\n",
        "        self.play(Write(special_thanks, run_time = 1))\n",
        "        self.play(\n",
        "            Write(left_patrons),\n",
        "            morty.look_at, left_patrons\n",
        "        )\n",
        "        self.play(\n",
        "            Write(right_patrons),\n",
        "            morty.look_at, right_patrons\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        for patrons in left_patrons, right_patrons:\n",
        "            for index in 0, -1:\n",
        "                self.play(morty.look_at, patrons[index])\n",
        "                self.wait()\n",
        "\n",
        "class CreditTWo(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "        morty.to_edge(RIGHT)\n",
        "\n",
        "        brother = PiCreature(color = GOLD_E)\n",
        "        brother.next_to(morty, LEFT)\n",
        "        brother.look_at(morty.eyes)\n",
        "        \n",
        "        headphones = Headphones(height = 1)\n",
        "        headphones.move_to(morty.eyes, aligned_edge = DOWN)\n",
        "        headphones.shift(0.1*DOWN)\n",
        "\n",
        "        url = OldTexText(\"www.audible.com/3b1b\")\n",
        "        url.to_corner(UP+RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeIn(headphones), \n",
        "            Write(url),\n",
        "            Animation(morty)\n",
        "        )\n",
        "        self.play(morty.change_mode, \"happy\")\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(brother),\n",
        "            morty.look_at, brother.eyes\n",
        "        )\n",
        "        self.play(brother.change_mode, \"surprised\")\n",
        "        self.play(Blink(brother))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.look, LEFT,\n",
        "            brother.change_mode, \"happy\",\n",
        "            brother.look, LEFT\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class CreditThree(Scene):\n",
        "    def construct(self):\n",
        "        logo_dot = Dot().to_edge(UP).shift(3*RIGHT)\n",
        "        randy = Randolph()\n",
        "        randy.next_to(ORIGIN, DOWN)\n",
        "        randy.to_edge(LEFT)\n",
        "        randy.look(RIGHT)\n",
        "        self.add(randy)\n",
        "        bubble = randy.get_bubble(width = 2, height = 2)\n",
        "\n",
        "        domains = VGroup(*list(map(TexText, [\n",
        "            \"visualnumbertheory.com\",\n",
        "            \"buymywidgets.com\",\n",
        "            \"learnwhatilearn.com\",\n",
        "        ])))\n",
        "        domains.arrange(DOWN, aligned_edge = LEFT)\n",
        "        domains.next_to(randy, UP, buff = LARGE_BUFF)\n",
        "        domains.shift_onto_screen()\n",
        "\n",
        "        promo_code = OldTexText(\"Promo code: TOPOLOGY\")\n",
        "        promo_code.shift(3*RIGHT)\n",
        "        self.add(promo_code)\n",
        "        whois = OldTexText(\"Free WHOIS privacy\")\n",
        "        whois.next_to(promo_code, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"happy\",\n",
        "            randy.look_at, logo_dot\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            randy.change_mode, \"pondering\",\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            Transform(bubble, VectorizedPoint(randy.get_corner(UP+LEFT))),\n",
        "            randy.change_mode, \"sad\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(domains, run_time = 5),\n",
        "            randy.look_at, domains\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"hooray\",\n",
        "            randy.look_at, logo_dot,\n",
        "            FadeOut(domains)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(whois),\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, whois\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(randy.change_mode, \"sassy\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            randy.change_mode, \"happy\",\n",
        "            randy.look_at, logo_dot\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShiftingLoopPairSurface(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class ThumbnailImage(ClosedLoopScene):\n",
        "    def construct(self):\n",
        "        self.add_rect_dots(square = True)\n",
        "        for dot in self.dots:\n",
        "            dot.scale(1.5)\n",
        "        self.add_connecting_lines(cyclic = True)\n",
        "        self.connecting_lines.set_stroke(width = 10)\n",
        "        self.loop.add(self.connecting_lines, self.dots)\n",
        "\n",
        "        title = OldTexText(\"Unsolved\")\n",
        "        title.scale(2.5)\n",
        "        title.to_edge(UP)\n",
        "        title.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "        self.add(title)\n",
        "        self.loop.next_to(title, DOWN, buff = MED_SMALL_BUFF)\n",
        "        self.loop.shift(2*LEFT)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}