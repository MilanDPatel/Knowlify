{
    "topic": "The mathematical concept being demonstrated is the convergence of a divergent series. The code demonstrates how to",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "import operator as op\n",
        "from random import sample\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from script_wrapper import command_line_create_scene\n",
        "from functools import reduce\n",
        "\n",
        "# from inventing_math_images import *\n",
        "\n",
        "MOVIE_PREFIX = \"inventing_math/\"\n",
        "DIVERGENT_SUM_TEXT = [\n",
        "    \"1\", \n",
        "    \"+2\", \n",
        "    \"+4\", \n",
        "    \"+8\", \n",
        "    \"+\\\\cdots\",\n",
        "    \"+2^n\",\n",
        "    \"+\\\\cdots\", \n",
        "    \"= -1\",\n",
        "]\n",
        "\n",
        "CONVERGENT_SUM_TEXT = [\n",
        "    \"\\\\frac{1}{2}\",\n",
        "    \"+\\\\frac{1}{4}\",\n",
        "    \"+\\\\frac{1}{8}\",\n",
        "    \"+\\\\frac{1}{16}\",\n",
        "    \"+\\\\cdots\",\n",
        "    \"+\\\\frac{1}{2^n}\",\n",
        "    \"+\\\\cdots\",\n",
        "    \"=1\",\n",
        "]\n",
        "\n",
        "CONVERGENT_SUM_TERMS = [\n",
        "    \"\\\\frac{1}{2}\",\n",
        "    \"\\\\frac{1}{4}\",\n",
        "    \"\\\\frac{1}{8}\",\n",
        "    \"\\\\frac{1}{16}\",\n",
        "]\n",
        "\n",
        "PARTIAL_CONVERGENT_SUMS_TEXT = [\n",
        "    \"\\\\frac{1}{2}\",\n",
        "    \"\", \"\", \",\\\\quad\",\n",
        "    \"\\\\frac{1}{2} + \\\\frac{1}{4}\",\n",
        "    \"=\", \"\\\\frac{3}{4}\", \",\\\\quad\",\n",
        "    \"\\\\frac{1}{2} + \\\\frac{1}{4} + \\\\frac{1}{8}\",\n",
        "    \"=\", \"\\\\frac{7}{8}\", \",\\\\quad\",\n",
        "    \"\\\\frac{1}{2} + \\\\frac{1}{4} + \\\\frac{1}{8} + \\\\frac{1}{16}\",\n",
        "    \"=\", \"\\\\frac{15}{16}\", \",\\\\dots\"\n",
        "]\n",
        "\n",
        "def partial_sum(n):\n",
        "    return sum([1.0/2**(k+1) for k in range(n)])\n",
        "\n",
        "ALT_PARTIAL_SUM_TEXT = reduce(op.add, [\n",
        "    [str(partial_sum(n)), \"&=\", \"+\".join(CONVERGENT_SUM_TERMS[:n])+\"\\\\\\\\\"]\n",
        "    for n in range(1, len(CONVERGENT_SUM_TERMS)+1)\n",
        "])+ [\n",
        "    \"\\\\vdots\", \"&\", \"\\\\\\\\\",\n",
        "    \"1.0\", \"&=\", \"+\".join(CONVERGENT_SUM_TERMS)+\"+\\\\cdots+\\\\frac{1}{2^n}+\\\\cdots\"\n",
        "]\n",
        "\n",
        "\n",
        "NUM_WRITTEN_TERMS = 4\n",
        "INTERVAL_RADIUS = 5\n",
        "NUM_INTERVAL_TICKS = 16\n",
        "\n",
        "\n",
        "def divergent_sum():\n",
        "    return OldTex(DIVERGENT_SUM_TEXT, size = \"\\\\large\").scale(2)\n",
        "\n",
        "def convergent_sum():\n",
        "    return OldTex(CONVERGENT_SUM_TEXT, size = \"\\\\large\").scale(2)\n",
        "\n",
        "def Underbrace(left, right):\n",
        "    result = OldTex(\"\\\\Underbrace{%s}\"%(14*\"\\\\quad\"))\n",
        "    result.stretch_to_fit_width(right[0]-left[0])\n",
        "    result.shift(left - result.get_points()[0])\n",
        "    return result\n",
        "\n",
        "def zero_to_one_interval():\n",
        "    interval = NumberLine(\n",
        "        radius = INTERVAL_RADIUS,\n",
        "        interval_size = 2.0*INTERVAL_RADIUS/NUM_INTERVAL_TICKS\n",
        "    )\n",
        "    interval.elongate_tick_at(-INTERVAL_RADIUS, 4)\n",
        "    interval.elongate_tick_at(INTERVAL_RADIUS, 4)\n",
        "    zero = OldTex(\"0\").shift(INTERVAL_RADIUS*LEFT+DOWN)\n",
        "    one = OldTex(\"1\").shift(INTERVAL_RADIUS*RIGHT+DOWN)\n",
        "    return Mobject(interval, zero, one)\n",
        "\n",
        "def draw_you(with_bubble = False):\n",
        "    result = PiCreature()\n",
        "    result.give_straight_face().set_color(\"grey\")\n",
        "    result.to_corner(LEFT+DOWN)\n",
        "    result.rewire_part_attributes()\n",
        "    if with_bubble:\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.stretch_to_fit_width(11)\n",
        "        bubble.pin_to(result)\n",
        "        return result, bubble\n",
        "    return result\n",
        "\n",
        "def get_room_colors():\n",
        "    return list(Color(\"yellow\").range_to(\"red\", 4))\n",
        "\n",
        "def power_of_divisor(n, d):\n",
        "    result = 0\n",
        "    while n%d == 0:\n",
        "        result += 1\n",
        "        n /= d\n",
        "    return result\n",
        "\n",
        "class FlipThroughNumbers(Animation):\n",
        "    def __init__(self, function = lambda x : x, \n",
        "                 start = 0, end = 10, \n",
        "                 start_center = ORIGIN,\n",
        "                 end_center = ORIGIN,\n",
        "                 **kwargs):\n",
        "        self.function = function\n",
        "        self.start = start\n",
        "        self.end = end\n",
        "        self.start_center = start_center\n",
        "        self.end_center = end_center\n",
        "        self.current_number = function(start)\n",
        "        mobject = OldTex(str(self.current_number)).shift(start_center)\n",
        "        Animation.__init__(self, mobject, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        new_number = self.function(\n",
        "            self.start + int(alpha *(self.end-self.start))\n",
        "        )\n",
        "        if new_number != self.current_number:\n",
        "            self.current_number = new_number\n",
        "            self.mobject = OldTex(str(new_number)).shift(self.start_center)\n",
        "        if not all(self.start_center == self.end_center):\n",
        "            self.mobject.center().shift(\n",
        "                (1-alpha)*self.start_center + alpha*self.end_center\n",
        "            )\n",
        "\n",
        "\n",
        "######################################\n",
        "\n",
        "class IntroduceDivergentSum(Scene):\n",
        "    def construct(self):\n",
        "        equation = divergent_sum().split()\n",
        "        sum_value = None\n",
        "        brace = Underbrace(\n",
        "            equation[0].get_boundary_point(DOWN+LEFT),\n",
        "            equation[1].get_boundary_point(DOWN+RIGHT)\n",
        "        ).shift(0.2*DOWN)\n",
        "        min_x_coord = min(equation[0].get_points()[:,0])\n",
        "        for x in range(NUM_WRITTEN_TERMS):\n",
        "            self.add(equation[x])\n",
        "            if x == 0:\n",
        "                self.wait(0.75)\n",
        "                continue\n",
        "            brace.stretch_to_fit_width(\n",
        "                max(equation[x].get_points()[:,0]) - min_x_coord\n",
        "            )\n",
        "            brace.to_edge(LEFT, buff = FRAME_X_RADIUS+min_x_coord)\n",
        "            if sum_value:\n",
        "                self.remove(sum_value)\n",
        "            sum_value = OldTex(str(2**(x+1) - 1))\n",
        "            sum_value.shift(brace.get_center() + 0.5*DOWN)\n",
        "            self.add(brace, sum_value)\n",
        "            self.wait(0.75)\n",
        "        self.remove(sum_value)\n",
        "        ellipses = Mobject(\n",
        "            *[equation[NUM_WRITTEN_TERMS + i] for i in range(3)]\n",
        "        )\n",
        "        end_brace = deepcopy(brace).stretch_to_fit_width(\n",
        "            max(ellipses.get_points()[:,0])-min_x_coord\n",
        "        ).to_edge(LEFT, buff = FRAME_X_RADIUS+min_x_coord)\n",
        "        kwargs = {\"run_time\" : 5.0, \"rate_func\" : rush_into}        \n",
        "        flip_through = FlipThroughNumbers(\n",
        "            lambda x : 2**(x+1)-1,\n",
        "            start = NUM_WRITTEN_TERMS-1,\n",
        "            end = 50,\n",
        "            start_center = brace.get_center() + 0.5*DOWN,\n",
        "            end_center = end_brace.get_center() + 0.5*DOWN,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.add(ellipses)\n",
        "        self.play(\n",
        "            Transform(brace, end_brace, **kwargs),\n",
        "            flip_through,\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(*equation)\n",
        "        self.wait()\n",
        "\n",
        "class ClearlyNonsense(Scene):\n",
        "    def construct(self):\n",
        "        number_line = NumberLine().add_numbers()\n",
        "        div_sum = divergent_sum()\n",
        "        this_way = OldTexText(\"Sum goes this way...\")\n",
        "        this_way.to_edge(LEFT).shift(RIGHT*(FRAME_X_RADIUS+1) + DOWN)\n",
        "        how_here = OldTexText(\"How does it end up here?\")\n",
        "        how_here.shift(1.5*UP+LEFT)\n",
        "        neg_1_arrow = Arrow(\n",
        "            (-1, 0.3, 0), \n",
        "            tail=how_here.get_center()+0.5*DOWN\n",
        "        )\n",
        "        right_arrow = Arrow(\n",
        "            (FRAME_X_RADIUS-0.5)*RIGHT + DOWN, \n",
        "            tail = (max(this_way.get_points()[:,0]), -1, 0)\n",
        "        )\n",
        "        how_here.set_color(\"red\")\n",
        "        neg_1_arrow.set_color(\"red\")\n",
        "        this_way.set_color(\"yellow\")\n",
        "        right_arrow.set_color(\"yellow\")\n",
        "\n",
        "        self.play(Transform(\n",
        "            div_sum, \n",
        "            deepcopy(div_sum).scale(0.5).shift(3*UP)\n",
        "        ))\n",
        "        self.play(ShowCreation(number_line))\n",
        "        self.wait()\n",
        "        self.add(how_here)\n",
        "        self.play(ShowCreation(neg_1_arrow))\n",
        "        self.wait()\n",
        "        self.add(this_way)\n",
        "        self.play(ShowCreation(right_arrow))\n",
        "        self.wait()\n",
        "\n",
        "class OutlineOfVideo(Scene):\n",
        "    def construct(self):\n",
        "        conv_sum = convergent_sum().scale(0.5)\n",
        "        div_sum = divergent_sum().scale(0.5)\n",
        "        overbrace = Underbrace(\n",
        "            conv_sum.get_left(),\n",
        "            conv_sum.get_right()\n",
        "        ).rotate(np.pi, RIGHT).shift(0.75*UP*conv_sum.get_height())\n",
        "        dots = conv_sum.split()[-2].set_color(\"green\")\n",
        "        dots.sort_points()\n",
        "        arrow = Arrow(\n",
        "            dots.get_bottom(),\n",
        "            direction = UP+LEFT\n",
        "        )\n",
        "        u_brace = Underbrace(div_sum.get_left(), div_sum.get_right())\n",
        "        u_brace.shift(1.5*div_sum.get_bottom())\n",
        "        for mob in conv_sum, overbrace, arrow, dots:\n",
        "            mob.shift(2*UP)\n",
        "        for mob in div_sum, u_brace:\n",
        "            mob.shift(DOWN)\n",
        "        texts = [\n",
        "            OldTexText(words).set_color(\"yellow\")\n",
        "            for words in [\n",
        "                \"1. Discover this\",\n",
        "                \"2. Clarify what this means\",\n",
        "                \"3. Discover this\",\n",
        "                [\"4. Invent \", \"\\\\textbf{new math}\"]\n",
        "            ]\n",
        "        ]\n",
        "        last_one_split = texts[-1].split()\n",
        "        last_one_split[1].set_color(\"skyblue\")\n",
        "        texts[-1] = Mobject(*last_one_split)\n",
        "        texts[0].shift(overbrace.get_top()+texts[0].get_height()*UP)\n",
        "        texts[1].shift(sum([\n",
        "            arrow.get_boundary_point(DOWN+RIGHT),\n",
        "            texts[1].get_height()*DOWN\n",
        "        ]))\n",
        "        texts[2].shift(u_brace.get_bottom()+texts[3].get_height()*DOWN)\n",
        "        texts[3].to_edge(DOWN)\n",
        "\n",
        "        groups = [\n",
        "            [texts[0], overbrace, conv_sum],\n",
        "            [texts[1], arrow, dots],\n",
        "            [texts[2], u_brace, div_sum],\n",
        "            [texts[3]]\n",
        "        ]\n",
        "        for group in groups:\n",
        "            self.play(*[\n",
        "                DelayByOrder(FadeIn(element))\n",
        "                for element in group\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "# # class ReasonsForMakingVideo(Scene):\n",
        "# #     def construct(self):\n",
        "# #         text = OldTexText([\n",
        "# #             \"\"\"\n",
        "# #             \\\\begin{itemize}\n",
        "# #             \\\\item Understand what ``$\n",
        "# #             \"\"\",\n",
        "# #             \"\".join(DIVERGENT_SUM_TEXT),\n",
        "# #             \"\"\"\n",
        "# #             $'' is saying.\n",
        "# #             \"\"\",\n",
        "# #             \"\"\"\n",
        "# #             \\\\item Nonsense-Driven Construction\n",
        "# #             \\\\end{itemize}\n",
        "# #             \"\"\"\n",
        "# #         ], size = \"\\\\Small\")\n",
        "# #         text.scale(1.5).to_edge(LEFT).shift(UP).set_color(\"white\")\n",
        "# #         text.set_color(\"green\", lambda (x, y, z) : x < -FRAME_X_RADIUS + 1)\n",
        "# #         line_one_first, equation, line_one_last, line_two = text.split()\n",
        "# #         line_two.shift(2*DOWN)\n",
        "# #         div_sum = divergent_sum().scale(0.5).shift(3*UP)\n",
        "\n",
        "# #         self.add(div_sum)\n",
        "# #         self.play(\n",
        "# #             ApplyMethod(div_sum.replace, equation),\n",
        "# #             FadeIn(line_one_first),\n",
        "# #             FadeIn(line_one_last)\n",
        "# #         )\n",
        "# #         self.wait()\n",
        "# #         self.add(line_two)\n",
        "# #         self.wait()\n",
        "\n",
        "# class DiscoverAndDefine(Scene):\n",
        "#     def construct(self):\n",
        "#         sum_mob = OldTex(\"\\\\sum_{n = 1}^\\\\infty a_n\")\n",
        "#         discover = OldTexText(\"What does it feel like to discover these?\")\n",
        "#         define = OldTexText([\n",
        "#             \"What does it feel like to\", \n",
        "#             \"\\\\emph{define} \",\n",
        "#             \"them?\"\n",
        "#         ])\n",
        "#         sum_mob.shift(2*UP)\n",
        "#         define.shift(2*DOWN)\n",
        "#         define_parts = define.split()\n",
        "#         define_parts[1].set_color(\"skyblue\")\n",
        "\n",
        "#         self.add(sum_mob)\n",
        "#         self.play(FadeIn(discover))\n",
        "#         self.wait()\n",
        "#         self.play(FadeIn(Mobject(*define_parts)))\n",
        "#         self.wait()\n",
        "\n",
        "class YouAsMathematician(Scene):\n",
        "    def construct(self):\n",
        "        you, bubble = draw_you(with_bubble = True)\n",
        "        explanation = OldTexText(\n",
        "            \"You as a (questionably accurate portrayal of a) mathematician.\",\n",
        "            size = \"\\\\small\"\n",
        "        ).shift([2, you.get_center()[1], 0])\n",
        "        arrow = Arrow(you.get_center(), direction = LEFT)\n",
        "        arrow.nudge(you.get_width())\n",
        "        for mob in arrow, explanation:\n",
        "            mob.set_color(\"yellow\")\n",
        "        equation = convergent_sum()\n",
        "        bubble.add_content(equation)\n",
        "        equation_parts = equation.split()\n",
        "        equation.shift(0.5*RIGHT)\n",
        "        bubble.clear()\n",
        "        dot_pair = [\n",
        "            Dot(density = 3*DEFAULT_POINT_DENSITY_1D).shift(x+UP)\n",
        "            for x in (LEFT, RIGHT)\n",
        "        ]\n",
        "        self.add(you, explanation)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            BlinkPiCreature(you)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(bubble))\n",
        "        for part in equation_parts:\n",
        "            self.play(DelayByOrder(FadeIn(part)), run_time = 0.5)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            BlinkPiCreature(you),\n",
        "            FadeOut(explanation),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "        self.remove(bubble, *equation_parts)\n",
        "        self.disapproving_friend()\n",
        "        self.add(bubble, equation)\n",
        "        self.play(Transform(equation, Mobject(*dot_pair)))\n",
        "        self.remove(equation)\n",
        "        self.add(*dot_pair)\n",
        "        two_arrows = [\n",
        "            Arrow(x, direction = x).shift(UP).nudge()\n",
        "            for x in (LEFT, RIGHT)\n",
        "        ]\n",
        "        self.play(*[ShowCreation(a) for a in two_arrows])\n",
        "        self.play(BlinkPiCreature(you))\n",
        "        self.remove(*dot_pair+two_arrows)\n",
        "        everything = Mobject(*self.mobjects)\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            ApplyPointwiseFunction(\n",
        "                lambda p : 3*FRAME_X_RADIUS*p/get_norm(p),                \n",
        "                everything\n",
        "            ),\n",
        "            *[\n",
        "                Transform(dot, deepcopy(dot).shift(DOWN).scale(3)) \n",
        "                for dot in dot_pair\n",
        "            ],\n",
        "            run_time = 2.0\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def disapproving_friend(self):\n",
        "        friend = Mortimer().to_corner(DOWN+RIGHT)\n",
        "        bubble = SpeechBubble().pin_to(friend)\n",
        "        bubble.write(\"It's simply not rigorous!\")\n",
        "        bubble.content.sort_points(lambda p : np.dot(p, DOWN+RIGHT))\n",
        "\n",
        "        self.add(friend, bubble)\n",
        "        self.play(DelayByOrder(FadeIn(bubble.content)))\n",
        "        self.wait()\n",
        "        self.remove(friend, bubble, bubble.content)\n",
        "\n",
        "\n",
        "class DotsGettingCloser(Scene):\n",
        "    def construct(self):\n",
        "        dots = [\n",
        "            Dot(radius = 3*Dot.DEFAULT_RADIUS).shift(3*x)\n",
        "            for x in (LEFT, RIGHT)\n",
        "        ]\n",
        "        self.add(*dots)\n",
        "        self.wait()\n",
        "        for x in range(10):\n",
        "            distance = min(dots[1].get_points()[:,0])-max(dots[0].get_points()[:,0])\n",
        "            self.play(ApplyMethod(dots[0].shift, 0.5*distance*RIGHT))\n",
        "\n",
        "\n",
        "class ZoomInOnInterval(Scene):\n",
        "    def construct(self):\n",
        "        number_line = NumberLine(density = 10*DEFAULT_POINT_DENSITY_1D)\n",
        "        number_line.add_numbers()\n",
        "        interval = zero_to_one_interval().split()\n",
        "\n",
        "        new_line = deepcopy(number_line)\n",
        "        new_line.set_color(\"black\", lambda x_y_z1 : x_y_z1[0] < 0 or x_y_z1[0] > 1 or x_y_z1[1] < -0.2)\n",
        "        # height = new_line.get_height()\n",
        "        new_line.scale(2*INTERVAL_RADIUS)\n",
        "        new_line.shift(INTERVAL_RADIUS*LEFT)\n",
        "        # new_line.stretch_to_fit_height(height)\n",
        "\n",
        "        self.add(number_line)\n",
        "        self.wait()\n",
        "        self.play(Transform(number_line, new_line))\n",
        "        self.clear()\n",
        "        squish = lambda p : (p[0], 0, 0)\n",
        "        self.play(\n",
        "            ApplyMethod(new_line.apply_function, squish),\n",
        "            ApplyMethod(\n",
        "                interval[0].apply_function, squish,\n",
        "                rate_func = lambda t : 1-t\n",
        "            ),\n",
        "            *[FadeIn(interval[x]) for x in [1, 2]]\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(*interval)\n",
        "        self.wait()\n",
        "\n",
        "class DanceDotOnInterval(Scene):\n",
        "    def construct(self, mode):\n",
        "        num_written_terms = NUM_WRITTEN_TERMS\n",
        "        prop = 0.5\n",
        "        sum_terms = [\n",
        "            \"\\\\frac{1}{2}\", \n",
        "            \"\\\\frac{1}{4}\",\n",
        "            \"\\\\frac{1}{8}\",\n",
        "            \"\\\\frac{1}{16}\",\n",
        "        ]\n",
        "        num_height = 1.3*DOWN\n",
        "        interval = zero_to_one_interval()\n",
        "        dots = [\n",
        "            Dot(radius = 3*Dot.DEFAULT_RADIUS).shift(INTERVAL_RADIUS*x+UP)\n",
        "            for x in (LEFT, RIGHT)\n",
        "        ]\n",
        "        color_range = Color(\"green\").range_to(\"yellow\", num_written_terms)\n",
        "        conv_sum = OldTex(sum_terms, size = \"\\\\large\").split()\n",
        "\n",
        "        self.add(interval)\n",
        "        self.play(*[\n",
        "            ApplyMethod(dot.shift, DOWN)\n",
        "            for dot in dots\n",
        "        ])\n",
        "        self.wait()\n",
        "        for count in range(num_written_terms):\n",
        "            shift_val = 2*RIGHT*INTERVAL_RADIUS*(1-prop)*(prop**count)\n",
        "            start = dots[0].get_center()\n",
        "            line = Line(start, start + shift_val*RIGHT)\n",
        "            line.set_color(next(color_range))\n",
        "            self.play(\n",
        "                ApplyMethod(dots[0].shift, shift_val),\n",
        "                ShowCreation(line)\n",
        "            )\n",
        "            num = conv_sum[count]\n",
        "            num.shift(RIGHT*(line.get_center()[0]-num.get_center()[0]))\n",
        "            num.shift(num_height)\n",
        "            arrow = Mobject()\n",
        "            if num.get_width() > line.get_length():\n",
        "                num.center().shift(3*DOWN+2*(count-2)*RIGHT)\n",
        "                arrow = Arrow(\n",
        "                    line.get_center()+2*DOWN,\n",
        "                    tail = num.get_center()+0.5*num.get_height()*UP\n",
        "                )\n",
        "            self.play(\n",
        "                ApplyMethod(line.shift, 2*DOWN),\n",
        "                FadeIn(num),\n",
        "                FadeIn(arrow),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.write_partial_sums()\n",
        "        self.wait()\n",
        "\n",
        "    def write_partial_sums(self):\n",
        "        partial_sums = OldTex(PARTIAL_CONVERGENT_SUMS_TEXT, size = \"\\\\small\")\n",
        "        partial_sums.scale(1.5).to_edge(UP)\n",
        "        partial_sum_parts = partial_sums.split()\n",
        "        partial_sum_parts[0].set_color(\"yellow\")\n",
        "\n",
        "        for x in range(0, len(partial_sum_parts), 4):\n",
        "            partial_sum_parts[x+2].set_color(\"yellow\")\n",
        "            self.play(*[\n",
        "                FadeIn(partial_sum_parts[y])\n",
        "                for y in range(x, x+4)\n",
        "            ])\n",
        "        self.wait(2)\n",
        "\n",
        "class OrganizePartialSums(Scene):\n",
        "    def construct(self):\n",
        "        partial_sums = OldTex(PARTIAL_CONVERGENT_SUMS_TEXT, size = \"\\\\small\")\n",
        "        partial_sums.scale(1.5).to_edge(UP)\n",
        "        partial_sum_parts = partial_sums.split()\n",
        "        for x in [0] + list(range(2, len(partial_sum_parts), 4)):\n",
        "            partial_sum_parts[x].set_color(\"yellow\")\n",
        "        pure_sums = [\n",
        "            partial_sum_parts[x] \n",
        "            for x in range(0, len(partial_sum_parts), 4)\n",
        "        ]\n",
        "        new_pure_sums = deepcopy(pure_sums)\n",
        "        for pure_sum, count in zip(new_pure_sums, it.count(3, -1.2)):\n",
        "            pure_sum.center().scale(1/1.25).set_color(\"white\")\n",
        "            pure_sum.to_edge(LEFT).shift(2*RIGHT+count*UP)\n",
        "\n",
        "        self.add(*partial_sum_parts)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ClockwiseTransform(*pair)\n",
        "            for pair in zip(pure_sums, new_pure_sums)\n",
        "        ]+[\n",
        "            FadeOut(mob)\n",
        "            for mob in partial_sum_parts\n",
        "            if mob not in pure_sums\n",
        "        ])\n",
        "        down_arrow = OldTex(\"\\\\downarrow\")\n",
        "        down_arrow.to_edge(LEFT).shift(2*RIGHT+2*DOWN)\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.shift(down_arrow.get_center()+down_arrow.get_height()*UP)\n",
        "        infinite_sum = OldTex(\"\".join(CONVERGENT_SUM_TEXT[:-1]), size = \"\\\\samll\")\n",
        "        infinite_sum.scale(1.5/1.25)\n",
        "        infinite_sum.to_corner(DOWN+LEFT).shift(2*RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(dots))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(Mobject(down_arrow, infinite_sum)))\n",
        "        self.wait()\n",
        "\n",
        "class SeeNumbersApproachOne(Scene):\n",
        "    def construct(self):\n",
        "        interval = zero_to_one_interval()\n",
        "        arrow = Arrow(INTERVAL_RADIUS*RIGHT, tail=ORIGIN).nudge()\n",
        "        arrow.shift(DOWN).set_color(\"yellow\")\n",
        "        num_dots = 6\n",
        "        colors = Color(\"green\").range_to(\"yellow\", num_dots)\n",
        "        dots = Mobject(*[\n",
        "            Dot(\n",
        "                density = 2*DEFAULT_POINT_DENSITY_1D\n",
        "            ).scale(1+1.0/2.0**x).shift(\n",
        "                INTERVAL_RADIUS*RIGHT +\\\n",
        "                (INTERVAL_RADIUS/2.0**x)*LEFT\n",
        "            ).set_color(next(colors))\n",
        "            for x in range(num_dots)\n",
        "        ])\n",
        "\n",
        "        self.add(interval)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            ShowCreation(dots),\n",
        "            run_time = 2.0\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class OneAndInfiniteSumAreTheSameThing(Scene):\n",
        "    def construct(self):\n",
        "        one, equals, inf_sum = OldTex([\n",
        "            \"1\", \"=\", \"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{2^n}\"\n",
        "        ]).split()\n",
        "        point = Point(equals.get_center()).set_color(\"black\")\n",
        "\n",
        "        self.add(one.shift(LEFT))\n",
        "        self.wait()\n",
        "        self.add(inf_sum.shift(RIGHT))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(one.shift, RIGHT),\n",
        "            ApplyMethod(inf_sum.shift, LEFT),\n",
        "            CounterclockwiseTransform(point, equals)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HowDoYouDefineInfiniteSums(Scene):\n",
        "    def construct(self):\n",
        "        you = draw_you().center().rewire_part_attributes()\n",
        "        text = OldTexText(\n",
        "            [\"How\", \" do\", \" you,\\\\\\\\\", \"\\\\emph{define}\"],\n",
        "            size = \"\\\\Huge\"\n",
        "        ).shift(UP).split()\n",
        "        text[-1].shift(3*DOWN).set_color(\"skyblue\")\n",
        "        sum_mob = OldTex(\"\\\\sum_{n=0}^\\\\infty{a_n}\")\n",
        "        text[-1].shift(LEFT)\n",
        "        sum_mob.shift(text[-1].get_center()+2*RIGHT)\n",
        "\n",
        "        self.add(you)\n",
        "        self.wait()\n",
        "        for mob in text[:-1]:\n",
        "            self.add(mob)\n",
        "            self.wait(0.1)\n",
        "        self.play(BlinkPiCreature(you))\n",
        "        self.wait()\n",
        "        self.add(text[-1])\n",
        "        self.wait()\n",
        "        self.add(sum_mob)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LessAboutNewThoughts(Scene):\n",
        "    def construct(self):\n",
        "        words = generating, new, thoughts, to, definitions = OldTexText([\n",
        "            \"Generating\", \" new\", \" thoughts\", \"$\\\\rightarrow$\",\n",
        "            \"useful definitions\"\n",
        "        ], size = \"\\\\large\").split()\n",
        "        gen_cross = OldTex(\"\\\\hline\").set_color(\"red\")\n",
        "        new_cross = deepcopy(gen_cross)\n",
        "        for cross, mob in [(gen_cross, generating), (new_cross, new)]:\n",
        "            cross.replace(mob)\n",
        "            cross.stretch_to_fit_height(0.03)\n",
        "        disecting = OldTexText(\"Disecting\").set_color(\"green\")\n",
        "        disecting.shift(generating.get_center() + 0.6*UP)\n",
        "        old = OldTexText(\"old\").set_color(\"green\")\n",
        "        old.shift(new.get_center()+0.6*UP)\n",
        "\n",
        "        kwargs = {\"run_time\" : 0.25}\n",
        "        self.add(*words)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(gen_cross, **kwargs))\n",
        "        self.play(ShowCreation(new_cross, **kwargs))\n",
        "        self.wait()        \n",
        "        self.add(disecting)\n",
        "        self.wait(0.5)\n",
        "        self.add(old)\n",
        "        self.wait()\n",
        "\n",
        "class ListOfPartialSums(Scene):\n",
        "    def construct(self):\n",
        "        all_terms = np.array(OldTex(\n",
        "            ALT_PARTIAL_SUM_TEXT,\n",
        "            size = \"\\\\large\"\n",
        "        ).split())\n",
        "        numbers, equals, sums = [\n",
        "            all_terms[list(range(k, 12, 3))]\n",
        "            for k in (0, 1, 2)\n",
        "        ]\n",
        "        dots = all_terms[12]\n",
        "        one = all_terms[-3]\n",
        "        last_equal = all_terms[-2]\n",
        "        infinite_sum = all_terms[-1]\n",
        "\n",
        "        self.count(\n",
        "            numbers, \n",
        "            mode = \"show\",\n",
        "            display_numbers = False, \n",
        "            run_time = 1.0\n",
        "        )\n",
        "        self.play(ShowCreation(dots))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(Mobject(*equals)),\n",
        "            *[\n",
        "                Transform(deepcopy(number), finite_sum)\n",
        "                for number, finite_sum in zip(numbers, sums)\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(s.set_color, \"yellow\", rate_func = there_and_back)\n",
        "            for s in sums\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.add(one.set_color(\"green\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowDecreasingDistance(Scene):\n",
        "    args_list = [(1,), (2,)]\n",
        "    @staticmethod\n",
        "    def args_to_string(num):\n",
        "        return str(num)\n",
        "\n",
        "    def construct(self, num):\n",
        "        number_line = NumberLine(interval_size = 1).add_numbers()\n",
        "        vert_line0 = Line(0.5*UP+RIGHT, UP+RIGHT)\n",
        "        vert_line1 = Line(0.5*UP+2*num*RIGHT, UP+2*num*RIGHT)\n",
        "        horiz_line = Line(vert_line0.end, vert_line1.end)\n",
        "        lines = [vert_line0, vert_line1, horiz_line]\n",
        "        for line in lines:\n",
        "            line.set_color(\"green\")\n",
        "        dots = Mobject(*[\n",
        "            Dot().scale(1.0/(n+1)).shift((1+partial_sum(n))*RIGHT)\n",
        "            for n in range(10)\n",
        "        ])\n",
        "\n",
        "        self.add(dots.split()[0])\n",
        "        self.add(number_line, *lines)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(vert_line0.shift, RIGHT),\n",
        "            Transform(\n",
        "                horiz_line, \n",
        "                Line(vert_line0.end+RIGHT, vert_line1.end).set_color(\"green\")\n",
        "            ),\n",
        "            ShowCreation(dots),\n",
        "            run_time = 2.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class CircleZoomInOnOne(Scene):\n",
        "    def construct(self):\n",
        "        number_line = NumberLine(interval_size = 1).add_numbers()\n",
        "        dots = Mobject(*[\n",
        "            Dot().scale(1.0/(n+1)).shift((1+partial_sum(n))*RIGHT)\n",
        "            for n in range(10)\n",
        "        ])\n",
        "        circle = Circle().shift(2*RIGHT)\n",
        "        text = OldTexText(\n",
        "            \"All but finitely many dots fall inside even the tiniest circle.\"\n",
        "        )\n",
        "        numbers = [Tex(\"\\\\frac{1}{%s}\"%s) for s in [\"100\", \"1,000,000\", \"g_{g_{64}}\"]]\n",
        "        for num in numbers + [text]:\n",
        "            num.shift(2*UP)\n",
        "            num.sort_points(lambda p : np.dot(p, DOWN+RIGHT))\n",
        "        curr_num = numbers[0]\n",
        "        arrow = Arrow(2*RIGHT, direction = 1.5*(DOWN+RIGHT)).nudge()\n",
        "\n",
        "        self.add(number_line, dots)\n",
        "        self.play(\n",
        "            Transform(circle, Point(2*RIGHT).set_color(\"white\")),\n",
        "            run_time = 5.0\n",
        "        )\n",
        "\n",
        "        self.play(*[\n",
        "            DelayByOrder(FadeIn(mob))\n",
        "            for mob in (arrow, curr_num)\n",
        "        ])\n",
        "        self.wait()\n",
        "        for num in numbers[1:] + [text]:\n",
        "            curr_num.set_points(list(reversed(curr_num.get_points())))\n",
        "            self.play(\n",
        "                ShowCreation(\n",
        "                    curr_num, \n",
        "                    rate_func = lambda t : smooth(1-t)\n",
        "                ),\n",
        "                ShowCreation(num)\n",
        "            )\n",
        "            self.remove(curr_num)\n",
        "            curr_num = num\n",
        "            self.wait()\n",
        "\n",
        "class ZoomInOnOne(Scene):\n",
        "    def construct(self):\n",
        "        num_iterations = 8\n",
        "        number_line = NumberLine(interval_size = 1, radius = FRAME_X_RADIUS+2)\n",
        "        number_line.filter_out(lambda x_y_z2:abs(x_y_z2[1])>0.1)\n",
        "        nl_with_nums = deepcopy(number_line).add_numbers()\n",
        "        self.play(ApplyMethod(nl_with_nums.shift, 2*LEFT))\n",
        "        zero, one, two = [\n",
        "            OldTex(str(n)).scale(0.5).shift(0.4*DOWN+2*(-1+n)*RIGHT)\n",
        "            for n in (0, 1, 2)\n",
        "        ]\n",
        "        self.play(\n",
        "            FadeOut(nl_with_nums),\n",
        "            *[Animation(mob) for mob in (zero, one, two, number_line)]\n",
        "        )\n",
        "        self.remove(nl_with_nums, number_line, zero, two)\n",
        "        powers_of_10 = [10**(-n) for n in range(num_iterations+1)]\n",
        "        number_pairs = [(1-epsilon, 1+epsilon) for epsilon in powers_of_10]\n",
        "        for count in range(num_iterations):\n",
        "            self.zoom_with_numbers(number_pairs[count], number_pairs[count+1])\n",
        "            self.clear()\n",
        "            self.add(one)\n",
        "\n",
        "    def zoom_with_numbers(self, numbers, next_numbers):\n",
        "        all_numbers = [Tex(str(n_u[0])).scale(0.5).shift(0.4*DOWN+2*n_u[1]*RIGHT) for n_u in zip(numbers+next_numbers, it.cycle([-1, 1]))]\n",
        "\n",
        "        num_levels = 3\n",
        "        scale_factor = 10\n",
        "        number_lines = [\n",
        "            NumberLine(\n",
        "                interval_size = 1, \n",
        "                density = scale_factor*DEFAULT_POINT_DENSITY_1D\n",
        "            ).filter_out(\n",
        "                lambda x_y_z:abs(x_y_z[1])>0.1\n",
        "            ).scale(1.0/scale_factor**x)\n",
        "            for x in range(num_levels)\n",
        "        ]\n",
        "        kwargs = {\"rate_func\" : None}\n",
        "        self.play(*[\n",
        "            ApplyMethod(number_lines[x].scale, scale_factor, **kwargs)\n",
        "            for x in range(1, num_levels)\n",
        "        ]+[\n",
        "            ApplyMethod(number_lines[0].stretch, scale_factor, 0, **kwargs),\n",
        "        ]+[\n",
        "            ApplyMethod(\n",
        "                all_numbers[i].shift, \n",
        "                2*LEFT*(scale_factor-1)*(-1)**i, \n",
        "                **kwargs\n",
        "            )\n",
        "            for i in (0, 1)\n",
        "        ]+[\n",
        "            Transform(Point(0.4*DOWN + u*0.2*RIGHT), num, **kwargs)\n",
        "            for u, num in zip([-1, 1], all_numbers[2:])\n",
        "        ])\n",
        "        self.remove(*all_numbers)\n",
        "\n",
        "\n",
        "class DefineInfiniteSum(Scene):\n",
        "    def construct(self):\n",
        "        self.put_expression_in_corner()\n",
        "        self.list_partial_sums()\n",
        "        self.wait()\n",
        "\n",
        "    def put_expression_in_corner(self):\n",
        "        buff = 0.24\n",
        "        define, infinite_sum = OldTex([\n",
        "            \"\\\\text{\\\\emph{Define} }\",\n",
        "            \"\\\\sum_{n = 0}^\\\\infty a_n = X\"\n",
        "        ]).split()\n",
        "        define.set_color(\"skyblue\")\n",
        "        expression = Mobject(define, infinite_sum)\n",
        "\n",
        "        self.add(expression)\n",
        "        self.wait()\n",
        "        self.play(ApplyFunction(\n",
        "            lambda mob : mob.scale(0.5).to_corner(UP+LEFT, buff = buff),\n",
        "            expression            \n",
        "        ))\n",
        "        bottom = (min(expression.get_points()[:,1]) - buff)*UP\n",
        "        side   = (max(expression.get_points()[:,0]) + buff)*RIGHT\n",
        "        lines = [\n",
        "            Line(FRAME_X_RADIUS*LEFT+bottom, side+bottom),\n",
        "            Line(FRAME_Y_RADIUS*UP+side, side+bottom)\n",
        "        ]\n",
        "        self.play(*[\n",
        "            ShowCreation(line.set_color(\"white\"))\n",
        "            for line in lines\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def list_partial_sums(self):\n",
        "        num_terms = 10\n",
        "        term_strings = reduce(op.add, [\n",
        "            [\n",
        "                \"s_%d\"%n, \n",
        "                \"&=\", \n",
        "                \"+\".join([\"a_%d\"%k for k in range(n+1)])+\"\\\\\\\\\"\n",
        "            ]\n",
        "            for n in range(num_terms)\n",
        "        ])\n",
        "        terms = OldTex(term_strings, size = \"\\\\large\").split()\n",
        "        number_line = NumberLine()\n",
        "        ex_point = 2*RIGHT\n",
        "        ex = OldTex(\"X\").shift(ex_point + LEFT + UP)\n",
        "        arrow = Arrow(ex_point, tail = ex.get_points()[-1]).nudge()\n",
        "\n",
        "        for term, count in zip(terms, it.count()):\n",
        "            self.add(term)\n",
        "            self.wait(0.1)\n",
        "            if count % 3 == 2:\n",
        "                self.wait(0.5)\n",
        "        self.wait()\n",
        "        esses = np.array(terms)[list(range(0, len(terms), 3))]\n",
        "        other_terms = [m for m in terms if m not in esses]\n",
        "        self.play(*[\n",
        "            ApplyMethod(ess.set_color, \"yellow\")\n",
        "            for ess in esses\n",
        "        ])\n",
        "\n",
        "        def move_s(s, n):\n",
        "            s.center()\n",
        "            s.scale(1.0/(n+1))\n",
        "            s.shift(ex_point-RIGHT*2.0/2**n)\n",
        "            return s\n",
        "        self.play(*[\n",
        "            FadeOut(term)\n",
        "            for term in other_terms\n",
        "        ]+[\n",
        "            ApplyFunction(lambda s : move_s(s, n), ess)\n",
        "            for ess, n in zip(esses, it.count())\n",
        "        ]+[\n",
        "            FadeIn(number_line), \n",
        "            FadeIn(ex), \n",
        "            FadeIn(arrow)\n",
        "        ])\n",
        "\n",
        "        lines = [\n",
        "            Line(x+0.25*DOWN, x+0.25*UP).set_color(\"white\")\n",
        "            for y in [-1, -0.01, 1, 0.01]\n",
        "            for x in [ex_point+y*RIGHT]\n",
        "        ]\n",
        "        self.play(*[\n",
        "            Transform(lines[x], lines[x+1], run_time = 3.0)\n",
        "            for x in (0, 2)\n",
        "        ])\n",
        "\n",
        "\n",
        "class YouJustInventedSomeMath(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText([\n",
        "            \"You \", \"just \", \"invented\\\\\\\\\", \"some \", \"math\"\n",
        "        ]).split()\n",
        "        for mob in text[:3]:\n",
        "            mob.shift(UP)\n",
        "        for mob in text[3:]:\n",
        "            mob.shift(1.3*DOWN)\n",
        "        # you = draw_you().center().rewire_part_attributes()\n",
        "        # smile = PiCreature().mouth.center().shift(you.mouth.get_center())\n",
        "        you = PiCreature().set_color(\"grey\")\n",
        "        you.center().rewire_part_attributes()\n",
        "\n",
        "        self.add(you)\n",
        "        for mob in text:\n",
        "            self.add(mob)\n",
        "            self.wait(0.2)\n",
        "        self.play(WaveArm(you))\n",
        "        self.play(BlinkPiCreature(you))\n",
        "\n",
        "\n",
        "\n",
        "class SeekMoreGeneralTruths(Scene):\n",
        "    def construct(self):\n",
        "        summands = [\n",
        "            \"\\\\frac{1}{3^n}\",\n",
        "            \"2^n\",            \n",
        "            \"\\\\frac{1}{n^2}\",\n",
        "            \"\\\\frac{(-1)^n}{n}\",\n",
        "            \"\\\\frac{(-1)^n}{(2n)!}\",\n",
        "            \"\\\\frac{2\\sqrt{2}}{99^2}\\\\frac{(4n)!}{(n!)^4} \\\\cdot \\\\frac{26390n + 1103}{396^{4k}}\",            \n",
        "        ]\n",
        "        sums = OldTex([\n",
        "            \"&\\\\sum_{n = 0}^\\\\infty\" + summand + \"= ? \\\\\\\\\"\n",
        "            for summand in summands\n",
        "        ], size = \"\")\n",
        "        sums.stretch_to_fit_height(FRAME_HEIGHT-1)\n",
        "        sums.shift((FRAME_Y_RADIUS-0.5-max(sums.get_points()[:,1]))*UP)\n",
        "\n",
        "        for qsum in sums.split():\n",
        "            qsum.sort_points(lambda p : np.dot(p, DOWN+RIGHT))\n",
        "            self.play(DelayByOrder(FadeIn(qsum)))\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "\n",
        "class ChopIntervalInProportions(Scene):\n",
        "    args_list = [(\"9\", ), (\"p\", )]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return args[0]\n",
        "\n",
        "    def construct(self, mode):\n",
        "        if mode == \"9\":\n",
        "            prop = 0.1\n",
        "            num_terms = 2\n",
        "            left_terms, right_terms = [\n",
        "                [\n",
        "                    OldTex(\"\\\\frac{%d}{%d}\"%(k, (10**(count+1))))\n",
        "                    for count in range(num_terms)\n",
        "                ]\n",
        "                for k in (9, 1)\n",
        "            ]\n",
        "        if mode == \"p\":\n",
        "            num_terms = 4         \n",
        "            prop = 0.7\n",
        "            left_terms = list(map(Tex, [\"(1-p)\", [\"p\",\"(1-p)\"]]+[\n",
        "                [\"p^%d\"%(count), \"(1-p)\"]\n",
        "                for count in range(2, num_terms)\n",
        "            ]))\n",
        "            right_terms = list(map(Tex, [\"p\"] + [\n",
        "                [\"p\", \"^%d\"%(count+1)]\n",
        "                for count in range(1, num_terms)\n",
        "            ]))\n",
        "        interval = zero_to_one_interval()\n",
        "        left = INTERVAL_RADIUS*LEFT\n",
        "        right = INTERVAL_RADIUS*RIGHT\n",
        "        left_paren = OldTex(\"(\")\n",
        "        right_paren = OldTex(\")\").shift(right + 1.1*UP)\n",
        "        curr = left.astype(\"float\")\n",
        "        brace_to_replace = None\n",
        "        term_to_replace = None\n",
        "\n",
        "        self.add(interval)\n",
        "        additional_anims = []\n",
        "        for lt, rt, count in zip(left_terms, right_terms, it.count()):\n",
        "            last = deepcopy(curr)\n",
        "            curr += 2*RIGHT*INTERVAL_RADIUS*(1-prop)*(prop**count)\n",
        "            braces = [\n",
        "                Underbrace(a, b).rotate(np.pi, RIGHT)\n",
        "                for a, b in [(last, curr), (curr, right)]\n",
        "            ]\n",
        "            for term, brace, count2 in zip([lt, rt], braces, it.count()):\n",
        "                term.scale(0.75)\n",
        "                term.shift(brace.get_center()+UP)                \n",
        "                if term.get_width() > brace.get_width():\n",
        "                    term.shift(UP+1.5*(count-2)*RIGHT)\n",
        "                    arrow = Arrow(\n",
        "                        brace.get_center()+0.3*UP,\n",
        "                        tail = term.get_center()+0.5*DOWN\n",
        "                    )\n",
        "                    arrow.set_points(list(reversed(arrow.get_points()))\n",
        "                    additional_anims = [ShowCreation(arrow)]\n",
        "            if brace_to_replace is not None:\n",
        "                if mode == \"p\":\n",
        "                    lt, rt = lt.split(), rt.split()                    \n",
        "                    if count == 1:\n",
        "                        new_term_to_replace = deepcopy(term_to_replace)\n",
        "                        new_term_to_replace.center().shift(last+UP+0.3*LEFT)\n",
        "                        left_paren.center().shift(last+1.1*UP)\n",
        "                        self.play(\n",
        "                            FadeIn(lt[1]),\n",
        "                            FadeIn(rt[0]),\n",
        "                            Transform(\n",
        "                                brace_to_replace.repeat(2),\n",
        "                                Mobject(*braces)\n",
        "                            ),\n",
        "                            FadeIn(left_paren), \n",
        "                            FadeIn(right_paren),\n",
        "                            Transform(term_to_replace, new_term_to_replace),\n",
        "                            *additional_anims\n",
        "                        )\n",
        "                        self.wait()\n",
        "                        self.play(\n",
        "                            Transform(\n",
        "                                term_to_replace,\n",
        "                                Mobject(lt[0], rt[1])\n",
        "                            ),\n",
        "                            FadeOut(left_paren),\n",
        "                            FadeOut(right_paren)\n",
        "                        )\n",
        "                        self.remove(left_paren, right_paren)\n",
        "                    else:\n",
        "                        self.play(\n",
        "                            FadeIn(lt[1]),\n",
        "                            FadeIn(rt[0]),\n",
        "                            Transform(\n",
        "                                brace_to_replace.repeat(2),\n",
        "                                Mobject(*braces)\n",
        "                            ),\n",
        "                            Transform(\n",
        "                                term_to_replace,\n",
        "                                Mobject(lt[0], rt[1])\n",
        "                            ),\n",
        "                            *additional_anims\n",
        "                        )\n",
        "                    self.remove(*lt+rt)\n",
        "                    lt, rt = Mobject(*lt), Mobject(*rt)\n",
        "                    self.add(lt, rt)\n",
        "                else:\n",
        "                    self.play(\n",
        "                        Transform(\n",
        "                            brace_to_replace.repeat(2), \n",
        "                            Mobject(*braces)\n",
        "                        ),\n",
        "                        Transform(\n",
        "                            term_to_replace,\n",
        "                            Mobject(lt, rt)\n",
        "                        ),\n",
        "                        *additional_anims\n",
        "                    )\n",
        "                self.remove(brace_to_replace, term_to_replace)\n",
        "                self.add(lt, rt, *braces)\n",
        "            else:\n",
        "                self.play(*[\n",
        "                    FadeIn(mob)\n",
        "                    for mob in braces + [lt, rt]\n",
        "                ] + additional_anims)\n",
        "            self.wait()\n",
        "            brace_to_replace = braces[1]\n",
        "            term_to_replace = rt\n",
        "        if mode == \"9\":\n",
        "            split_100 = OldTex(\"\\\\frac{9}{1000}+\\\\frac{1}{1000}\")\n",
        "            split_100.scale(0.5)\n",
        "            split_100.shift(right_terms[-1].get_center())\n",
        "            split_100.to_edge(RIGHT)\n",
        "            split_100.sort_points()\n",
        "            right_terms[-1].sort_points()\n",
        "            self.play(Transform(\n",
        "                right_terms[-1], split_100\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class GeometricSum(RearrangeEquation):\n",
        "    def construct(self):\n",
        "        start_terms = \"(1-p) + p (1-p) + p^2 (1-p) + p^3 (1-p) + \\\\cdots = 1\"\n",
        "        end_terms = \"1 + p + p^2 + p^3 + \\\\cdots = \\\\frac{1}{(1-p)}\"\n",
        "        index_map = {\n",
        "            0 : 0,\n",
        "            # 0 : -1, #(1-p)\n",
        "            1 : 1,  #+\n",
        "            2 : 2,  #p\n",
        "            # 3 : -1, #(1-p)\n",
        "            4 : 3,  #+\n",
        "            5 : 4,  #p^2\n",
        "            # 6 : -1, #(1-p)\n",
        "            7 : 5,  #+\n",
        "            8 : 6,  #p^3\n",
        "            # 9 : -1, #(1-p)\n",
        "            10: 7,  #+\n",
        "            11: 8,  #\\\\cdots\n",
        "            12: 9,  #=\n",
        "            13: 10, #1\n",
        "        }\n",
        "        def start_transform(mob):\n",
        "            return mob.scale(1.3).shift(2*UP)\n",
        "        def end_transform(mob):\n",
        "            return mob.scale(1.3).shift(DOWN)\n",
        "\n",
        "        RearrangeEquation.construct(\n",
        "            self, \n",
        "            start_terms.split(\" \"), end_terms.split(\" \"), \n",
        "            index_map, size = \"\\\\large\", \n",
        "            path = counterclockwise_path(),\n",
        "            start_transform = start_transform,\n",
        "            end_transform = end_transform,\n",
        "            leave_start_terms = True,\n",
        "            transform_kwargs = {\"run_time\" : 2.0}\n",
        "        )\n",
        "\n",
        "class PointNineRepeating(RearrangeEquation):\n",
        "    def construct(self):\n",
        "        start_terms = [\n",
        "            \"\\\\frac{9}{10}\",\n",
        "            \"+\",\n",
        "            \"\\\\frac{9}{100}\",\n",
        "            \"+\",\n",
        "            \"\\\\frac{9}{1000}\",\n",
        "            \"+\",\n",
        "            \"\\\\cdots=1\",\n",
        "        ]\n",
        "        end_terms = \"0 . 9 9 9 \\\\cdots=1\".split(\" \")\n",
        "        index_map = {\n",
        "            0 : 2,\n",
        "            2 : 3,\n",
        "            4 : 4,\n",
        "            6 : 5,\n",
        "        }\n",
        "        for term in OldTex(start_terms).split():\n",
        "            self.add(term)\n",
        "            self.wait(0.5)\n",
        "        self.clear()\n",
        "        RearrangeEquation.construct(\n",
        "            self,\n",
        "            start_terms,\n",
        "            end_terms,\n",
        "            index_map,\n",
        "            path = straight_path\n",
        "        )\n",
        "\n",
        "\n",
        "class PlugNumbersIntoRightside(Scene):\n",
        "    def construct(self):\n",
        "        scale_factor = 1.5\n",
        "        lhs, rhs = OldTex(\n",
        "            [\"1 + p + p^2 + p^3 + \\\\cdots = \", \"\\\\frac{1}{1-p}\"],\n",
        "            size = \"\\\\large\"\n",
        "        ).scale(scale_factor).split()\n",
        "        rhs = OldTex(\n",
        "            [\"1 \\\\over 1 - \", \"p\"], \n",
        "            size = \"\\\\large\"\n",
        "        ).replace(rhs).split()\n",
        "        num_strings = [\n",
        "            \"0.5\", \"3\", \"\\pi\", \"(-1)\", \"3.7\", \"2\",\n",
        "            \"0.2\", \"27\", \"i\"\n",
        "        ] \n",
        "        nums = [\n",
        "            OldTex(num_string, size=\"\\\\large\")\n",
        "            for num_string in num_strings\n",
        "        ]\n",
        "        for num, num_string in zip(nums, num_strings):\n",
        "            num.scale(scale_factor)\n",
        "            num.shift(rhs[1].get_center())\n",
        "            num.shift(0.1*RIGHT + 0.08*UP)\n",
        "            num.set_color(\"green\")\n",
        "            if num_string == \"(-1)\":\n",
        "                num.shift(0.3*RIGHT)\n",
        "        right_words = OldTexText(\n",
        "            \"This side makes sense for almost any value of $p$,\"\n",
        "        ).shift(2*UP)\n",
        "        left_words = OldTexText(\n",
        "            \"even if it seems like this side will not.\"\n",
        "        ).shift(2*DOWN)\n",
        "        right_words.add(Arrow(\n",
        "            rhs[0].get_center(),\n",
        "            tail = right_words.get_center()+DOWN+RIGHT\n",
        "        ).nudge(0.5))\n",
        "        left_words.add(Arrow(\n",
        "            lhs.get_center() + 0.3*DOWN,\n",
        "            tail = left_words.get_center() + 0.3*UP\n",
        "        ))\n",
        "        right_words.set_color(\"green\")\n",
        "        left_words.set_color(\"yellow\")\n",
        "\n",
        "\n",
        "        self.add(lhs, *rhs)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(right_words))\n",
        "        curr = rhs[1]\n",
        "        for num, count in zip(nums, it.count()):\n",
        "            self.play(CounterclockwiseTransform(curr, num))\n",
        "            self.wait()\n",
        "            if count == 2:\n",
        "                self.play(FadeIn(left_words))\n",
        "\n",
        "\n",
        "class PlugInNegativeOne(RearrangeEquation):\n",
        "    def construct(self):\n",
        "        num_written_terms = 4\n",
        "        start_terms = reduce(op.add, [\n",
        "            [\"(-\", \"1\", \")^%d\"%n, \"+\"]\n",
        "            for n in range(num_written_terms)\n",
        "        ]) + [\"\\\\cdots=\", \"\\\\frac{1}{1-(-1)}\"]\n",
        "        end_terms = \"1 - 1 + 1 - 1 + \\\\cdots= \\\\frac{1}{2}\".split(\" \")\n",
        "        index_map = dict([\n",
        "            (4*n + 1, 2*n)\n",
        "            for n in range(num_written_terms)\n",
        "        ]+[\n",
        "            (4*n + 3, 2*n + 1)\n",
        "            for n in range(num_written_terms)\n",
        "        ])\n",
        "        index_map[-2] = -2\n",
        "        index_map[-1] = -1\n",
        "        RearrangeEquation.construct(\n",
        "            self,\n",
        "            start_terms,\n",
        "            end_terms,\n",
        "            index_map,\n",
        "            path = straight_path,\n",
        "            start_transform = lambda m : m.shift(2*UP),\n",
        "            leave_start_terms = True,\n",
        "        )\n",
        "\n",
        "class PlugInTwo(RearrangeEquation):\n",
        "    def construct(self):\n",
        "        num_written_terms = 4\n",
        "        start_terms = reduce(op.add, [\n",
        "            [\"2\", \"^%d\"%n, \"+\"]\n",
        "            for n in range(num_written_terms)\n",
        "        ]) + [\"\\\\cdots=\", \"\\\\frac{1}{1-2}\"]\n",
        "        end_terms = \"1 + 2 + 4 + 8 + \\\\cdots= -1\".split(\" \")\n",
        "        index_map = dict([\n",
        "            (3*n, 2*n)\n",
        "            for n in range(num_written_terms)\n",
        "        ]+[\n",
        "            (3*n + 2, 2*n + 1)\n",
        "            for n in range(num_written_terms)\n",
        "        ])\n",
        "        index_map[-2] = -2\n",
        "        index_map[-1] = -1\n",
        "        RearrangeEquation.construct(\n",
        "            self,\n",
        "            start_terms,\n",
        "            end_terms,\n",
        "            index_map,\n",
        "            size = \"\\\\Huge\",\n",
        "            path = straight_path,\n",
        "            start_transform = lambda m : m.shift(2*UP),\n",
        "            leave_start_terms = True,\n",
        "        )\n",
        "\n",
        "class ListPartialDivergentSums(Scene):\n",
        "    args_list = [\n",
        "        (\n",
        "            lambda n : \"1\" if n%2 == 0 else \"(-1)\",\n",
        "            lambda n : \"1\" if n%2 == 0 else \"0\"\n",
        "        ),\n",
        "        (\n",
        "            lambda n : \"2^%d\"%n if n > 1 else (\"1\" if n==0 else \"2\"),\n",
        "            lambda n : str(2**(n+1)-1)\n",
        "        )\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        if args[0](1) == \"(-1)\":\n",
        "            return \"Negative1\"\n",
        "        else:\n",
        "            return args[0](1)\n",
        "    def construct(self, term_func, partial_sum_func):\n",
        "        num_lines = 8\n",
        "        rhss = [\n",
        "            partial_sum_func(n) \n",
        "            for n in range(num_lines)\n",
        "        ]\n",
        "        lhss = [\n",
        "            \"&=\" + \\\n",
        "            \"+\".join([term_func(k) for k in range(n+1)]) + \\\n",
        "            \"\\\\\\\\\"\n",
        "            for n in range(num_lines)\n",
        "        ]\n",
        "        terms = OldTex(\n",
        "            list(it.chain.from_iterable(list(zip(rhss, lhss)))) + [\"\\\\vdots&\", \"\"],\n",
        "            size = \"\\\\large\"\n",
        "        ).shift(RIGHT).split()\n",
        "        words = OldTexText(\"These numbers don't \\\\\\\\ approach anything\")\n",
        "        words.to_edge(LEFT)\n",
        "        arrow = Arrow(3*DOWN+2*LEFT, direction = DOWN, length = 6)\n",
        "\n",
        "        for x in range(0, len(terms), 2):\n",
        "            self.play(FadeIn(terms[x]), FadeIn(terms[x+1]))\n",
        "        self.play(FadeIn(words), ShowCreation(arrow))\n",
        "        for x in range(0, len(terms), 2):\n",
        "            self.play(\n",
        "                ApplyMethod(terms[x].set_color, \"green\"),\n",
        "                run_time = 0.1\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class NotARobot(Scene):\n",
        "    def construct(self):\n",
        "        you = draw_you().center()\n",
        "        top_words = OldTexText(\"You are a mathematician,\")\n",
        "        low_words = OldTexText(\"not a robot.\")\n",
        "        top_words.shift(1.5*UP)\n",
        "        low_words.shift(1.5*DOWN)\n",
        "        \n",
        "        self.add(you)\n",
        "        self.play(ShimmerIn(top_words))\n",
        "        self.play(ShimmerIn(low_words))\n",
        "\n",
        "\n",
        "class SumPowersOfTwoAnimation(Scene):\n",
        "    def construct(self):\n",
        "        iterations = 5\n",
        "        dot = Dot(density = 3*DEFAULT_POINT_DENSITY_1D).scale(1.5)\n",
        "        dot_width = dot.get_width()*RIGHT\n",
        "        dot_buff = 0.2*RIGHT\n",
        "        left = (FRAME_X_RADIUS-1)*LEFT\n",
        "        right = left + 2*dot_width + dot_buff\n",
        "        top_brace_left = left+dot_width+dot_buff+0.3*DOWN\n",
        "        bottom_brace_left = left + 0.3*DOWN\n",
        "        circle = Circle().scale(dot_width[0]/2).shift(left+dot_width/2)\n",
        "        curr_dots = deepcopy(dot).shift(left+1.5*dot_width+dot_buff)\n",
        "        topbrace = Underbrace(top_brace_left, right).rotate(np.pi, RIGHT)\n",
        "        bottombrace = Underbrace(bottom_brace_left, right)\n",
        "        colors = Color(\"yellow\").range_to(\"purple\", iterations)\n",
        "        curr_dots.set_color(next(colors))\n",
        "        equation = OldTex(\n",
        "            \"1+2+4+\\\\cdots+2^n=2^{n+1} - 1\",\n",
        "            size = \"\\\\Huge\"\n",
        "        ).shift(3*UP)\n",
        "        full_top_sum = OldTex([\"1\", \"+2\", \"+4\", \"+8\", \"+16\"]).split()\n",
        "\n",
        "        self.add(equation)\n",
        "        self.wait()\n",
        "        self.add(circle, curr_dots, topbrace, bottombrace)\n",
        "        for n in range(1,iterations):\n",
        "            bottom_num = OldTex(str(2**n))\n",
        "            new_bottom_num = OldTex(str(2**(n+1)))            \n",
        "            bottom_num.shift(bottombrace.get_center()+0.5*DOWN)\n",
        "\n",
        "            top_sum = Mobject(*full_top_sum[:n]).center()\n",
        "            top_sum_end = deepcopy(full_top_sum[n]).center()\n",
        "            top_sum.shift(topbrace.get_center()+0.5*UP)\n",
        "            new_top_sum = Mobject(*full_top_sum[:(n+1)]).center()\n",
        "            self.add(top_sum, bottom_num)\n",
        "\n",
        "            if n == iterations:\n",
        "                continue\n",
        "            new_dot = deepcopy(dot).shift(circle.get_center())\n",
        "            shift_val = (2**n)*(dot_width+dot_buff)\n",
        "            right += shift_val\n",
        "            new_dots = Mobject(new_dot, curr_dots)\n",
        "            new_dots.set_color(next(colors)).shift(shift_val)\n",
        "            alt_bottombrace = deepcopy(bottombrace).shift(shift_val)\n",
        "            alt_bottom_num = deepcopy(bottom_num).shift(shift_val)\n",
        "            alt_topbrace = deepcopy(alt_bottombrace).rotate(np.pi, RIGHT)\n",
        "            top_sum_end.shift(alt_topbrace.get_center()+0.5*UP)\n",
        "            new_topbrace = Underbrace(top_brace_left, right).rotate(np.pi, RIGHT)\n",
        "            new_bottombrace = Underbrace(bottom_brace_left, right)\n",
        "            new_bottom_num.shift(new_bottombrace.get_center()+0.5*DOWN)\n",
        "            new_top_sum.shift(new_topbrace.get_center()+0.5*UP)\n",
        "            for exp, brace in [\n",
        "                    (top_sum, topbrace),\n",
        "                    (top_sum_end, alt_topbrace),\n",
        "                    (new_top_sum, new_topbrace),\n",
        "                ]:\n",
        "                if exp.get_width() > brace.get_width():\n",
        "                    exp.stretch_to_fit_width(brace.get_width())\n",
        "            new_top_sum = new_top_sum.split()\n",
        "            new_top_sum_start = Mobject(*new_top_sum[:-1])\n",
        "            new_top_sum_end = new_top_sum[-1]\n",
        "\n",
        "            self.wait()            \n",
        "            self.play(*[\n",
        "                FadeIn(mob)\n",
        "                for mob in [\n",
        "                    new_dots, \n",
        "                    alt_topbrace, \n",
        "                    alt_bottombrace, \n",
        "                    top_sum_end,\n",
        "                    alt_bottom_num,\n",
        "                ]\n",
        "            ])\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                Transform(topbrace, new_topbrace),\n",
        "                Transform(alt_topbrace, new_topbrace),\n",
        "                Transform(bottombrace, new_bottombrace),\n",
        "                Transform(alt_bottombrace, new_bottombrace),\n",
        "                Transform(bottom_num, new_bottom_num),\n",
        "                Transform(alt_bottom_num, new_bottom_num),\n",
        "                Transform(top_sum, new_top_sum_start),\n",
        "                Transform(top_sum_end, new_top_sum_end)\n",
        "            )\n",
        "            self.remove(\n",
        "                bottom_num, alt_bottom_num, top_sum, \n",
        "                top_sum_end, new_top_sum_end,\n",
        "                alt_topbrace, alt_bottombrace\n",
        "            )\n",
        "            curr_dots = Mobject(curr_dots, new_dots)\n",
        "\n",
        "        \n",
        "class PretendTheyDoApproachNegativeOne(RearrangeEquation):\n",
        "    def construct(self):\n",
        "        num_lines = 6\n",
        "        da = \"\\\\downarrow\"\n",
        "        columns = [\n",
        "            OldTex(\"\\\\\\\\\".join([\n",
        "                n_func(n)\n",
        "                for n in range(num_lines)\n",
        "            ]+last_bits), size = \"\\\\Large\").to_corner(UP+LEFT)\n",
        "            for n_func, last_bits in [\n",
        "               (lambda n : str(2**(n+1)-1), [\"\\\\vdots\", da, \"-1\"]),\n",
        "               (lambda n : \"+1\", [\"\", \"\", \"+1\"]),\n",
        "               (lambda n : \"=\", [\"\", \"\", \"=\"]),\n",
        "               (lambda n : str(2**(n+1)), [\"\\\\vdots\", da, \"0\"]),\n",
        "            ]\n",
        "        ]\n",
        "        columns[-1].set_color()\n",
        "        columns[2].shift(0.2*DOWN)\n",
        "        shift_val = 3*RIGHT\n",
        "        for column in columns:\n",
        "            column.shift(shift_val)\n",
        "            shift_val = shift_val + (column.get_width()+0.2)*RIGHT            \n",
        "        self.play(ShimmerIn(columns[0]))\n",
        "        self.wait()\n",
        "        self.add(columns[1])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            DelayByOrder(Transform(deepcopy(columns[0]), columns[-1])),\n",
        "            FadeIn(columns[2])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class DistanceBetweenRationalNumbers(Scene):\n",
        "    def construct(self):\n",
        "        locii = [2*LEFT, 2*RIGHT]\n",
        "        nums = [\n",
        "            OldTex(s).shift(1.3*d)\n",
        "            for s, d in zip([\"\\\\frac{1}{2}\", \"3\"], locii)\n",
        "        ]            \n",
        "        arrows = [\n",
        "            Arrow(direction, tail = ORIGIN)\n",
        "            for direction in locii\n",
        "        ]\n",
        "        dist = OldTex(\"\\\\frac{5}{2}\").scale(0.5).shift(0.5*UP)\n",
        "        text = OldTexText(\"How we define distance between rational numbers\")\n",
        "        text.to_edge(UP)\n",
        "        self.add(text, *nums)\n",
        "        self.play(*[ShowCreation(arrow) for arrow in arrows])\n",
        "        self.play(ShimmerIn(dist))\n",
        "        self.wait()\n",
        "\n",
        "class NotTheOnlyWayToOrganize(Scene):\n",
        "    def construct(self):\n",
        "        self.play(ShowCreation(NumberLine().add_numbers()))\n",
        "        self.wait()\n",
        "        words = \"Is there any other reasonable way to organize numbers?\"\n",
        "        self.play(FadeIn(OldTexText(words).shift(2*UP)))\n",
        "        self.wait()\n",
        "\n",
        "class DistanceIsAFunction(Scene):\n",
        "    args_list = [\n",
        "        (\"Euclidian\",),\n",
        "        (\"Random\",),\n",
        "        (\"2adic\",),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(word):\n",
        "        return word\n",
        "\n",
        "    def construct(self, mode):\n",
        "        if mode == \"Euclidian\":\n",
        "            dist_text = \"dist\"\n",
        "        elif mode == \"Random\":\n",
        "            dist_text = \"random\\\\_dist\"\n",
        "        elif mode == \"2adic\":\n",
        "            dist_text = \"2\\\\_adic\\\\_dist\"\n",
        "        dist, r_paren, arg0, comma, arg1, l_paren, equals, result = OldTexText([\n",
        "            dist_text, \"(\", \"000\", \",\", \"000\", \")\", \"=\", \"000\"\n",
        "        ]).split()\n",
        "        point_origin = comma.get_center()+0.2*UP\n",
        "        if mode == \"Random\":\n",
        "            examples = [\n",
        "                (\"2\", \"3\", \"7\"),\n",
        "                (\"\\\\frac{1}{2}\", \"100\", \"\\\\frac{4}{5}\"),\n",
        "            ]\n",
        "            dist.set_color(\"orange\")\n",
        "            self.add(dist)\n",
        "            self.wait()\n",
        "        elif mode == \"Euclidian\":\n",
        "            examples = [\n",
        "                (\"1\", \"5\", \"4\"),\n",
        "                (\"\\\\frac{1}{2}\", \"3\", \"\\\\frac{5}{2}\"),\n",
        "                (\"-3\", \"3\", \"6\"),\n",
        "                (\"2\", \"3\", \"1\"),\n",
        "                (\"0\", \"4\", \"x\"),\n",
        "                (\"1\", \"5\", \"x\"),\n",
        "                (\"2\", \"6\", \"x\"),\n",
        "            ]\n",
        "        elif mode == \"2adic\":\n",
        "            examples = [\n",
        "                (\"2\", \"0\", \"\\\\frac{1}{2}\"),\n",
        "                (\"-1\", \"15\", \"\\\\frac{1}{16}\"),\n",
        "                (\"3\", \"7\", \"\\\\frac{1}{4}\"),\n",
        "                (\"\\\\frac{3}{2}\", \"1\", \"2\"),\n",
        "            ]\n",
        "            dist.set_color(\"green\")\n",
        "            self.add(dist)\n",
        "            self.wait()\n",
        "        example_mobs = [\n",
        "            (\n",
        "                OldTex(tup[0]).shift(arg0.get_center()),\n",
        "                OldTex(tup[1]).shift(arg1.get_center()),\n",
        "                OldTex(tup[2]).shift(result.get_center())\n",
        "            )\n",
        "            for tup in examples\n",
        "        ]\n",
        "\n",
        "        self.add(dist, r_paren, comma, l_paren, equals)\n",
        "        previous = None\n",
        "        kwargs = {\"run_time\" : 0.5}\n",
        "        for mobs in example_mobs:\n",
        "            if previous:\n",
        "                self.play(*[\n",
        "                    DelayByOrder(Transform(prev, mob, **kwargs))\n",
        "                    for prev, mob in zip(previous, mobs)[:-1]\n",
        "                ])\n",
        "                self.play(DelayByOrder(Transform(\n",
        "                    previous[-1], mobs[-1], **kwargs\n",
        "                )))\n",
        "                self.remove(*previous)\n",
        "            self.add(*mobs)\n",
        "            previous = mobs\n",
        "            self.wait()\n",
        "\n",
        "class ShiftInvarianceNumberLine(Scene):\n",
        "    def construct(self):\n",
        "        number_line = NumberLine().add_numbers()\n",
        "        topbrace = Underbrace(ORIGIN, 2*RIGHT).rotate(np.pi, RIGHT)\n",
        "        dist0 = OldTexText([\"dist(\", \"$0$\", \",\", \"$2$\",\")\"])\n",
        "        dist1 = OldTexText([\"dist(\", \"$2$\", \",\", \"$4$\",\")\"])\n",
        "        for dist in dist0, dist1:\n",
        "            dist.shift(topbrace.get_center()+0.3*UP)\n",
        "        dist1.shift(2*RIGHT)\n",
        "        footnote = OldTexText(\"\"\"\n",
        "            \\\\begin{flushleft}\n",
        "            *yeah yeah, I know I'm still drawing them on a line,\n",
        "            but until a few minutes from now I have no other way\n",
        "            to draw them\n",
        "            \\\\end{flushright}\n",
        "        \"\"\").scale(0.5).to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.add(number_line, topbrace, dist0, footnote)\n",
        "        self.wait()\n",
        "        self.remove(dist0)\n",
        "        self.play(\n",
        "            ApplyMethod(topbrace.shift, 2*RIGHT),\n",
        "            *[\n",
        "                Transform(*pair)\n",
        "                for pair in zip(dist0.split(), dist1.split())\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class NameShiftInvarianceProperty(Scene):\n",
        "    def construct(self):\n",
        "        prop = OldTexText([\n",
        "            \"dist($A$, $B$) = dist(\",\n",
        "            \"$A+x$, $B+x$\",\n",
        "            \") \\\\quad for all $x$\"\n",
        "        ])\n",
        "        mid_part = prop.split()[1]\n",
        "        u_brace = Underbrace(\n",
        "            mid_part.get_boundary_point(DOWN+LEFT),\n",
        "            mid_part.get_boundary_point(DOWN+RIGHT)\n",
        "        ).shift(0.3*DOWN)\n",
        "        label = OldTexText(\"Shifted values\")\n",
        "        label.shift(u_brace.get_center()+0.5*DOWN)\n",
        "        name = OldTexText(\"``Shift Invariance''\")\n",
        "        name.set_color(\"green\").to_edge(UP)\n",
        "        for mob in u_brace, label:\n",
        "            mob.set_color(\"yellow\")\n",
        "\n",
        "        self.add(prop)\n",
        "        self.play(ShimmerIn(label), ShimmerIn(u_brace))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(name))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TriangleInequality(Scene):\n",
        "    def construct(self):\n",
        "        symbols = [\"A\", \"B\", \"C\"]\n",
        "        locations = [2*(DOWN+LEFT), UP, 4*RIGHT]\n",
        "        ab, plus, bc, greater_than, ac = OldTexText([\n",
        "            \"dist($A$, $B$)\",\n",
        "            \"$+$\",\n",
        "            \"dist($B$, $C$)\",\n",
        "            \"$>$\",\n",
        "            \"dist($A$, $C$)\",\n",
        "        ]).to_edge(UP).split()\n",
        "        all_dists = [ab, ac, bc]\n",
        "        ab_line, ac_line, bc_line = all_lines = [\n",
        "            Line(*pair).scale(0.8)\n",
        "            for pair in it.combinations(locations, 2)\n",
        "        ]\n",
        "        def put_on_line(mob, line):\n",
        "            result = deepcopy(mob).center().scale(0.5)\n",
        "            result.rotate(np.arctan(line.get_slope()))\n",
        "            result.shift(line.get_center()+0.2*UP)\n",
        "            return result\n",
        "        ab_copy, ac_copy, bc_copy = all_copies = [\n",
        "            put_on_line(dist, line)\n",
        "            for dist, line in zip(all_dists, all_lines)\n",
        "        ]\n",
        "        for symbol, loc in zip(symbols, locations):\n",
        "            self.add(OldTex(symbol).shift(loc))\n",
        "        self.play(ShowCreation(ac_line), FadeIn(ac_copy))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ShowCreation(line) for line in (ab_line, bc_line)\n",
        "        ]+[\n",
        "            FadeIn(dist) for dist in (ab_copy, bc_copy)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in zip(all_copies, all_dists)\n",
        "        ]+[\n",
        "            FadeIn(mob)\n",
        "            for mob in (plus, greater_than)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        \n",
        "\n",
        "class StruggleToFindFrameOfMind(Scene):\n",
        "    def construct(self):\n",
        "        you, bubble = draw_you(with_bubble = True)\n",
        "        questions = OldTexText(\"???\", size = \"\\\\Huge\").scale(1.5)\n",
        "        contents = [\n",
        "            OldTex(\"2, 4, 8, 16, 32, \\\\dots \\\\rightarrow 0\"),\n",
        "            OldTexText(\"dist(0, 2) $<$ dist(0, 64)\"),\n",
        "            NumberLine().sort_points(lambda p : -p[1]).add(\n",
        "                OldTexText(\"Not on a line?\").shift(UP)\n",
        "            ),\n",
        "        ]\n",
        "        kwargs = {\"run_time\" : 0.5}\n",
        "        self.add(you, bubble)\n",
        "        bubble.add_content(questions)\n",
        "        for mob in contents:\n",
        "            curr = bubble.content\n",
        "            self.remove(curr)\n",
        "            bubble.add_content(mob)\n",
        "            for first, second in [(curr, questions), (questions, mob)]:\n",
        "                copy = deepcopy(first)\n",
        "                self.play(DelayByOrder(Transform(\n",
        "                    copy, second, **kwargs\n",
        "                )))\n",
        "                self.remove(copy)\n",
        "            self.add(mob)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class RoomsAndSubrooms(Scene):\n",
        "    def construct(self):\n",
        "        colors = get_room_colors()\n",
        "        a_set = [3*RIGHT, 3*LEFT]\n",
        "        b_set = [1.5*UP, 1.5*DOWN]\n",
        "        c_set = [LEFT, RIGHT]\n",
        "        rectangle_groups = [\n",
        "            [Rectangle(7, 12).set_color(colors[0])],\n",
        "            [\n",
        "                Rectangle(6, 5).shift(a).set_color(colors[1])\n",
        "                for a in a_set\n",
        "            ],\n",
        "            [\n",
        "                Rectangle(2, 4).shift(a + b).set_color(colors[2])\n",
        "                for a in a_set\n",
        "                for b in b_set\n",
        "            ],\n",
        "            [\n",
        "                Rectangle(1, 1).shift(a+b+c).set_color(colors[3])\n",
        "                for a in a_set\n",
        "                for b in b_set\n",
        "                for c in c_set\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        for group in rectangle_groups:\n",
        "            mob = Mobject(*group)\n",
        "            mob.sort_points(get_norm)\n",
        "            self.play(ShowCreation(mob))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RoomsAndSubroomsWithNumbers(Scene):\n",
        "    def construct(self):\n",
        "        zero_local = (FRAME_X_RADIUS-0.5)*LEFT\n",
        "        zero_one_width = FRAME_X_RADIUS-0.3\n",
        "\n",
        "        zero, power_mobs = self.draw_numbers(zero_local, zero_one_width)\n",
        "        self.wait()\n",
        "        rectangles    = self.draw_first_rectangles(zero_one_width)\n",
        "        rect_clusters = self.draw_remaining_rectangles(rectangles)\n",
        "        self.adjust_power_mobs(zero, power_mobs, rect_clusters[-1])\n",
        "        self.wait()        \n",
        "        num_mobs = self.draw_remaining_numbers(\n",
        "            zero, power_mobs, rect_clusters\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_negative_one(num_mobs)\n",
        "        self.wait()\n",
        "        self.show_distances(num_mobs, rect_clusters)\n",
        "\n",
        "\n",
        "    def draw_numbers(self, zero_local, zero_one_width):\n",
        "        num_numbers = 5\n",
        "        zero = OldTex(\"0\").shift(zero_local)\n",
        "        self.add(zero)\n",
        "        nums = []\n",
        "        for n in range(num_numbers):\n",
        "            num = OldTex(str(2**n))\n",
        "            num.scale(1.0/(n+1))\n",
        "            num.shift(\n",
        "                zero_local+\\\n",
        "                RIGHT*zero_one_width/(2.0**n)+\\\n",
        "                LEFT*0.05*n+\\\n",
        "                (0.4*RIGHT if n == 0 else ORIGIN) #Stupid\n",
        "            )\n",
        "            self.play(FadeIn(num, run_time = 0.5))\n",
        "            nums.append(num)\n",
        "        return zero, nums\n",
        "\n",
        "    def draw_first_rectangles(self, zero_one_width):\n",
        "        side_buff = 0.05\n",
        "        upper_buff = 0.5\n",
        "        colors = get_room_colors()\n",
        "        rectangles = []\n",
        "        for n in range(4):\n",
        "            rect = Rectangle(\n",
        "                FRAME_HEIGHT-(n+2)*upper_buff, \n",
        "                zero_one_width/(2**n)-0.85*(n+1)*side_buff\n",
        "            )\n",
        "            rect.sort_points(get_norm)\n",
        "            rect.to_edge(LEFT, buff = 0.2).shift(n*side_buff*RIGHT)\n",
        "            rect.set_color(colors[n])\n",
        "            rectangles.append(rect)\n",
        "        for rect in rectangles:\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.wait()\n",
        "        return rectangles\n",
        "\n",
        "    def draw_remaining_rectangles(self, rectangles):\n",
        "        clusters = []\n",
        "        centers = [ORIGIN] + list(map(Mobject.get_center, rectangles))\n",
        "        shift_vals = [\n",
        "            2*(c2 - c1)[0]*RIGHT\n",
        "            for c1, c2 in zip(centers[1:], centers)\n",
        "        ]\n",
        "        for rectangle, count in zip(rectangles, it.count(1)):\n",
        "            cluster = [rectangle]\n",
        "            for shift_val in shift_vals[:count]:\n",
        "                cluster += [mob.shift(shift_val) for mob in deepcopy(cluster)]\n",
        "            clusters.append(cluster)\n",
        "            for rect in cluster[1:]:\n",
        "                self.play(FadeIn(rect, run_time = 0.6**(count-1)))\n",
        "        return clusters\n",
        "\n",
        "    def adjust_power_mobs(self, zero, power_mobs, small_rects):\n",
        "        new_zero = deepcopy(zero)\n",
        "        self.center_in_closest_rect(new_zero, small_rects)\n",
        "        new_power_mobs = deepcopy(power_mobs)        \n",
        "        for mob, count in zip(new_power_mobs, it.count(1)):\n",
        "            self.center_in_closest_rect(mob, small_rects)\n",
        "        new_power_mobs[-1].shift(DOWN)\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.scale(0.5).shift(new_zero.get_center()+0.5*DOWN)\n",
        "        self.play(\n",
        "            Transform(zero, new_zero),\n",
        "            FadeIn(dots),\n",
        "            *[\n",
        "                Transform(old, new)\n",
        "                for old, new in zip(power_mobs, new_power_mobs)\n",
        "            ]\n",
        "        )\n",
        "\n",
        "    def draw_remaining_numbers(self, zero, power_mobs, rect_clusters):\n",
        "        small_rects = rect_clusters[-1]\n",
        "        max_width = 0.8*small_rects[0].get_width()\n",
        "        max_power = 4\n",
        "        num_mobs = [None]*(2**max_power + 1)\n",
        "        num_mobs[0] = zero\n",
        "        powers = [2**k for k in range(max_power+1)]\n",
        "        for p, index in zip(powers, it.count()):\n",
        "            num_mobs[p] = power_mobs[index]\n",
        "        for power, count in zip(powers[1:-1], it.count(1)):\n",
        "            zero_copy = deepcopy(zero)\n",
        "            power_mob_copy = deepcopy(num_mobs[power])\n",
        "            def transform(mob):\n",
        "                self.center_in_closest_rect(mob, small_rects)\n",
        "                mob.shift(UP)\n",
        "                return mob\n",
        "            self.play(*[\n",
        "                ApplyFunction(transform, mob)\n",
        "                for mob in (zero_copy, power_mob_copy)\n",
        "            ])\n",
        "            last_left_mob = zero\n",
        "            for n in range(power+1, 2*power):\n",
        "                left_mob = num_mobs[n-power]\n",
        "                shift_val = left_mob.get_center()-last_left_mob.get_center()\n",
        "                self.play(*[\n",
        "                    ApplyMethod(mob.shift, shift_val)\n",
        "                    for mob in (zero_copy, power_mob_copy)\n",
        "                ])\n",
        "                num_mobs[n] = OldTex(str(n))\n",
        "                num_mobs[n].scale(1.0/(power_of_divisor(n, 2)+1))\n",
        "                width_ratio = max_width / num_mobs[n].get_width()\n",
        "                if width_ratio < 1: \n",
        "                    num_mobs[n].scale(width_ratio)\n",
        "                num_mobs[n].shift(power_mob_copy.get_center()+DOWN)\n",
        "                self.center_in_closest_rect(num_mobs[n], small_rects)\n",
        "                point = Point(power_mob_copy.get_center())\n",
        "                self.play(Transform(point, num_mobs[n]))\n",
        "                self.remove(point)\n",
        "                self.add(num_mobs[n])\n",
        "                last_left_mob = left_mob\n",
        "            self.remove(zero_copy, power_mob_copy)\n",
        "            self.wait()\n",
        "        return num_mobs\n",
        "\n",
        "    @staticmethod\n",
        "    def center_in_closest_rect(mobject, rectangles):\n",
        "        center = mobject.get_center()\n",
        "        diffs = [r.get_center()-center for r in rectangles]\n",
        "        mobject.shift(diffs[np.argmin(list(map(get_norm, diffs)))])\n",
        "\n",
        "    def add_negative_one(self, num_mobs):\n",
        "        neg_one = OldTex(\"-1\").scale(0.5)\n",
        "        shift_val = num_mobs[15].get_center()-neg_one.get_center()\n",
        "        neg_one.shift(UP)\n",
        "        self.play(ApplyMethod(neg_one.shift, shift_val))\n",
        "\n",
        "    def show_distances(self, num_mobs, rect_clusters):\n",
        "        self.remove(*[r for c in rect_clusters for r in c])\n",
        "        text = None\n",
        "        for cluster, count in zip(rect_clusters, it.count()):\n",
        "            if text is not None:\n",
        "                self.remove(text)\n",
        "            if count == 0:\n",
        "                dist_string = \"1\"\n",
        "            else:\n",
        "                dist_string = \"$\\\\frac{1}{%d}$\"%(2**count)\n",
        "            text = OldTexText(\n",
        "                \"Any of these pairs are considered to be a distance \" +\\\n",
        "                dist_string +\\\n",
        "                \" away from each other\"\n",
        "            ).shift(2*UP)\n",
        "            self.add(text)\n",
        "            self.clear_way_for_text(text, cluster)\n",
        "            self.add(*cluster)          \n",
        "            pairs = [a_b for a_b in it.combinations(list(range(16)), 2) if (a_b[0]-a_b[1])%(2**count) == 0 and (a_b[0]-a_b[1])%(2**(count+1)) != 0]\n",
        "            for pair in sample(pairs, min(10, len(pairs))):\n",
        "                for index in pair:\n",
        "                    num_mobs[index].set_color(\"green\")\n",
        "                self.play(*[\n",
        "                    ApplyMethod(\n",
        "                        num_mobs[index].rotate, np.pi/10, \n",
        "                        rate_func = wiggle\n",
        "                    )\n",
        "                    for index in pair\n",
        "                ])\n",
        "                self.wait()\n",
        "                for index in pair:\n",
        "                    num_mobs[index].set_color(\"white\")\n",
        "\n",
        "    @staticmethod\n",
        "    def clear_way_for_text(text, mobjects):\n",
        "        right, top, null = np.max(text.points, 0)\n",
        "        left, bottom, null = np.min(text.points, 0)\n",
        "        def filter_func(xxx_todo_changeme):\n",
        "            (x, y, z) = xxx_todo_changeme\n",
        "            return x>left and x<right and y>bottom and y<top\n",
        "        for mobject in mobjects:\n",
        "            mobject.filter_out(filter_func)\n",
        "\n",
        "class DeduceWhereNegativeOneFalls(Scene):\n",
        "    def construct(self):\n",
        "        part0, arg0, part1, part2, arg1, part3 = OldTexText([\n",
        "            \"dist(-1, \", \"0000\", \") = \", \"dist(0, \", \"0000\", \")\"\n",
        "        ]).scale(1.5).split()\n",
        "        u_brace = Underbrace(\n",
        "            part2.get_boundary_point(DOWN+LEFT),\n",
        "            part3.get_boundary_point(DOWN+RIGHT)\n",
        "        ).shift(0.3+DOWN)\n",
        "        \n",
        "        colors = list(get_room_colors())\n",
        "        num_labels = len(colors)\n",
        "        texts = [\n",
        "            Mobject(parts[0], parts[1].set_color(color))\n",
        "            for count, color in zip(it.count(), colors)\n",
        "            for parts in [TexText([\n",
        "                \"Represented (heuristically) \\\\\\\\ by being in the same \\\\\\\\\", \n",
        "                (count*\"sub-\")+\"room\"\n",
        "            ]).split()]\n",
        "        ]\n",
        "        target_text_top = u_brace.get_center()+0.5*DOWN\n",
        "        for text in texts:\n",
        "            text.shift(target_text_top - text.get_top())\n",
        "\n",
        "        self.add(part0, part1, part2, part3, u_brace)\n",
        "        last_args = [arg0, arg1]\n",
        "        for n in range(1, 15):\n",
        "            rest_time = 0.3 + 1.0/(n+1)\n",
        "            new_args = [\n",
        "                OldTexText(\"$%d$\"%k).scale(1.5)\n",
        "                for k in (2**n-1, 2**n)\n",
        "            ]\n",
        "            for new_arg, old_arg in zip(new_args, last_args):\n",
        "                new_arg.shift(old_arg.get_center())\n",
        "            if last_args != [arg0, arg1]:\n",
        "                self.play(*[\n",
        "                    DelayByOrder(Transform(*pair, run_time = 0.5*rest_time))\n",
        "                    for pair in zip(last_args, new_args)\n",
        "                ])\n",
        "            if n-1 < num_labels:\n",
        "                self.add(texts[n-1])\n",
        "                if n > 1:\n",
        "                    self.remove(texts[n-2])\n",
        "            else:\n",
        "                self.remove(u_brace, *texts)\n",
        "            self.remove(*last_args)\n",
        "            self.add(*new_args)\n",
        "            self.wait(rest_time)\n",
        "            last_args = new_args\n",
        "\n",
        "\n",
        "class OtherRationalNumbers(Scene):\n",
        "    def construct(self):\n",
        "        import random\n",
        "        self.add(OldTexText(\"Where do other \\\\\\\\ rational numbers fall?\"))\n",
        "        pairs = [\n",
        "            (1, 2),\n",
        "            (1, 3),\n",
        "            (4, 9),\n",
        "            (-7, 13),\n",
        "            (3, 1001),\n",
        "        ]\n",
        "        locii = [\n",
        "            4*LEFT+2*UP,\n",
        "            4*RIGHT,\n",
        "            5*RIGHT+UP,\n",
        "            4*LEFT+2*DOWN,\n",
        "            3*DOWN,\n",
        "        ]\n",
        "        for pair, locus in zip(pairs, locii):\n",
        "            fraction = OldTex(\"\\\\frac{%d}{%d}\"%pair).shift(locus)\n",
        "            self.play(ShimmerIn(fraction))\n",
        "        self.wait()\n",
        "\n",
        "class PAdicMetric(Scene):\n",
        "    def construct(self):\n",
        "        p_str, text = OldTexText([\"$p$\", \"-adic metric\"]).shift(2*UP).split()\n",
        "        primes = [Tex(str(p)) for p in [2, 3, 5, 7, 11, 13, 17, 19, 23]]\n",
        "        p_str.set_color(\"yellow\")\n",
        "        colors = Color(\"green\").range_to(\"skyblue\", len(primes))\n",
        "        new_numbers = OldTexText(\"Completely new types of numbers!\")\n",
        "        new_numbers.set_color(\"skyblue\").shift(2.3*DOWN)\n",
        "        arrow = Arrow(2*DOWN, tail = 1.7*UP)\n",
        "\n",
        "        curr = deepcopy(p_str)\n",
        "        self.add(curr, text)\n",
        "        self.wait()        \n",
        "        for prime, count in zip(primes, it.count()):\n",
        "            prime.scale(1.0).set_color(next(colors))\n",
        "            prime.shift(center_of_mass([p_str.get_top(), p_str.get_center()]))\n",
        "            self.play(DelayByOrder(Transform(curr, prime)))\n",
        "            self.wait()\n",
        "            if count == 2:\n",
        "                self.spill(Mobject(curr, text), arrow, new_numbers)\n",
        "            self.remove(curr)\n",
        "            curr = prime\n",
        "        self.play(DelayByOrder(Transform(curr, p_str)))\n",
        "        self.wait()\n",
        "\n",
        "    def spill(self, start, arrow, end):\n",
        "        start.sort_points(lambda p : p[1])\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                arrow,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1.0)\n",
        "            ),\n",
        "            DelayByOrder(Transform(\n",
        "                start,\n",
        "                Point(arrow.get_points()[0]).set_color(\"white\")\n",
        "            ))\n",
        "        )\n",
        "        self.play(ShimmerIn(end))\n",
        "\n",
        "\n",
        "class FuzzyDiscoveryToNewMath(Scene):\n",
        "    def construct(self):\n",
        "        fuzzy = OldTexText(\"Fuzzy Discovery\")\n",
        "        fuzzy.to_edge(UP).shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        new_math = OldTexText(\"New Math\")\n",
        "        new_math.to_edge(UP).shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        lines = Mobject(\n",
        "            Line(DOWN*FRAME_Y_RADIUS, UP*FRAME_Y_RADIUS),\n",
        "            Line(3*UP+LEFT*FRAME_X_RADIUS, 3*UP+RIGHT*FRAME_X_RADIUS)\n",
        "        )\n",
        "        fuzzy_discoveries = [\n",
        "            OldTex(\"a^2 + b^2 = c^2\"),\n",
        "            OldTex(\"\".join(CONVERGENT_SUM_TEXT)),            \n",
        "            OldTex(\"\".join(DIVERGENT_SUM_TEXT)),\n",
        "            OldTex(\"e^{\\pi i} = -1\"),\n",
        "        ]\n",
        "        triangle_lines = [\n",
        "            Line(ORIGIN, LEFT),\n",
        "            Line(LEFT, UP),\n",
        "            Line(UP, ORIGIN),\n",
        "        ]\n",
        "        for line, char in zip(triangle_lines, [\"a\", \"c\", \"b\"]):\n",
        "            line.set_color(\"blue\")\n",
        "            char_mob = OldTex(char).scale(0.25)\n",
        "            line.add(char_mob.shift(line.get_center()))\n",
        "        triangle = Mobject(*triangle_lines)\n",
        "        triangle.center().shift(1.5*fuzzy_discoveries[0].get_right())\n",
        "        how_length = OldTexText(\"But how is length defined?\").scale(0.5)\n",
        "        how_length.shift(0.75*DOWN)\n",
        "        fuzzy_discoveries[0].add(triangle, how_length)\n",
        "        new_maths = [\n",
        "            OldTexText(\"\"\"\n",
        "                Define distance between points $(x_0, y_0)$ and\n",
        "                $(x_1, y_1)$ as $\\\\sqrt{(x_1-x_0)^2 + (y_1-y_0)^2}$\n",
        "            \"\"\"),\n",
        "            OldTexText(\"Define ``approach'' and infinite sums\"),\n",
        "            OldTexText(\"Discover $2$-adic numbers\"),\n",
        "            OldTexText(\n",
        "                \"Realize exponentiation is doing something much \\\n",
        "                different from repeated multiplication\"\n",
        "            )\n",
        "        ]\n",
        "        midpoints = []\n",
        "        triplets = list(zip(fuzzy_discoveries, new_maths, it.count(2, -1.75)))\n",
        "        for disc, math, count in triplets:\n",
        "            math.scale(0.65)\n",
        "            for mob in disc, math:\n",
        "                mob.to_edge(LEFT).shift(count*UP)\n",
        "            math.shift(FRAME_X_RADIUS*RIGHT)\n",
        "            midpoints.append(count*UP)\n",
        "\n",
        "        self.add(fuzzy, lines)\n",
        "        self.play(*list(map(ShimmerIn, fuzzy_discoveries)))\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(Transform(\n",
        "            deepcopy(fuzzy), new_math\n",
        "        )))\n",
        "        self.play(*[\n",
        "            DelayByOrder(Transform(deepcopy(disc), math))\n",
        "            for disc, math in zip(fuzzy_discoveries, new_maths)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DiscoveryAndInvention(Scene):\n",
        "    def construct(self):\n",
        "        invention, vs, discovery = OldTexText([\n",
        "            \"Invention \", \"vs. \", \"Discovery\"\n",
        "        ]).split()\n",
        "        nrd = OldTexText(\n",
        "            \"Non-rigorous truths\"\n",
        "        ).shift(2*UP)\n",
        "        rt = OldTexText(\n",
        "            \"Rigorous terms\"\n",
        "        ).shift(2*DOWN)\n",
        "        \n",
        "        arrows = []\n",
        "        self.add(discovery, vs, invention)\n",
        "        self.wait()\n",
        "        arrow = Arrow(\n",
        "            nrd.get_bottom(),\n",
        "            tail = discovery.get_top()\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(nrd),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        arrows.append(arrow)\n",
        "        self.wait()\n",
        "        arrow = Arrow(\n",
        "            invention.get_top(),\n",
        "            tail = nrd.get_bottom()\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        arrows.append(arrow)\n",
        "        self.wait()\n",
        "        arrow = Arrow(\n",
        "            rt.get_top(),\n",
        "            tail = invention.get_bottom()\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(rt),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        arrows.append(arrow)\n",
        "        self.wait()\n",
        "        arrow = Arrow(\n",
        "            discovery.get_bottom(),\n",
        "            tail = rt.get_top()\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        arrows.append(arrow)\n",
        "        for color in Color(\"yellow\").range_to(\"red\", 4):\n",
        "            for arrow in arrows:\n",
        "                self.play(\n",
        "                    ShowCreation(deepcopy(arrow).set_color(color)),\n",
        "                    run_time = 0.25\n",
        "                )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    command_line_create_scene(MOVIE_PREFIX)\n",
        "\n"
    ]
}