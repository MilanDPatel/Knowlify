{
    "topic": "demonstrates the concept of incomplete squares, specifically the way they can be reordered to form",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class IncompleteSquares(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up top row\n",
        "        squares = VGroup(self.get_square(n) for n in range(16))\n",
        "        squares.arrange(RIGHT, buff=0.5)\n",
        "        squares.center()\n",
        "        squares.set_width(FRAME_WIDTH - 1)\n",
        "        self.add(squares)\n",
        "\n",
        "        # Reorder by groups\n",
        "        groups = VGroup(\n",
        "            VGroup(squares[i] for i in index_groups)\n",
        "            for index_groups in [\n",
        "                [0],\n",
        "                [1, 2, 4, 8],\n",
        "                [3, 6, 9, 12],\n",
        "                [5, 10],\n",
        "                [7, 11, 13, 14],\n",
        "                [15],\n",
        "            ]\n",
        "        )\n",
        "        groups.target = groups.generate_target()\n",
        "        for group in groups.target:\n",
        "            group.arrange(RIGHT, buff=0.25)\n",
        "        groups.target.arrange(RIGHT, buff=0.5)\n",
        "        groups.target.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(group, buff=0.15).set_stroke(width=3).round_corners()\n",
        "            for group in groups.target\n",
        "        )\n",
        "        rects.set_submobject_colors_by_gradient(RED, YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(groups, path_arc=45 * DEG, run_time=3),\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, rects, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Count the groups\n",
        "        ones = VGroup(\n",
        "            Integer(1).next_to(rect, UP)\n",
        "            for rect in rects\n",
        "        )\n",
        "        plusses = VGroup(\n",
        "            Tex(R\"+\").move_to(VGroup(pair))\n",
        "            for pair in zip(ones, ones[1:])\n",
        "        )\n",
        "        brace = Brace(ones, UP)\n",
        "        six = Integer(6).next_to(brace, UP)\n",
        "        brace_group = VGroup(brace, six)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, ones, shift=0.25 * UP),\n",
        "            LaggedStartMap(FadeIn, plusses, shift=0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(six)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the fractions\n",
        "        all_fractions = VGroup(ones[0])\n",
        "        fraction_groups = VGroup(ones[:1])\n",
        "        ones_shift = 0.15 * UP\n",
        "        for group in groups[1:-1]:\n",
        "            n = len(group)\n",
        "            new_fracs = VGroup(\n",
        "                Tex(Rf\"1 \\over {{{n}}}\", font_size=36).next_to(square, UP).match_y(ones).shift(ones_shift)\n",
        "                for square in group\n",
        "            )\n",
        "            all_fractions.add(*new_fracs)\n",
        "            fraction_groups.add(new_fracs)\n",
        "\n",
        "        all_fractions.add(ones[-1])\n",
        "        fraction_groups.add(ones[-1:])\n",
        "\n",
        "        new_plusses = VGroup(\n",
        "            Tex(R\"+\", font_size=36).move_to(VGroup(*pair))\n",
        "            for pair in zip(all_fractions, all_fractions[1:])\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(plusses),\n",
        "            brace_group.animate.next_to(all_fractions, UP, SMALL_BUFF),\n",
        "            ones.animate.shift(ones_shift)\n",
        "        )\n",
        "        for one, frac_group in zip(ones, fraction_groups):\n",
        "            self.play(ReplacementTransform(one, frac_group, lag_ratio=0.01, run_time=1))\n",
        "\n",
        "        self.play(FadeIn(new_plusses, lag_ratio=0.1))\n",
        "\n",
        "        top_sum = VGroup(all_fractions, new_plusses)\n",
        "\n",
        "        # Show the rotations\n",
        "        frame = self.frame\n",
        "        v_line = Line(rects.get_left(), rects.get_right()).next_to(rects, DOWN)\n",
        "        v_line.set_stroke(WHITE, 2)\n",
        "        v_line.next_to(rects, DOWN)\n",
        "        v_line.scale(1.2, about_edge=RIGHT)\n",
        "\n",
        "        def get_rot_sym(angle, label_tex):\n",
        "            arcs = VGroup(\n",
        "                Arc(0, angle),\n",
        "                Arc(PI, angle)\n",
        "            )\n",
        "            for arc in arcs:\n",
        "                arc.set_stroke(TEAL, 3)\n",
        "                arc.add_tip()\n",
        "            arcs.scale(0.45)\n",
        "            label = Tex(label_tex, font_size=24)\n",
        "            return VGroup(arcs, label)\n",
        "\n",
        "        rot_symbols = VGroup(\n",
        "            Text(\"Id\"),\n",
        "            get_rot_sym(90 * DEG, R\"90^\\circ\"),\n",
        "            get_rot_sym(165 * DEG, R\"180^\\circ\"),\n",
        "            get_rot_sym(-90 * DEG, R\"-90^\\circ\"),\n",
        "        )\n",
        "        rot_symbols.arrange(DOWN, buff=0.75)\n",
        "        rot_symbols.next_to(v_line, DOWN, 0.75)\n",
        "        rot_symbols.set_x(rects.get_x(LEFT) - rot_symbols.get_width() - MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            frame.animate.reorient(0, 0, 0, (-1.55, -2.67, 0.0), 10.59),\n",
        "            FadeIn(rot_symbols)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Create columns\n",
        "        columns = VGroup()\n",
        "        squares.sort(lambda p: p[0])  # Sort from left to right\n",
        "        for square in squares:\n",
        "            col = VGroup(\n",
        "                square.copy().rotate(angle)\n",
        "                for angle in np.arange(0, TAU, TAU / 4)\n",
        "            )\n",
        "            col.match_x(square)\n",
        "            for part, sym in zip(col, rot_symbols):\n",
        "                part.match_y(sym)\n",
        "\n",
        "            columns.add(col)\n",
        "\n",
        "        fixed_points = [col[0] for col in columns]\n",
        "        fixed_points.extend(columns[0][1:])\n",
        "        fixed_points.extend(columns[-1][1:])\n",
        "        fixed_points.extend([\n",
        "            columns[9][2],\n",
        "            columns[10][2],\n",
        "        ])\n",
        "        fixed_point_dots = Group(GlowDot(radius=0.5).move_to(point) for point in fixed_points)\n",
        "\n",
        "        # Show example columns\n",
        "        low_opacity = 0.2\n",
        "        ex_index = 4\n",
        "        self.play(\n",
        "            rects.animate.set_stroke(opacity=low_opacity),\n",
        "            squares[:ex_index].animate.set_stroke(opacity=low_opacity),\n",
        "            squares[ex_index + 1:].animate.set_stroke(opacity=low_opacity),\n",
        "            all_fractions.animate.set_fill(opacity=low_opacity),\n",
        "            top_sum.animate.set_opacity(low_opacity),\n",
        "            brace_group.animate.set_opacity(low_opacity)\n",
        "        )\n",
        "        for piece in columns[ex_index]:\n",
        "            self.play(TransformFromCopy(squares[ex_index], piece, path_arc=30 * DEG))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            squares[1:ex_index].animate.set_stroke(opacity=1),\n",
        "            rects[1].animate.set_stroke(opacity=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ex_index = 9\n",
        "        self.play(squares[ex_index].animate.set_stroke(opacity=1))\n",
        "        for piece in columns[ex_index]:\n",
        "            self.play(TransformFromCopy(squares[ex_index], piece, path_arc=30 * DEG))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rects[3].animate.set_stroke(opacity=1),\n",
        "            squares[10].animate.set_stroke(opacity=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ex_index = 15\n",
        "        self.play(squares[ex_index].animate.set_stroke(opacity=1))\n",
        "        for piece in columns[ex_index]:\n",
        "            self.play(TransformFromCopy(squares[ex_index], piece, path_arc=30 * DEG))\n",
        "        self.wait()\n",
        "        self.play(rects[5].animate.set_stroke(opacity=1))\n",
        "\n",
        "        # Show fixed point dots\n",
        "        dot = GlowDot(radius=0.5)\n",
        "        ex_dots1 = Group(dot.copy().move_to(part) for part in columns[9][0::2])\n",
        "        ex_dots2 = Group(dot.copy().move_to(part) for part in columns[15])\n",
        "        ex_dots3 = Group(dot.copy().move_to(columns[4][0]))\n",
        "\n",
        "        for dots in [ex_dots1, ex_dots2, ex_dots3]:\n",
        "            self.play(FadeIn(dots))\n",
        "            self.wait()\n",
        "\n",
        "        # Show fractions\n",
        "        ex_fractions = VGroup(all_fractions[i] for i in [4, 9, 15])\n",
        "        ex_dot_groups = Group(ex_dots3, ex_dots1, ex_dots2)\n",
        "\n",
        "        def get_fourth_exprs(dot_group):\n",
        "            return VGroup(\n",
        "                Tex(R\"1 / 4\", font_size=24).next_to(dot, DOWN, buff=0)\n",
        "                for dot in dot_group\n",
        "            )\n",
        "\n",
        "        ex_fourths = VGroup(\n",
        "            get_fourth_exprs(dot_group)\n",
        "            for dot_group in ex_dot_groups\n",
        "        )\n",
        "\n",
        "        self.play(ex_fractions.animate.set_opacity(1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(frac, fourth_group, path_arc=30 * DEG)\n",
        "                for frac, fourth_group in zip(ex_fractions, ex_fourths)),\n",
        "                lag_ratio=0.75,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Light everything back up\n",
        "        self.play(\n",
        "            brace_group.animate.set_opacity(1),\n",
        "            top_sum.animate.set_opacity(1),\n",
        "            rects.animate.set_stroke(opacity=1),\n",
        "            squares.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show all transform/shape pairs\n",
        "        all_fourths = get_fourth_exprs(fixed_point_dots)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            (ReplacementTransform(square.replicate(4), col, path_arc=30 * DEG)\n",
        "            for square, col in zip(squares, columns)),\n",
        "            lag_ratio=0.5,\n",
        "            run_time=5\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(fixed_point_dots),\n",
        "            FadeOut(ex_dot_groups),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(all_fourths),\n",
        "            FadeOut(ex_fourths),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_square(self, edge_pattern: int = 0, edge_color=BLUE, edge_stroke_width=5):\n",
        "        outline = VGroup(\n",
        "            DashedLine(p1, p2, dash_length=0.1).set_stroke(GREY_C, 1)\n",
        "            for p1, p2 in adjacent_pairs([UL, UR, DR, DL])\n",
        "        )\n",
        "        pattern = [(edge_pattern >> (3 - i)) & 1 == 1 for i in range(4)]  # Pattern of bools\n",
        "        bold_edges = VGroup()\n",
        "\n",
        "        for edge, include in zip(outline, pattern):\n",
        "            if include:\n",
        "                line = Line(edge.get_start(), edge.get_end())\n",
        "                line.set_stroke(edge_color, edge_stroke_width)\n",
        "                line.scale(1.075)  # Bad hack for bevel\n",
        "                bold_edges.add(line)\n",
        "\n",
        "        return VGroup(outline, bold_edges)\n"
    ]
}