{
    "topic": "The mathematical concept being demonstrated is the Wallis product formula for pi.",
    "code": [
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from once_useful_constructs.light import AmbientLight\n",
        "from once_useful_constructs.light import Lighthouse\n",
        "from once_useful_constructs.light import SwitchOn\n",
        "from functools import reduce\n",
        "# from once_useful_constructs.light import LightSource\n",
        "\n",
        "PRODUCT_COLOR = BLUE\n",
        "DEFAULT_OPACITY_FUNCTION = inverse_power_law(1, 1.5, 1, 4)\n",
        "CHEAP_AMBIENT_LIGHT_CONFIG = {\n",
        "    \"num_levels\": 5,\n",
        "    \"radius\": 0.25,\n",
        "    \"opacity_function\": DEFAULT_OPACITY_FUNCTION,\n",
        "}\n",
        "HIGHT_QUALITY_AMBIENT_LIGHT_CONFIG = {\n",
        "    \"opacity_function\": DEFAULT_OPACITY_FUNCTION,\n",
        "    \"num_levels\": 100,\n",
        "    \"radius\": 5,\n",
        "    \"max_opacity\": 0.8,\n",
        "    \"color\": PRODUCT_COLOR,\n",
        "}\n",
        "\n",
        "\n",
        "def get_chord_f_label(chord, arg=\"f\", direction=DOWN):\n",
        "    chord_f = OldTexText(\"Chord(\", \"$%s$\" % arg, \")\", arg_separator=\"\")\n",
        "    chord_f.set_color_by_tex(\"$%s$\" % arg, YELLOW)\n",
        "    chord_f.add_background_rectangle()\n",
        "    chord_f.next_to(chord.get_center(), direction, SMALL_BUFF)\n",
        "    angle = ((chord.get_angle() + TAU / 2) % TAU) - TAU / 2\n",
        "    if np.abs(angle) > TAU / 4:\n",
        "        angle += TAU / 2\n",
        "    chord_f.rotate(angle, about_point=chord.get_center())\n",
        "    chord_f.angle = angle\n",
        "    return chord_f\n",
        "\n",
        "\n",
        "class WallisNumeratorDenominatorGenerator(object):\n",
        "    def __init__(self):\n",
        "        self.n = 0\n",
        "\n",
        "    def __iter__(self):\n",
        "        return self\n",
        "\n",
        "    def __next__(self):\n",
        "        return next(self)\n",
        "\n",
        "    def __next__(self):\n",
        "        n = self.n\n",
        "        self.n += 1\n",
        "        if n % 2 == 0:\n",
        "            return (n + 2, n + 1)\n",
        "        else:\n",
        "            return (n + 1, n + 2)\n",
        "\n",
        "\n",
        "def get_wallis_product(n_terms=6, show_result=True):\n",
        "    tex_mob_args = []\n",
        "    nd_generator = WallisNumeratorDenominatorGenerator()\n",
        "    for x in range(n_terms):\n",
        "        numerator, denominator = next(nd_generator)\n",
        "        tex_mob_args += [\n",
        "            \"{%d\" % numerator, \"\\\\over\", \"%d}\" % denominator, \"\\\\cdot\"\n",
        "        ]\n",
        "    tex_mob_args[-1] = \"\\\\cdots\"\n",
        "    if show_result:\n",
        "        tex_mob_args += [\"=\", \"{\\\\pi\", \"\\\\over\", \"2}\"]\n",
        "\n",
        "    result = OldTex(*tex_mob_args)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_wallis_product_numerical_terms(n_terms=20):\n",
        "    result = []\n",
        "    nd_generator = WallisNumeratorDenominatorGenerator()\n",
        "    for x in range(n_terms):\n",
        "        n, d = next(nd_generator)\n",
        "        result.append(float(n) / d)\n",
        "    return result\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class Introduction(Scene):\n",
        "    def construct(self):\n",
        "        n_terms = 10\n",
        "\n",
        "        number_line = NumberLine(\n",
        "            x_min=0,\n",
        "            x_max=2,\n",
        "            unit_size=5,\n",
        "            tick_frequency=0.25,\n",
        "            big_tick_numbers=[0, 1, 2],\n",
        "            color=GREY_B,\n",
        "        )\n",
        "        number_line.add_numbers()\n",
        "        number_line.move_to(DOWN)\n",
        "\n",
        "        numerical_terms = get_wallis_product_numerical_terms(400)\n",
        "        partial_products = np.cumprod(numerical_terms)\n",
        "        curr_product = partial_products[0]\n",
        "\n",
        "        arrow = Vector(DOWN, color=YELLOW)\n",
        "\n",
        "        def get_arrow_update():\n",
        "            return ApplyFunction(\n",
        "                lambda mob: mob.next_to(\n",
        "                    number_line.number_to_point(curr_product),\n",
        "                    UP, SMALL_BUFF\n",
        "                ),\n",
        "                arrow,\n",
        "            )\n",
        "        get_arrow_update().update(1)\n",
        "        decimal = DecimalNumber(\n",
        "            curr_product, num_decimal_places=5, show_ellipsis=True)\n",
        "        decimal.next_to(arrow, UP, SMALL_BUFF, submobject_to_align=decimal[:5])\n",
        "        decimal_anim = ChangingDecimal(\n",
        "            decimal,\n",
        "            lambda a: number_line.point_to_number(arrow.get_center()),\n",
        "            tracked_mobject=arrow\n",
        "        )\n",
        "\n",
        "        product_mob = get_wallis_product(n_terms)\n",
        "        product_mob.to_edge(UP)\n",
        "\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(product_mob[:n])\n",
        "            for n in list(range(3, 4 * n_terms, 4)) + [4 * n_terms]\n",
        "        ])\n",
        "        rect = rects[0].copy()\n",
        "\n",
        "        pi_halves_arrow = Vector(UP, color=BLUE)\n",
        "        pi_halves_arrow.next_to(\n",
        "            number_line.number_to_point(np.pi / 2), DOWN, SMALL_BUFF\n",
        "        )\n",
        "        pi_halves_term = OldTex(\"\\\\pi / 2\")\n",
        "        pi_halves_term.next_to(pi_halves_arrow, DOWN)\n",
        "\n",
        "        self.add(product_mob, number_line, rect, arrow, decimal)\n",
        "        self.add(pi_halves_arrow, pi_halves_term)\n",
        "        for n in range(1, len(rects)):\n",
        "            curr_product = partial_products[n]\n",
        "            self.play(\n",
        "                get_arrow_update(),\n",
        "                decimal_anim,\n",
        "                Transform(rect, rects[n]),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "        for n in range(len(rects), len(numerical_terms), 31):\n",
        "            curr_product = partial_products[n]\n",
        "            self.play(\n",
        "                get_arrow_update(),\n",
        "                decimal_anim,\n",
        "                run_time=0.25\n",
        "            )\n",
        "        curr_product = np.pi / 2\n",
        "        self.play(\n",
        "            get_arrow_update(),\n",
        "            decimal_anim,\n",
        "            run_time=0.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TableOfContents(Scene):\n",
        "    def construct(self):\n",
        "        topics = VGroup(\n",
        "            OldTexText(\"The setup\"),\n",
        "            OldTexText(\"Circle geometry with complex polynomials\"),\n",
        "            OldTexText(\"Proof of the Wallis product\"),\n",
        "            OldTexText(\"Formalities not discussed\"),\n",
        "            OldTexText(\n",
        "                \"Generalizing this proof to get \\\\\\\\ the product formula for sine\"),\n",
        "        )\n",
        "        for topic in topics:\n",
        "            dot = Dot(color=BLUE)\n",
        "            dot.next_to(topic, LEFT)\n",
        "            topic.add(dot)\n",
        "        topics.arrange(\n",
        "            DOWN, aligned_edge=LEFT, buff=LARGE_BUFF\n",
        "        )\n",
        "        self.add(topics)\n",
        "        self.wait()\n",
        "        for i in range(len(topics)):\n",
        "            self.play(\n",
        "                topics[i + 1:].set_fill, {\"opacity\": 0.25},\n",
        "                topics[:i].set_fill, {\"opacity\": 0.25},\n",
        "                topics[i].set_fill, {\"opacity\": 1},\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class SourcesOfOriginality(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.mention_excitement()\n",
        "        self.break_down_value_of_math_presentations()\n",
        "        self.where_we_fit_in()\n",
        "\n",
        "    def mention_excitement(self):\n",
        "        self.teacher_says(\n",
        "            \"This one came about \\\\\\\\ a bit differently...\",\n",
        "            target_mode=\"speaking\",\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"confused\", \"erm\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def break_down_value_of_math_presentations(self):\n",
        "        title = OldTexText(\"The value of a\", \"math\", \"presentation\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        value_of, math, presentation = title\n",
        "\n",
        "        MATH_COLOR = YELLOW\n",
        "        COMMUNICATION_COLOR = BLUE\n",
        "\n",
        "        big_rect = self.big_rect = Rectangle(\n",
        "            width=title.get_width() + 2 * MED_LARGE_BUFF,\n",
        "            height=3.5,\n",
        "            color=WHITE\n",
        "        )\n",
        "        big_rect.next_to(title, DOWN)\n",
        "\n",
        "        left_rect, right_rect = self.left_rect, self.right_rect = [\n",
        "            Rectangle(\n",
        "                height=big_rect.get_height() - 2 * SMALL_BUFF,\n",
        "                width=0.5 * big_rect.get_width() - 2 * SMALL_BUFF,\n",
        "                color=color\n",
        "            )\n",
        "            for color in (MATH_COLOR, COMMUNICATION_COLOR)\n",
        "        ]\n",
        "        right_rect.flip()\n",
        "        left_rect.next_to(big_rect.get_left(), RIGHT, SMALL_BUFF)\n",
        "        right_rect.next_to(big_rect.get_right(), LEFT, SMALL_BUFF)\n",
        "\n",
        "        underlying_math = OldTexText(\"Underlying\", \"math\")\n",
        "        underlying_math.set_color(MATH_COLOR)\n",
        "        communication = OldTexText(\"Communication\")\n",
        "        communication.set_color(COMMUNICATION_COLOR)\n",
        "        VGroup(underlying_math, communication).scale(0.75)\n",
        "        underlying_math.next_to(left_rect.get_top(), DOWN, SMALL_BUFF)\n",
        "        communication.next_to(right_rect.get_top(), DOWN, SMALL_BUFF)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"\\\\sum_{n = 1}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{2}\",\n",
        "        )\n",
        "        formula.scale(0.75)\n",
        "        formula.next_to(underlying_math, DOWN)\n",
        "\n",
        "        based_on_wastlund = OldTexText(\n",
        "            \"Previous video based on\\\\\\\\\",\n",
        "            \"a paper by Johan W\\\\\\\"{a}stlund\"\n",
        "        )\n",
        "        based_on_wastlund.set_width(\n",
        "            left_rect.get_width() - MED_SMALL_BUFF)\n",
        "        based_on_wastlund.next_to(formula, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        communication_parts = OldTexText(\"Visuals, narrative, etc.\")\n",
        "        communication_parts.scale(0.75)\n",
        "        communication_parts.next_to(communication, DOWN, MED_LARGE_BUFF)\n",
        "        lighthouse = Lighthouse(height=0.5)\n",
        "        lighthouse.next_to(communication_parts, DOWN, LARGE_BUFF)\n",
        "        ambient_light = AmbientLight(\n",
        "            num_levels=200,\n",
        "            radius=5,\n",
        "            opacity_function=DEFAULT_OPACITY_FUNCTION,\n",
        "        )\n",
        "        ambient_light.move_source_to(lighthouse.get_top())\n",
        "\n",
        "        big_rect.save_state()\n",
        "        big_rect.stretch(0, 1)\n",
        "        big_rect.stretch(0.5, 0)\n",
        "        big_rect.move_to(title)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(title),\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode=\"raise_right_hand\",\n",
        "                look_at=title,\n",
        "            ),\n",
        "            self.change_students(\n",
        "                *[\"pondering\"] * 3,\n",
        "                look_at=title\n",
        "            )\n",
        "        )\n",
        "        self.play(big_rect.restore)\n",
        "        self.play(*list(map(ShowCreation, [left_rect, right_rect])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            math.match_color, left_rect,\n",
        "            ReplacementTransform(VGroup(math.copy()), underlying_math)\n",
        "        )\n",
        "        self.play(FadeIn(formula))\n",
        "        self.play(\n",
        "            presentation.match_color, right_rect,\n",
        "            ReplacementTransform(presentation.copy(), communication)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(communication_parts),\n",
        "            FadeIn(lighthouse),\n",
        "            SwitchOn(ambient_light)\n",
        "        )\n",
        "        self.play(self.teacher.change, \"tease\")\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(based_on_wastlund),\n",
        "            self.change_students(\n",
        "                \"sassy\", \"erm\", \"plain\",\n",
        "                look_at=based_on_wastlund\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.math_content = VGroup(formula, based_on_wastlund)\n",
        "\n",
        "    def where_we_fit_in(self):\n",
        "        right_rect = self.right_rect\n",
        "        left_rect = self.left_rect\n",
        "\n",
        "        points = [\n",
        "            right_rect.get_left() + SMALL_BUFF * RIGHT,\n",
        "            right_rect.get_corner(UL),\n",
        "            right_rect.get_corner(UR),\n",
        "            right_rect.get_right() + SMALL_BUFF * LEFT,\n",
        "            right_rect.get_corner(DR),\n",
        "            right_rect.get_bottom() + SMALL_BUFF * UP,\n",
        "            right_rect.get_corner(DL),\n",
        "        ]\n",
        "        added_points = [\n",
        "            left_rect.get_bottom(),\n",
        "            left_rect.get_corner(DL),\n",
        "            left_rect.get_corner(DL) + 1.25 * UP,\n",
        "            left_rect.get_bottom() + 1.25 * UP,\n",
        "        ]\n",
        "\n",
        "        blob1, blob2 = VMobject(), VMobject()\n",
        "        blob1.set_points_smoothly(points + [points[0]])\n",
        "        blob1.append_points(3 * len(added_points) * [points[0]])\n",
        "        blob2.set_points_smoothly(points + added_points + [points[0]])\n",
        "        for blob in blob1, blob2:\n",
        "            blob.set_stroke(width=0)\n",
        "            blob.set_fill(BLUE, opacity=0.5)\n",
        "\n",
        "        our_contribution = OldTexText(\"Our target \\\\\\\\ contribution\")\n",
        "        our_contribution.scale(0.75)\n",
        "        our_contribution.to_corner(UR)\n",
        "        arrow = Arrow(\n",
        "            our_contribution.get_bottom(),\n",
        "            right_rect.get_right() + MED_LARGE_BUFF * LEFT,\n",
        "            color=BLUE\n",
        "        )\n",
        "\n",
        "        wallis_product = get_wallis_product(n_terms=4)\n",
        "        wallis_product.set_width(\n",
        "            left_rect.get_width() - 2 * MED_LARGE_BUFF)\n",
        "        wallis_product.move_to(self.math_content, UP)\n",
        "        wallis_product_name = OldTexText(\"``Wallis product''\")\n",
        "        wallis_product_name.scale(0.75)\n",
        "        wallis_product_name.next_to(wallis_product, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        new_proof = OldTexText(\"New proof\")\n",
        "        new_proof.next_to(wallis_product_name, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(blob1),\n",
        "            Write(our_contribution),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(self.math_content))\n",
        "        self.play(\n",
        "            FadeIn(wallis_product),\n",
        "            Write(wallis_product_name, run_time=1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Transform(blob1, blob2, path_arc=-90 * DEGREES),\n",
        "            FadeIn(new_proof),\n",
        "            self.teacher.change, \"hooray\",\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\", look_at=new_proof)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class Six(Scene):\n",
        "    def construct(self):\n",
        "        six = OldTex(\"6\")\n",
        "        six.add_background_rectangle(opacity = 1)\n",
        "        six.background_rectangle.stretch(1.5, 0)\n",
        "        six.set_height(7)\n",
        "        self.add(six)\n",
        "\n",
        "\n",
        "\n",
        "class SridharWatchingScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": YELLOW_E,\n",
        "            \"flip_at_start\": False,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        laptop = Laptop()\n",
        "        laptop.scale(1.8)\n",
        "        laptop.to_corner(DR)\n",
        "        sridhar = self.pi_creature\n",
        "        sridhar.next_to(laptop, LEFT, SMALL_BUFF, DOWN)\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.flip()\n",
        "        bubble.pin_to(sridhar)\n",
        "\n",
        "        basel = OldTex(\n",
        "            \"{1\", \"\\\\over\", \"1^2}\", \"+\"\n",
        "            \"{1\", \"\\\\over\", \"2^2}\", \"+\"\n",
        "            \"{1\", \"\\\\over\", \"3^2}\", \"+\", \"\\\\cdots\",\n",
        "            \"= \\\\frac{\\\\pi^2}{6}\"\n",
        "        )\n",
        "        wallis = get_wallis_product(n_terms=4)\n",
        "        VGroup(basel, wallis).scale(0.7)\n",
        "        basel.move_to(bubble.get_bubble_center())\n",
        "        basel.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        wallis.next_to(basel, DOWN, buff=0.75)\n",
        "        arrow = OldTex(\"\\\\updownarrow\")\n",
        "        arrow.move_to(VGroup(basel, wallis))\n",
        "        basel.set_color(YELLOW)\n",
        "        wallis.set_color(BLUE)\n",
        "\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, laptop))\n",
        "        self.play(sridhar.change, \"pondering\", laptop.screen)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(bubble))\n",
        "        self.play(LaggedStartMap(FadeIn, basel))\n",
        "        self.play(\n",
        "            ReplacementTransform(basel.copy(), wallis),\n",
        "            GrowFromPoint(arrow, arrow.get_top())\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(sridhar.change, \"thinking\", wallis)\n",
        "        self.wait(4)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction,\n",
        "            VGroup(*list(laptop) + [bubble, basel, arrow, wallis, sridhar]),\n",
        "            lambda mob: (lambda m: m.set_color(BLACK).fade(1).scale(0.8), mob),\n",
        "            run_time=3,\n",
        "        ))\n",
        "\n",
        "\n",
        "class ShowProduct(Scene):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_wallis_product()\n",
        "        self.show_larger_terms()\n",
        "        self.show_smaller_terms()\n",
        "        self.interleave_terms()\n",
        "        self.show_answer()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.axes = self.get_axes(unit_size=0.75)\n",
        "        self.add(axes)\n",
        "\n",
        "    def setup_wallis_product(self):\n",
        "        full_wallis_product = get_wallis_product(n_terms=16, show_result=False)\n",
        "        wallis_product_parts = VGroup(*[\n",
        "            full_wallis_product[i:i + 4]\n",
        "            for i in range(0, len(full_wallis_product), 4)\n",
        "        ])\n",
        "\n",
        "        larger_parts = self.larger_parts = wallis_product_parts[::2]\n",
        "        larger_parts.set_color(YELLOW)\n",
        "        dots = OldTex(\"\\\\cdots\")\n",
        "        dots.move_to(larger_parts[-1][-1], LEFT)\n",
        "        larger_parts[-1][-1].submobjects = dots.submobjects\n",
        "\n",
        "        smaller_parts = self.smaller_parts = wallis_product_parts[1::2]\n",
        "        smaller_parts.set_color(BLUE)\n",
        "\n",
        "        for parts in larger_parts, smaller_parts:\n",
        "            parts.arrange(RIGHT, buff=2 * SMALL_BUFF)\n",
        "            # Move around the dots\n",
        "            for part1, part2 in zip(parts, parts[1:]):\n",
        "                dot = part1.submobjects.pop(-1)\n",
        "                part2.add_to_back(dot)\n",
        "\n",
        "        larger_parts.to_edge(UP)\n",
        "        smaller_parts.next_to(larger_parts, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.wallis_product_terms = get_wallis_product_numerical_terms(40)\n",
        "\n",
        "    def show_larger_terms(self):\n",
        "        axes = self.axes\n",
        "        parts = self.larger_parts\n",
        "        terms = self.wallis_product_terms[::2]\n",
        "        partial_products = np.cumprod(terms)\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(axes.coords_to_point(n + 1, prod))\n",
        "            for n, prod in enumerate(partial_products)\n",
        "        ])\n",
        "        dots.match_color(parts)\n",
        "        lines = VGroup(*[\n",
        "            Line(d1.get_center(), d2.get_center())\n",
        "            for d1, d2 in zip(dots, dots[1:])\n",
        "        ])\n",
        "\n",
        "        braces = VGroup(*[\n",
        "            Brace(parts[:n + 1], DOWN)\n",
        "            for n in range(len(parts))\n",
        "        ])\n",
        "\n",
        "        brace = braces[0].copy()\n",
        "        decimal = DecimalNumber(partial_products[0], num_decimal_places=4)\n",
        "        decimal.next_to(brace, DOWN)\n",
        "\n",
        "        self.add(brace, decimal, dots[0], parts[0])\n",
        "        tuples = list(zip(parts[1:], lines, dots[1:], partial_products[1:], braces[1:]))\n",
        "        for part, line, dot, prod, new_brace in tuples:\n",
        "            self.play(\n",
        "                FadeIn(part),\n",
        "                Transform(brace, new_brace),\n",
        "                ChangeDecimalToValue(\n",
        "                    decimal, prod,\n",
        "                    position_update_func=lambda m: m.next_to(brace, DOWN)\n",
        "                ),\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(dot, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        N = len(parts)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines[N - 1:], lag_ratio=0.2),\n",
        "            LaggedStartMap(FadeIn, dots[N:], lag_ratio=0.2),\n",
        "            brace.stretch, 1.2, 0, {\"about_edge\": LEFT},\n",
        "            ChangeDecimalToValue(\n",
        "                decimal, partial_products[-1],\n",
        "                position_update_func=lambda m: m.next_to(brace, DOWN)\n",
        "            ),\n",
        "            run_time=4,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            ChangeDecimalToValue(\n",
        "                decimal, partial_products[-1] + 2,\n",
        "                position_update_func=lambda m: m.next_to(brace, DOWN)\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                decimal, lambda d: d.shift(self.frame_duration * RIGHT)\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                decimal, lambda d, a: d.set_fill(opacity=1 - a)\n",
        "            ),\n",
        "        )\n",
        "        self.remove(decimal)\n",
        "\n",
        "        self.graph_to_remove = VGroup(dots, lines)\n",
        "\n",
        "    def show_smaller_terms(self):\n",
        "        larger_parts = self.larger_parts\n",
        "        larger_parts.save_state()\n",
        "        larger_parts_mover = larger_parts.copy()\n",
        "        larger_parts.fade(0.5)\n",
        "\n",
        "        smaller_parts = self.smaller_parts\n",
        "        for parts in larger_parts_mover, smaller_parts:\n",
        "            parts.denominators = VGroup(\n",
        "                parts[0][2],\n",
        "                *[part[3] for part in parts[1:]]\n",
        "            )\n",
        "        vect = op.sub(\n",
        "            smaller_parts.denominators[1].get_left(),\n",
        "            smaller_parts.denominators[0].get_left(),\n",
        "        )\n",
        "        smaller_parts.denominators.shift(vect)\n",
        "\n",
        "        self.play(\n",
        "            larger_parts_mover.move_to, smaller_parts, LEFT,\n",
        "            FadeOut(self.graph_to_remove)\n",
        "        )\n",
        "        self.play(\n",
        "            larger_parts_mover.denominators.shift, -vect,\n",
        "            smaller_parts.denominators.shift, -vect,\n",
        "            UpdateFromAlphaFunc(\n",
        "                larger_parts_mover,\n",
        "                lambda m, a: m.set_fill(opacity=1 - a),\n",
        "                remover=True\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                smaller_parts,\n",
        "                lambda m, a: m.set_fill(opacity=a)\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Rescale axes\n",
        "        new_axes = self.get_axes(unit_size=1.5)\n",
        "        self.play(ReplacementTransform(self.axes, new_axes))\n",
        "        axes = self.axes = new_axes\n",
        "\n",
        "        # Show graph\n",
        "        terms = self.wallis_product_terms[1::2]\n",
        "        partial_products = np.cumprod(terms)[:15]\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(axes.coords_to_point(n + 1, prod))\n",
        "            for n, prod in enumerate(partial_products)\n",
        "        ])\n",
        "        dots.match_color(smaller_parts)\n",
        "        lines = VGroup(*[\n",
        "            Line(d1.get_center(), d2.get_center())\n",
        "            for d1, d2 in zip(dots, dots[1:])\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lines),\n",
        "            LaggedStartMap(FadeIn, dots, lag_ratio=0.1),\n",
        "            run_time=3,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(VGroup(dots, lines)))\n",
        "\n",
        "    def interleave_terms(self):\n",
        "        larger_parts = self.larger_parts\n",
        "        smaller_parts = self.smaller_parts\n",
        "        index = 6\n",
        "        larger_parts.restore()\n",
        "        for parts in larger_parts, smaller_parts:\n",
        "            parts.prefix = parts[:index]\n",
        "            parts.suffix = parts[index:]\n",
        "            parts.prefix.generate_target()\n",
        "        larger_parts.fade(0.5)\n",
        "        full_product = VGroup(*it.chain(\n",
        "            *list(zip(larger_parts.prefix.target, smaller_parts.prefix.target))\n",
        "        ))\n",
        "        for i, tex, vect in (0, \"\\\\cdot\", LEFT), (-1, \"\\\\cdots\", RIGHT):\n",
        "            part = smaller_parts.prefix.target[i]\n",
        "            dot = OldTex(tex)\n",
        "            dot.match_color(part)\n",
        "            dot.next_to(part, vect, buff=2 * SMALL_BUFF)\n",
        "            part.add(dot)\n",
        "        full_product.arrange(RIGHT, buff=2 * SMALL_BUFF)\n",
        "        full_product.to_edge(UP)\n",
        "\n",
        "        for parts in larger_parts, smaller_parts:\n",
        "            self.play(\n",
        "                MoveToTarget(parts.prefix),\n",
        "                FadeOut(parts.suffix)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Dots and lines\n",
        "        # In poor form, this is modified copy-pasted from show_larger_terms\n",
        "        axes = self.axes\n",
        "        parts = full_product\n",
        "        terms = self.wallis_product_terms\n",
        "        partial_products = np.cumprod(terms)\n",
        "        partial_products_iter = iter(partial_products)\n",
        "        print(partial_products)\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(axes.coords_to_point(n + 1, prod))\n",
        "            for n, prod in enumerate(partial_products)\n",
        "        ])\n",
        "        dots.set_color(GREEN)\n",
        "        lines = VGroup(*[\n",
        "            Line(d1.get_center(), d2.get_center())\n",
        "            for d1, d2 in zip(dots, dots[1:])\n",
        "        ])\n",
        "\n",
        "        braces = VGroup(*[\n",
        "            Brace(parts[:n + 1], DOWN)\n",
        "            for n in range(len(parts))\n",
        "        ])\n",
        "\n",
        "        brace = braces[0].copy()\n",
        "        decimal = DecimalNumber(next(partial_products_iter), num_decimal_places=4)\n",
        "        decimal.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [brace, decimal, dots[0]])))\n",
        "        tuples = list(zip(lines, dots[1:], braces[1:]))\n",
        "        for line, dot, new_brace in tuples:\n",
        "            self.play(\n",
        "                Transform(brace, new_brace),\n",
        "                ChangeDecimalToValue(\n",
        "                    decimal, next(partial_products_iter),\n",
        "                    position_update_func=lambda m: m.next_to(brace, DOWN)\n",
        "                ),\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(dot, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "        def get_decimal_anim():\n",
        "            return ChangeDecimalToValue(\n",
        "                decimal, next(partial_products_iter),\n",
        "                run_time=1,\n",
        "                rate_func=squish_rate_func(smooth, 0, 0.5),\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(lines[len(parts) - 1:]),\n",
        "            FadeIn(dots[len(parts):]),\n",
        "            get_decimal_anim()\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.play(get_decimal_anim())\n",
        "\n",
        "        self.partial_product_decimal = decimal\n",
        "        self.get_decimal_anim = get_decimal_anim\n",
        "\n",
        "    def show_answer(self):\n",
        "        decimal = self.partial_product_decimal\n",
        "        axes = self.axes\n",
        "\n",
        "        pi_halves = OldTex(\"{\\\\pi\", \"\\\\over\", \"2}\")\n",
        "        pi_halves.scale(1.5)\n",
        "        pi_halves.move_to(decimal, UP)\n",
        "\n",
        "        randy = Randolph(height=1.7)\n",
        "        randy.next_to(decimal, DL)\n",
        "        randy.change(\"confused\")\n",
        "        randy.save_state()\n",
        "        randy.change(\"plain\")\n",
        "        randy.fade(1)\n",
        "\n",
        "        h_line = DashedLine(\n",
        "            axes.coords_to_point(0, np.pi / 2),\n",
        "            axes.coords_to_point(20, np.pi / 2),\n",
        "            color=RED\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            randy.restore,\n",
        "            self.get_decimal_anim()\n",
        "        )\n",
        "        self.play(Blink(randy), self.get_decimal_anim())\n",
        "        self.play(self.get_decimal_anim())\n",
        "        self.play(\n",
        "            self.get_decimal_anim(),\n",
        "            UpdateFromAlphaFunc(\n",
        "                decimal,\n",
        "                lambda m, a: m.set_fill(opacity=1 - a)\n",
        "            ),\n",
        "            ReplacementTransform(randy, pi_halves[0]),\n",
        "            Write(pi_halves[1:]),\n",
        "        )\n",
        "        self.remove(decimal)\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_axes(self, unit_size):\n",
        "        y_max = 7\n",
        "        axes = Axes(\n",
        "            x_min=-1,\n",
        "            x_max=12.5,\n",
        "            y_min=-0.5,\n",
        "            y_max=y_max + 0.25,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": unit_size,\n",
        "                \"big_tick_numbers\": list(range(1, y_max + 1)),\n",
        "                \"tick_size\": 0.05,\n",
        "            },\n",
        "        )\n",
        "        axes.shift(6 * LEFT + 3 * DOWN - axes.coords_to_point(0, 0))\n",
        "\n",
        "        axes.y_axis.label_direction = LEFT\n",
        "        axes.y_axis.add_numbers(*list(range(1, y_max + 1)))\n",
        "        return axes\n",
        "\n",
        "\n",
        "class TeacherShowing(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        screen = self.screen\n",
        "        screen.set_height(4)\n",
        "        screen.next_to(self.students, UP, MED_LARGE_BUFF, RIGHT)\n",
        "        self.play(\n",
        "            ShowCreation(screen),\n",
        "            self.teacher.change, \"raise_right_hand\", screen,\n",
        "            self.change_students(\n",
        "                *[\"pondering\"] * 3,\n",
        "                look_at=screen\n",
        "            )\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class DistanceProductScene(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"ambient_light_config\": HIGHT_QUALITY_AMBIENT_LIGHT_CONFIG,\n",
        "        \"circle_color\": BLUE,\n",
        "        \"circle_radius\": 3,\n",
        "        \"num_lighthouses\": 6,\n",
        "        \"lighthouse_height\": 0.5,\n",
        "        \"ignored_lighthouse_indices\": [],\n",
        "        \"observer_config\": {\n",
        "            \"color\": MAROON_B,\n",
        "            \"mode\": \"pondering\",\n",
        "            \"height\": 0.25,\n",
        "            \"flip_at_start\": True,\n",
        "        },\n",
        "        \"observer_fraction\": 1.0 / 3,\n",
        "        \"d_label_height\": 0.35,\n",
        "        \"numeric_distance_label_height\": 0.25,\n",
        "        \"default_product_column_top\": FRAME_WIDTH * RIGHT / 4 + 1.5 * UP,\n",
        "        \"include_lighthouses\": True,\n",
        "        \"include_distance_labels_background_rectangle\": True,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super(DistanceProductScene, self).setup()\n",
        "        self.circle = Circle(\n",
        "            color=self.circle_color,\n",
        "            radius=self.circle_radius,\n",
        "        )\n",
        "\n",
        "    def get_circle_point_at_proportion(self, alpha):\n",
        "        radius = self.get_radius()\n",
        "        center = self.circle.get_center()\n",
        "        angle = alpha * TAU\n",
        "        unit_circle_point = np.cos(angle) * RIGHT + np.sin(angle) * UP\n",
        "        return radius * unit_circle_point + center\n",
        "\n",
        "    def get_lh_points(self):\n",
        "        return np.array([\n",
        "            self.get_circle_point_at_proportion(fdiv(i, self.num_lighthouses))\n",
        "            for i in range(self.num_lighthouses)\n",
        "            if i not in self.ignored_lighthouse_indices\n",
        "        ])\n",
        "\n",
        "    def get_observer_point(self, fraction=None):\n",
        "        if fraction is None:\n",
        "            fraction = self.observer_fraction\n",
        "        return self.get_circle_point_at_proportion(fraction / self.num_lighthouses)\n",
        "\n",
        "    def get_observer(self):\n",
        "        observer = self.observer = PiCreature(**self.observer_config)\n",
        "        observer.next_to(self.get_observer_point(), RIGHT, buff=SMALL_BUFF)\n",
        "        return observer\n",
        "\n",
        "    def get_observer_dot(self):\n",
        "        self.observer_dot = Dot(\n",
        "            self.get_observer_point(),\n",
        "            color=self.observer_config[\"color\"]\n",
        "        )\n",
        "        return self.observer_dot\n",
        "\n",
        "    def get_lighthouses(self):\n",
        "        self.lighthouses = VGroup()\n",
        "        for point in self.get_lh_points():\n",
        "            lighthouse = Lighthouse()\n",
        "            lighthouse.set_height(self.lighthouse_height)\n",
        "            lighthouse.move_to(point)\n",
        "            self.lighthouses.add(lighthouse)\n",
        "        return self.lighthouses\n",
        "\n",
        "    def get_lights(self):\n",
        "        self.lights = VGroup()\n",
        "        for point in self.get_lh_points():\n",
        "            light = AmbientLight(\n",
        "                source_point=VectorizedPoint(point),\n",
        "                **self.ambient_light_config\n",
        "            )\n",
        "            self.lights.add(light)\n",
        "        return self.lights\n",
        "\n",
        "    def get_distance_lines(self, start_point=None, line_class=Line):\n",
        "        if start_point is None:\n",
        "            start_point = self.get_observer_point()\n",
        "        lines = VGroup(*[\n",
        "            line_class(start_point, point)\n",
        "            for point in self.get_lh_points()\n",
        "        ])\n",
        "        lines.set_stroke(width=2)\n",
        "        self.distance_lines = lines\n",
        "        return self.distance_lines\n",
        "\n",
        "    def get_symbolic_distance_labels(self):\n",
        "        if not hasattr(self, \"distance_lines\"):\n",
        "            self.get_distance_lines()\n",
        "        self.d_labels = VGroup()\n",
        "        for i, line in enumerate(self.distance_lines):\n",
        "            d_label = OldTex(\"d_%d\" % i)\n",
        "            d_label.set_height(self.d_label_height)\n",
        "            vect = rotate_vector(line.get_vector(), 90 * DEGREES)\n",
        "            vect *= 2.5 * SMALL_BUFF / get_norm(vect)\n",
        "            d_label.move_to(line.get_center() + vect)\n",
        "            self.d_labels.add(d_label)\n",
        "        return self.d_labels\n",
        "\n",
        "    def get_numeric_distance_labels(self, lines=None, num_decimal_places=3, show_ellipsis=True):\n",
        "        radius = self.circle.get_width() / 2\n",
        "        if lines is None:\n",
        "            if not hasattr(self, \"distance_lines\"):\n",
        "                self.get_distance_lines()\n",
        "            lines = self.distance_lines\n",
        "        labels = self.numeric_distance_labels = VGroup()\n",
        "        for line in lines:\n",
        "            label = DecimalNumber(\n",
        "                line.get_length() / radius,\n",
        "                num_decimal_places=num_decimal_places,\n",
        "                show_ellipsis=show_ellipsis,\n",
        "                include_background_rectangle=self.include_distance_labels_background_rectangle,\n",
        "            )\n",
        "            label.set_height(self.numeric_distance_label_height)\n",
        "            max_width = 0.5 * max(line.get_length(), 0.1)\n",
        "            if label.get_width() > max_width:\n",
        "                label.set_width(max_width)\n",
        "            angle = (line.get_angle() % TAU) - TAU / 2\n",
        "            if np.abs(angle) > TAU / 4:\n",
        "                angle += np.sign(angle) * np.pi\n",
        "            label.angle = angle\n",
        "            label.next_to(line.get_center(), UP, SMALL_BUFF)\n",
        "            label.rotate(angle, about_point=line.get_center())\n",
        "            labels.add(label)\n",
        "        return labels\n",
        "\n",
        "    def get_distance_product_column(self, column_top=None, labels=None, fraction=None):\n",
        "        if column_top is None:\n",
        "            column_top = self.default_product_column_top\n",
        "        if labels is None:\n",
        "            if not hasattr(self, \"numeric_distance_labels\"):\n",
        "                self.get_numeric_distance_labels()\n",
        "            labels = self.numeric_distance_labels\n",
        "        stacked_labels = labels.copy()\n",
        "        for label in stacked_labels:\n",
        "            label.rotate(-label.angle)\n",
        "            label.set_height(self.numeric_distance_label_height)\n",
        "        stacked_labels.arrange(DOWN)\n",
        "        stacked_labels.move_to(column_top, UP)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(1.5 * stacked_labels.get_width())\n",
        "        h_line.next_to(stacked_labels, DOWN, aligned_edge=RIGHT)\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        times.next_to(h_line, UP, SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        product_decimal = DecimalNumber(\n",
        "            self.get_distance_product(fraction),\n",
        "            num_decimal_places=3,\n",
        "            show_ellipsis=True,\n",
        "            include_background_rectangle=self.include_distance_labels_background_rectangle,\n",
        "        )\n",
        "        product_decimal.set_height(self.numeric_distance_label_height)\n",
        "        product_decimal.next_to(h_line, DOWN)\n",
        "        product_decimal.align_to(stacked_labels, RIGHT)\n",
        "        product_decimal[1].set_color(BLUE)\n",
        "        self.distance_product_column = VGroup(\n",
        "            stacked_labels, h_line, times, product_decimal\n",
        "        )\n",
        "        return self.distance_product_column\n",
        "\n",
        "    def get_fractional_arc(self, fraction, start_fraction=0):\n",
        "        arc = Arc(\n",
        "            angle=fraction * TAU,\n",
        "            start_angle=start_fraction * TAU,\n",
        "            radius=self.get_radius(),\n",
        "        )\n",
        "        arc.shift(self.circle.get_center())\n",
        "        return arc\n",
        "\n",
        "    def get_halfway_indication_arcs(self):\n",
        "        fraction = 0.5 / self.num_lighthouses\n",
        "        arcs = VGroup(\n",
        "            self.get_fractional_arc(fraction),\n",
        "            self.get_fractional_arc(-fraction, start_fraction=2 * fraction),\n",
        "        )\n",
        "        arcs.set_stroke(YELLOW, 4)\n",
        "        return arcs\n",
        "\n",
        "    def get_circle_group(self):\n",
        "        group = VGroup(self.circle)\n",
        "        if not hasattr(self, \"observer_dot\"):\n",
        "            self.get_observer_dot()\n",
        "        if not hasattr(self, \"observer\"):\n",
        "            self.get_observer()\n",
        "        if not hasattr(self, \"lighthouses\"):\n",
        "            self.get_lighthouses()\n",
        "        if not hasattr(self, \"lights\"):\n",
        "            self.get_lights()\n",
        "        group.add(self.observer_dot, self.observer)\n",
        "        if self.include_lighthouses:\n",
        "            group.add(self.lighthouses)\n",
        "        group.add(self.lights)\n",
        "        return group\n",
        "\n",
        "    def setup_lighthouses_and_observer(self):\n",
        "        self.add(*self.get_circle_group())\n",
        "\n",
        "    # Numerical results\n",
        "\n",
        "    def get_radius(self):\n",
        "        return self.circle.get_width() / 2.0\n",
        "\n",
        "    def get_distance_product(self, fraction=None):\n",
        "        radius = self.get_radius()\n",
        "        observer_point = self.get_observer_point(fraction)\n",
        "        distances = [\n",
        "            get_norm(point - observer_point) / radius\n",
        "            for point in self.get_lh_points()\n",
        "        ]\n",
        "        return reduce(op.mul, distances, 1.0)\n",
        "\n",
        "    # Animating methods\n",
        "\n",
        "    def add_numeric_distance_labels(self, show_line_creation=True):\n",
        "        anims = []\n",
        "        if not hasattr(self, \"distance_lines\"):\n",
        "            self.get_distance_lines()\n",
        "        if not hasattr(self, \"numeric_distance_labels\"):\n",
        "            self.get_numeric_distance_labels()\n",
        "        if show_line_creation:\n",
        "            anims.append(LaggedStartMap(ShowCreation, self.distance_lines))\n",
        "        anims.append(LaggedStartMap(FadeIn, self.numeric_distance_labels))\n",
        "\n",
        "        self.play(*anims)\n",
        "\n",
        "    def show_distance_product_in_column(self, **kwargs):\n",
        "        group = self.get_distance_product_column(**kwargs)\n",
        "        stacked_labels, h_line, times, product_decimal = group\n",
        "        labels = self.numeric_distance_labels\n",
        "\n",
        "        self.play(ReplacementTransform(labels.copy(), stacked_labels))\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            Write(times)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                stacked_labels.copy(),\n",
        "                VGroup(product_decimal)\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "class IntroduceDistanceProduct(DistanceProductScene):\n",
        "    CONFIG = {\n",
        "        \"ambient_light_config\": {\"color\": YELLOW},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.draw_circle_with_points()\n",
        "        self.turn_into_lighthouses_and_observer()\n",
        "        self.show_sum_of_inverse_squares()\n",
        "        self.transition_to_lemma_1()\n",
        "\n",
        "    def draw_circle_with_points(self):\n",
        "        circle = self.circle\n",
        "\n",
        "        lh_dots = self.lh_dots = VGroup(*[\n",
        "            Dot(point) for point in self.get_lh_points()\n",
        "        ])\n",
        "        lh_dot_arrows = VGroup(*[\n",
        "            Arrow(*[\n",
        "                interpolate(circle.get_center(), dot.get_center(), a)\n",
        "                for a in (0.6, 0.9)\n",
        "            ], buff=0)\n",
        "            for dot in lh_dots\n",
        "        ])\n",
        "        evenly_space_dots_label = OldTexText(\"Evenly-spaced \\\\\\\\ dots\")\n",
        "        evenly_space_dots_label.set_width(0.5 * circle.get_width())\n",
        "        evenly_space_dots_label.move_to(circle)\n",
        "\n",
        "        special_dot = self.special_dot = self.get_observer_dot()\n",
        "        special_dot_arrow = Vector(DL)\n",
        "        special_dot_arrow.next_to(special_dot, UR, SMALL_BUFF)\n",
        "        special_dot_arrow.match_color(special_dot)\n",
        "        special_dot_label = OldTexText(\"Special dot\")\n",
        "        special_dot_label.next_to(\n",
        "            special_dot_arrow.get_start(), UP, SMALL_BUFF)\n",
        "        special_dot_label.match_color(special_dot)\n",
        "        special_dot.save_state()\n",
        "        special_dot.next_to(special_dot_arrow, UR)\n",
        "        special_dot.set_fill(opacity=0)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lh_dots),\n",
        "            LaggedStartMap(GrowArrow, lh_dot_arrows),\n",
        "            Write(evenly_space_dots_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            special_dot.restore,\n",
        "            GrowArrow(special_dot_arrow),\n",
        "            Write(special_dot_label, run_time=1),\n",
        "            FadeOut(VGroup(lh_dot_arrows, evenly_space_dots_label))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(special_dot_arrow, special_dot_label)))\n",
        "\n",
        "    def turn_into_lighthouses_and_observer(self):\n",
        "        lighthouses = self.get_lighthouses()\n",
        "        lights = self.get_lights()\n",
        "\n",
        "        observer = self.get_observer()\n",
        "        observer.save_state()\n",
        "        observer.set_height(2)\n",
        "        observer.change_mode(\"happy\")\n",
        "        observer.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, self.lh_dots),\n",
        "            LaggedStartMap(FadeIn, lighthouses),\n",
        "            LaggedStartMap(SwitchOn, lights),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(observer))\n",
        "        self.play(observer.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def show_sum_of_inverse_squares(self):\n",
        "        lines = self.get_distance_lines()\n",
        "        labels = self.get_symbolic_distance_labels()\n",
        "\n",
        "        sum_of_inverse_squares = OldTex(*it.chain(*[\n",
        "            [\"{1\", \"\\\\over\", \"(\", \"d_%d\" % i, \")\", \"^2}\", \"+\"]\n",
        "            for i in range(len(lines))\n",
        "        ]))\n",
        "        sum_of_inverse_squares.submobjects.pop(-1)\n",
        "        sum_of_inverse_squares.to_edge(UP)\n",
        "        d_terms = sum_of_inverse_squares.get_parts_by_tex(\"d_\")\n",
        "        d_terms.set_color(YELLOW)\n",
        "        plusses = sum_of_inverse_squares.get_parts_by_tex(\"+\")\n",
        "        last_term = sum_of_inverse_squares[-6:]\n",
        "        non_d_terms = VGroup(*[m for m in sum_of_inverse_squares if m not in d_terms and m not in last_term])\n",
        "\n",
        "        brace = Brace(sum_of_inverse_squares, DOWN)\n",
        "        brace_text = brace.get_text(\"Total intensity of light\")\n",
        "\n",
        "        arrow = Vector(DOWN, color=WHITE).next_to(brace, DOWN)\n",
        "        basel_sum = OldTex(\n",
        "            \"{1 \\\\over 1^2} + \",\n",
        "            \"{1 \\\\over 2^2} + \",\n",
        "            \"{1 \\\\over 3^2} + \",\n",
        "            \"{1 \\\\over 4^2} + \",\n",
        "            \"\\\\cdots\",\n",
        "        )\n",
        "        basel_sum.next_to(arrow, DOWN)\n",
        "        basel_cross = Cross(basel_sum)\n",
        "        useful_for = OldTexText(\"Useful for\")\n",
        "        useful_for.next_to(arrow, RIGHT)\n",
        "\n",
        "        wallis_product = OldTex(\n",
        "            \"{2 \\\\over 1} \\\\cdot\", \"{2 \\\\over 3} \\\\cdot\",\n",
        "            \"{4 \\\\over 3} \\\\cdot\", \"{4 \\\\over 5} \\\\cdot\",\n",
        "            \"{6 \\\\over 5} \\\\cdot\", \"{6 \\\\over 7} \\\\cdot\",\n",
        "            \"\\\\cdots\"\n",
        "        )\n",
        "        wallis_product.move_to(basel_sum)\n",
        "\n",
        "        light_rings = VGroup(*it.chain(*self.lights))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(Write, labels),\n",
        "        )\n",
        "        circle_group = VGroup(*self.get_top_level_mobjects())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(labels[-1].copy(), last_term[3]),\n",
        "            Write(VGroup(*it.chain(last_term[:3], last_term[4:])))\n",
        "        )\n",
        "        self.remove(last_term)\n",
        "        self.add(last_term)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(non_d_terms),\n",
        "            ReplacementTransform(\n",
        "                labels[:-1].copy(),\n",
        "                d_terms[:-1],\n",
        "            ),\n",
        "            circle_group.scale, 0.8, {\"about_point\": FRAME_Y_RADIUS * DOWN}\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, light_rings,\n",
        "            lambda m: (m.set_fill, {\"opacity\": 2 * m.get_fill_opacity()}),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Mention useful just to basel problem\n",
        "        circle_group.save_state()\n",
        "        v_point = VectorizedPoint(\n",
        "            FRAME_X_RADIUS * LEFT + FRAME_Y_RADIUS * DOWN)\n",
        "        self.play(\n",
        "            circle_group.next_to, v_point, UR, {\n",
        "                \"submobject_to_align\": self.circle},\n",
        "            circle_group.scale, 0.5, {\"about_point\": v_point.get_center()},\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(brace_text),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(useful_for),\n",
        "            FadeIn(basel_sum),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(basel_cross),\n",
        "            FadeOut(VGroup(arrow, useful_for, brace))\n",
        "        )\n",
        "        basel_group = VGroup(basel_sum, basel_cross)\n",
        "        self.play(\n",
        "            basel_group.scale, 0.5,\n",
        "            basel_group.to_corner, DR,\n",
        "        )\n",
        "        self.play(Write(wallis_product))\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to distance product\n",
        "        self.play(\n",
        "            circle_group.restore,\n",
        "            wallis_product.match_width, basel_sum,\n",
        "            wallis_product.next_to, basel_sum, UP, {\"aligned_edge\": RIGHT},\n",
        "        )\n",
        "        self.play(\n",
        "            d_terms.shift, 0.75 * d_terms.get_height() * UP,\n",
        "            d_terms.set_color, PRODUCT_COLOR,\n",
        "            light_rings.set_fill, PRODUCT_COLOR,\n",
        "            *[\n",
        "                FadeOut(mob)\n",
        "                for mob in sum_of_inverse_squares\n",
        "                if mob not in d_terms and mob not in plusses\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(plusses),\n",
        "            d_terms.arrange, RIGHT, 0.25 * SMALL_BUFF,\n",
        "            d_terms.move_to, sum_of_inverse_squares, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label distance product\n",
        "        brace = Brace(d_terms, UP, buff=SMALL_BUFF)\n",
        "        distance_product_label = brace.get_text(\"``Distance product''\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(distance_product_label)\n",
        "        )\n",
        "        line_copies = lines.copy().set_color(RED)\n",
        "        self.play(LaggedStartMap(ShowCreationThenDestruction, line_copies))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, light_rings,\n",
        "            lambda mob: (\n",
        "                lambda m: m.shift(\n",
        "                    MED_SMALL_BUFF * UP).set_fill(opacity=2 * m.get_fill_opacity()),\n",
        "                mob\n",
        "            ),\n",
        "            rate_func=wiggle,\n",
        "            run_time=6,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def transition_to_lemma_1(self):\n",
        "        self.lighthouse_height = Lemma1.CONFIG[\"lighthouse_height\"]\n",
        "        self.circle_radius = Lemma1.CONFIG[\"circle_radius\"]\n",
        "        self.observer_fraction = Lemma1.CONFIG[\"observer_fraction\"]\n",
        "\n",
        "        self.ambient_light_config[\"color\"] = BLUE\n",
        "\n",
        "        circle = self.circle\n",
        "        lighthouses = self.lighthouses\n",
        "        lights = self.lights\n",
        "\n",
        "        circle.generate_target()\n",
        "        circle.target.set_width(2 * self.circle_radius)\n",
        "        circle.target.to_corner(DL)\n",
        "        self.circle = circle.target\n",
        "\n",
        "        new_lighthouses = self.get_lighthouses()\n",
        "        new_lights = self.get_lights()\n",
        "\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            MoveToTarget(circle),\n",
        "            Transform(lighthouses, new_lighthouses),\n",
        "            Transform(lights, new_lights),\n",
        "            ApplyMethod(\n",
        "                self.observer_dot.move_to,\n",
        "                self.get_circle_point_at_proportion(\n",
        "                    self.observer_fraction / self.num_lighthouses\n",
        "                )\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(self.observer, self.observer_dot),\n",
        "        )\n",
        "\n",
        "\n",
        "class Lemma1(DistanceProductScene):\n",
        "    CONFIG = {\n",
        "        \"circle_radius\": 2.5,\n",
        "        \"observer_fraction\": 0.5,\n",
        "        \"lighthouse_height\": 0.25,\n",
        "        \"lemma_text\": \"distance product = 2\",\n",
        "        \"include_distance_labels_background_rectangle\": False,\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_circle_group()\n",
        "        self.state_lemma_premise()\n",
        "        self.show_product()\n",
        "        self.wiggle_observer()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"Two lemmas:\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.add(title)\n",
        "\n",
        "    def add_circle_group(self):\n",
        "        self.circle.to_corner(DL)\n",
        "        circle_group = self.get_circle_group()\n",
        "        self.play(LaggedStartMap(FadeIn, VGroup(\n",
        "            *circle_group.family_members_with_points())))\n",
        "\n",
        "    def state_lemma_premise(self):\n",
        "        premise = OldTexText(\n",
        "            \"Lemma 1: If observer is halfway between lighthouses,\")\n",
        "        self.premise = premise\n",
        "        premise.next_to(self.title, DOWN)\n",
        "\n",
        "        frac = 1.0 / self.num_lighthouses\n",
        "        arc1, arc2 = arcs = VGroup(VMobject(), VMobject())\n",
        "        arc1.pointwise_become_partial(self.circle, 0, frac / 2)\n",
        "        arc2.pointwise_become_partial(self.circle, frac / 2, frac)\n",
        "        arc1.reverse_points()\n",
        "        arcs.set_stroke(YELLOW, 5)\n",
        "        show_arcs = ShowCreationThenDestruction(\n",
        "            arcs,\n",
        "            lag_ratio=0,\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        self.play(Write(premise), show_arcs, run_time=2)\n",
        "        self.wait()\n",
        "        self.play(show_arcs)\n",
        "        self.wait()\n",
        "\n",
        "    def show_product(self):\n",
        "        lemma = OldTexText(self.lemma_text)\n",
        "        lemma.set_color(BLUE)\n",
        "        lemma.next_to(self.premise, DOWN)\n",
        "        self.add_numeric_distance_labels()\n",
        "        self.play(Write(lemma, run_time=1))\n",
        "        self.show_distance_product_in_column()\n",
        "        self.wait()\n",
        "\n",
        "    def wiggle_observer(self):\n",
        "        # Overwriting existing method\n",
        "        self.get_observer_point = lambda dummy=None: self.observer_dot.get_center()\n",
        "\n",
        "        center = self.circle.get_center()\n",
        "        observer_angle = angle_of_vector(self.get_observer_point() - center)\n",
        "        observer_angle_tracker = ValueTracker(observer_angle)\n",
        "\n",
        "        def update_dot(dot):\n",
        "            dot.move_to(self.get_circle_point_at_proportion(\n",
        "                observer_angle_tracker.get_value() / TAU\n",
        "            ))\n",
        "\n",
        "        def update_distance_lines(lines):\n",
        "            new_lines = self.get_distance_lines(start_point=self.get_observer_point())\n",
        "            lines.submobjects = new_lines.submobjects\n",
        "\n",
        "        def update_numeric_distance_labels(labels):\n",
        "            new_labels = self.get_numeric_distance_labels(self.distance_lines)\n",
        "            labels.submobjects = new_labels.submobjects\n",
        "\n",
        "        def update_distance_product_column(column):\n",
        "            new_column = self.get_distance_product_column()\n",
        "            column.submobjects = new_column.submobjects\n",
        "\n",
        "        self.remove(*VGroup(\n",
        "            self.observer, self.observer_dot,\n",
        "            self.distance_lines,\n",
        "            self.numeric_distance_labels,\n",
        "            self.distance_product_column,\n",
        "        ).get_family())\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                observer_angle_tracker.set_value, observer_angle + 0.05 * TAU,\n",
        "                rate_func=wiggle\n",
        "            ),\n",
        "            UpdateFromFunc(self.observer_dot, update_dot),\n",
        "            MaintainPositionRelativeTo(self.observer, self.observer_dot),\n",
        "            UpdateFromFunc(self.distance_lines, update_distance_lines),\n",
        "            UpdateFromFunc(self.numeric_distance_labels, update_numeric_distance_labels),\n",
        "            UpdateFromFunc(self.distance_product_column, update_distance_product_column),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.distance_product_column[-1].set_color(BLUE).scale(1.05)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Lemma1With7Lighthouses(Lemma1):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 7,\n",
        "    }\n",
        "\n",
        "\n",
        "class Lemma1With8Lighthouses(Lemma1):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 8,\n",
        "    }\n",
        "\n",
        "\n",
        "class Lemma1With9Lighthouses(Lemma1):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 9,\n",
        "    }\n",
        "\n",
        "\n",
        "class Lemma2(Lemma1):\n",
        "    CONFIG = {\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        \"lemma_text\": \"distance product = \\\\# Initial lighthouses\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_circle_group()\n",
        "        self.state_lemma_premise()\n",
        "        self.replace_first_lighthouse()\n",
        "        self.show_product()\n",
        "        self.wiggle_observer()\n",
        "\n",
        "    def state_lemma_premise(self):\n",
        "        premise = self.premise = OldTexText(\n",
        "            \"Lemma 2: If the observer replaces a lighthouse,\"\n",
        "        )\n",
        "        premise.next_to(self.title, DOWN)\n",
        "\n",
        "        self.play(Write(premise, run_time=1))\n",
        "\n",
        "    def replace_first_lighthouse(self):\n",
        "        dot = self.observer_dot\n",
        "        observer_anim = MaintainPositionRelativeTo(self.observer, dot)\n",
        "        lighthouse_group = VGroup(self.lighthouses[0], self.lights[0])\n",
        "        point = self.get_lh_points()[0]\n",
        "\n",
        "        self.play(\n",
        "            lighthouse_group.shift, 5 * RIGHT,\n",
        "            lighthouse_group.fade, 1,\n",
        "            run_time=1.5,\n",
        "            rate_func=running_start,\n",
        "            remover=True,\n",
        "        )\n",
        "        self.play(\n",
        "            dot.move_to, point,\n",
        "            observer_anim,\n",
        "            path_arc=(-120 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ignored_lighthouse_indices = [0]\n",
        "        self.observer_fraction = 0\n",
        "        for group in self.lighthouses, self.lights:\n",
        "            self.lighthouses.submobjects.pop(0)\n",
        "\n",
        "\n",
        "class Lemma2With7Lighthouses(Lemma2):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 7,\n",
        "    }\n",
        "\n",
        "\n",
        "class Lemma2With8Lighthouses(Lemma2):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 8,\n",
        "    }\n",
        "\n",
        "\n",
        "class Lemma2With9Lighthouses(Lemma2):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 9,\n",
        "    }\n",
        "\n",
        "\n",
        "class ConfusedPiCreature(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph(color=GREY_BROWN)\n",
        "        self.add(randy)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FromGeometryToAlgebra(DistanceProductScene):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 7,\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_lights()\n",
        "        self.point_out_evenly_spaced()\n",
        "        self.transition_to_complex_plane()\n",
        "        self.discuss_powers()\n",
        "        self.raise_everything_to_the_nth()\n",
        "\n",
        "    def setup_lights(self):\n",
        "        circle = self.circle\n",
        "        circle.set_height(5, about_edge=DOWN)\n",
        "        lights = self.get_lights()\n",
        "        dots = VGroup(*[Dot(point) for point in self.get_lh_points()])\n",
        "        for dot, light in zip(dots, lights):\n",
        "            light.add_to_back(dot)\n",
        "\n",
        "        self.add(circle, lights)\n",
        "\n",
        "    def point_out_evenly_spaced(self):\n",
        "        circle = self.circle\n",
        "        step = 1.0 / self.num_lighthouses / 2\n",
        "        alpha_range = np.arange(0, 1 + step, step)\n",
        "        arcs = VGroup(*[\n",
        "            VMobject().pointwise_become_partial(circle, a1, a2)\n",
        "            for a1, a2 in zip(alpha_range, alpha_range[1:])\n",
        "        ])\n",
        "        arcs.set_stroke(YELLOW, 5)\n",
        "\n",
        "        for arc in arcs[::2]:\n",
        "            arc.reverse_points()\n",
        "\n",
        "        arcs_anim = ShowCreationThenDestruction(\n",
        "            arcs, lag_ratio=0, run_time=2\n",
        "        )\n",
        "\n",
        "        spacing_words = self.spacing_words = OldTexText(\"Evenly-spaced\")\n",
        "        spacing_words.set_width(self.get_radius())\n",
        "        spacing_words.move_to(circle)\n",
        "\n",
        "        arrows = self.get_arrows()\n",
        "\n",
        "        geometric_words = self.geometric_words = OldTexText(\n",
        "            \"Geometric property\")\n",
        "        geometric_words.to_edge(UP)\n",
        "        geometric_words.add_background_rectangle()\n",
        "\n",
        "        self.add(geometric_words)\n",
        "        self.play(\n",
        "            FadeIn(spacing_words),\n",
        "            arcs_anim,\n",
        "            *list(map(GrowArrow, arrows))\n",
        "        )\n",
        "        self.play(FadeOut(arrows), arcs_anim)\n",
        "        self.wait()\n",
        "\n",
        "    def transition_to_complex_plane(self):\n",
        "        plane = self.complex_plane = ComplexPlane(\n",
        "            unit_size=2, y_radius=6, x_radius=9,\n",
        "        )\n",
        "        plane.shift(1.5 * RIGHT)\n",
        "        plane.add_coordinates()\n",
        "        origin = plane.number_to_point(0)\n",
        "        h_line = Line(plane.number_to_point(-1), plane.number_to_point(1))\n",
        "\n",
        "        circle = self.circle\n",
        "        circle_group = VGroup(circle, self.lights)\n",
        "        circle_group.generate_target()\n",
        "        circle_group.target.scale(h_line.get_width() / circle.get_width())\n",
        "        circle_group.target.shift(\n",
        "            origin - circle_group.target[0].get_center()\n",
        "        )\n",
        "        circle_group.target[0].set_stroke(RED)\n",
        "\n",
        "        geometric_words = self.geometric_words\n",
        "        geometric_words.generate_target()\n",
        "        arrow = OldTex(\"\\\\rightarrow\")\n",
        "        arrow.add_background_rectangle()\n",
        "        algebraic_words = OldTexText(\"Algebraic property\")\n",
        "        algebraic_words.add_background_rectangle()\n",
        "        word_group = VGroup(geometric_words.target, arrow, algebraic_words)\n",
        "        word_group.arrange(RIGHT)\n",
        "        word_group.move_to(origin)\n",
        "        word_group.to_edge(UP)\n",
        "\n",
        "        unit_circle_words = OldTexText(\"Unit circle\", \"\")\n",
        "        unit_circle_words.match_color(circle_group.target[0])\n",
        "        for part in unit_circle_words:\n",
        "            part.add_background_rectangle()\n",
        "        unit_circle_words.next_to(origin, UP)\n",
        "\n",
        "        complex_plane_words = OldTexText(\"Complex Plane\")\n",
        "        self.complex_plane_words = complex_plane_words\n",
        "        complex_plane_words.move_to(word_group)\n",
        "        complex_plane_words.add_background_rectangle()\n",
        "\n",
        "        roots_of_unity_words = OldTexText(\"Roots of\\\\\\\\\", \"unity\")\n",
        "        roots_of_unity_words.move_to(origin)\n",
        "        roots_of_unity_words.set_color(YELLOW)\n",
        "        for part in roots_of_unity_words:\n",
        "            part.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            Write(plane),\n",
        "            MoveToTarget(circle_group),\n",
        "            FadeOut(self.spacing_words),\n",
        "            MoveToTarget(geometric_words),\n",
        "            FadeIn(arrow),\n",
        "            FadeIn(algebraic_words),\n",
        "        )\n",
        "        word_group.submobjects[0] = geometric_words\n",
        "        self.play(Write(unit_circle_words, run_time=1))\n",
        "\n",
        "        # Show complex values\n",
        "        outer_arrows = self.outer_arrows = self.get_arrows()\n",
        "        for arrow, point in zip(outer_arrows, self.get_lh_points()):\n",
        "            arrow.rotate(np.pi, about_point=point)\n",
        "        outer_arrow = self.outer_arrow = outer_arrows[3].copy()\n",
        "\n",
        "        values = list(map(plane.point_to_number, self.get_lh_points()))\n",
        "        complex_decimal = self.complex_decimal = DecimalNumber(\n",
        "            values[3],\n",
        "            num_decimal_places=3,\n",
        "            include_background_rectangle=True\n",
        "        )\n",
        "        complex_decimal.next_to(outer_arrow.get_start(), LEFT, SMALL_BUFF)\n",
        "        complex_decimal_rect = SurroundingRectangle(complex_decimal)\n",
        "        complex_decimal_rect.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(complex_plane_words),\n",
        "            FadeOut(word_group),\n",
        "            FadeIn(complex_decimal),\n",
        "            FadeIn(outer_arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(\n",
        "                complex_decimal, values[1],\n",
        "                tracked_mobject=complex_decimal_rect\n",
        "            ),\n",
        "            complex_decimal_rect.next_to, outer_arrows[1].get_start(\n",
        "            ), UP, SMALL_BUFF,\n",
        "            Transform(outer_arrow, outer_arrows[1]),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrows = self.get_arrows()\n",
        "        arrows.set_color(YELLOW)\n",
        "        self.play(\n",
        "            ReplacementTransform(unit_circle_words, roots_of_unity_words),\n",
        "            LaggedStartMap(GrowArrow, arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            complex_plane_words.move_to, word_group,\n",
        "            LaggedStartMap(FadeOut, VGroup(*it.chain(\n",
        "                arrows, roots_of_unity_words\n",
        "            )))\n",
        "        )\n",
        "\n",
        "        # Turn decimal into z\n",
        "        x_term = self.x_term = OldTex(\"x\")\n",
        "        x_term.add_background_rectangle()\n",
        "        x_term.move_to(complex_decimal, DOWN)\n",
        "        x_term.shift(0.5 * SMALL_BUFF * (DR))\n",
        "        self.play(ReplacementTransform(complex_decimal, x_term))\n",
        "\n",
        "    def discuss_powers(self):\n",
        "        x_term = self.x_term\n",
        "        outer_arrows = self.outer_arrows\n",
        "        outer_arrows.add(outer_arrows[0].copy())\n",
        "        plane = self.complex_plane\n",
        "        origin = plane.number_to_point(0)\n",
        "\n",
        "        question = OldTexText(\"What is $x^2$\")\n",
        "        question.next_to(x_term, RIGHT, LARGE_BUFF)\n",
        "        question.set_color(YELLOW)\n",
        "\n",
        "        lh_points = list(self.get_lh_points())\n",
        "        lh_points.append(lh_points[0])\n",
        "        lines = VGroup(*[\n",
        "            Line(origin, point)\n",
        "            for point in lh_points\n",
        "        ])\n",
        "        lines.set_color(GREEN)\n",
        "        step = 1.0 / self.num_lighthouses\n",
        "        angle_arcs = VGroup(*[\n",
        "            Arc(angle=alpha * TAU, radius=0.35).shift(origin)\n",
        "            for alpha in np.arange(0, 1 + step, step)\n",
        "        ])\n",
        "        angle_labels = VGroup()\n",
        "        for i, arc in enumerate(angle_arcs):\n",
        "            label = OldTex(\"(%d / %d)\\\\tau\" % (i, self.num_lighthouses))\n",
        "            label.scale(0.5)\n",
        "            label.add_background_rectangle()\n",
        "            point = arc.point_from_proportion(0.5)\n",
        "            point += 1.2 * (point - origin)\n",
        "            label.move_to(point)\n",
        "            angle_labels.add(label)\n",
        "            if i == 0:\n",
        "                label.shift(0.75 * label.get_height() * DOWN)\n",
        "\n",
        "        line = self.angle_line = lines[1].copy()\n",
        "        line_ghost = DashedLine(line.get_start(), line.get_end())\n",
        "        self.ghost_angle_line = line_ghost\n",
        "        line_ghost.set_stroke(line.get_color(), 2)\n",
        "        angle_arc = angle_arcs[1].copy()\n",
        "        angle_label = angle_labels[1].copy()\n",
        "        angle_label.shift(0.25 * SMALL_BUFF * DR)\n",
        "\n",
        "        magnitude_label = OldTex(\"1\")\n",
        "        magnitude_label.next_to(line.get_center(), UL, buff=SMALL_BUFF)\n",
        "\n",
        "        power_labels = VGroup()\n",
        "        for i, arrow in enumerate(outer_arrows[:-1]):\n",
        "            label = OldTex(\"x^%d\" % i)\n",
        "            label.next_to(\n",
        "                arrow.get_start(), -arrow.get_vector(),\n",
        "                submobject_to_align=label[0]\n",
        "            )\n",
        "            label.add_background_rectangle()\n",
        "            power_labels.add(label)\n",
        "        power_labels[0].next_to(outer_arrows[-1].get_start(), UR, SMALL_BUFF)\n",
        "        power_labels.submobjects[1] = x_term\n",
        "\n",
        "        L_labels = self.L_labels = VGroup(*[\n",
        "            OldTex(\"L_%d\" % i).move_to(power_label, DOWN).add_background_rectangle(\n",
        "                opacity=1\n",
        "            )\n",
        "            for i, power_label in enumerate(power_labels)\n",
        "        ])\n",
        "\n",
        "        # Ask about squaring\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(magnitude_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(angle_arc),\n",
        "            Write(angle_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(line_ghost)\n",
        "        for i in list(range(2, self.num_lighthouses)) + [0]:\n",
        "            anims = [\n",
        "                Transform(angle_arc, angle_arcs[i]),\n",
        "                Transform(angle_label, angle_labels[i]),\n",
        "                Transform(line, lines[i], path_arc=TAU / self.num_lighthouses),\n",
        "            ]\n",
        "            if i == 2:\n",
        "                anims.append(FadeOut(magnitude_label))\n",
        "            if i == 3:\n",
        "                anims.append(FadeOut(question))\n",
        "            self.play(*anims)\n",
        "            new_anims = [\n",
        "                GrowArrow(outer_arrows[i]),\n",
        "                Write(power_labels[i]),\n",
        "            ]\n",
        "            if i == 2:\n",
        "                new_anims.append(FadeOut(self.complex_plane_words))\n",
        "            self.play(*new_anims)\n",
        "            self.wait()\n",
        "        self.play(ReplacementTransform(power_labels, L_labels))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(self.lights, TAU / self.num_lighthouses / 2),\n",
        "            rate_func=wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(angle_arc),\n",
        "            FadeOut(angle_label),\n",
        "            *list(map(ShowCreationThenDestruction, lines))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def raise_everything_to_the_nth(self):\n",
        "        func_label = OldTex(\"L \\\\rightarrow L^7\")\n",
        "        func_label.set_color(YELLOW)\n",
        "        func_label.to_corner(UL, buff=LARGE_BUFF)\n",
        "        func_label.add_background_rectangle()\n",
        "\n",
        "        polynomial_scale_factor = 0.8\n",
        "\n",
        "        polynomial = OldTex(\"x^%d - 1\" % self.num_lighthouses, \"=\", \"0\")\n",
        "        polynomial.scale(polynomial_scale_factor)\n",
        "        polynomial.next_to(func_label, UP)\n",
        "        polynomial.to_edge(LEFT)\n",
        "\n",
        "        factored_polynomial = OldTex(\n",
        "            \"(x-L_0)(x-L_1)\\\\cdots(x-L_{%d - 1})\" % self.num_lighthouses, \"=\", \"0\"\n",
        "        )\n",
        "        factored_polynomial.scale(polynomial_scale_factor)\n",
        "        factored_polynomial.next_to(polynomial, DOWN, aligned_edge=LEFT)\n",
        "        for group in polynomial, factored_polynomial:\n",
        "            for part in group:\n",
        "                part.add_background_rectangle()\n",
        "\n",
        "        origin = self.complex_plane.number_to_point(0)\n",
        "\n",
        "        lights = self.lights\n",
        "        lights.save_state()\n",
        "        rotations = []\n",
        "        for i, light in enumerate(lights):\n",
        "            rotations.append(Rotating(\n",
        "                light,\n",
        "                radians=(i * TAU - i * TAU / self.num_lighthouses),\n",
        "                about_point=origin,\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "            ))\n",
        "\n",
        "        self.play(Write(func_label, run_time=1))\n",
        "        for i, rotation in enumerate(rotations[:4]):\n",
        "            if i == 3:\n",
        "                rect = SurroundingRectangle(polynomial)\n",
        "                rect.set_color(YELLOW)\n",
        "                self.play(\n",
        "                    FadeIn(polynomial),\n",
        "                    ShowCreationThenDestruction(rect)\n",
        "                )\n",
        "            self.play(\n",
        "                rotation,\n",
        "                run_time=np.sqrt(i + 1)\n",
        "            )\n",
        "        self.play(*rotations[4:], run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(lights.restore)\n",
        "        self.play(\n",
        "            FadeOut(func_label),\n",
        "            FadeIn(factored_polynomial)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            factored_polynomial[0].next_to, polynomial[1], RIGHT, 1.5 * SMALL_BUFF,\n",
        "            FadeOut(polynomial[2]),\n",
        "            FadeOut(factored_polynomial[1:]),\n",
        "        )\n",
        "\n",
        "        # Comment on formula\n",
        "        formula = VGroup(polynomial[0], polynomial[1], factored_polynomial[0])\n",
        "        rect = SurroundingRectangle(formula)\n",
        "\n",
        "        brace = Brace(factored_polynomial[0], DOWN)\n",
        "        brace2 = Brace(polynomial[0], DOWN)\n",
        "\n",
        "        morty = PiCreature(color=GREY_BROWN)\n",
        "        morty.scale(0.5)\n",
        "        morty.next_to(brace.get_center(), DL, buff=LARGE_BUFF)\n",
        "\n",
        "        L1_rhs = OldTex(\"= \\\\cos(\\\\tau / 7) + \\\\\\\\\", \"\\\\sin(\\\\tau / 7)i\")\n",
        "        L1_rhs.next_to(self.L_labels[1], RIGHT, aligned_edge=UP)\n",
        "        for part in L1_rhs:\n",
        "            part.add_background_rectangle()\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(morty.change, \"horrified\", brace)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(L1_rhs),\n",
        "            morty.change, \"confused\", L1_rhs\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(brace, brace2),\n",
        "            morty.change, \"hooray\", brace2\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        # Nothing special about 7\n",
        "        new_lights = self.lights.copy()\n",
        "        new_lights.rotate(\n",
        "            TAU / self.num_lighthouses / 2,\n",
        "            about_point=origin\n",
        "        )\n",
        "        sevens = VGroup(polynomial[0][1][1], factored_polynomial[0][1][-4])\n",
        "        n_terms = VGroup()\n",
        "        for seven in sevens:\n",
        "            n_term = OldTex(\"N\")\n",
        "            n_term.replace(seven, dim_to_match=1)\n",
        "            n_term.scale(0.9)\n",
        "            n_term.shift(0.25 * SMALL_BUFF * DR)\n",
        "            n_terms.add(n_term)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(*it.chain(\n",
        "            L1_rhs, self.outer_arrows, self.L_labels, self.outer_arrow,\n",
        "            self.angle_line, self.ghost_angle_line\n",
        "        ))))\n",
        "        self.play(LaggedStartMap(SwitchOn, new_lights), morty.look_at, new_lights)\n",
        "        self.play(Transform(sevens, n_terms))\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "    #\n",
        "\n",
        "    def get_arrows(self):\n",
        "        return VGroup(*[\n",
        "            Arrow(\n",
        "                interpolate(self.circle.get_center(), point, 0.6),\n",
        "                interpolate(self.circle.get_center(), point, 0.9),\n",
        "                buff=0\n",
        "            )\n",
        "            for point in self.get_lh_points()\n",
        "        ])\n",
        "\n",
        "\n",
        "class PlugObserverIntoPolynomial(DistanceProductScene):\n",
        "    CONFIG = {\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        \"num_lighthouses\": 7,\n",
        "        # This makes it look slightly better, but renders much slower\n",
        "        \"add_lights_in_foreground\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_circle_group()\n",
        "        self.label_roots()\n",
        "        self.add_polynomial()\n",
        "        self.point_out_rhs()\n",
        "        self.introduce_observer()\n",
        "        self.raise_observer_to_the_N()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane(\n",
        "            unit_size=2,\n",
        "            y_radius=5,\n",
        "        )\n",
        "        plane.shift(DOWN)\n",
        "        plane.add_coordinates()\n",
        "        plane.coordinate_labels.submobjects.pop(-4)\n",
        "        self.origin = plane.number_to_point(0)\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_circle_group(self):\n",
        "        self.circle.set_color(RED)\n",
        "        self.circle.set_width(\n",
        "            2 * get_norm(self.plane.number_to_point(1) - self.origin)\n",
        "        )\n",
        "        self.circle.move_to(self.origin)\n",
        "\n",
        "        lights = self.lights = self.get_lights()\n",
        "        dots = VGroup(*[\n",
        "            Dot(point) for point in self.get_lh_points()\n",
        "        ])\n",
        "        for dot, light in zip(dots, lights):\n",
        "            light.add_to_back(dot)\n",
        "\n",
        "        self.add(self.circle, lights)\n",
        "        if self.add_lights_in_foreground:\n",
        "            self.add_foreground_mobject(lights)\n",
        "\n",
        "    def label_roots(self):\n",
        "        origin = self.origin\n",
        "        labels = VGroup(*[\n",
        "            OldTex(\"L_%d\" % d)\n",
        "            for d in range(self.num_lighthouses)\n",
        "        ])\n",
        "        self.root_labels = labels\n",
        "        points = self.get_lh_points()\n",
        "        for label, point in zip(labels, points):\n",
        "            label.move_to(interpolate(origin, point, 1.2))\n",
        "        labels[0].align_to(origin, UP)\n",
        "        labels[0].shift(SMALL_BUFF * DOWN)\n",
        "        self.add(labels)\n",
        "\n",
        "    def add_polynomial(self, arg=\"x\"):\n",
        "        self.polynomial = self.get_polynomial_equation(arg)\n",
        "        self.add(self.polynomial)\n",
        "\n",
        "    def point_out_rhs(self):\n",
        "        rhs = self.get_polynomial_rhs(self.polynomial)\n",
        "        brace = Brace(rhs, DOWN, buff=SMALL_BUFF)\n",
        "        brace_text = brace.get_text(\n",
        "            \"Useful for distance product\", buff=SMALL_BUFF)\n",
        "        brace_text.set_color(YELLOW)\n",
        "        brace_text.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(brace, brace_text)))\n",
        "\n",
        "    def introduce_observer(self):\n",
        "        dot = self.observer_dot = Dot()\n",
        "        dot.move_to(self.plane.coords_to_point(1.6, 0.8))\n",
        "        observer = PiCreature(**self.observer_config)\n",
        "        observer.move_to(dot)\n",
        "        dot.match_color(observer)\n",
        "\n",
        "        vect = 2 * DOWN + LEFT\n",
        "        vect /= get_norm(vect)\n",
        "        arrow = self.arrow = Vector(0.5 * vect)\n",
        "        arrow.next_to(observer, -vect, buff=SMALL_BUFF)\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        full_name = OldTexText(\"Observer\")\n",
        "        var_name = self.var_name = OldTex(\"O\")\n",
        "        for mob in full_name, var_name:\n",
        "            mob.match_color(observer)\n",
        "            mob.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "            mob.add_background_rectangle()\n",
        "\n",
        "        complex_decimal = DecimalNumber(0, include_background_rectangle=True)\n",
        "        equals = OldTex(\"=\")\n",
        "        complex_decimal_animation = ChangingDecimal(\n",
        "            complex_decimal,\n",
        "            lambda a: self.plane.point_to_number(dot.get_center()),\n",
        "            position_update_func=lambda m: m.next_to(equals, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "        complex_decimal_animation.update(0)\n",
        "        equals_decimal = VGroup(equals, complex_decimal)\n",
        "        equals_decimal.next_to(var_name, RIGHT)\n",
        "\n",
        "        new_polynomial = self.get_polynomial_equation(\"O\")\n",
        "        O_terms = new_polynomial.get_parts_by_tex(\"O\")\n",
        "\n",
        "        lhs, poly_eq, rhs = self.get_polynomial_split(new_polynomial)\n",
        "        lhs_rect = SurroundingRectangle(lhs, color=YELLOW)\n",
        "        rhs_rect = SurroundingRectangle(rhs, color=YELLOW)\n",
        "        self.lhs, self.rhs = lhs, rhs\n",
        "        self.lhs_rect, self.rhs_rect = lhs_rect, rhs_rect\n",
        "\n",
        "        lines = self.lines = self.get_lines()\n",
        "        lines_update = self.lines_update = UpdateFromFunc(\n",
        "            lines, lambda l: Transform(l, self.get_lines()).update(1)\n",
        "        )\n",
        "\n",
        "        anims_for_dot_movement = self.anims_for_dot_movement = [\n",
        "            MaintainPositionRelativeTo(arrow, dot),\n",
        "            MaintainPositionRelativeTo(var_name, arrow),\n",
        "            MaintainPositionRelativeTo(equals, var_name),\n",
        "            complex_decimal_animation,\n",
        "            lines_update,\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(observer, direction=-vect),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.play(Write(full_name))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(full_name[0], var_name[0]),\n",
        "            ReplacementTransform(full_name[1][0], var_name[1][0]),\n",
        "            FadeOut(full_name[1][1:]),\n",
        "            ReplacementTransform(observer, dot),\n",
        "            FadeIn(equals_decimal)\n",
        "        )\n",
        "        self.add_foreground_mobject(dot)\n",
        "\n",
        "        # Substitute\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(var_name.copy(), O_terms),\n",
        "            ReplacementTransform(self.polynomial, new_polynomial)\n",
        "        )\n",
        "        self.polynomial = new_polynomial\n",
        "        self.wait()\n",
        "\n",
        "        # Show distances\n",
        "        self.play(ShowCreation(rhs_rect))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            Animation(dot)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                dot,\n",
        "                radians=TAU,\n",
        "                rate_func=smooth,\n",
        "                about_point=dot.get_center() + MED_LARGE_BUFF * LEFT,\n",
        "                run_time=4\n",
        "            ),\n",
        "            *anims_for_dot_movement\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(rhs_rect)\n",
        "        self.play(ReplacementTransform(rhs_rect.copy(), lhs_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Move onto circle\n",
        "        angle = self.observer_angle = TAU / self.num_lighthouses / 3.0\n",
        "        target_point = self.plane.number_to_point(\n",
        "            np.exp(complex(0, angle))\n",
        "        )\n",
        "        self.play(\n",
        "            dot.move_to, target_point,\n",
        "            *anims_for_dot_movement\n",
        "        )\n",
        "        self.play(FadeOut(VGroup(\n",
        "            equals, complex_decimal,\n",
        "            var_name, arrow,\n",
        "        )))\n",
        "\n",
        "    def raise_observer_to_the_N(self):\n",
        "        dot = self.observer_dot\n",
        "        origin = self.origin\n",
        "        radius = self.get_radius()\n",
        "\n",
        "        text_scale_val = 0.8\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"What fraction \\\\\\\\\", \"between $L_0$ and $L_1$\", \"?\",\n",
        "            arg_separator=\"\"\n",
        "        )\n",
        "        question.scale(text_scale_val)\n",
        "        question.next_to(dot, RIGHT)\n",
        "        question.add_background_rectangle_to_submobjects()\n",
        "\n",
        "        f_words = OldTexText(\"$f$\", \"of the way\")\n",
        "        third_words = OldTexText(\"$\\\\frac{1}{3}$\", \"of the way\")\n",
        "        for words in f_words, third_words:\n",
        "            words.scale(text_scale_val)\n",
        "            words.move_to(question[0])\n",
        "            words[0].set_color(YELLOW)\n",
        "            words.add_background_rectangle()\n",
        "\n",
        "        obs_angle = self.observer_angle\n",
        "        full_angle = TAU / self.num_lighthouses\n",
        "\n",
        "        def get_arc(angle):\n",
        "            result = Arc(angle=angle, radius=radius,\n",
        "                         color=YELLOW, stroke_width=4)\n",
        "            result.shift(origin)\n",
        "            return result\n",
        "\n",
        "        arc = get_arc(obs_angle)\n",
        "        O_to_N_arc = get_arc(obs_angle * self.num_lighthouses)\n",
        "\n",
        "        O_to_N_dot = dot.copy().move_to(O_to_N_arc.point_from_proportion(1))\n",
        "        O_to_N_arrow = Vector(0.5 * DR).next_to(O_to_N_dot, UL, SMALL_BUFF)\n",
        "        O_to_N_arrow.set_color(WHITE)\n",
        "        O_to_N_label = OldTex(\"O\", \"^N\")\n",
        "        O_to_N_label.set_color_by_tex(\"O\", dot.get_color())\n",
        "        O_to_N_label.next_to(O_to_N_arrow.get_start(), UP, SMALL_BUFF)\n",
        "        O_to_N_label.shift(SMALL_BUFF * RIGHT)\n",
        "        O_to_N_group = VGroup(O_to_N_arc, O_to_N_arrow, O_to_N_label)\n",
        "\n",
        "        around_circle_words = OldTexText(\"around the circle\")\n",
        "        around_circle_words.scale(text_scale_val)\n",
        "        around_circle_words.add_background_rectangle()\n",
        "        around_circle_words.next_to(self.circle.get_top(), UR)\n",
        "\n",
        "        chord = Line(O_to_N_dot.get_center(), self.circle.get_right())\n",
        "        chord.set_stroke(GREEN)\n",
        "\n",
        "        chord_halves = VGroup(\n",
        "            Line(chord.get_center(), chord.get_start()),\n",
        "            Line(chord.get_center(), chord.get_end()),\n",
        "        )\n",
        "        chord_halves.set_stroke(WHITE, 5)\n",
        "\n",
        "        chord_label = OldTex(\"|\", \"O\", \"^N\", \"-\", \"1\", \"|\")\n",
        "        chord_label.set_color_by_tex(\"O\", MAROON_B)\n",
        "        chord_label.add_background_rectangle()\n",
        "        chord_label.next_to(chord.get_center(), DOWN, SMALL_BUFF)\n",
        "        chord_label.rotate(\n",
        "            chord.get_angle(), about_point=chord.get_center()\n",
        "        )\n",
        "\n",
        "        numeric_chord_label = DecimalNumber(\n",
        "            np.sqrt(3),\n",
        "            num_decimal_places=4,\n",
        "            include_background_rectangle=True,\n",
        "            show_ellipsis=True,\n",
        "        )\n",
        "        numeric_chord_label.rotate(chord.get_angle())\n",
        "        numeric_chord_label.move_to(chord_label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question),\n",
        "            ShowCreation(arc),\n",
        "        )\n",
        "        for angle in [full_angle - obs_angle, -full_angle, obs_angle]:\n",
        "            last_angle = angle_of_vector(dot.get_center() - origin)\n",
        "            self.play(\n",
        "                self.lines_update,\n",
        "                UpdateFromAlphaFunc(\n",
        "                    arc, lambda arc, a: Transform(\n",
        "                        arc, get_arc(last_angle + a * angle)\n",
        "                    ).update(1)\n",
        "                ),\n",
        "                Rotate(dot, angle, about_point=origin),\n",
        "                run_time=2\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(question[0]),\n",
        "            FadeOut(question[2]),\n",
        "            FadeIn(f_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(self.lines),\n",
        "            FadeOut(self.root_labels),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(dot.copy(), O_to_N_dot),\n",
        "            ReplacementTransform(arc, O_to_N_arc),\n",
        "            path_arc=O_to_N_arc.angle - arc.angle,\n",
        "        )\n",
        "        self.add_foreground_mobject(O_to_N_dot)\n",
        "        self.play(\n",
        "            FadeIn(O_to_N_label),\n",
        "            GrowArrow(O_to_N_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(question[1]),\n",
        "            f_words.next_to, around_circle_words, UP, SMALL_BUFF,\n",
        "            FadeIn(around_circle_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(chord_label[0]),\n",
        "            ReplacementTransform(self.lhs.copy(), chord_label[1]),\n",
        "            ShowCreation(chord)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Talk through current example\n",
        "        light_rings = VGroup(*it.chain(self.lights))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, light_rings,\n",
        "            lambda m: (m.shift, MED_SMALL_BUFF * UP),\n",
        "            rate_func=wiggle\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeOut(around_circle_words),\n",
        "            FadeIn(question[1]),\n",
        "            ReplacementTransform(f_words, third_words)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(dot, 0.05 * TAU, about_point=origin, rate_func=wiggle)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            dot.copy(), O_to_N_dot, path_arc=TAU / 3))\n",
        "        self.play(\n",
        "            third_words.next_to, around_circle_words, UP, SMALL_BUFF,\n",
        "            FadeIn(around_circle_words),\n",
        "            FadeOut(question[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Indicate(self.lhs))\n",
        "        for x in range(2):\n",
        "            self.play(ShowCreationThenDestruction(chord_halves))\n",
        "        self.play(\n",
        "            FadeOut(chord_label),\n",
        "            FadeIn(numeric_chord_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(self.lhs_rect)\n",
        "        self.play(\n",
        "            FadeOut(chord),\n",
        "            FadeOut(numeric_chord_label),\n",
        "            FadeOut(O_to_N_group),\n",
        "            FadeIn(self.lines),\n",
        "            ReplacementTransform(self.lhs_rect.copy(), self.rhs_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add new lights\n",
        "        for light in self.lights:\n",
        "            light[1:].fade(0.5)\n",
        "        added_lights = self.lights.copy()\n",
        "        added_lights.rotate(full_angle / 2, about_point=origin)\n",
        "        new_lights = VGroup(*it.chain(*list(zip(self.lights, added_lights))))\n",
        "        self.num_lighthouses *= 2\n",
        "        dot.generate_target()\n",
        "        dot.target.move_to(self.get_circle_point_at_proportion(\n",
        "            obs_angle / TAU / 2\n",
        "        ))\n",
        "        dot.save_state()\n",
        "        dot.move_to(dot.target)\n",
        "        new_lines = self.get_lines()\n",
        "        dot.restore()\n",
        "\n",
        "        self.play(Transform(self.lights, new_lights))\n",
        "        self.play(\n",
        "            MoveToTarget(dot),\n",
        "            Transform(self.lines, new_lines)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            third_words.next_to, question[1], UP, SMALL_BUFF,\n",
        "            FadeOut(around_circle_words),\n",
        "            FadeIn(question[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        chord_group = VGroup(chord, numeric_chord_label[1])\n",
        "        chord_group.set_color(YELLOW)\n",
        "        self.add_foreground_mobjects(*chord_group)\n",
        "        self.play(\n",
        "            FadeIn(chord),\n",
        "            FadeIn(numeric_chord_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_polynomial_equation(self, var=\"x\", color=None):\n",
        "        if color is None:\n",
        "            color = self.observer_config[\"color\"]\n",
        "        equation = OldTex(\n",
        "            \"\\\\left(\", var, \"^N\", \"-\", \"1\", \"\\\\right)\", \"=\",\n",
        "            \"\\\\left(\", var, \"-\", \"L_0\", \"\\\\right)\",\n",
        "            \"\\\\left(\", var, \"-\", \"L_1\", \"\\\\right)\",\n",
        "            \"\\\\cdots\",\n",
        "            \"\\\\left(\", var, \"-\", \"L_{N-1}\", \"\\\\right)\",\n",
        "        )\n",
        "        equation.set_color_by_tex(var, color)\n",
        "        equation.to_edge(UP)\n",
        "        equation.add_background_rectangle()\n",
        "        return equation\n",
        "\n",
        "    def get_polynomial_rhs(self, polynomial):\n",
        "        return self.get_polynomial_split(polynomial)[2]\n",
        "\n",
        "    def get_polynomial_lhs(self, polynomial):\n",
        "        return self.get_polynomial_split(polynomial)[0]\n",
        "\n",
        "    def get_polynomial_split(self, polynomial):\n",
        "        eq = polynomial.get_part_by_tex(\"=\")\n",
        "        i = polynomial[1].submobjects.index(eq)\n",
        "        return polynomial[1][:i], polynomial[1][i], polynomial[1][i + 1:]\n",
        "\n",
        "    def get_lines(self, start_point=None):\n",
        "        return self.get_distance_lines(\n",
        "            start_point=start_point,\n",
        "            line_class=DashedLine\n",
        "        )\n",
        "\n",
        "    def get_observer_point(self, dummy_arg=None):\n",
        "        return self.observer_dot.get_center()\n",
        "\n",
        "\n",
        "class PlugObserverIntoPolynomial5Lighthouses(PlugObserverIntoPolynomial):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 5,\n",
        "    }\n",
        "\n",
        "\n",
        "class PlugObserverIntoPolynomial3Lighthouses(PlugObserverIntoPolynomial):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 3,\n",
        "    }\n",
        "\n",
        "\n",
        "class PlugObserverIntoPolynomial2Lighthouses(PlugObserverIntoPolynomial):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 2,\n",
        "    }\n",
        "\n",
        "\n",
        "class DefineChordF(Scene):\n",
        "    def construct(self):\n",
        "        radius = 2.5\n",
        "\n",
        "        full_chord_f = OldTexText(\n",
        "            \"``\", \"Chord(\", \"$f$\", \")\", \"''\", arg_separator=\"\")\n",
        "        full_chord_f.set_color_by_tex(\"$f$\", YELLOW)\n",
        "        full_chord_f.to_edge(UP)\n",
        "        chord_f = full_chord_f[1:-1]\n",
        "        chord_f.generate_target()\n",
        "\n",
        "        circle = Circle(radius=2.5)\n",
        "        circle.set_color(RED)\n",
        "        radius_line = Line(circle.get_center(), circle.get_right())\n",
        "        one_label = OldTex(\"1\")\n",
        "        one_label.next_to(radius_line, DOWN, SMALL_BUFF)\n",
        "\n",
        "        chord = Line(*[circle.point_from_proportion(f) for f in [0, 1. / 3]])\n",
        "        chord.set_color(YELLOW)\n",
        "        chord_third = OldTexText(\"Chord(\", \"$1/3$\", \")\", arg_separator=\"\")\n",
        "        chord_third.set_color_by_tex(\"1/3\", YELLOW)\n",
        "        for term in chord_third, chord_f.target:\n",
        "            term.next_to(chord.get_center(), UP, SMALL_BUFF)\n",
        "            chord_angle = chord.get_angle() + np.pi\n",
        "            term.rotate(chord_angle, about_point=chord.get_center())\n",
        "\n",
        "        brace = Brace(Line(ORIGIN, TAU * UP / 3), RIGHT, buff=0)\n",
        "        brace.generate_target()\n",
        "        brace.target.stretch(0.5, 0)\n",
        "        brace.target.apply_complex_function(np.exp)\n",
        "        VGroup(brace, brace.target).scale(radius)\n",
        "        brace.next_to(circle.get_right(), RIGHT, SMALL_BUFF, DOWN)\n",
        "        brace.scale(0.5, about_edge=DOWN)\n",
        "        brace.target.move_to(brace, DR)\n",
        "        brace.target.shift(2 * SMALL_BUFF * LEFT)\n",
        "\n",
        "        f_label = OldTex(\"f\")\n",
        "        f_label.set_color(YELLOW)\n",
        "        point = circle.point_from_proportion(1.0 / 6)\n",
        "        f_label.move_to(point + 0.4 * (point - circle.get_center()))\n",
        "\n",
        "        third_label = OldTex(\"\\\\frac{1}{3}\")\n",
        "        third_label.scale(0.7)\n",
        "        third_label.move_to(f_label)\n",
        "        third_label.match_color(f_label)\n",
        "\n",
        "        alphas = np.linspace(0, 1, 4)\n",
        "        third_arcs = VGroup(*[\n",
        "            VMobject().pointwise_become_partial(circle, a1, a2)\n",
        "            for a1, a2 in zip(alphas, alphas[1:])\n",
        "        ])\n",
        "        third_arcs.set_color_by_gradient(BLUE, PINK, GREEN)\n",
        "\n",
        "        # Terms for sine formula\n",
        "        origin = circle.get_center()\n",
        "        height = DashedLine(origin, chord.get_center())\n",
        "        half_chords = VGroup(\n",
        "            Line(chord.get_start(), chord.get_center()),\n",
        "            Line(chord.get_end(), chord.get_center()),\n",
        "        )\n",
        "        half_chords.set_color_by_gradient(BLUE, PINK)\n",
        "        alt_radius_line = Line(origin, chord.get_end())\n",
        "        alt_radius_line.set_color(WHITE)\n",
        "        angle_arc = Arc(\n",
        "            radius=0.3,\n",
        "            angle=TAU / 6,\n",
        "        )\n",
        "        angle_arc.shift(origin)\n",
        "        angle_label = OldTex(\"\\\\frac{f}{2}\", \"2\\\\pi\")\n",
        "        angle_label[0][0].set_color(YELLOW)\n",
        "        angle_label.scale(0.6)\n",
        "        angle_label.next_to(angle_arc, RIGHT, SMALL_BUFF, DOWN)\n",
        "        angle_label.shift(SMALL_BUFF * UR)\n",
        "\n",
        "        circle_group = VGroup(\n",
        "            circle, chord, radius_line, one_label,\n",
        "            brace, f_label, chord_f,\n",
        "            half_chords, height,\n",
        "            angle_arc, angle_label,\n",
        "        )\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"= 2 \\\\cdot \\\\sin\\\\left(\\\\frac{f}{2} 2\\\\pi \\\\right)\",\n",
        "            \"= 2 \\\\cdot \\\\sin\\\\left(f \\\\pi \\\\right)\",\n",
        "        )\n",
        "        for part in formula:\n",
        "            part[7].set_color(YELLOW)\n",
        "\n",
        "        # Draw circle and chord\n",
        "        self.add(radius_line, circle, one_label)\n",
        "        self.play(Write(full_chord_f))\n",
        "        self.play(ShowCreation(chord))\n",
        "        self.play(\n",
        "            MoveToTarget(chord_f),\n",
        "            FadeOut(VGroup(full_chord_f[0], full_chord_f[-1]))\n",
        "        )\n",
        "        self.play(GrowFromEdge(brace, DOWN))\n",
        "        self.play(MoveToTarget(brace, path_arc=TAU / 3))\n",
        "        self.play(Write(f_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show third\n",
        "        self.remove(chord_f, f_label)\n",
        "        self.play(\n",
        "            ReplacementTransform(chord_f.copy(), chord_third),\n",
        "            ReplacementTransform(f_label.copy(), third_label),\n",
        "        )\n",
        "        chord_copies = VGroup()\n",
        "        last_chord = chord\n",
        "        for color in PINK, BLUE:\n",
        "            chord_copy = last_chord.copy()\n",
        "            old_color = chord_copy.get_color()\n",
        "            self.play(\n",
        "                Rotate(chord_copy, -TAU / 6, about_point=last_chord.get_end()),\n",
        "                UpdateFromAlphaFunc(\n",
        "                    chord_copy,\n",
        "                    lambda m, a: m.set_stroke(\n",
        "                        interpolate_color(old_color, color, a))\n",
        "                )\n",
        "            )\n",
        "            chord_copy.reverse_points()\n",
        "            last_chord = chord_copy\n",
        "            chord_copies.add(chord_copy)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(chord_copies),\n",
        "            ReplacementTransform(chord_third, chord_f),\n",
        "            ReplacementTransform(third_label, f_label),\n",
        "        )\n",
        "\n",
        "        # Show sine formula\n",
        "        top_chord_f = chord_f.copy()\n",
        "        top_chord_f.generate_target()\n",
        "        top_chord_f.target.rotate(-chord_angle)\n",
        "        top_chord_f.target.center().to_edge(UP, buff=LARGE_BUFF)\n",
        "        top_chord_f.target.shift(3 * LEFT)\n",
        "        formula.next_to(top_chord_f.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(height),\n",
        "            FadeIn(half_chords),\n",
        "            ShowCreation(angle_arc),\n",
        "            Write(angle_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(top_chord_f),\n",
        "            circle_group.shift, 1.5 * DOWN,\n",
        "        )\n",
        "        self.play(Write(formula[0], run_time=1))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            formula[0].copy(), formula[1],\n",
        "            path_arc=45 * DEGREES\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DistanceProductIsChordF(PlugObserverIntoPolynomial):\n",
        "    CONFIG = {\n",
        "        \"include_lighthouses\": False,\n",
        "        \"num_lighthouses\": 8,\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        # \"add_lights_in_foreground\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_circle_group()\n",
        "        self.add_polynomial(\"O\")\n",
        "        self.show_all_animations()\n",
        "\n",
        "    def show_all_animations(self):\n",
        "        fraction = self.observer_fraction = 0.3\n",
        "        circle = self.circle\n",
        "\n",
        "        O_dot = self.observer_dot = Dot()\n",
        "        O_dot.set_color(self.observer_config[\"color\"])\n",
        "        O_to_N_dot = O_dot.copy()\n",
        "        O_dot.move_to(self.get_circle_point_at_proportion(\n",
        "            fraction / self.num_lighthouses))\n",
        "        O_to_N_dot.move_to(self.get_circle_point_at_proportion(fraction))\n",
        "\n",
        "        for dot, vect, tex in [(O_dot, DL, \"O\"), (O_to_N_dot, DR, \"O^N\")]:\n",
        "            arrow = Vector(0.5 * vect, color=WHITE)\n",
        "            arrow.next_to(dot.get_center(), -vect, SMALL_BUFF)\n",
        "            label = OldTex(tex)\n",
        "            O_part = label[0]\n",
        "            O_part.match_color(dot)\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(arrow.get_start(), -vect, buff=0,\n",
        "                          submobject_to_align=O_part)\n",
        "            dot.arrow = arrow\n",
        "            dot.label = label\n",
        "            self.add_foreground_mobject(dot)\n",
        "            self.add(arrow, label)\n",
        "            # For the transition to f = 1 / 2\n",
        "            dot.generate_target()\n",
        "\n",
        "        fraction_words = VGroup(\n",
        "            OldTexText(\"$f$\", \"of the way\"),\n",
        "            OldTexText(\"between lighthouses\")\n",
        "        )\n",
        "        fraction_words.scale(0.8)\n",
        "        fraction_words[0][0].set_color(YELLOW)\n",
        "        fraction_words.arrange(DOWN, SMALL_BUFF, aligned_edge=LEFT)\n",
        "        fraction_words.next_to(O_dot.label, RIGHT)\n",
        "        list(map(Tex.add_background_rectangle, fraction_words))\n",
        "\n",
        "        f_arc, new_arc = [\n",
        "            Arc(\n",
        "                angle=(TAU * f / self.num_lighthouses),\n",
        "                radius=self.get_radius(),\n",
        "                color=YELLOW,\n",
        "            ).shift(circle.get_center())\n",
        "            for f in (fraction, 0.5)\n",
        "        ]\n",
        "        self.add(f_arc)\n",
        "\n",
        "        lines = self.lines = self.get_lines()\n",
        "        labels = self.get_numeric_distance_labels()\n",
        "\n",
        "        black_rect = Rectangle(height=6, width=3.5)\n",
        "        black_rect.set_stroke(width=0)\n",
        "        black_rect.set_fill(BLACK, 0.8)\n",
        "        black_rect.to_corner(DL, buff=0)\n",
        "        colum_group = self.get_distance_product_column(\n",
        "            column_top=black_rect.get_top() + MED_SMALL_BUFF * DOWN\n",
        "        )\n",
        "        stacked_labels, h_line, times, product_decimal = colum_group\n",
        "\n",
        "        chord = Line(*[\n",
        "            self.get_circle_point_at_proportion(f)\n",
        "            for f in (0, fraction)\n",
        "        ])\n",
        "        chord.set_stroke(YELLOW)\n",
        "        chord_f = get_chord_f_label(chord)\n",
        "        chord_f_as_product = chord_f.copy()\n",
        "        chord_f_as_product.generate_target()\n",
        "        chord_f_as_product.target.rotate(-chord_f_as_product.angle)\n",
        "        chord_f_as_product.target.scale(0.8)\n",
        "        chord_f_as_product.target.move_to(product_decimal, RIGHT)\n",
        "\n",
        "        # Constructs for the case f = 1 / 2\n",
        "        new_chord = Line(circle.get_right(), circle.get_left())\n",
        "        new_chord.match_style(chord)\n",
        "        chord_half = get_chord_f_label(new_chord, \"1/2\")\n",
        "\n",
        "        f_terms = VGroup(fraction_words[0][1][0], chord_f_as_product[1][1])\n",
        "        half_terms = VGroup(*[\n",
        "            OldTex(\"\\\\frac{1}{2}\").scale(0.6).set_color(YELLOW).move_to(f)\n",
        "            for f in f_terms\n",
        "        ])\n",
        "        half_terms[1].move_to(chord_f_as_product.target[1][1])\n",
        "\n",
        "        O_dot.target.move_to(self.get_circle_point_at_proportion(\n",
        "            0.5 / self.num_lighthouses))\n",
        "        O_to_N_dot .target.move_to(circle.get_left())\n",
        "        self.observer_dot = O_dot.target\n",
        "        new_lines = self.get_lines()\n",
        "\n",
        "        changing_decimals = []\n",
        "        radius = self.get_radius()\n",
        "        for decimal, line in zip(stacked_labels, new_lines):\n",
        "            changing_decimals.append(\n",
        "                ChangeDecimalToValue(decimal, line.get_length() / radius)\n",
        "            )\n",
        "\n",
        "        equals_two_terms = VGroup(*[\n",
        "            OldTex(\"=2\").next_to(mob, DOWN, SMALL_BUFF)\n",
        "            for mob in (chord_half, chord_f_as_product.target)\n",
        "        ])\n",
        "\n",
        "        # Animations\n",
        "\n",
        "        self.play(Write(fraction_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(FadeIn, labels),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(black_rect),\n",
        "            ReplacementTransform(labels.copy(), stacked_labels),\n",
        "            ShowCreation(h_line),\n",
        "            Write(times),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.add_foreground_mobjects(\n",
        "            chord_f[1], chord, O_dot, O_to_N_dot\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(labels),\n",
        "            ShowCreation(chord),\n",
        "            FadeIn(chord_f),\n",
        "        )\n",
        "        self.play(MoveToTarget(chord_f_as_product))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Transition to f = 1 / 2\n",
        "        self.play(\n",
        "            Transform(lines, new_lines),\n",
        "            Transform(f_arc, new_arc),\n",
        "            Transform(chord, new_chord),\n",
        "            chord_f.rotate, -chord_f.angle,\n",
        "            chord_f.move_to, chord_half,\n",
        "            MoveToTarget(O_dot),\n",
        "            MoveToTarget(O_to_N_dot),\n",
        "            MaintainPositionRelativeTo(O_dot.arrow, O_dot),\n",
        "            MaintainPositionRelativeTo(O_dot.label, O_dot),\n",
        "            MaintainPositionRelativeTo(O_to_N_dot.arrow, O_to_N_dot),\n",
        "            MaintainPositionRelativeTo(O_to_N_dot.label, O_to_N_dot),\n",
        "            *changing_decimals,\n",
        "            path_arc=(45 * DEGREES),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(chord_f, chord_half),\n",
        "            Transform(f_terms, half_terms),\n",
        "        )\n",
        "        self.wait()\n",
        "        for term in equals_two_terms:\n",
        "            term.add_background_rectangle()\n",
        "            self.add_foreground_mobject(term[1])\n",
        "        self.play(\n",
        "            Write(equals_two_terms)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ProveLemma2(PlugObserverIntoPolynomial):\n",
        "    CONFIG = {\n",
        "        \"include_lighthouses\": False,\n",
        "        \"num_lighthouses\": 8,\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        # \"add_lights_in_foreground\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_circle_group()\n",
        "        self.add_polynomial(\"O\")\n",
        "\n",
        "        self.replace_first_lighthouse()\n",
        "        self.rearrange_polynomial()\n",
        "        self.plug_in_one()\n",
        "\n",
        "    def replace_first_lighthouse(self):\n",
        "        light_to_remove = self.lights[0]\n",
        "        dot = self.observer_dot = Dot(color=self.observer_config[\"color\"])\n",
        "        dot.move_to(self.get_circle_point_at_proportion(\n",
        "            0.5 / self.num_lighthouses))\n",
        "        arrow = Vector(0.5 * DL, color=WHITE)\n",
        "        arrow.next_to(dot, UR, SMALL_BUFF)\n",
        "        O_label = self.O_dot_label = OldTex(\"O\")\n",
        "        O_label.match_color(dot)\n",
        "        O_label.add_background_rectangle()\n",
        "        O_label.next_to(arrow, UR, SMALL_BUFF)\n",
        "\n",
        "        # First, move the lighthouse\n",
        "        self.add_foreground_mobject(dot)\n",
        "        self.play(\n",
        "            dot.move_to, light_to_remove,\n",
        "            MaintainPositionRelativeTo(arrow, dot),\n",
        "            MaintainPositionRelativeTo(O_label, dot),\n",
        "            path_arc=-TAU / 2\n",
        "        )\n",
        "\n",
        "        black_rect = Rectangle(\n",
        "            height=6, width=3.5,\n",
        "            stroke_width=0,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        black_rect.to_corner(DL, buff=0)\n",
        "        lines = self.get_lines(self.circle.get_right())\n",
        "        labels = self.get_numeric_distance_labels()\n",
        "        column_group = self.get_distance_product_column(\n",
        "            black_rect.get_top() + MED_SMALL_BUFF * DOWN\n",
        "        )\n",
        "        stacked_labels, h_line, times, product_decimal = column_group\n",
        "        q_marks = self.q_marks = OldTexText(\"???\")\n",
        "        q_marks.move_to(product_decimal, LEFT)\n",
        "        q_marks.match_color(product_decimal)\n",
        "\n",
        "        zero_rects = VGroup(\n",
        "            *list(map(SurroundingRectangle, [dot, stacked_labels[0]])))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(FadeIn, labels),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(black_rect),\n",
        "            ShowCreation(h_line),\n",
        "            Write(times),\n",
        "            ReplacementTransform(labels.copy(), stacked_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            stacked_labels.copy(),\n",
        "            VGroup(product_decimal)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(zero_rects)\n",
        "        self.play(*list(map(ShowCreation, zero_rects)))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            VGroup(light_to_remove, zero_rects[0]\n",
        "                   ).shift, FRAME_WIDTH * RIGHT / 2,\n",
        "            path_arc=-60 * DEGREES,\n",
        "            rate_func=running_start,\n",
        "            remover=True\n",
        "        )\n",
        "        self.play(\n",
        "            VGroup(stacked_labels[0], zero_rects[1]).shift, 4 * LEFT,\n",
        "            rate_func=running_start,\n",
        "            remover=True,\n",
        "        )\n",
        "        self.remove_foreground_mobjects(zero_rects)\n",
        "        self.play(\n",
        "            FadeOut(product_decimal),\n",
        "            FadeIn(q_marks)\n",
        "        )\n",
        "        self.play(FadeOut(labels))\n",
        "        self.wait()\n",
        "\n",
        "    def rearrange_polynomial(self):\n",
        "        dot = self.observer_dot\n",
        "        lhs, equals, rhs = self.get_polynomial_split(self.polynomial)\n",
        "        polynomial_background = self.polynomial[0]\n",
        "        first_factor = rhs[:5]\n",
        "        remaining_factors = rhs[5:]\n",
        "        equals_remaining_factors = VGroup(equals, remaining_factors)\n",
        "\n",
        "        # first_factor_rect = SurroundingRectangle(first_factor)\n",
        "        lhs_rect = SurroundingRectangle(lhs)\n",
        "\n",
        "        frac_line = Line(LEFT, RIGHT, color=WHITE)\n",
        "        frac_line.match_width(lhs, stretch=True)\n",
        "        frac_line.next_to(lhs, DOWN, SMALL_BUFF)\n",
        "        O_minus_1 = OldTex(\"\\\\left(\", \"O\", \"-\", \"1\", \"\\\\right)\")\n",
        "        O_minus_1.next_to(frac_line, DOWN, SMALL_BUFF)\n",
        "        new_lhs_background = BackgroundRectangle(\n",
        "            VGroup(lhs, O_minus_1), buff=SMALL_BUFF)\n",
        "        new_lhs_rect = SurroundingRectangle(VGroup(lhs, O_minus_1))\n",
        "\n",
        "        roots_of_unity_circle = VGroup(*[\n",
        "            Circle(radius=0.2, color=YELLOW).move_to(point)\n",
        "            for point in self.get_lh_points()\n",
        "        ])\n",
        "        for circle in roots_of_unity_circle:\n",
        "            circle.save_state()\n",
        "            circle.scale(4)\n",
        "            circle.fade(1)\n",
        "\n",
        "        self.play(ShowCreation(lhs_rect))\n",
        "        self.add_foreground_mobject(roots_of_unity_circle)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, roots_of_unity_circle,\n",
        "            lambda m: (m.restore,)\n",
        "        ))\n",
        "        self.wait()\n",
        "        frac_line_copy = frac_line.copy()\n",
        "        self.play(\n",
        "            FadeIn(new_lhs_background),\n",
        "            polynomial_background.stretch, 0.8, 0,\n",
        "            polynomial_background.move_to, frac_line_copy, LEFT,\n",
        "            equals_remaining_factors.arrange, RIGHT, SMALL_BUFF,\n",
        "            equals_remaining_factors.next_to, frac_line_copy, RIGHT, MED_SMALL_BUFF,\n",
        "            ReplacementTransform(first_factor, O_minus_1,\n",
        "                                 path_arc=-90 * DEGREES),\n",
        "            ShowCreation(frac_line),\n",
        "            Animation(lhs),\n",
        "            ReplacementTransform(lhs_rect, new_lhs_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            roots_of_unity_circle[0].shift, FRAME_WIDTH * RIGHT / 2,\n",
        "            path_arc=(-60 * DEGREES),\n",
        "            rate_func=running_start,\n",
        "            remover=True\n",
        "        )\n",
        "\n",
        "        # Expand rhs\n",
        "        expanded_rhs = self.expanded_rhs = OldTex(\n",
        "            \"=\", \"1\", \"+\",\n",
        "            \"O\", \"+\",\n",
        "            \"O\", \"^2\", \"+\",\n",
        "            \"\\\\cdots\",\n",
        "            \"O\", \"^{N-1}\"\n",
        "        )\n",
        "        expanded_rhs.next_to(frac_line, RIGHT)\n",
        "        expanded_rhs.shift(LEFT)\n",
        "        expanded_rhs.scale(0.9)\n",
        "        expanded_rhs.set_color_by_tex(\"O\", dot.get_color())\n",
        "\n",
        "        self.play(\n",
        "            polynomial_background.stretch, 1.8, 0, {\"about_edge\": LEFT},\n",
        "            FadeIn(expanded_rhs),\n",
        "            equals_remaining_factors.scale, 0.9,\n",
        "            equals_remaining_factors.next_to, expanded_rhs,\n",
        "            VGroup(\n",
        "                new_lhs_background, lhs, frac_line, O_minus_1,\n",
        "                new_lhs_rect,\n",
        "            ).shift, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def plug_in_one(self):\n",
        "        expanded_rhs = self.expanded_rhs\n",
        "        O_terms = expanded_rhs.get_parts_by_tex(\"O\")\n",
        "        ones = VGroup(*[\n",
        "            OldTex(\"1\").move_to(O_term, RIGHT)\n",
        "            for O_term in O_terms\n",
        "        ])\n",
        "        ones.match_color(O_terms[0])\n",
        "\n",
        "        equals_1 = OldTex(\"= 1\")\n",
        "        equals_1.next_to(self.O_dot_label, RIGHT, SMALL_BUFF)\n",
        "        brace = Brace(expanded_rhs[1:], DOWN)\n",
        "        N_term = brace.get_text(\"N\")\n",
        "\n",
        "        product = DecimalNumber(\n",
        "            self.num_lighthouses,\n",
        "            num_decimal_places=3,\n",
        "            show_ellipsis=True\n",
        "        )\n",
        "        product.move_to(self.q_marks, LEFT)\n",
        "\n",
        "        self.play(Write(equals_1))\n",
        "        self.play(\n",
        "            FocusOn(brace),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(O_terms, ones))\n",
        "        self.wait()\n",
        "        self.play(Write(N_term))\n",
        "        self.play(FocusOn(product))\n",
        "        self.play(\n",
        "            FadeOut(self.q_marks),\n",
        "            FadeIn(product)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LocalMathematician(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy, mathy = self.pi_creatures\n",
        "        screen = ScreenRectangle(height=2)\n",
        "        screen.to_corner(UL)\n",
        "        screen.fade(1)\n",
        "\n",
        "        mathy_name = OldTexText(\"Local \\\\\\\\ mathematician\")\n",
        "        mathy_name.next_to(mathy, LEFT, LARGE_BUFF)\n",
        "        arrow = Arrow(mathy_name, mathy)\n",
        "\n",
        "        self.play(\n",
        "            Animation(screen),\n",
        "            mathy.change, \"pondering\",\n",
        "            PiCreatureSays(\n",
        "                randy, \"Check these \\\\\\\\ out!\",\n",
        "                target_mode=\"surprised\",\n",
        "                bubble_config={\"height\": 3, \"width\": 4},\n",
        "                look_at=screen,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            Animation(screen),\n",
        "            RemovePiCreatureBubble(\n",
        "                randy, \n",
        "                target_mode=\"raise_right_hand\",\n",
        "                look_at=screen,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                mathy, \"Ah yes, consider \\\\\\\\ $x^n - 1$ over $\\\\mathds{C}$...\",\n",
        "                look_at=randy.eyes\n",
        "            ),\n",
        "            randy.change, \"happy\", mathy.eyes\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph().flip()\n",
        "        mathy = Mathematician()\n",
        "        randy.scale(0.9)\n",
        "        randy.to_edge(DOWN).shift(4 * RIGHT)\n",
        "        mathy.to_edge(DOWN).shift(4 * LEFT)\n",
        "        return randy, mathy\n",
        "\n",
        "\n",
        "class ArmedWithTwoKeyFacts(TeacherStudentsScene, DistanceProductScene):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 6,\n",
        "        \"ambient_light_config\": {\n",
        "            \"opacity_function\": inverse_power_law(1, 1, 1, 6),\n",
        "            \"radius\": 1,\n",
        "            \"num_levels\": 100,\n",
        "            \"max_opacity\": 1,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        TeacherStudentsScene.setup(self)\n",
        "        DistanceProductScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        circle1 = self.circle\n",
        "        circle1.set_height(1.5)\n",
        "        circle1.to_corner(UL)\n",
        "        circle2 = circle1.copy()\n",
        "        circle2.next_to(circle1, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        wallis_product = get_wallis_product(n_terms=8)\n",
        "\n",
        "        N = self.num_lighthouses\n",
        "        labels = VGroup()\n",
        "        for circle, f, dp in (circle1, 0.5, \"2\"), (circle2, 0, \"N\"):\n",
        "            self.circle = circle\n",
        "            lights = self.get_lights()\n",
        "            if f == 0:\n",
        "                lights.submobjects.pop(0)\n",
        "            observer = Dot(color=MAROON_B)\n",
        "            frac = f / N\n",
        "            point = self.get_circle_point_at_proportion(frac)\n",
        "            observer.move_to(point)\n",
        "            lines = self.get_distance_lines(point, line_class=DashedLine)\n",
        "\n",
        "            label = OldTexText(\"Distance product = %s\" % dp)\n",
        "            label.scale(0.7)\n",
        "            label.next_to(circle, RIGHT)\n",
        "            labels.add(label)\n",
        "\n",
        "            group = VGroup(lines, observer, label)\n",
        "            self.play(\n",
        "                FadeIn(circle),\n",
        "                LaggedStartMap(FadeIn, VGroup(*it.chain(lights))),\n",
        "                LaggedStartMap(\n",
        "                    FadeIn, VGroup(\n",
        "                        *it.chain(group.family_members_with_points()))\n",
        "                ),\n",
        "                self.teacher.change, \"raise_right_hand\",\n",
        "                self.change_students(*[\"pondering\"] * 3)\n",
        "            )\n",
        "        wallis_product.move_to(labels).to_edge(RIGHT)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, wallis_product),\n",
        "            self.teacher.change_mode, \"hooray\",\n",
        "            self.change_students(\n",
        "                *[\"thinking\"] * 3, look_at=wallis_product)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class Sailor(PiCreature):\n",
        "    CONFIG = {\n",
        "        \"flip_at_start\": True,\n",
        "        \"color\": YELLOW_D,\n",
        "        \"hat_height_factor\": 1.0 / 6,\n",
        "    }\n",
        "\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        PiCreature.__init__(self, *args, **kwargs)\n",
        "        height = self.get_height() * self.hat_height_factor\n",
        "        sailor_hat = SVGMobject(file_name=\"sailor_hat\", height=height)\n",
        "        # Rhombus is a horrible hack...\n",
        "        rhombus = Polygon(\n",
        "            UP, UP + 2 * RIGHT,\n",
        "            1.75 * RIGHT + 0.5 * UP, 0.5 * RIGHT + 0.1 * DOWN,\n",
        "            1.25 * LEFT + 0.15 * DOWN,\n",
        "        )\n",
        "        rhombus.set_fill(BLACK, opacity=1)\n",
        "        rhombus.set_stroke(width=0)\n",
        "        rhombus.set_height(sailor_hat.get_height() / 3)\n",
        "        rhombus.rotate(5 * DEGREES)\n",
        "        rhombus.move_to(sailor_hat, DR)\n",
        "        rhombus.shift(0.05 * sailor_hat.get_width() * LEFT)\n",
        "        sailor_hat.add_to_back(rhombus)\n",
        "        sailor_hat.rotate(-15 * DEGREES)\n",
        "        sailor_hat.move_to(self.eyes.get_center(), DOWN)\n",
        "        sailor_hat.shift(\n",
        "            0.1 * self.eyes.get_width() * RIGHT,\n",
        "            0.1 * self.eyes.get_height() * UP,\n",
        "        )\n",
        "        self.add(sailor_hat)\n",
        "\n",
        "\n",
        "class KeeperAndSailor(DistanceProductScene, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"num_lighthouses\": 9,\n",
        "        \"circle_radius\": 2.75,\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        \"add_lights_in_foreground\": False,  # Keep this way\n",
        "        \"text_scale_val\": 0.7,\n",
        "        \"observer_fraction\": 0.5,\n",
        "        \"keeper_color\": BLUE,\n",
        "        \"sailor_color\": YELLOW_D,\n",
        "        \"include_distance_labels_background_rectangle\": False,\n",
        "        \"big_circle_center\": FRAME_WIDTH * LEFT / 2 + SMALL_BUFF * RIGHT,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        DistanceProductScene.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.remove(*self.pi_creatures)\n",
        "\n",
        "    def construct(self):\n",
        "        self.place_lighthouses()\n",
        "        self.introduce_observers()\n",
        "        self.write_distance_product_fraction()\n",
        "        self.break_down_distance_product_by_parts()\n",
        "        self.grow_circle_and_N()\n",
        "        self.show_limit_for_each_fraction()\n",
        "        self.show_limit_of_lhs()\n",
        "\n",
        "    def place_lighthouses(self):\n",
        "        circle = self.circle\n",
        "        circle.to_corner(DL)\n",
        "        circle.shift(MED_SMALL_BUFF * UR)\n",
        "        circle.set_color(RED)\n",
        "\n",
        "        lighthouses = self.get_lighthouses()\n",
        "        lights = self.get_lights()\n",
        "        for light in lights:\n",
        "            dot = Dot(radius=0.06).move_to(light)\n",
        "            dot.match_color(light)\n",
        "            light.add_to_back(dot)\n",
        "        origin = circle.get_center()\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(0.6 * (p - origin), 0.9 * (p - origin), buff=0).shift(origin)\n",
        "            for p in self.get_lh_points()\n",
        "        ])\n",
        "        arrows.set_color(WHITE)\n",
        "\n",
        "        words = OldTexText(\"N evenly-spaced \\\\\\\\ lighthouses\")\n",
        "        words.scale(0.8)\n",
        "        words.move_to(origin)\n",
        "\n",
        "        self.add(circle)\n",
        "        if self.add_lights_in_foreground:\n",
        "            self.add_foreground_mobject(lights)\n",
        "        self.add_foreground_mobject(words)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, VGroup(*it.chain(lights))),\n",
        "            LaggedStartMap(FadeIn, lighthouses),\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "        )\n",
        "        self.remove_foreground_mobjects(words)\n",
        "        self.play(FadeOut(words), FadeOut(arrows))\n",
        "        self.wait()\n",
        "\n",
        "    def introduce_observers(self):\n",
        "        keeper, sailor = observers = self.observers\n",
        "        keeper.target_point = self.get_keeper_point()\n",
        "        sailor.target_point = self.get_sailor_point()\n",
        "\n",
        "        for pi, text in (keeper, \"Keeper\"), (sailor, \"Sailor\"):\n",
        "            pi.title = OldTexText(text)\n",
        "            pi.title.next_to(pi, DOWN)\n",
        "            pi.dot = Dot()\n",
        "            pi.dot.match_color(pi)\n",
        "            pi.dot.next_to(pi, LEFT)\n",
        "            pi.dot.set_fill(opacity=0)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            Succession, observers,\n",
        "            lambda m: (FadeIn, m, ApplyMethod, m.change, \"wave_1\")\n",
        "        ))\n",
        "        for pi in observers:\n",
        "            self.play(\n",
        "                FadeIn(pi.title),\n",
        "                pi.change, \"plain\"\n",
        "            )\n",
        "        self.wait()\n",
        "        if self.add_lights_in_foreground:\n",
        "            self.add_foreground_mobjects(keeper, keeper.dot, keeper.title)\n",
        "        for pi in observers:\n",
        "            self.play(\n",
        "                pi.set_height, 0.5,\n",
        "                pi.next_to, pi.target_point, RIGHT, SMALL_BUFF,\n",
        "                pi.dot.move_to, pi.target_point,\n",
        "                pi.dot.set_fill, {\"opacity\": 1},\n",
        "                pi.title.scale, self.text_scale_val,\n",
        "                pi.title.next_to, pi.target_point, RIGHT, {\"buff\": 0.6},\n",
        "            )\n",
        "            if pi is sailor:\n",
        "                arcs = self.get_halfway_indication_arcs()\n",
        "                self.play(*list(map(ShowCreationThenDestruction, arcs)))\n",
        "            self.wait()\n",
        "\n",
        "    def write_distance_product_fraction(self):\n",
        "        fraction = self.distance_product_fraction = OldTex(\n",
        "            \"{\\\\text{Keeper's distance product}\", \"\\\\over\",\n",
        "            \"\\\\text{Sailor's distance product}}\"\n",
        "        )\n",
        "        fraction.scale(self.text_scale_val)\n",
        "        fraction.to_corner(UR)\n",
        "\n",
        "        keeper_lines = self.get_distance_lines(\n",
        "            self.get_keeper_point(),\n",
        "            line_class=DashedLine\n",
        "        )\n",
        "        sailor_lines = self.get_distance_lines(\n",
        "            self.get_sailor_point(),\n",
        "            line_class=DashedLine\n",
        "        )\n",
        "        sailor_line_lengths = self.get_numeric_distance_labels(sailor_lines)\n",
        "        keeper_line_lengths = self.get_numeric_distance_labels(keeper_lines)\n",
        "        sailor_dp_column, keeper_dp_column = [\n",
        "            self.get_distance_product_column(\n",
        "                4 * RIGHT + 1.5 * UP, labels, frac\n",
        "            )\n",
        "            for labels, frac in [\n",
        "                (sailor_line_lengths, 0.5),\n",
        "                (keeper_line_lengths, 0),\n",
        "            ]\n",
        "        ]\n",
        "        sailor_dp_decimal = sailor_dp_column[-1]\n",
        "        sailor_dp_decimal_rect = SurroundingRectangle(sailor_dp_decimal)\n",
        "        keeper_dp_decimal = keeper_dp_column[-1]\n",
        "        keeper_dp_decimal_rect = SurroundingRectangle(keeper_dp_decimal)\n",
        "        keeper_top_zero_rect = SurroundingRectangle(keeper_dp_column[0][0])\n",
        "\n",
        "        # stacked_labels, h_line, times, product_decimal = column\n",
        "\n",
        "        # Define result fraction\n",
        "        equals = self.distance_product_equals = OldTex(\"=\")\n",
        "        result_fraction = self.result_fraction = OldTex(\n",
        "            \"{N\", \"{\\\\text{distance} \\\\choose \\\\text{between obs.}}\", \"\\\\over\", \"2}\"\n",
        "        )\n",
        "        N, dist, frac_line, two = result_fraction\n",
        "        result_fraction.to_corner(UR)\n",
        "        equals.next_to(frac_line, LEFT)\n",
        "        for part in result_fraction:\n",
        "            part.save_state()\n",
        "            part.generate_target()\n",
        "        div = OldTex(\"/\")\n",
        "        first_denom = VGroup(two.target, div, dist)\n",
        "        first_denom.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        first_denom.move_to(two, UP)\n",
        "        N.next_to(frac_line, UP, SMALL_BUFF)\n",
        "\n",
        "        # Define terms to be removed\n",
        "        first_light_group = VGroup(self.lights[0], self.lighthouses[0])\n",
        "        keeper_top_zero_group = VGroup(\n",
        "            keeper_dp_column[0][0], keeper_top_zero_rect)\n",
        "\n",
        "        new_keeper_dp_decimal = DecimalNumber(\n",
        "            self.num_lighthouses,\n",
        "            num_decimal_places=3,\n",
        "        )\n",
        "        new_keeper_dp_decimal.replace(keeper_dp_decimal, dim_to_match=1)\n",
        "        new_keeper_dp_decimal.set_color(YELLOW)\n",
        "\n",
        "        self.play(*list(map(ShowCreation, keeper_lines)))\n",
        "        self.play(ReplacementTransform(\n",
        "            keeper_lines.copy(), VGroup(fraction[0])\n",
        "        ))\n",
        "        self.play(FadeOut(keeper_lines))\n",
        "        self.play(*list(map(ShowCreation, sailor_lines)))\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                sailor_lines.copy(),\n",
        "                VGroup(fraction[2])\n",
        "            ),\n",
        "            ShowCreation(fraction[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, sailor_line_lengths))\n",
        "        self.play(ReplacementTransform(\n",
        "            sailor_line_lengths.copy(), sailor_dp_column[0]\n",
        "        ))\n",
        "        self.play(FadeIn(sailor_dp_column[1:]))\n",
        "        self.play(ShowCreation(sailor_dp_decimal_rect))\n",
        "        self.play(\n",
        "            fraction.next_to, equals, LEFT,\n",
        "            FadeIn(equals),\n",
        "            ShowCreation(frac_line),\n",
        "            ReplacementTransform(sailor_dp_decimal.copy(), two),\n",
        "            FadeOut(sailor_dp_decimal_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Note, sailor_lines and sailor_line_lengths get changed here\n",
        "        self.remove(*list(sailor_lines) + list(sailor_line_lengths))\n",
        "        self.play(\n",
        "            FadeOut(sailor_dp_column),\n",
        "            ReplacementTransform(sailor_lines.deepcopy(), keeper_lines),\n",
        "            ReplacementTransform(\n",
        "                sailor_line_lengths.deepcopy(), keeper_line_lengths),\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            keeper_line_lengths.copy(), keeper_dp_column[0]\n",
        "        ))\n",
        "        self.play(FadeIn(keeper_dp_column[1:]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(keeper_dp_decimal_rect),\n",
        "            ShowCreation(keeper_top_zero_rect)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Remove first lighthouse\n",
        "        self.play(\n",
        "            first_light_group.shift, 0.6 * FRAME_WIDTH * RIGHT,\n",
        "            keeper_top_zero_group.shift, 0.4 * FRAME_WIDTH * RIGHT,\n",
        "            FadeOut(keeper_dp_decimal),\n",
        "            FadeOut(keeper_dp_decimal_rect),\n",
        "            path_arc=-30 * DEGREES,\n",
        "            rate_func=running_start,\n",
        "        )\n",
        "        self.remove(first_light_group, keeper_top_zero_group)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            keeper_dp_column[0][1:].copy(),\n",
        "            VGroup(new_keeper_dp_decimal),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(new_keeper_dp_decimal.copy(), N,))\n",
        "        self.wait(2)\n",
        "\n",
        "        sailor_lines[0].set_color(RED)\n",
        "        sailor_line_lengths[0].set_color(RED)\n",
        "        sailor_line_lengths[0].set_stroke(RED, 1)\n",
        "        self.remove(*list(keeper_lines) + list(keeper_line_lengths))\n",
        "        self.play(\n",
        "            ReplacementTransform(keeper_lines.copy(), sailor_lines),\n",
        "            ReplacementTransform(\n",
        "                keeper_line_lengths.copy(), sailor_line_lengths),\n",
        "            FadeOut(keeper_dp_column[:-1]),\n",
        "            FadeOut(new_keeper_dp_decimal),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(sailor_line_lengths[0], 30 * DEGREES, rate_func=wiggle)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(sailor_lines[0].copy(), dist),\n",
        "            FadeIn(div),\n",
        "            MoveToTarget(two),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            two.restore,\n",
        "            FadeOut(div),\n",
        "            dist.restore,\n",
        "            N.restore,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(sailor_lines),\n",
        "            FadeOut(sailor_line_lengths),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def break_down_distance_product_by_parts(self):\n",
        "        result_fraction = self.result_fraction\n",
        "        result_fraction_rect = SurroundingRectangle(result_fraction)\n",
        "\n",
        "        product_parts = self.product_parts = OldTex(\n",
        "            \"{|L_1 - K|\", \"\\\\over\", \"|L_1 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_2 - K|\", \"\\\\over\", \"|L_2 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_3 - K|\", \"\\\\over\", \"|L_3 - S|}\", \"\\\\cdots\",\n",
        "        )\n",
        "        product_parts.set_color_by_tex_to_color_map({\n",
        "            \"K\": BLUE,\n",
        "            \"S\": YELLOW,\n",
        "        })\n",
        "        product_parts.set_width(0.4 * FRAME_WIDTH)\n",
        "        product_parts.next_to(result_fraction, DOWN, LARGE_BUFF, RIGHT)\n",
        "        product_parts.shift(MED_SMALL_BUFF * RIGHT)\n",
        "\n",
        "        sailor_lines = self.get_sailor_lines()\n",
        "        sailor_lines.save_state()\n",
        "        keeper_lines = self.get_keeper_lines()\n",
        "        keeper_lines.save_state()\n",
        "\n",
        "        sailor_length_braces = VGroup(VMobject())  # Add fluff first object\n",
        "        keeper_length_braces = VGroup(VMobject())  # Add fluff first object\n",
        "        triplets = [\n",
        "            (\"S\", sailor_length_braces, DOWN),\n",
        "            (\"K\", keeper_length_braces, UP),\n",
        "        ]\n",
        "        for char, brace_group, vect in triplets:\n",
        "            for part in product_parts.get_parts_by_tex(char):\n",
        "                brace = Brace(part, vect, buff=SMALL_BUFF)\n",
        "                brace.match_color(part)\n",
        "                brace_group.add(brace)\n",
        "\n",
        "        # Animations\n",
        "        self.replace_lighthouses_with_labels()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, product_parts),\n",
        "            LaggedStartMap(FadeIn, sailor_lines,\n",
        "                        rate_func=there_and_back, remover=True),\n",
        "            LaggedStartMap(FadeIn, keeper_lines,\n",
        "                        rate_func=there_and_back, remover=True),\n",
        "        )\n",
        "        sailor_lines.restore()\n",
        "        keeper_lines.restore()\n",
        "        self.wait()\n",
        "\n",
        "        keeper_line = self.keeper_line = keeper_lines[1].copy()\n",
        "        sailor_line = self.sailor_line = sailor_lines[1].copy()\n",
        "        keeper_brace = keeper_length_braces[1].copy()\n",
        "        sailor_brace = sailor_length_braces[1].copy()\n",
        "        self.play(\n",
        "            ShowCreation(keeper_line),\n",
        "            GrowFromCenter(keeper_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(sailor_line),\n",
        "            GrowFromCenter(sailor_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in range(2, 4):\n",
        "            self.play(\n",
        "                Transform(keeper_line, keeper_lines[i]),\n",
        "                Transform(keeper_brace, keeper_length_braces[i]),\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(sailor_line, sailor_lines[i]),\n",
        "                Transform(sailor_brace, sailor_length_braces[i]),\n",
        "            )\n",
        "            self.wait()\n",
        "        for i in range(4, self.num_lighthouses):\n",
        "            anims = [\n",
        "                Transform(keeper_line, keeper_lines[i]),\n",
        "                Transform(sailor_line, sailor_lines[i]),\n",
        "            ]\n",
        "            if i == 4:\n",
        "                anims += [\n",
        "                    FadeOut(sailor_brace),\n",
        "                    FadeOut(keeper_brace),\n",
        "                ]\n",
        "            self.play(*anims)\n",
        "        self.play(FocusOn(result_fraction))\n",
        "        self.play(ShowPassingFlash(result_fraction_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "    def grow_circle_and_N(self, circle_scale_factor=2, N_multiple=3, added_anims=None):\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "        circle = self.circle\n",
        "        lights = self.lights\n",
        "        labels = self.lighthouse_labels\n",
        "        keeper = self.keeper\n",
        "        sailor = self.sailor\n",
        "        half_N = self.num_lighthouses / 2\n",
        "\n",
        "        anims = []\n",
        "\n",
        "        circle.generate_target()\n",
        "        for pi in keeper, sailor:\n",
        "            for mob in pi, pi.dot, pi.title:\n",
        "                mob.generate_target()\n",
        "\n",
        "        circle.target.scale(circle_scale_factor)\n",
        "        circle.target.move_to(self.big_circle_center)\n",
        "        self.circle = circle.target\n",
        "        anims.append(MoveToTarget(circle))\n",
        "\n",
        "        self.num_lighthouses = int(N_multiple * self.num_lighthouses)\n",
        "        new_lights = self.get_lights()\n",
        "        for light in new_lights:\n",
        "            light.scale(1.0 / circle_scale_factor)\n",
        "        new_labels = self.get_light_labels()\n",
        "        anims.append(ReplacementTransform(labels[1:], new_labels[1:]))\n",
        "\n",
        "        if hasattr(self, \"keeper_line\"):\n",
        "            keeper_line = self.keeper_line\n",
        "            sailor_line = self.sailor_line\n",
        "            self.keeper_lines = self.get_keeper_lines()\n",
        "            self.sailor_lines = self.get_sailor_lines()\n",
        "            anims += [\n",
        "                Transform(keeper_line, self.keeper_lines[-1]),\n",
        "                Transform(sailor_line, self.sailor_lines[-1]),\n",
        "            ]\n",
        "\n",
        "        for group in lights, labels, new_lights, new_labels:\n",
        "            group[0].fade(1)\n",
        "\n",
        "        for mob in lights, labels:\n",
        "            for x in range(len(new_lights) - len(mob)):\n",
        "                mob.submobjects.insert(\n",
        "                    half_N + 1, VectorizedPoint(circle.get_left()))\n",
        "        anims.append(ReplacementTransform(lights, new_lights))\n",
        "\n",
        "        keeper.dot.target.move_to(self.get_keeper_point())\n",
        "        sailor.dot.target.move_to(self.get_sailor_point())\n",
        "        for pi in keeper, sailor:\n",
        "            pi.target.scale(0)\n",
        "            pi.target.move_to(pi.dot.target)\n",
        "            pi.title.target.scale(0.85)\n",
        "            pi.title.target.next_to(pi.dot.target, RIGHT, SMALL_BUFF)\n",
        "        anims += [\n",
        "            MoveToTarget(part)\n",
        "            for pi in self.observers\n",
        "            for part in [pi, pi.dot, pi.title]\n",
        "        ]\n",
        "\n",
        "        anims += added_anims\n",
        "\n",
        "        self.circle = circle\n",
        "\n",
        "        self.play(*anims, run_time=2)\n",
        "        if self.add_lights_in_foreground:\n",
        "            self.remove_foreground_mobjects(*self.lights)\n",
        "            self.remove_foreground_mobjects(*self.lighthouse_labels)\n",
        "            self.add_foreground_mobjects(new_lights, new_labels)\n",
        "        self.wait()\n",
        "        self.lights = new_lights\n",
        "        self.lighthouse_labels = new_labels\n",
        "\n",
        "    def show_limit_for_each_fraction(self):\n",
        "        product_parts = self.product_parts\n",
        "        keeper_line = self.keeper_line\n",
        "        keeper_lines = self.keeper_lines\n",
        "        sailor_line = self.sailor_line\n",
        "        sailor_lines = self.sailor_lines\n",
        "        labels = self.lighthouse_labels\n",
        "\n",
        "        center = self.circle.get_center()\n",
        "        center_dot = Dot(center)\n",
        "        lh_points = self.get_lh_points()\n",
        "        sailor_point = self.get_sailor_point()\n",
        "        keeper_point = self.get_keeper_point()\n",
        "\n",
        "        def get_angle_mob(p1, p2):\n",
        "            angle1 = angle_of_vector(p1 - center)\n",
        "            angle2 = angle_of_vector(p2 - center)\n",
        "            arc = Arc(start_angle=angle1, angle=(angle2 - angle1), radius=1)\n",
        "            arc.shift(center)\n",
        "            return VGroup(\n",
        "                center_dot,\n",
        "                Line(center, p1),\n",
        "                Line(center, p2),\n",
        "                arc,\n",
        "            )\n",
        "\n",
        "        angle_mob = get_angle_mob(lh_points[1], keeper_point)\n",
        "\n",
        "        ratios = VGroup(*[\n",
        "            product_parts[i:i + 3]\n",
        "            for i in [0, 4, 8]\n",
        "        ])\n",
        "        term_rects = self.get_term_rects(ratios)\n",
        "\n",
        "        limit_fractions = VGroup(\n",
        "            OldTex(\"{2\", \"\\\\over\", \"1}\"),\n",
        "            OldTex(\"{4\", \"\\\\over\", \"3}\"),\n",
        "            OldTex(\"{6\", \"\\\\over\", \"5}\"),\n",
        "        )\n",
        "        limit_arrows = VGroup()\n",
        "        for rect, fraction in zip(term_rects, limit_fractions):\n",
        "            fraction.next_to(rect, DOWN, LARGE_BUFF)\n",
        "            arrow = Arrow(rect, fraction, color=WHITE)\n",
        "            limit_arrows.add(arrow)\n",
        "\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.scale(1.5)\n",
        "        approx.rotate(90 * DEGREES)\n",
        "        approx.move_to(limit_arrows[0])\n",
        "\n",
        "        braces = self.get_all_circle_braces()\n",
        "\n",
        "        # Show first lighthouse\n",
        "        term_rect = term_rects[0].copy()\n",
        "        self.play(\n",
        "            Transform(keeper_line, keeper_lines[1]),\n",
        "            Transform(sailor_line, sailor_lines[1]),\n",
        "            FadeIn(term_rect),\n",
        "            path_arc=-180 * DEGREES\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(VGroup(keeper_line, sailor_line)),\n",
        "            FadeIn(braces[:2]),\n",
        "            FadeIn(angle_mob)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(angle_mob, get_angle_mob(\n",
        "            lh_points[1], sailor_point)))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(approx),\n",
        "            ReplacementTransform(ratios[0].copy(), limit_fractions[0]),\n",
        "            FadeOut(angle_mob)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(approx, limit_arrows[0]))\n",
        "        self.let_N_approach_infinity(braces[:2])\n",
        "\n",
        "        # Show second lighthouse\n",
        "        self.play(\n",
        "            Transform(term_rect, term_rects[1]),\n",
        "            ReplacementTransform(limit_arrows[0].copy(), limit_arrows[1]),\n",
        "            FadeIn(braces[2:4])\n",
        "        )\n",
        "        for group, color in (braces[:4], self.keeper_color), (braces[1:4], self.sailor_color):\n",
        "            self.play(\n",
        "                group.scale, 0.95, {\"about_point\": center},\n",
        "                group.set_color, color,\n",
        "                rate_func=there_and_back\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            ReplacementTransform(ratios[1].copy(), limit_fractions[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show third lighthouse\n",
        "        braces[4:6].set_color(YELLOW)\n",
        "        self.play(\n",
        "            Transform(term_rect, term_rects[2]),\n",
        "            ReplacementTransform(limit_arrows[1].copy(), limit_arrows[2]),\n",
        "            FadeIn(braces[4:6]),\n",
        "            braces[1:4].set_color, YELLOW,\n",
        "            ReplacementTransform(limit_fractions[1].copy(), limit_fractions[2])\n",
        "        )\n",
        "        self.let_N_approach_infinity(braces[:6])\n",
        "        self.wait()\n",
        "\n",
        "        # Set up for lighthouse \"before\" keeper\n",
        "        ccw_product_group = VGroup(\n",
        "            product_parts, limit_arrows, limit_fractions)\n",
        "        cw_product_parts = OldTex(\n",
        "            \"\\\\cdots\", \"{|L_{-3} - K|\", \"\\\\over\", \"|L_{-3} - S|}\",\n",
        "            \"\\\\cdot\", \"{|L_{-2} - K|\", \"\\\\over\", \"|L_{-2} - S|}\",\n",
        "            \"\\\\cdot\", \"{|L_{-1} - K|\", \"\\\\over\", \"|L_{-1} - S|}\",\n",
        "        )\n",
        "        cw_product_parts.match_height(product_parts)\n",
        "        cw_product_parts.set_color_by_tex_to_color_map({\n",
        "            \"K\": BLUE,\n",
        "            \"S\": YELLOW,\n",
        "        })\n",
        "        cw_product_parts.move_to(ratios, RIGHT)\n",
        "        cw_ratios = VGroup(*[cw_product_parts[i:i + 3] for i in (9, 5, 1)])\n",
        "        cw_term_rects = self.get_term_rects(cw_ratios)\n",
        "        cw_limit_fractions = VGroup(\n",
        "            OldTex(\"{2\", \"\\\\over\", \"3}\"),\n",
        "            OldTex(\"{4\", \"\\\\over\", \"5}\"),\n",
        "            OldTex(\"{6\", \"\\\\over\", \"7}\"),\n",
        "        )\n",
        "        cw_limit_arrows = VGroup()\n",
        "        for rect, fraction in zip(cw_term_rects, cw_limit_fractions):\n",
        "            fraction.next_to(rect, DOWN, LARGE_BUFF)\n",
        "            arrow = Arrow(rect, fraction, color=WHITE)\n",
        "            cw_limit_arrows.add(arrow)\n",
        "\n",
        "        cw_product_parts.save_state()\n",
        "        cw_product_parts.next_to(product_parts, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        cw_label_rects = self.get_term_rects(labels[-1:-5:-1])\n",
        "        cw_label_rects.set_color(RED)\n",
        "\n",
        "        braces[-8:].set_color(BLUE)\n",
        "        braces[0].set_color(YELLOW)\n",
        "\n",
        "        def show_braces(n):\n",
        "            cw_group = braces[-2 * n:]\n",
        "            for group in cw_group, VGroup(braces[0], *cw_group):\n",
        "                self.play(\n",
        "                    group.scale, 0.95, {\"about_point\": center},\n",
        "                    rate_func=there_and_back\n",
        "                )\n",
        "                self.wait(0.5)\n",
        "\n",
        "        # Animated clockwise-from-keeper terms\n",
        "        self.play(\n",
        "            ccw_product_group.scale, 0.5, {\"about_edge\": UL},\n",
        "            ccw_product_group.to_corner, UL,\n",
        "            FadeOut(term_rect),\n",
        "            FadeOut(braces[:6]),\n",
        "            cw_product_parts.restore,\n",
        "        )\n",
        "        term_rect = cw_term_rects[0].copy()\n",
        "        self.play(LaggedStartMap(ShowCreationThenDestruction, cw_label_rects))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(term_rect),\n",
        "            FadeIn(braces[-2:]),\n",
        "            FadeIn(braces[0]),\n",
        "        )\n",
        "        show_braces(1)\n",
        "        self.play(\n",
        "            GrowArrow(cw_limit_arrows[0]),\n",
        "            FadeIn(cw_limit_fractions[0])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Second and third lighthouse before\n",
        "        self.play(\n",
        "            Transform(term_rect, cw_term_rects[1]),\n",
        "            ReplacementTransform(\n",
        "                cw_limit_arrows[0].copy(), cw_limit_arrows[1]),\n",
        "            FadeIn(braces[-4:-2]),\n",
        "            Write(cw_limit_fractions[1])\n",
        "        )\n",
        "        show_braces(2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(term_rect, cw_term_rects[2]),\n",
        "            ReplacementTransform(\n",
        "                cw_limit_arrows[1].copy(), cw_limit_arrows[2]),\n",
        "            FadeIn(braces[-6:-4]),\n",
        "            Write(cw_limit_fractions[2])\n",
        "        )\n",
        "        show_braces(3)\n",
        "        self.let_N_approach_infinity(VGroup(braces[0], *braces[-6:]))\n",
        "        self.wait()\n",
        "\n",
        "        # Organize fractions\n",
        "        fractions = VGroup(*it.chain(*list(zip(\n",
        "            limit_fractions, cw_limit_fractions,\n",
        "        ))))\n",
        "        fractions.generate_target()\n",
        "        wallis_product = VGroup()\n",
        "        dots = VGroup()\n",
        "        for fraction in fractions.target:\n",
        "            fraction.match_height(cw_limit_fractions[0])\n",
        "            wallis_product.add(fraction)\n",
        "            dot = OldTex(\"\\\\cdot\")\n",
        "            wallis_product.add(dot)\n",
        "            dots.add(dot)\n",
        "        final_dot = OldTex(\"\\\\cdots\")\n",
        "        for group in wallis_product, dots:\n",
        "            group.submobjects[-1] = final_dot\n",
        "        wallis_product.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        wallis_product.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(limit_arrows),\n",
        "            FadeOut(cw_limit_arrows),\n",
        "            FadeOut(braces[-6:]),\n",
        "            FadeOut(braces[0]),\n",
        "            FadeOut(term_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            cw_product_parts.scale, 0.5,\n",
        "            cw_product_parts.next_to, product_parts, DOWN, {\n",
        "                \"aligned_edge\": LEFT},\n",
        "            MoveToTarget(fractions),\n",
        "            Write(dots),\n",
        "            run_time=2,\n",
        "            path_arc=90 * DEGREES\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.wallis_product = VGroup(dots, fractions)\n",
        "        self.observers_brace = braces[0]\n",
        "\n",
        "    def show_limit_of_lhs(self):\n",
        "        brace = self.observers_brace\n",
        "        wallis_product = self.wallis_product\n",
        "        result_fraction = self.result_fraction\n",
        "        N, dist, over, two = result_fraction\n",
        "        distance_product_equals = self.distance_product_equals\n",
        "\n",
        "        result_rect = SurroundingRectangle(result_fraction)\n",
        "        result_rect.set_color(WHITE)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(brace, LEFT, SMALL_BUFF)\n",
        "        approx1, approx2, approx3 = [Tex(\"\\\\approx\") for x in range(3)]\n",
        "        approx1.next_to(brace, LEFT, SMALL_BUFF)\n",
        "        half_two_pi_over_N = OldTex(\n",
        "            \"{1\", \"\\\\over\", \"2}\", \"{2\", \"\\\\pi\", \"\\\\over\", \"N}\",\n",
        "        )\n",
        "        pi = half_two_pi_over_N.get_part_by_tex(\"\\\\pi\")\n",
        "        half_two_pi_over_N.next_to(approx1, LEFT)\n",
        "        approx2.next_to(half_two_pi_over_N, LEFT, SMALL_BUFF)\n",
        "\n",
        "        approx3.move_to(distance_product_equals)\n",
        "\n",
        "        pi_over_N = OldTex(\"(\", \"\\\\pi\", \"/\", \"N\", \")\")\n",
        "        pi_over_N.next_to(N, RIGHT)\n",
        "        N_shift = MED_LARGE_BUFF * RIGHT\n",
        "        pi_over_N.shift(N_shift)\n",
        "\n",
        "        pi_halves = OldTex(\"{\\\\pi\", \"\\\\over\", \"2}\")\n",
        "        pi_halves.next_to(result_rect, DOWN, LARGE_BUFF)\n",
        "        pi_halves.shift(RIGHT)\n",
        "        pi_halves_arrow = Arrow(\n",
        "            result_rect.get_bottom(),\n",
        "            pi_halves.get_top(),\n",
        "            color=WHITE,\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        last_equals = OldTex(\"=\")\n",
        "        last_equals.next_to(pi_halves, LEFT)\n",
        "\n",
        "        self.play(ShowCreation(result_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dist.next_to, equals, LEFT,\n",
        "            FadeIn(equals),\n",
        "            GrowFromCenter(brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        approx2.next_to(dist, LEFT, SMALL_BUFF)\n",
        "        half_two_pi_over_N.next_to(approx2, LEFT)\n",
        "        self.play(\n",
        "            Write(half_two_pi_over_N),\n",
        "            FadeIn(approx2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(half_two_pi_over_N[:4]),\n",
        "            pi.shift, SMALL_BUFF * LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                half_two_pi_over_N[-3:].copy(),\n",
        "                pi_over_N[1:4]\n",
        "            ),\n",
        "            FadeIn(pi_over_N[0]),\n",
        "            FadeIn(pi_over_N[-1]),\n",
        "            N.shift, N_shift * RIGHT,\n",
        "            ReplacementTransform(distance_product_equals, approx3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(pi_halves_arrow),\n",
        "            wallis_product.shift, DOWN,\n",
        "        )\n",
        "        self.play(Write(pi_halves))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            wallis_product.next_to, last_equals, LEFT, 2 * SMALL_BUFF,\n",
        "            FadeIn(last_equals)\n",
        "        )\n",
        "        final_rect = SurroundingRectangle(\n",
        "            VGroup(wallis_product, pi_halves),\n",
        "            buff=MED_SMALL_BUFF\n",
        "        )\n",
        "        final_rect.set_color(YELLOW)\n",
        "        self.play(ShowCreation(final_rect))\n",
        "        self.wait(2)\n",
        "\n",
        "    #\n",
        "\n",
        "    def let_N_approach_infinity(self, braces=None, factor=4, run_time=5, zoom_in_after=False):\n",
        "        lights = self.lights\n",
        "        labels = self.lighthouse_labels\n",
        "        keeper, sailor = self.observers\n",
        "        circle = self.circle\n",
        "\n",
        "        if braces is None:\n",
        "            braces = VGroup()\n",
        "\n",
        "        start_fraction = 1.0 / self.num_lighthouses\n",
        "        target_fraction = start_fraction / factor\n",
        "        half_N = self.num_lighthouses / 2\n",
        "\n",
        "        fraction_tracker = ValueTracker(start_fraction)\n",
        "\n",
        "        def get_fraction():\n",
        "            return fraction_tracker.get_value()\n",
        "\n",
        "        def get_ks_distance():\n",
        "            return get_norm(keeper.dot.get_center() - sailor.dot.get_center())\n",
        "\n",
        "        def update_title_heights(*titles):\n",
        "            for title in titles:\n",
        "                if not hasattr(title, \"original_height\"):\n",
        "                    title.original_height = title.get_height()\n",
        "                title.set_height(min(\n",
        "                    title.original_height,\n",
        "                    0.8 * get_ks_distance(),\n",
        "                ))\n",
        "            if len(titles) > 1:\n",
        "                return titles\n",
        "            else:\n",
        "                return titles[0]\n",
        "\n",
        "        initial_light_width = lights[0].get_width()\n",
        "\n",
        "        def update_lights(lights):\n",
        "            for k in range(-half_N, half_N + 1):\n",
        "                if k == 0:\n",
        "                    continue\n",
        "                light = lights[k]\n",
        "                light = light.set_width(\n",
        "                    (get_fraction() / start_fraction) * initial_light_width\n",
        "                )\n",
        "                point = self.get_circle_point_at_proportion(k * get_fraction())\n",
        "                light.move_source_to(point)\n",
        "            return lights\n",
        "\n",
        "        def update_braces(braces):\n",
        "            for brace in braces:\n",
        "                f1 = brace.fraction1 * (get_fraction() / start_fraction)\n",
        "                f2 = brace.fraction2 * (get_fraction() / start_fraction)\n",
        "                new_brace = self.get_circle_brace(f1, f2)\n",
        "                new_brace.match_style(brace)\n",
        "                Transform(brace, new_brace).update(1)\n",
        "            return braces\n",
        "\n",
        "        light_update_anim = UpdateFromFunc(lights, update_lights)\n",
        "        label_update_anim = UpdateFromFunc(\n",
        "            labels,\n",
        "            lambda ls: self.position_labels_outside_lights(\n",
        "                update_title_heights(*ls)),\n",
        "        )\n",
        "        sailor_dot_anim = UpdateFromFunc(\n",
        "            sailor.dot,\n",
        "            lambda d: d.move_to(\n",
        "                self.get_circle_point_at_proportion(get_fraction() / 2))\n",
        "        )\n",
        "        sailor_title_anim = UpdateFromFunc(\n",
        "            sailor.title,\n",
        "            lambda m: update_title_heights(m).next_to(\n",
        "                sailor.dot, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "        keeper_title_anim = UpdateFromFunc(\n",
        "            keeper.title,\n",
        "            lambda m: update_title_heights(m).next_to(\n",
        "                keeper.dot, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "        braces_update_anim = UpdateFromFunc(braces, update_braces)\n",
        "\n",
        "        lights[0].fade(1)\n",
        "        labels[0].fade(1)\n",
        "\n",
        "        all_updates = [\n",
        "            light_update_anim,\n",
        "            label_update_anim,\n",
        "            sailor_dot_anim,\n",
        "            sailor_title_anim,\n",
        "            keeper_title_anim,\n",
        "            braces_update_anim,\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            fraction_tracker.set_value, target_fraction,\n",
        "            *all_updates,\n",
        "            run_time=run_time\n",
        "        )\n",
        "        if zoom_in_after:\n",
        "            self.play(\n",
        "                circle.scale, factor, {\"about_point\": circle.get_right()},\n",
        "                *all_updates,\n",
        "                run_time=1\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                circle.scale, 1.0 /\n",
        "                factor, {\"about_point\": circle.get_right()},\n",
        "                *all_updates,\n",
        "                run_time=1\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            fraction_tracker.set_value, start_fraction,\n",
        "            *all_updates,\n",
        "            run_time=run_time / 2\n",
        "        )\n",
        "\n",
        "    def get_keeper_point(self):\n",
        "        return self.get_circle_point_at_proportion(0)\n",
        "\n",
        "    def get_sailor_point(self):\n",
        "        return self.get_circle_point_at_proportion(0.5 / self.num_lighthouses)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        keeper = self.keeper = PiCreature(color=self.keeper_color).flip()\n",
        "        sailor = self.sailor = Sailor()\n",
        "        observers = self.observers = VGroup(keeper, sailor)\n",
        "        observers.set_height(3)\n",
        "        keeper.shift(4 * RIGHT + 2 * DOWN)\n",
        "        sailor.shift(4 * RIGHT + 2 * UP)\n",
        "        return VGroup(keeper, sailor)\n",
        "\n",
        "    def replace_lighthouses_with_labels(self):\n",
        "        lighthouse_labels = self.get_light_labels()\n",
        "        self.lighthouse_labels = lighthouse_labels\n",
        "\n",
        "        self.remove(self.lights[0], self.lighthouses[0])\n",
        "        self.play(\n",
        "            FadeOut(self.lighthouses[1:]),\n",
        "            FadeIn(lighthouse_labels[1:]),\n",
        "        )\n",
        "\n",
        "    def get_light_labels(self):\n",
        "        labels = VGroup()\n",
        "        for count, point in enumerate(self.get_lh_points()):\n",
        "            if count > self.num_lighthouses / 2:\n",
        "                count -= self.num_lighthouses\n",
        "            label = OldTex(\"L_{%d}\" % count)\n",
        "            label.scale(0.8)\n",
        "            labels.add(label)\n",
        "        self.position_labels_outside_lights(labels)\n",
        "        return labels\n",
        "\n",
        "    def position_labels_outside_lights(self, labels):\n",
        "        center = self.circle.get_center()\n",
        "        for light, label in zip(self.lights, labels):\n",
        "            point = light[0].get_center()\n",
        "            vect = (point - center)\n",
        "            norm = get_norm(vect)\n",
        "            buff = label.get_height()\n",
        "            vect *= (norm + buff) / norm\n",
        "            label.move_to(center + vect)\n",
        "        return labels\n",
        "\n",
        "    def get_keeper_lines(self, line_class=Line):\n",
        "        lines = self.get_distance_lines(self.get_keeper_point())\n",
        "        lines.set_stroke(self.keeper_color, 3)\n",
        "        return lines\n",
        "\n",
        "    def get_sailor_lines(self, line_class=Line):\n",
        "        lines = self.get_distance_lines(self.get_sailor_point())\n",
        "        lines.set_stroke(self.sailor_color, 3)\n",
        "        return lines\n",
        "\n",
        "    def get_term_rects(self, terms):\n",
        "        return VGroup(*[\n",
        "            SurroundingRectangle(term, color=WHITE)\n",
        "            for term in terms\n",
        "        ])\n",
        "\n",
        "    def get_circle_brace(self, f1, f2):\n",
        "        line = Line(\n",
        "            self.get_circle_point_at_proportion(f1),\n",
        "            self.get_circle_point_at_proportion(f2),\n",
        "        )\n",
        "        angle = (line.get_angle() + TAU / 2) % TAU\n",
        "        scale_factor = 1.5\n",
        "        line.rotate(-angle, about_point=ORIGIN)\n",
        "        line.scale(scale_factor, about_point=ORIGIN)\n",
        "        brace = Brace(line, DOWN, buff=SMALL_BUFF)\n",
        "        group = VGroup(line, brace)\n",
        "        group.scale(1.0 / scale_factor, about_point=ORIGIN)\n",
        "        group.rotate(angle, about_point=ORIGIN)\n",
        "\n",
        "        # Keep track of a fraction between -0.5 and 0.5\n",
        "        if f1 > 0.5:\n",
        "            f1 -= 1\n",
        "        if f2 > 0.5:\n",
        "            f2 -= 1\n",
        "        brace.fraction1 = f1\n",
        "        brace.fraction2 = f2\n",
        "        return brace\n",
        "\n",
        "    def get_all_circle_braces(self):\n",
        "        fractions = np.linspace(0, 1, 2 * self.num_lighthouses + 1)\n",
        "        return VGroup(*[\n",
        "            self.get_circle_brace(f1, f2)\n",
        "            for f1, f2 in zip(fractions, fractions[1:])\n",
        "        ])\n",
        "\n",
        "\n",
        "class MentionJohnWallis(Scene):\n",
        "    def construct(self):\n",
        "        product = get_wallis_product(10)\n",
        "        product.to_edge(UP)\n",
        "\n",
        "        name = OldTexText(\"``Wallis product''\")\n",
        "        name.scale(1.5)\n",
        "        name.set_color(BLUE)\n",
        "        name.next_to(product, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        image = ImageMobject(\"John_Wallis\")\n",
        "        image.set_height(3)\n",
        "        image.next_to(name, DOWN)\n",
        "        image_name = OldTexText(\"John Wallis\")\n",
        "        image_name.next_to(image, DOWN)\n",
        "\n",
        "        infinity = OldTex(\"\\\\infty\")\n",
        "        infinity.set_height(1.5)\n",
        "        infinity.next_to(image, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(product)\n",
        "        self.wait()\n",
        "        self.play(Write(name))\n",
        "        self.play(GrowFromEdge(image, UP))\n",
        "        self.play(Write(image_name))\n",
        "        self.wait(2)\n",
        "        self.play(Write(infinity, run_time=3))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class HowThisArgumentRequiresCommunitingLimits(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        mathy, morty = self.pi_creatures\n",
        "\n",
        "        scale_val = 0.7\n",
        "        factors = OldTex(\n",
        "            \"{|L_1 - K|\", \"\\\\over\", \"|L_1 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_{-1} - K|\", \"\\\\over\", \"|L_{-1} - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_2 - K|\", \"\\\\over\", \"|L_2 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_{-2} - K|\", \"\\\\over\", \"|L_{-2} - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_3 - K|\", \"\\\\over\", \"|L_3 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_{-3} - K|\", \"\\\\over\", \"|L_{-3} - S|}\", \"\\\\cdots\",\n",
        "        )\n",
        "        factors.set_color_by_tex_to_color_map({\n",
        "            \"K\": BLUE,\n",
        "            \"S\": YELLOW,\n",
        "        })\n",
        "        equals = OldTex(\"=\")\n",
        "        result = OldTex(\n",
        "            \"{N\", \"{\\\\text{distance} \\\\choose \\\\text{between obs.}}\",\n",
        "            \"\\\\over\", \"2}\"\n",
        "        )\n",
        "\n",
        "        top_line = VGroup(factors, equals, result)\n",
        "        top_line.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        result.shift(SMALL_BUFF * UP)\n",
        "        top_line.scale(scale_val)\n",
        "        top_line.to_edge(UP)\n",
        "\n",
        "        fractions = VGroup(*[\n",
        "            factors[i:i + 3]\n",
        "            for i in range(0, len(factors), 4)\n",
        "        ])\n",
        "        fraction_limit_arrows = VGroup(*[\n",
        "            Vector(0.5 * DOWN).next_to(fraction, DOWN)\n",
        "            for fraction in fractions\n",
        "        ])\n",
        "        fraction_limit_arrows.set_color(WHITE)\n",
        "\n",
        "        wallis_product = get_wallis_product(6)\n",
        "        fraction_limits = VGroup(*[\n",
        "            wallis_product[i:i + 3]\n",
        "            for i in range(0, 4 * 6, 4)\n",
        "        ])\n",
        "        for lf, arrow in zip(fraction_limits, fraction_limit_arrows):\n",
        "            lf.next_to(arrow, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        result_limit_arrow = fraction_limit_arrows[0].copy()\n",
        "        result_limit_arrow.next_to(result, DOWN)\n",
        "        result_limit_arrow.align_to(fraction_limit_arrows[0])\n",
        "\n",
        "        result_limit = wallis_product[-3:]\n",
        "        result_limit.next_to(result_limit_arrow, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        lower_equals = OldTex(\"=\")\n",
        "        lower_equals.next_to(result_limit, LEFT)\n",
        "\n",
        "        mult_signs = VGroup()\n",
        "        for f1, f2 in zip(fraction_limits, fraction_limits[1:]):\n",
        "            mult_sign = OldTex(\"\\\\times\")\n",
        "            mult_sign.move_to(VGroup(f1, f2))\n",
        "            mult_signs.add(mult_sign)\n",
        "        cdots = OldTex(\"\\\\cdots\")\n",
        "        cdots.move_to(VGroup(fraction_limits[-1], lower_equals))\n",
        "        mult_signs.add(cdots)\n",
        "\n",
        "        # Pi creatures react\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                mathy,\n",
        "                \"Whoa whoa whoa \\\\\\\\ there buddy\",\n",
        "                look_at=morty.eyes,\n",
        "                target_mode=\"sassy\",\n",
        "            ),\n",
        "            morty.change, \"guilty\", mathy.eyes,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Write out commutative diagram\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                mathy,\n",
        "                target_mode=\"raise_right_hand\",\n",
        "                look_at=factors,\n",
        "            ),\n",
        "            morty.change, \"pondering\", factors,\n",
        "            LaggedStartMap(FadeIn, factors),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(equals),\n",
        "            Write(result)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, fraction_limit_arrows),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, fraction_limits,\n",
        "                direction=UP\n",
        "            ),\n",
        "            run_time=4,\n",
        "            lag_ratio=0.25,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, mult_signs),\n",
        "            FadeIn(lower_equals),\n",
        "            mathy.change, \"sassy\",\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(result_limit_arrow),\n",
        "            FadeIn(result_limit, direction=UP),\n",
        "            morty.change, \"confused\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Write general limit rule\n",
        "        limit_rule = OldTex(\n",
        "            \"\\\\left( \\\\lim_{N \\\\to \\\\infty} a_N^{(1)} \\\\right)\",\n",
        "            \"\\\\left( \\\\lim_{N \\\\to \\\\infty} a_N^{(2)} \\\\right)\",\n",
        "            \"\\\\cdots\", \"=\",\n",
        "            \"\\\\lim_{N \\\\to \\\\infty} \\\\left( a_N^{(1)} a_N^{(2)} \\\\cdots \\\\right)\"\n",
        "        )\n",
        "        limit_rule.next_to(self.pi_creatures, UP)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.set_color(YELLOW)\n",
        "        limit_equals = limit_rule.get_part_by_tex(\"=\")\n",
        "        q_marks.next_to(limit_equals, UP, SMALL_BUFF)\n",
        "\n",
        "        index_of_equals = limit_rule.index_of_part(limit_equals)\n",
        "        lhs_brace = Brace(limit_rule[:index_of_equals], UP)\n",
        "        rhs_brace = Brace(limit_rule[index_of_equals + 1:], UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(limit_rule),\n",
        "            mathy.change, \"angry\",\n",
        "            morty.change, \"erm\",\n",
        "        )\n",
        "        self.play(GrowFromCenter(lhs_brace))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(lhs_brace, rhs_brace))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(rhs_brace), Write(q_marks))\n",
        "        limit_rule.add(q_marks)\n",
        "        self.wait(2)\n",
        "        self.play(morty.change, \"pondering\")\n",
        "        self.play(mathy.change, \"tease\")\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Animation(limit_rule),\n",
        "            morty.change, \"pondering\",\n",
        "            mathy.change, \"pondering\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Write dominated convergence\n",
        "        mover = VGroup(\n",
        "            top_line, fraction_limits, fraction_limit_arrows,\n",
        "            mult_signs, lower_equals,\n",
        "            result_limit, result_limit_arrow,\n",
        "        )\n",
        "        self.play(\n",
        "            mover.next_to, FRAME_HEIGHT * UP / 2, UP,\n",
        "            limit_rule.to_edge, UP,\n",
        "        )\n",
        "        dominated_convergence = OldTexText(\"``Dominated convergence''\")\n",
        "        dominated_convergence.set_color(BLUE)\n",
        "        dominated_convergence.next_to(limit_rule, DOWN, LARGE_BUFF)\n",
        "\n",
        "        see_blog_post = OldTexText(\"(See supplementary blog post)\")\n",
        "        see_blog_post.next_to(dominated_convergence, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(dominated_convergence),\n",
        "            mathy.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(morty.change, \"thinking\")\n",
        "        self.wait()\n",
        "        self.play(Write(see_blog_post))\n",
        "        self.wait(4)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        group = VGroup(PiCreature(color=GREY), Mortimer())\n",
        "        group.set_height(2)\n",
        "        group.arrange(RIGHT, buff=4)\n",
        "        group.to_edge(DOWN)\n",
        "        return group\n",
        "\n",
        "\n",
        "class NonCommunitingLimitsExample(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_terms_per_row\": 6,\n",
        "        \"num_rows\": 5,\n",
        "        \"x_spacing\": 0.75,\n",
        "        \"y_spacing\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        rows = VGroup(*[\n",
        "            self.get_row(seven_index)\n",
        "            for seven_index in range(self.num_rows)\n",
        "        ])\n",
        "        rows.add(self.get_v_dot_row())\n",
        "        for n, row in enumerate(rows):\n",
        "            row.move_to(n * self.y_spacing * DOWN)\n",
        "        rows.center().to_edge(UP)\n",
        "        rows[-1].shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        row_rects = VGroup(*list(map(SurroundingRectangle, rows[:-1])))\n",
        "        row_rects.set_color(YELLOW)\n",
        "\n",
        "        columns = VGroup(*[\n",
        "            VGroup(*[row[0][i] for row in rows])\n",
        "            for i in range(len(rows[0][0]))\n",
        "        ])\n",
        "        column_rects = VGroup(*list(map(SurroundingRectangle, columns)))\n",
        "        column_rects.set_color(BLUE)\n",
        "\n",
        "        row_arrows = VGroup(*[\n",
        "            OldTex(\"\\\\rightarrow\").next_to(row, RIGHT)\n",
        "            for row in rows[:-1]\n",
        "        ])\n",
        "        row_products = VGroup(*[\n",
        "            Integer(7).next_to(arrow)\n",
        "            for arrow in row_arrows\n",
        "        ])\n",
        "        row_products.set_color(YELLOW)\n",
        "\n",
        "        row_product_limit_dots = OldTex(\"\\\\vdots\")\n",
        "        row_product_limit_dots.next_to(row_products, DOWN)\n",
        "        row_product_limit = Integer(7)\n",
        "        row_product_limit.set_color(YELLOW)\n",
        "        row_product_limit.next_to(row_product_limit_dots, DOWN)\n",
        "\n",
        "        column_arrows = VGroup(*[\n",
        "            OldTex(\"\\\\downarrow\").next_to(part, DOWN, SMALL_BUFF)\n",
        "            for part in rows[-1][0]\n",
        "        ])\n",
        "        column_limits = VGroup(*[\n",
        "            Integer(1).next_to(arrow, DOWN)\n",
        "            for arrow in column_arrows\n",
        "        ])\n",
        "        column_limits.set_color(BLUE)\n",
        "        column_limit_dots = self.get_row_dots(column_limits)\n",
        "\n",
        "        column_limits_arrow = OldTex(\"\\\\rightarrow\").next_to(\n",
        "            column_limit_dots, RIGHT\n",
        "        )\n",
        "        product_of_limits = Integer(1).next_to(column_limits_arrow, RIGHT)\n",
        "        product_of_limits.set_color(BLUE)\n",
        "\n",
        "        self.add(rows)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, row_rects))\n",
        "        self.wait(2)\n",
        "        row_products_iter = iter(row_products)\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, row_arrows),\n",
        "            LaggedStartMap(\n",
        "                ReplacementTransform, rows[:-1].copy(),\n",
        "                lambda r: (r, next(row_products_iter))\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(row_product_limit_dots))\n",
        "        self.play(Write(row_product_limit))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, row_rects))\n",
        "        self.play(LaggedStartMap(FadeIn, column_rects))\n",
        "        self.wait()\n",
        "        column_limit_iter = iter(column_limits)\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, column_arrows),\n",
        "            LaggedStartMap(\n",
        "                ReplacementTransform, columns.copy(),\n",
        "                lambda c: (c, next(column_limit_iter))\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(column_limits_arrow))\n",
        "        self.play(\n",
        "            Write(product_of_limits),\n",
        "            FadeOut(row_product_limit)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def get_row(self, seven_index):\n",
        "        terms = [1] * (self.num_terms_per_row)\n",
        "        if seven_index < len(terms):\n",
        "            terms[seven_index] = 7\n",
        "        row = VGroup(*list(map(Integer, terms)))\n",
        "        self.arrange_row(row)\n",
        "        dots = self.get_row_dots(row)\n",
        "\n",
        "        return VGroup(row, dots)\n",
        "\n",
        "    def get_v_dot_row(self):\n",
        "        row = VGroup(*[\n",
        "            OldTex(\"\\\\vdots\")\n",
        "            for x in range(self.num_terms_per_row)\n",
        "        ])\n",
        "        self.arrange_row(row)\n",
        "        dots = self.get_row_dots(row)\n",
        "        dots.fade(1)\n",
        "        return VGroup(row, dots)\n",
        "\n",
        "    def arrange_row(self, row):\n",
        "        for n, part in enumerate(row):\n",
        "            part.move_to(n * self.x_spacing * RIGHT)\n",
        "\n",
        "    def get_row_dots(self, row):\n",
        "        dots = VGroup()\n",
        "        for p1, p2 in zip(row, row[1:]):\n",
        "            dots.add(OldTex(\"\\\\cdot\").move_to(VGroup(p1, p2)))\n",
        "        dots.add(OldTex(\"\\\\cdots\").next_to(row, RIGHT))\n",
        "        return dots\n",
        "\n",
        "\n",
        "class DelicacyInIntermixingSeries(Scene):\n",
        "    def construct(self):\n",
        "        n_terms = 6\n",
        "\n",
        "        top_product, bottom_product = products = VGroup(*[\n",
        "            OldTex(*it.chain(*[\n",
        "                [\"{%d\" % (2 * x), \"\\\\over\", \"%d}\" % (2 * x + u), \"\\\\cdot\"]\n",
        "                for x in range(1, n_terms + 1)\n",
        "            ]))\n",
        "            for u in (-1, 1)\n",
        "        ])\n",
        "        top_product.set_color(GREEN)\n",
        "        bottom_product.set_color(BLUE)\n",
        "        top_product.to_edge(UP)\n",
        "        bottom_product.next_to(top_product, DOWN, LARGE_BUFF)\n",
        "\n",
        "        infinity = OldTex(\"\\\\infty\")\n",
        "        top_product.limit = infinity\n",
        "        zero = OldTex(\"0\")\n",
        "        bottom_product.limit = zero\n",
        "\n",
        "        for product in products:\n",
        "            cdots = OldTex(\"\\\\cdots\")\n",
        "            cdots.move_to(product[-1], LEFT)\n",
        "            cdots.match_color(product)\n",
        "            product.submobjects[-1] = cdots\n",
        "            product.parts = VGroup(*[\n",
        "                product[i:i + 4]\n",
        "                for i in range(0, len(product), 4)\n",
        "            ])\n",
        "            arrow = Vector(0.75 * RIGHT)\n",
        "            arrow.set_color(WHITE)\n",
        "            arrow.next_to(product, RIGHT)\n",
        "            product.arrow = arrow\n",
        "            product.limit.next_to(arrow, RIGHT)\n",
        "            product.limit.match_color(product)\n",
        "\n",
        "        group = VGroup(products, infinity)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.stretch_to_fit_width(group.get_width() + LARGE_BUFF)\n",
        "        h_line.next_to(group, DOWN, aligned_edge=RIGHT)\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        times.next_to(h_line, UP, aligned_edge=LEFT)\n",
        "        q_marks = OldTex(\"?????\")\n",
        "        q_marks.set_color_by_gradient(BLUE, YELLOW)\n",
        "        q_marks.scale(2)\n",
        "        q_marks.next_to(h_line, DOWN)\n",
        "\n",
        "        # Show initial products\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, top_product),\n",
        "            LaggedStartMap(FadeIn, bottom_product),\n",
        "        )\n",
        "        self.wait()\n",
        "        for product in products:\n",
        "            self.play(\n",
        "                GrowArrow(product.arrow),\n",
        "                FadeIn(product.limit, direction=LEFT)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            Write(times),\n",
        "            ShowCreation(h_line)\n",
        "        )\n",
        "        self.play(Write(q_marks, run_time=3))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show alternate interweaving\n",
        "        top_parts_iter = iter(top_product.parts)\n",
        "        bottom_parts_iter = iter(bottom_product.parts)\n",
        "        movers1 = VGroup()\n",
        "        while True:\n",
        "            try:\n",
        "                new_terms = [\n",
        "                    next(bottom_parts_iter),\n",
        "                    next(top_parts_iter),\n",
        "                    next(top_parts_iter),\n",
        "                ]\n",
        "                movers1.add(*new_terms)\n",
        "            except StopIteration:\n",
        "                break\n",
        "        new_product = VGroup()\n",
        "        movers1.save_state()\n",
        "        for mover in movers1:\n",
        "            mover.generate_target()\n",
        "            new_product.add(mover.target)\n",
        "        new_product.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        new_product.next_to(h_line, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        new_arrow = top_product.arrow.copy()\n",
        "        new_arrow.next_to(new_product, RIGHT)\n",
        "\n",
        "        ghost_top = top_product.copy().fade()\n",
        "        ghost_bottom = bottom_product.copy().fade()\n",
        "        self.add(ghost_top, top_product)\n",
        "        self.add(ghost_bottom, bottom_product)\n",
        "\n",
        "        new_limit = OldTex(\"\\\\frac{\\\\pi}{2}\", \"\\\\sqrt{2}\")\n",
        "        new_limit.next_to(new_arrow, RIGHT)\n",
        "\n",
        "        randy = Randolph(height=1.5)\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR)\n",
        "\n",
        "        movers2 = VGroup(*it.chain(*list(zip(\n",
        "            top_product.parts, bottom_product.parts\n",
        "        ))))\n",
        "        final_product = VGroup()\n",
        "        for mover in movers2:\n",
        "            mover.final_position = mover.copy()\n",
        "            if mover is movers2[-2]:\n",
        "                # Excessive ellipses\n",
        "                final_dot = mover.final_position[-1][0]\n",
        "                mover.final_position.submobjects[-1] = final_dot\n",
        "            final_product.add(mover.final_position)\n",
        "        final_product.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        final_product.move_to(new_product, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(q_marks),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, movers1,\n",
        "                run_time=5,\n",
        "                lag_ratio=0.2,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(new_arrow),\n",
        "            FadeIn(new_limit, LEFT),\n",
        "            bottom_product.parts[3:].fade, 1,\n",
        "        )\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", new_limit)\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            Transform, movers2,\n",
        "            lambda m: (m, m.final_position),\n",
        "            run_time=3,\n",
        "            path_arc=TAU / 4,\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeOut(new_limit[1]),\n",
        "            randy.change, \"pondering\", new_limit\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class JustTechnicalities(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"These are just \\\\\\\\ technicalities\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"happy\")\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            self.teacher, target_mode=\"raise_right_hand\",\n",
        "        ))\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class KeeperAndSailorForSineProduct(KeeperAndSailor):\n",
        "    CONFIG = {\n",
        "        # \"ambient_light_config\": CHEAP_AMBIENT_LIGHT_CONFIG,\n",
        "        \"new_sailor_fraction\": 0.7,\n",
        "        \"big_circle_center\": FRAME_WIDTH * LEFT / 2 + 2.6 * LEFT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Rerun old animation (probably to be skipped)g\n",
        "        self.force_skipping()\n",
        "        self.place_lighthouses()\n",
        "        self.introduce_observers()\n",
        "        self.write_distance_product_fraction()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        # New animations\n",
        "        self.replace_lighthouses_with_labels()\n",
        "        self.move_sailor_to_new_spot()\n",
        "        self.show_new_distance_product()\n",
        "        self.show_new_limit_of_ratio()\n",
        "        self.show_new_infinite_product()\n",
        "\n",
        "    def move_sailor_to_new_spot(self):\n",
        "        sailor = self.sailor\n",
        "        fraction = self.new_sailor_fraction\n",
        "        self.get_sailor_point = lambda: self.get_circle_point_at_proportion(\n",
        "            fraction / self.num_lighthouses\n",
        "        )\n",
        "        target_point = self.get_sailor_point()\n",
        "\n",
        "        brace1 = self.get_circle_brace(0, 0.5 / self.num_lighthouses)\n",
        "        brace2 = self.get_circle_brace(0, fraction / self.num_lighthouses)\n",
        "\n",
        "        center = self.circle.get_center()\n",
        "        radius = self.get_radius()\n",
        "\n",
        "        def warp_func(point):\n",
        "            vect = point - center\n",
        "            norm = get_norm(vect)\n",
        "            new_norm = norm + 0.5 * (radius - norm)\n",
        "            return center + new_norm * vect / norm\n",
        "        brace1.apply_function(warp_func)\n",
        "        brace2.apply_function(warp_func)\n",
        "\n",
        "        scale_val = 0.7\n",
        "        words1 = OldTexText(\"Instead of\", \"$\\\\frac{1}{2}$\")\n",
        "        words1.set_color_by_tex(\"$\", YELLOW)\n",
        "        words1.scale(scale_val)\n",
        "        words1.next_to(brace1.get_center(), LEFT)\n",
        "        words2 = OldTexText(\"Some other fraction\", \"$f$\")\n",
        "        words2.set_color_by_tex(\"$\", GREEN)\n",
        "        words2.scale(scale_val)\n",
        "        words2.next_to(brace2.get_center(), LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace1),\n",
        "            Write(words1, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            sailor.dot.move_to, target_point,\n",
        "            sailor.dot.set_color, GREEN,\n",
        "            sailor.set_color, GREEN,\n",
        "            MaintainPositionRelativeTo(sailor, sailor.dot),\n",
        "            MaintainPositionRelativeTo(sailor.title, sailor),\n",
        "            ReplacementTransform(brace1, brace2),\n",
        "            ReplacementTransform(words1, words2),\n",
        "            run_time=1.5\n",
        "        )\n",
        "\n",
        "        self.fraction_label_group = VGroup(brace2, words2)\n",
        "\n",
        "    def show_new_distance_product(self):\n",
        "        result_fraction = self.result_fraction\n",
        "        N, dist, over, two = result_fraction\n",
        "        sailor_dp = self.distance_product_fraction[-1]\n",
        "        sailor_dp_rect = SurroundingRectangle(sailor_dp)\n",
        "        sailor_dp_rect.set_color(GREEN)\n",
        "\n",
        "        sailor_lines = self.get_distance_lines(\n",
        "            self.sailor.dot.get_center(), line_class=DashedLine\n",
        "        )\n",
        "        chord_f = OldTexText(\"Chord(\", \"$f$\", \")\", arg_separator=\"\")\n",
        "        chord_f.set_color_by_tex(\"$f$\", GREEN)\n",
        "        chord_f.move_to(two, UP)\n",
        "\n",
        "        two_cross = Cross(SurroundingRectangle(two))\n",
        "        two_group = VGroup(two, two_cross)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sailor_dp_rect),\n",
        "            LaggedStartMap(ShowCreation, sailor_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(two_cross))\n",
        "        self.play(\n",
        "            two_group.next_to, chord_f, DOWN,\n",
        "            ReplacementTransform(\n",
        "                VGroup(\n",
        "                    sailor_dp[:-6].copy(),\n",
        "                    sailor_dp[-6:-4].copy(),\n",
        "                    sailor_dp[-4:-2].copy(),\n",
        "                    sailor_dp[-2:].copy(),\n",
        "                ),\n",
        "                chord_f\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            sailor_lines, sailor_dp_rect, two_group\n",
        "        )))\n",
        "\n",
        "        result_fraction.submobjects[-1] = chord_f\n",
        "\n",
        "    def show_new_limit_of_ratio(self):\n",
        "        fraction_label_group = self.fraction_label_group\n",
        "        fraction_brace, fraction_words = fraction_label_group\n",
        "\n",
        "        frac1 = OldTex(\n",
        "            \"{N\", \"(\", \"f\", \" \\\\cdot 2\\\\pi / N)\", \"\\\\over\",\n",
        "            \"\\\\text{Chord}(\", \"f\", \")}\"\n",
        "        )\n",
        "        frac2 = OldTex(\n",
        "            \"{f\", \"\\\\cdot\", \"2\", \"\\\\pi\", \"\\\\over\",\n",
        "            \"\\\\text{Chord}(\", \"f\", \")}\"\n",
        "        )\n",
        "        for frac in frac1, frac2:\n",
        "            frac.set_color_by_tex(\"f\", GREEN, substring=False)\n",
        "        arrow1, arrow2 = [\n",
        "            Vector(0.75 * DOWN, color=WHITE)\n",
        "            for x in range(2)\n",
        "        ]\n",
        "\n",
        "        group = VGroup(arrow1, frac1, arrow2, frac2)\n",
        "        group.arrange(DOWN)\n",
        "        group.next_to(self.result_fraction, DOWN)\n",
        "        big_group = VGroup(self.result_fraction, *group)\n",
        "\n",
        "        arrow = OldTex(\"\\\\rightarrow\")\n",
        "        arrow.move_to(self.distance_product_equals)\n",
        "\n",
        "        fraction_brace.generate_target()\n",
        "        fraction_brace.target.rotate(-10 * DEGREES)\n",
        "        fraction_brace.target.scale(0.65)\n",
        "        fraction_brace.target.align_to(ORIGIN, DOWN)\n",
        "        fraction_brace.target.shift(3.3 * LEFT)\n",
        "        fraction_words.generate_target()\n",
        "        fraction_words.target[0][:9].next_to(\n",
        "            VGroup(fraction_words.target[0][9:], fraction_words.target[1]),\n",
        "            UP, SMALL_BUFF\n",
        "        )\n",
        "        fraction_words.target.next_to(fraction_brace.target, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, group))\n",
        "        self.grow_circle_and_N(\n",
        "            added_anims=[\n",
        "                MoveToTarget(fraction_brace),\n",
        "                MoveToTarget(fraction_words),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            big_group.next_to, self.distance_product_equals, RIGHT,\n",
        "            {\"submobject_to_align\": frac2},\n",
        "            UpdateFromAlphaFunc(\n",
        "                big_group[:-1],\n",
        "                lambda m, a: m.set_fill(opacity=1 - a),\n",
        "            ),\n",
        "            Transform(self.distance_product_equals, arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.result_fraction = frac2\n",
        "\n",
        "    def show_new_infinite_product(self):\n",
        "        scale_val = 0.7\n",
        "        fractions = OldTex(\n",
        "            \"\\\\cdots\",\n",
        "            \"{|L_{-2} - K|\", \"\\\\over\", \"|L_{-2} - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_{-1} - K|\", \"\\\\over\", \"|L_{-1} - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_1 - K|\", \"\\\\over\", \"|L_1 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_2 - K|\", \"\\\\over\", \"|L_2 - S|}\", \"\\\\cdot\",\n",
        "            \"{|L_3 - K|\", \"\\\\over\", \"|L_3 - S|}\", \"\\\\cdots\",\n",
        "        )\n",
        "        fractions.scale(scale_val)\n",
        "        fractions.move_to(self.observers)\n",
        "        fractions.to_edge(RIGHT)\n",
        "        fractions.set_color_by_tex_to_color_map({\n",
        "            \"K\": BLUE,\n",
        "            \"S\": GREEN,\n",
        "        })\n",
        "\n",
        "        keeper_lines = self.get_keeper_lines()\n",
        "        sailor_lines = self.get_sailor_lines()\n",
        "        sailor_lines.set_color(GREEN)\n",
        "\n",
        "        ratios = VGroup(*[\n",
        "            fractions[i:i + 3]\n",
        "            for i in range(1, len(fractions), 4)\n",
        "        ])\n",
        "        limit_arrows = VGroup(*[\n",
        "            Vector(0.5 * DOWN, color=WHITE).next_to(ratio, DOWN, SMALL_BUFF)\n",
        "            for ratio in ratios\n",
        "        ])\n",
        "        limits = VGroup(*[\n",
        "            OldTex(\"{%d\" % k, \"\\\\over\", \"%d\" % k, \"-\", \"f}\")\n",
        "            for k in (-2, -1, 1, 2, 3)\n",
        "        ])\n",
        "        for limit, arrow in zip(limits, limit_arrows):\n",
        "            limit.set_color_by_tex(\"f\", GREEN)\n",
        "            limit.scale(scale_val)\n",
        "            limit.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "        dots = VGroup()\n",
        "        dots.add(OldTex(\"\\\\cdots\").next_to(limits, LEFT))\n",
        "        for l1, l2 in zip(limits, limits[1:]):\n",
        "            dots.add(OldTex(\"\\\\cdot\").move_to(VGroup(l1, l2)))\n",
        "        dots.add(OldTex(\"\\\\cdots\").next_to(limits, RIGHT))\n",
        "        full_limits_group = VGroup(*list(limits) + list(dots))\n",
        "\n",
        "        # brace = Brace(limits, DOWN)\n",
        "        product = OldTex(\n",
        "            \"\\\\prod_{k \\\\ne 0}\", \"{k\", \"\\\\over\", \"k\", \"-\", \"f}\"\n",
        "        )\n",
        "        product.next_to(limits, DOWN, LARGE_BUFF)\n",
        "        product_lines = VGroup(\n",
        "            DashedLine(full_limits_group.get_corner(DL), product.get_corner(UL)),\n",
        "            DashedLine(full_limits_group.get_corner(DR), product.get_corner(UR)),\n",
        "        )\n",
        "        product_lines.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, fractions),\n",
        "            *[\n",
        "                LaggedStartMap(\n",
        "                    FadeIn, VGroup(*list(lines[-10:]) + list(lines[1:10])),\n",
        "                    rate_func=there_and_back,\n",
        "                    remover=True,\n",
        "                    run_time=3,\n",
        "                    lag_ratio=0.1\n",
        "                )\n",
        "                for lines in (keeper_lines, sailor_lines)\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, limit_arrows),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, limits,\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            LaggedStartMap(FadeIn, dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            # GrowFromCenter(brace),\n",
        "            ShowCreation(product_lines, lag_ratio=0),\n",
        "            FadeIn(product)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shift everything\n",
        "        result_fraction = self.result_fraction\n",
        "        big_group = VGroup(\n",
        "            fractions, limit_arrows, full_limits_group,\n",
        "            # brace,\n",
        "            product_lines,\n",
        "            product,\n",
        "        )\n",
        "        big_group.generate_target()\n",
        "        big_group.target.to_edge(UP)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(big_group.target[-1], LEFT)\n",
        "        result_fraction.generate_target()\n",
        "        result_fraction.target.next_to(equals, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(big_group),\n",
        "            FadeIn(equals),\n",
        "            MoveToTarget(result_fraction),\n",
        "            FadeOut(self.distance_product_fraction),\n",
        "            FadeOut(self.distance_product_equals),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Replace chord with sine\n",
        "        chord_f = result_fraction[-3:]\n",
        "        f_pi = VGroup(result_fraction[0], result_fraction[3])\n",
        "        over = result_fraction.get_part_by_tex(\"\\\\over\")\n",
        "        dot_two = result_fraction[1:3]\n",
        "\n",
        "        two_sine_f_pi = OldTex(\"2\", \"\\\\sin(\", \"f\", \"\\\\pi\", \")\")\n",
        "        sine_f_pi = two_sine_f_pi[1:]\n",
        "        two_sine_f_pi.set_color_by_tex(\"f\", GREEN)\n",
        "        two_sine_f_pi.move_to(chord_f)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(two_sine_f_pi),\n",
        "            chord_f.shift, DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(chord_f))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            f_pi.arrange, RIGHT, {\"buff\": SMALL_BUFF},\n",
        "            f_pi.next_to, over, UP, SMALL_BUFF,\n",
        "            FadeOut(dot_two),\n",
        "            FadeOut(two_sine_f_pi[0]),\n",
        "            sine_f_pi.shift, SMALL_BUFF * LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reciprocate\n",
        "        pairs = VGroup()\n",
        "        for num, denom in zip(fractions[1::4], fractions[3::4]):\n",
        "            pairs.add(VGroup(num, denom))\n",
        "        for limit in limits:\n",
        "            pairs.add(VGroup(limit[0], limit[2:]))\n",
        "        pairs.add(\n",
        "            VGroup(f_pi, sine_f_pi),\n",
        "            VGroup(product[1], product[3:]),\n",
        "        )\n",
        "\n",
        "        for pair in pairs:\n",
        "            pair.generate_target()\n",
        "            pair.target[0].move_to(pair[1], UP)\n",
        "            pair.target[1].move_to(pair[0], DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, pairs,\n",
        "                path_arc=180 * DEGREES,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            product_lines[1].scale, 0.9, {\"about_point\": product_lines[1].get_start()},\n",
        "            product_lines[1].shift, SMALL_BUFF * UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Rearrange\n",
        "        one_minus_f_over_k = OldTex(\n",
        "            \"\\\\left(\", \"1\", \"-\", \"{f\", \"\\\\over\", \"k}\", \"\\\\right)\"\n",
        "        )\n",
        "        # 0 1 2 3 4\n",
        "        # k / k - f\n",
        "        one_minus_f_over_k.set_color_by_tex(\"{f\", GREEN)\n",
        "        one_minus_f_over_k.next_to(product[0], RIGHT, buff=SMALL_BUFF)\n",
        "        one_minus_f_over_k.shift(SMALL_BUFF * UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(one_minus_f_over_k[0]),\n",
        "            FadeIn(one_minus_f_over_k[-1]),\n",
        "            FadeOut(product_lines),\n",
        "            *[\n",
        "                ReplacementTransform(product[i], one_minus_f_over_k[j])\n",
        "                for i, j in [(3, 1), (4, 2), (5, 3), (2, 4), (1, 5)]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        product = VGroup(product[0], *one_minus_f_over_k)\n",
        "        product.generate_target()\n",
        "        f_pi.generate_target()\n",
        "        f_pi.target.next_to(equals, RIGHT, SMALL_BUFF)\n",
        "        product.target.next_to(f_pi.target, RIGHT, SMALL_BUFF)\n",
        "        product.target.shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            sine_f_pi.next_to, equals, LEFT, SMALL_BUFF,\n",
        "            FadeOut(over),\n",
        "            MoveToTarget(f_pi),\n",
        "            MoveToTarget(product),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show final result\n",
        "        rect = SurroundingRectangle(VGroup(sine_f_pi, product))\n",
        "        rect.set_color(BLUE)\n",
        "        pi_creatures = VGroup(\n",
        "            PiCreature(color=BLUE_E),\n",
        "            PiCreature(color=BLUE_C),\n",
        "            PiCreature(color=BLUE_D),\n",
        "            Mortimer()\n",
        "        )\n",
        "        pi_creatures.arrange(RIGHT, LARGE_BUFF)\n",
        "        pi_creatures.set_height(1)\n",
        "        pi_creatures.next_to(rect, DOWN)\n",
        "        for pi in pi_creatures:\n",
        "            pi.change(\"hooray\", rect)\n",
        "            pi.save_state()\n",
        "            pi.change(\"plain\")\n",
        "            pi.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            LaggedStartMap(ApplyMethod, pi_creatures, lambda m: (m.restore,))\n",
        "        )\n",
        "        for x in range(4):\n",
        "            self.play(Blink(random.choice(pi_creatures)))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class Conclusion(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        wallis_product = get_wallis_product(6)\n",
        "        wallis_product.move_to(self.hold_up_spot, DOWN)\n",
        "        wallis_product.shift_onto_screen()\n",
        "        for i in range(0, len(wallis_product) - 5, 4):\n",
        "            color = GREEN if (i / 4) % 2 == 0 else BLUE\n",
        "            wallis_product[i:i + 3].set_color(color)\n",
        "\n",
        "        sine_formula = OldTex(\n",
        "            \"\\\\sin(\", \"f\", \"\\\\pi\", \")\", \"=\", \"f\", \"\\\\pi\",\n",
        "            \"\\\\prod_{k \\\\ne 0}\", \"\\\\left(\", \"1\", \"-\",\n",
        "            \"{f\", \"\\\\over\", \"k}\", \"\\\\right)\"\n",
        "        )\n",
        "        sine_formula.set_color_by_tex(\"f\", GREEN)\n",
        "        sine_formula.set_color_by_tex(\"left\", WHITE)\n",
        "        sine_formula.move_to(self.hold_up_spot, DOWN)\n",
        "        sine_formula.shift_onto_screen()\n",
        "\n",
        "        euler = ImageMobject(\"Euler\")\n",
        "        euler.set_height(2.5)\n",
        "        basel_problem = OldTex(\n",
        "            \"\\\\frac{1}{1^2} + \",\n",
        "            \"\\\\frac{1}{2^2} + \",\n",
        "            \"\\\\frac{1}{3^2} + \",\n",
        "            \"\\\\cdots\",\n",
        "            \"\\\\frac{\\\\pi^2}{6}\"\n",
        "        )\n",
        "        basel_problem.move_to(self.hold_up_spot, DOWN)\n",
        "        implication = OldTex(\"\\\\Rightarrow\")\n",
        "        implication.next_to(basel_problem[0][1], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(wallis_product),\n",
        "            self.change_students(\"thinking\", \"hooray\", \"surprised\")\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change, \"hooray\",\n",
        "            FadeInFromDown(sine_formula),\n",
        "            wallis_product.to_edge, UP,\n",
        "            self.change_students(\"pondering\", \"thinking\", \"erm\")\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            sine_formula.next_to, implication, LEFT,\n",
        "            {\"submobject_to_align\": sine_formula[-1]},\n",
        "            FadeIn(implication),\n",
        "        )\n",
        "        euler.next_to(sine_formula, UP)\n",
        "        self.play(\n",
        "            FadeIn(euler),\n",
        "            LaggedStartMap(FadeIn, basel_problem),\n",
        "            self.teacher.change, \"happy\",\n",
        "            self.change_students(\"sassy\", \"confused\", \"hesitant\")\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        wallis_rect = SurroundingRectangle(wallis_product)\n",
        "        wallis_rect.set_color(BLUE)\n",
        "        basel_rect = SurroundingRectangle(basel_problem)\n",
        "        basel_rect.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(wallis_rect),\n",
        "            FadeOut(implication),\n",
        "            FadeOut(euler),\n",
        "            FadeOut(sine_formula),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(basel_rect),\n",
        "            self.teacher.change, \"surprised\",\n",
        "            self.change_students(*[\"happy\"] * 3)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ByLine(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\"\"\n",
        "            Written and animated by \\\\\\\\\n",
        "            \\\\quad \\\\\\\\\n",
        "            Sridhar Ramesh \\\\\\\\\n",
        "            Grant Sanderson\n",
        "        \"\"\").shift(2 * UP))\n",
        "\n",
        "\n",
        "class SponsorUnderlay(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_start_corner\": DR,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"https://udacity.com/3b1b/\")\n",
        "        url.to_corner(UL)\n",
        "\n",
        "        rect = ScreenRectangle(height=5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "        url.next_to(rect, UP)\n",
        "        url.save_state()\n",
        "\n",
        "        url.next_to(self.pi_creature.get_corner(UL), UP)\n",
        "\n",
        "        logo = SVGMobject(file_name=\"udacity\")\n",
        "        logo.set_fill(\"#02b3e4\")\n",
        "        logo.to_corner(UR)\n",
        "\n",
        "        self.add(logo)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(\n",
        "            url.restore,\n",
        "            ShowCreation(rect),\n",
        "            path_arc=90 * DEGREES,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "        self.remove(rect)\n",
        "        self.play(url.next_to, self.pi_creature, UL)\n",
        "        url_rect = SurroundingRectangle(url)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(FadeOut(url_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Keith Smith\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Ross Garber\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Hoang Tung Lam\",\n",
        "            \"Sergei\",\n",
        "            \"Devin Scott\",\n",
        "            \"George John\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yu Jun\",\n",
        "            \"dave nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Fred Ehrsam\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Cooper Jones\",\n",
        "            \"James Hughes\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Chris Giddings\",\n",
        "            \"Song Gao\",\n",
        "            \"William Fritzon\",\n",
        "            \"Alexander Feldman\",\n",
        "            # \"\u5b5f\u5b50\u6613\",\n",
        "            \"Mengzi yi\",\n",
        "            \"zheng zhang\",\n",
        "            \"Matt Langford\",\n",
        "            \"Max Mitchell\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"John Griffith\",\n",
        "            \"Chris Connett\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Bong Choung\",\n",
        "            \"Ignacio Freiberg\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Dan Esposito (Guardion)\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Cody Brocious\",\n",
        "            \"James H. Park\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"David MacCumber\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"Dave B\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"George Chiesa\",\n",
        "            \"supershabam\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Isak Hietala\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Awoo\",\n",
        "            \"Dr  David G. Stork\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            # \"\u4e16\u73c9 \u5321\",\n",
        "            \"Shi min kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail(DistanceProductScene):\n",
        "    def construct(self):\n",
        "        product = get_wallis_product()\n",
        "        product.scale(1.5)\n",
        "        product.move_to(2.5 * UP)\n",
        "        frac_lines = product.get_parts_by_tex(\"\\\\over\")\n",
        "        frac_indices = list(map(product.index_of_part, frac_lines))\n",
        "        parts = VGroup(*[\n",
        "            product[i-1:i+2]\n",
        "            for i in frac_indices\n",
        "        ])\n",
        "        parts[::2].set_color(WHITE)\n",
        "        parts[1::2].set_color(WHITE)\n",
        "        parts[-1].set_color(WHITE)\n",
        "        parts[-1].set_background_stroke(color=YELLOW, width=3)\n",
        "        parts[-1].scale(1.5, about_edge=LEFT)\n",
        "        product[-4:].next_to(product[:-4], DOWN, MED_LARGE_BUFF)\n",
        "        product.scale(1.2).center().to_edge(UP)\n",
        "\n",
        "        # new_proof = OldTexText(\"New proof\")\n",
        "        # new_proof.scale(2.5)\n",
        "        # new_proof.set_color(YELLOW)\n",
        "        # new_proof.set_stroke(RED, 0.75)\n",
        "        # new_proof.next_to(product, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        circle = self.circle = Circle(radius=8, color=YELLOW)\n",
        "        circle.move_to(3 * DOWN, DOWN)\n",
        "        bottom_dot = Dot(color=BLUE)\n",
        "        bottom_dot.move_to(circle.get_bottom())\n",
        "        observer = PiCreature(mode=\"pondering\")\n",
        "        observer.set_height(0.5)\n",
        "        observer.next_to(bottom_dot, DOWN)\n",
        "\n",
        "        lights = VGroup()\n",
        "        lines = VGroup()\n",
        "        light_config = dict(HIGHT_QUALITY_AMBIENT_LIGHT_CONFIG)\n",
        "        # light_config = dict(CHEAP_AMBIENT_LIGHT_CONFIG)\n",
        "        light_config[\"max_opacity\"] = 1\n",
        "        step = 0.03\n",
        "        for frac in np.arange(step, 0.2, step):\n",
        "            for u in -1, 1:\n",
        "                light = AmbientLight(**light_config)\n",
        "                dot = Dot(color=BLUE)\n",
        "                dot.move_to(light)\n",
        "                light.add_to_back(dot)\n",
        "                light.move_to(self.get_circle_point_at_proportion(u * frac - 0.25))\n",
        "                lights.add(light)\n",
        "                line = DashedLine(dot.get_center(), circle.get_bottom())\n",
        "                lines.add(line)\n",
        "\n",
        "\n",
        "        self.add(circle)\n",
        "        self.add(lights)\n",
        "        self.add(product)\n",
        "        # self.add(new_proof)\n",
        "        self.add(bottom_dot, observer)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}