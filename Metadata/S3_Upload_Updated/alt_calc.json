{
    "topic": "demonstrates the concept of a number line transformation scene, where a function is applied to a",
    "code": [
        " # -*- coding: utf-8 -*-\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def apply_function_to_center(point_func, mobject):\n",
        "    mobject.apply_function_to_position(point_func)\n",
        "\n",
        "\n",
        "def apply_function_to_submobjects(point_func, mobject):\n",
        "    mobject.apply_function_to_submobject_positions(point_func)\n",
        "\n",
        "\n",
        "def apply_function_to_points(point_func, mobject):\n",
        "    mobject.apply_function(point_func)\n",
        "\n",
        "\n",
        "def get_nested_one_plus_one_over_x(n_terms, bottom_term=\"x\"):\n",
        "    tex = \"1+ {1 \\\\over\" * n_terms + bottom_term + \"}\" * n_terms\n",
        "    return OldTex(tex, isolate=[\"1\", \"\\\\over\", bottom_term])\n",
        "\n",
        "\n",
        "def get_phi_continued_fraction(n_terms):\n",
        "    return get_nested_one_plus_one_over_x(n_terms, bottom_term=\"1+\\\\cdots\")\n",
        "\n",
        "\n",
        "def get_nested_f(n_terms, arg=\"x\"):\n",
        "    terms = [\"f(\"] * n_terms + [arg] + [\")\"] * n_terms\n",
        "    return OldTex(*terms)\n",
        "\n",
        "\n",
        "# Scene types\n",
        "\n",
        "class NumberlineTransformationScene(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"input_line_zero_point\": 0.5 * UP + (FRAME_X_RADIUS - 1) * LEFT,\n",
        "        \"output_line_zero_point\": 2 * DOWN + (FRAME_X_RADIUS - 1) * LEFT,\n",
        "        \"number_line_config\": {\n",
        "            \"include_numbers\": True,\n",
        "            \"x_min\": -3.5,\n",
        "            \"x_max\": 3.5,\n",
        "            \"unit_size\": 2,\n",
        "        },\n",
        "        # These would override number_line_config\n",
        "        \"input_line_config\": {\n",
        "            \"color\": BLUE,\n",
        "        },\n",
        "        \"output_line_config\": {},\n",
        "        \"num_inserted_number_line_curves\": 20,\n",
        "        \"default_delta_x\": 0.1,\n",
        "        \"default_sample_dot_radius\": 0.07,\n",
        "        \"default_sample_dot_colors\": [RED, YELLOW],\n",
        "        \"default_mapping_animation_config\": {\n",
        "            \"run_time\": 3,\n",
        "            # \"path_arc\": 30 * DEGREES,\n",
        "        },\n",
        "        \"local_coordinate_num_decimal_places\": 2,\n",
        "        \"zoom_factor\": 0.1,\n",
        "        \"zoomed_display_height\": 2.5,\n",
        "        \"zoomed_display_corner_buff\": MED_SMALL_BUFF,\n",
        "        \"mini_line_scale_factor\": 2,\n",
        "        \"default_coordinate_value_dx\": 0.05,\n",
        "        \"zoomed_camera_background_rectangle_fill_opacity\": 1.0,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        ZoomedScene.setup(self)\n",
        "        self.setup_number_lines()\n",
        "        self.setup_titles()\n",
        "        self.setup_zoomed_camera_background_rectangle()\n",
        "\n",
        "    def setup_number_lines(self):\n",
        "        number_lines = self.number_lines = VGroup()\n",
        "        added_configs = (self.input_line_config, self.output_line_config)\n",
        "        zero_opints = (self.input_line_zero_point, self.output_line_zero_point)\n",
        "        for added_config, zero_point in zip(added_configs, zero_opints):\n",
        "            full_config = dict(self.number_line_config)\n",
        "            full_config.update(added_config)\n",
        "            number_line = NumberLine(**full_config)\n",
        "            number_line.insert_n_curves(\n",
        "                self.num_inserted_number_line_curves\n",
        "            )\n",
        "            number_line.shift(zero_point - number_line.number_to_point(0))\n",
        "            number_lines.add(number_line)\n",
        "        self.input_line, self.output_line = number_lines\n",
        "\n",
        "        self.add(number_lines)\n",
        "\n",
        "    def setup_titles(self):\n",
        "        input_title, output_title = self.titles = VGroup(*[\n",
        "            OldTexText(word)\n",
        "            for word in (\"Inputs\", \"Outputs\")\n",
        "        ])\n",
        "        vects = [UP, DOWN]\n",
        "        for title, line, vect in zip(self.titles, self.number_lines, vects):\n",
        "            title.next_to(line, vect, aligned_edge=LEFT)\n",
        "            title.shift_onto_screen()\n",
        "\n",
        "        self.add(self.titles)\n",
        "\n",
        "    def setup_zoomed_camera_background_rectangle(self):\n",
        "        frame = self.zoomed_camera.frame\n",
        "        frame.next_to(self.camera.frame, UL)\n",
        "        self.zoomed_camera_background_rectangle = BackgroundRectangle(\n",
        "            frame, fill_opacity=self.zoomed_camera_background_rectangle_fill_opacity\n",
        "        )\n",
        "        self.zoomed_camera_background_rectangle_anim = UpdateFromFunc(\n",
        "            self.zoomed_camera_background_rectangle,\n",
        "            lambda m: m.replace(frame, stretch=True)\n",
        "        )\n",
        "        self.zoomed_camera_background_rectangle_group = VGroup(\n",
        "            self.zoomed_camera_background_rectangle,\n",
        "        )\n",
        "\n",
        "    def get_sample_input_points(self, x_min=None, x_max=None, delta_x=None):\n",
        "        x_min = x_min or self.input_line.x_min\n",
        "        x_max = x_max or self.input_line.x_max\n",
        "        delta_x = delta_x or self.default_delta_x\n",
        "        return [\n",
        "            self.get_input_point(x)\n",
        "            for x in np.arange(x_min, x_max + delta_x, delta_x)\n",
        "        ]\n",
        "\n",
        "    def get_sample_dots(self, x_min=None, x_max=None,\n",
        "                        delta_x=None, dot_radius=None, colors=None):\n",
        "        dot_radius = dot_radius or self.default_sample_dot_radius\n",
        "        colors = colors or self.default_sample_dot_colors\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(point, radius=dot_radius)\n",
        "            for point in self.get_sample_input_points(x_min, x_max, delta_x)\n",
        "        ])\n",
        "        dots.set_color_by_gradient(*colors)\n",
        "        return dots\n",
        "\n",
        "    def get_local_sample_dots(self, x, sample_radius=None, **kwargs):\n",
        "        zoom_factor = self.get_zoom_factor()\n",
        "        delta_x = kwargs.get(\"delta_x\", self.default_delta_x * zoom_factor)\n",
        "        dot_radius = kwargs.get(\"dot_radius\", self.default_sample_dot_radius * zoom_factor)\n",
        "\n",
        "        if sample_radius is None:\n",
        "            unrounded_radius = self.zoomed_camera.frame.get_width() / 2\n",
        "            sample_radius = int(unrounded_radius / delta_x) * delta_x\n",
        "        config = {\n",
        "            \"x_min\": x - sample_radius,\n",
        "            \"x_max\": x + sample_radius,\n",
        "            \"delta_x\": delta_x,\n",
        "            \"dot_radius\": dot_radius,\n",
        "        }\n",
        "        config.update(kwargs)\n",
        "        return self.get_sample_dots(**config)\n",
        "\n",
        "    def add_sample_dot_ghosts(self, sample_dots, fade_factor=0.5):\n",
        "        self.sample_dot_ghosts = sample_dots.copy()\n",
        "        self.sample_dot_ghosts.fade(fade_factor)\n",
        "        self.add(self.sample_dot_ghosts, sample_dots)\n",
        "\n",
        "    def get_local_coordinate_values(self, x, dx=None, n_neighbors=1):\n",
        "        dx = dx or self.default_coordinate_value_dx\n",
        "        return [\n",
        "            x + n * dx\n",
        "            for n in range(-n_neighbors, n_neighbors + 1)\n",
        "        ]\n",
        "\n",
        "    # Mapping animations\n",
        "    def get_mapping_animation(self, func, mobject,\n",
        "                              how_to_apply_func=apply_function_to_center,\n",
        "                              **kwargs):\n",
        "        anim_config = dict(self.default_mapping_animation_config)\n",
        "        anim_config.update(kwargs)\n",
        "\n",
        "        point_func = self.number_func_to_point_func(func)\n",
        "\n",
        "        mobject.generate_target(use_deepcopy=True)\n",
        "        how_to_apply_func(point_func, mobject.target)\n",
        "        return MoveToTarget(mobject, **anim_config)\n",
        "\n",
        "    def get_line_mapping_animation(self, func, **kwargs):\n",
        "        input_line_copy = self.input_line.deepcopy()\n",
        "        self.moving_input_line = input_line_copy\n",
        "        input_line_copy.remove(input_line_copy.numbers)\n",
        "        # input_line_copy.set_stroke(width=2)\n",
        "        input_line_copy.insert_n_curves(\n",
        "            self.num_inserted_number_line_curves\n",
        "        )\n",
        "        return AnimationGroup(\n",
        "            self.get_mapping_animation(\n",
        "                func, input_line_copy,\n",
        "                apply_function_to_points\n",
        "            ),\n",
        "            self.get_mapping_animation(\n",
        "                func, input_line_copy.tick_marks,\n",
        "                apply_function_to_submobjects\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def get_sample_dots_mapping_animation(self, func, dots, **kwargs):\n",
        "        return self.get_mapping_animation(\n",
        "            func, dots, how_to_apply_func=apply_function_to_submobjects\n",
        "        )\n",
        "\n",
        "    def get_zoomed_camera_frame_mapping_animation(self, func, x=None, **kwargs):\n",
        "        frame = self.zoomed_camera.frame\n",
        "        if x is None:\n",
        "            point = frame.get_center()\n",
        "        else:\n",
        "            point = self.get_input_point(x)\n",
        "        point_mob = VectorizedPoint(point)\n",
        "        return AnimationGroup(\n",
        "            self.get_mapping_animation(func, point_mob),\n",
        "            UpdateFromFunc(frame, lambda m: m.move_to(point_mob)),\n",
        "        )\n",
        "\n",
        "    def apply_function(self, func,\n",
        "                       apply_function_to_number_line=True,\n",
        "                       sample_dots=None,\n",
        "                       local_sample_dots=None,\n",
        "                       target_coordinate_values=None,\n",
        "                       added_anims=None,\n",
        "                       **kwargs\n",
        "                       ):\n",
        "        zcbr_group = self.zoomed_camera_background_rectangle_group\n",
        "        zcbr_anim = self.zoomed_camera_background_rectangle_anim\n",
        "        frame = self.zoomed_camera.frame\n",
        "\n",
        "        anims = []\n",
        "        if apply_function_to_number_line:\n",
        "            anims.append(self.get_line_mapping_animation(func))\n",
        "        if hasattr(self, \"mini_line\"):  # Test for if mini_line is in self?\n",
        "            anims.append(self.get_mapping_animation(\n",
        "                func, self.mini_line,\n",
        "                how_to_apply_func=apply_function_to_center\n",
        "            ))\n",
        "        if sample_dots:\n",
        "            anims.append(\n",
        "                self.get_sample_dots_mapping_animation(func, sample_dots)\n",
        "            )\n",
        "        if self.zoom_activated:\n",
        "            zoom_anim = self.get_zoomed_camera_frame_mapping_animation(func)\n",
        "            anims.append(zoom_anim)\n",
        "            anims.append(zcbr_anim)\n",
        "\n",
        "            zoom_anim.update(1)\n",
        "            target_mini_line = Line(frame.get_left(), frame.get_right())\n",
        "            target_mini_line.scale(self.mini_line_scale_factor)\n",
        "            target_mini_line.match_style(self.output_line)\n",
        "            zoom_anim.update(0)\n",
        "            zcbr_group.submobjects.insert(1, target_mini_line)\n",
        "        if target_coordinate_values:\n",
        "            coordinates = self.get_local_coordinates(\n",
        "                self.output_line,\n",
        "                *target_coordinate_values\n",
        "            )\n",
        "            anims.append(FadeIn(coordinates))\n",
        "            zcbr_group.add(coordinates)\n",
        "            self.local_target_coordinates = coordinates\n",
        "        if local_sample_dots:\n",
        "            anims.append(\n",
        "                self.get_sample_dots_mapping_animation(func, local_sample_dots)\n",
        "            )\n",
        "            zcbr_group.add(local_sample_dots)\n",
        "        if added_anims:\n",
        "            anims += added_anims\n",
        "        anims.append(Animation(zcbr_group))\n",
        "\n",
        "        self.play(*anims, **kwargs)\n",
        "\n",
        "    # Zooming\n",
        "    def zoom_in_on_input(self, x,\n",
        "                         local_sample_dots=None,\n",
        "                         local_coordinate_values=None,\n",
        "                         pop_out=True,\n",
        "                         first_added_anims=None,\n",
        "                         first_anim_kwargs=None,\n",
        "                         second_added_anims=None,\n",
        "                         second_anim_kwargs=None,\n",
        "                         zoom_factor=None,\n",
        "                         ):\n",
        "\n",
        "        first_added_anims = first_added_anims or []\n",
        "        first_anim_kwargs = first_anim_kwargs or {}\n",
        "        second_added_anims = second_added_anims or []\n",
        "        second_anim_kwargs = second_anim_kwargs or {}\n",
        "        input_point = self.get_input_point(x)\n",
        "\n",
        "        # Decide how to move camera frame into place\n",
        "        frame = self.zoomed_camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.move_to(input_point)\n",
        "        if zoom_factor:\n",
        "            frame.target.set_height(\n",
        "                self.zoomed_display.get_height() * zoom_factor\n",
        "            )\n",
        "        movement = MoveToTarget(frame)\n",
        "        zcbr = self.zoomed_camera_background_rectangle\n",
        "        zcbr_group = self.zoomed_camera_background_rectangle_group\n",
        "        zcbr_anim = self.zoomed_camera_background_rectangle_anim\n",
        "        anims = []\n",
        "        if self.zoom_activated:\n",
        "            anims.append(movement)\n",
        "            anims.append(zcbr_anim)\n",
        "        else:\n",
        "            movement.update(1)\n",
        "            zcbr_anim.update(1)\n",
        "            anims.append(self.get_zoom_in_animation())\n",
        "            anims.append(FadeIn(zcbr))\n",
        "\n",
        "        # Make sure frame is in final place\n",
        "        for anim in anims:\n",
        "            anim.update(1)\n",
        "\n",
        "        # Add miniature number_line\n",
        "        mini_line = self.mini_line = Line(frame.get_left(), frame.get_right())\n",
        "        mini_line.scale(self.mini_line_scale_factor)\n",
        "        mini_line.insert_n_curves(self.num_inserted_number_line_curves)\n",
        "        mini_line.match_style(self.input_line)\n",
        "        mini_line_copy = mini_line.copy()\n",
        "        zcbr_group.add(mini_line_copy, mini_line)\n",
        "        anims += [FadeIn(mini_line), FadeIn(mini_line_copy)]\n",
        "\n",
        "        # Add tiny coordinates\n",
        "        if local_coordinate_values is None:\n",
        "            local_coordinate_values = [x]\n",
        "        local_coordinates = self.get_local_coordinates(\n",
        "            self.input_line,\n",
        "            *local_coordinate_values\n",
        "        )\n",
        "        anims.append(FadeIn(local_coordinates))\n",
        "        zcbr_group.add(local_coordinates)\n",
        "        self.local_coordinates = local_coordinates\n",
        "\n",
        "        # Add tiny dots\n",
        "        if local_sample_dots is not None:\n",
        "            anims.append(LaggedStartMap(GrowFromCenter, local_sample_dots))\n",
        "            zcbr_group.add(local_sample_dots)\n",
        "\n",
        "        if first_added_anims:\n",
        "            anims += first_added_anims\n",
        "\n",
        "        anims.append(Animation(zcbr_group))\n",
        "        if not pop_out:\n",
        "            self.activate_zooming(animate=False)\n",
        "        self.play(*anims, **first_anim_kwargs)\n",
        "\n",
        "        if not self.zoom_activated and pop_out:\n",
        "            self.activate_zooming(animate=False)\n",
        "            added_anims = second_added_anims or []\n",
        "            self.play(\n",
        "                self.get_zoomed_display_pop_out_animation(),\n",
        "                *added_anims,\n",
        "                **second_anim_kwargs\n",
        "            )\n",
        "\n",
        "    def get_local_coordinates(self, line, *x_values, **kwargs):\n",
        "        num_decimal_places = kwargs.get(\n",
        "            \"num_decimal_places\", self.local_coordinate_num_decimal_places\n",
        "        )\n",
        "        result = VGroup()\n",
        "        result.tick_marks = VGroup()\n",
        "        result.numbers = VGroup()\n",
        "        result.add(result.tick_marks, result.numbers)\n",
        "        for x in x_values:\n",
        "            tick_mark = Line(UP, DOWN)\n",
        "            tick_mark.set_height(\n",
        "                0.15 * self.zoomed_camera.frame.get_height()\n",
        "            )\n",
        "            tick_mark.move_to(line.number_to_point(x))\n",
        "            result.tick_marks.add(tick_mark)\n",
        "\n",
        "            number = DecimalNumber(x, num_decimal_places=num_decimal_places)\n",
        "            number.scale(self.get_zoom_factor())\n",
        "            number.scale(0.5)  # To make it seem small\n",
        "            number.next_to(tick_mark, DOWN, buff=0.5 * number.get_height())\n",
        "            result.numbers.add(number)\n",
        "        return result\n",
        "\n",
        "    def get_mobjects_in_zoomed_camera(self, mobjects):\n",
        "        frame = self.zoomed_camera.frame\n",
        "        x_min = frame.get_left()[0]\n",
        "        x_max = frame.get_right()[0]\n",
        "        y_min = frame.get_bottom()[1]\n",
        "        y_max = frame.get_top()[1]\n",
        "        result = VGroup()\n",
        "        for mob in mobjects:\n",
        "            for point in mob.get_all_points():\n",
        "                if (x_min < point[0] < x_max) and (y_min < point[1] < y_max):\n",
        "                    result.add(mob)\n",
        "                    break\n",
        "        return result\n",
        "\n",
        "    # Helpers\n",
        "    def get_input_point(self, x):\n",
        "        return self.input_line.number_to_point(x)\n",
        "\n",
        "    def get_output_point(self, fx):\n",
        "        return self.output_line.number_to_point(fx)\n",
        "\n",
        "    def number_func_to_point_func(self, number_func):\n",
        "        input_line, output_line = self.number_lines\n",
        "\n",
        "        def point_func(point):\n",
        "            input_number = input_line.point_to_number(point)\n",
        "            output_number = number_func(input_number)\n",
        "            return output_line.number_to_point(output_number)\n",
        "        return point_func\n",
        "\n",
        "\n",
        "class ExampleNumberlineTransformationScene(NumberlineTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 5,\n",
        "            \"unit_size\": 2.0\n",
        "        },\n",
        "        \"output_line_config\": {\n",
        "            \"x_max\": 20,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        func = lambda x: x**2\n",
        "        x = 3\n",
        "        dx = 0.05\n",
        "\n",
        "        sample_dots = self.get_sample_dots()\n",
        "        local_sample_dots = self.get_local_sample_dots(x)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, sample_dots))\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=[x - dx, x, x + dx],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.apply_function(\n",
        "            func,\n",
        "            sample_dots=sample_dots,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=[func(x) - dx, func(x), func(x) + dx],\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class WriteOpeningWords(Scene):\n",
        "    def construct(self):\n",
        "        raw_string1 = \"Dear calculus student,\"\n",
        "        raw_string2 = \"You're about to go through your first course. Like \" + \\\n",
        "                      \"any new topic, it will take some hard work to understand,\"\n",
        "        words1, words2 = [\n",
        "            OldTexText(\"\\\\Large\", *rs.split(\" \"))\n",
        "            for rs in (raw_string1, raw_string2)\n",
        "        ]\n",
        "        words1.next_to(words2, UP, aligned_edge=LEFT, buff=LARGE_BUFF)\n",
        "        words = VGroup(*it.chain(words1, words2))\n",
        "        words.set_width(FRAME_WIDTH - 2 * LARGE_BUFF)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        letter_wait = 0.05\n",
        "        word_wait = 2 * letter_wait\n",
        "        comma_wait = 5 * letter_wait\n",
        "        for word in words:\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, word,\n",
        "                run_time=len(word) * letter_wait,\n",
        "                lag_ratio=1.5 / len(word)\n",
        "            ))\n",
        "            self.wait(word_wait)\n",
        "            if word.get_tex()[-1] == \",\":\n",
        "                self.wait(comma_wait)\n",
        "\n",
        "\n",
        "class StartingCalc101(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1},\n",
        "        \"image_frame_width\": 3.5,\n",
        "        \"image_frame_height\": 2.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_you()\n",
        "        self.show_images()\n",
        "        self.show_mystery_topic()\n",
        "\n",
        "    def show_you(self):\n",
        "        randy = self.pi_creature\n",
        "        title = self.title = Title(\"Calculus 101\")\n",
        "        you = OldTexText(\"You\")\n",
        "        arrow = Vector(DL, color=WHITE)\n",
        "        arrow.next_to(randy, UR)\n",
        "        you.next_to(arrow.get_start(), UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(you),\n",
        "            GrowArrow(arrow),\n",
        "            randy.change, \"erm\", title\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(title, run_time=1))\n",
        "        self.play(FadeOut(VGroup(arrow, you)))\n",
        "\n",
        "    def show_images(self):\n",
        "        randy = self.pi_creature\n",
        "        images = self.get_all_images()\n",
        "        modes = [\n",
        "            \"pondering\",  # hard_work_image\n",
        "            \"pondering\",  # neat_example_image\n",
        "            \"hesitant\",  # not_so_neat_example_image\n",
        "            \"hesitant\",  # physics_image\n",
        "            \"horrified\",  # piles_of_formulas_image\n",
        "            \"horrified\",  # getting_stuck_image\n",
        "            \"thinking\",  # aha_image\n",
        "            \"thinking\",  # graphical_intuition_image\n",
        "        ]\n",
        "\n",
        "        for i, image, mode in zip(it.count(), images, modes):\n",
        "            anims = []\n",
        "            if hasattr(image, \"fade_in_anim\"):\n",
        "                anims.append(image.fade_in_anim)\n",
        "                anims.append(FadeIn(image.frame))\n",
        "            else:\n",
        "                anims.append(FadeIn(image))\n",
        "\n",
        "            if i >= 3:\n",
        "                image_to_fade_out = images[i - 3]\n",
        "                if hasattr(image_to_fade_out, \"fade_out_anim\"):\n",
        "                    anims.append(image_to_fade_out.fade_out_anim)\n",
        "                else:\n",
        "                    anims.append(FadeOut(image_to_fade_out))\n",
        "\n",
        "            if hasattr(image, \"continual_animations\"):\n",
        "                self.add(*image.continual_animations)\n",
        "\n",
        "            anims.append(ApplyMethod(randy.change, mode))\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            if i >= 3:\n",
        "                if hasattr(image_to_fade_out, \"continual_animations\"):\n",
        "                    self.remove(*image_to_fade_out.continual_animations)\n",
        "                self.remove(image_to_fade_out.frame)\n",
        "        self.wait(3)\n",
        "\n",
        "        self.remaining_images = images[-3:]\n",
        "\n",
        "    def show_mystery_topic(self):\n",
        "        images = self.remaining_images\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        mystery_box = Rectangle(\n",
        "            width=self.image_frame_width,\n",
        "            height=self.image_frame_height,\n",
        "            stroke_color=YELLOW,\n",
        "            fill_color=GREY_D,\n",
        "            fill_opacity=0.5,\n",
        "        )\n",
        "        mystery_box.scale(1.5)\n",
        "        mystery_box.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        rects = images[-1].rects.copy()\n",
        "        rects.center()\n",
        "        rects.set_height(FRAME_HEIGHT - 1)\n",
        "        # image = rects.get_image()\n",
        "        open_cv_image = cv2.imread(get_full_raster_image_path(\"alt_calc_hidden_image\"))\n",
        "        blurry_iamge = cv2.blur(open_cv_image, (50, 50))\n",
        "        array = np.array(blurry_iamge)[:, :, ::-1]\n",
        "        im_mob = ImageMobject(array)\n",
        "        im_mob.replace(mystery_box, stretch=True)\n",
        "        mystery_box.add(im_mob)\n",
        "\n",
        "        q_marks = OldTex(\"???\").scale(3)\n",
        "        q_marks.space_out_submobjects(1.5)\n",
        "        q_marks.set_stroke(BLACK, 1)\n",
        "        q_marks.move_to(mystery_box)\n",
        "        mystery_box.add(q_marks)\n",
        "\n",
        "        for image in images:\n",
        "            if hasattr(image, \"continual_animations\"):\n",
        "                self.remove(*image.continual_animations)\n",
        "            self.play(\n",
        "                image.shift, DOWN,\n",
        "                image.fade, 1,\n",
        "                randy.change, \"erm\",\n",
        "                run_time=1.5\n",
        "            )\n",
        "            self.remove(image)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(mystery_box),\n",
        "            randy.change, \"confused\"\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_all_images(self):\n",
        "        # Images matched to narration's introductory list\n",
        "        images = VGroup(\n",
        "            self.get_hard_work_image(),\n",
        "            self.get_neat_example_image(),\n",
        "            self.get_not_so_neat_example_image(),\n",
        "            self.get_physics_image(),\n",
        "            self.get_piles_of_formulas_image(),\n",
        "            self.get_getting_stuck_image(),\n",
        "            self.get_aha_image(),\n",
        "            self.get_graphical_intuition_image(),\n",
        "        )\n",
        "        colors = color_gradient([BLUE, YELLOW], len(images))\n",
        "        for i, image, color in zip(it.count(), images, colors):\n",
        "            self.adjust_size(image)\n",
        "            frame = Rectangle(\n",
        "                width=self.image_frame_width,\n",
        "                height=self.image_frame_height,\n",
        "                color=color,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "            frame.move_to(image)\n",
        "            image.frame = frame\n",
        "            image.add(frame)\n",
        "            image.next_to(self.title, DOWN)\n",
        "            alt_i = (i % 3) - 1\n",
        "            vect = (self.image_frame_width + LARGE_BUFF) * RIGHT\n",
        "            image.shift(alt_i * vect)\n",
        "        return images\n",
        "\n",
        "    def adjust_size(self, group):\n",
        "        group.set_width(min(\n",
        "            group.get_width(),\n",
        "            self.image_frame_width - 2 * MED_SMALL_BUFF\n",
        "        ))\n",
        "        group.set_height(min(\n",
        "            group.get_height(),\n",
        "            self.image_frame_height - 2 * MED_SMALL_BUFF\n",
        "        ))\n",
        "        return group\n",
        "\n",
        "    def get_hard_work_image(self):\n",
        "        new_randy = self.pi_creature.copy()\n",
        "        new_randy.change_mode(\"telepath\")\n",
        "        bubble = new_randy.get_bubble(height=3.5, width=4)\n",
        "        bubble.add_content(OldTex(\"\\\\frac{d}{dx}(\\\\sin(\\\\sqrt{x}))\"))\n",
        "        bubble.add(bubble.content)  # Remove?\n",
        "\n",
        "        return VGroup(new_randy, bubble)\n",
        "\n",
        "    def get_neat_example_image(self):\n",
        "        filled_circle = Circle(\n",
        "            stroke_width=0,\n",
        "            fill_color=BLUE_E,\n",
        "            fill_opacity=1\n",
        "        )\n",
        "        area = OldTex(\"\\\\pi r^2\")\n",
        "        area.move_to(filled_circle)\n",
        "        unfilled_circle = Circle(\n",
        "            stroke_width=3,\n",
        "            stroke_color=YELLOW,\n",
        "            fill_opacity=0,\n",
        "        )\n",
        "        unfilled_circle.next_to(filled_circle, RIGHT)\n",
        "        circles = VGroup(filled_circle, unfilled_circle)\n",
        "        circumference = OldTex(\"2\\\\pi r\")\n",
        "        circumference.move_to(unfilled_circle)\n",
        "        equation = OldTex(\n",
        "            \"{d (\\\\pi r^2) \\\\over dr}  = 2\\\\pi r\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\pi r^2\": BLUE_D,\n",
        "                \"2\\\\pi r\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        equation.next_to(circles, UP)\n",
        "\n",
        "        return VGroup(\n",
        "            filled_circle, area,\n",
        "            unfilled_circle, circumference,\n",
        "            equation\n",
        "        )\n",
        "\n",
        "    def get_not_so_neat_example_image(self):\n",
        "        return OldTex(\"\\\\int x \\\\cos(x) \\\\, dx\")\n",
        "\n",
        "    def get_physics_image(self):\n",
        "        t_max = 6.5\n",
        "        r = 0.2\n",
        "        spring = ParametricCurve(\n",
        "            lambda t: op.add(\n",
        "                r * (np.sin(TAU * t) * RIGHT + np.cos(TAU * t) * UP),\n",
        "                t * DOWN,\n",
        "            ),\n",
        "            t_min=0, t_max=t_max,\n",
        "            color=WHITE,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        spring.color_using_background_image(\"grey_gradient\")\n",
        "\n",
        "        weight = Square()\n",
        "        weight.set_stroke(width=0)\n",
        "        weight.set_fill(opacity=1)\n",
        "        weight.color_using_background_image(\"grey_gradient\")\n",
        "        weight.set_height(0.4)\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        group = VGroup(spring, weight)\n",
        "        group.continual_animations = [\n",
        "            t_tracker.add_udpater(\n",
        "                lambda tracker, dt: tracker.set_value(\n",
        "                    tracker.get_value() + dt\n",
        "                )\n",
        "            ),\n",
        "            spring.add_updater(\n",
        "                lambda s: s.stretch_to_fit_height(\n",
        "                    1.5 + 0.5 * np.cos(3 * t_tracker.get_value()),\n",
        "                    about_edge=UP\n",
        "                )\n",
        "            ),\n",
        "            weight.add_updater(\n",
        "                lambda w: w.move_to(spring.get_points()[-1])\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        def update_group_style(alpha):\n",
        "            spring.set_stroke(width=2 * alpha)\n",
        "            weight.set_fill(opacity=alpha)\n",
        "\n",
        "        group.fade_in_anim = UpdateFromAlphaFunc(\n",
        "            group,\n",
        "            lambda g, a: update_group_style(a)\n",
        "        )\n",
        "        group.fade_out_anim = UpdateFromAlphaFunc(\n",
        "            group,\n",
        "            lambda g, a: update_group_style(1 - a)\n",
        "        )\n",
        "        return group\n",
        "\n",
        "    def get_piles_of_formulas_image(self):\n",
        "        return OldTex(\"(f/g)' = \\\\frac{gf' - fg'}{g^2}\")\n",
        "\n",
        "    def get_getting_stuck_image(self):\n",
        "        creature = self.pi_creature.copy()\n",
        "        creature.change_mode(\"angry\")\n",
        "        equation = OldTex(\"\\\\frac{d}{dx}(x^x)\")\n",
        "        equation.set_height(creature.get_height() / 2)\n",
        "        equation.next_to(creature, RIGHT, aligned_edge=UP)\n",
        "        creature.look_at(equation)\n",
        "        return VGroup(creature, equation)\n",
        "\n",
        "    def get_aha_image(self):\n",
        "        creature = self.pi_creature.copy()\n",
        "        creature.change_mode(\"hooray\")\n",
        "        from _2017.eoc.eoc.chapter3 import NudgeSideLengthOfCube\n",
        "        scene = NudgeSideLengthOfCube(\n",
        "            end_at_animation_number=7,\n",
        "            skip_animations=True\n",
        "        )\n",
        "        group = VGroup(\n",
        "            scene.cube, scene.faces,\n",
        "            scene.bars, scene.corner_cube,\n",
        "        )\n",
        "        group.set_height(0.75 * creature.get_height())\n",
        "        group.next_to(creature, RIGHT)\n",
        "        creature.look_at(group)\n",
        "        return VGroup(creature, group)\n",
        "\n",
        "    def get_graphical_intuition_image(self):\n",
        "        gs = GraphScene()\n",
        "        gs.setup_axes()\n",
        "        graph = gs.get_graph(\n",
        "            lambda x: 0.2 * (x - 3) * (x - 5) * (x - 6) + 4,\n",
        "            x_min=2, x_max=8,\n",
        "        )\n",
        "        rects = gs.get_riemann_rectangles(\n",
        "            graph, x_min=2, x_max=8,\n",
        "            stroke_width=0.5,\n",
        "            dx=0.25\n",
        "        )\n",
        "        gs.add(graph, rects, gs.axes)\n",
        "        group = VGroup(*gs.mobjects)\n",
        "        self.adjust_size(group)\n",
        "        group.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "        group.rects = rects\n",
        "        group.continual_animations = [\n",
        "            turn_animation_into_updater(Write(rects)),\n",
        "            turn_animation_into_updater(ShowCreation(graph)),\n",
        "            turn_animation_into_updater(FadeIn(gs.axes)),\n",
        "        ]\n",
        "        self.adjust_size(group)\n",
        "        return group\n",
        "\n",
        "\n",
        "class GraphicalIntuitions(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"func\": lambda x: 0.1 * (x - 2) * (x - 5) * (x - 7) + 4,\n",
        "        \"x_labeled_nums\": list(range(1, 10)),\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        axes = self.axes\n",
        "        graph = self.get_graph(self.func)\n",
        "\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            x=8, graph=graph, dx=0.01,\n",
        "            secant_line_length=6,\n",
        "            secant_line_color=RED,\n",
        "        )\n",
        "        rects = self.get_riemann_rectangles(\n",
        "            graph, x_min=2, x_max=8, dx=0.01, stroke_width=0\n",
        "        )\n",
        "\n",
        "        deriv_text = OldTexText(\n",
        "            \"Derivative $\\\\rightarrow$ slope\",\n",
        "            tex_to_color_map={\"slope\": ss_group.secant_line.get_color()}\n",
        "        )\n",
        "        deriv_text.to_edge(UP)\n",
        "        integral_text = OldTexText(\n",
        "            \"Integral $\\\\rightarrow$ area\",\n",
        "            tex_to_color_map={\"area\": rects[0].get_color()}\n",
        "        )\n",
        "        integral_text.next_to(deriv_text, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Succession(Write(axes), ShowCreation(graph, run_time=2)),\n",
        "            self.get_graph_words_anim(),\n",
        "        )\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_x=2,\n",
        "            rate_func=smooth,\n",
        "            run_time=2.5,\n",
        "            added_anims=[\n",
        "                Write(deriv_text),\n",
        "                VFadeIn(ss_group, run_time=2),\n",
        "            ]\n",
        "        )\n",
        "        self.play(FadeIn(integral_text))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                GrowFromEdge, rects,\n",
        "                lambda r: (r, DOWN)\n",
        "            ),\n",
        "            Animation(axes),\n",
        "            Animation(graph),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_graph_words_anim(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Graphs,\"),\n",
        "            OldTexText(\"graphs,\"),\n",
        "            OldTexText(\"non-stop graphs\"),\n",
        "            OldTexText(\"all day\"),\n",
        "            OldTexText(\"every day\"),\n",
        "            OldTexText(\"as if to visualize is to graph\"),\n",
        "        )\n",
        "        for word in words:\n",
        "            word.add_background_rectangle()\n",
        "        words.arrange(DOWN)\n",
        "        words.to_edge(UP)\n",
        "        return LaggedStartMap(\n",
        "            FadeIn, words,\n",
        "            rate_func=there_and_back,\n",
        "            run_time=len(words) - 1,\n",
        "            lag_ratio=0.6,\n",
        "            remover=True\n",
        "        )\n",
        "\n",
        "\n",
        "class Wrapper(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\": \"\",\n",
        "        \"title_kwargs\": {},\n",
        "        \"screen_height\": 6,\n",
        "        \"wait_time\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        rect = self.rect = ScreenRectangle(height=self.screen_height)\n",
        "        title = self.title = OldTexText(self.title, **self.title_kwargs)\n",
        "        title.to_edge(UP)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(self.wait_time)\n",
        "\n",
        "\n",
        "class DomainColoringWrapper(Wrapper):\n",
        "    CONFIG = {\n",
        "        \"title\": \"Complex $\\\\rightarrow$ Complex\",\n",
        "    }\n",
        "\n",
        "\n",
        "class R2ToR2Wrapper(Wrapper):\n",
        "    CONFIG = {\"title\": \"$\\\\mathds{R}^2 \\\\rightarrow \\\\mathds{R}^2$\"}\n",
        "\n",
        "\n",
        "class ExampleMultivariableFunction(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"show_basis_vectors\": False,\n",
        "        \"show_coordinates\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        def example_function(point):\n",
        "            x, y, z = point\n",
        "            return np.array([\n",
        "                x + np.sin(y),\n",
        "                y + np.sin(x),\n",
        "                0\n",
        "            ])\n",
        "        self.wait()\n",
        "        self.apply_nonlinear_transformation(example_function, run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ChangingVectorFieldWrapper(Wrapper):\n",
        "    CONFIG = {\"title\": \"$(x, y, t) \\\\rightarrow (x', y')$\"}\n",
        "\n",
        "\n",
        "class ChangingVectorField(Scene):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        plane = self.plane = NumberPlane()\n",
        "        plane.set_stroke(width=2)\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "\n",
        "        # Obviously a silly thing to do, but I'm sweeping\n",
        "        # through trying to make sure old scenes don't\n",
        "        # completely break in spots which used to have\n",
        "        # Continual animations\n",
        "        time_tracker = self.time_tracker = ValueTracker(0)\n",
        "        time_tracker.add_updater(\n",
        "            lambda t: t.set_value(self.get_time())\n",
        "        )\n",
        "\n",
        "        vectors = self.get_vectors()\n",
        "        vectors.add_updater(self.update_vectors)\n",
        "        self.add(vectors)\n",
        "        self.wait(self.wait_time)\n",
        "\n",
        "    def get_vectors(self):\n",
        "        vectors = VGroup()\n",
        "        x_max = int(np.ceil(FRAME_WIDTH))\n",
        "        y_max = int(np.ceil(FRAME_HEIGHT))\n",
        "        step = 0.5\n",
        "        for x in np.arange(-x_max, x_max + 1, step):\n",
        "            for y in np.arange(-y_max, y_max + 1, step):\n",
        "                point = x * RIGHT + y * UP\n",
        "                vectors.add(Vector(RIGHT).shift(point))\n",
        "        vectors.set_color_by_gradient(YELLOW, RED)\n",
        "        return vectors\n",
        "\n",
        "    def update_vectors(self, vectors):\n",
        "        time = self.time_tracker.get_value()\n",
        "        for vector in vectors:\n",
        "            point = vector.get_start()\n",
        "            out_point = self.func(point, time)\n",
        "            norm = get_norm(out_point)\n",
        "            if norm == 0:\n",
        "                out_point = RIGHT  # Fake it\n",
        "                vector.set_fill(opacity=0)\n",
        "            else:\n",
        "                out_point *= 0.5\n",
        "                color = interpolate_color(BLUE, RED, norm / np.sqrt(8))\n",
        "                vector.set_fill(color, opacity=1)\n",
        "                vector.set_stroke(BLACK, width=1)\n",
        "            new_x, new_y = out_point[:2]\n",
        "            vector.put_start_and_end_on(\n",
        "                point, point + new_x * RIGHT + new_y * UP\n",
        "            )\n",
        "\n",
        "    def func(self, point, time):\n",
        "        x, y, z = point\n",
        "        return np.array([\n",
        "            np.sin(time + 0.5 * x + y),\n",
        "            np.cos(time + 0.2 * x * y + 0.7),\n",
        "            0\n",
        "        ])\n",
        "\n",
        "\n",
        "class MoreTopics(Scene):\n",
        "    def construct(self):\n",
        "        calculus = OldTexText(\"Calculus\")\n",
        "        calculus.next_to(LEFT, LEFT)\n",
        "        calculus.set_color(YELLOW)\n",
        "        calculus.add_background_rectangle()\n",
        "        others = VGroup(\n",
        "            OldTexText(\"Multivariable calculus\"),\n",
        "            OldTexText(\"Complex analysis\"),\n",
        "            OldTexText(\"Differential geometry\"),\n",
        "            OldTexText(\"$\\\\vdots$\")\n",
        "        )\n",
        "        for word in others:\n",
        "            word.add_background_rectangle()\n",
        "        others.arrange(\n",
        "            DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT,\n",
        "        )\n",
        "        others.next_to(RIGHT, RIGHT)\n",
        "        lines = VGroup(*[\n",
        "            Line(calculus.get_right(), word.get_left(), buff=MED_SMALL_BUFF)\n",
        "            for word in others\n",
        "        ])\n",
        "\n",
        "        rect = FullScreenFadeRectangle(fill_opacity=0.7)\n",
        "        self.add(rect)\n",
        "\n",
        "        self.add(calculus)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(Write, others),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.calculus = calculus\n",
        "        self.lines = lines\n",
        "        self.full_screen_rect = rect\n",
        "        self.other_topics = others\n",
        "\n",
        "\n",
        "class TransformationalViewWrapper(Wrapper):\n",
        "    CONFIG = {\n",
        "        \"title\": \"Transformational view\"\n",
        "    }\n",
        "\n",
        "\n",
        "class SetTheStage(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        ordinary = OldTexText(\"Ordinary visual\")\n",
        "        transformational = OldTexText(\"Transformational visual\")\n",
        "        for word in ordinary, transformational:\n",
        "            word.move_to(self.hold_up_spot, DOWN)\n",
        "            word.shift_onto_screen()\n",
        "\n",
        "        self.screen.scale(1.25, about_edge=UL)\n",
        "        self.add(self.screen)\n",
        "        self.teacher_holds_up(\n",
        "            ordinary,\n",
        "            added_anims=[self.change_students(*3 * [\"sassy\"])]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ordinary.shift, UP,\n",
        "            FadeInFromDown(transformational),\n",
        "            self.teacher.change, \"hooray\",\n",
        "            self.change_students(*3 * [\"erm\"])\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play_all_student_changes(\"pondering\", look_at=self.screen)\n",
        "\n",
        "\n",
        "class StandardDerivativeVisual(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"y_max\": 8,\n",
        "        \"y_axis_height\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_function_graph()\n",
        "        self.show_slope_of_graph()\n",
        "        self.encourage_not_to_think_of_slope_as_definition()\n",
        "        self.show_sensitivity()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"Standard derivative visual\")\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_WIDTH - 2 * LARGE_BUFF)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title, h_line)\n",
        "\n",
        "    def show_function_graph(self):\n",
        "        self.setup_axes()\n",
        "\n",
        "        def func(x):\n",
        "            x -= 5\n",
        "            return 0.1 * (x + 3) * (x - 3) * x + 3\n",
        "        graph = self.get_graph(func)\n",
        "        graph_label = self.get_graph_label(graph, x_val=9.5)\n",
        "\n",
        "        input_tracker = ValueTracker(4)\n",
        "\n",
        "        def get_x_value():\n",
        "            return input_tracker.get_value()\n",
        "\n",
        "        def get_y_value():\n",
        "            return graph.underlying_function(get_x_value())\n",
        "\n",
        "        def get_x_point():\n",
        "            return self.coords_to_point(get_x_value(), 0)\n",
        "\n",
        "        def get_y_point():\n",
        "            return self.coords_to_point(0, get_y_value())\n",
        "\n",
        "        def get_graph_point():\n",
        "            return self.coords_to_point(get_x_value(), get_y_value())\n",
        "\n",
        "        def get_v_line():\n",
        "            return DashedLine(get_x_point(), get_graph_point(), stroke_width=2)\n",
        "\n",
        "        def get_h_line():\n",
        "            return DashedLine(get_graph_point(), get_y_point(), stroke_width=2)\n",
        "\n",
        "        input_triangle = RegularPolygon(n=3, start_angle=TAU / 4)\n",
        "        output_triangle = RegularPolygon(n=3, start_angle=0)\n",
        "        for triangle in input_triangle, output_triangle:\n",
        "            triangle.set_fill(WHITE, 1)\n",
        "            triangle.set_stroke(width=0)\n",
        "            triangle.scale(0.1)\n",
        "\n",
        "        input_triangle_update = input_tracker.add_updater(\n",
        "            lambda m: m.move_to(get_x_point(), UP)\n",
        "        )\n",
        "        output_triangle_update = output_triangle.add_updater(\n",
        "            lambda m: m.move_to(get_y_point(), RIGHT)\n",
        "        )\n",
        "\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label_update = Mobject.add_updater(\n",
        "            x_label, lambda m: m.next_to(input_triangle, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        output_label = OldTex(\"f(x)\")\n",
        "        output_label_update = Mobject.add_updater(\n",
        "            output_label, lambda m: m.next_to(\n",
        "                output_triangle, LEFT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        v_line = get_v_line()\n",
        "        v_line_update = Mobject.add_updater(\n",
        "            v_line, lambda vl: Transform(vl, get_v_line()).update(1)\n",
        "        )\n",
        "\n",
        "        h_line = get_h_line()\n",
        "        h_line_update = Mobject.add_updater(\n",
        "            h_line, lambda hl: Transform(hl, get_h_line()).update(1)\n",
        "        )\n",
        "\n",
        "        graph_dot = Dot(color=YELLOW)\n",
        "        graph_dot_update = Mobject.add_updater(\n",
        "            graph_dot, lambda m: m.move_to(get_graph_point())\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(graph_label),\n",
        "        )\n",
        "        self.play(\n",
        "            DrawBorderThenFill(input_triangle, run_time=1),\n",
        "            Write(x_label),\n",
        "            ShowCreation(v_line),\n",
        "            GrowFromCenter(graph_dot),\n",
        "        )\n",
        "        self.add_foreground_mobject(graph_dot)\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            Write(output_label),\n",
        "            DrawBorderThenFill(output_triangle, run_time=1)\n",
        "        )\n",
        "        self.add(\n",
        "            input_triangle_update,\n",
        "            x_label_update,\n",
        "            graph_dot_update,\n",
        "            v_line_update,\n",
        "            h_line_update,\n",
        "            output_triangle_update,\n",
        "            output_label_update,\n",
        "        )\n",
        "        self.play(\n",
        "            input_tracker.set_value, 8,\n",
        "            run_time=6,\n",
        "            rate_func=there_and_back\n",
        "        )\n",
        "\n",
        "        self.input_tracker = input_tracker\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_slope_of_graph(self):\n",
        "        input_tracker = self.input_tracker\n",
        "        deriv_input_tracker = ValueTracker(input_tracker.get_value())\n",
        "\n",
        "        # Slope line\n",
        "        def get_slope_line():\n",
        "            return self.get_secant_slope_group(\n",
        "                x=deriv_input_tracker.get_value(),\n",
        "                graph=self.graph,\n",
        "                dx=0.01,\n",
        "                secant_line_length=4\n",
        "            ).secant_line\n",
        "\n",
        "        slope_line = get_slope_line()\n",
        "        slope_line_update = Mobject.add_updater(\n",
        "            slope_line, lambda sg: Transform(sg, get_slope_line()).update(1)\n",
        "        )\n",
        "\n",
        "        def position_deriv_label(deriv_label):\n",
        "            deriv_label.next_to(slope_line, UP)\n",
        "            return deriv_label\n",
        "        deriv_label = OldTex(\n",
        "            \"\\\\frac{df}{dx}(x) =\", \"\\\\text{Slope}\", \"=\"\n",
        "        )\n",
        "        deriv_label.get_part_by_tex(\"Slope\").match_color(slope_line)\n",
        "        deriv_label_update = Mobject.add_updater(\n",
        "            deriv_label, position_deriv_label\n",
        "        )\n",
        "\n",
        "        slope_decimal = DecimalNumber(slope_line.get_slope())\n",
        "        slope_decimal.match_color(slope_line)\n",
        "        slope_decimal.add_updater(\n",
        "            lambda d: d.set_value(slope_line.get_slope())\n",
        "        )\n",
        "        slope_decimal.add_upater(\n",
        "            lambda d: d.next_to(\n",
        "                deriv_label, RIGHT, SMALL_BUFF\n",
        "            ).shift(0.2 * SMALL_BUFF * DOWN)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(slope_line),\n",
        "            Write(deriv_label),\n",
        "            Write(slope_decimal),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(\n",
        "            slope_line_update,\n",
        "            # deriv_label_update,\n",
        "        )\n",
        "        for x in 9, 2, 4:\n",
        "            self.play(\n",
        "                input_tracker.set_value, x,\n",
        "                deriv_input_tracker.set_value, x,\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.deriv_input_tracker = deriv_input_tracker\n",
        "\n",
        "    def encourage_not_to_think_of_slope_as_definition(self):\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.to_corner(DR)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Don't think of \\\\\\\\ this as the definition\",\n",
        "            bubble_config={\"height\": 2, \"width\": 4}\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(morty),\n",
        "            UpdateFromAlphaFunc(\n",
        "                morty, lambda m, a: m.set_fill(opacity=1 - a),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def show_sensitivity(self):\n",
        "        input_tracker = self.input_tracker\n",
        "        deriv_input_tracker = self.deriv_input_tracker\n",
        "\n",
        "        self.wiggle_input()\n",
        "        for x in 9, 7, 2:\n",
        "            self.play(\n",
        "                input_tracker.set_value, x,\n",
        "                deriv_input_tracker.set_value, x,\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wiggle_input()\n",
        "\n",
        "    ###\n",
        "    def wiggle_input(self, dx=0.5, run_time=3):\n",
        "        input_tracker = self.input_tracker\n",
        "\n",
        "        x = input_tracker.get_value()\n",
        "        x_min = x - dx\n",
        "        x_max = x + dx\n",
        "        y, y_min, y_max = list(map(\n",
        "            self.graph.underlying_function,\n",
        "            [x, x_min, x_max]\n",
        "        ))\n",
        "        x_line = Line(\n",
        "            self.coords_to_point(x_min, 0),\n",
        "            self.coords_to_point(x_max, 0),\n",
        "        )\n",
        "        y_line = Line(\n",
        "            self.coords_to_point(0, y_min),\n",
        "            self.coords_to_point(0, y_max),\n",
        "        )\n",
        "\n",
        "        x_rect, y_rect = rects = VGroup(Rectangle(), Rectangle())\n",
        "        rects.set_stroke(width=0)\n",
        "        rects.set_fill(YELLOW, 0.5)\n",
        "        x_rect.match_width(x_line)\n",
        "        x_rect.stretch_to_fit_height(0.25)\n",
        "        x_rect.move_to(x_line)\n",
        "        y_rect.match_height(y_line)\n",
        "        y_rect.stretch_to_fit_width(0.25)\n",
        "        y_rect.move_to(y_line)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                input_tracker.set_value, input_tracker.get_value() + dx,\n",
        "                rate_func=lambda t: wiggle(t, 6)\n",
        "            ),\n",
        "            FadeIn(\n",
        "                rects,\n",
        "                rate_func=squish_rate_func(smooth, 0, 0.33),\n",
        "                remover=True,\n",
        "            ),\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.play(FadeOut(rects))\n",
        "\n",
        "\n",
        "class EoCWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\"Essence of calculus\")\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceTransformationView(NumberlineTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"func\": lambda x: 0.5 * np.sin(2 * x) + x,\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 6,\n",
        "            \"unit_size\": 2.0\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_animation_preview()\n",
        "        self.indicate_indicate_point_densities()\n",
        "        self.show_zoomed_transformation()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"$f(x)$ as a transformation\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "    def show_animation_preview(self):\n",
        "        input_points = self.get_sample_input_points()\n",
        "        output_points = list(map(\n",
        "            self.number_func_to_point_func(self.func),\n",
        "            input_points\n",
        "        ))\n",
        "        sample_dots = self.get_sample_dots()\n",
        "        sample_dot_ghosts = sample_dots.copy().fade(0.5)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(ip, op, buff=MED_SMALL_BUFF)\n",
        "            for ip, op in zip(input_points, output_points)\n",
        "        ])\n",
        "        arrows = arrows[1::3]\n",
        "        arrows.set_stroke(BLACK, 1)\n",
        "\n",
        "        for sd in sample_dots:\n",
        "            sd.save_state()\n",
        "            sd.scale(2)\n",
        "            sd.fade(1)\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, sample_dots,\n",
        "            lambda sd: (sd.restore,),\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            GrowArrow, arrows,\n",
        "            run_time=6,\n",
        "            lag_ratio=0.3,\n",
        "        ))\n",
        "        self.add(sample_dot_ghosts)\n",
        "        self.apply_function(\n",
        "            self.func, sample_dots=sample_dots,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, arrows, run_time=1))\n",
        "\n",
        "        self.sample_dots = sample_dots\n",
        "        self.sample_dot_ghosts = sample_dot_ghosts\n",
        "\n",
        "    def indicate_indicate_point_densities(self):\n",
        "        lower_brace = Brace(Line(LEFT, RIGHT), UP)\n",
        "        upper_brace = lower_brace.copy()\n",
        "        input_tracker = ValueTracker(0.5)\n",
        "        dx = 0.5\n",
        "\n",
        "        def update_upper_brace(brace):\n",
        "            x = input_tracker.get_value()\n",
        "            line = Line(\n",
        "                self.get_input_point(x),\n",
        "                self.get_input_point(x + dx),\n",
        "            )\n",
        "            brace.match_width(line, stretch=True)\n",
        "            brace.next_to(line, UP, buff=SMALL_BUFF)\n",
        "            return brace\n",
        "\n",
        "        def update_lower_brace(brace):\n",
        "            x = input_tracker.get_value()\n",
        "            line = Line(\n",
        "                self.get_output_point(self.func(x)),\n",
        "                self.get_output_point(self.func(x + dx)),\n",
        "            )\n",
        "            brace.match_width(line, stretch=True)\n",
        "            brace.next_to(line, UP, buff=SMALL_BUFF)\n",
        "            return brace\n",
        "\n",
        "        lower_brace_anim = UpdateFromFunc(lower_brace, update_lower_brace)\n",
        "        upper_brace_anim = UpdateFromFunc(upper_brace, update_upper_brace)\n",
        "\n",
        "        new_title = OldTexText(\n",
        "            \"$\\\\frac{df}{dx}(x)$ measures stretch/squishing\"\n",
        "        )\n",
        "        new_title.move_to(self.title, UP)\n",
        "\n",
        "        stretch_factor = DecimalNumber(0, color=YELLOW)\n",
        "        stretch_factor_anim = ChangingDecimal(\n",
        "            stretch_factor, lambda a: lower_brace.get_width() / upper_brace.get_width(),\n",
        "            position_update_func=lambda m: m.next_to(lower_brace, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(upper_brace),\n",
        "            FadeOut(self.title),\n",
        "            # FadeIn(new_title)\n",
        "            Write(new_title, run_time=2)\n",
        "        )\n",
        "        self.title = new_title\n",
        "        self.play(\n",
        "            ReplacementTransform(upper_brace.copy(), lower_brace),\n",
        "            GrowFromPoint(stretch_factor, upper_brace.get_center())\n",
        "        )\n",
        "        self.play(\n",
        "            input_tracker.set_value, self.input_line.x_max - dx,\n",
        "            lower_brace_anim,\n",
        "            upper_brace_anim,\n",
        "            stretch_factor_anim,\n",
        "            run_time=8,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        new_sample_dots = self.get_sample_dots()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(\n",
        "                upper_brace, lower_brace, stretch_factor,\n",
        "                self.sample_dots, self.moving_input_line,\n",
        "            )),\n",
        "            FadeIn(new_sample_dots),\n",
        "        )\n",
        "        self.sample_dots = new_sample_dots\n",
        "\n",
        "    def show_zoomed_transformation(self):\n",
        "        x = 2.75\n",
        "        local_sample_dots = self.get_local_sample_dots(x)\n",
        "\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=self.get_local_coordinate_values(x),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            sample_dots=self.sample_dots,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=self.get_local_coordinate_values(self.func(x))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExamplePlease(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Example?\", index=0)\n",
        "        self.teacher_holds_up(OldTex(\"f(x) = x^2\").scale(1.5))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class TalkThroughXSquaredExample(IntroduceTransformationView):\n",
        "    CONFIG = {\n",
        "        \"func\": lambda x: x**2,\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 5,\n",
        "            \"unit_size\": 1.25,\n",
        "        },\n",
        "        \"output_line_config\": {\n",
        "            \"x_max\": 25,\n",
        "        },\n",
        "        \"default_delta_x\": 0.2\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_specific_points_mapping()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"$f(x) = x^2$\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.add(title)\n",
        "\n",
        "    def show_specific_points_mapping(self):\n",
        "        # First, just show integers as examples\n",
        "        int_dots = self.get_sample_dots(1, 6, 1)\n",
        "        int_dot_ghosts = int_dots.copy().fade(0.5)\n",
        "        int_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                # num.get_bottom(),\n",
        "                self.get_input_point(x),\n",
        "                self.get_output_point(self.func(x)),\n",
        "                buff=MED_SMALL_BUFF\n",
        "            )\n",
        "            for x, num in zip(list(range(1, 6)), self.input_line.numbers[1:])\n",
        "        ])\n",
        "        point_func = self.number_func_to_point_func(self.func)\n",
        "\n",
        "        numbers = self.input_line.numbers\n",
        "        numbers.next_to(self.input_line, UP, SMALL_BUFF)\n",
        "        self.titles[0].next_to(numbers, UP, MED_SMALL_BUFF, LEFT)\n",
        "        # map(Tex.add_background_rectangle, numbers)\n",
        "        # self.add_foreground_mobject(numbers)\n",
        "\n",
        "        for dot, dot_ghost, arrow in zip(int_dots, int_dot_ghosts, int_arrows):\n",
        "            arrow.match_color(dot)\n",
        "            self.play(DrawBorderThenFill(dot, run_time=1))\n",
        "            self.add(dot_ghost)\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                dot.apply_function_to_position, point_func\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show more sample_dots\n",
        "        sample_dots = self.get_sample_dots()\n",
        "        sample_dot_ghosts = sample_dots.copy().fade(0.5)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, sample_dots),\n",
        "            LaggedStartMap(FadeOut, int_arrows),\n",
        "        )\n",
        "        self.remove(int_dot_ghosts)\n",
        "        self.add(sample_dot_ghosts)\n",
        "        self.apply_function(self.func, sample_dots=sample_dots)\n",
        "        self.remove(int_dots)\n",
        "        self.wait()\n",
        "\n",
        "        self.sample_dots = sample_dots\n",
        "        self.sample_dot_ghosts = sample_dot_ghosts\n",
        "\n",
        "    def get_stretch_words(self, factor, color=RED, less_than_one=False):\n",
        "        factor_str = \"$%s$\" % str(factor)\n",
        "        result = OldTexText(\n",
        "            \"Scale \\\\\\\\ by\", factor_str,\n",
        "            tex_to_color_map={factor_str: color}\n",
        "        )\n",
        "        result.scale(0.7)\n",
        "        la, ra = OldTex(\"\\\\leftarrow \\\\rightarrow\")\n",
        "        if less_than_one:\n",
        "            la, ra = ra, la\n",
        "        if factor < 0:\n",
        "            kwargs = {\n",
        "                \"path_arc\": np.pi,\n",
        "            }\n",
        "            la = Arrow(UP, DOWN, **kwargs)\n",
        "            ra = Arrow(DOWN, UP, **kwargs)\n",
        "            for arrow in la, ra:\n",
        "                arrow.pointwise_become_partial(arrow, 0, 0.9)\n",
        "                arrow.tip.scale(2)\n",
        "            VGroup(la, ra).match_height(result)\n",
        "        la.next_to(result, LEFT)\n",
        "        ra.next_to(result, RIGHT)\n",
        "        result.add(la, ra)\n",
        "        result.next_to(\n",
        "            self.zoomed_display.get_top(), DOWN, SMALL_BUFF\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def get_deriv_equation(self, x, rhs, color=RED):\n",
        "        deriv_equation = self.deriv_equation = OldTex(\n",
        "            \"\\\\frac{df}{dx}(\", str(x), \")\", \"=\", str(rhs),\n",
        "            tex_to_color_map={str(x): color, str(rhs): color}\n",
        "        )\n",
        "        deriv_equation.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "        return deriv_equation\n",
        "\n",
        "\n",
        "class ZoomInOnXSquaredNearOne(TalkThroughXSquaredExample):\n",
        "    def setup(self):\n",
        "        TalkThroughXSquaredExample.setup(self)\n",
        "        self.force_skipping()\n",
        "        self.add_title()\n",
        "        self.show_specific_points_mapping()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def construct(self):\n",
        "        zoom_words = OldTexText(\"Zoomed view \\\\\\\\ near 1\")\n",
        "        zoom_words.next_to(self.zoomed_display, DOWN)\n",
        "        # zoom_words.shift_onto_screen()\n",
        "\n",
        "        x = 1\n",
        "        local_sample_dots = self.get_local_sample_dots(x)\n",
        "        local_coords = self.get_local_coordinate_values(x, dx=0.1)\n",
        "\n",
        "        zcbr_anim = self.zoomed_camera_background_rectangle_anim\n",
        "        zcbr_group = self.zoomed_camera_background_rectangle_group\n",
        "        frame = self.zoomed_camera.frame\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "\n",
        "        self.zoom_in_on_input(x, local_sample_dots, local_coords)\n",
        "        self.play(FadeIn(zoom_words))\n",
        "        self.wait()\n",
        "        local_sample_dots.save_state()\n",
        "        frame.save_state()\n",
        "        self.mini_line.save_state()\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=local_coords\n",
        "        )\n",
        "        self.remove(sample_dot_ghost_copies)\n",
        "        self.wait()\n",
        "\n",
        "        # Go back\n",
        "        self.play(\n",
        "            frame.restore,\n",
        "            self.mini_line.restore,\n",
        "            local_sample_dots.restore,\n",
        "            zcbr_anim,\n",
        "            Animation(zcbr_group)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in even more\n",
        "        extra_zoom_factor = 0.3\n",
        "        one_group = VGroup(\n",
        "            self.local_coordinates.tick_marks[1],\n",
        "            self.local_coordinates.numbers[1],\n",
        "        )\n",
        "        all_other_coordinates = VGroup(\n",
        "            self.local_coordinates.tick_marks[::2],\n",
        "            self.local_coordinates.numbers[::2],\n",
        "            self.local_target_coordinates,\n",
        "        )\n",
        "        self.play(frame.scale, extra_zoom_factor)\n",
        "        new_local_sample_dots = self.get_local_sample_dots(x, delta_x=0.005)\n",
        "        new_coordinate_values = self.get_local_coordinate_values(x, dx=0.02)\n",
        "        new_local_coordinates = self.get_local_coordinates(\n",
        "            self.input_line, *new_coordinate_values\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(new_local_coordinates),\n",
        "            Write(new_local_sample_dots),\n",
        "            one_group.scale, extra_zoom_factor, {\"about_point\": self.get_input_point(1)},\n",
        "            FadeOut(all_other_coordinates),\n",
        "            *[\n",
        "                ApplyMethod(dot.scale, extra_zoom_factor)\n",
        "                for dot in local_sample_dots\n",
        "            ]\n",
        "        )\n",
        "        self.remove(one_group, local_sample_dots)\n",
        "        zcbr_group.remove(\n",
        "            self.local_coordinates, self.local_target_coordinates,\n",
        "            local_sample_dots\n",
        "        )\n",
        "\n",
        "        # Transform new zoomed view\n",
        "        stretch_by_two_words = self.get_stretch_words(2)\n",
        "        self.add_foreground_mobject(stretch_by_two_words)\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=new_local_sample_dots,\n",
        "            target_coordinate_values=new_coordinate_values,\n",
        "            added_anims=[FadeIn(stretch_by_two_words)]\n",
        "        )\n",
        "        self.remove(sample_dot_ghost_copies)\n",
        "        self.wait()\n",
        "\n",
        "        # Write derivative\n",
        "        deriv_equation = self.get_deriv_equation(1, 2, color=RED)\n",
        "        self.play(Write(deriv_equation))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ZoomInOnXSquaredNearThree(ZoomInOnXSquaredNearOne):\n",
        "    CONFIG = {\n",
        "        \"zoomed_display_width\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        zoom_words = OldTexText(\"Zoomed view \\\\\\\\ near 3\")\n",
        "        zoom_words.next_to(self.zoomed_display, DOWN)\n",
        "\n",
        "        x = 3\n",
        "        local_sample_dots = self.get_local_sample_dots(x)\n",
        "        local_coordinate_values = self.get_local_coordinate_values(x, dx=0.1)\n",
        "        target_coordinate_values = self.get_local_coordinate_values(self.func(x), dx=0.1)\n",
        "\n",
        "        color = self.sample_dots[len(self.sample_dots) / 2].get_color()\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "        stretch_words = self.get_stretch_words(2 * x, color)\n",
        "        deriv_equation = self.get_deriv_equation(x, 2 * x, color)\n",
        "\n",
        "        self.add(deriv_equation)\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            pop_out=False,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values\n",
        "        )\n",
        "        self.play(Write(zoom_words, run_time=1))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(stretch_words)\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=target_coordinate_values,\n",
        "            added_anims=[Write(stretch_words)]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ZoomInOnXSquaredNearOneFourth(ZoomInOnXSquaredNearOne):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\": 0.01,\n",
        "        \"local_coordinate_num_decimal_places\": 4,\n",
        "        \"zoomed_display_width\": 4,\n",
        "        \"default_delta_x\": 0.25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Much copy-pasting from previous scenes.  Not great, but\n",
        "        # the fastest way to get the ease-of-tweaking I'd like.\n",
        "        zoom_words = OldTexText(\"Zoomed view \\\\\\\\ near $1/4$\")\n",
        "        zoom_words.next_to(self.zoomed_display, DOWN)\n",
        "\n",
        "        x = 0.25\n",
        "        local_sample_dots = self.get_local_sample_dots(\n",
        "            x, sample_radius=2.5 * self.zoomed_camera.frame.get_width(),\n",
        "        )\n",
        "        local_coordinate_values = self.get_local_coordinate_values(\n",
        "            x, dx=0.01,\n",
        "        )\n",
        "        target_coordinate_values = self.get_local_coordinate_values(\n",
        "            self.func(x), dx=0.01,\n",
        "        )\n",
        "\n",
        "        color = RED\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "        stretch_words = self.get_stretch_words(\"1/2\", color, less_than_one=True)\n",
        "        deriv_equation = self.get_deriv_equation(\"1/4\", \"1/2\", color)\n",
        "\n",
        "        one_fourth_point = self.get_input_point(x)\n",
        "        one_fourth_arrow = Vector(0.5 * UP, color=WHITE)\n",
        "        one_fourth_arrow.stem.stretch(0.75, 0)\n",
        "        one_fourth_arrow.tip.scale(0.75, about_edge=DOWN)\n",
        "        one_fourth_arrow.next_to(one_fourth_point, DOWN, SMALL_BUFF)\n",
        "        one_fourth_label = OldTex(\"0.25\")\n",
        "        one_fourth_label.match_height(self.input_line.numbers)\n",
        "        one_fourth_label.next_to(one_fourth_arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(deriv_equation)\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values,\n",
        "            pop_out=False,\n",
        "            first_added_anims=[\n",
        "                FadeIn(one_fourth_label),\n",
        "                GrowArrow(one_fourth_arrow),\n",
        "            ]\n",
        "        )\n",
        "        self.play(Write(zoom_words, run_time=1))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(stretch_words)\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=target_coordinate_values,\n",
        "            added_anims=[Write(stretch_words)]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ZoomInOnXSquaredNearZero(ZoomInOnXSquaredNearOne):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\": 0.1,\n",
        "        \"zoomed_display_width\": 4,\n",
        "        \"scale_by_term\": \"???\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        zoom_words = OldTexText(\n",
        "            \"Zoomed %sx \\\\\\\\ near 0\" % \"{:,}\".format(int(1.0 / self.zoom_factor))\n",
        "        )\n",
        "        zoom_words.next_to(self.zoomed_display, DOWN)\n",
        "\n",
        "        x = 0\n",
        "        local_sample_dots = self.get_local_sample_dots(\n",
        "            x, sample_radius=2 * self.zoomed_camera.frame.get_width()\n",
        "        )\n",
        "        local_coordinate_values = self.get_local_coordinate_values(\n",
        "            x, dx=self.zoom_factor\n",
        "        )\n",
        "        # target_coordinate_values = self.get_local_coordinate_values(\n",
        "        #     self.func(x), dx=self.zoom_factor\n",
        "        # )\n",
        "\n",
        "        color = self.sample_dots[len(self.sample_dots) / 2].get_color()\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "        stretch_words = self.get_stretch_words(\n",
        "            self.scale_by_term, color, less_than_one=True\n",
        "        )\n",
        "        deriv_equation = self.get_deriv_equation(x, 2 * x, color)\n",
        "\n",
        "        self.add(deriv_equation)\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            pop_out=False,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values\n",
        "        )\n",
        "        self.play(Write(zoom_words, run_time=1))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(stretch_words)\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            # target_coordinate_values=target_coordinate_values,\n",
        "            added_anims=[\n",
        "                Write(stretch_words),\n",
        "                MaintainPositionRelativeTo(\n",
        "                    self.local_coordinates,\n",
        "                    self.zoomed_camera.frame\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ZoomInMoreAndMoreToZero(ZoomInOnXSquaredNearZero):\n",
        "    def construct(self):\n",
        "        x = 0\n",
        "        color = self.sample_dots[len(self.sample_dots) / 2].get_color()\n",
        "        deriv_equation = self.get_deriv_equation(x, 2 * x, color)\n",
        "        self.add(deriv_equation)\n",
        "\n",
        "        frame = self.zoomed_camera.frame\n",
        "        zoomed_display_height = self.zoomed_display.get_height()\n",
        "\n",
        "        last_sample_dots = VGroup()\n",
        "        last_coords = VGroup()\n",
        "        last_zoom_words = None\n",
        "        for factor in 0.1, 0.01, 0.001, 0.0001:\n",
        "            frame.save_state()\n",
        "            frame.set_height(factor * zoomed_display_height)\n",
        "            self.local_coordinate_num_decimal_places = int(-np.log10(factor))\n",
        "            zoom_words = OldTexText(\n",
        "                \"Zoomed\", \"{:,}x \\\\\\\\\".format(int(1.0 / factor)),\n",
        "                \"near 0\",\n",
        "            )\n",
        "            zoom_words.next_to(self.zoomed_display, DOWN)\n",
        "\n",
        "            sample_dots = self.get_local_sample_dots(x)\n",
        "            coords = self.get_local_coordinate_values(x, dx=factor)\n",
        "            frame.restore()\n",
        "\n",
        "            added_anims = [\n",
        "                ApplyMethod(last_sample_dots.fade, 1),\n",
        "                ApplyMethod(last_coords.fade, 1),\n",
        "            ]\n",
        "            if last_zoom_words is not None:\n",
        "                added_anims.append(ReplacementTransform(\n",
        "                    last_zoom_words, zoom_words\n",
        "                ))\n",
        "            else:\n",
        "                added_anims.append(FadeIn(zoom_words))\n",
        "            self.zoom_in_on_input(\n",
        "                x,\n",
        "                local_sample_dots=sample_dots,\n",
        "                local_coordinate_values=coords,\n",
        "                pop_out=False,\n",
        "                zoom_factor=factor,\n",
        "                first_added_anims=added_anims\n",
        "            )\n",
        "            self.wait()\n",
        "            last_sample_dots = sample_dots\n",
        "            last_coords = self.local_coordinates\n",
        "            last_zoom_words = zoom_words\n",
        "\n",
        "\n",
        "class ZoomInOnXSquared100xZero(ZoomInOnXSquaredNearZero):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\": 0.01\n",
        "    }\n",
        "\n",
        "\n",
        "class ZoomInOnXSquared1000xZero(ZoomInOnXSquaredNearZero):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\": 0.001,\n",
        "        \"local_coordinate_num_decimal_places\": 3,\n",
        "    }\n",
        "\n",
        "\n",
        "class ZoomInOnXSquared10000xZero(ZoomInOnXSquaredNearZero):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\": 0.0001,\n",
        "        \"local_coordinate_num_decimal_places\": 4,\n",
        "        \"scale_by_term\": \"0\",\n",
        "    }\n",
        "\n",
        "\n",
        "class XSquaredForNegativeInput(TalkThroughXSquaredExample):\n",
        "    CONFIG = {\n",
        "        \"input_line_config\": {\n",
        "            \"x_min\": -4,\n",
        "            \"x_max\": 4,\n",
        "        },\n",
        "        \"input_line_zero_point\": 0.5 * UP + 0 * LEFT,\n",
        "        \"output_line_config\": {},\n",
        "        \"default_mapping_animation_config\": {\n",
        "            \"path_arc\": 30 * DEGREES\n",
        "        },\n",
        "        \"zoomed_display_width\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_full_transformation()\n",
        "        self.zoom_in_on_example()\n",
        "\n",
        "    def show_full_transformation(self):\n",
        "        sample_dots = self.get_sample_dots(\n",
        "            x_min=-4.005,\n",
        "            delta_x=0.05,\n",
        "            dot_radius=0.05\n",
        "        )\n",
        "        sample_dots.set_fill(opacity=0.8)\n",
        "\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, sample_dots))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, sample_dots[len(sample_dots) / 2:0:-1],\n",
        "            lambda mob: (\n",
        "                lambda m: m.scale(2).shift(SMALL_BUFF * UP).set_color(PINK),\n",
        "                mob,\n",
        "            ),\n",
        "            rate_func=there_and_back,\n",
        "        ))\n",
        "        self.add_sample_dot_ghosts(sample_dots)\n",
        "        self.apply_function(self.func, sample_dots=sample_dots)\n",
        "        self.wait()\n",
        "\n",
        "    def zoom_in_on_example(self):\n",
        "        x = -2\n",
        "\n",
        "        local_sample_dots = self.get_local_sample_dots(x)\n",
        "        local_coordinate_values = self.get_local_coordinate_values(\n",
        "            x, dx=0.1\n",
        "        )\n",
        "        target_coordinate_values = self.get_local_coordinate_values(\n",
        "            self.func(x), dx=0.1\n",
        "        )\n",
        "        deriv_equation = self.get_deriv_equation(x, 2 * x, color=BLUE)\n",
        "        sample_dot_ghost_copies = self.sample_dot_ghosts.copy()\n",
        "        scale_words = self.get_stretch_words(-4, color=BLUE)\n",
        "\n",
        "        self.zoom_in_on_input(\n",
        "            x,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(deriv_equation))\n",
        "        self.add_foreground_mobject(scale_words)\n",
        "        self.play(Write(scale_words))\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            sample_dots=sample_dot_ghost_copies,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=target_coordinate_values\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FeelsALittleCramped(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Kind of cramped,\\\\\\\\ isn't it?\",\n",
        "            target_mode=\"sassy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Sure, but think \\\\\\\\ locally\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\", look_at=self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class HowDoesThisSolveProblems(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Is this...useful?\",\n",
        "            target_mode=\"confused\"\n",
        "        )\n",
        "        self.play_student_changes(\"maybe\", \"confused\", \"sassy\")\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class IntroduceContinuedFractionPuzzle(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"remove_initial_rhs\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.ask_question()\n",
        "        self.set_equal_to_x()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.to_corner(DR)\n",
        "\n",
        "        friend = PiCreature(color=GREEN, height=2)\n",
        "        friend.to_edge(DOWN)\n",
        "        friend.shift(LEFT)\n",
        "\n",
        "        group = VGroup(morty, friend)\n",
        "        group.shift(2 * LEFT)\n",
        "\n",
        "        return morty, friend\n",
        "\n",
        "    def ask_question(self):\n",
        "        morty, friend = self.pi_creatures\n",
        "        frac = get_phi_continued_fraction(9)\n",
        "        frac.scale(0.8)\n",
        "        rhs = DecimalNumber(\n",
        "            (1 - np.sqrt(5)) / 2.0,\n",
        "            num_decimal_places=5,\n",
        "            show_ellipsis=True,\n",
        "        )\n",
        "        rhs.set_color(YELLOW)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(frac.get_part_by_tex(\"\\\\over\"), RIGHT)\n",
        "        rhs.next_to(equals, RIGHT)\n",
        "        group = VGroup(frac, equals, rhs)\n",
        "        group.scale(1.5)\n",
        "        group.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Write, frac,\n",
        "                run_time=15,\n",
        "                lag_ratio=0.15,\n",
        "            ),\n",
        "            FadeInFromDown(equals),\n",
        "            FadeInFromDown(rhs),\n",
        "            PiCreatureSays(\n",
        "                friend, \"Would this be valid? \\\\\\\\ If not, why not?\",\n",
        "                target_mode=\"confused\",\n",
        "                look_at=frac,\n",
        "                bubble_config={\n",
        "                    \"direction\": RIGHT,\n",
        "                    \"width\": 4,\n",
        "                    \"height\": 3,\n",
        "                }\n",
        "            ),\n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        anims = [\n",
        "            RemovePiCreatureBubble(\n",
        "                friend, target_mode=\"pondering\",\n",
        "                look_at=frac\n",
        "            ),\n",
        "        ]\n",
        "        if self.remove_initial_rhs:\n",
        "            anims += [\n",
        "                Animation(frac),\n",
        "                FadeOut(equals),\n",
        "                rhs.scale, 0.5,\n",
        "                rhs.to_corner, DL,\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "\n",
        "        self.neg_one_over_phi = rhs\n",
        "        self.equals = equals\n",
        "        self.frac = frac\n",
        "\n",
        "    def set_equal_to_x(self):\n",
        "        frac = self.frac\n",
        "        morty, friend = self.get_pi_creatures()\n",
        "\n",
        "        inner_frac = frac[4:]\n",
        "        inner_frac_rect = SurroundingRectangle(\n",
        "            inner_frac, stroke_width=2, buff=0.5 * SMALL_BUFF\n",
        "        )\n",
        "        inner_frac_group = VGroup(inner_frac, inner_frac_rect)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(frac[3], RIGHT)\n",
        "        x, new_x = [Tex(\"x\") for i in range(2)]\n",
        "        xs = VGroup(x, new_x)\n",
        "        xs.set_color(YELLOW)\n",
        "        xs.scale(1.3)\n",
        "        x.next_to(equals, RIGHT)\n",
        "        new_x.next_to(frac[3], DOWN, 2 * SMALL_BUFF)\n",
        "\n",
        "        fixed_point_words = VGroup(\n",
        "            OldTexText(\"Fixed point of\"),\n",
        "            OldTex(\n",
        "                \"f(x) = 1 + \\\\frac{1}{x}\",\n",
        "                tex_to_color_map={\"x\": YELLOW}\n",
        "            )\n",
        "        )\n",
        "        fixed_point_words.arrange(DOWN)\n",
        "\n",
        "        self.play(Write(x), Write(equals))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(inner_frac_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            inner_frac_group.scale, 0.75,\n",
        "            inner_frac_group.center,\n",
        "            inner_frac_group.to_edge, LEFT,\n",
        "            ReplacementTransform(\n",
        "                x.copy(), new_x,\n",
        "                path_arc=-90 * DEGREES\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frac[3].stretch, 0.1, 0, {\"about_edge\": RIGHT},\n",
        "            MaintainPositionRelativeTo(\n",
        "                VGroup(frac[2], new_x), frac[3]\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                frac[:2], lambda m: m.next_to(frac[3], LEFT)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        fixed_point_words.next_to(VGroup(frac[0], xs), DOWN, LARGE_BUFF)\n",
        "        self.play(\n",
        "            Write(fixed_point_words),\n",
        "            morty.change, \"hooray\",\n",
        "            friend.change, \"happy\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class GraphOnePlusOneOverX(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\": -6,\n",
        "        \"x_max\": 6,\n",
        "        \"x_axis_width\": 12,\n",
        "        \"y_min\": -4,\n",
        "        \"y_max\": 5,\n",
        "        \"y_axis_height\": 8,\n",
        "        \"y_axis_label\": None,\n",
        "        \"graph_origin\": 0.5 * DOWN,\n",
        "        \"num_graph_anchor_points\": 100,\n",
        "        \"func_graph_color\": GREEN,\n",
        "        \"identity_graph_color\": BLUE,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.setup_axes()\n",
        "        self.draw_graphs()\n",
        "        self.show_solutions()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTex(\n",
        "            \"\\\\text{Solve: }\", \"1 + \\\\frac{1}{x}\", \"=\", \"x\",\n",
        "        )\n",
        "        title.set_color_by_tex(\"x\", self.identity_graph_color, substring=False)\n",
        "        title.set_color_by_tex(\"frac\", self.func_graph_color)\n",
        "        title.to_corner(UL)\n",
        "        self.add(title)\n",
        "\n",
        "    def setup_axes(self):\n",
        "        GraphScene.setup_axes(self)\n",
        "        step = 2\n",
        "        self.x_axis.add_numbers(*list(range(-6, 0, step)) + list(range(step, 7, step)))\n",
        "        self.y_axis.label_direction = RIGHT\n",
        "        self.y_axis.add_numbers(*list(range(-2, 0, step)) + list(range(step, 4, step)))\n",
        "\n",
        "    def draw_graphs(self, animate=True):\n",
        "        lower_func_graph, upper_func_graph = func_graph = VGroup(*[\n",
        "            self.get_graph(\n",
        "                lambda x: 1.0 + 1.0 / x,\n",
        "                x_min=x_min,\n",
        "                x_max=x_max,\n",
        "                color=self.func_graph_color,\n",
        "            )\n",
        "            for x_min, x_max in [(-10, -0.1), (0.1, 10)]\n",
        "        ])\n",
        "        func_graph.label = self.get_graph_label(\n",
        "            upper_func_graph, \"y = 1 + \\\\frac{1}{x}\",\n",
        "            x_val=6, direction=UP,\n",
        "        )\n",
        "\n",
        "        identity_graph = self.get_graph(\n",
        "            lambda x: x, color=self.identity_graph_color\n",
        "        )\n",
        "        identity_graph.label = self.get_graph_label(\n",
        "            identity_graph, \"y = x\",\n",
        "            x_val=3, direction=UL, buff=SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        if animate:\n",
        "            for graph in func_graph, identity_graph:\n",
        "                self.play(\n",
        "                    ShowCreation(graph),\n",
        "                    Write(graph.label),\n",
        "                    run_time=2\n",
        "                )\n",
        "            self.wait()\n",
        "        else:\n",
        "            self.add(\n",
        "                func_graph, func_graph.label,\n",
        "                identity_graph, identity_graph.label,\n",
        "            )\n",
        "\n",
        "        self.func_graph = func_graph\n",
        "        self.identity_graph = identity_graph\n",
        "\n",
        "    def show_solutions(self):\n",
        "        phi = 0.5 * (1 + np.sqrt(5))\n",
        "        phi_bro = 0.5 * (1 - np.sqrt(5))\n",
        "\n",
        "        lines = VGroup()\n",
        "        for num in phi, phi_bro:\n",
        "            line = DashedLine(\n",
        "                self.coords_to_point(num, 0),\n",
        "                self.coords_to_point(num, num),\n",
        "                color=WHITE\n",
        "            )\n",
        "            line_copy = line.copy()\n",
        "            line_copy.set_color(YELLOW)\n",
        "            line.fade(0.5)\n",
        "            line_anim = ShowCreationThenDestruction(\n",
        "                line_copy,\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            )\n",
        "            cycle_animation(line_anim)\n",
        "            lines.add(line)\n",
        "\n",
        "        phi_line, phi_bro_line = lines\n",
        "\n",
        "        decimal_kwargs = {\n",
        "            \"num_decimal_places\": 3,\n",
        "            \"show_ellipsis\": True,\n",
        "            \"color\": YELLOW,\n",
        "        }\n",
        "        arrow_kwargs = {\n",
        "            \"buff\": SMALL_BUFF,\n",
        "            \"color\": WHITE,\n",
        "            \"tip_length\": 0.15,\n",
        "            \"rectangular_stem_width\": 0.025,\n",
        "        }\n",
        "\n",
        "        phi_decimal = DecimalNumber(phi, **decimal_kwargs)\n",
        "        phi_decimal.next_to(phi_line, DOWN, LARGE_BUFF)\n",
        "        phi_arrow = Arrow(\n",
        "            phi_decimal[:4].get_top(), phi_line.get_bottom(),\n",
        "            **arrow_kwargs\n",
        "        )\n",
        "        phi_label = OldTex(\"=\", \"\\\\varphi\")\n",
        "        phi_label.next_to(phi_decimal, RIGHT)\n",
        "        phi_label.set_color_by_tex(\"\\\\varphi\", YELLOW)\n",
        "\n",
        "        phi_bro_decimal = DecimalNumber(phi_bro, **decimal_kwargs)\n",
        "        phi_bro_decimal.next_to(phi_bro_line, UP, LARGE_BUFF)\n",
        "        phi_bro_decimal.shift(0.5 * LEFT)\n",
        "        phi_bro_arrow = Arrow(\n",
        "            phi_bro_decimal[:6].get_bottom(), phi_bro_line.get_top(),\n",
        "            **arrow_kwargs\n",
        "        )\n",
        "\n",
        "        brother_words = OldTexText(\n",
        "            \"$\\\\varphi$'s little brother\",\n",
        "            tex_to_color_map={\"$\\\\varphi$\": YELLOW},\n",
        "            arg_separator=\"\"\n",
        "        )\n",
        "        brother_words.next_to(\n",
        "            phi_bro_decimal[-2], UP, buff=MED_SMALL_BUFF,\n",
        "            aligned_edge=RIGHT\n",
        "        )\n",
        "\n",
        "        self.add(phi_line.continual_anim)\n",
        "        self.play(ShowCreation(phi_line))\n",
        "        self.play(\n",
        "            Write(phi_decimal),\n",
        "            GrowArrow(phi_arrow),\n",
        "        )\n",
        "        self.play(Write(phi_label))\n",
        "        self.wait(3)\n",
        "        self.add(phi_bro_line.continual_anim)\n",
        "        self.play(ShowCreation(phi_bro_line))\n",
        "        self.play(\n",
        "            Write(phi_bro_decimal),\n",
        "            GrowArrow(phi_bro_arrow),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(Write(brother_words))\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class ThinkAboutWithRepeatedApplication(IntroduceContinuedFractionPuzzle):\n",
        "    CONFIG = {\n",
        "        \"remove_initial_rhs\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.ask_question()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.obviously_not()\n",
        "        self.ask_about_fraction()\n",
        "        self.plug_func_into_self()\n",
        "\n",
        "    def obviously_not(self):\n",
        "        morty, friend = self.get_pi_creatures()\n",
        "        friend.change_mode(\"confused\")\n",
        "        randy = Randolph()\n",
        "        randy.match_height(morty)\n",
        "        randy.to_corner(DL)\n",
        "\n",
        "        frac = self.frac\n",
        "        rhs = self.neg_one_over_phi\n",
        "        plusses = frac[1::4]\n",
        "        plus_rects = VGroup(*[\n",
        "            SurroundingRectangle(plus, buff=0) for plus in plusses\n",
        "        ])\n",
        "        plus_rects.set_color(PINK)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, \"Obviously not!\",\n",
        "                bubble_config={\"width\": 3, \"height\": 2},\n",
        "                target_mode=\"angry\",\n",
        "                run_time=1,\n",
        "            ),\n",
        "            morty.change, \"guilty\",\n",
        "            friend.change, \"hesitant\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Animation(frac),\n",
        "            RemovePiCreatureBubble(randy, target_mode=\"sassy\"),\n",
        "            morty.change, \"confused\",\n",
        "            friend.change, \"confused\",\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, plus_rects,\n",
        "            run_time=2,\n",
        "            lag_ratio=0.35,\n",
        "        ))\n",
        "        self.play(WiggleOutThenIn(rhs))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frac.scale, 0.7,\n",
        "            frac.to_corner, UL,\n",
        "            FadeOut(self.equals),\n",
        "            rhs.scale, 0.5,\n",
        "            rhs.center,\n",
        "            rhs.to_edge, LEFT,\n",
        "            FadeOut(randy),\n",
        "            morty.change, \"pondering\",\n",
        "            friend.change, \"pondering\",\n",
        "        )\n",
        "\n",
        "    def ask_about_fraction(self):\n",
        "        frac = self.frac\n",
        "        arrow = Vector(LEFT, color=RED)\n",
        "        arrow.next_to(frac, RIGHT)\n",
        "        question = OldTexText(\"What does this \\\\\\\\ actually mean?\")\n",
        "        question.set_color(RED)\n",
        "        question.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, question, run_time=1),\n",
        "            GrowArrow(arrow),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, frac,\n",
        "                lambda m: (m.set_color, RED),\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.2,\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(question), FadeOut(arrow))\n",
        "\n",
        "    def plug_func_into_self(self, value=1, value_str=\"1\"):\n",
        "        morty, friend = self.pi_creatures\n",
        "\n",
        "        def func(x):\n",
        "            return 1 + 1.0 / x\n",
        "\n",
        "        lines = VGroup()\n",
        "        value_labels = VGroup()\n",
        "        for n_terms in range(5):\n",
        "            lhs = get_nested_f(n_terms, arg=\"c\")\n",
        "            equals = OldTex(\"=\")\n",
        "            rhs = get_nested_one_plus_one_over_x(n_terms, bottom_term=value_str)\n",
        "            equals.next_to(rhs[0], LEFT)\n",
        "            lhs.next_to(equals, LEFT)\n",
        "            lines.add(VGroup(lhs, equals, rhs))\n",
        "\n",
        "            value_label = OldTex(\"= %.3f\\\\dots\" % value)\n",
        "            value = func(value)\n",
        "            value_labels.add(value_label)\n",
        "\n",
        "        lines.arrange(\n",
        "            DOWN, buff=MED_LARGE_BUFF,\n",
        "        )\n",
        "        VGroup(lines, value_labels).scale(0.8)\n",
        "        lines.to_corner(UR)\n",
        "        buff = MED_LARGE_BUFF + MED_SMALL_BUFF + value_labels.get_width()\n",
        "        lines.to_edge(RIGHT, buff=buff)\n",
        "        for line, value_label in zip(lines, value_labels):\n",
        "            value_label.move_to(line[1]).to_edge(RIGHT)\n",
        "\n",
        "        top_line = lines[0]\n",
        "        colors = [WHITE] + color_gradient([YELLOW, RED, PINK], len(lines) - 1)\n",
        "        for n in range(1, len(lines)):\n",
        "            color = colors[n]\n",
        "            lines[n][0].set_color(color)\n",
        "            lines[n][0][1:-1].match_style(lines[n - 1][0])\n",
        "            lines[n][2].set_color(color)\n",
        "            lines[n][2][4:].match_style(lines[n - 1][2])\n",
        "\n",
        "        arrow = Vector(0.5 * DOWN, color=WHITE)\n",
        "        arrow.next_to(value_labels[-1], DOWN)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(top_line),\n",
        "            FadeInFromDown(value_labels[0])\n",
        "        )\n",
        "        for n in range(1, len(lines)):\n",
        "            new_line = lines[n]\n",
        "            last_line = lines[n - 1]\n",
        "            value_label = value_labels[n]\n",
        "            mover, target = [\n",
        "                VGroup(\n",
        "                    line[0][0],\n",
        "                    line[0][-1],\n",
        "                    line[1],\n",
        "                    line[2][:4],\n",
        "                )\n",
        "                for line in (lines[1], new_line)\n",
        "            ]\n",
        "            anims = [ReplacementTransform(\n",
        "                mover.copy().fade(1), target, path_arc=30 * DEGREES\n",
        "            )]\n",
        "            if n == 4:\n",
        "                morty.generate_target()\n",
        "                morty.target.change(\"horrified\")\n",
        "                morty.target.shift(2.5 * DOWN)\n",
        "                anims.append(MoveToTarget(morty, remover=True))\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    last_line[0].copy(), new_line[0][1:-1]\n",
        "                ),\n",
        "                ReplacementTransform(\n",
        "                    last_line[2].copy(), new_line[2][4:]\n",
        "                ),\n",
        "            )\n",
        "            self.play(FadeIn(value_label))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(q_marks),\n",
        "            friend.change, \"confused\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.top_line = VGroup(lines[0], value_labels[0])\n",
        "\n",
        "\n",
        "class RepeatedApplicationWithPhiBro(ThinkAboutWithRepeatedApplication):\n",
        "    CONFIG = {\n",
        "        \"value\": (1 - np.sqrt(5)) / 2,\n",
        "        \"value_str\": \"-1/\\\\varphi\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.ask_question()\n",
        "        self.obviously_not()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.plug_func_into_self(\n",
        "            value=self.value,\n",
        "            value_str=self.value_str\n",
        "        )\n",
        "\n",
        "\n",
        "class RepeatedApplicationWithNegativeSeed(RepeatedApplicationWithPhiBro, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"value\": -0.65,\n",
        "        \"value_str\": \"-0.65\"\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        RepeatedApplicationWithPhiBro.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        RepeatedApplicationWithPhiBro.construct(self)\n",
        "\n",
        "        rect = SurroundingRectangle(self.top_line)\n",
        "        question = OldTexText(\"What about a negative seed?\")\n",
        "        question.match_color(rect)\n",
        "        question.next_to(rect, UP)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            self.camera.frame.set_height, FRAME_HEIGHT + 1.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(question),\n",
        "            FadeOut(rect),\n",
        "            self.camera.frame.set_height, FRAME_HEIGHT\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowRepeatedApplication(Scene):\n",
        "    CONFIG = {\n",
        "        \"title_color\": YELLOW,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_func_title()\n",
        "        self.show_repeated_iteration()\n",
        "\n",
        "    def add_func_title(self):\n",
        "        title = self.title = VGroup(\n",
        "            OldTex(\"f(\", \"x\", \")\"),\n",
        "            OldTex(\"=\"),\n",
        "            get_nested_one_plus_one_over_x(1)\n",
        "        )\n",
        "        title.arrange(RIGHT)\n",
        "        title.to_corner(UL)\n",
        "        title.set_color(self.title_color)\n",
        "\n",
        "        self.add(title)\n",
        "\n",
        "    def show_repeated_iteration(self):\n",
        "        line = VGroup()\n",
        "        decimal_kwargs = {\n",
        "            \"num_decimal_places\": 3,\n",
        "            \"show_ellipsis\": True,\n",
        "        }\n",
        "        phi = (1 + np.sqrt(5)) / 2\n",
        "\n",
        "        def func(x):\n",
        "            return 1.0 + 1.0 / x\n",
        "\n",
        "        initial_term = DecimalNumber(2.71828, **decimal_kwargs)\n",
        "        line.add(initial_term)\n",
        "        last_term = initial_term\n",
        "\n",
        "        def get_arrow():\n",
        "            arrow = OldTex(\"\\\\rightarrow\")\n",
        "            arrow.stretch(1.5, 0)\n",
        "            arrow.next_to(line[-1], RIGHT)\n",
        "            tex = OldTex(\"f(x)\")\n",
        "            tex.set_color(YELLOW)\n",
        "            tex.match_width(arrow)\n",
        "            tex.next_to(arrow, UP, SMALL_BUFF)\n",
        "            return VGroup(arrow, tex)\n",
        "\n",
        "        for x in range(2):\n",
        "            arrow = get_arrow()\n",
        "            line.add(arrow)\n",
        "\n",
        "            new_term = DecimalNumber(\n",
        "                func(last_term.number),\n",
        "                **decimal_kwargs\n",
        "            )\n",
        "            new_term.next_to(arrow[0], RIGHT)\n",
        "            last_term = new_term\n",
        "            line.add(new_term)\n",
        "\n",
        "        line.add(get_arrow())\n",
        "        line.add(OldTex(\"\\\\dots\\\\dots\").next_to(line[-1][0], RIGHT))\n",
        "        num_phi_mob = DecimalNumber(phi, **decimal_kwargs)\n",
        "        line.add(num_phi_mob.next_to(line[-1], RIGHT))\n",
        "        line.move_to(DOWN)\n",
        "\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(mob)\n",
        "            for mob in (line[0], line[1:-1], line[-1])\n",
        "        ])\n",
        "        rects.set_stroke(BLUE, 2)\n",
        "\n",
        "        braces = VGroup(*[\n",
        "            Brace(rect, DOWN, buff=SMALL_BUFF)\n",
        "            for rect in rects\n",
        "        ])\n",
        "        braces.set_color_by_gradient(GREEN, YELLOW)\n",
        "        brace_texts = VGroup(*[\n",
        "            brace.get_text(text).scale(0.75, about_edge=UP)\n",
        "            for brace, text in zip(braces, [\n",
        "                \"Arbitrary \\\\\\\\ starting \\\\\\\\ value\",\n",
        "                \"Repeatedly apply $f(x)$\",\n",
        "                \"$\\\\varphi$ \\\\\\\\ ``Golden ratio''\"\n",
        "            ])\n",
        "        ])\n",
        "        var_phi_mob = brace_texts[2][0]\n",
        "        var_phi_mob.scale(2, about_edge=UP).set_color(YELLOW)\n",
        "        brace_texts[2][1:].next_to(var_phi_mob, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        # Animations\n",
        "        self.add(line[0])\n",
        "        self.play(\n",
        "            GrowFromCenter(braces[0]),\n",
        "            Write(brace_texts[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromEdge(line[1], LEFT),\n",
        "            FadeIn(braces[1]),\n",
        "            FadeIn(brace_texts[1]),\n",
        "        )\n",
        "        self.play(ReplacementTransform(line[0].copy(), line[2]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(GrowFromEdge(line[3], LEFT))\n",
        "        self.play(ReplacementTransform(line[2].copy(), line[4]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(GrowFromEdge(line[5], LEFT))\n",
        "        self.play(LaggedStartMap(GrowFromCenter, line[6]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(line[7]))\n",
        "        self.play(\n",
        "            GrowFromCenter(braces[2]),\n",
        "            FadeIn(brace_texts[2]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NumericalPlayFromOne(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class NumericalPlayFromTau(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class NumericalPlayFromNegPhi(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class NumericalPlayOnNumberLineFromOne(Scene):\n",
        "    CONFIG = {\n",
        "        \"starting_value\": 1,\n",
        "        \"n_jumps\": 10,\n",
        "        \"func\": lambda x: 1 + 1.0 / x,\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 2,\n",
        "            \"unit_size\": 6,\n",
        "            \"tick_frequency\": 0.25,\n",
        "            \"big_tick_numbers\": [0, 1, 2]\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_number_line()\n",
        "        self.add_phi_label()\n",
        "        self.add_title()\n",
        "        self.bounce_around()\n",
        "\n",
        "    def add_number_line(self):\n",
        "        number_line = NumberLine(**self.number_line_config)\n",
        "        number_line.move_to(2 * DOWN)\n",
        "        number_line.add_numbers()\n",
        "\n",
        "        self.add(number_line)\n",
        "        self.number_line = number_line\n",
        "\n",
        "    def add_phi_label(self):\n",
        "        number_line = self.number_line\n",
        "        phi_point = number_line.number_to_point(\n",
        "            (1 + np.sqrt(5)) / 2\n",
        "        )\n",
        "        phi_dot = Dot(phi_point, color=YELLOW)\n",
        "        arrow = Vector(DL)\n",
        "        arrow.next_to(phi_point, UR, SMALL_BUFF)\n",
        "        phi_label = OldTex(\"\\\\varphi = 1.618\\\\dots\")\n",
        "        phi_label.set_color(YELLOW)\n",
        "        phi_label.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(phi_dot, phi_label, arrow)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"x \\\\rightarrow 1 + \\\\frac{1}{x}\")\n",
        "        title.to_corner(UL)\n",
        "        self.add(title)\n",
        "\n",
        "    def bounce_around(self):\n",
        "        number_line = self.number_line\n",
        "        value = self.starting_value\n",
        "        point = number_line.number_to_point(value)\n",
        "        dot = Dot(point)\n",
        "        dot.set_fill(RED, opacity=0.8)\n",
        "        arrow = Vector(DR)\n",
        "        arrow.next_to(point, UL, buff=SMALL_BUFF)\n",
        "        arrow.match_color(dot)\n",
        "        start_here = OldTexText(\"Start here\")\n",
        "        start_here.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "        start_here.match_color(dot)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(start_here),\n",
        "            GrowArrow(arrow),\n",
        "            GrowFromPoint(dot, arrow.get_start())\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(start_here),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(self.n_jumps):\n",
        "            new_value = self.func(value)\n",
        "            new_point = number_line.number_to_point(new_value)\n",
        "            if new_value - value > 0:\n",
        "                path_arc = -120 * DEGREES\n",
        "            else:\n",
        "                path_arc = -120 * DEGREES\n",
        "            arc = Line(\n",
        "                point, new_point,\n",
        "                path_arc=path_arc,\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(arc, run_time=1.5),\n",
        "                ApplyMethod(\n",
        "                    dot.move_to, new_point,\n",
        "                    path_arc=path_arc\n",
        "                ),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "            value = new_value\n",
        "            point = new_point\n",
        "\n",
        "\n",
        "class NumericalPlayOnNumberLineFromTau(NumericalPlayOnNumberLineFromOne):\n",
        "    CONFIG = {\n",
        "        \"starting_value\": TAU,\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 7,\n",
        "            \"unit_size\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "\n",
        "class NumericalPlayOnNumberLineFromMinusPhi(NumericalPlayOnNumberLineFromOne):\n",
        "    CONFIG = {\n",
        "        \"starting_value\": -0.61803,\n",
        "        \"number_line_config\": {\n",
        "            \"x_min\": -3,\n",
        "            \"x_max\": 3,\n",
        "            \"unit_size\": 2,\n",
        "            \"tick_frequency\": 0.25,\n",
        "        },\n",
        "        \"n_jumps\": 25,\n",
        "    }\n",
        "\n",
        "    def add_phi_label(self):\n",
        "        NumericalPlayOnNumberLineFromOne.add_phi_label(self)\n",
        "        number_line = self.number_line\n",
        "        new_point = number_line.number_to_point(\n",
        "            (1 - np.sqrt(5)) / 2\n",
        "        )\n",
        "        arrow = Vector(DR)\n",
        "        arrow.next_to(new_point, UL, SMALL_BUFF)\n",
        "        arrow.set_color(RED)\n",
        "        new_label = OldTex(\"-\\\\frac{1}{\\\\varphi} = -0.618\\\\dots\")\n",
        "        new_label.set_color(RED)\n",
        "        new_label.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "        new_label.shift(RIGHT)\n",
        "        self.add(new_label, arrow)\n",
        "\n",
        "\n",
        "class RepeatedApplicationGraphically(GraphOnePlusOneOverX, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"starting_value\": 1,\n",
        "        \"n_jumps\": 5,\n",
        "        \"n_times_to_show_identity_property\": 2,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        GraphOnePlusOneOverX.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.draw_graphs(animate=False)\n",
        "        self.draw_spider_web()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = Randolph(height=2)\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR)\n",
        "        return randy\n",
        "\n",
        "    def get_new_randy_mode(self):\n",
        "        randy = self.pi_creature\n",
        "        if not hasattr(self, \"n_mode_changes\"):\n",
        "            self.n_mode_changes = 0\n",
        "        else:\n",
        "            self.n_mode_changes += 1\n",
        "        if self.n_mode_changes % 3 != 0:\n",
        "            return randy.get_mode()\n",
        "        return random.choice([\n",
        "            \"confused\",\n",
        "            \"erm\",\n",
        "            \"maybe\"\n",
        "        ])\n",
        "\n",
        "    def draw_spider_web(self):\n",
        "        randy = self.pi_creature\n",
        "        func = self.func_graph[0].underlying_function\n",
        "        x_val = self.starting_value\n",
        "        curr_output = 0\n",
        "        dot = Dot(color=RED, fill_opacity=0.7)\n",
        "        dot.move_to(self.coords_to_point(x_val, curr_output))\n",
        "\n",
        "        self.play(FadeIn(dot, 2 * UR))\n",
        "        self.wait()\n",
        "\n",
        "        for n in range(self.n_jumps):\n",
        "            new_output = func(x_val)\n",
        "            func_graph_point = self.coords_to_point(x_val, new_output)\n",
        "            id_graph_point = self.coords_to_point(new_output, new_output)\n",
        "            v_line = DashedLine(dot.get_center(), func_graph_point)\n",
        "            h_line = DashedLine(func_graph_point, id_graph_point)\n",
        "\n",
        "            curr_output = new_output\n",
        "            x_val = new_output\n",
        "\n",
        "            for line in v_line, h_line:\n",
        "                line_end = line.get_end()\n",
        "                self.play(\n",
        "                    ShowCreation(line),\n",
        "                    dot.move_to, line_end,\n",
        "                    randy.change, self.get_new_randy_mode()\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "            if n < self.n_times_to_show_identity_property:\n",
        "                x_point = self.coords_to_point(new_output, 0)\n",
        "                y_point = self.coords_to_point(0, new_output)\n",
        "                lines = VGroup(*[\n",
        "                    Line(dot.get_center(), point)\n",
        "                    for point in (x_point, y_point)\n",
        "                ])\n",
        "                lines.set_color(YELLOW)\n",
        "                self.play(ShowCreationThenDestruction(\n",
        "                    lines, run_time=2\n",
        "                ))\n",
        "                self.wait(0.25)\n",
        "\n",
        "\n",
        "class RepeatedApplicationGraphicallyFromNegPhi(RepeatedApplicationGraphically):\n",
        "    CONFIG = {\n",
        "        \"starting_value\": -0.61,\n",
        "        \"n_jumps\": 13,\n",
        "        \"n_times_to_show_identity_property\": 0,\n",
        "    }\n",
        "\n",
        "\n",
        "class LetsSwitchToTheTransformationalView(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Lose the \\\\\\\\ graphs!\",\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(\"hooray\", \"erm\", \"surprised\")\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class AnalyzeFunctionWithTransformations(NumberlineTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"input_line_zero_point\": 0.5 * UP,\n",
        "        \"output_line_zero_point\": 2 * DOWN,\n",
        "        \"func\": lambda x: 1 + 1.0 / x,\n",
        "        \"num_initial_applications\": 10,\n",
        "        \"num_repeated_local_applications\": 7,\n",
        "        \"zoomed_display_width\": 3.5,\n",
        "        \"zoomed_display_height\": 2,\n",
        "        \"default_mapping_animation_config\": {},\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_function_title()\n",
        "        self.repeatedly_apply_function()\n",
        "        self.show_phi_and_phi_bro()\n",
        "        self.zoom_in_on_phi()\n",
        "        self.zoom_in_on_phi_bro()\n",
        "\n",
        "    def setup_number_lines(self):\n",
        "        NumberlineTransformationScene.setup_number_lines(self)\n",
        "        for line in self.input_line, self.output_line:\n",
        "            VGroup(line, line.tick_marks).set_stroke(width=2)\n",
        "\n",
        "    def add_function_title(self):\n",
        "        title = OldTex(\"f(x)\", \"=\", \"1 +\", \"\\\\frac{1}{x}\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def repeatedly_apply_function(self):\n",
        "        input_zero_point = self.input_line.number_to_point(0)\n",
        "        output_zero_point = self.output_line.number_to_point(0)\n",
        "        sample_dots = self.get_sample_dots(\n",
        "            delta_x=0.05,\n",
        "            dot_radius=0.05,\n",
        "            x_min=-10,\n",
        "            x_max=10,\n",
        "        )\n",
        "        sample_dots.set_stroke(BLACK, 0.5)\n",
        "        sample_points = list(map(Mobject.get_center, sample_dots))\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, sample_dots,\n",
        "            lambda m: (m, UP)\n",
        "        ))\n",
        "        self.show_arrows(sample_points)\n",
        "        self.wait()\n",
        "        for x in range(self.num_initial_applications):\n",
        "            self.apply_function(\n",
        "                self.func,\n",
        "                apply_function_to_number_line=False,\n",
        "                sample_dots=sample_dots\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            shift_vect = input_zero_point - output_zero_point\n",
        "            shift_vect[0] = 0\n",
        "            lower_output_line = self.output_line.copy()\n",
        "            upper_output_line = self.output_line.copy()\n",
        "            lower_output_line.shift(-shift_vect)\n",
        "            lower_output_line.fade(1)\n",
        "\n",
        "            self.remove(self.output_line)\n",
        "            self.play(\n",
        "                ReplacementTransform(lower_output_line, self.output_line),\n",
        "                upper_output_line.shift, shift_vect,\n",
        "                upper_output_line.fade, 1,\n",
        "                sample_dots.shift, shift_vect,\n",
        "            )\n",
        "            self.remove(upper_output_line)\n",
        "            self.wait()\n",
        "        self.play(FadeOut(sample_dots))\n",
        "\n",
        "    def show_arrows(self, sample_points):\n",
        "        input_zero_point = self.input_line.number_to_point(0)\n",
        "        point_func = self.number_func_to_point_func(self.func)\n",
        "        alt_point_func = self.number_func_to_point_func(lambda x: 1.0 / x)\n",
        "        arrows, alt_arrows = [\n",
        "            VGroup(*[\n",
        "                Arrow(\n",
        "                    point, func(point), buff=SMALL_BUFF,\n",
        "                    tip_length=0.15\n",
        "                )\n",
        "                for point in sample_points\n",
        "                if get_norm(point - input_zero_point) > 0.3\n",
        "            ])\n",
        "            for func in (point_func, alt_point_func)\n",
        "        ]\n",
        "        for group in arrows, alt_arrows:\n",
        "            group.set_stroke(WHITE, 0.5)\n",
        "            group.set_color_by_gradient(RED, YELLOW)\n",
        "            for arrow in group:\n",
        "                arrow.tip.set_stroke(BLACK, 0.5)\n",
        "\n",
        "        one_plus = self.title.get_part_by_tex(\"1 +\")\n",
        "        one_plus_rect = BackgroundRectangle(one_plus)\n",
        "        one_plus_rect.set_fill(BLACK, opacity=0.8)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, arrows,\n",
        "            lambda a: (a.scale, 0.7),\n",
        "            rate_func=there_and_back,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(arrows, alt_arrows),\n",
        "            FadeIn(one_plus_rect, remover=True),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.all_arrows = arrows\n",
        "\n",
        "    def show_phi_and_phi_bro(self):\n",
        "        phi = (1 + np.sqrt(5)) / 2\n",
        "        phi_bro = (1 - np.sqrt(5)) / 2\n",
        "\n",
        "        input_phi_point = self.input_line.number_to_point(phi)\n",
        "        output_phi_point = self.output_line.number_to_point(phi)\n",
        "        input_phi_bro_point = self.input_line.number_to_point(phi_bro)\n",
        "        output_phi_bro_point = self.output_line.number_to_point(phi_bro)\n",
        "\n",
        "        tick = Line(UP, DOWN)\n",
        "        tick.set_stroke(YELLOW, 3)\n",
        "        tick.match_height(self.input_line.tick_marks)\n",
        "        phi_tick = tick.copy().move_to(input_phi_point, DOWN)\n",
        "        phi_bro_tick = tick.copy().move_to(input_phi_bro_point, DOWN)\n",
        "        VGroup(phi_tick, phi_bro_tick).shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        phi_label = OldTex(\"1.618\\\\dots\")\n",
        "        phi_label.next_to(phi_tick, UP)\n",
        "        phi_bro_label = OldTex(\"-0.618\\\\dots\")\n",
        "        phi_bro_label.next_to(phi_bro_tick, UP)\n",
        "        VGroup(phi_label, phi_bro_label).set_color(YELLOW)\n",
        "\n",
        "        arrow_kwargs = {\n",
        "            \"buff\": SMALL_BUFF,\n",
        "            \"rectangular_stem_width\": 0.035,\n",
        "            \"tip_length\": 0.2,\n",
        "        }\n",
        "        phi_arrow = Arrow(phi_tick, output_phi_point, **arrow_kwargs)\n",
        "        phi_bro_arrow = Arrow(phi_bro_tick, output_phi_bro_point, **arrow_kwargs)\n",
        "\n",
        "        def fade_arrow(arrow):\n",
        "            # arrow.set_stroke(GREY_D, 0.5)\n",
        "            arrow.set_stroke(width=0.1)\n",
        "            arrow.tip.set_fill(opacity=0)\n",
        "            arrow.tip.set_stroke(width=0)\n",
        "            return arrow\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyFunction, self.all_arrows,\n",
        "                lambda a: (fade_arrow, a)\n",
        "            ),\n",
        "            FadeIn(phi_arrow),\n",
        "            FadeIn(phi_bro_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(phi_label),\n",
        "            GrowFromCenter(phi_tick)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(phi_bro_label),\n",
        "            GrowFromCenter(phi_bro_tick)\n",
        "        )\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            input_phi_point, output_phi_point,\n",
        "            input_phi_bro_point, output_phi_bro_point,\n",
        "            phi_label, phi_tick,\n",
        "            phi_bro_label, phi_bro_tick,\n",
        "            phi_arrow, phi_bro_arrow\n",
        "        )\n",
        "\n",
        "    def zoom_in_on_phi(self):\n",
        "        phi = (1 + np.sqrt(5)) / 2\n",
        "        # phi_point = self.get_input_point(phi)\n",
        "        local_sample_dots = self.get_local_sample_dots(\n",
        "            phi, dot_radius=0.005, sample_radius=1\n",
        "        )\n",
        "        local_coordinate_values = [1.55, 1.6, 1.65, 1.7]\n",
        "\n",
        "        # zcbr = self.zoomed_camera_background_rectangle\n",
        "        zcbr_group = self.zoomed_camera_background_rectangle_group\n",
        "        zcbr_group.add(self.phi_tick)\n",
        "\n",
        "        title = self.title\n",
        "        deriv_text = OldTex(\n",
        "            \"|\", \"\\\\frac{df}{dx}(\\\\varphi)\", \"|\", \"< 1\",\n",
        "            tex_to_color_map={\"\\\\varphi\": YELLOW}\n",
        "        )\n",
        "        deriv_text.get_parts_by_tex(\"|\").match_height(\n",
        "            deriv_text, stretch=True\n",
        "        )\n",
        "        deriv_text.move_to(title, UP)\n",
        "        approx_value = OldTex(\"\\\\approx |%.2f|\" % (-1 / phi**2))\n",
        "        approx_value.move_to(deriv_text)\n",
        "        deriv_text_lhs = deriv_text[:-1]\n",
        "        deriv_text_rhs = deriv_text[-1]\n",
        "\n",
        "        self.zoom_in_on_input(\n",
        "            phi,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values\n",
        "        )\n",
        "        self.wait()\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=local_coordinate_values,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(deriv_text_lhs),\n",
        "            FadeInFromDown(deriv_text_rhs),\n",
        "            title.to_corner, UL\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            deriv_text_lhs.next_to, approx_value, LEFT,\n",
        "            deriv_text_rhs.next_to, approx_value, RIGHT,\n",
        "            FadeIn(approx_value)\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(self.num_repeated_local_applications):\n",
        "            self.apply_function(\n",
        "                self.func,\n",
        "                apply_function_to_number_line=False,\n",
        "                local_sample_dots=local_sample_dots,\n",
        "                path_arc=60 * DEGREES,\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        self.deriv_text = VGroup(\n",
        "            deriv_text_lhs, deriv_text_rhs, approx_value\n",
        "        )\n",
        "\n",
        "    def zoom_in_on_phi_bro(self):\n",
        "        zcbr = self.zoomed_camera_background_rectangle\n",
        "        # zcbr_group = self.zoomed_camera_background_rectangle_group\n",
        "        zoomed_frame = self.zoomed_camera.frame\n",
        "\n",
        "        phi_bro = (1 - np.sqrt(5)) / 2\n",
        "        # phi_bro_point = self.get_input_point(phi_bro)\n",
        "        local_sample_dots = self.get_local_sample_dots(phi_bro)\n",
        "        local_coordinate_values = [-0.65, -0.6, -0.55]\n",
        "\n",
        "        deriv_text = OldTex(\n",
        "            \"\\\\left| \\\\frac{df}{dx}\\\\left(\\\\frac{-1}{\\\\varphi}\\\\right) \\\\right|\",\n",
        "            \"\\\\approx |%.2f|\" % (-1 / (phi_bro**2)),\n",
        "            \"> 1\"\n",
        "        )\n",
        "        deriv_text.move_to(self.deriv_text, UL)\n",
        "        deriv_text[0][10:14].set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            zoomed_frame.set_height, 4,\n",
        "            zoomed_frame.center,\n",
        "            self.deriv_text.fade, 1,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        zcbr.set_fill(opacity=0)\n",
        "        self.zoom_in_on_input(\n",
        "            phi_bro,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            local_coordinate_values=local_coordinate_values,\n",
        "            zoom_factor=self.zoom_factor,\n",
        "            first_anim_kwargs={\"run_time\": 2},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(deriv_text))\n",
        "        self.wait()\n",
        "        zcbr.set_fill(opacity=1)\n",
        "        self.apply_function(\n",
        "            self.func,\n",
        "            apply_function_to_number_line=False,\n",
        "            local_sample_dots=local_sample_dots,\n",
        "            target_coordinate_values=local_coordinate_values,\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(self.num_repeated_local_applications):\n",
        "            self.apply_function(\n",
        "                self.func,\n",
        "                apply_function_to_number_line=False,\n",
        "                local_sample_dots=local_sample_dots,\n",
        "                path_arc=20 * DEGREES,\n",
        "                run_time=2,\n",
        "            )\n",
        "\n",
        "\n",
        "class StabilityAndInstability(AnalyzeFunctionWithTransformations):\n",
        "    CONFIG = {\n",
        "        \"num_initial_applications\": 0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_function_title()\n",
        "        self.repeatedly_apply_function()\n",
        "        self.show_phi_and_phi_bro()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.label_stability()\n",
        "        self.write_derivative_fact()\n",
        "\n",
        "    def label_stability(self):\n",
        "        self.title.to_corner(UL)\n",
        "\n",
        "        stable_label = OldTexText(\"Stable fixed point\")\n",
        "        unstable_label = OldTexText(\"Unstable fixed point\")\n",
        "        labels = VGroup(stable_label, unstable_label)\n",
        "        labels.scale(0.8)\n",
        "        stable_label.next_to(self.phi_label, UP, aligned_edge=ORIGIN)\n",
        "        unstable_label.next_to(self.phi_bro_label, UP, aligned_edge=ORIGIN)\n",
        "\n",
        "        phi_point = self.input_phi_point\n",
        "        phi_bro_point = self.input_phi_bro_point\n",
        "\n",
        "        arrow_groups = VGroup()\n",
        "        for point in phi_point, phi_bro_point:\n",
        "            arrows = VGroup(*[a for a in self.all_arrows if get_norm(a.get_start() - point) < 0.75]).copy()\n",
        "            arrows.set_fill(PINK, 1)\n",
        "            arrows.set_stroke(PINK, 3)\n",
        "            arrows.second_anim = LaggedStartMap(\n",
        "                ApplyMethod, arrows,\n",
        "                lambda m: (m.set_color, YELLOW),\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                lag_ratio=0.7,\n",
        "                run_time=2,\n",
        "            )\n",
        "            arrows.anim = AnimationGroup(*list(map(GrowArrow, arrows)))\n",
        "            arrow_groups.add(arrows)\n",
        "        phi_arrows, phi_bro_arrows = arrow_groups\n",
        "\n",
        "        self.add_foreground_mobjects(self.phi_arrow, self.phi_bro_arrow)\n",
        "        self.play(\n",
        "            Write(stable_label),\n",
        "            phi_arrows.anim,\n",
        "        )\n",
        "        self.play(phi_arrows.second_anim)\n",
        "        self.play(\n",
        "            Write(unstable_label),\n",
        "            phi_bro_arrows.anim,\n",
        "        )\n",
        "        self.play(phi_bro_arrows.second_anim)\n",
        "        self.wait()\n",
        "\n",
        "        self.stable_label = stable_label\n",
        "        self.unstable_label = unstable_label\n",
        "        self.phi_arrows = phi_arrows\n",
        "        self.phi_bro_arrows = phi_bro_arrows\n",
        "\n",
        "    def write_derivative_fact(self):\n",
        "        stable_label = self.stable_label\n",
        "        unstable_label = self.unstable_label\n",
        "        labels = VGroup(stable_label, unstable_label)\n",
        "        phi_arrows = self.phi_arrows\n",
        "        phi_bro_arrows = self.phi_bro_arrows\n",
        "        arrow_groups = VGroup(phi_arrows, phi_bro_arrows)\n",
        "\n",
        "        deriv_labels = VGroup()\n",
        "        for char, label in zip(\"<>\", labels):\n",
        "            deriv_label = OldTex(\n",
        "                \"\\\\big|\", \"\\\\frac{df}{dx}(\", \"x\", \")\", \"\\\\big|\",\n",
        "                char, \"1\"\n",
        "            )\n",
        "            deriv_label.get_parts_by_tex(\"\\\\big|\").match_height(\n",
        "                deriv_label, stretch=True\n",
        "            )\n",
        "            deriv_label.set_color_by_tex(\"x\", YELLOW, substring=False)\n",
        "            deriv_label.next_to(label, UP)\n",
        "            deriv_labels.add(deriv_label)\n",
        "\n",
        "        dot_groups = VGroup()\n",
        "        for arrow_group in arrow_groups:\n",
        "            dot_group = VGroup()\n",
        "            for arrow in arrow_group:\n",
        "                start_point, end_point = [\n",
        "                    line.number_to_point(line.point_to_number(p))\n",
        "                    for line, p in [\n",
        "                        (self.input_line, arrow.get_start()),\n",
        "                        (self.output_line, arrow.get_end()),\n",
        "                    ]\n",
        "                ]\n",
        "                dot = Dot(start_point, radius=0.05)\n",
        "                dot.set_color(YELLOW)\n",
        "                dot.generate_target()\n",
        "                dot.target.move_to(end_point)\n",
        "                dot_group.add(dot)\n",
        "            dot_groups.add(dot_group)\n",
        "\n",
        "        for deriv_label, dot_group in zip(deriv_labels, dot_groups):\n",
        "            self.play(FadeInFromDown(deriv_label))\n",
        "            self.play(LaggedStartMap(GrowFromCenter, dot_group))\n",
        "            self.play(*list(map(MoveToTarget, dot_group)), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class StaticAlgebraicObject(Scene):\n",
        "    def construct(self):\n",
        "        frac = get_phi_continued_fraction(40)\n",
        "        frac.set_width(FRAME_WIDTH - 1)\n",
        "        # frac.shift(2 * DOWN)\n",
        "        frac.to_edge(DOWN)\n",
        "        frac.set_stroke(WHITE, width=0.5)\n",
        "\n",
        "        title = OldTex(\n",
        "            \"\\\\infty \\\\ne \\\\lim\",\n",
        "            tex_to_color_map={\"\\\\ne\": RED}\n",
        "        )\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        polynomial = OldTex(\"x^2 - x - 1 = 0\")\n",
        "        polynomial.move_to(title)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(LaggedStartMap(\n",
        "            GrowFromCenter, frac,\n",
        "            lag_ratio=0.1,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "        factor = 1.1\n",
        "        self.play(frac.scale, factor, run_time=0.5)\n",
        "        self.play(\n",
        "            frac.scale, 1 / factor,\n",
        "            frac.set_color, GREY_B,\n",
        "            run_time=0.5, rate_func=lambda t: t**5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            FadeIn(polynomial)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class NotBetterThanGraphs(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Um, yeah, I'll stick \\\\\\\\ with graphs thanks\",\n",
        "            target_mode=\"sassy\",\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"guilty\",\n",
        "            self.change_students(\"sad\", \"sassy\", \"hesitant\")\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"confused\", look_at=self.screen\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"You must flex those \\\\\\\\ conceptual muscles\",\n",
        "            added_anims=[self.change_students(\n",
        "                *3 * [\"thinking\"],\n",
        "                look_at=self.teacher.eyes\n",
        "            )]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class WhatComesAfterWrapper(Wrapper):\n",
        "    CONFIG = {\"title\": \"Beyond the first year\"}\n",
        "\n",
        "    def construct(self):\n",
        "        Wrapper.construct(self)\n",
        "        new_title = OldTexText(\"Next video\")\n",
        "        new_title.set_color(BLUE)\n",
        "        new_title.move_to(self.title)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(new_title),\n",
        "            self.title.shift, UP,\n",
        "            self.title.fade, 1,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class TopicsAfterSingleVariable(PiCreatureScene, MoreTopics):\n",
        "    CONFIG = {\n",
        "        \"pi_creatures_start_on_screen\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        MoreTopics.construct(self)\n",
        "        self.show_horror()\n",
        "        self.zero_in_on_complex_analysis()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        creatures = VGroup(*[\n",
        "            PiCreature(color=color)\n",
        "            for color in [BLUE_E, BLUE_C, BLUE_D]\n",
        "        ])\n",
        "        creatures.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        creatures.scale(0.5)\n",
        "        creatures.to_corner(DR)\n",
        "        return creatures\n",
        "\n",
        "    def show_horror(self):\n",
        "        creatures = self.get_pi_creatures()\n",
        "        modes = [\"horrified\", \"tired\", \"horrified\"]\n",
        "        for creature, mode in zip(creatures, modes):\n",
        "            creature.generate_target()\n",
        "            creature.target.change(mode, self.other_topics)\n",
        "        creatures.fade(1)\n",
        "\n",
        "        self.play(LaggedStartMap(MoveToTarget, creatures))\n",
        "        self.wait(2)\n",
        "\n",
        "    def zero_in_on_complex_analysis(self):\n",
        "        creatures = self.get_pi_creatures()\n",
        "        complex_analysis = self.other_topics[1]\n",
        "        self.other_topics.remove(complex_analysis)\n",
        "\n",
        "        self.play(\n",
        "            complex_analysis.scale, 1.25,\n",
        "            complex_analysis.center,\n",
        "            complex_analysis.to_edge, UP,\n",
        "            LaggedStartMap(FadeOut, self.other_topics),\n",
        "            LaggedStartMap(FadeOut, self.lines),\n",
        "            FadeOut(self.calculus),\n",
        "            *[\n",
        "                ApplyMethod(creature.change, \"pondering\")\n",
        "                for creature in creatures\n",
        "            ]\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class ShowJacobianZoomedIn(LinearTransformationScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"show_basis_vectors\": False,\n",
        "        \"show_coordinates\": True,\n",
        "        \"zoom_factor\": 0.05,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        LinearTransformationScene.setup(self)\n",
        "        ZoomedScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        def example_function(point):\n",
        "            x, y, z = point\n",
        "            return np.array([\n",
        "                x + np.sin(y),\n",
        "                y + np.sin(x),\n",
        "                0\n",
        "            ])\n",
        "\n",
        "        zoomed_camera = self.zoomed_camera\n",
        "        zoomed_display = self.zoomed_display\n",
        "        frame = zoomed_camera.frame\n",
        "        frame.move_to(3 * LEFT + 1 * UP)\n",
        "        frame.set_color(YELLOW)\n",
        "        zoomed_display.display_frame.set_color(YELLOW)\n",
        "        zd_rect = BackgroundRectangle(\n",
        "            zoomed_display,\n",
        "            fill_opacity=1,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "        )\n",
        "        self.add_foreground_mobject(zd_rect)\n",
        "        zd_rect.anim = UpdateFromFunc(\n",
        "            zd_rect,\n",
        "            lambda rect: rect.replace(zoomed_display).scale(1.1)\n",
        "        )\n",
        "        zd_rect.next_to(FRAME_HEIGHT * UP, UP)\n",
        "\n",
        "        tiny_grid = NumberPlane(\n",
        "            x_radius=2,\n",
        "            y_radius=2,\n",
        "            color=BLUE_E,\n",
        "            secondary_color=GREY_D,\n",
        "        )\n",
        "        tiny_grid.replace(frame)\n",
        "\n",
        "        jacobian_words = OldTexText(\"Jacobian\")\n",
        "        jacobian_words.add_background_rectangle()\n",
        "        jacobian_words.scale(1.5)\n",
        "        jacobian_words.move_to(zoomed_display, UP)\n",
        "        zoomed_display.next_to(jacobian_words, DOWN)\n",
        "\n",
        "        self.play(self.get_zoom_in_animation())\n",
        "        self.activate_zooming()\n",
        "        self.play(\n",
        "            self.get_zoomed_display_pop_out_animation(),\n",
        "            zd_rect.anim\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(tiny_grid),\n",
        "            Write(jacobian_words),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add_transformable_mobject(tiny_grid)\n",
        "        self.add_foreground_mobject(jacobian_words)\n",
        "        self.wait()\n",
        "        self.apply_nonlinear_transformation(\n",
        "            example_function,\n",
        "            added_anims=[MaintainPositionRelativeTo(\n",
        "                zoomed_camera.frame, tiny_grid,\n",
        "            )],\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PrinciplesOverlay(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "            \"flip_at_start\": True,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DR,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        q_marks = VGroup(*[Tex(\"?\") for x in range(40)])\n",
        "        q_marks.arrange_in_grid(4, 10)\n",
        "        q_marks.space_out_submobjects(1.4)\n",
        "        for mark in q_marks:\n",
        "            mark.shift(\n",
        "                random.random() * RIGHT,\n",
        "                random.random() * UP,\n",
        "            )\n",
        "            mark.scale(1.5)\n",
        "            mark.set_stroke(BLACK, 1)\n",
        "        q_marks.next_to(morty, UP)\n",
        "        q_marks.shift_onto_screen()\n",
        "        q_marks.sort(\n",
        "            lambda p: get_norm(p - morty.get_top())\n",
        "        )\n",
        "\n",
        "        self.play(morty.change, \"pondering\")\n",
        "        self.wait(2)\n",
        "        self.play(morty.change, \"raise_right_hand\")\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"thinking\")\n",
        "        self.wait(4)\n",
        "        self.play(FadeInFromDown(q_marks[0]))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, q_marks[1:],\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ManyInfiniteExpressions(Scene):\n",
        "    def construct(self):\n",
        "        frac = get_phi_continued_fraction(10)\n",
        "        frac.set_height(2)\n",
        "        frac.to_corner(UL)\n",
        "\n",
        "        n = 9\n",
        "        radical_str_parts = [\n",
        "            \"%d + \\\\sqrt{\" % d\n",
        "            for d in range(1, n + 1)\n",
        "        ]\n",
        "        radical_str_parts += [\"\\\\cdots\"]\n",
        "        radical_str_parts += [\"}\"] * n\n",
        "        radical = OldTex(\"\".join(radical_str_parts))\n",
        "        radical.to_corner(UR)\n",
        "        radical.to_edge(DOWN)\n",
        "        radical.set_color_by_gradient(YELLOW, RED)\n",
        "\n",
        "        n = 12\n",
        "        power_tower = OldTex(\n",
        "            *[\"\\\\sqrt{2}^{\"] * n + [\"\\\\dots\"] + [\"}\"] * n\n",
        "        )\n",
        "        power_tower.to_corner(UR)\n",
        "        power_tower.set_color_by_gradient(BLUE, GREEN)\n",
        "\n",
        "        self.play(*[\n",
        "            LaggedStartMap(\n",
        "                GrowFromCenter, group,\n",
        "                lag_ratio=0.1,\n",
        "                run_time=8,\n",
        "            )\n",
        "            for group in (frac, radical, power_tower)\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class HoldUpPromo(PrinciplesOverlay):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        url = OldTexText(\"https://brilliant.org/3b1b/\")\n",
        "        url.to_corner(UL)\n",
        "\n",
        "        rect = ScreenRectangle(height=5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "        self.play(FadeOut(rect), FadeOut(url))\n",
        "        self.play(morty.change, \"raise_right_hand\")\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Keith Smith\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Andrew Sachs\",\n",
        "            \"Ho\\\\`ang T\\\\`ung L\\\\^am\",\n",
        "            # \"Ho\u00e0ng T\u00f9ng L\u00e2m\",\n",
        "            \"Devin Scott\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yu Jun\",\n",
        "            \"dave nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Fela\",\n",
        "            \"Fred Ehrsam\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Jamie Warner\",\n",
        "            \"Marek Cirkos\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Cooper Jones\",\n",
        "            \"James Hughes\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Chris Giddings\",\n",
        "            \"Song Gao\",\n",
        "            \"Alexander Feldman\",\n",
        "            \"Matt Langford\",\n",
        "            \"Max Mitchell\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"John Griffith\",\n",
        "            \"Chris Connett\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Bong Choung\",\n",
        "            \"Ignacio Freiberg\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Cody Brocious\",\n",
        "            \"James H. Park\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"David MacCumber\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"Dave B\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"George Chiesa\",\n",
        "            \"supershabam\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Isak Hietala\",\n",
        "            \"1st ViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Awoo\",\n",
        "            \"Dr . David G. Stork\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Sh\\\\`im\\\\'in Ku\\\\=ang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "# class Thumbnail(GraphicalIntuitions):\n",
        "class Thumbnail(AnalyzeFunctionWithTransformations):\n",
        "    CONFIG = {\n",
        "        \"x_axis_width\": 12,\n",
        "        \"graph_origin\": 1.5 * DOWN + 4 * LEFT,\n",
        "        \"num_initial_applications\": 1,\n",
        "        \"input_line_zero_point\": 2 * UP,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_function_title()\n",
        "        self.title.fade(1)\n",
        "        self.titles.fade(1)\n",
        "        self.repeatedly_apply_function()\n",
        "        self.all_arrows.set_stroke(width=1)\n",
        "\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "        cross = Cross(full_rect)\n",
        "        cross.set_stroke(width=40)\n",
        "\n",
        "        # self.add(cross)\n"
    ]
}