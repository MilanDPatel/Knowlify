{
    "topic": "demonstrates the concept of a prime number spiral.",
    "code": [
        "from manim_imports_ext import *\n",
        "import json\n",
        "import numbers\n",
        "\n",
        "\n",
        "OUTPUT_DIRECTORY = \"spirals\"\n",
        "INV_113_MOD_710 = 377  # Inverse of 113 mode 710\n",
        "INV_7_MOD_44 = 19\n",
        "\n",
        "\n",
        "def is_prime(n):\n",
        "    if n < 2:\n",
        "        return False\n",
        "    for k in range(2, int(np.sqrt(n)) + 1):\n",
        "        if n % k == 0:\n",
        "            return False\n",
        "    return True\n",
        "\n",
        "\n",
        "def generate_prime_list(*args):\n",
        "    if len(args) == 1:\n",
        "        start, stop = 2, args[0]\n",
        "    elif len(args) == 2:\n",
        "        start, stop = args\n",
        "        start = max(start, 2)\n",
        "    else:\n",
        "        raise TypeError(\"generate_prime_list takes 1 or 2 arguments\")\n",
        "\n",
        "    result = [\n",
        "        n for n in range(start, stop)\n",
        "        if is_prime(n)\n",
        "    ]\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_gcd(x, y):\n",
        "    while y > 0:\n",
        "        x, y = y, x % y\n",
        "    return x\n",
        "\n",
        "\n",
        "def read_in_primes(max_N=None):\n",
        "    if max_N is None:\n",
        "        max_N = int(1e7)\n",
        "\n",
        "    if max_N < 1e5:\n",
        "        file = \"primes_1e5.json\"\n",
        "    elif max_N < 1e6:\n",
        "        file = \"primes_1e6.json\"\n",
        "    else:\n",
        "        file = \"primes_1e7.json\"\n",
        "\n",
        "    with open(os.path.join(\"assets\", file)) as fp:\n",
        "        primes = np.array(json.load(fp))\n",
        "    return primes[primes <= max_N]\n",
        "\n",
        "\n",
        "class SpiralScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"axis_config\": {\n",
        "                \"stroke_width\": 1.5,\n",
        "            }\n",
        "        },\n",
        "        \"default_dot_color\": TEAL,\n",
        "        \"p_spiral_width\": 6,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.axes = Axes(**self.axes_config)\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def get_v_spiral(self, sequence, axes=None, box_width=None):\n",
        "        if axes is None:\n",
        "            axes = self.axes\n",
        "        if box_width is None:\n",
        "            unit = get_norm(axes.c2p(1, 0) - axes.c2p(0, 0)),\n",
        "            box_width = max(\n",
        "                0.2 / (-np.log10(unit) + 1),\n",
        "                0.02,\n",
        "            )\n",
        "\n",
        "        return VGroup(*[\n",
        "            Square(\n",
        "                side_length=box_width,\n",
        "                fill_color=self.default_dot_color,\n",
        "                fill_opacity=1,\n",
        "                stroke_width=0,\n",
        "            ).move_to(self.get_polar_point(n, n, axes))\n",
        "            for n in sequence\n",
        "        ])\n",
        "\n",
        "    def get_p_spiral(self, sequence, axes=None):\n",
        "        if axes is None:\n",
        "            axes = self.axes\n",
        "        result = PMobject(\n",
        "            color=self.default_dot_color,\n",
        "            stroke_width=self.p_spiral_width,\n",
        "        )\n",
        "        result.add_points([\n",
        "            self.get_polar_point(n, n, axes)\n",
        "            for n in sequence\n",
        "        ])\n",
        "        return result\n",
        "\n",
        "    def get_prime_v_spiral(self, max_N, **kwargs):\n",
        "        primes = read_in_primes(max_N)\n",
        "        return self.get_v_spiral(primes, **kwargs)\n",
        "\n",
        "    def get_prime_p_spiral(self, max_N, **kwargs):\n",
        "        primes = read_in_primes(max_N)\n",
        "        return self.get_p_spiral(primes, **kwargs)\n",
        "\n",
        "    def get_polar_point(self, r, theta, axes=None):\n",
        "        if axes is None:\n",
        "            axes = self.axes\n",
        "        return axes.c2p(r * np.cos(theta), r * np.sin(theta))\n",
        "\n",
        "    def set_scale(self, scale,\n",
        "                  axes=None,\n",
        "                  spiral=None,\n",
        "                  to_shrink=None,\n",
        "                  min_box_width=0.05,\n",
        "                  target_p_spiral_width=None,\n",
        "                  added_anims=[],\n",
        "                  run_time=3):\n",
        "        if axes is None:\n",
        "            axes = self.axes\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "        sf = self.get_scale_factor(scale, axes)\n",
        "\n",
        "        anims = []\n",
        "        for mob in [axes, spiral, to_shrink]:\n",
        "            if mob is None:\n",
        "                continue\n",
        "            mob.generate_target()\n",
        "            mob.target.scale(sf, about_point=ORIGIN)\n",
        "            if mob is spiral:\n",
        "                if isinstance(mob, VMobject):\n",
        "                    old_width = mob[0].get_width()\n",
        "                    for submob in mob.target:\n",
        "                        submob.set_width(max(\n",
        "                            old_width * sf,\n",
        "                            min_box_width,\n",
        "                        ))\n",
        "                elif isinstance(mob, PMobject):\n",
        "                    if target_p_spiral_width is not None:\n",
        "                        mob.target.set_stroke_width(target_p_spiral_width)\n",
        "            anims.append(MoveToTarget(mob))\n",
        "        anims += added_anims\n",
        "\n",
        "        if run_time == 0:\n",
        "            for anim in anims:\n",
        "                anim.begin()\n",
        "                anim.update(1)\n",
        "                anim.finish()\n",
        "        else:\n",
        "            self.play(\n",
        "                *anims,\n",
        "                run_time=run_time,\n",
        "                rate_func=lambda t: interpolate(\n",
        "                    smooth(t),\n",
        "                    smooth(t)**(sf**(0.5)),\n",
        "                    t,\n",
        "                )\n",
        "            )\n",
        "\n",
        "    def get_scale_factor(self, target_scale, axes=None):\n",
        "        if axes is None:\n",
        "            axes = self.axes\n",
        "        unit = get_norm(axes.c2p(1, 0) - axes.c2p(0, 0))\n",
        "        return 1 / (target_scale * unit)\n",
        "\n",
        "    def get_labels(self, sequence, scale_func=np.sqrt):\n",
        "        labels = VGroup()\n",
        "        for n in sequence:\n",
        "            label = Integer(n)\n",
        "            label.set_stroke(width=0, background=True)\n",
        "            label.scale(scale_func(n))\n",
        "            label.next_to(\n",
        "                self.get_polar_point(n, n), UP,\n",
        "                buff=0.5 * label.get_height(),\n",
        "            )\n",
        "            labels.add(label)\n",
        "        return labels\n",
        "\n",
        "    def get_prime_labels(self, max_N):\n",
        "        primes = read_in_primes(max_N)\n",
        "        return self.get_labels(primes)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class AltTitle(Scene):\n",
        "    def construct(self):\n",
        "        title_text = \"\"\"\n",
        "            How pretty but pointless patterns\\\\\\\\\n",
        "            in polar plots of primes\\\\\\\\\n",
        "            prompt pretty important ponderings\\\\\\\\\n",
        "            on properties of those primes.\n",
        "        \"\"\"\n",
        "        words = [w + \" \" for w in title_text.split(\" \") if w]\n",
        "        title = OldTexText(*words)\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        title[2:5].set_color(TEAL)\n",
        "        title[12:15].set_color(YELLOW)\n",
        "        title.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        image = ImageMobject(\"PrimeSpiral\")\n",
        "        image.set_height(FRAME_HEIGHT)\n",
        "        rect = FullScreenFadeRectangle(fill_opacity=0.25)\n",
        "\n",
        "        self.add(image, rect)\n",
        "\n",
        "        for word in title:\n",
        "            self.play(\n",
        "                FadeIn(\n",
        "                    word, run_time=0.05 * len(word),\n",
        "                    lag_ratio=0.4,\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HoldUpMathExchange(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Mathematics Stack Exchange\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(self.teacher.change, \"raise_right_hand\", ORIGIN),\n",
        "        self.play_all_student_changes(\"thinking\", look_at=ORIGIN)\n",
        "        self.wait(3)\n",
        "        self.play_all_student_changes(\"confused\", look_at=ORIGIN)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class MathExchangeNames(Scene):\n",
        "    def construct(self):\n",
        "        names = VGroup(\n",
        "            OldTexText(\"dwymark\"),\n",
        "            OldTexText(\"Greg Martin\"),\n",
        "        )\n",
        "        names.arrange(DOWN, buff=1)\n",
        "        for name in names:\n",
        "            self.play(FadeIn(name, RIGHT))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MathExchange(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class PrimesAndPi(Scene):\n",
        "    def construct(self):\n",
        "        self.show_primes()\n",
        "        self.show_rational_approximations()\n",
        "\n",
        "    def show_primes(self):\n",
        "        n_rows = 10\n",
        "        n_cols = 10\n",
        "        matrix = IntegerMatrix([\n",
        "            [n_cols * x + y for y in range(n_cols)]\n",
        "            for x in range(n_rows)\n",
        "        ])\n",
        "        numbers = matrix.get_entries()\n",
        "        primes = VGroup(*filter(\n",
        "            lambda m: is_prime(m.get_value()),\n",
        "            numbers,\n",
        "        ))\n",
        "        non_primes = VGroup(*filter(\n",
        "            lambda m: not is_prime(m.get_value()),\n",
        "            numbers\n",
        "        ))\n",
        "\n",
        "        self.add(numbers)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyFunction(\n",
        "                    lambda m: m.set_color(TEAL).scale(1.2),\n",
        "                    prime\n",
        "                )\n",
        "                for prime in primes\n",
        "            ]),\n",
        "            non_primes.set_opacity, 0.25,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.numbers = numbers\n",
        "\n",
        "    def show_rational_approximations(self):\n",
        "        numbers = self.numbers\n",
        "\n",
        "        approxs = OldTex(\n",
        "            \"{22 \\\\over 7} &=\", \"{:.12}\\\\dots\\\\\\\\\".format(22 / 7),\n",
        "            \"{355 \\\\over 113} &=\", \"{:.12}\\\\dots\\\\\\\\\".format(355 / 113),\n",
        "            \"\\\\pi &=\", \"{:.12}\\\\dots\\\\\\\\\".format(PI),\n",
        "        )\n",
        "        approxs[:2].shift(MED_LARGE_BUFF * UP)\n",
        "        approxs[-2:].shift(MED_LARGE_BUFF * DOWN)\n",
        "        approxs[-2:].set_color(YELLOW)\n",
        "        approxs[1][:4].set_color(YELLOW)\n",
        "        approxs[3][:8].set_color(YELLOW)\n",
        "        approxs.scale(1.5)\n",
        "\n",
        "        randy = Randolph(color=YELLOW, height=1)\n",
        "        randy.move_to(approxs[-2][0], RIGHT)\n",
        "        approxs[-2][0].set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOutAndShiftDown, numbers),\n",
        "            LaggedStartMap(FadeIn, approxs),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"pondering\", UR)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RefresherOnPolarCoordinates(Scene):\n",
        "    CONFIG = {\n",
        "        \"x_color\": GREEN,\n",
        "        \"y_color\": RED,\n",
        "        \"r_color\": YELLOW,\n",
        "        \"theta_color\": LIGHT_PINK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_xy_coordinates()\n",
        "        self.transition_to_polar_grid()\n",
        "        self.show_polar_coordinates()\n",
        "\n",
        "        self.show_all_nn_tuples()\n",
        "\n",
        "    def show_xy_coordinates(self):\n",
        "        plane = NumberPlane()\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        x = 3 * np.cos(PI / 6)\n",
        "        y = 3 * np.sin(PI / 6)\n",
        "\n",
        "        point = plane.c2p(x, y)\n",
        "        xp = plane.c2p(x, 0)\n",
        "        origin = plane.c2p(0, 0)\n",
        "\n",
        "        x_color = self.x_color\n",
        "        y_color = self.y_color\n",
        "\n",
        "        x_line = Line(origin, xp, color=x_color)\n",
        "        y_line = Line(xp, point, color=y_color)\n",
        "\n",
        "        dot = Dot(point)\n",
        "\n",
        "        coord_label = self.get_coord_label(0, 0, x_color, y_color)\n",
        "        x_coord = coord_label.x_coord\n",
        "        y_coord = coord_label.y_coord\n",
        "\n",
        "        coord_label.next_to(dot, UR, SMALL_BUFF)\n",
        "\n",
        "        x_brace = Brace(x_coord, UP)\n",
        "        y_brace = Brace(y_coord, UP)\n",
        "        x_brace.add(x_brace.get_tex(\"x\").set_color(x_color))\n",
        "        y_brace.add(y_brace.get_tex(\"y\").set_color(y_color))\n",
        "        x_brace.add_updater(lambda m: m.next_to(x_coord, UP, SMALL_BUFF))\n",
        "        y_brace.add_updater(lambda m: m.next_to(y_coord, UP, SMALL_BUFF))\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(dot, coord_label)\n",
        "        self.add(x_brace, y_brace)\n",
        "\n",
        "        coord_label.add_updater(\n",
        "            lambda m: m.next_to(dot, UR, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            ChangeDecimalToValue(x_coord, x),\n",
        "            UpdateFromFunc(\n",
        "                dot,\n",
        "                lambda d: d.move_to(x_line.get_end()),\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(y_line),\n",
        "            ChangeDecimalToValue(y_coord, y),\n",
        "            UpdateFromFunc(\n",
        "                dot,\n",
        "                lambda d: d.move_to(y_line.get_end()),\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.xy_coord_mobjects = VGroup(\n",
        "            x_line, y_line, coord_label,\n",
        "            x_brace, y_brace,\n",
        "        )\n",
        "        self.plane = plane\n",
        "        self.dot = dot\n",
        "\n",
        "    def transition_to_polar_grid(self):\n",
        "        self.polar_grid = self.get_polar_grid()\n",
        "        self.add(self.polar_grid, self.dot)\n",
        "        self.play(\n",
        "            FadeOut(self.xy_coord_mobjects),\n",
        "            FadeOut(self.plane),\n",
        "            ShowCreation(self.polar_grid, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_polar_coordinates(self):\n",
        "        dot = self.dot\n",
        "        plane = self.plane\n",
        "        origin = plane.c2p(0, 0)\n",
        "\n",
        "        r_color = self.r_color\n",
        "        theta_color = self.theta_color\n",
        "\n",
        "        r_line = Line(origin, dot.get_center())\n",
        "        r_line.set_color(r_color)\n",
        "        r_value = r_line.get_length()\n",
        "        theta_value = r_line.get_angle()\n",
        "\n",
        "        coord_label = self.get_coord_label(r_value, theta_value, r_color, theta_color)\n",
        "        r_coord = coord_label.x_coord\n",
        "        theta_coord = coord_label.y_coord\n",
        "\n",
        "        coord_label.add_updater(lambda m: m.next_to(dot, UP, buff=SMALL_BUFF))\n",
        "        r_coord.add_updater(lambda d: d.set_value(\n",
        "            get_norm(dot.get_center())\n",
        "        ))\n",
        "        theta_coord.add_background_rectangle()\n",
        "        theta_coord.add_updater(lambda d: d.set_value(\n",
        "            (angle_of_vector(dot.get_center()) % TAU)\n",
        "        ))\n",
        "        coord_label[-1].add_updater(\n",
        "            lambda m: m.next_to(theta_coord, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        non_coord_parts = VGroup(*[\n",
        "            part\n",
        "            for part in coord_label\n",
        "            if part not in [r_coord, theta_coord]\n",
        "        ])\n",
        "\n",
        "        r_label = OldTex(\"r\")\n",
        "        r_label.set_color(r_color)\n",
        "        r_label.add_updater(lambda m: m.next_to(r_coord, UP))\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.set_color(theta_color)\n",
        "        theta_label.add_updater(lambda m: m.next_to(theta_coord, UP))\n",
        "\n",
        "        r_coord_copy = r_coord.copy()\n",
        "        r_coord_copy.add_updater(\n",
        "            lambda m: m.next_to(r_line.get_center(), UL, buff=0)\n",
        "        )\n",
        "\n",
        "        degree_label = DecimalNumber(0, num_decimal_places=1, unit=\"^\\\\circ\")\n",
        "        arc = Arc(radius=1, angle=theta_value)\n",
        "        arc.set_color(theta_color)\n",
        "        degree_label.set_color(theta_color)\n",
        "\n",
        "        # Show r\n",
        "        self.play(\n",
        "            ShowCreation(r_line, run_time=2),\n",
        "            ChangeDecimalToValue(r_coord_copy, r_value, run_time=2),\n",
        "            VFadeIn(r_coord_copy, run_time=0.5),\n",
        "        )\n",
        "        r_coord.set_value(r_value)\n",
        "        self.add(non_coord_parts, r_coord_copy)\n",
        "        self.play(\n",
        "            FadeIn(non_coord_parts),\n",
        "            ReplacementTransform(r_coord_copy, r_coord),\n",
        "            FadeInFromDown(r_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show theta\n",
        "        degree_label.next_to(arc.get_start(), UR, SMALL_BUFF)\n",
        "        line = r_line.copy()\n",
        "        line.rotate(-theta_value, about_point=ORIGIN)\n",
        "        line.set_color(theta_color)\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Rotate(line, theta_value, about_point=ORIGIN),\n",
        "            VFadeInThenOut(line),\n",
        "            ChangeDecimalToValue(degree_label, theta_value / DEGREES),\n",
        "        )\n",
        "        self.play(\n",
        "            degree_label.scale, 0.9,\n",
        "            degree_label.move_to, theta_coord,\n",
        "            FadeInFromDown(theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        degree_cross = Cross(degree_label)\n",
        "        radians_word = OldTexText(\"in radians\")\n",
        "        radians_word.scale(0.9)\n",
        "        radians_word.set_color(theta_color)\n",
        "        radians_word.add_background_rectangle()\n",
        "        radians_word.add_updater(\n",
        "            lambda m: m.next_to(theta_label, RIGHT, aligned_edge=DOWN)\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(degree_cross))\n",
        "        self.play(\n",
        "            FadeOut(\n",
        "                VGroup(degree_label, degree_cross),\n",
        "                DOWN\n",
        "            ),\n",
        "            FadeIn(theta_coord)\n",
        "        )\n",
        "        self.play(FadeIn(radians_word))\n",
        "        self.wait()\n",
        "\n",
        "        # Move point around\n",
        "        r_line.add_updater(\n",
        "            lambda l: l.put_start_and_end_on(ORIGIN, dot.get_center())\n",
        "        )\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        theta_tracker.add_updater(\n",
        "            lambda m: m.set_value(r_line.get_angle() % TAU)\n",
        "        )\n",
        "        self.add(theta_tracker)\n",
        "        arc.add_updater(\n",
        "            lambda m: m.become(\n",
        "                self.get_arc(theta_tracker.get_value())\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(coord_label)\n",
        "        for angle in [PI - theta_value, PI - 0.001, -TAU + 0.002]:\n",
        "            self.play(\n",
        "                Rotate(dot, angle, about_point=ORIGIN),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeOut(coord_label),\n",
        "            FadeOut(r_label),\n",
        "            FadeOut(theta_label),\n",
        "            FadeOut(radians_word),\n",
        "            FadeOut(r_line),\n",
        "            FadeOut(arc),\n",
        "            FadeOut(dot),\n",
        "        )\n",
        "\n",
        "        self.dot = dot\n",
        "        self.r_line = r_line\n",
        "        self.arc = arc\n",
        "        self.theta_tracker = theta_tracker\n",
        "\n",
        "    def show_all_nn_tuples(self):\n",
        "        dot = self.dot\n",
        "        arc = self.arc\n",
        "        r_line = self.r_line\n",
        "        theta_tracker = self.theta_tracker\n",
        "\n",
        "        primes = generate_prime_list(20)\n",
        "        non_primes = list(range(1, 20))\n",
        "        for prime in primes:\n",
        "            non_primes.remove(prime)\n",
        "\n",
        "        pp_points = VGroup(*map(self.get_nn_point, primes))\n",
        "        pp_points[0][1].shift(0.3 * LEFT + SMALL_BUFF * UP)\n",
        "        np_points = VGroup(*map(self.get_nn_point, non_primes))\n",
        "        pp_points.set_color(TEAL)\n",
        "        np_points.set_color(WHITE)\n",
        "        pp_points.set_stroke(BLACK, 4, background=True)\n",
        "        np_points.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        self.play(\n",
        "            ApplyMethod(frame.scale, 2),\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown, pp_points\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, np_points))\n",
        "        self.play(frame.scale, 0.5)\n",
        "        self.wait()\n",
        "\n",
        "        # Talk about 1\n",
        "        one = np_points[0]\n",
        "        dot.move_to(self.get_polar_point(1, 1))\n",
        "        self.add(dot)\n",
        "        theta_tracker.clear_updaters()\n",
        "        theta_tracker.set_value(1)\n",
        "        # r_line = Line(ORIGIN, one.dot.get_center())\n",
        "        # r_line.set_color(self.r_color)\n",
        "        # pre_arc = Line(RIGHT, UR, color=self.r_color)\n",
        "        # theta_tracker = ValueTracker(1)\n",
        "        # arc = always_redraw(lambda: self.get_arc(theta_tracker.get_value()))\n",
        "\n",
        "        one_rect = SurroundingRectangle(one)\n",
        "        one_r_rect = SurroundingRectangle(one.label[1])\n",
        "        one_theta_rect = SurroundingRectangle(one.label[3])\n",
        "        one_theta_rect.set_color(self.theta_color)\n",
        "\n",
        "        self.play(ShowCreation(one_rect))\n",
        "        self.add(r_line, np_points, pp_points, one_rect)\n",
        "        self.play(\n",
        "            ReplacementTransform(one_rect, one_r_rect),\n",
        "            ShowCreation(r_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        # self.play(TransformFromCopy(r_line, pre_arc))\n",
        "        # self.add(pre_arc, one)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                Line(*r_line.get_start_and_end()), arc\n",
        "            ),\n",
        "            ReplacementTransform(one_r_rect, one_theta_rect)\n",
        "        )\n",
        "        self.add(arc, one, one_theta_rect)\n",
        "        self.play(FadeOut(one_theta_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Talk about 2, 3 then 4\n",
        "        for n in [2, 3, 4]:\n",
        "            self.play(\n",
        "                Rotate(dot, 1, about_point=ORIGIN),\n",
        "                theta_tracker.set_value, n,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(dot.move_to, self.get_polar_point(n, n))\n",
        "            self.wait()\n",
        "\n",
        "        # Zoom out and show spiral\n",
        "        big_anim = Succession(*3 * [Animation(Mobject())], *it.chain(*[\n",
        "            [\n",
        "                AnimationGroup(\n",
        "                    Rotate(dot, 1, about_point=ORIGIN),\n",
        "                    ApplyMethod(theta_tracker.set_value, n),\n",
        "                ),\n",
        "                ApplyMethod(dot.move_to, self.get_polar_point(n, n))\n",
        "            ]\n",
        "            for n in [5, 6, 7, 8, 9]\n",
        "        ]))\n",
        "\n",
        "        spiral = ParametricCurve(\n",
        "            lambda t: self.get_polar_point(t, t),\n",
        "            t_min=0,\n",
        "            t_max=25,\n",
        "            stroke_width=1.5,\n",
        "        )\n",
        "\n",
        "        # self.add(spiral, pp_points, np_points)\n",
        "\n",
        "        self.polar_grid.generate_target()\n",
        "        for mob in self.polar_grid:\n",
        "            if not isinstance(mob[0], Integer):\n",
        "                mob.set_stroke(width=1)\n",
        "\n",
        "        self.play(\n",
        "            frame.scale, 3,\n",
        "            big_anim,\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            # ApplyMethod(\n",
        "            #     frame.scale, 1.5,\n",
        "            #     run_time=2,\n",
        "            #     rate_func=lambda t: smooth(t, 2)\n",
        "            # ),\n",
        "            ShowCreation(\n",
        "                spiral,\n",
        "                run_time=4,\n",
        "            ),\n",
        "            FadeOut(r_line),\n",
        "            FadeOut(arc),\n",
        "            FadeOut(dot),\n",
        "            # MoveToTarget(self.polar_grid)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_nn_point(self, n):\n",
        "        point = self.get_polar_point(n, n)\n",
        "        dot = Dot(point)\n",
        "        coord_label = self.get_coord_label(\n",
        "            n, n,\n",
        "            include_background_rectangle=False,\n",
        "            num_decimal_places=0\n",
        "        )\n",
        "        coord_label.next_to(dot, UR, buff=0)\n",
        "        result = VGroup(dot, coord_label)\n",
        "        result.dot = dot\n",
        "        result.label = coord_label\n",
        "        return result\n",
        "\n",
        "    def get_polar_grid(self, radius=25):\n",
        "        plane = self.plane\n",
        "        axes = VGroup(\n",
        "            Line(radius * DOWN, radius * UP),\n",
        "            Line(radius * LEFT, radius * RIGHT),\n",
        "        )\n",
        "        axes.set_stroke(width=2)\n",
        "        circles = VGroup(*[\n",
        "            Circle(color=BLUE, stroke_width=1, radius=r)\n",
        "            for r in range(1, int(radius))\n",
        "        ])\n",
        "        rays = VGroup(*[\n",
        "            Line(\n",
        "                ORIGIN, radius * RIGHT,\n",
        "                color=BLUE,\n",
        "                stroke_width=1,\n",
        "            ).rotate(angle, about_point=ORIGIN)\n",
        "            for angle in np.arange(0, TAU, TAU / 16)\n",
        "        ])\n",
        "        labels = VGroup(*[\n",
        "            Integer(n).scale(0.5).next_to(\n",
        "                plane.c2p(n, 0), DR, SMALL_BUFF\n",
        "            )\n",
        "            for n in range(1, int(radius))\n",
        "        ])\n",
        "\n",
        "        return VGroup(\n",
        "            circles, rays, labels, axes,\n",
        "        )\n",
        "\n",
        "    def get_coord_label(self,\n",
        "                        x=0,\n",
        "                        y=0,\n",
        "                        x_color=WHITE,\n",
        "                        y_color=WHITE,\n",
        "                        include_background_rectangle=True,\n",
        "                        **decimal_kwargs):\n",
        "        coords = VGroup()\n",
        "        for n in x, y:\n",
        "            if isinstance(n, numbers.Number):\n",
        "                coord = DecimalNumber(n, **decimal_kwargs)\n",
        "            elif isinstance(n, str):\n",
        "                coord = OldTex(n)\n",
        "            else:\n",
        "                raise Exception(\"Invalid type\")\n",
        "            coords.add(coord)\n",
        "\n",
        "        x_coord, y_coord = coords\n",
        "        x_coord.set_color(x_color)\n",
        "        y_coord.set_color(y_color)\n",
        "\n",
        "        coord_label = VGroup(\n",
        "            OldTex(\"(\"), x_coord,\n",
        "            OldTex(\",\"), y_coord,\n",
        "            OldTex(\")\")\n",
        "        )\n",
        "        coord_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        coord_label[2].align_to(coord_label[0], DOWN)\n",
        "\n",
        "        coord_label.x_coord = x_coord\n",
        "        coord_label.y_coord = y_coord\n",
        "        if include_background_rectangle:\n",
        "            coord_label.add_background_rectangle()\n",
        "        return coord_label\n",
        "\n",
        "    def get_polar_point(self, r, theta):\n",
        "        plane = self.plane\n",
        "        return plane.c2p(r * np.cos(theta), r * np.sin(theta))\n",
        "\n",
        "    def get_arc(self, theta, r=1, color=None):\n",
        "        if color is None:\n",
        "            color = self.theta_color\n",
        "        return ParametricCurve(\n",
        "            lambda t: self.get_polar_point(1 + 0.025 * t, t),\n",
        "            t_min=0,\n",
        "            t_max=theta,\n",
        "            dt=0.25,\n",
        "            color=color,\n",
        "            stroke_width=3,\n",
        "        )\n",
        "        # return Arc(\n",
        "        #     angle=theta,\n",
        "        #     radius=r,\n",
        "        #     stroke_color=color,\n",
        "        # )\n",
        "\n",
        "\n",
        "class IntroducePolarPlot(RefresherOnPolarCoordinates):\n",
        "    def construct(self):\n",
        "        self.plane = NumberPlane()\n",
        "        grid = self.get_polar_grid()\n",
        "        title = OldTexText(\"Polar coordinates\")\n",
        "        title.scale(3)\n",
        "        title.set_stroke(BLACK, 10, background=True)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(grid, title)\n",
        "        self.play(\n",
        "            ShowCreation(grid, lag_ratio=0.1),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "\n",
        "class ReplacePolarCoordinatesWithPrimes(RefresherOnPolarCoordinates):\n",
        "    def construct(self):\n",
        "        coords, p_coords = [\n",
        "            self.get_coord_label(\n",
        "                *pair,\n",
        "                x_color=self.r_color,\n",
        "                y_color=self.theta_color,\n",
        "            ).scale(2)\n",
        "            for pair in [(\"r\", \"\\\\theta\"), (\"p\", \"p\")]\n",
        "        ]\n",
        "        p_coords.x_coord.set_color(GREY_B)\n",
        "        p_coords.y_coord.set_color(GREY_B)\n",
        "\n",
        "        some_prime = OldTexText(\"Some prime\")\n",
        "        some_prime.scale(1.5)\n",
        "        some_prime.next_to(p_coords.get_left(), DOWN, buff=1.5)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                some_prime.get_top(), coord.get_bottom(),\n",
        "                stroke_width=5,\n",
        "                tip_length=0.4\n",
        "            )\n",
        "            for coord in [p_coords.x_coord, p_coords.y_coord]\n",
        "        ])\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(p_coords, LEFT)\n",
        "\n",
        "        self.add(coords)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            coords.next_to, equals, LEFT,\n",
        "            FadeIn(equals),\n",
        "            FadeIn(p_coords),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(some_prime),\n",
        "            ShowCreation(arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroducePrimePatterns(SpiralScene):\n",
        "    CONFIG = {\n",
        "        \"small_n_primes\": 25000,\n",
        "        \"big_n_primes\": 1000000,\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -25,\n",
        "            \"x_max\": 25,\n",
        "            \"y_min\": -25,\n",
        "            \"y_max\": 25,\n",
        "        },\n",
        "        \"spiral_scale\": 3e3,\n",
        "        \"ray_scale\": 1e5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.slowly_zoom_out()\n",
        "        self.show_clumps_of_four()\n",
        "\n",
        "    def slowly_zoom_out(self):\n",
        "        zoom_time = 8\n",
        "\n",
        "        prime_spiral = self.get_prime_p_spiral(self.small_n_primes)\n",
        "        prime_spiral.set_stroke_width(25)\n",
        "        self.add(prime_spiral)\n",
        "\n",
        "        self.set_scale(3, spiral=prime_spiral)\n",
        "        self.wait()\n",
        "        self.set_scale(\n",
        "            self.spiral_scale,\n",
        "            spiral=prime_spiral,\n",
        "            target_p_spiral_width=8,\n",
        "            run_time=zoom_time,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(prime_spiral)\n",
        "        prime_spiral = self.get_prime_p_spiral(self.big_n_primes)\n",
        "        prime_spiral.set_stroke_width(8)\n",
        "        self.set_scale(\n",
        "            self.ray_scale,\n",
        "            spiral=prime_spiral,\n",
        "            target_p_spiral_width=4,\n",
        "            run_time=zoom_time,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_clumps_of_four(self):\n",
        "        line_groups = VGroup()\n",
        "        for n in range(71):\n",
        "            group = VGroup()\n",
        "            for k in [-3, -1, 1, 3]:\n",
        "                r = ((10 * n + k) * INV_113_MOD_710) % 710\n",
        "                group.add(self.get_arithmetic_sequence_line(\n",
        "                    710, r, self.big_n_primes\n",
        "                ))\n",
        "            line_groups.add(group)\n",
        "\n",
        "        line_groups.set_stroke(YELLOW, 2, opacity=0.5)\n",
        "\n",
        "        self.play(ShowCreation(line_groups[0]))\n",
        "        for g1, g2 in zip(line_groups, line_groups[1:5]):\n",
        "            self.play(\n",
        "                FadeOut(g1),\n",
        "                ShowCreation(g2)\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(line_groups[4]),\n",
        "            LaggedStartMap(\n",
        "                VFadeInThenOut,\n",
        "                line_groups[4:],\n",
        "                lag_ratio=0.5,\n",
        "                run_time=5,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_arithmetic_sequence_line(self, N, r, max_val, skip_factor=5):\n",
        "        line = VMobject()\n",
        "        line.set_points_smoothly([\n",
        "            self.get_polar_point(x, x)\n",
        "            for x in range(r, max_val, skip_factor * N)\n",
        "        ])\n",
        "        return line\n",
        "\n",
        "\n",
        "class AskWhat(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        screen = self.screen\n",
        "        self.student_says(\n",
        "            \"I'm sorry,\\\\\\\\what?!?\",\n",
        "            target_mode=\"angry\",\n",
        "            look_at=screen,\n",
        "            index=2,\n",
        "            added_anims=[\n",
        "                self.teacher.change, \"happy\", screen,\n",
        "                self.students[0].change, \"confused\", screen,\n",
        "                self.students[1].change, \"confused\", screen,\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class CountSpirals(IntroducePrimePatterns):\n",
        "    CONFIG = {\n",
        "        \"count_sound\": \"pen_click.wav\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        prime_spiral = self.get_prime_p_spiral(self.small_n_primes)\n",
        "\n",
        "        self.add(prime_spiral)\n",
        "        self.set_scale(\n",
        "            self.spiral_scale,\n",
        "            spiral=prime_spiral,\n",
        "            run_time=0,\n",
        "        )\n",
        "\n",
        "        spiral_lines = self.get_all_primitive_arithmetic_lines(\n",
        "            44, self.small_n_primes, INV_7_MOD_44,\n",
        "        )\n",
        "        spiral_lines.set_stroke(YELLOW, 2, opacity=0.5)\n",
        "\n",
        "        counts = VGroup()\n",
        "        for n, spiral in zip(it.count(1), spiral_lines):\n",
        "            count = Integer(n)\n",
        "            count.move_to(spiral.point_from_proportion(0.25))\n",
        "            counts.add(count)\n",
        "\n",
        "        run_time = 3\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(spiral_lines),\n",
        "            ShowSubmobjectsOneByOne(counts),\n",
        "            run_time=run_time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.add_count_clicks(len(spiral_lines), run_time)\n",
        "        self.play(\n",
        "            counts[-1].scale, 3,\n",
        "            counts[-1].set_stroke, BLACK, 5, {\"background\": True},\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_all_primitive_arithmetic_lines(self, N, max_val, mult_factor):\n",
        "        lines = VGroup()\n",
        "        for r in range(1, N):\n",
        "            if get_gcd(N, r) == 1:\n",
        "                lines.add(\n",
        "                    self.get_arithmetic_sequence_line(N, (mult_factor * r) % N, max_val)\n",
        "                )\n",
        "        return lines\n",
        "\n",
        "    def add_count_clicks(self, N, time, rate_func=linear):\n",
        "        alphas = np.arange(0, 1, 1 / N)\n",
        "        if rate_func is linear:\n",
        "            delays = time * alphas\n",
        "        else:\n",
        "            delays = time * np.array([\n",
        "                binary_search(rate_func, alpha, 0, 1)\n",
        "                for alpha in alphas\n",
        "            ])\n",
        "\n",
        "        for delay in delays:\n",
        "            self.add_sound(\n",
        "                self.count_sound,\n",
        "                time_offset=-delay,\n",
        "                gain=-15,\n",
        "            )\n",
        "\n",
        "\n",
        "class CountRays(CountSpirals):\n",
        "    def construct(self):\n",
        "        prime_spiral = self.get_prime_p_spiral(self.big_n_primes)\n",
        "\n",
        "        self.add(prime_spiral)\n",
        "        self.set_scale(\n",
        "            self.ray_scale,\n",
        "            spiral=prime_spiral,\n",
        "            run_time=0,\n",
        "        )\n",
        "\n",
        "        spiral_lines = self.get_all_primitive_arithmetic_lines(\n",
        "            710, self.big_n_primes, INV_113_MOD_710,\n",
        "        )\n",
        "        spiral_lines.set_stroke(YELLOW, 2, opacity=0.5)\n",
        "\n",
        "        counts = VGroup()\n",
        "        for n, spiral in zip(it.count(1), spiral_lines):\n",
        "            count = Integer(n)\n",
        "            count.move_to(spiral.point_from_proportion(0.25))\n",
        "            counts.add(count)\n",
        "\n",
        "        run_time = 6\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(spiral_lines),\n",
        "            ShowSubmobjectsOneByOne(counts),\n",
        "            run_time=run_time,\n",
        "            rate_func=smooth,\n",
        "        )\n",
        "        self.add_count_clicks(len(spiral_lines), run_time, rate_func=smooth)\n",
        "        self.play(\n",
        "            counts[-1].scale, 3,\n",
        "            counts[-1].set_stroke, BLACK, 5, {\"background\": True},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(spiral_lines))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutRelationToPrimes(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        numbers = OldTexText(\"20, 280\")\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        primes = OldTexText(\"2, 3, 5, 7, 11, \\\\dots\")\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.set_color(YELLOW)\n",
        "\n",
        "        group = VGroup(primes, arrow, numbers)\n",
        "        group.arrange(RIGHT)\n",
        "        q_marks.next_to(arrow, UP)\n",
        "        group.add(q_marks)\n",
        "        group.scale(1.5)\n",
        "        group.next_to(self.pi_creatures, UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            self.change_students(\n",
        "                *3 * [\"maybe\"],\n",
        "                look_at=numbers,\n",
        "            ),\n",
        "            self.teacher.change, \"maybe\", numbers,\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(numbers, RIGHT)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(primes, LEFT),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, q_marks[0]),\n",
        "            Blink(self.teacher)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ZoomOutOnPrimesWithNumbers(IntroducePrimePatterns):\n",
        "    CONFIG = {\n",
        "        \"n_labeled_primes\": 1000,\n",
        "        \"big_n_primes\": int(5e6),\n",
        "        \"thicknesses\": [8, 3, 2],\n",
        "        \"thicker_target\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        zoom_time = 20\n",
        "\n",
        "        prime_spiral = self.get_prime_p_spiral(self.big_n_primes)\n",
        "        prime_spiral.set_stroke_width(25)\n",
        "\n",
        "        prime_labels = self.get_prime_labels(self.n_labeled_primes)\n",
        "\n",
        "        self.add(prime_spiral)\n",
        "        self.add(prime_labels)\n",
        "\n",
        "        scales = [self.spiral_scale, self.ray_scale, 5e5]\n",
        "        thicknesses = self.thicknesses\n",
        "\n",
        "        for scale, tp in zip(scales, thicknesses):\n",
        "            kwargs = {\n",
        "                \"spiral\": prime_spiral,\n",
        "                \"to_shrink\": prime_labels,\n",
        "                \"run_time\": zoom_time,\n",
        "                \"target_p_spiral_width\": tp,\n",
        "            }\n",
        "            if self.thicker_target:\n",
        "                kwargs[\"target_p_spiral_width\"] += 1\n",
        "            self.set_scale(scale, **kwargs)\n",
        "            prime_spiral.set_stroke_width(tp)\n",
        "            self.wait()\n",
        "            self.remove(prime_labels)\n",
        "\n",
        "\n",
        "class ThickZoomOutOnPrimesWithNumbers(ZoomOutOnPrimesWithNumbers):\n",
        "    CONFIG = {\n",
        "        # The only purpose of this scene is for overlay\n",
        "        # with the last one to smooth things out.\n",
        "        \"thicker_target\": True,\n",
        "    }\n",
        "\n",
        "\n",
        "class HighlightGapsInSpirals(IntroducePrimePatterns):\n",
        "    def construct(self):\n",
        "        self.setup_spiral()\n",
        "\n",
        "        max_n_tracker = ValueTracker(0)\n",
        "        get_max_n = max_n_tracker.get_value\n",
        "        gaps = always_redraw(lambda: VGroup(*[\n",
        "            self.get_highlighted_gap(n - 1, n + 1, get_max_n())\n",
        "            for n in [11, 33]\n",
        "        ]))\n",
        "\n",
        "        self.add(gaps)\n",
        "        self.play(max_n_tracker.set_value, 25000, run_time=5)\n",
        "        gaps.clear_updaters()\n",
        "        self.play(FadeOut(gaps))\n",
        "\n",
        "    def setup_spiral(self):\n",
        "        p_spiral = self.get_p_spiral(read_in_primes(self.small_n_primes))\n",
        "        self.add(p_spiral)\n",
        "        self.set_scale(\n",
        "            scale=self.spiral_scale,\n",
        "            spiral=p_spiral,\n",
        "            target_p_spiral_width=8,\n",
        "            run_time=0,\n",
        "        )\n",
        "\n",
        "    def get_highlighted_gap(self, n1, n2, max_n):\n",
        "        l1, l2 = [\n",
        "            [\n",
        "                self.get_polar_point(k, k)\n",
        "                for k in range(INV_7_MOD_44 * n, int(max_n), 5 * 44)\n",
        "            ]\n",
        "            for n in (n1, n2)\n",
        "        ]\n",
        "\n",
        "        if len(l1) == 0 or len(l2) == 0:\n",
        "            return VectorizedPoint()\n",
        "\n",
        "        result = VMobject()\n",
        "        result.set_points_as_corners(\n",
        "            [*l1, *reversed(l2)]\n",
        "        )\n",
        "        result.make_smooth()\n",
        "\n",
        "        result.set_stroke(GREY, width=0)\n",
        "        result.set_fill(GREY_D, 1)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class QuestionIsMisleading(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Whoa, is this some\\\\\\\\divine hidden structure\\\\\\\\in the primes?\",\n",
        "            target_mode=\"surprised\",\n",
        "            index=0,\n",
        "            added_anims=[\n",
        "                self.students[1].change, \"pondering\",\n",
        "                self.students[2].change, \"pondering\",\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.students[0].bubble = None\n",
        "        self.teacher_says(\n",
        "            \"Er...not exactly\",\n",
        "            bubble_config={\"width\": 3, \"height\": 2},\n",
        "            target_mode=\"guilty\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class JustPrimesLabel(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Just the primes\")\n",
        "        text.scale(2)\n",
        "        text.to_corner(UL)\n",
        "        self.play(Write(text))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(text, DOWN))\n",
        "\n",
        "\n",
        "class DirichletComingUp(Scene):\n",
        "    def construct(self):\n",
        "        image = ImageMobject(\"Dirichlet\")\n",
        "        image.set_height(3)\n",
        "        words = OldTexText(\n",
        "            \"Coming up: \\\\\\\\\", \"Dirichlet's theorem\",\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        words.set_color_by_tex(\"Dirichlet's\", YELLOW)\n",
        "        words.scale(1.5)\n",
        "        words.next_to(image, RIGHT)\n",
        "        words.set_stroke(BLACK, 8, background=True)\n",
        "        Group(words, image).center()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(image, RIGHT),\n",
        "            FadeIn(words, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ImagineYouFoundIt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        you = self.students[1]\n",
        "        others = VGroup(\n",
        "            self.students[0],\n",
        "            self.students[2],\n",
        "            self.teacher,\n",
        "        )\n",
        "        bubble = you.get_bubble(direction=LEFT)\n",
        "        bubble[-1].set_fill(GREEN_SCREEN, 1)\n",
        "\n",
        "        you_label = OldTexText(\"You\")\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(you, UP)\n",
        "        you_label.next_to(arrow, UP)\n",
        "\n",
        "        self.play(\n",
        "            you.change, \"hesitant\", you_label,\n",
        "            FadeInFromDown(you_label),\n",
        "            GrowArrow(arrow),\n",
        "            others.set_opacity, 0.25,\n",
        "        )\n",
        "        self.play(Blink(you))\n",
        "        self.play(\n",
        "            FadeIn(bubble),\n",
        "            FadeOut(you_label),\n",
        "            FadeOut(arrow),\n",
        "            you.change, \"pondering\",\n",
        "        )\n",
        "        self.play(you.look_at, bubble.get_corner(UR))\n",
        "        self.play(Blink(you))\n",
        "        self.wait()\n",
        "        self.play(you.change, \"hooray\")\n",
        "        self.play(Blink(you))\n",
        "        self.wait()\n",
        "        self.play(you.change, \"sassy\", bubble.get_top())\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class ShowSpiralsForWholeNumbers(CountSpirals):\n",
        "    CONFIG = {\n",
        "        \"max_prime\": 10000,\n",
        "        \"scale_44\": 1e3,\n",
        "        \"scale_6\": 10,\n",
        "        \"n_labels\": 100,\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -50,\n",
        "            \"x_max\": 50,\n",
        "            \"y_min\": -50,\n",
        "            \"y_max\": 50,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.zoom_out_with_whole_numbers()\n",
        "        self.count_44_spirals()\n",
        "        self.zoom_back_in_to_6()\n",
        "\n",
        "    def zoom_out_with_whole_numbers(self):\n",
        "        wholes = self.get_p_spiral(range(self.max_prime))\n",
        "        primes = self.get_prime_p_spiral(self.max_prime)\n",
        "\n",
        "        wholes.set_color(YELLOW)\n",
        "        wholes.set_stroke_width(20)\n",
        "        primes.set_stroke_width(20)\n",
        "        spiral = PGroup(wholes, primes)\n",
        "\n",
        "        labels = self.get_labels(range(1, self.n_labels))\n",
        "\n",
        "        self.add(spiral, labels)\n",
        "        self.set_scale(\n",
        "            self.scale_44,\n",
        "            spiral=spiral,\n",
        "            to_shrink=labels,\n",
        "            target_p_spiral_width=6,\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.spiral = spiral\n",
        "        self.labels = labels\n",
        "\n",
        "    def count_44_spirals(self):\n",
        "        curr_spiral = self.spiral\n",
        "\n",
        "        new_spirals = PGroup(*[\n",
        "            self.get_p_spiral(range(\n",
        "                (INV_7_MOD_44 * k) % 44, self.max_prime, 44\n",
        "            ))\n",
        "            for k in range(44)\n",
        "        ])\n",
        "        new_spirals.set_color(YELLOW)\n",
        "\n",
        "        counts = VGroup()\n",
        "        for n, spiral in zip(it.count(1), new_spirals):\n",
        "            count = Integer(n)\n",
        "            count.scale(2)\n",
        "            count.move_to(spiral.get_points()[50])\n",
        "            counts.add(count)\n",
        "\n",
        "        self.remove(curr_spiral)\n",
        "        run_time = 3\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(new_spirals),\n",
        "            ShowSubmobjectsOneByOne(counts),\n",
        "            run_time=run_time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.add_count_clicks(44, run_time)\n",
        "        self.play(\n",
        "            counts[-1].scale, 2, {\"about_edge\": DL},\n",
        "            counts[-1].set_stroke, BLACK, 5, {\"background\": True},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(counts[-1]),\n",
        "            FadeOut(new_spirals),\n",
        "            FadeIn(curr_spiral),\n",
        "        )\n",
        "\n",
        "    def zoom_back_in_to_6(self):\n",
        "        spiral = self.spiral\n",
        "\n",
        "        self.rescale_labels(self.labels)\n",
        "        self.set_scale(\n",
        "            self.scale_6,\n",
        "            spiral=spiral,\n",
        "            to_shrink=self.labels,\n",
        "            target_p_spiral_width=15,\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def rescale_labels(self, labels):\n",
        "        for i, label in zip(it.count(1), labels):\n",
        "            height = label.get_height()\n",
        "            label.set_height(\n",
        "                3 * height / (i**0.25),\n",
        "                about_point=label.get_bottom() + 0.5 * label.get_height() * DOWN,\n",
        "            )\n",
        "\n",
        "\n",
        "class PrimeSpiralsAtScale1000(SpiralScene):\n",
        "    def construct(self):\n",
        "        spiral = self.get_prime_p_spiral(10000)\n",
        "        self.add(spiral)\n",
        "        self.set_scale(\n",
        "            scale=1000,\n",
        "            spiral=spiral,\n",
        "            target_p_spiral_width=15,\n",
        "            run_time=0,\n",
        "        )\n",
        "\n",
        "\n",
        "class SeparateIntoTwoQuestions(Scene):\n",
        "    def construct(self):\n",
        "        top_q = OldTexText(\"Why do\", \" primes\", \" cause\", \" spirals\", \"?\")\n",
        "        top_q.scale(2)\n",
        "        top_q.to_edge(UP)\n",
        "\n",
        "        q1 = OldTexText(\"Where do the\\\\\\\\\", \"spirals\", \" come from?\")\n",
        "        q2 = OldTexText(\"What happens when\\\\\\\\\", \"filtering to\", \" primes\", \"?\")\n",
        "        for q in q1, q2:\n",
        "            q.scale(1.3)\n",
        "            q.next_to(top_q, DOWN, LARGE_BUFF)\n",
        "        q1.to_edge(LEFT)\n",
        "        q1.set_color(YELLOW)\n",
        "        q2.to_edge(RIGHT)\n",
        "        q2.set_color(TEAL)\n",
        "\n",
        "        v_line = DashedLine(\n",
        "            top_q.get_bottom() + MED_SMALL_BUFF * DOWN,\n",
        "            FRAME_HEIGHT * DOWN / 2,\n",
        "        )\n",
        "\n",
        "        self.add(top_q)\n",
        "        self.wait()\n",
        "\n",
        "        for q, text in [(q1, \"spirals\"), (q2, \"primes\")]:\n",
        "            self.play(\n",
        "                top_q.get_part_by_tex(text).set_color, q.get_color(),\n",
        "                TransformFromCopy(\n",
        "                    top_q.get_part_by_tex(text),\n",
        "                    q.get_part_by_tex(text),\n",
        "                ),\n",
        "                LaggedStartMap(\n",
        "                    FadeIn,\n",
        "                    filter(\n",
        "                        lambda m: m is not q.get_part_by_tex(text),\n",
        "                        q,\n",
        "                    )\n",
        "                ),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TopQuestionCross(Scene):\n",
        "    def construct(self):\n",
        "        top_q = OldTexText(\"Why do\", \" primes\", \" cause\", \" spirals\", \"?\")\n",
        "        top_q.scale(2)\n",
        "        top_q.to_edge(UP)\n",
        "        cross = Cross(top_q)\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExplainSixSpirals(ShowSpiralsForWholeNumbers):\n",
        "    CONFIG = {\n",
        "        \"max_N\": 150,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_spirals_and_labels()\n",
        "        self.comment_on_arms()\n",
        "        self.talk_though_multiples_of_six()\n",
        "        self.limit_to_primes()\n",
        "\n",
        "    def add_spirals_and_labels(self):\n",
        "        max_N = self.max_N\n",
        "\n",
        "        spiral = self.get_v_spiral(range(max_N))\n",
        "        primes = generate_prime_list(max_N)\n",
        "        spiral.set_color(YELLOW)\n",
        "        for n, box in enumerate(spiral):\n",
        "            if n in primes:\n",
        "                box.set_color(TEAL)\n",
        "\n",
        "        labels = self.get_labels(range(max_N))\n",
        "\n",
        "        self.add(spiral, labels)\n",
        "        self.set_scale(\n",
        "            spiral=spiral,\n",
        "            scale=self.scale_6,\n",
        "            to_shrink=labels,\n",
        "            min_box_width=0.08,\n",
        "            run_time=0,\n",
        "        )\n",
        "        self.rescale_labels(labels)\n",
        "\n",
        "        self.spiral = spiral\n",
        "        self.labels = labels\n",
        "\n",
        "    def comment_on_arms(self):\n",
        "        labels = self.labels\n",
        "        spiral = self.spiral\n",
        "\n",
        "        label_groups = VGroup(*[labels[k::6] for k in range(6)])\n",
        "        spiral_groups = VGroup(*[spiral[k::6] for k in range(6)])\n",
        "        six_groups = VGroup(*[\n",
        "            VGroup(sg, lg)\n",
        "            for sg, lg in zip(spiral_groups, label_groups)\n",
        "        ])\n",
        "        rect_groups = VGroup(*[\n",
        "            VGroup(*[\n",
        "                SurroundingRectangle(label, stroke_width=2, buff=0.05)\n",
        "                for label in group\n",
        "            ])\n",
        "            for group in label_groups\n",
        "        ])\n",
        "\n",
        "        formula = VGroup(\n",
        "            *Tex(\"6k\", \"+\"),\n",
        "            Integer(1)\n",
        "        )\n",
        "        formula.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        formula.scale(2)\n",
        "        formula.set_color(YELLOW)\n",
        "        formula.to_corner(UL)\n",
        "        formula_rect = SurroundingRectangle(formula, buff=MED_LARGE_BUFF - SMALL_BUFF)\n",
        "        formula_rect.set_fill(GREY_D, opacity=1)\n",
        "        formula_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        # 6k\n",
        "        self.add(six_groups, formula_rect)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, rect_groups[0]),\n",
        "            FadeInFromDown(formula_rect),\n",
        "            FadeInFromDown(formula[0]),\n",
        "            *[\n",
        "                ApplyMethod(group.set_opacity, 0.25)\n",
        "                for group in six_groups[1:]\n",
        "            ],\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut, rect_groups[0],\n",
        "                run_time=1,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 6k + 1\n",
        "        self.play(\n",
        "            six_groups[0].set_opacity, 0.25,\n",
        "            six_groups[1].set_opacity, 1,\n",
        "            FadeIn(formula[1:]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # 6k + m\n",
        "        for m in [2, 3, 4, 5]:\n",
        "            self.play(\n",
        "                six_groups[m - 1].set_opacity, 0.25,\n",
        "                six_groups[m].set_opacity, 1,\n",
        "                ChangeDecimalToValue(formula[2], m),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            six_groups[5].set_opacity, 0.25,\n",
        "            six_groups[0].set_opacity, 1,\n",
        "            formula[1:].set_opacity, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.six_groups = six_groups\n",
        "        self.formula = VGroup(formula_rect, *formula)\n",
        "\n",
        "    def talk_though_multiples_of_six(self):\n",
        "        spiral = self.spiral\n",
        "        labels = self.labels\n",
        "        formula = self.formula\n",
        "\n",
        "        # Zoom in\n",
        "        self.add(spiral, labels, formula)\n",
        "        self.set_scale(\n",
        "            4.5,\n",
        "            spiral=spiral,\n",
        "            to_shrink=labels,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        boxes = VGroup(*[\n",
        "            VGroup(b.copy(), l.copy())\n",
        "            for b, l in zip(spiral, labels)\n",
        "        ])\n",
        "        boxes.set_opacity(1)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, box[0].get_center())\n",
        "            for box in boxes\n",
        "        ])\n",
        "        lines.set_stroke(GREY_B, width=2)\n",
        "\n",
        "        arcs = self.get_arcs(range(31))\n",
        "\n",
        "        trash = VGroup()\n",
        "\n",
        "        def show_steps(start, stop, added_anims=None, run_time=2):\n",
        "            if added_anims is None:\n",
        "                added_anims = []\n",
        "            self.play(\n",
        "                *[\n",
        "                    ShowSubmobjectsOneByOne(group[start:stop + 1])\n",
        "                    for group in [arcs, boxes, lines]\n",
        "                ],\n",
        "                *added_anims,\n",
        "                rate_func=linear,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "            self.add_count_clicks(N=6, time=run_time)\n",
        "            trash.add(VGroup(arcs[stop], boxes[stop], lines[stop]))\n",
        "\n",
        "        # Writing next to the 6\n",
        "        six = boxes[6][1]\n",
        "        rhs = OldTex(\n",
        "            \"\\\\text{radians}\",\n",
        "            \"\\\\approx\",\n",
        "            \"2\\\\pi\",\n",
        "            \"\\\\text{ radians}\"\n",
        "        )\n",
        "        rhs.next_to(six, RIGHT, 2 * SMALL_BUFF, aligned_edge=DOWN)\n",
        "        rhs.add_background_rectangle()\n",
        "        tau_value = OldTex(\"{:.8}\\\\dots\".format(TAU))\n",
        "        tau_value.next_to(rhs[3], UP, aligned_edge=LEFT)\n",
        "\n",
        "        # Animations\n",
        "        show_steps(0, 6, run_time=3)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rhs))\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(tau_value))\n",
        "        self.wait(2)\n",
        "\n",
        "        show_steps(6, 12)\n",
        "        self.wait()\n",
        "\n",
        "        show_steps(12, 18)\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom out\n",
        "        frame = self.camera_frame\n",
        "        frame.add(formula)\n",
        "        show_steps(18, 24, added_anims=[frame.scale, 2.5])\n",
        "        self.wait()\n",
        "        show_steps(24, 30)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(trash),\n",
        "            FadeOut(rhs),\n",
        "            FadeOut(tau_value),\n",
        "            spiral.set_opacity, 1,\n",
        "            labels.set_opacity, 1,\n",
        "            formula[1].set_opacity, 0,\n",
        "        )\n",
        "\n",
        "    def limit_to_primes(self):\n",
        "        formula = self.formula\n",
        "        formula_rect, six_k, plus, m_sym = formula\n",
        "        spiral = self.spiral\n",
        "        labels = self.labels\n",
        "        six_groups = self.six_groups\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        boxes = VGroup(*[\n",
        "            VGroup(b, l)\n",
        "            for b, l in zip(spiral, labels)\n",
        "        ])\n",
        "        prime_numbers = read_in_primes(self.max_N)\n",
        "        primes = VGroup()\n",
        "        non_primes = VGroup()\n",
        "        for n, box in enumerate(boxes):\n",
        "            if n in prime_numbers:\n",
        "                primes.add(box)\n",
        "            else:\n",
        "                non_primes.add(box)\n",
        "\n",
        "        prime_label = OldTexText(\"Primes\")\n",
        "        prime_label.set_color(TEAL)\n",
        "        prime_label.match_width(VGroup(six_k, m_sym))\n",
        "        prime_label.move_to(six_k, LEFT)\n",
        "\n",
        "        # Show just primes\n",
        "        self.add(primes, non_primes, formula)\n",
        "        self.play(\n",
        "            FadeIn(prime_label),\n",
        "            non_primes.set_opacity, 0.25,\n",
        "        )\n",
        "        frame.add(prime_label)\n",
        "        self.play(\n",
        "            frame.scale, 1.5,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        cross_groups = VGroup()\n",
        "        for group in six_groups:\n",
        "            group.save_state()\n",
        "            boxes, labels = group\n",
        "            cross_group = VGroup()\n",
        "            for label in labels:\n",
        "                cross_group.add(Cross(label))\n",
        "            cross_groups.add(cross_group)\n",
        "        cross_groups.set_stroke(width=3)\n",
        "        cross_groups[2].remove(cross_groups[2][0])\n",
        "        cross_groups[3].remove(cross_groups[3][0])\n",
        "\n",
        "        # Show multiples of 6\n",
        "        for r in [0, 2, 4, 3]:\n",
        "            arm = six_groups[r]\n",
        "            crosses = cross_groups[r]\n",
        "            self.add(arm, frame)\n",
        "\n",
        "            anims = [arm.set_opacity, 1]\n",
        "            if r == 0:\n",
        "                anims += [\n",
        "                    prime_label.set_opacity, 0,\n",
        "                    six_k.set_opacity, 1\n",
        "                ]\n",
        "            elif r == 2:\n",
        "                m_sym.set_value(2)\n",
        "                anims += [\n",
        "                    plus.set_opacity, 1,\n",
        "                    m_sym.set_opacity, 1,\n",
        "                ]\n",
        "            else:\n",
        "                anims.append(ChangeDecimalToValue(m_sym, r))\n",
        "            self.play(*anims)\n",
        "            self.add(*crosses, frame)\n",
        "            self.play(\n",
        "                LaggedStartMap(ShowCreation, crosses),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Fade forbidden groups\n",
        "        to_fade = VGroup(*[\n",
        "            VGroup(six_groups[r], cross_groups[r])\n",
        "            for r in (0, 2, 3, 4)\n",
        "        ])\n",
        "        self.add(to_fade, frame)\n",
        "        self.play(\n",
        "            to_fade.set_opacity, 0.25,\n",
        "            VGroup(six_k, plus, m_sym).set_opacity, 0,\n",
        "            prime_label.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def arc_func(self, t):\n",
        "        r = 0.25 + 0.02 * t\n",
        "        return r * np.array([np.cos(t), np.sin(t), 0])\n",
        "\n",
        "    def get_arc(self, n):\n",
        "        if n == 0:\n",
        "            return VectorizedPoint()\n",
        "        return ParametricCurve(\n",
        "            self.arc_func,\n",
        "            t_min=0,\n",
        "            t_max=n,\n",
        "            step_size=0.1,\n",
        "            stroke_width=2,\n",
        "            stroke_color=PINK,\n",
        "        )\n",
        "\n",
        "    def get_arcs(self, sequence):\n",
        "        return VGroup(*map(self.get_arc, sequence))\n",
        "\n",
        "\n",
        "class IntroduceResidueClassTerminology(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_sequences()\n",
        "        self.add_terms()\n",
        "        self.highlight_example()\n",
        "        self.simple_english()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Overly-fancy \", \"terminology\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        underline = Line().match_width(title)\n",
        "        underline.next_to(title, DOWN, SMALL_BUFF)\n",
        "\n",
        "        pre_title = OldTexText(\"Terminology\")\n",
        "        pre_title.replace(title, dim_to_match=1)\n",
        "\n",
        "        self.play(FadeInFromDown(pre_title))\n",
        "        self.wait()\n",
        "        title[0].set_color(BLUE)\n",
        "        underline.set_color(BLUE)\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_title[0], title[1]),\n",
        "            FadeIn(title[0], RIGHT),\n",
        "            GrowFromCenter(underline)\n",
        "        )\n",
        "        self.play(\n",
        "            title[0].set_color, WHITE,\n",
        "            underline.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        title.add(underline)\n",
        "        self.add(title)\n",
        "\n",
        "        self.title = title\n",
        "        self.underline = underline\n",
        "\n",
        "    def add_sequences(self):\n",
        "        sequences = VGroup()\n",
        "        n_terms = 7\n",
        "\n",
        "        for r in range(6):\n",
        "            sequence = VGroup(*[\n",
        "                Integer(6 * k + r)\n",
        "                for k in range(n_terms)\n",
        "            ])\n",
        "            sequence.arrange(RIGHT, buff=0.4)\n",
        "            sequences.add(sequence)\n",
        "\n",
        "        sequences.arrange(DOWN, buff=0.7, aligned_edge=LEFT)\n",
        "        for sequence in sequences:\n",
        "            for s1, s2 in zip(sequence[:n_terms], sequences[-1]):\n",
        "                s1.align_to(s2, RIGHT)\n",
        "            commas = VGroup()\n",
        "            for num in sequence[:-1]:\n",
        "                comma = OldTexText(\",\")\n",
        "                comma.next_to(num.get_corner(DR), RIGHT, SMALL_BUFF)\n",
        "                commas.add(comma)\n",
        "            dots = OldTex(\"\\\\dots\")\n",
        "            dots.next_to(sequence.get_corner(DR), RIGHT, SMALL_BUFF)\n",
        "            sequence.numbers = VGroup(*sequence)\n",
        "            sequence.commas = commas\n",
        "            sequence.dots = dots\n",
        "\n",
        "            sequence.add(*commas)\n",
        "            sequence.add(dots)\n",
        "            sequence.sort(lambda p: p[0])\n",
        "\n",
        "        labels = VGroup(*[\n",
        "            OldTex(\"6k + {}:\".format(r))\n",
        "            for r in range(6)\n",
        "        ])\n",
        "        labels.set_color(YELLOW)\n",
        "        for label, sequence in zip(labels, sequences):\n",
        "            label.next_to(sequence, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        group = VGroup(sequences, labels)\n",
        "        group.to_edge(LEFT).to_edge(DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(labels)\n",
        "        self.play(LaggedStart(*[\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, sequence,\n",
        "                lambda m: (m, LEFT),\n",
        "            )\n",
        "            for sequence in sequences\n",
        "        ], lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        self.sequences = sequences\n",
        "        self.sequence_labels = labels\n",
        "\n",
        "    def add_terms(self):\n",
        "        sequences = self.sequences\n",
        "\n",
        "        terms = OldTexText(\n",
        "            \"``\", \"Residue\\\\\\\\\",\n",
        "            \"classes\\\\\\\\\",\n",
        "            \"mod \", \"6''\"\n",
        "        )\n",
        "        terms.scale(1.5)\n",
        "        terms.set_color(YELLOW)\n",
        "        terms.to_edge(RIGHT)\n",
        "\n",
        "        res_brace = Brace(terms.get_part_by_tex(\"Residue\"), UP)\n",
        "        remainder = OldTexText(\"Remainder\")\n",
        "        remainder.next_to(res_brace, UP, SMALL_BUFF)\n",
        "\n",
        "        mod_brace = Brace(terms.get_part_by_tex(\"mod\"), DOWN)\n",
        "        mod_def = OldTexText(\n",
        "            \"``where the thing\\\\\\\\you divide by is''\"\n",
        "        )\n",
        "        mod_def.next_to(mod_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(terms.get_left(), sequence.get_right())\n",
        "            for sequence in sequences\n",
        "        ])\n",
        "        arrows.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(terms),\n",
        "            LaggedStartMap(ShowCreation, arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(res_brace),\n",
        "            FadeInFromDown(remainder),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(mod_brace))\n",
        "        self.play(Write(mod_def))\n",
        "        self.wait()\n",
        "\n",
        "        self.terminology = VGroup(\n",
        "            terms,\n",
        "            res_brace, remainder,\n",
        "            mod_brace, mod_def,\n",
        "            arrows\n",
        "        )\n",
        "\n",
        "    def highlight_example(self):\n",
        "        sequences = self.sequences\n",
        "        labels = self.sequence_labels\n",
        "\n",
        "        r = 2\n",
        "        k = 3\n",
        "        sequence = sequences[r]\n",
        "        label = labels[r]\n",
        "        r_tex = label[0][3]\n",
        "        n_rects = VGroup(*[\n",
        "            SurroundingRectangle(num)\n",
        "            for num in sequence.numbers\n",
        "        ])\n",
        "        r_rect = SurroundingRectangle(r_tex)\n",
        "        n_rects.set_color(RED)\n",
        "        r_rect.set_color(RED)\n",
        "\n",
        "        n_rect = n_rects.submobjects.pop(k)\n",
        "\n",
        "        self.play(ShowCreation(n_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(n_rect, r_rect, path_arc=30 * DEGREES)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(n_rects))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(\n",
        "                self.underline.copy().set_color(PINK),\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def simple_english(self):\n",
        "        terminology = self.terminology\n",
        "        sequences = self.sequences\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.set_height(2)\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR)\n",
        "\n",
        "        new_phrase = OldTexText(\"Everything 2 above\\\\\\\\a multiple of 6\")\n",
        "        new_phrase.scale(1.2)\n",
        "        new_phrase.set_color(RED_B)\n",
        "        new_phrase.next_to(sequences[2])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(terminology),\n",
        "            FadeIn(new_phrase),\n",
        "            VFadeIn(randy),\n",
        "            randy.change, \"sassy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"angry\")\n",
        "        for x in range(2):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeOut(new_phrase),\n",
        "            FadeIn(terminology),\n",
        "            FadeOut(randy, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class SimpleLongDivision(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"background_color\": GREY_E\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        divisor = Integer(6)\n",
        "        num = Integer(20)\n",
        "        quotient = Integer(num.get_value() // divisor.get_value())\n",
        "        to_subtract = Integer(-1 * quotient.get_value() * divisor.get_value())\n",
        "        remainder = Integer(num.get_value() + to_subtract.get_value())\n",
        "\n",
        "        div_sym = VMobject()\n",
        "        div_sym.set_points_as_corners([0.2 * UP, UP, UP + 3 * RIGHT])\n",
        "\n",
        "        divisor.next_to(div_sym, LEFT, MED_SMALL_BUFF)\n",
        "        num.next_to(divisor, RIGHT, MED_LARGE_BUFF)\n",
        "        to_subtract.next_to(num, DOWN, buff=MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.next_to(to_subtract, DOWN, buff=MED_SMALL_BUFF)\n",
        "        remainder.next_to(to_subtract, DOWN, buff=MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        quotient.next_to(num, UP, buff=MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "\n",
        "        remainder_rect = SurroundingRectangle(remainder)\n",
        "        remainder_rect.set_color(RED)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        frame.scale(0.7, about_point=ORIGIN)\n",
        "\n",
        "        divisor.set_color(YELLOW)\n",
        "        num.set_color(RED)\n",
        "\n",
        "        self.add(divisor)\n",
        "        self.add(div_sym)\n",
        "        self.add(num)\n",
        "        self.play(FadeInFromDown(quotient))\n",
        "        self.play(\n",
        "            TransformFromCopy(divisor, to_subtract.copy()),\n",
        "            TransformFromCopy(quotient, to_subtract),\n",
        "        )\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.play(Write(remainder))\n",
        "        self.play(ShowCreation(remainder_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(remainder_rect))\n",
        "\n",
        "\n",
        "class ZoomOutWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Zoom out!\")\n",
        "        words.scale(3)\n",
        "        self.play(FadeInFromLarge(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Explain44Spirals(ExplainSixSpirals):\n",
        "    CONFIG = {\n",
        "        \"max_N\": 3000,\n",
        "        \"initial_scale\": 10,\n",
        "        \"zoom_factor_1\": 7,\n",
        "        \"zoom_factor_2\": 3,\n",
        "        \"n_labels\": 80,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_spirals_and_labels()\n",
        "        self.show_44_steps()\n",
        "        self.show_top_right_arithmetic()\n",
        "        self.show_pi_approx_arithmetic()\n",
        "        self.count_by_44()\n",
        "\n",
        "    def add_spirals_and_labels(self):\n",
        "        max_N = self.max_N\n",
        "\n",
        "        wholes = self.get_p_spiral(range(max_N))\n",
        "        primes = self.get_prime_p_spiral(max_N)\n",
        "        wholes.set_color(YELLOW)\n",
        "        spiral = PGroup(wholes, primes)\n",
        "\n",
        "        labels = self.get_labels(range(self.n_labels))\n",
        "\n",
        "        self.add(spiral, labels)\n",
        "        self.set_scale(\n",
        "            spiral=spiral,\n",
        "            scale=self.initial_scale,\n",
        "            to_shrink=labels,\n",
        "            target_p_spiral_width=10,\n",
        "            run_time=0,\n",
        "        )\n",
        "        self.rescale_labels(labels)\n",
        "\n",
        "        self.spiral = spiral\n",
        "        self.labels = labels\n",
        "\n",
        "    def show_44_steps(self):\n",
        "        labels = self.labels\n",
        "\n",
        "        ns = range(45)\n",
        "        points = [self.get_polar_point(n, n) for n in ns]\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, point)\n",
        "            for point in points\n",
        "        ])\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "        arcs = self.get_arcs(ns)\n",
        "\n",
        "        opaque_labels = labels.copy()\n",
        "        labels.set_opacity(0.25)\n",
        "\n",
        "        trash = VGroup()\n",
        "\n",
        "        def show_steps(start, stop, added_anims=None, run_time=2):\n",
        "            if added_anims is None:\n",
        "                added_anims = []\n",
        "\n",
        "            def rate_func(t):\n",
        "                return smooth(t, 2)\n",
        "\n",
        "            self.play(\n",
        "                *[\n",
        "                    ShowSubmobjectsOneByOne(group[start:stop + 1])\n",
        "                    for group in [arcs, opaque_labels, lines]\n",
        "                ],\n",
        "                *added_anims,\n",
        "                rate_func=rate_func,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "            self.add_count_clicks(\n",
        "                N=(stop - start), time=run_time,\n",
        "                rate_func=rate_func\n",
        "            )\n",
        "            trash.add(arcs[stop], opaque_labels[stop], lines[stop])\n",
        "\n",
        "        show_steps(0, 6)\n",
        "        self.wait()\n",
        "        show_steps(6, 44, added_anims=[FadeOut(trash)], run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "        self.spiral_group = trash[-3:]\n",
        "\n",
        "    def show_top_right_arithmetic(self):\n",
        "        labels = self.labels\n",
        "        ff = labels[44].copy()\n",
        "        ff.generate_target()\n",
        "\n",
        "        radians = OldTexText(\"radians\")\n",
        "        ff.target.scale(1.5)\n",
        "        ff.target.set_opacity(1)\n",
        "\n",
        "        unit_conversion = OldTex(\n",
        "            \"/\\\\,\", \"\\\\left(\", \"2\\\\pi\",\n",
        "            \"{\\\\text{radians}\", \"\\\\over\", \"\\\\text{rotations}}\",\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        unit_conversion[1:].scale(0.7, about_edge=LEFT)\n",
        "\n",
        "        top_line = VGroup(ff.target, radians, unit_conversion)\n",
        "        top_line.arrange(RIGHT)\n",
        "        ff.target.align_to(radians, DOWN)\n",
        "        top_line.to_corner(UR, buff=0.4)\n",
        "\n",
        "        next_line = OldTex(\n",
        "            \"=\", \"44\", \"/\", \"2\\\\pi\",\n",
        "            \"\\\\text{ rotations}\"\n",
        "        )\n",
        "        next_line.next_to(top_line, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        brace = Brace(next_line[1:4], DOWN, buff=SMALL_BUFF)\n",
        "        value = DecimalNumber(44 / TAU, num_decimal_places=8, show_ellipsis=True)\n",
        "        value.next_to(brace, DOWN)\n",
        "\n",
        "        rect = SurroundingRectangle(VGroup(top_line, value), buff=MED_SMALL_BUFF)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(GREY_E, 0.9)\n",
        "\n",
        "        self.play(MoveToTarget(ff))\n",
        "        top_line.add(ff)\n",
        "        self.play(FadeIn(radians, LEFT))\n",
        "        self.wait()\n",
        "        self.add(rect, top_line, unit_conversion)\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(unit_conversion),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(ff, next_line.get_part_by_tex(\"44\")),\n",
        "            FadeIn(next_line.get_part_by_tex(\"=\")),\n",
        "            TransformFromCopy(\n",
        "                unit_conversion.get_part_by_tex(\"/\"),\n",
        "                next_line.get_part_by_tex(\"/\"),\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                unit_conversion.get_part_by_tex(\"rotations\"),\n",
        "                next_line.get_part_by_tex(\"rotations\"),\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                unit_conversion.get_part_by_tex(\"2\\\\pi\"),\n",
        "                next_line.get_part_by_tex(\"2\\\\pi\"),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(value),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.right_arithmetic = VGroup(\n",
        "            rect, top_line, next_line,\n",
        "            brace, value\n",
        "        )\n",
        "\n",
        "    def show_pi_approx_arithmetic(self):\n",
        "        ra = self.right_arithmetic\n",
        "        ra_rect, ra_l1, ra_l2, ra_brace, ra_value = ra\n",
        "\n",
        "        lines = VGroup(\n",
        "            OldTex(\"{44\", \"\\\\over\", \"2\\\\pi}\", \"\\\\approx\", \"7\"),\n",
        "            OldTex(\"\\\\Leftrightarrow\"),\n",
        "            OldTex(\"{44\", \"\\\\over\", \"7}\", \"\\\\approx\", \"2\\\\pi\"),\n",
        "            OldTex(\"{22\", \"\\\\over\", \"7}\", \"\\\\approx\", \"\\\\pi\"),\n",
        "        )\n",
        "        lines.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        lines.to_corner(UL)\n",
        "        lines[3].move_to(lines[2], LEFT)\n",
        "\n",
        "        rect = SurroundingRectangle(lines, buff=MED_LARGE_BUFF)\n",
        "        rect.match_style(ra_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(ra_l2[1:4], lines[0][:3]),\n",
        "                FadeIn(lines[0].get_part_by_tex(\"approx\")),\n",
        "                TransformFromCopy(ra_value[0], lines[0].get_part_by_tex(\"7\")),\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        l0_copy = lines[0].copy()\n",
        "        self.play(\n",
        "            l0_copy.move_to, lines[2],\n",
        "            Write(lines[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ReplacementTransform(\n",
        "                    l0_copy.get_part_by_tex(tex),\n",
        "                    lines[2].get_part_by_tex(tex),\n",
        "                    path_arc=60 * DEGREES,\n",
        "                )\n",
        "                for tex in [\"44\", \"\\\\over\", \"7\", \"approx\", \"2\\\\pi\"]\n",
        "            ], lag_ratio=0.1, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(lines[2], lines[3]))\n",
        "        self.wait()\n",
        "\n",
        "        left_arithmetic = VGroup(rect, lines[:3])\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(self.spiral_group[0]),\n",
        "                FadeOut(left_arithmetic),\n",
        "                FadeOut(self.right_arithmetic),\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def count_by_44(self):\n",
        "        ff_label, ff_line = self.spiral_group[1:]\n",
        "        faded_labels = self.labels\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        n_values = 100\n",
        "        mod = 44\n",
        "        values = range(mod, n_values * mod, mod)\n",
        "        points = [\n",
        "            self.get_polar_point(n, n)\n",
        "            for n in values\n",
        "        ]\n",
        "\n",
        "        p2l_tracker = ValueTracker(\n",
        "            get_norm(ff_label.get_bottom() - points[0])\n",
        "        )\n",
        "        get_p2l = p2l_tracker.get_value\n",
        "        l_height_ratio_tracker = ValueTracker(\n",
        "            ff_label.get_height() / frame.get_height()\n",
        "        )\n",
        "        get_l_height_ratio = l_height_ratio_tracker.get_value\n",
        "\n",
        "        n_labels = 10\n",
        "        labels = VGroup(*[Integer(n) for n in values[:n_labels]])\n",
        "        for label, point in zip(labels, points):\n",
        "            label.point = point\n",
        "            label.add_updater(\n",
        "                lambda l: l.set_height(\n",
        "                    frame.get_height() * get_l_height_ratio()\n",
        "                )\n",
        "            )\n",
        "            label.add_updater(\n",
        "                lambda l: l.move_to(\n",
        "                    l.point + get_p2l() * UP,\n",
        "                    DOWN,\n",
        "                )\n",
        "            )\n",
        "        labels.set_stroke(BLACK, 2, background=True)\n",
        "\n",
        "        lines = VGroup(ff_line)\n",
        "        for p1, p2 in zip(points, points[1:]):\n",
        "            lines.add(Line(p1, p2))\n",
        "        lines.match_style(ff_line)\n",
        "\n",
        "        self.remove(self.spiral_group)\n",
        "        self.remove(faded_labels[44])\n",
        "        self.play(\n",
        "            frame.scale, self.zoom_factor_1,\n",
        "            p2l_tracker.set_value, 1,\n",
        "            l_height_ratio_tracker.set_value, 0.025,\n",
        "            FadeOut(\n",
        "                ff_label,\n",
        "                rate_func=squish_rate_func(smooth, 0, 1 / 8),\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                *2 * [Animation(Group())],  # Weird and dumb\n",
        "                *map(FadeIn, labels),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                *2 * [Animation(Group())],\n",
        "                *map(ShowCreation, lines[:len(labels)]),\n",
        "                lag_ratio=1,\n",
        "            ),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.scale, self.zoom_factor_2,\n",
        "            l_height_ratio_tracker.set_value, 0.01,\n",
        "            ShowCreation(lines[len(labels):]),\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "        self.ff_spiral_lines = lines\n",
        "        self.ff_spiral_labels = labels\n",
        "\n",
        "    #\n",
        "    def arc_func(self, t):\n",
        "        r = 0.1 * t\n",
        "        return r * np.array([np.cos(t), np.sin(t), 0])\n",
        "\n",
        "\n",
        "class Label44Spirals(Explain44Spirals):\n",
        "    def construct(self):\n",
        "        self.setup_spirals()\n",
        "        self.enumerate_spirals()\n",
        "\n",
        "    def setup_spirals(self):\n",
        "        max_N = self.max_N\n",
        "        mod = 44\n",
        "        primes = read_in_primes(max_N)\n",
        "        spirals = VGroup()\n",
        "        for r in range(mod):\n",
        "            ns = range(r, max_N, mod)\n",
        "            spiral = self.get_v_spiral(ns, box_width=1)\n",
        "            for box, n in zip(spiral, ns):\n",
        "                box.n = n\n",
        "                if n in primes:\n",
        "                    box.set_color(TEAL)\n",
        "                else:\n",
        "                    box.set_color(YELLOW)\n",
        "            spirals.add(spiral)\n",
        "\n",
        "        self.add(spirals)\n",
        "        scale = np.prod([\n",
        "            self.initial_scale,\n",
        "            self.zoom_factor_1,\n",
        "            self.zoom_factor_2,\n",
        "        ])\n",
        "        self.set_scale(\n",
        "            spiral=VGroup(*it.chain(*spirals)),\n",
        "            scale=scale,\n",
        "            run_time=0\n",
        "        )\n",
        "\n",
        "        self.spirals = spirals\n",
        "\n",
        "    def enumerate_spirals(self):\n",
        "        spirals = self.spirals\n",
        "        labels = self.get_spiral_arm_labels(spirals)\n",
        "\n",
        "        self.play(\n",
        "            spirals[1:].set_opacity, 0.25,\n",
        "            FadeIn(labels[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for n in range(10):\n",
        "            arc = Arc(\n",
        "                start_angle=n + 0.2,\n",
        "                angle=0.9,\n",
        "                radius=1.5,\n",
        "            )\n",
        "            arc.add_tip()\n",
        "            mid_point = arc.point_from_proportion(0.5)\n",
        "            r_label = OldTexText(\"1 radian\")\n",
        "            # r_label.rotate(\n",
        "            #     angle_of_vector(arc.get_end() - arc.get_start()) - PI\n",
        "            # )\n",
        "            r_label.next_to(mid_point, normalize(mid_point))\n",
        "            if n > 2:\n",
        "                r_label.set_opacity(0)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(arc),\n",
        "                FadeIn(r_label),\n",
        "                spirals[n + 1].set_opacity, 1,\n",
        "                TransformFromCopy(labels[n], labels[n + 1])\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(arc),\n",
        "                FadeOut(r_label),\n",
        "                spirals[n].set_opacity, 0.25,\n",
        "                FadeOut(labels[n]),\n",
        "            )\n",
        "\n",
        "    #\n",
        "    def get_spiral_arm_labels(self, spirals, index=15):\n",
        "        mod = 44\n",
        "        labels = VGroup(*[\n",
        "            VGroup(\n",
        "                *Tex(\"44k\", \"+\"),\n",
        "                Integer(n)\n",
        "            ).arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            for n in range(mod)\n",
        "        ])\n",
        "        labels[0][1:].set_opacity(0)\n",
        "        labels.scale(1.5)\n",
        "        labels.set_color(YELLOW)\n",
        "\n",
        "        for label, spiral in zip(labels, spirals):\n",
        "            box = spiral[index]\n",
        "            vect = rotate_vector(box.get_center(), 90 * DEGREES)\n",
        "            label.next_to(box, normalize(vect), SMALL_BUFF)\n",
        "        labels[0].shift(UR + 1.25 * RIGHT)\n",
        "        return labels\n",
        "\n",
        "\n",
        "class ResidueClassMod44Label(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\n",
        "            \"``Residue class mod 44''\"\n",
        "        )\n",
        "        text.scale(2)\n",
        "        text.to_corner(UL)\n",
        "\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EliminateNonPrimativeResidueClassesOf44(Label44Spirals):\n",
        "    CONFIG = {\n",
        "        \"max_N\": 7000,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_spirals()\n",
        "        self.eliminate_classes()\n",
        "        self.zoom_out()\n",
        "        self.filter_to_primes()\n",
        "\n",
        "    def eliminate_classes(self):\n",
        "        spirals = self.spirals\n",
        "        labels = self.get_spiral_arm_labels(spirals)\n",
        "\n",
        "        # Eliminate factors of 2\n",
        "        self.play(\n",
        "            spirals[1:].set_opacity, 0.5,\n",
        "            FadeIn(labels[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(spirals[0]),\n",
        "            FadeOut(labels[0]),\n",
        "        )\n",
        "        for n in range(2, 8, 2):\n",
        "            self.play(\n",
        "                FadeIn(labels[n]),\n",
        "                spirals[n].set_opacity, 1,\n",
        "            )\n",
        "            self.play(FadeOut(VGroup(labels[n], spirals[n])))\n",
        "\n",
        "        words = OldTexText(\"All even numbers\")\n",
        "        words.scale(1.5)\n",
        "        words.to_corner(UL)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyMethod(spiral.set_opacity, 1)\n",
        "                for spiral in spirals[8::2]\n",
        "            ], lag_ratio=0.01),\n",
        "            FadeIn(words),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(spirals[8::2])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Eliminate factors of 11\n",
        "        for k in [11, 33]:\n",
        "            self.play(\n",
        "                spirals[k].set_opacity, 1,\n",
        "                FadeIn(labels[k])\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(spirals[k]),\n",
        "                FadeOut(labels[k]),\n",
        "            )\n",
        "\n",
        "        admissible_spirals = VGroup(*[\n",
        "            spiral\n",
        "            for n, spiral in enumerate(spirals)\n",
        "            if n % 2 != 0 and n % 11 != 0\n",
        "\n",
        "        ])\n",
        "\n",
        "        self.play(admissible_spirals.set_opacity, 1)\n",
        "\n",
        "        self.admissible_spirals = admissible_spirals\n",
        "\n",
        "    def zoom_out(self):\n",
        "        frame = self.camera_frame\n",
        "        admissible_spirals = self.admissible_spirals\n",
        "        admissible_spirals.generate_target()\n",
        "        for spiral in admissible_spirals.target:\n",
        "            for box in spiral:\n",
        "                box.scale(3)\n",
        "\n",
        "        self.play(\n",
        "            frame.scale, 4,\n",
        "            MoveToTarget(admissible_spirals),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "    def filter_to_primes(self):\n",
        "        admissible_spirals = self.admissible_spirals\n",
        "        frame = self.camera_frame\n",
        "        primes = read_in_primes(self.max_N)\n",
        "\n",
        "        to_fade = VGroup(*[\n",
        "            box\n",
        "            for spiral in admissible_spirals\n",
        "            for box in spiral\n",
        "            if box.n not in primes\n",
        "        ])\n",
        "        words = OldTexText(\"Just the primes\")\n",
        "        words.set_height(0.1 * frame.get_height())\n",
        "        words.next_to(frame.get_corner(UL), DR, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, to_fade, lag_ratio=2 / len(to_fade)),\n",
        "            FadeIn(words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceTotientJargon(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.eliminate_non_coprimes()\n",
        "\n",
        "    def add_title(self):\n",
        "        self.teacher_says(\n",
        "            \"More jargon!\",\n",
        "            target_mode=\"hooray\",\n",
        "        )\n",
        "        self.play_all_student_changes(\"erm\")\n",
        "        words = self.teacher.bubble.content\n",
        "\n",
        "        words.generate_target()\n",
        "        words.target.scale(1.5)\n",
        "        words.target.center().to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        words.target.set_color(BLUE)\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.match_width(words.target)\n",
        "        underline.next_to(words.target, DOWN, SMALL_BUFF)\n",
        "        underline.scale(1.2)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(words),\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            LaggedStart(*[\n",
        "                FadeOut(pi, 4 * DOWN)\n",
        "                for pi in self.pi_creatures\n",
        "            ]),\n",
        "            ShowCreation(underline)\n",
        "        )\n",
        "\n",
        "    def eliminate_non_coprimes(self):\n",
        "        number_grid = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Integer(n) for n in range(11 * k, 11 * (k + 1))\n",
        "            ]).arrange(DOWN)\n",
        "            for k in range(4)\n",
        "        ]).arrange(RIGHT, buff=1)\n",
        "        numbers = VGroup(*it.chain(*number_grid))\n",
        "        numbers.set_height(6)\n",
        "        numbers.move_to(4 * LEFT)\n",
        "        numbers.to_edge(DOWN)\n",
        "\n",
        "        evens = VGroup(*filter(\n",
        "            lambda nm: nm.get_value() % 2 == 0,\n",
        "            numbers\n",
        "        ))\n",
        "        div11 = VGroup(*filter(\n",
        "            lambda nm: nm.get_value() % 11 == 0,\n",
        "            numbers\n",
        "        ))\n",
        "        coprimes = VGroup(*filter(\n",
        "            lambda nm: nm not in evens and nm not in div11,\n",
        "            numbers\n",
        "        ))\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Which ones \", \"don't\\\\\\\\\",\n",
        "            \"share any factors\\\\\\\\\",\n",
        "            \"with \", \"44\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        words.scale(1.5)\n",
        "        words.next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        ff = words.get_part_by_tex(\"44\")\n",
        "        ff.set_color(YELLOW)\n",
        "        ff.generate_target()\n",
        "\n",
        "        # Show coprimes\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(numbers, run_time=3),\n",
        "            FadeIn(words, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        for group in evens, div11:\n",
        "            rects = VGroup(*[\n",
        "                SurroundingRectangle(number, color=RED)\n",
        "                for number in group\n",
        "            ])\n",
        "            self.play(LaggedStartMap(ShowCreation, rects, run_time=1))\n",
        "            self.play(\n",
        "                LaggedStart(*[\n",
        "                    ApplyMethod(number.set_opacity, 0.2)\n",
        "                    for number in group\n",
        "                ]),\n",
        "                LaggedStartMap(FadeOut, rects),\n",
        "                run_time=1\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Rearrange words\n",
        "        dsf = words[1:3]\n",
        "        dsf.generate_target()\n",
        "        dsf.target.arrange(RIGHT)\n",
        "        dsf.target[0].align_to(dsf.target[1][0], DOWN)\n",
        "\n",
        "        example = numbers[35].copy()\n",
        "        example.generate_target()\n",
        "        example.target.match_height(ff)\n",
        "        num_pair = VGroup(\n",
        "            ff.target,\n",
        "            OldTexText(\"and\").scale(1.5),\n",
        "            example.target,\n",
        "        )\n",
        "        num_pair.arrange(RIGHT)\n",
        "        num_pair.move_to(words.get_top(), DOWN)\n",
        "        dsf.target.next_to(num_pair, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        phrase1 = OldTexText(\"are \", \"``relatively prime''\")\n",
        "        phrase2 = OldTexText(\"are \", \"``coprime''\")\n",
        "        for phrase in phrase1, phrase2:\n",
        "            phrase.scale(1.5)\n",
        "            phrase.move_to(dsf.target)\n",
        "            phrase[1].set_color(BLUE)\n",
        "            phrase.arrow = OldTex(\"\\\\Updownarrow\")\n",
        "            phrase.arrow.scale(1.5)\n",
        "            phrase.arrow.next_to(phrase, DOWN, 2 * SMALL_BUFF)\n",
        "            phrase.rect = SurroundingRectangle(phrase[1])\n",
        "            phrase.rect.set_stroke(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(words[0]),\n",
        "            FadeOut(words[3]),\n",
        "            MoveToTarget(dsf),\n",
        "            MoveToTarget(ff),\n",
        "            GrowFromCenter(num_pair[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(example, path_arc=30 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dsf.next_to, phrase1.arrow, DOWN, SMALL_BUFF,\n",
        "            GrowFromEdge(phrase1.arrow, UP),\n",
        "            GrowFromCenter(phrase1),\n",
        "            ShowCreation(phrase1.rect)\n",
        "        )\n",
        "        self.play(FadeOut(phrase1.rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(dsf, phrase1, phrase1.arrow).next_to,\n",
        "            phrase2.arrow, DOWN, SMALL_BUFF,\n",
        "            GrowFromEdge(phrase2.arrow, UP),\n",
        "            GrowFromCenter(phrase2),\n",
        "            ShowCreation(phrase2.rect)\n",
        "        )\n",
        "        self.play(FadeOut(phrase2.rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Count through coprimes\n",
        "        coprime_rects = VGroup(*map(SurroundingRectangle, coprimes))\n",
        "        coprime_rects.set_stroke(BLUE, 2)\n",
        "        example_anim = UpdateFromFunc(\n",
        "            example, lambda m: m.set_value(coprimes[len(coprime_rects) - 1].get_value())\n",
        "        )\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coprime_rects, int_func=np.ceil),\n",
        "            example_anim,\n",
        "            run_time=3,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show totient function\n",
        "        words_to_keep = VGroup(ff, num_pair[1], example, phrase2)\n",
        "        to_fade = VGroup(phrase2.arrow, phrase1, phrase1.arrow, dsf)\n",
        "\n",
        "        totient = OldTex(\"\\\\phi\", \"(\", \"44\", \")\", \"=\", \"20\")\n",
        "        totient.set_color_by_tex(\"44\", YELLOW)\n",
        "        totient.scale(1.5)\n",
        "        totient.move_to(num_pair, UP)\n",
        "        phi = totient.get_part_by_tex(\"phi\")\n",
        "        rhs = Integer(20)\n",
        "        rhs.replace(totient[-1], dim_to_match=1)\n",
        "        totient.submobjects[-1] = rhs\n",
        "\n",
        "        self.play(\n",
        "            words_to_keep.to_edge, DOWN,\n",
        "            MaintainPositionRelativeTo(to_fade, words_to_keep),\n",
        "            VFadeOut(to_fade),\n",
        "        )\n",
        "        self.play(FadeIn(totient))\n",
        "        self.wait()\n",
        "\n",
        "        # Label totient\n",
        "        brace = Brace(phi, DOWN)\n",
        "        etf = OldTexText(\"Euler's totient function\")\n",
        "        etf.next_to(brace, DOWN)\n",
        "        etf.shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(etf, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coprime_rects),\n",
        "            UpdateFromFunc(\n",
        "                rhs, lambda m: m.set_value(len(coprime_rects)),\n",
        "            ),\n",
        "            example_anim,\n",
        "            rate_func=linear,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show totatives\n",
        "        totient_group = VGroup(totient, brace, etf)\n",
        "        for cp, rect in zip(coprimes, coprime_rects):\n",
        "            cp.add(rect)\n",
        "\n",
        "        self.play(\n",
        "            coprimes.arrange, RIGHT, {\"buff\": SMALL_BUFF},\n",
        "            coprimes.set_width, FRAME_WIDTH - 1,\n",
        "            coprimes.move_to, 2 * UP,\n",
        "            FadeOut(evens),\n",
        "            FadeOut(div11[1::2]),\n",
        "            FadeOutAndShiftDown(words_to_keep),\n",
        "            totient_group.center,\n",
        "            totient_group.to_edge, DOWN,\n",
        "        )\n",
        "\n",
        "        totatives = OldTexText(\"``Totatives''\")\n",
        "        totatives.scale(2)\n",
        "        totatives.set_color(BLUE)\n",
        "        totatives.move_to(ORIGIN)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(totatives.get_top(), coprime.get_bottom())\n",
        "            for coprime in coprimes\n",
        "        ])\n",
        "        arrows.set_color(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(totatives),\n",
        "            LaggedStartMap(VFadeInThenOut, arrows, run_time=4, lag_ratio=0.05)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class TwoUnrelatedFacts(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_columns()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Two (unrelated) bits of number theory\")\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line()\n",
        "        h_line.match_width(title)\n",
        "        h_line.next_to(title, DOWN, SMALL_BUFF)\n",
        "        h_line.set_stroke(GREY_B)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(title),\n",
        "            ShowCreation(h_line),\n",
        "        )\n",
        "\n",
        "        self.h_line = h_line\n",
        "\n",
        "    def show_columns(self):\n",
        "        h_line = self.h_line\n",
        "        v_line = Line(\n",
        "            h_line.get_center() + MED_SMALL_BUFF * DOWN,\n",
        "            FRAME_HEIGHT * DOWN / 2,\n",
        "        )\n",
        "        v_line.match_style(h_line)\n",
        "\n",
        "        approx = OldTex(\n",
        "            \"{44 \\\\over 7} \\\\approx 2\\\\pi\"\n",
        "        )\n",
        "        approx.scale(1.5)\n",
        "        approx.next_to(\n",
        "            h_line.point_from_proportion(0.25),\n",
        "            DOWN, MED_LARGE_BUFF,\n",
        "        )\n",
        "\n",
        "        mod = 44\n",
        "        n_terms = 9\n",
        "        residue_classes = VGroup()\n",
        "        prime_numbers = read_in_primes(1000)\n",
        "        primes = VGroup()\n",
        "        non_primes = VGroup()\n",
        "        for r in range(mod):\n",
        "            if r <= 11 or r == 43:\n",
        "                row = VGroup()\n",
        "                for n in range(r, r + n_terms * mod, mod):\n",
        "                    elem = Integer(n)\n",
        "                    comma = OldTex(\",\")\n",
        "                    comma.next_to(\n",
        "                        elem.get_corner(DR),\n",
        "                        RIGHT, SMALL_BUFF\n",
        "                    )\n",
        "                    elem.add(comma)\n",
        "                    row.add(elem)\n",
        "                    if n in prime_numbers:\n",
        "                        primes.add(elem)\n",
        "                    else:\n",
        "                        non_primes.add(elem)\n",
        "                row.arrange(RIGHT, buff=0.3)\n",
        "                dots = OldTex(\"\\\\dots\")\n",
        "                dots.next_to(row.get_corner(DR), RIGHT, SMALL_BUFF)\n",
        "                dots.shift(SMALL_BUFF * UP)\n",
        "                row.add(dots)\n",
        "                row.r = r\n",
        "            if r == 12:\n",
        "                row = OldTex(\"\\\\vdots\")\n",
        "            residue_classes.add(row)\n",
        "\n",
        "        residue_classes.arrange(DOWN)\n",
        "        residue_classes[-2].align_to(residue_classes, LEFT)\n",
        "        residue_classes[-2].shift(MED_SMALL_BUFF * RIGHT)\n",
        "        residue_classes.set_height(6)\n",
        "        residue_classes.next_to(ORIGIN, RIGHT)\n",
        "        residue_classes.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        def get_line(row):\n",
        "            return Line(\n",
        "                row.get_left(), row.get_right(),\n",
        "                stroke_color=RED,\n",
        "                stroke_width=4,\n",
        "            )\n",
        "\n",
        "        even_lines = VGroup(*[\n",
        "            get_line(row)\n",
        "            for row in residue_classes[:12:2]\n",
        "        ])\n",
        "        eleven_line = get_line(residue_classes[11])\n",
        "        eleven_line.set_color(PINK)\n",
        "        for line in [even_lines[1], eleven_line]:\n",
        "            line.scale(0.93, about_edge=RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(approx, DOWN))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(residue_classes))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, even_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(eleven_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            primes.set_color, TEAL,\n",
        "            non_primes.set_opacity, 0.25,\n",
        "            even_lines.set_opacity, 0.25,\n",
        "            eleven_line.set_opacity, 0.25,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExplainRays(Explain44Spirals):\n",
        "    CONFIG = {\n",
        "        \"max_N\": int(5e5),\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -1000,\n",
        "            \"x_max\": 1000,\n",
        "            \"y_min\": -1000,\n",
        "            \"y_max\": 1000,\n",
        "            \"axis_config\": {\n",
        "                \"tick_frequency\": 50,\n",
        "            },\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_spirals_and_labels()\n",
        "        self.show_710th_point()\n",
        "        self.show_arithmetic()\n",
        "        self.zoom_and_count()\n",
        "\n",
        "    def show_710th_point(self):\n",
        "        spiral = self.spiral\n",
        "        axes = self.axes\n",
        "        labels = self.labels\n",
        "\n",
        "        scale_factor = 12\n",
        "\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        fade_rect.scale(scale_factor)\n",
        "\n",
        "        new_ns = list(range(711))\n",
        "        bright_boxes = self.get_v_spiral(new_ns)\n",
        "        bright_boxes.set_color(YELLOW)\n",
        "        for n, box in enumerate(bright_boxes):\n",
        "            box.set_height(0.02 * np.sqrt(n))\n",
        "\n",
        "        big_labels = self.get_labels(new_ns)\n",
        "\n",
        "        index_tracker = ValueTracker(44)\n",
        "\n",
        "        labeled_box = VGroup(Square(), Integer(0))\n",
        "\n",
        "        def update_labeled_box(mob):\n",
        "            index = int(index_tracker.get_value())\n",
        "            labeled_box[0].become(bright_boxes[index])\n",
        "            labeled_box[1].become(big_labels[index])\n",
        "\n",
        "        labeled_box.add_updater(update_labeled_box)\n",
        "\n",
        "        self.set_scale(\n",
        "            scale=120,\n",
        "            spiral=spiral,\n",
        "            to_shrink=labels,\n",
        "        )\n",
        "\n",
        "        box_710 = self.get_v_spiral([710])[0]\n",
        "        box_710.scale(2)\n",
        "        box_710.set_color(YELLOW)\n",
        "        label_710 = Integer(710)\n",
        "        label_710.scale(1.5)\n",
        "        label_710.next_to(box_710, UP)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            ORIGIN, DOWN,\n",
        "            stroke_width=6,\n",
        "            max_tip_length_to_length_ratio=0.35,\n",
        "            max_stroke_width_to_length_ratio=10,\n",
        "            tip_length=0.35\n",
        "        )\n",
        "        arrow.match_color(box_710)\n",
        "        arrow.next_to(box_710, UP, SMALL_BUFF)\n",
        "        label_710.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(spiral, fade_rect, axes, labels)\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            FadeOut(labels),\n",
        "            FadeInFromLarge(box_710),\n",
        "            FadeIn(label_710, DOWN),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.fade_rect = fade_rect\n",
        "        self.box_710 = box_710\n",
        "        self.label_710 = label_710\n",
        "        self.arrow = arrow\n",
        "\n",
        "    def show_arithmetic(self):\n",
        "        label_710 = self.label_710\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"710\", \"\\\\text{ radians}\", \"=\",\n",
        "            \"(710 / 2\\\\pi)\", \"\\\\text{ rotations}\",\n",
        "        )\n",
        "        equation.to_corner(UL)\n",
        "        frac = equation.get_part_by_tex(\"710 / 2\\\\pi\")\n",
        "        brace = Brace(frac, DOWN, buff=SMALL_BUFF)\n",
        "        value = OldTexText(\"{:.15}\".format(710 / TAU))\n",
        "        value.next_to(brace, DOWN, SMALL_BUFF)\n",
        "        values = VGroup(*[\n",
        "            value[0][:n].deepcopy().next_to(brace, DOWN, SMALL_BUFF)\n",
        "            for n in [3, *range(5, 13)]\n",
        "        ])\n",
        "\n",
        "        group = VGroup(equation, brace, value)\n",
        "        rect = SurroundingRectangle(group, buff=MED_SMALL_BUFF)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        rect.set_fill(GREY_D, 1)\n",
        "\n",
        "        approx = OldTex(\n",
        "            \"{710\", \"\\\\over\", \"113}\",\n",
        "            \"\\\\approx\", \"2\\\\pi\",\n",
        "        )\n",
        "        approx.next_to(rect, DOWN)\n",
        "        approx.align_to(equation, LEFT)\n",
        "\n",
        "        approx2 = OldTex(\n",
        "            \"{355\", \"\\\\over\", \"113}\",\n",
        "            \"\\\\approx\", \"\\\\pi\",\n",
        "        )\n",
        "        approx2.next_to(approx, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            TransformFromCopy(label_710, equation[0]),\n",
        "            FadeIn(equation[1:3]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(equation[3:], LEFT)\n",
        "        )\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(\n",
        "            ShowSubmobjectsOneByOne(values),\n",
        "            run_time=3,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.stretch, 2, 1, {\"about_edge\": UP},\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(  # 710\n",
        "                    equation[3][1:4],\n",
        "                    approx[0],\n",
        "                ),\n",
        "                FadeIn(approx[1][0]),\n",
        "                TransformFromCopy(  # 113\n",
        "                    values[-1][:3],\n",
        "                    approx[2],\n",
        "                ),\n",
        "                FadeIn(approx[3]),\n",
        "                TransformFromCopy(  # 2pi\n",
        "                    equation[3][5:7],\n",
        "                    approx[4],\n",
        "                ),\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(approx, approx2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(\n",
        "                rect, equation, brace, values[-1],\n",
        "                approx, approx2\n",
        "            )),\n",
        "            self.fade_rect.set_opacity, 0.25,\n",
        "        )\n",
        "\n",
        "    def zoom_and_count(self):\n",
        "        label = self.label_710\n",
        "        arrow = self.arrow\n",
        "        box = self.box_710\n",
        "        axes = self.axes\n",
        "        spiral = self.spiral\n",
        "\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        times.next_to(label, LEFT, SMALL_BUFF)\n",
        "        k_label = Integer(1)\n",
        "        k_label.match_height(label)\n",
        "        k_label.set_color(YELLOW)\n",
        "        k_label.next_to(times, LEFT)\n",
        "\n",
        "        boxes = VGroup(*[box.copy() for x in range(150)])\n",
        "        box_height_tracker = ValueTracker(box.get_height())\n",
        "\n",
        "        def get_k():\n",
        "            max_x = axes.x_axis.p2n(label.get_center())\n",
        "            return max(1, int(max_x / 710))\n",
        "\n",
        "        def get_k_point(k):\n",
        "            return self.get_polar_point(710 * k, 710 * k)\n",
        "\n",
        "        def update_arrow(arrow):\n",
        "            point = get_k_point(get_k())\n",
        "            arrow.put_start_and_end_on(\n",
        "                label.get_bottom() + SMALL_BUFF * DOWN,\n",
        "                point + SMALL_BUFF * UP\n",
        "            )\n",
        "\n",
        "        def get_unit():\n",
        "            return get_norm(axes.c2p(1, 0) - axes.c2p(0, 0))\n",
        "\n",
        "        def update_boxes(boxes):\n",
        "            box_height = box_height_tracker.get_value()\n",
        "            for k, box in enumerate(boxes):\n",
        "                box.set_height(box_height)\n",
        "                box.move_to(get_k_point(k))\n",
        "\n",
        "        arrow.add_updater(update_arrow)\n",
        "        boxes.add_updater(update_boxes)\n",
        "        k_label.add_updater(\n",
        "            lambda d: d.set_value(get_k()).next_to(\n",
        "                times, LEFT, SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.remove(box)\n",
        "        self.add(times, k_label, boxes)\n",
        "        self.set_scale(\n",
        "            scale=10000,\n",
        "            spiral=self.spiral,\n",
        "            run_time=8,\n",
        "            target_p_spiral_width=2,\n",
        "            added_anims=[\n",
        "                box_height_tracker.set_value, 0.035,\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show other residue classes\n",
        "        new_label = OldTex(\n",
        "            \"710\", \"k\", \"+\",\n",
        "            tex_to_color_map={\"k\": YELLOW}\n",
        "        )\n",
        "        new_label.match_height(label)\n",
        "        new_label.next_to(boxes, UP, SMALL_BUFF)\n",
        "        new_label.to_edge(RIGHT)\n",
        "        new_label[2].set_opacity(0)\n",
        "\n",
        "        r_label = Integer(1)\n",
        "        r_label.match_height(new_label)\n",
        "        r_label.set_opacity(0)\n",
        "        r_label.add_updater(\n",
        "            lambda m: m.next_to(new_label, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        k_label.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(times),\n",
        "            ReplacementTransform(label, new_label[0]),\n",
        "            ReplacementTransform(k_label, new_label[1]),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "\n",
        "        boxes.clear_updaters()\n",
        "        for r in range(1, 12):\n",
        "            if r in [3, 6]:\n",
        "                vect = UR\n",
        "            else:\n",
        "                vect = RIGHT\n",
        "            point = rotate_vector(boxes[40].get_center(), 1)\n",
        "            new_boxes = boxes.copy()\n",
        "            new_boxes.rotate(1, about_point=ORIGIN)\n",
        "            for box in new_boxes:\n",
        "                box.rotate(-1)\n",
        "            self.play(\n",
        "                FadeOut(boxes),\n",
        "                LaggedStartMap(FadeIn, new_boxes, lag_ratio=0.01),\n",
        "                new_label.set_opacity, 1,\n",
        "                new_label.next_to, point, vect,\n",
        "                r_label.set_opacity, 1,\n",
        "                ChangeDecimalToValue(r_label, r),\n",
        "                run_time=1,\n",
        "            )\n",
        "            self.remove(boxes)\n",
        "            boxes = new_boxes\n",
        "            self.add(boxes)\n",
        "            self.wait()\n",
        "\n",
        "        # Show just the primes\n",
        "        self.play(\n",
        "            FadeOut(boxes),\n",
        "            FadeOut(new_label),\n",
        "            FadeOut(r_label),\n",
        "            FadeOut(self.fade_rect)\n",
        "        )\n",
        "        self.set_scale(\n",
        "            30000,\n",
        "            spiral=spiral,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(spiral)\n",
        "        self.add(spiral[1])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CompareTauToApprox(Scene):\n",
        "    def construct(self):\n",
        "        eqs = VGroup(\n",
        "            OldTex(\"2\\\\pi\", \"=\", \"{:.10}\\\\dots\".format(TAU)),\n",
        "            OldTex(\"\\\\frac{710}{113}\", \"=\", \"{:.10}\\\\dots\".format(710 / 113)),\n",
        "        )\n",
        "        eqs.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        eqs[1].shift((eqs[0][2].get_left()[0] - eqs[1][2].get_left()[0]) * RIGHT)\n",
        "\n",
        "        eqs.generate_target()\n",
        "        for eq in eqs.target:\n",
        "            eq[2][:8].set_color(RED)\n",
        "            eq.set_stroke(BLACK, 8, background=True)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(eqs[0], DOWN),\n",
        "            FadeIn(eqs[1], UP),\n",
        "        ))\n",
        "        self.play(MoveToTarget(eqs))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RecommendedMathologerVideo(Scene):\n",
        "    def construct(self):\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "        full_rect.set_fill(GREY_D, 1)\n",
        "        self.add(full_rect)\n",
        "\n",
        "        title = OldTexText(\"Recommended Mathologer video\")\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "        title.to_edge(UP)\n",
        "        screen_rect = SurroundingRectangle(ScreenRectangle(height=5.9), buff=SMALL_BUFF)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        screen_rect.set_stroke(WHITE, 3)\n",
        "\n",
        "        self.add(screen_rect)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowClassesOfPrimeRays(SpiralScene):\n",
        "    CONFIG = {\n",
        "        \"max_N\": int(1e6),\n",
        "        \"scale\": 1e5\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_rays()\n",
        "        self.show_classes()\n",
        "\n",
        "    def setup_rays(self):\n",
        "        spiral = self.get_prime_p_spiral(self.max_N)\n",
        "        self.add(spiral)\n",
        "        self.set_scale(\n",
        "            scale=self.scale,\n",
        "            spiral=spiral,\n",
        "            target_p_spiral_width=3,\n",
        "            run_time=0\n",
        "        )\n",
        "\n",
        "    def show_classes(self):\n",
        "        max_N = self.max_N\n",
        "        mod = 710\n",
        "        primes = read_in_primes(max_N)\n",
        "\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_opacity(0)\n",
        "        self.add(rect)\n",
        "\n",
        "        last_ray = PMobject()\n",
        "        last_label = VGroup(*[VectorizedPoint() for x in range(3)])\n",
        "        for i in range(40):\n",
        "            if get_gcd(i, mod) != 1:\n",
        "                continue\n",
        "\n",
        "            r = (INV_113_MOD_710 * i) % mod\n",
        "\n",
        "            sequence = filter(\n",
        "                lambda x: x in primes,\n",
        "                range(r, max_N, mod)\n",
        "            )\n",
        "            ray = self.get_v_spiral(sequence, box_width=0.03)\n",
        "            ray.set_color(GREEN)\n",
        "            ray.set_opacity(0.9)\n",
        "\n",
        "            label = VGroup(\n",
        "                *Tex(\"710k\", \"+\"),\n",
        "                Integer(r)\n",
        "            )\n",
        "            label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            label.next_to(ray[100], UL, SMALL_BUFF)\n",
        "\n",
        "            label[2].save_state()\n",
        "            label[2].set_opacity(0)\n",
        "            label[2].move_to(last_label, RIGHT)\n",
        "\n",
        "            self.play(\n",
        "                rect.set_opacity, 0.5,\n",
        "                ShowCreation(ray),\n",
        "                LaggedStartMap(FadeOut, last_ray),\n",
        "                ReplacementTransform(last_label[:2], label[:2]),\n",
        "                Restore(label[2]),\n",
        "                last_label[2].move_to, label[2].saved_state,\n",
        "                last_label[2].set_opacity, 0,\n",
        "            )\n",
        "            self.remove(last_label)\n",
        "            self.add(label)\n",
        "            self.wait()\n",
        "\n",
        "            last_ray = ray\n",
        "            last_label = label\n",
        "\n",
        "\n",
        "class ShowFactorsOf710(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"710\", \"=\",\n",
        "            \"71\", \"\\\\cdot\",\n",
        "            \"5\", \"\\\\cdot\",\n",
        "            \"2\",\n",
        "        )\n",
        "        equation.scale(1.5)\n",
        "        equation.to_corner(UL)\n",
        "        ten = OldTex(\"10\")\n",
        "        ten.match_height(equation)\n",
        "        ten.move_to(equation.get_part_by_tex(\"5\"), LEFT)\n",
        "\n",
        "        self.add(equation[0])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                equation[0][:2],\n",
        "                equation[2],\n",
        "            ),\n",
        "            FadeIn(equation[1]),\n",
        "            FadeIn(equation[3]),\n",
        "            TransformFromCopy(\n",
        "                equation[0][2:],\n",
        "                ten,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(ten)\n",
        "        self.play(*[\n",
        "            TransformFromCopy(ten, mob)\n",
        "            for mob in equation[4:]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        # Circle factors\n",
        "        colors = [RED, BLUE, PINK]\n",
        "        for factor, color in zip(equation[:-6:-2], colors):\n",
        "            rect = SurroundingRectangle(factor)\n",
        "            rect.set_color(color)\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class LookAtRemainderMod710(Scene):\n",
        "    def construct(self):\n",
        "        t2c = {\n",
        "            \"n\": YELLOW,\n",
        "            \"r\": GREEN\n",
        "        }\n",
        "        equation = OldTex(\n",
        "            \"n\", \"=\", \"710\", \"k\", \"+\", \"r\",\n",
        "            tex_to_color_map=t2c,\n",
        "        )\n",
        "        equation.scale(1.5)\n",
        "\n",
        "        n_arrow = Vector(UP).next_to(equation.get_part_by_tex(\"n\"), DOWN)\n",
        "        r_arrow = Vector(UP).next_to(equation.get_part_by_tex(\"r\"), DOWN)\n",
        "        n_arrow.set_color(t2c[\"n\"])\n",
        "        r_arrow.set_color(t2c[\"r\"])\n",
        "\n",
        "        n_label = OldTexText(\"Some\\\\\\\\number\")\n",
        "        r_label = OldTexText(\"Remainder\")\n",
        "        VGroup(n_label, r_label).scale(1.5)\n",
        "        n_label.next_to(n_arrow, DOWN)\n",
        "        n_label.match_color(n_arrow)\n",
        "        r_label.next_to(r_arrow, DOWN)\n",
        "        r_label.match_color(r_arrow)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            FadeIn(n_label, UP),\n",
        "            ShowCreation(n_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(r_label, DOWN),\n",
        "            ShowCreation(r_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EliminateNonPrimative710Residues(ShowClassesOfPrimeRays):\n",
        "    CONFIG = {\n",
        "        \"max_N\": int(5e5),\n",
        "        \"scale\": 5e4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_rays()\n",
        "        self.eliminate_classes()\n",
        "\n",
        "    def setup_rays(self):\n",
        "        mod = 710\n",
        "        rays = PGroup(*[\n",
        "            self.get_p_spiral(range(r, self.max_N, mod))\n",
        "            for r in range(mod)\n",
        "        ])\n",
        "        rays.set_color(YELLOW)\n",
        "        self.add(rays)\n",
        "        self.set_scale(\n",
        "            scale=self.scale,\n",
        "            spiral=rays,\n",
        "            target_p_spiral_width=1,\n",
        "            run_time=0,\n",
        "        )\n",
        "\n",
        "        self.rays = rays\n",
        "\n",
        "    def eliminate_classes(self):\n",
        "        rays = self.rays\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_opacity(0)\n",
        "\n",
        "        for r, ray in enumerate(rays):\n",
        "            ray.r = r\n",
        "\n",
        "        mod = 710\n",
        "        odds = PGroup(*[rays[i] for i in range(1, mod, 2)])\n",
        "        mult5 = PGroup(*[rays[i] for i in range(0, mod, 5) if i % 2 != 0])\n",
        "        mult71 = PGroup(*[rays[i] for i in range(0, mod, 71) if (i % 2 != 0 and i % 5 != 0)])\n",
        "        colors = [RED, BLUE, PINK]\n",
        "\n",
        "        pre_label, r_label = label = VGroup(\n",
        "            OldTex(\"710k + \"),\n",
        "            Integer(100)\n",
        "        )\n",
        "        label.scale(1.5)\n",
        "        label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        label.set_stroke(BLACK, 5, background=True, family=True)\n",
        "        label.next_to(ORIGIN, DOWN)\n",
        "\n",
        "        r_label.group = odds\n",
        "        r_label.add_updater(\n",
        "            lambda m: m.set_value(m.group[-1].r if len(m.group) > 0 else 1),\n",
        "        )\n",
        "\n",
        "        self.remove(rays)\n",
        "        # Odds\n",
        "        odds.set_stroke_width(3)\n",
        "        self.add(odds, label)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(odds, int_func=np.ceil),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(FadeOut(label))\n",
        "        self.remove(odds)\n",
        "        self.add(*odds)\n",
        "        self.wait()\n",
        "\n",
        "        # Multiples of 5 then 71\n",
        "        for i, group in [(1, mult5), (2, mult71)]:\n",
        "            group_copy = group.copy()\n",
        "            group_copy.set_color(colors[i])\n",
        "            group_copy.set_stroke_width(4)\n",
        "            r_label.group = group_copy\n",
        "            self.add(group_copy, label)\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(group_copy, int_func=np.ceil, run_time=10),\n",
        "            )\n",
        "            self.play(FadeOut(label))\n",
        "            self.wait()\n",
        "            self.remove(group_copy, *group)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class Show280Computation(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"\\\\phi(710) = \",\n",
        "            \"710\",\n",
        "            \"\\\\left({1 \\\\over 2}\\\\right)\",\n",
        "            \"\\\\left({4 \\\\over 5}\\\\right)\",\n",
        "            \"\\\\left({70 \\\\over 71}\\\\right)\",\n",
        "            \"=\",\n",
        "            \"280\",\n",
        "        )\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.move_to(UP)\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Filter out\\\\\\\\evens\"),\n",
        "            OldTexText(\"Filter out\\\\\\\\multiples of 5\"),\n",
        "            OldTexText(\"Filter out\\\\\\\\multiples of 71\"),\n",
        "        )\n",
        "        vects = [DOWN, UP, DOWN]\n",
        "        colors = [RED, BLUE, LIGHT_PINK]\n",
        "        for part, word, vect, color in zip(equation[2:5], words, vects, colors):\n",
        "            brace = Brace(part, vect)\n",
        "            brace.stretch(0.8, 0)\n",
        "            word.brace = brace\n",
        "            word.next_to(brace, vect)\n",
        "            part.set_color(color)\n",
        "            word.set_color(color)\n",
        "            word.set_stroke(BLACK, 5, background=True)\n",
        "        equation.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        etf_label = OldTexText(\"Euler's totient function\")\n",
        "        etf_label.to_corner(UL)\n",
        "        arrow = Arrow(etf_label.get_bottom(), equation[0][0].get_top())\n",
        "        equation[0][0].set_color(YELLOW)\n",
        "        etf_label.set_color(YELLOW)\n",
        "\n",
        "        rect = FullScreenFadeRectangle(fill_opacity=0.9)\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeInFromDown(equation),\n",
        "            FadeIn(etf_label),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        for word in words:\n",
        "            self.play(\n",
        "                FadeIn(word),\n",
        "                GrowFromCenter(word.brace),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class TeacherHoldUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\", look_at=2 * UP,\n",
        "            added_anims=[\n",
        "                self.teacher.change, \"raise_right_hand\"\n",
        "            ]\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class DiscussPrimesMod10(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(str(n), \" mod 10:\")\n",
        "            for n in range(10)\n",
        "        ])\n",
        "        labels.arrange(DOWN, buff=0.35, aligned_edge=LEFT)\n",
        "        labels.to_edge(LEFT)\n",
        "        # digits = VGroup(*[l[0] for l in labels])\n",
        "        labels.set_submobject_colors_by_gradient(YELLOW, BLUE)\n",
        "\n",
        "        sequences = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Integer(n).shift((n // 10) * RIGHT)\n",
        "                for n in range(r, 100 + r, 10)\n",
        "            ])\n",
        "            for r in range(10)\n",
        "        ])\n",
        "        for sequence, label in zip(sequences, labels):\n",
        "            sequence.next_to(label, RIGHT, buff=MED_LARGE_BUFF)\n",
        "            for item in sequence:\n",
        "                if item is sequence[-1]:\n",
        "                    punc = OldTex(\"\\\\dots\")\n",
        "                else:\n",
        "                    punc = OldTexText(\",\")\n",
        "                punc.next_to(item.get_corner(DR), RIGHT, SMALL_BUFF)\n",
        "                item.add(punc)\n",
        "\n",
        "        # Introduce everything\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeIn(label, UP)\n",
        "            for label in labels\n",
        "        ]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                LaggedStart(*[\n",
        "                    FadeIn(item, LEFT)\n",
        "                    for item in sequence\n",
        "                ])\n",
        "                for sequence in sequences\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight 0's then 1's\n",
        "        for sequence in sequences[:2]:\n",
        "            lds = VGroup(*[item[-2] for item in sequence])\n",
        "            rects = VGroup(*[\n",
        "                SurroundingRectangle(ld, buff=0.05)\n",
        "                for ld in lds\n",
        "            ])\n",
        "            rects.set_color(YELLOW)\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    ShowCreationThenFadeOut, rects\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Eliminate certain residues\n",
        "        two = sequences[2][0]\n",
        "        five = sequences[5][0]\n",
        "        evens = VGroup(*it.chain(*sequences[::2]))\n",
        "        evens.remove(two)\n",
        "        div5 = sequences[5][1:]\n",
        "        prime_numbers = read_in_primes(100)\n",
        "\n",
        "        primes = VGroup(*[\n",
        "            item\n",
        "            for seq in sequences\n",
        "            for item in seq\n",
        "            if int(item.get_value()) in prime_numbers\n",
        "        ])\n",
        "        non_primes = VGroup(*[\n",
        "            item\n",
        "            for seq in sequences\n",
        "            for item in seq\n",
        "            if reduce(op.and_, [\n",
        "                int(item.get_value()) not in prime_numbers,\n",
        "                item.get_value() % 2 != 0,\n",
        "                item.get_value() % 5 != 0,\n",
        "            ])\n",
        "        ])\n",
        "\n",
        "        for prime, group in [(two, evens), (five, div5)]:\n",
        "            self.play(ShowCreationThenFadeAround(prime))\n",
        "            self.play(LaggedStart(*[\n",
        "                ApplyMethod(item.set_opacity, 0.2)\n",
        "                for item in group\n",
        "            ]))\n",
        "            self.wait()\n",
        "\n",
        "        # Highlight primes\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyFunction(\n",
        "                    lambda m: m.scale(1.2).set_color(TEAL),\n",
        "                    prime\n",
        "                )\n",
        "                for prime in primes\n",
        "            ]),\n",
        "            LaggedStart(*[\n",
        "                ApplyFunction(\n",
        "                    lambda m: m.scale(0.8).set_opacity(0.8),\n",
        "                    non_prime\n",
        "                )\n",
        "                for non_prime in non_primes\n",
        "            ]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight coprime residue classes\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(VGroup(labels[r], sequences[r]))\n",
        "            for r in [1, 3, 7, 9]\n",
        "        ])\n",
        "        for rect in rects:\n",
        "            rect.reverse_points()\n",
        "\n",
        "        fade_rect = FullScreenFadeRectangle()\n",
        "        fade_rect.scale(1.1)\n",
        "        new_fade_rect = fade_rect.copy()\n",
        "        fade_rect.append_vectorized_mobject(rects[0])\n",
        "        for rect in rects:\n",
        "            new_fade_rect.append_vectorized_mobject(rect)\n",
        "\n",
        "        self.play(DrawBorderThenFill(fade_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(fade_rect),\n",
        "            FadeIn(new_fade_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BucketPrimesByLastDigit(Scene):\n",
        "    CONFIG = {\n",
        "        \"bar_colors\": [YELLOW, BLUE],\n",
        "        \"mod\": 10,\n",
        "        \"max_n\": 10000,\n",
        "        \"n_to_animate\": 20,\n",
        "        \"n_to_show\": 1000,\n",
        "        \"x_label_scale_factor\": 1,\n",
        "        \"x_axis_label\": \"Last digit\",\n",
        "        \"bar_width\": 0.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_bars()\n",
        "        self.bucket_primes()\n",
        "\n",
        "    def add_axes(self):\n",
        "        mod = self.mod\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=mod + 0.5,\n",
        "            x_axis_config={\n",
        "                \"unit_size\": 10 / mod,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            y_min=0,\n",
        "            y_max=100,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.055,\n",
        "                \"tick_frequency\": 12.5,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "        )\n",
        "\n",
        "        x_labels = VGroup()\n",
        "        for x in range(mod):\n",
        "            digit = Integer(x)\n",
        "            digit.scale(self.x_label_scale_factor)\n",
        "            digit.next_to(axes.x_axis.n2p(x + 1), DOWN, MED_SMALL_BUFF)\n",
        "            x_labels.add(digit)\n",
        "        self.modify_x_labels(x_labels)\n",
        "        x_labels.set_submobject_colors_by_gradient(*self.bar_colors)\n",
        "        axes.add(x_labels)\n",
        "        axes.x_labels = x_labels\n",
        "\n",
        "        y_labels = VGroup()\n",
        "        for y in range(25, 125, 25):\n",
        "            label = Integer(y, unit=\"\\\\%\")\n",
        "            label.next_to(axes.y_axis.n2p(y), LEFT, MED_SMALL_BUFF)\n",
        "            y_labels.add(label)\n",
        "        axes.add(y_labels)\n",
        "\n",
        "        x_axis_label = OldTexText(self.x_axis_label)\n",
        "        x_axis_label.next_to(axes.x_axis.get_end(), RIGHT, buff=MED_LARGE_BUFF)\n",
        "        axes.add(x_axis_label)\n",
        "\n",
        "        y_axis_label = OldTexText(\"Proportion\")\n",
        "        y_axis_label.next_to(axes.y_axis.get_end(), UP, buff=MED_LARGE_BUFF)\n",
        "        # y_axis_label.set_color(self.bar_colors[0])\n",
        "        axes.add(y_axis_label)\n",
        "\n",
        "        axes.center()\n",
        "        axes.set_width(FRAME_WIDTH - 1)\n",
        "        axes.to_edge(DOWN)\n",
        "\n",
        "        self.axes = axes\n",
        "        self.add(axes)\n",
        "\n",
        "    def add_bars(self):\n",
        "        axes = self.axes\n",
        "        mod = self.mod\n",
        "\n",
        "        count_trackers = Group(*[\n",
        "            ValueTracker(0)\n",
        "            for x in range(mod)\n",
        "        ])\n",
        "\n",
        "        bars = VGroup()\n",
        "        for x in range(mod):\n",
        "            bar = Rectangle(\n",
        "                height=1,\n",
        "                width=self.bar_width,\n",
        "                fill_opacity=1,\n",
        "            )\n",
        "            bar.bottom = axes.x_axis.n2p(x + 1)\n",
        "            bars.add(bar)\n",
        "        bars.set_submobject_colors_by_gradient(*self.bar_colors)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "\n",
        "        def update_bars(bars):\n",
        "            values = [ct.get_value() for ct in count_trackers]\n",
        "            total = sum(values)\n",
        "            if total == 0:\n",
        "                props = [0 for x in range(mod)]\n",
        "            elif total < 1:\n",
        "                props = values\n",
        "            else:\n",
        "                props = [value / total for value in values]\n",
        "\n",
        "            for bar, prop in zip(bars, props):\n",
        "                bar.set_height(\n",
        "                    max(\n",
        "                        1e-5,\n",
        "                        100 * prop * axes.y_axis.unit_size,\n",
        "                    ),\n",
        "                    stretch=True\n",
        "                )\n",
        "                # bar.set_height(1)\n",
        "                bar.move_to(bar.bottom, DOWN)\n",
        "\n",
        "        bars.add_updater(update_bars)\n",
        "\n",
        "        self.add(count_trackers)\n",
        "        self.add(bars)\n",
        "\n",
        "        self.bars = bars\n",
        "        self.count_trackers = count_trackers\n",
        "\n",
        "    def bucket_primes(self):\n",
        "        bars = self.bars\n",
        "        count_trackers = self.count_trackers\n",
        "\n",
        "        max_n = self.max_n\n",
        "        n_to_animate = self.n_to_animate\n",
        "        n_to_show = self.n_to_show\n",
        "        mod = self.mod\n",
        "\n",
        "        primes = VGroup(*[\n",
        "            Integer(prime).scale(2).to_edge(UP, buff=LARGE_BUFF)\n",
        "            for prime in read_in_primes(max_n)\n",
        "        ])\n",
        "\n",
        "        arrow = Arrow(ORIGIN, DOWN)\n",
        "        x_labels = self.axes.x_labels\n",
        "        rects = VGroup(*map(SurroundingRectangle, x_labels))\n",
        "        rects.set_color(RED)\n",
        "\n",
        "        self.play(FadeIn(primes[0]))\n",
        "        for i, p, np in zip(it.count(), primes[:n_to_show], primes[1:]):\n",
        "            d = int(p.get_value()) % mod\n",
        "            self.add(rects[d])\n",
        "            if i < n_to_animate:\n",
        "                self.play(\n",
        "                    p.scale, 0.5,\n",
        "                    p.move_to, bars[d].get_top(),\n",
        "                    p.set_opacity, 0,\n",
        "                    FadeIn(np),\n",
        "                    count_trackers[d].increment_value, 1,\n",
        "                )\n",
        "                self.remove(p)\n",
        "            else:\n",
        "                arrow.next_to(bars[d], UP)\n",
        "                self.add(arrow)\n",
        "                self.add(p)\n",
        "                count_trackers[d].increment_value(1)\n",
        "                self.wait(0.1)\n",
        "                self.remove(p)\n",
        "            self.remove(rects[d])\n",
        "\n",
        "    #\n",
        "    def modify_x_labels(self, labels):\n",
        "        pass\n",
        "\n",
        "\n",
        "class PhraseDirichletsTheoremFor10(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        expression = OldTex(\n",
        "            \"\\\\lim_{x \\\\to \\\\infty}\",\n",
        "            \"\\\\left(\",\n",
        "            \"{\\\\text{\\\\# of primes $p$ where $p \\\\le x$} \\\\text{ and $p \\\\equiv 1$ mod 10}\",\n",
        "            \"\\\\over\",\n",
        "            \"\\\\text{\\\\# of primes $p$ where $p \\\\le x$}}\",\n",
        "            \"\\\\right)\",\n",
        "            \"=\",\n",
        "            \"\\\\frac{1}{4}\",\n",
        "        )\n",
        "        lim, lp, num, over, denom, rp, eq, fourth = expression\n",
        "        expression.shift(UP)\n",
        "\n",
        "        denom.save_state()\n",
        "        denom.move_to(self.hold_up_spot, DOWN)\n",
        "        denom.shift_onto_screen()\n",
        "\n",
        "        num[len(denom):].set_color(YELLOW)\n",
        "\n",
        "        x_example = VGroup(\n",
        "            OldTexText(\"Think, for example, $x = $\"),\n",
        "            Integer(int(1e6)),\n",
        "        )\n",
        "        x_example.arrange(RIGHT)\n",
        "        x_example.scale(1.5)\n",
        "        x_example.to_edge(UP)\n",
        "\n",
        "        #\n",
        "        teacher = self.teacher\n",
        "        students = self.students\n",
        "        self.play(\n",
        "            FadeInFromDown(denom),\n",
        "            teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*[\"pondering\"] * 3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(x_example))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(denom),\n",
        "            teacher.change, \"thinking\",\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(denom, num[:len(denom)]),\n",
        "            Write(over),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(num[len(denom):]),\n",
        "            students[0].change, \"confused\",\n",
        "            students[2].change, \"erm\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(lp),\n",
        "            Write(rp),\n",
        "            Write(eq),\n",
        "        )\n",
        "        self.play(FadeIn(fourth, LEFT))\n",
        "        self.play(FadeIn(lim, RIGHT))\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(\n",
        "                x_example[1], int(1e7),\n",
        "                run_time=8,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            VFadeOut(x_example, run_time=8),\n",
        "            self.change_students(*[\"thinking\"] * 3),\n",
        "            Blink(\n",
        "                teacher,\n",
        "                run_time=4,\n",
        "                rate_func=squish_rate_func(there_and_back, 0.65, 0.7)\n",
        "            ),\n",
        "        )\n",
        "\n",
        "\n",
        "class InsertNewResidueClasses(Scene):\n",
        "    def construct(self):\n",
        "        nums = VGroup(*map(Integer, [3, 7, 9]))\n",
        "        colors = [GREEN, TEAL, BLUE]\n",
        "        for num, color in zip(nums, colors):\n",
        "            num.set_color(color)\n",
        "            num.add_background_rectangle(buff=SMALL_BUFF, opacity=1)\n",
        "            self.play(FadeIn(num, UP))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class BucketPrimesBy44(BucketPrimesByLastDigit):\n",
        "    CONFIG = {\n",
        "        \"mod\": 44,\n",
        "        \"n_to_animate\": 5,\n",
        "        \"x_label_scale_factor\": 0.5,\n",
        "        \"x_axis_label\": \"r mod 44\",\n",
        "        \"bar_width\": 0.1,\n",
        "    }\n",
        "\n",
        "    def modify_x_labels(self, labels):\n",
        "        labels[::2].set_opacity(0)\n",
        "\n",
        "\n",
        "class BucketPrimesBy9(BucketPrimesByLastDigit):\n",
        "    CONFIG = {\n",
        "        \"mod\": 9,\n",
        "        \"n_to_animate\": 5,\n",
        "        \"x_label_scale_factor\": 1,\n",
        "        \"x_axis_label\": \"r mod 9\",\n",
        "        \"bar_width\": 1,\n",
        "    }\n",
        "\n",
        "    def modify_x_labels(self, labels):\n",
        "        pass\n",
        "\n",
        "\n",
        "class DirichletIn1837(Scene):\n",
        "    def construct(self):\n",
        "        # Add timeline\n",
        "        dates = list(range(1780, 2030, 10))\n",
        "        timeline = NumberLine(\n",
        "            x_min=1700,\n",
        "            x_max=2020,\n",
        "            tick_frequency=1,\n",
        "            big_tick_numbers=dates,\n",
        "            unit_size=0.2,\n",
        "            stroke_color=GREY,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        timeline.add_numbers(\n",
        "            *dates,\n",
        "            group_with_commas=False,\n",
        "        )\n",
        "        timeline.numbers.shift(SMALL_BUFF * DOWN)\n",
        "        timeline.to_edge(RIGHT)\n",
        "\n",
        "        # Special dates\n",
        "        d_arrow, rh_arrow, pnt_arrow = arrows = VGroup(*[\n",
        "            Vector(DOWN).next_to(timeline.n2p(date), UP)\n",
        "            for date in [1837, 1859, 1896]\n",
        "        ])\n",
        "        d_label, rh_label, pnt_label = labels = VGroup(*[\n",
        "            OldTexText(text).next_to(arrow, UP)\n",
        "            for arrow, text in zip(arrows, [\n",
        "                \"Dirichlet's\\\\\\\\theorem\\\\\\\\1837\",\n",
        "                \"Riemann\\\\\\\\hypothesis\\\\\\\\1859\",\n",
        "                \"Prime number\\\\\\\\theorem\\\\\\\\1896\",\n",
        "            ])\n",
        "        ])\n",
        "\n",
        "        # Back in time\n",
        "        frame = self.camera_frame\n",
        "        self.add(timeline, arrows, labels)\n",
        "        self.play(\n",
        "            frame.move_to, timeline.n2p(1837),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show picture\n",
        "        image = ImageMobject(\"Dirichlet\")\n",
        "        image.set_height(3)\n",
        "        image.next_to(d_label, LEFT)\n",
        "        self.play(FadeIn(image, RIGHT))\n",
        "        self.wait()\n",
        "\n",
        "        # Flash\n",
        "        self.play(\n",
        "            Flash(\n",
        "                d_label.get_center(),\n",
        "                num_lines=12,\n",
        "                line_length=0.25,\n",
        "                flash_radius=1.5,\n",
        "                line_stroke_width=3,\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition title\n",
        "        title, underline = self.get_title_and_underline()\n",
        "        n = len(title[0])\n",
        "        self.play(\n",
        "            ReplacementTransform(d_label[0][:n], title[0][:n]),\n",
        "            FadeOut(d_label[0][n:]),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShiftDown, Group(\n",
        "                    image, d_arrow,\n",
        "                    rh_label, rh_arrow,\n",
        "                    pnt_label, pnt_arrow,\n",
        "                    *timeline,\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.wait()\n",
        "\n",
        "    def get_title_and_underline(self):\n",
        "        frame = self.camera_frame\n",
        "        title = OldTexText(\"Dirichlet's theorem\")\n",
        "        title.scale(1.5)\n",
        "        title.next_to(frame.get_top(), DOWN, buff=MED_LARGE_BUFF)\n",
        "        underline = Line()\n",
        "        underline.match_width(title)\n",
        "        underline.next_to(title, DOWN, SMALL_BUFF)\n",
        "        return title, underline\n",
        "\n",
        "\n",
        "class PhraseDirichletsTheorem(DirichletIn1837):\n",
        "    def construct(self):\n",
        "        self.add(*self.get_title_and_underline())\n",
        "\n",
        "        # Copy-pasted, which isn't great\n",
        "        expression = OldTex(\n",
        "            \"\\\\lim_{x \\\\to \\\\infty}\",\n",
        "            \"\\\\left(\",\n",
        "            \"{\\\\text{\\\\# of primes $p$ where $p \\\\le x$} \\\\text{ and $p \\\\equiv 1$ mod 10}\",\n",
        "            \"\\\\over\",\n",
        "            \"\\\\text{\\\\# of primes $p$ where $p \\\\le x$}}\",\n",
        "            \"\\\\right)\",\n",
        "            \"=\",\n",
        "            \"\\\\frac{1}{4}\",\n",
        "        )\n",
        "        lim, lp, num, over, denom, rp, eq, fourth = expression\n",
        "        expression.shift(1.5 * UP)\n",
        "        expression.to_edge(LEFT, MED_SMALL_BUFF)\n",
        "        num[len(denom):].set_color(YELLOW)\n",
        "        #\n",
        "\n",
        "        # Terms and labels\n",
        "        ten = num[-2:]\n",
        "        one = num[-6]\n",
        "        four = fourth[-1]\n",
        "\n",
        "        N = OldTex(\"N\")\n",
        "        r = OldTex(\"r\")\n",
        "        one_over_phi_N = OldTex(\"1\", \"\\\\over\", \"\\\\phi(\", \"N\", \")\")\n",
        "\n",
        "        N.set_color(MAROON_B)\n",
        "        r.set_color(BLUE)\n",
        "        one_over_phi_N.set_color_by_tex(\"N\", N.get_color())\n",
        "\n",
        "        N.move_to(ten, DL)\n",
        "        r.move_to(one, DOWN)\n",
        "        one_over_phi_N.move_to(fourth, LEFT)\n",
        "\n",
        "        N_label = OldTexText(\"$N$\", \" is any number\")\n",
        "        N_label.set_color_by_tex(\"N\", N.get_color())\n",
        "        N_label.next_to(expression, DOWN, LARGE_BUFF)\n",
        "\n",
        "        r_label = OldTexText(\"$r$\", \" is coprime to \", \"$N$\")\n",
        "        r_label[0].set_color(r.get_color())\n",
        "        r_label[2].set_color(N.get_color())\n",
        "        r_label.next_to(N_label, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        phi_N_label = OldTex(\n",
        "            \"\\\\phi({10}) = \",\n",
        "            \"\\\\#\\\\{1, 3, 7, 9\\\\} = 4\",\n",
        "            tex_to_color_map={\n",
        "                \"{10}\": N.get_color(),\n",
        "            }\n",
        "        )\n",
        "        phi_N_label[-1][2:9:2].set_color(r.get_color())\n",
        "        phi_N_label.next_to(r_label, DOWN, MED_LARGE_BUFF)\n",
        "        #\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                FadeIn(denom),\n",
        "                ShowCreation(over),\n",
        "                FadeIn(num),\n",
        "                Write(VGroup(lp, rp)),\n",
        "                FadeIn(lim),\n",
        "                Write(VGroup(eq, fourth)),\n",
        "            ]),\n",
        "            run_time=3,\n",
        "            lag_ratio=0.7,\n",
        "        )\n",
        "        self.wait()\n",
        "        for mob in denom, num:\n",
        "            self.play(ShowCreationThenFadeAround(mob))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeIn(r, DOWN),\n",
        "            FadeOut(one, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(N, DOWN),\n",
        "            FadeOut(ten, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(N, N_label[0]),\n",
        "            FadeIn(N_label[1:], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(r_label[1:-1], DOWN),\n",
        "            TransformFromCopy(r, r_label[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(N_label[0], r_label[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(fourth),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(one_over_phi_N[2:], LEFT),\n",
        "            FadeOut(four, RIGHT),\n",
        "            ReplacementTransform(fourth[0], one_over_phi_N[0][0]),\n",
        "            ReplacementTransform(fourth[1], one_over_phi_N[1][0]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(phi_N_label, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fancier version\n",
        "        new_expression = OldTex(\n",
        "            \"\\\\lim_{x \\\\to \\\\infty}\",\n",
        "            \"\\\\left(\",\n",
        "            \"{\\\\pi(x; {N}, {r})\",\n",
        "            \"\\\\over\",\n",
        "            \"\\\\pi(x)}\",\n",
        "            \"\\\\right)\",\n",
        "            \"=\",\n",
        "            \"\\\\frac{1}{\\\\phi({N})}\",\n",
        "            tex_to_color_map={\n",
        "                \"{N}\": N.get_color(),\n",
        "                \"{r}\": r.get_color(),\n",
        "                \"\\\\pi\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        pis = new_expression.get_parts_by_tex(\"\\\\pi\")\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.next_to(new_expression, LEFT, buff=LARGE_BUFF)\n",
        "        randy.shift(0.75 * DOWN)\n",
        "\n",
        "        new_expression.next_to(expression, DOWN, LARGE_BUFF)\n",
        "        ne_rect = SurroundingRectangle(new_expression, color=BLUE)\n",
        "\n",
        "        label_group = VGroup(N_label, r_label)\n",
        "        label_group.generate_target()\n",
        "        label_group.target.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        label_group.target.next_to(new_expression, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change, \"hooray\", expression\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(new_expression),\n",
        "            MoveToTarget(label_group),\n",
        "            phi_N_label.to_edge, DOWN, MED_LARGE_BUFF,\n",
        "            randy.change, \"horrified\", new_expression,\n",
        "        )\n",
        "        self.play(ShowCreation(ne_rect))\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeAround, pis,\n",
        "            ),\n",
        "            randy.change, \"angry\", new_expression\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MoreModestDirichlet(Scene):\n",
        "    def construct(self):\n",
        "        ed = OldTexText(\n",
        "            \"Each (coprime) residue class \",\n",
        "            \"is equally dense with \",\n",
        "            \"primes.\"\n",
        "        )\n",
        "        inf = OldTexText(\n",
        "            \"Each (coprime) residue class \",\n",
        "            \"has infinitely many \",\n",
        "            \"primes.\"\n",
        "        )\n",
        "        ed[1].set_color(BLUE)\n",
        "        inf[1].set_color(GREEN)\n",
        "\n",
        "        for mob in [*ed, *inf]:\n",
        "            mob.save_state()\n",
        "\n",
        "        cross = Cross(ed[1])\n",
        "        c_group = VGroup(ed[1], cross)\n",
        "\n",
        "        self.add(ed)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(\n",
        "            c_group.shift, DOWN,\n",
        "            c_group.set_opacity, 0.5,\n",
        "            ReplacementTransform(ed[::2], inf[::2]),\n",
        "            FadeIn(inf[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(*inf)\n",
        "        self.play(\n",
        "            inf[1].shift, UP,\n",
        "            Restore(ed[0]),\n",
        "            Restore(ed[1]),\n",
        "            Restore(ed[2]),\n",
        "            FadeOut(cross),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TalkAboutProof(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        teacher = self.teacher\n",
        "        students = self.students\n",
        "\n",
        "        # Ask question\n",
        "        self.student_says(\n",
        "            \"So how'd he\\\\\\\\prove it?\",\n",
        "            index=0,\n",
        "        )\n",
        "        bubble = students[0].bubble\n",
        "        students[0].bubble = None\n",
        "        self.play(\n",
        "            teacher.change, \"hesitant\",\n",
        "            students[1].change, \"happy\",\n",
        "            students[2].change, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"...er...it's a\\\\\\\\bit complicated\",\n",
        "            target_mode=\"guilty\",\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"tired\",\n",
        "            look_at=teacher.bubble,\n",
        "            lag_ratio=0.1,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Bring up complex analysis\n",
        "        ca = OldTexText(\"Complex \", \"Analysis\")\n",
        "        ca.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(ca),\n",
        "            FadeOut(teacher.bubble),\n",
        "            FadeOut(teacher.bubble.content),\n",
        "            self.change_students(*[\"pondering\"] * 3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ca.scale, 2,\n",
        "            ca.center,\n",
        "            ca.to_edge, UP,\n",
        "            teacher.change, \"happy\",\n",
        "        )\n",
        "        self.play(ca[1].set_color, GREEN)\n",
        "        self.wait(2)\n",
        "        self.play(ca[0].set_color, YELLOW)\n",
        "        self.wait(2)\n",
        "        self.play_all_student_changes(\n",
        "            \"confused\", look_at=ca,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class HighlightTwinPrimes(Scene):\n",
        "    def construct(self):\n",
        "        self.add_paper_titles()\n",
        "        self.show_twin_primes()\n",
        "\n",
        "    def add_paper_titles(self):\n",
        "        gpy = OldTexText(\n",
        "            \"Goldston, Pintz, Yildirim\\\\\\\\\",\n",
        "            \"2005\",\n",
        "        )\n",
        "        zhang = OldTexText(\"Zhang\\\\\\\\2014\")\n",
        "\n",
        "        gpy.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "        gpy.to_edge(UP)\n",
        "        zhang.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        zhang.to_edge(UP)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, VGroup(gpy, zhang),\n",
        "            lag_ratio=0.3,\n",
        "        ))\n",
        "\n",
        "    def show_twin_primes(self):\n",
        "        max_x = 300\n",
        "        line = NumberLine(\n",
        "            x_min=0,\n",
        "            x_max=max_x,\n",
        "            unit_size=0.5,\n",
        "            big_tick_numbers=range(10, max_x, 10),\n",
        "        )\n",
        "        line.move_to(2.5 * DOWN + 7 * LEFT, LEFT)\n",
        "        line.add_numbers(*range(10, max_x, 10))\n",
        "\n",
        "        primes = read_in_primes(max_x)\n",
        "        prime_mobs = VGroup(*[\n",
        "            Integer(p).next_to(line.n2p(p), UP)\n",
        "            for p in primes\n",
        "        ])\n",
        "        dots = VGroup(*[Dot(line.n2p(p)) for p in primes])\n",
        "\n",
        "        arcs = VGroup()\n",
        "        for pm, npm in zip(prime_mobs, prime_mobs[1:]):\n",
        "            p = pm.get_value()\n",
        "            np = npm.get_value()\n",
        "            if np - p == 2:\n",
        "                angle = 30 * DEGREES\n",
        "                arc = Arc(\n",
        "                    start_angle=angle,\n",
        "                    angle=PI - 2 * angle,\n",
        "                    color=RED,\n",
        "                )\n",
        "                arc.set_width(\n",
        "                    get_norm(npm.get_center() - pm.get_center())\n",
        "                )\n",
        "                arc.next_to(VGroup(pm, npm), UP, SMALL_BUFF)\n",
        "                arcs.add(arc)\n",
        "\n",
        "        dots.set_color(TEAL)\n",
        "        prime_mobs.set_color(TEAL)\n",
        "\n",
        "        line.add(dots)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(line, lag_ratio=0.9),\n",
        "            LaggedStartMap(FadeInFromDown, prime_mobs),\n",
        "            run_time=2,\n",
        "        )\n",
        "        line.add(prime_mobs)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(arcs))\n",
        "        self.play(\n",
        "            line.shift, 100 * LEFT,\n",
        "            arcs.shift, 100 * LEFT,\n",
        "            run_time=20,\n",
        "            rate_func=lambda t: smooth(t, 5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RandomToImportant(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "        },\n",
        "        \"camera_config\": {\n",
        "            \"background_color\": GREY_E,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.center().to_edge(DOWN)\n",
        "\n",
        "        left_comment = OldTexText(\"Arbitrary question\")\n",
        "        left_comment.to_edge(UP)\n",
        "        left_comment.shift(3.5 * LEFT)\n",
        "\n",
        "        right_comment = OldTexText(\"Deep fact\")\n",
        "        right_comment.to_edge(UP)\n",
        "        right_comment.shift(3.5 * RIGHT)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            left_comment.get_right(),\n",
        "            right_comment.get_left(),\n",
        "            buff=0.5,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            morty.change, \"raise_left_hand\", left_comment,\n",
        "            FadeInFromDown(left_comment)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\", right_comment,\n",
        "            FadeInFromDown(right_comment)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            morty.look_at, right_comment,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class RandomWalkOfTopics(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 30,\n",
        "        \"n_edge_range\": [2, 4],\n",
        "        \"super_dot_n_edges\": 20,\n",
        "        \"isolated_threashold\": 0.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_network()\n",
        "        self.define_important()\n",
        "        self.perform_walk()\n",
        "\n",
        "    def setup_network(self):\n",
        "        n_dots = self.n_dots\n",
        "        dots = VGroup()\n",
        "\n",
        "        while len(dots) < n_dots:\n",
        "            point = np.random.uniform(-1, 1, size=3)\n",
        "            point[2] = 0\n",
        "            point[0] *= 7\n",
        "            point[1] *= 3\n",
        "            isolated = True\n",
        "            for dot in dots:\n",
        "                if get_norm(dot.get_center() - point) < self.isolated_threashold:\n",
        "                    isolated = False\n",
        "            if not isolated:\n",
        "                continue\n",
        "            dot = Dot(point)\n",
        "            dot.edges = VGroup()\n",
        "            dot.neighbors = VGroup()\n",
        "            dots.add(dot)\n",
        "        super_dot = dots[len(dots) // 2]\n",
        "\n",
        "        all_edges = VGroup()\n",
        "\n",
        "        def add_edge(d1, d2):\n",
        "            if d1 is d2:\n",
        "                return\n",
        "            edge = Line(\n",
        "                d1.get_center(), d2.get_center(),\n",
        "                buff=d1.get_width() / 2\n",
        "            )\n",
        "            d1.edges.add(edge)\n",
        "            d2.edges.add(edge)\n",
        "            d1.neighbors.add(d2)\n",
        "            d2.neighbors.add(d1)\n",
        "            all_edges.add(edge)\n",
        "\n",
        "        for dot in dots:\n",
        "            # others = list(dots[i + 1:])\n",
        "            others = [d for d in dots if d is not dot]\n",
        "            others.sort(key=lambda d: get_norm(d.get_center() - dot.get_center()))\n",
        "            n_edges = np.random.randint(*self.n_edge_range)\n",
        "            for other in others[:n_edges]:\n",
        "                if dot in other.neighbors:\n",
        "                    continue\n",
        "                add_edge(dot, other)\n",
        "\n",
        "        for dot in dots:\n",
        "            if len(super_dot.neighbors) > self.super_dot_n_edges:\n",
        "                break\n",
        "            elif dot in super_dot.neighbors:\n",
        "                continue\n",
        "            add_edge(super_dot, dot)\n",
        "\n",
        "        dots.sort(lambda p: p[0])\n",
        "\n",
        "        all_edges.set_stroke(WHITE, 2)\n",
        "        dots.set_fill(GREY_B, 1)\n",
        "\n",
        "        VGroup(dots, all_edges).to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.dots = dots\n",
        "        self.edges = all_edges\n",
        "        self.super_dot = super_dot\n",
        "\n",
        "    def define_important(self):\n",
        "        sd = self.super_dot\n",
        "        dots = self.dots\n",
        "        edges = self.edges\n",
        "\n",
        "        sd.set_color(RED)\n",
        "        for mob in [*dots, *edges]:\n",
        "            mob.save_state()\n",
        "            mob.set_opacity(0)\n",
        "\n",
        "        sd.set_opacity(1)\n",
        "        sd.edges.set_opacity(1)\n",
        "        sd.neighbors.set_opacity(1)\n",
        "\n",
        "        # angles = np.arange(0, TAU, TAU / len(sd.neighbors))\n",
        "        # center = 0.5 * DOWN\n",
        "        # sd.move_to(center)\n",
        "        # for dot, edge, angle in zip(sd.neighbors, sd.edges, angles):\n",
        "        #     dot.move_to(center + rotate_vector(2.5 * RIGHT, angle))\n",
        "        #     if edge.get_length() > 0:\n",
        "        #         edge.put_start_and_end_on(\n",
        "        #             sd.get_center(),\n",
        "        #             dot.get_center()\n",
        "        #         )\n",
        "        #     rad = dot.get_width() / 2\n",
        "        #     llen = edge.get_length()\n",
        "        #     edge.scale((llen - 2 * rad) / llen)\n",
        "\n",
        "        title = VGroup(\n",
        "            OldTexText(\"Important\"),\n",
        "            OldTex(\"\\\\Leftrightarrow\"),\n",
        "            OldTexText(\"Many connections\"),\n",
        "        )\n",
        "        title.scale(1.5)\n",
        "        title.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        arrow_words = OldTexText(\"(in my view)\")\n",
        "        arrow_words.set_width(2 * title[1].get_width())\n",
        "        arrow_words.next_to(title[1], UP, SMALL_BUFF)\n",
        "\n",
        "        title[0].save_state()\n",
        "        title[0].set_x(0)\n",
        "\n",
        "        self.add(title[0])\n",
        "        self.play(\n",
        "            FadeInFromLarge(sd),\n",
        "            title[0].set_color, RED,\n",
        "        )\n",
        "        title[0].saved_state.set_color(RED)\n",
        "        self.play(\n",
        "            Restore(title[0]),\n",
        "            GrowFromCenter(title[1]),\n",
        "            FadeIn(arrow_words),\n",
        "            FadeIn(title[2], LEFT),\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, sd.edges,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                GrowFromPoint, sd.neighbors,\n",
        "                lambda m: (m, sd.get_center()),\n",
        "                run_time=3,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(Restore, [*dots, *edges]))\n",
        "        self.wait()\n",
        "\n",
        "    def perform_walk(self):\n",
        "        # dots = self.dots\n",
        "        # edges = self.edges\n",
        "        sd = self.super_dot\n",
        "\n",
        "        path = VGroup(sd)\n",
        "        random.seed(1)\n",
        "        for x in range(3):\n",
        "            new_choice = None\n",
        "            while new_choice is None or new_choice in path:\n",
        "                new_choice = random.choice(path[0].neighbors)\n",
        "            path.add_to_back(new_choice)\n",
        "\n",
        "        for d1, d2 in zip(path, path[1:]):\n",
        "            self.play(Flash(d1.get_center()))\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(\n",
        "                    Line(\n",
        "                        d1.get_center(),\n",
        "                        d2.get_center(),\n",
        "                        color=YELLOW,\n",
        "                    )\n",
        "                )\n",
        "            )\n",
        "\n",
        "        self.play(Flash(sd))\n",
        "        self.play(LaggedStart(*[\n",
        "            ApplyMethod(\n",
        "                edge.set_stroke, YELLOW, 5,\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "            for edge in sd.edges\n",
        "        ]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DeadEnds(RandomWalkOfTopics):\n",
        "    CONFIG = {\n",
        "        \"n_dots\": 20,\n",
        "        \"n_edge_range\": [2, 4],\n",
        "        \"super_dot_n_edges\": 2,\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_network()\n",
        "        dots = self.dots\n",
        "        edges = self.edges\n",
        "\n",
        "        self.add(dots, edges)\n",
        "\n",
        "        VGroup(\n",
        "            edges[3],\n",
        "            edges[4],\n",
        "            edges[7],\n",
        "            edges[10],\n",
        "            edges[12],\n",
        "            edges[15],\n",
        "            edges[27],\n",
        "            edges[30],\n",
        "            edges[33],\n",
        "        ).set_opacity(0)\n",
        "\n",
        "        # for i, edge in enumerate(edges):\n",
        "        #     self.add(Integer(i).move_to(edge))\n",
        "\n",
        "\n",
        "class Rediscovery(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(2 * RIGHT)\n",
        "\n",
        "        lightbulb = Lightbulb()\n",
        "        lightbulb.set_stroke(width=4)\n",
        "        lightbulb.scale(1.5)\n",
        "        lightbulb.next_to(randy, UP)\n",
        "\n",
        "        rings = self.get_rings(\n",
        "            lightbulb.get_center(),\n",
        "            max_radius=10.0,\n",
        "            delta_r=0.1,\n",
        "        )\n",
        "\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.pin_to(randy)\n",
        "        # bubble[-1].set_fill(GREEN_SCREEN, 0.5)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\",\n",
        "            ShowCreation(bubble),\n",
        "            FadeInFromDown(lightbulb),\n",
        "        )\n",
        "        self.add(rings, bubble)\n",
        "        self.play(\n",
        "            randy.change, \"thinking\",\n",
        "            LaggedStartMap(\n",
        "                VFadeInThenOut,\n",
        "                rings,\n",
        "                lag_ratio=0.002,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def get_rings(self, center, max_radius, delta_r):\n",
        "        radii = np.arange(0, max_radius, delta_r)\n",
        "        rings = VGroup(*[\n",
        "            Annulus(\n",
        "                inner_radius=r1,\n",
        "                outer_radius=r2,\n",
        "                fill_opacity=0.75 * (1 - fdiv(r1, max_radius)),\n",
        "                fill_color=YELLOW\n",
        "            )\n",
        "            for r1, r2 in zip(radii, radii[1:])\n",
        "        ])\n",
        "        rings.move_to(center)\n",
        "        return rings\n",
        "\n",
        "\n",
        "class BePlayful(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"So be playful!\",\n",
        "            target_mode=\"hooray\",\n",
        "        )\n",
        "        self.play_student_changes(\"thinking\", \"hooray\", \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class SpiralsPatronThanks(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Kurt Dicus\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Matt Russell\",\n",
        "            \"Scott Gray\",\n",
        "            \"soekul\",\n",
        "            \"Tihan Seale\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Arthur Zey\",\n",
        "            \"dave nicponski\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"kkm\",\n",
        "            \"Lambda AI Hardware\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Mark Heising\",\n",
        "            \"Nicholas Cahill\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Quantopian\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Tauba Auerbach\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yu Jun\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"Andrew Weir\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Britton Finley\",\n",
        "            \"David Gow\",\n",
        "            \"J\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Matt\u00e9o Delabre\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Aidan Shenkman\",\n",
        "            \"Alex Mijalis\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Andreas Benjamin Br\u00f6ssel\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Andrew R. Whalley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Anthony Turvey\",\n",
        "            \"Antoine Bruguier\",\n",
        "            \"Antonio Juarez\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Austin Goodman\",\n",
        "            \"Avi Finkel\",\n",
        "            \"Awoo\",\n",
        "            \"Azeem Ansar\",\n",
        "            \"AZsorcerer\",\n",
        "            \"Barry Fam\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Bradley Pirtle\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Calvin Lin\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Charlie N\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Danger Dai\",\n",
        "            \"Daniel Herrera C\",\n",
        "            \"Daniel Pang\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"David B. Hill\",\n",
        "            \"David Clark\",\n",
        "            \"DeathByShrimp\",\n",
        "            \"Delton Ding\",\n",
        "            \"Dominik Wagner\",\n",
        "            \"eaglle\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Ero Carrera\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Fernando Via Canel\",\n",
        "            \"Frank R. Brown, Jr.\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hause Lin\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"Ivan Sorokin\",\n",
        "            \"j eduardo perez\",\n",
        "            \"Jacob Baxter\",\n",
        "            \"Jacob Harmon\",\n",
        "            \"Jacob Hartmann\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"James Stevenson\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"John C. Vesey\",\n",
        "            \"John Griffith\",\n",
        "            \"John Haley\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Josh Kinnear\",\n",
        "            \"Joshua Claeys\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Kartik Cating-Subramanian\",\n",
        "            \"L0j1k\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Mark Mann\",\n",
        "            \"Martin Price\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matthew Bouchard\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Michael Faust\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Michele Donadoni\",\n",
        "            \"Mirik Gogri\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nero Li\",\n",
        "            \"Nikita Lesnikov\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Patrick Lucas\",\n",
        "            \"Pedro Igor Salom\u00e3o Budib\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"RedAgent14\",\n",
        "            \"rehmi post\",\n",
        "            \"Rex Godby\",\n",
        "            \"Richard Barthel\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Roman Sergeychik\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Sebastian Garcia\",\n",
        "            \"Solara570\",\n",
        "            \"Steven Siddals\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Suthen Thomas\",\n",
        "            \"Tal Einav\",\n",
        "            \"Ted Suzman\",\n",
        "            \"The Responsible One\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Tom Fleming\",\n",
        "            \"Tyler VanValkenburg\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Veritasium\",\n",
        "            \"Vinicius Reis\",\n",
        "            \"Xuanji Li\",\n",
        "            \"Yavor Ivanov\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class Thumbnail(SpiralScene):\n",
        "    CONFIG = {\n",
        "        \"max_N\": 8000,\n",
        "        \"just_show\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_dots()\n",
        "        if not self.just_show:\n",
        "            pass\n",
        "\n",
        "    def add_dots(self):\n",
        "        self.set_scale(scale=1e3)\n",
        "\n",
        "        p_spiral = self.get_prime_p_spiral(self.max_N)\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                point,\n",
        "                radius=interpolate(0.01, 0.07, min(0.5 * get_norm(point), 1)),\n",
        "                fill_color=TEAL,\n",
        "                # fill_opacity=interpolate(0.5, 1, min(get_norm(point), 1))\n",
        "            )\n",
        "            for point in p_spiral.get_points()\n",
        "        ])\n",
        "        dots.set_fill([TEAL_E, TEAL_A])\n",
        "        dots.set_stroke(BLACK, 1)\n",
        "\n",
        "        label = OldTexText(\n",
        "            \"($p$, $p$) for all primes $p$,\\\\\\\\\",\n",
        "            \"in polar coordinates\",\n",
        "            tex_to_color_map={\n",
        "                \"$p$\": YELLOW,\n",
        "            },\n",
        "        )\n",
        "\n",
        "        label.scale(2)\n",
        "        label.set_stroke(BLACK, 10, background=True)\n",
        "        label.add_background_rectangle_to_submobjects()\n",
        "        label.to_corner(DL, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(dots)\n",
        "        # self.add(label)\n",
        "\n",
        "        self.dots = dots\n"
    ]
}