{
    "topic": "demonstrates the concept of a multilayered structure, where a glass is divided into",
    "code": [
        "import numpy as np\n",
        "import itertools as it\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from from_3b1b.old.brachistochrone.light import PhotonScene\n",
        "from from_3b1b.old.brachistochrone.curves import *\n",
        "\n",
        "\n",
        "class MultilayeredScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_layers\" : 5,\n",
        "        \"top_color\" : BLUE_E,\n",
        "        \"bottom_color\" : BLUE_A,\n",
        "        \"total_glass_height\" : 5,\n",
        "        \"top\" : 3*UP,\n",
        "        \"RectClass\" : Rectangle #FilledRectangle\n",
        "    }\n",
        "\n",
        "    def get_layers(self, n_layers = None):\n",
        "        if n_layers is None:\n",
        "            n_layers = self.n_layers\n",
        "        width = FRAME_WIDTH\n",
        "        height = float(self.total_glass_height)/n_layers\n",
        "        rgb_pair = [\n",
        "            np.array(Color(color).get_rgb())\n",
        "            for color in (self.top_color, self.bottom_color)\n",
        "        ]\n",
        "        rgb_range = [\n",
        "            interpolate(*rgb_pair+[x])\n",
        "            for x in np.arange(0, 1, 1./n_layers)\n",
        "        ]\n",
        "        tops = [\n",
        "            self.top + x*height*DOWN\n",
        "            for x in range(n_layers)\n",
        "        ]\n",
        "        color = Color()\n",
        "        result = []\n",
        "        for top, rgb in zip(tops, rgb_range):\n",
        "            color.set_rgb(rgb)\n",
        "            rect = self.RectClass(\n",
        "                height = height, \n",
        "                width = width, \n",
        "                color = color\n",
        "            )\n",
        "            rect.shift(top-rect.get_top())\n",
        "            result.append(rect)\n",
        "        return result\n",
        "\n",
        "    def add_layers(self):\n",
        "        self.layers = self.get_layers()\n",
        "        self.add(*self.layers)\n",
        "        self.freeze_background()\n",
        "\n",
        "    def get_bottom(self):\n",
        "        return self.top + self.total_glass_height*DOWN\n",
        "\n",
        "    def get_continuous_glass(self):\n",
        "        result = self.RectClass(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = self.total_glass_height,\n",
        "        )\n",
        "        result.sort_points(lambda p : -p[1])\n",
        "        result.set_color_by_gradient(self.top_color, self.bottom_color)\n",
        "        result.shift(self.top-result.get_top())\n",
        "        return result\n",
        "\n",
        "\n",
        "class TwoToMany(MultilayeredScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        glass = self.get_glass()\n",
        "        layers = self.get_layers()\n",
        "\n",
        "        self.add(glass)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            FadeIn(\n",
        "                layer,\n",
        "                rate_func = squish_rate_func(smooth, x, 1)\n",
        "            )\n",
        "            for layer, x in zip(layers[1:], it.count(0, 0.2))\n",
        "        ]+[\n",
        "            Transform(glass, layers[0])\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def get_glass(self):\n",
        "        return self.RectClass(\n",
        "            height = FRAME_Y_RADIUS,\n",
        "            width = FRAME_WIDTH,\n",
        "            color = BLUE_E\n",
        "        ).shift(FRAME_Y_RADIUS*DOWN/2)\n",
        "\n",
        "\n",
        "class RaceLightInLayers(MultilayeredScene, PhotonScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_layers()\n",
        "        line = Line(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "        lines = [\n",
        "            line.copy().shift(layer.get_center())\n",
        "            for layer in self.layers\n",
        "        ]\n",
        "\n",
        "        def rate_maker(x):\n",
        "            return lambda t : min(x*x*t, 1)\n",
        "        min_rate, max_rate = 1., 2.\n",
        "        rates = np.arange(min_rate, max_rate, (max_rate-min_rate)/self.n_layers)\n",
        "        self.play(*[\n",
        "            self.photon_run_along_path(\n",
        "                line,\n",
        "                rate_func = rate_maker(rate),\n",
        "                run_time = 2\n",
        "            )\n",
        "            for line, rate in zip(lines, rates)\n",
        "        ])\n",
        "\n",
        "class ShowDiscretePath(MultilayeredScene, PhotonScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_layers()\n",
        "        self.cycloid = Cycloid(end_theta = np.pi)\n",
        "\n",
        "        self.generate_discrete_path()\n",
        "        self.play(ShowCreation(self.discrete_path))\n",
        "        self.wait()\n",
        "        self.play(self.photon_run_along_path(\n",
        "            self.discrete_path,\n",
        "            rate_func = rush_into,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def generate_discrete_path(self):\n",
        "        points = self.cycloid.points\n",
        "        tops = [mob.get_top()[1] for mob in self.layers]\n",
        "        tops.append(tops[-1]-self.layers[0].get_height())\n",
        "        indices = [\n",
        "            np.argmin(np.abs(points[:, 1]-top))\n",
        "            for top in tops\n",
        "        ]\n",
        "        self.bend_points = points[indices[1:-1]]\n",
        "        self.path_angles = []\n",
        "        self.discrete_path = Mobject1D(\n",
        "            color = WHITE,\n",
        "            density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        for start, end in zip(indices, indices[1:]):\n",
        "            start_point, end_point = points[start], points[end]\n",
        "            self.discrete_path.add_line(\n",
        "                start_point, end_point\n",
        "            )\n",
        "            self.path_angles.append(\n",
        "                angle_of_vector(start_point-end_point)-np.pi/2\n",
        "            )\n",
        "        self.discrete_path.add_line(\n",
        "            points[end], FRAME_X_RADIUS*RIGHT+(tops[-1]-0.5)*UP\n",
        "        )\n",
        "\n",
        "class NLayers(MultilayeredScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_layers()\n",
        "        brace = Brace(\n",
        "            Mobject(\n",
        "                Point(self.top),\n",
        "                Point(self.get_bottom())\n",
        "            ),\n",
        "            RIGHT\n",
        "        )\n",
        "        n_layers = OldTexText(\"$n$ layers\")\n",
        "        n_layers.next_to(brace)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        self.add(brace)\n",
        "        self.show_frame()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            GrowFromCenter(n_layers)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ShowLayerVariables(MultilayeredScene, PhotonScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_layers()\n",
        "        v_equations = []\n",
        "        start_ys = []\n",
        "        end_ys = []\n",
        "        center_paths = []\n",
        "        braces = []\n",
        "        for layer, x in zip(self.layers[:3], it.count(1)):\n",
        "            eq_mob = OldTex(\n",
        "                [\"v_%d\"%x, \"=\", \"\\sqrt{\\phantom{y_1}}\"],\n",
        "                size = \"\\\\Large\"\n",
        "            )\n",
        "            eq_mob.shift(layer.get_center()+2*LEFT)\n",
        "            v_eq = eq_mob.split()\n",
        "            v_eq[0].set_color(layer.get_color())\n",
        "            path = Line(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "            path.shift(layer.get_center())\n",
        "            brace_endpoints = Mobject(\n",
        "                Point(self.top),\n",
        "                Point(layer.get_bottom())\n",
        "            )\n",
        "            brace = Brace(brace_endpoints, RIGHT)\n",
        "            brace.shift(x*RIGHT)\n",
        "\n",
        "            start_y = OldTex(\"y_%d\"%x, size = \"\\\\Large\")\n",
        "            end_y = start_y.copy()\n",
        "            start_y.next_to(brace, RIGHT)\n",
        "            end_y.shift(v_eq[-1].get_center())\n",
        "            nudge = 0.2*RIGHT\n",
        "            end_y.shift(nudge)\n",
        "\n",
        "            v_equations.append(v_eq)\n",
        "            start_ys.append(start_y)\n",
        "            end_ys.append(end_y)\n",
        "            center_paths.append(path)            \n",
        "            braces.append(brace)\n",
        "\n",
        "        for v_eq, path, time in zip(v_equations, center_paths, [2, 1, 0.5]):\n",
        "            photon_run = self.photon_run_along_path(\n",
        "                path,\n",
        "                rate_func=linear\n",
        "            )\n",
        "            self.play(\n",
        "                FadeToColor(v_eq[0], WHITE),\n",
        "                photon_run,\n",
        "                run_time = time\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        starts = [0, 0.3, 0.6]\n",
        "        self.play(*it.chain(*[\n",
        "            [\n",
        "                GrowFromCenter(\n",
        "                    mob,\n",
        "                    rate_func=squish_rate_func(smooth, start, 1)\n",
        "                )\n",
        "                for mob, start in zip(mobs, starts)\n",
        "            ]\n",
        "            for mobs in (start_ys, braces)\n",
        "        ]))\n",
        "        self.wait()\n",
        "\n",
        "        triplets = list(zip(v_equations, start_ys, end_ys))\n",
        "        anims = []\n",
        "        for v_eq, start_y, end_y in triplets:\n",
        "            anims += [\n",
        "                ShowCreation(v_eq[1]),\n",
        "                ShowCreation(v_eq[2]),\n",
        "                Transform(start_y.copy(), end_y)\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LimitingProcess(MultilayeredScene):\n",
        "    CONFIG = {\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        num_iterations = 3\n",
        "        layer_sets = [\n",
        "            self.get_layers((2**x)*self.n_layers)\n",
        "            for x in range(num_iterations)\n",
        "        ]\n",
        "        glass_sets = [\n",
        "            Mobject(*[\n",
        "                Mobject(\n",
        "                    *layer_sets[x][(2**x)*index:(2**x)*(index+1)]\n",
        "                )\n",
        "                for index in range(self.n_layers)\n",
        "            ]).ingest_submobjects()\n",
        "            for x in range(num_iterations)\n",
        "        ]\n",
        "        glass_sets.append(self.get_continuous_glass())\n",
        "        for glass_set in glass_sets:\n",
        "            glass_set.sort_points(lambda p : p[1])\n",
        "        curr_set = glass_sets[0]\n",
        "        self.add(curr_set)\n",
        "        for layer_set in glass_sets[1:]:\n",
        "            self.wait()\n",
        "            self.play(Transform(curr_set, layer_set))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class ShowLightAndSlidingObject(MultilayeredScene, TryManyPaths, PhotonScene):\n",
        "    CONFIG = {\n",
        "        \"show_time\" : False,\n",
        "        \"wait_and_add\" : False,\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        glass = self.get_continuous_glass()\n",
        "        self.play(ApplyMethod(glass.fade, 0.8))\n",
        "        self.freeze_background()\n",
        "\n",
        "        paths = self.get_paths()\n",
        "        for path in paths:\n",
        "            if path.get_height() > self.total_glass_height:\n",
        "                path.stretch(0.7, 1)\n",
        "                path.shift(self.top - path.get_top())\n",
        "            path.rgbas[:,2] = 0\n",
        "        loop = paths.pop(1) ##Bad!\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        photon_run = self.photon_run_along_path(\n",
        "            loop, \n",
        "            rate_func = lambda t : smooth(1.2*t, 2),\n",
        "            run_time = 4.1\n",
        "        )\n",
        "        text = self.get_text().to_edge(UP, buff = 0.2)\n",
        "\n",
        "        self.play(ShowCreation(loop))\n",
        "        self.wait()\n",
        "        self.play(photon_run)\n",
        "        self.remove(photon_run.mobject)\n",
        "        randy = self.slide(randy, loop)\n",
        "        self.add(randy)\n",
        "        self.wait()\n",
        "        self.remove(randy)\n",
        "        self.play(ShimmerIn(text))\n",
        "        for path in paths:\n",
        "            self.play(Transform(\n",
        "                loop, path,\n",
        "                path_func = path_along_arc(np.pi/2),\n",
        "                run_time = 2\n",
        "            ))\n",
        "\n",
        "\n",
        "class ContinuouslyObeyingSnellsLaw(MultilayeredScene):\n",
        "    CONFIG = {\n",
        "        \"arc_radius\" : 0.5,\n",
        "        \"RectClass\" : FilledRectangle\n",
        "    }\n",
        "    def construct(self):\n",
        "        glass = self.get_continuous_glass()\n",
        "        self.add(glass)\n",
        "        self.freeze_background()\n",
        "\n",
        "        cycloid = Cycloid(end_theta = np.pi)\n",
        "        cycloid.set_color(YELLOW)\n",
        "        chopped_cycloid = cycloid.copy()\n",
        "        n = cycloid.get_num_points()\n",
        "        chopped_cycloid.filter_out(lambda p : p[1] > 1 and p[0] < 0)\n",
        "        chopped_cycloid.reverse_points()\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(cycloid))\n",
        "        ref_mob = self.snells_law_at_every_point(cycloid, chopped_cycloid)\n",
        "        self.show_equation(chopped_cycloid, ref_mob)\n",
        "\n",
        "    def snells_law_at_every_point(self, cycloid, chopped_cycloid):\n",
        "        square = Square(side_length = 0.2, color = WHITE)\n",
        "        words = OldTexText([\"Snell's law \", \"everywhere\"])\n",
        "        snells, rest = words.split()\n",
        "        colon = OldTexText(\":\")\n",
        "        words.next_to(square)\n",
        "        words.shift(0.3*UP)\n",
        "        combo = Mobject(square, words)\n",
        "        combo.get_center = lambda : square.get_center()\n",
        "        new_snells = snells.copy().center().to_edge(UP, buff = 1.5)\n",
        "        colon.next_to(new_snells)\n",
        "        colon.shift(0.05*DOWN)\n",
        "            \n",
        "        self.play(MoveAlongPath(\n",
        "            combo, cycloid,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.play(MoveAlongPath(\n",
        "            combo, chopped_cycloid,\n",
        "            run_time = 4\n",
        "        ))\n",
        "        dot = Dot(combo.get_center())\n",
        "        self.play(Transform(square, dot))\n",
        "        self.play(\n",
        "            Transform(snells, new_snells),\n",
        "            Transform(rest, colon)\n",
        "        )\n",
        "        self.wait()\n",
        "        return colon\n",
        "\n",
        "    def get_marks(self, point1, point2):\n",
        "        vert_line = Line(2*DOWN, 2*UP)\n",
        "        tangent_line = vert_line.copy()\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.scale(0.5)\n",
        "        angle = angle_of_vector(point1 - point2)\n",
        "        tangent_line.rotate(\n",
        "            angle - tangent_line.get_angle()\n",
        "        )\n",
        "        angle_from_vert = angle - np.pi/2\n",
        "        for mob in vert_line, tangent_line:\n",
        "            mob.shift(point1 - mob.get_center())\n",
        "        arc = Arc(angle_from_vert, start_angle = np.pi/2)\n",
        "        arc.scale(self.arc_radius)\n",
        "        arc.shift(point1)\n",
        "        vect_angle = angle_from_vert/2 + np.pi/2\n",
        "        vect = rotate_vector(RIGHT, vect_angle)\n",
        "        theta.center()\n",
        "        theta.shift(point1)\n",
        "        theta.shift(1.5*self.arc_radius*vect)\n",
        "        return arc, theta, vert_line, tangent_line\n",
        "\n",
        "\n",
        "    def show_equation(self, chopped_cycloid, ref_mob):\n",
        "        point2, point1 = chopped_cycloid.get_points()[-2:]\n",
        "        arc, theta, vert_line, tangent_line = self.get_marks(\n",
        "            point1, point2\n",
        "        )\n",
        "        equation = OldTex([\n",
        "            \"\\\\sin(\\\\theta)\",\n",
        "            \"\\\\over \\\\sqrt{y}\",            \n",
        "        ])\n",
        "        sin, sqrt_y = equation.split()\n",
        "        equation.next_to(ref_mob)\n",
        "        const = OldTex(\" = \\\\text{constant}\")\n",
        "        const.next_to(equation)\n",
        "        ceil_point = np.array(point1)\n",
        "        ceil_point[1] = self.top[1]\n",
        "        brace = Brace(\n",
        "            Mobject(Point(point1), Point(ceil_point)),\n",
        "            RIGHT\n",
        "        )\n",
        "        y_mob = OldTex(\"y\").next_to(brace)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(sin),\n",
        "            ShowCreation(arc), \n",
        "            GrowFromCenter(theta)\n",
        "        )\n",
        "        self.play(ShowCreation(vert_line))\n",
        "        self.play(ShowCreation(tangent_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(sqrt_y),\n",
        "            GrowFromCenter(brace),\n",
        "            GrowFromCenter(y_mob)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            Point(const.get_left()), const\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}