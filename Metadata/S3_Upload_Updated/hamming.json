{
    "topic": "is demonstrating the concept of Hamming coding and its application in error correction.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2020.chess import string_to_bools\n",
        "\n",
        "\n",
        "def get_background(color=GREY_E):\n",
        "    background = FullScreenRectangle()\n",
        "    background.set_fill(color, 1)\n",
        "    background.set_stroke(width=0)\n",
        "    return background\n",
        "\n",
        "\n",
        "def get_bit_grid(n_rows, n_cols, bits=None, buff=MED_SMALL_BUFF, height=4):\n",
        "    bit_pair = VGroup(Integer(0), Integer(1))\n",
        "    bit_mobs = VGroup(*[\n",
        "        bit_pair.copy()\n",
        "        for x in range(n_rows * n_cols)\n",
        "    ])\n",
        "    bit_mobs.arrange_in_grid(n_rows, n_cols, buff=buff)\n",
        "    bit_mobs.set_height(height)\n",
        "    if bits is None:\n",
        "        bits = np.random.randint(0, 2, len(bit_mobs))\n",
        "\n",
        "    for bit_mob, bit in zip(bit_mobs, bits):\n",
        "        bit_mob[1 - bit].set_opacity(0)\n",
        "\n",
        "    bit_mobs.n_rows = n_rows\n",
        "    bit_mobs.n_cols = n_cols\n",
        "    return bit_mobs\n",
        "\n",
        "\n",
        "def get_bit_mob_value(bit_mob):\n",
        "    return int(bit_mob[1].get_fill_opacity() > bit_mob[0].get_fill_opacity())\n",
        "\n",
        "\n",
        "def bit_grid_to_bits(bit_grid):\n",
        "    return list(map(get_bit_mob_value, bit_grid))\n",
        "\n",
        "\n",
        "def toggle_bit(bit):\n",
        "    for sm in bit:\n",
        "        sm.set_fill(opacity=1 - sm.get_fill_opacity())\n",
        "    return bit\n",
        "\n",
        "\n",
        "def hamming_syndrome(bits):\n",
        "    return reduce(\n",
        "        lambda i1, i2: i1 ^ i2,\n",
        "        [i for i, b in enumerate(bits) if b],\n",
        "        0,\n",
        "    )\n",
        "\n",
        "\n",
        "def string_to_bits(message):\n",
        "    return [int(b) for b in string_to_bools(message)]\n",
        "\n",
        "\n",
        "def int_to_bit_string(number, n_bits=None):\n",
        "    result = \"{:b}\".format(number)\n",
        "    if n_bits is not None:\n",
        "        result = (n_bits - len(result)) * \"0\" + result\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_image_bits(image, bit_height=0.15, buff=MED_SMALL_BUFF):\n",
        "    bit = Integer(0)\n",
        "    small_buff = (buff / bit.get_height()) * bit_height\n",
        "    bit.set_height(bit_height)\n",
        "    bits = get_bit_grid(\n",
        "        n_rows=int(image.get_height() / (bit.get_height() + small_buff)),\n",
        "        n_cols=int(image.get_width() / (bit.get_width() + small_buff)),\n",
        "        buff=buff\n",
        "    )\n",
        "    bits.replace(image)\n",
        "    return bits\n",
        "\n",
        "\n",
        "def get_sound_wave():\n",
        "    sound = VGroup(*[\n",
        "        Line(DOWN, UP).set_height(\n",
        "            (0.3 + 0.8 * random.random()) * abs(np.sin(x))\n",
        "        )\n",
        "        for x in np.linspace(0, 3 * PI, 100)\n",
        "    ])\n",
        "    sound.arrange(RIGHT, buff=0.05)\n",
        "    return sound\n",
        "\n",
        "\n",
        "def get_sender_and_receiver(height=2):\n",
        "    sender = Randolph(height=height)\n",
        "    receiver = Mortimer(height=height)\n",
        "    sender.name = OldTexText(\"Sender\")\n",
        "    receiver.name = OldTexText(\"Receiver\")\n",
        "\n",
        "    pis = VGroup(sender, receiver)\n",
        "    names = VGroup(sender.name, receiver.name)\n",
        "\n",
        "    sender.to_corner(DL)\n",
        "    receiver.to_corner(DR)\n",
        "    pis.shift(UP)\n",
        "    for name, pi in zip(names, pis):\n",
        "        name.next_to(pi, DOWN)\n",
        "\n",
        "    return pis, names\n",
        "\n",
        "\n",
        "def get_ones(block):\n",
        "    result = VGroup()\n",
        "    for bit in block:\n",
        "        if isinstance(bit, Integer):\n",
        "            value = bit.get_value()\n",
        "        else:\n",
        "            value = get_bit_mob_value(bit)\n",
        "        if value == 1:\n",
        "            result.add(bit)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_one_rects(block, buff=SMALL_BUFF):\n",
        "    rects = VGroup()\n",
        "    for bit in get_ones(block):\n",
        "        rect = SurroundingRectangle(bit, buff=buff)\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "        rect.set_fill(YELLOW, 0.2)\n",
        "        rects.add(rect)\n",
        "    return rects\n",
        "\n",
        "\n",
        "def get_ones_counter(label, one_rects, buff=MED_LARGE_BUFF):\n",
        "    counter = Integer()\n",
        "    counter.match_color(one_rects[0])\n",
        "    counter.match_height(label[1])\n",
        "    counter.next_to(label[1], RIGHT, buff=buff, aligned_edge=DOWN)\n",
        "    f_always(counter.set_value, lambda: len(one_rects))\n",
        "    return counter\n",
        "\n",
        "\n",
        "def get_bit_grid_boxes(bit_grid, color=GREY_B, stroke_width=2):\n",
        "    width = get_norm(bit_grid[1].get_center() - bit_grid[0].get_center())\n",
        "    height = get_norm(bit_grid[bit_grid.n_cols].get_center() - bit_grid[0].get_center())\n",
        "    return VGroup(*[\n",
        "        Rectangle(\n",
        "            height=height,\n",
        "            width=width,\n",
        "            stroke_color=color,\n",
        "            stroke_width=stroke_width,\n",
        "        ).move_to(bit)\n",
        "        for bit in bit_grid\n",
        "    ])\n",
        "\n",
        "\n",
        "def get_grid_position_labels(boxes, height=0.25):\n",
        "    labels = VGroup()\n",
        "    for n, box in enumerate(boxes):\n",
        "        label = Integer(n)\n",
        "        label.set_height(height)\n",
        "        label.move_to(box, DR)\n",
        "        label.shift(SMALL_BUFF * UL)\n",
        "        labels.add(label)\n",
        "    return labels\n",
        "\n",
        "\n",
        "def get_bit_n_sublist(input_list, n, bit_value=1):\n",
        "    return [\n",
        "        elem\n",
        "        for i, elem in enumerate(input_list)\n",
        "        if bool(i & (1 << n)) ^ bool(1 - bit_value)\n",
        "    ]\n",
        "\n",
        "\n",
        "def get_bit_n_subgroup(mob, n, bit_value=1):\n",
        "    \"\"\"\n",
        "    If we enumerate mob, this returns a subgroup of all elements\n",
        "    whose index has a binary representation with the n'th bit\n",
        "    equal to bit_value\n",
        "    \"\"\"\n",
        "    return VGroup(*get_bit_n_sublist(mob, n, bit_value))\n",
        "\n",
        "\n",
        "# Special animations\n",
        "def image_reveal_animation(image, bit_height=0.1):\n",
        "    box = SurroundingRectangle(image)\n",
        "    box.set_fill(BLACK, 1)\n",
        "    box.set_stroke(width=0)\n",
        "    bits = get_image_bits(image, bit_height=bit_height)\n",
        "\n",
        "    return AnimationGroup(\n",
        "        Animation(image),\n",
        "        ApplyMethod(\n",
        "            box.stretch, 0, 1, {\"about_edge\": DOWN}, remover=True,\n",
        "            rate_func=linear,\n",
        "        ),\n",
        "        LaggedStartMap(\n",
        "            VFadeInThenOut, bits,\n",
        "            run_time=1,\n",
        "            lag_ratio=3 / len(bits)\n",
        "        )\n",
        "    )\n",
        "\n",
        "\n",
        "def toggle_bit_anim(bit, target_color=None, **kwargs):\n",
        "    original = bit.copy()\n",
        "    original[1 - get_bit_mob_value(original)].rotate(PI)\n",
        "    toggle_bit(bit)\n",
        "    if target_color is not None:\n",
        "        bit.set_color(target_color)\n",
        "\n",
        "    if \"path_arc\" not in kwargs:\n",
        "        kwargs[\"path_arc\"] = PI\n",
        "\n",
        "    return TransformFromCopy(original, bit, **kwargs)\n",
        "\n",
        "\n",
        "def zap_anim(bit, bolt_height=0.75):\n",
        "    bolt = SVGMobject(\"lightning_bolt\")\n",
        "    bolt[0].add_line_to(bolt[0].get_start())\n",
        "    bolt.set_fill(RED_B, 1)\n",
        "    bolt.set_stroke(width=0)\n",
        "    bolt.set_height(bolt_height)\n",
        "\n",
        "    bolt.move_to(bit.get_center(), DL)\n",
        "\n",
        "    outline = bolt.deepcopy()\n",
        "    outline.set_stroke(RED_D, 2)\n",
        "    outline.set_fill(opacity=0)\n",
        "\n",
        "    return AnimationGroup(\n",
        "        Succession(\n",
        "            GrowFromPoint(bolt, bolt.get_corner(UR), rate_func=rush_into),\n",
        "            FadeOut(bolt, run_time=0.5),\n",
        "        ),\n",
        "        Succession(\n",
        "            ShowCreation(outline),\n",
        "            FadeOut(outline),\n",
        "        ),\n",
        "        run_time=1,\n",
        "    )\n",
        "\n",
        "\n",
        "def scan_anim(point, bits, final_stroke_width=0, run_time=3, lag_factor=3, show_robot=True, robot_height=0.5):\n",
        "    lines = VGroup(*[\n",
        "        Line(\n",
        "            point, bit.get_center(),\n",
        "            stroke_color=[GREEN, BLUE][get_bit_mob_value(bit)],\n",
        "            stroke_width=1,\n",
        "        )\n",
        "        for bit in bits\n",
        "    ])\n",
        "    anims = [\n",
        "        LaggedStartMap(\n",
        "            lambda m, **kw: Succession(\n",
        "                ShowCreation(m),\n",
        "                ApplyMethod(m.set_stroke, None, final_stroke_width),\n",
        "                **kw\n",
        "            ),\n",
        "            lines,\n",
        "            lag_ratio=lag_factor / len(bits),\n",
        "            run_time=run_time,\n",
        "            remover=bool(final_stroke_width)\n",
        "        )\n",
        "    ]\n",
        "\n",
        "    if show_robot:\n",
        "        robot = SVGMobject(\"robot\")\n",
        "        robot.set_stroke(width=0)\n",
        "        robot.set_color(GREY)\n",
        "        robot.set_gloss(1)\n",
        "        robot.set_height(robot_height)\n",
        "        robot.move_to(point, UP)\n",
        "        anims.append(FadeIn(robot))\n",
        "\n",
        "    return AnimationGroup(*anims)\n",
        "\n",
        "\n",
        "def focus_scan_anim_lines(scanim, point, final_stroke_width=1):\n",
        "    lines = scanim.mobject[0]\n",
        "    for line in lines:\n",
        "        line.generate_target()\n",
        "        line.target.put_start_and_end_on(line.get_start(), point)\n",
        "        line.target.set_stroke(width=final_stroke_width)\n",
        "\n",
        "    return AnimationGroup(*[\n",
        "        MoveToTarget(line)\n",
        "        for line in lines\n",
        "    ])\n",
        "\n",
        "\n",
        "def get_xor(height=0.35, color=BLUE_B, stroke_width=4):\n",
        "    xor = VGroup(\n",
        "        Line(UP, DOWN),\n",
        "        Line(LEFT, RIGHT),\n",
        "        Circle(),\n",
        "    )\n",
        "    xor.set_stroke(color, stroke_width)\n",
        "    xor.set_height(height)\n",
        "    return xor\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        phrases = VGroup(\n",
        "            OldTexText(\"One Bit is Wrong\"),\n",
        "            OldTexText(\"(according to an extended Hamming Code)\"),\n",
        "            OldTexText(\"Can you tell which?\"),\n",
        "        )\n",
        "        for phrase in phrases:\n",
        "            phrase.set_width(12)\n",
        "\n",
        "        phrases[0].to_edge(UP)\n",
        "\n",
        "        phrases[1].set_width(10)\n",
        "        phrases[1].set_color(GREY_C)\n",
        "        phrases[1].next_to(phrases[0], DOWN, SMALL_BUFF)\n",
        "\n",
        "        phrases[2].to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        phrases[0].set_color(BLUE_B)\n",
        "        phrases[2].set_color(BLUE_C)\n",
        "\n",
        "        bit_values = [\n",
        "            1, 1, 0, 1, 1, 0, 0, 1,\n",
        "            0, 1, 1, 0, 1, 1, 1, 1,\n",
        "        ]\n",
        "        bits = get_bit_grid(2, 8, bits=bit_values, buff=MED_LARGE_BUFF)\n",
        "        boxes = get_bit_grid_boxes(bits)\n",
        "        pos_labels = get_grid_position_labels(boxes)\n",
        "\n",
        "        pos_labels.set_color(GREY_B)\n",
        "        for bit, box in zip(bits, boxes):\n",
        "            bit.set_height(0.7 * box.get_height())\n",
        "\n",
        "        group = VGroup(boxes, bits, pos_labels)\n",
        "        group.set_width(10)\n",
        "        group.next_to(phrases[1], DOWN)\n",
        "\n",
        "        self.add(phrases)\n",
        "        self.add(group)\n",
        "\n",
        "\n",
        "class AltThumbnail(Scene):\n",
        "    def construct(self):\n",
        "        background = self.get_background()\n",
        "        self.add(background)\n",
        "\n",
        "        bits = get_bit_grid(4, 4)\n",
        "        bits.arrange_in_grid(h_buff=0.7, v_buff=0.5)\n",
        "        boxes = get_bit_grid_boxes(bits)\n",
        "        boxes.set_fill(BLACK, 1)\n",
        "\n",
        "        boxes[0].set_fill(TEAL_E)\n",
        "        parity_boxes = VGroup(*(boxes[2**n] for n in range(4)))\n",
        "        parity_boxes.set_fill(BLUE_E, 1)\n",
        "        group = VGroup(boxes, bits)\n",
        "        group.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        grouped_blocks = VGroup(*(boxes.copy() for x in range(4)))\n",
        "        grouped_blocks.arrange_in_grid(buff_ratio=0.4)\n",
        "        grouped_blocks.match_height(boxes)\n",
        "        grouped_blocks.match_y(boxes)\n",
        "        for n, gb in enumerate(grouped_blocks):\n",
        "            gb.set_fill(BLACK)\n",
        "            for k, box in enumerate(gb):\n",
        "                if (k & (2**n)):\n",
        "                    box.set_fill(BLUE_E)\n",
        "        grouped_blocks.to_edge(RIGHT, LARGE_BUFF)\n",
        "\n",
        "        all_blocks = VGroup(group, grouped_blocks)\n",
        "        all_blocks.arrange(RIGHT, buff=1.0).to_edge(DOWN, LARGE_BUFF)\n",
        "        all_blocks.set_height(6).center()\n",
        "\n",
        "        self.add(group)\n",
        "        self.add(grouped_blocks)\n",
        "        return\n",
        "\n",
        "        #\n",
        "        title = Text(\"Hamming codes\", font_size=72)\n",
        "        title.to_edge(UP)\n",
        "        shadow = VGroup()\n",
        "        for w in np.linspace(50, 0, 50):\n",
        "            tc = title.copy()\n",
        "            tc.set_stroke(BLACK, width=w, opacity=0.02)\n",
        "            tc.set_fill(opacity=0)\n",
        "            shadow.add(tc)\n",
        "\n",
        "        self.add(shadow)\n",
        "        self.add(title)\n",
        "        return\n",
        "\n",
        "\n",
        "        #\n",
        "        words = OldTexText(\"Parity bits\", font_size=72)\n",
        "        words.next_to(boxes, LEFT, LARGE_BUFF)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        words.move_to(boxes.get_corner(UL), DR)\n",
        "        words.shift(0.5 * UL)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for n, v in zip(range(4), [UP, UP, LEFT, LEFT]):\n",
        "            lines.add(Line(words.get_corner(DR), boxes[2**n].get_corner(v), buff=0.0))\n",
        "\n",
        "        lines.set_stroke(BLUE_B)\n",
        "\n",
        "        self.add(words)\n",
        "        self.add(lines)\n",
        "\n",
        "    def get_background(self, n=25, k=100):\n",
        "        choices = (Integer(0), Integer(1))\n",
        "        background = VGroup(*(random.choice(choices).copy() for x in range(n * k)))\n",
        "        background.arrange_in_grid(n, k)\n",
        "        background.set_height(FRAME_HEIGHT)\n",
        "        background.set_opacity(0.25)\n",
        "        background.set_fill(border_width=0)\n",
        "        return background\n",
        "\n",
        "\n",
        "class DiskOfBits(Scene):\n",
        "    def construct(self):\n",
        "        # Setup disc\n",
        "        bits = get_bit_grid(2**5, 2**6, height=6)\n",
        "\n",
        "        inner_r = 1\n",
        "        outer_r = 3\n",
        "        annulus = Annulus(\n",
        "            inner_radius=inner_r * 0.93,\n",
        "            outer_radius=outer_r * 1.02,\n",
        "            fill_color=GREY_D,\n",
        "        )\n",
        "        annulus.set_gloss(0.5)\n",
        "\n",
        "        for bit in bits:\n",
        "            point = bit.get_center()\n",
        "            norm = get_norm(point)\n",
        "            to_inner = inner_r - norm\n",
        "            to_outer = norm - outer_r\n",
        "            sdf = 10 * max(to_inner, to_outer)\n",
        "            if 0 < sdf < 0.5:\n",
        "                bit.scale(1 - sdf)\n",
        "            elif sdf > 0:\n",
        "                bits.remove(bit)\n",
        "\n",
        "        disc = VGroup(annulus, bits)\n",
        "\n",
        "        # Setup scratch\n",
        "        scratch_line = Line(disc.get_top(), disc.get_right())\n",
        "        scratch_line.set_stroke(RED, width=2, opacity=0.75)\n",
        "\n",
        "        flipped_bits = VGroup()\n",
        "        for bit in bits:\n",
        "            point = bit.get_center()\n",
        "            norm = abs(point[0] + point[1] - 3)\n",
        "            alpha = 1 - clip(norm / 0.2, 0, 1)\n",
        "            if alpha > 0.25:\n",
        "                bit.generate_target()\n",
        "                bit.target.set_stroke(width=1)\n",
        "                bit.target.set_color(RED)\n",
        "                flipped_bits.add(bit)\n",
        "\n",
        "        # Add disc\n",
        "        light = self.camera.light_source\n",
        "        light.move_to([0, -10, 10])\n",
        "\n",
        "        random_bits = bits.copy()\n",
        "        random_bits.sort(lambda p: -get_norm(p))\n",
        "        self.add(annulus)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, random_bits, lag_ratio=10 / len(bits)),\n",
        "            light.move_to, [-10, 10, 10],\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(disc)\n",
        "\n",
        "        # Show scratch\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, flipped_bits),\n",
        "            ShowCreationThenDestruction(scratch_line),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Flip 'em'\n",
        "        self.play(LaggedStartMap(toggle_bit_anim, flipped_bits))\n",
        "        self.wait()\n",
        "\n",
        "        # Show image in and image out\n",
        "        disc.generate_target()\n",
        "        disc.target.scale(0.5)\n",
        "\n",
        "        in_image = ImageMobject(\"Mona_Lisa\")\n",
        "        in_image.to_edge(LEFT)\n",
        "        in_image.shift(UP)\n",
        "        in_words = OldTexText(\"What was\\\\\\\\encoded\")\n",
        "        in_words.next_to(in_image, DOWN)\n",
        "        out_image = in_image.copy()\n",
        "        out_image.to_edge(RIGHT)\n",
        "        out_words = OldTexText(\"What is\\\\\\\\decoded\")\n",
        "        out_words.next_to(out_image, DOWN)\n",
        "\n",
        "        in_arrow = Arrow(\n",
        "            in_image.get_right(),\n",
        "            disc.target.get_left() + 0.2 * UP,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "        )\n",
        "        out_arrow = Arrow(\n",
        "            disc.target.get_right() + 0.2 * UP,\n",
        "            out_image.get_left(),\n",
        "            buff=MED_SMALL_BUFF,\n",
        "        )\n",
        "        for arrow in in_arrow, out_arrow:\n",
        "            arrow.set_fill(GREY_B)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(disc),\n",
        "            GrowArrow(out_arrow),\n",
        "        )\n",
        "\n",
        "        in_bits = get_bit_grid(40, 33)\n",
        "        in_bits.replace(in_image, stretch=True)\n",
        "        in_bits.set_fill(GREY_B)\n",
        "        out_bits = in_bits.copy()\n",
        "        out_bits.move_to(out_image)\n",
        "\n",
        "        out_image_blocker = SurroundingRectangle(out_image)\n",
        "        out_image_blocker.set_fill(BLACK, 1)\n",
        "        out_image_blocker.set_stroke(width=0)\n",
        "\n",
        "        self.add(out_image, out_image_blocker, out_bits, out_words)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    Succession(\n",
        "                        GrowFromPoint(\n",
        "                            out_bit,\n",
        "                            random.choice(bits).get_center(),\n",
        "                        ),\n",
        "                        FadeOut(out_bit),\n",
        "                    )\n",
        "                    for out_bit in out_bits\n",
        "                ],\n",
        "                lag_ratio=3 / len(out_bits),\n",
        "                run_time=12,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                out_image_blocker.stretch, 0, 1, {\"about_edge\": DOWN},\n",
        "                run_time=12,\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "            ),\n",
        "            FadeIn(out_words, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(out_image, in_image),\n",
        "            ReplacementTransform(\n",
        "                in_words.copy().replace(out_words).set_opacity(0),\n",
        "                in_words,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    Succession(\n",
        "                        FadeIn(in_bit),\n",
        "                        Transform(in_bit, random.choice(bits)),\n",
        "                        FadeOut(in_bit),\n",
        "                    )\n",
        "                    for in_bit in in_bits\n",
        "                ],\n",
        "                lag_ratio=3 / len(in_bits),\n",
        "                run_time=12,\n",
        "            ),\n",
        "            GrowArrow(in_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pi Creature\n",
        "        randy = Randolph()\n",
        "        randy.set_height(1.5)\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(2 * LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"maybe\")\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TripleRedundancy(Scene):\n",
        "    def construct(self):\n",
        "        # Show different file types\n",
        "        image = ImageMobject(\"Claude_Shannon\")\n",
        "        image.set_height(6)\n",
        "        image.to_edge(DOWN)\n",
        "        video = ImageMobject(\"ZoeyInGrass\")\n",
        "        video.set_opacity(0)\n",
        "        sound = get_sound_wave()\n",
        "        text = OldTexText(\n",
        "            \"\"\"\n",
        "            Fourscore and seven years ago\\\\\\\\\n",
        "            our fathers brought forth, on this\\\\\\\\\n",
        "            continent, a new nation, conceived\\\\\\\\\n",
        "            in liberty, and dedicated to the\\\\\\\\\n",
        "            proposition that all men are created\\\\\\\\\n",
        "            equal. Now we are engaged$\\\\dots$\n",
        "            \"\"\",\n",
        "            alignment=\"\"\n",
        "        )\n",
        "        code = ImageMobject(\"Hamming_Code_Snippet\")\n",
        "        files = Group(video, sound, text, code, image)\n",
        "        for file in files:\n",
        "            file.match_width(image)\n",
        "            file.move_to(image, UP)\n",
        "\n",
        "        brace = Brace(image, UP)\n",
        "        file_word = OldTexText(\"Original File\")\n",
        "        file_word.set_height(0.5)\n",
        "        file_word.next_to(brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(file_word),\n",
        "            image_reveal_animation(video),\n",
        "        )\n",
        "        video.set_opacity(0)\n",
        "        self.wait(2)\n",
        "        for f1, f2 in zip(files, files[1:]):\n",
        "            self.play(FadeOut(f1), FadeIn(f2))\n",
        "            self.wait()\n",
        "\n",
        "        # Show bits\n",
        "        bits = get_image_bits(image)\n",
        "        for bit, value in zip(bits, string_to_bits(\";)Hi\")):\n",
        "            bit[1 - value].set_opacity(0)\n",
        "            bit[value].set_opacity(1)\n",
        "        bits.generate_target()\n",
        "        bits.target.arrange(RIGHT)\n",
        "        bits.target.set_height(0.5)\n",
        "        bits.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        bits.target.to_edge(LEFT)\n",
        "        bits.target.shift(UP)\n",
        "        last_shown_bit_index = 31\n",
        "        dots = OldTexText(\"\\\\dots\")\n",
        "        dots.next_to(bits.target[last_shown_bit_index], RIGHT, aligned_edge=DOWN, buff=SMALL_BUFF)\n",
        "        new_brace = Brace(VGroup(bits.target[0], dots), UP)\n",
        "        file_rect = SurroundingRectangle(VGroup(bits.target[0], dots))\n",
        "        file_rect.set_stroke(BLUE, 4)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(image),\n",
        "            FadeIn(bits, lag_ratio=1 / len(bits))\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(bits),\n",
        "            Transform(brace, new_brace),\n",
        "            file_word.next_to, new_brace, UP, SMALL_BUFF,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(bits[last_shown_bit_index + 1:last_shown_bit_index + 5]),\n",
        "            FadeIn(dots),\n",
        "            FadeOut(brace),\n",
        "            FadeIn(file_rect),\n",
        "            file_word.next_to, file_rect, UP,\n",
        "        )\n",
        "        self.remove(*bits[last_shown_bit_index + 1:])\n",
        "        bits.remove(*bits[last_shown_bit_index + 1:])\n",
        "        self.add(bits)\n",
        "        self.wait()\n",
        "\n",
        "        # Show redundant copies\n",
        "        bits.add(dots)\n",
        "        copies = VGroup(bits.copy(), bits.copy())\n",
        "        copies.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        copies.next_to(bits, DOWN, buff=MED_SMALL_BUFF)\n",
        "        copies.set_color(BLUE)\n",
        "        copies_rect = SurroundingRectangle(copies, buff=SMALL_BUFF)\n",
        "        copies_rect.set_stroke(BLUE_E, 4)\n",
        "        copies_word = OldTexText(\"Redundant copies\")\n",
        "        copies_word.scale(file_word[0][0].get_height() / copies_word[0][0].get_height())\n",
        "        copies_word.match_color(copies)\n",
        "        copies_word.next_to(copies_rect, DOWN)\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            TransformFromCopy(bits, bits_copy)\n",
        "            for bits_copy in copies\n",
        "        ], lag_ratio=0.5))\n",
        "        self.play(\n",
        "            ShowCreation(copies_rect),\n",
        "            FadeIn(copies_word, UP),\n",
        "            copies.set_color, WHITE,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a correction\n",
        "        flipper_index = 7\n",
        "        flipper = bits[flipper_index]\n",
        "        self.play(\n",
        "            zap_anim(flipper),\n",
        "            toggle_bit_anim(flipper),\n",
        "        )\n",
        "        self.play()\n",
        "        self.wait()\n",
        "\n",
        "        bit_groups = [bits, *copies]\n",
        "        scan_rect = SurroundingRectangle(\n",
        "            VGroup(*[group[0] for group in bit_groups])\n",
        "        )\n",
        "        scan_rect.set_stroke(GREEN, 5)\n",
        "\n",
        "        self.add(scan_rect)\n",
        "        for i in range(flipper_index + 1):\n",
        "            self.play(\n",
        "                scan_rect.match_x, bits[i],\n",
        "                run_time=0.25\n",
        "            )\n",
        "            self.wait(0.25)\n",
        "\n",
        "        bangs = OldTexText(\"!!!\")[0]\n",
        "        bangs.scale(1.5)\n",
        "        bangs.set_color(RED)\n",
        "        bangs.next_to(scan_rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, bangs,\n",
        "                lambda m: (m, DOWN),\n",
        "                run_time=1,\n",
        "            ),\n",
        "            scan_rect.set_color, RED\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        flipper_rect = SurroundingRectangle(flipper, buff=SMALL_BUFF)\n",
        "        flipper_rect.set_stroke(GREEN, 4)\n",
        "        flipper_rect.set_fill(GREEN, 0.5)\n",
        "        self.play(\n",
        "            ReplacementTransform(bangs, flipper_rect)\n",
        "        )\n",
        "        self.play(\n",
        "            toggle_bit_anim(flipper),\n",
        "            FadeOut(flipper_rect),\n",
        "            scan_rect.set_color, GREEN,\n",
        "        )\n",
        "\n",
        "        for i in range(flipper_index + 1, flipper_index + 5):\n",
        "            self.play(\n",
        "                scan_rect.match_x, bits[i],\n",
        "                run_time=0.25\n",
        "            )\n",
        "            self.wait(0.25)\n",
        "        self.play(FadeOut(scan_rect, 0.2 * RIGHT, run_time=0.5))\n",
        "\n",
        "        # Show 2/3 of transmission block\n",
        "        rects = VGroup(file_rect, copies_rect)\n",
        "        rects.generate_target()\n",
        "        for rect, width in zip(rects.target, [1, 2]):\n",
        "            rect.set_width(width, stretch=True)\n",
        "            rect.set_height(0.75, stretch=True)\n",
        "            rect.set_fill(rect.get_stroke_color(), opacity=1)\n",
        "        rects.target[0].set_color(BLUE)\n",
        "        rects.target[1].set_color(BLUE_E)\n",
        "        rects.target.set_stroke(width=0)\n",
        "        rects.target.arrange(RIGHT, buff=0)\n",
        "        rects.target.set_width(12, stretch=True)\n",
        "        rects.target.move_to(UP)\n",
        "\n",
        "        braces = VGroup(*[Brace(rect, UP, buff=SMALL_BUFF) for rect in rects.target])\n",
        "\n",
        "        frac_labels = VGroup(*[\n",
        "            DecimalNumber(100 * frac, unit=\"\\\\%\", num_decimal_places=1)\n",
        "            for frac in [1 / 3, 2 / 3]\n",
        "        ])\n",
        "        for rect, label in zip(rects.target, frac_labels):\n",
        "            label.move_to(rect)\n",
        "\n",
        "        redundancy_word = OldTexText(\"Redundancy\")\n",
        "        redundancy_word.match_height(copies_word)\n",
        "        redundancy_word.match_color(copies_word)\n",
        "        redundancy_word.next_to(braces[1], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            bits.replace, rects.target[0], {\"stretch\": True},\n",
        "            bits.set_opacity, 0,\n",
        "            copies.replace, rects.target[1], {\"stretch\": True},\n",
        "            copies.set_opacity, 0,\n",
        "            MoveToTarget(rects),\n",
        "            LaggedStartMap(GrowFromCenter, braces),\n",
        "            file_word.next_to, braces[0], UP, SMALL_BUFF,\n",
        "            ReplacementTransform(copies_word, redundancy_word),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Write(frac_labels))\n",
        "        self.wait()\n",
        "\n",
        "        # Show failure for some two-bit errors\n",
        "        bits = get_bit_grid(3, 1, [0, 0, 0], height=3, buff=SMALL_BUFF)\n",
        "        bits.next_to(rects, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(bits))\n",
        "        self.play(\n",
        "            LaggedStart(zap_anim(bits[0]), zap_anim(bits[2]), lag_ratio=0.5),\n",
        "            LaggedStart(toggle_bit_anim(bits[0]), toggle_bit_anim(bits[2]), lag_ratio=0.5),\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(bits))\n",
        "\n",
        "        # Shrink bars\n",
        "        rects.generate_target()\n",
        "        p = 9 / 256\n",
        "        rects.target[0].set_width(1 - p, stretch=True)\n",
        "        rects.target[1].set_width(p, stretch=True)\n",
        "        rects.target.arrange(RIGHT, buff=0)\n",
        "        rects.target.match_width(rects, stretch=True)\n",
        "        rects.target.move_to(rects)\n",
        "\n",
        "        braces.generate_target()\n",
        "        for rect, brace in zip(rects.target, braces.target):\n",
        "            brace.become(Brace(rect, UP, buff=SMALL_BUFF, min_num_quads=1))\n",
        "\n",
        "        f_always(frac_labels[0].move_to, rects[0].get_center)\n",
        "        f_always(frac_labels[1].move_to, rects[1].get_center)\n",
        "        rl_width = frac_labels[1].get_width()\n",
        "        f_always(frac_labels[1].set_width, lambda: min(0.95 * rects[1].get_width(), rl_width))\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rects),\n",
        "            MoveToTarget(braces),\n",
        "            ChangeDecimalToValue(frac_labels[0], 100 * (1 - p)),\n",
        "            ChangeDecimalToValue(frac_labels[1], 100 * p),\n",
        "            file_word.next_to, braces.target[0], UP, SMALL_BUFF,\n",
        "            redundancy_word.next_to, braces.target[1], UP, SMALL_BUFF,\n",
        "            redundancy_word.to_edge, RIGHT,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ratio_group = VGroup(rects, braces, frac_labels, file_word, redundancy_word)\n",
        "        ratio_group.clear_updaters()\n",
        "\n",
        "        # Show space division for a (256, 247) Hamming code\n",
        "        bits = get_bit_grid(\n",
        "            16, 16,\n",
        "            bits=string_to_bits(\"There are 10 kinds of people....\"),\n",
        "            buff=0.2, height=5\n",
        "        )\n",
        "        bits.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        bits.shift(2 * LEFT)\n",
        "        ecc_bits = bits[-9:]\n",
        "        ecc_rect = SurroundingRectangle(ecc_bits, buff=0.05)\n",
        "        ecc_rect.set_stroke(BLUE_E, 2)\n",
        "        ecc_rect.set_fill(BLUE_E, 0.5)\n",
        "\n",
        "        block_label = OldTexText(\"256 bit block\")\n",
        "        ecc_label = OldTexText(\"9 redundancy bits\")\n",
        "        message_label = OldTexText(\"247 message bits\")\n",
        "\n",
        "        block_label.next_to(bits, RIGHT, LARGE_BUFF)\n",
        "        block_label.shift(UP)\n",
        "        ecc_label.next_to(ecc_bits, RIGHT, LARGE_BUFF)\n",
        "        ecc_label.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        ecc_label.set_color(BLUE)\n",
        "        message_label.move_to(VGroup(block_label, ecc_label))\n",
        "        message_label.align_to(block_label, LEFT)\n",
        "        message_label.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ratio_group.to_edge, UP,\n",
        "            LaggedStartMap(FadeIn, bits, lag_ratio=1 / len(bits)),\n",
        "            Write(block_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                SurroundingRectangle(bits, color=BLUE, stroke_opacity=0),\n",
        "                ecc_rect\n",
        "            ),\n",
        "            Write(ecc_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                VFadeInThenOut,\n",
        "                bits[:-9].copy().set_fill(color=YELLOW),\n",
        "                lag_ratio=0.1 / len(bits),\n",
        "                run_time=3,\n",
        "            ),\n",
        "            Write(message_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show correction\n",
        "        flipper = random.choice(bits)\n",
        "\n",
        "        self.play(\n",
        "            zap_anim(flipper),\n",
        "            toggle_bit_anim(flipper),\n",
        "        )\n",
        "        self.play(flipper.set_color, RED)\n",
        "\n",
        "        point = bits.get_corner(DL) + 1.5 * LEFT + UP\n",
        "        scanim = scan_anim(point, bits, final_stroke_width=0.2)\n",
        "        lines, robot = scanim.mobject\n",
        "\n",
        "        self.play(scanim)\n",
        "        self.play(*[\n",
        "            Succession(\n",
        "                ApplyMethod(line.put_start_and_end_on, point, flipper.get_center()),\n",
        "                ApplyMethod(line.set_stroke, None, 1)\n",
        "            )\n",
        "            for line in lines\n",
        "        ])\n",
        "        self.play(\n",
        "            toggle_bit_anim(flipper),\n",
        "            FadeOut(lines),\n",
        "            FadeOut(robot),\n",
        "        )\n",
        "        self.play(flipper.set_color, WHITE)\n",
        "\n",
        "        # Show two errors\n",
        "        two_error_label = OldTexText(\"Two errors\")\n",
        "        two_error_label.next_to(bits, LEFT, buff=MED_LARGE_BUFF, aligned_edge=UP)\n",
        "        two_error_label.set_color(RED)\n",
        "\n",
        "        flippers = VGroup(*random.sample(list(bits), 2))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(two_error_label),\n",
        "            LaggedStart(*[zap_anim(f) for f in flippers], lag_ratio=0.5),\n",
        "            LaggedStartMap(toggle_bit_anim, flippers, lag_ratio=0.5),\n",
        "        )\n",
        "        self.play(flippers.set_color, RED)\n",
        "        self.wait()\n",
        "\n",
        "        scanim = scan_anim(point, bits, final_stroke_width=0.2)\n",
        "        bangs = OldTexText(\"!!!\")[0]\n",
        "        bangs.set_color(RED)\n",
        "        bangs.next_to(point, UL, SMALL_BUFF)\n",
        "        q_marks = OldTexText(\"???\")[0]\n",
        "        q_marks.replace(bangs, dim_to_match=1)\n",
        "        q_marks.match_style(bangs)\n",
        "\n",
        "        self.play(scanim)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, bangs,\n",
        "                lambda m: (m, 0.25 * DOWN),\n",
        "                lag_ratio=0.2,\n",
        "                run_time=1,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(bangs, q_marks, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TimeLine(Scene):\n",
        "    def construct(self):\n",
        "        # Time line\n",
        "        decades = list(range(1920, 2030, 10))\n",
        "        timeline = NumberLine(\n",
        "            (decades[0], decades[-1], 2),\n",
        "            big_tick_numbers=decades,\n",
        "            width=13\n",
        "        )\n",
        "        timeline.add_numbers(\n",
        "            decades,\n",
        "            group_with_commas=False,\n",
        "            height=0.2,\n",
        "        )\n",
        "        timeline.numbers.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "        # Events\n",
        "        def get_event(timeline, date, words, direction=UP):\n",
        "            arrow = Vector(-direction)\n",
        "            arrow.set_fill(GREY_A, 0.75)\n",
        "            arrow.shift(timeline.n2p(date) - arrow.get_end())\n",
        "            arrow.shift(SMALL_BUFF * direction)\n",
        "\n",
        "            label = OldTexText(words)\n",
        "            label.scale(0.7)\n",
        "            label.next_to(arrow.get_start(), np.sign(direction[1]) * UP, SMALL_BUFF)\n",
        "            label.set_color(GREY_A)\n",
        "            label.set_stroke(BLACK, 4, background=True)\n",
        "\n",
        "            event = VGroup(label, arrow)\n",
        "            return event\n",
        "\n",
        "        events = VGroup(\n",
        "            get_event(timeline, 1947, \"Hamming codes\", 1.5 * UP),\n",
        "            get_event(timeline, 1948, \"Shannon's paper\\\\\\\\on information theory\", DOWN + 0.2 * LEFT),\n",
        "            # get_event(timeline, 1949, \"Gorlay codes\", 0.7 * UP),\n",
        "            get_event(timeline, 1960, \"Reed-Solomon\\\\\\\\codes\", 0.7 * UP),\n",
        "            get_event(timeline, 1993, \"Turbo codes\", UP),\n",
        "            get_event(timeline, 1995, \"Shor codes\\\\\\\\(quantum)\", DOWN),\n",
        "        )\n",
        "\n",
        "        # Title\n",
        "        title = OldTexText(\"Error correction codes\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.set_height(0.5)\n",
        "        title.to_edge(UP)\n",
        "        title_underline = Underline(title)\n",
        "        title_underline.match_color(title)\n",
        "        title.add(title_underline)\n",
        "        title.fix_in_frame()\n",
        "\n",
        "        # Introduce time line\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.scale(0.5, about_point=timeline.n2p(1945))\n",
        "        frame.shift(0.5 * UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(timeline),\n",
        "            Write(timeline.numbers.copy(), remover=True),\n",
        "            LaggedStart(\n",
        "                *[Animation(Mobject()) for x in range(1)],\n",
        "                *[\n",
        "                    AnimationGroup(\n",
        "                        Write(event[0], run_time=1),\n",
        "                        GrowArrow(event[1]),\n",
        "                    )\n",
        "                    for event in events\n",
        "                ],\n",
        "                lag_ratio=0.75,\n",
        "            ),\n",
        "            FadeIn(title, DOWN),\n",
        "            Restore(frame, run_time=6),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Isolate Hamming\n",
        "        hamming_word = events[0][0]\n",
        "        rs_word = events[2][0]\n",
        "        self.play(\n",
        "            hamming_word.scale, 2, {\"about_edge\": DL},\n",
        "            hamming_word.set_fill, WHITE,\n",
        "            LaggedStart(*[\n",
        "                ApplyMethod(mob.set_opacity, 0.5)\n",
        "                for mob in events[1:]\n",
        "            ]),\n",
        "            FadeOut(VGroup(title, title_underline))\n",
        "        )\n",
        "\n",
        "        invent_words = OldTexText(\"How to invent\")\n",
        "        invent_words.match_height(hamming_word[0][0])\n",
        "        invent_words.next_to(events[0], UP, buff=0.3)\n",
        "        invent_words.set_color(BLUE)\n",
        "\n",
        "        self.play(Write(invent_words))\n",
        "        self.wait()\n",
        "\n",
        "        hamming_word.generate_target()\n",
        "        hamming_word.target.scale(0.5, about_edge=UL)\n",
        "        hamming_word.target.set_opacity(0.5)\n",
        "        hamming_arrow = events[0][1]\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(hamming_word),\n",
        "            FadeOut(invent_words),\n",
        "            hamming_arrow.put_start_and_end_on, hamming_word.target.get_bottom(), hamming_arrow.get_end(),\n",
        "            hamming_arrow.set_opacity, 0.5,\n",
        "            rs_word.scale, 1.5, {\"about_edge\": DOWN},\n",
        "            rs_word.set_opacity, 1,\n",
        "            events[2][1].set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhatCDsActuallyUse(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Vector(2 * RIGHT + UP)\n",
        "        words = OldTexText(\"What CDs/DVDs\\\\\\\\actually use\")\n",
        "        words.next_to(arrow.get_end(), RIGHT)\n",
        "        arrow.set_color(YELLOW)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromPoint(words, arrow.get_start()),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ListOfRelevantMathTopics(Scene):\n",
        "    def construct(self):\n",
        "        topics = VGroup(\n",
        "            OldTexText(\"$L^1$ norm\"),\n",
        "            OldTexText(\"Sphere packing\"),\n",
        "            OldTexText(\"Finite sporadic groups (see Golay codes)\"),\n",
        "            OldTexText(\"Finite fields\"),\n",
        "            OldTexText(\"Galois extensions\"),\n",
        "            OldTexText(\"Lagrange interpolation (see Reed-Solomon)\"),\n",
        "            OldTexText(\"Discrete Fourier Transform\"),\n",
        "            OldTex(\"\\\\dots\")\n",
        "        )\n",
        "        topics.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        brown = interpolate_color(GREY_BROWN, WHITE, 0.25)\n",
        "        for topic, color in zip(topics, it.cycle([BLUE_C, BLUE_D, BLUE_B, brown])):\n",
        "            topic.set_color(color)\n",
        "\n",
        "        topics.move_to(ORIGIN, LEFT)\n",
        "        topics.to_edge(UP)\n",
        "        self.play(topics.shift, (topics.get_width() - 5) * LEFT, run_time=12)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Reinvention(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*3 * [\"pondering\"]),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.student_says(\n",
        "            \"I see where\\\\\\\\this is going\",\n",
        "            index=0,\n",
        "            target_mode=\"tease\",\n",
        "        )\n",
        "        self.look_at(self.students[0].bubble)\n",
        "        self.play(self.students[0].change, \"thinking\")\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class EaterWrapper(Scene):\n",
        "    def construct(self):\n",
        "        bg_rect = FullScreenRectangle()\n",
        "        bg_rect.set_fill(GREY_E, 1)\n",
        "        bg_rect.set_stroke(BLACK, 0)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        title = OldTexText(\"Ben Eater implementing Hamming codes\")\n",
        "        title.set_width(FRAME_WIDTH - 2)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        screen_rect = ScreenRectangle()\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        screen_rect.set_height(6)\n",
        "        screen_rect.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        self.add(screen_rect)\n",
        "\n",
        "        self.add(AnimatedBoundary(screen_rect))\n",
        "        self.wait(16)\n",
        "\n",
        "\n",
        "class DataGettingZapped(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup bit array\n",
        "        # bits = get_bit_grid(50, 100)\n",
        "        bits = get_bit_grid(25, 50)\n",
        "        bits.set_color(GREY_B)\n",
        "        bits.set_height(FRAME_HEIGHT - 0.25)\n",
        "\n",
        "        image = ImageMobject(\"LowResMandelbrot\")\n",
        "        image.replace(bits, dim_to_match=0)\n",
        "\n",
        "        threshold = 0.1\n",
        "        for bit in bits:\n",
        "            try:\n",
        "                rgb = image.point_to_rgb(bit.get_center())\n",
        "                if get_norm(rgb) > threshold:\n",
        "                    value = 1\n",
        "                else:\n",
        "                    value = 0\n",
        "                bit[value].set_opacity(1)\n",
        "                bit[1 - value].set_opacity(0)\n",
        "            except Exception:\n",
        "                pass\n",
        "\n",
        "        self.add(bits)\n",
        "\n",
        "        # Zippity zap\n",
        "        bolt = SVGMobject(\"lightning_bolt\")\n",
        "        bolt[0].add_line_to(bolt[0].get_start())\n",
        "        bolt.set_fill(RED_B, 1)\n",
        "        bolt.set_stroke(width=0)\n",
        "        bolt.set_height(0.5)\n",
        "\n",
        "        def strike_anim(bit, bolt=bolt, **kwargs):\n",
        "            bolt = bolt.copy()\n",
        "            bolt.move_to(bit.get_center(), DL)\n",
        "            bits.remove(bit)\n",
        "            bit.generate_target()\n",
        "            bit.target.set_color(RED)\n",
        "            bit.target.set_stroke(RED, 1)\n",
        "            for sm in bit.target:\n",
        "                sm.set_opacity(1 - sm.get_fill_opacity())\n",
        "\n",
        "            outline = bolt.deepcopy()\n",
        "            outline.set_stroke(RED_D, 2)\n",
        "            outline.set_fill(opacity=0)\n",
        "\n",
        "            return AnimationGroup(\n",
        "                Succession(\n",
        "                    GrowFromPoint(bolt, bolt.get_corner(UR), rate_func=rush_into),\n",
        "                    FadeOut(bolt, run_time=0.5),\n",
        "                ),\n",
        "                Succession(\n",
        "                    ShowCreation(outline),\n",
        "                    FadeOut(outline),\n",
        "                ),\n",
        "                MoveToTarget(bit),\n",
        "            )\n",
        "\n",
        "        for count in range(20):\n",
        "            self.play(LaggedStart(*[\n",
        "                strike_anim(random.choice(bits))\n",
        "                for x in range(int(random.expovariate(0.5)) + 1)\n",
        "            ], lag_ratio=0.25))\n",
        "            self.wait(random.expovariate(2))\n",
        "\n",
        "\n",
        "class AmbientErrorCorrection(Scene):\n",
        "    CONFIG = {\n",
        "        \"N\": 8,\n",
        "        \"bit_grid_height\": 7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        N = self.N\n",
        "        size = (2**(N // 2), 2**(N // 2))\n",
        "        bits = get_bit_grid(\n",
        "            *size,\n",
        "            bits=string_to_bits(\"Claude Shannon was a total boss!\"),\n",
        "            height=self.bit_grid_height,\n",
        "        )\n",
        "        bits.move_to(2 * RIGHT)\n",
        "        point = 2.5 * LEFT + 2.5 * DOWN\n",
        "        last_block = VMobject()\n",
        "\n",
        "        for x in range(10):\n",
        "            block = get_bit_grid(*size, height=self.bit_grid_height)\n",
        "            block.move_to(2 * RIGHT)\n",
        "            syndrome = hamming_syndrome(bit_grid_to_bits(block))\n",
        "\n",
        "            if random.random() < 0.5:\n",
        "                syndrome = 0\n",
        "                toggle_bit(block[syndrome])\n",
        "\n",
        "            scanim = scan_anim(\n",
        "                point, bits,\n",
        "                final_stroke_width=0.2, run_time=3, lag_factor=1,\n",
        "                show_robot=(x == 0),\n",
        "            )\n",
        "            self.play(\n",
        "                FadeIn(block, 6 * RIGHT),\n",
        "                FadeOut(last_block, 6 * LEFT),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.play(scanim, run_time=1)\n",
        "            if syndrome:\n",
        "                flipper = block[syndrome]\n",
        "                bangs = OldTex(\"!!!\")\n",
        "                bangs.scale(2)\n",
        "                bangs.next_to(point, UL)\n",
        "                bangs.set_color(RED)\n",
        "                self.play(\n",
        "                    Write(bangs, run_time=0.5),\n",
        "                    focus_scan_anim_lines(scanim, flipper.get_center()),\n",
        "                    flipper.set_color, RED,\n",
        "                )\n",
        "                self.play(\n",
        "                    toggle_bit_anim(flipper, target_color=WHITE),\n",
        "                    ApplyMethod(scanim.mobject[0].set_stroke, None, 0, 0, remover=True),\n",
        "                    FadeOut(bangs),\n",
        "                )\n",
        "            else:\n",
        "                check = Checkmark()\n",
        "                check.scale(2)\n",
        "                check.next_to(point, UL)\n",
        "                self.play(FadeIn(check, 0.5 * DOWN))\n",
        "                self.play(FadeOut(check), FadeOut(scanim.mobject[0]))\n",
        "            last_block = block\n",
        "\n",
        "\n",
        "class AmbientErrorCorrection6(AmbientErrorCorrection):\n",
        "    CONFIG = {\n",
        "        \"N\": 6\n",
        "    }\n",
        "\n",
        "\n",
        "class AmbientErrorCorrection4(AmbientErrorCorrection):\n",
        "    CONFIG = {\n",
        "        \"N\": 4,\n",
        "        \"bit_grid_height\": 5,\n",
        "    }\n",
        "\n",
        "\n",
        "class ImpossibleToReasonable(Scene):\n",
        "    def construct(self):\n",
        "        group = VGroup(\n",
        "            OldTexText(\"Impossible\"),\n",
        "            Vector(RIGHT, color=GREY_B),\n",
        "            OldTexText(\"Utterly reasonable\"),\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "        group.scale(1.5)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_width(FRAME_WIDTH)\n",
        "        line.set_stroke(GREY, 2)\n",
        "        line.next_to(group, DOWN, SMALL_BUFF)\n",
        "        self.add(line)\n",
        "\n",
        "        self.play(FadeIn(group[0], 0.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(group[1]),\n",
        "            FadeIn(group[2], LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HammingAtBell(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        hamming_image = ImageMobject(\"Richard_Hamming\")\n",
        "        hamming_name = OldTexText(\"Richard Hamming\")\n",
        "        hamming_name.match_width(hamming_image)\n",
        "        hamming_name.next_to(hamming_image, DOWN, MED_SMALL_BUFF)\n",
        "        hamming = Group(hamming_image, hamming_name)\n",
        "        hamming.to_corner(DR)\n",
        "        hamming.shift(2 * LEFT)\n",
        "\n",
        "        bell_logo = ImageMobject(\"BellSystemLogo\")\n",
        "        bell_logo.set_height(3)\n",
        "        bell_logo.next_to(hamming, LEFT, buff=2)\n",
        "        bell_logo.to_edge(UP)\n",
        "\n",
        "        bell_logo_outline = SVGMobject(\"BellSystemLogo\")\n",
        "        bell_logo_outline.match_height(bell_logo)\n",
        "        bell_logo_outline.set_stroke(GREY_B, 1)\n",
        "        bell_logo_outline.set_fill(BLACK, 0)\n",
        "        bell_logo_outline.move_to(bell_logo)\n",
        "\n",
        "        punchcard = SVGMobject(\"punchcard\")\n",
        "        punchcard.set_stroke(width=0)\n",
        "        punchcard.set_fill(GREY_B, 1)\n",
        "        punchcard.next_to(bell_logo, DOWN, LARGE_BUFF)\n",
        "        punchcard.remove(*punchcard[23:])\n",
        "\n",
        "        years = OldTexText(\"1940s\")\n",
        "        years.scale(2)\n",
        "        years.to_edge(UP)\n",
        "\n",
        "        # Introductions\n",
        "        self.play(Write(years))\n",
        "        self.play(FadeIn(hamming[0], RIGHT))\n",
        "        self.play(Write(hamming[1]))\n",
        "        self.play(\n",
        "            FadeOut(years),\n",
        "            ShowCreationThenFadeOut(bell_logo_outline, lag_ratio=0.1, run_time=4),\n",
        "            FadeIn(bell_logo, run_time=3),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(punchcard[0]),\n",
        "            Write(punchcard[1:], lag_ratio=0.5, run_time=4)\n",
        "        )\n",
        "        self.add(punchcard)\n",
        "        self.wait()\n",
        "\n",
        "        # Zap some bits\n",
        "        random.seed(3)\n",
        "        bits = random.sample(list(punchcard[1:]), 4)\n",
        "        for bit in bits:\n",
        "            bit.generate_target()\n",
        "            bit.target.set_color(RED)\n",
        "            if random.random() < 0.5:\n",
        "                bit.target.stretch(0.2, 1, about_edge=DOWN)\n",
        "            else:\n",
        "                bit.target.shift(1.2 * bit.get_width() * LEFT)\n",
        "            self.play(\n",
        "                MoveToTarget(bit),\n",
        "                zap_anim(bit)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Frustration\n",
        "        curse = OldTexText(\"\\\\$*@\\\\#*!!?!\")[0]\n",
        "        curse.set_color(RED)\n",
        "        curse.next_to(hamming, UP)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(curse))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MultiplePerspectives(Scene):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        background = VGroup(*[\n",
        "            Rectangle().set_fill(color, 1)\n",
        "            for color in [GREY_E, BLACK, GREY_E]\n",
        "        ])\n",
        "        background.set_stroke(width=0)\n",
        "        background.arrange(RIGHT, buff=0)\n",
        "        background.set_height(FRAME_HEIGHT)\n",
        "        background.set_width(FRAME_WIDTH, stretch=True)\n",
        "        self.add(background)\n",
        "\n",
        "        # Names\n",
        "        names = VGroup(\n",
        "            OldTexText(\"Parity checks\"),\n",
        "            OldTexText(\"Xor of indices\"),\n",
        "            OldTexText(\"Matrix\"),\n",
        "        )\n",
        "\n",
        "        names.set_height(0.6)\n",
        "        for name, rect in zip(names, background):\n",
        "            name.match_x(rect)\n",
        "        names[0].shift(SMALL_BUFF * DOWN)\n",
        "        names.to_edge(DOWN, buff=1)\n",
        "\n",
        "        # Objects\n",
        "        parity_groups = VGroup()\n",
        "        for n in range(4):\n",
        "            pg = VGroup(*[Square() for x in range(16)])\n",
        "            pg.arrange_in_grid(4, 4, buff=0)\n",
        "            pg.set_height(0.7)\n",
        "            pg.set_stroke(GREY_A, 2)\n",
        "            get_bit_n_subgroup(pg, n).set_fill(BLUE, 0.8)\n",
        "            parity_groups.add(pg)\n",
        "        parity_groups.arrange_in_grid(2, 2)\n",
        "\n",
        "        code = ImageMobject(\"Hamming_Code_Snippet\")\n",
        "\n",
        "        ints = list(random.sample(list(range(16)), 4))\n",
        "        ints.sort()\n",
        "        xor_sum = reduce(op.xor, ints)\n",
        "        bits = [int_to_bit_string(n, n_bits=4) for n in [*ints, xor_sum]]\n",
        "        column = Group(*map(TexText, bits))\n",
        "        column.arrange(DOWN, SMALL_BUFF)\n",
        "        column[-1].set_color(YELLOW)\n",
        "        column[-1].shift(MED_SMALL_BUFF * DOWN)\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_stroke(GREY_B)\n",
        "        line.set_width(column.get_width() + 0.75)\n",
        "        line.move_to(column[-2:], RIGHT)\n",
        "        xor = get_xor()\n",
        "        xor.next_to(line, UP, SMALL_BUFF, LEFT)\n",
        "        column.add(line, xor)\n",
        "        code.set_width(2 * column.get_width())\n",
        "        code.next_to(column, UP)\n",
        "        column.add(code)\n",
        "\n",
        "        matrix = IntegerMatrix(\n",
        "            [\n",
        "               [1, 1, 0, 1],\n",
        "               [1, 0, 1, 1],\n",
        "               [1, 0, 0, 0],\n",
        "               [0, 1, 1, 1],\n",
        "               [0, 1, 0, 0],\n",
        "               [0, 0, 1, 0],\n",
        "               [0, 0, 0, 1],\n",
        "            ],\n",
        "            v_buff=0.6,\n",
        "            h_buff=0.75,\n",
        "        )\n",
        "\n",
        "        objs = Group(parity_groups, column, matrix)\n",
        "\n",
        "        for name, obj in zip(names, objs):\n",
        "            obj.match_width(names[0])\n",
        "            obj.next_to(name, UP, LARGE_BUFF)\n",
        "        matrix.scale(0.7, about_edge=DOWN)\n",
        "\n",
        "        # Introduce\n",
        "        anims = []\n",
        "        for name, obj in zip(names, objs):\n",
        "            anims.append(AnimationGroup(\n",
        "                FadeIn(name, 0.25 * UP),\n",
        "                FadeIn(obj, lag_ratio=0, run_time=2),\n",
        "            ))\n",
        "        self.play(LaggedStart(*anims, lag_ratio=0.4))\n",
        "        self.wait()\n",
        "        for name, obj in zip(names, objs):\n",
        "            obj.add(name)\n",
        "        self.add(background[0])\n",
        "        self.play(\n",
        "            FadeOut(background),\n",
        "            objs[0].set_x, 0,\n",
        "            FadeOut(objs[1], 5 * RIGHT),\n",
        "            FadeOut(objs[2], 2 * RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SetupSixteenBitExample(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = OldTexText(\"Reinventing Hamming Codes\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(BLUE)\n",
        "        self.play(Write(title))\n",
        "\n",
        "        # Simple but not too simple\n",
        "        block = get_bit_grid(4, 4, bits=string_to_bits(\":)\"))\n",
        "        block.move_to(0.5 * DOWN)\n",
        "        top_row = block[:4]\n",
        "        top_row.save_state()\n",
        "        top_row.center()\n",
        "\n",
        "        simple_words = OldTexText(\"Simple\\\\\\\\\", \"but not too\\\\\\\\simple\")\n",
        "        simple_words.scale(1.5)\n",
        "        simple_words.next_to(block[4:12], LEFT, buff=LARGE_BUFF)\n",
        "        top_simp = simple_words[0]\n",
        "        top_simp.save_state()\n",
        "        top_simp.set_y(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(top_simp),\n",
        "            ShowIncreasingSubsets(top_row),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(top_simp),\n",
        "            Restore(top_row),\n",
        "            FadeIn(simple_words[1:]),\n",
        "            LaggedStartMap(FadeIn, block[4:])\n",
        "        )\n",
        "        self.add(block)\n",
        "        self.add(simple_words)\n",
        "\n",
        "        boxes = get_bit_grid_boxes(block, color=GREEN)\n",
        "        bits_word = OldTexText(\"bits\")\n",
        "        bits_word.set_height(0.7)\n",
        "        bits_word.next_to(boxes, LEFT, buff=LARGE_BUFF)\n",
        "        counter = Integer(0, edge_to_fix=RIGHT)\n",
        "        counter.match_height(bits_word)\n",
        "        counter.next_to(bits_word, LEFT, buff=0.35)\n",
        "        bit_count_group = VGroup(bits_word, counter)\n",
        "        bit_count_group.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(simple_words),\n",
        "            FadeIn(bits_word),\n",
        "            UpdateFromAlphaFunc(\n",
        "                counter,\n",
        "                lambda m, a: m.set_fill(opacity=a)\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                counter,\n",
        "                lambda c: c.set_value(len(boxes))\n",
        "            ),\n",
        "            ShowIncreasingSubsets(boxes, run_time=2)\n",
        "        )\n",
        "\n",
        "        # Enumerate bits\n",
        "        block.generate_target()\n",
        "        block.target.space_out_submobjects(1.5)\n",
        "        block.target.center()\n",
        "\n",
        "        new_boxes = get_bit_grid_boxes(block.target, color=GREY_B)\n",
        "        h_buff = get_norm(block.target[0].get_center() - block.target[4].get_center())\n",
        "        for box in new_boxes:\n",
        "            box.set_height(h_buff, stretch=True)\n",
        "\n",
        "        p_labels = VGroup()\n",
        "        for n, box in enumerate(new_boxes):\n",
        "            label = Integer(n)\n",
        "            label.set_height(0.25)\n",
        "            label.set_color(YELLOW)\n",
        "            label.move_to(box, DR)\n",
        "            label.shift(SMALL_BUFF * UL)\n",
        "            p_labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(block),\n",
        "            Transform(boxes, new_boxes),\n",
        "            FadeOut(title, UP),\n",
        "            FadeOut(VGroup(counter, bits_word), LEFT),\n",
        "        )\n",
        "        self.play(FadeIn(p_labels, lag_ratio=0.07, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Data bits\n",
        "        r_boxes = VGroup(*[boxes[2**n] for n in range(4)]).copy()\n",
        "        r_bits = VGroup(*[block[2**n] for n in range(4)])\n",
        "        d_bits = VGroup(*[b for b in block if b not in r_bits])\n",
        "\n",
        "        d_label = OldTexText(\"12 bits\\\\\\\\of data\")\n",
        "        d_label.set_height(1.5)\n",
        "        d_label.next_to(boxes, RIGHT, aligned_edge=UP, buff=LARGE_BUFF)\n",
        "        d_label.set_color(BLUE)\n",
        "\n",
        "        d_lines = VGroup(*[\n",
        "            Line(\n",
        "                d_label.get_left(), bit.get_center(),\n",
        "                color=(TEAL if get_bit_mob_value(bit) else YELLOW)\n",
        "            )\n",
        "            for bit in d_bits\n",
        "        ])\n",
        "        d_lines.set_stroke(width=1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(r_bits),\n",
        "            d_bits.set_color, BLUE,\n",
        "            FadeIn(d_label),\n",
        "            p_labels.set_color, WHITE,\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreationThenFadeOut, d_lines))\n",
        "        self.wait()\n",
        "\n",
        "        # Redundancy bits\n",
        "        r_label = OldTexText(\"4 bits for\\\\\\\\\", \"redundancy\")\n",
        "        r_label.match_height(d_label)\n",
        "        r_label.next_to(boxes, LEFT, aligned_edge=UP, buff=MED_LARGE_BUFF)\n",
        "        r_label.set_color(GREEN)\n",
        "\n",
        "        r_boxes.set_fill(GREEN, 0.5)\n",
        "        self.add(r_boxes, p_labels)\n",
        "        self.play(\n",
        "            FadeIn(r_label, 0.2 * RIGHT),\n",
        "            LaggedStartMap(FadeIn, r_boxes, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Can't cram in copies\n",
        "        d_bit_copies = d_bits.copy()\n",
        "        d_bit_copies.generate_target()\n",
        "        for n, box in enumerate(r_boxes):\n",
        "            group = d_bit_copies.target[3 * n:3 * (n + 1)]\n",
        "            group.arrange_in_grid(2, 2, buff=SMALL_BUFF)\n",
        "            group.set_width(0.4 * box.get_width())\n",
        "            group.move_to(box)\n",
        "            group.set_color(YELLOW)\n",
        "\n",
        "        self.play(ShowCreationThenDestruction(Underline(r_label[1])))\n",
        "        self.play(MoveToTarget(d_bit_copies, lag_ratio=0.1, run_time=4, rate_func=linear))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                d_bit_copies, lambda m, a: m.shift(0.03 * np.sin(7 * TAU * a) * RIGHT).fade(a),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Set true redundancy bits\n",
        "        highlights = boxes.copy()\n",
        "        highlights.set_stroke(YELLOW, 6)\n",
        "\n",
        "        for n in range(4):\n",
        "            h_group = get_bit_n_subgroup(highlights, n)\n",
        "            bit = r_bits[n]\n",
        "            if get_bit_mob_value(bit) == 1:\n",
        "                toggle_bit(bit)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(h_group, lag_ratio=0.2),\n",
        "                FadeIn(bit)\n",
        "            )\n",
        "            anims = [FadeOut(h_group)]\n",
        "            if n in [2, 3]:\n",
        "                anims.append(toggle_bit_anim(bit))\n",
        "            self.play(*anims)\n",
        "\n",
        "        # Might expect them to come at the end\n",
        "        movers = [d_bits, r_bits]\n",
        "        for mover in movers:\n",
        "            mover.save_state()\n",
        "            mover.generate_target()\n",
        "\n",
        "        for b1, b2 in zip(it.chain(d_bits.target, r_bits.target), block):\n",
        "            b1.move_to(b2)\n",
        "\n",
        "        for box, bit in zip(r_boxes, r_bits):\n",
        "            box.bit = bit\n",
        "            box.add_updater(lambda m: m.move_to(m.bit))\n",
        "\n",
        "        self.add(*r_boxes)\n",
        "        self.play(\n",
        "            *[\n",
        "                MoveToTarget(mover, lag_ratio=0.1, run_time=3, path_arc=20 * DEGREES)\n",
        "                for mover in movers\n",
        "            ],\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*[\n",
        "            Restore(mover, lag_ratio=0.1, run_time=3, path_arc=20 * DEGREES)\n",
        "            for mover in movers\n",
        "        ])\n",
        "        r_boxes.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        power_of_2_rects = VGroup(*[\n",
        "            SurroundingRectangle(p_labels[2**n])\n",
        "            for n in range(4)\n",
        "        ])\n",
        "        self.play(LaggedStartMap(ShowCreationThenFadeOut, power_of_2_rects))\n",
        "\n",
        "        # Correct to 11 bits\n",
        "        cross = Cross(d_label[0][:2])\n",
        "        c_label = OldTexText(\"Er...11 bits\")\n",
        "        c_label.match_width(d_label)\n",
        "        c_label.next_to(d_label, DOWN, buff=MED_LARGE_BUFF)\n",
        "        c_label.set_color(RED)\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.replace(block[0])\n",
        "        q_mark.set_color(RED)\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(Write(c_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(block[0]),\n",
        "            Write(q_mark),\n",
        "        )\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DL)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(randy),\n",
        "            randy.change, \"confused\", q_mark\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    def old_functions(self):\n",
        "        # Show redundancy and message\n",
        "        redundancy_words = OldTexText(\"Separate some for\\\\\\\\redundancy\")\n",
        "        redundancy_words.next_to(block[-4:], LEFT, buff=LARGE_BUFF, aligned_edge=UP)\n",
        "        redundancy_words.set_color(BLUE)\n",
        "\n",
        "        vect = redundancy_words.get_center() - bit_count_group.get_center()\n",
        "        self.play(\n",
        "            FadeOut(bit_count_group, vect),\n",
        "            FadeIn(redundancy_words, -vect),\n",
        "            ApplyMethod(boxes[-4:].set_color, BLUE, lag_ratio=0.2),\n",
        "            ApplyMethod(block[-4:].set_color, BLUE, lag_ratio=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        message_words = OldTexText(\"Leave the rest\\\\\\\\for a message\")\n",
        "        message_words.next_to(block[:-4], LEFT)\n",
        "        message_words.match_x(redundancy_words)\n",
        "        message_words.set_color(YELLOW)\n",
        "        message_words.save_state()\n",
        "        message_words.replace(redundancy_words)\n",
        "        message_words.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            Restore(message_words),\n",
        "            boxes[:-4].set_color, YELLOW,\n",
        "        )\n",
        "        for x in range(10):\n",
        "            bits = list(block[:-4])\n",
        "            random.shuffle(bits)\n",
        "            for bit in bits:\n",
        "                if random.random() < 0.5:\n",
        "                    toggle_bit(bit)\n",
        "                self.wait(0.2 / 12)\n",
        "        self.wait()\n",
        "\n",
        "        # Show correction\n",
        "        flipper = random.choice(block)\n",
        "        scanim = scan_anim(\n",
        "            block.get_corner(DR) + 2 * RIGHT, block,\n",
        "            final_stroke_width=0.5,\n",
        "            lag_factor=1,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            zap_anim(flipper),\n",
        "            toggle_bit_anim(flipper, target_color=RED)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(scanim)\n",
        "        self.play(focus_scan_anim_lines(scanim, flipper.get_center()))\n",
        "        self.play(\n",
        "            toggle_bit_anim(flipper, target_color=WHITE),\n",
        "            FadeOut(scanim.mobject)\n",
        "        )\n",
        "\n",
        "\n",
        "class SenderReceiverDynamic(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        # Sender and receiver\n",
        "        sender_word = OldTexText(\"Sender\")\n",
        "        receiver_word = OldTexText(\"Receiver\")\n",
        "        words = VGroup(sender_word, receiver_word)\n",
        "        words.scale(1.5)\n",
        "        words.set_y(-2)\n",
        "        sender_word.to_edge(LEFT)\n",
        "        receiver_word.to_edge(RIGHT)\n",
        "\n",
        "        sender, receiver = pis = self.pi_creatures\n",
        "        for pi, word in zip(pis, words):\n",
        "            pi.set_height(2)\n",
        "            pi.next_to(word, UP)\n",
        "\n",
        "        self.clear()\n",
        "        for pi in pis:\n",
        "            self.play(\n",
        "                VFadeIn(pi),\n",
        "                pi.change, \"pondering\", ORIGIN,\n",
        "            )\n",
        "        for word in words:\n",
        "            self.play(Write(word, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Message\n",
        "        block = get_bit_grid(4, 4)\n",
        "        block.set_height(1.5)\n",
        "        block.next_to(pis[0].get_corner(UR), UR)\n",
        "\n",
        "        self.play(\n",
        "            sender.change, \"raise_right_hand\",\n",
        "            FadeIn(block, DOWN, lag_ratio=0.01),\n",
        "        )\n",
        "        self.add(sender, block)\n",
        "        block.save_state()\n",
        "        self.play(\n",
        "            block.move_to, sender,\n",
        "            block.scale, 0.5,\n",
        "            sender.change, \"gracious\", sender,\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            ApplyMethod(block[1].set_color, GREEN),\n",
        "            toggle_bit_anim(block[2], target_color=GREEN),\n",
        "            ApplyMethod(block[4].set_color, GREEN),\n",
        "            toggle_bit_anim(block[8], target_color=GREEN),\n",
        "        ))\n",
        "        self.wait()\n",
        "        block.generate_target()\n",
        "        block.target.scale(2)\n",
        "        block.target.next_to(receiver, UL)\n",
        "        self.play(\n",
        "            MoveToTarget(block, run_time=3, path_arc=-30 * DEGREES),\n",
        "            receiver.change, \"tease\", receiver.get_corner(UL) + UP,\n",
        "            sender.change, \"happy\", receiver.get_corner(UL) + UP,\n",
        "        )\n",
        "        self.play(scan_anim(receiver.get_corner(UL), block, lag_factor=1, show_robot=False))\n",
        "        self.wait()\n",
        "\n",
        "        # Replace with machines\n",
        "        underlines = VGroup(*[Underline(word) for word in words])\n",
        "        underlines.set_color(YELLOW)\n",
        "        servers = VGroup(*[SVGMobject(\"server_stack\") for x in range(2)])\n",
        "        servers.set_color(GREY)\n",
        "        servers.set_stroke(BLACK, 2)\n",
        "        servers.set_gloss(0.5)\n",
        "        for server, pi in zip(servers, pis):\n",
        "            server.move_to(pi)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreationThenFadeOut, underlines, lag_ratio=0.7),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"thinking\", pi)\n",
        "                for pi in pis\n",
        "            ],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *it.chain(*[\n",
        "                [\n",
        "                    pi.change, \"horrified\",\n",
        "                    pi.shift, 2 * UP,\n",
        "                    pi.set_opacity, 0\n",
        "                ]\n",
        "                for pi in pis\n",
        "            ]),\n",
        "            FadeIn(servers, 2 * DOWN)\n",
        "        )\n",
        "        self.remove(pis)\n",
        "\n",
        "        bits_copy = block.copy()\n",
        "        bits_copy.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        bits_copy.set_width(0.7 * servers[1].get_width())\n",
        "        bits_copy.move_to(servers[1], LEFT)\n",
        "        bits_copy.shift(SMALL_BUFF * RIGHT)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(b1, b2)\n",
        "                for b1, b2 in zip(block, bits_copy)\n",
        "            ], run_time=3),\n",
        "        )\n",
        "\n",
        "        # Sent and received\n",
        "        sent_block = block.copy()\n",
        "        sent_block.next_to(servers[0], UR)\n",
        "        sent_block.match_y(block)\n",
        "        wire = VGroup(\n",
        "            SurroundingRectangle(sent_block),\n",
        "            Line(sent_block.get_right(), block.get_left(), buff=SMALL_BUFF / 2),\n",
        "            SurroundingRectangle(block),\n",
        "        )\n",
        "        wire.set_stroke(GREY, 2)\n",
        "        noise_word = OldTexText(\"Potential noise\")\n",
        "        noise_word.scale(0.75)\n",
        "        noise_word.set_color(RED)\n",
        "        noise_word.next_to(wire[1], UP, SMALL_BUFF)\n",
        "\n",
        "        small_words = VGroup(\n",
        "            OldTexText(\"sent\"),\n",
        "            OldTexText(\"received\"),\n",
        "        )\n",
        "        for word, mob in zip(small_words, [sent_block, block]):\n",
        "            word.next_to(mob, UP, buff=0.35)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(wire[0]),\n",
        "            FadeIn(small_words[0], 0.5 * DOWN),\n",
        "            FadeIn(sent_block),\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(sent_block.copy(), block, remover=True, lag_ratio=0.01),\n",
        "            ShowCreation(wire[1]),\n",
        "            FadeIn(noise_word, lag_ratio=0.1)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(wire[2]),\n",
        "            FadeIn(small_words[1], 0.5 * DOWN)\n",
        "        )\n",
        "\n",
        "        # Past and future\n",
        "        cross_lines = VGroup(*[\n",
        "            Line(\n",
        "                word.get_left(), word.get_right(),\n",
        "                stroke_width=5,\n",
        "                stroke_color=RED,\n",
        "            )\n",
        "            for word in words\n",
        "        ])\n",
        "        time_words = VGroup(\n",
        "            OldTexText(\"Past\"),\n",
        "            OldTexText(\"Future\"),\n",
        "        )\n",
        "        time_words.set_color(BLUE)\n",
        "        for w1, w2 in zip(words, time_words):\n",
        "            w2.match_height(w1)\n",
        "            w2.next_to(w1, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, cross_lines, lag_ratio=0.7),\n",
        "            LaggedStartMap(ApplyMethod, words, lambda m: (m.set_opacity, 0.75), lag_ratio=0.7),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, time_words, lambda m: (m, UP), lag_ratio=0.3)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        return VGroup(Randolph(), Mortimer())\n",
        "\n",
        "\n",
        "class ParityChecks(Scene):\n",
        "    def construct(self):\n",
        "        # Show detection\n",
        "        block = get_bit_grid(4, 4, bits=string_to_bits(\":)\"))\n",
        "        block.move_to(3 * LEFT)\n",
        "        point = block.get_corner(DR) + 2 * RIGHT + UP\n",
        "        scanim = scan_anim(point, block, final_stroke_width=0.5, run_time=2, lag_factor=2)\n",
        "        lines, robot = scanim.mobject\n",
        "        detection_words = OldTexText(\"Error detected!\")\n",
        "        detection_words.set_color(RED)\n",
        "        detection_subwords = OldTexText(\"But I have no idea where!\")\n",
        "        detection_words.next_to(robot.get_top(), UR, SMALL_BUFF)\n",
        "        detection_subwords.move_to(detection_words, DL)\n",
        "\n",
        "        self.add(block)\n",
        "        self.play(scanim)\n",
        "        self.play(\n",
        "            GrowFromPoint(detection_words, robot.get_top())\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            detection_words.shift, 0.75 * UP,\n",
        "            FadeIn(detection_subwords, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        title = OldTexText(\"Parity Check\")[0]\n",
        "        title.set_color(YELLOW)\n",
        "        title.set_stroke(BLACK, 3, background=True)\n",
        "        title.add(Underline(title).shift(0.05 * UP))\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(scanim.mobject),\n",
        "                FadeOut(detection_words),\n",
        "                FadeOut(detection_subwords),\n",
        "            ),\n",
        "            block.move_to, DOWN,\n",
        "        )\n",
        "\n",
        "        # Single bit vs. message\n",
        "        pb_rect = SurroundingRectangle(block[0])\n",
        "        pb_rect.set_stroke(GREEN, 3)\n",
        "        ms_rect = SurroundingRectangle(block)\n",
        "        ms_blob = Polygon(\n",
        "            pb_rect.get_corner(UR) + 0.05 * RIGHT,\n",
        "            ms_rect.get_corner(UR),\n",
        "            ms_rect.get_corner(DR),\n",
        "            ms_rect.get_corner(DL),\n",
        "            pb_rect.get_corner(DL) + 0.05 * DOWN,\n",
        "            pb_rect.get_corner(DR) + 0.05 * DR,\n",
        "        )\n",
        "        ms_blob.set_stroke(BLUE, 3)\n",
        "\n",
        "        pb_words = OldTexText(\"Reserve one special bit\")\n",
        "        pb_words.next_to(pb_rect, LEFT)\n",
        "        pb_words.match_color(pb_rect)\n",
        "        ms_words = OldTexText(\"The rest carry\\\\\\\\a message\", alignment=\"\")\n",
        "        ms_words.next_to(ms_blob, RIGHT, aligned_edge=UP)\n",
        "        ms_words.align_to(pb_words, UP)\n",
        "        ms_words.match_color(ms_blob)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pb_words),\n",
        "            ShowCreation(pb_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(ms_words),\n",
        "            ShowCreation(ms_blob),\n",
        "        )\n",
        "\n",
        "        # Wave of flips\n",
        "        k = 3\n",
        "        for n in range(1, len(block) + k):\n",
        "            if n < len(block):\n",
        "                toggle_bit(block[n])\n",
        "            if 1 <= n - k < len(block):\n",
        "                toggle_bit(block[n - k])\n",
        "            self.wait(0.05)\n",
        "\n",
        "        # Count 1's\n",
        "        number_ones_label = OldTexText(\"\\\\# \", \"of 1's: \")\n",
        "        number_ones_label.set_height(0.7)\n",
        "        number_ones_label.to_edge(UP)\n",
        "        number_ones_label.shift(LEFT)\n",
        "\n",
        "        one_rects = get_one_rects(block)\n",
        "        one_counter = get_ones_counter(number_ones_label, one_rects)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(number_ones_label, DOWN),\n",
        "            FadeOut(title, UP),\n",
        "        )\n",
        "        self.add(one_counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects, run_time=1, rate_func=bezier([0, 0, 1, 1])))\n",
        "        self.wait()\n",
        "\n",
        "        # Show need to flip\n",
        "        want_even_label = OldTexText(\"Want this\\\\\\\\to be even\")\n",
        "        want_even_label.next_to(one_counter, RIGHT, buff=1.5)\n",
        "        want_even_arrow = Arrow(\n",
        "            want_even_label.get_left(), one_counter.get_right()\n",
        "        )\n",
        "        want_even_label.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(want_even_arrow),\n",
        "            FadeIn(want_even_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Indicate, one_rects,\n",
        "                scale_factor=1.1,\n",
        "                color=RED,\n",
        "                lag_ratio=0.2,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pb = block[0]\n",
        "        pb_center = pb.get_center()\n",
        "\n",
        "        self.play(pb.next_to, pb_words, DOWN)\n",
        "        self.play(toggle_bit_anim(pb))\n",
        "        self.play(pb.move_to, pb_center)\n",
        "        one_rects.become(get_one_rects(block))\n",
        "        self.play(DrawBorderThenFill(one_rects[0]))\n",
        "\n",
        "        # Show case with no need to flip\n",
        "        self.play(\n",
        "            FadeOut(block),\n",
        "            FadeOut(one_rects),\n",
        "            FadeOut(one_counter),\n",
        "        )\n",
        "        new_block = get_bit_grid(4, 4, bits=string_to_bits(\"<3\"))\n",
        "        new_block.replace(block)\n",
        "        block = new_block\n",
        "        self.play(ShowIncreasingSubsets(block))\n",
        "        one_rects = get_one_rects(block)\n",
        "        one_counter = get_ones_counter(number_ones_label, one_rects)\n",
        "        self.add(one_counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        check = Checkmark()\n",
        "        check.scale(2)\n",
        "        check.next_to(pb, UP)\n",
        "        self.play(Write(check, run_time=0.5))\n",
        "        self.play(FadeOut(check))\n",
        "        self.wait()\n",
        "\n",
        "        # Sender and receiver\n",
        "        self.play(LaggedStart(*map(FadeOut, [\n",
        "            number_ones_label, one_counter,\n",
        "            want_even_arrow, want_even_label,\n",
        "            pb_words, pb_rect,\n",
        "            ms_words, ms_blob,\n",
        "            one_rects\n",
        "        ])))\n",
        "\n",
        "        pis, names = get_sender_and_receiver()\n",
        "        sender, receiver = pis\n",
        "\n",
        "        block.generate_target()\n",
        "        block.target.scale(0.5)\n",
        "        block.target.next_to(sender, UR)\n",
        "        r_block = block.target.copy()\n",
        "        r_block.next_to(receiver, UL)\n",
        "        n_block = r_block.copy()\n",
        "        n_block.move_to(VGroup(block.target, r_block))\n",
        "        arrows = VGroup(\n",
        "            Arrow(block.target.get_right(), n_block.get_left()),\n",
        "            Arrow(n_block.get_right(), r_block.get_left()),\n",
        "        )\n",
        "        noise_word = OldTexText(\"Noise\")\n",
        "        noise_arrow = Vector(0.7 * DOWN)\n",
        "        noise_arrow.next_to(n_block, UP)\n",
        "        noise_word.next_to(noise_arrow, UP)\n",
        "        noise_label = VGroup(noise_word, noise_arrow)\n",
        "        noise_label.set_color(RED)\n",
        "        flipper_index = 7\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(sender.change, \"raise_right_hand\", block.target),\n",
        "            VFadeIn(sender),\n",
        "            FadeIn(names),\n",
        "            FadeIn(receiver),\n",
        "            MoveToTarget(block),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(block, n_block),\n",
        "            GrowArrow(arrows[0]),\n",
        "            FadeIn(noise_label),\n",
        "        )\n",
        "        self.play(\n",
        "            toggle_bit_anim(n_block[flipper_index], target_color=RED),\n",
        "            zap_anim(n_block[flipper_index]),\n",
        "        )\n",
        "        toggle_bit(r_block[flipper_index])\n",
        "        self.play(\n",
        "            TransformFromCopy(n_block, r_block),\n",
        "            GrowArrow(arrows[1]),\n",
        "            receiver.change, \"pondering\", r_block,\n",
        "        )\n",
        "\n",
        "        # Recount the 1's\n",
        "        blocks = (block, r_block)\n",
        "        one_rects_pair = VGroup(*[get_one_rects(b, buff=0.05) for b in blocks])\n",
        "        label_pair = VGroup(*[\n",
        "            OldTexText(\"\\\\#\", \" 1's:\").next_to(b, UP, buff=MED_LARGE_BUFF)\n",
        "            for b in blocks\n",
        "        ])\n",
        "        one_counter_pair = VGroup(*[\n",
        "            get_ones_counter(label, rect, buff=MED_SMALL_BUFF)\n",
        "            for label, rect in zip(label_pair, one_rects_pair)\n",
        "        ])\n",
        "\n",
        "        self.add(label_pair, one_counter_pair)\n",
        "        self.play(*[\n",
        "            ShowIncreasingSubsets(group)\n",
        "            for group in one_rects_pair\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        bangs = OldTex(\"!!!\")\n",
        "        bangs.set_color(RED)\n",
        "        bangs.next_to(receiver, UP)\n",
        "        self.play(\n",
        "            FadeIn(bangs, DOWN),\n",
        "            receiver.change, \"horrified\", r_block,\n",
        "        )\n",
        "        self.play(Blink(receiver))\n",
        "        self.wait()\n",
        "\n",
        "        # Define parity and parity bit\n",
        "        parity_rects = VGroup(\n",
        "            SurroundingRectangle(VGroup(block, one_counter_pair[0]), buff=MED_SMALL_BUFF),\n",
        "            SurroundingRectangle(VGroup(r_block, one_counter_pair[1]), buff=MED_SMALL_BUFF),\n",
        "        )\n",
        "        parity_rects[0].set_stroke(BLUE, 2)\n",
        "        parity_rects[1].set_stroke(RED, 2)\n",
        "\n",
        "        parity_labels = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"Parity: \", word,\n",
        "                tex_to_color_map={word: color}\n",
        "            ).next_to(rect, UP)\n",
        "            for word, color, rect in zip(\n",
        "                [\"Even\", \"Odd\"],\n",
        "                [BLUE, RED],\n",
        "                parity_rects,\n",
        "            )\n",
        "        ])\n",
        "\n",
        "        for label, rect in zip(parity_labels, parity_rects):\n",
        "            self.play(\n",
        "                FadeIn(label, DOWN),\n",
        "                ShowCreation(rect),\n",
        "            )\n",
        "        self.play(LaggedStart(*[\n",
        "            ShowCreationThenFadeOut(Underline(label[0], color=YELLOW))\n",
        "            for label in parity_labels\n",
        "        ], lag_ratio=0.3))\n",
        "        self.wait()\n",
        "        self.play(Blink(sender))\n",
        "        self.play(Blink(receiver))\n",
        "        for bit, label, rect in zip([0, 1], parity_labels, parity_rects):\n",
        "            bit_mob = get_bit_grid(1, 1, bits=[bit])[0]\n",
        "            bit_mob.match_height(label[1])\n",
        "            bit_mob.match_color(label[1])\n",
        "            bit_mob.move_to(label[1], LEFT)\n",
        "            x_shift = (rect.get_center() - VGroup(label[0], bit_mob).get_center()) * RIGHT\n",
        "            bit_mob.shift(x_shift)\n",
        "            self.play(\n",
        "                label[1].replace, bit_mob, {\"stretch\": True},\n",
        "                label[1].set_opacity, 0,\n",
        "                FadeIn(bit_mob),\n",
        "                label[0].shift, x_shift,\n",
        "            )\n",
        "            label.replace_submobject(1, bit_mob)\n",
        "\n",
        "        pb_rect = SurroundingRectangle(block[0], buff=0.05)\n",
        "        pb_rect.set_stroke(GREEN, 3)\n",
        "        pb_label = OldTexText(\"Parity bit\")\n",
        "        pb_label.move_to(pb_rect)\n",
        "        pb_label.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        pb_label.shift(UP)\n",
        "        pb_label.match_color(pb_rect)\n",
        "        pb_arrow = Arrow(\n",
        "            pb_label.get_bottom() + SMALL_BUFF * DOWN,\n",
        "            pb_rect.get_left(),\n",
        "            buff=SMALL_BUFF,\n",
        "            fill_color=GREEN\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(pb_label, run_time=1),\n",
        "            GrowArrow(pb_arrow),\n",
        "            ShowCreation(pb_rect),\n",
        "        )\n",
        "        for color in [RED, BLUE]:\n",
        "            self.play(\n",
        "                toggle_bit_anim(block[0]),\n",
        "                toggle_bit_anim(parity_labels[0][1], target_color=color),\n",
        "                parity_rects[0].set_color, color,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        parity_descriptors = VGroup(\n",
        "            parity_rects, parity_labels,\n",
        "            pb_rect, pb_label, pb_arrow,\n",
        "        )\n",
        "        self.play(FadeOut(parity_descriptors, lag_ratio=0.1))\n",
        "\n",
        "        # More than 1 error\n",
        "        new_filpper_indices = [8, 13]\n",
        "        n_flippers = VGroup(*[n_block[fi] for fi in new_filpper_indices])\n",
        "        r_flippers = VGroup(*[r_block[fi] for fi in new_filpper_indices])\n",
        "        for bit in r_flippers:\n",
        "            toggle_bit(bit)\n",
        "        new_one_rects_pair = VGroup(*[get_one_rects(b, buff=0.05) for b in blocks])\n",
        "        new_one_counter_pair = VGroup(*[\n",
        "            get_ones_counter(label, rect, buff=MED_SMALL_BUFF)\n",
        "            for label, rect in zip(label_pair, new_one_rects_pair)\n",
        "        ])\n",
        "        for bit in r_flippers:\n",
        "            toggle_bit(bit)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                toggle_bit_anim, n_flippers,\n",
        "                target_color=RED,\n",
        "            ),\n",
        "            LaggedStartMap(toggle_bit_anim, r_flippers),\n",
        "            LaggedStart(*map(zap_anim, n_flippers)),\n",
        "            receiver.change, \"maybe\",\n",
        "            FadeOut(one_rects_pair[1]),\n",
        "            FadeOut(one_counter_pair[1]),\n",
        "        )\n",
        "        self.remove(one_rects_pair, one_counter_pair)\n",
        "        one_rects_pair = new_one_rects_pair\n",
        "        one_counter_pair = new_one_counter_pair\n",
        "        self.add(one_rects_pair, one_counter_pair)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(one_rects_pair[1])\n",
        "        )\n",
        "\n",
        "        for x in range(2):\n",
        "            self.play(Blink(receiver))\n",
        "            self.play(Blink(sender))\n",
        "            self.wait()\n",
        "\n",
        "        # Even number of errors\n",
        "        self.play(\n",
        "            FadeOut(one_rects_pair[1]),\n",
        "            FadeOut(one_counter_pair[1]),\n",
        "            FadeOut(bangs),\n",
        "            receiver.change, \"pondering\", r_block,\n",
        "        )\n",
        "        temp_rect = SurroundingRectangle(\n",
        "            n_flippers[1],\n",
        "            buff=0.05,\n",
        "            color=GREEN,\n",
        "        )\n",
        "        temp_rect.flip()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(temp_rect),\n",
        "            toggle_bit_anim(n_flippers[1], target_color=WHITE),\n",
        "            toggle_bit_anim(r_flippers[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(receiver))\n",
        "\n",
        "        one_counter_pair.set_opacity(1)\n",
        "        self.add(one_counter_pair)\n",
        "        one_rects_pair[1].set_submobjects(\n",
        "            get_one_rects(r_block, buff=0.05).submobjects\n",
        "        )\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(one_rects_pair[1])\n",
        "        )\n",
        "        self.play(receiver.change, \"hooray\", r_block)\n",
        "        self.wait()\n",
        "        self.play(receiver.change, \"erm\")\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ChangeAnywhereToOneBit(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title = VGroup(\n",
        "            OldTexText(\"Change anywhere\"),\n",
        "            Vector(RIGHT),\n",
        "            OldTexText(\"One bit of information\"),\n",
        "        )\n",
        "        title.arrange(RIGHT)\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        grid = get_bit_grid(4, 4)\n",
        "        grid.set_height(4)\n",
        "        grid.match_x(title[0])\n",
        "        grid.set_y(-1)\n",
        "        self.add(grid)\n",
        "\n",
        "        one_rects = get_one_rects(grid)\n",
        "        self.add(one_rects)\n",
        "\n",
        "        parity_words = VGroup(\n",
        "            OldTexText(\"Even \\\\# of 1s\", color=BLUE_B),\n",
        "            OldTexText(\"Odd \\\\# of 1s\", color=TEAL_D),\n",
        "        )\n",
        "        parity_words.scale(1.5)\n",
        "        parity_words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        parity_words.match_x(title[2])\n",
        "        parity_words.match_y(grid)\n",
        "        self.add(parity_words)\n",
        "\n",
        "        def get_parity_rect(n, words=parity_words):\n",
        "            return SurroundingRectangle(words[n % 2])\n",
        "\n",
        "        p_rect = get_parity_rect(len(one_rects))\n",
        "        self.add(p_rect)\n",
        "\n",
        "        # Random changes\n",
        "        for x in range(10):\n",
        "            bit = random.choice(grid)\n",
        "            self.play(toggle_bit_anim(bit))\n",
        "            one_rects.set_submobjects(get_one_rects(grid))\n",
        "            p_rect.become(get_parity_rect(len(one_rects)))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class OddNumberCountTo101(Scene):\n",
        "    def construct(self):\n",
        "        group = VGroup(\n",
        "            *[Integer(2 * n + 1) for n in range(1, 50)],\n",
        "        )\n",
        "        group.set_color(RED)\n",
        "        group.scale(2)\n",
        "        for mob in group[:2]:\n",
        "            self.add(mob)\n",
        "            self.wait()\n",
        "            self.remove(mob)\n",
        "        self.play(ShowSubmobjectsOneByOne(group[2:]), run_time=6, rate_func=bezier([0, 0, 1, 1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ComplainAboutParityCheckWeakness(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.embed()\n",
        "\n",
        "        self.screen.set_fill(BLACK, 1)\n",
        "        self.add(self.screen)\n",
        "\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                self.students[1],\n",
        "                \"Wait, it fails\\\\\\\\for two flips?\",\n",
        "                target_mode=\"sassy\",\n",
        "                bubble_config={\n",
        "                    \"height\": 3,\n",
        "                    \"width\": 3,\n",
        "                }\n",
        "            ),\n",
        "            self.teacher.change, \"guilty\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                self.students[2], \"Weak!\",\n",
        "                target_mode=\"angry\",\n",
        "                bubble_config={\"direction\": LEFT}\n",
        "            ),\n",
        "            self.students[0].change, \"hesitant\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.teacher.change, \"tease\")\n",
        "        self.wait()\n",
        "        self.play_student_changes(\n",
        "            \"thinking\", \"pondering\", \"pondering\",\n",
        "            look_at=self.screen,\n",
        "            added_anims=[\n",
        "                FadeOut(self.students[1].bubble),\n",
        "                FadeOut(self.students[1].bubble.content),\n",
        "                FadeOut(self.students[2].bubble),\n",
        "                FadeOut(self.students[2].bubble.content),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ArrayOfValidMessages(Scene):\n",
        "    def construct(self):\n",
        "        # Messages\n",
        "        title = OldTexText(\"All possible messages\")\n",
        "        title.to_edge(UP)\n",
        "        nr = 22\n",
        "        nc = 46\n",
        "        dots = VGroup(*[Dot() for x in range(nr * nc)])\n",
        "        dots.arrange_in_grid(nr, nc)\n",
        "        dots.set_color(GREY_C)\n",
        "        dots.set_height(6)\n",
        "        dots.to_edge(DOWN)\n",
        "        shuffled_dots = dots.copy()\n",
        "        shuffled_dots.shuffle()\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(Write(shuffled_dots, remover=True, run_time=6, lag_ratio=5 / len(dots)))\n",
        "        self.add(dots)\n",
        "        self.wait()\n",
        "\n",
        "        # Valid messages\n",
        "        subset = OldTex(\"\\\\subset\")\n",
        "        subset.set_height(0.4)\n",
        "        subset.to_edge(UP)\n",
        "        valid_label = OldTexText(\"Valid messages\")\n",
        "        valid_label.set_color(YELLOW)\n",
        "        valid_label.next_to(subset, LEFT)\n",
        "\n",
        "        valid_dots = VGroup()\n",
        "        for row in range(0, nr, 3):\n",
        "            for col in range(0, nc, 3):\n",
        "                valid_dot = dots[row * nc + col]\n",
        "                valid_dot.generate_target()\n",
        "                valid_dot.target.scale(2)\n",
        "                valid_dot.target.set_color(YELLOW)\n",
        "                valid_dots.add(valid_dot)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, valid_dots, run_time=3),\n",
        "            Write(subset),\n",
        "            FadeIn(valid_label, LEFT),\n",
        "            title.next_to, subset, RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Words analogy\n",
        "        example_words = VGroup(\n",
        "            OldTexText(\"Hello world\", color=YELLOW),\n",
        "            OldTexText(\"Helho world\", color=GREY_B),\n",
        "        )\n",
        "        example_words.scale(1.25)\n",
        "        index = 12 * nc + 21\n",
        "        example_dots = VGroup(dots[index], dots[index + 1]).copy()\n",
        "\n",
        "        example_groups = VGroup()\n",
        "        for word, dot in zip(example_words, example_dots):\n",
        "            arrow = Vector(0.7 * DOWN)\n",
        "            arrow.next_to(dot, UP, SMALL_BUFF)\n",
        "            word.next_to(arrow, UP, SMALL_BUFF)\n",
        "            example_group = VGroup(word, arrow, dot)\n",
        "            example_groups.add(example_group)\n",
        "\n",
        "        fade_rect = SurroundingRectangle(dots)\n",
        "        fade_rect.set_stroke(BLACK, 0)\n",
        "        fade_rect.set_fill(BLACK, 0.7)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            FadeIn(example_groups[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            zap_anim(example_words[0][0][3:5]),\n",
        "            Transform(*example_groups),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(example_groups[0]), FadeOut(fade_rect))\n",
        "\n",
        "        # Corrections\n",
        "        valid_centers = [vd.get_center() for vd in valid_dots]\n",
        "        lines = VGroup()\n",
        "        for dot in dots:\n",
        "            dc = dot.get_center()\n",
        "            norms = [get_norm(dc - vc) for vc in valid_centers]\n",
        "            line = Line(dc, valid_centers[np.argmin(norms)])\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            lines.add(line)\n",
        "\n",
        "        shuffled_lines = VGroup(*lines)\n",
        "        shuffled_lines.shuffle()\n",
        "\n",
        "        self.play(ShowCreation(shuffled_lines, lag_ratio=10 / len(lines), run_time=5))\n",
        "        self.wait()\n",
        "\n",
        "        # Mandering path between valid messages\n",
        "        self.add(fade_rect, valid_dots)\n",
        "        self.play(FadeIn(fade_rect))\n",
        "\n",
        "        path = [RIGHT, UP, UP, RIGHT, RIGHT, RIGHT, UP, UP, RIGHT, RIGHT, DOWN]\n",
        "        dist = get_norm(dots[1].get_center() - dots[0].get_center())\n",
        "        curr = dots[index].get_center()\n",
        "        arrows = VGroup()\n",
        "        for vect in path:\n",
        "            new = curr + dist * vect\n",
        "            arrows.add(Arrow(curr, new, buff=0, fill_color=RED))\n",
        "            curr = new\n",
        "\n",
        "        for arrow in arrows:\n",
        "            self.play(GrowArrow(arrow), run_time=0.5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RobustForLessThanNErrors(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Robust for \", \"$\\\\le N$\", \" errors\",\n",
        "        )\n",
        "        words.to_edge(UP)\n",
        "        words[1].set_color(YELLOW)\n",
        "        words[2].shift(0.15 * RIGHT)\n",
        "        N = words[1][-1]\n",
        "\n",
        "        num = Integer(1)\n",
        "        num.set_color(YELLOW)\n",
        "        num.move_to(N, LEFT)\n",
        "        num.set_value(1)\n",
        "\n",
        "        self.play(Write(words, run_time=2))\n",
        "        self.wait()\n",
        "        self.remove(N)\n",
        "        self.add(num)\n",
        "        self.play(ChangeDecimalToValue(num, 20, run_time=3))\n",
        "        self.remove(num)\n",
        "        self.add(N)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwentyQuestions(Scene):\n",
        "    def construct(self):\n",
        "        # Hamming's insight\n",
        "        bits = [\n",
        "            1, 0, 0, 1,\n",
        "            0, 1, 0, 0,\n",
        "            0, 1, 0, 1,\n",
        "            1, 0, 1, 1,\n",
        "        ]\n",
        "        block = get_bit_grid(4, 4, bits=bits)\n",
        "\n",
        "        hamming = ImageMobject(\"Richard_Hamming\")\n",
        "        hamming.set_height(3)\n",
        "        hamming.to_corner(DL)\n",
        "\n",
        "        bulb = Lightbulb()\n",
        "        bulb.next_to(hamming.get_corner(UR), UP)\n",
        "\n",
        "        self.add(block)\n",
        "        self.play(FadeIn(hamming, 0.5 * RIGHT))\n",
        "        self.play(Write(bulb, run_time=1, stroke_width=5))\n",
        "        self.wait()\n",
        "\n",
        "        # Preview parity checks\n",
        "        parity_word = OldTexText(\"Parity check\")\n",
        "        parity_word.set_height(0.7)\n",
        "        parity_word.set_color(BLUE)\n",
        "        parity_word.move_to(block, UP)\n",
        "        parity_word.set_opacity(0)\n",
        "\n",
        "        back_rects = VGroup(*[\n",
        "            SurroundingRectangle(bit, buff=MED_SMALL_BUFF / 2).scale(0)\n",
        "            for bit in get_bit_n_subgroup(block, 0)\n",
        "        ])\n",
        "        back_rects.set_stroke(width=0)\n",
        "        back_rects.set_fill(BLUE_E, 1)\n",
        "\n",
        "        last_one_rects = VMobject()\n",
        "\n",
        "        self.add(back_rects, block)\n",
        "\n",
        "        for n, vect in zip(it.count(), [UP, UP, RIGHT, RIGHT]):\n",
        "            block.generate_target()\n",
        "            block.target.set_color(WHITE)\n",
        "            color_group = get_bit_n_subgroup(block.target, n)\n",
        "            color_group.set_color(BLUE)\n",
        "            one_rects = get_one_rects(color_group)\n",
        "\n",
        "            rects = VGroup(*[\n",
        "                SurroundingRectangle(bit, buff=MED_SMALL_BUFF / 2)\n",
        "                for bit in color_group\n",
        "            ])\n",
        "            rects.match_style(back_rects)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(last_one_rects),\n",
        "                MoveToTarget(block),\n",
        "                parity_word.next_to, color_group, vect, MED_LARGE_BUFF,\n",
        "                parity_word.set_opacity, 1,\n",
        "                Transform(back_rects, rects),\n",
        "            )\n",
        "            self.play(ShowIncreasingSubsets(one_rects))\n",
        "            last_one_rects = one_rects\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(back_rects),\n",
        "            FadeOut(last_one_rects),\n",
        "            FadeOut(parity_word),\n",
        "            block.set_color, WHITE,\n",
        "        )\n",
        "\n",
        "        # Expand to grid\n",
        "        block.generate_target()\n",
        "        block.target.space_out_submobjects(1.5)\n",
        "        block.target.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        boxes = get_bit_grid_boxes(block.target)\n",
        "        p_labels = get_grid_position_labels(boxes)\n",
        "        p_labels.set_color(GREY_C)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(hamming, LEFT),\n",
        "            FadeOut(bulb, 1.5 * LEFT),\n",
        "            MoveToTarget(block),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(boxes, lag_ratio=0.2),\n",
        "            FadeIn(p_labels, lag_ratio=0.2),\n",
        "        )\n",
        "\n",
        "        # Set up questions\n",
        "        q_labels = VGroup(*[\n",
        "            OldTexText(f\"Q{n}:\")\n",
        "            for n in range(1, 5)\n",
        "        ])\n",
        "        q_labels.set_height(0.5)\n",
        "        q_labels.arrange(DOWN, buff=1.25)\n",
        "        q_labels.next_to(boxes, RIGHT, buff=2)\n",
        "\n",
        "        questions = VGroup()\n",
        "        for n, q_label in enumerate(q_labels):\n",
        "            m_grids = VGroup(boxes.copy(), boxes.copy())\n",
        "            m_grids.set_height(1)\n",
        "            m_grids.set_width(1, stretch=True)\n",
        "            colors = [GREY_BROWN, BLUE]\n",
        "            for k, m_grid in enumerate(m_grids):\n",
        "                get_bit_n_subgroup(m_grid, n, k).set_fill(colors[k], 0.75)\n",
        "            vs = OldTexText(\"or\")\n",
        "            question = VGroup(m_grids[0], vs, m_grids[1])\n",
        "            question.arrange(RIGHT)\n",
        "            question.next_to(q_label, RIGHT, buff=MED_SMALL_BUFF)\n",
        "            question.add_to_back(q_label)\n",
        "            questions.add(question)\n",
        "\n",
        "        questions.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        for question in questions:\n",
        "            question.save_state()\n",
        "            q_center = question.get_center()\n",
        "            for mob in question:\n",
        "                if mob is not question[0]:\n",
        "                    mob.move_to(q_center)\n",
        "                mob.set_fill(opacity=0)\n",
        "                mob.set_stroke(width=0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, questions, lag_ratio=0.25),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        questions.save_state()\n",
        "\n",
        "        # Focus on question 1\n",
        "        h_rects = boxes.copy()\n",
        "        h_rects.set_fill(BLUE, 0.5)\n",
        "        h_groups = VGroup(*[\n",
        "            get_bit_n_subgroup(h_rects, n)\n",
        "            for n in range(4)\n",
        "        ])\n",
        "\n",
        "        pc_words = OldTexText(\"Parity check\\\\\\\\these 8 bits\")\n",
        "        pc_words.next_to(boxes, RIGHT, aligned_edge=UP)\n",
        "        pc_words.shift(DOWN)\n",
        "        pc_words.set_color(BLUE)\n",
        "\n",
        "        block.save_state()\n",
        "        self.add(h_groups[0], block, p_labels)\n",
        "        self.play(\n",
        "            questions[1:].fade, 0.9,\n",
        "            FadeIn(h_groups[0], lag_ratio=0.3, run_time=3),\n",
        "            get_bit_n_subgroup(block, 0, 0).fade, 0.9,\n",
        "            Write(pc_words, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Scan first group\n",
        "        def get_sub_scanim(n, boxes=boxes, block=block, **kwargs):\n",
        "            return scan_anim(\n",
        "                boxes.get_corner(DR) + UR,\n",
        "                get_bit_n_subgroup(block, n),\n",
        "                lag_factor=0.5,\n",
        "                run_time=2,\n",
        "                **kwargs\n",
        "            )\n",
        "\n",
        "        scanim = get_sub_scanim(0)\n",
        "        robot = scanim.mobject[-1]\n",
        "        bangs = OldTex(\"!!!\")\n",
        "        bangs.set_color(RED)\n",
        "        bangs.next_to(robot, UR, buff=SMALL_BUFF)\n",
        "        check = Checkmark()\n",
        "        check.next_to(robot, UR, buff=SMALL_BUFF)\n",
        "        for mob in (bangs, check):\n",
        "            mob.scale(1.5, about_edge=DL)\n",
        "\n",
        "        q1_rect = SurroundingRectangle(questions[0][3])\n",
        "\n",
        "        self.play(scanim)\n",
        "        self.play(FadeIn(bangs, 0.1 * DOWN, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(q1_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            get_sub_scanim(0, show_robot=False),\n",
        "            FadeOut(bangs)\n",
        "        )\n",
        "        self.play(FadeIn(check, 0.2 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][1],\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeOut,\n",
        "                get_bit_n_subgroup(h_rects, 0, 0).copy().set_fill(GREY_BROWN, 0.5)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, [\n",
        "            robot, check, q1_rect,\n",
        "        ])))\n",
        "\n",
        "        # Comment over in pi creature scene\n",
        "        pass\n",
        "\n",
        "        # Highlight parity bit\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "\n",
        "        ecc_rects = VGroup(*[\n",
        "            h_group[0]\n",
        "            for h_group in h_groups\n",
        "        ])\n",
        "        pb_label = OldTexText(\"Parity bit\")\n",
        "        pb_label.next_to(ecc_rects[0], UP, MED_LARGE_BUFF)\n",
        "        pb_arrow = Arrow(\n",
        "            pb_label.get_bottom() + MED_SMALL_BUFF * LEFT,\n",
        "            block[1].get_top(),\n",
        "            buff=0.1\n",
        "        )\n",
        "        pb_label.set_color(GREEN)\n",
        "        pb_arrow.set_color(GREEN)\n",
        "        pb_arrow.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        h_groups[0].remove(ecc_rects[0])\n",
        "        self.add(ecc_rects[0], block, p_labels)\n",
        "        self.play(\n",
        "            frame.set_height, 9, {\"about_edge\": DOWN},\n",
        "            FadeIn(pb_label, 0.5 * DOWN),\n",
        "            GrowArrow(pb_arrow),\n",
        "            ecc_rects[0].set_color, GREEN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(p_labels[1]))\n",
        "        self.wait()\n",
        "\n",
        "        one_rects = get_one_rects(get_bit_n_subgroup(block, 0))\n",
        "        counter = get_ones_counter(boxes[-2:], one_rects)\n",
        "        counter.scale(0.5)\n",
        "        self.add(counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "        self.play(toggle_bit_anim(block[1]))\n",
        "        one_rects.set_submobjects(\n",
        "            get_one_rects(get_bit_n_subgroup(block, 0)).submobjects\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Back to all questions\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                one_rects, counter,\n",
        "                pb_arrow, pb_label,\n",
        "                pc_words, h_groups[0]\n",
        "            ])),\n",
        "            frame.restore,\n",
        "        )\n",
        "        toggle_bit(block.saved_state[1])  # Dumb hack\n",
        "        self.play(\n",
        "            questions.restore,\n",
        "            block.restore,\n",
        "        )\n",
        "\n",
        "        # Focus on question 2\n",
        "        self.play(\n",
        "            questions[0].fade, 0.9,\n",
        "            questions[2:].fade, 0.9,\n",
        "            get_bit_n_subgroup(block, 1, 0).fade, 0.9,\n",
        "            ecc_rects[0].fade, 0.5,\n",
        "        )\n",
        "        self.add(h_groups[1], block, p_labels)\n",
        "        self.play(FadeIn(h_groups[1], lag_ratio=0.2, run_time=2))\n",
        "\n",
        "        pb_label.next_to(boxes[2], UP, SMALL_BUFF)\n",
        "        h_groups[1].remove(ecc_rects[1])\n",
        "        self.add(ecc_rects[1], block, p_labels)\n",
        "        self.play(\n",
        "            FadeIn(pb_label, 0.25 * LEFT),\n",
        "            ecc_rects[1].set_color, GREEN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Apply second parity check\n",
        "        one_rects = get_one_rects(get_bit_n_subgroup(block, 1))\n",
        "        counter = get_ones_counter(boxes[-2:], one_rects)\n",
        "        counter.scale(0.5)\n",
        "        self.add(counter)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(one_rects)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, [\n",
        "            one_rects, counter, pb_label,\n",
        "        ])))\n",
        "\n",
        "        # Find error in right half\n",
        "        scanim = get_sub_scanim(1)\n",
        "        robot = scanim.mobject[-1]\n",
        "        self.play(\n",
        "            zap_anim(block[6]),\n",
        "            toggle_bit_anim(block[6], target_color=RED)\n",
        "        )\n",
        "        self.play(scanim)\n",
        "        self.play(FadeIn(bangs, 0.1 * DOWN, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        q2_rect = q1_rect.copy()\n",
        "        q2_rect.move_to(questions[1][3])\n",
        "        self.play(ShowCreation(q2_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            toggle_bit_anim(block[6], target_color=WHITE),\n",
        "            FadeOut(bangs),\n",
        "        )\n",
        "        self.play(get_sub_scanim(1, show_robot=False))\n",
        "        self.play(FadeIn(check, 0.2 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(q2_rect.move_to, questions[1][1])\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(\n",
        "                get_bit_n_subgroup(boxes.copy(), 1, 0).set_fill(GREY_BROWN, 0.5),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(h_groups[1]),\n",
        "            FadeOut(robot),\n",
        "            FadeOut(check),\n",
        "            FadeOut(q2_rect),\n",
        "            block.restore,\n",
        "            Transform(questions[0], questions.saved_state[0]),\n",
        "            ecc_rects[0].set_fill, GREEN, 0.5,\n",
        "        )\n",
        "\n",
        "        # Mention two errors?\n",
        "\n",
        "        # How to use Q1 with Q2\n",
        "        q1_rect.move_to(questions[0][3])\n",
        "        q2_rect.move_to(questions[1][3])\n",
        "        q1_highlight, q2_highlight = [\n",
        "            get_bit_n_subgroup(h_rects, n).copy().set_fill(BLUE, 0.5)\n",
        "            for n in [0, 1]\n",
        "        ]\n",
        "\n",
        "        q2_highlight.set_fill(opacity=0)\n",
        "        q2_highlight.set_stroke(YELLOW, 7)\n",
        "\n",
        "        self.add(q1_highlight, block, p_labels)\n",
        "        self.play(\n",
        "            FadeIn(q1_highlight, lag_ratio=0.2),\n",
        "            ShowCreation(q1_rect),\n",
        "            get_bit_n_subgroup(block, 0, 0).fade, 0.9,\n",
        "            *map(FadeOut, ecc_rects[:2]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(q2_highlight, lag_ratio=0.2),\n",
        "            ShowCreation(q2_rect),\n",
        "            get_bit_n_subgroup(block, 1, 0)[1::2].fade, 0.9,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][1],\n",
        "            q1_highlight.move_to, boxes, LEFT,\n",
        "            q1_highlight.set_fill, GREY_BROWN,\n",
        "            block.restore,\n",
        "            FadeOut(q2_highlight),\n",
        "        )\n",
        "        self.play(get_bit_n_subgroup(block, 0).fade, 0.9)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(q2_highlight, lag_ratio=0.2),\n",
        "            block[::4].fade, 0.9,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            q1_highlight.move_to, boxes, RIGHT,\n",
        "            q1_highlight.set_fill, BLUE,\n",
        "            q2_highlight.move_to, boxes, LEFT,\n",
        "            block.restore,\n",
        "            q1_rect.move_to, questions[0][3],\n",
        "            q2_rect.move_to, questions[1][1],\n",
        "        )\n",
        "        self.play(\n",
        "            block[::4].fade, 0.9,\n",
        "            get_bit_n_subgroup(block, 1).fade, 0.9,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][1],\n",
        "            q1_highlight.move_to, boxes, LEFT,\n",
        "            q1_highlight.set_fill, GREY_BROWN,\n",
        "            block[1::4].fade, 0.9,\n",
        "            Transform(block[0::4], block.saved_state[0::4]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.flip()\n",
        "        morty.next_to(boxes, RIGHT, buff=0.5, aligned_edge=DOWN)\n",
        "        words = OldTexText(\"Or no error\\\\\\\\at all!\")\n",
        "        words.next_to(morty, UP)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(morty),\n",
        "            morty.change, \"shruggie\", questions[0],\n",
        "            FadeIn(words, DOWN)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                q1_highlight, q2_highlight[1::2],\n",
        "                words, morty,\n",
        "            ])),\n",
        "            block.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        column_highlight = q2_highlight[0::2]\n",
        "\n",
        "        # Choosing a column\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][3],\n",
        "            column_highlight.move_to, boxes[1], UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][1],\n",
        "            q2_rect.move_to, questions[1][3],\n",
        "            column_highlight.move_to, boxes[2], UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            q1_rect.move_to, questions[0][3],\n",
        "            column_highlight.move_to, boxes[3], UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring back the parity highlights\n",
        "        self.add(*ecc_rects[:2], block, p_labels)\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                column_highlight, q1_rect, q2_rect\n",
        "            ])),\n",
        "            *map(FadeIn, ecc_rects[:2]),\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in [2, 3]:\n",
        "            self.play(Transform(questions[n], questions.saved_state[n]))\n",
        "        self.wait()\n",
        "\n",
        "        # Question 3\n",
        "        self.add(h_groups[2], block, p_labels)\n",
        "        self.play(\n",
        "            get_bit_n_subgroup(block, 2, 0).fade, 0.9,\n",
        "            FadeIn(h_groups[2], lag_ratio=0.2, run_time=2),\n",
        "            questions[:2].fade, 0.9,\n",
        "            questions[3].fade, 0.9,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        h_groups[2].remove(ecc_rects[2])\n",
        "        self.add(ecc_rects[2], block, p_labels)\n",
        "        self.play(\n",
        "            ecc_rects[2].set_color, GREEN,\n",
        "            ShowCreationThenFadeOut(SurroundingRectangle(boxes[4], buff=0))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        one_rects = get_one_rects(get_bit_n_subgroup(block, 2))\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "        temp_check = Checkmark()\n",
        "        temp_check.set_height(0.4)\n",
        "        temp_check.next_to(block[4], UL, buff=0)\n",
        "        self.play(Write(temp_check))\n",
        "        self.play(FadeOut(temp_check))\n",
        "        self.play(FadeOut(one_rects))\n",
        "        self.play(\n",
        "            block.restore,\n",
        "            FadeOut(h_groups[2]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Question 4\n",
        "        self.add(h_groups[3], block, p_labels)\n",
        "        self.play(\n",
        "            questions[2].fade, 0.9,\n",
        "            Transform(questions[3], questions.saved_state[3]),\n",
        "            get_bit_n_subgroup(block, 3, 0).fade, 0.9,\n",
        "            FadeIn(h_groups[3], lag_ratio=0.2, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "        h_groups[3].remove(ecc_rects[3])\n",
        "        self.add(ecc_rects[3], block, p_labels)\n",
        "        self.play(\n",
        "            ecc_rects[3].set_color, GREEN,\n",
        "            ShowCreationThenFadeOut(SurroundingRectangle(boxes[8], buff=0))\n",
        "        )\n",
        "\n",
        "        one_rects = get_one_rects(get_bit_n_subgroup(block, 3))\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "        self.play(toggle_bit_anim(block[8]))\n",
        "        toggle_bit(block.saved_state[8])\n",
        "        one_rects.set_submobjects(get_one_rects(get_bit_n_subgroup(block, 3)))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(one_rects, lag_ratio=0.2))\n",
        "        self.play(\n",
        "            block.restore,\n",
        "            questions.restore,\n",
        "            FadeOut(h_groups[3], lag_ratio=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Point out rolls of questions\n",
        "        braces = VGroup(\n",
        "            Brace(questions[:2], LEFT),\n",
        "            Brace(questions[2:], LEFT),\n",
        "        )\n",
        "        for brace, text in zip(braces, [\"column\", \"row\"]):\n",
        "            brace.words = brace.get_text(f\"Which\\\\\\\\{text}?\")\n",
        "\n",
        "        for brace in braces:\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                FadeIn(brace.words, 0.25 * RIGHT)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Example with error at 3\n",
        "        q_rects = VGroup()\n",
        "        for question, answer in zip(questions, [1, 1, 0, 0]):\n",
        "            q_rects.add(SurroundingRectangle(question[1 + 2 * answer]))\n",
        "\n",
        "        self.play(\n",
        "            zap_anim(block[3]),\n",
        "            toggle_bit_anim(block[3], target_color=RED),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        target_square = SurroundingRectangle(boxes[3::4], buff=0, stroke_width=5)\n",
        "        for n in range(4):\n",
        "            highlight = get_bit_n_subgroup(h_rects.copy(), n)\n",
        "            one_rects = get_one_rects(get_bit_n_subgroup(block, n))\n",
        "            self.add(highlight, block, p_labels)\n",
        "            self.play(\n",
        "                FadeIn(highlight),\n",
        "                ShowCreation(q_rects[n]),\n",
        "                ShowIncreasingSubsets(one_rects),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(highlight),\n",
        "                FadeOut(one_rects),\n",
        "            )\n",
        "            if n == 1:\n",
        "                self.play(FadeIn(target_square))\n",
        "            elif n == 3:\n",
        "                self.play(target_square.replace, boxes[3], {\"stretch\": True})\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            toggle_bit_anim(block[3], target_color=WHITE)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Binary counting\n",
        "        for n in range(1, 16):\n",
        "            target_square.generate_target()\n",
        "            target_square.target.move_to(boxes[n])\n",
        "            for k, q_rect in enumerate(q_rects):\n",
        "                index = 3 if((1 << k) & n) else 1\n",
        "                q_rect.generate_target()\n",
        "                q_rect.target.move_to(questions[k][index])\n",
        "            self.play(*map(MoveToTarget, [target_square, *q_rects]), run_time=0.5)\n",
        "            self.wait()\n",
        "\n",
        "        # Bit 0\n",
        "        for q_rect, question in zip(q_rects, questions):\n",
        "            q_rect.generate_target()\n",
        "            q_rect.target.move_to(question[1])\n",
        "\n",
        "        self.play(\n",
        "            target_square.move_to, boxes[0],\n",
        "            LaggedStartMap(MoveToTarget, q_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(4):\n",
        "            group = get_bit_n_subgroup(h_rects.copy(), n)\n",
        "            self.play(FadeIn(group, lag_ratio=0.2))\n",
        "            self.wait(0.5)\n",
        "            self.play(FadeOut(group))\n",
        "        self.wait()\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.next_to(boxes, RIGHT, buff=MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "        ne_word = OldTexText(\"No error?\")\n",
        "        ne_word.next_to(randy, UP, buff=MED_LARGE_BUFF)\n",
        "        ne_word.shift(0.2 * RIGHT)\n",
        "        ez_word = OldTexText(\"or error\\\\\\\\at bit 0?\")\n",
        "        ez_word.set_color(RED)\n",
        "        ez_word.move_to(ne_word, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(randy),\n",
        "            randy.change, 'pondering', questions,\n",
        "            FadeOut(braces),\n",
        "            *[\n",
        "                FadeOut(brace.words)\n",
        "                for brace in braces\n",
        "            ]\n",
        "        )\n",
        "        self.play(FadeIn(ne_word, 0.5 * DOWN))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ne_word.next_to, ez_word, UP, MED_LARGE_BUFF,\n",
        "            FadeIn(ez_word, 0.25 * DOWN),\n",
        "            randy.change, \"confused\", target_square,\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        for x in range(2):\n",
        "            self.play(toggle_bit_anim(block[0]))\n",
        "        self.play(randy.change, \"pondering\", questions)\n",
        "\n",
        "        # Count through again\n",
        "        for n in [*range(0, 16), 0]:\n",
        "            target_square.move_to(boxes[n])\n",
        "            for k, q_rect in enumerate(q_rects):\n",
        "                index = 3 if((1 << k) & n) else 1\n",
        "                q_rect.move_to(questions[k][index])\n",
        "            randy.look_at(target_square)\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Highlight no error\n",
        "        ne_rect = SurroundingRectangle(ne_word)\n",
        "        ne_rect.set_stroke(GREY_B, 2)\n",
        "        ne_comment = OldTexText(\"17th outcome\")\n",
        "        ne_comment.set_color(GREY_B)\n",
        "        ne_comment.next_to(ne_rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ne_rect),\n",
        "            FadeIn(ne_comment, 0.25 * DOWN),\n",
        "            randy.change, \"maybe\", ne_comment,\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait(2)\n",
        "\n",
        "        # Nix bit 0\n",
        "        zero_rect = SurroundingRectangle(boxes[0], buff=0)\n",
        "        zero_rect.set_fill(BLACK, 1)\n",
        "        zero_rect.set_stroke(BLACK, 0)\n",
        "        zero_rect.scale(0.98)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(zero_rect),\n",
        "            boxes[0].set_stroke, {\"width\": 0},\n",
        "            FadeOut(target_square),\n",
        "            randy.change, \"raise_left_hand\", zero_rect,\n",
        "        )\n",
        "        ne_word.generate_target()\n",
        "        ne_word.target[0][-1].set_opacity(0)\n",
        "        ne_word.target.next_to(randy, UP, MED_LARGE_BUFF)\n",
        "        ne_word.target.set_color(YELLOW)\n",
        "        self.play(\n",
        "            MoveToTarget(ne_word),\n",
        "            LaggedStart(*map(FadeOut, [ne_rect, ne_comment, ez_word]))\n",
        "        )\n",
        "        for n in range(4):\n",
        "            highlight = get_bit_n_subgroup(h_rects.copy(), n)\n",
        "            one_rects = get_one_rects(get_bit_n_subgroup(block, n))\n",
        "            self.add(highlight, block, p_labels, zero_rect, one_rects)\n",
        "            self.wait()\n",
        "            self.remove(highlight, one_rects)\n",
        "\n",
        "        # (15, 11) setup\n",
        "        stat_words = VGroup(\n",
        "            OldTexText(\"15\", \"-bit block\"),\n",
        "            OldTexText(\"11\", \" bits of\\\\\\\\message\", alignment=\"\"),\n",
        "            OldTexText(\"4 bits of\\\\\\\\redundancy\", alignment=\"\"),\n",
        "        )\n",
        "        stat_words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        stat_words[0].set_color(YELLOW)\n",
        "        stat_words[2].set_color(GREEN)\n",
        "        stat_words.next_to(boxes, RIGHT, buff=MED_LARGE_BUFF, aligned_edge=UP)\n",
        "        stat_words.shift(0.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [*q_rects, ne_word])),\n",
        "            randy.change, \"tease\", stat_words,\n",
        "            FadeIn(stat_words[0], 0.5 * LEFT)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeIn(stat_words[1], 0.5 * LEFT),\n",
        "            LaggedStart(*[\n",
        "                toggle_bit_anim(bit)\n",
        "                for i, bit in enumerate(block)\n",
        "                if i not in [0, 1, 2, 4, 8]\n",
        "            ])\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                toggle_bit_anim(bit)\n",
        "                for i, bit in enumerate(block)\n",
        "                if i not in [0, 1, 2, 4, 8]\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(stat_words[2], 0.5 * LEFT),\n",
        "            LaggedStart(*map(ShowCreationThenFadeAround, [\n",
        "                block[2**n]\n",
        "                for n in range(4)\n",
        "            ]))\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        code_name = OldTexText(\"(\", \"15\", \", \", \"11\", \")\", \" Hamming code\")\n",
        "        code_name.set_height(0.8)\n",
        "        code_name.to_edge(UP)\n",
        "        code_name.shift(UP)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(frame.set_height, 9, {\"about_edge\": DOWN}, run_time=2),\n",
        "            TransformFromCopy(stat_words[0][0], code_name[1]),\n",
        "            TransformFromCopy(stat_words[1][0], code_name[3]),\n",
        "            LaggedStart(*map(FadeIn, [\n",
        "                code_name[i] for i in [0, 2, 4, 5]\n",
        "            ])),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring back bit zero\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                *stat_words, randy,\n",
        "                *questions, code_name,\n",
        "            ])),\n",
        "            ApplyMethod(frame.match_x, block),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        old_zero_rect = zero_rect\n",
        "        zero_rect = old_zero_rect.copy()\n",
        "        zero_rect.set_stroke(YELLOW, 2)\n",
        "        zero_rect.set_fill(YELLOW, 0.5)\n",
        "        zero_rect.save_state()\n",
        "        zero_rect.stretch(0, 1, about_edge=UP)\n",
        "        zero_words = OldTexText(\"Can we put this bit to work?\")\n",
        "        zero_words.set_height(0.7)\n",
        "        zero_words.next_to(zero_rect, UP, MED_LARGE_BUFF)\n",
        "        zero_words.match_x(block)\n",
        "        zero_words.set_color(YELLOW)\n",
        "\n",
        "        self.add(zero_rect, block, p_labels)\n",
        "        block[0].set_opacity(0)\n",
        "        self.play(\n",
        "            FadeOut(old_zero_rect),\n",
        "            Restore(zero_rect),\n",
        "            Write(zero_words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Parity check the whole block\n",
        "        pc_words = OldTexText(\"Parity check\\\\\\\\ \\\\emph{the whole block}\")\n",
        "        pc_words.set_height(1.2)\n",
        "        pc_words.next_to(boxes, LEFT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        one_rects = get_one_rects(block)\n",
        "        counter = get_ones_counter(boxes[-2:], one_rects)\n",
        "        counter.scale(0.5)\n",
        "\n",
        "        self.play(\n",
        "            Write(pc_words, run_time=1),\n",
        "            ShowCreationThenFadeOut(h_rects.copy()),\n",
        "        )\n",
        "        self.wait()\n",
        "        ecc_bits = VGroup(*[block[2**n] for n in range(4)])\n",
        "        for x in range(2):\n",
        "            self.play(LaggedStartMap(toggle_bit_anim, ecc_bits, lag_ratio=0.25, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "        block[0][1].set_opacity(1)\n",
        "        self.play(Write(block[0]))\n",
        "        one_rects.set_submobjects(get_one_rects(block))\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [one_rects, counter]))\n",
        "\n",
        "        # Walk through single and two bit errors\n",
        "        self.play(\n",
        "            zap_anim(block[9]),\n",
        "            toggle_bit_anim(block[9], target_color=RED),\n",
        "        )\n",
        "        one_rects.set_submobjects(get_one_rects(block))\n",
        "        counter.set_opacity(1)\n",
        "        self.add(counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            zap_anim(block[5]),\n",
        "            toggle_bit_anim(block[5], target_color=RED),\n",
        "        )\n",
        "        one_rects.set_submobjects(get_one_rects(block))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(one_rects), FadeOut(counter))\n",
        "\n",
        "        for n in [2, 3]:\n",
        "            group = get_bit_n_subgroup(h_rects.copy(), n)\n",
        "            group.set_fill(opacity=0)\n",
        "            group.set_stroke(BLUE, 10)\n",
        "            self.play(ShowCreation(group, lag_ratio=0.5))\n",
        "            self.play(FadeOut(group))\n",
        "        self.wait()\n",
        "\n",
        "        scanim = scan_anim(boxes.get_corner(DR) + 2 * UR, block, lag_factor=0.5, run_time=2)\n",
        "        robot = scanim.mobject[-1]\n",
        "        robot.set_color(GREY_B)\n",
        "        robot.scale(2, about_edge=UP)\n",
        "        ded_words = OldTexText(\"At least\\\\\\\\2 errors!\")\n",
        "        ded_words.set_color(RED)\n",
        "        ded_words.next_to(robot, UR, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(scanim)\n",
        "        self.play(FadeIn(ded_words, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Extended name\n",
        "        new_title = OldTexText(\"Extended Hamming Code\")\n",
        "        new_title.replace(zero_words, dim_to_match=1)\n",
        "        self.play(\n",
        "            FadeIn(new_title, DOWN),\n",
        "            FadeOut(zero_words, UP),\n",
        "            FadeOut(pc_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhatIfTheresAndArrowInECCBits(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What if an\\\\\\\\error-correction bit\\\\\\\\needs to be corrected?\",\n",
        "            bubble_config={'width': 5, 'height': 4, \"direction\": LEFT},\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"confused\")\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\"Try it!\", target_mode=\"hooray\")\n",
        "        self.play_student_changes(*3 * [\"pondering\"], look_at=self.screen)\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(*3 * [\"thinking\"], look_at=self.screen)\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class ErrorAtECCBit(Scene):\n",
        "    def construct(self):\n",
        "        bits = get_bit_grid(4, 4, height=6)\n",
        "        toggle_bit(bits[1])\n",
        "        toggle_bit(bits[4])\n",
        "        boxes = get_bit_grid_boxes(bits)\n",
        "        pos_labels = get_grid_position_labels(boxes)\n",
        "        ecc_boxes = VGroup(*[boxes[2**n] for n in range(4)])\n",
        "        ecc_boxes.set_fill(GREEN, 0.5)\n",
        "        bangs = OldTexText(\"!!!\")\n",
        "        bangs.set_color(RED)\n",
        "        bangs.next_to(boxes[2], UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(boxes, ecc_boxes, pos_labels, bits)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(Rotate, ecc_boxes, lambda m: (m, PI)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            zap_anim(bits[2]),\n",
        "            toggle_bit_anim(bits[2], target_color=RED),\n",
        "        )\n",
        "        self.play(Write(bangs))\n",
        "        self.wait()\n",
        "\n",
        "        for bit in bits:\n",
        "            bit.remove(bit[1 - get_bit_mob_value(bit)])\n",
        "        for n in range(4):\n",
        "            bits.generate_target()\n",
        "            bits.target.set_opacity(1)\n",
        "            get_bit_n_subgroup(bits.target, n, 0).set_opacity(0)\n",
        "            self.play(MoveToTarget(bits))\n",
        "            self.wait()\n",
        "        self.play(bits.set_opacity, 1)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HalfAsPowerful(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Shouldn't that be\\\\\\\\only half as good?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"pondering\", look_at=self.screen,\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class WhatAboutTwoErrors(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What about\\\\\\\\2 errors?\",\n",
        "        )\n",
        "        self.play(self.teacher.change, \"guilty\")\n",
        "        self.look_at(self.screen)\n",
        "        self.play_student_changes(\"erm\", \"confused\")\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class BlockSize256(Scene):\n",
        "    def construct(self):\n",
        "        N = 8\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        # Bit block\n",
        "        bits = string_to_bits(\"You decoded an easter egg. Nice!\")\n",
        "        block = get_bit_grid(2**(N // 2), 2**(N // 2), bits=bits)\n",
        "        block.set_height(6)\n",
        "        block.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        boxes = get_bit_grid_boxes(block)\n",
        "\n",
        "        parity_boxes = VGroup(*[boxes[2**k] for k in range(N)])\n",
        "        parity_boxes.set_fill(GREEN, 0.8)\n",
        "\n",
        "        bit_boxes = VGroup(*[VGroup(box, bit) for bit, box in zip(block, boxes)])\n",
        "        to_fade = VGroup()\n",
        "        to_keep = VGroup()\n",
        "        for i, bb in enumerate(bit_boxes):\n",
        "            if i >= 64 or (i % 16) >= 4:\n",
        "                to_fade.add(bb.copy())\n",
        "            else:\n",
        "                to_keep.add(bb.copy())\n",
        "\n",
        "        to_fade.save_state()\n",
        "        to_fade.fade(1)\n",
        "        frame.save_state()\n",
        "        frame.replace(to_keep, dim_to_match=1)\n",
        "        frame.scale(1.2)\n",
        "\n",
        "        self.add(to_keep)\n",
        "        self.play(\n",
        "            Restore(frame),\n",
        "            Restore(to_fade, lag_ratio=0.1),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        self.clear()\n",
        "        self.add(boxes)\n",
        "        self.add(block)\n",
        "\n",
        "        # Add title\n",
        "        title = OldTexText(\"$256 = 2^8$ bits\")\n",
        "        title.set_height(0.7)\n",
        "        title.next_to(boxes, UP, MED_LARGE_BUFF)\n",
        "        title.set_x(0)\n",
        "\n",
        "        self.play(\n",
        "            frame.move_to, 0.5 * UP,\n",
        "            Write(title)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Parity groups\n",
        "        parity_groups = VGroup()\n",
        "        for k in range(N):\n",
        "            group = boxes.copy()\n",
        "            group.set_fill(BLACK, opacity=0)\n",
        "            group.set_stroke(GREY_B, 1)\n",
        "            group.set_height(1.5)\n",
        "            get_bit_n_subgroup(group, k).set_fill(BLUE_E, 1)\n",
        "            parity_groups.add(group)\n",
        "\n",
        "        parity_groups.arrange_in_grid(2, 4, buff=MED_LARGE_BUFF)\n",
        "        parity_groups.set_width(7)\n",
        "        VGroup(parity_groups[:4], parity_groups[4:]).arrange(DOWN, buff=1.5)\n",
        "        parity_groups.to_edge(RIGHT)\n",
        "\n",
        "        # Question labels\n",
        "        q_labels = VGroup(*[TexText(f\"Q{i + 1}\") for i in range(N)])\n",
        "        for label, group in zip(q_labels, parity_groups):\n",
        "            label.set_height(0.3)\n",
        "            label.next_to(group, UP, SMALL_BUFF)\n",
        "\n",
        "        # Add questions\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, q_labels, lambda m: (m, DOWN), lag_ratio=0.3, run_time=5),\n",
        "            LaggedStartMap(FadeIn, parity_groups, lambda m: (m, DOWN), lag_ratio=0.3, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate one square\n",
        "        pos = 69  # Why not?\n",
        "        bits = \"{0:b}\".format(pos)\n",
        "        bits = (N - len(bits)) * '0' + bits\n",
        "        bits = bits[::-1]\n",
        "\n",
        "        yes_no_group = VGroup()\n",
        "        boxes.save_state()\n",
        "        possible_positions = list(range(2**N))\n",
        "        for k, bit, group in zip(it.count(), bits, parity_groups):\n",
        "            bit_value = int(bit)\n",
        "            if bit_value:\n",
        "                word = OldTexText(\"Yes\", color=GREEN)\n",
        "            else:\n",
        "                word = OldTexText(\"No\", color=RED)\n",
        "            word.next_to(group, DOWN)\n",
        "            yes_no_group.add(word)\n",
        "\n",
        "            intersect_positions = get_bit_n_sublist(range(2**N), k, bit_value)\n",
        "            globals()['intersect_positions'] = intersect_positions\n",
        "            possible_positions = list(filter(\n",
        "                lambda i: i in intersect_positions,\n",
        "                possible_positions,\n",
        "            ))\n",
        "\n",
        "            boxes.generate_target()\n",
        "            boxes.target.match_style(boxes.saved_state)\n",
        "            globals()['possible_positions'] = possible_positions\n",
        "            globals()['boxes'] = boxes\n",
        "            VGroup(*[boxes.target[i] for i in possible_positions]).set_fill(BLUE, 1)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(word),\n",
        "                MoveToTarget(boxes)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Highlight parity bits\n",
        "        parity_bits_label = OldTexText(\"8 parity bits\")\n",
        "        parity_bits_label.next_to(boxes, UP, aligned_edge=LEFT)\n",
        "        parity_bits_label.set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(parity_bits_label, DOWN),\n",
        "            title.to_edge, RIGHT\n",
        "        )\n",
        "        self.add(parity_boxes, block)\n",
        "        self.play(\n",
        "            LaggedStartMap(Rotate, parity_boxes, lambda m: (m, TAU)),\n",
        "        )\n",
        "        self.add(boxes, block)\n",
        "\n",
        "        # Un-highlight isolated point\n",
        "        self.play(\n",
        "            boxes[pos].set_fill, BLACK, 0,\n",
        "            FadeOut(yes_no_group)\n",
        "        )\n",
        "\n",
        "        # Message bits\n",
        "        message_bits = VGroup(*[\n",
        "            bit\n",
        "            for i, bit in enumerate(block)\n",
        "            if i not in [2**k for k in range(N)]\n",
        "        ])\n",
        "        message_bits.shuffle()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                toggle_bit_anim(bit)\n",
        "                for bit in message_bits\n",
        "            ], lag_ratio=0.01, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write redundant\n",
        "        redundant_label = OldTexText(\"``Redundant''\")\n",
        "        redundant_label.set_color(GREEN)\n",
        "        redundant_label.next_to(parity_bits_label[-1][-1], RIGHT, MED_LARGE_BUFF, DOWN)\n",
        "\n",
        "        self.play(Write(redundant_label))\n",
        "\n",
        "        block.save_state()\n",
        "        for k in range(N):\n",
        "            block.target = block.saved_state.copy()\n",
        "            get_bit_n_subgroup(block.target, k, 0).set_fill(opacity=0)\n",
        "            self.play(MoveToTarget(block))\n",
        "            self.wait(0.5)\n",
        "        self.play(Restore(block))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WellAlmost(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Well...\\\\\\\\almost\", target_mode=\"hesitant\")\n",
        "        self.play_student_changes(\"angry\", \"sassy\", \"confused\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ChecksSpellOutPositionInBinary(Scene):\n",
        "    def construct(self):\n",
        "        N = 4\n",
        "        pos = 7\n",
        "\n",
        "        # Setup block\n",
        "        random.seed(0)\n",
        "        bits = [random.choice([0, 1]) for n in range(2**N)]\n",
        "        bits[1] = 0\n",
        "        bits[2] = 1\n",
        "        bits[4] = 0\n",
        "        bits[8] = 0\n",
        "        block = get_bit_grid(2**(N // 2), 2**(N // 2), bits=bits)\n",
        "        block.set_height(5)\n",
        "        block.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        boxes = get_bit_grid_boxes(block)\n",
        "        VGroup(*[boxes[2**n] for n in range(N)]).set_fill(GREY_D, 1)\n",
        "\n",
        "        pos_labels = VGroup(*map(Integer, range(2**N)))\n",
        "        pos_labels.set_height(0.2)\n",
        "        for label, box, bit_label in zip(pos_labels, boxes, block):\n",
        "            label.move_to(box, DR)\n",
        "            label.shift(0.1 * UL)\n",
        "            label.set_color(GREY_A)\n",
        "            bit_label.scale(0.8)\n",
        "\n",
        "        self.add(boxes)\n",
        "        self.add(block)\n",
        "        self.add(pos_labels)\n",
        "\n",
        "        self.play(\n",
        "            zap_anim(block[pos]),\n",
        "            toggle_bit_anim(block[pos]),\n",
        "        )\n",
        "\n",
        "        # Setup questions\n",
        "        parity_groups = VGroup()\n",
        "        for n in range(N):\n",
        "            group = boxes.copy()\n",
        "            group.set_height(1)\n",
        "            group.set_width(1, stretch=True)\n",
        "            group.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(group, n).set_fill(BLUE_D, 1)\n",
        "            parity_groups.add(group)\n",
        "        parity_groups.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        parity_groups.set_height(6)\n",
        "        parity_groups.to_edge(RIGHT, buff=3)\n",
        "\n",
        "        q_labels = VGroup(*[TexText(f\"Q{n + 1}:\") for n in range(N)])\n",
        "        for label, group in zip(q_labels, parity_groups):\n",
        "            label.next_to(group, LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(parity_groups),\n",
        "            FadeIn(q_labels),\n",
        "        )\n",
        "\n",
        "        # Binary search down\n",
        "        bits_word = \"{0:b}\".format(pos)\n",
        "        bits_word = (N - len(bits_word)) * '0' + bits_word\n",
        "        bits = list(map(int, bits_word[::-1]))\n",
        "\n",
        "        boxes.save_state()\n",
        "        yes_no_words = VGroup()\n",
        "        possible_positions = list(range(2**N))\n",
        "        for n, bit, group in zip(it.count(), bits, parity_groups):\n",
        "            if bit:\n",
        "                word = OldTexText(\"Yes\", color=GREEN)\n",
        "            else:\n",
        "                word = OldTexText(\"No\", color=RED)\n",
        "            word.next_to(group, RIGHT)\n",
        "            yes_no_words.add(word)\n",
        "\n",
        "            possible_positions = list(filter(\n",
        "                lambda i: i in get_bit_n_sublist(range(2**N), n, bit_value=bit),\n",
        "                possible_positions,\n",
        "            ))\n",
        "\n",
        "            boxes.target = boxes.saved_state.copy()\n",
        "            VGroup(*[boxes.target[i] for i in possible_positions]).set_fill(BLUE_D, 0.8)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(word, 0.5 * LEFT),\n",
        "                MoveToTarget(boxes),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Spell answer in binary\n",
        "        binary_answers = VGroup(*[\n",
        "            Integer(bit).move_to(word).match_color(word)\n",
        "            for bit, word in zip(bits, yes_no_words)\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, binary_answers),\n",
        "            LaggedStartMap(ApplyMethod, yes_no_words, lambda m: (m.scale, 0), remover=True),\n",
        "        )\n",
        "\n",
        "        # Show value of 7\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        binary_pos_label = binary_answers.copy()\n",
        "        binary_pos_label.generate_target()\n",
        "        binary_pos_label.target.arrange(LEFT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "\n",
        "        equation = VGroup(\n",
        "            Integer(7, color=BLUE),\n",
        "            OldTex(\"\\\\rightarrow\"),\n",
        "            binary_pos_label.target,\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_edge(UP, buff=0)\n",
        "\n",
        "        arrow = Arrow(equation.get_left(), equation.get_right(), buff=0)\n",
        "        arrow.next_to(equation, DOWN, SMALL_BUFF)\n",
        "        trans_words = OldTexText(\"Decimal to binary\")\n",
        "        trans_words.match_width(arrow)\n",
        "        trans_words.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(binary_pos_label),\n",
        "            frame.move_to, 0.5 * UP\n",
        "        )\n",
        "        self.play(\n",
        "            Write(equation[:-1]),\n",
        "            Write(trans_words),\n",
        "            GrowArrow(arrow),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        bin_group = VGroup(*equation[:-1], binary_pos_label, arrow, trans_words)\n",
        "\n",
        "        # Spell out binary\n",
        "        bin_equation = OldTex(\n",
        "            \"{7} = {0} \\\\cdot 8 + {1} \\\\cdot 4 + {1} \\\\cdot 2 + {1} \\\\cdot 1\",\n",
        "            tex_to_color_map={\n",
        "                \"{0}\": RED,\n",
        "                \"{1}\": GREEN,\n",
        "                \"{7}\": BLUE,\n",
        "            }\n",
        "        )\n",
        "        bin_equation.move_to(bin_group, UP)\n",
        "\n",
        "        bit_parts = list(it.chain(*[\n",
        "            bin_equation.get_parts_by_tex(f\"{{{d}}}\")\n",
        "            for d in [0, 1]\n",
        "        ]))\n",
        "\n",
        "        self.play(\n",
        "            bin_group.next_to, bin_equation, DOWN, LARGE_BUFF,\n",
        "            *[\n",
        "                ApplyMethod(m1.copy().replace, m2, {\"dim_to_match\": 1}, remover=True, run_time=1.5)\n",
        "                for m1, m2 in zip(binary_pos_label[::-1], bit_parts)\n",
        "            ],\n",
        "            ApplyMethod(equation[0].copy().replace, bin_equation[0], remover=True, run_time=1.5)\n",
        "        )\n",
        "        self.add(bin_equation[0], *bit_parts)\n",
        "        self.play(FadeIn(VGroup(*[\n",
        "            part\n",
        "            for part in bin_equation\n",
        "            if part.get_tex() not in [\"{0}\", \"{1}\", \"{7}\"]\n",
        "        ]), lag_ratio=0.1))\n",
        "        self.add(bin_equation)\n",
        "        self.wait()\n",
        "\n",
        "        # Error at 7\n",
        "        toggle_bit(block[pos])\n",
        "        self.play(\n",
        "            zap_anim(block[pos]),\n",
        "            toggle_bit_anim(block[pos], target_color=RED),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Four parity checks\n",
        "        for n, label, group, word in zip(it.count(), q_labels, parity_groups, yes_no_words):\n",
        "            boxes.target = boxes.saved_state.copy()\n",
        "            get_bit_n_subgroup(boxes.target, n).set_fill(BLUE, 0.8)\n",
        "\n",
        "            rect = SurroundingRectangle(VGroup(label, group, word), buff=MED_SMALL_BUFF)\n",
        "            one_rects = get_one_rects(get_bit_n_subgroup(block, n))\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(boxes),\n",
        "                ShowCreation(rect),\n",
        "                ShowIncreasingSubsets(one_rects)\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(one_rects),\n",
        "                FadeOut(rect),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(Restore(boxes))\n",
        "        self.wait()\n",
        "\n",
        "        # Other examples\n",
        "        toggle_bit(block[7])\n",
        "        block[7].set_color(WHITE)\n",
        "\n",
        "        bit_parts = VGroup(*bit_parts)\n",
        "        to_save = VGroup(\n",
        "            equation[0], bin_equation[0],\n",
        "            bit_parts, binary_pos_label, binary_answers,\n",
        "        )\n",
        "        to_save.save_state()\n",
        "\n",
        "        ns = random.sample(list(range(16)), 10)\n",
        "        for n in ns:\n",
        "            toggle_bit(block[n])\n",
        "            block[n].set_color(YELLOW)\n",
        "\n",
        "            nc1 = Integer(n)\n",
        "            nc1.replace(equation[0], 1)\n",
        "            nc1.match_color(equation[0])\n",
        "            equation[0].set_opacity(0)\n",
        "            nc2 = nc1.copy()\n",
        "            nc2.replace(bin_equation[0], 1)\n",
        "            bin_equation[0].set_fill(0)\n",
        "\n",
        "            new_bits = int_to_bit_string(n, 4)\n",
        "            new_bit_mobs = VGroup()\n",
        "            for b1, b2, b3, value in zip(reversed(bit_parts), binary_pos_label, binary_answers, reversed(new_bits)):\n",
        "                new_mob = OldTex(value)\n",
        "                new_mob.set_color(GREEN if int(value) else RED)\n",
        "                for b in (b1, b2, b3):\n",
        "                    nmc = new_mob.copy()\n",
        "                    nmc.replace(b, 1)\n",
        "                    b.set_opacity(0)\n",
        "                    new_bit_mobs.add(nmc)\n",
        "\n",
        "            self.play(*[\n",
        "                Animation(mob, remover=True, run_time=1)\n",
        "                for mob in [new_bit_mobs, nc1, nc2]\n",
        "            ])\n",
        "\n",
        "            toggle_bit(block[n])\n",
        "            block[n].set_color(WHITE)\n",
        "\n",
        "        to_save.restore()\n",
        "        self.wait()\n",
        "\n",
        "        # Remove 7 stuff\n",
        "        self.play(\n",
        "            FadeOut(VGroup(\n",
        "                *bin_group, *bin_equation, *binary_answers\n",
        "            ), lag_ratio=0.1),\n",
        "            block[pos].set_color, WHITE,\n",
        "        )\n",
        "\n",
        "        question_group = VGroup(q_labels, parity_groups)\n",
        "\n",
        "        # Show numbers 0 through 15\n",
        "        pos_labels_movers = pos_labels.copy()\n",
        "        bin_pos_groups = VGroup()\n",
        "        arrows = VGroup()\n",
        "        bin_labels = VGroup()\n",
        "\n",
        "        for n, label in enumerate(pos_labels_movers):\n",
        "            label.scale(2)\n",
        "            arrow = OldTex(\"\\\\rightarrow\")\n",
        "            bits_word = \"{0:b}\".format(n)\n",
        "            bits_word = (N - len(bits_word)) * '0' + bits_word\n",
        "            bin_label = VGroup(*[Tex(b) for b in bits_word])\n",
        "            bin_label.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "            pos_group = VGroup(label, arrow, bin_label)\n",
        "            pos_group.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            bin_pos_groups.add(pos_group)\n",
        "            arrows.add(pos_group[1])\n",
        "            bin_labels.add(bin_label)\n",
        "\n",
        "        bin_pos_groups.arrange_in_grid(8, 2, fill_rows_first=False)\n",
        "        bin_pos_groups.set_height(7)\n",
        "        bin_pos_groups.to_edge(RIGHT)\n",
        "        bin_pos_groups.set_y(0.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question_group),\n",
        "            FadeIn(arrows, lag_ratio=0.02),\n",
        "            TransformFromCopy(pos_labels, pos_labels_movers),\n",
        "        )\n",
        "        self.play(ShowIncreasingSubsets(bin_labels, run_time=3, rate_func=bezier([0, 0, 1, 1])))\n",
        "        self.wait()\n",
        "\n",
        "        # Put bin labels in boxes\n",
        "        for label, box in zip(bin_labels, boxes):\n",
        "            label.generate_target()\n",
        "            label.target.set_width(0.7 * box.get_width())\n",
        "            label.target.move_to(box, DOWN)\n",
        "            label.target.shift(SMALL_BUFF * UP)\n",
        "\n",
        "        for bit in block:\n",
        "            bit.generate_target()\n",
        "            bit.target.scale(0.5, about_edge=UP),\n",
        "            bit.target.fade(0.5)\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 5,\n",
        "            \"lag_ratio\": 0.3,\n",
        "        }\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, bin_labels, **kw),\n",
        "            LaggedStartMap(FadeOut, arrows, **kw),\n",
        "            LaggedStartMap(FadeOut, pos_labels_movers, **kw),\n",
        "            LaggedStartMap(FadeOut, pos_labels, **kw),\n",
        "            LaggedStartMap(MoveToTarget, block, **kw),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show confusion\n",
        "        randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(randy),\n",
        "            randy.change, \"maybe\", boxes,\n",
        "        )\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"Wait...\",\n",
        "            target_mode=\"confused\",\n",
        "            bubble_type=ThoughtBubble,\n",
        "            look_at=boxes.get_top(),\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStart(*map(ShowCreationThenFadeAround, bin_labels), lag_ratio=0))\n",
        "        self.play(randy.change, \"maybe\")\n",
        "        self.play(\n",
        "            LaggedStart(*[ShowCreationThenFadeOut(SurroundingRectangle(b, color=GREEN)) for b in block], lag_ratio=0),\n",
        "            randy.look_at, boxes.get_bottom(),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change, 'pondering', boxes,\n",
        "            FadeOut(randy.bubble),\n",
        "            FadeOut(randy.bubble.content),\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.wait()\n",
        "            self.play(Blink(randy))\n",
        "            self.play(randy.change, \"thinking\")\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        # Go through parity group 1 (and setup others)\n",
        "        bit_arrow_groups = VGroup()\n",
        "        for n in range(N):\n",
        "            arrow_group = VGroup()\n",
        "            for bin_label in bin_labels:\n",
        "                char = bin_label[-(n + 1)]\n",
        "                arrow = Triangle(start_angle=-PI / 2)\n",
        "                arrow.stretch(0.8, 0)\n",
        "                arrow.set_height(0.8 * char.get_height())\n",
        "                arrow.next_to(char, UP, buff=0.05)\n",
        "                arrow.set_stroke(width=0)\n",
        "                if char.get_tex() == '0':\n",
        "                    arrow.set_fill(GREY, 1)\n",
        "                else:\n",
        "                    arrow.set_fill(BLUE, 1)\n",
        "                arrow_group.add(arrow)\n",
        "            bit_arrow_groups.add(arrow_group)\n",
        "\n",
        "        highlight_groups = VGroup()\n",
        "        for n in range(N):\n",
        "            highlight_group = boxes.copy()\n",
        "            highlight_group.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(highlight_group, n).set_fill(BLUE, 0.5)\n",
        "            highlight_groups.add(highlight_group)\n",
        "\n",
        "        questions = VGroup()\n",
        "        for n in range(N):\n",
        "            chars = [\"\\\\underline{\\\\phantom{0}}\" for x in range(4)]\n",
        "            chars[-(n + 1)] = \"\\\\underline{1}\"\n",
        "            question = OldTexText(\n",
        "                f\"\"\"\n",
        "                If there's an error, does\\\\\\\\\n",
        "                its position look like\\\\\\\\\n",
        "                \"\"\",\n",
        "                \" \".join(chars),\n",
        "                \"?\"\n",
        "            )\n",
        "            question.scale(1.25)\n",
        "            question[1:].scale(1.5, about_edge=UP)\n",
        "            question[1:].shift(SMALL_BUFF * DOWN)\n",
        "            question[1].set_color(BLUE)\n",
        "            question.next_to(boxes, RIGHT, LARGE_BUFF)\n",
        "            questions.add(question)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, bit_arrow_groups[0], lag_ratio=0.3, run_time=3),\n",
        "            FadeOut(block),\n",
        "        )\n",
        "        self.play(Transform(boxes, highlight_groups[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(questions[0]))\n",
        "        self.wait()\n",
        "\n",
        "        # Go through parity groups 2-4\n",
        "        bit_arrows = bit_arrow_groups[0]\n",
        "        for n in range(1, N):\n",
        "            self.play(boxes.set_fill, BLACK, 0)\n",
        "            self.play(\n",
        "                Transform(bit_arrows, bit_arrow_groups[n]),\n",
        "                FadeOut(questions[n - 1])\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                Transform(boxes, highlight_groups[n]),\n",
        "                FadeIn(questions[n])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Organize questions\n",
        "        questions.generate_target()\n",
        "        questions.target.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        questions.target.set_height(FRAME_HEIGHT - 1)\n",
        "        questions.target.next_to(boxes, RIGHT, buff=1.5)\n",
        "        questions.target.match_y(frame)\n",
        "        questions[:N - 1].set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(questions),\n",
        "            Restore(boxes),\n",
        "            FadeOut(bit_arrows),\n",
        "        )\n",
        "\n",
        "        fade_anims = []\n",
        "        for n in range(N):\n",
        "            rect = SurroundingRectangle(questions[n])\n",
        "            rect.set_stroke(BLUE, 2)\n",
        "            self.play(\n",
        "                FadeIn(highlight_groups[n]),\n",
        "                FadeIn(rect),\n",
        "                *fade_anims\n",
        "            )\n",
        "            fade_anims = [\n",
        "                FadeOut(highlight_groups[n]),\n",
        "                FadeOut(rect),\n",
        "            ]\n",
        "        self.play(*fade_anims)\n",
        "\n",
        "        # Note power of 2 points\n",
        "        parity_arrows = VGroup(Vector(DOWN), Vector(DOWN), Vector(RIGHT), Vector(RIGHT))\n",
        "        parity_arrows[0].next_to(boxes[1], UP, SMALL_BUFF)\n",
        "        parity_arrows[1].next_to(boxes[2], UP, SMALL_BUFF)\n",
        "        parity_arrows[2].next_to(boxes[4], LEFT, SMALL_BUFF)\n",
        "        parity_arrows[3].next_to(boxes[8], LEFT, SMALL_BUFF)\n",
        "        parity_arrows.set_color(GREEN)\n",
        "\n",
        "        parity_groups = VGroup()\n",
        "        for n, question in enumerate(questions):\n",
        "            pg = boxes.copy()\n",
        "            pg.set_width(pg.get_height(), stretch=True)\n",
        "            pg.set_height(0.8 * question.get_height())\n",
        "            pg.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(pg, n).set_fill(BLUE, 0.8)\n",
        "            pg.next_to(question, RIGHT, LARGE_BUFF)\n",
        "            parity_groups.add(pg)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, parity_arrows),\n",
        "            ApplyMethod(frame.set_x, -1, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        rects = VGroup(*[boxes[2**n].copy() for n in range(N)])\n",
        "        rects.set_fill(BLUE, 0.8)\n",
        "        self.add(rects, bin_label)\n",
        "        self.play(\n",
        "            LaggedStartMap(VFadeInThenOut, rects, lag_ratio=0.5, run_time=5),\n",
        "            LaggedStartMap(FadeIn, parity_groups, lag_ratio=0.5, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(rects, bin_label)\n",
        "        self.play(\n",
        "            LaggedStartMap(VFadeInThenOut, rects, lag_ratio=0.5, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PowerOfTwoPositions(Scene):\n",
        "    def construct(self):\n",
        "        block = get_bit_grid(4, 4)\n",
        "        block.set_height(5)\n",
        "        block.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        boxes = get_bit_grid_boxes(block)\n",
        "\n",
        "        numbers = VGroup(*[\n",
        "            Integer(n).move_to(box)\n",
        "            for n, box in enumerate(boxes)\n",
        "        ])\n",
        "\n",
        "        self.add(numbers)\n",
        "        self.wait()\n",
        "        for n in range(4):\n",
        "            numbers[2**n].scale(1.5)\n",
        "            numbers[2**n].set_color(YELLOW)\n",
        "            self.wait(0.25)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OneGroupPerParityBit(Scene):\n",
        "    def construct(self):\n",
        "        N = 4\n",
        "        block = get_bit_grid(2**(N // 2), 2**(N // 2))\n",
        "        block.set_height(5)\n",
        "        block.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        boxes = get_bit_grid_boxes(block)\n",
        "        pos_labels = get_grid_position_labels(boxes)\n",
        "\n",
        "        for bit in block:\n",
        "            bit.scale(0.7)\n",
        "\n",
        "        parity_boxes = VGroup(*[boxes[2**n] for n in range(N)])\n",
        "        parity_boxes.set_fill(GREEN, 0.8)\n",
        "        block.save_state()\n",
        "        self.add(boxes, pos_labels, block)\n",
        "        for n in range(4):\n",
        "            block.restore()\n",
        "            get_bit_n_subgroup(block, n, 0).set_fill(opacity=0)\n",
        "            self.wait(1.5)\n",
        "\n",
        "\n",
        "class LetsWalkThroughAnExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Can we walk through\\\\\\\\a full example?\",\n",
        "            index=1,\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.play_student_changes(\"hooray\", None, \"hooray\")\n",
        "        self.wait(5)\n",
        "        self.teacher_says(\n",
        "            \"But of\\\\\\\\course!\",\n",
        "            target_mode=\"tease\"\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"coin_flip_1\", \"happy\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class FullExampleWithNewEnd(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Pull bits out of an image\n",
        "        image = ImageMobject(\"Tom_In_Bowtie\")\n",
        "        image.set_height(6)\n",
        "        image.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        bits = get_image_bits(image)\n",
        "        bits.match_height(image)\n",
        "        bits.generate_target()\n",
        "        bits.target.arrange_in_grid(n_cols=11, h_buff=SMALL_BUFF, v_buff=MED_SMALL_BUFF)\n",
        "        bits.target.next_to(image, RIGHT, LARGE_BUFF, UP)\n",
        "        for bit, bt in zip(bits, bits.target):\n",
        "            bit.save_state()\n",
        "            bit.target = bt\n",
        "            bit.fade(0.9)\n",
        "\n",
        "        words = OldTexText(\"11-bit\\\\\\\\chunks\")\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(RIGHT)\n",
        "        lines = VGroup()\n",
        "        for bit in bits.target[10:200:11]:\n",
        "            line = Line(RIGHT, LEFT)\n",
        "            line.set_stroke(BLUE, 1)\n",
        "            line.bit = bit\n",
        "            line.word = words[0][0]\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "                m.word.get_left() + SMALL_BUFF * LEFT,\n",
        "                m.bit.get_right() + SMALL_BUFF * RIGHT,\n",
        "            ))\n",
        "            lines.add(line)\n",
        "\n",
        "        self.add(image)\n",
        "        self.add(bits)\n",
        "        self.save_state()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Succession, bits,\n",
        "                lambda m: (Restore(m), MoveToTarget(m)),\n",
        "                lag_ratio=3 / len(bits),\n",
        "            ),\n",
        "            Write(words, rate_func=squish_rate_func(smooth, 0.5, 0.7)),\n",
        "            ShowCreation(lines, lag_ratio=0.1, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        for line, bit in zip(lines, bits[10::11]):\n",
        "            line.bit = bit\n",
        "\n",
        "        for bit in bits:\n",
        "            if bit.get_center()[1] < -FRAME_HEIGHT / 2:\n",
        "                bits.remove(bit)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # Show many 16 bit blocks\n",
        "        bits.generate_target()\n",
        "        bits.target.scale(1.5)\n",
        "        bits.target.arrange_in_grid(n_cols=11, h_buff=SMALL_BUFF, v_buff=LARGE_BUFF)\n",
        "        bits.target.move_to(bits, UR)\n",
        "\n",
        "        box_groups = VGroup()\n",
        "        box_arrows = VGroup()\n",
        "        for bit in bits.target[0:77:11]:\n",
        "            boxes = VGroup(*[Square() for x in range(16)])\n",
        "            boxes.arrange_in_grid(4, 4, buff=0)\n",
        "            boxes.set_height(0.8)\n",
        "            boxes.next_to(bit, LEFT, buff=1.5)\n",
        "            boxes.set_stroke(GREY_B, 2)\n",
        "            arrow = Arrow(bit.get_left(), boxes.get_right())\n",
        "            box_arrows.add(arrow)\n",
        "            box_groups.add(boxes)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(image, 2 * LEFT),\n",
        "            MoveToTarget(bits, run_time=2),\n",
        "            LaggedStartMap(FadeIn, box_groups, run_time=4),\n",
        "            LaggedStartMap(GrowArrow, box_arrows, run_time=4),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate to one box\n",
        "        first_bits = bits[:11]\n",
        "        first_boxes = box_groups[0]\n",
        "\n",
        "        first_bits.generate_target()\n",
        "        first_bits.target.set_height(0.6)\n",
        "        first_bits.target.to_edge(UP)\n",
        "        first_bits.target.set_x(-3)\n",
        "        first_boxes.generate_target()\n",
        "        first_boxes.target.set_height(5)\n",
        "        first_boxes.target.next_to(first_bits.target, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(first_bits),\n",
        "            MoveToTarget(first_boxes),\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                *bits[11:], box_arrows, box_groups[1:],\n",
        "                *lines, words,\n",
        "            ]), lag_ratio=0.01),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        bits = first_bits\n",
        "        boxes = first_boxes\n",
        "\n",
        "        # Try it yourself\n",
        "        morty = Mortimer()\n",
        "        morty.to_edge(DR)\n",
        "        self.play(\n",
        "            PiCreatureSays(morty, \"Try it\\\\\\\\yourself\", target_mode=\"hooray\"),\n",
        "            VFadeIn(morty)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(morty),\n",
        "            FadeOut(morty.bubble),\n",
        "            FadeOut(morty.bubble.content),\n",
        "        ))\n",
        "\n",
        "        # Fill block\n",
        "        N = 4\n",
        "        ecc_boxes = VGroup(*[boxes[2**n] for n in range(N)])\n",
        "        message_boxes = VGroup(*[\n",
        "            box for box in boxes[1:]\n",
        "            if box not in ecc_boxes\n",
        "        ])\n",
        "        pos_labels = get_grid_position_labels(boxes, height=0.2)\n",
        "        pos_labels.set_color(GREY_B)\n",
        "\n",
        "        self.play(\n",
        "            ecc_boxes.set_fill, GREEN, 0.7,\n",
        "            boxes[0].set_fill, YELLOW, 0.5,\n",
        "            FadeIn(pos_labels, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            ApplyMethod(bit.move_to, box)\n",
        "            for bit, box in zip(bits, message_boxes)\n",
        "        ], run_time=4, lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        # Organize bits properly\n",
        "        bit_template = bits[0].copy()\n",
        "        if get_bit_mob_value(bit_template) == 1:\n",
        "            toggle_bit(bit_template)\n",
        "\n",
        "        new_bits = [None] * 16\n",
        "        for i in [0, 1, 2, 4, 8]:\n",
        "            new_bits[i] = bit_template.copy()\n",
        "            new_bits[i].move_to(boxes[i])\n",
        "\n",
        "        bits_iter = iter(bits)\n",
        "        for i, new_bit in enumerate(new_bits):\n",
        "            if new_bit is None:\n",
        "                new_bits[i] = next(bits_iter)\n",
        "\n",
        "        bits = VGroup(*new_bits)\n",
        "\n",
        "        # Show parity groups\n",
        "        boxes.save_state()\n",
        "        self.add(boxes, pos_labels, bits)\n",
        "        for bit in bits:\n",
        "            for part in bit:\n",
        "                if part.get_fill_opacity() > 0:\n",
        "                    part.set_fill(opacity=1)\n",
        "            bit.save_state()\n",
        "        VGroup(*bits[:3], bits[4], bits[8]).set_opacity(0)\n",
        "\n",
        "        for n in range(N):\n",
        "            boxes.generate_target()\n",
        "            boxes.target.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(boxes.target, n).set_fill(BLUE, 0.8)\n",
        "            for k in range(n):\n",
        "                boxes.target[2**k].set_fill(GREEN, 0.5)\n",
        "            one_rects = get_one_rects(get_bit_n_subgroup(bits, n))\n",
        "            counter = get_ones_counter(boxes[10:12], one_rects, buff=1.5)\n",
        "            counter.match_height(bits[0])\n",
        "\n",
        "            self.play(MoveToTarget(boxes))\n",
        "            self.add(counter)\n",
        "            self.play(ShowIncreasingSubsets(one_rects))\n",
        "            self.wait()\n",
        "            self.play(Restore(bits[2**n]))\n",
        "            if counter.get_value() % 2 == 1:\n",
        "                rect_copy = one_rects[0].copy()\n",
        "                rect_copy.move_to(bits[2**n])\n",
        "                one_rects.add(rect_copy)\n",
        "                bits[2**n][0].set_opacity(1)\n",
        "                toggle_bit(bits[2**n])\n",
        "                self.add(rect_copy)\n",
        "                self.wait()\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeOut, VGroup(*one_rects, counter), run_time=1),\n",
        "            )\n",
        "        self.play(Restore(boxes))\n",
        "\n",
        "        # Final parity check\n",
        "        one_rects = get_one_rects(bits)\n",
        "        counter = get_ones_counter(boxes[10:12], one_rects, buff=1.5)\n",
        "        counter.match_height(bits[0])\n",
        "\n",
        "        self.add(counter)\n",
        "        self.play(ShowIncreasingSubsets(one_rects))\n",
        "        self.wait()\n",
        "        self.play(Restore(bits[0]))\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(*one_rects, counter)))\n",
        "        self.wait()\n",
        "\n",
        "        # Send as a message\n",
        "        block_group = VGroup(boxes, pos_labels, bits)\n",
        "        pis, names = get_sender_and_receiver()\n",
        "        randy, morty = pis\n",
        "\n",
        "        line = Line(randy.get_corner(UR), morty.get_corner(UL), buff=MED_SMALL_BUFF)\n",
        "        line.add(\n",
        "            Dot().move_to(line.get_start(), RIGHT),\n",
        "            Dot().move_to(line.get_end(), LEFT),\n",
        "        )\n",
        "        line.set_stroke(GREY, 2)\n",
        "        line_label = OldTexText(\"Noisy channel\")\n",
        "        line_label.next_to(line, DOWN, SMALL_BUFF)\n",
        "        line_label.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(pis),\n",
        "            FadeIn(names, DOWN),\n",
        "            randy.change, \"raise_right_hand\",\n",
        "            block_group.set_height, 1,\n",
        "            block_group.move_to, randy.get_corner(UR), DOWN,\n",
        "            block_group.shift, 0.1 * UP,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(line_label)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            block_group.match_x, line,\n",
        "            randy.change, \"happy\", morty.eyes,\n",
        "        )\n",
        "\n",
        "        # Possible changes\n",
        "        black_box = SurroundingRectangle(block_group, buff=0)\n",
        "        black_box.set_fill(GREY_D, 1)\n",
        "        black_box.set_stroke(WHITE, 2)\n",
        "        change_words = VGroup(\n",
        "            OldTexText(\"Maybe flip 0 bits\"),\n",
        "            OldTexText(\"Maybe flip 1 bit\"),\n",
        "            OldTexText(\"Maybe flip 2 bits\"),\n",
        "        )\n",
        "        colors = [WHITE, RED_B, RED]\n",
        "        for word, color in zip(change_words, colors):\n",
        "            word.next_to(black_box, UP)\n",
        "            word.set_color(color)\n",
        "\n",
        "        morty_arrow = Vector(DOWN)\n",
        "        morty_arrow.next_to(morty, UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(morty_arrow),\n",
        "            morty.change, \"pondering\", morty_arrow\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(morty))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty_arrow.next_to, block_group, UP,\n",
        "            FadeIn(black_box),\n",
        "            morty.look_at, black_box,\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeIn(change_words[0], 0.25 * DOWN),\n",
        "            FadeOut(morty_arrow, UP),\n",
        "            morty.change, \"confused\", change_words[0],\n",
        "        )\n",
        "        for i in [1, 2]:\n",
        "            self.play(\n",
        "                FadeIn(change_words[i], 0.25 * DOWN),\n",
        "                change_words[:i].shift, UP,\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        error_pos = 10\n",
        "        toggle_bit(bits[error_pos])\n",
        "\n",
        "        self.add(block_group, black_box)\n",
        "        self.play(\n",
        "            FadeOut(black_box),\n",
        "            FadeOut(change_words),\n",
        "        )\n",
        "        self.play(\n",
        "            block_group.set_x, line.get_end()[0],\n",
        "            morty.change, \"pondering\", line.get_end() + UP,\n",
        "        )\n",
        "        self.play(\n",
        "            Uncreate(line),\n",
        "            FadeOut(line_label, DOWN),\n",
        "            FadeOut(randy, DL),\n",
        "            FadeOut(morty, DR),\n",
        "            FadeOut(names, DOWN),\n",
        "            block_group.set_height, 5,\n",
        "            block_group.set_y, 0,\n",
        "            block_group.to_edge, RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Try it!\n",
        "        try_it_words = OldTexText(\"Try it\\\\\\\\yourself!\")\n",
        "        try_it_words.scale(2)\n",
        "        try_it_words.next_to(boxes, LEFT, buff=2)\n",
        "        self.play(FadeIn(try_it_words, RIGHT))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(try_it_words, LEFT))\n",
        "\n",
        "        # Do parity checks\n",
        "        working_grid = boxes.copy()\n",
        "        working_grid.to_edge(LEFT)\n",
        "        working_grid_words = OldTexText(\"Possibilities\")\n",
        "        working_grid_words.set_color(BLUE)\n",
        "        working_grid_words.next_to(working_grid, UP)\n",
        "        working_grid.set_fill(BLUE, 0.7)\n",
        "        working_pos_labels = get_grid_position_labels(working_grid)\n",
        "\n",
        "        counter = Integer(0)\n",
        "        counter.set_height(0.7)\n",
        "        counter.set_color(YELLOW)\n",
        "        counter.next_to(boxes, LEFT, MED_LARGE_BUFF)\n",
        "        counter.counted = VGroup()\n",
        "        counter.add_updater(lambda m: m.set_value(len(m.counted)))\n",
        "        for n in range(N):\n",
        "            off_bits = get_bit_n_subgroup(bits, n, 0)\n",
        "            on_bits = get_bit_n_subgroup(bits, n, 1)\n",
        "            rects = get_one_rects(on_bits)\n",
        "            counter.counted = rects\n",
        "\n",
        "            self.play(FadeOut(off_bits))\n",
        "            self.add(counter)\n",
        "            self.play(ShowIncreasingSubsets(rects))\n",
        "\n",
        "            to_fade = get_bit_n_subgroup(working_grid, n, 1 - (len(rects) % 2))\n",
        "            if n == 0:\n",
        "                to_fade.set_fill(BLACK, 0)\n",
        "                self.play(\n",
        "                    FadeIn(working_grid),\n",
        "                    FadeIn(working_pos_labels),\n",
        "                    FadeIn(working_grid_words),\n",
        "                )\n",
        "            else:\n",
        "                self.play(to_fade.set_fill, BLACK, 0)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(counter),\n",
        "                FadeOut(rects),\n",
        "                FadeIn(off_bits),\n",
        "            )\n",
        "\n",
        "        # Move working grid\n",
        "        self.add(working_grid, block_group)\n",
        "        self.play(\n",
        "            ApplyMethod(working_grid.move_to, boxes, run_time=2),\n",
        "            FadeOut(working_grid_words),\n",
        "            FadeOut(working_pos_labels),\n",
        "        )\n",
        "\n",
        "        # Full parity check\n",
        "        rects = get_one_rects(bits)\n",
        "        counter.counted = rects\n",
        "        self.add(counter)\n",
        "        self.play(ShowIncreasingSubsets(rects))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rects), FadeOut(counter))\n",
        "\n",
        "        # Correct error bit\n",
        "        self.play(toggle_bit_anim(bits[error_pos]))\n",
        "        self.play(FadeOut(working_grid))\n",
        "        self.wait()\n",
        "\n",
        "        # Show 11 message bits\n",
        "        block_group.generate_target()\n",
        "        block_group.target.center()\n",
        "        block_group.target.to_edge(DOWN)\n",
        "        VGroup(*[\n",
        "            block_group.target[2][i]\n",
        "            for i in [0, 1, 2, 4, 8]\n",
        "        ]).set_color(GREY_C)\n",
        "        self.play(MoveToTarget(block_group))\n",
        "\n",
        "        message_bits = VGroup(*[\n",
        "            bit for i, bit in enumerate(bits)\n",
        "            if i not in [0, 1, 2, 4, 8]\n",
        "        ])\n",
        "        message_bits.generate_target()\n",
        "        message_bits.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        message_bits.target.to_edge(UP)\n",
        "        for mb, mt in zip(message_bits, message_bits.target):\n",
        "            mb.target = mt\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, message_bits,\n",
        "            lag_ratio=0.3,\n",
        "            run_time=4,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def old_parity_checks(self):\n",
        "        questions = VGroup(*[boxes.copy() for x in range(4)])\n",
        "        questions.set_height(1)\n",
        "        questions.arrange(DOWN, buff=0.5)\n",
        "        questions.set_height(6)\n",
        "        questions.to_edge(LEFT, buff=1)\n",
        "\n",
        "        counter = Integer(0, color=YELLOW)\n",
        "        counter.match_height(bits[0])\n",
        "        counter.next_to(boxes, LEFT, LARGE_BUFF)\n",
        "\n",
        "        boxes.save_state()\n",
        "        self.add(boxes, pos_labels, bits)\n",
        "        results = VGroup()\n",
        "        for n, question in enumerate(questions):\n",
        "            question.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(question, n).set_fill(BLUE, 0.7)\n",
        "\n",
        "            one_rects = get_one_rects(get_bit_n_subgroup(bits, n))\n",
        "            counter.set_value(len(one_rects))\n",
        "\n",
        "            boxes.generate_target()\n",
        "            boxes.target.match_style(question)\n",
        "\n",
        "            self.play(MoveToTarget(boxes))\n",
        "            self.play(FadeIn(one_rects))\n",
        "\n",
        "            if counter.get_value() % 2 == 0:\n",
        "                result = Integer(0, color=GREEN)\n",
        "            else:\n",
        "                result = Integer(1, color=RED)\n",
        "            result.next_to(question, RIGHT)\n",
        "            results.add(result)\n",
        "\n",
        "            counter_mover = counter.copy()\n",
        "            counter_mover.generate_target()\n",
        "            counter_mover.target.replace(result, stretch=True)\n",
        "            counter_mover.target.fade(1)\n",
        "            result.save_state()\n",
        "            result.replace(counter, stretch=True)\n",
        "            result.fade(1)\n",
        "\n",
        "            self.play(\n",
        "                ReplacementTransform(boxes.copy().set_fill(opacity=0), question),\n",
        "                MoveToTarget(counter_mover, remover=True),\n",
        "                Restore(result),\n",
        "                FadeOut(one_rects),\n",
        "                FadeOut(counter),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        one_rects = get_one_rects(bits)\n",
        "        counter.set_value(len(one_rects))\n",
        "        words = OldTexText(\"Likely one error\")\n",
        "        words.next_to(counter, DOWN, LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        self.play(\n",
        "            boxes.set_fill, BLACK, 0,\n",
        "            FadeIn(counter),\n",
        "            FadeIn(one_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(words, 0.1 * UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(counter, words, one_rects), lag_ratio=0.2)\n",
        "        )\n",
        "\n",
        "        # Read result\n",
        "        final_result = results.copy()\n",
        "        final_result.arrange(LEFT, buff=SMALL_BUFF)\n",
        "\n",
        "        equation = VGroup(\n",
        "            final_result,\n",
        "            OldTex(\"\\\\rightarrow\"),\n",
        "            Integer(10)\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.play(TransformFromCopy(results, final_result, run_time=3, lag_ratio=0.3))\n",
        "        self.play(\n",
        "            Write(equation[1]),\n",
        "            FadeIn(equation[2], LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        boxes.generate_target()\n",
        "        boxes.target[10].set_fill(BLUE, 0.7)\n",
        "        self.play(MoveToTarget(boxes))\n",
        "        self.play(toggle_bit_anim(bits[10]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut, VGroup(*equation, *questions, *results),\n",
        "                lambda m: (m, DOWN),\n",
        "            ),\n",
        "            Restore(boxes),\n",
        "        )\n",
        "\n",
        "\n",
        "class ByHandVsSoftwareVsHardware(Scene):\n",
        "    def construct(self):\n",
        "        self.add(get_background(GREY_E))\n",
        "\n",
        "        rects = VGroup(*[ScreenRectangle() for x in range(3)])\n",
        "        rects.set_stroke(GREY_B)\n",
        "        rects.set_fill(BLACK, 1)\n",
        "        rects.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        rects.set_width(FRAME_WIDTH - 1)\n",
        "        rects[0].shift(UP)\n",
        "        rects[2].shift(DOWN)\n",
        "        self.add(rects)\n",
        "\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"By hand\"),\n",
        "            OldTexText(\"In software\"),\n",
        "            OldTexText(\"In hardware\"),\n",
        "        )\n",
        "        for label, rect in zip(labels, rects):\n",
        "            label.next_to(rect, DOWN)\n",
        "\n",
        "        randy = Randolph(height=1.25)\n",
        "        randy.next_to(rects[0], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, labels,\n",
        "                lambda m: (m, 0.5 * UP),\n",
        "                lag_ratio=0.4,\n",
        "            ),\n",
        "            randy.change, 'thinking', rects[0],\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        randy.generate_target()\n",
        "        randy.target.next_to(rects[1], UP, SMALL_BUFF)\n",
        "        randy.target.change(\"hooray\", rects[1])\n",
        "        self.play(\n",
        "            MoveToTarget(randy, path_arc=-45 * DEGREES)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, 'thinking', rects[1])\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(Scene):\n",
        "    def construct(self):\n",
        "        self.add(get_background(GREY_E))\n",
        "\n",
        "        rects = VGroup(*[ScreenRectangle() for x in range(2)])\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        rects.set_fill(BLACK, 1)\n",
        "        rects.set_height(3)\n",
        "        rects.arrange(RIGHT, buff=1)\n",
        "        rects.shift(UP)\n",
        "        self.add(rects)\n",
        "\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"Part 2\\\\\\\\\", \"the elegance of it all\"),\n",
        "            OldTexText(\"Ben Eater\\\\\\\\\", \"doing this on breadboards\"),\n",
        "        )\n",
        "\n",
        "        for label, rect in zip(labels, rects):\n",
        "            label[0].scale(1.5, about_edge=DOWN)\n",
        "            label.scale(0.9)\n",
        "            label.next_to(rect, DOWN)\n",
        "\n",
        "        self.add(labels)\n",
        "\n",
        "        self.add(AnimatedBoundary(rects[0]))\n",
        "        self.wait()\n",
        "        self.add(AnimatedBoundary(rects[1]))\n",
        "        self.wait(19)\n",
        "\n",
        "\n",
        "# Part 2\n",
        "\n",
        "class Thumbnail2(AltThumbnail):\n",
        "    def construct(self):\n",
        "        self.add(self.get_background())\n",
        "\n",
        "        # Test\n",
        "\n",
        "        # code = ImageMobject(\"HammingCodeOneLine\")\n",
        "        code = Code(\"\"\"\n",
        "            reduce(\n",
        "                lambda x, y: x^y,\n",
        "                (i for (i, bit) in enumerate(block) if bit)\n",
        "            )\n",
        "        \"\"\", alignment=\"LEFT\")\n",
        "        code.set_width(FRAME_WIDTH - 3)\n",
        "        br = SurroundingRectangle(code, buff=MED_SMALL_BUFF)\n",
        "        br.set_fill(BLACK, 1)\n",
        "        br.set_stroke(GREY_B, 2)\n",
        "        code = Group(br, code)\n",
        "        code.set_width(10)\n",
        "        code.to_edge(DOWN)\n",
        "        self.add(code)\n",
        "\n",
        "        words = Text(\"One line\", font_size=90)\n",
        "        words.next_to(code, UP)\n",
        "        words.set_stroke(BLACK, 20, background=True)\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class Part1Wrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(get_background())\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.set_stroke(GREY_B, 2)\n",
        "        rect.set_height(6)\n",
        "        rect.to_edge(DOWN)\n",
        "        title = OldTexText(\"Part 1\")\n",
        "        title.set_height(0.7)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(rect)\n",
        "        self.add(AnimatedBoundary(rect, max_stroke_width=2, cycle_rate=0.25))\n",
        "        self.play(Write(title))\n",
        "        self.wait(35)\n",
        "\n",
        "\n",
        "class AskHowItsImplemented(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"How do you\\\\\\\\implement this?\")\n",
        "        self.play(\n",
        "            self.teacher.change, \"happy\",\n",
        "            self.change_students(\"pondering\", \"confused\"),\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class ScaleUp(Scene):\n",
        "    def construct(self):\n",
        "        square_template = Square()\n",
        "        square_template.set_stroke(GREY_B, 2)\n",
        "        square_template.set_height(1)\n",
        "        zero = Integer(0)\n",
        "        one = Integer(1)\n",
        "\n",
        "        last_grid = None\n",
        "        last_parity_groups = None\n",
        "        last_words = None\n",
        "\n",
        "        for N in range(4, 13):\n",
        "            grid = VGroup(*[square_template.copy() for x in range(2**N)])\n",
        "            grid.arrange_in_grid(\n",
        "                2**int(math.floor(N / 2)),\n",
        "                2**int(math.ceil(N / 2)),\n",
        "                buff=0\n",
        "            )\n",
        "            grid.set_width(5.5)\n",
        "            if N > 8:\n",
        "                grid.set_stroke(width=1)\n",
        "            elif N > 10:\n",
        "                grid.set_stroke(width=0.25)\n",
        "            grid.set_stroke(background=True)\n",
        "\n",
        "            grid[0].set_fill(YELLOW, 0.6)\n",
        "            for n in range(N):\n",
        "                grid[2**n].set_fill(GREEN, 0.7)\n",
        "\n",
        "            parity_groups = VGroup()\n",
        "            for n in range(N):\n",
        "                group = grid.copy()\n",
        "                group.set_fill(BLACK, 0)\n",
        "                get_bit_n_subgroup(group, n).set_fill(BLUE, 0.8)\n",
        "                parity_groups.add(group)\n",
        "            parity_groups.arrange_in_grid(n_cols=2, buff=1.5)\n",
        "            parity_groups.set_width(5)\n",
        "            max_height = 7\n",
        "            if parity_groups.get_height() > max_height:\n",
        "                parity_groups.set_height(max_height)\n",
        "            parity_groups.to_edge(RIGHT, buff=0.5)\n",
        "\n",
        "            random.seed(0)\n",
        "            for square in grid:\n",
        "                bit = random.choice([zero, one]).copy()\n",
        "                bit.replace(square, dim_to_match=1)\n",
        "                bit.scale(0.5)\n",
        "                square.add(bit)\n",
        "\n",
        "            redun = \"{:.3}\".format((N + 1) / (2**N))\n",
        "            words = OldTex(\n",
        "                f\"\"\"\n",
        "                {{ {{{N + 1}}} \\\\text{{ parity bits}}\n",
        "                \\\\over\n",
        "                {2**N} \\\\text{{ bits per block}} }}\n",
        "                \\\\approx {redun}\n",
        "                \"\"\",\n",
        "                tex_to_color_map={\n",
        "                    f\"{{{N + 1}}}\": GREEN,\n",
        "                    f\"{2**N}\": WHITE,\n",
        "                    f\"{redun}\": YELLOW,\n",
        "                },\n",
        "                fill_color=GREY_A\n",
        "            )\n",
        "            words.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "            grid.next_to(words, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "            if last_grid is None:\n",
        "                self.add(grid)\n",
        "                self.add(parity_groups)\n",
        "                self.add(words)\n",
        "            else:\n",
        "                self.play(\n",
        "                    ReplacementTransform(last_grid, grid[:2**(N - 1)]),\n",
        "                    FadeIn(grid[2**(N - 1):], lag_ratio=0.1, run_time=2),\n",
        "                    FadeOut(last_parity_groups),\n",
        "                    LaggedStartMap(FadeIn, parity_groups, lag_ratio=0.2, run_time=2),\n",
        "                    FadeOut(last_words, UP),\n",
        "                    FadeIn(words, DOWN),\n",
        "                )\n",
        "            self.wait()\n",
        "\n",
        "            last_grid = grid\n",
        "            last_parity_groups = parity_groups\n",
        "            last_words = words\n",
        "\n",
        "\n",
        "class MillionRatio(Scene):\n",
        "    def construct(self):\n",
        "        # Largely copied from above\n",
        "        N = 20\n",
        "        words = OldTex(\n",
        "            \"\"\"\n",
        "            {21 \\\\text{ parity bits}\n",
        "            \\\\over\n",
        "            1{,}048{,}576 \\\\text{ bits per block} }\n",
        "            \\\\approx 0.00002\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"21\": GREEN,\n",
        "                \"1{,}048{,}576\": WHITE,\n",
        "                \"0.00002\": YELLOW,\n",
        "            },\n",
        "            fill_color=GREY_A\n",
        "        )\n",
        "        words.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "        st = Square()\n",
        "        st.set_stroke(GREY, 0.5)\n",
        "        grid = VGroup(*[st.copy() for x in range(2**(16))])\n",
        "        grid.arrange_in_grid(buff=0)\n",
        "        grid.set_height(6)\n",
        "        grid.next_to(words, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        k = 17\n",
        "        positions = VGroup(*[\n",
        "            OldTex(int_to_bit_string(n, n_bits=20))\n",
        "            for n in [*range(k), *range(2**N - k // 2, 2**N)]\n",
        "        ])\n",
        "        positions.replace_submobject(-k // 2, OldTex(\"\\\\vdots\"))\n",
        "        positions.arrange(DOWN)\n",
        "        positions.set_height(7)\n",
        "        positions.to_edge(RIGHT)\n",
        "        for n in [0, 1, 2, 4, 8, 16]:\n",
        "            positions[n].set_color(GREEN_B)\n",
        "\n",
        "        brace = Brace(positions, LEFT, buff=SMALL_BUFF)\n",
        "        p_label = OldTexText(\"$2^{20}$\\\\\\\\positions\")\n",
        "        p_label.next_to(brace, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(positions, run_time=3),\n",
        "            GrowFromPoint(brace, brace.get_top(), run_time=3, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            FadeIn(p_label, 0.5 * RIGHT, run_time=3, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        grid.set_stroke(background=True)\n",
        "        for n in range(16):\n",
        "            grid.set_fill(BLACK, 0)\n",
        "            get_bit_n_subgroup(grid, n).set_fill(BLUE, 0.8)\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class BurstErrors(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        bl = 8\n",
        "        nb = 4\n",
        "\n",
        "        bits = get_bit_grid(1, bl * nb, bits=string_to_bits(\"3b1b\"))\n",
        "        bits.set_height(0.5)\n",
        "        bits.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        bits.move_to(DOWN)\n",
        "        self.add(bits)\n",
        "\n",
        "        colors = [BLUE, YELLOW, MAROON_B, TEAL]\n",
        "        block_words = VGroup(*[\n",
        "            OldTexText(f\"Block {n}\", fill_color=color)\n",
        "            for n, color in zip(range(nb), colors)\n",
        "        ])\n",
        "        block_words.set_height(0.5)\n",
        "        block_words.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        block_words.move_to(2 * UP)\n",
        "        self.add(block_words)\n",
        "\n",
        "        # Add lines\n",
        "        lines = VGroup()\n",
        "        for n, bit in enumerate(bits):\n",
        "            words = block_words[n // bl]\n",
        "            line = Line()\n",
        "            line.match_color(words)\n",
        "            line.set_stroke(width=2)\n",
        "            line.words = words\n",
        "            line.bit = bit\n",
        "            bit.line = line\n",
        "            underline = Underline(bit)\n",
        "            underline.set_stroke(words.get_color(), 4)\n",
        "            bit.add(underline)\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "                m.words.get_bottom() + SMALL_BUFF * DOWN,\n",
        "                m.bit.get_top(),\n",
        "            ))\n",
        "            lines.add(line)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, lines, suspend_mobject_updating=True))\n",
        "        self.wait()\n",
        "\n",
        "        # Show burst error\n",
        "        error_bits = bits[9:13]\n",
        "        error_words = OldTexText(\"Burst of errors\")\n",
        "        error_words.next_to(error_bits, DOWN)\n",
        "        error_words.set_color(RED)\n",
        "        ruined_words = OldTexText(\"Ruined\")\n",
        "        ruined_words.set_color(RED)\n",
        "        ruined_words.next_to(block_words[1], UP)\n",
        "        strike = Line(LEFT, RIGHT)\n",
        "        strike.replace(block_words[1])\n",
        "        strike.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(toggle_bit_anim, error_bits, target_color=RED),\n",
        "            LaggedStart(*map(zap_anim, error_bits)),\n",
        "            Write(error_words)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(strike),\n",
        "            FadeIn(ruined_words, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(ruined_words, 0.2 * UP),\n",
        "            FadeOut(error_words, 0.2 * DOWN),\n",
        "            FadeOut(strike),\n",
        "            LaggedStartMap(toggle_bit_anim, error_bits, target_color=WHITE),\n",
        "            run_time=1,\n",
        "        )\n",
        "        for bit in error_bits:\n",
        "            bit[-1].set_color(YELLOW)\n",
        "\n",
        "        # Rearrange\n",
        "        new_order = VGroup()\n",
        "        for i in range(bl):\n",
        "            for j in range(nb):\n",
        "                new_order.add(bits[bl * j + i])\n",
        "        new_order.generate_target()\n",
        "        new_order.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        new_order.target.replace(bits)\n",
        "\n",
        "        self.play(MoveToTarget(new_order, run_time=3, path_arc=30 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        # New burst\n",
        "        error_bits = new_order[9:13]\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(toggle_bit_anim, error_bits, target_color=RED),\n",
        "            LaggedStart(*map(zap_anim, error_bits)),\n",
        "            Write(error_words),\n",
        "        )\n",
        "        non_error_lines = VGroup()\n",
        "        for line in lines:\n",
        "            if line.bit not in error_bits:\n",
        "                non_error_lines.add(line)\n",
        "        self.play(non_error_lines.set_stroke, {\"width\": 1, \"opacity\": 0.5})\n",
        "        self.wait()\n",
        "\n",
        "        error_words = VGroup(*[TexText(\"1 error\", fill_color=GREEN) for x in range(4)])\n",
        "        for ew, bw in zip(error_words, block_words):\n",
        "            ew.next_to(bw, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, error_words, lambda m: (m, DOWN)))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BinaryCounting(Scene):\n",
        "    def construct(self):\n",
        "        def get_bit_grids(bit_values):\n",
        "            left_bits = get_bit_grid(4, 1, buff=LARGE_BUFF, bits=bit_values, height=6)\n",
        "            left_bits.move_to(3 * LEFT)\n",
        "            right_bits = get_bit_grid(1, 4, buff=SMALL_BUFF, bits=bit_values, height=0.6)\n",
        "            right_bits.set_submobjects(list(reversed(right_bits)))\n",
        "            right_bits.move_to(RIGHT + 2 * UP)\n",
        "            return VGroup(left_bits, right_bits)\n",
        "\n",
        "        bit_grids = get_bit_grids([0, 0, 0, 0])\n",
        "\n",
        "        brace = Brace(bit_grids[1], UP)\n",
        "        counter = Integer(0, edge_to_fix=ORIGIN)\n",
        "        counter.match_height(bit_grids[1])\n",
        "        counter.set_color(BLUE)\n",
        "        counter.next_to(brace, UP)\n",
        "\n",
        "        boxes = VGroup(*[Square() for x in range(16)])\n",
        "        boxes.arrange_in_grid(4, 4, buff=0)\n",
        "        boxes.set_height(4)\n",
        "        boxes.next_to(bit_grids[1], DOWN, LARGE_BUFF)\n",
        "        boxes.set_stroke(GREY_B, 2)\n",
        "        pos_labels = get_grid_position_labels(boxes)\n",
        "\n",
        "        self.add(bit_grids)\n",
        "        self.add(brace)\n",
        "        self.add(counter)\n",
        "        self.add(boxes)\n",
        "        self.add(pos_labels)\n",
        "\n",
        "        for n in range(16):\n",
        "            bit_values = list(map(int, int_to_bit_string(n, n_bits=4)))\n",
        "            boxes.generate_target()\n",
        "            boxes.target.set_fill(BLACK, 0)\n",
        "            boxes.target[n].set_fill(BLUE, 0.8)\n",
        "            anims = [\n",
        "                ChangeDecimalToValue(counter, n),\n",
        "                MoveToTarget(boxes)\n",
        "            ]\n",
        "            for grid in bit_grids:\n",
        "                for bit, bv in zip(grid, reversed(bit_values)):\n",
        "                    if get_bit_mob_value(bit) != bv:\n",
        "                        anims.append(toggle_bit_anim(bit))\n",
        "            self.play(*anims, run_time=0.5)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ReviewOfXOR(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup equations\n",
        "        xor = get_xor()\n",
        "\n",
        "        equations = VGroup()\n",
        "        for n in range(4):\n",
        "            bits = list(map(int, int_to_bit_string(n, n_bits=2)))\n",
        "            equation = VGroup(\n",
        "                Integer(bits[0]),\n",
        "                xor.copy(),\n",
        "                Integer(bits[1]),\n",
        "                OldTex(\"=\"),\n",
        "                Integer(op.xor(*bits)),\n",
        "            )\n",
        "            equation.set_height(0.6)\n",
        "            equation.arrange(RIGHT)\n",
        "            equations.add(equation)\n",
        "\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        # Intro xor\n",
        "        equation = equations[1]\n",
        "        equation.save_state()\n",
        "        equation.center()\n",
        "        equation[3:].set_opacity(0)\n",
        "\n",
        "        arrow = Vector(0.7 * DOWN)\n",
        "        arrow.next_to(equation[1], UP, SMALL_BUFF)\n",
        "        xor_word = OldTexText(\"xor\")\n",
        "        xor_word_long = OldTexText(\"``exclusive or''\")\n",
        "        xor_words = VGroup(xor_word, xor_word_long)\n",
        "        xor_words.scale(1.5)\n",
        "        xor_words.match_color(xor)\n",
        "        xor_words.next_to(arrow, UP)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            FadeIn(equation[1], 0.5 * UP),\n",
        "            GrowArrow(arrow),\n",
        "            Write(xor_word),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            xor_word.next_to, xor_word_long, UP, MED_SMALL_BUFF,\n",
        "            FadeIn(xor_word_long, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            xor_words.to_corner, UL,\n",
        "            Restore(equation),\n",
        "            FadeIn(equations[2], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(equations[0], DOWN),\n",
        "            FadeIn(equations[3], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Parity of two bits\n",
        "        parity_words = OldTexText(\"Parity of\\\\\\\\two bits\")\n",
        "        parity_words.set_color(YELLOW)\n",
        "        parity_words.scale(1.5)\n",
        "        parity_words.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for equation in equations:\n",
        "            globals()['equation'] = equation\n",
        "            new_arrows = VGroup(*[\n",
        "                Arrow(equation[i].get_top(), equation[4].get_top(), path_arc=-60 * DEGREES)\n",
        "                for i in [0, 2]\n",
        "            ])\n",
        "            new_arrows.set_color(YELLOW)\n",
        "            arrows.add(new_arrows)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, arrows),\n",
        "            FadeIn(parity_words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Addition mod 2\n",
        "        mod2_words = OldTexText(\"Addition\\\\\\\\mod 2\")\n",
        "        mod2_words.scale(1.5)\n",
        "        mod2_words.move_to(parity_words, RIGHT)\n",
        "        mod2_words.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(mod2_words, DOWN),\n",
        "            FadeOut(parity_words, UP),\n",
        "            FadeOut(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # xor of two bit strings\n",
        "        row_len = 8\n",
        "        bit_strings = VGroup(*[\n",
        "            Integer(random.choice([0, 1]), edge_to_fix=ORIGIN)\n",
        "            for x in range(row_len * 3)\n",
        "        ])\n",
        "        bit_strings.arrange_in_grid(\n",
        "            3, row_len,\n",
        "            h_buff=SMALL_BUFF,\n",
        "            v_buff=MED_LARGE_BUFF,\n",
        "            fill_rows_first=False\n",
        "        )\n",
        "        bit_strings.scale(equation[0][0].get_height() / bit_strings[0].get_height())\n",
        "        rows = VGroup(*[bit_strings[i::3] for i in range(3)])\n",
        "        rows[0].next_to(rows[1], UP, buff=0.25)\n",
        "\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_width(bit_strings.get_width() + 1)\n",
        "        line.move_to(bit_strings[-2:], RIGHT)\n",
        "        line.set_stroke(GREY_B, 3)\n",
        "        line_xor = xor.copy()\n",
        "        line_xor.set_height(0.5)\n",
        "        line_xor.next_to(line, UP, aligned_edge=LEFT)\n",
        "\n",
        "        for b1, b2, b3 in zip(*[row for row in rows]):\n",
        "            b3.set_value(b1.get_value() ^ b2.get_value())\n",
        "            b2.match_x(b1)\n",
        "            b3.match_x(b1)\n",
        "\n",
        "        equations.generate_target()\n",
        "        for n, eq in enumerate(equations.target):\n",
        "            for k, b1 in enumerate(eq[0::2]):\n",
        "                target_bit = bit_strings[3 * n + k]\n",
        "                target_bit.set_value(b1.get_value())\n",
        "                b1.become(target_bit)\n",
        "            eq[1].become(line_xor)\n",
        "            eq[3].fade(1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(equations, run_time=2),\n",
        "            FadeOut(mod2_words),\n",
        "            FadeIn(bit_strings[12:], run_time=2, rate_func=squish_rate_func(smooth, 0.5, 1), lag_ratio=0.1),\n",
        "            ShowCreation(line, run_time=2, rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "        self.remove(equations)\n",
        "        self.add(bit_strings, line_xor)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight columns\n",
        "        last_rect = VMobject()\n",
        "        for b1, b2, b3 in zip(*[row for row in rows]):\n",
        "            rect = SurroundingRectangle(VGroup(b1, b2, b3), buff=SMALL_BUFF)\n",
        "            rect.set_stroke(BLUE, 2)\n",
        "            self.play(FadeIn(rect), FadeOut(last_rect))\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_rect))\n",
        "\n",
        "        # Add more rows\n",
        "        new_rows = VGroup(*[rows[0].copy() for x in range(3)])\n",
        "        new_rows.arrange(DOWN, buff=0.2)\n",
        "        new_rows.next_to(rows, UP, buff=0.2)\n",
        "        for row in new_rows:\n",
        "            for bit in row:\n",
        "                bit.set_value(random.choice([0, 1]))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, new_rows, lambda m: (m, DOWN)),\n",
        "            FadeOut(xor_words),\n",
        "            FadeOut(rows[2])\n",
        "        )\n",
        "\n",
        "        # Compute parities\n",
        "        parity_words = OldTexText(\"Computes\\\\\\\\parity\\\\\\\\of each\\\\\\\\column\", alignment=\"\")\n",
        "        parity_words.set_color(YELLOW)\n",
        "        parity_words.to_corner(UL)\n",
        "        self.add(parity_words)\n",
        "\n",
        "        for tup in zip(*[*new_rows, *rows]):\n",
        "            rects = VGroup()\n",
        "            for bit in tup[:-1]:\n",
        "                if bit.get_value() == 1:\n",
        "                    rect = SurroundingRectangle(bit)\n",
        "                    rect.set_stroke(YELLOW, 2)\n",
        "                    rect.set_fill(YELLOW, 0.5)\n",
        "                    rects.add(rect)\n",
        "            tup[-1].set_value(len(rects) % 2)\n",
        "            tup[-1].set_color(YELLOW)\n",
        "            self.add(rects, *tup)\n",
        "            self.wait()\n",
        "            self.remove(rects)\n",
        "        self.wait()\n",
        "\n",
        "        # Simpler sum\n",
        "        self.play(FadeOut(\n",
        "            VGroup(new_rows, rows[0][4:], rows[1][4:], rows[2][4:]),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        for b1, b2, b3 in zip(*[row[:4] for row in rows]):\n",
        "            b3.set_value(b1.get_value() ^ b2.get_value())\n",
        "            self.wait(0.25)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        integers = VGroup()\n",
        "        for row, n in zip(rows, [3, 5, 6]):\n",
        "            arrow = Vector(0.75 * RIGHT)\n",
        "            arrow.next_to(row[:4], RIGHT, buff=0.2)\n",
        "            integer = Integer(n)\n",
        "            integer.match_height(row[0])\n",
        "            integer.match_color(row[0])\n",
        "            integer.next_to(arrow, RIGHT, buff=0.2)\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                FadeIn(integer, LEFT)\n",
        "            )\n",
        "\n",
        "            arrows.add(arrow)\n",
        "            integers.add(integer)\n",
        "\n",
        "\n",
        "class ButWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Hang on...\\\\\\\\why?\", target_mode=\"confused\",\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"maybe\", \"erm\", \"confused\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class WhyPointToError(Scene):\n",
        "    def construct(self):\n",
        "        rect = SurroundingRectangle(OldTexText(\"0000\").scale(2))\n",
        "        rect.to_edge(RIGHT)\n",
        "        rect.set_stroke(RED, 3)\n",
        "        words = OldTexText(\"Why do these\\\\\\\\point to an error?\")\n",
        "        arrow = Vector(0.7 * RIGHT)\n",
        "        arrow.next_to(rect, LEFT)\n",
        "        words.next_to(arrow, LEFT)\n",
        "        words.set_color(RED)\n",
        "\n",
        "        bit = Integer(0).scale(2)\n",
        "        bit.next_to(words, UP, buff=0.45)\n",
        "        bit.shift(1.11 * words.get_width() * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(rect),\n",
        "        )\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.become, SurroundingRectangle(bit).match_style(rect),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimplePointer(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Arrow(ORIGIN, [-4, 1.5, 0])\n",
        "        arrow.center()\n",
        "        arrow.set_fill(GREY_B)\n",
        "        self.play(DrawBorderThenFill(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ArrowPair(Scene):\n",
        "    def construct(self):\n",
        "        arrows = VGroup(\n",
        "            Vector(LEFT),\n",
        "            Vector(LEFT),\n",
        "        )\n",
        "        arrows.scale(1.5)\n",
        "        arrows.arrange(DOWN, buff=2)\n",
        "        arrows[0].shift(4 * LEFT)\n",
        "        arrows.set_fill(YELLOW)\n",
        "\n",
        "        self.play(*map(GrowArrow, arrows))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PythonXorExample(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class HammingCodesWithXOR(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        bits = get_bit_grid(4, 4, bits=string_to_bits(\":)\"))\n",
        "        bits.to_edge(LEFT, buff=1.5)\n",
        "        boxes = get_bit_grid_boxes(bits)\n",
        "        block = VGroup(boxes, bits)\n",
        "        block.set_height(6)\n",
        "        for bit in bits:\n",
        "            bit.set_height(0.7)\n",
        "\n",
        "        bin_pos_labels = VGroup()\n",
        "        dec_pos_labels = VGroup()\n",
        "        for n, box, bit in zip(it.count(), boxes, bits):\n",
        "            bin_label = VGroup(\n",
        "                *[Integer(int(c)) for c in int_to_bit_string(n, n_bits=4)]\n",
        "            )\n",
        "            bin_label.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "            bin_label.set_color(GREY_B)\n",
        "            bin_label.set_width(0.7 * box.get_width())\n",
        "            bin_label.move_to(box, DOWN)\n",
        "            bin_label.shift(SMALL_BUFF * UP)\n",
        "            bin_pos_labels.add(bin_label)\n",
        "\n",
        "            dec_label = Integer(n)\n",
        "            dec_label.match_height(bin_label)\n",
        "            dec_label.match_style(bin_label[0])\n",
        "            dec_label.move_to(bin_label, DR)\n",
        "            dec_pos_labels.add(dec_label)\n",
        "\n",
        "            bit.generate_target()\n",
        "            bit.target.scale(0.9)\n",
        "            bit.target.move_to(box, UP)\n",
        "            bit.target.shift(MED_SMALL_BUFF * DOWN)\n",
        "\n",
        "        # Enumerate\n",
        "        self.add(block)\n",
        "        kw = {\"lag_ratio\": 0.3, \"run_time\": 2}\n",
        "        self.play(LaggedStartMap(FadeIn, dec_pos_labels, **kw))\n",
        "        self.wait()\n",
        "        kw[\"lag_ratio\"] = 0.1\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, dec_pos_labels, **kw),\n",
        "            LaggedStartMap(FadeIn, bin_pos_labels, **kw),\n",
        "            LaggedStartMap(MoveToTarget, bits, **kw),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight ones\n",
        "        summands = VGroup()\n",
        "        for bit, box, label in zip(bits, boxes, bin_pos_labels):\n",
        "            for mob in bit, box, label:\n",
        "                mob.save_state()\n",
        "                mob.generate_target()\n",
        "\n",
        "            if get_bit_mob_value(bit) == 1:\n",
        "                box.target.set_fill(BLUE, 0.7)\n",
        "                summands.add(label.copy())\n",
        "            else:\n",
        "                bit.target.fade(0.5)\n",
        "                label.target.fade(0.5)\n",
        "\n",
        "        self.play(*[\n",
        "            LaggedStartMap(MoveToTarget, mob, lag_ratio=0.02)\n",
        "            for mob in [boxes, bits, bin_pos_labels]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        # Arrange sum\n",
        "        summands.generate_target()\n",
        "        summands.target.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        summands.target.set_width(1.5)\n",
        "        summands.target.set_color(WHITE)\n",
        "        summands.target.to_edge(RIGHT, buff=1.5)\n",
        "        summands.target.to_edge(UP)\n",
        "\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        xor = get_xor()\n",
        "        line.set_width(summands.target.get_width() + 0.75)\n",
        "        line.next_to(summands.target, DOWN, aligned_edge=RIGHT, buff=SMALL_BUFF)\n",
        "        xor.next_to(line, UP, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(summands, run_time=2),\n",
        "            ShowCreation(line),\n",
        "            ShowCreation(xor),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Perform xor\n",
        "        result = VGroup()\n",
        "        rect_columns = VGroup()\n",
        "        for tup in zip(*summands):\n",
        "            rects = get_one_rects(tup)\n",
        "            result_bit = get_bit_grid(1, 1, bits=[len(rects) % 2])[0]\n",
        "            result_bit.replace(tup[-1], dim_to_match=1)\n",
        "            result_bit.shift(1.5 * result_bit.get_height() * DOWN)\n",
        "            result_bit.set_color(YELLOW)\n",
        "\n",
        "            result.add(result_bit)\n",
        "            rect_columns.add(rects)\n",
        "\n",
        "        pre_result = VGroup()\n",
        "        for summand in summands:\n",
        "            pr = result.copy()\n",
        "            pr.save_state()\n",
        "            pr.move_to(summand)\n",
        "            pr.fade(1)\n",
        "            pre_result.add(pr)\n",
        "\n",
        "        self.play(LaggedStartMap(Restore, pre_result, lag_ratio=0.05, remover=True))\n",
        "        self.add(result)\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeOut(SurroundingRectangle(result, stroke_color=BLUE)))\n",
        "        self.wait()\n",
        "\n",
        "        for n, rects, result_bit in zip(it.count(), reversed(rect_columns), reversed(result)):\n",
        "            faders = VGroup()\n",
        "            for bit_vect in [*summands, result]:\n",
        "                for k, bit in enumerate(reversed(bit_vect)):\n",
        "                    if k != n:\n",
        "                        bit.generate_target()\n",
        "                        bit.target.fade(0.7)\n",
        "                        faders.add(bit)\n",
        "            for group in bits, bin_pos_labels:\n",
        "                sg = get_bit_n_subgroup(group, n, 0)\n",
        "                sg.generate_target()\n",
        "                sg.target.fade(1)\n",
        "                faders.add(sg)\n",
        "            faders.save_state()\n",
        "\n",
        "            self.play(LaggedStartMap(MoveToTarget, faders, lag_ratio=0, run_time=1))\n",
        "\n",
        "            new_rects = VGroup()\n",
        "            for bit, pos in zip(get_bit_n_subgroup(bits, n), get_bit_n_subgroup(bin_pos_labels, n)):\n",
        "                if get_bit_mob_value(bit) == 1:\n",
        "                    nr = SurroundingRectangle(pos[3 - n], buff=0.05)\n",
        "                    nr.set_fill(YELLOW, 0.25)\n",
        "                    new_rects.add(nr)\n",
        "\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(rects),\n",
        "                ShowIncreasingSubsets(new_rects),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                faders.restore,\n",
        "                FadeOut(rects),\n",
        "                FadeOut(new_rects),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Sender manipulations (Doing more by hand than should here...sorry)\n",
        "        parity_highlights = VGroup(*[boxes[2**n].copy() for n in range(4)])\n",
        "        parity_highlights.set_stroke(GREEN, 8)\n",
        "        parity_highlights.set_fill(BLACK, 0)\n",
        "        self.play(ShowCreation(parity_highlights))\n",
        "\n",
        "        words = OldTexText(\"Try to make\\\\\\\\this 0000\")\n",
        "        words.set_color(GREEN)\n",
        "        words.next_to(boxes, RIGHT, MED_LARGE_BUFF)\n",
        "        words.to_edge(DOWN, buff=1)\n",
        "        arrow = Arrow(words.get_right(), result.get_left(), buff=0.1)\n",
        "        arrow.get_lp = words.get_right\n",
        "        arrow.get_rp = result.get_left\n",
        "        arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            m.get_lp() + SMALL_BUFF * RIGHT,\n",
        "            m.get_rp() + SMALL_BUFF * LEFT,\n",
        "        ))\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            DrawBorderThenFill(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        strike = Cross(summands[0])\n",
        "        strike.set_stroke(RED, 8)\n",
        "        self.play(ShowCreation(strike))\n",
        "        self.add(summands[0], strike)\n",
        "        bits[2].generate_target()\n",
        "        toggle_bit(bits[2].target)\n",
        "        bits[2].target.fade(0.5)\n",
        "        self.play(\n",
        "            boxes[2].set_fill, BLACK, 0,\n",
        "            MoveToTarget(bits[2]),\n",
        "            bin_pos_labels[2].fade, 0.5,\n",
        "            toggle_bit_anim(result[2]),\n",
        "            FadeOut(summands[0]),\n",
        "            FadeOut(strike),\n",
        "        )\n",
        "        summands.remove(summands[0])\n",
        "        self.wait()\n",
        "\n",
        "        toggle_bit(bits[8].saved_state)\n",
        "        self.play(\n",
        "            boxes[8].set_fill, BLUE, 0.7,\n",
        "            Restore(bits[8]),\n",
        "            Restore(bin_pos_labels[8]),\n",
        "        )\n",
        "        new_term = bin_pos_labels[8].copy()\n",
        "        new_term.generate_target()\n",
        "        new_term.target.set_color(WHITE)\n",
        "        new_term.target.replace(summands[2])\n",
        "        self.play(\n",
        "            MoveToTarget(new_term),\n",
        "            summands[:3].move_to, summands[1], DOWN,\n",
        "        )\n",
        "        self.play(toggle_bit_anim(result[0]))\n",
        "        self.wait()\n",
        "        summands.set_submobjects([*summands[:3], new_term, *summands[3:]])\n",
        "        self.play(FadeOut(words), FadeOut(arrow), FadeOut(parity_highlights))\n",
        "\n",
        "        # Show 0 -> 1 error\n",
        "        pos = 11\n",
        "        self.play(\n",
        "            Restore(bits[pos]),\n",
        "            Restore(bin_pos_labels[pos]),\n",
        "        )\n",
        "        self.play(toggle_bit_anim(bits[pos], target_color=RED))\n",
        "        self.wait()\n",
        "\n",
        "        new_term = bin_pos_labels[pos].copy()\n",
        "        new_term.generate_target()\n",
        "        new_term.target.set_color(RED)\n",
        "        new_term.target.replace(summands[5])\n",
        "        bottom_group = VGroup(summands[5:], xor, line, result)\n",
        "        bottom_group.save_state()\n",
        "        self.play(\n",
        "            MoveToTarget(new_term),\n",
        "            bottom_group.move_to, summands[6], UR,\n",
        "        )\n",
        "        self.wait(0.25)\n",
        "        nt_copy = new_term.copy()\n",
        "        self.play(\n",
        "            nt_copy.replace, result,\n",
        "            nt_copy.fade, 1,\n",
        "            *[\n",
        "                toggle_bit_anim(b1, path_arc=0)\n",
        "                for b1, b2 in zip(result, new_term)\n",
        "                if b2.get_value() == 1\n",
        "            ]\n",
        "        )\n",
        "        self.remove(nt_copy)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(bottom_group),\n",
        "            FadeOut(new_term),\n",
        "            toggle_bit_anim(bits[pos], target_color=WHITE)\n",
        "        )\n",
        "        self.play(\n",
        "            bits[pos].fade, 0.5,\n",
        "            bin_pos_labels[pos].fade, 0.5,\n",
        "        )\n",
        "\n",
        "        # Show 1 -> 0 error\n",
        "        pos = 6\n",
        "        self.play(\n",
        "            toggle_bit_anim(bits[pos], target_color=RED),\n",
        "            zap_anim(bits[pos]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        new_term = bin_pos_labels[pos].copy()\n",
        "        new_term.generate_target()\n",
        "        new_term.target.set_color(RED)\n",
        "        new_term.target.replace(summands[3])\n",
        "        bottom_group = VGroup(summands[3:], xor, line, result)\n",
        "        bottom_group.save_state()\n",
        "        self.play(\n",
        "            MoveToTarget(new_term),\n",
        "            bottom_group.move_to, summands[4], UR,\n",
        "        )\n",
        "\n",
        "        for bit in result:\n",
        "            bit[0].set_opacity(1)\n",
        "            bit[1].set_opacity(0)\n",
        "        nt_copy = new_term.copy()\n",
        "        self.play(\n",
        "            nt_copy.move_to, result,\n",
        "            nt_copy.fade, 1,\n",
        "            *[\n",
        "                toggle_bit_anim(b1, path_arc=0)\n",
        "                for b1, b2 in zip(result, new_term)\n",
        "                if b2.get_value() == 1\n",
        "            ]\n",
        "        )\n",
        "        self.remove(nt_copy)\n",
        "        self.wait()\n",
        "\n",
        "        brace = Brace(VGroup(summands[2], new_term), LEFT, buff=SMALL_BUFF)\n",
        "        brace_bits = summands[2].copy()\n",
        "        for bb in brace_bits:\n",
        "            bb.set_value(0)\n",
        "        brace_bits.next_to(brace, LEFT)\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(\n",
        "            Transform(summands[2].copy(), brace_bits, remover=True),\n",
        "            ReplacementTransform(new_term.copy(), brace_bits),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow = Arrow(result.get_left(), bin_pos_labels[pos].get_corner(DR), path_arc=-30 * DEGREES, buff=0.1)\n",
        "        self.play(DrawBorderThenFill(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(toggle_bit_anim(bits[pos], target_color=WHITE))\n",
        "        self.play(\n",
        "            Restore(bottom_group),\n",
        "            FadeOut(new_term),\n",
        "            FadeOut(brace),\n",
        "            FadeOut(brace_bits),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HammingSyndromePython(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class WhatAboutTwoBitDetection(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What about\\\\\\\\detecting\\\\\\\\two bit errors?\"\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(\"angry\", \"maybe\", \"raise_left_hand\"),\n",
        "            self.teacher.change, \"guilty\",\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(4)\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.play_student_changes(\"confused\", \"erm\", \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ConflictingViewsOnXor(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        self.add(self.pi_creatures)\n",
        "        self.student_says(\n",
        "            \"Um...can you\\\\\\\\say that again?\",\n",
        "            target_mode=\"confused\",\n",
        "            index=2,\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"pondering\", look_at=self.screen)\n",
        "        self.wait(2)\n",
        "        self.student_says(\n",
        "            \"Why didn't you\\\\\\\\just use xors\\\\\\\\from the start?\",\n",
        "            target_mode=\"sassy\",\n",
        "            index=1,\n",
        "        )\n",
        "        self.look_at(self.students[1].bubble)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class CompareXorToParityChecks(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        bg_rect = FullScreenRectangle()\n",
        "        bg_rect.set_fill(GREY_E, 1)\n",
        "        bg_rect.set_stroke(width=0)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        title = OldTexText(\"One algorithm, multiple perspectives\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.add_to_back(Underline(title))\n",
        "        self.add(title)\n",
        "\n",
        "        # Options\n",
        "        rects = VGroup(*[ScreenRectangle() for x in range(3)])\n",
        "        rects.set_fill(BLACK, 1)\n",
        "        rects.set_stroke(GREY_B, 3)\n",
        "        rects.set_height(3)\n",
        "        rects.arrange(RIGHT, buff=1)\n",
        "        rects.shift(-rects[:2].get_center())\n",
        "\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"Multiple parity checks\"),\n",
        "            OldTexText(\"One big xor\"),\n",
        "            OldTexText(\"Matrix product\"),\n",
        "        )\n",
        "        for label, rect in zip(labels, rects):\n",
        "            label.next_to(rect, DOWN)\n",
        "        labels.set_color(BLUE)\n",
        "\n",
        "        self.add(rects[:2])\n",
        "        self.add(labels[:2])\n",
        "\n",
        "        self.play(Write(title, run_time=2))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Hardware/software labels\n",
        "        hw_label = OldTexText(\"(nicer for hardware)\")\n",
        "        sw_label = OldTexText(\"(nicer for software)\")\n",
        "\n",
        "        for l1, l2 in zip(labels, [hw_label, sw_label]):\n",
        "            l2.next_to(l1, DOWN)\n",
        "\n",
        "        self.play(FadeIn(hw_label, 0.25 * UP))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sw_label, 0.25 * UP))\n",
        "        self.wait()\n",
        "\n",
        "        # Third view\n",
        "        icons = Group(\n",
        "            ImageMobject(\"ParityCheckIcon\"),\n",
        "            ImageMobject(\"XorViewIcon\"),\n",
        "        )\n",
        "        for icon, rect in zip(icons, rects):\n",
        "            icon.replace(rect)\n",
        "            icon.scale(0.95)\n",
        "\n",
        "        groups = Group(\n",
        "            Group(rects[0], labels[0], icons[0], hw_label),\n",
        "            Group(rects[1], labels[1], icons[1], sw_label),\n",
        "            Group(rects[2], labels[2]),\n",
        "        )\n",
        "        groups.generate_target()\n",
        "        groups.target[:2].arrange(DOWN, buff=LARGE_BUFF)\n",
        "        groups.target[:2].match_height(groups.target[2])\n",
        "        groups.target[2].next_to(groups.target[:2], RIGHT, LARGE_BUFF)\n",
        "        groups.target.set_height(5)\n",
        "        groups.target.center()\n",
        "        groups.target.to_edge(DOWN, buff=1)\n",
        "        groups[2].set_opacity(0)\n",
        "        self.play(MoveToTarget(groups))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LogTitle(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"$\\\\text{log}_2(256) = 8$ parity checks\")\n",
        "        title.set_height(0.7)\n",
        "        title.to_edge(UP)\n",
        "        underline = Underline(title[0][:4])\n",
        "        underline.set_color(YELLOW)\n",
        "        self.add(title)\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeOut(underline))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MatrixProduct(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"(7, 4) Hamming code\")\n",
        "        title.set_height(0.7)\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(GREY_A)\n",
        "\n",
        "        encoder_matrix = np.array([\n",
        "           [1, 1, 0, 1],\n",
        "           [1, 0, 1, 1],\n",
        "           [1, 0, 0, 0],\n",
        "           [0, 1, 1, 1],\n",
        "           [0, 1, 0, 0],\n",
        "           [0, 0, 1, 0],\n",
        "           [0, 0, 0, 1],\n",
        "        ])\n",
        "        message_matrix = np.array([1, 0, 1, 1]).reshape((4, 1))\n",
        "        result_matrix = np.dot(encoder_matrix, message_matrix) % 2\n",
        "\n",
        "        kw = {\"v_buff\": 0.6, \"h_buff\": 0.75}\n",
        "        encoder, message, result = [\n",
        "            IntegerMatrix(matrix, **kw)\n",
        "            for matrix in [encoder_matrix, message_matrix, result_matrix]\n",
        "        ]\n",
        "        equation = VGroup(\n",
        "            encoder, message, OldTex(\"=\"), result\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        equation.to_edge(LEFT, buff=2)\n",
        "\n",
        "        # Labels\n",
        "        message_label = OldTexText(\"Content\")\n",
        "        message_label.move_to(message)\n",
        "        message_label.to_edge(DOWN)\n",
        "        message_arrow = Arrow(\n",
        "            message_label.get_top(),\n",
        "            message.get_bottom(),\n",
        "        )\n",
        "        message_label.set_color(YELLOW)\n",
        "        message_arrow.set_color(YELLOW)\n",
        "\n",
        "        brace = Brace(result, RIGHT)\n",
        "        brace_text = brace.get_text(\"Error-resistant\\\\\\\\block\")\n",
        "        brace.set_color(BLUE)\n",
        "        brace_text.set_color(BLUE)\n",
        "\n",
        "        # Animate\n",
        "        self.add(title)\n",
        "        self.add(equation)\n",
        "\n",
        "        self.play(FadeIn(message_label, UP), GrowArrow(message_arrow))\n",
        "        self.play(GrowFromCenter(brace), FadeIn(brace_text, LEFT))\n",
        "\n",
        "        equation.set_fill(opacity=0.8)\n",
        "        for n in range(encoder.mob_matrix.shape[0]):\n",
        "            row = VGroup(*encoder.mob_matrix[n, :]).copy()\n",
        "            col = VGroup(*message.elements).copy()\n",
        "            rhs = result.mob_matrix[n, 0].copy()\n",
        "\n",
        "            mult_group = VGroup(row, col, rhs)\n",
        "            mult_group.set_fill(YELLOW, 1)\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(row),\n",
        "                ShowIncreasingSubsets(col),\n",
        "                FadeIn(rhs),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.remove(mult_group)\n",
        "\n",
        "\n",
        "class TooManyErrorsTripUpHamming(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"$>2$ Errors\",\" $\\\\Rightarrow$ \", \"Invalid decoding\"\n",
        "        )\n",
        "        title.set_height(0.7)\n",
        "        title[2].set_color(RED)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        block = get_bit_grid(8, 8, bits=string_to_bits(\"EpicFail\"), height=5.5)\n",
        "        block.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        self.add(block)\n",
        "\n",
        "        # Animations\n",
        "        errors = random.sample(list(range(64)), 3)\n",
        "        kw = {\"lag_ratio\": 0.5}\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                zap_anim(block[pos])\n",
        "                for pos in errors\n",
        "            ], **kw),\n",
        "            LaggedStart(*[\n",
        "                toggle_bit_anim(block[pos], target_color=RED)\n",
        "                for pos in errors\n",
        "            ], **kw),\n",
        "        )\n",
        "\n",
        "        scanim = scan_anim(block.get_corner(DR) + UR, block, run_time=5, lag_factor=1)\n",
        "        self.play(scanim)\n",
        "\n",
        "        self.play(ShowCreationThenFadeOut(Underline(title[2], color=RED)))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LouisPasteurQuote(Scene):\n",
        "    def construct(self):\n",
        "        quote = OldTexText(\"``Luck favors a\\\\\\\\prepared mind''\")\n",
        "        quote.scale(2)\n",
        "        quote.set_stroke(BLACK, 8, background=True)\n",
        "        self.play(Write(quote))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReedSolomonPreview(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        title = OldTexText(\"Reed-Solomon basic idea\")\n",
        "        title.set_height(0.5)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        axes = Axes(\n",
        "            x_range=(-1, 10, 1), y_range=(-1, 8, 1),\n",
        "            width=12,\n",
        "            height=7,\n",
        "        )\n",
        "        axes.to_edge(DOWN, buff=SMALL_BUFF)\n",
        "        axes.set_color(GREY_B)\n",
        "\n",
        "        cubic = axes.get_graph(\n",
        "            lambda x: -0.05 * x * (x - 2) * (x - 4) * (x - 8) + 2\n",
        "        )\n",
        "        cubic.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Data\n",
        "        dots = VGroup(*[\n",
        "            Dot(axes.input_to_graph_point(x, cubic))\n",
        "            for x in range(0, 8)\n",
        "        ])\n",
        "        dots[:4].set_color(YELLOW)\n",
        "        dots[4:].set_color(BLUE)\n",
        "\n",
        "        # Input words\n",
        "        input_words = OldTexText(\"Input data\")\n",
        "        poly_words = OldTexText(\"Polynomial\\\\\\\\fit\")\n",
        "        redundant_words = OldTexText(\"Redundancy\")\n",
        "\n",
        "        input_words.next_to(dots[:4], UP, buff=2)\n",
        "        input_words.set_color(YELLOW)\n",
        "        input_arrows = VGroup(*[\n",
        "            Arrow(input_words.get_bottom(), dot.get_center())\n",
        "            for dot in dots[:4]\n",
        "        ])\n",
        "        input_arrows.set_fill(YELLOW)\n",
        "\n",
        "        poly_words.next_to(dots[5], LEFT)\n",
        "        poly_words.shift(0.5 * UR)\n",
        "        poly_words.match_color(cubic)\n",
        "\n",
        "        redundant_words.move_to(dots[4:].get_center(), LEFT)\n",
        "        redundant_words.shift(2 * DR + DOWN)\n",
        "        redundant_words.set_color(BLUE)\n",
        "        redundant_arrows = VGroup(*[\n",
        "            Arrow(redundant_words.get_corner(UL), dot.get_center())\n",
        "            for dot in dots[4:]\n",
        "        ])\n",
        "        redundant_arrows.set_color(BLUE)\n",
        "\n",
        "        # Animations\n",
        "        kw = {\"lag_ratio\": 0.5}\n",
        "        self.play(\n",
        "            FadeIn(input_words),\n",
        "            LaggedStartMap(FadeIn, dots[:4], lambda m: (m, UP), **kw),\n",
        "            LaggedStartMap(GrowArrow, input_arrows, **kw),\n",
        "        )\n",
        "        self.add(cubic, *dots[:4])\n",
        "        self.play(\n",
        "            ShowCreation(cubic),\n",
        "            Write(poly_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(redundant_words),\n",
        "            LaggedStartMap(FadeIn, dots[4:], lambda m: (m, DR), **kw),\n",
        "            LaggedStartMap(GrowArrow, redundant_arrows, **kw),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, VGroup(*reversed(self.mobjects)),\n",
        "            lambda m: (m, 0.2 * normalize(m.get_center())),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HammingThinking(Scene):\n",
        "    def construct(self):\n",
        "        hamming = ImageMobject(\"Richard_Hamming\")\n",
        "        hamming.set_height(3)\n",
        "        hamming.to_corner(DL)\n",
        "        randy = Randolph()\n",
        "        randy.set_opacity(0)\n",
        "        randy.move_to(hamming)\n",
        "\n",
        "        self.add(hamming)\n",
        "        self.wait()\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"What's the most efficient\\\\\\\\I could conceivably be?\",\n",
        "            bubble_type=ThoughtBubble,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RandomWalks(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        N_PATHS = 25\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(2 * FRAME_HEIGHT)\n",
        "        frame.shift(2 * RIGHT)\n",
        "\n",
        "        idea_spot = 10 * RIGHT + 3 * UP\n",
        "        idea_dot = Dot(idea_spot)\n",
        "        idea_dot.set_color(YELLOW)\n",
        "        bulb = Lightbulb()\n",
        "        bulb.next_to(idea_dot, UP)\n",
        "\n",
        "        start_point = 7 * LEFT + 3 * DOWN\n",
        "        start_dot = Dot(start_point, color=WHITE)\n",
        "        start_dot.scale(2)\n",
        "\n",
        "        self.add(idea_dot, bulb, start_dot)\n",
        "\n",
        "        # Paths\n",
        "        paths = VGroup(*[VGroup() for n in range(N_PATHS)])\n",
        "        for path in paths:\n",
        "            path.add(Line(start_point, start_point))\n",
        "            path.set_stroke(WHITE, 3, 0.5)\n",
        "\n",
        "        path_dots = VGroup()\n",
        "        for path in paths:\n",
        "            # dot = Randolph(\n",
        "            #     mode=\"thinking\", height=0.25,\n",
        "            #     # color=random.choice([BLUE_B, BLUE_C, BLUE_D, GREY_BROWN])\n",
        "            # )\n",
        "            dot = Dot(color=BLUE)\n",
        "            dot.set_stroke(BLACK, 3, background=True)\n",
        "            dot.path = path\n",
        "            dot.add_updater(lambda m: m.move_to(m.path[-1].get_end()))\n",
        "            path_dots.add(dot)\n",
        "\n",
        "        self.add(paths)\n",
        "        self.add(path_dots)\n",
        "\n",
        "        # Perform search\n",
        "        magic_path = None\n",
        "        while magic_path is None:\n",
        "            new_segments = VGroup()\n",
        "            for path in paths:\n",
        "                start = path[-1].get_end()\n",
        "\n",
        "                # Choose random direction based on loosely sniffing out idea spot\n",
        "                R_vect = start - idea_spot\n",
        "                R_vect = rotate_vector(10 * R_vect, TAU * random.random())\n",
        "                point = idea_spot + R_vect\n",
        "                to_point = point - start\n",
        "                angle = angle_of_vector(to_point)\n",
        "                if -3 * PI / 2 < angle <= -PI / 2:\n",
        "                    vect = DOWN\n",
        "                elif -PI / 2 < angle <= PI / 2:\n",
        "                    vect = RIGHT\n",
        "                elif PI / 2 < angle <= 3 * PI / 2:\n",
        "                    vect = UP\n",
        "                else:\n",
        "                    vect = LEFT\n",
        "\n",
        "                end = start + vect\n",
        "                new_segment = Line(start, end)\n",
        "                new_segment.match_style(path)\n",
        "\n",
        "                new_segments.add(new_segment)\n",
        "                path.add(new_segment)\n",
        "\n",
        "                if np.isclose(end, idea_spot).all():\n",
        "                    magic_path = path.copy()\n",
        "            self.play(\n",
        "                LaggedStartMap(ShowCreation, new_segments, lag_ratio=10 / N_PATHS),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "            self.add(paths)\n",
        "\n",
        "        # Highlight magic path\n",
        "        magic_path.set_stroke(YELLOW, 5, 1)\n",
        "        self.play(\n",
        "            paths.fade, 0.7,\n",
        "            ShowCreation(magic_path, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        fake_path = VMobject()\n",
        "        fake_path.start_new_path(start_point)\n",
        "        for segment in magic_path:\n",
        "            fake_path.add_line_to(segment.get_end())\n",
        "        fake_path.match_style(magic_path)\n",
        "\n",
        "        line = Line(start_point, idea_spot)\n",
        "        line.match_style(magic_path)\n",
        "        line.set_stroke(TEAL, 8)\n",
        "\n",
        "        self.add(fake_path, start_dot)\n",
        "        self.play(\n",
        "            ApplyMethod(magic_path.set_opacity, 0.5),\n",
        "            Transform(fake_path, line, run_time=2),\n",
        "            paths.fade, 0.5,\n",
        "            path_dots.fade, 0.5,\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class ThinkingInTermsOfBits(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"Information\")\n",
        "        word.scale(2)\n",
        "        word.next_to(ORIGIN, LEFT, buff=0.7)\n",
        "        bits = get_bit_grid(11, 8, bits=string_to_bits(\"Information\"))\n",
        "        bits.set_height(6)\n",
        "        bits.next_to(ORIGIN, RIGHT, buff=0.7)\n",
        "        bits.set_color(GREY_A)\n",
        "\n",
        "        for bit in bits:\n",
        "            toggle_bit(bit)\n",
        "\n",
        "        bits.shuffle()\n",
        "\n",
        "        self.add(word)\n",
        "        self.add(bits)\n",
        "        self.play(LaggedStartMap(\n",
        "            toggle_bit_anim, bits,\n",
        "            lag_ratio=5 / len(bits),\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SimpleHoldUpBackground(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(self.teacher.change, \"raise_right_hand\", 3 * UP)\n",
        "        self.play_student_changes(\"pondering\", \"thinking\", \"tease\", look_at=3 * UP)\n",
        "        self.wait(4)\n",
        "        self.play_student_changes(\"tease\", \"hesitant\", \"happy\", look_at=3 * UP)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class HammingEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"scroll_time\": 25\n",
        "    }\n",
        "\n",
        "\n",
        "# Extras\n",
        "\n",
        "class TwoErrorGrids(Scene):\n",
        "    def construct(self):\n",
        "        grid = VGroup(*[Square() for x in range(16)])\n",
        "        grid.arrange_in_grid(buff=0)\n",
        "        grid.set_stroke(WHITE, 1)\n",
        "        grid.set_height(1)\n",
        "\n",
        "        grids = VGroup(*[grid.copy() for x in range(16)])\n",
        "        grids.arrange_in_grid(buff=MED_LARGE_BUFF)\n",
        "        grids.set_height(7)\n",
        "        grids.to_edge(RIGHT)\n",
        "\n",
        "        self.add(grids)\n",
        "\n",
        "        vects = [\n",
        "            np.array(tup)\n",
        "            for tup in it.product(*[[0, 1]] * 4)\n",
        "        ]\n",
        "\n",
        "        def vect_to_int(vect):\n",
        "            return sum([b * (1 << i) for i, b in enumerate(reversed(vect))])\n",
        "\n",
        "        for vect in vects:\n",
        "            label = VGroup(*map(Integer, vect))\n",
        "            label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            label.to_edge(LEFT)\n",
        "            self.add(label)\n",
        "\n",
        "            error_int = vect_to_int(vect)\n",
        "            for i, grid in enumerate(grids):\n",
        "                grid[i].set_fill(YELLOW, 1)\n",
        "                grid[i ^ error_int].set_fill(TEAL, 1)\n",
        "\n",
        "            self.wait()\n",
        "            grids.set_fill(opacity=0)\n",
        "            self.remove(label)"
    ]
}