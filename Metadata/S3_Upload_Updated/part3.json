{
    "topic": "demonstrates the concept of gradient descent, specifically the interpretation of the components of the gradient",
    "code": [
        "from _2017.nn.network import *\n",
        "from _2017.nn.part1 import *\n",
        "from _2017.nn.part2 import *\n",
        "\n",
        "class LayOutPlan(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Plan\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS - 1)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        items = BulletedList(\n",
        "            \"Recap\",\n",
        "            \"Intuitive walkthrough\",\n",
        "            \"Derivatives in \\\\\\\\ computational graphs\",\n",
        "        )\n",
        "        items.to_edge(LEFT, buff = LARGE_BUFF)\n",
        "        self.add(items)\n",
        "\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_width(FRAME_WIDTH - items.get_width() - 2)\n",
        "        rect.next_to(items, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            ShowCreation(h_line),\n",
        "            ShowCreation(rect),\n",
        "            run_time = 2\n",
        "        )\n",
        "        for i in range(len(items)):\n",
        "            self.play(items.fade_all_but, i)\n",
        "            self.wait(2)\n",
        "\n",
        "class TODOInsertFeedForwardAnimations(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert Feed Forward Animations\"\n",
        "    }\n",
        "\n",
        "class TODOInsertStepsDownCostSurface(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert Steps Down Cost Surface\"\n",
        "    }\n",
        "\n",
        "class TODOInsertDefinitionOfCostFunction(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert Definition of cost function\"\n",
        "    }\n",
        "\n",
        "class TODOInsertGradientNudging(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert GradientNudging\"\n",
        "    }\n",
        "\n",
        "class InterpretGradientComponents(GradientNudging):\n",
        "    CONFIG = {\n",
        "        \"network_mob_config\" : {\n",
        "            \"layer_to_layer_buff\" : 3,\n",
        "        },\n",
        "        \"stroke_width_exp\" : 2,\n",
        "        \"n_decimals\" : 6,\n",
        "        \"n_steps\" : 3,\n",
        "        \"start_cost\" : 3.48,\n",
        "        \"delta_cost\" : -0.21,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_network()\n",
        "        self.add_cost()\n",
        "        self.add_gradient()\n",
        "        self.change_weights_repeatedly()\n",
        "        self.ask_about_high_dimensions()\n",
        "        self.circle_magnitudes()\n",
        "        self.isolate_particular_weights()\n",
        "        self.shift_cost_expression()\n",
        "        self.tweak_individual_weights()\n",
        "\n",
        "    def setup_network(self):\n",
        "        self.network_mob.scale(0.55)\n",
        "        self.network_mob.to_corner(UP+RIGHT)\n",
        "        self.color_network_edges()\n",
        "\n",
        "    def add_cost(self):\n",
        "        rect = SurroundingRectangle(self.network_mob)\n",
        "        rect.set_color(RED)\n",
        "        arrow = Vector(DOWN, color = RED)\n",
        "        arrow.shift(rect.get_bottom())\n",
        "        cost = DecimalNumber(self.start_cost)\n",
        "        cost.set_color(RED)\n",
        "        cost.next_to(arrow, DOWN)\n",
        "\n",
        "        cost_expression = OldTex(\n",
        "            \"C(\", \"w_0, w_1, \\\\dots, w_{13{,}001}\", \")\", \"=\"\n",
        "        )\n",
        "        for tex in \"()\":\n",
        "            cost_expression.set_color_by_tex(tex, RED)\n",
        "        cost_expression.next_to(cost, DOWN)\n",
        "        cost_group = VGroup(cost_expression, cost)\n",
        "        cost_group.arrange(RIGHT)\n",
        "        cost_group.next_to(arrow, DOWN)\n",
        "\n",
        "        self.add(rect, arrow, cost_group)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            cost, cost_expression, cost_group,\n",
        "            network_rect = rect\n",
        "        )\n",
        "\n",
        "    def change_weights_repeatedly(self):\n",
        "        decimals = self.grad_vect.decimals\n",
        "        grad_terms = self.grad_vect.contents\n",
        "        edges = VGroup(*reversed(list(\n",
        "            it.chain(*self.network_mob.edge_groups)\n",
        "        )))\n",
        "        cost = self.cost\n",
        "\n",
        "        for x in range(self.n_steps):\n",
        "            self.move_grad_terms_into_position(\n",
        "                grad_terms.copy(),\n",
        "                *self.get_weight_adjustment_anims(edges, cost)\n",
        "            )\n",
        "            self.play(*self.get_decimal_change_anims(decimals))\n",
        "\n",
        "    def ask_about_high_dimensions(self):\n",
        "        grad_vect = self.grad_vect\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Direction in \\\\\\\\ ${13{,}002}$ dimensions?!?\")\n",
        "        words.set_color(YELLOW)\n",
        "        words.move_to(grad_vect).to_edge(DOWN)\n",
        "        arrow = Arrow(\n",
        "            words.get_top(),\n",
        "            grad_vect.get_bottom(),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.6)\n",
        "        randy.next_to(words, LEFT)\n",
        "        randy.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time = 2), \n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", words)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [randy, words, arrow])))\n",
        "\n",
        "    def circle_magnitudes(self):\n",
        "        rects = VGroup()\n",
        "        for decimal in self.grad_vect.decimals:\n",
        "            rects.add(SurroundingRectangle(VGroup(*decimal[-8:])))\n",
        "        rects.set_color(WHITE)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, rects))\n",
        "        self.play(FadeOut(rects))\n",
        "\n",
        "    def isolate_particular_weights(self):\n",
        "        vect_contents = self.grad_vect.contents\n",
        "        w_terms = self.cost_expression[1]\n",
        "\n",
        "        edges = self.network_mob.edge_groups\n",
        "        edge1 = self.network_mob.layers[1].neurons[3].edges_in[0].copy()\n",
        "        edge2 = self.network_mob.layers[1].neurons[9].edges_in[15].copy()\n",
        "        VGroup(edge1, edge2).set_stroke(width = 4)\n",
        "        d1 = DecimalNumber(3.2)\n",
        "        d2 = DecimalNumber(0.1)\n",
        "        VGroup(edge1, d1).set_color(YELLOW)\n",
        "        VGroup(edge2, d2).set_color(MAROON_B)\n",
        "        new_vect_contents = VGroup(\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            d1, OldTex(\"\\\\vdots\"),\n",
        "            d2, OldTex(\"\\\\vdots\"),\n",
        "        )\n",
        "        new_vect_contents.arrange(DOWN)\n",
        "        new_vect_contents.move_to(vect_contents)\n",
        "\n",
        "        new_w_terms = OldTex(\n",
        "            \"\\\\dots\", \"w_n\", \"\\\\dots\", \"w_k\", \"\\\\dots\"\n",
        "        )\n",
        "        new_w_terms.move_to(w_terms, DOWN)\n",
        "        new_w_terms[1].set_color(d1.get_color())\n",
        "        new_w_terms[3].set_color(d2.get_color())\n",
        "\n",
        "        for d, edge in (d1, edge1), (d2, edge2):\n",
        "            d.arrow = Arrow(\n",
        "                d.get_right(), edge.get_center(),\n",
        "                color = d.get_color()\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(vect_contents),\n",
        "            FadeIn(new_vect_contents),\n",
        "            FadeOut(w_terms),\n",
        "            FadeIn(new_w_terms),\n",
        "            edges.set_stroke, GREY_B, 0.35,\n",
        "        )\n",
        "        self.play(GrowArrow(d1.arrow))\n",
        "        self.play(ShowCreation(edge1))\n",
        "        self.wait()\n",
        "        self.play(GrowArrow(d2.arrow))\n",
        "        self.play(ShowCreation(edge2))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.cost_expression.remove(w_terms)\n",
        "        self.cost_expression.add(new_w_terms)\n",
        "        self.set_variables_as_attrs(\n",
        "            edge1, edge2, new_w_terms, \n",
        "            new_decimals = VGroup(d1, d2)\n",
        "        )\n",
        "\n",
        "    def shift_cost_expression(self):\n",
        "        self.play(self.cost_group.shift, DOWN+0.5*LEFT)\n",
        "\n",
        "    def tweak_individual_weights(self):\n",
        "        cost = self.cost\n",
        "        cost_num = cost.number\n",
        "        edges = VGroup(self.edge1, self.edge2)\n",
        "        decimals = self.new_decimals\n",
        "        changes = (1.0, 1./32)\n",
        "        wn = self.new_w_terms[1]\n",
        "        wk = self.new_w_terms[3]\n",
        "\n",
        "        number_line_template = NumberLine(\n",
        "            x_min = -1,\n",
        "            x_max = 1,\n",
        "            tick_frequency = 0.25,\n",
        "            big_tick_numbers = [],\n",
        "            color = WHITE\n",
        "        )\n",
        "        for term in wn, wk, cost:\n",
        "            term.number_line = number_line_template.copy()\n",
        "            term.brace = Brace(term.number_line, DOWN, buff = SMALL_BUFF)\n",
        "            group = VGroup(term.number_line, term.brace)\n",
        "            group.next_to(term, UP)\n",
        "            term.dot = Dot()\n",
        "            term.dot.set_color(term.get_color())\n",
        "            term.dot.move_to(term.number_line.get_center())\n",
        "            term.dot.save_state()\n",
        "            term.dot.move_to(term)\n",
        "            term.dot.set_fill(opacity = 0)\n",
        "            term.words = OldTexText(\"Nudge this weight\")\n",
        "            term.words.scale(0.7)\n",
        "            term.words.next_to(term.number_line, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        groups = [\n",
        "            VGroup(d, d.arrow, edge, w)\n",
        "            for d, edge, w in zip(decimals, edges, [wn, wk])\n",
        "        ]\n",
        "        for group in groups:\n",
        "            group.save_state()\n",
        "\n",
        "        for i in range(2):\n",
        "            group1, group2 = groups[i], groups[1-i]\n",
        "            change = changes[i]\n",
        "            edge = edges[i]\n",
        "            w = group1[-1]\n",
        "            added_anims = []\n",
        "            if i == 0:\n",
        "                added_anims = [\n",
        "                    GrowFromCenter(cost.brace),\n",
        "                    ShowCreation(cost.number_line),\n",
        "                    cost.dot.restore\n",
        "                ]\n",
        "            self.play(\n",
        "                group1.restore,\n",
        "                group2.fade, 0.7,\n",
        "                GrowFromCenter(w.brace),\n",
        "                ShowCreation(w.number_line),\n",
        "                w.dot.restore,\n",
        "                Write(w.words, run_time = 1),\n",
        "                *added_anims\n",
        "            )\n",
        "            for x in range(2):\n",
        "                func = lambda a : interpolate(\n",
        "                    cost_num, cost_num-change, a\n",
        "                )\n",
        "                self.play(\n",
        "                    ChangingDecimal(cost, func),\n",
        "                    cost.dot.shift, change*RIGHT,\n",
        "                    w.dot.shift, 0.25*RIGHT,\n",
        "                    edge.set_stroke, None, 8,\n",
        "                    rate_func = lambda t : wiggle(t, 4),\n",
        "                    run_time = 2,\n",
        "                )\n",
        "                self.wait()\n",
        "            self.play(*list(map(FadeOut, [\n",
        "                w.dot, w.brace, w.number_line, w.words\n",
        "            ])))\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def move_grad_terms_into_position(self, grad_terms, *added_anims):\n",
        "        cost_expression = self.cost_expression\n",
        "        w_terms = self.cost_expression[1]\n",
        "        points = VGroup(*[\n",
        "            VectorizedPoint()\n",
        "            for term in grad_terms\n",
        "        ])\n",
        "        points.arrange(RIGHT)\n",
        "        points.replace(w_terms, dim_to_match = 0)\n",
        "\n",
        "        grad_terms.generate_target()\n",
        "        grad_terms.target[len(grad_terms)/2].rotate(np.pi/2)\n",
        "        grad_terms.target.arrange(RIGHT)\n",
        "        grad_terms.target.set_width(cost_expression.get_width())\n",
        "        grad_terms.target.next_to(cost_expression, DOWN)\n",
        "\n",
        "        words = OldTexText(\"Nudge weights\")\n",
        "        words.scale(0.8)\n",
        "        words.next_to(grad_terms.target, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(grad_terms),\n",
        "            FadeIn(words)\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(\n",
        "                grad_terms, points,\n",
        "                remover = True,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 1\n",
        "            ),\n",
        "            FadeOut(words),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def get_weight_adjustment_anims(self, edges, cost):\n",
        "        start_cost = cost.number\n",
        "        target_cost = start_cost + self.delta_cost\n",
        "        w_terms = self.cost_expression[1]\n",
        "\n",
        "        return [\n",
        "            self.get_edge_change_anim(edges),\n",
        "            LaggedStartMap(\n",
        "                Indicate, w_terms,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5,\n",
        "            ),\n",
        "            ChangingDecimal(\n",
        "                cost, \n",
        "                lambda a : interpolate(start_cost, target_cost, a),\n",
        "                run_time = 1.5\n",
        "            )\n",
        "        ]\n",
        "\n",
        "class GetLostInNotation(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        equations = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\delta\", \"^L\", \"=\", \"\\\\nabla_a\", \"C\", \n",
        "                \"\\\\odot \\\\sigma'(\", \"z\", \"^L)\"\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"\\\\delta\", \"^l = ((\", \"w\", \"^{l+1})^T\", \n",
        "                \"\\\\delta\", \"^{l+1}) \\\\odot \\\\sigma'(\", \"z\", \"^l)\"\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"{\\\\partial\", \"C\", \"\\\\over \\\\partial\", \"b\", \n",
        "                \"_j^l} =\", \"\\\\delta\", \"_j^l\"\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"{\\\\partial\", \"C\", \" \\\\over \\\\partial\", \n",
        "                \"w\", \"_{jk}^l} = \", \"a\", \"_k^{l-1}\", \"\\\\delta\", \"_j^l\"\n",
        "            ),\n",
        "        )\n",
        "        for equation in equations:\n",
        "            equation.set_color_by_tex_to_color_map({\n",
        "                \"\\\\delta\" : YELLOW,\n",
        "                \"C\" : RED,\n",
        "                \"b\" : MAROON_B,\n",
        "                \"w\" : BLUE,\n",
        "                \"z\" : TEAL,\n",
        "            })\n",
        "            equation.set_color_by_tex(\"nabla\", WHITE)\n",
        "        equations.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        circle = Circle(radius = 3*FRAME_X_RADIUS)\n",
        "        circle.set_fill(WHITE, 0)\n",
        "        circle.set_stroke(WHITE, 0)\n",
        "\n",
        "        self.play(\n",
        "            Write(equations),\n",
        "            morty.change, \"confused\", equations\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"pleading\")\n",
        "        self.wait(2)\n",
        "\n",
        "        ##\n",
        "        movers = VGroup(*equations.family_members_with_points())\n",
        "        random.shuffle(movers.submobjects)\n",
        "        for mover in list(movers):\n",
        "            if mover.is_subpath:\n",
        "                movers.remove(mover)\n",
        "                continue\n",
        "            mover.set_stroke(WHITE, width = 0)\n",
        "            mover.target = Circle()\n",
        "            mover.target.scale(0.5)\n",
        "            mover.target.set_fill(mover.get_color(), opacity = 0)\n",
        "            mover.target.set_stroke(BLACK, width = 1)\n",
        "            mover.target.move_to(mover)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, movers,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class TODOInsertPreviewLearning(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert PreviewLearning\"\n",
        "    }\n",
        "\n",
        "class ShowAveragingCost(PreviewLearning):\n",
        "    CONFIG = {\n",
        "        \"network_scale_val\" : 0.8,\n",
        "        \"stroke_width_exp\" : 1,\n",
        "        \"start_examples_time\" : 5,\n",
        "        \"examples_per_adjustment_time\" : 2,\n",
        "        \"n_adjustments\" : 5,\n",
        "        \"time_per_example\" : 1./15,\n",
        "        \"image_height\" : 1.2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_network()\n",
        "        self.setup_diff_words()\n",
        "        self.show_many_examples()\n",
        "\n",
        "    def setup_network(self):\n",
        "        self.network_mob.scale(self.network_scale_val)\n",
        "        self.network_mob.to_edge(DOWN)\n",
        "        self.network_mob.shift(LEFT)\n",
        "        self.color_network_edges()\n",
        "\n",
        "    def setup_diff_words(self):\n",
        "        last_layer_copy = self.network_mob.layers[-1].deepcopy()\n",
        "        last_layer_copy.add(self.network_mob.output_labels.copy())\n",
        "        last_layer_copy.shift(1.5*RIGHT)\n",
        "\n",
        "        double_arrow = DoubleArrow(\n",
        "            self.network_mob.output_labels,\n",
        "            last_layer_copy,\n",
        "            color = RED\n",
        "        )\n",
        "        brace = Brace(\n",
        "            VGroup(self.network_mob.layers[-1], last_layer_copy), \n",
        "            UP\n",
        "        )\n",
        "        cost_words = brace.get_text(\"Cost of \\\\\\\\ one example\")\n",
        "        cost_words.set_color(RED)\n",
        "\n",
        "        self.add(last_layer_copy, double_arrow, brace, cost_words)\n",
        "        self.set_variables_as_attrs(\n",
        "            last_layer_copy, double_arrow, brace, cost_words\n",
        "        )\n",
        "        self.last_layer_copy = last_layer_copy\n",
        "\n",
        "    def show_many_examples(self):\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "\n",
        "        average_words = OldTexText(\"Average over all training examples\")\n",
        "        average_words.next_to(LEFT, RIGHT)\n",
        "        average_words.to_edge(UP)\n",
        "        self.add(average_words)\n",
        "\n",
        "        n_start_examples = int(self.start_examples_time/self.time_per_example)\n",
        "        n_examples_per_adjustment = int(self.examples_per_adjustment_time/self.time_per_example)\n",
        "        for train_in, train_out in training_data[:n_start_examples]:\n",
        "            self.show_one_example(train_in, train_out)\n",
        "            self.wait(self.time_per_example)\n",
        "\n",
        "        #Wiggle all edges\n",
        "        edges = VGroup(*it.chain(*self.network_mob.edge_groups))\n",
        "        reversed_edges = VGroup(*reversed(edges))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, edges,\n",
        "            lambda edge : (\n",
        "                lambda m : m.rotate(np.pi/12).set_color(YELLOW),\n",
        "                edge,\n",
        "            ),\n",
        "            rate_func = lambda t : wiggle(t, 4),\n",
        "            run_time = 3,\n",
        "        ))\n",
        "\n",
        "        #Show all, then adjust\n",
        "        words = OldTexText(\n",
        "            \"Each step \\\\\\\\ uses every \\\\\\\\ example\\\\\\\\\",\n",
        "            \"$\\\\dots$theoretically\",\n",
        "            alignment = \"\"\n",
        "        )\n",
        "        words.set_color(YELLOW)\n",
        "        words.scale(0.8)\n",
        "        words.to_corner(UP+LEFT)\n",
        "\n",
        "        for x in range(self.n_adjustments):\n",
        "            if x < 2:\n",
        "                self.play(FadeIn(words[x]))\n",
        "            for train_in, train_out in training_data[:n_examples_per_adjustment]:\n",
        "                self.show_one_example(train_in, train_out)\n",
        "                self.wait(self.time_per_example)\n",
        "            self.play(LaggedStartMap(\n",
        "                ApplyMethod, reversed_edges,\n",
        "                lambda m : (m.rotate, np.pi),\n",
        "                run_time = 1,\n",
        "                lag_ratio = 0.2,\n",
        "            ))\n",
        "            if x >= 2:\n",
        "                self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def show_one_example(self, train_in, train_out):\n",
        "        if hasattr(self, \"curr_image\"):\n",
        "            self.remove(self.curr_image)\n",
        "        image = MNistMobject(train_in)\n",
        "        image.set_height(self.image_height)\n",
        "        image.next_to(\n",
        "            self.network_mob.layers[0].neurons, UP,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        self.add(image)\n",
        "        self.network_mob.activate_layers(train_in)\n",
        "\n",
        "        index = np.argmax(train_out)\n",
        "        self.last_layer_copy.neurons.set_fill(opacity = 0)\n",
        "        self.last_layer_copy.neurons[index].set_fill(WHITE, opacity = 1)\n",
        "        self.add(self.last_layer_copy)\n",
        "\n",
        "        self.curr_image = image\n",
        "\n",
        "class FocusOnOneExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Focus on just \\\\\\\\ one example\")\n",
        "        self.wait(2)\n",
        "\n",
        "class WalkThroughTwoExample(ShowAveragingCost):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 0,\n",
        "    }\n",
        "    def setup(self):\n",
        "        np.random.seed(self.random_seed)\n",
        "        random.seed(self.random_seed)\n",
        "        self.setup_bases()\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.setup_network()\n",
        "        self.setup_diff_words()\n",
        "        self.show_single_example()\n",
        "        self.single_example_influencing_weights()\n",
        "        self.expand_last_layer()\n",
        "        self.show_activation_formula()\n",
        "        self.three_ways_to_increase()\n",
        "        self.note_connections_to_brightest_neurons()\n",
        "        self.fire_together_wire_together()\n",
        "        self.show_desired_increase_to_previous_neurons()\n",
        "        self.only_keeping_track_of_changes()\n",
        "        self.show_other_output_neurons()\n",
        "        self.show_recursion()\n",
        "\n",
        "    def show_single_example(self):\n",
        "        two_vect = get_organized_images()[2][0]\n",
        "        two_out = np.zeros(10)\n",
        "        two_out[2] = 1.0\n",
        "        self.show_one_example(two_vect, two_out)\n",
        "        for layer in self.network_mob.layers:\n",
        "            layer.neurons.set_fill(opacity = 0)\n",
        "\n",
        "        self.activate_network(two_vect)\n",
        "        self.wait()\n",
        "\n",
        "    def single_example_influencing_weights(self):\n",
        "        two = self.curr_image\n",
        "        two.save_state()\n",
        "\n",
        "        edge_groups = self.network_mob.edge_groups\n",
        "        def adjust_edge_group_anim(edge_group):\n",
        "            return LaggedStartMap(\n",
        "                ApplyFunction, edge_group,\n",
        "                lambda edge : (\n",
        "                    lambda m : m.rotate(np.pi/12).set_color(YELLOW),\n",
        "                    edge\n",
        "                ),\n",
        "                rate_func = wiggle,\n",
        "                run_time = 1,\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            two.next_to, edge_groups[0].get_corner(DOWN+RIGHT), DOWN,\n",
        "            adjust_edge_group_anim(edge_groups[0])\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                two.next_to, edge_groups[1].get_corner(UP+RIGHT), UP,\n",
        "                path_arc = np.pi/6,\n",
        "            ),\n",
        "            adjust_edge_group_anim(VGroup(*reversed(edge_groups[1])))\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                two.next_to, edge_groups[2].get_corner(DOWN+RIGHT), DOWN,\n",
        "                path_arc = -np.pi/6,\n",
        "            ),\n",
        "            adjust_edge_group_anim(edge_groups[2])\n",
        "        )\n",
        "        self.play(two.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def expand_last_layer(self):\n",
        "        neurons = self.network_mob.layers[-1].neurons\n",
        "        alt_neurons = self.last_layer_copy.neurons\n",
        "        output_labels = self.network_mob.output_labels\n",
        "        alt_output_labels = self.last_layer_copy[-1]\n",
        "        edges = self.network_mob.edge_groups[-1]\n",
        "\n",
        "        movers = VGroup(\n",
        "            neurons, alt_neurons, \n",
        "            output_labels, alt_output_labels, \n",
        "            *edges\n",
        "        )\n",
        "        to_fade = VGroup(self.brace, self.cost_words, self.double_arrow)\n",
        "        for mover in movers:\n",
        "            mover.save_state()\n",
        "            mover.generate_target()\n",
        "            mover.target.scale(2)\n",
        "        neurons[2].save_state()\n",
        "\n",
        "        neurons.target.to_edge(DOWN, MED_LARGE_BUFF)\n",
        "        output_labels.target.next_to(neurons.target, RIGHT, MED_SMALL_BUFF)\n",
        "        alt_neurons.target.next_to(neurons.target, RIGHT, buff = 2)\n",
        "        alt_output_labels.target.next_to(alt_neurons.target, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        n_pairs = it.product(\n",
        "            self.network_mob.layers[-2].neurons, \n",
        "            neurons.target\n",
        "        )\n",
        "        for edge, (n1, n2) in zip(edges, n_pairs):\n",
        "            r1 = n1.get_width()/2.0\n",
        "            r2 = n2.get_width()/2.0\n",
        "            c1 = n1.get_center()\n",
        "            c2 = n2.get_center()\n",
        "            vect = c2 - c1\n",
        "            norm = get_norm(vect)\n",
        "            unit_vect = vect / norm\n",
        "\n",
        "            edge.target.put_start_and_end_on(\n",
        "                c1 + unit_vect*r1,\n",
        "                c2 - unit_vect*r2\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            *list(map(MoveToTarget, movers))\n",
        "        )\n",
        "        self.show_decimals(neurons)\n",
        "        self.cannot_directly_affect_activations()\n",
        "        self.show_desired_activation_nudges(neurons, output_labels, alt_output_labels)\n",
        "        self.focus_on_one_neuron(movers)\n",
        "\n",
        "    def show_decimals(self, neurons):\n",
        "        decimals = VGroup()\n",
        "        for neuron in neurons:\n",
        "            activation = neuron.get_fill_opacity()\n",
        "            decimal = DecimalNumber(activation, num_decimal_places = 1)\n",
        "            decimal.set_width(0.7*neuron.get_width())\n",
        "            decimal.move_to(neuron)\n",
        "            if activation > 0.8:\n",
        "                decimal.set_color(BLACK)\n",
        "            decimals.add(decimal)\n",
        "\n",
        "        self.play(Write(decimals, run_time = 2))\n",
        "        self.wait()\n",
        "        self.decimals = decimals\n",
        "\n",
        "    def cannot_directly_affect_activations(self):\n",
        "        words = OldTexText(\"You can only adjust weights and biases\")\n",
        "        words.next_to(self.curr_image, RIGHT, MED_SMALL_BUFF, UP)\n",
        "\n",
        "        edges = VGroup(*self.network_mob.edge_groups.family_members_with_points())\n",
        "        random.shuffle(edges.submobjects)\n",
        "        for edge in edges:\n",
        "            edge.generate_target()\n",
        "            edge.target.set_stroke(\n",
        "                random.choice([BLUE, RED]),\n",
        "                2*random.random()**2,\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Transform, edges,\n",
        "                lambda e : (e, e.target),\n",
        "                run_time = 4, \n",
        "                rate_func = there_and_back,\n",
        "            ),\n",
        "            Write(words, run_time = 2)\n",
        "        )\n",
        "        self.play(FadeOut(words))\n",
        "\n",
        "    def show_desired_activation_nudges(self, neurons, output_labels, alt_output_labels):\n",
        "        arrows = VGroup()\n",
        "        rects = VGroup()\n",
        "        for i, neuron, label in zip(it.count(), neurons, alt_output_labels):\n",
        "            activation = neuron.get_fill_opacity()\n",
        "            target_val = 1 if i == 2 else 0\n",
        "            diff = abs(activation - target_val)\n",
        "            arrow = Arrow(\n",
        "                ORIGIN, diff*neuron.get_height()*DOWN,\n",
        "                color = RED,\n",
        "            )\n",
        "            arrow.move_to(neuron.get_right())\n",
        "            arrow.shift(0.175*RIGHT)\n",
        "            if i == 2:\n",
        "                arrow.set_color(BLUE)\n",
        "                arrow.rotate(np.pi)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "            rect = SurroundingRectangle(VGroup(neuron, label))\n",
        "            if i == 2:\n",
        "                rect.set_color(BLUE)\n",
        "            else:\n",
        "                rect.set_color(RED)\n",
        "            rects.add(rect)\n",
        "\n",
        "        self.play(\n",
        "            output_labels.shift, SMALL_BUFF*RIGHT,\n",
        "            LaggedStartMap(GrowArrow, arrows, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Show changing activations\n",
        "        anims = []\n",
        "        def get_decimal_update(start, end):\n",
        "            return lambda a : interpolate(start, end, a)\n",
        "        for i in range(10):\n",
        "            target = 1.0 if i == 2 else 0.01\n",
        "            anims += [neurons[i].set_fill, WHITE, target]\n",
        "            decimal = self.decimals[i]\n",
        "            anims.append(ChangingDecimal(\n",
        "                decimal,\n",
        "                get_decimal_update(decimal.number, target),\n",
        "                num_decimal_places = 1\n",
        "            ))\n",
        "            anims.append(UpdateFromFunc(\n",
        "                self.decimals[i],\n",
        "                lambda m : m.set_fill(WHITE if m.number < 0.8 else BLACK)\n",
        "            ))\n",
        "\n",
        "        self.play(\n",
        "            *anims,\n",
        "            run_time = 3,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "\n",
        "        two_rect = rects[2]\n",
        "        eight_rect = rects[8].copy()\n",
        "        non_two_rects = VGroup(*[r for r in rects if r is not two_rect])\n",
        "        self.play(ShowCreation(two_rect))\n",
        "        self.wait()\n",
        "        self.remove(two_rect)\n",
        "        self.play(ReplacementTransform(two_rect.copy(), non_two_rects))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, non_two_rects, run_time = 1))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, arrows,\n",
        "            lambda arrow : (\n",
        "                lambda m : m.scale(0.5).set_color(YELLOW),\n",
        "                arrow,\n",
        "            ),\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.play(ShowCreation(two_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(two_rect, eight_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(eight_rect))\n",
        "\n",
        "        self.arrows = arrows\n",
        "\n",
        "    def focus_on_one_neuron(self, expanded_mobjects):\n",
        "        network_mob = self.network_mob\n",
        "        neurons = network_mob.layers[-1].neurons\n",
        "        labels = network_mob.output_labels\n",
        "        two_neuron = neurons[2]\n",
        "        neurons.remove(two_neuron)\n",
        "        two_label = labels[2]\n",
        "        labels.remove(two_label)\n",
        "        expanded_mobjects.remove(*two_neuron.edges_in)\n",
        "        two_decimal = self.decimals[2]\n",
        "        self.decimals.remove(two_decimal)\n",
        "        two_arrow = self.arrows[2]\n",
        "        self.arrows.remove(two_arrow)\n",
        "\n",
        "        to_fade = VGroup(*it.chain(\n",
        "            network_mob.layers[:2],\n",
        "            network_mob.edge_groups[:2],\n",
        "            expanded_mobjects,\n",
        "            self.decimals,\n",
        "            self.arrows\n",
        "        ))\n",
        "\n",
        "        self.play(FadeOut(to_fade))\n",
        "        self.wait()\n",
        "        for mob in expanded_mobjects:\n",
        "            if mob in [neurons, labels]:\n",
        "                mob.scale(0.5)\n",
        "                mob.move_to(mob.saved_state)\n",
        "            else:\n",
        "                mob.restore()\n",
        "        for d, a, n in zip(self.decimals, self.arrows, neurons):\n",
        "            d.scale(0.5)\n",
        "            d.move_to(n)\n",
        "            a.scale(0.5)\n",
        "            a.move_to(n.get_right())\n",
        "            a.shift(SMALL_BUFF*RIGHT)\n",
        "        labels.shift(SMALL_BUFF*RIGHT)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            two_neuron, two_label, two_arrow, two_decimal,\n",
        "        )\n",
        "\n",
        "    def show_activation_formula(self):\n",
        "        rhs = OldTex(\n",
        "            \"=\", \"\\\\sigma(\",\n",
        "            \"w_0\", \"a_0\", \"+\",\n",
        "            \"w_1\", \"a_1\", \"+\",\n",
        "            \"\\\\cdots\", \"+\",\n",
        "            \"w_{n-1}\", \"a_{n-1}\", \"+\",\n",
        "            \"b\", \")\"\n",
        "        )\n",
        "        equals = rhs[0]\n",
        "        sigma = VGroup(rhs[1], rhs[-1])\n",
        "        w_terms = rhs.get_parts_by_tex(\"w_\")\n",
        "        a_terms = rhs.get_parts_by_tex(\"a_\")\n",
        "        plus_terms = rhs.get_parts_by_tex(\"+\")\n",
        "        b = rhs.get_part_by_tex(\"b\", substring = False)\n",
        "        dots = rhs.get_part_by_tex(\"dots\")\n",
        "\n",
        "        w_terms.set_color(BLUE)\n",
        "        b.set_color(MAROON_B)\n",
        "        sigma.set_color(YELLOW)\n",
        "\n",
        "        rhs.to_corner(UP+RIGHT)\n",
        "        sigma.save_state()\n",
        "        sigma.shift(DOWN)\n",
        "        sigma.set_fill(opacity = 0)\n",
        "\n",
        "        prev_neurons = self.network_mob.layers[-2].neurons\n",
        "        edges = self.two_neuron.edges_in\n",
        "\n",
        "        neuron_copy = VGroup(\n",
        "            self.two_neuron.copy(),\n",
        "            self.two_decimal.copy(),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            neuron_copy.next_to, equals.get_left(), LEFT,\n",
        "            self.curr_image.to_corner, UP+LEFT,\n",
        "            Write(equals)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(edges.copy(), w_terms),\n",
        "            Write(VGroup(*plus_terms[:-1])),\n",
        "            Write(dots),\n",
        "            run_time = 1.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            prev_neurons.copy(), a_terms,\n",
        "            path_arc = np.pi/2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(plus_terms[-1]),\n",
        "            Write(b)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(sigma.restore)\n",
        "        self.wait()\n",
        "        for mob in b, w_terms, a_terms:\n",
        "            self.play(\n",
        "                mob.shift, MED_SMALL_BUFF*DOWN,\n",
        "                rate_func = there_and_back,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 1.5\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            rhs, w_terms, a_terms, b,\n",
        "            lhs = neuron_copy\n",
        "        )\n",
        "\n",
        "    def three_ways_to_increase(self):\n",
        "        w_terms = self.w_terms\n",
        "        a_terms = self.a_terms\n",
        "        b = self.b\n",
        "        increase_words = VGroup(\n",
        "            OldTexText(\"Increase\", \"$b$\"),\n",
        "            OldTexText(\"Increase\", \"$w_i$\"),\n",
        "            OldTexText(\"Change\", \"$a_i$\"),\n",
        "        )\n",
        "        for words in increase_words:\n",
        "            words.set_color_by_tex_to_color_map({\n",
        "                \"b\" : b.get_color(),\n",
        "                \"w_\" : w_terms.get_color(),\n",
        "                \"a_\" : a_terms.get_color(),\n",
        "            })\n",
        "        increase_words.arrange(\n",
        "            DOWN, aligned_edge = LEFT,\n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "        increase_words.to_edge(LEFT)\n",
        "\n",
        "        mobs = [b, w_terms[0], a_terms[0]]\n",
        "        for words, mob in zip(increase_words, mobs):\n",
        "            self.play(\n",
        "                Write(words[0], run_time = 1),\n",
        "                ReplacementTransform(mob.copy(), words[1])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.increase_words = increase_words\n",
        "\n",
        "    def note_connections_to_brightest_neurons(self):\n",
        "        w_terms = self.w_terms\n",
        "        a_terms = self.a_terms\n",
        "        increase_words = self.increase_words\n",
        "        prev_neurons = self.network_mob.layers[-2].neurons\n",
        "        edges = self.two_neuron.edges_in\n",
        "\n",
        "        prev_activations = np.array([n.get_fill_opacity() for n in prev_neurons])\n",
        "        sorted_indices = np.argsort(prev_activations.flatten())\n",
        "        bright_neurons = VGroup()\n",
        "        dim_neurons = VGroup()\n",
        "        edges_to_bright_neurons = VGroup()\n",
        "        for i in sorted_indices[:5]:\n",
        "            dim_neurons.add(prev_neurons[i])\n",
        "        for i in sorted_indices[-4:]:\n",
        "            bright_neurons.add(prev_neurons[i])\n",
        "            edges_to_bright_neurons.add(edges[i])\n",
        "        bright_edges = edges_to_bright_neurons.copy()\n",
        "        bright_edges.set_stroke(YELLOW, 4)\n",
        "\n",
        "        added_words = OldTexText(\"in proportion to $a_i$\")\n",
        "        added_words.next_to(\n",
        "            increase_words[1], DOWN, \n",
        "            1.5*SMALL_BUFF, LEFT\n",
        "        )\n",
        "        added_words.set_color(YELLOW)\n",
        "\n",
        "        terms_rect = SurroundingRectangle(\n",
        "            VGroup(w_terms[0], a_terms[0]),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, edges,\n",
        "            lambda edge : (\n",
        "                lambda m : m.rotate(np.pi/12).set_stroke(YELLOW),\n",
        "                edge\n",
        "            ),\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(bright_edges),\n",
        "            ShowCreation(bright_neurons)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, bright_neurons,\n",
        "            lambda m : (m.shift, MED_LARGE_BUFF*LEFT),\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(bright_edges[0].copy(), w_terms[0]),\n",
        "            ReplacementTransform(bright_neurons[0].copy(), a_terms[0]),\n",
        "            ShowCreation(terms_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(LaggedStartMap(ShowCreationThenDestruction, bright_edges))\n",
        "        self.play(LaggedStartMap(ShowCreation, bright_edges))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, dim_neurons,\n",
        "            lambda m : (m.shift, MED_LARGE_BUFF*LEFT),\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.play(FadeOut(terms_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.curr_image.shift, MED_LARGE_BUFF*RIGHT,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(added_words))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            bright_neurons, bright_edges,\n",
        "            in_proportion_to_a = added_words\n",
        "        )\n",
        "\n",
        "    def fire_together_wire_together(self):\n",
        "        bright_neurons = self.bright_neurons\n",
        "        bright_edges = self.bright_edges\n",
        "        two_neuron = self.two_neuron\n",
        "        two_decimal = self.two_decimal\n",
        "        two_activation = two_decimal.number\n",
        "\n",
        "        def get_edge_animation():\n",
        "            return LaggedStartMap(\n",
        "                ShowCreationThenDestruction, bright_edges,\n",
        "                lag_ratio = 0.7\n",
        "            )\n",
        "        neuron_arrows = VGroup(*[\n",
        "            Vector(MED_LARGE_BUFF*RIGHT).next_to(n, LEFT)\n",
        "            for n in bright_neurons\n",
        "        ])\n",
        "        two_neuron_arrow = Vector(MED_LARGE_BUFF*DOWN)\n",
        "        two_neuron_arrow.next_to(two_neuron, UP)\n",
        "        VGroup(neuron_arrows, two_neuron_arrow).set_color(YELLOW)\n",
        "\n",
        "        neuron_rects = VGroup(*list(map(\n",
        "            SurroundingRectangle, bright_neurons\n",
        "        )))\n",
        "        two_neuron_rect = SurroundingRectangle(two_neuron)\n",
        "        seeing_words = OldTexText(\"Seeing a 2\")\n",
        "        seeing_words.scale(0.8)\n",
        "        thinking_words = OldTexText(\"Thinking about a 2\")\n",
        "        thinking_words.scale(0.8)\n",
        "        seeing_words.next_to(neuron_rects, UP)\n",
        "        thinking_words.next_to(two_neuron_arrow, RIGHT)\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.8)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        words = OldTexText(\"\"\"\n",
        "            ``Neurons that \\\\\\\\\n",
        "            fire together \\\\\\\\\n",
        "            wire together''\n",
        "        \"\"\")\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            morty.change, \"speaking\", words\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            get_edge_animation(),\n",
        "            morty.change, \"pondering\", bright_edges\n",
        "        )\n",
        "        self.play(get_edge_animation())\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, neuron_arrows),\n",
        "            get_edge_animation(),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(two_neuron_arrow),\n",
        "            morty.change, \"raise_right_hand\", two_neuron\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(two_neuron.set_fill, WHITE, 1),\n",
        "            ChangingDecimal(\n",
        "                two_decimal,\n",
        "                lambda a : interpolate(two_activation, 1, a),\n",
        "                num_decimal_places = 1,\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                two_decimal,\n",
        "                lambda m : m.set_color(WHITE if m.number < 0.8 else BLACK),\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, bright_edges),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, neuron_rects),\n",
        "            Write(seeing_words, run_time = 2),\n",
        "            morty.change, \"thinking\", seeing_words\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(two_neuron_rect),\n",
        "            Write(thinking_words, run_time = 2),\n",
        "            morty.look_at, thinking_words\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            neuron_rects, two_neuron_rect,\n",
        "            seeing_words, thinking_words,\n",
        "            words, morty,\n",
        "            neuron_arrows, two_neuron_arrow,\n",
        "            bright_edges, \n",
        "        )))\n",
        "        self.play(\n",
        "            ApplyMethod(two_neuron.set_fill, WHITE, two_activation),\n",
        "            ChangingDecimal(\n",
        "                two_decimal,\n",
        "                lambda a : interpolate(1, two_activation, a),\n",
        "                num_decimal_places = 1,\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                two_decimal,\n",
        "                lambda m : m.set_color(WHITE if m.number < 0.8 else BLACK),\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def show_desired_increase_to_previous_neurons(self):\n",
        "        increase_words = self.increase_words\n",
        "        two_neuron = self.two_neuron\n",
        "        two_decimal = self.two_decimal\n",
        "        edges = two_neuron.edges_in\n",
        "        prev_neurons = self.network_mob.layers[-2].neurons\n",
        "\n",
        "        positive_arrows = VGroup()\n",
        "        negative_arrows = VGroup()\n",
        "        all_arrows = VGroup()\n",
        "        positive_edges = VGroup()\n",
        "        negative_edges = VGroup()\n",
        "        positive_neurons = VGroup()\n",
        "        negative_neurons = VGroup()\n",
        "        for neuron, edge in zip(prev_neurons, edges):\n",
        "            value = self.get_edge_value(edge)\n",
        "            arrow = self.get_neuron_nudge_arrow(edge)\n",
        "            arrow.move_to(neuron.get_left())\n",
        "            arrow.shift(SMALL_BUFF*LEFT)\n",
        "            all_arrows.add(arrow)\n",
        "            if value > 0:\n",
        "                positive_arrows.add(arrow)\n",
        "                positive_edges.add(edge)\n",
        "                positive_neurons.add(neuron)\n",
        "            else:\n",
        "                negative_arrows.add(arrow)\n",
        "                negative_edges.add(edge)\n",
        "                negative_neurons.add(neuron)\n",
        "        for s_edges in positive_edges, negative_edges:\n",
        "            s_edges.alt_position = VGroup(*[\n",
        "                Line(LEFT, RIGHT, color = s_edge.get_color())\n",
        "                for s_edge in s_edges\n",
        "            ])\n",
        "            s_edges.alt_position.arrange(DOWN, MED_SMALL_BUFF)\n",
        "            s_edges.alt_position.to_corner(DOWN+RIGHT, LARGE_BUFF)\n",
        "\n",
        "        added_words = OldTexText(\"in proportion to $w_i$\")\n",
        "        added_words.set_color(self.w_terms.get_color())\n",
        "        added_words.next_to(\n",
        "            increase_words[-1], DOWN,\n",
        "            SMALL_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, prev_neurons,\n",
        "            lambda neuron : (\n",
        "                lambda m : m.scale(0.5).set_color(YELLOW),\n",
        "                neuron\n",
        "            ),\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait()\n",
        "        for positive in [True, False]:\n",
        "            if positive:\n",
        "                arrows = positive_arrows\n",
        "                s_edges = positive_edges\n",
        "                neurons = positive_neurons\n",
        "                color = self.positive_edge_color\n",
        "            else:\n",
        "                arrows = negative_arrows\n",
        "                s_edges = negative_edges\n",
        "                neurons = negative_neurons\n",
        "                color = self.negative_edge_color\n",
        "            s_edges.save_state()\n",
        "            self.play(Transform(s_edges, s_edges.alt_position))\n",
        "            self.wait(0.5)\n",
        "            self.play(s_edges.restore)\n",
        "            self.play(\n",
        "                LaggedStartMap(GrowArrow, arrows),\n",
        "                neurons.set_stroke, color\n",
        "            )\n",
        "            self.play(ApplyMethod(\n",
        "                neurons.set_fill, color, 1,\n",
        "                rate_func = there_and_back,\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            two_neuron.set_fill, None, 0.8,\n",
        "            ChangingDecimal(\n",
        "                two_decimal,\n",
        "                lambda a : two_neuron.get_fill_opacity()\n",
        "            ),\n",
        "            run_time = 3,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                edge.set_stroke, None, 3*edge.get_stroke_width(),\n",
        "                rate_func = there_and_back, \n",
        "                run_time = 2\n",
        "            )\n",
        "            for edge in edges\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Write(added_words, run_time = 1))\n",
        "        self.play(prev_neurons.set_stroke, WHITE, 2)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            in_proportion_to_w = added_words,\n",
        "            prev_neuron_arrows = all_arrows,\n",
        "        )\n",
        "\n",
        "    def only_keeping_track_of_changes(self):\n",
        "        arrows = self.prev_neuron_arrows\n",
        "        prev_neurons = self.network_mob.layers[-2].neurons\n",
        "        rect = SurroundingRectangle(VGroup(arrows, prev_neurons))\n",
        "\n",
        "        words1 = OldTexText(\"No direct influence\")\n",
        "        words1.next_to(rect, UP)\n",
        "        words2 = OldTexText(\"Just keeping track\")\n",
        "        words2.move_to(words1)\n",
        "\n",
        "        edges = self.network_mob.edge_groups[-2]\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(Write(words1))\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, prev_neurons,\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, edges\n",
        "        ))\n",
        "        self.play(Transform(words1, words2))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(words1, rect)))\n",
        "\n",
        "    def show_other_output_neurons(self):\n",
        "        two_neuron = self.two_neuron\n",
        "        two_decimal = self.two_decimal\n",
        "        two_arrow = self.two_arrow\n",
        "        two_label = self.two_label\n",
        "        two_edges = two_neuron.edges_in\n",
        "\n",
        "        prev_neurons = self.network_mob.layers[-2].neurons\n",
        "        neurons = self.network_mob.layers[-1].neurons\n",
        "        prev_neuron_arrows = self.prev_neuron_arrows\n",
        "        arrows_to_fade = VGroup(prev_neuron_arrows)\n",
        "\n",
        "        output_labels = self.network_mob.output_labels\n",
        "        quads = list(zip(neurons, self.decimals, self.arrows, output_labels))\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(\n",
        "            two_neuron.restore,\n",
        "            two_decimal.scale, 0.5,\n",
        "            two_decimal.move_to, two_neuron.saved_state,\n",
        "            two_arrow.scale, 0.5,\n",
        "            two_arrow.next_to, two_neuron.saved_state, RIGHT, 0.5*SMALL_BUFF,\n",
        "            two_label.scale, 0.5,\n",
        "            two_label.next_to, two_neuron.saved_state, RIGHT, 1.5*SMALL_BUFF,\n",
        "            FadeOut(VGroup(self.lhs, self.rhs)),\n",
        "            *[e.restore for e in two_edges]\n",
        "        )\n",
        "        for neuron, decimal, arrow, label in quads[:2] + quads[2:5]:\n",
        "            plusses = VGroup()\n",
        "            new_arrows = VGroup()\n",
        "            for edge, prev_arrow in zip(neuron.edges_in, prev_neuron_arrows):\n",
        "                plus = OldTex(\"+\").scale(0.5)\n",
        "                plus.move_to(prev_arrow)\n",
        "                plus.shift(2*SMALL_BUFF*LEFT)\n",
        "                new_arrow = self.get_neuron_nudge_arrow(edge)\n",
        "                new_arrow.move_to(plus)\n",
        "                new_arrow.shift(2*SMALL_BUFF*LEFT)\n",
        "                plusses.add(plus)\n",
        "                new_arrows.add(new_arrow)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(VGroup(neuron, decimal, arrow, label)),\n",
        "                LaggedStartMap(ShowCreation, neuron.edges_in),\n",
        "            )\n",
        "            self.play(\n",
        "                ReplacementTransform(neuron.edges_in.copy(), new_arrows),\n",
        "                Write(plusses, run_time = 2)\n",
        "            )\n",
        "\n",
        "            arrows_to_fade.add(new_arrows, plusses)\n",
        "            prev_neuron_arrows = new_arrows\n",
        "\n",
        "        all_dots_plus = VGroup()\n",
        "        for arrow in prev_neuron_arrows:\n",
        "            dots_plus = OldTex(\"\\\\cdots +\")\n",
        "            dots_plus.scale(0.5)\n",
        "            dots_plus.move_to(arrow.get_center(), RIGHT)\n",
        "            dots_plus.shift(2*SMALL_BUFF*LEFT)\n",
        "            all_dots_plus.add(dots_plus)\n",
        "        arrows_to_fade.add(all_dots_plus)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, VGroup(*it.starmap(VGroup, quads[5:])),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, VGroup(*[n.edges_in for n in neurons[5:]])\n",
        "            ),\n",
        "            Write(all_dots_plus),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        ##\n",
        "        words = OldTexText(\"Propagate backwards\")\n",
        "        words.to_edge(UP)\n",
        "        words.set_color(BLUE)\n",
        "        target_arrows = prev_neuron_arrows.copy()\n",
        "        target_arrows.next_to(prev_neurons, RIGHT, SMALL_BUFF)\n",
        "        rect = SurroundingRectangle(VGroup(\n",
        "            self.network_mob.layers[-1],\n",
        "            self.network_mob.output_labels\n",
        "        ))\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.set_stroke(BLACK, 0)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(self.network_mob.edge_groups[-1]),\n",
        "            FadeIn(rect),\n",
        "            ReplacementTransform(arrows_to_fade, VGroup(target_arrows)),\n",
        "        )\n",
        "        self.prev_neuron_arrows = target_arrows\n",
        "\n",
        "    def show_recursion(self):\n",
        "        network_mob = self.network_mob\n",
        "        words_to_fade = VGroup(\n",
        "            self.increase_words,\n",
        "            self.in_proportion_to_w,\n",
        "            self.in_proportion_to_a,\n",
        "        )\n",
        "        edges = network_mob.edge_groups[1]\n",
        "        neurons = network_mob.layers[2].neurons\n",
        "        prev_neurons = network_mob.layers[1].neurons\n",
        "        for neuron in neurons:\n",
        "            neuron.edges_in.save_state()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(words_to_fade),\n",
        "            FadeIn(prev_neurons),\n",
        "            LaggedStartMap(ShowCreation, edges),\n",
        "        )\n",
        "        self.wait()\n",
        "        for neuron, arrow in zip(neurons, self.prev_neuron_arrows):\n",
        "            edge_copies = neuron.edges_in.copy()\n",
        "            for edge in edge_copies:\n",
        "                edge.set_stroke(arrow.get_color(), 2)\n",
        "                edge.rotate(np.pi)\n",
        "            self.play(\n",
        "                edges.set_stroke, None, 0.15,\n",
        "                neuron.edges_in.restore,\n",
        "            )\n",
        "            self.play(ShowCreationThenDestruction(edge_copies))\n",
        "            self.remove(edge_copies)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_neuron_nudge_arrow(self, edge):\n",
        "        value = self.get_edge_value(edge)\n",
        "        height = np.sign(value)*0.1 + 0.1*value\n",
        "        arrow = Vector(height*UP, color = edge.get_color())\n",
        "        return arrow\n",
        "\n",
        "    def get_edge_value(self, edge):\n",
        "        value = edge.get_stroke_width()\n",
        "        if Color(edge.get_stroke_color()) == Color(self.negative_edge_color):\n",
        "            value *= -1\n",
        "        return value\n",
        "\n",
        "class WriteHebbian(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Hebbian theory\")\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(UP)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class NotANeuroScientist(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        quote = OldTexText(\"``Neurons that fire together wire together''\")\n",
        "        quote.to_edge(UP)\n",
        "        self.add(quote)\n",
        "        asterisks = OldTexText(\"***\")\n",
        "        asterisks.next_to(quote.get_corner(UP+RIGHT), RIGHT, SMALL_BUFF)\n",
        "        asterisks.set_color(BLUE)\n",
        "\n",
        "        brain = SVGMobject(file_name = \"brain\")\n",
        "        brain.set_height(1.5)\n",
        "        self.add(brain)\n",
        "        double_arrow = DoubleArrow(LEFT, RIGHT)\n",
        "        double_arrow.next_to(brain, RIGHT)\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.next_to(double_arrow, UP)\n",
        "\n",
        "        network = NetworkMobject(Network(sizes = [6, 4, 4, 5]))\n",
        "        network.set_height(1.5)\n",
        "        network.next_to(double_arrow, RIGHT)\n",
        "\n",
        "        group = VGroup(brain, double_arrow, q_marks, network)\n",
        "        group.next_to(self.students, UP, buff = 1.5)\n",
        "        self.add(group)\n",
        "        self.add(ContinualEdgeUpdate(\n",
        "            network,\n",
        "            stroke_width_exp = 0.5,\n",
        "            color = [BLUE, RED],\n",
        "        ))\n",
        "\n",
        "        rect = SurroundingRectangle(group)\n",
        "        no_claim_words = OldTexText(\"No claims here...\")\n",
        "        no_claim_words.next_to(rect, UP)\n",
        "        no_claim_words.set_color(YELLOW)\n",
        "\n",
        "        brain_outline = brain.copy()\n",
        "        brain_outline.set_fill(opacity = 0)\n",
        "        brain_outline.set_stroke(BLUE, 3)\n",
        "        brain_anim = ShowCreationThenDestruction(brain_outline)\n",
        "\n",
        "        words = OldTexText(\"Definitely not \\\\\\\\ a neuroscientist\")\n",
        "        words.next_to(self.teacher, UP, buff = 1.5)\n",
        "        words.shift_onto_screen()\n",
        "        arrow = Arrow(words.get_bottom(), self.teacher.get_top())\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            GrowArrow(arrow),\n",
        "            self.teacher.change, \"guilty\", words,\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play_student_changes(*3*[\"sassy\"])\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(no_claim_words, run_time = 1),\n",
        "            brain_anim\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(brain_anim)\n",
        "        self.play(FocusOn(asterisks))\n",
        "        self.play(Write(asterisks, run_time = 1))\n",
        "        for x in range(2):\n",
        "            self.play(brain_anim)\n",
        "            self.wait()\n",
        "\n",
        "class ConstructGradientFromAllTrainingExamples(Scene):\n",
        "    CONFIG = { \n",
        "        \"image_height\" : 0.9,\n",
        "        \"eyes_height\" : 0.25,\n",
        "        \"n_examples\" : 6,\n",
        "        \"change_scale_val\" : 0.8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_grid()\n",
        "        self.setup_weights()\n",
        "        self.show_two_requesting_changes()\n",
        "        self.show_all_examples_requesting_changes()\n",
        "        self.average_together()\n",
        "        self.collapse_into_gradient_vector()\n",
        "\n",
        "    def setup_grid(self):\n",
        "        h_lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT).scale(0.85*FRAME_X_RADIUS)\n",
        "            for x in range(6)\n",
        "        ])\n",
        "        h_lines.arrange(DOWN, buff = 1)\n",
        "        h_lines.set_stroke(GREY_B, 2)\n",
        "        h_lines.to_edge(DOWN, buff = MED_LARGE_BUFF)\n",
        "        h_lines.to_edge(LEFT, buff = 0)\n",
        "\n",
        "        v_lines = VGroup(*[\n",
        "            Line(UP, DOWN).scale(FRAME_Y_RADIUS - MED_LARGE_BUFF)\n",
        "            for x in range(self.n_examples + 1)\n",
        "        ])\n",
        "        v_lines.arrange(RIGHT, buff = 1.4)\n",
        "        v_lines.set_stroke(GREY_B, 2)\n",
        "        v_lines.to_edge(LEFT, buff = 2)\n",
        "\n",
        "        # self.add(h_lines, v_lines)\n",
        "        self.h_lines = h_lines\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def setup_weights(self):\n",
        "        weights = VGroup(*list(map(Tex, [\n",
        "            \"w_0\", \"w_1\", \"w_2\", \"\\\\vdots\", \"w_{13{,}001}\"\n",
        "        ])))\n",
        "        for i, weight in enumerate(weights):\n",
        "            weight.move_to(self.get_grid_position(i, 0))\n",
        "        weights.to_edge(LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        brace = Brace(weights, RIGHT)\n",
        "        weights_words = brace.get_text(\"All weights and biases\")\n",
        "\n",
        "        self.add(weights, brace, weights_words)\n",
        "        self.set_variables_as_attrs(\n",
        "            weights, brace, weights_words,\n",
        "            dots = weights[-2]\n",
        "        )\n",
        "\n",
        "    def show_two_requesting_changes(self):\n",
        "        two = self.get_example(get_organized_images()[2][0], 0)\n",
        "        self.two = two\n",
        "        self.add(two)\n",
        "\n",
        "        self.two_changes = VGroup()\n",
        "        for i in list(range(3)) + [4]:\n",
        "            weight = self.weights[i]\n",
        "            bubble, change = self.get_requested_change_bubble(two)\n",
        "            weight.save_state()\n",
        "            weight.generate_target()\n",
        "            weight.target.next_to(two, RIGHT, aligned_edge = DOWN)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(weight),\n",
        "                two.eyes.look_at_anim(weight.target),\n",
        "                FadeIn(bubble),\n",
        "                Write(change, run_time = 1),\n",
        "            )\n",
        "            if random.random() < 0.5:\n",
        "                self.play(two.eyes.blink_anim())\n",
        "            else:\n",
        "                self.wait()\n",
        "            if i == 0:\n",
        "                added_anims = [\n",
        "                    FadeOut(self.brace),\n",
        "                    FadeOut(self.weights_words),\n",
        "                ]\n",
        "            elif i == 4:\n",
        "                dots_copy = self.dots.copy()\n",
        "                added_anims = [\n",
        "                    dots_copy.move_to,\n",
        "                    self.get_grid_position(3, 0)\n",
        "                ]\n",
        "                self.first_column_dots = dots_copy\n",
        "            else:\n",
        "                added_anims = []\n",
        "            self.play(\n",
        "                FadeOut(bubble),\n",
        "                weight.restore,\n",
        "                two.eyes.look_at_anim(weight.saved_state),\n",
        "                change.restore,\n",
        "                change.scale, self.change_scale_val,\n",
        "                change.move_to, self.get_grid_position(i, 0),\n",
        "                *added_anims\n",
        "            )\n",
        "            self.two_changes.add(change)\n",
        "        self.wait()\n",
        "\n",
        "    def show_all_examples_requesting_changes(self):\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        data = training_data[:self.n_examples-1]\n",
        "        examples = VGroup(*[\n",
        "            self.get_example(t[0], j)\n",
        "            for t, j in zip(data, it.count(1))\n",
        "        ])\n",
        "        h_dots = OldTex(\"\\\\dots\")\n",
        "        h_dots.next_to(examples, RIGHT, MED_LARGE_BUFF)\n",
        "        more_h_dots = VGroup(*[\n",
        "            OldTex(\"\\\\dots\").move_to(\n",
        "                self.get_grid_position(i, self.n_examples)\n",
        "            )\n",
        "            for i in range(5)\n",
        "        ])\n",
        "        more_h_dots.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        more_h_dots[-2].rotate(-np.pi/4)\n",
        "        more_v_dots = VGroup(*[\n",
        "            self.dots.copy().move_to(\n",
        "                self.get_grid_position(3, j)\n",
        "            )\n",
        "            for j in range(1, self.n_examples)\n",
        "        ])\n",
        "\n",
        "        changes = VGroup(*[\n",
        "            self.get_random_decimal().move_to(\n",
        "                self.get_grid_position(i, j)\n",
        "            )\n",
        "            for i in list(range(3)) + [4]\n",
        "            for j in range(1, self.n_examples)\n",
        "        ])\n",
        "        for change in changes:\n",
        "            change.scale(self.change_scale_val)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, examples),\n",
        "            LaggedStartMap(ShowCreation, self.h_lines),\n",
        "            LaggedStartMap(ShowCreation, self.v_lines),\n",
        "            Write(\n",
        "                h_dots, \n",
        "                run_time = 2, \n",
        "                rate_func = squish_rate_func(smooth, 0.7, 1)\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(changes),\n",
        "            Write(more_v_dots),\n",
        "            Write(more_h_dots),\n",
        "            *[\n",
        "                example.eyes.look_at_anim(random.choice(changes))\n",
        "                for example in examples\n",
        "            ]\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(random.choice(examples).eyes.blink_anim())\n",
        "\n",
        "        k = self.n_examples - 1\n",
        "        self.change_rows = VGroup(*[\n",
        "            VGroup(two_change, *changes[k*i:k*(i+1)])\n",
        "            for i, two_change in enumerate(self.two_changes)\n",
        "        ])\n",
        "        for i in list(range(3)) + [-1]:\n",
        "            self.change_rows[i].add(more_h_dots[i])\n",
        "\n",
        "        self.all_eyes = VGroup(*[\n",
        "            m.eyes for m in [self.two] + list(examples)\n",
        "        ])\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            more_h_dots, more_v_dots,\n",
        "            h_dots, changes,\n",
        "        )\n",
        "\n",
        "    def average_together(self):\n",
        "        rects = VGroup()\n",
        "        arrows = VGroup()\n",
        "        averages = VGroup()\n",
        "        for row in self.change_rows:\n",
        "            rect = SurroundingRectangle(row)\n",
        "            arrow = Arrow(ORIGIN, RIGHT)\n",
        "            arrow.next_to(rect, RIGHT)\n",
        "            rect.arrow = arrow\n",
        "            average = self.get_colored_decimal(3*np.mean([\n",
        "                m.number for m in row \n",
        "                if isinstance(m, DecimalNumber)\n",
        "            ]))\n",
        "            average.scale(self.change_scale_val)\n",
        "            average.next_to(arrow, RIGHT)\n",
        "            row.target = VGroup(average)\n",
        "\n",
        "            rects.add(rect)\n",
        "            arrows.add(arrow)\n",
        "            averages.add(average)\n",
        "\n",
        "        words = OldTexText(\"Average over \\\\\\\\ all training data\")\n",
        "        words.scale(0.8)\n",
        "        words.to_corner(UP+RIGHT)\n",
        "        arrow_to_averages = Arrow(\n",
        "            words.get_bottom(), averages.get_top(),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        dots = self.dots.copy()\n",
        "        dots.move_to(VGroup(*averages[-2:]))\n",
        "\n",
        "        look_at_anims = self.get_look_at_anims\n",
        "\n",
        "        self.play(Write(words, run_time = 1), *look_at_anims(words))\n",
        "        self.play(ShowCreation(rects[0]), *look_at_anims(rects[0]))\n",
        "        self.play(\n",
        "            ReplacementTransform(rects[0].copy(), arrows[0]),\n",
        "            rects[0].set_stroke, WHITE, 1,\n",
        "            ReplacementTransform(\n",
        "                self.change_rows[0].copy(),\n",
        "                self.change_rows[0].target\n",
        "            ),\n",
        "            *look_at_anims(averages[0])\n",
        "        )\n",
        "        self.play(GrowArrow(arrow_to_averages))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, VGroup(*rects[1:])),\n",
        "            *look_at_anims(rects[1])\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ReplacementTransform, VGroup(*rects[1:]).copy(),\n",
        "                lambda m : (m, m.arrow),\n",
        "                lag_ratio = 0.7,\n",
        "            ),\n",
        "            VGroup(*rects[1:]).set_stroke, WHITE, 1,\n",
        "            LaggedStartMap(\n",
        "                ReplacementTransform, VGroup(*self.change_rows[1:]).copy(),\n",
        "                lambda m : (m, m.target),\n",
        "                lag_ratio = 0.7,\n",
        "            ),\n",
        "            Write(dots),\n",
        "            *look_at_anims(averages[1])\n",
        "        )\n",
        "        self.blink(3)\n",
        "        self.wait()\n",
        "\n",
        "        averages.add(dots)\n",
        "        self.set_variables_as_attrs(\n",
        "            rects, arrows, averages,\n",
        "            arrow_to_averages\n",
        "        )\n",
        "\n",
        "    def collapse_into_gradient_vector(self):\n",
        "        averages = self.averages\n",
        "        lb, rb = brackets = OldTex(\"[]\")\n",
        "        brackets.scale(2)\n",
        "        brackets.stretch_to_fit_height(1.2*averages.get_height())\n",
        "        lb.next_to(averages, LEFT, SMALL_BUFF)\n",
        "        rb.next_to(averages, RIGHT, SMALL_BUFF)\n",
        "        brackets.set_fill(opacity = 0)\n",
        "\n",
        "        shift_vect = 2*LEFT\n",
        "\n",
        "        lhs = OldTex(\n",
        "            \"-\", \"\\\\nabla\", \"C(\",\n",
        "            \"w_1,\", \"w_2,\", \"\\\\dots\", \"w_{13{,}001}\",\n",
        "            \")\", \"=\"\n",
        "        )\n",
        "        lhs.next_to(lb, LEFT)\n",
        "        lhs.shift(shift_vect)\n",
        "        minus = lhs[0]\n",
        "        w_terms = lhs.get_parts_by_tex(\"w_\")\n",
        "        dots_term = lhs.get_part_by_tex(\"dots\")\n",
        "        eta = OldTex(\"\\\\eta\")\n",
        "        eta.move_to(minus, RIGHT)\n",
        "        eta.set_color(MAROON_B)\n",
        "\n",
        "        to_fade = VGroup(*it.chain(\n",
        "            self.h_lines, self.v_lines,\n",
        "            self.more_h_dots, self.more_v_dots,\n",
        "            self.change_rows, \n",
        "            self.first_column_dots,\n",
        "            self.rects,\n",
        "            self.arrows,\n",
        "        ))\n",
        "        arrow = self.arrow_to_averages\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, to_fade))\n",
        "        self.play(\n",
        "            brackets.shift, shift_vect,\n",
        "            brackets.set_fill, WHITE, 1,\n",
        "            averages.shift, shift_vect,\n",
        "            Transform(arrow, Arrow(\n",
        "                arrow.get_start(),\n",
        "                arrow.get_end() + shift_vect,\n",
        "                buff = 0,\n",
        "                color = arrow.get_color(),\n",
        "            )),\n",
        "            FadeIn(VGroup(*lhs[:3])),\n",
        "            FadeIn(VGroup(*lhs[-2:])),\n",
        "            *self.get_look_at_anims(lhs)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(self.weights, w_terms),\n",
        "            ReplacementTransform(self.dots, dots_term),\n",
        "            *self.get_look_at_anims(w_terms)\n",
        "        )\n",
        "        self.blink(2)\n",
        "        self.play(\n",
        "            GrowFromCenter(eta),\n",
        "            minus.shift, MED_SMALL_BUFF*LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_example(self, in_vect, index):\n",
        "        result = MNistMobject(in_vect)\n",
        "        result.set_height(self.image_height)\n",
        "\n",
        "        eyes = Eyes(result, height = self.eyes_height)\n",
        "        result.eyes = eyes\n",
        "        result.add(eyes)\n",
        "        result.move_to(self.get_grid_position(0, index))\n",
        "        result.to_edge(UP, buff = LARGE_BUFF)\n",
        "        return result\n",
        "\n",
        "    def get_grid_position(self, i, j):\n",
        "        x = VGroup(*self.v_lines[j:j+2]).get_center()[0]\n",
        "        y = VGroup(*self.h_lines[i:i+2]).get_center()[1]\n",
        "        return x*RIGHT + y*UP\n",
        "\n",
        "    def get_requested_change_bubble(self, example_mob):\n",
        "        change = self.get_random_decimal()\n",
        "        words = OldTexText(\"Change by\")\n",
        "        change.next_to(words, RIGHT)\n",
        "        change.save_state()\n",
        "        content = VGroup(words, change)\n",
        "\n",
        "        bubble = SpeechBubble(height = 1.5, width = 3)\n",
        "        bubble.add_content(content)\n",
        "        group = VGroup(bubble, content)\n",
        "        group.shift(\n",
        "            example_mob.get_right() + SMALL_BUFF*RIGHT \\\n",
        "            -bubble.get_corner(DOWN+LEFT)\n",
        "        )\n",
        "\n",
        "        return VGroup(bubble, words), change\n",
        "\n",
        "    def get_random_decimal(self):\n",
        "        return self.get_colored_decimal(\n",
        "            0.3*(random.random() - 0.5)\n",
        "        )\n",
        "\n",
        "    def get_colored_decimal(self, number):\n",
        "        result = DecimalNumber(number)\n",
        "        if result.number > 0:\n",
        "            plus = OldTex(\"+\")\n",
        "            plus.next_to(result, LEFT, SMALL_BUFF)\n",
        "            result.add_to_back(plus)\n",
        "            result.set_color(BLUE)\n",
        "        else:\n",
        "            result.set_color(RED)\n",
        "        return result\n",
        "\n",
        "    def get_look_at_anims(self, mob):\n",
        "        return [eyes.look_at_anim(mob) for eyes in self.all_eyes]\n",
        "\n",
        "    def blink(self, n):\n",
        "        for x in range(n):\n",
        "            self.play(random.choice(self.all_eyes).blink_anim())\n",
        "\n",
        "class WatchPreviousScene(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        screen = ScreenRectangle(height = 4.5)\n",
        "        screen.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\", screen,\n",
        "            self.change_students(\n",
        "                *[\"thinking\"]*3,\n",
        "                look_at = screen\n",
        "            ),\n",
        "            ShowCreation(screen)\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "class OpenCloseSGD(Scene):\n",
        "    def construct(self):\n",
        "        term = OldTex(\n",
        "            \"\\\\langle\", \"\\\\text{Stochastic gradient descent}\",\n",
        "            \"\\\\rangle\"\n",
        "        )\n",
        "        alt_term0 = OldTex(\"\\\\langle /\")\n",
        "        alt_term0.move_to(term[0], RIGHT)\n",
        "\n",
        "        term.save_state()\n",
        "        center = term.get_center()\n",
        "        term[0].move_to(center, RIGHT)\n",
        "        term[2].move_to(center, LEFT)\n",
        "        term[1].scale(0.0001).move_to(center)\n",
        "\n",
        "        self.play(term.restore)\n",
        "        self.wait(2)\n",
        "        self.play(Transform(term[0], alt_term0))\n",
        "        self.wait(2)\n",
        "\n",
        "class OrganizeDataIntoMiniBatches(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_rows\" : 5,\n",
        "        \"n_cols\" : 12,\n",
        "        \"example_height\" : 1,\n",
        "        \"random_seed\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.seed_random_libraries()\n",
        "        self.add_examples()\n",
        "        self.shuffle_examples()\n",
        "        self.divide_into_minibatches()\n",
        "        self.one_step_per_batch()\n",
        "\n",
        "    def seed_random_libraries(self):\n",
        "        random.seed(self.random_seed)\n",
        "        np.random.seed(self.random_seed)\n",
        "\n",
        "    def add_examples(self):\n",
        "        examples = self.get_examples()\n",
        "        self.arrange_examples_in_grid(examples)\n",
        "        for example in examples:\n",
        "            example.save_state()\n",
        "        alt_order_examples = VGroup(*examples)\n",
        "        for mob in examples, alt_order_examples:\n",
        "            random.shuffle(mob.submobjects)\n",
        "        self.arrange_examples_in_grid(examples)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, alt_order_examples,\n",
        "            lag_ratio = 0.2,\n",
        "            run_time = 4\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.examples = examples\n",
        "\n",
        "    def shuffle_examples(self):\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, self.examples,\n",
        "            lambda m : (m.restore,),\n",
        "            lag_ratio = 0.3,\n",
        "            run_time = 3,\n",
        "            path_arc = np.pi/3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def divide_into_minibatches(self):\n",
        "        examples = self.examples\n",
        "        examples.sort(lambda p : -p[1])\n",
        "        rows = Group(*[\n",
        "            Group(*examples[i*self.n_cols:(i+1)*self.n_cols])\n",
        "            for i in range(self.n_rows)\n",
        "        ])\n",
        "\n",
        "        mini_batches_words = OldTexText(\"``Mini-batches''\")\n",
        "        mini_batches_words.to_edge(UP)\n",
        "        mini_batches_words.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            rows.space_out_submobjects, 1.5,\n",
        "            rows.to_edge, UP, 1.5,\n",
        "            Write(mini_batches_words, run_time = 1)\n",
        "        )\n",
        "\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                row, \n",
        "                stroke_width = 0,\n",
        "                fill_color = YELLOW,\n",
        "                fill_opacity = 0.25,\n",
        "            )\n",
        "            for row in rows\n",
        "        ])\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, rects,\n",
        "            lag_ratio = 0.7,\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(rows, rects, mini_batches_words)\n",
        "\n",
        "    def one_step_per_batch(self):\n",
        "        rows = self.rows\n",
        "        brace = Brace(rows[0], UP, buff = SMALL_BUFF)\n",
        "        text = brace.get_text(\n",
        "            \"Compute gradient descent step (using backprop)\",\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        def indicate_row(row):\n",
        "            row.sort(lambda p : p[0])\n",
        "            return LaggedStartMap(\n",
        "                ApplyFunction, row,\n",
        "                lambda row : (\n",
        "                    lambda m : m.scale(0.75).set_color(YELLOW),\n",
        "                    row\n",
        "                ),\n",
        "                rate_func = wiggle\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.mini_batches_words),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(text, run_time = 2),\n",
        "        )\n",
        "        self.play(indicate_row(rows[0]))\n",
        "        brace.add(text)\n",
        "        for last_row, row in zip(rows, rows[1:-1]):\n",
        "            self.play(\n",
        "                last_row.shift, UP,\n",
        "                brace.next_to, row, UP, SMALL_BUFF\n",
        "            )\n",
        "            self.play(indicate_row(row))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_examples(self):\n",
        "        n_examples = self.n_rows*self.n_cols\n",
        "        height = self.example_height\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        return Group(*[\n",
        "            MNistMobject(\n",
        "                t[0],\n",
        "                rect_kwargs = {\"stroke_width\" : 2}\n",
        "            ).set_height(height)\n",
        "            for t in training_data[:n_examples]\n",
        "        ])\n",
        "        # return Group(*[\n",
        "        #     Square(\n",
        "        #         color = BLUE, \n",
        "        #         stroke_width = 2\n",
        "        #     ).set_height(height)\n",
        "        #     for x in range(n_examples)\n",
        "        # ])\n",
        "\n",
        "    def arrange_examples_in_grid(self, examples):\n",
        "        examples.arrange_in_grid(\n",
        "            n_rows = self.n_rows,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "class SGDSteps(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class GradientDescentSteps(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class SwimmingInTerms(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        terms = VGroup(\n",
        "            OldTexText(\"Cost surface\"),\n",
        "            OldTexText(\"Stochastic gradient descent\"),\n",
        "            OldTexText(\"Mini-batches\"),\n",
        "            OldTexText(\"Backpropagation\"),\n",
        "        )\n",
        "        terms.arrange(DOWN)\n",
        "        terms.to_edge(UP)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, terms),\n",
        "            self.change_students(*[\"horrified\"]*3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            terms[-1].next_to, self.teacher.get_corner(UP+LEFT), UP,\n",
        "            FadeOut(VGroup(*terms[:-1])),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class BackpropCode(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BackpropCodeAddOn(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"The code you'd find \\\\\\\\ in Nielsen's book\"\n",
        "        )\n",
        "        words.to_corner(DOWN+LEFT)\n",
        "        morty = self.pi_creature\n",
        "        morty.next_to(words, UP)\n",
        "        self.add(words)\n",
        "        for mode in [\"pondering\", \"thinking\", \"happy\"]:\n",
        "            self.play(\n",
        "                morty.change, \"pondering\",\n",
        "                morty.look, UP+LEFT\n",
        "            )\n",
        "            self.play(morty.look, LEFT)\n",
        "            self.wait(2)\n",
        "\n",
        "class CannotFollowCode(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"I...er...can't follow\\\\\\\\ that code at all.\",\n",
        "            target_mode = \"confused\",\n",
        "            index = 1\n",
        "        )\n",
        "        self.play(self.students[1].change, \"sad\")\n",
        "        self.play_student_changes(\n",
        "            \"angry\", \"sad\", \"angry\",\n",
        "            look_at = self.teacher.eyes\n",
        "        )\n",
        "        self.play(self.teacher.change, \"hesitant\")\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"Let's get to the \\\\\\\\ calculus then\",\n",
        "            target_mode = \"hooray\",\n",
        "            added_anims = [self.change_students(*3*[\"plain\"])],\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class EOCWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Essence of calculus\")\n",
        "        title.to_edge(UP)\n",
        "        screen = ScreenRectangle(height = 6)\n",
        "        screen.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen))\n",
        "        self.wait()\n",
        "\n",
        "class SimplestNetworkExample(PreviewLearning):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 6,\n",
        "        \"z_color\" : GREEN,\n",
        "        \"cost_color\" : RED,\n",
        "        \"desired_output_color\" : YELLOW,\n",
        "        \"derivative_scale_val\" : 0.85,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.seed_random_libraries()\n",
        "        self.collapse_ordinary_network()\n",
        "        self.show_weights_and_biases()\n",
        "        self.focus_just_on_last_two_layers()\n",
        "        self.label_neurons()\n",
        "        self.show_desired_output()\n",
        "        self.show_cost()\n",
        "        self.show_activation_formula()\n",
        "        self.introduce_z()\n",
        "        self.break_into_computational_graph()\n",
        "        self.show_preceding_layer_in_computational_graph()\n",
        "        self.show_number_lines()\n",
        "        self.ask_about_w_sensitivity()\n",
        "        self.show_derivative_wrt_w()\n",
        "        self.show_chain_of_events()\n",
        "        self.show_chain_rule()\n",
        "        self.name_chain_rule()\n",
        "        self.indicate_everything_on_screen()\n",
        "        self.prepare_for_derivatives()\n",
        "        self.compute_derivatives()\n",
        "        self.get_lost_in_formulas()\n",
        "        self.fire_together_wire_together()\n",
        "        self.organize_chain_rule_rhs()\n",
        "        self.show_average_derivative()\n",
        "        self.show_gradient()\n",
        "        self.transition_to_derivative_wrt_b()\n",
        "        self.show_derivative_wrt_b()\n",
        "        self.show_derivative_wrt_a()\n",
        "        self.show_previous_weight_and_bias()\n",
        "        self.animate_long_path()\n",
        "\n",
        "    def seed_random_libraries(self):\n",
        "        np.random.seed(self.random_seed)\n",
        "        random.seed(self.random_seed)\n",
        "\n",
        "    def collapse_ordinary_network(self):\n",
        "        network_mob = self.network_mob\n",
        "        config = dict(self.network_mob_config)\n",
        "        config.pop(\"include_output_labels\")\n",
        "        config.update({\n",
        "            \"edge_stroke_width\" : 3,\n",
        "            \"edge_propogation_color\" : YELLOW,\n",
        "            \"edge_propogation_time\" : 1,\n",
        "            \"neuron_radius\" : 0.3,\n",
        "        })\n",
        "        simple_network = Network(sizes = [1, 1, 1, 1])\n",
        "        simple_network_mob = NetworkMobject(simple_network, **config)\n",
        "        self.color_network_edges()\n",
        "        s_edges = simple_network_mob.edge_groups\n",
        "        for edge, weight_matrix in zip(s_edges, simple_network.weights):\n",
        "            weight = weight_matrix[0][0]\n",
        "            width = 2*abs(weight)\n",
        "            color = BLUE if weight > 0 else RED\n",
        "            edge.set_stroke(color, width)\n",
        "\n",
        "        def edge_collapse_anims(edges, left_attachment_target):\n",
        "            return [\n",
        "                ApplyMethod(\n",
        "                    e.put_start_and_end_on_with_projection,\n",
        "                    left_attachment_target.get_right(), \n",
        "                    e.get_end()\n",
        "                )\n",
        "                for e in edges\n",
        "            ]\n",
        "\n",
        "        neuron = simple_network_mob.layers[0].neurons[0]\n",
        "        self.play(\n",
        "            ReplacementTransform(network_mob.layers[0], neuron),\n",
        "            *edge_collapse_anims(network_mob.edge_groups[0], neuron)\n",
        "        )\n",
        "        for i, layer in enumerate(network_mob.layers[1:]):\n",
        "            neuron = simple_network_mob.layers[i+1].neurons[0]\n",
        "            prev_edges = network_mob.edge_groups[i]\n",
        "            prev_edge_target = simple_network_mob.edge_groups[i]\n",
        "            if i+1 < len(network_mob.edge_groups):\n",
        "                edges = network_mob.edge_groups[i+1]\n",
        "                added_anims = edge_collapse_anims(edges, neuron)\n",
        "            else:\n",
        "                added_anims = [FadeOut(network_mob.output_labels)]\n",
        "            self.play(\n",
        "                ReplacementTransform(layer, neuron),\n",
        "                ReplacementTransform(prev_edges, prev_edge_target),\n",
        "                *added_anims\n",
        "            )\n",
        "        self.remove(network_mob)\n",
        "        self.add(simple_network_mob)\n",
        "        self.network_mob = simple_network_mob\n",
        "        self.network = self.network_mob.neural_network\n",
        "        self.feed_forward(np.array([0.5]))\n",
        "        self.wait()\n",
        "\n",
        "    def show_weights_and_biases(self):\n",
        "        network_mob = self.network_mob\n",
        "        edges = VGroup(*[eg[0] for eg in network_mob.edge_groups])\n",
        "        neurons = VGroup(*[\n",
        "            layer.neurons[0] \n",
        "            for layer in network_mob.layers[1:]\n",
        "        ])\n",
        "        expression = OldTex(\n",
        "            \"C\", \"(\", \n",
        "            \"w_1\", \",\", \"b_1\", \",\",\n",
        "            \"w_2\", \",\", \"b_2\", \",\",\n",
        "            \"w_3\", \",\", \"b_3\",\n",
        "            \")\"\n",
        "        )\n",
        "        expression.shift(2*UP)\n",
        "        expression.set_color_by_tex(\"C\", RED)\n",
        "        w_terms = expression.get_parts_by_tex(\"w_\")\n",
        "        for w, edge in zip(w_terms, edges):\n",
        "            w.set_color(edge.get_color())\n",
        "        b_terms = expression.get_parts_by_tex(\"b_\")\n",
        "        variables = VGroup(*it.chain(w_terms, b_terms))\n",
        "        other_terms = VGroup(*[m for m in expression if m not in variables])\n",
        "        random.shuffle(variables.submobjects)\n",
        "\n",
        "        self.play(ReplacementTransform(edges.copy(), w_terms))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(neurons.copy(), b_terms))\n",
        "        self.wait()\n",
        "        self.play(Write(other_terms))\n",
        "        for x in range(2):\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, variables,\n",
        "                rate_func = wiggle,\n",
        "                run_time = 4,\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(other_terms),\n",
        "            ReplacementTransform(w_terms, edges),\n",
        "            ReplacementTransform(b_terms, neurons),\n",
        "        )\n",
        "        self.remove(expression)\n",
        "\n",
        "    def focus_just_on_last_two_layers(self):\n",
        "        to_fade = VGroup(*it.chain(*list(zip(\n",
        "            self.network_mob.layers[:2],\n",
        "            self.network_mob.edge_groups[:2],\n",
        "        ))))\n",
        "        for mob in to_fade:\n",
        "            mob.save_state()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, to_fade,\n",
        "            lambda m : (m.fade, 0.9)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.prev_layers = to_fade\n",
        "\n",
        "    def label_neurons(self):\n",
        "        neurons = VGroup(*[\n",
        "            self.network_mob.layers[i].neurons[0]\n",
        "            for i in (-1, -2)\n",
        "        ])\n",
        "        decimals = VGroup()\n",
        "        a_labels = VGroup()\n",
        "        a_label_arrows = VGroup()\n",
        "        superscripts = [\"L\", \"L-1\"]\n",
        "        superscript_rects = VGroup()\n",
        "        for neuron, superscript in zip(neurons, superscripts):\n",
        "            decimal = self.get_neuron_activation_decimal(neuron)\n",
        "            label = OldTex(\"a^{(%s)}\"%superscript)\n",
        "            label.next_to(neuron, DOWN, buff = LARGE_BUFF)\n",
        "            superscript_rect = SurroundingRectangle(VGroup(*label[1:]))\n",
        "            arrow = Arrow(\n",
        "                label[0].get_top(),\n",
        "                neuron.get_bottom(),\n",
        "                buff = SMALL_BUFF,\n",
        "                color = WHITE\n",
        "            )\n",
        "\n",
        "            decimal.save_state()\n",
        "            decimal.set_fill(opacity = 0)\n",
        "            decimal.move_to(label)\n",
        "\n",
        "            decimals.add(decimal)\n",
        "            a_labels.add(label)\n",
        "            a_label_arrows.add(arrow)\n",
        "            superscript_rects.add(superscript_rect)\n",
        "\n",
        "            self.play(\n",
        "                Write(label, run_time = 1),\n",
        "                GrowArrow(arrow),\n",
        "            )\n",
        "            self.play(decimal.restore)\n",
        "            opacity = neuron.get_fill_opacity()\n",
        "            self.play(\n",
        "                neuron.set_fill, None, 0,\n",
        "                ChangingDecimal(\n",
        "                    decimal, \n",
        "                    lambda a : interpolate(opacity, 0.01, a)\n",
        "                ),\n",
        "                UpdateFromFunc(\n",
        "                    decimal,\n",
        "                    lambda d : d.set_fill(WHITE if d.number < 0.8 else BLACK)\n",
        "                ),\n",
        "                run_time = 2,\n",
        "                rate_func = there_and_back,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        not_exponents = OldTexText(\"Not exponents\")\n",
        "        not_exponents.next_to(superscript_rects, DOWN, MED_LARGE_BUFF)\n",
        "        not_exponents.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, superscript_rects,\n",
        "                lag_ratio = 0.8, run_time = 1.5\n",
        "            ),\n",
        "            Write(not_exponents, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [not_exponents, superscript_rects])))\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            a_labels, a_label_arrows, decimals,\n",
        "            last_neurons = neurons\n",
        "        )\n",
        "\n",
        "    def show_desired_output(self):\n",
        "        neuron = self.network_mob.layers[-1].neurons[0].copy()\n",
        "        neuron.shift(2*RIGHT)\n",
        "        neuron.set_fill(opacity = 1)\n",
        "        decimal = self.get_neuron_activation_decimal(neuron)\n",
        "\n",
        "        rect = SurroundingRectangle(neuron)\n",
        "        words = OldTexText(\"Desired \\\\\\\\ output\")\n",
        "        words.next_to(rect, UP)\n",
        "\n",
        "        y_label = OldTex(\"y\")\n",
        "        y_label.next_to(neuron, DOWN, LARGE_BUFF)\n",
        "        y_label.align_to(self.a_labels, DOWN)\n",
        "        y_label_arrow = Arrow(\n",
        "            y_label, neuron, \n",
        "            color = WHITE,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        VGroup(words, rect, y_label).set_color(self.desired_output_color)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [neuron, decimal])))\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(words, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(y_label, run_time = 1),\n",
        "            GrowArrow(y_label_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            y_label, y_label_arrow,\n",
        "            desired_output_neuron = neuron,\n",
        "            desired_output_decimal = decimal,\n",
        "            desired_output_rect = rect,\n",
        "            desired_output_words = words,\n",
        "        )\n",
        "\n",
        "    def show_cost(self):\n",
        "        pre_a = self.a_labels[0].copy()\n",
        "        pre_y = self.y_label.copy()\n",
        "\n",
        "        cost_equation = OldTex(\n",
        "            \"C_0\", \"(\", \"\\\\dots\", \")\", \"=\",\n",
        "            \"(\", \"a^{(L)}\", \"-\", \"y\", \")\", \"^2\"\n",
        "        )\n",
        "        cost_equation.to_corner(UP+RIGHT)\n",
        "        C0, a, y = [\n",
        "            cost_equation.get_part_by_tex(tex)\n",
        "            for tex in (\"C_0\", \"a^{(L)}\", \"y\")\n",
        "        ]\n",
        "        y.set_color(YELLOW)\n",
        "\n",
        "        cost_word = OldTexText(\"Cost\")\n",
        "        cost_word.next_to(C0[0], LEFT, LARGE_BUFF)\n",
        "        cost_arrow = Arrow(\n",
        "            cost_word, C0,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        VGroup(C0, cost_word, cost_arrow).set_color(self.cost_color)\n",
        "\n",
        "        expression = OldTex(\n",
        "            \"\\\\text{For example: }\"\n",
        "            \"(\", \"0.00\", \"-\", \"0.00\", \")\", \"^2\"\n",
        "        )\n",
        "        numbers = expression.get_parts_by_tex(\"0.00\")\n",
        "        non_numbers = VGroup(*[m for m in expression if m not in numbers])\n",
        "        expression.next_to(cost_equation, DOWN, aligned_edge = RIGHT)\n",
        "        decimals = VGroup(\n",
        "            self.decimals[0],\n",
        "            self.desired_output_decimal\n",
        "        ).copy()\n",
        "        decimals.generate_target()\n",
        "        for d, n in zip(decimals.target, numbers):\n",
        "            d.replace(n, dim_to_match = 1)\n",
        "            d.set_color(n.get_color())\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_a, a),\n",
        "            ReplacementTransform(pre_y, y),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(*[m for m in cost_equation if m not in [a, y]])\n",
        "        ))\n",
        "        self.play(\n",
        "            MoveToTarget(decimals),\n",
        "            FadeIn(non_numbers)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(cost_word, run_time = 1),\n",
        "            GrowArrow(cost_arrow)\n",
        "        )\n",
        "        self.play(C0.shift, MED_SMALL_BUFF*UP, rate_func = wiggle)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [decimals, non_numbers])))\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            cost_equation, cost_word, cost_arrow\n",
        "        )\n",
        "\n",
        "    def show_activation_formula(self):\n",
        "        neuron = self.network_mob.layers[-1].neurons[0]\n",
        "        edge = self.network_mob.edge_groups[-1][0]\n",
        "        pre_aL, pre_aLm1 = self.a_labels.copy()\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"a^{(L)}\", \"=\", \"\\\\sigma\", \"(\",\n",
        "            \"w^{(L)}\", \"a^{(L-1)}\", \"+\", \"b^{(L)}\", \")\"\n",
        "        )\n",
        "        formula.next_to(neuron, UP, MED_LARGE_BUFF, RIGHT)\n",
        "        aL, equals, sigma, lp, wL, aLm1, plus, bL, rp = formula\n",
        "        wL.set_color(edge.get_color())\n",
        "        weight_label = wL.copy()\n",
        "        bL.set_color(MAROON_B)\n",
        "        bias_label = bL.copy()\n",
        "        sigma_group = VGroup(sigma, lp, rp)\n",
        "        sigma_group.save_state()\n",
        "        sigma_group.set_fill(opacity = 0)\n",
        "        sigma_group.shift(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_aL, aL),\n",
        "            Write(equals)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            edge.copy(), wL\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(pre_aLm1, aLm1))\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(plus, bL), run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(sigma_group.restore)\n",
        "        self.wait()\n",
        "\n",
        "        weighted_sum_terms = VGroup(wL, aLm1, plus, bL)\n",
        "        self.set_variables_as_attrs(\n",
        "            formula, weighted_sum_terms\n",
        "        )\n",
        "\n",
        "    def introduce_z(self):\n",
        "        terms = self.weighted_sum_terms\n",
        "        terms.generate_target()\n",
        "        terms.target.next_to(\n",
        "            self.formula, UP, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "        terms.target.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(terms.target[0][0], LEFT)\n",
        "\n",
        "        z_label = OldTex(\"z^{(L)}\")\n",
        "        z_label.next_to(equals, LEFT)\n",
        "        z_label.align_to(terms.target, DOWN)\n",
        "        z_label.set_color(self.z_color)\n",
        "        z_label2 = z_label.copy()\n",
        "\n",
        "        aL_start = VGroup(*self.formula[:4])\n",
        "        aL_start.generate_target()\n",
        "        aL_start.target.align_to(z_label, LEFT)\n",
        "        z_label2.next_to(aL_start.target, RIGHT, SMALL_BUFF)\n",
        "        z_label2.align_to(aL_start.target[0], DOWN)\n",
        "        rp = self.formula[-1]\n",
        "        rp.generate_target()\n",
        "        rp.target.next_to(z_label2, RIGHT, SMALL_BUFF)\n",
        "        rp.target.align_to(aL_start.target, DOWN)\n",
        "\n",
        "        self.play(MoveToTarget(terms))\n",
        "        self.play(Write(z_label), Write(equals))\n",
        "        self.play(\n",
        "            ReplacementTransform(z_label.copy(), z_label2),\n",
        "            MoveToTarget(aL_start),\n",
        "            MoveToTarget(rp),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        zL_formula = VGroup(z_label, equals, *terms)\n",
        "        aL_formula = VGroup(*list(aL_start) + [z_label2, rp])\n",
        "        self.set_variables_as_attrs(z_label, zL_formula, aL_formula)\n",
        "\n",
        "    def break_into_computational_graph(self):\n",
        "        network_early_layers = VGroup(*it.chain(\n",
        "            self.network_mob.layers[:2],\n",
        "            self.network_mob.edge_groups[:2]\n",
        "        ))\n",
        "\n",
        "        wL, aL, plus, bL = self.weighted_sum_terms\n",
        "        top_terms = VGroup(wL, aL, bL).copy()\n",
        "        zL = self.z_label.copy()\n",
        "        aL = self.formula[0].copy()\n",
        "        y = self.y_label.copy()\n",
        "        C0 = self.cost_equation[0].copy()\n",
        "        targets = VGroup()\n",
        "        for mob in top_terms, zL, aL, C0:\n",
        "            mob.generate_target()\n",
        "            targets.add(mob.target)\n",
        "        y.generate_target()\n",
        "        top_terms.target.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        targets.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        targets.center().to_corner(DOWN+LEFT)\n",
        "        y.target.next_to(aL.target, LEFT, LARGE_BUFF, DOWN)\n",
        "\n",
        "        top_lines = VGroup(*[\n",
        "            Line(\n",
        "                term.get_bottom(), \n",
        "                zL.target.get_top(), \n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            for term in top_terms.target\n",
        "        ])\n",
        "        z_to_a_line, a_to_c_line, y_to_c_line = all_lines = [\n",
        "            Line(\n",
        "                m1.target.get_bottom(), \n",
        "                m2.target.get_top(), \n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            for m1, m2 in [\n",
        "                (zL, aL), \n",
        "                (aL, C0), \n",
        "                (y, C0)\n",
        "            ]\n",
        "        ]\n",
        "        for mob in [top_lines] + all_lines:\n",
        "            yellow_copy = mob.copy().set_color(YELLOW)\n",
        "            mob.flash = ShowCreationThenDestruction(yellow_copy)\n",
        "\n",
        "        self.play(MoveToTarget(top_terms))\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(zL))\n",
        "        self.play(\n",
        "            ShowCreation(top_lines, lag_ratio = 0),\n",
        "            top_lines.flash\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(aL))\n",
        "        self.play(\n",
        "            network_early_layers.fade, 1,\n",
        "            ShowCreation(z_to_a_line),\n",
        "            z_to_a_line.flash\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(y))\n",
        "        self.play(MoveToTarget(C0))\n",
        "        self.play(*it.chain(*[\n",
        "            [ShowCreation(line), line.flash]\n",
        "            for line in (a_to_c_line, y_to_c_line)\n",
        "        ]))\n",
        "        self.wait(2)\n",
        "\n",
        "        comp_graph = VGroup()\n",
        "        comp_graph.wL, comp_graph.aLm1, comp_graph.bL = top_terms\n",
        "        comp_graph.top_lines = top_lines\n",
        "        comp_graph.zL = zL\n",
        "        comp_graph.z_to_a_line = z_to_a_line\n",
        "        comp_graph.aL = aL\n",
        "        comp_graph.y = y\n",
        "        comp_graph.a_to_c_line = a_to_c_line\n",
        "        comp_graph.y_to_c_line = y_to_c_line\n",
        "        comp_graph.C0 = C0\n",
        "        comp_graph.digest_mobject_attrs()\n",
        "        self.comp_graph = comp_graph\n",
        "\n",
        "    def show_preceding_layer_in_computational_graph(self):\n",
        "        shift_vect = DOWN\n",
        "        comp_graph = self.comp_graph\n",
        "        comp_graph.save_state()\n",
        "        comp_graph.generate_target()\n",
        "        comp_graph.target.shift(shift_vect)\n",
        "        rect = SurroundingRectangle(comp_graph.aLm1)\n",
        "\n",
        "        attrs = [\"wL\", \"aLm1\", \"bL\", \"zL\"]\n",
        "        new_terms = VGroup()\n",
        "        for attr in attrs:\n",
        "            term = getattr(comp_graph, attr)\n",
        "            tex = term.get_tex()\n",
        "            if \"L-1\" in tex:\n",
        "                tex = tex.replace(\"L-1\", \"L-2\")\n",
        "            else:\n",
        "                tex = tex.replace(\"L\", \"L-1\")\n",
        "            new_term = OldTex(tex)\n",
        "            new_term.set_color(term.get_color())\n",
        "            new_term.move_to(term)\n",
        "            new_terms.add(new_term)\n",
        "        new_edges = VGroup(\n",
        "            comp_graph.top_lines.copy(),\n",
        "            comp_graph.z_to_a_line.copy(),\n",
        "        )\n",
        "        new_subgraph = VGroup(new_terms, new_edges)\n",
        "        new_subgraph.next_to(comp_graph.target, UP, SMALL_BUFF)\n",
        "        self.wLm1 = new_terms[0]\n",
        "        self.zLm1 = new_terms[-1]\n",
        "\n",
        "        prev_neuron = self.network_mob.layers[1]\n",
        "        prev_neuron.restore()\n",
        "        prev_edge = self.network_mob.edge_groups[1]\n",
        "        prev_edge.restore()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(prev_neuron),\n",
        "            ShowCreation(prev_edge)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(prev_neuron, prev_edge).copy(),\n",
        "                new_subgraph\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                new_terms,\n",
        "                lambda m, a : m.set_fill(opacity = a)\n",
        "            ),\n",
        "            MoveToTarget(comp_graph),\n",
        "            rect.shift, shift_vect\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(new_subgraph),\n",
        "            FadeOut(prev_neuron),\n",
        "            FadeOut(prev_edge),\n",
        "            comp_graph.restore,\n",
        "            rect.shift, -shift_vect,\n",
        "            rect.set_stroke, BLACK, 0\n",
        "        )\n",
        "        VGroup(prev_neuron, prev_edge).fade(1)\n",
        "        self.remove(rect)\n",
        "        self.wait()\n",
        "\n",
        "        self.prev_comp_subgraph = new_subgraph\n",
        "\n",
        "    def show_number_lines(self):\n",
        "        comp_graph = self.comp_graph\n",
        "        wL, aLm1, bL, zL, aL, C0 = [\n",
        "            getattr(comp_graph, attr)\n",
        "            for attr in [\"wL\", \"aLm1\", \"bL\", \"zL\", \"aL\", \"C0\"]\n",
        "        ]\n",
        "        wL.val = self.network.weights[-1][0][0]\n",
        "        aL.val = self.decimals[0].number\n",
        "        zL.val = sigmoid_inverse(aL.val)\n",
        "        C0.val = (aL.val - 1)**2\n",
        "\n",
        "        number_line = UnitInterval(\n",
        "            unit_size = 2,\n",
        "            stroke_width = 2,\n",
        "            tick_size = 0.075,\n",
        "            color = GREY_B,\n",
        "        )\n",
        "\n",
        "        for mob in wL, zL, aL, C0:\n",
        "            mob.number_line = number_line.deepcopy()\n",
        "            if mob is wL:\n",
        "                mob.number_line.next_to(mob, UP, MED_LARGE_BUFF, LEFT)\n",
        "            else:\n",
        "                mob.number_line.next_to(mob, RIGHT)\n",
        "            if mob is C0:\n",
        "                mob.number_line.x_max = 0.5\n",
        "                for tick_mark in mob.number_line.tick_marks[1::2]:\n",
        "                    mob.number_line.tick_marks.remove(tick_mark)\n",
        "            mob.dot = Dot(color = mob.get_color())\n",
        "            mob.dot.move_to(\n",
        "                mob.number_line.number_to_point(mob.val)\n",
        "            )\n",
        "            if mob is wL:\n",
        "                path_arc = 0\n",
        "                dot_spot = mob.dot.get_bottom()\n",
        "            else:\n",
        "                path_arc = -0.7*np.pi\n",
        "                dot_spot = mob.dot.get_top()\n",
        "            if mob is C0:\n",
        "                mob_spot = mob[0].get_corner(UP+RIGHT)\n",
        "                tip_length = 0.15\n",
        "            else:\n",
        "                mob_spot = mob.get_corner(UP+RIGHT)\n",
        "                tip_length = 0.2\n",
        "            mob.arrow = Arrow(\n",
        "                mob_spot, dot_spot,\n",
        "                path_arc = path_arc,\n",
        "                tip_length = tip_length,\n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "            mob.arrow.set_color(mob.get_color())\n",
        "            mob.arrow.set_stroke(width = 5)\n",
        "\n",
        "            self.play(ShowCreation(\n",
        "                mob.number_line, \n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "            self.play(\n",
        "                ShowCreation(mob.arrow),\n",
        "                ReplacementTransform(\n",
        "                    mob.copy(), mob.dot,\n",
        "                    path_arc = path_arc\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_w_sensitivity(self):\n",
        "        wL, aLm1, bL, zL, aL, C0 = [\n",
        "            getattr(self.comp_graph, attr)\n",
        "            for attr in [\"wL\", \"aLm1\", \"bL\", \"zL\", \"aL\", \"C0\"]\n",
        "        ]\n",
        "        aLm1_val = self.last_neurons[1].get_fill_opacity()\n",
        "        bL_val = self.network.biases[-1][0]\n",
        "\n",
        "        get_wL_val = lambda : wL.number_line.point_to_number(\n",
        "            wL.dot.get_center()\n",
        "        )\n",
        "        get_zL_val = lambda : get_wL_val()*aLm1_val+bL_val\n",
        "        get_aL_val = lambda : sigmoid(get_zL_val())\n",
        "        get_C0_val = lambda : (get_aL_val() - 1)**2\n",
        "\n",
        "        def generate_dot_update(term, val_func):\n",
        "            def update_dot(dot):\n",
        "                dot.move_to(term.number_line.number_to_point(val_func()))\n",
        "                return dot\n",
        "            return update_dot\n",
        "\n",
        "        dot_update_anims = [\n",
        "            UpdateFromFunc(term.dot, generate_dot_update(term, val_func))\n",
        "            for term, val_func in [\n",
        "                (zL, get_zL_val),\n",
        "                (aL, get_aL_val),\n",
        "                (C0, get_C0_val),\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        def shake_dot(run_time = 2, rate_func = there_and_back):\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    wL.dot.shift, LEFT, \n",
        "                    rate_func = rate_func, \n",
        "                    run_time = run_time\n",
        "                ),\n",
        "                *dot_update_anims\n",
        "            )        \n",
        "\n",
        "        wL_line = Line(wL.dot.get_center(), wL.dot.get_center()+LEFT)\n",
        "        del_wL = OldTex(\"\\\\partial w^{(L)}\")\n",
        "        del_wL.scale(self.derivative_scale_val)\n",
        "        del_wL.brace = Brace(wL_line, UP, buff = SMALL_BUFF)\n",
        "        del_wL.set_color(wL.get_color())\n",
        "        del_wL.next_to(del_wL.brace, UP, SMALL_BUFF)\n",
        "\n",
        "        C0_line = Line(C0.dot.get_center(), C0.dot.get_center()+MED_SMALL_BUFF*RIGHT)\n",
        "        del_C0 = OldTex(\"\\\\partial C_0\")\n",
        "        del_C0.scale(self.derivative_scale_val)\n",
        "        del_C0.brace = Brace(C0_line, UP, buff = SMALL_BUFF)\n",
        "        del_C0.set_color(C0.get_color())\n",
        "        del_C0.next_to(del_C0.brace, UP, SMALL_BUFF)\n",
        "\n",
        "        for sym in del_wL, del_C0:\n",
        "            self.play(\n",
        "                GrowFromCenter(sym.brace),\n",
        "                Write(sym, run_time = 1)\n",
        "            )\n",
        "            shake_dot()\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            shake_dot, del_wL, del_C0,\n",
        "        )\n",
        "\n",
        "    def show_derivative_wrt_w(self):\n",
        "        del_wL = self.del_wL\n",
        "        del_C0 = self.del_C0\n",
        "        cost_word = self.cost_word\n",
        "        cost_arrow = self.cost_arrow\n",
        "        shake_dot = self.shake_dot\n",
        "        wL = self.comp_graph.wL\n",
        "\n",
        "        dC_dw = OldTex(\n",
        "            \"{\\\\partial C_0\", \"\\\\over\", \"\\\\partial w^{(L)} }\"\n",
        "        )\n",
        "        dC_dw[0].set_color(del_C0.get_color())\n",
        "        dC_dw[2].set_color(del_wL.get_color())\n",
        "        dC_dw.scale(self.derivative_scale_val)\n",
        "        dC_dw.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        dC_dw.shift(3.5*LEFT)\n",
        "\n",
        "        full_rect = SurroundingRectangle(dC_dw)\n",
        "        full_rect_copy = full_rect.copy()\n",
        "        words = OldTexText(\"What we want\")\n",
        "        words.next_to(full_rect, RIGHT)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        denom_rect = SurroundingRectangle(dC_dw[2])\n",
        "        numer_rect = SurroundingRectangle(dC_dw[0])\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(del_C0.copy(), dC_dw[0]),\n",
        "            ReplacementTransform(del_wL.copy(), dC_dw[2]),\n",
        "            Write(dC_dw[1], run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(cost_word),\n",
        "            FadeOut(cost_arrow),\n",
        "            ShowCreation(full_rect),\n",
        "            Write(words, run_time = 1),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            ReplacementTransform(full_rect, denom_rect)\n",
        "        )\n",
        "        self.play(Transform(dC_dw[2].copy(), del_wL, remover = True))\n",
        "        shake_dot()\n",
        "        self.play(ReplacementTransform(denom_rect, numer_rect))\n",
        "        self.play(Transform(dC_dw[0].copy(), del_C0, remover = True))\n",
        "        shake_dot()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(numer_rect, full_rect_copy))\n",
        "        self.play(FadeOut(full_rect_copy))\n",
        "        self.wait()\n",
        "\n",
        "        self.dC_dw = dC_dw\n",
        "\n",
        "    def show_chain_of_events(self):\n",
        "        comp_graph = self.comp_graph\n",
        "        wL, zL, aL, C0 = [\n",
        "            getattr(comp_graph, attr)\n",
        "            for attr in [\"wL\", \"zL\", \"aL\", \"C0\"]\n",
        "        ]\n",
        "        del_wL = self.del_wL\n",
        "        del_C0 = self.del_C0\n",
        "\n",
        "        zL_line = Line(ORIGIN, MED_LARGE_BUFF*LEFT)\n",
        "        zL_line.shift(zL.dot.get_center())\n",
        "        del_zL = OldTex(\"\\\\partial z^{(L)}\")\n",
        "        del_zL.set_color(zL.get_color())\n",
        "        del_zL.brace = Brace(zL_line, DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        aL_line = Line(ORIGIN, MED_SMALL_BUFF*LEFT)\n",
        "        aL_line.shift(aL.dot.get_center())\n",
        "        del_aL = OldTex(\"\\\\partial a^{(L)}\")\n",
        "        del_aL.set_color(aL.get_color())\n",
        "        del_aL.brace = Brace(aL_line, DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        for sym in del_zL, del_aL:\n",
        "            sym.scale(self.derivative_scale_val)\n",
        "            sym.brace.stretch_about_point(\n",
        "                0.5, 1, sym.brace.get_top(),\n",
        "            )\n",
        "            sym.shift(\n",
        "                sym.brace.get_bottom()+SMALL_BUFF*DOWN \\\n",
        "                -sym[0].get_corner(UP+RIGHT)\n",
        "            )\n",
        "\n",
        "        syms = [del_wL, del_zL, del_aL, del_C0]\n",
        "        for s1, s2 in zip(syms, syms[1:]):\n",
        "            self.play(\n",
        "                ReplacementTransform(s1.copy(), s2),\n",
        "                ReplacementTransform(s1.brace.copy(), s2.brace),\n",
        "            )\n",
        "            self.shake_dot(run_time = 1.5)\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(del_zL, del_aL)\n",
        "\n",
        "    def show_chain_rule(self):\n",
        "        dC_dw = self.dC_dw\n",
        "        del_syms = [\n",
        "            getattr(self, attr)\n",
        "            for attr in (\"del_wL\", \"del_zL\", \"del_aL\", \"del_C0\")\n",
        "        ]\n",
        "\n",
        "        dz_dw = OldTex(\n",
        "            \"{\\\\partial z^{(L)}\", \"\\\\over\", \"\\\\partial w^{(L)}}\"\n",
        "        )\n",
        "        da_dz = OldTex(\n",
        "            \"{\\\\partial a^{(L)}\", \"\\\\over\", \"\\\\partial z^{(L)}}\"\n",
        "        )\n",
        "        dC_da = OldTex(\n",
        "            \"{\\\\partial C0}\", \"\\\\over\", \"\\\\partial a^{(L)}}\"\n",
        "        )\n",
        "        dz_dw[2].set_color(self.del_wL.get_color())\n",
        "        VGroup(dz_dw[0], da_dz[2]).set_color(self.z_color)\n",
        "        dC_da[0].set_color(self.cost_color)\n",
        "        equals = OldTex(\"=\")\n",
        "        group = VGroup(equals, dz_dw, da_dz, dC_da)\n",
        "        group.arrange(RIGHT, SMALL_BUFF)\n",
        "        group.scale(self.derivative_scale_val)\n",
        "        group.next_to(dC_dw, RIGHT)\n",
        "        for mob in group[1:]:\n",
        "            target_y = equals.get_center()[1]\n",
        "            y = mob[1].get_center()[1]\n",
        "            mob.shift((target_y - y)*UP)\n",
        "\n",
        "        self.play(Write(equals, run_time = 1))\n",
        "        for frac, top_sym, bot_sym in zip(group[1:], del_syms[1:], del_syms):\n",
        "            self.play(Indicate(top_sym, rate_func = wiggle))\n",
        "            self.play(\n",
        "                ReplacementTransform(top_sym.copy(), frac[0]),\n",
        "                FadeIn(frac[1]),\n",
        "            )\n",
        "            self.play(Indicate(bot_sym, rate_func = wiggle))\n",
        "            self.play(ReplacementTransform(\n",
        "                bot_sym.copy(), frac[2]\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.shake_dot()\n",
        "        self.wait()\n",
        "\n",
        "        self.chain_rule_equation = VGroup(dC_dw, *group)\n",
        "\n",
        "    def name_chain_rule(self):\n",
        "        graph_parts = self.get_all_comp_graph_parts()\n",
        "        equation = self.chain_rule_equation\n",
        "        rect = SurroundingRectangle(equation)\n",
        "        group = VGroup(equation, rect)\n",
        "        group.generate_target()\n",
        "        group.target.to_corner(UP+LEFT)\n",
        "        words = OldTexText(\"Chain rule\")\n",
        "        words.set_color(YELLOW)\n",
        "        words.next_to(group.target, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            MoveToTarget(group),\n",
        "            Write(words, run_time = 1),\n",
        "            graph_parts.scale, 0.7, graph_parts.get_bottom()\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [rect, words])))\n",
        "\n",
        "    def indicate_everything_on_screen(self):\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        everything = VGroup(*[m for m in everything.family_members_with_points() if not m.is_subpath])\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, everything,\n",
        "            rate_func = wiggle,\n",
        "            lag_ratio = 0.2,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def prepare_for_derivatives(self):\n",
        "        zL_formula = self.zL_formula\n",
        "        aL_formula = self.aL_formula\n",
        "        az_formulas = VGroup(zL_formula, aL_formula)\n",
        "        cost_equation = self.cost_equation\n",
        "        desired_output_words = self.desired_output_words\n",
        "\n",
        "        az_formulas.generate_target()\n",
        "        az_formulas.target.to_edge(RIGHT)\n",
        "\n",
        "        index = 4\n",
        "        cost_eq = cost_equation[index]\n",
        "        z_eq = az_formulas.target[0][1]\n",
        "        x_shift = (z_eq.get_center() - cost_eq.get_center())[0]*RIGHT\n",
        "        cost_equation.generate_target()\n",
        "        Transform(\n",
        "            VGroup(*cost_equation.target[1:index]),\n",
        "            VectorizedPoint(cost_eq.get_left())\n",
        "        ).update(1)\n",
        "        cost_equation.target[0].next_to(cost_eq, LEFT, SMALL_BUFF)\n",
        "        cost_equation.target.shift(x_shift)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.all_comp_graph_parts),\n",
        "            FadeOut(self.desired_output_words),\n",
        "            MoveToTarget(az_formulas),\n",
        "            MoveToTarget(cost_equation)\n",
        "        )\n",
        "\n",
        "    def compute_derivatives(self):\n",
        "        cost_equation = self.cost_equation\n",
        "        zL_formula = self.zL_formula\n",
        "        aL_formula = self.aL_formula\n",
        "        chain_rule_equation = self.chain_rule_equation.copy()\n",
        "        dC_dw, equals, dz_dw, da_dz, dC_da = chain_rule_equation\n",
        "\n",
        "        derivs = VGroup(dC_da, da_dz, dz_dw)\n",
        "        deriv_targets = VGroup()\n",
        "        for deriv in derivs:\n",
        "            deriv.generate_target()\n",
        "            deriv_targets.add(deriv.target)\n",
        "        deriv_targets.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        deriv_targets.next_to(dC_dw, DOWN, LARGE_BUFF)\n",
        "        for deriv in derivs:\n",
        "            deriv.equals = OldTex(\"=\")\n",
        "            deriv.equals.next_to(deriv.target, RIGHT)\n",
        "\n",
        "\n",
        "        #dC_da\n",
        "        self.play(\n",
        "            MoveToTarget(dC_da),\n",
        "            Write(dC_da.equals)\n",
        "        )\n",
        "        index = 4\n",
        "        cost_rhs = VGroup(*cost_equation[index+1:])       \n",
        "        dC_da.rhs = cost_rhs.copy()\n",
        "        two = dC_da.rhs[-1]\n",
        "        two.scale(1.5)\n",
        "        two.next_to(dC_da.rhs[0], LEFT, SMALL_BUFF)\n",
        "        dC_da.rhs.next_to(dC_da.equals, RIGHT)\n",
        "        dC_da.rhs.shift(0.7*SMALL_BUFF*UP)\n",
        "        cost_equation.save_state()\n",
        "\n",
        "        self.play(\n",
        "            cost_equation.next_to, dC_da.rhs,\n",
        "            DOWN, MED_LARGE_BUFF, LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            cost_rhs.copy(), dC_da.rhs,\n",
        "            path_arc = np.pi/2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(cost_equation.restore)\n",
        "        self.wait()\n",
        "\n",
        "        #show_difference\n",
        "        neuron = self.last_neurons[0]\n",
        "        decimal = self.decimals[0]\n",
        "        double_arrow = DoubleArrow(\n",
        "            neuron.get_right(),\n",
        "            self.desired_output_neuron.get_left(),\n",
        "            buff = SMALL_BUFF,\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        moving_decimals = VGroup(\n",
        "            self.decimals[0].copy(),\n",
        "            self.desired_output_decimal.copy()\n",
        "        )\n",
        "        minus = OldTex(\"-\")\n",
        "        minus.move_to(moving_decimals)\n",
        "        minus.scale(0.7)\n",
        "        minus.set_fill(opacity = 0)\n",
        "        moving_decimals.submobjects.insert(1, minus)\n",
        "        moving_decimals.generate_target(use_deepcopy = True)\n",
        "        moving_decimals.target.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        moving_decimals.target.scale(1.5)\n",
        "        moving_decimals.target.next_to(\n",
        "            dC_da.rhs, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT,\n",
        "        )\n",
        "        moving_decimals.target.set_fill(WHITE, 1)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            dC_da.rhs.copy(), double_arrow\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(moving_decimals))\n",
        "        opacity = neuron.get_fill_opacity()\n",
        "        for target_o in 0, opacity:\n",
        "            self.wait(2)\n",
        "            self.play(\n",
        "                neuron.set_fill, None, target_o,\n",
        "                *[\n",
        "                    ChangingDecimal(d, lambda a : neuron.get_fill_opacity())\n",
        "                    for d in (decimal, moving_decimals[0])\n",
        "                ]\n",
        "            )\n",
        "        self.play(*list(map(FadeOut, [double_arrow, moving_decimals])))\n",
        "\n",
        "        #da_dz\n",
        "        self.play(\n",
        "            MoveToTarget(da_dz),\n",
        "            Write(da_dz.equals)\n",
        "        )\n",
        "        a_rhs = VGroup(*aL_formula[2:])\n",
        "        da_dz.rhs = a_rhs.copy()\n",
        "        prime = OldTex(\"'\")\n",
        "        prime.move_to(da_dz.rhs[0].get_corner(UP+RIGHT))\n",
        "        da_dz.rhs[0].shift(0.5*SMALL_BUFF*LEFT)\n",
        "        da_dz.rhs.add_to_back(prime)\n",
        "        da_dz.rhs.next_to(da_dz.equals, RIGHT)\n",
        "        da_dz.rhs.shift(0.5*SMALL_BUFF*UP)\n",
        "        aL_formula.save_state()\n",
        "        self.play(\n",
        "            aL_formula.next_to, da_dz.rhs,\n",
        "            DOWN, MED_LARGE_BUFF, LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            a_rhs.copy(), da_dz.rhs,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(aL_formula.restore)\n",
        "        self.wait()\n",
        "\n",
        "        #dz_dw\n",
        "        self.play(\n",
        "            MoveToTarget(dz_dw),\n",
        "            Write(dz_dw.equals)\n",
        "        )\n",
        "        z_rhs = VGroup(*zL_formula[2:])\n",
        "        dz_dw.rhs = z_rhs[1].copy()\n",
        "        dz_dw.rhs.next_to(dz_dw.equals, RIGHT)\n",
        "        dz_dw.rhs.shift(SMALL_BUFF*UP)\n",
        "        zL_formula.save_state()\n",
        "        self.play(\n",
        "            zL_formula.next_to, dz_dw.rhs,\n",
        "                DOWN, MED_LARGE_BUFF, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "        rect = SurroundingRectangle(VGroup(*zL_formula[2:4]))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(ReplacementTransform(\n",
        "            z_rhs[1].copy(), dz_dw.rhs,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(zL_formula.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.derivative_equations = VGroup(dC_da, da_dz, dz_dw)\n",
        "\n",
        "    def get_lost_in_formulas(self):\n",
        "        randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.scale(0.7)\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"pleading\", self.chain_rule_equation)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"maybe\")\n",
        "        self.play(Blink(randy))\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "    def fire_together_wire_together(self):\n",
        "        dz_dw = self.derivative_equations[2]\n",
        "        rhs = dz_dw.rhs\n",
        "        rhs_copy = rhs.copy()\n",
        "        del_wL = dz_dw[2].copy()\n",
        "        rect = SurroundingRectangle(VGroup(dz_dw, dz_dw.rhs))\n",
        "        edge = self.network_mob.edge_groups[-1][0]\n",
        "        edge.save_state()\n",
        "        neuron = self.last_neurons[1]\n",
        "        decimal = self.decimals[1]\n",
        "\n",
        "        def get_decimal_anims():\n",
        "            return [\n",
        "                ChangingDecimal(decimal, lambda a : neuron.get_fill_opacity()),\n",
        "                UpdateFromFunc(\n",
        "                    decimal, lambda m : m.set_color(\n",
        "                        WHITE if neuron.get_fill_opacity() < 0.8 \\\n",
        "                        else BLACK\n",
        "                    )\n",
        "                )\n",
        "            ]\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(\n",
        "            del_wL.next_to, edge, UP, SMALL_BUFF\n",
        "        )\n",
        "        self.play(\n",
        "            edge.set_stroke, None, 10,\n",
        "            rate_func = wiggle,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(rhs.shift, MED_LARGE_BUFF*UP, rate_func = wiggle)\n",
        "        self.play(\n",
        "            rhs_copy.move_to, neuron,\n",
        "            rhs_copy.set_fill, None, 0\n",
        "        )\n",
        "        self.remove(rhs_copy)\n",
        "        self.play(\n",
        "            neuron.set_fill, None, 0,\n",
        "            *get_decimal_anims(),\n",
        "            run_time = 3,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Fire together wire together\n",
        "        opacity = neuron.get_fill_opacity()\n",
        "        self.play(\n",
        "            neuron.set_fill, None, 0.99, \n",
        "            *get_decimal_anims()\n",
        "        )\n",
        "        self.play(edge.set_stroke, None, 8)\n",
        "        self.play(\n",
        "            neuron.set_fill, None, opacity, \n",
        "            *get_decimal_anims()\n",
        "        )\n",
        "        self.play(edge.restore, FadeOut(del_wL))\n",
        "        self.wait(3)\n",
        "\n",
        "    def organize_chain_rule_rhs(self):\n",
        "        fracs = self.derivative_equations\n",
        "        equals_group = VGroup(*[frac.equals for frac in fracs])\n",
        "        rhs_group = VGroup(*[frac.rhs for frac in reversed(fracs)])\n",
        "\n",
        "        chain_rule_equation = self.chain_rule_equation\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(chain_rule_equation, RIGHT)\n",
        "\n",
        "        rhs_group.generate_target()\n",
        "        rhs_group.target.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        rhs_group.target.next_to(equals, RIGHT)\n",
        "        rhs_group.target.shift(SMALL_BUFF*UP)\n",
        "\n",
        "        right_group = VGroup(\n",
        "            self.cost_equation, self.zL_formula, self.aL_formula,\n",
        "            self.network_mob, self.decimals,\n",
        "            self.a_labels, self.a_label_arrows,\n",
        "            self.y_label, self.y_label_arrow,\n",
        "            self.desired_output_neuron,\n",
        "            self.desired_output_rect,\n",
        "            self.desired_output_decimal,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rhs_group, path_arc = np.pi/2),\n",
        "            Write(equals),\n",
        "            FadeOut(fracs),\n",
        "            FadeOut(equals_group),\n",
        "            right_group.to_corner, DOWN+RIGHT\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rhs_group.add(equals)\n",
        "        self.chain_rule_rhs = rhs_group\n",
        "\n",
        "    def show_average_derivative(self):\n",
        "        dC0_dw = self.chain_rule_equation[0]\n",
        "        full_derivative = OldTex(\n",
        "            \"{\\\\partial C\", \"\\\\over\", \"\\\\partial w^{(L)}}\",\n",
        "            \"=\", \"\\\\frac{1}{n}\", \"\\\\sum_{k=0}^{n-1}\",\n",
        "            \"{\\\\partial C_k\", \"\\\\over\", \"\\\\partial w^{(L)}}\"\n",
        "        )\n",
        "        full_derivative.set_color_by_tex_to_color_map({\n",
        "            \"partial C\" : self.cost_color,\n",
        "            \"partial w\" : self.del_wL.get_color()\n",
        "        })\n",
        "        full_derivative.to_edge(LEFT)\n",
        "\n",
        "        dCk_dw = VGroup(*full_derivative[-3:])\n",
        "        lhs = VGroup(*full_derivative[:3])\n",
        "        rhs = VGroup(*full_derivative[4:])\n",
        "        lhs_brace = Brace(lhs, DOWN)\n",
        "        lhs_text = lhs_brace.get_text(\"Derivative of \\\\\\\\ full cost function\")\n",
        "        rhs_brace = Brace(rhs, UP)\n",
        "        rhs_text = rhs_brace.get_text(\"Average of all \\\\\\\\ training examples\")\n",
        "        VGroup(\n",
        "            full_derivative, lhs_brace, lhs_text, rhs_brace, rhs_text\n",
        "        ).to_corner(DOWN+LEFT)\n",
        "\n",
        "        mover = dC0_dw.copy()\n",
        "        self.play(Transform(mover, dCk_dw))\n",
        "        self.play(Write(full_derivative, run_time = 2))\n",
        "        self.remove(mover)\n",
        "        for brace, text in (rhs_brace, rhs_text), (lhs_brace, lhs_text):\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text, run_time = 2),\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.cycle_through_altnernate_training_examples()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            VGroup(*full_derivative[3:]), \n",
        "            lhs_brace, lhs_text,\n",
        "            rhs_brace, rhs_text,\n",
        "        ])))\n",
        "\n",
        "        self.dC_dw = lhs\n",
        "\n",
        "    def cycle_through_altnernate_training_examples(self):\n",
        "        neurons = VGroup(\n",
        "            self.desired_output_neuron, *self.last_neurons\n",
        "        )\n",
        "        decimals = VGroup(\n",
        "            self.desired_output_decimal, *self.decimals\n",
        "        )\n",
        "        group = VGroup(neurons, decimals)\n",
        "        group.save_state()\n",
        "\n",
        "        for x in range(20):\n",
        "            for n, d in zip(neurons, decimals):\n",
        "                o = np.random.random()\n",
        "                if n is self.desired_output_neuron:\n",
        "                    o = np.round(o)\n",
        "                n.set_fill(opacity = o)\n",
        "                Transform(\n",
        "                    d, self.get_neuron_activation_decimal(n)\n",
        "                ).update(1)\n",
        "            self.wait(0.2)\n",
        "        self.play(group.restore, run_time = 0.2)\n",
        "\n",
        "    def show_gradient(self):\n",
        "        dC_dw = self.dC_dw\n",
        "        dC_dw.generate_target()\n",
        "        terms = VGroup(\n",
        "            OldTex(\"{\\\\partial C\", \"\\\\over\", \"\\\\partial w^{(1)}\"),\n",
        "            OldTex(\"{\\\\partial C\", \"\\\\over\", \"\\\\partial b^{(1)}\"),\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            dC_dw.target,\n",
        "            OldTex(\"{\\\\partial C\", \"\\\\over\", \"\\\\partial b^{(L)}\"),\n",
        "        )\n",
        "        for term in terms:\n",
        "            if isinstance(term, Tex):\n",
        "                term.set_color_by_tex_to_color_map({\n",
        "                    \"partial C\" : RED,\n",
        "                    \"partial w\" : BLUE,\n",
        "                    \"partial b\" : MAROON_B,\n",
        "                })\n",
        "        terms.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        lb, rb = brackets = OldTex(\"[]\")\n",
        "        brackets.scale(3)\n",
        "        brackets.stretch_to_fit_height(1.1*terms.get_height())\n",
        "        lb.next_to(terms, LEFT, buff = SMALL_BUFF)\n",
        "        rb.next_to(terms, RIGHT, buff = SMALL_BUFF)\n",
        "        vect = VGroup(lb, terms, rb)\n",
        "        vect.set_height(5)\n",
        "        lhs = OldTex(\"\\\\nabla C\", \"=\")\n",
        "        lhs[0].set_color(RED)\n",
        "        lhs.next_to(vect, LEFT)\n",
        "        VGroup(lhs, vect).to_corner(DOWN+LEFT, buff = LARGE_BUFF)\n",
        "        terms.remove(dC_dw.target)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(dC_dw),\n",
        "            Write(vect, run_time = 1)\n",
        "        )\n",
        "        terms.add(dC_dw)\n",
        "        self.play(Write(lhs))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(VGroup(lhs, vect)))\n",
        "\n",
        "    def transition_to_derivative_wrt_b(self):\n",
        "        all_comp_graph_parts = self.all_comp_graph_parts\n",
        "        all_comp_graph_parts.scale(\n",
        "            1.3, about_point = all_comp_graph_parts.get_bottom()\n",
        "        )\n",
        "        comp_graph = self.comp_graph\n",
        "        wL, bL, zL, aL, C0 = [\n",
        "            getattr(comp_graph, attr)\n",
        "            for attr in [\"wL\", \"bL\", \"zL\", \"aL\", \"C0\"]\n",
        "        ]\n",
        "        path_to_C = VGroup(wL, zL, aL, C0)\n",
        "\n",
        "        top_expression = VGroup(\n",
        "            self.chain_rule_equation,\n",
        "            self.chain_rule_rhs\n",
        "        )\n",
        "        rect = SurroundingRectangle(top_expression)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeIn(comp_graph), FadeOut(rect))\n",
        "        for x in range(2):\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, path_to_C, \n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5,\n",
        "                lag_ratio = 0.7,\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_derivative_wrt_b(self):\n",
        "        comp_graph = self.comp_graph\n",
        "        dC0_dw = self.chain_rule_equation[0]\n",
        "        dz_dw = self.chain_rule_equation[2]\n",
        "        aLm1 = self.chain_rule_rhs[0]\n",
        "        left_term_group = VGroup(dz_dw, aLm1)\n",
        "        dz_dw_rect = SurroundingRectangle(dz_dw)\n",
        "\n",
        "        del_w = dC0_dw[2]\n",
        "        del_b = OldTex(\"\\\\partial b^{(L)}\")\n",
        "        del_b.set_color(MAROON_B)\n",
        "        del_b.replace(del_w)\n",
        "\n",
        "        dz_db = OldTex(\n",
        "            \"{\\\\partial z^{(L)}\", \"\\\\over\", \"\\\\partial b^{(L)}}\"\n",
        "        )\n",
        "        dz_db.set_color_by_tex_to_color_map({\n",
        "            \"partial z\" : self.z_color,\n",
        "            \"partial b\" : MAROON_B\n",
        "        })\n",
        "        dz_db.replace(dz_dw)\n",
        "\n",
        "        one = OldTex(\"1\")\n",
        "        one.move_to(aLm1, RIGHT)\n",
        "        arrow = Arrow(\n",
        "            dz_db.get_bottom(),\n",
        "            one.get_bottom(),\n",
        "            path_arc = np.pi/2,\n",
        "            color = WHITE,\n",
        "        )\n",
        "        arrow.set_stroke(width = 2)\n",
        "\n",
        "        wL, bL, zL, aL, C0 = [\n",
        "            getattr(comp_graph, attr)\n",
        "            for attr in [\"wL\", \"bL\", \"zL\", \"aL\", \"C0\"]\n",
        "        ]\n",
        "        path_to_C = VGroup(bL, zL, aL, C0)\n",
        "        def get_path_animation():\n",
        "            return LaggedStartMap(\n",
        "                Indicate, path_to_C, \n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5,\n",
        "                lag_ratio = 0.7,\n",
        "            )\n",
        "\n",
        "        zL_formula = self.zL_formula\n",
        "        b_in_z_formula = zL_formula[-1]\n",
        "        z_formula_rect = SurroundingRectangle(zL_formula)\n",
        "        b_in_z_rect = SurroundingRectangle(b_in_z_formula)\n",
        "\n",
        "        self.play(get_path_animation())\n",
        "        self.play(ShowCreation(dz_dw_rect))\n",
        "        self.play(FadeOut(dz_dw_rect))\n",
        "        self.play(\n",
        "            left_term_group.shift, DOWN,\n",
        "            left_term_group.fade, 1,\n",
        "        )\n",
        "        self.remove(left_term_group)\n",
        "        self.chain_rule_equation.remove(dz_dw)\n",
        "        self.chain_rule_rhs.remove(aLm1)\n",
        "        self.play(Transform(del_w, del_b))\n",
        "        self.play(FadeIn(dz_db))\n",
        "        self.play(get_path_animation())\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(z_formula_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(z_formula_rect, b_in_z_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(b_in_z_formula.copy(), one),\n",
        "            FadeOut(b_in_z_rect)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            ReplacementTransform(\n",
        "                dz_db.copy(), one,\n",
        "                path_arc = arrow.path_arc\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [dz_db, arrow, one])))\n",
        "\n",
        "        self.dz_db = dz_db\n",
        "\n",
        "    def show_derivative_wrt_a(self):\n",
        "        denom = self.chain_rule_equation[0][2]\n",
        "        numer = VGroup(*self.chain_rule_equation[0][:2])\n",
        "        del_aLm1 = OldTex(\"\\\\partial a^{(L-1)}\")\n",
        "        del_aLm1.scale(0.8)\n",
        "        del_aLm1.move_to(denom)\n",
        "        dz_daLm1 = OldTex(\n",
        "            \"{\\\\partial z^{(L)}\", \"\\\\over\", \"\\\\partial a^{(L-1)}}\"\n",
        "        )\n",
        "        dz_daLm1.scale(0.8)\n",
        "        dz_daLm1.next_to(self.chain_rule_equation[1], RIGHT, SMALL_BUFF)\n",
        "        dz_daLm1.shift(0.7*SMALL_BUFF*UP)\n",
        "        dz_daLm1[0].set_color(self.z_color)\n",
        "        dz_daLm1_rect = SurroundingRectangle(dz_daLm1)\n",
        "        wL = self.zL_formula[2].copy()\n",
        "        wL.next_to(self.chain_rule_rhs[0], LEFT, SMALL_BUFF)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            dz_daLm1.get_bottom(), wL.get_bottom(),\n",
        "            path_arc = np.pi/2,\n",
        "            color = WHITE,\n",
        "        )\n",
        "\n",
        "        comp_graph = self.comp_graph\n",
        "        path_to_C = VGroup(*[\n",
        "            getattr(comp_graph, attr)\n",
        "            for attr in [\"aLm1\", \"zL\", \"aL\", \"C0\"]\n",
        "        ])\n",
        "        def get_path_animation():\n",
        "            return LaggedStartMap(\n",
        "                Indicate, path_to_C, \n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5,\n",
        "                lag_ratio = 0.7,\n",
        "            )\n",
        "\n",
        "        zL_formula = self.zL_formula\n",
        "        z_formula_rect = SurroundingRectangle(zL_formula)\n",
        "        a_in_z_rect = SurroundingRectangle(VGroup(*zL_formula[2:4]))\n",
        "        wL_in_z = zL_formula[2]\n",
        "\n",
        "        for x in range(3):\n",
        "            self.play(get_path_animation())\n",
        "        self.play(\n",
        "            numer.shift, SMALL_BUFF*UP,\n",
        "            Transform(denom, del_aLm1)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(dz_daLm1),\n",
        "            VGroup(*self.chain_rule_equation[-2:]).shift, SMALL_BUFF*RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(dz_daLm1_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            dz_daLm1_rect, z_formula_rect\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(z_formula_rect, a_in_z_rect))\n",
        "        self.play(\n",
        "            ReplacementTransform(wL_in_z.copy(), wL),\n",
        "            FadeOut(a_in_z_rect)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            ReplacementTransform(\n",
        "                dz_daLm1.copy(), wL,\n",
        "                path_arc = arrow.path_arc\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.chain_rule_rhs.add(wL, arrow)\n",
        "        self.chain_rule_equation.add(dz_daLm1)\n",
        "\n",
        "    def show_previous_weight_and_bias(self):\n",
        "        to_fade = self.chain_rule_rhs\n",
        "        comp_graph = self.comp_graph\n",
        "        prev_comp_subgraph = self.prev_comp_subgraph\n",
        "        prev_comp_subgraph.scale(0.8)\n",
        "        prev_comp_subgraph.next_to(comp_graph, UP, SMALL_BUFF)\n",
        "\n",
        "        prev_layer = VGroup(\n",
        "            self.network_mob.layers[1],\n",
        "            self.network_mob.edge_groups[1],\n",
        "        )\n",
        "        for mob in prev_layer:\n",
        "            mob.restore()\n",
        "        prev_layer.next_to(self.last_neurons, LEFT, buff = 0)\n",
        "        self.remove(prev_layer)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, to_fade, run_time = 1))\n",
        "        self.play(\n",
        "            ShowCreation(prev_comp_subgraph, run_time = 1),\n",
        "            self.chain_rule_equation.to_edge, RIGHT\n",
        "        )\n",
        "        self.play(FadeIn(prev_layer))\n",
        "\n",
        "        ###\n",
        "        neuron = self.network_mob.layers[1].neurons[0]\n",
        "        decimal = self.get_neuron_activation_decimal(neuron)\n",
        "        a_label = OldTex(\"a^{(L-2)}\")\n",
        "        a_label.replace(self.a_labels[1])\n",
        "        arrow = self.a_label_arrows[1].copy()\n",
        "        VGroup(a_label, arrow).shift(\n",
        "            neuron.get_center() - self.last_neurons[1].get_center()\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(a_label, run_time = 1),\n",
        "            Write(decimal, run_time = 1),\n",
        "            GrowArrow(arrow),\n",
        "        )        \n",
        "\n",
        "    def animate_long_path(self):\n",
        "        comp_graph = self.comp_graph\n",
        "        path_to_C = VGroup(\n",
        "            self.wLm1, self.zLm1,\n",
        "            *[\n",
        "                getattr(comp_graph, attr)\n",
        "                for attr in [\"aLm1\", \"zL\", \"aL\", \"C0\"]\n",
        "            ]\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, path_to_C, \n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5,\n",
        "                lag_ratio = 0.4,\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_neuron_activation_decimal(self, neuron):\n",
        "        opacity = neuron.get_fill_opacity()\n",
        "        decimal = DecimalNumber(opacity, num_decimal_places = 2)\n",
        "        decimal.set_width(0.85*neuron.get_width())\n",
        "        if decimal.number > 0.8:\n",
        "            decimal.set_fill(BLACK)\n",
        "        decimal.move_to(neuron)\n",
        "        return decimal\n",
        "\n",
        "    def get_all_comp_graph_parts(self):\n",
        "        comp_graph = self.comp_graph\n",
        "        result = VGroup(comp_graph)\n",
        "        for attr in \"wL\", \"zL\", \"aL\", \"C0\":\n",
        "            sym = getattr(comp_graph, attr)\n",
        "            result.add(\n",
        "                sym.arrow, sym.number_line, sym.dot\n",
        "            )\n",
        "            del_sym = getattr(self, \"del_\" + attr)\n",
        "            result.add(del_sym, del_sym.brace)\n",
        "\n",
        "        self.all_comp_graph_parts = result\n",
        "        return result\n",
        "\n",
        "class IsntThatOverSimplified(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Isn't that over-simplified?\", \n",
        "            target_mode = \"raise_right_hand\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"raise_right_hand\", \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Not that much, actually!\",\n",
        "            run_time = 1,\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class GeneralFormulas(SimplestNetworkExample):\n",
        "    CONFIG = {\n",
        "        \"layer_sizes\" : [3, 3, 2],\n",
        "        \"network_mob_config\" : {\n",
        "            \"include_output_labels\" : False,\n",
        "            \"neuron_to_neuron_buff\" : LARGE_BUFF,\n",
        "            \"neuron_radius\" : 0.3,\n",
        "        },\n",
        "        \"edge_stroke_width\" : 4,\n",
        "        \"stroke_width_exp\" : 0.2,\n",
        "        \"random_seed\" : 9,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.seed_random_libraries()\n",
        "        self.setup_bases()\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_network_mob()\n",
        "        self.show_all_a_labels()\n",
        "        self.only_show_abstract_a_labels()\n",
        "        self.add_desired_output()\n",
        "        self.show_cost()\n",
        "        self.show_example_weight()\n",
        "        self.show_values_between_weight_and_cost()\n",
        "        self.show_weight_chain_rule()\n",
        "        self.show_derivative_wrt_prev_activation()\n",
        "        self.show_multiple_paths_from_prev_layer_neuron()\n",
        "        self.show_previous_layer()\n",
        "\n",
        "    def setup_network_mob(self):\n",
        "        self.color_network_edges()\n",
        "        self.network_mob.to_edge(LEFT)\n",
        "        self.network_mob.shift(DOWN)\n",
        "        in_vect = np.random.random(self.layer_sizes[0])\n",
        "        self.network_mob.activate_layers(in_vect)\n",
        "        self.remove(self.network_mob.layers[0])\n",
        "        self.remove(self.network_mob.edge_groups[0])\n",
        "\n",
        "    def show_all_a_labels(self):\n",
        "        Lm1_neurons = self.network_mob.layers[-2].neurons\n",
        "        L_neurons = self.network_mob.layers[-1].neurons\n",
        "        all_arrows = VGroup()\n",
        "        all_labels = VGroup()\n",
        "        all_decimals = VGroup()\n",
        "        all_subscript_rects = VGroup()\n",
        "        for neurons in L_neurons, Lm1_neurons:\n",
        "            is_L = neurons is L_neurons\n",
        "            vect = LEFT if is_L else RIGHT\n",
        "            s = \"L\" if is_L else \"L-1\"\n",
        "            arrows = VGroup()\n",
        "            labels = VGroup()\n",
        "            decimals = VGroup()\n",
        "            subscript_rects = VGroup()\n",
        "            for i, neuron in enumerate(neurons):\n",
        "                arrow = Arrow(ORIGIN, vect)\n",
        "                arrow.next_to(neuron, -vect)\n",
        "                arrow.set_fill(WHITE)\n",
        "                label = OldTex(\"a^{(%s)}_%d\"%(s, i))\n",
        "                label.next_to(arrow, -vect, SMALL_BUFF)\n",
        "                rect = SurroundingRectangle(label[-1], buff = 0.5*SMALL_BUFF)\n",
        "                decimal = self.get_neuron_activation_decimal(neuron)\n",
        "                neuron.arrow = arrow\n",
        "                neuron.label = label\n",
        "                neuron.decimal = decimal\n",
        "                arrows.add(arrow)\n",
        "                labels.add(label)\n",
        "                decimals.add(decimal)\n",
        "                subscript_rects.add(rect)\n",
        "            all_arrows.add(arrows)\n",
        "            all_labels.add(labels)\n",
        "            all_decimals.add(decimals)\n",
        "            all_subscript_rects.add(subscript_rects)\n",
        "\n",
        "        start_labels, start_arrows = [\n",
        "            VGroup(*list(map(VGroup, [group[i][0] for i in (0, 1)]))).copy()\n",
        "            for group in (all_labels, all_arrows)\n",
        "        ]\n",
        "        for label in start_labels:\n",
        "            label[0][-1].set_color(BLACK)\n",
        "\n",
        "        self.add(all_decimals)\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, start_labels)),\n",
        "            [GrowArrow(a[0]) for a in start_arrows]\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(start_labels, all_labels),\n",
        "            ReplacementTransform(start_arrows, all_arrows),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction,\n",
        "            VGroup(*all_subscript_rects.family_members_with_points()),\n",
        "            lag_ratio = 0.7\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            L_neurons, Lm1_neurons,\n",
        "            all_arrows, all_labels,\n",
        "            all_decimals, all_subscript_rects,\n",
        "        )\n",
        "\n",
        "    def only_show_abstract_a_labels(self):\n",
        "        arrows_to_fade = VGroup()\n",
        "        labels_to_fade = VGroup()\n",
        "        labels_to_change = VGroup()\n",
        "        self.chosen_neurons = VGroup()\n",
        "        rects = VGroup()\n",
        "        for x, layer in enumerate(self.network_mob.layers[-2:]):\n",
        "            for y, neuron in enumerate(layer.neurons):\n",
        "                if (x == 0 and y == 1) or (x == 1 and y == 0):\n",
        "                    tex = \"k\" if x == 0 else \"j\"\n",
        "                    neuron.label.generate_target()\n",
        "                    self.replace_subscript(neuron.label.target, tex)\n",
        "                    self.chosen_neurons.add(neuron)\n",
        "                    labels_to_change.add(neuron.label)\n",
        "                    rects.add(SurroundingRectangle(\n",
        "                        neuron.label.target[-1], \n",
        "                        buff = 0.5*SMALL_BUFF\n",
        "                    ))\n",
        "                else:\n",
        "                    labels_to_fade.add(neuron.label)\n",
        "                    arrows_to_fade.add(neuron.arrow)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, labels_to_fade),\n",
        "            LaggedStartMap(FadeOut, arrows_to_fade),\n",
        "            run_time = 1\n",
        "        )\n",
        "        for neuron, rect in zip(self.chosen_neurons, rects):\n",
        "            self.play(\n",
        "                MoveToTarget(neuron.label),\n",
        "                ShowCreation(rect)\n",
        "            )\n",
        "            self.play(FadeOut(rect))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "    def add_desired_output(self):\n",
        "        layer = self.network_mob.layers[-1]\n",
        "        desired_output = layer.deepcopy()\n",
        "        desired_output.shift(3*RIGHT)\n",
        "        desired_output_decimals = VGroup()\n",
        "        arrows = VGroup()\n",
        "        labels = VGroup()\n",
        "        for i, neuron in enumerate(desired_output.neurons):\n",
        "            neuron.set_fill(opacity = i)\n",
        "            decimal = self.get_neuron_activation_decimal(neuron)\n",
        "            neuron.decimal = decimal\n",
        "            neuron.arrow = Arrow(ORIGIN, LEFT, color = WHITE)\n",
        "            neuron.arrow.next_to(neuron, RIGHT)\n",
        "            neuron.label = OldTex(\"y_%d\"%i)\n",
        "            neuron.label.next_to(neuron.arrow, RIGHT)\n",
        "            neuron.label.set_color(self.desired_output_color)\n",
        "\n",
        "            desired_output_decimals.add(decimal)\n",
        "            arrows.add(neuron.arrow)\n",
        "            labels.add(neuron.label)\n",
        "        rect = SurroundingRectangle(desired_output, buff = 0.5*SMALL_BUFF)\n",
        "        words = OldTexText(\"Desired output\")\n",
        "        words.next_to(rect, DOWN)\n",
        "        VGroup(words, rect).set_color(self.desired_output_color)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(words),\n",
        "            ReplacementTransform(layer.copy(), desired_output),\n",
        "            FadeIn(labels),\n",
        "            *[\n",
        "                ReplacementTransform(n1.decimal.copy(), n2.decimal)\n",
        "                for n1, n2 in zip(layer.neurons, desired_output.neurons)\n",
        "            ] + list(map(GrowArrow, arrows))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            desired_output,\n",
        "            desired_output_decimals,\n",
        "            desired_output_rect = rect,\n",
        "            desired_output_words = words,\n",
        "        )\n",
        "\n",
        "    def show_cost(self):\n",
        "        aj = self.chosen_neurons[1].label.copy()\n",
        "        yj = self.desired_output.neurons[0].label.copy()\n",
        "\n",
        "        cost_equation = OldTex(\n",
        "            \"C_0\", \"=\", \"\\\\sum_{j = 0}^{n_L - 1}\",\n",
        "            \"(\", \"a^{(L)}_j\", \"-\", \"y_j\", \")\", \"^2\"\n",
        "        )\n",
        "        cost_equation.to_corner(UP+RIGHT)\n",
        "        cost_equation[0].set_color(self.cost_color)\n",
        "        aj.target = cost_equation.get_part_by_tex(\"a^{(L)}_j\")\n",
        "        yj.target = cost_equation.get_part_by_tex(\"y_j\")\n",
        "        yj.target.set_color(self.desired_output_color)\n",
        "        to_fade_in = VGroup(*[m for m in cost_equation if m not in [aj.target, yj.target]])\n",
        "        sum_part = cost_equation.get_part_by_tex(\"sum\")\n",
        "\n",
        "        self.play(*[\n",
        "            ReplacementTransform(mob, mob.target)\n",
        "            for mob in (aj, yj)\n",
        "        ])\n",
        "        self.play(LaggedStartMap(FadeIn, to_fade_in))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, sum_part,\n",
        "            rate_func = wiggle,\n",
        "        ))\n",
        "        self.wait()\n",
        "        for mob in aj.target, yj.target, cost_equation[-1]:\n",
        "            self.play(Indicate(mob))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(cost_equation)\n",
        "\n",
        "    def show_example_weight(self):\n",
        "        edges = self.network_mob.edge_groups[-1]\n",
        "        edge = self.chosen_neurons[1].edges_in[1]\n",
        "        faded_edges = VGroup(*[e for e in edges if e is not edge])\n",
        "        faded_edges.save_state()\n",
        "        for faded_edge in faded_edges:\n",
        "            faded_edge.save_state()\n",
        "\n",
        "        w_label = OldTex(\"w^{(L)}_{jk}\")\n",
        "        subscripts = VGroup(*w_label[-2:])\n",
        "        w_label.scale(1.2)\n",
        "        w_label.add_background_rectangle()\n",
        "        w_label.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "        w_label.rotate(edge.get_angle())\n",
        "        w_label.shift(edge.get_center())\n",
        "        w_label.set_color(BLUE)\n",
        "\n",
        "        edges.save_state()\n",
        "        edges.generate_target()\n",
        "        for e in edges.target:\n",
        "            e.rotate(-e.get_angle())\n",
        "        edges.target.arrange(DOWN)\n",
        "        edges.target.move_to(edges)\n",
        "        edges.target.to_edge(UP)\n",
        "\n",
        "        self.play(MoveToTarget(edges))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, edges,\n",
        "            lambda e : (\n",
        "                lambda m : m.rotate(np.pi/12).set_color(YELLOW),\n",
        "                e\n",
        "            ),\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.play(edges.restore)\n",
        "        self.play(faded_edges.fade, 0.9)\n",
        "        for neuron in self.chosen_neurons:\n",
        "            self.play(Indicate(neuron), Animation(neuron.decimal))\n",
        "        self.play(Write(w_label))\n",
        "        self.wait()\n",
        "        self.play(Indicate(subscripts))\n",
        "        for x in range(2):\n",
        "            self.play(Swap(*subscripts))\n",
        "            self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(faded_edges, w_label)\n",
        "\n",
        "    def show_values_between_weight_and_cost(self):\n",
        "        z_formula = OldTex(\n",
        "            \"z^{(L)}_j\", \"=\", \n",
        "            \"w^{(L)}_{j0}\", \"a^{(L-1)}_0\", \"+\",\n",
        "            \"w^{(L)}_{j1}\", \"a^{(L-1)}_1\", \"+\",\n",
        "            \"w^{(L)}_{j2}\", \"a^{(L-1)}_2\", \"+\", \n",
        "            \"b^{(L)}_j\"\n",
        "        )\n",
        "        compact_z_formula = OldTex(\n",
        "            \"z^{(L)}_j\", \"=\", \n",
        "            \"\\\\cdots\", \"\", \"+\" \n",
        "            \"w^{(L)}_{jk}\", \"a^{(L-1)}_k\", \"+\", \n",
        "            \"\\\\cdots\", \"\", \"\", \"\",\n",
        "        )\n",
        "        for expression in z_formula, compact_z_formula:\n",
        "            expression.to_corner(UP+RIGHT)\n",
        "            expression.set_color_by_tex_to_color_map({\n",
        "                \"z^\" : self.z_color,\n",
        "                \"w^\" : self.w_label.get_color(),\n",
        "                \"b^\" : MAROON_B,\n",
        "            })\n",
        "        w_part = z_formula.get_parts_by_tex(\"w^\")[1]\n",
        "        aLm1_part = z_formula.get_parts_by_tex(\"a^{(L-1)}\")[1]\n",
        "\n",
        "        a_formula = OldTex(\n",
        "            \"a^{(L)}_j\", \"=\", \"\\\\sigma(\", \"z^{(L)}_j\", \")\"\n",
        "        )\n",
        "        a_formula.set_color_by_tex(\"z^\", self.z_color)\n",
        "        a_formula.next_to(z_formula, DOWN, MED_LARGE_BUFF)\n",
        "        a_formula.align_to(self.cost_equation, LEFT)\n",
        "        aL_part = a_formula[0]\n",
        "\n",
        "        to_fade = VGroup(\n",
        "            self.desired_output,\n",
        "            self.desired_output_decimals,\n",
        "            self.desired_output_rect,\n",
        "            self.desired_output_words,\n",
        "            *[\n",
        "                VGroup(n.arrow, n.label)\n",
        "                for n in self.desired_output.neurons\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            self.cost_equation.next_to, a_formula, DOWN, MED_LARGE_BUFF,\n",
        "            self.cost_equation.to_edge, RIGHT,\n",
        "            ReplacementTransform(self.w_label[1].copy(), w_part),\n",
        "            ReplacementTransform(\n",
        "                self.chosen_neurons[0].label.copy(), \n",
        "                aLm1_part\n",
        "            ),\n",
        "        )\n",
        "        self.play(Write(VGroup(*[m for m in z_formula if m not in [w_part, aLm1_part]])))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            self.chosen_neurons[1].label.copy(),\n",
        "            aL_part\n",
        "        ))\n",
        "        self.play(\n",
        "            Write(VGroup(*a_formula[1:3] + [a_formula[-1]])),\n",
        "            ReplacementTransform(\n",
        "                z_formula[0].copy(),\n",
        "                a_formula.get_part_by_tex(\"z^\")\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(z_formula, compact_z_formula, a_formula)\n",
        "\n",
        "    def show_weight_chain_rule(self):\n",
        "        chain_rule = self.get_chain_rule(\n",
        "            \"{\\\\partial C_0\", \"\\\\over\", \"\\\\partial w^{(L)}_{jk}}\",\n",
        "            \"=\",\n",
        "            \"{\\\\partial z^{(L)}_j\", \"\\\\over\", \"\\\\partial w^{(L)}_{jk}}\",\n",
        "            \"{\\\\partial a^{(L)}_j\", \"\\\\over\", \"\\\\partial z^{(L)}_j}\",\n",
        "            \"{\\\\partial C_0\", \"\\\\over\", \"\\\\partial a^{(L)}_j}\",\n",
        "        )\n",
        "        terms = VGroup(*[\n",
        "            VGroup(*chain_rule[i:i+3])\n",
        "            for i in range(4,len(chain_rule), 3)\n",
        "        ])\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(term, buff = 0.5*SMALL_BUFF)\n",
        "            for term in terms\n",
        "        ])\n",
        "        rects.set_color_by_gradient(GREEN, WHITE, RED)\n",
        "\n",
        "        self.play(Transform(\n",
        "            self.z_formula, self.compact_z_formula\n",
        "        ))\n",
        "        self.play(Write(chain_rule))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, rects,\n",
        "            lag_ratio = 0.7,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(chain_rule)\n",
        "\n",
        "    def show_derivative_wrt_prev_activation(self):\n",
        "        chain_rule = self.get_chain_rule(\n",
        "            \"{\\\\partial C_0\", \"\\\\over\", \"\\\\partial a^{(L-1)}_k}\",\n",
        "            \"=\",\n",
        "            \"\\\\sum_{j=0}^{n_L - 1}\", \n",
        "            \"{\\\\partial z^{(L)}_j\", \"\\\\over\", \"\\\\partial a^{(L-1)}_k}\",\n",
        "            \"{\\\\partial a^{(L)}_j\", \"\\\\over\", \"\\\\partial z^{(L)}_j}\",\n",
        "            \"{\\\\partial C_0\", \"\\\\over\", \"\\\\partial a^{(L)}_j}\",\n",
        "        )\n",
        "        formulas = VGroup(self.z_formula, self.a_formula, self.cost_equation)\n",
        "\n",
        "        n = chain_rule.index_of_part_by_tex(\"sum\")\n",
        "        self.play(ReplacementTransform(\n",
        "            self.chain_rule, VGroup(*chain_rule[:n] + chain_rule[n+1:])\n",
        "        ))\n",
        "        self.play(Write(chain_rule[n], run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(chain_rule)\n",
        "\n",
        "    def show_multiple_paths_from_prev_layer_neuron(self):\n",
        "        neurons = self.network_mob.layers[-1].neurons\n",
        "        labels, arrows, decimals = [\n",
        "            VGroup(*[getattr(n, attr) for n in neurons])\n",
        "            for attr in (\"label\", \"arrow\", \"decimal\")\n",
        "        ]\n",
        "        edges = VGroup(*[n.edges_in[1] for n in neurons])\n",
        "        labels[0].generate_target()\n",
        "        self.replace_subscript(labels[0].target, \"0\")\n",
        "\n",
        "        paths = [\n",
        "            VGroup(\n",
        "                self.chosen_neurons[0].label,\n",
        "                self.chosen_neurons[0].arrow,\n",
        "                self.chosen_neurons[0],\n",
        "                self.chosen_neurons[0].decimal,\n",
        "                edges[i],\n",
        "                neurons[i],\n",
        "                decimals[i],\n",
        "                arrows[i],\n",
        "                labels[i],\n",
        "            )\n",
        "            for i in range(2)\n",
        "        ]\n",
        "        path_lines = VGroup()\n",
        "        for path in paths:\n",
        "            points = [path[0].get_center()]\n",
        "            for mob in path[1:]:\n",
        "                if isinstance(mob, DecimalNumber):\n",
        "                    continue\n",
        "                points.append(mob.get_center())\n",
        "            path_line = VMobject()\n",
        "            path_line.set_points_as_corners(points)\n",
        "            path_lines.add(path_line)\n",
        "        path_lines.set_color(YELLOW)\n",
        "\n",
        "        chain_rule = self.chain_rule\n",
        "        n = chain_rule.index_of_part_by_tex(\"sum\")\n",
        "        brace = Brace(VGroup(*chain_rule[n:]), DOWN, buff = SMALL_BUFF)\n",
        "        words = brace.get_text(\"Sum over layer L\", buff = SMALL_BUFF)\n",
        "\n",
        "        cost_aL = self.cost_equation.get_part_by_tex(\"a^{(L)}\")\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(labels[0]),\n",
        "            FadeIn(labels[1]),\n",
        "            GrowArrow(arrows[1]),\n",
        "            edges[1].restore,\n",
        "            FadeOut(self.w_label),\n",
        "        )\n",
        "        for x in range(5):\n",
        "            anims = [\n",
        "                ShowCreationThenDestruction(\n",
        "                    path_line,\n",
        "                    run_time = 1.5,\n",
        "                    time_width = 0.5,\n",
        "                )\n",
        "                for path_line in path_lines\n",
        "            ]\n",
        "            if x == 2:\n",
        "                anims += [\n",
        "                    FadeIn(words),\n",
        "                    GrowFromCenter(brace)\n",
        "                ]\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "        for path, path_line in zip(paths, path_lines):\n",
        "            label = path[-1]\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    Indicate, path,\n",
        "                    rate_func = wiggle,\n",
        "                    run_time = 1,\n",
        "                ),\n",
        "                ShowCreation(path_line),\n",
        "                Animation(label)\n",
        "            )\n",
        "            self.wait()\n",
        "            group = VGroup(label, cost_aL)\n",
        "            self.play(\n",
        "                group.shift, MED_SMALL_BUFF*UP, \n",
        "                rate_func = wiggle\n",
        "            )\n",
        "            self.play(FadeOut(path_line))\n",
        "        self.wait()\n",
        "\n",
        "    def show_previous_layer(self):\n",
        "        mid_neurons = self.network_mob.layers[1].neurons\n",
        "        layer = self.network_mob.layers[0]\n",
        "        edges = self.network_mob.edge_groups[0]\n",
        "        faded_edges = self.faded_edges\n",
        "        to_fade = VGroup(\n",
        "            self.chosen_neurons[0].label,\n",
        "            self.chosen_neurons[0].arrow,\n",
        "        )\n",
        "        for neuron in layer.neurons:\n",
        "            neuron.add(self.get_neuron_activation_decimal(neuron))\n",
        "\n",
        "        all_edges_out = VGroup(*[\n",
        "            VGroup(*[n.edges_in[i] for n in mid_neurons]).copy()\n",
        "            for i in range(len(layer.neurons))\n",
        "        ])\n",
        "        all_edges_out.set_stroke(YELLOW, 3)\n",
        "\n",
        "        deriv = VGroup(*self.chain_rule[:3])\n",
        "        deriv_rect = SurroundingRectangle(deriv)\n",
        "        mid_neuron_outlines = mid_neurons.copy()\n",
        "        mid_neuron_outlines.set_fill(opacity = 0)\n",
        "        mid_neuron_outlines.set_stroke(YELLOW, 5)\n",
        "\n",
        "        def get_neurons_decimal_anims(neuron):\n",
        "            return [\n",
        "                ChangingDecimal(\n",
        "                    neuron.decimal,\n",
        "                    lambda a : neuron.get_fill_opacity(),\n",
        "                ),\n",
        "                UpdateFromFunc(\n",
        "                    neuron.decimal,\n",
        "                    lambda m : m.set_fill(\n",
        "                        WHITE if neuron.get_fill_opacity() < 0.8 else BLACK\n",
        "                    )\n",
        "                )\n",
        "            ]\n",
        "\n",
        "        self.play(ShowCreation(deriv_rect))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction, \n",
        "            mid_neuron_outlines\n",
        "        ))\n",
        "        self.play(*it.chain(*[\n",
        "            [\n",
        "                ApplyMethod(n.set_fill, None, random.random()),\n",
        "            ] + get_neurons_decimal_anims(n)\n",
        "            for n in mid_neurons\n",
        "        ]), run_time = 4, rate_func = there_and_back)\n",
        "        self.play(faded_edges.restore)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                GrowFromCenter, layer.neurons,\n",
        "                run_time = 1\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, edges),\n",
        "            FadeOut(to_fade)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            for edges_out in all_edges_out:\n",
        "                self.play(ShowCreationThenDestruction(edges_out))\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def replace_subscript(self, label, tex):\n",
        "        subscript = label[-1]\n",
        "        new_subscript = OldTex(tex)[0]\n",
        "        new_subscript.replace(subscript, dim_to_match = 1)\n",
        "        label.remove(subscript)\n",
        "        label.add(new_subscript)\n",
        "        return label\n",
        "\n",
        "    def get_chain_rule(self, *tex):\n",
        "        chain_rule = OldTex(*tex)\n",
        "        chain_rule.scale(0.8)\n",
        "        chain_rule.to_corner(UP+LEFT)\n",
        "        chain_rule.set_color_by_tex_to_color_map({\n",
        "            \"C_0\" : self.cost_color,\n",
        "            \"z^\" : self.z_color,\n",
        "            \"w^\" : self.w_label.get_color()\n",
        "        })\n",
        "        return chain_rule\n",
        "\n",
        "class ThatsPrettyMuchIt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"That's pretty \\\\\\\\ much it!\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class PatYourselfOnTheBack(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Pat yourself on \\\\\\\\ the back!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ThatsALotToThinkAbout(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"That's a lot to \\\\\\\\ think about!\",\n",
        "            target_mode = \"surprised\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(4)\n",
        "\n",
        "class LayersOfComplexity(Scene):\n",
        "    def construct(self):\n",
        "        chain_rule_equations = self.get_chain_rule_equations()\n",
        "        chain_rule_equations.to_corner(UP+RIGHT)\n",
        "\n",
        "        brace = Brace(chain_rule_equations, LEFT)\n",
        "        arrow = Vector(LEFT, color = RED)\n",
        "        arrow.next_to(brace, LEFT)\n",
        "        gradient = OldTex(\"\\\\nabla C\")\n",
        "        gradient.scale(2)\n",
        "        gradient.set_color(RED)\n",
        "        gradient.next_to(arrow, LEFT)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, chain_rule_equations))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.play(Write(gradient))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def get_chain_rule_equations(self):\n",
        "        w_deriv = OldTex(\n",
        "            \"{\\\\partial C\", \"\\\\over\", \"\\\\partial w^{(l)}_{jk}}\",\n",
        "            \"=\",\n",
        "            \"a^{(l-1)}_k\",\n",
        "            \"\\\\sigma'(z^{(l)}_j)\",\n",
        "            \"{\\\\partial C\", \"\\\\over\", \"\\\\partial a^{(l)}_j}\",\n",
        "        )\n",
        "        lil_rect = SurroundingRectangle(\n",
        "            VGroup(*w_deriv[-3:]),\n",
        "            buff = 0.5*SMALL_BUFF\n",
        "        )\n",
        "        a_deriv = OldTex(\n",
        "            \"\\\\sum_{j = 0}^{n_{l+1} - 1}\",\n",
        "            \"w^{(l+1)}_{jk}\",\n",
        "            \"\\\\sigma'(z^{(l+1)}_j)\",\n",
        "            \"{\\\\partial C\", \"\\\\over\", \"\\\\partial a^{(l+1)}_j}\",\n",
        "        )\n",
        "        or_word = OldTexText(\"or\")\n",
        "        last_a_deriv = OldTex(\"2(a^{(L)}_j - y_j)\")\n",
        "\n",
        "        a_deriv.next_to(w_deriv, DOWN, LARGE_BUFF)\n",
        "        or_word.next_to(a_deriv, DOWN)\n",
        "        last_a_deriv.next_to(or_word, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        big_rect = SurroundingRectangle(VGroup(a_deriv, last_a_deriv))\n",
        "        arrow = Arrow(\n",
        "            lil_rect.get_corner(DOWN+LEFT), \n",
        "            big_rect.get_top(),\n",
        "        )\n",
        "\n",
        "        result = VGroup(\n",
        "            w_deriv, lil_rect, arrow,\n",
        "            big_rect, a_deriv, or_word, last_a_deriv\n",
        "        )\n",
        "        for expression in w_deriv, a_deriv, last_a_deriv:\n",
        "            expression.set_color_by_tex_to_color_map({\n",
        "                \"C\" : RED,\n",
        "                \"z^\" : GREEN,\n",
        "                \"w^\" : BLUE,\n",
        "                \"b^\" : MAROON_B,\n",
        "            })\n",
        "        return result\n",
        "\n",
        "class SponsorFrame(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        screen = ScreenRectangle(height = 5)\n",
        "        screen.to_corner(UP+LEFT)\n",
        "        url = OldTexText(\"http://3b1b.co/crowdflower\")\n",
        "        url.move_to(screen, UP+LEFT)\n",
        "        screen.shift(LARGE_BUFF*DOWN)\n",
        "        arrow = Arrow(LEFT, RIGHT, color = WHITE)\n",
        "        arrow.next_to(url, RIGHT)\n",
        "\n",
        "        t_shirt_words = OldTexText(\"Free T-Shirt\")\n",
        "        t_shirt_words.scale(1.5)\n",
        "        t_shirt_words.set_color(YELLOW)\n",
        "        t_shirt_words.next_to(morty, UP, aligned_edge = RIGHT)\n",
        "\n",
        "        human_in_the_loop = OldTexText(\"Human-in-the-loop approach\")\n",
        "        human_in_the_loop.next_to(screen, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            morty.change, \"hooray\", t_shirt_words,\n",
        "            Write(t_shirt_words, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\", screen,\n",
        "            ShowCreation(screen)\n",
        "        )\n",
        "        self.play(\n",
        "            t_shirt_words.scale, 1./1.5,\n",
        "            t_shirt_words.next_to, arrow, RIGHT\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait(2)\n",
        "        self.play(morty.change, \"thinking\", url)\n",
        "        self.wait(3)\n",
        "        self.play(Write(human_in_the_loop))\n",
        "        self.play(morty.change, \"happy\", url)\n",
        "        self.play(morty.look_at, screen)\n",
        "        self.wait(7)\n",
        "        t_shirt_words_outline = t_shirt_words.copy()\n",
        "        t_shirt_words_outline.set_fill(opacity = 0)\n",
        "        t_shirt_words_outline.set_stroke(GREEN, 3)\n",
        "        self.play(\n",
        "            morty.change, \"hooray\", t_shirt_words,\n",
        "            LaggedStartMap(ShowCreation, t_shirt_words_outline),\n",
        "        )\n",
        "        self.play(FadeOut(t_shirt_words_outline))\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, url,\n",
        "            rate_func = wiggle,\n",
        "            color = PINK,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "class NN3PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Randall Hunt\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"David Kedmey\",\n",
        "            \"Michael Hardwicke\",\n",
        "            \"Nathan Weeks\",\n",
        "            \"Marcus Schiebold\",\n",
        "            \"Ali Yahya\",\n",
        "            \"William\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Dagan Harrington\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Eric Chow\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Robert Teed\",\n",
        "            \"Pedro Perez Sanchez\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Harsev Singh\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Xueqi Li\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "        \"max_patron_group_size\" : 25,\n",
        "        \"patron_scale_val\" : 0.7,\n",
        "    }\n",
        "\n",
        "class Thumbnail(PreviewLearning):\n",
        "    CONFIG = {\n",
        "        \"layer_sizes\" : [8, 6, 6, 4],\n",
        "        \"network_mob_config\" : {\n",
        "            \"neuron_radius\" : 0.3,\n",
        "            \"neuron_to_neuron_buff\" : MED_SMALL_BUFF,\n",
        "            \"include_output_labels\" : False,\n",
        "        },\n",
        "        \"stroke_width_exp\" : 1,\n",
        "        \"max_stroke_width\" : 5,\n",
        "        \"title\" : \"Backpropagation\",\n",
        "        \"network_scale_val\" : 0.8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.color_network_edges()\n",
        "        network_mob = self.network_mob\n",
        "        network_mob.scale(\n",
        "            self.network_scale_val, \n",
        "            about_point = network_mob.get_bottom()\n",
        "        )\n",
        "        network_mob.activate_layers(np.random.random(self.layer_sizes[0]))\n",
        "\n",
        "        for edge in it.chain(*network_mob.edge_groups):\n",
        "            arrow = Arrow(\n",
        "                edge.get_end(), edge.get_start(), \n",
        "                buff = 0,\n",
        "                tip_length = 0.1,\n",
        "                color = edge.get_color()\n",
        "            )\n",
        "            network_mob.add(arrow.tip)\n",
        "\n",
        "        arrow = Vector(\n",
        "            3*LEFT, \n",
        "            tip_length = 0.75, \n",
        "            rectangular_stem_width = 0.2,\n",
        "            color = BLUE,\n",
        "        )\n",
        "        arrow.next_to(network_mob.edge_groups[1], UP, MED_LARGE_BUFF)\n",
        "\n",
        "        network_mob.add(arrow)\n",
        "        self.add(network_mob)\n",
        "\n",
        "        title = OldTexText(self.title)\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "class SupplementThumbnail(Thumbnail):\n",
        "    CONFIG = {\n",
        "        \"title\" : \"Backpropagation \\\\\\\\ calculus\",\n",
        "        \"network_scale_val\" : 0.7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        Thumbnail.construct(self)\n",
        "        self.network_mob.to_edge(DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        for layer in self.network_mob.layers:\n",
        "            for neuron in layer.neurons:\n",
        "                partial = OldTex(\"\\\\partial\")\n",
        "                partial.move_to(neuron)\n",
        "                self.remove(neuron)\n",
        "                self.add(partial)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}