{
    "topic": "The mathematical concept being demonstrated is the visualization of a white light wave with different wavelengths",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.optics_puzzles.objects import *\n",
        "\n",
        "\n",
        "class WhiteLightAsASum(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Initial orientation\n",
        "        frame = self.frame\n",
        "        frame.reorient(0, 90)\n",
        "\n",
        "        # Create axes\n",
        "        n_colors = 15\n",
        "        axes_width = 9.0\n",
        "        x_max = 8\n",
        "        spectral_axes = VGroup(*(\n",
        "            ThreeDAxes((0, x_max), (-1, 1), (-1, 1))\n",
        "            for _ in range(n_colors)\n",
        "        ))\n",
        "        spectral_axes.set_width(axes_width)\n",
        "        spectral_axes.arrange(UP, buff=0.05)\n",
        "\n",
        "        white_axes = ThreeDAxes((0, x_max), (-1, 1), (-1, 1))\n",
        "        white_axes.set_width(axes_width)\n",
        "        white_axes.shift(2 * DOWN)\n",
        "        spectral_axes.next_to(white_axes, UP)\n",
        "\n",
        "        all_axes = [white_axes, *spectral_axes]\n",
        "        for axes in all_axes:\n",
        "            axes.y_axis.set_opacity(0)\n",
        "\n",
        "        for axes in spectral_axes:\n",
        "            axes.z_axis.stretch(0.5, 2)\n",
        "\n",
        "        white_axes.z_axis.stretch(1.5, 2)\n",
        "\n",
        "        # Create individual waves\n",
        "        white_parts = VGroup()\n",
        "        spectral_waves = VGroup()\n",
        "        alphas = np.linspace(0.0, 1.0, n_colors)\n",
        "        for alpha, s_axes in zip(alphas, spectral_axes):\n",
        "            wave_len = interpolate(1.0, 2.0, alpha)\n",
        "            for axes, group in [(s_axes, spectral_waves), (white_axes, white_parts)]:\n",
        "                wave = OscillatingWave(\n",
        "                    axes,\n",
        "                    y_amplitude=0,\n",
        "                    z_amplitude=1,\n",
        "                    wave_len=wave_len,\n",
        "                    color=get_spectral_color(1 - alpha)\n",
        "                )\n",
        "                group.add(wave)\n",
        "\n",
        "        # Show white wave\n",
        "        white_wave = MeanWave(white_parts)\n",
        "        white_wave.set_stroke(width=1)\n",
        "        white_vects = OscillatingFieldWave(white_axes, white_wave, tip_width_ratio=3)\n",
        "    \n",
        "        self.add(white_axes, white_wave, white_vects)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show spectral parts\n",
        "        symbols = Tex(\"=\" + \"+\" * (n_colors - 1))\n",
        "        symbols.scale(2)\n",
        "        symbols.rotate(90 * DEGREES)\n",
        "        for symbol, a1, a2 in zip(symbols, all_axes, all_axes[1:]):\n",
        "            symbol.move_to(VGroup(a1, a2))\n",
        "\n",
        "        spectral_vect_waves = VGroup()\n",
        "        for sa, sw in zip(spectral_axes, spectral_waves):\n",
        "            vwave = OscillatingFieldWave(sa, sw, tip_width_ratio=3)\n",
        "            sw.set_stroke(width=1)\n",
        "            spectral_vect_waves.add(vwave)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(50, 65, 0).move_to([0.6, 2.9, -0.16]).set_height(11).set_anim_args(run_time=3),\n",
        "            LaggedStartMap(FadeIn, spectral_axes),\n",
        "            LaggedStartMap(VFadeIn, spectral_waves),\n",
        "            LaggedStartMap(VFadeIn, spectral_vect_waves),\n",
        "            LaggedStartMap(FadeIn, symbols),\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(19, 65, 0).move_to([0.6, 2.9, -0.16]).set_height(11.00),\n",
        "            run_time=8\n",
        "        )\n",
        "        return\n",
        "\n",
        "        # Scrap\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(\n",
        "                sa.get_left(),\n",
        "                interpolate(white_axes.get_corner(UR), white_axes.get_corner(DR), alpha),\n",
        "                buff=0.3,\n",
        "                stroke_color=wave.get_color()\n",
        "            )\n",
        "            for sa, wave, alpha in zip(\n",
        "                spectral_axes,\n",
        "                spectral_waves,\n",
        "                np.linspace(0, 1, n_colors),\n",
        "            )\n",
        "        ))\n",
        "\n",
        "        pass\n",
        "\n",
        "\n",
        "class AddTwoSineWaves(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup axes\n",
        "        axes1, axes2, axes3 = all_axes = [self.get_axes() for _ in range(3)]\n",
        "        for axes, y in zip(all_axes, [2.5, 0, -3.0]):\n",
        "            axes.set_y(y)\n",
        "            axes.to_edge(RIGHT)\n",
        "\n",
        "        # First two waves\n",
        "        wave1 = self.get_variable_wave(axes1, color=BLUE, func_name=\"f(t)\", index=\"1\")\n",
        "        wave2 = self.get_variable_wave(axes2, color=YELLOW, func_name=\"g(t)\", index=\"2\", omega=PI)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes1),\n",
        "            ShowCreation(wave1[0]),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, wave1[2]),)\n",
        "        self.change_all_parameters(wave1, 0.5, PI, PI / 4)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes2),\n",
        "            ShowCreation(wave2[0]),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, wave2[2]),)\n",
        "        self.change_all_parameters(wave2, 0.75, 2 * PI, PI / 2)\n",
        "        self.wait()\n",
        "\n",
        "        self.add(axes2)\n",
        "        self.add(wave2)\n",
        "\n",
        "        # Sum wave\n",
        "        wave3 = axes3.get_graph(\n",
        "            lambda x: wave1.func(x) + wave2.func(x),\n",
        "            color=GREEN,\n",
        "            bind=True\n",
        "        )\n",
        "        wave3_label = Tex(\"f(t) + g(t)\", font_size=36)\n",
        "        wave3_label.move_to(axes3.c2p(0.5, 1.5), DL)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(axes1, axes3),\n",
        "            TransformFromCopy(axes2, axes3),\n",
        "            TransformFromCopy(wave1.labels[3][\"f(t)\"], wave3_label[\"f(t)\"]),\n",
        "            TransformFromCopy(wave2.labels[3][\"g(t)\"], wave3_label[\"+ g(t)\"]),\n",
        "            lag_ratio=0.05\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(wave1[0], wave3),\n",
        "            TransformFromCopy(wave2[0], wave3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Some example changes\n",
        "        self.change_wave_parameter(wave1, \"phi\", TAU)\n",
        "        self.change_wave_parameter(wave2, \"A\", 0.5)\n",
        "        self.change_wave_parameter(wave1, \"omega\", 4.5)\n",
        "        self.change_wave_parameter(wave1, \"phi\", 3 * PI / 4)\n",
        "        self.change_wave_parameter(wave2, \"omega\", 3 * PI)\n",
        "        self.change_wave_parameter(wave2, \"phi\", 5)\n",
        "        self.wait()\n",
        "\n",
        "        # Lock both frequencies\n",
        "        frame = self.frame\n",
        "        t2c = {R\"\\omega\": GOLD}\n",
        "        top_words = TexText(\n",
        "            R\"If both have matching \\\\ frequencies, $\\omega$...\",\n",
        "            font_size=36,\n",
        "            t2c=t2c\n",
        "        )\n",
        "        top_words.next_to(VGroup(wave1.labels, wave2.labels), LEFT, buff=2.0)\n",
        "\n",
        "        omega_locks = VGroup()\n",
        "        for wave in [wave1, wave2]:\n",
        "            lock = SVGMobject(\"lock\")\n",
        "            lock.match_height(wave.labels[1])\n",
        "            lock.next_to(wave.labels[1], LEFT, SMALL_BUFF)\n",
        "            omega_locks.add(lock)\n",
        "\n",
        "        omega_locks.set_color(GOLD)\n",
        "\n",
        "        top_arrows = VGroup(*(\n",
        "            Arrow(top_words.get_right(), lock.get_left())\n",
        "            for lock in omega_locks\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_x(-5),\n",
        "            FadeIn(top_words, 0.5 * LEFT),\n",
        "            LaggedStartMap(ShowCreation, top_arrows),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, omega_locks),\n",
        "            *self.get_wave_change_animations(wave1, \"omega\", PI),\n",
        "            *self.get_wave_change_animations(wave2, \"omega\", PI),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Graph is also sine\n",
        "        low_words = TexText(\n",
        "            R\"Then this is also a sine \\\\ wave with frequency $\\omega$\",\n",
        "            font_size=36,\n",
        "            t2c=t2c,\n",
        "        )\n",
        "        low_words.align_to(top_words, LEFT)\n",
        "        low_words.match_y(axes3).shift(UP)\n",
        "        low_arrow = Arrow(low_words.get_right(), axes3.get_left())\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(top_words.copy(), low_words),\n",
        "            FadeIn(low_arrow, 2 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show lower function label\n",
        "        sum_sine = Tex(R\"= 1.00\\sin(\\omega t +2.00)\", t2c={R\"\\omega\": GOLD}, font_size=36)\n",
        "        sum_sine.next_to(wave3_label, RIGHT, SMALL_BUFF)\n",
        "        sum_A = sum_sine.make_number_changeable(\"1.00\")\n",
        "        sum_phi = sum_sine.make_number_changeable(\"+2.00\", include_sign=True)\n",
        "        sum_A.set_color(RED)\n",
        "        sum_phi.set_color(PINK)\n",
        "        sum_parameters = VGroup(sum_A, sum_phi)\n",
        "\n",
        "        def update_sum_parameters(params):\n",
        "            A1 = wave1.trackers[0].get_value()\n",
        "            A2 = wave2.trackers[0].get_value()\n",
        "            phi1 = wave1.trackers[2].get_value()\n",
        "            phi2 = wave2.trackers[2].get_value()\n",
        "            z3 = A1 * np.exp(phi1 * 1j) + A2 * np.exp(phi2 * 1j)\n",
        "            params[0].set_value(abs(z3))\n",
        "            params[1].set_value(np.log(z3).imag)\n",
        "\n",
        "        sum_parameters.add_updater(update_sum_parameters)\n",
        "\n",
        "        self.play(Write(sum_sine))\n",
        "        self.add(sum_parameters)\n",
        "\n",
        "        # Ask about sum parameters\n",
        "        param_arrows = VGroup()\n",
        "        param_qmarks = VGroup()\n",
        "        for param in sum_parameters:\n",
        "            arrow = Vector(0.5 * DOWN)\n",
        "            arrow.next_to(param, UP, buff=SMALL_BUFF)\n",
        "            arrow.match_color(param)\n",
        "            q_mark = Text(\"?\")\n",
        "            q_mark.match_color(param)\n",
        "            q_mark.next_to(arrow, UP, SMALL_BUFF)\n",
        "            param_arrows.add(arrow)\n",
        "            param_qmarks.add(q_mark)\n",
        "            self.play(ShowCreation(arrow), FadeIn(q_mark))\n",
        "        self.wait()\n",
        "\n",
        "        # Change the other parameters a bunch\n",
        "        self.change_wave_parameter(wave1, \"phi\", 0)\n",
        "        self.change_wave_parameter(wave1, \"A\", 1.0)\n",
        "        self.change_wave_parameter(wave2, \"phi\", -0.8, run_time=4)\n",
        "        self.change_wave_parameter(wave2, \"A\", 0.75)\n",
        "        self.change_wave_parameter(wave1, \"phi\", PI / 3)\n",
        "\n",
        "        # Clear the board\n",
        "        low_fade_rect = FullScreenFadeRectangle()\n",
        "        low_fade_rect.set_height(5.25, about_edge=DOWN, stretch=True)\n",
        "        low_fade_rect.set_fill(BLACK, 0.85)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(top_words),\n",
        "            FadeOut(top_arrows),\n",
        "            FadeOut(low_words),\n",
        "            FadeOut(low_arrow),\n",
        "            FadeOut(param_arrows),\n",
        "            FadeOut(param_qmarks),\n",
        "            FadeIn(low_fade_rect),\n",
        "        ))\n",
        "\n",
        "        # Show first and second phasors\n",
        "        phasor1 = self.get_phasor(axes1, wave1)\n",
        "        phasor2 = self.get_phasor(axes2, wave2)\n",
        "\n",
        "        for wave, phasor in [(wave1, phasor1), (wave2, phasor2)]:\n",
        "            # Setup and add phasor\n",
        "            A_label = wave.labels[0][:2]\n",
        "            phi_label = wave.labels[2][:2]\n",
        "            phasor.A_label = A_label.copy()\n",
        "            phasor.A_label.scale(0.75)\n",
        "            max_A_height = phasor.A_label.get_height()\n",
        "            phasor.A_label.vector = phasor.vector\n",
        "            phasor.A_label.add_updater(lambda m: m.set_height(min(max_A_height, m.vector.get_length())))\n",
        "            phasor.A_label.add_updater(lambda m: m.next_to(\n",
        "                m.vector.pfp(0.5),\n",
        "                normalize(rotate_vector(\n",
        "                    m.vector.get_vector(),\n",
        "                    (1 if m.vector.get_angle() > 0 else -1) * 90 * DEGREES\n",
        "                )),\n",
        "                buff=0.05,\n",
        "            ))\n",
        "            phasor.phi_label = phi_label.copy()\n",
        "            phasor.phi_label.scale(0.65)\n",
        "            max_phi_height = phasor.phi_label.get_height()\n",
        "            phasor.phi_label.plane = phasor.plane\n",
        "            phasor.phi_label.arc = phasor.arc\n",
        "            phasor.phi_label.add_updater(lambda m: m.set_height(min(max_phi_height, m.arc.get_height())))\n",
        "            phasor.phi_label.add_updater(lambda m: m.move_to(m.plane.n2p(\n",
        "                1.5 * m.plane.p2n(m.arc.pfp(0.5))\n",
        "            )))\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(phasor.plane, LEFT),\n",
        "                FadeIn(phasor.rot_vect, LEFT),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            # Show y coordinate\n",
        "            wave.output_indicator = self.get_output_indicator(\n",
        "                wave.axes, wave.wave, phasor.t_tracker\n",
        "            )\n",
        "            self.play(\n",
        "                FadeIn(phasor.y_line),\n",
        "                FadeIn(phasor.y_dot),\n",
        "                FadeIn(wave.output_indicator),\n",
        "            )\n",
        "            self.play(\n",
        "                phasor.t_tracker.animate.set_value(4),\n",
        "                run_time=8,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(wave.output_indicator),\n",
        "                FadeOut(phasor.y_line),\n",
        "                FadeOut(phasor.y_dot),\n",
        "            )\n",
        "\n",
        "            self.add(\n",
        "                phasor.vector,\n",
        "                phasor.rot_vect,\n",
        "            )\n",
        "\n",
        "            # Show amplitude and phase\n",
        "            self.play(TransformFromCopy(A_label, phasor.A_label))\n",
        "            self.play(\n",
        "                wave.trackers[0].animate.set_value(1.5 * wave.trackers[0].get_value()),\n",
        "                run_time=2,\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                TransformFromCopy(phi_label, phasor.phi_label),\n",
        "                FadeIn(phasor.arc),\n",
        "            )\n",
        "            self.play(\n",
        "                wave.trackers[2].animate.set_value(wave.trackers[2].get_value() + PI / 2),\n",
        "                run_time=4,\n",
        "                rate_func=there_and_back,\n",
        "            )\n",
        "\n",
        "            # Shrink rect\n",
        "            self.play(\n",
        "                low_fade_rect.animate.set_height(3, about_edge=DOWN, stretch=True)\n",
        "            )\n",
        "\n",
        "        # Show the sum\n",
        "        sum_plane = ComplexPlane(\n",
        "            (-1, 1), (-1, 1),\n",
        "            background_line_style=dict(stroke_color=GREY_B, stroke_width=1),\n",
        "            faded_line_style=dict(stroke_color=GREY_B, stroke_width=0.5, stroke_opacity=0.25),\n",
        "            faded_line_ratio=4,\n",
        "        )\n",
        "        sum_plane.set_height(2.0)\n",
        "        sum_plane.match_x(phasor1)\n",
        "        sum_plane.match_y(axes3)\n",
        "        sum_plane.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        low_vects = VGroup(*(\n",
        "            Vector(\n",
        "                stroke_width=3,\n",
        "                stroke_color=wave.wave.get_color(),\n",
        "            )\n",
        "            for wave in [wave1, wave2]\n",
        "        ))\n",
        "        def update_low_vects(vects):\n",
        "            z1 = phasor1.get_z()\n",
        "            z2 = phasor2.get_z()\n",
        "            vects[0].put_start_and_end_on(\n",
        "                sum_plane.n2p(0),\n",
        "                sum_plane.n2p(z1),\n",
        "            )\n",
        "            vects[1].put_start_and_end_on(\n",
        "                sum_plane.n2p(z1),\n",
        "                sum_plane.n2p(z1 + z2),\n",
        "            )\n",
        "\n",
        "        low_vects.add_updater(update_low_vects)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(sum_plane),\n",
        "            FadeOut(low_fade_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(phasor1.rot_vect, low_vects[0]),\n",
        "            TransformFromCopy(phasor2.rot_vect, low_vects[1]),\n",
        "        )\n",
        "        self.add(low_vects)\n",
        "        self.wait()\n",
        "\n",
        "        # Show the sum of the two vectors\n",
        "        sum_vect = Vector(stroke_color=wave3.get_color(), stroke_width=3)\n",
        "        sum_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            sum_plane.n2p(0),\n",
        "            sum_plane.n2p(phasor1.get_z() + phasor2.get_z()),\n",
        "        ))\n",
        "\n",
        "        sum_output_indicator = self.get_output_indicator(axes3, wave3, phasor1.t_tracker)\n",
        "\n",
        "        def show_rotation(max_t=4):\n",
        "            for phasor in [phasor1, phasor2]:\n",
        "                phasor.t_tracker.set_value(0)\n",
        "            self.add(\n",
        "                wave1.output_indicator,\n",
        "                wave2.output_indicator,\n",
        "                sum_output_indicator,\n",
        "            )\n",
        "            self.play(\n",
        "                phasor1.t_tracker.animate.set_value(max_t),\n",
        "                phasor2.t_tracker.animate.set_value(max_t),\n",
        "                run_time=4 * max_t,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            self.play(*map(FadeOut, (\n",
        "                wave1.output_indicator,\n",
        "                wave2.output_indicator,\n",
        "                sum_output_indicator,\n",
        "            )))\n",
        "\n",
        "        self.play(ShowCreation(sum_vect))\n",
        "        show_rotation()\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize amplitude and phase of the new wave\n",
        "        param_rects = VGroup(*(\n",
        "            SurroundingRectangle(param).match_color(param)\n",
        "            for param in sum_parameters\n",
        "        ))\n",
        "        param_rects.set_stroke(width=2)\n",
        "\n",
        "        sum_arc = Arc(angle=sum_parameters[1].get_value(), radius=0.5, arc_center=sum_plane.n2p(0))\n",
        "        sum_arc.set_stroke(WHITE, 2)\n",
        "\n",
        "        sum_A_copy, sum_phi_copy = sum_parameters.copy()\n",
        "        sum_A_copy.scale(0.5)\n",
        "        sum_A_copy.rotate(sum_vect.get_angle())\n",
        "        sum_A_copy.next_to(sum_vect.get_center(), UP, buff=0.05)\n",
        "        sum_phi_copy.scale(0.25)\n",
        "        sum_phi_copy.next_to(sum_arc, RIGHT, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(param_arrows[0]),\n",
        "            FadeIn(param_qmarks[0]),\n",
        "            ShowCreation(param_rects[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(sum_parameters[0], sum_A_copy),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(*param_arrows),\n",
        "            ReplacementTransform(*param_qmarks),\n",
        "            ReplacementTransform(*param_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(sum_parameters[1], sum_phi_copy),\n",
        "            ShowCreation(sum_arc)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, (\n",
        "            sum_A_copy, sum_phi_copy, sum_arc,\n",
        "            param_arrows[1], param_qmarks[1], param_rects[1]\n",
        "        )))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # Play around with some alternate values, again\n",
        "        phi0 = PI / 6\n",
        "        self.play(\n",
        "            *self.get_wave_change_animations(wave1, \"phi\", phi0),\n",
        "            *self.get_wave_change_animations(wave2, \"phi\", phi0),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *self.get_wave_change_animations(wave2, \"phi\", phi0 - PI),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_wave_parameter(wave2, \"phi\", phi0 - PI / 2, run_time=3)\n",
        "        self.change_wave_parameter(wave2, \"A\", 0.2)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight sum offset\n",
        "        self.play(FlashAround(low_vects, run_time=2))\n",
        "        self.wait()\n",
        "        show_rotation(4)\n",
        "\n",
        "        # Bigger and smaller shift\n",
        "        for value in [0.1, 0.3]:\n",
        "            self.change_wave_parameter(wave2, \"A\", value)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "    def get_axes(\n",
        "        self,\n",
        "        x_range=(0, 8),\n",
        "        y_range=(-1, 1),\n",
        "        width=11,\n",
        "        height=1.25\n",
        "    ):\n",
        "        result = Axes(\n",
        "            x_range, y_range,\n",
        "            width=width,\n",
        "            height=height\n",
        "        )\n",
        "        result.add_coordinate_labels(font_size=16, buff=0.15)\n",
        "        return result\n",
        "\n",
        "    def get_variable_wave(\n",
        "        self,\n",
        "        axes,\n",
        "        color=YELLOW,\n",
        "        func_name=\"f(t)\",\n",
        "        A=1.0,\n",
        "        omega=TAU,\n",
        "        phi=0.0,\n",
        "        index=\"\",\n",
        "        label_font_size=36,\n",
        "        parameter_font_size=24,\n",
        "        A_color=RED,\n",
        "        k_color=GOLD,\n",
        "        phi_color=PINK,\n",
        "        func_name_coords=(0.5, 1.25)\n",
        "    ):\n",
        "        A_tracker = ValueTracker(A)\n",
        "        k_tracker = ValueTracker(omega)\n",
        "        phi_tracker = ValueTracker(phi)\n",
        "        trackers = Group(A_tracker, k_tracker, phi_tracker)\n",
        "\n",
        "        A_tex = f\"A_{{{index}}}\"\n",
        "        omega_tex = Rf\"\\omega_{{{index}}}\"\n",
        "        phi_tex = Rf\"\\phi_{{{index}}}\"\n",
        "        t2c = {\n",
        "            A_tex: A_color,\n",
        "            omega_tex: k_color,\n",
        "            phi_tex: phi_color,\n",
        "        }\n",
        "\n",
        "        get_A = A_tracker.get_value\n",
        "        get_k = k_tracker.get_value\n",
        "        get_phi = phi_tracker.get_value\n",
        "\n",
        "        def func(x):\n",
        "            return get_A() * np.sin(get_k() * x + get_phi())\n",
        "\n",
        "        wave = axes.get_graph(\n",
        "            func,\n",
        "            stroke_color=color,\n",
        "            bind=True\n",
        "        )\n",
        "        labels = VGroup(*(\n",
        "            Tex(tex, font_size=parameter_font_size, t2c=t2c)\n",
        "            for tex in [\n",
        "                f\"{A_tex} = 1.00\",\n",
        "                f\"{omega_tex} = 1.00\",\n",
        "                f\"{phi_tex} = 1.00\",\n",
        "            ]\n",
        "        ))\n",
        "        labels.arrange(DOWN, aligned_edge=RIGHT)\n",
        "        labels.next_to(axes, LEFT, MED_LARGE_BUFF)\n",
        "        for label, tracker in zip(labels, trackers):\n",
        "            label.tracker = tracker\n",
        "            label.value = label.make_number_changeable(\"1.00\")\n",
        "            label.add_updater(lambda m: m.value.set_value(m.tracker.get_value()))\n",
        "\n",
        "        name_label = Tex(\n",
        "            fR\"{func_name} = {A_tex} \\sin({omega_tex} t + {phi_tex})\",\n",
        "            tex_to_color_map=t2c,\n",
        "            font_size=label_font_size,\n",
        "        )\n",
        "        name_label.move_to(axes.c2p(*func_name_coords), DL)\n",
        "        labels.add(name_label)\n",
        "\n",
        "        result = Group(wave, trackers, labels)\n",
        "        result.axes = axes\n",
        "        result.func = func\n",
        "        result.wave = wave\n",
        "        result.trackers = trackers\n",
        "        result.labels = labels\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_phasor(self, axes, wave_group, plane_height=2.0):\n",
        "        # Plane\n",
        "        plane = ComplexPlane(\n",
        "            (-1, 1), (-1, 1),\n",
        "            background_line_style=dict(stroke_color=GREY_B, stroke_width=1),\n",
        "            faded_line_style=dict(stroke_color=GREY_B, stroke_width=0.5, stroke_opacity=0.5),\n",
        "            faded_line_ratio=4,\n",
        "        )\n",
        "        plane.set_height(plane_height)\n",
        "        plane.next_to(axes, LEFT, buff=4.0)\n",
        "\n",
        "        # Initial arrow\n",
        "        graph, trackers, labels = wave_group\n",
        "        get_A, get_omega, get_phi = (t.get_value for t in trackers)\n",
        "\n",
        "        def get_z0():\n",
        "            return get_A() * np.exp(get_phi() * 1j)\n",
        "\n",
        "        vector = Arrow(\n",
        "            plane.n2p(0), plane.n2p(1),\n",
        "            buff=0,\n",
        "            stroke_color=GREY_B,\n",
        "            stroke_width=3,\n",
        "            stroke_opacity=0.5\n",
        "        )\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.n2p(0), plane.n2p(get_z0())\n",
        "        ))\n",
        "\n",
        "        # Arc\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            angle=get_phi(),\n",
        "            radius=min(plane_height / 6, 0.5 * vector.get_length()),\n",
        "            arc_center=plane.n2p(0)\n",
        "        ).set_stroke(WHITE, 1))\n",
        "\n",
        "        # t tracker\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        rot_vect = vector.copy()\n",
        "        rot_vect.set_stroke(graph.get_color(), opacity=1)\n",
        "\n",
        "        def get_z():\n",
        "            return np.exp(get_omega() * get_t() * 1j) * get_z0()\n",
        "\n",
        "        rot_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.n2p(0), plane.n2p(get_z())\n",
        "        ))\n",
        "\n",
        "        # Y glow dot\n",
        "        y_dot = GlowDot(color=graph.get_color())\n",
        "        y_dot.add_updater(lambda m: m.match_x(plane).match_y(rot_vect.get_end()))\n",
        "        y_line = Line()\n",
        "        y_line.set_stroke(WHITE, 1, 0.5)\n",
        "        y_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            rot_vect.get_end(), y_dot.get_center()\n",
        "        ))\n",
        "\n",
        "        # Result\n",
        "        result = Group(plane, vector, arc, t_tracker, rot_vect, y_dot, y_line)\n",
        "        result.plane = plane\n",
        "        result.vector = vector\n",
        "        result.arc = arc\n",
        "        result.t_tracker = t_tracker\n",
        "        result.rot_vect = rot_vect\n",
        "        result.y_dot = y_dot\n",
        "        result.y_line = y_line\n",
        "        result.get_z = get_z\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_output_indicator(self, axes, graph, t_tracker):\n",
        "        # Triangle\n",
        "        func = graph.underlying_function\n",
        "        get_t = t_tracker.get_value\n",
        "        triangle = ArrowTip(angle=PI / 2)\n",
        "        triangle.set_height(0.1)\n",
        "        triangle.set_fill(GREY_C)\n",
        "        triangle.add_updater(lambda m: m.move_to(axes.x_axis.n2p(get_t()), UP))\n",
        "\n",
        "        # Glow dot\n",
        "        dot = GlowDot(color=graph.get_color())\n",
        "        dot.add_updater(lambda m: m.move_to(axes.c2p(get_t(), func(get_t()))))\n",
        "\n",
        "        # Vertical line\n",
        "        v_line = Line()\n",
        "        v_line.set_stroke(WHITE, 1, 0.5)\n",
        "        v_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.x_axis.n2p(get_t()),\n",
        "            dot.get_center()\n",
        "        ))\n",
        "\n",
        "        result = Group(dot, v_line)\n",
        "        return result\n",
        "\n",
        "    def get_wave_change_animations(self, wave_group, parameter, value):\n",
        "        index = [\"A\", \"omega\", \"phi\"].index(parameter)\n",
        "        if len(parameter) > 1:\n",
        "            parameter = Rf\"\\{parameter}\"\n",
        "        wave, trackers, labels = wave_group\n",
        "\n",
        "        rect1 = SurroundingRectangle(labels[index])\n",
        "        rect2 = SurroundingRectangle(labels[3][parameter])\n",
        "        rect1.stretch(1.1, 0, about_edge=LEFT)\n",
        "        rect2.stretch(1.25, 0, about_edge=LEFT)\n",
        "        rects = VGroup(rect1, rect2)\n",
        "        rects.match_color(labels[index][0])\n",
        "\n",
        "        return [\n",
        "            VFadeInThenOut(rects, rate_func=lambda t: there_and_back(t)**0.5),\n",
        "            trackers[index].animate.set_value(value),\n",
        "        ]\n",
        "\n",
        "    def change_wave_parameter(self, wave_group, parameter, value, run_time=2):\n",
        "        self.play(\n",
        "            *self.get_wave_change_animations(wave_group, parameter, value, ),\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "    def change_all_parameters(self, wave_group, *values, **kwargs):\n",
        "        parameters = [\"A\", \"omega\", \"phi\"]\n",
        "        for parameter, value in zip(parameters, values):\n",
        "            if value is not None:\n",
        "                self.change_wave_parameter(wave_group, parameter, value)\n",
        "\n",
        "\n",
        "class AddTwoRotatingVectors(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class WavePlusLayerInfluence(InteractiveScene):\n",
        "    default_frame_orientation = (-90, 0, 90)\n",
        "\n",
        "    def construct(self):\n",
        "        # Initialize axes\n",
        "        frame = self.frame\n",
        "        boxes = FullScreenRectangle().replicate(3)\n",
        "        boxes.set_height(FRAME_HEIGHT / 3, stretch=True)\n",
        "        boxes.arrange(DOWN, buff=0)\n",
        "\n",
        "        x_range = (-12, 12)\n",
        "        y_range = (-1, 1)\n",
        "        z_range = (-1, 1)\n",
        "        top_axes, mid_axes, low_axes = (\n",
        "            ThreeDAxes(x_range, y_range, z_range),\n",
        "            Axes(x_range, y_range),\n",
        "            Axes(x_range, y_range),\n",
        "        )\n",
        "        all_axes = VGroup(top_axes, mid_axes, low_axes)\n",
        "        all_axes.move_to(boxes[1])\n",
        "        low_axes.move_to(boxes[2])\n",
        "        for axes in all_axes:\n",
        "            axes.set_stroke(opacity=0)\n",
        "            axes.x_axis.set_stroke(opacity=0.5)\n",
        "\n",
        "        # Initialize labels\n",
        "        text_kw = dict(font_size=36)\n",
        "        labels = VGroup(\n",
        "            Text(\"Incoming light\", **text_kw),\n",
        "            Text(\"Wave from layer oscillations\", **text_kw),\n",
        "            Text(\"Net effect\", **text_kw),\n",
        "        )\n",
        "        for label, box in zip(labels, boxes):\n",
        "            label.next_to(box.get_corner(UL), DR, buff=MED_SMALL_BUFF)\n",
        "        labels[2].shift(0.25 * UP)\n",
        "\n",
        "        # Initialize waves\n",
        "        wave1 = OscillatingWave(\n",
        "            top_axes,\n",
        "            y_amplitude=0.75,\n",
        "            z_amplitude=0.0,\n",
        "            wave_len=4.0,\n",
        "            speed=1.5,\n",
        "        )\n",
        "        wave2_scale_tracker = ValueTracker(0.2)\n",
        "\n",
        "        def wave2_func(x):\n",
        "            offset_x = np.abs(x) + wave1.wave_len / 4\n",
        "            y, z = wave1.xt_to_yz(offset_x, wave1.time)\n",
        "            return wave2_scale_tracker.get_value() * y\n",
        "\n",
        "        def sum_func(x):\n",
        "            return wave1.xt_to_yz(x, wave1.time)[0] + wave2_func(x)\n",
        "\n",
        "\n",
        "        wave2 = mid_axes.get_graph(wave2_func, bind=True)\n",
        "        wave2.set_stroke(BLUE, 2)\n",
        "        wave3 = low_axes.get_graph(sum_func, bind=True)\n",
        "        wave3.set_stroke(TEAL, 2)\n",
        "\n",
        "        # Vect waves\n",
        "        field_kw = dict(stroke_width=2, stroke_opacity=0.5, tip_width_ratio=3)\n",
        "        vect_wave1 = OscillatingFieldWave(top_axes, wave1, **field_kw)\n",
        "        vect_wave2 = GraphAsVectorField(\n",
        "            mid_axes, wave2_func,\n",
        "            stroke_color=wave2.get_color(),\n",
        "            **field_kw\n",
        "        )\n",
        "        vect_wave3 = GraphAsVectorField(\n",
        "            low_axes, sum_func,\n",
        "            stroke_color=wave3.get_color(),\n",
        "            **field_kw\n",
        "        )\n",
        "        for vect_wave in [vect_wave1, vect_wave2, vect_wave3]:\n",
        "            vect_wave.insert_updater(lambda m: m.reset_sample_points(), index=0)\n",
        "\n",
        "        wave1_group = VGroup(wave1, vect_wave1)\n",
        "        wave2_group = VGroup(wave2, vect_wave2)\n",
        "        wave3_group = VGroup(wave3, vect_wave3)\n",
        "\n",
        "        # Layers of charges\n",
        "        layer_xs = np.arange(0, 6, 0.25)\n",
        "        layers = Group()\n",
        "        for x in layer_xs:\n",
        "            charges = DotCloud(color=BLUE)\n",
        "            charges.to_grid(31, 15)\n",
        "            charges.make_3d()\n",
        "            charges.set_shape(3, 3)\n",
        "            charges.set_radius(0.035)\n",
        "            charges.set_opacity(0.5)\n",
        "            charges.rotate(90 * DEGREES, UP)\n",
        "            charges.sort_points(lambda p: np.dot(p, OUT + UP))\n",
        "            charges.x = x\n",
        "            charges.amplitude_tracker = ValueTracker(0)\n",
        "            charges.add_updater(lambda m: m.move_to(mid_axes.c2p(\n",
        "                m.x, m.amplitude_tracker.get_value() * wave1.xt_to_yz(m.x, wave1.time)[0], 0,\n",
        "            )))\n",
        "            layers.add(charges)\n",
        "\n",
        "        # Glass\n",
        "        glass = VCube()\n",
        "        glass.set_fill(opacity=0.25)\n",
        "        glass.deactivate_depth_test()                                                              \n",
        "        glass.set_shading(0.5, 0.5, 0)\n",
        "        buff = 0.1\n",
        "        glass.set_shape(*(\n",
        "            dim + buff\n",
        "            for dim in layers.get_shape()\n",
        "        ))\n",
        "        glass.move_to(layers, LEFT)\n",
        "        glass.sort(lambda p: -p[0])\n",
        "        glass.set_stroke(WHITE, 0.5, 0.5)\n",
        "\n",
        "        # Show initial wave, then add layers\n",
        "        frame = self.frame\n",
        "        frame.reorient(-135, 20, 135)\n",
        "\n",
        "        self.add(top_axes)\n",
        "        self.add(wave1, vect_wave1)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(glass, time_span=(0, 2)),\n",
        "            frame.animate.reorient(-110, 10, 110).set_anim_args(run_time=4),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                layer.amplitude_tracker.animate.set_value(0.1)\n",
        "                for layer in layers\n",
        "            ), lag_ratio=0, time_span=(0, 2)),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(layer, suspend_mobject_updating=False)\n",
        "                for layer in layers\n",
        "            ), lag_ratio=0, time_span=(0, 2)),\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-90, -40, 90),\n",
        "            FadeOut(glass),\n",
        "            run_time=9\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Go back to just one layer\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeOut(charges, suspend_mobject_updating=False)\n",
        "                for charges in layers[1:]\n",
        "            ), run_time=5, lag_ratio=0.25),\n",
        "            layers[0].amplitude_tracker.animate.set_value(0.2),\n",
        "            self.frame.animate.reorient(-90, -20, 90),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Add the second order wave, then separate\n",
        "        self.play(\n",
        "            VFadeIn(wave2_group),\n",
        "            FadeIn(mid_axes),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            top_axes.animate.move_to(boxes[0], DOWN),\n",
        "            frame.animate.reorient(-90, 0, 90).set_focal_distance(100),\n",
        "            LaggedStartMap(FadeIn, labels[:2], shift=UP),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Show sum (todo, add + and =)\n",
        "        plus, eq = plus_eq = Tex(\"+=\", font_size=72) \n",
        "        eq.rotate(90 * DEGREES)\n",
        "        plus.move_to(all_axes[0:2])\n",
        "        eq.move_to(all_axes[1:3])\n",
        "        plus_eq.set_x(FRAME_WIDTH / 4)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, plus_eq),\n",
        "            ShowCreation(low_axes),\n",
        "        )\n",
        "        self.play(\n",
        "            VFadeIn(wave3_group),\n",
        "            Write(labels[2]),\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "        # Comment on reflected light\n",
        "        reflection_label = VGroup(\n",
        "            Vector(2 * LEFT),\n",
        "            Text(\"Reflected light\", font_size=36),\n",
        "        )\n",
        "        reflection_label.arrange(RIGHT)\n",
        "        reflection_label.next_to(mid_axes.get_origin(), LEFT, buff=0.75)\n",
        "        reflection_label.shift(0.5 * DOWN)\n",
        "        reflection_label.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(reflection_label[0]),\n",
        "            Write(reflection_label[1]),\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Cover left half\n",
        "        cover = FullScreenFadeRectangle()\n",
        "        cover.set_fill(BLACK, 0.9)\n",
        "        cover.stretch(0.5, 0, about_edge=LEFT)\n",
        "\n",
        "        self.add(cover, charges, labels)\n",
        "        self.play(\n",
        "            FadeOut(reflection_label),\n",
        "            FadeIn(cover),\n",
        "            plus_eq.animate.set_x(1.5),\n",
        "            frame.animate.set_x(0.5 * FRAME_WIDTH - 2),\n",
        "            *(\n",
        "                label.animate.set_x(FRAME_WIDTH - 2.5, RIGHT)\n",
        "                for label in labels\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(9)\n",
        "\n",
        "        # Compare\n",
        "        wave1.stop_clock()\n",
        "        wave1_copy = wave1.copy()\n",
        "        wave1_copy.clear_updaters()\n",
        "        wave1_copy.set_stroke(width=3)\n",
        "\n",
        "        self.wait()\n",
        "        self.add(wave1_copy, cover, charges)\n",
        "        self.play(\n",
        "            wave1_copy.animate.match_y(wave3),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Indicate tiny change\n",
        "        def find_peak(wave, threshold=1e-2):\n",
        "            points = wave.get_points()\n",
        "            sub_points = points[int(0.6 * len(points)):int(0.8 * len(points))]\n",
        "            top_y = wave.get_top()[1]\n",
        "            index = np.argmax(sub_points[:, 1])\n",
        "            return sub_points[index]\n",
        "\n",
        "        line = Line(find_peak(wave3), find_peak(wave1_copy))\n",
        "        shift_arrow = Vector(\n",
        "            line.get_length() * LEFT * 2,\n",
        "            stroke_width=3,\n",
        "            max_tip_length_to_length_ratio=10,\n",
        "        )\n",
        "        shift_arrow.next_to(line, UP, buff=0.2)\n",
        "        shift_label = Text(\"shift\", font_size=24)\n",
        "        always(shift_label.next_to, shift_arrow, UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(shift_arrow),\n",
        "            Write(shift_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Play with different strengths\n",
        "        net_stretch = 1.0\n",
        "        for stretch_factor in [3.0, 0.5, 2.0, 0.5, 1.0]:\n",
        "            stretch = stretch_factor / net_stretch\n",
        "            net_stretch = stretch_factor\n",
        "\n",
        "            scale_arrows = VGroup(Vector(0.5 * UP), Vector(0.5 * DOWN))\n",
        "            scale_arrows.arrange(DOWN if stretch > 1 else UP, buff=1.0)\n",
        "            scale_arrows.move_to(mid_axes.c2p(2, 0))\n",
        "            scale_arrows.set_stroke(opacity=1)\n",
        "            scale_arrows.save_state()\n",
        "            scale_arrows.stretch(0.5 if stretch > 1 else 1.5, 1)\n",
        "            scale_arrows.set_stroke(opacity=0)\n",
        "\n",
        "            self.play(\n",
        "                Restore(scale_arrows),\n",
        "                wave2_scale_tracker.animate.set_value(stretch * wave2_scale_tracker.get_value()),\n",
        "                shift_arrow.animate.stretch(stretch, 0, about_edge=RIGHT),\n",
        "            )\n",
        "            self.play(FadeOut(scale_arrows))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            wave2_scale_tracker.animate.set_value(0.2),\n",
        "            FadeOut(wave1_copy),\n",
        "            FadeOut(shift_arrow),\n",
        "            FadeOut(shift_label),\n",
        "        )\n",
        "\n",
        "        # Restart\n",
        "        wave1.start_clock()\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class Pulse(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup axes\n",
        "        n_parts = 10\n",
        "        x_max = 4\n",
        "        left_axes_group = VGroup(*(\n",
        "            Axes(\n",
        "                (0, x_max), (-1, 1),\n",
        "                width=0.5 * FRAME_WIDTH - 2,\n",
        "                height=1,\n",
        "                num_sampled_graph_points_per_tick=20,\n",
        "            )\n",
        "            for _ in range(n_parts)\n",
        "        ))\n",
        "        left_axes_group.arrange(DOWN, buff=0.75)\n",
        "        left_axes_group.set_height(FRAME_HEIGHT - 1)\n",
        "        left_axes_group.to_edge(LEFT)\n",
        "\n",
        "        right_axes = Axes((0, x_max), (-1, 1), width=0.5 * FRAME_WIDTH - 1, height=3)\n",
        "        right_axes.to_edge(RIGHT)\n",
        "\n",
        "        brace = Brace(left_axes_group, RIGHT, buff=0.5)\n",
        "        arrow = Arrow(brace, right_axes)\n",
        "        sigma = Tex(R\"\\Sigma\", font_size=72).next_to(arrow, UP)\n",
        "\n",
        "        self.add(left_axes_group)\n",
        "        self.add(right_axes)\n",
        "        self.add(brace, arrow, sigma)\n",
        "\n",
        "        # Graphs\n",
        "        f0 = 6\n",
        "        sigma = 2\n",
        "        frequencies = np.linspace(0, 2 * f0, n_parts + 1)[1:]\n",
        "        weights = 0.25 * np.exp(-0.5 * ((frequencies - f0) / sigma) ** 2)\n",
        "        speeds = np.linspace(8, 10, n_parts)\n",
        "        time_tracker = ValueTracker(0)\n",
        "        colors = color_gradient([BLUE, YELLOW], n_parts)\n",
        "\n",
        "        left_graphs = VGroup(*(\n",
        "            self.create_graph(axes, freq, speed, color, time_tracker)\n",
        "            for axes, freq, speed, color in zip(\n",
        "                left_axes_group,\n",
        "                frequencies,\n",
        "                speeds,\n",
        "                colors,\n",
        "            )\n",
        "        ))\n",
        "\n",
        "        def sum_func(x):\n",
        "            time = time_tracker.get_value()\n",
        "            return sum(\n",
        "                weight * self.wave_func(x, freq, speed, time)\n",
        "                for weight, freq, speed in zip(weights, frequencies, speeds)\n",
        "            )\n",
        "\n",
        "        sum_graph = right_axes.get_graph(sum_func, bind=True)\n",
        "        sum_graph.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.add(left_graphs)\n",
        "        self.add(sum_graph)\n",
        "\n",
        "        final_time = 20.0\n",
        "        time_tracker.set_value(0)\n",
        "        self.play(\n",
        "            time_tracker.animate.increment_value(final_time),\n",
        "            rate_func=linear,\n",
        "            run_time=final_time,\n",
        "        )\n",
        "\n",
        "\n",
        "    def wave_func(self, x, freq, speed, time):\n",
        "        return np.cos(freq * x - speed * time)\n",
        "\n",
        "    def create_graph(self, axes, freq, speed, color, time_tracker):\n",
        "        return axes.get_graph(\n",
        "            lambda x: self.wave_func(x, freq, speed, time_tracker.get_value()),\n",
        "            stroke_color=color,\n",
        "            stroke_width=2,\n",
        "            bind=True\n",
        "        )\n",
        "\n"
    ]
}