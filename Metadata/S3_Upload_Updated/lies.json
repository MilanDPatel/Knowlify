{
    "topic": "The mathematical concept being demonstrated is the visualization of a sphere using parametric surfaces. The code creates",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "EQUATOR_STYLE = dict(stroke_color=TEAL, stroke_width=2)\n",
        "\n",
        "\n",
        "def get_sphere_slices(radius=1.0, n_slices=20):\n",
        "    delta_theta = TAU / n_slices\n",
        "    north_slices = Group(*(\n",
        "        ParametricSurface(\n",
        "            uv_func=lambda u, v: [\n",
        "                radius * math.sin(v) * math.cos(u),\n",
        "                radius * math.sin(v) * math.sin(u),\n",
        "                radius * math.cos(v),\n",
        "            ],\n",
        "            u_range=[theta, theta + delta_theta],\n",
        "            v_range=[0, PI / 2],\n",
        "            resolution=(4, 25),\n",
        "        )\n",
        "        for theta in np.arange(0, TAU, delta_theta)\n",
        "    ))\n",
        "    north_slices.set_x(0)\n",
        "    color_slices(north_slices)\n",
        "\n",
        "    equator = Circle(**EQUATOR_STYLE)\n",
        "    equator.insert_n_curves(100)\n",
        "    equator.match_width(north_slices)\n",
        "    equator.move_to(ORIGIN)\n",
        "    equator.apply_depth_test()\n",
        "\n",
        "    return Group(north_slices, get_south_slices(north_slices, dim=2), equator)\n",
        "\n",
        "\n",
        "def get_flattened_slices(radius=1.0, n_slices=20, straightened=True):\n",
        "    slc = ParametricSurface(\n",
        "        # lambda u, v: [u * v, 1 - v, 0],\n",
        "        lambda u, v: [u * math.sin(v * PI / 2), 1 - v, 0],\n",
        "        u_range=[-1, 1],\n",
        "        v_range=[0, 1],\n",
        "        resolution=(4, 25),\n",
        "    )\n",
        "    slc.set_width(TAU / n_slices, stretch=True)\n",
        "    slc.set_height(radius * PI / 2)\n",
        "    north_slices = slc.get_grid(1, n_slices, buff=0)\n",
        "    north_slices.move_to(ORIGIN, DOWN)\n",
        "    color_slices(north_slices)\n",
        "    equator = Line(\n",
        "        north_slices.get_corner(DL), north_slices.get_corner(DR),\n",
        "        **EQUATOR_STYLE,\n",
        "    )\n",
        "\n",
        "    return Group(north_slices, get_south_slices(north_slices, dim=1), equator)\n",
        "\n",
        "\n",
        "def color_slices(slices, colors=(BLUE_D, BLUE_E)):\n",
        "    for slc, color in zip(slices, it.cycle([BLUE_D, BLUE_E])):\n",
        "        slc.set_color(color)\n",
        "    return slices\n",
        "\n",
        "\n",
        "def get_south_slices(north_slices, dim):\n",
        "    ss = north_slices.copy().stretch(-1, dim, about_point=ORIGIN)\n",
        "    for slc in ss:\n",
        "        slc.reverse_points()\n",
        "    return ss\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class PreviewThreeExamples(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.add(FullScreenRectangle())\n",
        "        rects = Rectangle(3.5, 4.5).replicate(3)\n",
        "        rects.set_stroke(WHITE, 2)\n",
        "        rects.set_fill(BLACK, 1)\n",
        "        rects.arrange(RIGHT, buff=0.75)\n",
        "        rects.to_edge(DOWN, buff=0.25)\n",
        "\n",
        "        # Titles\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"S.A. = $\\\\pi^2 R^2$\"),\n",
        "            OldTex(\"\\\\pi = 4\").scale(1.5),\n",
        "            Text(\"All triangles\\nare isosceles\"),\n",
        "        )\n",
        "        titles.set_width(rects[0].get_width())\n",
        "        for title, rect in zip(titles, rects):\n",
        "            title.next_to(rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, rects, lag_ratio=0.3),\n",
        "            LaggedStartMap(FadeIn, titles, shift=0.25 * UP, lag_ratio=0.3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Increasing subtlety\n",
        "        arrow = Arrow(LEFT, RIGHT, stroke_width=10)\n",
        "        arrow.set_width(FRAME_WIDTH - 1)\n",
        "        arrow.next_to(titles, UP)\n",
        "        arrow.set_stroke(opacity=(0.5, 0.9, 1))\n",
        "        words = Text(\"Increasingly subtle\", font_size=72, color=YELLOW)\n",
        "        words.next_to(arrow, UP)\n",
        "        VGroup(arrow, words).to_edge(UP)\n",
        "        arrow.set_x(0)\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(words, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Intro(TeacherStudentsScene):\n",
        "    CONFIG = {\"background_color\": BLACK}\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        ss = self.students\n",
        "\n",
        "        self.play(morty.change(\"raise_right_hand\"))\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"angry\", \"confused\",\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ss[0].change(\"worried\", self.screen))\n",
        "        self.wait()\n",
        "        self.play(ss[1].change(\"pondering\", self.screen))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class SimpleSphereQuestion(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Intro statement\n",
        "        text = OldTexText(\"A ``proof'' of a formula for\\\\\\\\the surface area of a sphere\")\n",
        "        text.set_stroke(WHITE, 0)\n",
        "\n",
        "        rect = Rectangle(width=TAU, height=TAU / 4)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(GREY_E, 1)\n",
        "        rect.set_width(FRAME_WIDTH)\n",
        "        self.add(rect)\n",
        "\n",
        "        morty = Mortimer(height=1.5)\n",
        "        randy = Randolph(height=1.5)\n",
        "        morty.next_to(text, RIGHT)\n",
        "        randy.next_to(text, LEFT)\n",
        "        VGroup(morty, randy).align_to(rect, DOWN).shift(0.1 * UP)\n",
        "        self.add(morty, randy)\n",
        "\n",
        "        self.play(\n",
        "            Write(text),\n",
        "            morty.change(\"raise_right_hand\", text),\n",
        "            randy.change(\"thinking\", text)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SphereExample(InteractiveScene):\n",
        "    radius = 2.0\n",
        "    n_slices = 20\n",
        "    slice_stroke_width = 1.0\n",
        "    # show_true_slices = False\n",
        "    show_true_slices = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        frame.set_focal_distance(100)\n",
        "        light = self.camera.light_source\n",
        "        light.move_to([-10, 2, 5])\n",
        "\n",
        "        # Create the sphere\n",
        "        img_path = \"/Users/grant/Dropbox/3Blue1Brown/videos/2022/visual_proofs/lies/images/SimpleSphereQuestion.png\"\n",
        "        radius = 2.5\n",
        "        sphere = TexturedSurface(Sphere(radius=radius), img_path)\n",
        "        sphere.set_opacity(1.0)\n",
        "        sphere.rotate(91 * DEGREES, OUT).rotate(80 * DEGREES, LEFT)\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(BLUE_B, 1, 0.5)\n",
        "        banner = TexturedSurface(Surface(resolution=sphere.resolution), img_path)\n",
        "        banner.set_width(FRAME_WIDTH)\n",
        "        banner.set_height(FRAME_WIDTH / 4, stretch=True)\n",
        "        banner.center()\n",
        "        banner.set_gloss(0)\n",
        "        banner.set_reflectiveness(0)\n",
        "        banner.set_shadow(0)\n",
        "\n",
        "        self.add(banner)\n",
        "        self.play(ReplacementTransform(banner, sphere, run_time=2))\n",
        "        self.play(Write(mesh, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Slice sphere\n",
        "        slices = get_sphere_slices(n_slices=self.n_slices)\n",
        "        slices.rotate(90 * DEGREES, OUT).rotate(80 * DEGREES, LEFT)\n",
        "        slices.scale(radius)\n",
        "        slice_highlights = slices[0][len(slices[0]) // 4:3 * len(slices[0]) // 4].copy().set_color(YELLOW)\n",
        "        slice_highlights.scale(1.01, about_point=ORIGIN)\n",
        "\n",
        "        flat_slices = get_flattened_slices(n_slices=self.n_slices)\n",
        "        flat_slices.to_edge(RIGHT, buff=1.0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(slices),\n",
        "            FadeOut(sphere, lag_ratio=0, scale=0.95),\n",
        "            FadeOut(mesh, lag_ratio=0, scale=0.95),\n",
        "        )\n",
        "        self.play(LaggedStart(*(\n",
        "            FadeIn(sh, rate_func=there_and_back)\n",
        "            for sh in slice_highlights\n",
        "        ), lag_ratio=0.35, run_time=1.5))\n",
        "        self.remove(slice_highlights)\n",
        "        self.wait()\n",
        "\n",
        "        # Unfold sphere\n",
        "        self.play(slices.animate.scale(1 / radius).to_corner(UL).shift(IN))\n",
        "        pre_slices = slices.copy()\n",
        "        self.add(pre_slices, slices)\n",
        "        for slcs in pre_slices:\n",
        "            for slc in slcs:\n",
        "                slc.set_color(interpolate_color(slc.get_color(), BLACK, 0.0))\n",
        "        flat_slices[2].shift(0.01 * OUT)\n",
        "        self.play(\n",
        "            Transform(slices[0], flat_slices[0]),\n",
        "            Transform(slices[2], flat_slices[2]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                slices[1], flat_slices[1],\n",
        "                run_time=2,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show width line\n",
        "        slc = flat_slices[0][0]\n",
        "        v_tracker = ValueTracker(0)\n",
        "        width_line = Line(LEFT, RIGHT)\n",
        "        width_line.set_stroke(RED, 3)\n",
        "\n",
        "        def update_width_line(width_line, slc=slc, v_tracker=v_tracker):\n",
        "            v = v_tracker.get_value()\n",
        "            width_line.set_width(1.2 * slc.get_width() * math.sin(v) + 1e-2)\n",
        "            width_line.move_to(interpolate(slc.get_top(), slc.get_bottom(), v))\n",
        "\n",
        "        width_line.add_updater(update_width_line)\n",
        "        self.add(width_line)\n",
        "        self.play(v_tracker.animate.set_value(1), run_time=3)\n",
        "        self.play(v_tracker.animate.set_value(0), run_time=3)\n",
        "        self.remove(width_line)\n",
        "\n",
        "        # Interlink\n",
        "        tri_template = Triangle(start_angle=90 * DEGREES)\n",
        "        tri_template.set_width(2).set_height(1, stretch=True)\n",
        "        tri_template.move_to(ORIGIN, DOWN)\n",
        "\n",
        "        if self.show_true_slices:\n",
        "            tri_template = VMobject()\n",
        "            dtheta = TAU / self.n_slices\n",
        "            curve = ParametricCurve(lambda phi: [-math.sin(phi) * dtheta / 2, PI / 2 - phi, 0], t_range=(0, PI / 2))\n",
        "            curve2 = curve.copy().stretch(-1, 0, about_point=ORIGIN)\n",
        "            curve2.reverse_points()\n",
        "            tri_template.append_vectorized_mobject(curve)\n",
        "            tri_template.add_line_to(curve2.get_start())\n",
        "            tri_template.append_vectorized_mobject(curve2)\n",
        "\n",
        "        vslices = VGroup(*(\n",
        "            VGroup(*(\n",
        "                tri_template.copy().rotate(rot).replace(slc, stretch=True)\n",
        "                for slc in hemi\n",
        "            ))\n",
        "            for rot, hemi in zip([0, PI], slices)\n",
        "        ))\n",
        "        for hemi, vhemi in zip(slices, vslices):\n",
        "            for slc, vslc in zip(hemi, vhemi):\n",
        "                vslc.set_fill(slc.get_color(), 1)\n",
        "                vslc.set_stroke(WHITE, 0)\n",
        "        slices[2].deactivate_depth_test()\n",
        "        vslices.add(slices[2].copy())\n",
        "\n",
        "        vslices[1].move_to(vslices[0][0].get_top(), UL)\n",
        "        vslices[1].set_stroke(WHITE, self.slice_stroke_width)\n",
        "        vslices.center()\n",
        "\n",
        "        self.play(FadeTransformPieces(slices, vslices))\n",
        "        self.wait()\n",
        "\n",
        "        if self.show_true_slices:\n",
        "            self.play(vslices.animate.set_opacity(0.5))\n",
        "\n",
        "        # Show equator\n",
        "        circ_label = Text(\"Circumference\")\n",
        "        circ_label.next_to(vslices[2], DOWN)\n",
        "        circ_formula = OldTex(\"2\\\\pi R\")\n",
        "        circ_formula.next_to(vslices[2], DOWN)\n",
        "        circ_formula.set_stroke(WHITE, 0)\n",
        "        equator = pre_slices[2]\n",
        "\n",
        "        vslices[2].set_stroke()\n",
        "        self.play(\n",
        "            Write(circ_label),\n",
        "            VShowPassingFlash(\n",
        "                vslices[2].copy().set_stroke(YELLOW, 5).insert_n_curves(20),\n",
        "                time_width=1.5,\n",
        "                run_time=1.5,\n",
        "            ),\n",
        "            vslices[2].animate.set_color(YELLOW),\n",
        "        )\n",
        "        self.play(equator.animate.shift(1.5 * DOWN).set_color(YELLOW))\n",
        "        self.wait()\n",
        "        self.play(equator.animate.shift(1.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(circ_formula),\n",
        "            circ_label.animate.next_to(circ_formula, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Arc height\n",
        "        edge = Line(vslices.get_corner(DL), vslices[0][0].get_top())\n",
        "        edge.set_stroke(PINK, 2)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(edge.get_center(), LEFT, SMALL_BUFF)\n",
        "        arc = Arc(0, 90 * DEGREES)\n",
        "        arc.match_style(edge)\n",
        "        arc.set_height(pre_slices.get_height() / 2)\n",
        "        arc.rotate(-10 * DEGREES, LEFT)\n",
        "        arc.shift(pre_slices[0][0].get_points()[0] - arc.get_end())\n",
        "\n",
        "        arc_form = OldTex(\"{\\\\pi \\\\over 2} R\")\n",
        "        arc_form.scale(0.5)\n",
        "        arc_form.next_to(arc.pfp(0.5), RIGHT)\n",
        "        arc_form2 = arc_form.copy()\n",
        "        arc_form2.scale(1.5)\n",
        "        arc_form2.move_to(q_marks, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(edge),\n",
        "            Write(q_marks),\n",
        "        )\n",
        "        self.play(WiggleOutThenIn(edge, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(edge, arc))\n",
        "        self.play(Write(arc_form))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(arc_form, arc_form2),\n",
        "            FadeOut(q_marks, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Area\n",
        "        arc_tex = \"{\\\\pi \\\\over 2} R\"\n",
        "        circ_tex = \"2\\\\pi R\"\n",
        "        eq_parts = [\"\\\\text{Area}\", \"=\", arc_tex, \"\\\\times\", circ_tex, \"=\", \"\\\\pi^2 R^2\"]\n",
        "        equation = Tex(\" \".join(eq_parts), isolate=eq_parts)\n",
        "        equation.center().to_edge(UP, buff=LARGE_BUFF)\n",
        "        rect = SurroundingRectangle(equation.select_parts(eq_parts[-1]))\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            Write(equation.select_parts(\"\\\\text{Area}\")),\n",
        "            Write(equation.select_parts(\"=\")[0]),\n",
        "            Write(equation.select_parts(\"\\\\times\")),\n",
        "            TransformFromCopy(arc_form2, equation.select_parts(arc_tex)),\n",
        "            TransformFromCopy(circ_formula, equation.select_parts(circ_tex)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equation.select_parts(\"=\")[1]),\n",
        "            Write(equation.select_parts(\"\\\\pi^2 R^2\")),\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SphereExample50(SphereExample):\n",
        "    n_slices = 50\n",
        "    slice_stroke_width = 0.5\n",
        "\n",
        "\n",
        "class SphereExample100(SphereExample):\n",
        "    n_slices = 100\n",
        "    slice_stroke_width = 0.1\n",
        "\n",
        "\n",
        "class CallOutSphereExampleAsWrong(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class SomethingSomethingLimits(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.says(\"Something,\\nsomething\\nlimits!\", mode=\"shruggie\"),\n",
        "            self.change_students(\"hesitant\", \"angry\", \"erm\")\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PiEqualsFourOverlay(InteractiveScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Fine, as long as\\\\\\\\$\\\\pi = 4$\")\n",
        "        words.scale(2)\n",
        "        words.set_color(RED)\n",
        "        self.play(Write(words, stroke_color=WHITE))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Proof2Slide(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.add(FullScreenRectangle())\n",
        "        title = OldTexText(\"``Proof'' \\\\#2\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "        subtitle = OldTex(\"\\\\pi = 4\", font_size=60)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        subtitle.set_color(RED)\n",
        "        self.add(title, subtitle)\n",
        "\n",
        "        # Number line\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        radius = 1.25\n",
        "\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.to_edge(DOWN)\n",
        "        circle.set_fill(BLUE_E, 1)\n",
        "        circle.set_stroke(width=0)\n",
        "        circle.rotate(-TAU / 4)\n",
        "\n",
        "        nl = NumberLine((0, 4), width=4 * circle.get_width())\n",
        "        nl.add_numbers()\n",
        "        nl.move_to(2 * DOWN)\n",
        "\n",
        "        v_lines = VGroup(*(\n",
        "            DashedLine(ORIGIN, circle.get_height() * UP).move_to(nl.n2p(x), DOWN)\n",
        "            for x in range(5)\n",
        "        ))\n",
        "        v_lines.set_stroke(GREY_B, 1)\n",
        "\n",
        "        circum = circle.copy()\n",
        "        circum.set_fill(opacity=0)\n",
        "        circum.set_stroke(YELLOW, 2)\n",
        "\n",
        "        def update_circum(circum):\n",
        "            line = Line(nl.n2p(0), nl.n2p(get_t() * 4))\n",
        "            arc = Arc(start_angle=-TAU / 4, angle=TAU * (1 - get_t()), radius=radius)\n",
        "            arc.shift(circle.get_bottom() - arc.get_start())\n",
        "            circum.set_points(np.vstack([line.get_points(), arc.get_points()]))\n",
        "            return circum\n",
        "\n",
        "        circum.add_updater(update_circum)\n",
        "\n",
        "        radial_line = Line(circle.get_bottom(), circle.get_center(), stroke_width=1)\n",
        "        radial_line.add_updater(lambda m: m.set_angle(TAU * (0.75 - get_t())).shift(circle.get_center() - m.get_start()))\n",
        "\n",
        "        circle.move_to(nl.n2p(0.5), DOWN)\n",
        "\n",
        "        self.add(nl, circle, radial_line, circum)\n",
        "        self.play(LaggedStartMap(ShowCreation, v_lines, run_time=1))\n",
        "\n",
        "        # Roll\n",
        "        self.play(circle.animate.set_x(nl.n2p(0)[0]))\n",
        "        self.play(\n",
        "            circle.animate.set_x(nl.n2p(4)[0]),\n",
        "            t_tracker.animate.set_value(1),\n",
        "            rate_func=linear,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CircleExample(InteractiveScene):\n",
        "    n_slices = 20\n",
        "    sector_stroke_width = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        radius = 2.0\n",
        "\n",
        "        # Slice up circle\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "        circle.set_fill(BLUE_E, 1)\n",
        "\n",
        "        question = Text(\"Area?\")\n",
        "        question.next_to(circle, UP)\n",
        "\n",
        "        sectors = self.get_sectors(circle, n_slices=self.n_slices)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(circle),\n",
        "            Write(question, stroke_color=WHITE)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(sectors))\n",
        "        self.remove(circle)\n",
        "\n",
        "        # Lay out sectors\n",
        "        laid_sectors = sectors.copy()\n",
        "        N = len(sectors)\n",
        "        dtheta = TAU / N\n",
        "        angles = np.arange(0, TAU, dtheta)\n",
        "        for sector, angle in zip(laid_sectors, angles):\n",
        "            sector.rotate(-90 * DEGREES - angle - dtheta / 2)\n",
        "\n",
        "        laid_sectors.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "        laid_sectors.move_to(1.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            sectors.animate.scale(0.7).to_corner(UL),\n",
        "            question.animate.to_corner(UR),\n",
        "        )\n",
        "        self.play(TransformFromCopy(sectors, laid_sectors, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Interslice\n",
        "        lh, rh = laid_sectors[:N // 2], laid_sectors[N // 2:]\n",
        "        lh.generate_target()\n",
        "        rh.generate_target()\n",
        "        rh.target.rotate(PI)\n",
        "        rh.target.move_to(lh[0].get_top(), UL)\n",
        "        VGroup(lh.target, rh.target).set_x(0)\n",
        "        rh.target.shift(UP)\n",
        "        lh.target.shift(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(lh, run_time=1.5),\n",
        "            MoveToTarget(rh, run_time=1.5, path_arc=PI),\n",
        "        )\n",
        "        self.play(\n",
        "            lh.animate.shift(UP),\n",
        "            rh.animate.shift(DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*(\n",
        "            LaggedStart(*(\n",
        "                VShowPassingFlash(piece, time_width=2)\n",
        "                for piece in group.copy().set_fill(opacity=0).set_stroke(RED, 5)\n",
        "            ), lag_ratio=0.02, run_time=4)\n",
        "            for group in [laid_sectors, sectors]\n",
        "        ))\n",
        "\n",
        "        # Side lengths\n",
        "        ulp = lh[0].get_top()\n",
        "        width_line = Line(ulp, rh.get_corner(UR))\n",
        "        width_line.set_stroke(YELLOW, 3)\n",
        "        width_form = OldTex(\"\\\\pi R\")\n",
        "        width_form.next_to(width_line, UP)\n",
        "\n",
        "        semi_circ = Arc(angle=PI)\n",
        "        semi_circ.set_stroke(YELLOW, 3)\n",
        "        semi_circ.replace(sectors)\n",
        "        semi_circ.move_to(sectors, UP)\n",
        "\n",
        "        height_line = Line(lh.get_corner(DL), ulp)\n",
        "        height_line.set_stroke(PINK, 3)\n",
        "        height_form = OldTex(\"R\")\n",
        "        height_form.next_to(height_line, LEFT)\n",
        "\n",
        "        radial_line = Line(sectors.get_center(), sectors.get_right())\n",
        "        radial_line.match_style(height_line)\n",
        "        pre_R_label = OldTex(\"R\").next_to(radial_line, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(width_line))\n",
        "        self.play(TransformFromCopy(width_line, semi_circ, path_arc=-PI / 2, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(Write(width_form, stroke_color=WHITE))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(height_line))\n",
        "        self.play(TransformFromCopy(height_line, radial_line))\n",
        "        self.play(Write(pre_R_label))\n",
        "        self.play(ReplacementTransform(pre_R_label, height_form))\n",
        "        self.wait()\n",
        "\n",
        "        # Area\n",
        "        rhs = OldTex(\"=\\\\pi R^2\")\n",
        "        question.generate_target()\n",
        "        question.target.match_y(sectors).match_x(lh)\n",
        "        question.target[-1].scale(0, about_edge=LEFT)\n",
        "        rhs.next_to(question.target, RIGHT)\n",
        "\n",
        "        rect = SurroundingRectangle(VGroup(question.target, rhs))\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(MoveToTarget(question))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(VGroup(height_form, width_form).copy(), rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(rect))\n",
        "\n",
        "    def get_sectors(self, circle, n_slices=20, fill_colors=[BLUE_D, BLUE_E]):\n",
        "        angle = TAU / n_slices\n",
        "        sectors = VGroup(*(\n",
        "            Sector(angle=angle, start_angle=i * angle, fill_color=color, fill_opacity=1)\n",
        "            for i, color in zip(range(n_slices), it.cycle(fill_colors))\n",
        "        ))\n",
        "        sectors.set_stroke(WHITE, self.sector_stroke_width)\n",
        "        sectors.replace(circle, stretch=True)\n",
        "        return sectors\n",
        "\n",
        "\n",
        "class CircleExample50(CircleExample):\n",
        "    n_slices = 50\n",
        "    sector_stroke_width = 0.5\n",
        "\n",
        "\n",
        "class CircleExample100(CircleExample):\n",
        "    n_slices = 100\n",
        "    sector_stroke_width = 0.2\n",
        "\n",
        "\n",
        "class SideBySide(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class SphereSectorAnalysis(Scene):\n",
        "    n_slices = 20\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        radius = 2.0\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(10, 60)\n",
        "\n",
        "        axes = ThreeDAxes()\n",
        "        axes.insert_n_curves(20)\n",
        "        axes.set_stroke(GREY_B, 1)\n",
        "        axes.apply_depth_test()\n",
        "\n",
        "        sphere = Sphere(radius=radius)\n",
        "        mesh = SurfaceMesh(sphere, resolution=(self.n_slices + 1, 3))\n",
        "        mesh.set_stroke(BLUE_E, 1)\n",
        "        slices = get_sphere_slices(radius=radius, n_slices=self.n_slices)\n",
        "        slices[2].scale(1.007)\n",
        "        slices.rotate(-90 * DEGREES, OUT)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(slices, mesh)\n",
        "        self.play(\n",
        "            ShowCreation(slices, lag_ratio=0.05),\n",
        "            frame.animate.reorient(-10, 70),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.add(slices, mesh)\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate one slice\n",
        "        self.play(\n",
        "            slices[0][1:].animate.set_opacity(0.1),\n",
        "            slices[1].animate.set_opacity(0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Preview varying width\n",
        "        dtheta = TAU / self.n_slices\n",
        "        phi_tracker = ValueTracker(45 * DEGREES)\n",
        "        get_phi = phi_tracker.get_value\n",
        "\n",
        "        def get_width_line():\n",
        "            return ParametricCurve(\n",
        "                lambda t: radius * np.array([\n",
        "                    math.sin(t) * math.sin(get_phi()),\n",
        "                    -math.cos(t) * math.sin(get_phi()),\n",
        "                    math.cos(get_phi()),\n",
        "                ]),\n",
        "                t_range=(0, dtheta),\n",
        "                stroke_color=RED,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "\n",
        "        width_line = get_width_line()\n",
        "        width_label = Text(\"Width\", color=RED)\n",
        "        width_label.rotate(90 * DEGREES, RIGHT)\n",
        "        width_label.set_stroke(BLACK, 1, background=True)\n",
        "        width_label.add_updater(lambda m: m.next_to(width_line, OUT, buff=SMALL_BUFF).set_width(1.5 * width_line.get_width() + 1e-2))\n",
        "\n",
        "        self.play(ShowCreation(width_line), Write(width_label))\n",
        "        self.wait()\n",
        "        width_line.add_updater(lambda m: m.match_points(get_width_line()))\n",
        "        for angle in 0, PI / 2, 0:\n",
        "            self.play(phi_tracker.animate.set_value(angle), run_time=2)\n",
        "        self.play(FadeOut(width_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Reorient\n",
        "        slices.generate_target()\n",
        "        mesh.generate_target()\n",
        "        for mob in slices, mesh:\n",
        "            for submob in mob.target.family_members_with_points():\n",
        "                if submob.get_x() < -0.1:\n",
        "                    submob.set_opacity(0)\n",
        "\n",
        "        self.add(slices, width_line)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-65, 65),\n",
        "            MoveToTarget(slices),\n",
        "            MoveToTarget(mesh),\n",
        "            slices[2].animate.set_stroke(width=0),\n",
        "            run_time=2,\n",
        "        )\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.01 * dt))\n",
        "\n",
        "        # Show phi angle\n",
        "        def get_sphere_point():\n",
        "            return radius * (math.cos(get_phi()) * OUT + math.sin(get_phi()) * DOWN)\n",
        "\n",
        "        def get_radial_line():\n",
        "            return Line(\n",
        "                ORIGIN, get_sphere_point(),\n",
        "                stroke_color=YELLOW,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "\n",
        "        phi_label = OldTex(\"\\\\phi\", font_size=30)\n",
        "\n",
        "        def get_angle_label():\n",
        "            arc = Arc(start_angle=90 * DEGREES, angle=-get_phi(), radius=0.5, n_components=8)\n",
        "            arc.set_stroke(WHITE, 2)\n",
        "            arc.set_fill(opacity=0)\n",
        "            label = phi_label.copy()\n",
        "            label.next_to(arc.pfp(0.5), UP, buff=SMALL_BUFF)\n",
        "            result = VGroup(arc, label)\n",
        "            result.rotate(90 * DEGREES, RIGHT, about_point=ORIGIN)\n",
        "            result.rotate(90 * DEGREES, IN, about_point=ORIGIN)\n",
        "            return result\n",
        "\n",
        "        def get_lat_line_radius():\n",
        "            point = get_sphere_point()\n",
        "            return Line(point[2] * OUT, point, stroke_color=PINK, stroke_width=2)\n",
        "\n",
        "        def get_lat_line():\n",
        "            result = Circle(radius=radius * math.sin(get_phi()))\n",
        "            result.set_stroke(RED, 1, opacity=0.5)\n",
        "            result.set_z(get_sphere_point()[2])\n",
        "            return result\n",
        "\n",
        "        radial_line = get_radial_line()\n",
        "        radial_line.add_updater(lambda m: m.match_points(get_radial_line()))\n",
        "        angle_label = get_angle_label()\n",
        "        angle_label[0].add_updater(lambda m: m.match_points(get_angle_label()[0]).set_stroke(WHITE, 2).set_fill(opacity=0))\n",
        "        angle_label[1].add_updater(lambda m: m.move_to(get_angle_label()[1]))\n",
        "        lat_line_radius = get_lat_line_radius()\n",
        "        lat_line_radius.add_updater(lambda m: m.match_points(get_lat_line_radius()))\n",
        "        lat_line_label = OldTex(\"R\\\\sin(\\\\phi)\", font_size=24)\n",
        "        lat_line_label.rotate(90 * DEGREES, RIGHT).rotate(90 * DEGREES, IN)\n",
        "        lat_line_label.next_to(lat_line_radius, OUT, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(\n",
        "            phi_tracker.animate.set_value(30 * DEGREES),\n",
        "            UpdateFromAlphaFunc(angle_label, lambda m, a: m.update().set_opacity(a)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            phi_tracker.animate.set_value(75 * DEGREES),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(phi_tracker.animate.set_value(45 * DEGREES), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        lat_line_label.add_updater(lambda m: m.next_to(lat_line_radius, OUT, SMALL_BUFF))\n",
        "        self.play(\n",
        "            ShowCreation(lat_line_radius),\n",
        "            Write(lat_line_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        lat_line = get_lat_line()\n",
        "        lat_line.add_updater(lambda m: m.match_points(get_lat_line()))\n",
        "        self.play(ShowCreation(lat_line))\n",
        "        self.wait()\n",
        "\n",
        "        # Show delta theta\n",
        "        brace = Brace(Line(ORIGIN, radius * dtheta * RIGHT), UP, buff=SMALL_BUFF)\n",
        "        delta_theta = OldTex(\"\\\\Delta \\\\theta\", font_size=36)\n",
        "        delta_theta.next_to(brace, UP, buff=SMALL_BUFF)\n",
        "        dt_label = VGroup(brace, delta_theta)\n",
        "        dt_label.rotate(90 * DEGREES, RIGHT)\n",
        "        dt_label.next_to(radius * DOWN, OUT, buff=0)\n",
        "        dt_label.rotate(0.5 * dtheta, OUT, about_point=ORIGIN)\n",
        "\n",
        "        self.play(Write(dt_label), frame.animate.set_theta(-30 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        # Exact formula\n",
        "        formula1 = OldTex(\"2\\\\pi\", \" R \\\\sin(\\\\phi)\", \"\\\\cdot\", \"{\\\\Delta \\\\theta\", \" \\\\over 2\\\\pi}\")\n",
        "        formula2 = OldTex(\"R \\\\sin(\\\\phi)\", \"\\\\cdot\", \"\\\\Delta \\\\theta\")\n",
        "        for formula in formula1, formula2:\n",
        "            formula.to_corner(UR)\n",
        "            formula.fix_in_frame()\n",
        "\n",
        "        self.play(Write(formula1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(formula1[1], formula2[0]),\n",
        "            FadeTransform(formula1[2], formula2[1]),\n",
        "            FadeTransform(formula1[3], formula2[2]),\n",
        "            FadeOut(formula1[0]),\n",
        "            FadeOut(formula1[4:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Graph\n",
        "        axes = Axes(\n",
        "            (0, PI, PI / 4),\n",
        "            (0, 1, 1 / 2),\n",
        "            height=1,\n",
        "            width=PI,\n",
        "        )\n",
        "        axes.y_axis.add(Text(\"Wedge width\", font_size=24, color=RED).next_to(axes.c2p(0, 1), LEFT))\n",
        "        axes.x_axis.add(OldTex(\"\\\\pi / 2\", font_size=24).next_to(axes.c2p(PI / 2, 0), DOWN))\n",
        "        axes.x_axis.add(OldTex(\"\\\\pi\", font_size=24).next_to(axes.c2p(PI, 0), DOWN))\n",
        "        axes.x_axis.add(OldTex(\"\\\\phi\", font_size=24).next_to(axes.c2p(PI, 0), UR, buff=SMALL_BUFF))\n",
        "        axes.to_corner(UL)\n",
        "        axes.fix_in_frame()\n",
        "        graph = axes.get_graph(lambda x: math.sin(x), x_range=[0, PI / 2])\n",
        "        graph.set_stroke(RED, 2)\n",
        "        graph.fix_in_frame()\n",
        "        dot = Dot()\n",
        "        dot.scale(0.25)\n",
        "        dot.fix_in_frame()\n",
        "\n",
        "        self.play(FadeIn(axes), frame.animate.set_theta(-50 * DEGREES))\n",
        "        self.wait()\n",
        "        self.play(phi_tracker.animate.set_value(0))\n",
        "        self.wait()\n",
        "        graph_copy = graph.copy()\n",
        "        self.play(\n",
        "            phi_tracker.animate.set_value(90 * DEGREES),\n",
        "            ShowCreation(graph),\n",
        "            UpdateFromAlphaFunc(dot, lambda d, a: d.move_to(graph_copy.pfp(a))),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            phi_tracker.animate.set_value(45 * DEGREES),\n",
        "            UpdateFromAlphaFunc(dot, lambda d, a: d.move_to(graph.pfp(1 - 0.5 * a))),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FalseVsTrueSurfaceAreaOverlay(InteractiveScene):\n",
        "    def construct(self):\n",
        "        false_answer = VGroup(\n",
        "            Text(\"False answer\", color=RED),\n",
        "            OldTex(\"\\\\pi^2 R^2\"),\n",
        "        )\n",
        "        true_answer = VGroup(\n",
        "            Text(\"True answer\", color=GREEN),\n",
        "            OldTex(\"4\\\\pi R^2\"),\n",
        "        )\n",
        "        answers = VGroup(false_answer, true_answer)\n",
        "        for answer in answers:\n",
        "            answer.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        answers.arrange(RIGHT, buff=LARGE_BUFF, aligned_edge=UP)\n",
        "\n",
        "        self.play(FadeIn(false_answer))\n",
        "        self.play(FadeIn(true_answer))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FakeAreaManipulation(InteractiveScene):\n",
        "    CONFIG = {\n",
        "        \"unit\": 0.5\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        unit = self.unit\n",
        "        group1, group2 = groups = self.get_diagrams()\n",
        "        for group in groups:\n",
        "            group.set_width(10 * unit, stretch=True)\n",
        "            group.set_height(12 * unit, stretch=True)\n",
        "            group.move_to(3 * DOWN, DOWN)\n",
        "            group[2].append_points(3 * [group[2].get_left() + LEFT])\n",
        "            group[3].append_points(3 * [group[3].get_right() + RIGHT])\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            x_range=(-30, 30),\n",
        "            y_range=(-30, 30),\n",
        "            faded_line_ratio=0,\n",
        "        )\n",
        "        grid.set_stroke(width=1)\n",
        "        grid.scale(unit)\n",
        "        grid.shift(3 * DOWN - grid.c2p(0, 0))\n",
        "\n",
        "        vertex_dots = VGroup(\n",
        "            Dot(group1.get_top()),\n",
        "            Dot(group1.get_corner(DR)),\n",
        "            Dot(group1.get_corner(DL)),\n",
        "        )\n",
        "\n",
        "        self.add(grid)\n",
        "        self.add(*group1)\n",
        "        self.add(vertex_dots)\n",
        "\n",
        "        self.disable_interaction(grid, vertex_dots)\n",
        "        targets = [group1.copy(), group2.copy()]\n",
        "\n",
        "        self.wait(note=\"Manually manipulate\")\n",
        "\n",
        "        # Animate swap\n",
        "        kw = {\n",
        "            \"lag_ratio\": 0.1,\n",
        "            \"run_time\": 2,\n",
        "            \"rate_func\": bezier([0, 0, 1, 1]),\n",
        "        }\n",
        "        path_arc_factors = [-1, 1, 0, 0, -1, 1]\n",
        "        for target in targets:\n",
        "            self.play(group1.animate.space_out_submobjects(1.2))\n",
        "            self.play(*[\n",
        "                Transform(\n",
        "                    sm1, sm2,\n",
        "                    path_arc=path_arc_factors[i] * 60 * DEGREES,\n",
        "                    **kw\n",
        "                )\n",
        "                for i, sm1, sm2 in zip(it.count(), group1, target)\n",
        "            ])\n",
        "            self.wait(2)\n",
        "\n",
        "        # Zoom\n",
        "        lines = VGroup(\n",
        "            Line(grid.c2p(0, 12), grid.c2p(-5, 0)),\n",
        "            Line(grid.c2p(0, 12), grid.c2p(5, 0)),\n",
        "        )\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "        self.disable_interaction(lines)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "\n",
        "        self.play(ShowCreation(lines, lag_ratio=0))\n",
        "        self.play(\n",
        "            frame.animate.scale(0.15).move_to(group1[0].get_corner(UR)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(frame.animate.restore(), run_time=2)\n",
        "\n",
        "        # Another switch\n",
        "        self.wait(note=\"Hold for next swap\")\n",
        "        self.play(*(\n",
        "            Transform(sm1, sm2, **kw)\n",
        "            for sm1, sm2 in zip(group1, targets[0])\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Another zooming\n",
        "        self.play(\n",
        "            frame.animate.scale(0.15).move_to(group1[4].get_corner(UR)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(frame.animate.restore(), run_time=2)\n",
        "\n",
        "        # Show slopes\n",
        "        tris = VGroup(group1[0], group1[4])\n",
        "        lil_lines = VGroup(*(Line(tri.get_corner(DL), tri.get_corner(UR)) for tri in tris))\n",
        "        lil_lines[0].set_stroke(PINK, 3)\n",
        "        lil_lines[1].set_stroke(WHITE, 3)\n",
        "\n",
        "        slope_labels = VGroup(\n",
        "            OldTexText(\"Slope =\", \" $5 / 2$\"),\n",
        "            OldTexText(\"Slope =\", \" $7 / 3$\"),\n",
        "        )\n",
        "        for line, label in zip(lil_lines, slope_labels):\n",
        "            label.next_to(line.pfp(0.5), UL, buff=0.7)\n",
        "            arrow = Arrow(label.get_bottom(), line.pfp(0.5))\n",
        "            label.add(arrow)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(lines[0]),\n",
        "            ShowCreation(lil_lines),\n",
        "        )\n",
        "        for line, label in zip(lil_lines, slope_labels):\n",
        "            p1, p2 = line.get_start_and_end()\n",
        "            corner = [p2[0], p1[1], 0]\n",
        "            x_line = Line(p1, corner).set_stroke(line.get_color(), 2)\n",
        "            y_line = Line(corner, p2).set_stroke(line.get_color(), 2)\n",
        "            self.play(\n",
        "                FadeIn(label[:2]),\n",
        "                ShowCreation(label[2]),\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(line, y_line),\n",
        "                FlashAround(label[1][0]),\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(line, x_line),\n",
        "                FlashAround(label[1][2]),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def get_diagrams(self):\n",
        "        unit = self.unit\n",
        "\n",
        "        tri1 = Polygon(2 * LEFT, ORIGIN, 5 * UP)\n",
        "        tri2 = tri1.copy()\n",
        "        tri2.flip()\n",
        "        tri2.next_to(tri1, RIGHT, buff=0)\n",
        "        tris = VGroup(tri1, tri2)\n",
        "        tris.scale(unit)\n",
        "        tris.move_to(3 * UP, UP)\n",
        "        tris.set_stroke(width=0)\n",
        "        tris.set_fill(BLUE_D)\n",
        "        tris[1].set_color(BLUE_C)\n",
        "\n",
        "        ell = Polygon(\n",
        "            ORIGIN,\n",
        "            4 * RIGHT,\n",
        "            4 * RIGHT + 2 * UP,\n",
        "            2 * RIGHT + 2 * UP,\n",
        "            2 * RIGHT + 5 * UP,\n",
        "            5 * UP,\n",
        "        )\n",
        "        ell.scale(unit)\n",
        "        ells = VGroup(ell, ell.copy().rotate(PI).shift(2 * unit * UP))\n",
        "        ells.next_to(tris, DOWN, buff=0)\n",
        "\n",
        "        ells.set_stroke(width=0)\n",
        "        ells.set_fill(GREY)\n",
        "        ells[1].set_fill(GREY_BROWN)\n",
        "\n",
        "        big_tri = Polygon(ORIGIN, 3 * LEFT, 7 * UP)\n",
        "        big_tri.set_stroke(width=0)\n",
        "        big_tri.scale(unit)\n",
        "\n",
        "        big_tri.move_to(ells.get_corner(DL), DR)\n",
        "        big_tris = VGroup(big_tri, big_tri.copy().rotate(PI, UP, about_point=ORIGIN))\n",
        "\n",
        "        big_tris[0].set_fill(RED_E, 1)\n",
        "        big_tris[1].set_fill(RED_C, 1)\n",
        "        full_group = VGroup(*tris, *ells, *big_tris)\n",
        "        full_group.set_height(5, about_edge=UP)\n",
        "\n",
        "        alt_group = full_group.copy()\n",
        "\n",
        "        alt_group[0].move_to(alt_group, DL)\n",
        "        alt_group[1].move_to(alt_group, DR)\n",
        "        alt_group[4].move_to(alt_group[0].get_corner(UR), DL)\n",
        "        alt_group[5].move_to(alt_group[1].get_corner(UL), DR)\n",
        "        alt_group[2].rotate(90 * DEGREES)\n",
        "        alt_group[2].move_to(alt_group[1].get_corner(DL), DR)\n",
        "        alt_group[2].rotate(-90 * DEGREES)\n",
        "        alt_group[2].move_to(alt_group[0].get_corner(DR), DL)\n",
        "        alt_group[3].move_to(alt_group[1].get_corner(DL), DR)\n",
        "\n",
        "        full_group.set_opacity(0.75)\n",
        "        alt_group.set_opacity(0.75)\n",
        "\n",
        "        return full_group, alt_group\n",
        "\n",
        "\n",
        "class ContrastSphericalGeometry(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Titles\n",
        "        titles = VGroup(\n",
        "            Text(\"Spherical geometry\"),\n",
        "            Text(\"Euclidean geometry\"),\n",
        "        )\n",
        "        for title, v in zip(titles, [LEFT, RIGHT]):\n",
        "            title.move_to(FRAME_WIDTH * v / 4)\n",
        "            title.to_edge(UP)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "        self.add(v_line, titles)\n",
        "\n",
        "        # Setup sphere\n",
        "        sphere = TexturedSurface(Sphere(radius=1.5), \"EarthTextureMap\", \"NightEarthTextureMap\")\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(GREY_C, 1, opacity=0.5)\n",
        "        sphere_group = Group(sphere, mesh)\n",
        "        sphere_group.rotate(80 * DEGREES, LEFT)\n",
        "        sphere_group.rotate(-3 * DEGREES, OUT)\n",
        "        sphere_axis = mesh[0].get_end() - sphere.get_center()\n",
        "        sphere_group.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "        sphere_group.to_edge(DOWN, buff=0.75)\n",
        "        self.add(sphere_group)\n",
        "\n",
        "        # Flat shapes\n",
        "        shapes = VGroup(\n",
        "            Polygon(RIGHT, UP, DL).set_fill(BLACK, 1),\n",
        "            Square().set_fill(BLUE_C, 1),\n",
        "            Circle().set_fill(BLUE_E, 1),\n",
        "            RegularPolygon(5).set_fill(GREY_BROWN, 1)\n",
        "        )\n",
        "        shapes.set_stroke(WHITE, 2)\n",
        "        for shape in shapes:\n",
        "            shape.set_height(1)\n",
        "        shapes.arrange_in_grid()\n",
        "        shapes.match_x(titles[1])\n",
        "        shapes.to_edge(DOWN)\n",
        "\n",
        "        pre_tri = shapes[0].copy()\n",
        "        pre_tri.scale(2.5)\n",
        "        pre_tri.move_to(shapes).align_to(sphere, DOWN)\n",
        "        pre_tri_arcs, pre_tri_angle_labels = self.get_flat_angle_labels(pre_tri)\n",
        "        shift_line, new_arcs, new_labels = self.get_aligned_angle_labels(\n",
        "            pre_tri, pre_tri_arcs, pre_tri_angle_labels\n",
        "        )\n",
        "\n",
        "        # Setup spherical triangle\n",
        "        t2c = {\n",
        "            \"\\\\alpha\": BLUE_B,\n",
        "            \"\\\\beta\": BLUE_C,\n",
        "            \"\\\\gamma\": BLUE_D,\n",
        "        }\n",
        "        kw = dict(tex_to_color_map=t2c)\n",
        "        sph_tri = VGroup(\n",
        "            VMobject().pointwise_become_partial(mesh[16], 0.5, 1.0),\n",
        "            VMobject().pointwise_become_partial(mesh[19], 0.5, 1.0).reverse_points(),\n",
        "            VMobject().pointwise_become_partial(mesh[26], 16 / 20, 19 / 20).reverse_points(),\n",
        "        )\n",
        "        sph_tri.set_stroke(BLUE, 3)\n",
        "        sph_tri_angle_labels = Tex(\"\\\\alpha\\\\beta\\\\gamma\", font_size=30, **kw)\n",
        "        sph_tri_angle_labels.set_backstroke()\n",
        "        for label, curve in zip(sph_tri_angle_labels, sph_tri):\n",
        "            label.curve = curve\n",
        "            label.add_updater(lambda l: l.move_to(l.curve.get_end()))\n",
        "            label.add_updater(lambda l: l.shift(0.2 * normalize(sph_tri.get_center() - l.curve.get_end())))\n",
        "\n",
        "        sph_tri.deactivate_depth_test()\n",
        "\n",
        "        # Equations\n",
        "        angle_equations = VGroup(\n",
        "            Tex(\"\\\\alpha + \\\\beta + \\\\gamma > 180^\\\\circ\", **kw),\n",
        "            Tex(\"\\\\alpha + \\\\beta + \\\\gamma = 180^\\\\circ\", **kw),\n",
        "        )\n",
        "        for eq, title in zip(angle_equations, titles):\n",
        "            eq.next_to(title, DOWN, buff=1.5)\n",
        "\n",
        "        # Write triangles\n",
        "        sph_tri_angle_labels.suspend_updating()\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, VGroup(\n",
        "                pre_tri, pre_tri_arcs, pre_tri_angle_labels,\n",
        "                sph_tri, sph_tri_angle_labels,\n",
        "            )),\n",
        "            *(FadeIn(eq, 0.25 * DOWN) for eq in angle_equations)\n",
        "        )\n",
        "        sph_tri_angle_labels.resume_updating()\n",
        "        sphere_group.add(sph_tri, sph_tri_angle_labels)\n",
        "        sph_tri.deactivate_depth_test()\n",
        "        self.add(sphere_group)\n",
        "        self.play()\n",
        "\n",
        "        # Justify euclidean case\n",
        "        self.play(\n",
        "            FadeIn(shift_line, shift=shift_line.shift_vect),\n",
        "            Rotate(sphere_group, -30 * DEGREES, axis=sphere_axis, run_time=2)\n",
        "        )\n",
        "        for i in (0, 1):\n",
        "            self.play(\n",
        "                TransformFromCopy(pre_tri_arcs[i + 1], new_arcs[i]),\n",
        "                TransformFromCopy(pre_tri_angle_labels[i + 1], new_labels[i]),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        pre_tri_group = VGroup(\n",
        "            pre_tri, pre_tri_arcs, pre_tri_angle_labels,\n",
        "            shift_line, new_arcs, new_labels\n",
        "        )\n",
        "\n",
        "        # Write area formulas\n",
        "        area_formulas = VGroup(\n",
        "            Tex(\"\\\\text{Area}(\\\\Delta) = (\\\\alpha + \\\\beta + \\\\gamma - \\\\pi) R^2\", **kw),\n",
        "            Tex(\"\\\\text{Area}(\\\\Delta) = \\\\frac{1}{2} bh\")\n",
        "        )\n",
        "        for title, formula in zip(titles, area_formulas):\n",
        "            formula.move_to(title).shift(1.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(area_formulas, 0.5 * DOWN),\n",
        "            angle_equations.animate.shift(0.75 * DOWN)\n",
        "        )\n",
        "\n",
        "        # Mention Gaussian Curvature\n",
        "        curvature_words = VGroup(\n",
        "            OldTexText(\"Gaussian curvature > 0\", color=GREEN_B),\n",
        "            OldTexText(\"Gaussian curvature = 0\", color=YELLOW),\n",
        "        )\n",
        "        for words, eq in zip(curvature_words, angle_equations):\n",
        "            words.next_to(eq, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(curvature_words, 0.7 * DOWN),\n",
        "            sphere_group.animate.scale(0.7, about_edge=DOWN),\n",
        "            pre_tri_group.animate.scale(0.7, about_edge=DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Try unraveling sphere\n",
        "        unwrapped = TexturedSurface(Surface(), \"EarthTextureMap\", \"NightEarthTextureMap\")\n",
        "        unwrapped.set_height(2)\n",
        "        unwrapped.set_width(TAU, stretch=True)\n",
        "        unwrapped.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        unwrapped.next_to(titles[1], DOWN, LARGE_BUFF)\n",
        "\n",
        "        loss_words = Text(\"Some geometric information\\nmust be lost\")\n",
        "        loss_words.set_color(RED)\n",
        "        loss_words.set_max_width(unwrapped.get_width())\n",
        "        loss_words.next_to(unwrapped, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeOut(mob, RIGHT)\n",
        "                for mob in [area_formulas[1], angle_equations[1], curvature_words[1], pre_tri_group]\n",
        "            )),\n",
        "            TransformFromCopy(sphere, unwrapped, run_time=2)\n",
        "        )\n",
        "        self.play(Write(loss_words))\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_flat_angle_labels(self, tri):\n",
        "        arcs = VGroup()\n",
        "        for v1, v2, v3 in adjacent_n_tuples(tri.get_vertices(), 3):\n",
        "            a1 = angle_of_vector(v2 - v1)\n",
        "            a2 = angle_of_vector(v3 - v2)\n",
        "            arc = Arc(\n",
        "                start_angle=a2,\n",
        "                angle=PI - (a2 - a1) % PI,\n",
        "                radius=0.2\n",
        "            )\n",
        "            arc.shift(v2)\n",
        "            arcs.add(arc)\n",
        "\n",
        "        labels = Tex(\"\\\\alpha \\\\beta \\\\gamma\", font_size=30)\n",
        "        for label, arc in zip(labels, arcs):\n",
        "            vect = normalize(arc.pfp(0.5) - midpoint(arc.get_start(), arc.get_end()))\n",
        "            label.move_to(arc.pfp(0.5))\n",
        "            label.shift(0.25 * vect)\n",
        "\n",
        "        result = VGroup(arcs, labels)\n",
        "        for group in result:\n",
        "            group.set_submobject_colors_by_gradient(BLUE_B, BLUE_C, BLUE_D)\n",
        "        return result\n",
        "\n",
        "    def get_aligned_angle_labels(self, tri, arcs, labels):\n",
        "        verts = tri.get_vertices()\n",
        "        line = Line(verts[0], verts[2])\n",
        "        line.set_stroke(GREY_B, 2)\n",
        "\n",
        "        vect1 = verts[1] - verts[2]\n",
        "        vect2 = verts[1] - verts[0]\n",
        "        line.shift_vect = (vect1 + vect2) / 2\n",
        "        line.shift(line.shift_vect)\n",
        "\n",
        "        new_arcs = arcs[1:3].copy()\n",
        "        new_labels = labels[1:3].copy()\n",
        "        VGroup(new_arcs[0], new_labels[0]).rotate(PI, about_point=midpoint(verts[1], verts[2]))\n",
        "        VGroup(new_arcs[1], new_labels[1]).rotate(PI, about_point=midpoint(verts[1], verts[0]))\n",
        "        for label in new_labels:\n",
        "            label.rotate(PI)\n",
        "\n",
        "        return VGroup(line, new_arcs, new_labels)\n",
        "\n",
        "\n",
        "class GiveItAGo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        ss = self.students\n",
        "\n",
        "        self.play(\n",
        "            morty.says(\"Can you see\\nwhat's happening?\"),\n",
        "            ss[0].change(\"pondering\", self.screen),\n",
        "            ss[1].change(\"angry\", self.screen),\n",
        "            ss[2].change(\"confused\", self.screen),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ss[1].change(\"maybe\"))\n",
        "        self.play(morty.change(\"tease\"), ss[0].change(\"thinking\"))\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SquareCircleExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        radius = 2.0\n",
        "        circle = Circle(radius=radius, n_components=32)\n",
        "        rich_circle = Circle(radius=radius, n_components=2**14)\n",
        "        circle.set_fill(BLUE_E, 1)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "        approx_curves = [\n",
        "            self.get_square_approx(rich_circle, 4 * 2**n)\n",
        "            for n in range(10)\n",
        "        ]\n",
        "        square = approx_curves[0].copy()\n",
        "\n",
        "        self.add(circle)\n",
        "\n",
        "        # Ask about circumference\n",
        "        radial_line = Line(ORIGIN, circle.get_right())\n",
        "        radial_line.set_stroke(WHITE, 1)\n",
        "        radius_label = OldTex(\"1\")\n",
        "        radius_label.next_to(radial_line, UP, SMALL_BUFF)\n",
        "\n",
        "        circum = circle.copy()\n",
        "        circum.set_stroke(YELLOW, 3).set_fill(opacity=0)\n",
        "        question = Text(\"What is the circumference?\")\n",
        "        question.next_to(circle, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        unwrapped_circum = Line(LEFT, RIGHT)\n",
        "        unwrapped_circum.set_width(PI * circle.get_width())\n",
        "        unwrapped_circum.match_style(circum)\n",
        "        unwrapped_circum.next_to(circle, UP)\n",
        "\n",
        "        diameter = Line(circle.get_left(), circle.get_right())\n",
        "        diameter.set_stroke(RED, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            Write(radius_label, stroke_color=WHITE)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(circum)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            question.animate.to_edge(UP),\n",
        "            Transform(circum, unwrapped_circum),\n",
        "        )\n",
        "        self.play(ShowCreation(diameter))\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [question, circum, diameter]))\n",
        "\n",
        "        # Show perimeter length\n",
        "        points = [square.get_edge_center(np.round(vect)) for vect in compass_directions(8)]\n",
        "        new_radii = VGroup(*(\n",
        "            Line(p1, p2).match_style(radial_line)\n",
        "            for p1, p2 in adjacent_pairs(points)\n",
        "        ))\n",
        "        new_radii.save_state()\n",
        "        new_radii.space_out_submobjects(1.1)\n",
        "\n",
        "        perimeter_label = OldTexText(\"Perimeter = $8$\")\n",
        "        perimeter_label.to_edge(UP)\n",
        "\n",
        "        self.play(ShowCreation(square), run_time=3)\n",
        "        self.play(square.animate.scale(1.2), rate_func=there_and_back)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(VGroup(radial_line), new_radii, lag_ratio=0.2, run_time=2),\n",
        "            FadeIn(perimeter_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(new_radii.animate.restore())\n",
        "        self.play(FadeOut(new_radii))\n",
        "        self.wait()\n",
        "\n",
        "        # Finer approximations\n",
        "        for i, curve in enumerate(approx_curves[1:]):\n",
        "            curve.set_color(YELLOW)\n",
        "            self.play(\n",
        "                square.animate.set_stroke(width=1),\n",
        "                TransformFromCopy(square, curve)\n",
        "            )\n",
        "            self.wait()\n",
        "            if i == 0:\n",
        "                dots = GlowDot().replicate(2)\n",
        "                dots.set_color(BLUE)\n",
        "                sc = square.copy().insert_n_curves(200)\n",
        "                cc = curve.copy().insert_n_curves(200)\n",
        "                self.play(VGroup(square, curve).animate.set_stroke(opacity=0.2))\n",
        "                self.play(\n",
        "                    MoveAlongPath(dots[0], square),\n",
        "                    MoveAlongPath(dots[1], curve),\n",
        "                    ShowCreation(sc),\n",
        "                    ShowCreation(cc),\n",
        "                    rate_func=linear,\n",
        "                    run_time=6,\n",
        "                )\n",
        "                self.play(FadeOut(dots), FadeOut(sc), FadeOut(cc), VGroup(square, curve).animate.set_stroke(opacity=1))\n",
        "\n",
        "            if i == 1:\n",
        "                curve.set_stroke(width=5)\n",
        "                print(self.num_plays)\n",
        "            self.play(FadeOut(square), curve.animate.set_color(RED))\n",
        "            square = curve\n",
        "\n",
        "        # Zoom in\n",
        "        frame = self.camera.frame\n",
        "        self.wait(note=\"Prepare for zoom\")\n",
        "        self.play(frame.animate.set_height(0.05).move_to(circle.pfp(1 / 8)), run_time=4)\n",
        "        self.wait()\n",
        "        self.play(frame.animate.to_default_state(), run_time=3)\n",
        "\n",
        "        # Define parametric curve\n",
        "        frame = self.camera.frame\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        dot = GlowDot()\n",
        "        t_axis = UnitInterval()\n",
        "        t_axis.set_width(6)\n",
        "        t_axis.next_to(circle, RIGHT, buff=1.5)\n",
        "        t_axis.add_numbers()\n",
        "        t_indicator = Triangle(start_angle=-90 * DEGREES)\n",
        "        t_indicator.set_height(0.1)\n",
        "        t_indicator.set_fill(RED, 1)\n",
        "        t_indicator.set_stroke(WHITE, 0)\n",
        "        t_label = VGroup(OldTex(\"t = \"), DecimalNumber())\n",
        "        t_label.arrange(RIGHT)\n",
        "        t_label.next_to(t_axis, UP, buff=LARGE_BUFF)\n",
        "        VGroup(t_axis, t_label).to_edge(UP)\n",
        "\n",
        "        t_label[1].add_updater(lambda d: d.set_value(get_t()))\n",
        "        dot.add_updater(lambda d: d.move_to(square.pfp(get_t())))\n",
        "        t_indicator.add_updater(lambda m: m.move_to(t_axis.n2p(get_t()), DOWN))\n",
        "\n",
        "        c_labels = VGroup(*(OldTex(f\"c_{n}(t)\") for n in range(len(approx_curves))))\n",
        "        c_labels.add(OldTex(\"c_\\\\infty (t)\"))\n",
        "        for label in c_labels:\n",
        "            label.scale(0.75)\n",
        "            label.add_updater(lambda m: m.next_to(dot, UR, buff=-SMALL_BUFF))\n",
        "\n",
        "        self.play(\n",
        "            Transform(square, approx_curves[0]),\n",
        "            frame.animate.move_to(4 * RIGHT),\n",
        "            FadeIn(dot),\n",
        "            FadeIn(t_label),\n",
        "            Write(c_labels[0]),\n",
        "            Write(t_axis),\n",
        "            Write(t_indicator),\n",
        "            run_time=1\n",
        "        )\n",
        "        square.match_points(approx_curves[0])\n",
        "        self.wait()\n",
        "        self.play(t_tracker.animate.set_value(1), run_time=7)\n",
        "        self.wait()\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        self.play(\n",
        "            Transform(square, approx_curves[1]),\n",
        "            FadeTransform(c_labels[0], c_labels[1]),\n",
        "        )\n",
        "        self.play(t_tracker.animate.set_value(1), run_time=7)\n",
        "        self.wait()\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        # Show limits\n",
        "        self.play(t_tracker.animate.set_value(0.2), run_time=3)\n",
        "        dot_shadows = VGroup()\n",
        "        self.add(dot_shadows)\n",
        "        for i in range(2, len(approx_curves)):\n",
        "            dot_shadow = Dot(radius=0.01, color=YELLOW, opacity=0.5)\n",
        "            dot_shadow.move_to(dot)\n",
        "            dot_shadows.add(dot_shadow)\n",
        "            self.play(\n",
        "                Transform(square, approx_curves[i]),\n",
        "                FadeTransform(c_labels[i - 1], c_labels[i]),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Write limits\n",
        "        lim_tex_ex = Tex(\"\\\\lim_{n \\\\to \\\\infty} c_{n}(\" + \"{:.1f}\".format(get_t()) + \")\")\n",
        "        lim_tex = OldTex(\"c_\\\\infty(t)\", \":=\", \"\\\\lim_{n \\\\to \\\\infty} c_{n}(t)\")\n",
        "        for lt in lim_tex_ex, lim_tex:\n",
        "            lt.next_to(t_axis, DOWN, aligned_edge=LEFT, buff=2.0)\n",
        "        lim_arrow = Arrow(lim_tex_ex.get_corner(UL), dot.get_center(), buff=0.1, stroke_width=2, color=YELLOW)\n",
        "        self.play(Write(lim_tex_ex))\n",
        "        self.play(ShowCreation(lim_arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(lim_tex_ex, lim_tex[2]),\n",
        "            Write(lim_tex[:2]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(dot_shadows), FadeOut(lim_arrow), FadeTransform(c_labels[9], c_labels[-1]))\n",
        "        self.play(t_tracker.animate.set_value(0), run_time=2)\n",
        "        self.play(t_tracker.animate.set_value(1), run_time=8)\n",
        "        self.wait()\n",
        "\n",
        "        # This is a circle\n",
        "        text = Text(\"This is, precisely, a circle\", t2s={\"precisely\": ITALIC})\n",
        "        text.next_to(lim_tex, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        arrow = Arrow(text, lim_tex[0])\n",
        "        VGroup(text, arrow).set_color(GREEN)\n",
        "\n",
        "        self.play(Write(text), ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(text), FadeOut(arrow), lim_tex.animate.shift(UP))\n",
        "\n",
        "        # Mismatched limits\n",
        "        t2c = {\n",
        "            \"\\\\lim_{n \\\\to \\\\infty}\": YELLOW,\n",
        "            \"\\\\text{len}\": RED,\n",
        "            \"c_n(t)\": WHITE,\n",
        "            \"\\\\Big(\": WHITE,\n",
        "            \"\\\\Big)\": WHITE,\n",
        "        }\n",
        "        lim_len = Tex(\"\\\\lim_{n \\\\to \\\\infty}\\\\Big(\\\\text{len}\\\\big(c_n(t)\\\\big) \\\\Big) = 8\", tex_to_color_map=t2c)\n",
        "        len_lim = Tex(\"\\\\text{len} \\\\Big( \\\\lim_{n \\\\to \\\\infty} c_n(t) \\\\Big) = 2\\\\pi\", tex_to_color_map=t2c)\n",
        "        lims = VGroup(lim_len, len_lim)\n",
        "        lim_len.next_to(lim_tex, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        top_group = VGroup(t_axis, t_indicator, t_label)\n",
        "\n",
        "        self.play(Write(lim_len))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(lim_tex, lim_len).animate.next_to(frame.get_corner(UR), DL, MED_LARGE_BUFF),\n",
        "            FadeOut(top_group, 2 * UR),\n",
        "        )\n",
        "\n",
        "        len_lim.next_to(lim_len, DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        not_eq = OldTex(\"\\\\ne\", font_size=96)\n",
        "        not_eq.rotate(90 * DEGREES)\n",
        "        not_eq.move_to(VGroup(len_lim, lim_len))\n",
        "        not_eq.match_x(len_lim)\n",
        "\n",
        "        self.play(*(\n",
        "            TransformFromCopy(lim_len.select_parts(tex), len_lim.select_parts(tex))\n",
        "            for tex in t2c.keys()\n",
        "        ))\n",
        "        self.play(Write(not_eq))\n",
        "        self.wait()\n",
        "        self.play(Write(len_lim[3:]))\n",
        "        self.wait()\n",
        "\n",
        "        # Commentary\n",
        "        morty = Mortimer()\n",
        "\n",
        "    def get_square_approx(self, circle, n_samples):\n",
        "        radius = circle.radius\n",
        "        points = [\n",
        "            radius * np.array([math.cos(a), math.sin(a), 0])\n",
        "            for a in np.linspace(0, TAU, n_samples + 1)\n",
        "        ]\n",
        "        result = VMobject()\n",
        "        result.start_new_path(points[0])\n",
        "        for p1, p2 in zip(points, points[1:]):\n",
        "            corners = np.array([\n",
        "                [p2[0], p1[1], 0],\n",
        "                [p1[0], p2[1], 0]\n",
        "            ])\n",
        "            corner = corners[np.argmax(np.apply_along_axis(np.linalg.norm, 1, corners))]\n",
        "            result.add_line_to(corner)\n",
        "            result.add_line_to(p2)\n",
        "\n",
        "        result.set_stroke(RED, 2)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ObviouslyWrong(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        ss = self.students\n",
        "        self.play(LaggedStart(\n",
        "            ss[2].says(\"Obviously those\\nperimeters aren't\\nthe circle...\", mode=\"sassy\", look_at=self.screen, bubble_direction=LEFT),\n",
        "            ss[0].change(\"erm\", self.screen),\n",
        "            ss[1].change(\"angry\", self.screen),\n",
        "            morty.change(\"guilty\")\n",
        "        ))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class UpshotOfLimitExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = Text(\"The takeaway\", font_size=60)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "        underline.scale(1.2)\n",
        "        underline.insert_n_curves(20)\n",
        "        underline.set_stroke(WHITE, (1, 3, 3, 1))\n",
        "\n",
        "        subtitle = Text(\n",
        "            \"What's true of a sequence may not be true of the limit\",\n",
        "            t2c={\"sequence\": BLUE, \"limit\": YELLOW},\n",
        "        )\n",
        "        subtitle.set_max_width(FRAME_WIDTH - 1)\n",
        "        subtitle.next_to(title, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(title, underline, subtitle)\n",
        "\n",
        "        # Various limits\n",
        "        n = 4\n",
        "        numbers = VGroup(\n",
        "            OldTex(\"1.4\"),\n",
        "            OldTex(\"1.41\"),\n",
        "            OldTex(\"1.414\"),\n",
        "            OldTex(\"1.4142\"),\n",
        "            OldTex(\"\\\\sqrt{2}\")\n",
        "        )\n",
        "        numbers.scale(1.25)\n",
        "        properties = VGroup(\n",
        "            *Text(\"Rational\", font_size=30).replicate(n),\n",
        "            Text(\"Irrational\", font_size=30)\n",
        "        )\n",
        "\n",
        "        folder = \"/Users/grant/Dropbox/3Blue1Brown/videos/2022/visual_proofs/lies/images/\"\n",
        "        rational_example = VGroup(numbers, properties)\n",
        "        circle_example = Group(\n",
        "            Group(*(\n",
        "                ImageMobject(os.path.join(folder, \"SquareApprox\" + end)).set_width(1.25)\n",
        "                for end in [\"1\", \"2\", \"3\", \"4\", \"Inf\"]\n",
        "            )),\n",
        "            VGroup(\n",
        "                *TexText(\"Len = 8\").replicate(n),\n",
        "                OldTexText(\"Len = $2\\\\pi$\")\n",
        "            )\n",
        "        )\n",
        "        fourier_example = Group(\n",
        "            Group(*(\n",
        "                ImageMobject(os.path.join(folder, \"Fourier\" + end)).set_width(1.25)\n",
        "                for end in [\"1\", \"2\", \"3\", \"4\", \"Inf\"]\n",
        "            )),\n",
        "            VGroup(\n",
        "                *TexText(\"Continuous\").replicate(n),\n",
        "                OldTexText(\"Discontinuous\")\n",
        "            )\n",
        "        )\n",
        "        examples = Group(rational_example, circle_example, fourier_example)\n",
        "\n",
        "        for objs, descs in examples:\n",
        "            arrow = OldTex(\"\\\\cdots \\\\, \\\\rightarrow\", font_size=72)\n",
        "            group = Group(*objs[:n], arrow, objs[n])\n",
        "            for x, mob in enumerate(group):\n",
        "                mob.move_to(2.75 * x * RIGHT)\n",
        "            group.set_x(0)\n",
        "            for desc, obj in zip(descs, objs):\n",
        "                desc.set_max_width(1.25 * obj.get_width())\n",
        "                desc.next_to(obj, DOWN)\n",
        "            descs[:n].set_color(BLUE)\n",
        "            descs[n].set_color(YELLOW)\n",
        "            objs.insert_submobject(n, arrow)\n",
        "\n",
        "        examples.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        examples.set_height(5.0)\n",
        "        examples.to_edge(DOWN)\n",
        "\n",
        "        for i in range(3):\n",
        "            objs, descs = examples[i]\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeIn, objs, lag_ratio=0.5, scale=2),\n",
        "                LaggedStartMap(FadeIn, descs, lag_ratio=0.5, scale=2),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "\n",
        "class WhyWeNeedProofs(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        phrases = VGroup(\n",
        "            Text(\"Looks can be deceiving\"),\n",
        "            Text(\"We need rigor!\"),\n",
        "            Text(\"We need proofs!\"),\n",
        "        )\n",
        "        phrases.move_to(self.hold_up_spot, DOWN)\n",
        "        for phrase in phrases:\n",
        "            phrase.shift_onto_screen()\n",
        "            phrase.align_to(phrases[0], LEFT)\n",
        "\n",
        "        image = ImageMobject(\"Euclid\").set_height(3)\n",
        "        rect = SurroundingRectangle(image, buff=0)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        name = Text(\"Euclid\")\n",
        "        name.next_to(image, DOWN, )\n",
        "        euclid = Group(image, rect, name)\n",
        "        euclid.to_corner(UL)\n",
        "\n",
        "        morty = self.teacher\n",
        "        ss = self.students\n",
        "\n",
        "        # Show phrases\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            FadeIn(phrases[0], UP),\n",
        "            ss[0].change(\"happy\"),\n",
        "            ss[1].change(\"tease\"),\n",
        "            ss[2].change(\"happy\"),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"hooray\"),\n",
        "            phrases[0].animate.shift(UP),\n",
        "            FadeIn(phrases[1], UP),\n",
        "        )\n",
        "        self.play(\n",
        "            phrases[0].animate.shift(UP),\n",
        "            phrases[1].animate.shift(UP),\n",
        "            FadeIn(phrases[2], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"tease\"),\n",
        "            FadeIn(euclid, lag_ratio=0.3),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"thinking\", look_at=euclid)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class Proof3Slide(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        title = OldTexText(\"``Proof'' \\\\#3\", font_size=60)\n",
        "        subtitle = Text(\"All triangles are isosceles\", font_size=60, color=BLUE)\n",
        "        title.to_edge(UP)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        self.add(title, subtitle)\n",
        "\n",
        "        # Triangle\n",
        "        tri = Triangle()\n",
        "        tri.set_fill(BLUE_E)\n",
        "        tri.set_stroke(WHITE, 1)\n",
        "        tri.stretch(2, 1)\n",
        "        tri.to_corner(DL, buff=LARGE_BUFF).shift(RIGHT)\n",
        "        A, B, C = tri.get_top(), tri.get_corner(DL), tri.get_corner(DR)\n",
        "        AB = Line(A, B, color=YELLOW)\n",
        "        AC = Line(A, C, color=TEAL)\n",
        "        eq = OldTex(\"\\\\overline{AB}\", \" = \", \"\\\\overline{AC}\")\n",
        "        eq.next_to(tri, UP)\n",
        "        eq[0].match_color(AB)\n",
        "        eq[2].match_color(AC)\n",
        "\n",
        "        self.add(tri)\n",
        "        self.play(ShowCreation(AB), Write(eq[0]))\n",
        "        self.play(\n",
        "            TransformFromCopy(AB, AC),\n",
        "            FadeTransform(eq[0].copy(), eq[2]),\n",
        "            Write(eq[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SpeakingOfLimits(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.says(\"Speaking of\\nlimits...\"),\n",
        "            self.change_students(\"happy\", \"tease\", \"thinking\"),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class IntegralExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        axes = Axes((-1, 4), (-1, 10), width=12, height=6)\n",
        "        graph = axes.get_graph(lambda x: x**2)\n",
        "        graph.set_stroke(TEAL, 2)\n",
        "        all_rects = VGroup(*(\n",
        "            axes.get_riemann_rectangles(graph, (0, 3), dx).set_stroke(BLACK, np.round(4 * dx, 1), behind=False)\n",
        "            for dx in [2**(-n) for n in range(2, 8)]\n",
        "        ))\n",
        "        rects = all_rects[0]\n",
        "        last_rects = all_rects[-1].copy()\n",
        "        last_rects.set_stroke(width=0)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(FadeIn(last_rects, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rects, lag_ratio=0.1), FadeOut(last_rects))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            ApplyMethod(rect.set_color, YELLOW, rate_func=there_and_back)\n",
        "            for rect in rects\n",
        "        ), lag_ratio=0.5, run_time=4))\n",
        "\n",
        "        # Iterations\n",
        "        for new_rects in all_rects[1:]:\n",
        "            self.play(Transform(rects, new_rects))\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Zoom\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.play(frame.animate.move_to(graph.pfp(0.5)).set_height(0.1), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(frame.animate.to_default_state(), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntegralError(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # (Coped from above)\n",
        "        axes = Axes((-1, 4), (-1, 10), width=12, height=6)\n",
        "        graph = axes.get_graph(lambda x: x**2)\n",
        "        graph.set_stroke(TEAL, 2)\n",
        "        all_rects = VGroup(*(\n",
        "            axes.get_riemann_rectangles(graph, (0, 3), dx).set_stroke(BLACK, np.round(4 * dx, 1), behind=False)\n",
        "            for dx in [2**(-n) for n in range(2, 9)]\n",
        "        ))\n",
        "        rects = all_rects[0]\n",
        "        last_rects = all_rects[-1].copy()\n",
        "        last_rects.set_stroke(width=0)\n",
        "\n",
        "        self.add(axes, graph)\n",
        "        self.add(rects)\n",
        "\n",
        "        # Mention error\n",
        "        error = last_rects.copy()\n",
        "        error.set_fill(RED, 1)\n",
        "\n",
        "        error_label = Text(\"Error\", font_size=72, color=RED)\n",
        "        error_label.move_to(rects, UP).shift(UP)\n",
        "        error_arrows = VGroup(*(\n",
        "            Arrow(error_label, rect.get_top() + 0.2 * UP, stroke_width=2, tip_width_ratio=8)\n",
        "            for rect in rects\n",
        "        ))\n",
        "        error_arrows.set_color(RED)\n",
        "\n",
        "        self.add(error, rects)\n",
        "        self.play(\n",
        "            FadeIn(error, lag_ratio=0.5, run_time=2),\n",
        "            Write(error_label, stroke_color=RED),\n",
        "            LaggedStart(*(\n",
        "                ShowCreation(arrow)\n",
        "                for arrow in error_arrows\n",
        "            ), lag_ratio=0.2, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Error boxes\n",
        "        all_error_boxes = VGroup()\n",
        "        for rg in all_rects:\n",
        "            boxes = VGroup()\n",
        "            for rect in rg:\n",
        "                box = Rectangle(stroke_width=0, fill_opacity=0.5, fill_color=RED)\n",
        "                box.replace(Line(\n",
        "                    axes.i2gp(axes.x_axis.p2n(rect.get_left()), graph),\n",
        "                    axes.i2gp(axes.x_axis.p2n(rect.get_right()), graph),\n",
        "                ), stretch=True)\n",
        "                boxes.add(box)\n",
        "            all_error_boxes.add(boxes)\n",
        "        self.play(\n",
        "            FadeIn(all_error_boxes[0], lag_ratio=0.1),\n",
        "            error.animate.set_opacity(0.25),\n",
        "            FadeOut(error_arrows),\n",
        "        )\n",
        "        for rg, ebg in zip(all_rects, all_error_boxes):\n",
        "            for rect, box in zip(rg, ebg):\n",
        "                rect.add(box)\n",
        "        self.remove(all_error_boxes)\n",
        "        self.add(rects)\n",
        "\n",
        "        # Inequality\n",
        "        error_label.generate_target()\n",
        "        error_label.target.scale(0.7)\n",
        "        sum_squares = Tex(\"< \\\\sum \\\\Delta\", isolate=\"\\\\Delta\")\n",
        "        rhs = VGroup(OldTex(\"=\"), DecimalNumber(num_decimal_places=4))\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs[1].set_value(0.3417)\n",
        "\n",
        "        group = VGroup(error_label.target, sum_squares, rhs)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        pre_box_sym = rects[-1].submobjects[0]\n",
        "        box_sym = pre_box_sym.copy()\n",
        "        box_sym.replace(sum_squares[2], dim_to_match=1)\n",
        "        sum_squares.replace_submobject(2, box_sym)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(error_label),\n",
        "            Write(sum_squares[:2]),\n",
        "            TransformFromCopy(pre_box_sym, box_sym)\n",
        "        )\n",
        "        self.add(rhs)\n",
        "        self.play(\n",
        "            CountInFrom(rhs[1], 0),\n",
        "            LaggedStart(*(\n",
        "                VFadeInThenOut(r.copy().set_fill(opacity=1), buff=0, color=RED)\n",
        "                for r in all_error_boxes[0]\n",
        "            ), lag_ratio=0.2),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Iterations\n",
        "        for new_rects in all_rects[1:]:\n",
        "            self.play(\n",
        "                Transform(rects, new_rects),\n",
        "                ChangeDecimalToValue(rhs[1], rhs[1].get_value() / 4),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class IntegralExampleWithErrorBoxes(IntegralExample):\n",
        "    show_error_boxes = True\n",
        "\n",
        "\n",
        "class DefiningTheLengthOfACurve(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class FalseEuclidProofAnnotation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # path = \"/Users/grant/Dropbox/3Blue1Brown/videos/2022/visual_proofs/lies/images/FalseEuclidProof.jpg\"\n",
        "        # self.add(ImageMobject(path).set_width(FRAME_WIDTH))\n",
        "\n",
        "        # Points\n",
        "        A = np.array([-1.94444444, 1.44444444, 0.])\n",
        "        B = np.array([-4.44444444, -0.02777778, 0.])\n",
        "        C = np.array([-1.09722222, -0.48611111, 0.])\n",
        "        D = np.array([-2.63888889, -0.27777778, 0.])\n",
        "        E = np.array([-1.56944444, 0.55555556, 0.])\n",
        "        F = np.array([-3.01388889, 0.83555556, 0.])\n",
        "        P = np.array([-2.58333333, 0.122222, 0.])\n",
        "        # dots = Group(*(GlowDot(point, color=RED) for point in [A, B, C, D, E, F, P]))\n",
        "\n",
        "        AFP = Polygon(A, F, P)\n",
        "        AEP = Polygon(A, E, P)\n",
        "        BPD = Polygon(B, P, D)\n",
        "        CPD = Polygon(C, P, D)\n",
        "        BFP = Polygon(B, F, P)\n",
        "        CEP = Polygon(C, E, P)\n",
        "\n",
        "        tris = VGroup(AFP, AEP, BPD, CPD, BFP, CEP)\n",
        "        tris.set_stroke(BLACK, 1)\n",
        "        tris[:2].set_fill(BLUE)\n",
        "        tris[2:4].set_fill(GREEN)\n",
        "        tris[4:].set_fill(RED)\n",
        "        tris.set_fill(opacity=0.8)\n",
        "\n",
        "        # Final sum\n",
        "        AF = Line(A, F)\n",
        "        FB = Line(F, B)\n",
        "        AB = Line(A, B)\n",
        "        AE = Line(A, E)\n",
        "        EC = Line(E, C)\n",
        "        AC = Line(A, C)\n",
        "        lines = VGroup(AF, FB, AB, AE, EC, AC)\n",
        "        for line in lines:\n",
        "            brace = Brace(Line(ORIGIN, line.get_length() * RIGHT), UP)\n",
        "            brace.next_to(ORIGIN, UP, buff=0.1)\n",
        "            angle = line.get_angle()\n",
        "            angle = (angle + PI / 2) % PI - PI / 2\n",
        "            brace.rotate(angle, about_point=ORIGIN)\n",
        "            brace.shift(line.get_center())\n",
        "            brace.set_fill(BLACK, 1)\n",
        "            line.brace = brace\n",
        "\n",
        "        self.play(GrowFromCenter(AF.brace), run_time=1)\n",
        "        self.play(GrowFromCenter(FB.brace), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(AF.brace, AB.brace, path_arc=45 * DEGREES),\n",
        "            Transform(FB.brace, AB.brace, path_arc=45 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(AE.brace), run_time=1)\n",
        "        self.play(GrowFromCenter(EC.brace), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(AE.brace, AC.brace, path_arc=45 * DEGREES),\n",
        "            Transform(EC.brace, AC.brace, path_arc=45 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "        return\n",
        "\n",
        "        # Lines for final triangles\n",
        "        BP = Line(B, P)\n",
        "        CP = Line(C, P)\n",
        "        PF = Line(P, F)\n",
        "        PE = Line(P, E)\n",
        "        BF = Line(B, F)\n",
        "        CE = Line(C, E)\n",
        "\n",
        "        VGroup(BP, CP).set_stroke(BLUE_E, 5)\n",
        "        VGroup(PF, PE).set_stroke(TEAL, 5)\n",
        "        VGroup(BF, CE).set_stroke(RED, 5)\n",
        "\n",
        "        self.play(*map(ShowCreation, [BP, CP]))\n",
        "        self.play(*map(ShowCreation, [PF, PE]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(PF, BF, path_arc=90 * DEGREES),\n",
        "            TransformFromCopy(PE, CE, path_arc=-90 * DEGREES),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Compare AB to BC\n",
        "        AB = Line(A, B).set_stroke(RED, 3)\n",
        "        AC = Line(A, C).set_stroke(BLUE, 3)\n",
        "\n",
        "        self.play(ShowCreation(AB))\n",
        "        self.play(ShowCreation(AC))\n",
        "        self.wait()\n",
        "        self.add(AB.copy(), AC.copy())\n",
        "        self.play(\n",
        "            AB.animate.set_angle(-90 * DEGREES).next_to(A, RIGHT, aligned_edge=UP, buff=2),\n",
        "            AC.animate.set_angle(-90 * DEGREES).next_to(A, RIGHT, aligned_edge=UP, buff=2.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(AB), FadeOut(AC))\n",
        "\n",
        "        # Bisector labels\n",
        "        perp = Text(\"Perpendicular\\nbisector\", font_size=30, color=BLACK, stroke_width=0)\n",
        "        perp.next_to(F, UL, buff=0.5)\n",
        "        perp.set_color(BLUE_E)\n",
        "        perp_arrow = Arrow(perp, midpoint(D, P), buff=0.1, stroke_width=2)\n",
        "        perp_arrow.match_color(perp)\n",
        "\n",
        "        ang_b = Text(\"Angle\\nbisector\", font_size=30, color=BLACK, stroke_width=0)\n",
        "        ang_b.next_to(F, UL, buff=0.5)\n",
        "        ang_b.set_color(RED_E)\n",
        "        ang_b_arrow = Arrow(ang_b, midpoint(A, P), buff=0.1, stroke_width=2)\n",
        "        ang_b_arrow.match_color(ang_b)\n",
        "\n",
        "        self.play(Write(perp), ShowCreation(perp_arrow), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(perp), FadeOut(perp_arrow))\n",
        "        self.wait()\n",
        "        self.play(Write(ang_b), ShowCreation(ang_b_arrow), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(ang_b), FadeOut(ang_b_arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Similar triangles\n",
        "        for pair in [(AFP, AEP), (BPD, CPD), (BFP, CEP)]:\n",
        "            self.play(DrawBorderThenFill(pair[0]))\n",
        "            self.play(TransformFromCopy(pair[0], pair[1]))\n",
        "            self.wait()\n",
        "            self.play(LaggedStartMap(FadeOut, VGroup(*pair)))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class FalseEuclidFollowup(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # All triangles are equilateral\n",
        "        tri1 = Polygon(3 * UP, DL, RIGHT)\n",
        "        tri2 = Polygon(3 * UP, LEFT, RIGHT)\n",
        "        tri3 = tri2.copy().set_height(math.sqrt(3) * tri2.get_width() / 2, stretch=True, about_edge=DOWN)\n",
        "        tris = VGroup(tri1, tri2, tri3)\n",
        "        tris.set_fill(BLUE_D, 1)\n",
        "        tris.set_stroke(WHITE, 2)\n",
        "        tris.scale(1.5)\n",
        "        tris.to_edge(DOWN, buff=1.0)\n",
        "        tri = tri1\n",
        "\n",
        "        def get_side(i, j, tri=tri):\n",
        "            return Line(tri.get_vertices()[i], tri.get_vertices()[j]).set_stroke(YELLOW, 4)\n",
        "\n",
        "        labels = Text(\"ABC\")\n",
        "        for letter, vert in zip(labels, tri.get_vertices()):\n",
        "            letter.next_to(vert, normalize(vert - tri.get_center_of_mass()), SMALL_BUFF)\n",
        "\n",
        "        equation = Tex(\"\\\\overline{AB} = \\\\overline{AC}\")\n",
        "        equation2 = Tex(\"\\\\overline{AB} = \\\\overline{AC} = \\\\overline{BC}\")\n",
        "        equation.next_to(labels, LEFT, aligned_edge=UP)\n",
        "        equation2.move_to(equation).to_edge(LEFT)\n",
        "        words = Text(\"All triangles are\\nisosceles\")\n",
        "        words.next_to(equation, DOWN, LARGE_BUFF)\n",
        "        VGroup(equation, words).to_edge(LEFT)\n",
        "        iso = words.select_parts(\"isosceles\")\n",
        "        iso_cross = Cross(iso)\n",
        "        equi = Text(\"equilateral\")\n",
        "        equi.move_to(iso, UP)\n",
        "        equi.set_color(YELLOW)\n",
        "\n",
        "        self.add(tri, labels)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(equation), FadeIn(words),\n",
        "            ShowCreationThenDestruction(get_side(0, 1), run_time=2),\n",
        "            ShowCreationThenDestruction(get_side(0, 2), run_time=2),\n",
        "        )\n",
        "        self.play(Transform(tri, tri2), labels[1].animate.shift(1.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(CyclicReplace(*labels))\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(get_side(1, 0), run_time=2),\n",
        "            ShowCreationThenDestruction(get_side(1, 2), run_time=2),\n",
        "            ShowCreation(iso_cross)\n",
        "        )\n",
        "        cross_group = VGroup(iso, iso_cross)\n",
        "        self.play(\n",
        "            cross_group.animate.shift(DOWN),\n",
        "            FadeIn(equi, 0.5 * DOWN),\n",
        "            Transform(tri, tri3),\n",
        "            labels[2].animate.next_to(tri3, UP, SMALL_BUFF)\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(equation, equation2[:len(equation)]),\n",
        "            FadeIn(equation2[len(equation):], RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        words = VGroup(words.select_parts(\"All triangles are\"), equi)\n",
        "\n",
        "        # Three possibilities\n",
        "        possibilities = VGroup(\n",
        "            Text(\"1. This is true\"),\n",
        "            OldTexText(\"2. Euclid's axioms $\\\\Rightarrow$ falsehoods\")[0],\n",
        "            Text(\"3. This proof has a flaw\"),\n",
        "        )\n",
        "        possibilities.arrange(DOWN, buff=1.0, aligned_edge=LEFT)\n",
        "        possibilities.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        poss_title = Text(\"Possibilities\", font_size=60)\n",
        "        poss_title.next_to(possibilities, UP, buff=1.5, aligned_edge=LEFT)\n",
        "        poss_title.add(Underline(poss_title))\n",
        "\n",
        "        tri.add(labels)\n",
        "        self.play(\n",
        "            FadeOut(cross_group, DL),\n",
        "            tri.animate.match_width(words).next_to(words, DOWN, LARGE_BUFF),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(poss[:2], shift=LEFT)\n",
        "                for poss in possibilities\n",
        "            )),\n",
        "            Write(poss_title)\n",
        "        )\n",
        "        self.wait()\n",
        "        for poss in possibilities:\n",
        "            self.play(Write(poss[2:], stroke_color=WHITE))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class TryToFindFault(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        morty = self.teacher\n",
        "        ss = self.students\n",
        "\n",
        "        points = compass_directions(5, start_vect=UP)\n",
        "        star = Polygon(*(points[i] for i in [0, 2, 4, 1, 3]))\n",
        "        star.set_fill(YELLOW, 1)\n",
        "        star.set_stroke(width=0)\n",
        "        star.set_gloss(1)\n",
        "        star.set_height(0.5)\n",
        "        stars = star.replicate(3)\n",
        "        stars.arrange(RIGHT)\n",
        "        stars.move_to(self.hold_up_spot, DOWN)\n",
        "        stars.insert_n_curves(10)\n",
        "        stars.refresh_triangulation()\n",
        "\n",
        "        self.play(\n",
        "            morty.says(\"I dare you to\\nfind a fault\", mode=\"tease\"),\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"pondering\", \"sassy\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.debubble(mode=\"raise_right_hand\"),\n",
        "            self.change_students(\"thinking\", \"happy\", \"tease\"),\n",
        "            Write(stars)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class SideSumTruthiness(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Lines\n",
        "        A, E, C = Dot().replicate(3)\n",
        "        A.move_to(2 * UL)\n",
        "        C.move_to(DR)\n",
        "        VGroup(A, C).to_corner(DR, buff=1.5)\n",
        "\n",
        "        alpha_tracker = ValueTracker(0.75)\n",
        "        E.add_updater(lambda m: m.move_to(interpolate(\n",
        "            A.get_center(), C.get_center(), alpha_tracker.get_value()\n",
        "        )))\n",
        "\n",
        "        AE = Line().set_stroke(RED, 3, opacity=0.75)\n",
        "        EC = Line().set_stroke(BLUE, 3, opacity=0.75)\n",
        "        AE.add_updater(lambda l: l.put_start_and_end_on(A.get_center(), E.get_center()))\n",
        "        EC.add_updater(lambda l: l.put_start_and_end_on(E.get_center(), C.get_center()))\n",
        "\n",
        "        labels = Text(\"AEC\")\n",
        "        labels[0].next_to(A, UP, SMALL_BUFF)\n",
        "        labels[1].add_updater(lambda m: m.next_to(E, DL, SMALL_BUFF))\n",
        "        labels[2].next_to(C, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(AE, EC, A, E, C, *labels)\n",
        "\n",
        "        # Equation\n",
        "        eq = OldTex(\"\\\\overline{AE} + \\\\overline{EC} = \\\\overline{AC}\", font_size=60)\n",
        "        eq.to_corner(UR)\n",
        "\n",
        "        labels = VGroup(\n",
        "            VGroup(Text(\"True\"), Checkmark()),\n",
        "            VGroup(Text(\"False\"), Exmark()),\n",
        "        )\n",
        "        labels.scale(60 / 48)\n",
        "        for label in labels:\n",
        "            label[0].match_color(label[1])\n",
        "            label.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "            label.next_to(eq, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        labels[0].add_updater(lambda m: m.set_opacity(1 if 0 < alpha_tracker.get_value() < 1 else 0))\n",
        "        labels[1].add_updater(lambda m: m.set_opacity(0 if 0 < alpha_tracker.get_value() < 1 else 1))\n",
        "\n",
        "        self.add(eq)\n",
        "        self.add(labels)\n",
        "\n",
        "        # Move around\n",
        "        for alpha in [0.3, 0.7, 0.5, 0.7, 0.3, -0.3, 0.7, 1.4, 1.2, 0.5]:\n",
        "            self.play(alpha_tracker.animate.set_value(alpha), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PythagoreanProofSketch(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # First orientation\n",
        "        tri = Polygon(ORIGIN, UP, 2 * RIGHT)\n",
        "        tri.set_stroke(WHITE, 1)\n",
        "        tri.set_fill(BLUE_E, 1)\n",
        "\n",
        "        verts = tri.get_vertices()\n",
        "        tris = VGroup(tri, tri.copy().rotate(PI, about_point=midpoint(*verts[1:])))\n",
        "        tris.add(*tris.copy().rotate(PI, axis=UL, about_point=tris.get_corner(DL)))\n",
        "        tris[2:4].flip(UP)\n",
        "        big_square = SurroundingRectangle(tris, buff=0)\n",
        "        big_square.set_stroke(WHITE, 2)\n",
        "        VGroup(tris, big_square).center().set_height(5)\n",
        "\n",
        "        A, B = tri.get_height(), tri.get_width()\n",
        "        a_square = Square(A)\n",
        "        a_square.move_to(big_square, UL)\n",
        "        a_square.set_fill(RED_C, 0.75)\n",
        "        b_square = Square(B)\n",
        "        b_square.move_to(big_square, DR)\n",
        "        b_square.set_fill(RED_D, 0.75)\n",
        "\n",
        "        a_square_label = Tex(\"a^2\").move_to(a_square)\n",
        "        b_square_label = Tex(\"b^2\").move_to(b_square)\n",
        "\n",
        "        # Pre triangle\n",
        "        pre_tri = tris[0].copy()\n",
        "        pre_tri.scale(1.5)\n",
        "        pre_tri.shift(-pre_tri.get_center_of_mass())\n",
        "        side_labels = Tex(\"abc\")\n",
        "        side_labels[0].next_to(pre_tri, LEFT)\n",
        "        side_labels[1].next_to(pre_tri, DOWN)\n",
        "        side_labels[2].next_to(pre_tri.get_center(), UR)\n",
        "\n",
        "        self.add(pre_tri)\n",
        "        self.add(side_labels)\n",
        "\n",
        "        # Equation\n",
        "        equation = Tex(\"a^2 + b^2 = c^2\", isolate=[\"a^2\", \"+\", \"b^2\", \"=\", \"c^2\"])\n",
        "        equation.next_to(big_square, UP).to_edge(UP)\n",
        "\n",
        "        # A^2 and B^2\n",
        "        scale_factor = tris[0].get_height() / pre_tri.get_height()\n",
        "        shift_vect = tris[0].get_center() - pre_tri.get_center()\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_tri, tris[0]),\n",
        "            side_labels.animate.scale(scale_factor, about_point=pre_tri.get_center()).shift(shift_vect)\n",
        "        )\n",
        "        self.add(tris[1], side_labels)\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(tris[0], tris[1], path_arc=PI),\n",
        "            TransformFromCopy(tris[0], tris[2]),\n",
        "            TransformFromCopy(tris[0], tris[3]),\n",
        "            FadeIn(big_square),\n",
        "            Animation(side_labels),\n",
        "            lag_ratio=0.3\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(a_square),\n",
        "            FadeTransform(side_labels[0], a_square_label),\n",
        "            FadeIn(b_square),\n",
        "            FadeTransform(side_labels[1], b_square_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(a_square),\n",
        "            FadeOut(b_square),\n",
        "            TransformFromCopy(a_square_label, equation.select_parts(\"a^2\")),\n",
        "            TransformFromCopy(b_square_label, equation.select_parts(\"b^2\")),\n",
        "            Write(equation.select_parts(\"+\")),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Second orientation\n",
        "        tris.save_state()\n",
        "        tris2 = tris.copy()\n",
        "\n",
        "        tris2[0].rotate(PI / 2, OUT, about_point=tris2[0].get_corner(DR))\n",
        "        tris2[3].rotate(-PI / 2).move_to(big_square, DL)\n",
        "        tris2[2].move_to(big_square, UL)\n",
        "\n",
        "        c_square = Square(math.sqrt(A**2 + B**2))\n",
        "        c_square.rotate(math.atan(B / A))\n",
        "        c_square.move_to(big_square)\n",
        "        c_square.set_fill(RED_D, 0.7)\n",
        "        c_square_label = Tex(\"c^2\").move_to(c_square)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(a_square_label),\n",
        "            FadeOut(b_square_label),\n",
        "            *(Transform(tris[i], tris2[i]) for i in (0, 2, 3)),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(c_square),\n",
        "            FadeIn(c_square_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(c_square_label.copy(), equation.select_parts(\"c^2\")),\n",
        "            Write(equation.select_parts(\"=\")),\n",
        "            c_square.animate.set_fill(opacity=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(c_square))\n",
        "\n",
        "        # Final gif\n",
        "        self.play(\n",
        "            Transform(tris, tris.saved_state, lag_ratio=0.2, run_time=3, path_arc=45 * DEGREES),\n",
        "            FadeOut(c_square_label),\n",
        "            FadeIn(a_square_label, time_span=(1.5, 2.5)),\n",
        "            FadeIn(b_square_label, time_span=(2, 3)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(tris, tris2, lag_ratio=0.2, run_time=3, path_arc=45 * DEGREES),\n",
        "            FadeIn(c_square_label, time_span=(2, 3)),\n",
        "            FadeOut(a_square_label, time_span=(0, 1)),\n",
        "            FadeOut(b_square_label, time_span=(0.5, 1.5)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LastSideBySide(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        squares = Square().replicate(2)\n",
        "        squares.set_stroke(WHITE, 2)\n",
        "        squares.set_fill(BLACK, 2)\n",
        "        squares.set_height(5)\n",
        "        squares.set_width(6, stretch=True)\n",
        "        for square, vect in zip(squares, [LEFT, RIGHT]):\n",
        "            square.move_to(FRAME_WIDTH * vect / 4)\n",
        "        squares.to_edge(DOWN, buff=0.7)\n",
        "        self.add(squares)\n",
        "\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Given examples\\\\\\\\like this...\"),\n",
        "            OldTexText(\"What's needed to\\\\\\\\make this rigorous?\"),\n",
        "        )\n",
        "        for title, square in zip(titles, squares):\n",
        "            title.next_to(square, UP, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(titles[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(titles[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ByTheWay(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.play(Write(Text(\"By the way...\")))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"thanks_words\": \"Special thanks to the following patrons\",\n",
        "    }\n"
    ]
}