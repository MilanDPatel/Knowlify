{
    "topic": "is demonstrating the concept of Fourier analysis and visualization. It takes an audio file",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.piano.fourier_animations import DecomposeAudioSegment\n",
        "from _2019.diffyq.part2.fourier_series import FourierCirclesScene\n",
        "\n",
        "\n",
        "class DecomposeRoar_SlowFPS(DecomposeAudioSegment):\n",
        "    audio_file = \"/Users/grant/Dropbox/3Blue1Brown/videos/2022/infinity/Roar.wav\"\n",
        "    graph_point = 0.428\n",
        "    zoom_rect_dims = (0.2, 6.0)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_full_waveform(run_time=2.5)\n",
        "        self.zoom_in_on_segment(\n",
        "            self.axes, self.graph,\n",
        "            self.graph_point, self.zoom_rect_dims,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.prepare_for_3d()\n",
        "        self.show_all_waves()\n",
        "\n",
        "    def show_all_waves(self):\n",
        "        t_axes = self.axes\n",
        "        graph = self.graph\n",
        "\n",
        "        # Take the fourier transform\n",
        "        t_max = t_axes.x_range[1]\n",
        "        ts, values = t_axes.p2c(graph.get_points()[::6])\n",
        "        signal = values[(ts > 0) * (ts < t_max)]\n",
        "        signal_fft = np.fft.fft(signal)\n",
        "        signal_fft /= len(signal)\n",
        "        signal_fft_abs = np.abs(signal_fft)\n",
        "        signal_fft_phase = np.log(signal_fft).imag\n",
        "\n",
        "        # Prepare the graph\n",
        "        max_freq = signal.size / t_max\n",
        "        f_axes = Axes(\n",
        "            (0, max_freq / 2, max_freq / len(signal) / 2),\n",
        "            (0, 1, 1 / 8),\n",
        "            height=t_axes.get_depth(),\n",
        "            width=150,\n",
        "        )\n",
        "        f_axes.rotate(PI / 2, RIGHT)\n",
        "        f_axes.rotate(PI / 2, OUT)\n",
        "        f_axes.shift(t_axes.get_origin() - f_axes.get_origin())\n",
        "        freqs = np.fft.fftfreq(signal.size, 1 / max_freq) % max_freq\n",
        "\n",
        "        # Express the most dominant signals as sine waves\n",
        "        sine_waves = VGroup()\n",
        "        amps = []\n",
        "        for index in range(1, 50):\n",
        "            freq = freqs[index]\n",
        "            amp = signal_fft_abs[index]\n",
        "            phase = signal_fft_phase[index]\n",
        "            wave = t_axes.get_graph(\n",
        "                lambda t: 2 * amp * np.cos(TAU * freq * (t + phase)),\n",
        "                x_range=(0, t_max),\n",
        "            )\n",
        "            wave.match_y(f_axes.c2p(freq, 0))\n",
        "            # wave.set_stroke(opacity=0.75)\n",
        "            wave.set_stroke(opacity=1.0)\n",
        "            wave.amp = amp\n",
        "            wave.freq = freq\n",
        "            wave.phase = phase\n",
        "            amps.append(amp)\n",
        "            sine_waves.add(wave)\n",
        "\n",
        "        sine_waves.set_submobject_colors_by_gradient(YELLOW, GREEN, RED, ORANGE)\n",
        "        sine_waves.set_stroke(width=3)\n",
        "\n",
        "        # Break down\n",
        "        frame = self.camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.reorient(67, 71)\n",
        "        frame.target.set_height(10.5)\n",
        "        frame.target.move_to([2.6, 6.15, 0.79])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(f_axes),\n",
        "            MoveToTarget(frame),\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    ReplacementTransform(\n",
        "                        graph.copy().set_opacity(0),\n",
        "                        wave\n",
        "                    )\n",
        "                    for wave in sine_waves\n",
        "                ),\n",
        "                lag_ratio=1 / len(sine_waves),\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class CombineWavesToImage_SlowFPS(FourierCirclesScene):\n",
        "    CONFIG = {\n",
        "        \"drawing_height\": 6.0,\n",
        "        \"n_shown_waves\": 5,\n",
        "        \"n_vectors\": 500,\n",
        "        # \"n_vectors\": 50,\n",
        "        \"slow_factor\": 0.1,\n",
        "        \"max_circle_stroke_width\": 2.0,\n",
        "        \"parametric_function_step_size\": 0.001,\n",
        "        # \"parametric_function_step_size\": 0.01,\n",
        "        \"drawn_path_color\": YELLOW,\n",
        "        \"remove_background_waves\": False,\n",
        "        \"drawing_file\": \"/Users/grant/Dropbox/3Blue1Brown/videos/2022/infinity/monster-holding-piece-sign-3.svg\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.generate_coefs()\n",
        "        self.show_sine_waves()\n",
        "        self.piece_together_circles()\n",
        "\n",
        "    def generate_coefs(self):\n",
        "        drawing = self.get_drawing()\n",
        "        coefs = self.get_coefficients_of_path(drawing)\n",
        "        vectors = self.get_rotating_vectors(coefficients=coefs)\n",
        "        circles = self.get_circles(vectors)\n",
        "\n",
        "        self.style_vectors(vectors)\n",
        "        self.style_circles(circles)\n",
        "\n",
        "        self.path = drawing\n",
        "        self.coefs = coefs\n",
        "        self.vectors = vectors\n",
        "        self.circles = circles\n",
        "\n",
        "    def show_sine_waves(self):\n",
        "        # Initialized copycat vectors and circles\n",
        "        s = slice(1, 1 + self.n_shown_waves)\n",
        "        shown_vectors = self.vectors[s].copy().clear_updaters()\n",
        "        shown_circles = self.circles[s].copy().clear_updaters()\n",
        "        scale_factor = 1.0 / 3.0\n",
        "        for vect, circ in zip(shown_vectors, shown_circles):\n",
        "            vect.scale(scale_factor)\n",
        "            circ.scale(scale_factor)\n",
        "            vect.center_point = VectorizedPoint()\n",
        "            vect.center_func = vect.center_point.get_center\n",
        "            circ.center_func = vect.center_point.get_center\n",
        "            vect.add_updater(lambda v: v.set_angle(\n",
        "                np.log(v.coefficient).imag + self.get_vector_time() * v.freq * TAU\n",
        "            ))\n",
        "            vect.add_updater(lambda v: v.shift(v.center_func() - v.get_start()))\n",
        "            circ.add_updater(lambda c: c.move_to(c.center_func()))\n",
        "        shown_circles.set_stroke(width=2)\n",
        "        shown_vectors.set_stroke(width=2)\n",
        "        graphs = VGroup()\n",
        "\n",
        "        # Add axes\n",
        "        max_y = int(np.ceil(max(v.get_length() for v in shown_vectors)))\n",
        "        all_axes = VGroup(*(\n",
        "            Axes(\n",
        "                x_range=(0, 8 * PI, PI),\n",
        "                y_range=(-max_y, max_y),\n",
        "                height=1.0,\n",
        "                width=18,\n",
        "            )\n",
        "            for n in range(self.n_shown_waves)\n",
        "        ))\n",
        "        all_axes.arrange(DOWN, buff=1.0)\n",
        "\n",
        "        dots = OldTex(\"\\\\vdots\", font_size=100)\n",
        "        dots.next_to(all_axes, DOWN, buff=0.5)\n",
        "        dots.match_x(all_axes[0].get_origin())\n",
        "        dots.set_fill(WHITE)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        group = Group(all_axes, dots)\n",
        "        group.move_to(0.5 * UP)\n",
        "        group.set_height(7)\n",
        "        frame.set_height(group.get_height() + 1)\n",
        "        frame.move_to(group)\n",
        "        frame.shift(0.5 * LEFT)\n",
        "\n",
        "        # Add graphs\n",
        "        colors = color_gradient([RED, YELLOW], self.n_shown_waves)\n",
        "        v2g_lines = VGroup()\n",
        "        for vect, axes, color in zip(shown_vectors, all_axes, colors):\n",
        "            vect.center_point.next_to(axes, LEFT, buff=0.75)\n",
        "            axes.amp = vect.get_length() / axes.y_axis.get_unit_size()\n",
        "            axes.vect = vect\n",
        "            axes.color = color\n",
        "\n",
        "            axes.graph = always_redraw(\n",
        "                lambda a=axes: a.get_graph(\n",
        "                    lambda x: a.amp * math.sin(a.vect.freq * x + a.vect.get_angle()),\n",
        "                    stroke_width=2,\n",
        "                    stroke_color=a.color\n",
        "                )\n",
        "            )\n",
        "            graphs.add(axes.graph)\n",
        "\n",
        "            line = Line()\n",
        "            line.set_stroke(WHITE, 1.0)\n",
        "            line.vect = vect\n",
        "            line.graph = axes.graph\n",
        "            line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "                l.vect.get_end(), l.graph.get_start()\n",
        "            ))\n",
        "            v2g_lines.add(line)\n",
        "\n",
        "        # Animate the addition of all these?\n",
        "        self.wait(1)\n",
        "        for mobs in zip(all_axes, graphs, shown_vectors, shown_circles, v2g_lines):\n",
        "            self.add(*mobs)\n",
        "            self.wait(0.25)\n",
        "        self.add(dots)\n",
        "\n",
        "        self.all_axes = all_axes\n",
        "        self.shown_vectors = shown_vectors\n",
        "        self.shown_circles = shown_circles\n",
        "        self.graphs = graphs\n",
        "        self.v2g_lines = v2g_lines\n",
        "        self.dots = dots\n",
        "\n",
        "    def piece_together_circles(self):\n",
        "        # Setup path and labels\n",
        "        true_path = self.path\n",
        "        fade_region = self.get_fade_region(true_path)\n",
        "\n",
        "        rt = 5\n",
        "        # sf = self.get_slow_factor()\n",
        "        # future_vt = self.get_vector_time() + sf * rt\n",
        "\n",
        "        label = VGroup(Integer(100, edge_to_fix=DR), Text(\"terms\"))\n",
        "        label.arrange(RIGHT, buff=0.15)\n",
        "        label.next_to(true_path, UP, buff=0.85)\n",
        "        label[0].set_value(self.n_shown_waves)\n",
        "\n",
        "        # Animate entry\n",
        "        terms = self.get_terms(self.n_shown_waves)\n",
        "        self.play(\n",
        "            FadeIn(fade_region, lag_ratio=0.1),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(v1, v2)\n",
        "                for v1, v2 in zip(self.shown_vectors, self.vectors[1:])\n",
        "            ), lag_ratio=0.1),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(c1, c2)\n",
        "                for c1, c2 in zip(self.shown_circles, self.circles[1:])\n",
        "            ), lag_ratio=0.1),\n",
        "            FadeIn(label),\n",
        "            Write(terms),\n",
        "            run_time=rt,\n",
        "        )\n",
        "\n",
        "        # Set up drawn paths\n",
        "        drawn_path = self.get_drawn_path(self.vectors[:self.n_shown_waves + 1])\n",
        "        dot = self.add_draw_dot(self.vectors[:self.n_shown_waves + 1])\n",
        "        self.add(drawn_path, terms, dot)\n",
        "        anims = [\n",
        "            UpdateFromAlphaFunc(drawn_path, lambda m, a: m.set_stroke(interpolate_color(BLACK, YELLOW, a))),\n",
        "            UpdateFromAlphaFunc(dot, lambda m, a: m.set_opacity(a)),\n",
        "        ]\n",
        "        if self.remove_background_waves:\n",
        "            self.play(\n",
        "                fade_region.animate.set_height(2 * FRAME_WIDTH).set_opacity(0.05),\n",
        "                *anims,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.remove(\n",
        "                self.all_axes, self.graphs,\n",
        "                self.shown_vectors, self.shown_circles,\n",
        "                self.v2g_lines, self.dots,\n",
        "                fade_region,\n",
        "            )\n",
        "        else:\n",
        "            self.play(*anims, run_time=2)\n",
        "\n",
        "        # Now add on new vectors one at a time\n",
        "        drawn_paths = dict()\n",
        "        all_terms = dict()\n",
        "\n",
        "        drawing_group = VGroup(\n",
        "            drawn_path,\n",
        "            terms,\n",
        "            label,\n",
        "            VGroup(),  # Vectors\n",
        "            VGroup(),  # Circles\n",
        "        )\n",
        "\n",
        "        def update_drawing_group(group, alpha):\n",
        "            n, _ = integer_interpolate(self.n_shown_waves, self.n_vectors, alpha)\n",
        "            if n not in drawn_paths:\n",
        "                drawn_paths[n] = self.get_drawn_path(self.vectors[:n])\n",
        "            if n not in all_terms:\n",
        "                all_terms[n] = self.get_terms(n)\n",
        "            group.replace_submobject(0, drawn_paths[n])\n",
        "            group.replace_submobject(1, all_terms[n])\n",
        "            group[2][0].set_value(n)\n",
        "            group[3].set_submobjects(self.vectors[:n])\n",
        "            group[4].set_submobjects(self.circles[:n])\n",
        "\n",
        "            self.style_vectors(group[3])\n",
        "            self.style_circles(group[4])\n",
        "\n",
        "            if n > 25:\n",
        "                group[4].set_stroke(opacity=(1.0 / (n - 25))**0.2)\n",
        "\n",
        "            group.update()\n",
        "            return group\n",
        "\n",
        "        self.remove(self.vectors, self.circles, drawn_path, terms, dot)\n",
        "        self.add_draw_dot(drawing_group[3])\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            drawing_group, update_drawing_group,\n",
        "            run_time=15,\n",
        "            rate_func=lambda a: a**2,\n",
        "        ))\n",
        "\n",
        "        inf = OldTex(\"\\\\infty\")\n",
        "        inf.match_height(label[0])\n",
        "        inf.move_to(label[0], RIGHT)\n",
        "        inf.set_fill(WHITE)\n",
        "\n",
        "        drawn_path = drawing_group[0]\n",
        "        # self.add_path_fader(true_path, fade_rate=1)\n",
        "        true_path.set_stroke(width=1.0)\n",
        "\n",
        "        self.add(drawn_path, true_path, self.circles, self.vectors)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(drawn_path, lambda m, a: m.set_stroke(interpolate_color(YELLOW, BLACK, a))),\n",
        "            VFadeIn(true_path),\n",
        "            ChangeDecimalToValue(label[0], 1000),\n",
        "            VFadeOut(label[0]),\n",
        "            FadeIn(inf),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.remove(drawn_path)\n",
        "        self.wait(12)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_drawing(self):\n",
        "        svg = SVGMobject(self.drawing_file)\n",
        "        drawing = svg[1]\n",
        "        drawing.set_height(self.drawing_height)\n",
        "        drawing.set_stroke(self.drawn_path_color, 2)\n",
        "        return drawing\n",
        "\n",
        "    def get_peace_sign(self):\n",
        "        theta = 40 * DEGREES\n",
        "        arc1 = Arc(270 * DEGREES, -theta, n_components=1)\n",
        "        arc2 = Arc(270 * DEGREES + theta, -(theta + PI), n_components=7)\n",
        "        circ = Circle(start_angle=90 * DEGREES, n_components=12)\n",
        "        parts = [\n",
        "            circ,\n",
        "            Line(UP, ORIGIN),\n",
        "            Line(ORIGIN, DOWN),\n",
        "            arc1,\n",
        "            Line(arc1.get_end(), ORIGIN),\n",
        "            Line(ORIGIN, arc2.get_start()),\n",
        "            arc2,\n",
        "        ]\n",
        "        path = VMobject()\n",
        "        for part in parts:\n",
        "            path.append_points(part.get_points())\n",
        "\n",
        "        return path\n",
        "\n",
        "    def style_vectors(self, vectors):\n",
        "        for k, vector in enumerate(vectors):\n",
        "            vector.set_stroke(width=2.5 / (1 + k / 10), opacity=1)\n",
        "        return vectors\n",
        "\n",
        "    def style_circles(self, circles):\n",
        "        mcsw = self.max_circle_stroke_width\n",
        "        circles.set_stroke(Color('green'))\n",
        "        for k, circle in zip(it.count(0), circles):\n",
        "            circle.set_stroke(width=mcsw / (1 + k / 4), opacity=1)\n",
        "\n",
        "        return circles\n",
        "\n",
        "    def get_fade_region(self, path):\n",
        "        dot = GlowDot()\n",
        "        dot.set_radius(1.0 * path.get_width())\n",
        "        dot.set_glow_factor(0.2)\n",
        "        dot.set_color(BLACK, 0.95)\n",
        "        return dot\n",
        "\n",
        "    def get_drawn_path(self, vectors):\n",
        "        nv = len(vectors)\n",
        "        if nv == 0:\n",
        "            return VGroup()\n",
        "        fade_rate = 10 * np.exp(0.01 * (5 - nv)) + 1.0\n",
        "        path = super().get_drawn_path(vectors, stroke_width=4, fade_rate=fade_rate)\n",
        "        path.set_stroke(self.drawn_path_color)\n",
        "        return path\n",
        "\n",
        "    def get_terms(self, n_terms, max_terms=100, max_width=12):\n",
        "        ks = list(range(-int(np.floor(n_terms / 2)), int(np.ceil(n_terms / 2))))\n",
        "        ks.sort(key=abs)\n",
        "        ks = ks[:max_terms]\n",
        "        ks.sort()\n",
        "        font_size = max(180 / n_terms, 5)\n",
        "        terms = VGroup()\n",
        "        for k in ks:\n",
        "            terms.add(Tex(\"c_{k} e^{k \\\\cdot 2 \\\\pi i \\\\cdot t} +\".replace(\"k\", str(k))))\n",
        "        if n_terms <= max_terms:\n",
        "            terms[-1][-1].set_opacity(0)\n",
        "        else:\n",
        "            terms.add_to_back(Tex(\"\\\\cdots + \"))\n",
        "            terms.add(Tex(\"\\\\cdots\"))\n",
        "\n",
        "        terms.arrange(RIGHT, SMALL_BUFF)\n",
        "        terms.scale(font_size / 48)\n",
        "        terms.set_max_width(max_width)\n",
        "        terms.next_to(self.path, UP, SMALL_BUFF)\n",
        "\n",
        "        max_light_terms = 15\n",
        "        if n_terms > max_light_terms:\n",
        "            terms.set_fill(opacity=max_light_terms / (n_terms - max_light_terms))\n",
        "            terms.set_stroke(width=0)\n",
        "\n",
        "        return terms\n",
        "\n",
        "    def add_draw_dot(self, vectors):\n",
        "        dot = GlowDot()\n",
        "        dot.add_updater(lambda d: d.move_to(\n",
        "            vectors[-1].get_end() if len(vectors) > 0 else ORIGIN\n",
        "        ))\n",
        "        self.add(dot)\n",
        "        return dot\n"
    ]
}