{
    "topic": "demonstrates the concept of simple autoregressive modeling.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2024.transformers.helpers import *\n",
        "\n",
        "from transformers import GPT2Tokenizer\n",
        "from transformers import GPT2LMHeadModel\n",
        "from transformers import PreTrainedModel\n",
        "import torch\n",
        "import openai\n",
        "import tiktoken\n",
        "\n",
        "\n",
        "@lru_cache(maxsize=1)\n",
        "def get_gpt2_tokenizer(model_name='gpt2'):\n",
        "    return GPT2Tokenizer.from_pretrained(model_name)\n",
        "\n",
        "\n",
        "@lru_cache(maxsize=1)\n",
        "def get_gpt2_model(model_name='gpt2'):\n",
        "    return GPT2LMHeadModel.from_pretrained(model_name)\n",
        "\n",
        "\n",
        "def gpt2_predict_next_token(text, n_shown=7):\n",
        "    tokenizer = get_gpt2_tokenizer()\n",
        "    model = get_gpt2_model()\n",
        "    # Encode the input text\n",
        "    indexed_tokens = tokenizer.encode(\n",
        "        text, add_special_tokens=False, return_tensors='pt'\n",
        "    )\n",
        "\n",
        "    # Predict all tokens\n",
        "    with torch.no_grad():\n",
        "        outputs = model(indexed_tokens)\n",
        "        # Pull out the first batch, and the last token prediction\n",
        "        predictions = outputs[0][0, -1, :]\n",
        "\n",
        "    # Get the predicted next token\n",
        "    indices = torch.argsort(predictions)\n",
        "    top_indices = reversed(indices[-n_shown:])\n",
        "    tokens = list(map(tokenizer.decode, top_indices))\n",
        "    probs = softmax(predictions)[top_indices]\n",
        "\n",
        "    return tokens, probs\n",
        "\n",
        "\n",
        "def gpt3_predict_next_token(text, n_shown=10, random_seed=0):\n",
        "    openai.api_key = os.getenv('OPENAI_KEY')\n",
        "    response = openai.Completion.create(\n",
        "        # Or another model version, adjust as necessary\n",
        "        engine=\"gpt-3.5-turbo-instruct\",\n",
        "        prompt=text,\n",
        "        max_tokens=1,\n",
        "        n=1,\n",
        "        temperature=1.0,\n",
        "        user=str(random_seed),\n",
        "        # Retrieve more than are shown\n",
        "        logprobs=50\n",
        "    )\n",
        "    top_logprob_dict = response.choices[0][\"logprobs\"][\"top_logprobs\"][0]\n",
        "    tokens, logprobs = zip(*top_logprob_dict.items())\n",
        "    probs = np.exp(logprobs)\n",
        "    indices = np.argsort(probs)\n",
        "    top_indices = indices[-1:-n_shown:-1]\n",
        "    top_tokens = [tokens[i] for i in top_indices]\n",
        "    top_probs = [probs[i] for i in top_indices]\n",
        "    return top_tokens, top_probs\n",
        "\n",
        "\n",
        "class SimpleAutogregression(InteractiveScene):\n",
        "    text_corner = 3.5 * UP + 0.75 * RIGHT\n",
        "    line_len = 31\n",
        "    font_size = 35\n",
        "    n_shown_predictions = 12\n",
        "    seed_text = \"Behold, a wild pi creature, foraging in its native\"\n",
        "    seed_text_color = BLUE_B\n",
        "    machine_name = \"Transformer\"\n",
        "    machine_phi = 10 * DEGREES\n",
        "    machine_theta = 12 * DEGREES\n",
        "    n_predictions = 120\n",
        "    skip_through = False\n",
        "    random_seed = 0\n",
        "    model = \"gpt2\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Repeatedly generate\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        for n in range(self.n_predictions):\n",
        "            text_mob = self.new_selection_cycle(\n",
        "                text_mob, next_word_line, machine,\n",
        "                quick=(n > 10),\n",
        "                skip_anims=self.skip_through,\n",
        "            )\n",
        "\n",
        "    def init_text_and_machine(self):\n",
        "        # Set up active text\n",
        "        self.cur_str = self.seed_text\n",
        "        text_mob = self.string_to_mob(self.cur_str)\n",
        "        text_mob.set_color(self.seed_text_color)\n",
        "        next_word_line = self.get_next_word_line(text_mob)\n",
        "\n",
        "        # Set up Transformer as some sort of machine\n",
        "        machine = self.get_transformer_drawing()\n",
        "        machine.set_y(0).to_edge(LEFT, buff=-0.6)\n",
        "\n",
        "        self.add(text_mob)\n",
        "        self.add(next_word_line)\n",
        "        self.add(machine)\n",
        "\n",
        "        return text_mob, next_word_line, machine\n",
        "\n",
        "    def string_to_mob(self, text):\n",
        "        text += \" l\"  # Dumb hack for alignment\n",
        "        result = get_paragraph(\n",
        "            text.replace(\"\\n\", \" \").split(\" \"),\n",
        "            self.line_len,\n",
        "            self.font_size\n",
        "        )\n",
        "        result.move_to(self.text_corner, UL)\n",
        "        result[-1].set_fill(BLACK, 0)  # Continue dumb hack\n",
        "        result[-1].stretch(0, 0, about_edge=LEFT)\n",
        "        return result\n",
        "\n",
        "    def get_next_word_line(self, text_mob, char_len=7):\n",
        "        next_word_line = Underline(text_mob[:char_len])\n",
        "        next_word_line.set_stroke(TEAL, 2)\n",
        "        next_word_line.next_to(text_mob[-1], RIGHT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "        if self.skip_through:\n",
        "            next_word_line.set_opacity(0)\n",
        "        return next_word_line\n",
        "\n",
        "    def get_transformer_drawing(self):\n",
        "        self.camera.light_source.move_to([-5, 5, 10])\n",
        "        self.frame.set_field_of_view(20 * DEGREES)\n",
        "        blocks = VGroup(\n",
        "            VPrism(3, 2, 0.2)\n",
        "            for n in range(10)\n",
        "        )\n",
        "        blocks.set_fill(GREY_D, 1)\n",
        "        blocks.set_stroke(width=0)\n",
        "        blocks.set_shading(0.25, 0.5, 0.2)\n",
        "        blocks.arrange(OUT)\n",
        "        blocks.move_to(ORIGIN, OUT)\n",
        "        blocks.rotate(self.machine_phi, RIGHT, about_edge=OUT)\n",
        "        blocks.rotate(self.machine_theta, UP, about_edge=OUT)\n",
        "\n",
        "        blocks.deactivate_depth_test()\n",
        "        for block in blocks:\n",
        "            block.sort(lambda p: p[2])\n",
        "\n",
        "        word = Text(self.machine_name, alignment=\"LEFT\")\n",
        "        word.next_to(blocks[-1], UP)\n",
        "        word.shift(0.1 * UP + 0.4 * LEFT)\n",
        "        word.move_to(blocks[-1])\n",
        "        word.set_backstroke(BLACK, 5)\n",
        "        out_arrow = Vector(\n",
        "            0.5 * RIGHT, stroke_width=10,\n",
        "            max_tip_length_to_length_ratio=0.5,\n",
        "            max_width_to_length_ratio=12\n",
        "        )\n",
        "        out_arrow.next_to(blocks[-1], RIGHT, buff=SMALL_BUFF)\n",
        "        out_arrow.set_opacity(0)\n",
        "\n",
        "        result = VGroup(blocks, word, out_arrow)\n",
        "        return result\n",
        "\n",
        "    def get_distribution(\n",
        "        self, words, probs, machine,\n",
        "        font_size=24,\n",
        "        width_100p=1.8,\n",
        "        bar_height=0.25,\n",
        "        show_ellipses=True\n",
        "    ):\n",
        "        labels = VGroup(Text(word, font_size=font_size) for word in words)\n",
        "        bars = VGroup(\n",
        "            Rectangle(prob * width_100p, bar_height)\n",
        "            for prob, label in zip(probs, labels)\n",
        "        )\n",
        "        bars.arrange(DOWN, aligned_edge=LEFT, buff=0.5 * bar_height)\n",
        "        bars.set_fill(opacity=1)\n",
        "        bars.set_submobject_colors_by_gradient(TEAL, YELLOW)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "\n",
        "        bar_groups = VGroup()\n",
        "        for label, bar, prob in zip(labels, bars, probs):\n",
        "            prob_label = Integer(int(100 * prob), unit=\"%\", font_size=0.75 * font_size)\n",
        "            prob_label.next_to(bar, RIGHT, buff=SMALL_BUFF)\n",
        "            label.next_to(bar, LEFT)\n",
        "            bar_groups.add(VGroup(label, bar, prob_label))\n",
        "\n",
        "        if show_ellipses:\n",
        "            ellipses = Tex(R\"\\vdots\", font_size=font_size)\n",
        "            ellipses.next_to(bar_groups[-1][0], DOWN)\n",
        "            bar_groups.add(ellipses)\n",
        "\n",
        "        arrow_point = machine[-1].get_right()\n",
        "        bar_groups.shift(arrow_point - bars.get_left() + 1.5 * RIGHT)\n",
        "        bar_groups.align_to(machine, UP)\n",
        "\n",
        "        return bar_groups\n",
        "\n",
        "    def animate_text_input(self, text_mob, machine, position_text_over_machine=True, added_anims=[], lag_ratio=0.02):\n",
        "        blocks = machine[0]\n",
        "        text_copy = text_mob.copy()\n",
        "        if position_text_over_machine:\n",
        "            text_copy.target = text_copy.generate_target()\n",
        "            text_copy.target.set_max_width(4)\n",
        "            text_copy.target.next_to(blocks[0], UP)\n",
        "            text_copy.target.shift_onto_screen()\n",
        "            self.play(MoveToTarget(text_copy, path_arc=-45 * DEGREES))\n",
        "        self.play(LaggedStart(\n",
        "            *added_anims,\n",
        "            Transform(\n",
        "                text_copy,\n",
        "                VGroup(VectorizedPoint(machine.get_top())),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=1,\n",
        "                path_arc=-45 * DEGREES,\n",
        "                remover=True,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (\n",
        "                    block.animate.set_color(\n",
        "                        block.get_color() if block is blocks[-1] else TEAL\n",
        "                    ).set_anim_args(rate_func=there_and_back)\n",
        "                    for block in blocks\n",
        "                ),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1\n",
        "            ),\n",
        "            Animation(machine[1:]),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "    def animate_prediction_ouptut(self, machine, cur_str):\n",
        "        words, probs = self.predict_next_token(cur_str)\n",
        "        bar_groups = self.get_distribution(words, probs, machine)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeInFromPoint(bar_group, machine[0][-1].get_right())\n",
        "                for bar_group in bar_groups),\n",
        "                lag_ratio=0.025,\n",
        "                group=bar_groups,\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        return bar_groups\n",
        "\n",
        "    def animate_random_sample(self, bar_groups):\n",
        "        widths = np.array([group[1].get_width() for group in bar_groups[:-1]])\n",
        "        dist = widths / widths.sum()\n",
        "        seed = random.randint(0, 1000)\n",
        "        buff = 0.025\n",
        "        highlight_rect = SurroundingRectangle(bar_groups[0], buff=buff)\n",
        "        highlight_rect.set_stroke(YELLOW, 2)\n",
        "        highlight_rect.set_fill(YELLOW, 0.25)\n",
        "\n",
        "        def highlight_randomly(rect, dist, alpha):\n",
        "            np.random.seed(seed + int(10 * alpha))\n",
        "            index = np.random.choice(np.arange(len(dist)), p=dist)\n",
        "            rect.surround(bar_groups[index], buff=buff)\n",
        "            rect.stretch(1.1, 0)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(highlight_rect, lambda rect, a: highlight_randomly(rect, dist, a)),\n",
        "            Animation(bar_groups)\n",
        "        )\n",
        "\n",
        "        bar_groups.add_to_back(highlight_rect)\n",
        "\n",
        "    def animate_word_addition(self, bar_groups, text_mob, next_word_line, force_unskip=False):\n",
        "        # Choose the highlighted_group\n",
        "        bar_group = None\n",
        "        if isinstance(bar_groups[0], Rectangle):\n",
        "            # Use the highlight rect to find the group element\n",
        "            bars = bar_groups[1:-1]\n",
        "            diffs = [abs(bg.get_y() - bar_groups[0].get_y()) for bg in bars]\n",
        "            bar_group = bar_groups[1:][np.argmin(diffs)]\n",
        "        if bar_group is None:\n",
        "            bar_group = bar_groups[0]\n",
        "\n",
        "        # Animate selection\n",
        "        word = bar_group[0].get_text()\n",
        "        new_str = self.cur_str + word\n",
        "        new_text_mob = self.string_to_mob(new_str)\n",
        "        new_text_mob[:len(self.seed_text.replace(\" \", \"\"))].set_color(self.seed_text_color)\n",
        "\n",
        "        word_targets = new_text_mob[word.strip()]\n",
        "        if len(word_targets) > 0:\n",
        "            target = word_targets[-1]\n",
        "        else:\n",
        "            target = new_text_mob[-len(word) - 1:-1]\n",
        "\n",
        "        # target = new_text_mob[-len(word):]\n",
        "\n",
        "        self.add(bar_groups)\n",
        "        self.play(\n",
        "            FadeTransform(bar_group[0].copy(), target),\n",
        "            Transform(\n",
        "                next_word_line,\n",
        "                self.get_next_word_line(new_text_mob),\n",
        "            ),\n",
        "        )\n",
        "        if force_unskip:\n",
        "            self.skip_animations = False\n",
        "            target.save_state()\n",
        "            target.set_fill(YELLOW)\n",
        "            self.wait(0.5)\n",
        "            target.restore()\n",
        "            self.skip_animations = True\n",
        "        self.play(\n",
        "            FadeOut(bar_groups),\n",
        "        )\n",
        "\n",
        "        self.remove(text_mob)\n",
        "        self.add(new_text_mob)\n",
        "\n",
        "        self.cur_str = new_str\n",
        "\n",
        "        return new_text_mob\n",
        "\n",
        "    def new_selection_cycle(self, text_mob, next_word_line, machine, quick=False, skip_anims=False):\n",
        "        if skip_anims:\n",
        "            self.skip_animations = True\n",
        "\n",
        "        if quick:\n",
        "            words, probs = self.predict_next_token(self.cur_str)\n",
        "            bar_groups = self.get_distribution(words, probs, machine)\n",
        "            self.add(bar_groups)\n",
        "        else:\n",
        "            self.animate_text_input(text_mob, machine)\n",
        "            bar_groups = self.animate_prediction_ouptut(machine, self.cur_str)\n",
        "        self.animate_random_sample(bar_groups)\n",
        "        new_text_mob = self.animate_word_addition(\n",
        "            bar_groups, text_mob, next_word_line,\n",
        "            force_unskip=skip_anims\n",
        "        )\n",
        "        return new_text_mob\n",
        "\n",
        "    #\n",
        "\n",
        "    def predict_next_token(self, text):\n",
        "        result = None\n",
        "        n_shown = self.n_shown_predictions\n",
        "        if self.model == \"gpt3\":\n",
        "            try:\n",
        "                result = gpt3_predict_next_token(\n",
        "                    text, n_shown, random_seed=self.random_seed\n",
        "                )\n",
        "            except Exception as e:\n",
        "                pass\n",
        "        if result is None:\n",
        "            result = gpt2_predict_next_token(text, n_shown)\n",
        "        return result\n",
        "\n",
        "\n",
        "class AnnotateNextWord(SimpleAutogregression):\n",
        "    def construct(self):\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        self.add(machine, *machine[1:])\n",
        "        words, probs = self.predict_next_token(self.cur_str)\n",
        "        bar_groups = self.get_distribution(words, probs, machine)\n",
        "\n",
        "        self.add(bar_groups)\n",
        "\n",
        "        # Initial text\n",
        "        from manimlib.mobject.boolean_ops import Union\n",
        "        highlight = Union(\n",
        "            SurroundingRectangle(text_mob[\"in its native\"]),\n",
        "            SurroundingRectangle(text_mob[\"Behold, a wild pi creature, foraging\"]),\n",
        "        )\n",
        "        highlight.set_stroke(BLUE, 3)\n",
        "        arrow = Vector(RIGHT, stroke_width=10)\n",
        "        arrow.next_to(highlight, LEFT)\n",
        "\n",
        "        dist_rect = SurroundingRectangle(bar_groups)\n",
        "        dist_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(highlight),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            arrow.animate.rotate(-PI / 2).next_to(dist_rect, UP),\n",
        "            ReplacementTransform(highlight, dist_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dist_rect),\n",
        "            FadeOut(arrow),\n",
        "        )\n",
        "\n",
        "\n",
        "class QuickerRegression(SimpleAutogregression):\n",
        "    skip_through = True\n",
        "\n",
        "\n",
        "class AutoregressionGPT3(SimpleAutogregression):\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class QuickRegressionGPT3(SimpleAutogregression):\n",
        "    skip_through = True\n",
        "    model = \"gpt3\"\n",
        "\n",
        "\n",
        "class GPT3CleverestAutocomplete(QuickRegressionGPT3):\n",
        "    seed_text = \"To date, the cleverest thinker of all time was\"\n",
        "    n_predictions = 70\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        for n in range(self.n_predictions):\n",
        "            text_mob = self.new_selection_cycle(\n",
        "                text_mob, next_word_line, machine,\n",
        "                skip_anims=(n > 2),\n",
        "            )\n",
        "\n",
        "\n",
        "class GPT3OnLearningSimpler(QuickRegressionGPT3):\n",
        "    seed_text = \"The most effective way to learn computer science is\"\n",
        "    text_corner = 3.5 * UP + 3 * LEFT\n",
        "    line_len = 35\n",
        "    font_size = 35\n",
        "    n_predictions = 300\n",
        "    time_per_prediction = 0.2\n",
        "    random_seed = 313\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        cur_str = self.seed_text\n",
        "        text_mob = VGroup()\n",
        "        for n in range(self.n_predictions):\n",
        "            self.remove(text_mob)\n",
        "            words, probs = self.predict_next_token(cur_str)\n",
        "            probs = probs / probs.sum()\n",
        "            index = np.random.choice(np.arange(len(words)), p=probs)\n",
        "            new_word = words[index]\n",
        "            cur_str += new_word\n",
        "            text_mob = self.string_to_mob(cur_str)\n",
        "            text_mob[:len(self.seed_text.replace(\" \", \"\"))].set_color(BLUE)\n",
        "            text_mob[new_word.strip()][-1].set_color(YELLOW)\n",
        "            if text_mob.get_bottom()[1] < -3:\n",
        "                text_mob.shift(5 * UP)\n",
        "                self.text_corner += 5 * UP\n",
        "            self.add(text_mob)\n",
        "            self.wait(self.time_per_prediction)\n",
        "\n",
        "\n",
        "class ModelTakingInTextWithSurroundingPieces(SimpleAutogregression):\n",
        "    def construct(self):\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "\n",
        "\n",
        "class AthleteCompletion(SimpleAutogregression):\n",
        "    seed_text = \"Michael Jordan plays the sport of\"\n",
        "    text_corner = 3.5 * UP + 3.0 * LEFT\n",
        "    machine_phi = 5 * DEGREES\n",
        "    machine_theta = 12 * DEGREES\n",
        "    model = \"gpt3\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Initialize machine\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "        in_text, next_word_line, machine = self.init_text_and_machine()\n",
        "        self.clear()\n",
        "        machine = VGroup(*machine[0])\n",
        "        machine.set_height(4)\n",
        "        machine.next_to(in_text, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        dials = MachineWithDials(n_rows=10, n_cols=15).dials\n",
        "        dials.set_stroke(opacity=0.25)\n",
        "        dials.set_height(machine[-1].get_height() * 0.9)\n",
        "\n",
        "        llm_title = Text(\"Large\\nLanguage\\nModel\", alignment=\"LEFT\", font_size=72)\n",
        "        llm_title.set_backstroke(width=8)\n",
        "\n",
        "        for mob in [dials, llm_title]:\n",
        "            mob.rotate(self.machine_phi, RIGHT).rotate(self.machine_theta, UP)\n",
        "            mob.move_to(machine[-1], OUT)\n",
        "\n",
        "        last_block_copy = machine[-1].copy()\n",
        "        self.add(last_block_copy)\n",
        "\n",
        "        frame.reorient(-13, -6, 0)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(last_block_copy.copy().set_opacity(0), block)\n",
        "                for block in machine),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            Write(dials),\n",
        "            Write(llm_title),\n",
        "            frame.animate.reorient(0, 0, 0),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.remove(last_block_copy)\n",
        "        self.add(machine, dials, llm_title)\n",
        "\n",
        "        # Feed in many facts\n",
        "        facts = Path(DATA_DIR, \"facts.txt\").read_text().split(\"\\n\")\n",
        "        fact_mobs = VGroup(get_paragraph(fact.split(\" \"), line_len=20) for fact in facts)\n",
        "        directions = compass_directions(12, start_vect=UR)\n",
        "        for fact_mob, vect in zip(fact_mobs, it.cycle(directions)):\n",
        "            fact_mob.set_max_width(2)\n",
        "            fact_mob.move_to(5 * vect).shift_onto_screen(buff=0.25)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (Succession(\n",
        "                    FadeIn(fact_mob),\n",
        "                    fact_mob.animate.set_opacity(0).move_to(machine.get_center()),\n",
        "                )\n",
        "                for fact_mob in fact_mobs),\n",
        "                lag_ratio=0.05,\n",
        "                run_time=8\n",
        "            )\n",
        "        )\n",
        "        self.remove(fact_mobs)\n",
        "        self.wait()\n",
        "\n",
        "        # Show MJ fact\n",
        "        full_input = VGroup(in_text, next_word_line)\n",
        "        full_input.set_height(0.4)\n",
        "        full_input.to_edge(UP)\n",
        "\n",
        "        in_arrow = Arrow(full_input, machine, buff=0.1)\n",
        "        predictions, probs = self.predict_next_token(self.seed_text)\n",
        "\n",
        "        bar_groups = self.get_distribution(predictions, probs, machine)\n",
        "        bar_groups.next_to(machine[-1], RIGHT, buff=1.5)\n",
        "        out_arrow = Arrow(machine[-1], bar_groups)\n",
        "\n",
        "        top_rect = SurroundingRectangle(VGroup(bar_groups[0]))\n",
        "\n",
        "        self.play(FadeIn(full_input, scale=2))\n",
        "        self.play(\n",
        "            GrowArrow(in_arrow),\n",
        "            Transform(full_input.copy(), full_input.copy().scale(0.5).set_opacity(0).move_to(machine.get_top()))\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-14, -2, 0, (1.83, 0.07, -0.38), 8.63),\n",
        "            LaggedStart(\n",
        "                (block.animate.set_color(TEAL).set_anim_args(rate_func=there_and_back)\n",
        "                for block in machine[:-1]),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=1\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(out_arrow),\n",
        "            FadeIn(bar_groups, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(top_rect))\n",
        "\n",
        "        # Reshow parameters\n",
        "        self.play(\n",
        "            FadeOut(llm_title),\n",
        "            dials.animate.set_stroke(opacity=1)\n",
        "        )\n",
        "        for _ in range(5):\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    (dial.animate_set_value(dial.get_random_value())\n",
        "                    for dial in dials),\n",
        "                    lag_ratio=0.25 / len(dials),\n",
        "                    run_time=1\n",
        "                )\n",
        "            )\n",
        "\n",
        "        # Quetsions\n",
        "        questions = VGroup(Text(\"How?\"), Text(\"Where?\"))\n",
        "        questions.arrange(RIGHT, buff=1.0)\n",
        "        questions.set_height(0.5)\n",
        "        questions.next_to(machine[-1], DOWN)\n",
        "\n",
        "        for question in questions:\n",
        "            self.play(FadeIn(question, 0.5 * UP, scale=1.5))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThatWhichDoesNotKillMe(SimpleAutogregression):\n",
        "    text_corner = 3.5 * UP + 5.0 * LEFT\n",
        "    line_len = 75\n",
        "    # seed_text = \"That which does not kill you only makes you\"\n",
        "    seed_text = \"Down by the river bank\"\n",
        "    model = \"gpt3\"\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        text_mob, next_word_line, machine = self.init_text_and_machine()\n",
        "        machine.set_x(0)\n",
        "        text_mob = self.new_selection_cycle(\n",
        "            text_mob, next_word_line, machine,\n",
        "            quick=False,\n",
        "            skip_anims=False,\n",
        "        )\n"
    ]
}