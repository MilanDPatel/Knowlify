{
    "topic": "demonstrates the Greedy Algorithm for solving the Knapsack problem.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def get_value_grid(n_rows=6, n_cols=6):\n",
        "    random.seed(1)\n",
        "    boxes = VGroup(*[Square() for x in range(n_rows * n_cols)])\n",
        "    array = np.array(list(boxes)).reshape((n_rows, n_cols))\n",
        "    boxes.array = array\n",
        "    boxes.arrange_in_grid(n_rows, n_cols, buff=0)\n",
        "    boxes.set_height(5)\n",
        "    boxes.to_edge(DOWN)\n",
        "    boxes.shift(UP)\n",
        "    boxes.set_stroke(BLUE_D, 2)\n",
        "    for box in boxes:\n",
        "        value = DecimalNumber(\n",
        "            np.round(random.random(), 1),\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "        box.set_fill(WHITE, opacity=0.8 * value.get_value())\n",
        "        box.value = value\n",
        "        value.match_height(box)\n",
        "        value.scale(0.3)\n",
        "        value.move_to(box)\n",
        "        box.add(value)\n",
        "    boxes.array[5, 1].value.set_value(0.4)  # Tweaking for examples\n",
        "    return boxes\n",
        "\n",
        "\n",
        "def highlight_box(box, opacity=0.5, color=PINK):\n",
        "    box.set_stroke(color, opacity)\n",
        "    box[1].set_stroke(BLACK, 2, background=True)\n",
        "    return box\n",
        "\n",
        "\n",
        "def get_box_highlight(box, color=PINK, stroke_width=8, opacity=0.25):\n",
        "    highlight = SurroundingRectangle(box, buff=0)\n",
        "    highlight.set_fill(color, opacity)\n",
        "    highlight.set_stroke(color, stroke_width)\n",
        "    return highlight\n",
        "\n",
        "\n",
        "class GreedyAlgorithm(Scene):\n",
        "    def construct(self):\n",
        "        n_rows, n_cols = 6, 6\n",
        "        boxes = get_value_grid(n_rows, n_cols)\n",
        "        self.add(boxes)\n",
        "\n",
        "        last_sum_term = boxes[0].value.copy()\n",
        "        last_sum_term.to_edge(UP)\n",
        "        last_sum_term.set_x(-5)\n",
        "        sum_terms = VGroup()\n",
        "        to_fade = VGroup()\n",
        "\n",
        "        (i, j) = (0, 3)\n",
        "        while i < n_rows:\n",
        "            box = boxes.array[i, j]\n",
        "            value = box.value\n",
        "            box_highlight = get_box_highlight(box)\n",
        "            sum_term = VGroup(\n",
        "                OldTex(\"+\"),\n",
        "                value.copy()\n",
        "            )\n",
        "            if i == 0:\n",
        "                sum_term[0].set_opacity(0)\n",
        "            sum_term.arrange(RIGHT, buff=0.2)\n",
        "            sum_term.next_to(last_sum_term, RIGHT, buff=0.2)\n",
        "            sum_terms.add(sum_term)\n",
        "            last_sum_term = sum_term\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(box_highlight),\n",
        "                FadeIn(sum_term),\n",
        "                *map(FadeOut, to_fade)\n",
        "            )\n",
        "\n",
        "            i += 1\n",
        "            # Find new j\n",
        "            if i < n_rows:\n",
        "                next_boxes = VGroup()\n",
        "                for nj in range(j - 1, j + 2):\n",
        "                    next_boxes.add(boxes.array[i, clip(nj, 0, n_cols - 1)])\n",
        "\n",
        "                next_highlights = VGroup()\n",
        "                for nb in next_boxes:\n",
        "                    next_highlights.add(get_box_highlight(nb, stroke_width=4))\n",
        "\n",
        "                self.play(FadeIn(next_highlights))\n",
        "\n",
        "                min_box_index = np.argmin([b.value.get_value() for b in next_boxes])\n",
        "                j = j - 1 + min_box_index\n",
        "                j = clip(j, 0, n_cols - 1)  # Am I doing this right?\n",
        "                to_fade = next_highlights\n",
        "\n",
        "        final_sum = VGroup(\n",
        "            OldTex(\"=\"),\n",
        "            DecimalNumber(\n",
        "                sum([np.round(st[1].get_value(), 1) for st in sum_terms]),\n",
        "                height=sum_terms.get_height(),\n",
        "                num_decimal_places=1,\n",
        "            ).set_color(YELLOW)\n",
        "        )\n",
        "        final_sum.arrange(RIGHT, buff=0.2)\n",
        "        final_sum.next_to(sum_terms, RIGHT, buff=0.2)\n",
        "\n",
        "        self.play(Write(final_sum))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RecrusiveExhaustiveSearch(Scene):\n",
        "    def construct(self):\n",
        "        n_rows = 6\n",
        "        n_cols = 6\n",
        "        boxes = get_value_grid(n_rows, n_cols)\n",
        "        self.add(boxes)\n",
        "\n",
        "        seam = [\n",
        "            (i, 3)\n",
        "            for i in range(n_rows)\n",
        "        ]\n",
        "\n",
        "        def get_seam_sum(seam):\n",
        "            terms = VGroup(*[boxes.array[i, j].value.copy() for (i, j) in seam])\n",
        "            row = VGroup()\n",
        "            for term in terms[:-1]:\n",
        "                row.add(term)\n",
        "                row.add(OldTex(\"+\"))\n",
        "            row.add(terms[-1])\n",
        "            row.add(OldTex(\"=\"))\n",
        "            sum_term = DecimalNumber(sum([t.get_value() for t in terms]), num_decimal_places=1)\n",
        "            sum_term.match_height(terms[0])\n",
        "            sum_term.set_color(YELLOW)\n",
        "            row.add(sum_term)\n",
        "            row.arrange(RIGHT, buff=0.15)\n",
        "            row.to_edge(UP)\n",
        "            return row\n",
        "\n",
        "        def get_highlighted_seam(seam):\n",
        "            return VGroup(*[\n",
        "                get_box_highlight(boxes.array[i, j])\n",
        "                for (i, j) in seam\n",
        "            ])\n",
        "\n",
        "        def get_all_seams(seam_starts, n_rows=n_rows, n_cols=n_cols):\n",
        "            if seam_starts[0][-1][0] == n_rows - 1:\n",
        "                return seam_starts\n",
        "            new_seams = []\n",
        "            for seam in seam_starts:\n",
        "                i, j = seam[-1]\n",
        "                # Adjacent j values below (i, j)\n",
        "                js = []\n",
        "                if j > 0:\n",
        "                    js.append(j - 1)\n",
        "                js.append(j)\n",
        "                if j < n_cols - 1:\n",
        "                    js.append(j + 1)\n",
        "\n",
        "                for j_prime in js:\n",
        "                    new_seams.append([*seam, (i + 1, j_prime)])\n",
        "            return get_all_seams(new_seams, n_rows, n_cols)\n",
        "\n",
        "        all_seams = get_all_seams([[(0, 3)]])\n",
        "\n",
        "        curr_min_energy = np.inf\n",
        "        curr_best_seam = VGroup()\n",
        "        for seam in all_seams:\n",
        "            ss = get_seam_sum(seam)\n",
        "            hs = get_highlighted_seam(seam)\n",
        "\n",
        "            energy = ss[-1].get_value()\n",
        "            if energy < curr_min_energy:\n",
        "                curr_min_energy = energy\n",
        "                curr_best_seam = VGroup(ss, hs)\n",
        "\n",
        "            self.add(ss, hs)\n",
        "            self.wait(0.05)\n",
        "            self.remove(ss, hs)\n",
        "\n",
        "        self.add(curr_best_seam)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DynamicProgrammingApproachSearch(Scene):\n",
        "    def construct(self):\n",
        "        n_rows = 6\n",
        "        n_cols = 6\n",
        "        boxes = get_value_grid(n_rows, n_cols)\n",
        "        boxes.to_corner(DL)\n",
        "        boxes.shift(UP)\n",
        "        self.add(boxes)\n",
        "\n",
        "        new_boxes = get_value_grid(n_rows, n_cols)\n",
        "        new_boxes.to_corner(DR)\n",
        "        new_boxes.shift(UP)\n",
        "        for box in new_boxes:\n",
        "            box.set_fill(opacity=0)\n",
        "            box.value.set_fill(opacity=0)\n",
        "        self.add(new_boxes)\n",
        "\n",
        "        left_title = OldTexText(\"Energy\")\n",
        "        right_title = OldTexText(\"Minimal energy to bottom\")\n",
        "        left_title.next_to(boxes, UP)\n",
        "        right_title.next_to(new_boxes, UP)\n",
        "\n",
        "        self.add(left_title, right_title)\n",
        "\n",
        "        op_factor = 0.5\n",
        "\n",
        "        movers = VGroup()\n",
        "        for j in range(n_cols):\n",
        "            box = boxes.array[n_rows - 1, j]\n",
        "            new_box = new_boxes.array[n_rows - 1, j]\n",
        "            new_box.generate_target()\n",
        "            new_box.target.match_style(box)\n",
        "            new_box.target.set_fill(TEAL, opacity=op_factor * new_box.value.get_value())\n",
        "            new_box.target[1].set_fill(WHITE, 1)\n",
        "            movers.add(new_box)\n",
        "\n",
        "        self.play(LaggedStartMap(MoveToTarget, movers))\n",
        "        self.wait()\n",
        "\n",
        "        for i in range(n_rows - 2, -1, -1):\n",
        "            for j in range(n_cols):\n",
        "                box = boxes.array[i, j]\n",
        "                new_box = new_boxes.array[i, j]\n",
        "                box_highlight = get_box_highlight(box)\n",
        "                new_box_highlight = get_box_highlight(new_box)\n",
        "                boxes_below = [\n",
        "                    new_boxes.array[i + 1, j]\n",
        "                    for j in range(j - 1, j + 2)\n",
        "                    if 0 <= j < n_cols\n",
        "                ]\n",
        "                index = np.argmin([bb.value.get_value() for bb in boxes_below])\n",
        "                low_box = boxes_below[index]\n",
        "                low_box_highlight = get_box_highlight(low_box, stroke_width=3)\n",
        "                low_box_highlight.fade(0.5)\n",
        "\n",
        "                new_box.value.set_value(new_box.value.get_value() + low_box.value.get_value())\n",
        "                new_box.generate_target()\n",
        "                new_box.target.set_fill(TEAL, opacity=op_factor * new_box.value.get_value())\n",
        "                new_box.target[1].set_fill(WHITE, 1)\n",
        "\n",
        "                self.play(\n",
        "                    FadeIn(box_highlight),\n",
        "                    FadeIn(new_box_highlight),\n",
        "                    FadeIn(low_box_highlight),\n",
        "                    MoveToTarget(new_box),\n",
        "                )\n",
        "                self.play(\n",
        "                    FadeOut(box_highlight),\n",
        "                    FadeOut(new_box_highlight),\n",
        "                    FadeOut(low_box_highlight),\n",
        "                )\n"
    ]
}