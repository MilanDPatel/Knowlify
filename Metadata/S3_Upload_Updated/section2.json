{
    "topic": "demonstrates the concept of a Hilbert curve, which is a mathematical object used to visual",
    "code": [
        "from manim_imports_ext import *\n",
        "import displayer as disp\n",
        "from hilbert.curves import \\\n",
        "    TransformOverIncreasingOrders, FlowSnake, HilbertCurve, \\\n",
        "    SnakeCurve, PeanoCurve\n",
        "from hilbert.section1 import get_mathy_and_bubble\n",
        "from scipy.spatial.distance import cdist\n",
        "\n",
        "\n",
        "def get_time_line():\n",
        "    length = 2.6*FRAME_WIDTH\n",
        "    year_range = 400\n",
        "    time_line = NumberLine(\n",
        "        numerical_radius = year_range/2,\n",
        "        unit_length_to_spatial_width = length/year_range,\n",
        "        tick_frequency = 10,\n",
        "        leftmost_tick = 1720,\n",
        "        number_at_center = 1870,\n",
        "        big_tick_numbers = list(range(1700, 2100, 100))\n",
        "    )\n",
        "    time_line.sort_points(lambda p : p[0])        \n",
        "    time_line.set_color_by_gradient(\n",
        "        PeanoCurve.CONFIG[\"start_color\"], \n",
        "        PeanoCurve.CONFIG[\"end_color\"]\n",
        "    )\n",
        "    time_line.add_numbers(\n",
        "        2020, *list(range(1800, 2050, 50))\n",
        "    )\n",
        "    return time_line\n",
        "\n",
        "\n",
        "class SectionTwo(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Section 2: Filling space\"))\n",
        "        self.wait()\n",
        "\n",
        "class HilbertCurveIsPerfect(Scene):\n",
        "    def construct(self):\n",
        "        curve = HilbertCurve(order = 6)\n",
        "        curve.set_color(WHITE)\n",
        "        colored_curve = curve.copy()\n",
        "        colored_curve.thin_out(3)\n",
        "        lion = ImageMobject(\"lion\", invert = False)\n",
        "        lion.replace(curve, stretch = True)\n",
        "        sparce_lion = lion.copy()\n",
        "        sparce_lion.thin_out(100)\n",
        "        distance_matrix = cdist(colored_curve.points, sparce_lion.points)\n",
        "        closest_point_indices = np.apply_along_axis(\n",
        "            np.argmin, 1, distance_matrix\n",
        "        )\n",
        "        colored_curve.rgbas = sparce_lion.rgbas[closest_point_indices]\n",
        "        line = Line(5*LEFT, 5*RIGHT)\n",
        "        Mobject.align_data_and_family(line, colored_curve)\n",
        "        line.rgbas = colored_curve.rgbas\n",
        "\n",
        "        self.add(lion)\n",
        "        self.play(ShowCreation(curve, run_time = 3))\n",
        "        self.play(\n",
        "            FadeOut(lion),\n",
        "            Transform(curve, colored_curve),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(curve, line, run_time = 5))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskMathematicianFriend(Scene):\n",
        "    def construct(self):\n",
        "        mathy, bubble = get_mathy_and_bubble()\n",
        "        bubble.sort_points(lambda p : np.dot(p, UP+RIGHT))\n",
        "\n",
        "        self.add(mathy)\n",
        "        self.wait()\n",
        "        self.play(ApplyMethod(\n",
        "            mathy.blink, \n",
        "            rate_func = squish_rate_func(there_and_back)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(bubble))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(mathy.shift, 3*(DOWN+LEFT)),\n",
        "            ApplyPointwiseFunction(\n",
        "                lambda p : 15*p/get_norm(p),\n",
        "                bubble\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "\n",
        "class TimeLineAboutSpaceFilling(Scene):\n",
        "    def construct(self):\n",
        "        curve = PeanoCurve(order = 5)\n",
        "        curve.stretch_to_fit_width(FRAME_WIDTH)\n",
        "        curve.stretch_to_fit_height(FRAME_HEIGHT)\n",
        "        curve_start = curve.copy()\n",
        "        curve_start.apply_over_attr_arrays(\n",
        "            lambda arr : arr[:200]\n",
        "        )\n",
        "        time_line = get_time_line()\n",
        "        time_line.shift(-time_line.number_to_point(2000))\n",
        "\n",
        "        self.add(time_line)\n",
        "        self.play(ApplyMethod(\n",
        "            time_line.shift,\n",
        "            -time_line.number_to_point(1900),\n",
        "            run_time = 3\n",
        "        ))\n",
        "        brace = Brace(\n",
        "            Mobject(\n",
        "                Point(time_line.number_to_point(1865)),\n",
        "                Point(time_line.number_to_point(1888)),\n",
        "            ),\n",
        "            UP\n",
        "        )\n",
        "        words = OldTexText(\"\"\"\n",
        "            Cantor drives himself (and the \\\\\\\\\n",
        "            mathematical community at large) \\\\\\\\\n",
        "            crazy with research on infinity.\n",
        "        \"\"\")\n",
        "        words.next_to(brace, UP)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShimmerIn(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(time_line, curve_start),\n",
        "            FadeOut(brace),\n",
        "            FadeOut(words)\n",
        "        )\n",
        "        self.play(ShowCreation(\n",
        "            curve, \n",
        "            run_time = 5,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class NotPixelatedSpace(Scene):\n",
        "    def construct(self):\n",
        "        grid = Grid(64, 64)\n",
        "        space_region = Region()\n",
        "        space_mobject = MobjectFromRegion(space_region, GREY_D)\n",
        "        curve = PeanoCurve(order = 5).replace(space_mobject)\n",
        "        line = Line(5*LEFT, 5*RIGHT)\n",
        "        line.set_color_by_gradient(curve.start_color, curve.end_color)\n",
        "        for mob in grid, space_mobject:\n",
        "            mob.sort_points(get_norm)\n",
        "        infinitely = OldTexText(\"Infinitely\")\n",
        "        detailed = OldTexText(\"detailed\")\n",
        "        extending = OldTexText(\"extending\")\n",
        "        detailed.next_to(infinitely, RIGHT)\n",
        "        extending.next_to(infinitely, RIGHT)\n",
        "        Mobject(extending, infinitely, detailed).center()\n",
        "        arrows = Mobject(*[\n",
        "            Arrow(2*p, 4*p)\n",
        "            for theta in np.arange(np.pi/6, 2*np.pi, np.pi/3)\n",
        "            for p in [rotate_vector(RIGHT, theta)]\n",
        "        ])\n",
        "\n",
        "        self.add(grid)\n",
        "        self.wait()\n",
        "        self.play(Transform(grid, space_mobject, run_time = 5))\n",
        "        self.remove(grid)\n",
        "        self.set_color_region(space_region, GREY_D)\n",
        "        self.wait()\n",
        "        self.add(infinitely, detailed)\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(Transform(detailed, extending)))\n",
        "        self.play(ShowCreation(arrows))\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.set_color_region(space_region, GREY_D)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(Transform(line, curve, run_time = 5))\n",
        "\n",
        "\n",
        "\n",
        "class HistoryOfDiscover(Scene):\n",
        "    def construct(self):\n",
        "        time_line = get_time_line()\n",
        "        time_line.shift(-time_line.number_to_point(1900))\n",
        "        hilbert_curve = HilbertCurve(order = 3)\n",
        "        peano_curve = PeanoCurve(order = 2)\n",
        "        for curve in hilbert_curve, peano_curve:\n",
        "            curve.scale(0.5)\n",
        "        hilbert_curve.to_corner(DOWN+RIGHT)\n",
        "        peano_curve.to_corner(UP+LEFT)\n",
        "        squares = Mobject(*[\n",
        "            Square(side_length=3, color=WHITE).replace(curve)\n",
        "            for curve in (hilbert_curve, peano_curve)\n",
        "        ])\n",
        "\n",
        "\n",
        "        self.add(time_line)\n",
        "        self.wait()\n",
        "        for year, curve, vect, text in [\n",
        "            (1890, peano_curve, UP, \"Peano Curve\"), \n",
        "            (1891, hilbert_curve, DOWN, \"Hilbert Curve\"),\n",
        "            ]:\n",
        "            point = time_line.number_to_point(year)\n",
        "            point[1] = 0.2\n",
        "            arrow = Arrow(point+2*vect, point, buff = 0.1)\n",
        "            arrow.set_color_by_gradient(curve.start_color, curve.end_color)\n",
        "            year_mob = OldTex(str(year))\n",
        "            year_mob.next_to(arrow, vect)\n",
        "            words = OldTexText(text)\n",
        "            words.next_to(year_mob, vect)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(arrow), \n",
        "                ShimmerIn(year_mob),\n",
        "                ShimmerIn(words)\n",
        "            )\n",
        "            self.play(ShowCreation(curve))\n",
        "            self.wait()\n",
        "        self.play(ShowCreation(squares))\n",
        "        self.wait()\n",
        "        self.play(ApplyMethod(\n",
        "            Mobject(*self.mobjects).shift, 20*(DOWN+RIGHT)\n",
        "        ))\n",
        "\n",
        "\n",
        "\n",
        "class DefinitionOfCurve(Scene):\n",
        "    def construct(self):\n",
        "        start_words = OldTexText([\n",
        "            \"``\", \"Space Filling\", \"Curve ''\",\n",
        "        ]).to_edge(TOP, buff = 0.25)\n",
        "        quote, space_filling, curve_quote = start_words.copy().split()\n",
        "        curve_quote.shift(\n",
        "            space_filling.get_left()-\\\n",
        "            curve_quote.get_left()\n",
        "        )\n",
        "        space_filling = Point(space_filling.get_center())                \n",
        "        end_words = Mobject(*[\n",
        "            quote, space_filling, curve_quote\n",
        "        ]).center().to_edge(TOP, buff = 0.25)\n",
        "        space_filling_fractal = OldTexText(\"\"\"\n",
        "            ``Space Filling Fractal''\n",
        "        \"\"\").to_edge(UP)\n",
        "        curve = HilbertCurve(order = 2).shift(DOWN)\n",
        "        fine_curve = HilbertCurve(order = 8)\n",
        "        fine_curve.replace(curve)\n",
        "        dots = Mobject(*[\n",
        "            Dot(\n",
        "                curve.get_points()[n*curve.get_num_points()/15],\n",
        "                color = YELLOW_C\n",
        "            )\n",
        "            for n in range(1, 15)\n",
        "            if n not in [4, 11]\n",
        "        ])\n",
        "\n",
        "        start_words.shift(2*(UP+LEFT))\n",
        "        self.play(\n",
        "            ApplyMethod(start_words.shift, 2*(DOWN+RIGHT))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(start_words, end_words))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(curve))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            dots, \n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.play(ShowCreation(fine_curve, run_time = 5))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(space_filling_fractal))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PseudoHilbertCurvesDontFillSpace(Scene):\n",
        "    def construct(self):\n",
        "        curve = HilbertCurve(order = 1)\n",
        "        grid = Grid(2, 2, stroke_width=1)\n",
        "        self.add(grid, curve)\n",
        "        for order in range(2, 6):\n",
        "            self.wait()\n",
        "            new_grid = Grid(2**order, 2**order, stroke_width=1)\n",
        "            self.play(\n",
        "                ShowCreation(new_grid),\n",
        "                Animation(curve)          \n",
        "            )\n",
        "            self.remove(grid)\n",
        "            grid = new_grid\n",
        "            self.play(Transform(\n",
        "                curve, HilbertCurve(order = order)\n",
        "            ))\n",
        "\n",
        "\n",
        "        square = Square(side_length = 6, color = WHITE)\n",
        "        square.corner = Mobject1D()\n",
        "        square.corner.add_line(3*DOWN, ORIGIN)\n",
        "        square.corner.add_line(ORIGIN, 3*RIGHT)\n",
        "        square.digest_mobject_attrs()\n",
        "        square.scale(2**(-5))\n",
        "        square.corner.set_color(\n",
        "            Color(rgb = curve.rgbas[curve.get_num_points()/3])\n",
        "        )\n",
        "        square.shift(\n",
        "            grid.get_corner(UP+LEFT)-\\\n",
        "            square.get_corner(UP+LEFT)\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(grid), \n",
        "            FadeOut(curve),\n",
        "            FadeIn(square)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(square.replace, grid)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HilbertCurveIsLimit(Scene):\n",
        "    def construct(self):\n",
        "        mathy, bubble = get_mathy_and_bubble()\n",
        "        bubble.write(\n",
        "            \"A Hilbert curve is the \\\\\\\\ limit of all these \\\\dots\"\n",
        "        )\n",
        "\n",
        "        self.add(mathy, bubble)\n",
        "        self.play(ShimmerIn(bubble.content))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DefiningCurves(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            [\"One does not simply define the limit \\\\\\\\ \\\n",
        "            of a sequence of\",\"curves\",\"\\\\dots\"]\n",
        "        )\n",
        "        top_words = OldTexText([\n",
        "            \"curves\", \"are functions\"\n",
        "        ]).to_edge(UP)\n",
        "        curves1 = words.split()[1]\n",
        "        curves2 = top_words.split()[0]\n",
        "        words.ingest_submobjects()\n",
        "        number = OldTex(\"0.27\")\n",
        "        pair = OldTex(\"(0.53, 0.02)\")\n",
        "        pair.next_to(number, buff = 2)\n",
        "        arrow = Arrow(number, pair)\n",
        "        Mobject(number, arrow, pair).center().shift(UP)\n",
        "        number_line = UnitInterval()\n",
        "        number_line.stretch_to_fit_width(5)\n",
        "        number_line.to_edge(LEFT).shift(DOWN)\n",
        "        grid = Grid(4, 4).scale(0.4)\n",
        "        grid.next_to(number_line, buff = 2)\n",
        "        low_arrow = Arrow(number_line, grid)\n",
        "\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            ApplyMethod(curves1.replace, curves2),\n",
        "            ShimmerIn(top_words.split()[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(number))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(FadeIn(pair))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(number_line))\n",
        "        self.play(ShowCreation(low_arrow))\n",
        "        self.play(ShowCreation(grid))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PseudoHilbertCurveAsFunctionExample(Scene):\n",
        "    args_list = [(2,), (3,)]\n",
        "\n",
        "    # For subclasses to turn args in the above  \n",
        "    # list into stings which can be appended to the name\n",
        "    @staticmethod\n",
        "    def args_to_string(order):\n",
        "        return \"Order%d\"%order\n",
        "        \n",
        "    @staticmethod\n",
        "    def string_to_args(order_str):\n",
        "        return int(order_str)\n",
        "\n",
        "\n",
        "    def construct(self, order):\n",
        "        if order == 2:\n",
        "            result_tex = \"(0.125, 0.75)\"\n",
        "        elif order == 3:\n",
        "            result_tex = \"(0.0758,  0.6875)\"\n",
        "\n",
        "        phc, arg, result = OldTex([\n",
        "            \"\\\\text{PHC}_%d\"%order, \n",
        "            \"(0.3)\", \n",
        "            \"= %s\"%result_tex\n",
        "        ]).to_edge(UP).split()\n",
        "        function = OldTexText(\"Function\", size = \"\\\\normal\")\n",
        "        function.shift(phc.get_center()+DOWN+2*LEFT)\n",
        "        function_arrow = Arrow(function, phc)\n",
        "\n",
        "        line = Line(5*LEFT, 5*RIGHT)\n",
        "        curve = HilbertCurve(order = order)\n",
        "        line.match_colors(curve)\n",
        "        grid = Grid(2**order, 2**order)\n",
        "        grid.fade()\n",
        "        for mob in curve, grid:\n",
        "            mob.scale(0.7)\n",
        "        index = int(0.3*line.get_num_points())\n",
        "        dot1 = Dot(line.get_points()[index])\n",
        "        arrow1 = Arrow(arg, dot1, buff = 0.1)\n",
        "        dot2 = Dot(curve.get_points()[index])\n",
        "        arrow2 = Arrow(result.get_bottom(), dot2, buff = 0.1)\n",
        "\n",
        "        self.add(phc)\n",
        "        self.play(\n",
        "            ShimmerIn(function),\n",
        "            ShowCreation(function_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(function_arrow, function)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(arg),\n",
        "            ShowCreation(arrow1),\n",
        "            ShowCreation(dot1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(arrow1)\n",
        "        self.play(\n",
        "            FadeIn(grid),            \n",
        "            Transform(line, curve),\n",
        "            Transform(dot1, dot2),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(result),\n",
        "            ShowCreation(arrow2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class ContinuityRequired(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText([\n",
        "            \"A function must be\",\n",
        "            \"\\\\emph{continuous}\", \n",
        "            \"if it is to represent a curve.\"\n",
        "        ])\n",
        "        words.split()[1].set_color(YELLOW_C)\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class FormalDefinitionOfContinuity(Scene):\n",
        "    def construct(self):\n",
        "        self.setup()\n",
        "        self.label_spaces()\n",
        "        self.move_dot()\n",
        "        self.label_jump()\n",
        "        self.draw_circles()\n",
        "        self.vary_circle_sizes()\n",
        "        self.discontinuous_point()\n",
        "\n",
        "\n",
        "    def setup(self):\n",
        "        self.input_color = YELLOW_C\n",
        "        self.output_color = RED\n",
        "        def spiril(t):\n",
        "            theta = 2*np.pi*t\n",
        "            return t*np.cos(theta)*RIGHT+t*np.sin(theta)*UP\n",
        "\n",
        "        self.spiril1 = ParametricCurve(\n",
        "            lambda t : 1.5*RIGHT + DOWN + 2*spiril(t),\n",
        "            density = 5*DEFAULT_POINT_DENSITY_1D,\n",
        "        )\n",
        "        self.spiril2 = ParametricCurve(\n",
        "            lambda t : 5.5*RIGHT + UP - 2*spiril(1-t),\n",
        "            density = 5*DEFAULT_POINT_DENSITY_1D,\n",
        "        )\n",
        "        Mobject.align_data_and_family(self.spiril1, self.spiril2)\n",
        "        self.output = Mobject(self.spiril1, self.spiril2)\n",
        "        self.output.ingest_submobjects()\n",
        "        self.output.set_color(GREEN_A)\n",
        "\n",
        "        self.interval = UnitInterval()\n",
        "        self.interval.set_width(FRAME_X_RADIUS-1)\n",
        "        self.interval.to_edge(LEFT)\n",
        "\n",
        "        self.input_dot = Dot(color = self.input_color)\n",
        "        self.output_dot = self.input_dot.copy().set_color(self.output_color)\n",
        "        left, right = self.interval.get_left(), self.interval.get_right()\n",
        "        self.input_homotopy = lambda x_y_z_t : (x_y_z_t[0], x_y_z_t[1], x_y_z_t[3]) + interpolate(left, right, x_y_z_t[3])\n",
        "        output_size = self.output.get_num_points()-1\n",
        "        output_points = self.output.points        \n",
        "        self.output_homotopy = lambda x_y_z_t1 : (x_y_z_t1[0], x_y_z_t1[1], x_y_z_t1[2]) + output_points[int(x_y_z_t1[3]*output_size)]\n",
        "\n",
        "    def get_circles_and_points(self, min_input, max_input):\n",
        "        input_left, input_right = [\n",
        "            self.interval.number_to_point(num)\n",
        "            for num in (min_input, max_input)\n",
        "        ]\n",
        "        input_circle = Circle(\n",
        "            radius = get_norm(input_left-input_right)/2,\n",
        "            color = WHITE\n",
        "        )\n",
        "        input_circle.shift((input_left+input_right)/2)\n",
        "\n",
        "        input_points = Line(\n",
        "            input_left, input_right, \n",
        "            color = self.input_color\n",
        "        )\n",
        "        output_points = Mobject(color = self.output_color)\n",
        "        n = self.output.get_num_points()\n",
        "        output_points.add_points(\n",
        "            self.output.get_points()[int(min_input*n):int(max_input*n)]\n",
        "        )\n",
        "        output_center = output_points.get_points()[int(0.5*output_points.get_num_points())]\n",
        "        max_distance = get_norm(output_center-output_points.get_points()[-1])\n",
        "        output_circle = Circle(\n",
        "            radius = max_distance, \n",
        "            color = WHITE\n",
        "        )\n",
        "        output_circle.shift(output_center)\n",
        "        return (\n",
        "            input_circle, \n",
        "            input_points, \n",
        "            output_circle, \n",
        "            output_points\n",
        "        )\n",
        "\n",
        "\n",
        "    def label_spaces(self):\n",
        "        input_space = OldTexText(\"Input Space\")\n",
        "        input_space.to_edge(UP)        \n",
        "        input_space.shift(LEFT*FRAME_X_RADIUS/2)\n",
        "        output_space = OldTexText(\"Output Space\")\n",
        "        output_space.to_edge(UP)\n",
        "        output_space.shift(RIGHT*FRAME_X_RADIUS/2)\n",
        "        line = Line(\n",
        "            UP*FRAME_Y_RADIUS, DOWN*FRAME_Y_RADIUS, \n",
        "            color = WHITE\n",
        "        )\n",
        "        self.play(\n",
        "            ShimmerIn(input_space),\n",
        "            ShimmerIn(output_space),\n",
        "            ShowCreation(line),\n",
        "            ShowCreation(self.interval),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def move_dot(self):\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"run_time\"  : 3\n",
        "        }\n",
        "        self.play(\n",
        "            Homotopy(self.input_homotopy, self.input_dot, **kwargs),\n",
        "            Homotopy(self.output_homotopy, self.output_dot, **kwargs),\n",
        "            ShowCreation(self.output, **kwargs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def label_jump(self):\n",
        "        jump_points = Mobject(\n",
        "            Point(self.spiril1.get_points()[-1]),\n",
        "            Point(self.spiril2.get_points()[0])\n",
        "        )\n",
        "        self.brace = Brace(jump_points, RIGHT)\n",
        "        self.jump = OldTexText(\"Jump\")\n",
        "        self.jump.next_to(self.brace, RIGHT)\n",
        "        self.play(\n",
        "            GrowFromCenter(self.brace),\n",
        "            ShimmerIn(self.jump)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(self.brace, self.jump)\n",
        "\n",
        "\n",
        "    def draw_circles(self):\n",
        "        input_value = 0.45\n",
        "        input_radius = 0.04\n",
        "        for dot in self.input_dot, self.output_dot:\n",
        "            dot.center()\n",
        "        kwargs = {\n",
        "            \"rate_func\" : lambda t : interpolate(1, input_value, smooth(t))\n",
        "        }\n",
        "        self.play(\n",
        "            Homotopy(self.input_homotopy, self.input_dot, **kwargs),\n",
        "            Homotopy(self.output_homotopy, self.output_dot, **kwargs)\n",
        "        )\n",
        "\n",
        "        A, B = list(map(Mobject.get_center, [self.input_dot, self.output_dot]))\n",
        "        A_text = OldTexText(\"A\")\n",
        "        A_text.shift(A+2*(LEFT+UP))\n",
        "        A_arrow = Arrow(\n",
        "            A_text, self.input_dot,\n",
        "            color = self.input_color\n",
        "        )\n",
        "        B_text = OldTexText(\"B\")\n",
        "        B_text.shift(B+2*RIGHT+DOWN)\n",
        "        B_arrow = Arrow(\n",
        "            B_text, self.output_dot,\n",
        "            color = self.output_color\n",
        "        )\n",
        "        tup = self.get_circles_and_points(\n",
        "            input_value-input_radius, \n",
        "            input_value+input_radius\n",
        "        )\n",
        "        input_circle, input_points, output_circle, output_points = tup\n",
        "\n",
        "        for text, arrow in [(A_text, A_arrow), (B_text, B_arrow)]:\n",
        "            self.play(\n",
        "                ShimmerIn(text),\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.remove(A_text, A_arrow, B_text, B_arrow)\n",
        "        self.play(ShowCreation(input_circle))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(input_points))\n",
        "        self.wait()\n",
        "        input_points_copy = input_points.copy()\n",
        "        self.play(\n",
        "            Transform(input_points_copy, output_points),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(output_circle))\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.remove(*[\n",
        "            input_circle, input_points, \n",
        "            output_circle, input_points_copy\n",
        "        ])\n",
        "\n",
        "\n",
        "    def vary_circle_sizes(self):\n",
        "        input_value = 0.45\n",
        "        radius = 0.04\n",
        "        vary_circles = VaryCircles(\n",
        "            self, input_value, radius, \n",
        "            run_time = 5,\n",
        "        )\n",
        "        self.play(vary_circles)\n",
        "        self.wait()\n",
        "        text = OldTexText(\"Function is ``Continuous at A''\")\n",
        "        text.shift(2*UP).to_edge(LEFT)\n",
        "        arrow = Arrow(text, self.input_dot)\n",
        "        self.play(\n",
        "            ShimmerIn(text),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(vary_circles.mobject, text, arrow)\n",
        "\n",
        "    def discontinuous_point(self):\n",
        "        point_description = OldTexText(\n",
        "            \"Point where the function jumps\"\n",
        "        )\n",
        "        point_description.shift(3*RIGHT)        \n",
        "        discontinuous_at_A = OldTexText(\n",
        "            \"``Discontinuous at A''\",\n",
        "            size = \"\\\\Large\"\n",
        "        )\n",
        "        discontinuous_at_A.shift(2*UP).to_edge(LEFT)\n",
        "        text = OldTexText(\"\"\"\n",
        "            Circle around ouput \\\\\\\\ \n",
        "            points can never \\\\\\\\\n",
        "            be smaller than \\\\\\\\\n",
        "            the jump\n",
        "        \"\"\")\n",
        "        text.scale(0.75)\n",
        "        text.shift(3.5*RIGHT)\n",
        "\n",
        "        input_value = 0.5\n",
        "        input_radius = 0.04\n",
        "        vary_circles = VaryCircles(\n",
        "            self, input_value, input_radius, \n",
        "            run_time = 5,\n",
        "        )\n",
        "        for dot in self.input_dot, self.output_dot:\n",
        "            dot.center()\n",
        "        kwargs = {\n",
        "            \"rate_func\" : lambda t : interpolate(0.45, input_value, smooth(t))\n",
        "        }\n",
        "        self.play(\n",
        "            Homotopy(self.input_homotopy, self.input_dot, **kwargs),\n",
        "            Homotopy(self.output_homotopy, self.output_dot, **kwargs)\n",
        "        )\n",
        "        discontinuous_arrow = Arrow(discontinuous_at_A, self.input_dot)\n",
        "        arrow = Arrow(\n",
        "            point_description, self.output_dot,\n",
        "            buff = 0.05,\n",
        "            color = self.output_color\n",
        "        )\n",
        "        self.play(\n",
        "            ShimmerIn(point_description),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(point_description, arrow)\n",
        "\n",
        "        tup = self.get_circles_and_points(\n",
        "            input_value-input_radius, \n",
        "            input_value+input_radius\n",
        "        )\n",
        "        input_circle, input_points, output_circle, output_points = tup\n",
        "        input_points_copy = input_points.copy()\n",
        "        self.play(ShowCreation(input_circle))\n",
        "        self.play(ShowCreation(input_points))\n",
        "        self.play(\n",
        "            Transform(input_points_copy, output_points),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(ShowCreation(output_circle))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(text))\n",
        "        self.remove(input_circle, input_points, output_circle, input_points_copy)\n",
        "        self.play(vary_circles)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(discontinuous_at_A),\n",
        "            ShowCreation(discontinuous_arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.remove(vary_circles.mobject, discontinuous_at_A, discontinuous_arrow)\n",
        "\n",
        "    def continuous_point(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "\n",
        "class VaryCircles(Animation):\n",
        "    def __init__(self, scene, input_value, radius, **kwargs):\n",
        "        digest_locals(self)\n",
        "        Animation.__init__(self, Mobject(), **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        radius = self.radius + 0.9*self.radius*np.sin(1.5*np.pi*alpha)\n",
        "        self.mobject = Mobject(*self.scene.get_circles_and_points(\n",
        "            self.input_value-radius,\n",
        "            self.input_value+radius\n",
        "        )).ingest_submobjects()\n",
        "\n",
        "\n",
        "class FunctionIsContinuousText(Scene):\n",
        "    def construct(self):\n",
        "        all_points = OldTexText(\"$f$ is continuous at every input point\")\n",
        "        continuous = OldTexText(\"$f$ is continuous\")\n",
        "        all_points.shift(UP)\n",
        "        continuous.shift(DOWN)\n",
        "        arrow = Arrow(all_points, continuous)\n",
        "\n",
        "        self.play(ShimmerIn(all_points))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(ShimmerIn(continuous))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DefineActualHilbertCurveText(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\"\"\n",
        "            Finally define a Hilbert Curve\\\\dots\n",
        "        \"\"\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReliesOnWonderfulProperty(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\"\"\n",
        "            \\\\dots which relies on a certain property\n",
        "            of Pseudo-Hilbert-curves.\n",
        "        \"\"\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WonderfulPropertyOfPseudoHilbertCurves(Scene):\n",
        "    def construct(self):\n",
        "        val = 0.3\n",
        "        text = OldTexText([\n",
        "            \"PHC\", \"$_n\", \"(\", \"%3.1f\"%val, \")$\", \n",
        "            \" has a \", \"limit point \", \"as $n \\\\to \\\\infty$\"\n",
        "        ])\n",
        "        func_parts = text.copy().split()[:5]\n",
        "        Mobject(*func_parts).center().to_edge(UP)\n",
        "        num_str, val_str = func_parts[1], func_parts[3]\n",
        "        curve = UnitInterval()\n",
        "        curve.sort_points(lambda p : p[0])\n",
        "        dot = Dot().shift(curve.number_to_point(val))\n",
        "        arrow = Arrow(val_str, dot, buff = 0.1)\n",
        "        curve.add_numbers(0, 1)\n",
        "\n",
        "        self.play(ShowCreation(curve))\n",
        "        self.play(\n",
        "            ShimmerIn(val_str),\n",
        "            ShowCreation(arrow),\n",
        "            ShowCreation(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            *[\n",
        "                FadeIn(func_parts[i])\n",
        "                for i in (0, 1, 2, 4)\n",
        "            ]\n",
        "        )\n",
        "        for num in range(2,9):\n",
        "            new_curve = HilbertCurve(order = num)\n",
        "            new_curve.scale(0.8)\n",
        "            new_dot = Dot(new_curve.get_points()[int(val*new_curve.get_num_points())])\n",
        "            new_num_str = OldTex(str(num)).replace(num_str)\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                Transform(dot, new_dot),\n",
        "                Transform(num_str, new_num_str)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        text.to_edge(UP)\n",
        "        text_parts = text.split()\n",
        "        for index in 1, -1:\n",
        "            text_parts[index].set_color()\n",
        "        starters = Mobject(*func_parts + [\n",
        "            Point(mob.get_center(), stroke_width=1)\n",
        "            for mob in text_parts[5:]\n",
        "        ])\n",
        "        self.play(Transform(starters, text))\n",
        "        arrow = Arrow(text_parts[-2].get_bottom(), dot, buff = 0.1)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "class FollowManyPoints(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText([\n",
        "            \"PHC\", \"_n\", \"(\", \"x\", \")$\", \n",
        "            \" has a limit point \", \"as $n \\\\to \\\\infty$\",\n",
        "            \"\\\\\\\\ for all $x$\"\n",
        "        ])\n",
        "        parts = text.split()\n",
        "        parts[-1].next_to(Mobject(*parts[:-1]), DOWN)\n",
        "        parts[-1].set_color(BLUE)\n",
        "        parts[3].set_color(BLUE)\n",
        "        parts[1].set_color()\n",
        "        parts[-2].set_color()\n",
        "        text.to_edge(UP)\n",
        "        curve = UnitInterval()\n",
        "        curve.sort_points(lambda p : p[0])\n",
        "        vals = np.arange(0.1, 1, 0.1)\n",
        "        dots = Mobject(*[\n",
        "            Dot(curve.number_to_point(val))\n",
        "            for val in vals\n",
        "        ])\n",
        "        curve.add_numbers(0, 1)\n",
        "        starter_dots = dots.copy().ingest_submobjects()\n",
        "        starter_dots.shift(2*UP)\n",
        "\n",
        "        self.add(curve, text)\n",
        "        self.wait()\n",
        "        self.play(DelayByOrder(ApplyMethod(starter_dots.shift, 2*DOWN)))\n",
        "        self.wait()\n",
        "        self.remove(starter_dots)\n",
        "        self.add(dots)\n",
        "        for num in range(1, 10):\n",
        "            new_curve = HilbertCurve(order = num)\n",
        "            new_curve.scale(0.8)\n",
        "            new_dots = Mobject(*[\n",
        "                Dot(new_curve.get_points()[int(val*new_curve.get_num_points())])\n",
        "                for val in vals\n",
        "            ])\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                Transform(dots, new_dots),\n",
        "            )\n",
        "            # self.wait()\n",
        "\n",
        "\n",
        "class FormalDefinitionOfHilbertCurve(Scene):\n",
        "    def construct(self):\n",
        "        val = 0.7\n",
        "        text = OldTex([\n",
        "            \"\\\\text{HC}(\", \"x\", \")\",\n",
        "            \"=\\\\lim_{n \\\\to \\\\infty}\\\\text{PHC}_n(\", \"x\", \")\"\n",
        "        ])\n",
        "        text.to_edge(UP)\n",
        "        x1 = text.split()[1]\n",
        "        x2 = text.split()[-2]\n",
        "        x2.set_color(BLUE)\n",
        "        explanation = OldTexText(\"Actual Hilbert curve function\")\n",
        "        exp_arrow = Arrow(explanation, text.split()[0])\n",
        "        curve = UnitInterval()\n",
        "        dot = Dot(curve.number_to_point(val))\n",
        "        x_arrow = Arrow(x1.get_bottom(), dot, buff = 0)\n",
        "        curve.sort_points(lambda p : p[0])\n",
        "        curve.add_numbers(0, 1)\n",
        "\n",
        "        self.add(*text.split()[:3])\n",
        "        self.play(\n",
        "            ShimmerIn(explanation),\n",
        "            ShowCreation(exp_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(explanation, exp_arrow)\n",
        "        self.play(ShowCreation(curve))\n",
        "        self.play(\n",
        "            ApplyMethod(x1.set_color, BLUE),\n",
        "            ShowCreation(x_arrow), \n",
        "            ShowCreation(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(x_arrow)\n",
        "        limit = Mobject(*text.split()[3:]).ingest_submobjects()\n",
        "        limit.stroke_width = 1\n",
        "        self.play(ShimmerIn(limit))\n",
        "        for num in range(1, 9):\n",
        "            new_curve = HilbertCurve(order = num)\n",
        "            new_curve.scale(0.8)\n",
        "            new_dot = Dot(new_curve.get_points()[int(val*new_curve.get_num_points())])\n",
        "            self.play(\n",
        "                Transform(curve, new_curve),\n",
        "                Transform(dot, new_dot),\n",
        "            )\n",
        "\n",
        "\n",
        "class CouldNotDefineForSnakeCurve(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"\"\"\n",
        "            You could not define a limit curve from\n",
        "            snake curves.\n",
        "        \"\"\"))\n",
        "        self.wait()\n",
        "\n",
        "class ThreeThingsToProve(Scene):\n",
        "    def construct(self):\n",
        "        definition = OldTex([\n",
        "            \"\\\\text{HC}(\", \"x\", \")\",\n",
        "            \"=\\\\lim_{n \\\\to \\\\infty}\\\\text{PHC}_n(\", \"x\", \")\"\n",
        "        ])\n",
        "        definition.to_edge(UP)\n",
        "        definition.split()[1].set_color(BLUE)\n",
        "        definition.split()[-2].set_color(BLUE)\n",
        "        intro = OldTexText(\"Three things need to be proven\")\n",
        "        prove_that = OldTexText(\"Prove that HC is $\\\\dots$\")\n",
        "        prove_that.scale(0.7)\n",
        "        prove_that.to_edge(LEFT)\n",
        "        items = OldTexText([\n",
        "            \"\\\\begin{enumerate}\",\n",
        "            \"\\\\item Well-defined: \",\n",
        "            \"Points on Pseudo-Hilbert-curves really do converge\",\n",
        "            \"\\\\item A Curve: \",\n",
        "            \"HC is continuous\",\n",
        "            \"\\\\item Space-filling: \",\n",
        "            \"Each point in the unit square is an output of HC\",\n",
        "            \"\\\\end{enumerate}\",\n",
        "        ]).split()\n",
        "        items[1].set_color(GREEN)\n",
        "        items[3].set_color(YELLOW_C)\n",
        "        items[5].set_color(MAROON)\n",
        "        Mobject(*items).to_edge(RIGHT)\n",
        "\n",
        "        self.add(definition)\n",
        "        self.play(ShimmerIn(intro))\n",
        "        self.wait()\n",
        "        self.play(Transform(intro, prove_that))\n",
        "        for item in items[1:-1]:\n",
        "            self.play(ShimmerIn(item))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class TilingSpace(Scene):\n",
        "    def construct(self):\n",
        "        coords_set = [ORIGIN]\n",
        "        for n in range(int(FRAME_WIDTH)):\n",
        "            for vect in UP, RIGHT:\n",
        "                for k in range(n):\n",
        "                    new_coords = coords_set[-1]+((-1)**n)*vect\n",
        "                    coords_set.append(new_coords)\n",
        "        square = Square(side_length = 1, color = WHITE)\n",
        "        squares = Mobject(*[\n",
        "            square.copy().shift(coords)\n",
        "            for coords in coords_set\n",
        "        ]).ingest_submobjects()\n",
        "        self.play(\n",
        "            DelayByOrder(FadeIn(squares)),\n",
        "            run_time = 3\n",
        "        )\n",
        "        curve = HilbertCurve(order = 6).scale(1./6)\n",
        "        all_curves = Mobject(*[\n",
        "            curve.copy().shift(coords)\n",
        "            for coords in coords_set\n",
        "        ]).ingest_submobjects()\n",
        "        all_curves.thin_out(10)\n",
        "        self.play(ShowCreation(\n",
        "            all_curves,\n",
        "            rate_func=linear,\n",
        "            run_time = 15\n",
        "        ))\n",
        "\n",
        "\n",
        "class ColorIntervals(Scene):\n",
        "    def construct(self):\n",
        "        number_line = NumberLine(\n",
        "            numerical_radius = 5,\n",
        "            number_at_center = 5,\n",
        "            leftmost_tick = 0,\n",
        "            density = 2*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        number_line.shift(2*RIGHT)\n",
        "        number_line.add_numbers()\n",
        "        number_line.scale(2)\n",
        "        brace = Brace(Mobject(\n",
        "            *number_line.submobjects[:2]\n",
        "        ))\n",
        "\n",
        "        self.add(number_line)\n",
        "        for n in range(0, 10, 2):\n",
        "            if n == 0:\n",
        "                brace_anim = GrowFromCenter(brace)\n",
        "            else:\n",
        "                brace_anim = ApplyMethod(brace.shift, 2*RIGHT)\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    number_line.set_color,\n",
        "                    RED,\n",
        "                    lambda p : p[0] > n-6.2 and p[0] < n-4 and p[1] > -0.4\n",
        "                ),\n",
        "                brace_anim\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}