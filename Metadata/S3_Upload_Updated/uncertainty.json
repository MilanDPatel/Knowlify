{
    "topic": "The mathematical concept being demonstrated is the probability distribution of a normal distribution. The code creates a GaussianDist",
    "code": [
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "import scipy\n",
        "from manim_imports_ext import *\n",
        "from _2018.fourier import *\n",
        "\n",
        "import warnings\n",
        "warnings.warn(\"\"\"\n",
        "    Warning: This file makes use of\n",
        "    ContinualAnimation, which has since\n",
        "    been deprecated\n",
        "\"\"\")\n",
        "\n",
        "FREQUENCY_COLOR = RED\n",
        "USE_ALMOST_FOURIER_BY_DEFAULT = False\n",
        "\n",
        "class GaussianDistributionWrapper(Line):\n",
        "    \"\"\"\n",
        "    This is meant to encode a 2d normal distribution as\n",
        "    a mobject (so as to be able to have it be interpolated\n",
        "    during animations).  It is a line whose center is the mean\n",
        "    mu of a distribution, and whose radial vector (center to end)\n",
        "    is the distribution's standard deviation\n",
        "    \"\"\"\n",
        "    CONFIG = {\n",
        "        \"stroke_width\" : 0,\n",
        "        \"mu\" : ORIGIN,\n",
        "        \"sigma\" : RIGHT,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        Line.__init__(self, ORIGIN, RIGHT, **kwargs)\n",
        "        self.change_parameters(self.mu, self.sigma)\n",
        "\n",
        "    def change_parameters(self, mu = None, sigma = None):\n",
        "        curr_mu, curr_sigma = self.get_parameters()\n",
        "        mu = mu if mu is not None else curr_mu\n",
        "        sigma = sigma if sigma is not None else curr_sigma\n",
        "        self.put_start_and_end_on(mu - sigma, mu + sigma)\n",
        "        return self\n",
        "\n",
        "    def get_parameters(self):\n",
        "        \"\"\" Return mu_x, mu_y, sigma_x, sigma_y\"\"\"\n",
        "        center, end = self.get_center(), self.get_end()\n",
        "        return center, end-center\n",
        "\n",
        "    def get_random_points(self, size = 1):\n",
        "        mu, sigma = self.get_parameters()\n",
        "        return np.array([\n",
        "            np.array([\n",
        "                np.random.normal(mu_coord, sigma_coord)\n",
        "                for mu_coord, sigma_coord in zip(mu, sigma)\n",
        "            ])\n",
        "            for x in range(size)\n",
        "        ])\n",
        "\n",
        "class ProbabalisticMobjectCloud(ContinualAnimation):\n",
        "    CONFIG = {\n",
        "        \"fill_opacity\" : 0.25,\n",
        "        \"n_copies\" : 100,\n",
        "        \"gaussian_distribution_wrapper_config\" : {},\n",
        "        \"time_per_change\" : 1./60,\n",
        "        \"start_up_time\" : 0,\n",
        "    }\n",
        "    def __init__(self, prototype, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        fill_opacity = self.fill_opacity or prototype.get_fill_opacity()\n",
        "        if \"mu\" not in self.gaussian_distribution_wrapper_config:\n",
        "            self.gaussian_distribution_wrapper_config[\"mu\"] = prototype.get_center()\n",
        "        self.gaussian_distribution_wrapper = GaussianDistributionWrapper(\n",
        "            **self.gaussian_distribution_wrapper_config\n",
        "        )\n",
        "        self.time_since_last_change = np.inf\n",
        "        group = VGroup(*[\n",
        "            prototype.copy().set_fill(opacity = fill_opacity)\n",
        "            for x in range(self.n_copies)\n",
        "        ])\n",
        "        ContinualAnimation.__init__(self, group, **kwargs)\n",
        "        self.update_mobject(0)\n",
        "\n",
        "    def update_mobject(self, dt):\n",
        "        self.time_since_last_change += dt\n",
        "        if self.time_since_last_change < self.time_per_change:\n",
        "            return\n",
        "        self.time_since_last_change = 0\n",
        "\n",
        "        group = self.mobject\n",
        "        points = self.gaussian_distribution_wrapper.get_random_points(len(group))\n",
        "        for mob, point in zip(group, points):\n",
        "            self.update_mobject_by_point(mob, point)\n",
        "        return self\n",
        "\n",
        "    def update_mobject_by_point(self, mobject, point):\n",
        "        mobject.move_to(point)\n",
        "        return self\n",
        "\n",
        "class ProbabalisticDotCloud(ProbabalisticMobjectCloud):\n",
        "    CONFIG = {\n",
        "        \"color\" : BLUE,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        dot = Dot(color = self.color)\n",
        "        ProbabalisticMobjectCloud.__init__(self, dot)\n",
        "\n",
        "class ProbabalisticVectorCloud(ProbabalisticMobjectCloud):\n",
        "    CONFIG = {\n",
        "        \"color\" : RED,\n",
        "        \"n_copies\" : 20,\n",
        "        \"fill_opacity\" : 0.5,\n",
        "        \"center_func\" : lambda : ORIGIN,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        vector = Vector(\n",
        "            RIGHT, color = self.color,\n",
        "            max_tip_length_to_length_ratio = 1,\n",
        "        )\n",
        "        ProbabalisticMobjectCloud.__init__(self, vector)\n",
        "\n",
        "    def update_mobject_by_point(self, vector, point):\n",
        "        vector.put_start_and_end_on(\n",
        "            self.center_func(),\n",
        "            point\n",
        "        )\n",
        "\n",
        "class RadarDish(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"radar_dish\",\n",
        "        \"fill_color\" : GREY_B,\n",
        "        \"stroke_color\" : WHITE,\n",
        "        \"stroke_width\" : 1,\n",
        "        \"height\" : 1,\n",
        "    }\n",
        "\n",
        "class Plane(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"plane\",\n",
        "        \"color\" : GREY_B,\n",
        "        \"height\" : 1,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.rotate(-TAU/4)\n",
        "\n",
        "class FalconHeavy(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"falcon_heavy\",\n",
        "        \"color\" : WHITE,\n",
        "        \"logo_color\" : BLUE_E,\n",
        "        \"height\" : 1.5,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        self.logo = self[-9:]\n",
        "        self.logo.set_color(self.logo_color)\n",
        "\n",
        "class RadarPulseSingleton(ContinualAnimation):\n",
        "    CONFIG = {\n",
        "        \"speed\" : 3.0,\n",
        "        \"direction\" : RIGHT,\n",
        "        \"start_up_time\" : 0,\n",
        "        \"fade_in_time\" : 0.5,\n",
        "        \"color\" : WHITE,\n",
        "        \"stroke_width\" : 3,\n",
        "    }\n",
        "    def __init__(self, radar_dish, target, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        self.direction = self.direction/get_norm(self.direction)\n",
        "        self.radar_dish = radar_dish\n",
        "        self.target = target\n",
        "        self.reflection_distance = None\n",
        "        self.arc = Arc(\n",
        "            start_angle = -30*DEGREES,\n",
        "            angle = 60*DEGREES,\n",
        "        )\n",
        "        self.arc.set_height(0.75*radar_dish.get_height())\n",
        "        self.arc.move_to(radar_dish, UP+RIGHT)\n",
        "        self.start_points = np.array(self.arc.get_points())\n",
        "        self.start_center = self.arc.get_center()\n",
        "        self.finished = False\n",
        "\n",
        "        ContinualAnimation.__init__(self, self.arc, **kwargs)\n",
        "        \n",
        "    def update_mobject(self, dt):\n",
        "        arc = self.arc\n",
        "        total_distance = self.speed*self.internal_time\n",
        "        arc.set_points(self.start_points)\n",
        "        arc.shift(total_distance*self.direction)\n",
        "\n",
        "        if self.internal_time < self.fade_in_time:\n",
        "            alpha = np.clip(self.internal_time/self.fade_in_time, 0, 1)\n",
        "            arc.set_stroke(self.color, alpha*self.stroke_width)\n",
        "\n",
        "        if self.reflection_distance is None:\n",
        "            #Check if reflection is happening\n",
        "            arc_point = arc.get_edge_center(self.direction)\n",
        "            target_point = self.target.get_edge_center(-self.direction)\n",
        "            arc_distance = np.dot(arc_point, self.direction)\n",
        "            target_distance = np.dot(target_point, self.direction)\n",
        "            if arc_distance > target_distance:\n",
        "                self.reflection_distance = target_distance\n",
        "        #Don't use elif in case the above code creates reflection_distance\n",
        "        if self.reflection_distance is not None:\n",
        "            delta_distance = total_distance - self.reflection_distance\n",
        "            point_distances = np.dot(self.direction, arc.get_points().T)\n",
        "            diffs = point_distances - self.reflection_distance\n",
        "            shift_vals = np.outer(-2*np.maximum(diffs, 0), self.direction)\n",
        "            arc.set_points(arc.get_points() + shift_vals)\n",
        "\n",
        "            #Check if done\n",
        "            arc_point = arc.get_edge_center(-self.direction)\n",
        "            if np.dot(arc_point, self.direction) < np.dot(self.start_center, self.direction):\n",
        "                self.finished = True\n",
        "                self.arc.fade(1)\n",
        "\n",
        "    def is_finished(self):\n",
        "        return self.finished\n",
        "\n",
        "class RadarPulse(ContinualAnimation):\n",
        "    CONFIG = {\n",
        "        \"n_pulse_singletons\" : 8,\n",
        "        \"frequency\" : 0.05,\n",
        "        \"colors\" : [BLUE, YELLOW]\n",
        "    }\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        colors = color_gradient(self.colors, self.n_pulse_singletons)\n",
        "        self.pulse_singletons = [\n",
        "            RadarPulseSingleton(*args, color = color, **kwargs)\n",
        "            for color in colors\n",
        "        ]\n",
        "        pluse_mobjects = VGroup(*[ps.mobject for ps in self.pulse_singletons])\n",
        "        ContinualAnimation.__init__(self, pluse_mobjects, **kwargs)\n",
        "        \n",
        "    def update_mobject(self, dt):\n",
        "        for i, ps in enumerate(self.pulse_singletons):\n",
        "            ps.internal_time = self.internal_time - i*self.frequency\n",
        "            ps.update_mobject(dt)\n",
        "\n",
        "    def is_finished(self):\n",
        "        return all([ps.is_finished() for ps in self.pulse_singletons])\n",
        "\n",
        "class MultipleFlashes(Succession):\n",
        "    CONFIG = {\n",
        "        \"run_time_per_flash\" : 1.0,\n",
        "        \"num_flashes\" : 3,\n",
        "    }\n",
        "    def __init__(self, *args, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        kwargs[\"run_time\"] = self.run_time_per_flash\n",
        "        Succession.__init__(self, *[\n",
        "            Flash(*args, **kwargs)\n",
        "            for x in range(self.num_flashes)\n",
        "        ])\n",
        "\n",
        "class TrafficLight(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"traffic_light\",\n",
        "        \"height\" : 0.7,\n",
        "        \"post_height\" : 2,\n",
        "        \"post_width\" : 0.05,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        post = Rectangle(\n",
        "            height = self.post_height,\n",
        "            width = self.post_width,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        self.move_to(post.get_top(), DOWN)\n",
        "        self.add_to_back(post)\n",
        "\n",
        "###################\n",
        "\n",
        "class MentionUncertaintyPrinciple(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Heisenberg Uncertainty Principle\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        dot_cloud = ProbabalisticDotCloud()\n",
        "        vector_cloud = ProbabalisticVectorCloud(\n",
        "            gaussian_distribution_wrapper_config = {\"sigma_x\" : 0.2},\n",
        "            center_func = lambda : dot_cloud.gaussian_distribution_wrapper.get_parameters()[0],\n",
        "        )\n",
        "        for cloud in dot_cloud, vector_cloud:\n",
        "            cloud.gaussian_distribution_wrapper.next_to(\n",
        "                title, DOWN, 2*LARGE_BUFF\n",
        "            )\n",
        "        vector_cloud.gaussian_distribution_wrapper.shift(3*RIGHT)\n",
        "\n",
        "        def get_brace_text_group_update(gdw, vect, text, color):\n",
        "            brace = Brace(gdw, vect)\n",
        "            text = brace.get_tex(\"2\\\\sigma_{\\\\text{%s}}\"%text, buff = SMALL_BUFF)\n",
        "            group = VGroup(brace, text)\n",
        "            def update_group(group):\n",
        "                brace, text = group\n",
        "                brace.match_width(gdw, stretch = True)\n",
        "                brace.next_to(gdw, vect)\n",
        "                text.next_to(brace, vect, buff = SMALL_BUFF)\n",
        "            group.set_color(color)\n",
        "            return Mobject.add_updater(group, update_group)\n",
        "\n",
        "        dot_brace_anim = get_brace_text_group_update(\n",
        "            dot_cloud.gaussian_distribution_wrapper,\n",
        "            DOWN, \"position\", dot_cloud.color\n",
        "        )\n",
        "        vector_brace_anim = get_brace_text_group_update(\n",
        "            vector_cloud.gaussian_distribution_wrapper,\n",
        "            UP, \"momentum\", vector_cloud.color\n",
        "        )\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(dot_cloud)\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(dot_brace_anim.mobject, run_time = 1)\n",
        "        )\n",
        "        self.add(dot_brace_anim)\n",
        "        self.wait()\n",
        "        # self.wait(2)\n",
        "        self.play(\n",
        "            dot_cloud.gaussian_distribution_wrapper.change_parameters, \n",
        "            {\"sigma\" : 0.1*RIGHT},\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(vector_cloud)\n",
        "        self.play(\n",
        "            FadeIn(vector_brace_anim.mobject)\n",
        "        )\n",
        "        self.add(vector_brace_anim)\n",
        "        self.play(\n",
        "            vector_cloud.gaussian_distribution_wrapper.change_parameters,\n",
        "            {\"sigma\" : RIGHT},\n",
        "            self.change_students(*3*[\"confused\"]),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        #Back and forth\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                dot_cloud.gaussian_distribution_wrapper.change_parameters,\n",
        "                {\"sigma\" : 2*RIGHT},\n",
        "                vector_cloud.gaussian_distribution_wrapper.change_parameters,\n",
        "                {\"sigma\" : 0.1*RIGHT},\n",
        "                run_time = 3,\n",
        "            )\n",
        "            self.play_student_changes(\"thinking\", \"erm\", \"sassy\")\n",
        "            self.play(\n",
        "                dot_cloud.gaussian_distribution_wrapper.change_parameters,\n",
        "                {\"sigma\" : 0.1*RIGHT},\n",
        "                vector_cloud.gaussian_distribution_wrapper.change_parameters,\n",
        "                {\"sigma\" : 1*RIGHT},\n",
        "                run_time = 3,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class FourierTradeoff(Scene):\n",
        "    CONFIG = {\n",
        "        \"show_text\" : True,\n",
        "        \"complex_to_real_func\" : lambda z : z.real,\n",
        "        \"widths\" : [6, 0.02, 1],\n",
        "    }\n",
        "    def construct(self):\n",
        "        #Setup axes\n",
        "        time_mean = 4\n",
        "        time_axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 2*time_mean,\n",
        "            x_axis_config = {\"unit_size\" : 1.5},\n",
        "            y_min = -2, \n",
        "            y_max = 2,\n",
        "            y_axis_config = {\"unit_size\" : 0.5}\n",
        "        )\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.scale(1.5)\n",
        "        time_label.next_to(\n",
        "            time_axes.x_axis.get_right(), UP+LEFT,\n",
        "            buff = MED_SMALL_BUFF,\n",
        "        )\n",
        "        time_axes.add(time_label)\n",
        "        time_axes.center().to_edge(UP)\n",
        "        time_axes.x_axis.add_numbers(*list(range(1, 2*time_mean)))\n",
        "\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 8,\n",
        "            x_axis_config = {\"unit_size\" : 1.5},\n",
        "            y_min = -0.025,\n",
        "            y_max = 0.075,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 30,\n",
        "                \"tick_frequency\" : 0.025,\n",
        "            },\n",
        "            color = TEAL,\n",
        "        )\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.scale(1.5)\n",
        "        frequency_label.next_to(\n",
        "            frequency_axes.x_axis.get_right(), UP+LEFT,\n",
        "            buff = MED_SMALL_BUFF, \n",
        "        )\n",
        "        frequency_label.set_color(FREQUENCY_COLOR)\n",
        "        frequency_axes.add(frequency_label)\n",
        "        frequency_axes.move_to(time_axes, LEFT)\n",
        "        frequency_axes.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        frequency_axes.x_axis.add_numbers()\n",
        "\n",
        "        # Graph information\n",
        "\n",
        "        #x-coordinate of this point determines width of wave_packet graph\n",
        "        width_tracker = ExponentialValueTracker(0.5)\n",
        "        get_width = width_tracker.get_value\n",
        "\n",
        "        def get_wave_packet_function():\n",
        "            factor = 1./get_width()\n",
        "            return lambda t : (factor**0.25)*np.cos(4*TAU*t)*np.exp(-factor*(t-time_mean)**2)\n",
        "\n",
        "        def get_wave_packet():\n",
        "            graph = time_axes.get_graph(\n",
        "                get_wave_packet_function(),\n",
        "                num_graph_points = 200,\n",
        "            )\n",
        "            graph.set_color(YELLOW)\n",
        "            return graph\n",
        "\n",
        "        time_radius = 10\n",
        "        def get_wave_packet_fourier_transform():\n",
        "            return get_fourier_graph(\n",
        "                frequency_axes, \n",
        "                get_wave_packet_function(),\n",
        "                t_min = time_mean - time_radius,\n",
        "                t_max = time_mean + time_radius,\n",
        "                n_samples = 2*time_radius*17,\n",
        "                complex_to_real_func = self.complex_to_real_func,\n",
        "                color = FREQUENCY_COLOR,\n",
        "            )\n",
        "\n",
        "        wave_packet = get_wave_packet()\n",
        "        wave_packet_update = UpdateFromFunc(\n",
        "            wave_packet, \n",
        "            lambda g : Transform(g, get_wave_packet()).update(1)\n",
        "        )\n",
        "        fourier_graph = get_wave_packet_fourier_transform()\n",
        "        fourier_graph_update = UpdateFromFunc(\n",
        "            fourier_graph, \n",
        "            lambda g : Transform(g, get_wave_packet_fourier_transform()).update(1)\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(\n",
        "            wave_packet, frequency_axes.coords_to_point(\n",
        "                4, frequency_axes.y_max/2,\n",
        "            ),\n",
        "            color = FREQUENCY_COLOR,\n",
        "        )\n",
        "        fourier_words = OldTexText(\"Fourier Transform\")\n",
        "        fourier_words.next_to(arrow, LEFT, buff = MED_LARGE_BUFF)\n",
        "        sub_words = OldTexText(\"(To be explained shortly)\")\n",
        "        sub_words.set_color(BLUE)\n",
        "        sub_words.scale(0.75)\n",
        "        sub_words.next_to(fourier_words, DOWN)\n",
        "\n",
        "        #Draw items\n",
        "        self.add(time_axes, frequency_axes)\n",
        "        self.play(ShowCreation(wave_packet, rate_func = double_smooth))\n",
        "        anims = [ReplacementTransform(\n",
        "            wave_packet.copy(), fourier_graph\n",
        "        )]\n",
        "        if self.show_text:\n",
        "            anims += [\n",
        "                GrowArrow(arrow),\n",
        "                Write(fourier_words, run_time = 1)\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        # self.play(FadeOut(arrow))\n",
        "        self.wait()\n",
        "        for width in self.widths:\n",
        "            self.play(\n",
        "                width_tracker.set_value, width,\n",
        "                wave_packet_update,\n",
        "                fourier_graph_update,\n",
        "                run_time = 3\n",
        "            )\n",
        "            if sub_words not in self.mobjects and self.show_text:\n",
        "                self.play(FadeIn(sub_words))\n",
        "            else:\n",
        "                self.wait()\n",
        "        self.wait()\n",
        "\n",
        "class ShowPlan(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        words = self.get_words()\n",
        "        self.play_sound_anims(words[0])\n",
        "        self.play_doppler_anims(words[1])\n",
        "        self.play_quantum_anims(words[2])\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"The plan\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "\n",
        "    def get_words(self):\n",
        "        trips = [\n",
        "            (\"sound waves\", \"(time vs. frequency)\", YELLOW),\n",
        "            (\"Doppler radar\", \"(distance vs. velocity)\", GREEN),\n",
        "            (\"quantum particles\", \"(position vs. momentum)\", BLUE),\n",
        "        ]\n",
        "        words = VGroup()\n",
        "        for topic, tradeoff, color in trips:\n",
        "            word = OldTexText(\"Uncertainty for\", topic, tradeoff)\n",
        "            word[1:].set_color(color)\n",
        "            word[2].scale(0.75)\n",
        "            word[2].next_to(word[1], DOWN, buff = 1.5*SMALL_BUFF)\n",
        "            words.add(word)\n",
        "        words.arrange(DOWN, aligned_edge = LEFT, buff = MED_LARGE_BUFF)\n",
        "        words.to_edge(LEFT)\n",
        "\n",
        "        return words\n",
        "\n",
        "    def play_sound_anims(self, word):\n",
        "        morty = self.pi_creature\n",
        "        wave = FunctionGraph(\n",
        "            lambda x : 0.3*np.sin(15*x)*np.sin(0.5*x),\n",
        "            x_min = 0, x_max = 30,\n",
        "            step_size = 0.001,\n",
        "        )\n",
        "        wave.next_to(word, RIGHT)\n",
        "        rect = BackgroundRectangle(wave, fill_opacity = 1)\n",
        "        rect.stretch(2, 1)\n",
        "        rect.next_to(wave, LEFT, buff = 0)\n",
        "        always_shift(wave, direction=LEFT, rate=5)\n",
        "        wave_fader = UpdateFromAlphaFunc(\n",
        "            wave, \n",
        "            lambda w, a : w.set_stroke(width = 3*a)\n",
        "        )\n",
        "        checkmark = self.get_checkmark(word)\n",
        "\n",
        "        self.add(wave)\n",
        "        self.add_foreground_mobjects(rect, word)\n",
        "        self.play(\n",
        "            Animation(word),\n",
        "            wave_fader,\n",
        "            morty.change, \"raise_right_hand\", word\n",
        "        )\n",
        "        self.wait(2)\n",
        "        wave_fader.rate_func = lambda a : 1-smooth(a)\n",
        "        self.add_foreground_mobjects(checkmark)\n",
        "        self.play(\n",
        "            Write(checkmark),\n",
        "            morty.change, \"happy\",\n",
        "            wave_fader, \n",
        "        )\n",
        "        self.remove_foreground_mobjects(rect, word)\n",
        "        self.add(word)\n",
        "        self.wait()\n",
        "\n",
        "    def play_doppler_anims(self, word):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        radar_dish = RadarDish()\n",
        "        radar_dish.next_to(word, DOWN, aligned_edge = LEFT)\n",
        "        target = Plane()\n",
        "        # target.match_height(radar_dish)\n",
        "        target.next_to(radar_dish, RIGHT, buff = LARGE_BUFF)\n",
        "        always_shift(target, direction = RIGHT, rate = 1.25)\n",
        "\n",
        "        pulse = RadarPulse(radar_dish, target)\n",
        "\n",
        "        checkmark = self.get_checkmark(word)\n",
        "\n",
        "        self.add(target)\n",
        "        self.play(\n",
        "            Write(word),\n",
        "            DrawBorderThenFill(radar_dish),\n",
        "            UpdateFromAlphaFunc(\n",
        "                target, lambda m, a : m.set_fill(opacity = a)\n",
        "            ),\n",
        "            morty.change, \"pondering\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.add(pulse)\n",
        "        count = it.count() #TODO, this is not a great hack...\n",
        "        while not pulse.is_finished() and next(count) < 15:\n",
        "            self.play(\n",
        "                morty.look_at, pulse.mobject,\n",
        "                run_time = 0.5\n",
        "            )\n",
        "        self.play(\n",
        "            Write(checkmark),\n",
        "            UpdateFromAlphaFunc(\n",
        "                target, lambda m, a : m.set_fill(opacity = 1-a)\n",
        "            ),\n",
        "            FadeOut(radar_dish),\n",
        "            morty.change, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def play_quantum_anims(self, word):\n",
        "        morty = self.pi_creature\n",
        "        dot_cloud = ProbabalisticDotCloud()\n",
        "        gdw = dot_cloud.gaussian_distribution_wrapper\n",
        "        gdw.next_to(word, DOWN, MED_LARGE_BUFF)\n",
        "        gdw.rotate(5*DEGREES)\n",
        "        gdw.save_state()\n",
        "        gdw.scale(0)\n",
        "\n",
        "\n",
        "        checkmark = self.get_checkmark(word)\n",
        "        ish = OldTexText(\"$\\\\dots$ish\")\n",
        "        ish.next_to(checkmark, RIGHT, -SMALL_BUFF, DOWN)\n",
        "\n",
        "        self.add(dot_cloud)\n",
        "        self.play(\n",
        "            Write(word),\n",
        "            FadeIn(dot_cloud.mobject),\n",
        "            morty.change, \"confused\",\n",
        "        )\n",
        "        self.play(gdw.restore, run_time = 2)\n",
        "        self.play(Write(checkmark))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(ish), \n",
        "            morty.change, 'maybe'\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_checkmark(self, word):\n",
        "        checkmark = OldTex(\"\\\\checkmark\")\n",
        "        checkmark.set_color(GREEN)\n",
        "        checkmark.scale(1.25)\n",
        "        checkmark.next_to(word[1], UP+RIGHT, buff = 0)\n",
        "        return checkmark\n",
        "\n",
        "class StartWithIntuition(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"You already \\\\\\\\ have this \\\\\\\\ intuition\",\n",
        "            bubble_config = {\n",
        "                \"height\" : 3.5,\n",
        "                \"width\" : 3,\n",
        "            },\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"erm\", \"maybe\")\n",
        "        self.look_at(VectorizedPoint(4*LEFT + 2*UP))\n",
        "        self.wait(5)\n",
        "\n",
        "class TwoCarsAtRedLight(Scene):\n",
        "    CONFIG = {\n",
        "        \"text_scale_val\" : 0.75,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.pull_up_behind()\n",
        "        self.flash_in_sync_short_time()\n",
        "        self.show_low_confidence()\n",
        "        self.flash_in_sync_long_time()\n",
        "        self.show_high_confidence()\n",
        "\n",
        "    def pull_up_behind(self):\n",
        "        #Setup Traffic light\n",
        "        traffic_light = TrafficLight()\n",
        "        traffic_light.move_to(6*RIGHT + 2.5*DOWN, DOWN)\n",
        "        source_point = VectorizedPoint(\n",
        "            traffic_light[2].get_right()\n",
        "        )\n",
        "        screen = Line(ORIGIN, UP)\n",
        "        screen.next_to(source_point, RIGHT, LARGE_BUFF)\n",
        "        red_light = Spotlight(\n",
        "            color = RED,\n",
        "            source_point = source_point,\n",
        "            radius = 0.5,\n",
        "            screen = screen,\n",
        "            num_levels = 20,\n",
        "            opacity_function = lambda r : 1/(10*r**2+1)\n",
        "        )\n",
        "        red_light.fade(0.5)\n",
        "        red_light.rotate(TAU/2, about_edge = LEFT)\n",
        "        self.add(red_light, traffic_light)\n",
        "\n",
        "        #Setup cars\n",
        "        car1, car2 = cars = self.cars = VGroup(*[\n",
        "            Car() for x in range(2)\n",
        "        ])\n",
        "        cars.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        cars.next_to(\n",
        "            traffic_light, LEFT, \n",
        "            buff = LARGE_BUFF, aligned_edge = DOWN\n",
        "        )\n",
        "        car2.pi_creature.set_color(GREY_BROWN)\n",
        "        car1.start_point = car1.get_corner(DOWN+RIGHT)\n",
        "        car1.shift(FRAME_X_RADIUS*LEFT)\n",
        "\n",
        "        #Pull up car\n",
        "        self.add(cars)\n",
        "        self.play(\n",
        "            SwitchOn(\n",
        "                red_light, \n",
        "                rate_func = squish_rate_func(smooth, 0, 0.3),\n",
        "            ),\n",
        "            Animation(traffic_light),\n",
        "            self.get_flashes(car2, num_flashes = 3),\n",
        "            MoveCar(\n",
        "                car1, car1.start_point,\n",
        "                run_time = 3,\n",
        "                rate_func = rush_from,\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def flash_in_sync_short_time(self):\n",
        "        car1, car2 = cars = self.cars\n",
        "\n",
        "        #Setup axes\n",
        "        axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 5,\n",
        "            y_min = 0, \n",
        "            y_max = 2,\n",
        "            y_axis_config = {\n",
        "                \"tick_frequency\" : 0.5,\n",
        "            },\n",
        "        )\n",
        "        axes.x_axis.add_numbers(1, 2, 3)\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.scale(self.text_scale_val)\n",
        "        time_label.next_to(axes.x_axis.get_right(), DOWN)\n",
        "        y_title = OldTexText(\"Signal\")\n",
        "        y_title.scale(self.text_scale_val)\n",
        "        y_title.next_to(axes.y_axis, UP, SMALL_BUFF)\n",
        "        axes.add(time_label, y_title)\n",
        "        axes.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        graph = axes.get_graph(\n",
        "            self.get_multispike_function(list(range(1, 4))),\n",
        "            x_min = 0.8,\n",
        "            x_max = 3.8,\n",
        "        )\n",
        "        graph.set_color(YELLOW)\n",
        "\n",
        "        #Label short duration\n",
        "        brace = Brace(Line(\n",
        "            axes.input_to_graph_point(1, graph),\n",
        "            axes.input_to_graph_point(3, graph),\n",
        "        ), UP)\n",
        "        text = OldTexText(\"Short duration observation\")\n",
        "        text.scale(self.text_scale_val)\n",
        "        text.next_to(brace, UP, SMALL_BUFF)\n",
        "        text.align_to(\n",
        "            axes.coords_to_point(0.25, 0), LEFT\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            self.get_flashes(car1, num_flashes = 2),\n",
        "            self.get_flashes(car2, num_flashes = 2),\n",
        "            LaggedStartMap(FadeIn, VGroup(\n",
        "                axes, time_label, y_title,\n",
        "            ))\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_flashes(car1, num_flashes = 3),\n",
        "            self.get_flashes(car2, num_flashes = 3),\n",
        "            ShowCreation(graph, rate_func=linear, run_time = 3)\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_flashes(car1, num_flashes = 10),\n",
        "            self.get_flashes(car2, num_flashes = 10, run_time_per_flash = 0.98),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(text),\n",
        "        )\n",
        "\n",
        "        self.time_axes = axes\n",
        "        self.time_graph = graph\n",
        "        self.time_graph_label = VGroup(\n",
        "            brace, text\n",
        "        )\n",
        "\n",
        "    def show_low_confidence(self):\n",
        "        car1, car2 = cars = self.cars\n",
        "        time_axes = self.time_axes\n",
        "\n",
        "        #Setup axes\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 3,\n",
        "            y_min = 0,\n",
        "            y_max = 1.5,\n",
        "            y_axis_config = {\n",
        "                \"tick_frequency\" : 0.5,\n",
        "            }\n",
        "        )\n",
        "        frequency_axes.next_to(time_axes, DOWN, LARGE_BUFF)\n",
        "        frequency_axes.set_color(GREY_B)\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.scale(self.text_scale_val)\n",
        "        frequency_label.next_to(frequency_axes.x_axis.get_right(), DOWN)\n",
        "        frequency_axes.add(\n",
        "            frequency_label,\n",
        "            VectorizedPoint(frequency_axes.y_axis.get_top())\n",
        "        )\n",
        "        frequency_axes.x_axis.add_numbers(1, 2)\n",
        "        frequency_graph = frequency_axes.get_graph(\n",
        "            lambda x : np.exp(-4*(x-1)**2),\n",
        "            x_min = 0,\n",
        "            x_max = 2,\n",
        "        )\n",
        "        frequency_graph.set_color(RED)\n",
        "        peak_point = frequency_axes.input_to_graph_point(\n",
        "            1, frequency_graph\n",
        "        )\n",
        "\n",
        "        #Setup label\n",
        "        label = OldTexText(\"Low confidence\")\n",
        "        label.scale(self.text_scale_val)\n",
        "        label.move_to(peak_point + UP+RIGHT, DOWN)\n",
        "        label.match_color(frequency_graph)\n",
        "        arrow = Arrow(label.get_bottom(), peak_point, buff = 2*SMALL_BUFF)\n",
        "        arrow.match_color(frequency_graph)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.time_axes.copy(), frequency_axes\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                self.time_graph.copy(), frequency_graph\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(label), \n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.frequency_axes = frequency_axes\n",
        "        self.frequency_graph = frequency_graph\n",
        "        self.frequency_graph_label = VGroup(\n",
        "            label, arrow\n",
        "        )\n",
        "\n",
        "    def flash_in_sync_long_time(self):\n",
        "        time_graph = self.time_graph\n",
        "        time_axes = self.time_axes\n",
        "        frequency_graph = self.frequency_graph\n",
        "        frequency_axes = self.frequency_axes\n",
        "\n",
        "        n_spikes = 12\n",
        "        new_time_graph = time_axes.get_graph(\n",
        "            self.get_multispike_function(list(range(1, n_spikes+1))),\n",
        "            x_min = 0.8,\n",
        "            x_max = n_spikes + 0.8,\n",
        "        )\n",
        "        new_time_graph.match_color(time_graph)\n",
        "\n",
        "        new_frequency_graph = frequency_axes.get_graph(\n",
        "            lambda x : np.exp(-500*(x-1)**2),\n",
        "            x_min = 0,\n",
        "            x_max = 2,\n",
        "            num_anchors = 500,\n",
        "        )\n",
        "        new_frequency_graph.match_color(self.frequency_graph)\n",
        "\n",
        "        def pin_freq_graph_end_points(freq_graph):\n",
        "            freq_graph.get_points()[0] = frequency_axes.coords_to_point(0, 0)\n",
        "            freq_graph.get_points()[-1] = frequency_axes.coords_to_point(2, 0)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, VGroup(\n",
        "                self.time_graph_label,\n",
        "                self.frequency_graph_label,\n",
        "                self.time_graph,\n",
        "            )\n",
        "        ))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.time_axes.x_axis.stretch, 2.5, 0,\n",
        "                {\"about_edge\" : LEFT},\n",
        "                run_time = 4,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.6),\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                self.time_axes.x_axis.tip,\n",
        "                lambda m : m.move_to(\n",
        "                    self.time_axes.x_axis.get_right(), \n",
        "                    LEFT\n",
        "                )\n",
        "            ),\n",
        "            ShowCreation(\n",
        "                new_time_graph,\n",
        "                run_time = n_spikes,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                frequency_graph.stretch, 0.1, 0,\n",
        "                run_time = n_spikes,\n",
        "            ),\n",
        "            UpdateFromFunc(frequency_graph, pin_freq_graph_end_points),\n",
        "            *[\n",
        "                self.get_flashes(car, num_flashes = n_spikes)\n",
        "                for car in self.cars\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.new_time_graph = new_time_graph\n",
        "        self.new_frequency_graph = new_frequency_graph\n",
        "\n",
        "    def show_high_confidence(self):\n",
        "        #Frequency stuff\n",
        "        arrow = self.frequency_graph_label[1]\n",
        "        label = OldTexText(\"High confidence\")\n",
        "        label.scale(self.text_scale_val)\n",
        "        label.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "        label.match_color(arrow)\n",
        "\n",
        "        frequency_axes = self.frequency_axes\n",
        "\n",
        "        #Time stuff\n",
        "        new_time_graph = self.new_time_graph\n",
        "        brace = Brace(new_time_graph, UP, buff = SMALL_BUFF)\n",
        "        text = OldTexText(\"Long duration observation\")\n",
        "        text.scale(self.text_scale_val)\n",
        "        text.next_to(brace, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(label),\n",
        "            GrowArrow(arrow),\n",
        "            *list(map(self.get_flashes, self.cars))\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(text, run_time = 1),\n",
        "            *list(map(self.get_flashes, self.cars))\n",
        "        )\n",
        "        self.play(*[\n",
        "            self.get_flashes(car, num_flashes = 10)\n",
        "            for car in self.cars\n",
        "        ])\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_flashes(self, car, colors = [YELLOW, RED], num_flashes = 1, **kwargs):\n",
        "        return AnimationGroup(*[\n",
        "            MultipleFlashes(light, color, num_flashes = num_flashes, **kwargs)\n",
        "            for light, color in zip(car.get_lights(), colors)\n",
        "        ])\n",
        "\n",
        "    def get_multispike_function(self, spike_times):\n",
        "        return lambda x : sum([\n",
        "            1.25*np.exp(-100*(x-m)**2)\n",
        "            for m in spike_times\n",
        "        ])\n",
        "\n",
        "class VariousMusicalNotes(Scene):\n",
        "    def construct(self):\n",
        "        freq = 20\n",
        "        # x-coordinate of this point represents log(a)\n",
        "        # where the bell curve component of the signal\n",
        "        # is exp(-a*(x**2))\n",
        "        graph_width_tracker = ExponentialValueTracker(1)\n",
        "        def get_graph():\n",
        "            a = graph_width_tracker.get_value()\n",
        "            return FunctionGraph(\n",
        "                lambda x : np.exp(-a*x**2)*np.sin(freq*x)-0.5,\n",
        "                step_size = 0.001,\n",
        "            )\n",
        "        graph = get_graph()\n",
        "        def graph_update(graph):\n",
        "            graph.set_points(get_graph().get_points())\n",
        "        graph_update_anim = UpdateFromFunc(graph, graph_update)\n",
        "        def change_width_anim(width, **kwargs):\n",
        "            a = 2.0/(width**2)\n",
        "            return AnimationGroup(\n",
        "                ApplyMethod(graph_width_tracker.set_value, a),\n",
        "                graph_update_anim,\n",
        "                **kwargs\n",
        "            )\n",
        "        change_width_anim(FRAME_X_RADIUS).update(1)\n",
        "        graph_update_anim.update(0)\n",
        "\n",
        "        phrases = [\n",
        "            OldTexText(*words.split(\" \"))\n",
        "            for words in [\n",
        "                \"Very clear frequency\",\n",
        "                \"Less clear frequency\",\n",
        "                \"Extremely unclear frequency\",\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "\n",
        "        #Show graphs and phrases\n",
        "        widths = [FRAME_X_RADIUS, 1, 0.2]\n",
        "        for width, phrase in zip(widths, phrases):\n",
        "            brace = Brace(Line(LEFT, RIGHT), UP)\n",
        "            brace.stretch(width, 0)\n",
        "            brace.next_to(graph.get_center(), UP, buff = 1.2)\n",
        "            phrase.next_to(brace, UP)\n",
        "\n",
        "            if width is widths[0]:\n",
        "                self.play(ShowCreation(graph, rate_func=linear)),\n",
        "                self.play(\n",
        "                    GrowFromCenter(brace),\n",
        "                    Write(phrase, run_time = 1)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    change_width_anim(width),\n",
        "                    ReplacementTransform(\n",
        "                        VGroup(last_phrase, last_brace),\n",
        "                        VGroup(phrase, brace),\n",
        "                        rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "                    ),\n",
        "                    run_time = 2\n",
        "                )\n",
        "            self.wait()\n",
        "            # self.play(*map(FadeOut, [graph, brace, phrase]))\n",
        "            last_phrase = phrase\n",
        "            last_brace = brace\n",
        "\n",
        "        #Talk about correlations\n",
        "        short_signal_words = OldTexText(\n",
        "            \"Short\", \"signal\", \"correlates\",\n",
        "            \"with\", \"wide range\", \"of frequencies\"\n",
        "        )\n",
        "        long_signal_words = OldTexText(\n",
        "            \"Only\", \"wide\", \"signals\", \"correlate\",\n",
        "            \"with a\", \"short range\", \"of frequencies\"\n",
        "        )\n",
        "        phrases = VGroup(short_signal_words, long_signal_words)\n",
        "        for phrase in phrases:\n",
        "            phrase.scale(0.8)\n",
        "            phrase.set_color_by_tex_to_color_map({\n",
        "                \"short\" : RED,\n",
        "                \"long\" : GREEN,\n",
        "                \"wide\" : GREEN,\n",
        "            }, case_sensitive = False)\n",
        "        phrases.arrange(DOWN)\n",
        "        phrases.to_edge(UP)\n",
        "\n",
        "        long_graph = FunctionGraph(\n",
        "            lambda x : 0.5*np.sin(freq*x),\n",
        "            x_min = -FRAME_WIDTH,\n",
        "            x_max = FRAME_WIDTH,\n",
        "            n_components = 0.001\n",
        "        )\n",
        "        long_graph.set_color(BLUE)\n",
        "        long_graph.next_to(graph, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(long_graph),\n",
        "            *list(map(FadeOut, [last_brace, last_phrase]))\n",
        "        )\n",
        "        self.play(\n",
        "            Write(short_signal_words),\n",
        "            change_width_anim(widths[2])\n",
        "        )\n",
        "        self.play(\n",
        "            long_graph.stretch, 0.35, 0,\n",
        "            long_graph.set_color, GREEN,\n",
        "            run_time = 5,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(long_signal_words),\n",
        "            change_width_anim(widths[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            long_graph.stretch, 0.95, 0,\n",
        "            long_graph.set_color, average_color(GREEN, BLUE),\n",
        "            run_time = 4,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class CrossOutDefinitenessAndCertainty(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Definiteness\"),\n",
        "            OldTexText(\"Certainty\"),\n",
        "        )\n",
        "        words.arrange(DOWN)\n",
        "        words.next_to(self.teacher, UP+LEFT)\n",
        "        crosses = VGroup(*list(map(Cross, words)))\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            self.teacher.change, \"sassy\",\n",
        "            ShowCreation(crosses[0])\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(*3*[\"erm\"]),\n",
        "            ShowCreation(crosses[1])\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class BringInFourierTranform(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        fourier = OldTexText(\"Fourier\")\n",
        "        fourier.scale(1.5)\n",
        "        fourier.next_to(self.teacher.get_corner(UP+LEFT), UP, LARGE_BUFF)\n",
        "        fourier.save_state()\n",
        "        fourier.shift(DOWN)\n",
        "        fourier.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            fourier.restore\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"erm\", \"confused\")\n",
        "        self.look_at(3*LEFT + 2*UP)\n",
        "        self.wait(3)\n",
        "\n",
        "class LastVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Visualizing the Fourier Transform\")\n",
        "        title.to_edge(UP)\n",
        "        screen_rect = ScreenRectangle(height = 6)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait()\n",
        "\n",
        "class FourierRecapScene(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"frequency_axes_config\" : {\n",
        "            \"x_max\" : 10.0,\n",
        "            \"x_axis_config\" : {\n",
        "                \"unit_size\" : 0.7,\n",
        "                \"numbers_to_show\" : list(range(1, 10, 1)),\n",
        "            }\n",
        "        },\n",
        "        \"initial_winding_frequency\" : 0.1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.preview_fourier_plot()\n",
        "        self.wrap_signal_around_circle()\n",
        "        self.match_winding_to_beat_frequency()\n",
        "        self.follow_center_of_mass()\n",
        "        self.draw_fourier_plot()\n",
        "        self.set_color_spike()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        time_axes = self.get_time_axes()\n",
        "        time_axes.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        time_axes.scale(0.9, about_edge = UP)\n",
        "        frequency_axes = self.get_frequency_axes()\n",
        "        circle_plane = self.get_circle_plane()\n",
        "\n",
        "        self.add(time_axes)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            time_axes, frequency_axes,\n",
        "            circle_plane\n",
        "        )\n",
        "\n",
        "    def preview_fourier_plot(self):\n",
        "        time_graph = self.graph = self.get_time_graph(\n",
        "            width = 2,\n",
        "            num_graph_points = 200,\n",
        "        )\n",
        "        fourier_graph = self.get_fourier_transform_graph(\n",
        "            time_graph\n",
        "        )\n",
        "        fourier_graph.pointwise_become_partial(fourier_graph, 0.1, 1)\n",
        "\n",
        "        #labels\n",
        "        signal_label = OldTexText(\"Signal\")\n",
        "        fourier_label = OldTexText(\"Fourier transform\")\n",
        "        signal_label.next_to(time_graph, UP, buff = SMALL_BUFF)\n",
        "        fourier_label.next_to(fourier_graph, UP)\n",
        "        fourier_label.match_color(fourier_graph)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(time_graph, run_time = 2),\n",
        "            Write(signal_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, self.frequency_axes),\n",
        "            ReplacementTransform(\n",
        "                time_graph.copy(),\n",
        "                fourier_graph,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                signal_label.copy(),\n",
        "                fourier_label,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, self.frequency_axes.x_axis.numbers,\n",
        "            run_time = 4,\n",
        "            rate_func = wiggle,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.frequency_axes, fourier_graph,\n",
        "            signal_label,  fourier_label,\n",
        "        ])))\n",
        "\n",
        "        self.time_graph = time_graph\n",
        "        self.set_variables_as_attrs(time_graph, fourier_label)\n",
        "\n",
        "    def wrap_signal_around_circle(self):\n",
        "        time_graph = self.time_graph\n",
        "        circle_plane = self.circle_plane\n",
        "        freq = self.initial_winding_frequency\n",
        "        pol_graph = self.get_polarized_mobject(time_graph, freq)\n",
        "        winding_freq_label = self.get_winding_frequency_label()\n",
        "        winding_freq_label.add_to_back(BackgroundRectangle(winding_freq_label))\n",
        "        winding_freq_label.move_to(circle_plane.get_top(), DOWN)\n",
        "\n",
        "        self.add_foreground_mobjects(winding_freq_label)\n",
        "        self.play(\n",
        "            Write(circle_plane, run_time = 1),\n",
        "            ReplacementTransform(\n",
        "                time_graph.copy(), pol_graph,\n",
        "                path_arc = -TAU/4,\n",
        "                run_time_per_flash = 2,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            FadeIn(winding_freq_label),\n",
        "        )\n",
        "        freq = 0.3\n",
        "        self.change_frequency(freq, run_time = 2)\n",
        "        ghost_pol_graph = pol_graph.copy()\n",
        "        self.remove(pol_graph)\n",
        "        self.play(ghost_pol_graph.set_stroke, {\"width\" : 0.5})\n",
        "        self.play(\n",
        "            *self.get_vector_animations(time_graph),\n",
        "            run_time = 15\n",
        "        )\n",
        "        self.remove(ghost_pol_graph)\n",
        "        self.wait()\n",
        "\n",
        "    def match_winding_to_beat_frequency(self):\n",
        "        self.v_lines_indicating_periods = self.get_v_lines_indicating_periods(0.3)\n",
        "        self.add(self.v_lines_indicating_periods)\n",
        "        for freq in range(1, 6):\n",
        "            self.change_frequency(freq, run_time = 5)\n",
        "        self.play(\n",
        "            *self.get_vector_animations(\n",
        "                self.time_graph,\n",
        "                draw_polarized_graph = False\n",
        "            ),\n",
        "            run_time = 10\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def follow_center_of_mass(self):\n",
        "        com_dot = self.get_center_of_mass_dot()\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "        com_arrow = Arrow(UP+3*RIGHT, ORIGIN)\n",
        "        com_arrow.shift(com_dot.get_center())\n",
        "        com_arrow.match_color(com_dot)\n",
        "        com_words = OldTexText(\"Center of mass\")\n",
        "        com_words.next_to(com_arrow.get_start(), UP)\n",
        "        com_words.match_color(com_arrow)\n",
        "        com_words.add_background_rectangle()\n",
        "\n",
        "        com_dot.save_state()\n",
        "        com_dot.move_to(com_arrow.get_start())\n",
        "        com_dot.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            com_dot.restore,\n",
        "            GrowArrow(com_arrow, rate_func = squish_rate_func(smooth, 0.2, 1)),\n",
        "            Write(com_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        squished_func = squish_rate_func(smooth, 0, 0.2)\n",
        "        self.change_frequency(\n",
        "            4,\n",
        "            added_anims = [\n",
        "                FadeOut(com_arrow, rate_func = squished_func),\n",
        "                FadeOut(com_words, rate_func = squished_func),\n",
        "            ],\n",
        "            run_time = 5\n",
        "        )\n",
        "\n",
        "    def draw_fourier_plot(self):\n",
        "        frequency_axes = self.frequency_axes\n",
        "        fourier_label = self.fourier_label\n",
        "\n",
        "        self.change_frequency(0, run_time = 2)\n",
        "        self.play(\n",
        "            FadeIn(frequency_axes),\n",
        "            FadeIn(fourier_label),\n",
        "        )\n",
        "\n",
        "        fourier_graph = self.get_fourier_transform_graph(self.time_graph)\n",
        "        self.get_fourier_graph_drawing_update_anim(fourier_graph)\n",
        "        self.generate_fourier_dot_transform(fourier_graph)\n",
        "\n",
        "        self.change_frequency(5, run_time = 20)\n",
        "        self.wait()\n",
        "        self.change_frequency(7.5, run_time = 10)\n",
        "        self.fourier_graph_drawing_update_anim = Animation(Mobject())\n",
        "        self.fourier_graph = fourier_graph\n",
        "\n",
        "    def set_color_spike(self):\n",
        "        spike_point = self.frequency_axes.input_to_graph_point(\n",
        "            5, self.fourier_graph\n",
        "        )\n",
        "        circle = Circle(color = YELLOW, radius = 0.25)\n",
        "        circle.move_to(spike_point)\n",
        "        circle.save_state()\n",
        "        circle.scale(5)\n",
        "        circle.fade(1)\n",
        "\n",
        "        self.change_frequency(5)\n",
        "        self.play(circle.restore)\n",
        "        self.play(FadeOut(circle))\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.change_frequency(5.2, run_time = 3)\n",
        "            self.change_frequency(4.8, run_time = 3)\n",
        "        self.change_frequency(5, run_time = 1.5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_time_graph(self, frequency = 5, width = 2, **kwargs):\n",
        "        # low_x = center-width/2\n",
        "        # high_x = center+width/2\n",
        "        # new_smooth = lambda x : np.clip(smooth((x+0.5)), 0, 1)\n",
        "        # def func(x):\n",
        "        #     pure_signal = 0.9*np.cos(TAU*frequency*x)\n",
        "        #     factor = new_smooth(x - low_x) - new_smooth(x-high_x)\n",
        "        #     return 1 + factor*pure_signal\n",
        "        graph = self.time_axes.get_graph(\n",
        "            lambda x : 1+0.9*np.cos(TAU*frequency*x),\n",
        "            x_min = 0, x_max = width,\n",
        "            **kwargs\n",
        "        )\n",
        "        graph.set_color(YELLOW)\n",
        "        return graph\n",
        "\n",
        "class RealPartOfInsert(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"(Real part of the)\")\n",
        "        words.set_color(RED)\n",
        "        self.add(words)\n",
        "        self.play(Write(words))\n",
        "        self.wait(5)\n",
        "\n",
        "class CenterOfMassDescription(FourierRecapScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        circle_plane = self.get_circle_plane()\n",
        "        circle_plane.save_state()\n",
        "        circle_plane.generate_target()\n",
        "        circle_plane.target.set_height(FRAME_HEIGHT)\n",
        "        circle_plane.target.center()\n",
        "        circle_plane.target.axes.set_stroke(width = 2)\n",
        "        circle_plane.targets.set_stroke(width = 2)\n",
        "        circle_plane.target.secondary_lines.set_stroke(width = 1)\n",
        "\n",
        "        start_coords = (0.5, 0.5)\n",
        "        alt_coords = (0.8, 0.8)\n",
        "\n",
        "        com_dot = Dot(color = self.center_of_mass_color)\n",
        "        com_dot.move_to(circle_plane.coords_to_point(*start_coords))\n",
        "\n",
        "        self.add(circle_plane, com_dot)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(circle_plane),\n",
        "            com_dot.move_to, \n",
        "            circle_plane.target.coords_to_point(*start_coords)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        alt_com_dot = com_dot.copy().move_to(\n",
        "            circle_plane.coords_to_point(*alt_coords)\n",
        "        )\n",
        "\n",
        "        for dot in com_dot, alt_com_dot:\n",
        "            line = Line(ORIGIN, dot.get_center())\n",
        "            line.match_color(com_dot)\n",
        "            angle = line.get_angle()\n",
        "            line.rotate(-angle, about_point = ORIGIN)\n",
        "            brace = Brace(line, UP)\n",
        "            words = brace.get_text(\"Strength of frequency\")\n",
        "            words.add_background_rectangle()\n",
        "            dot.length_label_group = VGroup(line, brace, words)\n",
        "            dot.length_label_group.rotate(angle, about_point = ORIGIN)\n",
        "\n",
        "        line, brace, words = com_dot.length_label_group\n",
        "        self.play(\n",
        "            GrowFromCenter(line),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                com_dot.length_label_group,\n",
        "                alt_com_dot.length_label_group,\n",
        "            ),\n",
        "            Transform(com_dot, alt_com_dot),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 4,\n",
        "        )\n",
        "\n",
        "        #Do rotation\n",
        "        line = com_dot.length_label_group[0]\n",
        "        com_dot.length_label_group.remove(line)\n",
        "        angle = line.get_angle()\n",
        "        arc, alt_arc = [\n",
        "            Arc(\n",
        "                start_angle = 0, \n",
        "                angle = factor*angle,\n",
        "                radius = 0.5,\n",
        "            )\n",
        "            for factor in (1, 2)\n",
        "        ]\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.shift(1.5*arc.point_from_proportion(0.5))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(com_dot.length_label_group),\n",
        "            Animation(line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                VGroup(line, com_dot),\n",
        "                angle, about_point = ORIGIN\n",
        "            ),\n",
        "            Transform(arc, alt_arc),\n",
        "            theta.move_to, 1.5*alt_arc.point_from_proportion(0.5),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutLongVsShort(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What happens if we \\\\\\\\ change the length of \\\\\\\\ the signal?\",\n",
        "            index = 2,\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"happy\",\n",
        "            self.change_students(\"pondering\", \"confused\", \"raise_right_hand\")\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "class LongAndShortSignalsInWindingMachine(FourierRecapScene):\n",
        "    CONFIG = {\n",
        "        \"num_fourier_graph_points\" : 1000,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.extend_for_long_time()\n",
        "        self.note_sharp_fourier_peak()\n",
        "        self.very_short_signal()\n",
        "        self.note_wide_fourier_peak()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        FourierRecapScene.setup_axes(self)\n",
        "        self.add(self.circle_plane)\n",
        "        self.add(self.frequency_axes)\n",
        "        self.time_graph = self.graph = self.get_time_graph(width = 2)\n",
        "        self.add(self.time_graph)\n",
        "\n",
        "        self.force_skipping()\n",
        "        self.wrap_signal_around_circle()\n",
        "\n",
        "        fourier_graph = self.get_fourier_transform_graph(self.time_graph)\n",
        "        self.fourier_graph = fourier_graph\n",
        "        self.add(fourier_graph)\n",
        "        self.change_frequency(5)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def extend_for_long_time(self):\n",
        "        short_time_graph = self.time_graph\n",
        "        long_time_graph = self.get_time_graph(\n",
        "            width = 10,\n",
        "            num_graph_points = 500,\n",
        "        )\n",
        "        long_time_graph.set_stroke(width = 2)\n",
        "        new_freq = 5.1\n",
        "        long_pol_graph = self.get_polarized_mobject(\n",
        "            long_time_graph,\n",
        "            freq = new_freq\n",
        "        )\n",
        "        fourier_graph = self.fourier_graph\n",
        "\n",
        "        self.change_frequency(new_freq)\n",
        "        self.play(\n",
        "            FadeOut(self.graph),\n",
        "            FadeOut(self.graph.polarized_mobject),\n",
        "            FadeOut(fourier_graph)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(long_time_graph, rate_func=linear),\n",
        "            ShowCreation(long_pol_graph, rate_func=linear),\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.time_graph = self.graph = long_time_graph\n",
        "\n",
        "    def note_sharp_fourier_peak(self):\n",
        "        fourier_graph = self.get_fourier_transform_graph(\n",
        "            self.time_graph, \n",
        "            num_graph_points = self.num_fourier_graph_points\n",
        "        )\n",
        "        self.fourier_graph = fourier_graph\n",
        "        self.note_fourier_peak(fourier_graph, 5, 5.1)\n",
        "\n",
        "    def very_short_signal(self):\n",
        "        time_graph = self.time_graph\n",
        "        fourier_graph = self.fourier_graph\n",
        "        short_time_graph = self.get_time_graph(width = 0.6)\n",
        "        new_freq = 5.1\n",
        "        short_pol_graph = self.get_polarized_mobject(\n",
        "            short_time_graph,\n",
        "            freq = new_freq\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(fourier_graph),\n",
        "            FadeOut(time_graph),\n",
        "            FadeOut(time_graph.polarized_mobject),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(short_time_graph),\n",
        "            ShowCreation(short_time_graph.polarized_mobject),\n",
        "        )\n",
        "        self.graph = self.time_graph = short_time_graph\n",
        "        self.change_frequency(6.66, run_time = 5)\n",
        "\n",
        "    def note_wide_fourier_peak(self):\n",
        "        fourier_graph = self.get_fourier_transform_graph(\n",
        "            self.graph, \n",
        "            num_graph_points = self.num_fourier_graph_points\n",
        "        )\n",
        "        self.fourier_graph = fourier_graph\n",
        "        self.note_fourier_peak(fourier_graph, 5, 6.66)\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def note_fourier_peak(self, fourier_graph, freq1, freq2):\n",
        "        fourier_graph = self.fourier_graph\n",
        "        dots = self.get_fourier_graph_dots(fourier_graph, freq1, freq2)\n",
        "        self.get_center_of_mass_dot()\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "        self.generate_fourier_dot_transform(fourier_graph)\n",
        "        dot = self.fourier_graph_dot\n",
        "        arrow = Arrow(UP, ORIGIN, buff = SMALL_BUFF)\n",
        "        arrow.next_to(dot, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(fourier_graph))\n",
        "        self.change_frequency(freq1,\n",
        "            added_anims = [\n",
        "                MaintainPositionRelativeTo(arrow, dot),\n",
        "                UpdateFromAlphaFunc(\n",
        "                    arrow,\n",
        "                    lambda m, a : m.set_fill(opacity = a)\n",
        "                ),\n",
        "            ],\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_frequency(freq2,\n",
        "            added_anims = [\n",
        "                MaintainPositionRelativeTo(arrow, dot)\n",
        "            ],\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            dot, arrow, self.center_of_mass_dot\n",
        "        ])))\n",
        "        #This is not great...\n",
        "        for attr in \"center_of_mass_dot\", \"fourier_graph_dot\":\n",
        "            self.__dict__.pop(attr)\n",
        "\n",
        "\n",
        "    def get_fourier_graph_dots(self, fourier_graph, *freqs):\n",
        "        axis_point = self.frequency_axes.coords_to_point(4.5, -0.25)\n",
        "        dots = VGroup()\n",
        "        for freq in freqs:\n",
        "            point = self.frequency_axes.input_to_graph_point(freq, fourier_graph)\n",
        "            dot = Dot(point)\n",
        "            dot.scale(0.5)\n",
        "            dots.add(dot)\n",
        "            vect = point - axis_point\n",
        "            vect *= 1.3/get_norm(vect)\n",
        "            arrow = Arrow(vect, ORIGIN, buff = SMALL_BUFF)\n",
        "            arrow.set_color(YELLOW)\n",
        "            arrow.shift(point)\n",
        "            dot.arrow = arrow\n",
        "        return dots\n",
        "\n",
        "class FocusRectangleInsert(FourierRecapScene):\n",
        "    CONFIG = {\n",
        "        \"target_width\" : 0.5\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.clear()\n",
        "        point = self.frequency_axes.coords_to_point(5, 0.25)\n",
        "        rect = ScreenRectangle(height = 2.1*FRAME_Y_RADIUS)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        self.add(rect)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.stretch_to_fit_width, self.target_width,\n",
        "            rect.stretch_to_fit_height, 1.5,\n",
        "            rect.move_to, point,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class BroadPeakFocusRectangleInsert(FocusRectangleInsert):\n",
        "    CONFIG = {\n",
        "        \"target_width\" : 1.5,\n",
        "    }\n",
        "\n",
        "class CleanerFourierTradeoff(FourierTradeoff):\n",
        "    CONFIG = {\n",
        "        \"show_text\" : False,\n",
        "        \"complex_to_real_func\" : lambda z : z.real,\n",
        "        \"widths\" : [0.02, 6, 1],\n",
        "    }\n",
        "\n",
        "class MentionDopplerRadar(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Doppler Radar\")\n",
        "        words.next_to(self.teacher, UP)\n",
        "        words.save_state()\n",
        "        words.shift(DOWN).fade(1)\n",
        "        dish = RadarDish()\n",
        "        dish.next_to(self.students, UP, buff = 2, aligned_edge = LEFT)\n",
        "        plane = Plane()\n",
        "        plane.to_edge(RIGHT)\n",
        "        plane.align_to(dish)\n",
        "        always_shift(plane, LEFT, 1)\n",
        "        plane.flip()\n",
        "        pulse = RadarPulse(dish, plane)\n",
        "        look_at_anims = [\n",
        "            Mobject.add_updater(\n",
        "                pi, lambda pi : pi.look_at(pulse.mobject)\n",
        "            )\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ]\n",
        "\n",
        "        self.add(dish, plane, pulse, *look_at_anims)\n",
        "        self.play(\n",
        "            self.teacher.change, \"hooray\",\n",
        "            words.restore\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"erm\", \"sassy\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.teacher.change, \"happy\",\n",
        "            self.change_students(*[\"thinking\"]*3)\n",
        "        )\n",
        "        self.wait()\n",
        "        dish.set_stroke(width = 0)\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            VGroup(plane, dish),\n",
        "            lambda m, a : m.set_fill(opacity = 1 - a)\n",
        "        ))\n",
        "\n",
        "class IntroduceDopplerRadar(Scene):\n",
        "    CONFIG = {\n",
        "        \"frequency_spread_factor\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.measure_distance_with_time()\n",
        "        self.show_frequency_shift()\n",
        "        self.show_frequency_shift_in_fourier()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        self.dish = RadarDish()\n",
        "        self.dish.to_corner(UP+LEFT)\n",
        "        axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 10,\n",
        "            y_min = -1.5,\n",
        "            y_max = 1.5\n",
        "        )\n",
        "        axes.move_to(DOWN)\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        axes.time_label = time_label\n",
        "        axes.add(time_label)\n",
        "        self.axes = axes\n",
        "\n",
        "        self.add(self.dish)\n",
        "        self.add(axes)\n",
        "\n",
        "    def measure_distance_with_time(self):\n",
        "        dish = self.dish\n",
        "        axes = self.axes\n",
        "        distance = 5\n",
        "        time_diff = 5\n",
        "        speed = (2*distance)/time_diff\n",
        "        randy = Randolph().flip()\n",
        "        randy.match_height(dish)\n",
        "        randy.move_to(dish.get_right(), LEFT)\n",
        "        randy.shift(distance*RIGHT)\n",
        "\n",
        "        pulse_graph, echo_graph, sum_graph = \\\n",
        "            self.get_pulse_and_echo_graphs(\n",
        "                self.get_single_pulse_graph,\n",
        "                (1,), (1+time_diff,)\n",
        "            )\n",
        "        words = [\"Original signal\", \"Echo\"]\n",
        "        for graph, word in zip([pulse_graph, echo_graph], words):\n",
        "            arrow = Vector(DOWN)\n",
        "            arrow.next_to(graph.peak_point, UP, SMALL_BUFF)\n",
        "            arrow.match_color(graph)\n",
        "            graph.arrow = arrow\n",
        "            label = OldTexText(word)\n",
        "            label.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "            label.match_color(graph)\n",
        "            graph.label = label\n",
        "\n",
        "        double_arrow = DoubleArrow(\n",
        "            pulse_graph.peak_point,\n",
        "            echo_graph.peak_point,\n",
        "            color = WHITE\n",
        "        )\n",
        "        distance_text = OldTexText(\"$2 \\\\times$ distance/(signal speed)\")\n",
        "        distance_text.set_width(0.9*double_arrow.get_width())\n",
        "        distance_text.next_to(double_arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        #v_line anim?\n",
        "\n",
        "        pulse = RadarPulseSingleton(\n",
        "            dish, randy, \n",
        "            speed = 0.97*speed, #Just needs slightly better alignment\n",
        "        )\n",
        "        graph_draw = turn_animation_into_updater(\n",
        "            ShowCreation(\n",
        "                sum_graph, \n",
        "                rate_func=linear, \n",
        "                run_time = 0.97*axes.x_max\n",
        "            )\n",
        "        )\n",
        "        randy_look_at = Mobject.add_updater(\n",
        "            randy, lambda pi : pi.look_at(pulse.mobject)\n",
        "        )\n",
        "        axes_anim = ContinualAnimation(axes)\n",
        "\n",
        "        self.add(randy_look_at, axes_anim, graph_draw)\n",
        "        self.wait(0.5)\n",
        "        self.add(pulse)\n",
        "        self.play(\n",
        "            Write(pulse_graph.label),\n",
        "            GrowArrow(pulse_graph.arrow),\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.wait(time_diff - 2)\n",
        "        self.play(\n",
        "            Write(echo_graph.label),\n",
        "            GrowArrow(echo_graph.arrow),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(double_arrow),\n",
        "            FadeIn(distance_text)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(graph_draw, pulse, randy_look_at, axes_anim)\n",
        "        self.add(axes)\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            sum_graph, randy,\n",
        "            pulse_graph.arrow, pulse_graph.label,\n",
        "            echo_graph.arrow, echo_graph.label,\n",
        "            double_arrow, distance_text\n",
        "        )))\n",
        "\n",
        "    def show_frequency_shift(self):\n",
        "        axes = self.axes\n",
        "        dish = self.dish\n",
        "        plane = Plane()\n",
        "        plane.flip()\n",
        "        plane.move_to(dish)\n",
        "        plane.to_edge(RIGHT)\n",
        "\n",
        "        time_diff = 6\n",
        "\n",
        "        pulse_graph, echo_graph, sum_graph = graphs = \\\n",
        "            self.get_pulse_and_echo_graphs(\n",
        "                self.get_frequency_pulse_graph,\n",
        "                (1,25), (1+time_diff,50)\n",
        "            )\n",
        "        for graph in graphs:\n",
        "            graph.set_stroke(width = 3)\n",
        "        signal_graph = self.get_frequency_pulse_graph(1)\n",
        "\n",
        "        pulse_brace = Brace(Line(ORIGIN, RIGHT), UP)\n",
        "        pulse_brace.move_to(axes.coords_to_point(1, 1.2))\n",
        "        echo_brace = pulse_brace.copy()\n",
        "        echo_brace.stretch(0.6, 0)\n",
        "        echo_brace.move_to(axes.coords_to_point(7, 1.2))\n",
        "        pulse_text = pulse_brace.get_text(\"Original signal\")\n",
        "        pulse_text.add_background_rectangle()\n",
        "        echo_text = echo_brace.get_text(\"Echo\")\n",
        "        echo_subtext = OldTexText(\"(Higher frequency)\")\n",
        "        echo_subtext.next_to(echo_text, RIGHT)\n",
        "        echo_subtext.match_color(echo_graph)\n",
        "\n",
        "        graph_draw = turn_animation_into_updater(\n",
        "            ShowCreation(sum_graph, run_time = 8, rate_func=linear)\n",
        "        )\n",
        "        pulse = RadarPulse(dish, plane, n_pulse_singletons = 12)\n",
        "        always_shift(plane, LEFT, 1.5)\n",
        "\n",
        "        self.add(graph_draw, pulse, plane)\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            plane, lambda m, a : m.set_fill(opacity = a)\n",
        "        ))\n",
        "        self.play(\n",
        "            GrowFromCenter(pulse_brace),\n",
        "            FadeIn(pulse_text),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            GrowFromCenter(echo_brace),\n",
        "            GrowFromCenter(echo_text),\n",
        "        )\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            plane, lambda m, a : m.set_fill(opacity = 1-a)\n",
        "        ))\n",
        "        #Only for when -s is run\n",
        "        graph_draw.update(10) \n",
        "        self.wait(0.1)\n",
        "        self.play(Write(echo_subtext, run_time = 1))\n",
        "        self.wait()\n",
        "        self.remove(graph_draw, pulse, plane)\n",
        "\n",
        "        pulse_graph.set_stroke(width = 0)\n",
        "        echo_graph.set_stroke(width = 0)\n",
        "        self.time_graph_group = VGroup(\n",
        "            axes, pulse_brace, pulse_text,\n",
        "            echo_brace, echo_text, echo_subtext,\n",
        "            pulse_graph, echo_graph, sum_graph,\n",
        "        )\n",
        "        self.set_variables_as_attrs(*self.time_graph_group)\n",
        "\n",
        "    def show_frequency_shift_in_fourier(self):\n",
        "        sum_graph = self.sum_graph\n",
        "        pulse_graph = self.pulse_graph\n",
        "        pulse_label = VGroup(self.pulse_brace, self.pulse_text)\n",
        "        echo_graph = self.echo_graph\n",
        "        echo_label = VGroup(\n",
        "            self.echo_brace, self.echo_text, self.echo_subtext\n",
        "        )\n",
        "\n",
        "        #Setup all fourier graph stuff\n",
        "        f_max = 0.02\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0, x_max = 20,\n",
        "            x_axis_config = {\"unit_size\" : 0.5},\n",
        "            y_min = -f_max, y_max = f_max,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 50,\n",
        "                \"tick_frequency\" : 0.01,\n",
        "            },\n",
        "        )\n",
        "        frequency_axes.move_to(self.axes, LEFT)\n",
        "        frequency_axes.to_edge(DOWN)\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.next_to(\n",
        "            frequency_axes.x_axis.get_right(), UP,\n",
        "        )\n",
        "        frequency_label.to_edge(RIGHT)\n",
        "        frequency_axes.add(frequency_label)\n",
        "\n",
        "        for graph in pulse_graph, echo_graph, sum_graph:\n",
        "            graph.fourier_transform = get_fourier_graph(\n",
        "                frequency_axes, graph.underlying_function,\n",
        "                frequency_axes.x_min, 25,\n",
        "                complex_to_real_func = abs,\n",
        "            )\n",
        "\n",
        "        #Braces labeling F.T.\n",
        "        original_fourier_brace = Brace(\n",
        "            Line(\n",
        "                frequency_axes.coords_to_point(7, 0.9*f_max),\n",
        "                frequency_axes.coords_to_point(9, 0.9*f_max),\n",
        "            ),\n",
        "            UP,\n",
        "        ).set_color(BLUE)\n",
        "        echo_fourier_brace = Brace(\n",
        "            Line(\n",
        "                frequency_axes.coords_to_point(14, 0.4*f_max),\n",
        "                frequency_axes.coords_to_point(18, 0.4*f_max),\n",
        "            ),\n",
        "            UP,\n",
        "        ).set_color(YELLOW)\n",
        "        # braces = [original_fourier_brace, echo_fourier_brace]\n",
        "        # words = [\"original signal\", \"echo\"]\n",
        "        # for brace, word in zip(braces, words):\n",
        "        #     brace.add(brace.get_text(\"F.T. of \\\\\\\\ %s\"%word))\n",
        "        fourier_label = OldTex(\"||\\\\text{Fourier transform}||\")\n",
        "        # fourier_label.next_to(sum_graph.fourier_transform, UP, MED_LARGE_BUFF)\n",
        "        fourier_label.next_to(frequency_axes.y_axis, UP, buff = SMALL_BUFF)\n",
        "        fourier_label.shift_onto_screen()\n",
        "        fourier_label.set_color(RED)\n",
        "\n",
        "\n",
        "        #v_lines\n",
        "        v_line = DashedLine(\n",
        "            frequency_axes.coords_to_point(8, 0),\n",
        "            frequency_axes.coords_to_point(8, 1.2*f_max),\n",
        "            color = YELLOW,\n",
        "            dash_length = 0.025,\n",
        "        )\n",
        "        v_line_pair = VGroup(*[\n",
        "            v_line.copy().shift(u*0.6*RIGHT)\n",
        "            for u in (-1, 1)\n",
        "        ])\n",
        "        v_line = VGroup(v_line)\n",
        "\n",
        "        double_arrow = DoubleArrow(\n",
        "            frequency_axes.coords_to_point(8, 0.007),\n",
        "            frequency_axes.coords_to_point(16, 0.007),\n",
        "            buff = 0,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            self.time_graph_group.to_edge, UP,\n",
        "            ApplyMethod(\n",
        "                self.dish.shift, 2*UP, \n",
        "                remover = True\n",
        "            ),\n",
        "            FadeIn(frequency_axes)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(sum_graph),\n",
        "            FadeOut(echo_label),\n",
        "            pulse_graph.set_stroke, {\"width\" : 3},\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                pulse_label[0].copy(),\n",
        "                original_fourier_brace\n",
        "            ),\n",
        "            ShowCreation(pulse_graph.fourier_transform)\n",
        "        )\n",
        "        self.play(Write(fourier_label))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(v_line, v_line_pair))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(v_line_pair))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(pulse_graph),\n",
        "            FadeIn(sum_graph),\n",
        "            ReplacementTransform(\n",
        "                pulse_graph.fourier_transform,\n",
        "                sum_graph.fourier_transform\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeIn(echo_label))\n",
        "        self.play(ReplacementTransform(\n",
        "            echo_label[0].copy(),\n",
        "            echo_fourier_brace,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(GrowFromCenter(double_arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_graph(self, func, **kwargs):\n",
        "        graph = self.axes.get_graph(func, **kwargs)\n",
        "        graph.peak_point = self.get_peak_point(graph)\n",
        "        return graph\n",
        "\n",
        "    def get_single_pulse_graph(self, x, **kwargs):\n",
        "        return self.get_graph(self.get_single_pulse_function(x), **kwargs)\n",
        "\n",
        "    def get_single_pulse_function(self, x):\n",
        "        return lambda t : -2*np.sin(10*(t-x))*np.exp(-100*(t-x)**2)\n",
        "\n",
        "    def get_frequency_pulse_graph(self, x, freq = 50, **kwargs):\n",
        "        return self.get_graph(\n",
        "            self.get_frequency_pulse_function(x, freq), \n",
        "            num_graph_points = 700,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_frequency_pulse_function(self, x, freq):\n",
        "        factor = self.frequency_spread_factor\n",
        "        return lambda t : op.mul(\n",
        "            2*np.cos(2*freq*(t-x)),\n",
        "            min(np.exp(-(freq**2/factor)*(t-x)**2), 0.5)\n",
        "        )\n",
        "\n",
        "    def get_peak_point(self, graph):\n",
        "        anchors = graph.get_anchors()\n",
        "        return anchors[np.argmax([p[1] for p in anchors])]\n",
        "\n",
        "    def get_pulse_and_echo_graphs(self, func, args1, args2):\n",
        "        pulse_graph = func(*args1, color = BLUE)\n",
        "        echo_graph = func(*args2, color = YELLOW)\n",
        "        sum_graph = self.axes.get_graph(\n",
        "            lambda x : sum([\n",
        "                pulse_graph.underlying_function(x),\n",
        "                echo_graph.underlying_function(x),\n",
        "            ]),\n",
        "            num_graph_points = echo_graph.get_num_curves(),\n",
        "            color = WHITE\n",
        "        )\n",
        "        sum_graph.background_image_file = \"blue_yellow_gradient\"\n",
        "        return pulse_graph, echo_graph, sum_graph\n",
        "\n",
        "class DopplerFormulaInsert(Scene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\n",
        "            \"f_{\\\\text{echo}\", \"=\",\n",
        "            \"\\\\left(1 + \\\\frac{v}{c}\\\\right)\",\n",
        "            \"f_{\\\\text{pulse}}\"\n",
        "        )\n",
        "        formula[0].set_color(BLUE)\n",
        "        formula[3].set_color(YELLOW)\n",
        "\n",
        "        randy = Randolph(color = BLUE_C)\n",
        "        formula.scale(1.5)\n",
        "        formula.next_to(randy, UP+LEFT)\n",
        "        formula.shift_onto_screen()\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, formula),\n",
        "            randy.change, \"pondering\", randy.get_bottom(),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class MentionPRFNuance(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"Speed of light\", \"$\\\\gg$\", \"Speed of a plane\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        axes = self.axes = Axes(\n",
        "            x_min = 0, x_max = 10,\n",
        "            y_min = 0, y_max = 2,\n",
        "        )\n",
        "        axes.next_to(title, DOWN, buff = MED_LARGE_BUFF)\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.scale(0.7)\n",
        "        frequency_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        axes.add(frequency_label)\n",
        "        self.add(axes)\n",
        "\n",
        "        pulse_x, shift_x = 4, 6\n",
        "        pulse_graph = self.get_spike_graph(pulse_x)\n",
        "        shift_graph = self.get_spike_graph(shift_x)\n",
        "        shift_graph.set_stroke(YELLOW, 2)\n",
        "        peak_points = VGroup(pulse_graph.peak_point, shift_graph.peak_point)\n",
        "        self.add(pulse_graph)\n",
        "\n",
        "        brace = Brace(peak_points, UP, buff = SMALL_BUFF)\n",
        "        displayed_doppler_shift = OldTexText(\"How I'm showing the \\\\\\\\\", \"Doppler shift\")\n",
        "        actual_doppler_shift = OldTexText(\"Actual\\\\\\\\\", \"Doppler shift\")\n",
        "        doppler_shift_words = VGroup(displayed_doppler_shift, actual_doppler_shift)\n",
        "        doppler_shift_words.set_color(YELLOW)\n",
        "        doppler_shift_words.scale(0.75)\n",
        "        displayed_doppler_shift.next_to(brace, UP, buff = SMALL_BUFF)\n",
        "        actual_doppler_shift.move_to(pulse_graph.peak_point)\n",
        "        actual_doppler_shift.align_to(displayed_doppler_shift)\n",
        "\n",
        "        self.play(\n",
        "            Animation(pulse_graph),\n",
        "            self.teacher.change, \"raise_right_hand\", \n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(shift_graph),\n",
        "            FadeIn(brace),\n",
        "            Write(displayed_doppler_shift, run_time = 1),\n",
        "            self.change_students(*3*[\"sassy\"]),\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                shift_graph, \n",
        "                lambda g, a : Transform(\n",
        "                    g, self.get_spike_graph(\n",
        "                        interpolate(shift_x, pulse_x+0.01, a),\n",
        "                    ).match_style(shift_graph)\n",
        "                ).update(1),\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                brace,\n",
        "                lambda b : b.match_width(\n",
        "                    peak_points, stretch = True\n",
        "                ).next_to(peak_points, UP, SMALL_BUFF)\n",
        "            ),\n",
        "            Transform(\n",
        "                displayed_doppler_shift, actual_doppler_shift,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.6)\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        everything = VGroup(\n",
        "            title,\n",
        "            axes, pulse_graph, shift_graph,\n",
        "            brace, displayed_doppler_shift\n",
        "        )\n",
        "        rect = SurroundingRectangle(everything, color = WHITE)\n",
        "        everything.add(rect)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"I'll ignore certain \\\\\\\\ nuances for now.\",\n",
        "            target_mode = \"shruggie\",\n",
        "            added_anims = [\n",
        "                everything.scale, 0.4,\n",
        "                everything.to_corner, UP+LEFT,\n",
        "                UpdateFromAlphaFunc(\n",
        "                    rect, lambda m, a : m.set_stroke(width = 2*a)\n",
        "                )\n",
        "            ],\n",
        "        )\n",
        "        self.play_student_changes(*3*[\"hesitant\"])\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def get_spike_graph(self, x, color = RED, **kwargs):\n",
        "        graph = self.axes.get_graph(\n",
        "            lambda t : np.exp(-10*(t-x)**2)*np.cos(10*(t-x)),\n",
        "            color = color,\n",
        "            **kwargs\n",
        "        )\n",
        "        graph.peak_point = VectorizedPoint(self.axes.input_to_graph_point(x, graph))\n",
        "        graph.add(graph.peak_point)\n",
        "        return graph\n",
        "\n",
        "class TimeAndFrequencyGivePositionAndVelocity(IntroduceDopplerRadar):\n",
        "    def construct(self):\n",
        "        x = 7\n",
        "        freq = 25\n",
        "\n",
        "        axes = self.axes = Axes(\n",
        "            x_min = 0, x_max = 10,\n",
        "            y_min = -2, y_max = 2,\n",
        "        )\n",
        "        axes.center()\n",
        "        title = OldTexText(\"Echo signal\")\n",
        "        title.next_to(axes.y_axis, UP)\n",
        "        axes.add(title)\n",
        "        axes.to_edge(UP)\n",
        "        graph = self.get_frequency_pulse_graph(x = x, freq = freq)\n",
        "        graph.background_image_file = \"blue_yellow_gradient\"\n",
        "\n",
        "        arrow = Arrow(\n",
        "            axes.coords_to_point(0, -1.5),\n",
        "            axes.coords_to_point(x, -1.5),\n",
        "            color = WHITE,\n",
        "            buff = SMALL_BUFF,\n",
        "        )\n",
        "        time = OldTexText(\"Time\")\n",
        "        time.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        delta_x = 0.7\n",
        "        brace = Brace(\n",
        "            Line(\n",
        "                axes.coords_to_point(x-delta_x, 1), \n",
        "                axes.coords_to_point(x+delta_x, 1)\n",
        "            ),\n",
        "            UP\n",
        "        )\n",
        "        frequency = OldTexText(\"Frequency\")\n",
        "        frequency.set_color(YELLOW)\n",
        "        frequency.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        time_updown_arrow = OldTex(\"\\\\Updownarrow\")\n",
        "        time_updown_arrow.next_to(time, DOWN, SMALL_BUFF)\n",
        "        freq_updown_arrow = time_updown_arrow.copy()\n",
        "        freq_updown_arrow.next_to(frequency, UP, SMALL_BUFF)\n",
        "        distance = OldTexText(\"Distance\")\n",
        "        distance.next_to(time_updown_arrow, DOWN, SMALL_BUFF)\n",
        "        velocity = OldTexText(\"Velocity\")\n",
        "        velocity.next_to(freq_updown_arrow, UP, SMALL_BUFF)\n",
        "        VGroup(freq_updown_arrow, velocity).match_style(frequency)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            LaggedStartMap(FadeIn, time, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            LaggedStartMap(FadeIn, frequency, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromPoint(time_updown_arrow, time_updown_arrow.get_top()),\n",
        "            ReplacementTransform(\n",
        "                time.copy().fade(1), \n",
        "                distance\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromPoint(freq_updown_arrow, freq_updown_arrow.get_top()),\n",
        "            ReplacementTransform(\n",
        "                frequency.copy().fade(1), \n",
        "                velocity\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class RadarOperatorUncertainty(Scene):\n",
        "    def construct(self):\n",
        "        dish = RadarDish()\n",
        "        dish.scale(3)\n",
        "        dish.move_to(4*RIGHT + 2*DOWN)\n",
        "        dish_words = OldTexText(\"3b1b industrial \\\\\\\\ enterprises\")\n",
        "        dish_words.scale(0.25)\n",
        "        dish_words.set_stroke(BLACK, 0.5)\n",
        "        dish_words.set_color(BLACK)\n",
        "        dish_words.move_to(dish, DOWN)\n",
        "        dish_words.shift(SMALL_BUFF*(UP+2*LEFT))\n",
        "        dish.add(dish_words)\n",
        "        randy = Randolph()\n",
        "        randy.next_to(dish, LEFT, aligned_edge = DOWN)\n",
        "        bubble = randy.get_bubble(\n",
        "            width = 7,\n",
        "            height = 4,\n",
        "        )\n",
        "\n",
        "        echo_object = Square()\n",
        "        echo_object.move_to(dish)\n",
        "        echo_object.shift(FRAME_X_RADIUS*RIGHT)\n",
        "        pulse = RadarPulse(dish, echo_object, speed = 6)\n",
        "\n",
        "        plane = Plane().scale(0.5)\n",
        "        plane.move_to(bubble.get_bubble_center()+LEFT)\n",
        "        plane_cloud = ProbabalisticMobjectCloud(\n",
        "            plane, \n",
        "            fill_opacity = 0.3,\n",
        "            n_copies = 10,\n",
        "        )\n",
        "        plane_gdw = plane_cloud.gaussian_distribution_wrapper\n",
        "\n",
        "        vector_cloud = ProbabalisticVectorCloud(\n",
        "            center_func = plane_gdw.get_center,\n",
        "        )\n",
        "        vector_gdw = vector_cloud.gaussian_distribution_wrapper\n",
        "        vector_gdw.scale(0.05)\n",
        "        vector_gdw.move_to(plane_gdw)\n",
        "        vector_gdw.shift(2*RIGHT)\n",
        "\n",
        "        self.add(randy, dish, bubble, plane_cloud, pulse)\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.wait(3)\n",
        "        self.add(vector_cloud)\n",
        "        for i in range(3):\n",
        "            for plane_factor, vector_factor, freq in (0.05, 10, 0.01), (20, 0.1, 0.1):\n",
        "                pulse.internal_time = 0\n",
        "                pulse.frequency = freq\n",
        "                self.play(\n",
        "                    randy.change, \"pondering\", plane,\n",
        "                    plane_gdw.scale, plane_factor,\n",
        "                    vector_gdw.scale, vector_factor,\n",
        "                )\n",
        "                self.wait(2)\n",
        "\n",
        "class AmbiguityInLongEchos(IntroduceDopplerRadar, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"object_x_coords\" : [7, 4, 6, 9, 8],\n",
        "        \"frequency_spread_factor\" : 200,\n",
        "        \"n_pulse_singletons\" : 16,\n",
        "        \"pulse_frequency\" : 0.025,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_objects()\n",
        "        self.send_long_pulse_single_echo()\n",
        "        self.introduce_multiple_objects()\n",
        "        self.use_short_pulse()\n",
        "        self.fourier_transform_of_one_pulse()\n",
        "        self.show_echos_of_moving_objects()\n",
        "        self.overlapping_frequenies_of_various_objects()\n",
        "        self.echos_of_long_pure_signal_in_frequency_space()\n",
        "        self.concentrated_fourier_requires_long_time()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = self.axes = Axes(\n",
        "            x_min = 0, x_max = 10,\n",
        "            y_min = -1.5, y_max = 1.5,\n",
        "        )\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        axes.add(time_label)\n",
        "        axes.center()\n",
        "        axes.shift(DOWN)\n",
        "        self.add(axes)\n",
        "\n",
        "        dish = self.dish = RadarDish()\n",
        "        dish.move_to(axes, LEFT)\n",
        "        dish.to_edge(UP, buff = LARGE_BUFF)\n",
        "        self.add(dish)\n",
        "\n",
        "    def setup_objects(self):\n",
        "        objects = self.objects = VGroup(\n",
        "            Plane().flip(),\n",
        "            SVGMobject(\n",
        "                file_name = \"blimp\", \n",
        "                color = BLUE_C,\n",
        "                height = 0.5,\n",
        "            ),\n",
        "            SVGMobject(\n",
        "                file_name = \"biplane\", \n",
        "                color = RED_D,\n",
        "                height = 0.5,\n",
        "            ),\n",
        "            SVGMobject(\n",
        "                file_name = \"helicopter\", \n",
        "                color = GREY_B,\n",
        "                height = 0.5,\n",
        "            ).rotate(-TAU/24),\n",
        "            FalconHeavy(),\n",
        "        )\n",
        "        y_shifts = [0.25, 0, 0.5, 0.25, -0.5]\n",
        "        for x, y, obj in zip(self.object_x_coords, y_shifts, objects):\n",
        "            obj.move_to(self.axes.coords_to_point(x, 0))\n",
        "            obj.align_to(self.dish)\n",
        "            obj.shift(y*UP)\n",
        "\n",
        "        self.object_velocities = [\n",
        "            0.7*LEFT,\n",
        "            0.1*RIGHT,\n",
        "            0.4*LEFT,\n",
        "            0.4*RIGHT,\n",
        "            0.5*UP,\n",
        "        ]\n",
        "\n",
        "    def send_long_pulse_single_echo(self):\n",
        "        x = self.object_x_coords[0]\n",
        "        plane = self.objects[0]\n",
        "        self.add(plane)\n",
        "        randy = self.pi_creature\n",
        "        self.remove(randy)\n",
        "\n",
        "        pulse_graph = self.get_frequency_pulse_graph(x)\n",
        "        pulse_graph.background_image_file = \"blue_yellow_gradient\"\n",
        "\n",
        "        pulse = self.get_pulse(self.dish, plane)\n",
        "\n",
        "        brace = Brace(\n",
        "            Line(\n",
        "                self.axes.coords_to_point(x-1, 1),\n",
        "                self.axes.coords_to_point(x+1, 1),\n",
        "            ), UP\n",
        "        )\n",
        "        words = brace.get_text(\"Spread over time\")\n",
        "\n",
        "        self.add(pulse)\n",
        "        self.wait()\n",
        "        squished_rate_func = squish_rate_func(smooth, 0.6, 0.9)\n",
        "        self.play(\n",
        "            ShowCreation(pulse_graph, rate_func=linear),\n",
        "            GrowFromCenter(brace, rate_func = squished_rate_func),\n",
        "            Write(words, rate_func = squished_rate_func),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.remove(pulse)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \"Who cares?\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            bubble_config = {\n",
        "                \"direction\" : LEFT,\n",
        "                \"width\" : 2,\n",
        "                \"height\": 1.5,\n",
        "            },\n",
        "            target_mode = \"maybe\",\n",
        "            look_at = brace,\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, VGroup(\n",
        "                randy.bubble, randy.bubble.content, \n",
        "                brace, words,\n",
        "            )\n",
        "        ))\n",
        "\n",
        "        self.curr_graph = pulse_graph\n",
        "\n",
        "    def introduce_multiple_objects(self):\n",
        "        objects = self.objects\n",
        "        x_coords = self.object_x_coords\n",
        "        curr_graph = self.curr_graph\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        graphs = VGroup(*[\n",
        "            self.get_frequency_pulse_graph(x)\n",
        "            for x in x_coords\n",
        "        ])\n",
        "        graphs.set_color_by_gradient(BLUE, YELLOW)\n",
        "        sum_graph = self.axes.get_graph(\n",
        "            lambda t : sum([\n",
        "                graph.underlying_function(t)\n",
        "                for graph in graphs\n",
        "            ]),\n",
        "            num_graph_points = 1000\n",
        "        )\n",
        "\n",
        "        noise_function = lambda t : np.sum([\n",
        "            0.5*np.sin(f*t)/f \n",
        "            for f in (2, 3, 5, 7, 11, 13)\n",
        "        ])\n",
        "        noisy_graph = self.axes.get_graph(\n",
        "            lambda t : sum_graph.underlying_function(t)*(1+noise_function(t)),\n",
        "            num_graph_points = 1000\n",
        "        )\n",
        "        for graph in sum_graph, noisy_graph:\n",
        "            graph.background_image_file = \"blue_yellow_gradient\"\n",
        "\n",
        "        pulses = self.get_pulses()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, objects[1:]),\n",
        "            FadeOut(curr_graph),\n",
        "            randy.change, \"pondering\"\n",
        "        )\n",
        "        self.add(*pulses)\n",
        "        self.wait(0.5)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                sum_graph,\n",
        "                rate_func=linear,\n",
        "                run_time = 3.5,\n",
        "            ),\n",
        "            randy.change, \"confused\"\n",
        "        )\n",
        "        self.remove(*pulses)\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.play(Transform(\n",
        "            sum_graph, noisy_graph,\n",
        "            rate_func = lambda t : wiggle(t, 4),\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.curr_graph = sum_graph\n",
        "\n",
        "    def use_short_pulse(self):\n",
        "        curr_graph = self.curr_graph\n",
        "        objects = self.objects\n",
        "        x_coords = self.object_x_coords\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        self.frequency_spread_factor = 10\n",
        "        self.n_pulse_singletons = 4\n",
        "        self.pulse_frequency = 0.015\n",
        "\n",
        "        graphs = VGroup(*[\n",
        "            self.get_frequency_pulse_graph(x)\n",
        "            for x in x_coords\n",
        "        ])\n",
        "        sum_graph = self.axes.get_graph(\n",
        "            lambda t : sum([\n",
        "                graph.underlying_function(t)\n",
        "                for graph in graphs\n",
        "            ]),\n",
        "            num_graph_points = 1000\n",
        "        )\n",
        "        sum_graph.background_image_file = \"blue_yellow_gradient\"\n",
        "\n",
        "        pulses = self.get_pulses()\n",
        "\n",
        "        self.play(FadeOut(curr_graph))\n",
        "        self.add(*pulses)\n",
        "        self.wait(0.5)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                sum_graph,\n",
        "                rate_func=linear,\n",
        "                run_time = 3.5,\n",
        "            ),\n",
        "            randy.change, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.curr_graph = sum_graph\n",
        "        self.first_echo_graph = graphs[0]\n",
        "        self.first_echo_graph.set_color(YELLOW)\n",
        "\n",
        "    def fourier_transform_of_one_pulse(self):\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0, x_max = 20,\n",
        "            x_axis_config = {\n",
        "                \"unit_size\" : 0.5, \n",
        "                \"tick_frequency\" : 2, \n",
        "            },\n",
        "            y_min = -.01, y_max = .01,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 110,\n",
        "                \"tick_frequency\" : 0.006\n",
        "            }\n",
        "        )\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.next_to(frequency_axes.x_axis.get_right(), UP)\n",
        "        frequency_axes.add(frequency_label)\n",
        "        first_echo_graph = self.first_echo_graph\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VGroup(self.axes, first_echo_graph).to_edge, UP,\n",
        "                {\"buff\" : SMALL_BUFF},\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            LaggedStartMap(FadeOut, self.objects),\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                self.curr_graph, self.dish, self.pi_creature\n",
        "            )),\n",
        "            run_time = 2\n",
        "        )\n",
        "\n",
        "        #\n",
        "        frequency_axes.next_to(self.axes, DOWN, LARGE_BUFF, LEFT)\n",
        "        fourier_graph = get_fourier_graph(\n",
        "            frequency_axes, first_echo_graph.underlying_function,\n",
        "            t_min = 0, t_max = 25,\n",
        "            complex_to_real_func = np.abs,\n",
        "        )\n",
        "        fourier_graph.save_state()\n",
        "        fourier_graph.move_to(first_echo_graph)\n",
        "        h_vect = 4*RIGHT\n",
        "        fourier_graph.shift(h_vect)\n",
        "        fourier_graph.fade(1)\n",
        "\n",
        "        f = 8\n",
        "        v_line = DashedLine(\n",
        "            frequency_axes.coords_to_point(f, 0),\n",
        "            frequency_axes.coords_to_point(f, frequency_axes.y_max),\n",
        "        )\n",
        "        v_lines = VGroup(\n",
        "            v_line.copy().shift(2*LEFT),\n",
        "            v_line.copy().shift(2*RIGHT),\n",
        "        )\n",
        "        rect = Rectangle(stroke_width = 0, fill_color = YELLOW, fill_opacity = 0.25)\n",
        "        rect.replace(v_lines, stretch = True)\n",
        "        rect.save_state()\n",
        "        rect.stretch(0, 0)\n",
        "\n",
        "        self.play(Write(frequency_axes, run_time = 1))\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                lambda m : m.move_to(fourier_graph.saved_state).shift(-h_vect).fade(1),\n",
        "                first_echo_graph.copy(),\n",
        "                remover = True,\n",
        "            ),\n",
        "            fourier_graph.restore\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            ReplacementTransform(VGroup(v_line), v_lines),\n",
        "            rect.restore\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(v_lines), FadeOut(rect))\n",
        "\n",
        "        self.frequency_axes = frequency_axes\n",
        "        self.fourier_graph = fourier_graph\n",
        "\n",
        "    def show_echos_of_moving_objects(self):\n",
        "        objects = self.objects\n",
        "        objects.save_state()\n",
        "        object_velocities = self.object_velocities\n",
        "\n",
        "        movements = self.object_movements = [\n",
        "            always_shift(\n",
        "                obj, \n",
        "                direction = v/get_norm(v),\n",
        "                rate = get_norm(v)\n",
        "            )\n",
        "            for v, obj in zip(object_velocities, objects)\n",
        "        ]\n",
        "        pulses = self.get_pulses()\n",
        "        continual_anims = pulses+movements\n",
        "        \n",
        "        self.play(\n",
        "            FadeOut(self.axes),\n",
        "            FadeOut(self.first_echo_graph),\n",
        "            LaggedStartMap(FadeIn, objects),\n",
        "            FadeIn(self.dish)\n",
        "        )\n",
        "        self.add(*continual_anims)\n",
        "        self.wait(4)\n",
        "        self.play(*[\n",
        "            UpdateFromAlphaFunc(\n",
        "                obj, \n",
        "                lambda m, a : m.set_fill(opacity = 1-a),\n",
        "            )\n",
        "            for obj in objects\n",
        "        ])\n",
        "        self.remove(*continual_anims)\n",
        "        self.wait()\n",
        "\n",
        "    def overlapping_frequenies_of_various_objects(self):\n",
        "        frequency_axes = self.frequency_axes\n",
        "        fourier_graph = self.fourier_graph\n",
        "        shifted_graphs = self.get_shifted_frequency_graphs(fourier_graph)\n",
        "        color = fourier_graph.get_color()\n",
        "        shifted_graphs.set_color_by_gradient(\n",
        "            average_color(color, WHITE), \n",
        "            color,\n",
        "            average_color(color, BLACK),\n",
        "        )\n",
        "        sum_graph = self.get_sum_graph(frequency_axes, shifted_graphs)\n",
        "        sum_graph.match_style(fourier_graph)\n",
        "\n",
        "        shifted_graphs.save_state()\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(fourier_graph), shifted_graphs,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            shifted_graphs.arrange, DOWN,\n",
        "            shifted_graphs.move_to, fourier_graph, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(shifted_graphs.restore),\n",
        "        self.play(ReplacementTransform(\n",
        "            shifted_graphs, VGroup(sum_graph),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.curr_fourier_graph = sum_graph\n",
        "\n",
        "    def echos_of_long_pure_signal_in_frequency_space(self):\n",
        "        curr_fourier_graph = self.curr_fourier_graph\n",
        "        f_max = self.frequency_axes.y_max\n",
        "        new_fourier_graph = self.frequency_axes.get_graph(\n",
        "            lambda x : f_max * np.exp(-100*(x-8)**2),\n",
        "            num_graph_points = 1000,\n",
        "        )\n",
        "        new_fourier_graph.set_color(PINK)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(curr_fourier_graph),\n",
        "            FadeIn(new_fourier_graph),\n",
        "        )\n",
        "        self.fourier_graph = new_fourier_graph\n",
        "        self.overlapping_frequenies_of_various_objects()\n",
        "\n",
        "    def concentrated_fourier_requires_long_time(self):\n",
        "        objects = self.objects\n",
        "        objects.restore()\n",
        "        object_movements = self.object_movements\n",
        "        self.n_pulse_singletons = 32\n",
        "        pulses = self.get_pulses()\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        continual_anims = object_movements+pulses\n",
        "        self.play(FadeIn(randy))\n",
        "        self.add(*continual_anims)\n",
        "        self.play(randy.change, \"angry\", *[\n",
        "            UpdateFromAlphaFunc(obj, lambda m, a : m.set_fill(opacity = a))\n",
        "            for obj in objects\n",
        "        ])\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"plain\", *[\n",
        "            UpdateFromAlphaFunc(obj, lambda m, a : m.set_fill(opacity = 1-a))\n",
        "            for obj in objects\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_frequency_pulse_graph(self, x, freq = 25, **kwargs):\n",
        "        graph = IntroduceDopplerRadar.get_frequency_pulse_graph(\n",
        "            self, x, freq, **kwargs\n",
        "        )\n",
        "        return graph\n",
        "\n",
        "    def get_pulse(self, dish, echo_object):\n",
        "        return RadarPulse(\n",
        "            dish, echo_object, \n",
        "            n_pulse_singletons = self.n_pulse_singletons,\n",
        "            frequency = 0.025,\n",
        "            speed = 5.0,\n",
        "        )\n",
        "\n",
        "    def get_pulses(self):\n",
        "        return [\n",
        "            self.get_pulse(\n",
        "                self.dish.copy().shift(0.01*obj.get_center()[0]),\n",
        "                obj\n",
        "            )\n",
        "            for obj in self.objects\n",
        "        ]\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.5).flip()\n",
        "        randy.to_edge(RIGHT, buff = 1.7).shift(0.5*UP)\n",
        "        return randy\n",
        "\n",
        "    def get_shifted_frequency_graphs(self, fourier_graph):\n",
        "        frequency_axes = self.frequency_axes\n",
        "        def get_func(v):\n",
        "            return lambda f : fourier_graph.underlying_function(np.clip(\n",
        "                f-5*v[0], \n",
        "                frequency_axes.x_min,\n",
        "                frequency_axes.x_max,\n",
        "            ))\n",
        "        def get_graph(func):\n",
        "            return frequency_axes.get_graph(func)\n",
        "        shifted_graphs = VGroup(*list(map(\n",
        "            get_graph, list(map(get_func, self.object_velocities))\n",
        "        )))\n",
        "        shifted_graphs.match_style(fourier_graph)\n",
        "        return shifted_graphs\n",
        "\n",
        "    def get_sum_graph(self, axes, graphs):\n",
        "        def get_func(graph):\n",
        "            return graph.underlying_function\n",
        "        funcs = list(map(get_func, graphs))\n",
        "        return axes.get_graph(\n",
        "            lambda t : sum([func(t) for func in funcs]),\n",
        "        )\n",
        "\n",
        "class SummarizeFourierTradeoffForDoppler(Scene):\n",
        "    def construct(self):\n",
        "        time_axes = Axes(\n",
        "            x_min = 0, x_max = 12,\n",
        "            y_min = -0.5, y_max = 1,\n",
        "        )\n",
        "        time_axes.center().to_edge(UP, buff = LARGE_BUFF)\n",
        "        frequency_axes = time_axes.copy()\n",
        "        frequency_axes.next_to(time_axes, DOWN, buff = 2)\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        for label, axes in (time_label, time_axes), (frequency_label, frequency_axes):\n",
        "            label.next_to(axes.get_right(), UP, SMALL_BUFF)\n",
        "            axes.add(label)\n",
        "        frequency_label.shift_onto_screen()\n",
        "        title = OldTexText(\"Fourier Trade-off\")\n",
        "        title.next_to(time_axes, DOWN)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "        #Position determines log of scale value for exponentials\n",
        "        a_mob = VectorizedPoint()\n",
        "        x_values = [3, 5, 6, 7, 8]\n",
        "        v_values = [5, 5.5, 5.75, 6.5, 7]\n",
        "        def get_top_graphs():\n",
        "            a = np.exp(a_mob.get_center()[0])\n",
        "            graphs = VGroup(*[\n",
        "                time_axes.get_graph(lambda t : np.exp(-5*a*(t-x)**2))\n",
        "                for x in x_values\n",
        "            ])\n",
        "            graphs.set_color(WHITE)\n",
        "            graphs.color_using_background_image(\"blue_yellow_gradient\")\n",
        "            return graphs\n",
        "        def get_bottom_graphs():\n",
        "            a = np.exp(a_mob.get_center()[0])\n",
        "            graphs = VGroup(*[\n",
        "                frequency_axes.get_graph(lambda t : np.exp(-(5./a)*(t-v)**2))\n",
        "                for v in v_values\n",
        "            ])\n",
        "            graphs.set_color(RED)\n",
        "            return graphs\n",
        "\n",
        "        top_graphs = get_top_graphs()\n",
        "        bottom_graphs = get_bottom_graphs()\n",
        "        update_top_graphs = Mobject.add_updater(\n",
        "            top_graphs, \n",
        "            lambda g : Transform(g, get_top_graphs()).update(1)\n",
        "        )\n",
        "        update_bottom_graphs = Mobject.add_updater(\n",
        "            bottom_graphs, \n",
        "            lambda g : Transform(g, get_bottom_graphs()).update(1)\n",
        "        )\n",
        "\n",
        "        self.add(time_axes, frequency_axes)\n",
        "        self.add(update_top_graphs, update_bottom_graphs)\n",
        "\n",
        "        shift_vect = 2*RIGHT\n",
        "        for s in 1, -2, 1:\n",
        "            self.play(a_mob.shift, s*shift_vect, run_time = 3)\n",
        "\n",
        "class MentionUncertaintyPrincipleCopy(MentionUncertaintyPrinciple):\n",
        "    pass\n",
        "\n",
        "class IntroduceDeBroglie(Scene):\n",
        "    CONFIG = {\n",
        "        \"default_wave_frequency\" : 1,\n",
        "        \"wave_colors\" : [BLUE_D, YELLOW],\n",
        "        \"dispersion_factor\" : 1,\n",
        "        \"amplitude\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        text_scale_val = 0.8,\n",
        "\n",
        "        #Overlay real tower in video editor\n",
        "        eiffel_tower = Line(3*DOWN, 3*UP, stroke_width = 0)\n",
        "        picture = ImageMobject(\"de_Broglie\")\n",
        "        picture.set_height(4)\n",
        "        picture.to_corner(UP+LEFT)\n",
        "        name = OldTexText(\"Louis de Broglie\")\n",
        "        name.next_to(picture, DOWN)\n",
        "\n",
        "        picture.save_state()\n",
        "        picture.scale(0)\n",
        "        picture.move_to(eiffel_tower.get_top())\n",
        "\n",
        "\n",
        "        broadcasts = [\n",
        "            Broadcast(\n",
        "                eiffel_tower.get_top(),\n",
        "                big_radius = 10,\n",
        "                n_circles = 10,\n",
        "                lag_ratio = 0.9,\n",
        "                run_time = 7,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.3),\n",
        "                color = WHITE,\n",
        "            )\n",
        "            for a in np.linspace(0, 0.7, 3)\n",
        "        ]\n",
        "\n",
        "        self.play(*broadcasts)\n",
        "        self.play(picture.restore)\n",
        "        self.play(Write(name))\n",
        "        self.wait()\n",
        "\n",
        "        #Time line\n",
        "        time_line = NumberLine(\n",
        "            x_min = 1900,\n",
        "            x_max = 1935,\n",
        "            tick_frequency = 1,\n",
        "            big_tick_numbers = list(range(1900, 1941, 10)),\n",
        "            color = BLUE_D\n",
        "        )\n",
        "        time_line.stretch_to_fit_width(FRAME_WIDTH - picture.get_width() - 2)\n",
        "        time_line.add_numbers(*time_line.big_tick_numbers)\n",
        "        time_line.next_to(picture, RIGHT, MED_LARGE_BUFF, DOWN)\n",
        "\n",
        "        year_to_words = {\n",
        "            1914 : \"Wold War I begins\",\n",
        "            1915 : \"Einstein field equations\",\n",
        "            1916 : \"Lewis dot formulas\",\n",
        "            1917 : \"Not a lot of physics...because war\",\n",
        "            1918 : \"S'more Rutherford badassery\",\n",
        "            1919 : \"Eddington confirms general relativity predictions\",\n",
        "            1920 : \"World is generally stoked on general relativity\",\n",
        "            1921 : \"Einstein gets long overdue Nobel prize\",\n",
        "            1922 : \"Stern-Gerlach Experiment\",\n",
        "            1923 : \"Compton scattering observed\",\n",
        "            1924 : \"de Broglie's thesis\"\n",
        "        }\n",
        "        arrow = Vector(DOWN, color = WHITE)\n",
        "        arrow.next_to(time_line.number_to_point(1914), UP)\n",
        "        words = OldTexText(year_to_words[1914])\n",
        "        words.scale(text_scale_val)\n",
        "        date = Integer(1914)\n",
        "        date.next_to(arrow, UP, LARGE_BUFF)\n",
        "\n",
        "        def get_year(alpha = 0):\n",
        "            return int(time_line.point_to_number(arrow.get_end()))\n",
        "\n",
        "        def update_words(words):\n",
        "            text = year_to_words.get(get_year(), \"Hi there\")\n",
        "            if text not in words.get_tex():\n",
        "                words.__init__(text)\n",
        "                words.scale(text_scale_val)\n",
        "            words.move_to(interpolate(\n",
        "                arrow.get_top(), date.get_bottom(), 0.5\n",
        "            ))\n",
        "        update_words(words)\n",
        "        self.play(\n",
        "            FadeIn(time_line),\n",
        "            GrowArrow(arrow),\n",
        "            Write(words),\n",
        "            Write(date),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            arrow.next_to, time_line.number_to_point(1924), UP,\n",
        "            ChangingDecimal(\n",
        "                date, get_year,\n",
        "                position_update_func = lambda m : m.next_to(arrow, UP, LARGE_BUFF)\n",
        "            ),\n",
        "            UpdateFromFunc(words, update_words),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Transform time_line\n",
        "        line = time_line\n",
        "        self.play(\n",
        "            FadeOut(time_line.numbers),\n",
        "            VGroup(arrow, words, date).shift, MED_LARGE_BUFF*UP,\n",
        "            *[\n",
        "                ApplyFunction(\n",
        "                    lambda m : m.rotate(TAU/4).set_stroke(width = 0),\n",
        "                    mob,\n",
        "                    remover = True\n",
        "                )\n",
        "                for mob in time_line.tick_marks\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        #Wave function\n",
        "        particle = VectorizedPoint()\n",
        "        axes = Axes(x_min = -1, x_max = 10)\n",
        "        axes.match_width(line)\n",
        "        axes.shift(line.get_center() - axes.x_axis.get_center())\n",
        "        im_line = line.copy()\n",
        "        im_line.set_color(YELLOW)\n",
        "        wave_update_animation = self.get_wave_update_animation(\n",
        "            axes, particle, line, im_line\n",
        "        )\n",
        "\n",
        "        for x in range(3):\n",
        "            particle.move_to(axes.coords_to_point(-10, 0))\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    particle.move_to, axes.coords_to_point(22, 0),\n",
        "                    rate_func=linear\n",
        "                ),\n",
        "                wave_update_animation,\n",
        "                run_time = 3\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    ###\n",
        "    def get_wave_update_animation(self, axes, particle, re_line = None, im_line = None):\n",
        "        line = Line(\n",
        "            axes.x_axis.get_left(),\n",
        "            axes.x_axis.get_right(),\n",
        "        )\n",
        "        if re_line is None:\n",
        "            re_line = line.copy()\n",
        "            re_line.set_color(self.wave_colors[0])\n",
        "        if im_line is None:\n",
        "            im_line = line.copy()\n",
        "            im_line.set_color(self.wave_colors[1])\n",
        "        lines = VGroup(im_line, re_line)\n",
        "        def update_lines(lines):\n",
        "            waves = self.get_wave_pair(axes, particle)\n",
        "            for line, wave in zip(lines, waves):\n",
        "                wave.match_style(line)\n",
        "                Transform(line, wave).update(1)\n",
        "        return UpdateFromFunc(lines, update_lines)\n",
        "\n",
        "    def get_wave(\n",
        "        self, axes, particle, \n",
        "        complex_to_real_func = lambda z : z.real,\n",
        "        freq = None, \n",
        "        **kwargs):\n",
        "        freq = freq or self.default_wave_frequency\n",
        "        k0 = 1./freq\n",
        "        t0 = axes.x_axis.point_to_number(particle.get_center())\n",
        "        def func(x):\n",
        "            dispersion = fdiv(1., self.dispersion_factor)*(np.sqrt(1./(1+t0**2)))\n",
        "            wave_part = complex_to_real_func(np.exp(\n",
        "                complex(0, TAU*freq*(x-dispersion))\n",
        "            ))\n",
        "            bell_part = np.exp(-dispersion*(x-t0)**2)\n",
        "            amplitude = self.amplitude\n",
        "            return amplitude*wave_part*bell_part\n",
        "        graph = axes.get_graph(func)\n",
        "        return graph\n",
        "\n",
        "    def get_wave_pair(self, axes, particle, colors = None, **kwargs):\n",
        "        if colors is None and \"color\" not in kwargs:\n",
        "            colors = self.wave_colors\n",
        "        return VGroup(*[\n",
        "            self.get_wave(\n",
        "                axes, particle, \n",
        "                C_to_R, color = color, \n",
        "                **kwargs\n",
        "            )\n",
        "            for C_to_R, color in zip(\n",
        "                [lambda z : z.imag, lambda z : z.real], \n",
        "                colors\n",
        "            )\n",
        "        ])\n",
        "\n",
        "class ShowMomentumFormula(IntroduceDeBroglie, TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"default_wave_frequency\" : 2,\n",
        "        \"dispersion_factor\" : 0.25,\n",
        "        \"p_color\" : BLUE,\n",
        "        \"xi_color\" : YELLOW,\n",
        "        \"amplitude\" : 0.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_formula()\n",
        "        self.react_to_claim()\n",
        "\n",
        "    def introduce_formula(self):\n",
        "        formula = p, eq, h, xi = OldTex(\"p\", \"=\", \"h\", \"\\\\xi\")\n",
        "        formula.move_to(ORIGIN)\n",
        "        formula.scale(1.5)\n",
        "\n",
        "        word_shift_val = 1.75\n",
        "        p_words = OldTexText(\"Momentum\")\n",
        "        p_words.next_to(p, UP, LARGE_BUFF).shift(word_shift_val*LEFT)\n",
        "        p_arrow = Arrow(\n",
        "            p_words.get_bottom(), p.get_corner(UP+LEFT),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        added_p_words = OldTexText(\"(Classically $m \\\\times v$)\")\n",
        "        added_p_words.move_to(p_words, DOWN)\n",
        "        VGroup(p, p_words, added_p_words, p_arrow).set_color(self.p_color)\n",
        "\n",
        "        xi_words = OldTexText(\"Spatial frequency\")\n",
        "        added_xi_words = OldTexText(\"(cycles per unit \\\\emph{distance})\")\n",
        "        xi_words.next_to(xi, UP, LARGE_BUFF).shift(word_shift_val*RIGHT)\n",
        "        xi_words.align_to(p_words)\n",
        "        xi_arrow = Arrow(\n",
        "            xi_words.get_bottom(), xi.get_corner(UP+RIGHT), \n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        added_xi_words.move_to(xi_words, DOWN)\n",
        "        added_xi_words.align_to(added_p_words, DOWN)\n",
        "        VGroup(xi, xi_words, added_xi_words, xi_arrow).set_color(self.xi_color)\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min = 0, x_max = FRAME_WIDTH,\n",
        "            y_min = -1, y_max = 1,\n",
        "        )\n",
        "        axes.center().to_edge(UP, buff = -0.5)\n",
        "        # axes.next_to(formula, RIGHT)\n",
        "        particle = VectorizedPoint()\n",
        "        wave_update_animation = self.get_wave_update_animation(axes, particle)\n",
        "        wave = wave_update_animation.mobject\n",
        "        wave[0].set_stroke(width = 0)\n",
        "        particle.next_to(wave, LEFT, buff = 2)\n",
        "        wave_propagation = AnimationGroup(\n",
        "            ApplyMethod(particle.move_to, axes.coords_to_point(30, 0)),\n",
        "            wave_update_animation,\n",
        "            run_time = 4,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        stopped_wave_propagation = AnimationGroup(\n",
        "            ApplyMethod(particle.move_to, xi_words),\n",
        "            wave_update_animation,\n",
        "            run_time = 3,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        n_v_lines = 10\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(UP, DOWN)\n",
        "            for x in range(n_v_lines)\n",
        "        ])\n",
        "        v_lines.match_color(xi)\n",
        "        v_lines.arrange(\n",
        "            RIGHT,\n",
        "            buff = float(axes.x_axis.unit_size)/self.default_wave_frequency\n",
        "        )\n",
        "        v_lines.move_to(stopped_wave_propagation.sub_anims[0].target_mobject)\n",
        "        v_lines.align_to(wave)\n",
        "        v_lines.shift(0.125*RIGHT)\n",
        "        \n",
        "        self.add(formula, wave)\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\", \n",
        "            GrowArrow(p_arrow),\n",
        "            Succession(\n",
        "                Write, p_words,\n",
        "                ApplyMethod, p_words.next_to, added_p_words, UP,\n",
        "            ),\n",
        "            FadeIn(\n",
        "                added_p_words,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            wave_propagation\n",
        "        )\n",
        "        self.play(\n",
        "            Write(xi_words),\n",
        "            GrowArrow(xi_arrow),\n",
        "            self.change_students(\"confused\", \"erm\", \"sassy\"),\n",
        "            stopped_wave_propagation\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(added_xi_words),\n",
        "            xi_words.next_to, added_xi_words, UP,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, v_lines),\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeOut, v_lines))\n",
        "        self.wait()\n",
        "\n",
        "        self.formula_labels = VGroup(\n",
        "            p_words, p_arrow, added_p_words,\n",
        "            xi_words, xi_arrow, added_xi_words, \n",
        "        )        \n",
        "        self.set_variables_as_attrs(wave, wave_propagation, formula)\n",
        "\n",
        "    def react_to_claim(self):\n",
        "        formula_labels = self.formula_labels\n",
        "        full_formula = VGroup(self.formula, formula_labels)\n",
        "        full_formula.save_state()\n",
        "        wave_propagation = self.wave_propagation\n",
        "\n",
        "        student = self.students[2]\n",
        "        self.student_says(\n",
        "            \"Hang on...\",\n",
        "            bubble_config = {\"height\" : 2, \"width\" : 2, \"direction\" : LEFT},\n",
        "            target_mode = \"sassy\",\n",
        "            index = 2,\n",
        "            added_anims = [self.teacher.change, \"plain\"]\n",
        "        )\n",
        "        student.bubble.add(student.bubble.content)\n",
        "        self.wait()\n",
        "        kwargs = {\n",
        "            \"path_arc\" : TAU/4,\n",
        "            \"lag_ratio\" : 0.5,\n",
        "            \"lag_ratio\" : 0.7,\n",
        "            \"run_time\" : 1.5,\n",
        "        }\n",
        "        self.play(\n",
        "            full_formula.scale, 0,\n",
        "            full_formula.move_to, student.eyes.get_bottom()+SMALL_BUFF*DOWN,\n",
        "            Animation(student.bubble),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(full_formula.restore, Animation(student.bubble), **kwargs)\n",
        "        wave_propagation.update_config(\n",
        "            rate_func = lambda a : interpolate(0.35, 1, a)\n",
        "        )\n",
        "        self.play(\n",
        "            wave_propagation, \n",
        "            RemovePiCreatureBubble(student, target_mode = \"confused\"),\n",
        "        )\n",
        "        wave_propagation.update_config(rate_func = lambda t : t)\n",
        "        self.student_says(\n",
        "            \"Physics is \\\\\\\\ just weird\",\n",
        "            bubble_config = {\"height\" : 2.5, \"width\" : 3},\n",
        "            target_mode = \"shruggie\",\n",
        "            index = 0,\n",
        "            added_anims = [ApplyMethod(full_formula.shift, UP)]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            wave_propagation,\n",
        "            ApplyMethod(full_formula.shift, DOWN),\n",
        "            FadeOut(self.students[0].bubble),\n",
        "            FadeOut(self.students[0].bubble.content),\n",
        "            self.change_students(*3*[\"pondering\"]),\n",
        "            self.teacher.change, \"pondering\",\n",
        "        )\n",
        "        self.play(wave_propagation)\n",
        "\n",
        "class AskPhysicists(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty, physy1, physy2, physy3 = self.pi_creatures\n",
        "        formula = OldTex(\"p\", \"=\", \"h\", \"\\\\xi\")\n",
        "        formula.set_color_by_tex_to_color_map({\n",
        "            \"p\" : BLUE,\n",
        "            \"\\\\xi\" : YELLOW,\n",
        "        })\n",
        "        formula.scale(1.5)\n",
        "\n",
        "        formula.to_edge(UP)\n",
        "        formula.save_state()\n",
        "        formula.shift(DOWN)\n",
        "        formula.fade(1)\n",
        "        self.play(formula.restore)\n",
        "        self.pi_creature_says(\n",
        "            morty, \"So...why?\",\n",
        "            target_mode = \"maybe\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(morty),\n",
        "            PiCreatureSays(\n",
        "                physy2,\n",
        "                \"Take the Schr\u00f6dinger equation \\\\\\\\ with $H = \\\\frac{p^2}{2m}+V(x)$\",\n",
        "                bubble_config = {\"fill_opacity\" : 0.9},\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                physy1,\n",
        "                \"Even classically position and \\\\\\\\ momentum are conjugate\",\n",
        "                target_mode = \"surprised\",\n",
        "                bubble_config = {\"fill_opacity\" : 0.9},\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                physy3,\n",
        "                \"Consider special relativity \\\\\\\\ together with $E = hf$\",\n",
        "                target_mode = \"hooray\",\n",
        "                bubble_config = {\"fill_opacity\" : 0.9},\n",
        "            ),\n",
        "            morty.change, \"guilty\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        scale_factor = 0.85\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(scale_factor)\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "\n",
        "        physies = VGroup(*[\n",
        "            PiCreature(color = c).flip()\n",
        "            for c in (GREY, GREY_B, GREY_D)\n",
        "        ])\n",
        "        physies.arrange(RIGHT, buff = MED_SMALL_BUFF)\n",
        "        physies.scale(scale_factor)\n",
        "        physies.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.add(physies)\n",
        "        return VGroup(morty, *physies)\n",
        "\n",
        "class SortOfDopplerEffect(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"omega\" : np.pi,\n",
        "        \"arrow_spacing\" : 0.25,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        rect = self.screen_rect = ScreenRectangle(height = FRAME_HEIGHT)\n",
        "        rect.set_stroke(width = 0)\n",
        "        self.camera = MovingCamera(\n",
        "            rect, **self.camera_config\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        screen_rect = self.screen_rect\n",
        "\n",
        "        #x-coordinate gives time\n",
        "        t_tracker = VectorizedPoint()\n",
        "        #x-coordinate gives wave number\n",
        "        k_tracker = VectorizedPoint(2*RIGHT)\n",
        "        always_shift(t_tracker, RIGHT, 1)\n",
        "        def get_wave():\n",
        "            t = t_tracker.get_center()[0]\n",
        "            k = k_tracker.get_center()[0]\n",
        "            omega = self.omega\n",
        "            color = interpolate_color(\n",
        "                BLUE, RED, (k-2)/2.0\n",
        "            )\n",
        "            func = lambda x : 0.5*np.cos(omega*t - k*x)\n",
        "            graph = FunctionGraph(\n",
        "                func,\n",
        "                x_min = -5*FRAME_X_RADIUS,\n",
        "                x_max = FRAME_X_RADIUS,\n",
        "                color = color,\n",
        "            )\n",
        "            return VGroup(graph, *[\n",
        "                Arrow(\n",
        "                    x*RIGHT, x*RIGHT + func(x)*UP, \n",
        "                    color = color\n",
        "                )\n",
        "                for x in np.arange(\n",
        "                    -4*FRAME_X_RADIUS, FRAME_X_RADIUS, \n",
        "                    self.arrow_spacing\n",
        "                )\n",
        "            ])\n",
        "            return \n",
        "        wave = get_wave()\n",
        "        wave_update = Mobject.add_updater(\n",
        "            wave, lambda w : Transform(w, get_wave()).update(1)\n",
        "        )\n",
        "\n",
        "        rect = ScreenRectangle(height = 2)\n",
        "        rect.to_edge(RIGHT)\n",
        "        always_shift(rect, LEFT, 1)\n",
        "        rect_movement = rect\n",
        "\n",
        "        randy = self.pi_creature\n",
        "        randy_look_at = Mobject.add_updater(\n",
        "            randy, lambda r : r.look_at(rect)\n",
        "        )\n",
        "\n",
        "        ref_frame1 = OldTexText(\"Reference frame 1\")\n",
        "        # ref_frame1.next_to(randy, UP, aligned_edge = LEFT)\n",
        "        ref_frame1.to_edge(UP)\n",
        "        ref_frame2 = OldTexText(\"Reference frame 2\")\n",
        "        ref_frame2.next_to(rect, UP)\n",
        "        # ref_frame2.set_fill(opacity = 0)\n",
        "        ref_frame2_follow = Mobject.add_updater(\n",
        "            ref_frame2, lambda m : m.next_to(rect, UP)\n",
        "        )\n",
        "        ref_frame_1_continual_anim = ContinualAnimation(ref_frame1)\n",
        "\n",
        "        self.add(\n",
        "            t_tracker, wave_update, rect_movement, randy_look_at,\n",
        "            ref_frame2_follow, ref_frame_1_continual_anim\n",
        "        )\n",
        "        self.add(ref_frame1)\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.wait(4)\n",
        "        start_height = screen_rect.get_height()\n",
        "        start_center = screen_rect.get_center()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                screen_rect,\n",
        "                lambda m, a : m.move_to(\n",
        "                    interpolate(start_center, rect.get_center(), a)\n",
        "                )\n",
        "            ),\n",
        "            k_tracker.shift, 2*RIGHT,\n",
        "        )\n",
        "        self.play(\n",
        "            MaintainPositionRelativeTo(\n",
        "                screen_rect, rect,\n",
        "                run_time = 4\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            screen_rect.move_to, rect.get_right()+FRAME_X_RADIUS*LEFT,\n",
        "            k_tracker.shift, 2*LEFT,\n",
        "        )\n",
        "\n",
        "        #Frequency words\n",
        "        temporal_frequency = OldTexText(\"Temporal\", \"frequency\")\n",
        "        spatial_frequency = OldTexText(\"Spatial\", \"frequency\")\n",
        "        temporal_frequency.move_to(screen_rect).to_edge(UP)\n",
        "        spatial_frequency.next_to(temporal_frequency, DOWN)\n",
        "        cross = Cross(temporal_frequency[0])\n",
        "\n",
        "        time = OldTexText(\"Time\")\n",
        "        space = OldTexText(\"Space\")\n",
        "        time.next_to(temporal_frequency, RIGHT, buff = 2)\n",
        "        space.next_to(time, DOWN)\n",
        "        space.align_to(spatial_frequency)\n",
        "\n",
        "        self.play(FadeIn(temporal_frequency))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(Write(spatial_frequency))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(time), FadeIn(space))\n",
        "        self.play(\n",
        "            Transform(time, space),\n",
        "            Transform(space, time),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play(FadeOut(time), FadeOut(space))\n",
        "        self.wait(3)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().scale(0.5).to_corner(DOWN+LEFT)\n",
        "\n",
        "class HangingWeightsScene(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"frequency\" : 0.5,\n",
        "        \"ceiling_radius\" : 3*FRAME_X_RADIUS,\n",
        "        \"n_springs\" : 72,\n",
        "        \"amplitude\" : 0.6,\n",
        "        \"spring_radius\" : 0.15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_springs()\n",
        "        self.setup_weights()\n",
        "        self.introduce()\n",
        "        self.show_analogy_with_electron()\n",
        "        self.metaphor_for_something()\n",
        "        self.moving_reference_frame()\n",
        "\n",
        "    def setup_springs(self):\n",
        "        ceiling = self.ceiling = Line(LEFT, RIGHT)\n",
        "        ceiling.scale(self.ceiling_radius)\n",
        "        ceiling.to_edge(UP, buff = LARGE_BUFF)\n",
        "        self.add(ceiling)\n",
        "\n",
        "        def get_spring(alpha, height = 2):\n",
        "            t_max = 6.5\n",
        "            r = self.spring_radius\n",
        "            s = (height - r)/(t_max**2)\n",
        "            spring = ParametricCurve(\n",
        "                lambda t : op.add(\n",
        "                    r*(np.sin(TAU*t)*RIGHT+np.cos(TAU*t)*UP),\n",
        "                    s*((t_max - t)**2)*DOWN,\n",
        "                ),\n",
        "                t_min = 0, t_max = t_max,\n",
        "                color = WHITE,\n",
        "                stroke_width = 2,\n",
        "            )\n",
        "            spring.alpha = alpha\n",
        "            spring.move_to(ceiling.point_from_proportion(alpha), UP)\n",
        "            spring.color_using_background_image(\"grey_gradient\")\n",
        "            return spring\n",
        "        alphas = np.linspace(0, 1, self.n_springs)\n",
        "        bezier([0, 1, 0, 1])\n",
        "        springs = self.springs = VGroup(*list(map(get_spring, alphas)))\n",
        "\n",
        "        k_tracker = self.k_tracker = VectorizedPoint()\n",
        "        t_tracker = self.t_tracker = VectorizedPoint()\n",
        "        always_shift(t_tracker, RIGHT, 1)\n",
        "        self.t_tracker_walk = t_tracker\n",
        "        equilibrium_height = springs.get_height()\n",
        "        def update_springs(springs):\n",
        "            for spring in springs:\n",
        "                k = k_tracker.get_center()[0]\n",
        "                t = t_tracker.get_center()[0]\n",
        "                f = self.frequency\n",
        "                x = spring.get_top()[0]\n",
        "                A = self.amplitude\n",
        "                d_height = A*np.cos(TAU*f*t - k*x)\n",
        "                new_spring = get_spring(spring.alpha, 2+d_height)\n",
        "                Transform(spring, new_spring).update(1)\n",
        "        spring_update_anim = Mobject.add_updater(springs, update_springs)\n",
        "        self.spring_update_anim = spring_update_anim\n",
        "        spring_update_anim.update(0)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ceiling),\n",
        "            LaggedStartMap(ShowCreation, springs)\n",
        "        )\n",
        "\n",
        "    def setup_weights(self):\n",
        "        weights = self.weights = VGroup()\n",
        "        weight_anims = weight_anims = []\n",
        "        for spring in self.springs:\n",
        "            x = spring.get_top()[0]\n",
        "            mass = np.exp(-0.1*x**2)\n",
        "            weight = Circle(radius = 0.15)\n",
        "            weight.start_radius = 0.15\n",
        "            weight.target_radius = 0.25*mass #For future update\n",
        "            weight.spring = spring\n",
        "            weight_anim = Mobject.add_updater(\n",
        "                weight, lambda w : w.move_to(w.spring.get_bottom())\n",
        "            )\n",
        "            weight_anim.update(0)\n",
        "            weight_anims.append(weight_anim)\n",
        "            weights.add(weight)\n",
        "        weights.set_fill(opacity = 1)\n",
        "        weights.set_color_by_gradient(BLUE_D, BLUE_E, BLUE_D)\n",
        "        weights.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, weights))\n",
        "        self.add(self.t_tracker_walk)\n",
        "        self.add(self.spring_update_anim)\n",
        "        self.add(*weight_anims)\n",
        "\n",
        "    def introduce(self):\n",
        "        arrow = Arrow(4*LEFT, LEFT)\n",
        "        arrows = VGroup(arrow, arrow.copy().flip(about_point = ORIGIN))\n",
        "        arrows.set_color(WHITE)\n",
        "\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(GrowArrow, arrows)))\n",
        "        self.play(*[\n",
        "            UpdateFromAlphaFunc(\n",
        "                weight, lambda w, a : w.set_width(\n",
        "                    2*interpolate(w.start_radius, w.target_radius, a)\n",
        "                ),\n",
        "                run_time = 2\n",
        "            )\n",
        "            for weight in self.weights\n",
        "        ])\n",
        "        self.play(FadeOut(arrows))\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_analogy_with_electron(self):\n",
        "        words = OldTexText(\n",
        "            \"Analogous to the energy of a particle \\\\\\\\\",\n",
        "            \"(in the sense of $E=mc^2$)\"\n",
        "        )\n",
        "        words.move_to(DOWN)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(words))\n",
        "\n",
        "    def metaphor_for_something(self):\n",
        "        de_broglie = ImageMobject(\"de_Broglie\")\n",
        "        de_broglie.set_height(3.5)\n",
        "        de_broglie.to_corner(DOWN+RIGHT)\n",
        "        words = OldTexText(\"\"\"\n",
        "            If a photon's energy is carried as a wave \\\\\\\\\n",
        "            is this true for any particle?\n",
        "        \"\"\")\n",
        "        words.next_to(de_broglie, LEFT)\n",
        "\n",
        "        einstein = ImageMobject(\"Einstein\")\n",
        "        einstein.match_height(de_broglie)\n",
        "        einstein.to_corner(DOWN+LEFT)\n",
        "\n",
        "        for picture in de_broglie, einstein:\n",
        "            picture.backdrop = Rectangle()\n",
        "            picture.backdrop.replace(picture, stretch = True)\n",
        "            picture.backdrop.set_fill(BLACK, 1)\n",
        "            picture.backdrop.set_stroke(BLACK, 0)\n",
        "\n",
        "        self.play(\n",
        "            Animation(de_broglie.backdrop, remover = True),\n",
        "            FadeIn(de_broglie)\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            Animation(einstein.backdrop, remover = True),\n",
        "            FadeIn(einstein)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.de_broglie = de_broglie\n",
        "        self.einstein = einstein\n",
        "\n",
        "    def moving_reference_frame(self):\n",
        "        rect = ScreenRectangle(height = 2.1*FRAME_Y_RADIUS)\n",
        "        rect_movement = always_shift(rect, direction = LEFT, rate = 2)\n",
        "        camera_frame = self.camera_frame\n",
        "\n",
        "        self.add(rect)\n",
        "        self.play( \n",
        "            Animation(self.de_broglie.backdrop, remover = True),\n",
        "            FadeOut(self.de_broglie),\n",
        "            Animation(self.einstein.backdrop, remover = True),\n",
        "            FadeOut(self.einstein),\n",
        "        )\n",
        "        self.play(camera_frame.scale, 3, {\"about_point\" : 2*UP})\n",
        "        self.play(rect.shift, FRAME_WIDTH*RIGHT, path_arc = -TAU/2)\n",
        "        self.add(rect_movement)\n",
        "        self.wait(3)\n",
        "\n",
        "        def zoom_into_reference_frame():\n",
        "            original_height = camera_frame.get_height()\n",
        "            original_center = camera_frame.get_center()\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    camera_frame, lambda c, a : c.set_height(\n",
        "                        interpolate(original_height, 0.95*rect.get_height(), a)\n",
        "                    ).move_to(\n",
        "                        interpolate(original_center, rect.get_center(), a)\n",
        "                    )\n",
        "                ),\n",
        "                ApplyMethod(self.k_tracker.shift, RIGHT)\n",
        "            )\n",
        "            self.play(MaintainPositionRelativeTo(\n",
        "                camera_frame, rect,\n",
        "                run_time = 6\n",
        "            ))\n",
        "            self.play(\n",
        "                camera_frame.set_height, original_height,\n",
        "                camera_frame.move_to, original_center,\n",
        "                ApplyMethod(self.k_tracker.shift, LEFT)\n",
        "            )\n",
        "\n",
        "        zoom_into_reference_frame()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(rect, lambda m, a : m.set_stroke(width = 2*(1-a)))\n",
        "        )\n",
        "\n",
        "        index = int(0.5*len(self.springs))\n",
        "        weights = VGroup(self.weights[index], self.weights[index+4])\n",
        "        flashes = list(map(self.get_peak_flash_anim, weights))\n",
        "        weights.save_state()\n",
        "        weights.set_fill(RED)\n",
        "        self.add(*flashes)\n",
        "        self.wait(5)\n",
        "\n",
        "        rect.align_to(camera_frame, RIGHT)\n",
        "        self.play(UpdateFromAlphaFunc(rect, lambda m, a : m.set_stroke(width = 2*a)))\n",
        "\n",
        "        randy = Randolph(mode = \"pondering\")\n",
        "        randy.look(UP+RIGHT)\n",
        "        de_broglie = ImageMobject(\"de_Broglie\")\n",
        "        de_broglie.set_height(6)\n",
        "        de_broglie.next_to(4*DOWN, DOWN)\n",
        "        self.add(\n",
        "            Mobject.add_updater(\n",
        "                randy, lambda m : m.next_to(\n",
        "                    rect.get_corner(DOWN+LEFT), UP+RIGHT, MED_LARGE_BUFF,\n",
        "                ).look_at(weights)\n",
        "            ),\n",
        "            de_broglie\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        zoom_into_reference_frame()\n",
        "        self.wait(8)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_peak_flash_anim(self, weight):\n",
        "        mobject = Mobject() #Dummy\n",
        "        mobject.last_y = 0\n",
        "        mobject.last_dy = 0\n",
        "        mobject.curr_anim = None\n",
        "        mobject.curr_anim_time = 0\n",
        "        mobject.time_since_last_flash = 0\n",
        "        def update(mob, dt):\n",
        "            mob.time_since_last_flash += dt\n",
        "            point = weight.get_center()\n",
        "            y = point[1]\n",
        "            mob.dy = y - mob.last_y\n",
        "            different_dy = np.sign(mob.dy) != np.sign(mob.last_dy)\n",
        "            if different_dy and mob.time_since_last_flash > 0.5:\n",
        "                mob.curr_anim = Flash(\n",
        "                    VectorizedPoint(point),\n",
        "                    flash_radius = 0.5,\n",
        "                    line_length = 0.3,\n",
        "                    run_time = 0.2,\n",
        "                )\n",
        "                mob.submobjects = [mob.curr_anim.mobject]\n",
        "                mob.time_since_last_flash = 0\n",
        "            mob.last_y = float(y)\n",
        "            mob.last_dy = float(mob.dy)\n",
        "            ##\n",
        "            if mob.curr_anim:\n",
        "                mob.curr_anim_time += dt\n",
        "                if mob.curr_anim_time > mob.curr_anim.run_time:\n",
        "                    mob.curr_anim = None\n",
        "                    mob.submobjects = []\n",
        "                    mob.curr_anim_time = 0\n",
        "                    return\n",
        "                mob.curr_anim.update(mob.curr_anim_time/mob.curr_anim.run_time)\n",
        "\n",
        "        return Mobject.add_updater(mobject, update)\n",
        "\n",
        "class MinutPhysicsWrapper(Scene):\n",
        "    def construct(self):\n",
        "        logo = ImageMobject(\"minute_physics_logo\", invert = True)\n",
        "        logo.to_corner(UP+LEFT)\n",
        "        self.add(logo)\n",
        "\n",
        "        title = OldTexText(\"Minute Physics on special relativity\")\n",
        "        title.to_edge(UP).shift(MED_LARGE_BUFF*RIGHT)\n",
        "\n",
        "        screen_rect = ScreenRectangle()\n",
        "        screen_rect.set_width(title.get_width() + LARGE_BUFF)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.play(Write(title))\n",
        "        self.wait(2)\n",
        "\n",
        "class WhatDoesTheFourierTradeoffTellUs(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"So! What does \\\\\\\\ the Fourier trade-off \\\\\\\\ tell us?\",\n",
        "            target_mode = \"surprised\",\n",
        "            bubble_config = {\"width\" : 4, \"height\" : 3}\n",
        "        )\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(4)\n",
        "\n",
        "class FourierTransformOfWaveFunction(Scene):\n",
        "    CONFIG = {\n",
        "        \"wave_stroke_width\" : 3,\n",
        "        \"wave_color\" : BLUE,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_wave_packet()\n",
        "        self.take_fourier_transform()\n",
        "        self.show_correlations_with_pure_frequencies()\n",
        "        self.this_is_momentum()\n",
        "        self.show_tradeoff()\n",
        "\n",
        "    def setup(self):\n",
        "        self.x0_tracker = ValueTracker(-3)\n",
        "        self.k_tracker = ValueTracker(1)\n",
        "        self.a_tracker = ExponentialValueTracker(0.5)\n",
        "\n",
        "    def show_wave_packet(self):\n",
        "        axes = Axes(\n",
        "            x_min = 0, x_max = 12,\n",
        "            y_min = -1, y_max = 1,\n",
        "            y_axis_config = {\n",
        "                \"tick_frequency\" : 0.5\n",
        "            }\n",
        "        )\n",
        "        position_label = OldTexText(\"Position\")\n",
        "        position_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        axes.add(position_label)\n",
        "        axes.center().to_edge(UP, buff = LARGE_BUFF)\n",
        "\n",
        "        wave = self.get_wave(axes)\n",
        "        wave_update_animation = UpdateFromFunc(\n",
        "            wave, lambda w : Transform(w, self.get_wave(axes)).update(1)\n",
        "        )\n",
        "\n",
        "        self.add(axes, wave)\n",
        "        self.play(\n",
        "            self.x0_tracker.set_value, 5,\n",
        "            wave_update_animation,\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.wave_function = wave.underlying_function\n",
        "        self.wave_update_animation = wave_update_animation\n",
        "        self.wave = wave\n",
        "        self.axes = axes\n",
        "\n",
        "    def take_fourier_transform(self):\n",
        "        wave = self.wave\n",
        "        wave_update_animation = self.wave_update_animation\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0, x_max = 3,\n",
        "            x_axis_config = {\n",
        "                \"unit_size\" : 4,\n",
        "                \"tick_frequency\" : 0.25,\n",
        "                \"big_tick_numbers\" : [1, 2]\n",
        "            },\n",
        "            y_min = -0.15,\n",
        "            y_max = 0.15,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 7.5,\n",
        "                \"tick_frequency\" : 0.05,\n",
        "            }\n",
        "        )\n",
        "        label = self.frequency_x_axis_label = OldTexText(\"Spatial frequency\")\n",
        "        label.next_to(frequency_axes.x_axis.get_right(), UP)\n",
        "        frequency_axes.add(label)\n",
        "        frequency_axes.move_to(self.axes, LEFT)\n",
        "        frequency_axes.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        label.shift_onto_screen()\n",
        "\n",
        "        def get_wave_function_fourier_graph():\n",
        "            return get_fourier_graph(\n",
        "                frequency_axes, self.get_wave_func(),\n",
        "                t_min = 0, t_max = 15,\n",
        "            )\n",
        "        fourier_graph = get_wave_function_fourier_graph()\n",
        "        self.fourier_graph_update_animation = UpdateFromFunc(\n",
        "            fourier_graph, lambda m : Transform(\n",
        "                m, get_wave_function_fourier_graph()\n",
        "            ).update(1)\n",
        "        )\n",
        "\n",
        "        wave_copy = wave.copy()\n",
        "        wave_copy.generate_target()\n",
        "        wave_copy.target.move_to(fourier_graph, LEFT)\n",
        "        wave_copy.target.fade(1)\n",
        "        fourier_graph.save_state()\n",
        "        fourier_graph.move_to(wave, LEFT)\n",
        "        fourier_graph.fade(1)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            self.axes.coords_to_point(5, -1),\n",
        "            frequency_axes.coords_to_point(1, 0.1),\n",
        "            color = YELLOW,\n",
        "        )\n",
        "        fourier_label = OldTexText(\"Fourier Transform\")\n",
        "        fourier_label.next_to(arrow.get_center(), RIGHT)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.axes.copy(), frequency_axes\n",
        "        ))\n",
        "        self.play(\n",
        "            MoveToTarget(wave_copy, remover = True),\n",
        "            fourier_graph.restore,\n",
        "            GrowArrow(arrow),\n",
        "            Write(fourier_label, run_time = 1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.frequency_axes = frequency_axes\n",
        "        self.fourier_graph = fourier_graph\n",
        "        self.fourier_label = VGroup(arrow, fourier_label)\n",
        "\n",
        "    def show_correlations_with_pure_frequencies(self):\n",
        "        frequency_axes = self.frequency_axes\n",
        "        axes = self.axes\n",
        "\n",
        "        sinusoid = axes.get_graph(\n",
        "            lambda x : 0.5*np.cos(TAU*x),\n",
        "            x_min = -FRAME_X_RADIUS, x_max = 3*FRAME_X_RADIUS,\n",
        "        )\n",
        "        sinusoid.to_edge(UP, buff = SMALL_BUFF)\n",
        "\n",
        "        v_line = DashedLine(1.5*UP, ORIGIN, color = YELLOW)\n",
        "        v_line.move_to(frequency_axes.coords_to_point(1, 0), DOWN)\n",
        "\n",
        "        f_equals = OldTex(\"f = \")\n",
        "        freq_decimal = DecimalNumber(1)\n",
        "        freq_decimal.next_to(f_equals, RIGHT, buff = SMALL_BUFF)\n",
        "        freq_label = VGroup(f_equals, freq_decimal)\n",
        "        freq_label.next_to(\n",
        "            v_line, UP, SMALL_BUFF, \n",
        "            submobject_to_align = f_equals[0]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sinusoid),\n",
        "            ShowCreation(v_line),\n",
        "            Write(freq_label, run_time = 1),\n",
        "            FadeOut(self.fourier_label)\n",
        "        )\n",
        "        last_f = 1\n",
        "        for f in 1.4, 0.7, 1:\n",
        "            self.play(\n",
        "                sinusoid.stretch,f/last_f, 0, \n",
        "                    {\"about_point\" : axes.coords_to_point(0, 0)},\n",
        "                v_line.move_to, frequency_axes.coords_to_point(f, 0), DOWN,\n",
        "                MaintainPositionRelativeTo(freq_label, v_line),\n",
        "                ChangeDecimalToValue(freq_decimal, f),\n",
        "                run_time = 3,\n",
        "            )\n",
        "            last_f = f\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            sinusoid, v_line,  freq_label\n",
        "        ])))\n",
        "\n",
        "    def this_is_momentum(self):\n",
        "        formula = OldTex(\"p\", \"=\", \"h\", \"\\\\xi\")\n",
        "        formula.set_color_by_tex_to_color_map({\n",
        "            \"p\" : BLUE,\n",
        "            \"xi\" : YELLOW,\n",
        "        })\n",
        "        formula.next_to(\n",
        "            self.frequency_x_axis_label, UP\n",
        "        )\n",
        "\n",
        "        f_max = 0.12\n",
        "        brace = Brace(Line(2*LEFT, 2*RIGHT), UP)\n",
        "        brace.move_to(self.frequency_axes.coords_to_point(1, f_max), DOWN)\n",
        "        words = OldTexText(\"This wave \\\\\\\\ describes momentum\")\n",
        "        words.next_to(brace, UP)\n",
        "\n",
        "        self.play(Write(formula))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        brace.add(words)\n",
        "        for k in 2, 0.5, 1:\n",
        "            self.play(\n",
        "                self.k_tracker.set_value, k,\n",
        "                self.wave_update_animation,\n",
        "                self.fourier_graph_update_animation,\n",
        "                UpdateFromFunc(\n",
        "                    brace, lambda b : b.move_to(\n",
        "                        self.frequency_axes.coords_to_point(\n",
        "                            self.k_tracker.get_value(),\n",
        "                            f_max,\n",
        "                        ),\n",
        "                        DOWN\n",
        "                    )\n",
        "                ),\n",
        "                run_time = 2\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, words, formula])))\n",
        "\n",
        "    def show_tradeoff(self):\n",
        "        for a in 5, 0.1, 0.01, 10, 0.5:\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    self.a_tracker.set_value, a,\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                self.wave_update_animation,\n",
        "                self.fourier_graph_update_animation\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_wave_func(self):\n",
        "        x0 = self.x0_tracker.get_value()\n",
        "        k = self.k_tracker.get_value()\n",
        "        a = self.a_tracker.get_value()\n",
        "        A = a**(0.25)\n",
        "        return lambda x : A*np.cos(TAU*k*x)*np.exp(-a*(x - x0)**2)\n",
        "\n",
        "    def get_wave(self, axes):\n",
        "        return axes.get_graph(\n",
        "            self.get_wave_func(), \n",
        "            color = self.wave_color,\n",
        "            stroke_width = self.wave_stroke_width\n",
        "        )\n",
        "\n",
        "class DopplerComparisonTodos(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"\"\"\n",
        "            Insert some Doppler footage, \n",
        "            insert some hanging spring scene,\n",
        "            insert position-momentum Fourier trade-off\n",
        "        \"\"\"\n",
        "    }\n",
        "\n",
        "class MusicalNote(AddingPureFrequencies):\n",
        "    def construct(self):\n",
        "        speaker = self.speaker = SVGMobject(file_name = \"speaker\")\n",
        "        speaker.move_to(2*DOWN)\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min = 0, x_max = 10,\n",
        "            y_min = -1.5, y_max = 1.5\n",
        "        )\n",
        "        axes.center().to_edge(UP)\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        axes.add(time_label)\n",
        "\n",
        "        graph = axes.get_graph(\n",
        "            lambda x : op.mul(\n",
        "                np.exp(-0.2*(x-4)**2),\n",
        "                0.3*(np.cos(2*TAU*x) + np.cos(3*TAU*x) + np.cos(5*TAU*x)),\n",
        "            ),\n",
        "        )\n",
        "        graph.set_color(BLUE)\n",
        "        v_line = DashedLine(ORIGIN, 0.5*UP)\n",
        "        v_line_update = UpdateFromFunc(\n",
        "            v_line, lambda l : l.put_start_and_end_on_with_projection(\n",
        "                graph.get_points()[-1],\n",
        "                axes.x_axis.number_to_point(\n",
        "                    axes.x_axis.point_to_number(graph.get_points()[-1])\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(speaker, axes)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\",\n",
        "            self.get_broadcast_animation(n_circles = 6, run_time  = 5),\n",
        "            self.get_broadcast_animation(n_circles = 12, run_time = 5),\n",
        "            ShowCreation(graph, run_time = 5, rate_func=linear),\n",
        "            v_line_update\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class AskAboutUncertainty(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What does this have \\\\\\\\ to do with ``certainty''\",\n",
        "            bubble_config = {\"direction\" : LEFT},\n",
        "            index = 2\n",
        "        )\n",
        "        self.play(PiCreatureSays(\n",
        "            self.students[0], \n",
        "            \"What even are \\\\\\\\ these waves?\",\n",
        "            target_mode = \"confused\"\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class ProbabalisticDetection(FourierTransformOfWaveFunction):\n",
        "    CONFIG = {\n",
        "        \"wave_stroke_width\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_wave()\n",
        "        self.detect_only_single_points()\n",
        "        self.show_probability_distribution()\n",
        "        self.show_concentration_of_the_wave()\n",
        "\n",
        "    def setup_wave(self):\n",
        "        axes = Axes(\n",
        "            x_min = 0, x_max = 10,\n",
        "            y_min = -0.5, y_max = 1.5,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 1.5,\n",
        "                \"tick_frequency\" : 0.25,\n",
        "            }\n",
        "        )\n",
        "        axes.set_stroke(width = 2)\n",
        "        axes.center()\n",
        "        self.x0_tracker.set_value(5)\n",
        "        self.k_tracker.set_value(1)\n",
        "        self.a_tracker.set_value(0.2)\n",
        "        wave = self.get_wave(axes)\n",
        "        self.wave_update_animation = UpdateFromFunc(\n",
        "            wave, lambda w : Transform(w, self.get_wave(axes)).update(1)\n",
        "        )\n",
        "\n",
        "        self.k_tracker.save_state()\n",
        "        self.k_tracker.set_value(0)\n",
        "        bell_curve = self.get_wave(axes)\n",
        "        self.k_tracker.restore()\n",
        "        bell_curve.set_stroke(width = 0)\n",
        "        bell_curve.set_fill(BLUE, opacity = 0.5)\n",
        "        squared_bell_curve = axes.get_graph(\n",
        "            lambda x : bell_curve.underlying_function(x)**2\n",
        "        ).match_style(bell_curve)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            axes, wave, bell_curve, squared_bell_curve\n",
        "        )\n",
        "\n",
        "    def detect_only_single_points(self):\n",
        "        particle = ProbabalisticDotCloud(\n",
        "            n_copies = 100, \n",
        "            fill_opacity = 0.05, \n",
        "            time_per_change = 0.05,\n",
        "        )\n",
        "        particle.mobject[0].set_fill(BLUE, opacity = 1)\n",
        "        gdw = particle.gaussian_distribution_wrapper\n",
        "\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            height = 0.5,\n",
        "            width = 2,\n",
        "        )\n",
        "        rect.set_fill(YELLOW, 0.3)\n",
        "        rect.move_to(self.axes.coords_to_point(self.x0_tracker.get_value(), 0))\n",
        "        brace = Brace(rect, UP, buff = 0)\n",
        "        question = OldTexText(\"Do we detect the particle \\\\\\\\ in this region?\")\n",
        "        question.next_to(brace, UP)\n",
        "        question.add_background_rectangle()\n",
        "        rect.save_state()\n",
        "        rect.stretch(0, 0)\n",
        "\n",
        "        gdw_anim = Mobject.add_updater(\n",
        "            gdw, lambda m : m.set_width(\n",
        "                2.0/(self.a_tracker.get_value()**(0.5))\n",
        "            ).move_to(rect)\n",
        "        )\n",
        "\n",
        "        self.add(rect, brace, question)\n",
        "\n",
        "        yes = OldTexText(\"Yes\").set_color(GREEN)\n",
        "        no = OldTexText(\"No\").set_color(RED)\n",
        "        for word in yes, no:\n",
        "            word.next_to(rect, DOWN)\n",
        "            # word.add_background_rectangle()\n",
        "        answer = VGroup()\n",
        "        def update_answer(answer):\n",
        "            px = particle.mobject[0].get_center()[0]\n",
        "            lx = rect.get_left()[0]\n",
        "            rx = rect.get_right()[0]\n",
        "            if lx < px < rx:\n",
        "                answer.submobjects = [yes]\n",
        "            else:\n",
        "                answer.submobjects = [no]\n",
        "        answer_anim = Mobject.add_updater(answer, update_answer)\n",
        "\n",
        "        self.add(gdw_anim, particle)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            rect.restore,\n",
        "            Write(question)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(answer_anim)\n",
        "        self.wait(4)\n",
        "        self.add_foreground_mobjects(answer, particle.mobject)\n",
        "\n",
        "        self.question_group = VGroup(question, brace)\n",
        "        self.particle = particle\n",
        "        self.rect = rect\n",
        "\n",
        "    def show_probability_distribution(self):\n",
        "        axes = self.axes\n",
        "        wave = self.wave\n",
        "        bell_curve = self.bell_curve\n",
        "        question_group = self.question_group\n",
        "        gdw = self.particle.gaussian_distribution_wrapper\n",
        "        rect = self.rect\n",
        "\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(ORIGIN, 3*UP).move_to(point, DOWN)\n",
        "            for point in (rect.get_left(), rect.get_right())\n",
        "        ])\n",
        "        \n",
        "        self.play(\n",
        "            FadeIn(VGroup(axes, wave)),\n",
        "            question_group.next_to, v_lines, UP, {\"buff\" : 0},\n",
        "            *list(map(ShowCreation, v_lines))\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    def show_concentration_of_the_wave(self):\n",
        "        self.play(\n",
        "            self.a_tracker.set_value, 5,\n",
        "            self.wave_update_animation,\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "class HeisenbergCommentTodos(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert position-momentum trade-off\"\n",
        "    }\n",
        "\n",
        "class HeisenbergPetPeeve(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty, other = self.pi_creatures\n",
        "        particle = ProbabalisticDotCloud()\n",
        "        gdw = particle.gaussian_distribution_wrapper\n",
        "        gdw.to_edge(UP, buff = LARGE_BUFF)\n",
        "        gdw.stretch_to_fit_width(3)\n",
        "        gdw.rotate(3*DEGREES)\n",
        "\n",
        "        self.add(particle)\n",
        "        self.wait()\n",
        "        self.play(PiCreatureSays(\n",
        "            other, \"\"\"\n",
        "            According to the H.U.P., the \\\\\\\\\n",
        "            universe is unknowable!\n",
        "            \"\"\",\n",
        "            target_mode = \"speaking\"\n",
        "        ))\n",
        "        self.play(morty.change, \"angry\")\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                morty, \"Well, yes and no\",\n",
        "                target_mode = \"sassy\",\n",
        "            ),\n",
        "            RemovePiCreatureBubble(\n",
        "                other, target_mode = \"erm\"\n",
        "            )\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    ###\n",
        "    def create_pi_creatures(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        other = PiCreature(color = MAROON_E)\n",
        "        other.to_edge(DOWN).shift(3*LEFT)\n",
        "        return VGroup(morty, other)\n",
        "\n",
        "class OneLevelDeeper(Scene):\n",
        "    def construct(self):\n",
        "        heisenberg = ImageMobject(\"Heisenberg\")\n",
        "        heisenberg.to_corner(UP+LEFT)\n",
        "        self.add(heisenberg)\n",
        "\n",
        "        hup_words = OldTexText(\"Heisenberg's uncertainty principle\")\n",
        "        wave_words = OldTexText(\"Interpretation of the wave function\")\n",
        "        arrow = Vector(UP)\n",
        "        group = VGroup(hup_words, arrow, wave_words)\n",
        "        group.arrange(DOWN)\n",
        "\n",
        "        randomness = ProbabalisticMobjectCloud(\n",
        "            OldTexText(\"Randomness\"),\n",
        "            n_copies = 5,\n",
        "            time_per_change = 0.05\n",
        "        )\n",
        "        gdw = randomness.gaussian_distribution_wrapper\n",
        "        gdw.rotate(TAU/4)\n",
        "        gdw.set_height(1)\n",
        "        # gdw.set_width(4)\n",
        "        gdw.next_to(hup_words, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(hup_words, randomness)\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            FadeIn(wave_words),\n",
        "            GrowArrow(arrow),\n",
        "            ApplyMethod(\n",
        "                gdw.next_to, wave_words, DOWN, MED_LARGE_BUFF,\n",
        "                path_arc = TAU/2,\n",
        "            )\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "class BetterTranslation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        english_term = OldTexText(\"Uncertainty principle\")\n",
        "        german_word = OldTexText(\"Unsch\u00e4rferelation\")\n",
        "        translation = OldTexText(\"Unsharpness relation\")\n",
        "\n",
        "        to_german_words = OldTexText(\"In German\")\n",
        "        to_german_words.scale(0.5)\n",
        "        to_german_arrow = Vector(DOWN, color = WHITE, buff = SMALL_BUFF)\n",
        "        to_german_words.next_to(to_german_arrow, RIGHT, SMALL_BUFF)\n",
        "        to_german_words.set_color(YELLOW)\n",
        "        to_german_group = VGroup(to_german_arrow, to_german_words)\n",
        "\n",
        "        translation_words = OldTexText(\"Literal translation\")\n",
        "        translation_words.scale(0.5)\n",
        "        translation_arrow = Vector(DOWN, color = WHITE, buff = SMALL_BUFF)\n",
        "        translation_words.next_to(translation_arrow, LEFT, SMALL_BUFF)\n",
        "        translation_words.set_color(YELLOW)\n",
        "        translation_group = VGroup(translation_arrow, translation_words)\n",
        "\n",
        "        english_term.next_to(self.teacher, UP+LEFT)\n",
        "        english_term.save_state()\n",
        "        english_term.shift(DOWN)\n",
        "        english_term.fade(1)\n",
        "        self.play(\n",
        "            english_term.restore,\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        german_word.move_to(english_term)\n",
        "        to_german_group.next_to(\n",
        "            german_word, UP,\n",
        "            submobject_to_align = to_german_arrow\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\", \n",
        "            english_term.next_to, to_german_arrow, UP\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(to_german_arrow),\n",
        "            FadeIn(to_german_words),\n",
        "            ReplacementTransform(\n",
        "                english_term.copy().fade(1),\n",
        "                german_word\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        group = VGroup(english_term, to_german_group, german_word)\n",
        "        translation.move_to(german_word)\n",
        "        translation_group.next_to(\n",
        "            german_word, UP,\n",
        "            submobject_to_align = translation_arrow\n",
        "        )\n",
        "        self.play(\n",
        "            group.next_to, translation_arrow, UP,\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(translation_arrow),\n",
        "            FadeIn(translation_words),\n",
        "            ReplacementTransform(\n",
        "                german_word.copy().fade(1),\n",
        "                translation\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class ThinkOfHeisenbergUncertainty(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.center().to_edge(DOWN).shift(LEFT)\n",
        "\n",
        "        dot_cloud = ProbabalisticDotCloud()\n",
        "        dot_gdw = dot_cloud.gaussian_distribution_wrapper\n",
        "        dot_gdw.set_width(1)\n",
        "        dot_gdw.rotate(TAU/8)\n",
        "        dot_gdw.move_to(FRAME_X_RADIUS*RIGHT/2),\n",
        "\n",
        "        vector_cloud = ProbabalisticVectorCloud(\n",
        "            center_func = dot_gdw.get_center\n",
        "        )\n",
        "        vector_gdw = vector_cloud.gaussian_distribution_wrapper\n",
        "        vector_gdw.set_width(0.1)\n",
        "        vector_gdw.rotate(TAU/8)\n",
        "        vector_gdw.next_to(dot_gdw, UP+LEFT, LARGE_BUFF)\n",
        "\n",
        "        time_tracker = ValueTracker(0)\n",
        "        self.add()\n",
        "        freq = 1\n",
        "        continual_anims = [\n",
        "            always_shift(time_tracker, direction = RIGHT, rate = 1),\n",
        "            Mobject.add_updater(\n",
        "                dot_gdw,\n",
        "                lambda d : d.set_width(\n",
        "                    (np.cos(freq*time_tracker.get_value()) + 1.1)/2\n",
        "                )\n",
        "            ),\n",
        "            Mobject.add_updater(\n",
        "                vector_gdw,\n",
        "                lambda d : d.set_width(\n",
        "                    (-np.cos(freq*time_tracker.get_value()) + 1.1)/2\n",
        "                )\n",
        "            ),\n",
        "            dot_cloud, vector_cloud\n",
        "        ]\n",
        "        self.add(*continual_anims)\n",
        "\n",
        "        position, momentum, time, frequency = list(map(TexText, [\n",
        "            \"Position\", \"Momentum\", \"Time\", \"Frequency\"\n",
        "        ]))\n",
        "        VGroup(position, time).set_color(BLUE)\n",
        "        VGroup(momentum, frequency).set_color(YELLOW)\n",
        "        groups = VGroup()\n",
        "        for m1, m2 in (position, momentum), (time, frequency):\n",
        "            arrow = OldTex(\"\\\\updownarrow\").scale(1.5)\n",
        "            group = VGroup(m1, arrow, m2)\n",
        "            group.arrange(DOWN)\n",
        "            lp, rp = parens = OldTex(\"\\\\big(\\\\big)\")\n",
        "            parens.stretch(1.5, 1)\n",
        "            parens.match_height(group)\n",
        "            lp.next_to(group, LEFT, buff = SMALL_BUFF)\n",
        "            rp.next_to(group, RIGHT, buff = SMALL_BUFF)\n",
        "            group.add(parens)\n",
        "            groups.add(group)\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\").scale(2)\n",
        "        groups.submobjects.insert(1, arrow)\n",
        "        groups.arrange(RIGHT)\n",
        "        groups.next_to(morty, UP+RIGHT, LARGE_BUFF)\n",
        "        groups.shift_onto_screen()\n",
        "\n",
        "\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            morty, \"Heisenberg \\\\\\\\ uncertainty \\\\\\\\ principle\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            bubble_config = {\"height\" : 4, \"width\" : 4, \"direction\" : RIGHT},\n",
        "            target_mode = \"pondering\"\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"confused\", dot_gdw)\n",
        "        self.wait(10)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VGroup(dot_gdw, vector_gdw ).shift, \n",
        "                FRAME_X_RADIUS*RIGHT,\n",
        "                rate_func = running_start\n",
        "            )\n",
        "        )\n",
        "        self.remove(*continual_anims)\n",
        "        self.play(\n",
        "            morty.change, \"raise_left_hand\", groups,\n",
        "            FadeIn(\n",
        "                groups, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "# End things\n",
        "\n",
        "class PatreonMention(PatreonThanks):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "\n",
        "        patreon_logo = PatreonLogo()\n",
        "        patreon_logo.to_edge(UP)\n",
        "\n",
        "        thank_you = OldTexText(\"Thank you.\")\n",
        "        thank_you.next_to(patreon_logo, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(patreon_logo),\n",
        "            morty.change, \"gracious\"\n",
        "        )\n",
        "        self.play(Write(thank_you))\n",
        "        self.wait(3)\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        aops_logo = AoPSLogo()\n",
        "        aops_logo.next_to(self.pi_creature, UP+LEFT)\n",
        "        url = OldTexText(\n",
        "            \"AoPS.com/\", \"3b1b\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        url.to_corner(UP+LEFT)\n",
        "        url_rect = Rectangle(color = BLUE)\n",
        "        url_rect.replace(\n",
        "            url.get_part_by_tex(\"3b1b\"),\n",
        "            stretch = True\n",
        "        )\n",
        "\n",
        "        url_rect.stretch_in_place(1.1, dim = 1)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(4.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "        rect.set_stroke(width = 0)\n",
        "        mathy = Mathematician()\n",
        "        mathy.flip()\n",
        "        mathy.to_corner(DOWN+RIGHT)\n",
        "        morty = self.pi_creature\n",
        "        morty.save_state()\n",
        "        book = ImageMobject(\"AoPS_volume_2\")\n",
        "        book.set_height(2)\n",
        "        book.next_to(mathy, UP+LEFT).shift(MED_LARGE_BUFF*LEFT)\n",
        "        mathy.get_center = mathy.get_top\n",
        "\n",
        "        words = OldTexText(\"\"\"\n",
        "            Interested in working for \\\\\\\\ \n",
        "            one of my favorite math\\\\\\\\ \n",
        "            education companies?\n",
        "        \"\"\", alignment = \"\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            aops_logo.get_top(),\n",
        "            morty.get_top(),\n",
        "            path_arc = -0.4*TAU,\n",
        "            stroke_width = 5,\n",
        "            tip_length = 0.5,\n",
        "        )\n",
        "        arrow.tip.shift(SMALL_BUFF*DOWN)\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "            *[\n",
        "                DrawBorderThenFill(\n",
        "                    submob,\n",
        "                    run_time = 2,\n",
        "                    rate_func = squish_rate_func(double_smooth, a, a+0.5)\n",
        "                )\n",
        "                for submob, a in zip(aops_logo, np.linspace(0, 0.5, len(aops_logo)))\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            words.scale, 0.75,\n",
        "            words.next_to, url, DOWN, LARGE_BUFF,\n",
        "            words.shift_onto_screen,\n",
        "            Write(url),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyFunction, aops_logo,\n",
        "                lambda mob : (lambda m : m.shift(0.2*UP).set_color(YELLOW), mob),\n",
        "                rate_func = there_and_back, \n",
        "                run_time = 1,\n",
        "            ),\n",
        "            morty.change, \"thinking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(FadeOut(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # To teacher\n",
        "        self.play(\n",
        "            morty.change_mode, \"plain\",\n",
        "            morty.flip,\n",
        "            morty.scale, 0.7,\n",
        "            morty.next_to, mathy, LEFT, LARGE_BUFF,\n",
        "            morty.to_edge, DOWN,\n",
        "            FadeIn(mathy),\n",
        "        )\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                mathy, \"\",\n",
        "                bubble_config = {\"width\" : 5},\n",
        "                look_at = morty.eyes,\n",
        "            ),\n",
        "            morty.change, \"happy\",\n",
        "            aops_logo.shift, 1.5*UP + 0.5*RIGHT\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                mathy, target_mode = \"raise_right_hand\"\n",
        "            ),\n",
        "            aops_logo.to_corner, UP+RIGHT,\n",
        "            aops_logo.shift, MED_SMALL_BUFF*DOWN,\n",
        "            GrowFromPoint(book, mathy.get_corner(UP+LEFT)),\n",
        "        )\n",
        "        self.play(morty.change, \"pondering\", book)\n",
        "        self.wait(3)\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Animation(\n",
        "                BackgroundRectangle(book, fill_opacity = 1),\n",
        "                remover = True\n",
        "            ),\n",
        "            FadeOut(book),\n",
        "        )\n",
        "        print(self.num_plays)\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            ShowCreation(rect),\n",
        "            morty.restore,\n",
        "            morty.change, \"happy\", rect,\n",
        "            FadeOut(mathy),\n",
        "        )\n",
        "        self.wait(10)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(\n",
        "            FadeOut(url_rect),\n",
        "            url.get_part_by_tex(\"3b1b\").set_color, BLUE,\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "class PuzzleStatement(Scene):\n",
        "    def construct(self):\n",
        "        aops_logo = AoPSLogo()\n",
        "        url = OldTexText(\"AoPS.com/3b1b\")\n",
        "        url.next_to(aops_logo, UP)\n",
        "        group = VGroup(aops_logo, url)\n",
        "        group.to_edge(UP)\n",
        "        self.add(group)\n",
        "\n",
        "        words = OldTexText(\"\"\"\n",
        "            AoPS must choose one of 20 people to send to a \n",
        "            tug-of-war tournament.  We don't care who we send, \n",
        "            as long as we don't send our weakest person. \\\\\\\\ \\\\\\\\\n",
        "\n",
        "            Each person has a different strength, but we don't know \n",
        "            those strengths.  We get 10 intramural 10-on-10 matches \n",
        "            to determine who we send.  Can we make sure we don't send\n",
        "             the weakest person?\n",
        "        \"\"\", alignment = \"\")\n",
        "        words.set_width(FRAME_WIDTH - 2)\n",
        "        words.next_to(group, DOWN, LARGE_BUFF)\n",
        "        self.play(LaggedStartMap(FadeIn, words, run_time = 5, lag_ratio = 0.2))\n",
        "        self.wait(2)\n",
        "\n",
        "class UncertaintyEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"CrypticSwarm\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Juan Benet\",\n",
        "            \"Markus Persson\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Sh\u00ecm\u00edn Kuang\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Robert Teed\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Mark Govea\",\n",
        "            \"John Haley\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Desmos  \",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Randall Hunt\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Awoo\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Linh Tran\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James   H. Park\",\n",
        "            \"Ankalagon   \",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Eric Chow\",\n",
        "            \"Michael Gardner\",\n",
        "            \"David Kedmey\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"supershabam \",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Ross Garber\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Isak Hietala\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"David B\",\n",
        "            \"Delton Ding\",\n",
        "            \"James Thornton\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"George Chiesa\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Alexander Feldman\",\n",
        "            \"David MacCumber\",\n",
        "            \"Jacob Kohl\",\n",
        "            \"Frank Secilia\",\n",
        "            \"George John\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Michael Kunze\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Andrejs olins\",\n",
        "            \"Cody Brocious\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        uncertainty_principle = OldTexText(\"Uncertainty \\\\\\\\\", \"principle\")\n",
        "        uncertainty_principle[1].shift(SMALL_BUFF*UP)\n",
        "        quantum = OldTexText(\"Quantum\")\n",
        "        VGroup(uncertainty_principle, quantum).scale(2.5)\n",
        "        uncertainty_principle.to_edge(UP, MED_LARGE_BUFF)\n",
        "        quantum.to_edge(DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        arrow = OldTex(\"\\\\Downarrow\")\n",
        "        arrow.scale(4)\n",
        "        arrow.move_to(Line(\n",
        "            uncertainty_principle.get_bottom(),\n",
        "            quantum.get_top(),\n",
        "        ))\n",
        "\n",
        "        cross = Cross(arrow)\n",
        "        cross.set_stroke(RED, 20)\n",
        "\n",
        "        is_word, not_word = is_not = OldTexText(\"is\", \"\\\\emph{NOT}\")\n",
        "        is_not.scale(3)\n",
        "        is_word.move_to(arrow)\n",
        "        # is_word.shift(0.6*UP)\n",
        "        not_word.set_color(RED)\n",
        "        not_word.set_stroke(RED, 3)\n",
        "        not_word.rotate(10*DEGREES, about_edge = DOWN+LEFT)\n",
        "        not_word.next_to(is_word, DOWN, 0.1*SMALL_BUFF)\n",
        "\n",
        "        dot_cloud = ProbabalisticDotCloud(\n",
        "            n_copies = 1000,\n",
        "        )\n",
        "        dot_gdw = dot_cloud.gaussian_distribution_wrapper\n",
        "        # dot_gdw.rotate(3*DEGREES)\n",
        "        dot_gdw.rotate(25*DEGREES)\n",
        "        # dot_gdw.scale(2)\n",
        "        dot_gdw.scale(2)\n",
        "        # dot_gdw.move_to(quantum.get_bottom()+SMALL_BUFF*DOWN)\n",
        "        dot_gdw.move_to(quantum)\n",
        "\n",
        "\n",
        "\n",
        "        def get_func(a):\n",
        "            return lambda t : 0.5*np.exp(-a*t**2)*np.cos(TAU*t)\n",
        "        axes = Axes(\n",
        "            x_min = -6, x_max = 6,\n",
        "            x_axis_config = {\"unit_size\" : 0.25}\n",
        "        )\n",
        "        graphs = VGroup(*[\n",
        "            axes.get_graph(get_func(a))\n",
        "            for a in (10, 3, 1, 0.3, 0.1,)\n",
        "        ])\n",
        "        graphs.arrange(DOWN, buff = 0.6)\n",
        "        graphs.to_corner(UP+LEFT)\n",
        "        graphs.set_color_by_gradient(BLUE_B, BLUE_D)\n",
        "\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0, x_max = 2,\n",
        "            x_axis_config = {\"unit_size\" : 1}\n",
        "        )\n",
        "        fourier_graphs = VGroup(*[\n",
        "            get_fourier_graph(\n",
        "                frequency_axes, graph.underlying_function,\n",
        "                t_min = -10, t_max = 10,\n",
        "            )\n",
        "            for graph in graphs\n",
        "        ])\n",
        "        for graph, fourier_graph in zip(graphs, fourier_graphs):\n",
        "            fourier_graph.pointwise_become_partial(fourier_graph, 0.02, 0.06)\n",
        "            fourier_graph.scale(3)\n",
        "            fourier_graph.stretch(3, 1)\n",
        "            fourier_graph.move_to(graph)\n",
        "            fourier_graph.to_edge(RIGHT)\n",
        "\n",
        "        self.add(graphs, fourier_graphs)\n",
        "\n",
        "\n",
        "        self.add(dot_cloud)\n",
        "        self.add(\n",
        "            uncertainty_principle, quantum,\n",
        "        )\n",
        "        self.add(arrow, cross)\n",
        "        # self.add(is_word)\n",
        "        # self.add(is_not)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}