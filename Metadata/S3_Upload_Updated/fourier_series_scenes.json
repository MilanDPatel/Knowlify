{
    "topic": "The mathematical concept being demonstrated is the Fourier series of a complex function, specifically the Eighth Note",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from _2019.diffyq.part2.fourier_series import FourierOfTrebleClef\n",
        "from _2019.diffyq.part4.complex_functions import TRangingFrom0To1\n",
        "from _2019.diffyq.part4.complex_functions import SimpleComplexExponentExample\n",
        "\n",
        "\n",
        "class ComplexFourierSeriesExample(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"EighthNote\",\n",
        "        \"run_time\": 10,\n",
        "        \"n_vectors\": 200,\n",
        "        \"n_cycles\": 2,\n",
        "        \"max_circle_stroke_width\": 0.75,\n",
        "        \"drawing_height\": 5,\n",
        "        \"center_point\": DOWN,\n",
        "        \"top_row_center\": 3 * UP,\n",
        "        \"top_row_label_y\": 2,\n",
        "        \"top_row_x_spacing\": 1.75,\n",
        "        \"top_row_copy_scale_factor\": 0.9,\n",
        "        \"start_drawn\": False,\n",
        "        \"plane_config\": {\n",
        "            \"axis_config\": {\"unit_size\": 2},\n",
        "            \"y_min\": -1.25,\n",
        "            \"y_max\": 1.25,\n",
        "            \"x_min\": -2.5,\n",
        "            \"x_max\": 2.5,\n",
        "            \"background_line_style\": {\n",
        "                \"stroke_width\": 1,\n",
        "                \"stroke_color\": GREY_B,\n",
        "            },\n",
        "        },\n",
        "        \"top_rect_height\": 2.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_vectors_circles_path()\n",
        "        self.add_top_row(self.vectors, self.circles)\n",
        "        self.write_title()\n",
        "        self.highlight_vectors_one_by_one()\n",
        "        self.change_shape()\n",
        "\n",
        "    def write_title(self):\n",
        "        title = OldTexText(\"Complex\\\\\\\\Fourier series\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(LEFT)\n",
        "        title.match_y(self.path)\n",
        "\n",
        "        self.wait(11)\n",
        "        self.play(FadeInFromDown(title))\n",
        "        self.wait(2)\n",
        "        self.title = title\n",
        "\n",
        "    def highlight_vectors_one_by_one(self):\n",
        "        # Don't know why these vectors can't get copied.\n",
        "        # That seems like a problem that will come up again.\n",
        "        labels = self.top_row[-1]\n",
        "        next_anims = []\n",
        "        for vector, circle, label in zip(self.vectors, self.circles, labels):\n",
        "            # v_color = vector.get_color()\n",
        "            c_color = circle.get_color()\n",
        "            c_stroke_width = circle.get_stroke_width()\n",
        "\n",
        "            rect = SurroundingRectangle(label, color=PINK)\n",
        "            self.play(\n",
        "                # vector.set_color, PINK,\n",
        "                circle.set_stroke, RED, 3,\n",
        "                FadeIn(rect),\n",
        "                *next_anims\n",
        "            )\n",
        "            self.wait()\n",
        "            next_anims = [\n",
        "                # vector.set_color, v_color,\n",
        "                circle.set_stroke, c_color, c_stroke_width,\n",
        "                FadeOut(rect),\n",
        "            ]\n",
        "        self.play(*next_anims)\n",
        "\n",
        "    def change_shape(self):\n",
        "        # path_mob = OldTex(\"\\\\pi\")\n",
        "        path_mob = SVGMobject(\"Nail_And_Gear\")\n",
        "        new_path = path_mob.family_members_with_points()[0]\n",
        "        new_path.set_height(4)\n",
        "        new_path.move_to(self.path, DOWN)\n",
        "        new_path.shift(0.5 * UP)\n",
        "\n",
        "        self.transition_to_alt_path(new_path)\n",
        "        for n in range(self.n_cycles):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "    def transition_to_alt_path(self, new_path, morph_path=False):\n",
        "        new_coefs = self.get_coefficients_of_path(new_path)\n",
        "        new_vectors = self.get_rotating_vectors(\n",
        "            coefficients=new_coefs\n",
        "        )\n",
        "        new_drawn_path = self.get_drawn_path(new_vectors)\n",
        "\n",
        "        self.vector_clock.suspend_updating()\n",
        "\n",
        "        vectors = self.vectors\n",
        "        anims = []\n",
        "\n",
        "        for vect, new_vect in zip(vectors, new_vectors):\n",
        "            new_vect.update()\n",
        "            new_vect.clear_updaters()\n",
        "\n",
        "            line = Line(stroke_width=0)\n",
        "            line.put_start_and_end_on(*vect.get_start_and_end())\n",
        "            anims.append(ApplyMethod(\n",
        "                line.put_start_and_end_on,\n",
        "                *new_vect.get_start_and_end()\n",
        "            ))\n",
        "            vect.freq = new_vect.freq\n",
        "            vect.coefficient = new_vect.coefficient\n",
        "\n",
        "            vect.line = line\n",
        "            vect.add_updater(\n",
        "                lambda v: v.put_start_and_end_on(\n",
        "                    *v.line.get_start_and_end()\n",
        "                )\n",
        "            )\n",
        "        if morph_path:\n",
        "            anims.append(\n",
        "                ReplacementTransform(\n",
        "                    self.drawn_path,\n",
        "                    new_drawn_path\n",
        "                )\n",
        "            )\n",
        "        else:\n",
        "            anims.append(\n",
        "                FadeOut(self.drawn_path)\n",
        "            )\n",
        "\n",
        "        self.play(*anims, run_time=3)\n",
        "        for vect in self.vectors:\n",
        "            vect.remove_updater(vect.updaters[-1])\n",
        "\n",
        "        if not morph_path:\n",
        "            self.add(new_drawn_path)\n",
        "            self.vector_clock.set_value(0)\n",
        "\n",
        "        self.vector_clock.resume_updating()\n",
        "        self.drawn_path = new_drawn_path\n",
        "\n",
        "    #\n",
        "    def get_path(self):\n",
        "        path = super().get_path()\n",
        "        path.set_height(self.drawing_height)\n",
        "        path.to_edge(DOWN)\n",
        "        return path\n",
        "\n",
        "    def add_top_row(self, vectors, circles, max_freq=3):\n",
        "        self.top_row = self.get_top_row(\n",
        "            vectors, circles, max_freq\n",
        "        )\n",
        "        self.add(self.top_row)\n",
        "\n",
        "    def get_top_row(self, vectors, circles, max_freq=3):\n",
        "        vector_copies = VGroup()\n",
        "        circle_copies = VGroup()\n",
        "        for vector, circle in zip(vectors, circles):\n",
        "            if vector.freq > max_freq:\n",
        "                break\n",
        "            vcopy = vector.copy()\n",
        "            vcopy.clear_updaters()\n",
        "            ccopy = circle.copy()\n",
        "            ccopy.clear_updaters()\n",
        "            ccopy.original = circle\n",
        "            vcopy.original = vector\n",
        "\n",
        "            vcopy.center_point = op.add(\n",
        "                self.top_row_center,\n",
        "                vector.freq * self.top_row_x_spacing * RIGHT,\n",
        "            )\n",
        "            ccopy.center_point = vcopy.center_point\n",
        "            vcopy.add_updater(self.update_top_row_vector_copy)\n",
        "            ccopy.add_updater(self.update_top_row_circle_copy)\n",
        "            vector_copies.add(vcopy)\n",
        "            circle_copies.add(ccopy)\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            OldTex(\"\\\\dots\").next_to(\n",
        "                circle_copies, direction,\n",
        "                MED_LARGE_BUFF,\n",
        "            )\n",
        "            for direction in [LEFT, RIGHT]\n",
        "        ])\n",
        "        labels = self.get_top_row_labels(vector_copies)\n",
        "        return VGroup(\n",
        "            vector_copies,\n",
        "            circle_copies,\n",
        "            dots,\n",
        "            labels,\n",
        "        )\n",
        "\n",
        "    def update_top_row_vector_copy(self, vcopy):\n",
        "        vcopy.become(vcopy.original)\n",
        "        vcopy.scale(self.top_row_copy_scale_factor)\n",
        "        vcopy.shift(vcopy.center_point - vcopy.get_start())\n",
        "        return vcopy\n",
        "\n",
        "    def update_top_row_circle_copy(self, ccopy):\n",
        "        ccopy.become(ccopy.original)\n",
        "        ccopy.scale(self.top_row_copy_scale_factor)\n",
        "        ccopy.move_to(ccopy.center_point)\n",
        "        return ccopy\n",
        "\n",
        "    def get_top_row_labels(self, vector_copies):\n",
        "        labels = VGroup()\n",
        "        for vector_copy in vector_copies:\n",
        "            freq = vector_copy.freq\n",
        "            label = Integer(freq)\n",
        "            label.move_to(np.array([\n",
        "                freq * self.top_row_x_spacing,\n",
        "                self.top_row_label_y,\n",
        "                0\n",
        "            ]))\n",
        "            labels.add(label)\n",
        "        return labels\n",
        "\n",
        "    def setup_plane(self):\n",
        "        plane = ComplexPlane(**self.plane_config)\n",
        "        plane.shift(self.center_point)\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        top_rect = Rectangle(\n",
        "            width=FRAME_WIDTH,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1,\n",
        "            stroke_width=0,\n",
        "            height=self.top_rect_height,\n",
        "        )\n",
        "        top_rect.to_edge(UP, buff=0)\n",
        "\n",
        "        self.plane = plane\n",
        "        self.add(plane)\n",
        "        self.add(top_rect)\n",
        "\n",
        "    def get_path_end(self, vectors, stroke_width=None, **kwargs):\n",
        "        if stroke_width is None:\n",
        "            stroke_width = self.drawn_path_st\n",
        "        full_path = self.get_vector_sum_path(vectors, **kwargs)\n",
        "        path = VMobject()\n",
        "        path.set_stroke(\n",
        "            self.drawn_path_color,\n",
        "            stroke_width\n",
        "        )\n",
        "\n",
        "        def update_path(p):\n",
        "            alpha = self.get_vector_time() % 1\n",
        "            p.pointwise_become_partial(\n",
        "                full_path,\n",
        "                np.clip(alpha - 0.01, 0, 1),\n",
        "                np.clip(alpha, 0, 1),\n",
        "            )\n",
        "            p.get_points()[-1] = vectors[-1].get_end()\n",
        "\n",
        "        path.add_updater(update_path)\n",
        "        return path\n",
        "\n",
        "    def get_drawn_path_alpha(self):\n",
        "        return super().get_drawn_path_alpha() - 0.002\n",
        "\n",
        "    def get_drawn_path(self, vectors, stroke_width=2, **kwargs):\n",
        "        odp = super().get_drawn_path(vectors, stroke_width, **kwargs)\n",
        "        return VGroup(\n",
        "            odp,\n",
        "            self.get_path_end(vectors, stroke_width, **kwargs),\n",
        "        )\n",
        "\n",
        "    def get_vertically_falling_tracing(self, vector, color, stroke_width=3, rate=0.25):\n",
        "        path = VMobject()\n",
        "        path.set_stroke(color, stroke_width)\n",
        "        path.start_new_path(vector.get_end())\n",
        "        path.vector = vector\n",
        "\n",
        "        def update_path(p, dt):\n",
        "            p.shift(rate * dt * DOWN)\n",
        "            p.add_smooth_curve_to(p.vector.get_end())\n",
        "        path.add_updater(update_path)\n",
        "        return path\n",
        "\n",
        "\n",
        "class PiFourierSeries(ComplexFourierSeriesExample):\n",
        "    CONFIG = {\n",
        "        \"tex\": \"\\\\pi\",\n",
        "        \"n_vectors\": 101,\n",
        "        \"path_height\": 3.5,\n",
        "        \"max_circle_stroke_width\": 1,\n",
        "        \"top_row_copy_scale_factor\": 0.6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_vectors_circles_path()\n",
        "        self.add_top_row(self.vectors, self.circles)\n",
        "\n",
        "        for n in range(self.n_cycles):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "    def get_path(self):\n",
        "        pi = OldTex(self.tex)\n",
        "        path = pi.family_members_with_points()[0]\n",
        "        path.set_height(self.path_height)\n",
        "        path.move_to(3 * DOWN, DOWN)\n",
        "        path.set_stroke(YELLOW, 0)\n",
        "        path.set_fill(opacity=0)\n",
        "        return path\n",
        "\n",
        "\n",
        "class RealValuedFunctionFourierSeries(PiFourierSeries):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 101,\n",
        "        \"start_drawn\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_vectors_circles_path()\n",
        "        self.add_top_row(self.vectors, self.circles)\n",
        "\n",
        "        self.flatten_path()\n",
        "        self.focus_on_vector_pair()\n",
        "\n",
        "    def flatten_path(self):\n",
        "        new_path = self.path.copy()\n",
        "        new_path.stretch(0, 1)\n",
        "        new_path.set_y(self.plane.n2p(0)[1])\n",
        "        self.vector_clock.set_value(10)\n",
        "        self.transition_to_alt_path(new_path, morph_path=True)\n",
        "        self.run_one_cycle()\n",
        "\n",
        "    def focus_on_vector_pair(self):\n",
        "        vectors = self.vectors\n",
        "        circles = self.circles\n",
        "        top_row = self.top_row\n",
        "        top_vectors, top_circles, dots, labels = top_row\n",
        "\n",
        "        rects1, rects2, rects3 = [\n",
        "            VGroup(*[\n",
        "                SurroundingRectangle(VGroup(\n",
        "                    top_circles[i],\n",
        "                    labels[i],\n",
        "                ))\n",
        "                for i in pair\n",
        "            ]).set_stroke(GREY_B, 2)\n",
        "            for pair in [(1, 2), (3, 4), (5, 6)]\n",
        "        ]\n",
        "\n",
        "        def get_opacity_animation(i1, i2, alpha_func):\n",
        "            v_group = vectors[i1:i2]\n",
        "            c_group = circles[i1:i2]\n",
        "            return AnimationGroup(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    VectorizedPoint(),\n",
        "                    lambda m, a: v_group.set_opacity(\n",
        "                        alpha_func(a)\n",
        "                    )\n",
        "                ),\n",
        "                UpdateFromAlphaFunc(\n",
        "                    VectorizedPoint(),\n",
        "                    lambda m, a: c_group.set_stroke(\n",
        "                        opacity=alpha_func(a)\n",
        "                    )\n",
        "                ),\n",
        "            )\n",
        "\n",
        "        self.remove(self.path, self.drawn_path)\n",
        "        self.play(\n",
        "            get_opacity_animation(\n",
        "                3, len(vectors), lambda a: smooth(1 - a),\n",
        "            ),\n",
        "            ShowCreation(rects1, lag_ratio=0.3),\n",
        "        )\n",
        "        traced_path2 = self.get_vertically_falling_tracing(vectors[2], GREEN)\n",
        "        self.add(traced_path2)\n",
        "        for n in range(3):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "        self.play(\n",
        "            get_opacity_animation(3, 5, smooth),\n",
        "            get_opacity_animation(\n",
        "                0, 3,\n",
        "                lambda a: 1 - 0.75 * smooth(a)\n",
        "            ),\n",
        "            ReplacementTransform(rects1, rects2),\n",
        "        )\n",
        "        traced_path2.set_stroke(width=1)\n",
        "        traced_path4 = self.get_vertically_falling_tracing(vectors[4], YELLOW)\n",
        "        self.add(traced_path4)\n",
        "        self.run_one_cycle()\n",
        "        self.play(\n",
        "            get_opacity_animation(5, 7, smooth),\n",
        "            get_opacity_animation(\n",
        "                3, 5,\n",
        "                lambda a: 1 - 0.75 * smooth(a)\n",
        "            ),\n",
        "            ReplacementTransform(rects2, rects3),\n",
        "        )\n",
        "        traced_path2.set_stroke(width=1)\n",
        "        traced_path4.set_stroke(width=1)\n",
        "        traced_path6 = self.get_vertically_falling_tracing(vectors[6], TEAL)\n",
        "        self.add(traced_path6)\n",
        "        for n in range(2):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "\n",
        "class DemonstrateAddingArrows(PiFourierSeries):\n",
        "    CONFIG = {\n",
        "        \"tex\": \"\\\\leftarrow\",\n",
        "        \"n_arrows\": 21,\n",
        "        \"parametric_function_step_size\": 0.1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_vectors_circles_path()\n",
        "        self.add_top_row(self.vectors, self.circles)\n",
        "\n",
        "        circles = self.circles\n",
        "        original_vectors = self.vectors\n",
        "        vectors = VGroup(*[\n",
        "            Vector(\n",
        "                **self.vector_config\n",
        "            ).put_start_and_end_on(*v.get_start_and_end())\n",
        "            for v in original_vectors\n",
        "        ])\n",
        "        original_top_vectors = self.top_row[0]\n",
        "        top_vectors = VGroup(*[\n",
        "            Vector(\n",
        "                **self.vector_config\n",
        "            ).put_start_and_end_on(*v.get_start_and_end())\n",
        "            for v in original_top_vectors\n",
        "        ])\n",
        "\n",
        "        self.plane.axes.set_stroke(GREY_B, 1)\n",
        "\n",
        "        self.vector_clock.suspend_updating()\n",
        "        self.remove(circles, original_vectors)\n",
        "        self.remove(self.path, self.drawn_path)\n",
        "        anims1 = [\n",
        "            TransformFromCopy(tv, v)\n",
        "            for tv, v in zip(top_vectors, vectors)\n",
        "        ]\n",
        "        anims2 = [\n",
        "            ShowCreation(v)\n",
        "            for v in vectors[len(top_vectors):25]\n",
        "        ]\n",
        "        self.play(\n",
        "            LaggedStart(*anims1),\n",
        "            run_time=3,\n",
        "            lag_ratio=0.2,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*anims2),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "\n",
        "class LabelRotatingVectors(PiFourierSeries):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 6,\n",
        "        \"center_point\": 1.5 * DOWN,\n",
        "        \"top_rect_height\": 3,\n",
        "        \"plane_config\": {\n",
        "            \"axis_config\": {\n",
        "                \"unit_size\": 1.75,\n",
        "                \"stroke_color\": GREY_B,\n",
        "            },\n",
        "        },\n",
        "        \"top_row_x_spacing\": 1.9,\n",
        "        \"top_row_center\": 3 * UP + 0.2 * LEFT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.setup_top_row()\n",
        "\n",
        "        self.ask_about_labels()\n",
        "        self.initialize_at_one()\n",
        "        self.show_complex_exponents()\n",
        "        # self.show_complex_exponents_temp()\n",
        "\n",
        "        self.tweak_initial_states()\n",
        "        self.constant_examples()\n",
        "\n",
        "    def setup_top_row(self):\n",
        "        vectors = self.get_rotating_vectors(\n",
        "            coefficients=0.5 * np.ones(self.n_vectors)\n",
        "        )\n",
        "        circles = self.get_circles(vectors)\n",
        "\n",
        "        top_row = self.get_top_row(vectors, circles)\n",
        "        top_row.shift(0.5 * DOWN + 0.25 * RIGHT)\n",
        "        v_copies, c_copies, dots, labels = top_row\n",
        "        labels.to_edge(UP, MED_SMALL_BUFF)\n",
        "        freq_label = OldTexText(\"Frequencies:\")\n",
        "        freq_label.to_edge(LEFT, MED_SMALL_BUFF)\n",
        "        freq_label.match_y(labels)\n",
        "        VGroup(freq_label, labels).set_color(YELLOW)\n",
        "\n",
        "        def get_constant_func(const):\n",
        "            return lambda: const\n",
        "\n",
        "        for vector, v_copy in zip(vectors, v_copies):\n",
        "            vector.center_func = get_constant_func(\n",
        "                v_copy.get_start()\n",
        "            )\n",
        "        vectors.update(0)\n",
        "        circles.update(0)\n",
        "\n",
        "        self.add(vectors)\n",
        "        self.add(circles)\n",
        "        self.add(dots)\n",
        "        self.add(freq_label)\n",
        "        self.add(labels)\n",
        "\n",
        "        self.vectors = vectors\n",
        "        self.circles = circles\n",
        "        self.labels = labels\n",
        "        self.freq_label = freq_label\n",
        "\n",
        "    def ask_about_labels(self):\n",
        "        circles = self.circles\n",
        "\n",
        "        formulas = OldTexText(\"Formulas:\")\n",
        "        formulas.next_to(circles, DOWN)\n",
        "        formulas.to_edge(LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"??\").scale(1.0).next_to(circle, DOWN)\n",
        "            for circle in circles\n",
        "        ])\n",
        "\n",
        "        self.play(FadeIn(formulas, DOWN))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, q_marks,\n",
        "            lambda m: (m, UP),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.q_marks = q_marks\n",
        "        self.formulas_word = formulas\n",
        "\n",
        "    def initialize_at_one(self):\n",
        "        vectors = self.vectors\n",
        "        circles = self.circles\n",
        "        vector_clock = self.vector_clock\n",
        "        plane = self.plane\n",
        "        q_marks = self.q_marks\n",
        "\n",
        "        # Why so nuclear?\n",
        "        vc_updater = vector_clock.updaters.pop()\n",
        "        self.play(\n",
        "            vector_clock.set_value, 0,\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        zero_vect = Vector()\n",
        "        zero_vect.replace(vectors[0])\n",
        "        zero_circle = self.get_circle(zero_vect)\n",
        "        zero_circle.match_style(circles[0])\n",
        "        self.add(zero_circle)\n",
        "\n",
        "        one_label = OldTex(\"1\")\n",
        "        one_label.move_to(q_marks[0])\n",
        "\n",
        "        self.play(\n",
        "            zero_vect.put_start_and_end_on,\n",
        "            plane.n2p(0), plane.n2p(1),\n",
        "        )\n",
        "        vector_clock.add_updater(vc_updater)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(q_marks[0], UP),\n",
        "            FadeIn(one_label, DOWN),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.one_label = one_label\n",
        "        self.zero_vect = zero_vect\n",
        "        self.zero_circle = zero_circle\n",
        "\n",
        "    def show_complex_exponents(self):\n",
        "        vectors = self.vectors\n",
        "        circles = self.circles\n",
        "        q_marks = self.q_marks\n",
        "        labels = self.labels\n",
        "        one_label = self.one_label\n",
        "        v_lines = self.get_v_lines(circles)\n",
        "\n",
        "        # Vector 1\n",
        "        v1_rect = SurroundingRectangle(\n",
        "            VGroup(circles[1], q_marks[1], labels[1]),\n",
        "            stroke_color=GREY,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        f1_exp = self.get_exp_tex()\n",
        "        f1_exp.move_to(q_marks[1], DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.zero_vect),\n",
        "            FadeOut(self.zero_circle),\n",
        "            FadeIn(v1_rect)\n",
        "        )\n",
        "\n",
        "        vg1 = self.get_vector_in_plane_group(\n",
        "            vectors[1], circles[1],\n",
        "        )\n",
        "        vg1_copy = vg1.copy()\n",
        "        vg1_copy.clear_updaters()\n",
        "        vg1_copy.replace(circles[1])\n",
        "\n",
        "        cps_1 = self.get_cps_label(1)\n",
        "\n",
        "        circle_copy = vg1[1].copy().clear_updaters()\n",
        "        circle_copy.set_stroke(YELLOW, 3)\n",
        "        arclen_decimal = DecimalNumber(\n",
        "            num_decimal_places=3,\n",
        "            show_ellipsis=True,\n",
        "        )\n",
        "        arclen_tracker = ValueTracker(0)\n",
        "        arclen_decimal.add_updater(lambda m: m.next_to(\n",
        "            circle_copy.get_end(), UR, SMALL_BUFF,\n",
        "        ))\n",
        "        arclen_decimal.add_updater(lambda m: m.set_value(\n",
        "            arclen_tracker.get_value()\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(vg1_copy, vg1),\n",
        "        )\n",
        "        self.play(FadeIn(cps_1, DOWN))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(q_marks[1], UP),\n",
        "            FadeIn(f1_exp, DOWN),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            f1_exp.get_part_by_tex(\"2\\\\pi\")\n",
        "        ))\n",
        "        self.add(arclen_decimal),\n",
        "        self.play(\n",
        "            ShowCreation(circle_copy),\n",
        "            arclen_tracker.set_value, TAU,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(circle_copy),\n",
        "            FadeOut(arclen_decimal),\n",
        "        )\n",
        "        self.wait(8)\n",
        "        self.play(\n",
        "            v1_rect.move_to, circles[2],\n",
        "            v1_rect.match_y, v1_rect,\n",
        "            FadeOut(vg1),\n",
        "            FadeOut(cps_1),\n",
        "        )\n",
        "\n",
        "        # Vector -1\n",
        "        vgm1 = self.get_vector_in_plane_group(\n",
        "            vectors[2], circles[2],\n",
        "        )\n",
        "        vgm1_copy = vgm1.copy()\n",
        "        vgm1_copy.clear_updaters()\n",
        "        vgm1_copy.replace(circles[2])\n",
        "        cps_m1 = self.get_cps_label(-1)\n",
        "        fm1_exp = self.get_exp_tex(-1)\n",
        "        fm1_exp.move_to(q_marks[2], DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(vgm1_copy, vgm1),\n",
        "            FadeInFromDown(cps_m1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(q_marks[2], UP),\n",
        "            FadeInFromDown(fm1_exp),\n",
        "            v1_rect.stretch, 1.4, 0,\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            v1_rect.move_to, circles[3],\n",
        "            v1_rect.match_y, v1_rect,\n",
        "            FadeOut(vgm1),\n",
        "            FadeOut(cps_m1),\n",
        "        )\n",
        "\n",
        "        # Vector 2\n",
        "        # (Lots of copy-pasting here)\n",
        "        vg2 = self.get_vector_in_plane_group(\n",
        "            vectors[3], circles[3],\n",
        "        )\n",
        "        vg2_copy = vg2.copy()\n",
        "        vg2_copy.clear_updaters()\n",
        "        vg2_copy.replace(circles[3])\n",
        "        cps_2 = self.get_cps_label(2)\n",
        "        f2_exp = self.get_exp_tex(2)\n",
        "        f2_exp.move_to(q_marks[3], DOWN)\n",
        "        circle_copy.append_vectorized_mobject(circle_copy)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(vg2_copy, vg2),\n",
        "            FadeInFromDown(cps_2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(q_marks[3], UP),\n",
        "            FadeInFromDown(f2_exp),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            f2_exp.get_parts_by_tex(\"2\"),\n",
        "        ))\n",
        "        self.add(arclen_decimal)\n",
        "        arclen_tracker.set_value(0)\n",
        "        self.play(\n",
        "            ShowCreation(circle_copy),\n",
        "            arclen_tracker.set_value, 2 * TAU,\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(circle_copy),\n",
        "            FadeOut(arclen_decimal),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(vg2),\n",
        "            FadeOut(cps_2),\n",
        "            FadeOut(v1_rect),\n",
        "        )\n",
        "\n",
        "        # Show all formulas\n",
        "        fm2_exp = self.get_exp_tex(-2)\n",
        "        fm2_exp.move_to(q_marks[4], DOWN)\n",
        "        f3_exp = self.get_exp_tex(3)\n",
        "        f3_exp.move_to(q_marks[5], DOWN)\n",
        "        f1_exp_new = self.get_exp_tex(1)\n",
        "        f1_exp_new.move_to(q_marks[1], DOWN)\n",
        "        f0_exp = self.get_exp_tex(0)\n",
        "        f0_exp.move_to(q_marks[0], DOWN)\n",
        "        f_exp_general = self.get_exp_tex(\"n\")\n",
        "        f_exp_general.next_to(self.formulas_word, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(q_marks[4:]),\n",
        "            FadeOut(f1_exp),\n",
        "            FadeIn(f1_exp_new),\n",
        "            FadeInFromDown(fm2_exp),\n",
        "            FadeInFromDown(f3_exp),\n",
        "            FadeIn(v_lines, lag_ratio=0.2)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(f_exp_general, UP)\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(f_exp_general))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(one_label, UP),\n",
        "            TransformFromCopy(f_exp_general, f0_exp),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.f_exp_labels = VGroup(\n",
        "            f0_exp, f1_exp_new, fm1_exp,\n",
        "            f2_exp, fm2_exp, f3_exp,\n",
        "        )\n",
        "        self.f_exp_general = f_exp_general\n",
        "\n",
        "    def show_complex_exponents_temp(self):\n",
        "        self.f_exp_labels = VGroup(*[\n",
        "            self.get_exp_tex(n).move_to(qm, DOWN)\n",
        "            for n, qm in zip(\n",
        "                [0, 1, -1, 2, -2, 3],\n",
        "                self.q_marks,\n",
        "            )\n",
        "        ])\n",
        "        self.f_exp_general = self.get_exp_tex(\"n\")\n",
        "        self.f_exp_general.next_to(self.formulas_word, DOWN)\n",
        "\n",
        "        self.remove(*self.q_marks, self.one_label)\n",
        "        self.remove(self.zero_vect, self.zero_circle)\n",
        "        self.add(self.f_exp_labels, self.f_exp_general)\n",
        "\n",
        "    def tweak_initial_states(self):\n",
        "        vector_clock = self.vector_clock\n",
        "        f_exp_labels = self.f_exp_labels\n",
        "        f_exp_general = self.f_exp_general\n",
        "        vectors = self.vectors\n",
        "\n",
        "        cn_terms = VGroup()\n",
        "        for i, f_exp in enumerate(f_exp_labels):\n",
        "            n = (i + 1) // 2\n",
        "            if i % 2 == 0 and i > 0:\n",
        "                n *= -1\n",
        "            cn_terms.add(self.get_cn_label(n, f_exp))\n",
        "        cn_general = self.get_cn_label(\"n\", f_exp_general)\n",
        "\n",
        "        new_coefs = [\n",
        "            0.5,\n",
        "            np.exp(complex(0, TAU / 8)),\n",
        "            0.7 * np.exp(-complex(0, TAU / 8)),\n",
        "            0.6 * np.exp(complex(0, TAU / 3)),\n",
        "            1.1 * np.exp(-complex(0, TAU / 12)),\n",
        "            0.3 * np.exp(complex(0, TAU / 12)),\n",
        "        ]\n",
        "\n",
        "        def update_vectors(alpha):\n",
        "            for vect, new_coef in zip(vectors, new_coefs):\n",
        "                vect.coefficient = 0.5 * interpolate(\n",
        "                    1, new_coef, alpha\n",
        "                )\n",
        "\n",
        "        vector_clock.incrementer = vector_clock.updaters.pop()\n",
        "        self.play(\n",
        "            vector_clock.set_value,\n",
        "            int(vector_clock.get_value())\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget,\n",
        "                VGroup(f_exp_general, *f_exp_labels),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown,\n",
        "                VGroup(cn_general, *cn_terms),\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                VectorizedPoint(),\n",
        "                lambda m, a: update_vectors(a)\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ShowCreationThenFadeAround(\n",
        "                    cn_term,\n",
        "                    surrounding_rectangle_config={\n",
        "                        \"buff\": 0.05,\n",
        "                        \"stroke_width\": 2,\n",
        "                    },\n",
        "                )\n",
        "                for cn_term in cn_terms\n",
        "            ])\n",
        "        )\n",
        "\n",
        "        self.cn_terms = cn_terms\n",
        "        self.cn_general = cn_general\n",
        "\n",
        "    def constant_examples(self):\n",
        "        cn_terms = self.cn_terms\n",
        "        vectors = self.vectors\n",
        "        circles = self.circles\n",
        "\n",
        "        # c0 term\n",
        "        c0_brace = Brace(cn_terms[0], DOWN, buff=SMALL_BUFF)\n",
        "        c0_label = OldTex(\"0.5\")\n",
        "        c0_label.next_to(c0_brace, DOWN, SMALL_BUFF)\n",
        "        c0_label.add_background_rectangle()\n",
        "        vip_group0 = self.get_vector_in_plane_group(\n",
        "            vectors[0], circles[0]\n",
        "        )\n",
        "        vip_group0_copy = vip_group0.copy()\n",
        "        vip_group0_copy.clear_updaters()\n",
        "        vip_group0_copy.replace(circles[0])\n",
        "\n",
        "        self.play(\n",
        "            Transform(vip_group0_copy, vip_group0)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(vip_group0_copy.scale, 2)\n",
        "        self.play(\n",
        "            vip_group0_copy.scale, 0.5,\n",
        "            GrowFromCenter(c0_brace),\n",
        "            GrowFromCenter(c0_label),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(c0_brace),\n",
        "            FadeOut(c0_label),\n",
        "            FadeOut(vip_group0_copy),\n",
        "        )\n",
        "\n",
        "        # c1 term\n",
        "        c1_brace = Brace(cn_terms[1], DOWN, buff=SMALL_BUFF)\n",
        "        c1_label = OldTex(\"e^{(\\\\pi / 4)i}\")\n",
        "        c1_label.next_to(c1_brace, DOWN, SMALL_BUFF)\n",
        "        c1_decimal = DecimalNumber(\n",
        "            np.exp(np.complex(0, PI / 4)),\n",
        "            num_decimal_places=3,\n",
        "        )\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.next_to(c1_label, RIGHT, MED_SMALL_BUFF)\n",
        "        c1_decimal.next_to(approx, RIGHT, MED_SMALL_BUFF)\n",
        "        scalar = DecimalNumber(0.3)\n",
        "        scalar.next_to(\n",
        "            c1_label, LEFT, SMALL_BUFF,\n",
        "            aligned_edge=DOWN,\n",
        "        )\n",
        "\n",
        "        vip_group1 = self.get_vector_in_plane_group(\n",
        "            vectors[1], circles[1]\n",
        "        )\n",
        "        vip_group1_copy = vip_group1.copy()\n",
        "        vip_group1_copy[0].stroke_width = 3\n",
        "        vip_group1_copy.clear_updaters()\n",
        "        vip_group1_copy.save_state()\n",
        "        vip_group1_copy.replace(circles[1])\n",
        "\n",
        "        self.play(\n",
        "            Restore(vip_group1_copy)\n",
        "        )\n",
        "        self.play(Rotate(vip_group1_copy, -PI / 4))\n",
        "        self.play(Rotate(vip_group1_copy, PI / 4))\n",
        "        self.play(\n",
        "            GrowFromCenter(c1_brace),\n",
        "            FadeIn(c1_label),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(approx),\n",
        "            Write(c1_decimal),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        def update_v1(alpha):\n",
        "            vectors[1].coefficient = 0.5 * interpolate(\n",
        "                np.exp(complex(0, PI / 4)),\n",
        "                0.3 * np.exp(complex(0, PI / 4)),\n",
        "                alpha\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(scalar),\n",
        "            c1_decimal.set_value,\n",
        "            scalar.get_value() * c1_decimal.get_value(),\n",
        "            vip_group1_copy.scale, scalar.get_value(),\n",
        "            UpdateFromAlphaFunc(\n",
        "                VMobject(),\n",
        "                lambda m, a: update_v1(a)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(c1_brace),\n",
        "            FadeOut(c1_label),\n",
        "            FadeOut(approx),\n",
        "            FadeOut(c1_decimal),\n",
        "            FadeOut(scalar),\n",
        "            FadeOut(vip_group1_copy),\n",
        "        )\n",
        "\n",
        "        fade_anims = []\n",
        "        for cn_term, vect in zip(cn_terms[2:], vectors[2:]):\n",
        "            rect = SurroundingRectangle(cn_term, buff=0.025)\n",
        "            rect.set_stroke(width=2)\n",
        "            decimal = DecimalNumber(vect.coefficient)\n",
        "            decimal.next_to(rect, DOWN)\n",
        "            decimal.add_background_rectangle()\n",
        "            if cn_term is cn_terms[4]:\n",
        "                decimal.shift(0.7 * RIGHT)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(rect),\n",
        "                FadeIn(decimal),\n",
        "                *fade_anims\n",
        "            )\n",
        "            self.wait()\n",
        "            fade_anims = [FadeOut(rect), FadeOut(decimal)]\n",
        "        self.play(*fade_anims)\n",
        "\n",
        "    #\n",
        "    def get_vector_in_plane_group(self, top_vector, top_circle):\n",
        "        plane = self.plane\n",
        "        origin = plane.n2p(0)\n",
        "\n",
        "        vector = Vector()\n",
        "        vector.add_updater(\n",
        "            lambda v: v.put_start_and_end_on(\n",
        "                origin,\n",
        "                plane.n2p(2 * top_vector.coefficient)\n",
        "            ).set_angle(top_vector.get_angle())\n",
        "        )\n",
        "        circle = Circle()\n",
        "        circle.match_style(top_circle)\n",
        "        circle.set_width(2 * vector.get_length())\n",
        "        circle.move_to(origin)\n",
        "\n",
        "        return VGroup(vector, circle)\n",
        "\n",
        "    def get_exp_tex(self, freq=None):\n",
        "        if freq is None:\n",
        "            freq_str = \"{}\"\n",
        "        else:\n",
        "            freq_str = \"{\" + str(freq) + \"}\" + \"\\\\cdot\"\n",
        "\n",
        "        result = OldTex(\n",
        "            \"e^{\", freq_str, \"2\\\\pi i {t}}\",\n",
        "            tex_to_color_map={\n",
        "                \"2\\\\pi\": WHITE,\n",
        "                \"{t}\": PINK,\n",
        "                freq_str: YELLOW,\n",
        "            }\n",
        "        )\n",
        "        result.scale(0.9)\n",
        "        return result\n",
        "\n",
        "    def get_cn_label(self, n, exp_label):\n",
        "        exp_label.generate_target()\n",
        "        exp_label.target.scale(0.9)\n",
        "\n",
        "        n_str = \"{\" + str(n) + \"}\"\n",
        "        term = OldTex(\"c_\", n_str)\n",
        "        term.set_color(GREEN)\n",
        "        term[1].set_color(YELLOW)\n",
        "        term[1].set_width(0.12)\n",
        "        term[1].move_to(term[0].get_corner(DR), LEFT)\n",
        "        if isinstance(n, str):\n",
        "            term[1].scale(1.4, about_edge=LEFT)\n",
        "            term[1].shift(0.03 * RIGHT)\n",
        "        elif n < 0:\n",
        "            term[1].scale(1.4, about_edge=LEFT)\n",
        "            term[1].set_stroke(width=0.5)\n",
        "        else:\n",
        "            term[1].shift(0.05 * RIGHT)\n",
        "        term.scale(0.9)\n",
        "        term.shift(\n",
        "            exp_label.target[0].get_corner(LEFT) -\n",
        "            term[0].get_corner(RIGHT) +\n",
        "            0.2 * LEFT\n",
        "        )\n",
        "        VGroup(exp_label.target, term).move_to(\n",
        "            exp_label, DOWN\n",
        "        )\n",
        "\n",
        "        if isinstance(n, str):\n",
        "            VGroup(term, exp_label.target).scale(\n",
        "                1.3, about_edge=UP\n",
        "            )\n",
        "\n",
        "        return term\n",
        "\n",
        "    def get_cps_label(self, n):\n",
        "        n_str = str(n)\n",
        "        if n == 1:\n",
        "            frac_tex = \"\\\\frac{\\\\text{cycle}}{\\\\text{second}}\"\n",
        "        else:\n",
        "            frac_tex = \"\\\\frac{\\\\text{cycles}}{\\\\text{second}}\"\n",
        "\n",
        "        result = OldTex(\n",
        "            n_str, frac_tex,\n",
        "            tex_to_color_map={\n",
        "                n_str: YELLOW\n",
        "            },\n",
        "        )\n",
        "        result[1].scale(0.7, about_edge=LEFT)\n",
        "        result[0].scale(1.2, about_edge=RIGHT)\n",
        "        result.next_to(self.plane.n2p(2), UR)\n",
        "        return result\n",
        "\n",
        "    def get_v_lines(self, circles):\n",
        "        lines = VGroup()\n",
        "        o_circles = VGroup(*circles)\n",
        "        o_circles.sort(lambda p: p[0])\n",
        "        for c1, c2 in zip(o_circles, o_circles[1:]):\n",
        "            line = DashedLine(3 * UP, ORIGIN)\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            line.move_to(midpoint(\n",
        "                c1.get_center(), c2.get_center(),\n",
        "            ))\n",
        "            lines.add(line)\n",
        "        return lines\n",
        "\n",
        "\n",
        "class IntegralTrick(LabelRotatingVectors, TRangingFrom0To1):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"EighthNote\",\n",
        "        \"n_vectors\": 101,\n",
        "        \"path_height\": 3.5,\n",
        "        \"plane_config\": {\n",
        "            \"x_min\": -1.75,\n",
        "            \"x_max\": 1.75,\n",
        "            \"axis_config\": {\n",
        "                \"unit_size\": 1.75,\n",
        "                \"stroke_color\": GREY_B,\n",
        "            },\n",
        "        },\n",
        "        \"center_point\": 1.5 * DOWN + 3 * RIGHT,\n",
        "        \"input_space_rect_config\": {\n",
        "            \"width\": 6,\n",
        "            \"height\": 1.5,\n",
        "        },\n",
        "        \"start_drawn\": True,\n",
        "        \"parametric_function_step_size\": 0.01,\n",
        "        \"top_row_center\": 2 * UP + RIGHT,\n",
        "        \"top_row_x_spacing\": 2.25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_vectors_circles_path()\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "        self.setup_top_row()\n",
        "        self.setup_sum()\n",
        "\n",
        "        self.introduce_sum()\n",
        "        self.issolate_c0()\n",
        "        self.show_center_of_mass()\n",
        "        self.write_integral()\n",
        "\n",
        "    def setup_input_space(self):\n",
        "        super().setup_input_space()\n",
        "        self.input_line.next_to(\n",
        "            self.input_rect.get_bottom(),\n",
        "            UP,\n",
        "        )\n",
        "        group = VGroup(\n",
        "            self.input_rect,\n",
        "            self.input_line,\n",
        "        )\n",
        "        group.move_to(self.plane.n2p(0))\n",
        "        group.to_edge(LEFT)\n",
        "\n",
        "    def setup_top_row(self):\n",
        "        top_row = self.get_top_row(\n",
        "            self.vectors, self.circles,\n",
        "            max_freq=2,\n",
        "        )\n",
        "        self.top_vectors, self.top_circles, dots, labels = top_row\n",
        "\n",
        "        self.add(*top_row)\n",
        "        self.remove(labels)\n",
        "\n",
        "    def setup_sum(self):\n",
        "        top_vectors = self.top_vectors\n",
        "\n",
        "        terms = VGroup()\n",
        "        for vect in top_vectors:\n",
        "            freq = vect.freq\n",
        "            exp = self.get_exp_tex(freq)\n",
        "            cn = self.get_cn_label(freq, exp)\n",
        "            exp.become(exp.target)\n",
        "            term = VGroup(cn, exp)\n",
        "            term.move_to(vect.get_start())\n",
        "            term.shift(UP)\n",
        "            terms.add(term)\n",
        "\n",
        "        for vect in [LEFT, RIGHT]:\n",
        "            dots = OldTex(\"\\\\cdots\")\n",
        "            dots.next_to(terms, vect, MED_LARGE_BUFF)\n",
        "            terms.add(dots)\n",
        "\n",
        "        plusses = VGroup()\n",
        "        o_terms = VGroup(*terms)\n",
        "        o_terms.sort(lambda p: p[0])\n",
        "        for t1, t2 in zip(o_terms, o_terms[1:]):\n",
        "            plus = OldTex(\"+\")\n",
        "            plus.scale(0.7)\n",
        "            plus.move_to(midpoint(\n",
        "                t1.get_right(),\n",
        "                t2.get_left(),\n",
        "            ))\n",
        "            plusses.add(plus)\n",
        "        terms[:-2].shift(0.05 * UP)\n",
        "\n",
        "        ft_eq = OldTex(\"f(t)\", \"= \")\n",
        "        ft_eq.next_to(terms, LEFT)\n",
        "\n",
        "        self.add(terms)\n",
        "        self.add(plusses)\n",
        "        self.add(ft_eq)\n",
        "\n",
        "        self.terms = terms\n",
        "        self.plusses = plusses\n",
        "        self.ft_eq = ft_eq\n",
        "\n",
        "    def introduce_sum(self):\n",
        "        self.remove(\n",
        "            self.vector_clock,\n",
        "            self.vectors,\n",
        "            self.circles,\n",
        "            self.drawn_path,\n",
        "        )\n",
        "\n",
        "        ft = self.ft_eq[0]\n",
        "        terms = self.terms\n",
        "        path = self.path\n",
        "        input_tracker = self.input_tracker\n",
        "\n",
        "        rect = SurroundingRectangle(ft)\n",
        "        coefs = VGroup(*[term[0] for term in terms[:-2]])\n",
        "        terms_rect = SurroundingRectangle(terms)\n",
        "        terms_rect.set_stroke(YELLOW, 1.5)\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.add_updater(lambda d: d.move_to(path.get_end()))\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(rect, dot)\n",
        "        )\n",
        "        path.set_stroke(YELLOW, 2)\n",
        "        self.play(\n",
        "            ShowCreation(path),\n",
        "            input_tracker.set_value, 1,\n",
        "            run_time=3,\n",
        "            rate_func=lambda t: smooth(t, 1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        input_tracker.add_updater(\n",
        "            lambda m: m.set_value(\n",
        "                self.vector_clock.get_value() % 1\n",
        "            )\n",
        "        )\n",
        "        self.add(\n",
        "            self.vector_clock,\n",
        "            self.vectors,\n",
        "            self.circles,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(path),\n",
        "            FadeOut(dot),\n",
        "            FadeIn(self.drawn_path),\n",
        "        )\n",
        "        self.play(FadeIn(terms_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(terms_rect))\n",
        "\n",
        "        fade_outs = []\n",
        "        for coef in coefs:\n",
        "            rect = SurroundingRectangle(coef)\n",
        "            self.play(FadeIn(rect), *fade_outs)\n",
        "            fade_outs = [FadeOut(rect)]\n",
        "        self.play(*fade_outs)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.vector_clock.clear_updaters()\n",
        "\n",
        "    def issolate_c0(self):\n",
        "        vectors = self.vectors\n",
        "        circles = self.circles\n",
        "        terms = self.terms\n",
        "        top_circles = self.top_circles\n",
        "        path = self.path\n",
        "\n",
        "        path.set_stroke(YELLOW, 1)\n",
        "\n",
        "        c0_rect = SurroundingRectangle(\n",
        "            VGroup(top_circles[0], terms[0])\n",
        "        )\n",
        "        c0_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        opacity_tracker = ValueTracker(1)\n",
        "        for vect in vectors[1:]:\n",
        "            vect.add_updater(\n",
        "                lambda v: v.set_opacity(\n",
        "                    opacity_tracker.get_value()\n",
        "                )\n",
        "            )\n",
        "        for circle in circles[0:]:\n",
        "            circle.add_updater(\n",
        "                lambda c: c.set_stroke(\n",
        "                    opacity=opacity_tracker.get_value()\n",
        "                )\n",
        "            )\n",
        "\n",
        "        self.play(ShowCreation(c0_rect))\n",
        "        self.play(\n",
        "            opacity_tracker.set_value, 0.2,\n",
        "            FadeOut(self.drawn_path),\n",
        "            FadeIn(path)\n",
        "        )\n",
        "\n",
        "        v0 = vectors[0]\n",
        "        v0_point = VectorizedPoint(v0.get_end())\n",
        "        origin = self.plane.n2p(0)\n",
        "        v0.add_updater(lambda v: v.put_start_and_end_on(\n",
        "            origin, v0_point.get_location(),\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            MaintainPositionRelativeTo(path, v0_point),\n",
        "            ApplyMethod(\n",
        "                v0_point.shift, 1.5 * LEFT,\n",
        "                run_time=4,\n",
        "                rate_func=there_and_back,\n",
        "                path_arc=60 * DEGREES,\n",
        "            )\n",
        "        )\n",
        "        v0.updaters.pop()\n",
        "\n",
        "        self.opacity_tracker = opacity_tracker\n",
        "\n",
        "    def show_center_of_mass(self):\n",
        "        dot_sets = VGroup(*[\n",
        "            self.get_sample_dots(dt=dt, radius=radius)\n",
        "            for dt, radius in [\n",
        "                (0.05, 0.04),\n",
        "                (0.01, 0.03),\n",
        "                (0.0025, 0.02),\n",
        "            ]\n",
        "        ])\n",
        "        input_dots, output_dots = dot_sets[0]\n",
        "        v0_dot = input_dots[0].deepcopy()\n",
        "        v0_dot.move_to(center_of_mass([\n",
        "            od.get_center()\n",
        "            for od in output_dots\n",
        "        ]))\n",
        "        v0_dot.set_color(RED)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, input_dots,\n",
        "            lambda m: (m, 5),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                input_dots,\n",
        "                output_dots,\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                od.copy(), v0_dot.copy(),\n",
        "                remover=True\n",
        "            )\n",
        "            for od in output_dots\n",
        "        ])\n",
        "        self.add(v0_dot)\n",
        "        self.wait()\n",
        "\n",
        "        for ds1, ds2 in zip(dot_sets, dot_sets[1:]):\n",
        "            ind1, outd1 = ds1\n",
        "            ind2, outd2 = ds2\n",
        "            new_v0_dot = v0_dot.copy()\n",
        "            new_v0_dot.move_to(center_of_mass([\n",
        "                od.get_center()\n",
        "                for od in outd2\n",
        "            ]))\n",
        "            self.play(\n",
        "                FadeOut(ind1),\n",
        "                LaggedStartMap(\n",
        "                    FadeInFrom, ind2,\n",
        "                    lambda m: (m, UP),\n",
        "                    lag_ratio=4 / len(ind2),\n",
        "                    run_time=2,\n",
        "                )\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(ind2, outd2),\n",
        "                FadeOut(outd1),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(v0_dot),\n",
        "                *[\n",
        "                    Transform(\n",
        "                        od.copy(), v0_dot.copy(),\n",
        "                        remover=True\n",
        "                    )\n",
        "                    for od in outd2\n",
        "                ]\n",
        "            )\n",
        "            v0_dot = new_v0_dot\n",
        "            self.add(v0_dot)\n",
        "        self.wait()\n",
        "\n",
        "        self.input_dots, self.output_dots = dot_sets[-1]\n",
        "        self.v0_dot = v0_dot\n",
        "\n",
        "    def write_integral(self):\n",
        "        t_tracker = self.vector_clock\n",
        "        path = self.path\n",
        "\n",
        "        expression = OldTex(\n",
        "            \"c_{0}\", \"=\"\n",
        "            \"\\\\int_0^1 f({t}) d{t}\",\n",
        "            tex_to_color_map={\n",
        "                \"{t}\": PINK,\n",
        "                \"{0}\": YELLOW,\n",
        "            },\n",
        "        )\n",
        "        expression.next_to(self.input_rect, UP)\n",
        "        brace = Brace(expression[2:], UP, buff=SMALL_BUFF)\n",
        "        average = brace.get_text(\"Average\", buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(expression),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(average),\n",
        "        )\n",
        "        t_tracker.clear_updaters()\n",
        "        t_tracker.set_value(0)\n",
        "        self.add(path)\n",
        "        self.play(\n",
        "            t_tracker.set_value, 0.999,\n",
        "            ShowCreation(path),\n",
        "            run_time=8,\n",
        "            rate_func=lambda t: smooth(t, 1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_path(self):\n",
        "        mob = SVGMobject(self.file_name)\n",
        "        path = mob.family_members_with_points()[0]\n",
        "        path.set_height(self.path_height)\n",
        "        path.move_to(self.center_point)\n",
        "        path.shift(0.5 * UR)\n",
        "        path.set_stroke(YELLOW, 0)\n",
        "        path.set_fill(opacity=0)\n",
        "        return path\n",
        "\n",
        "    def get_sample_dots(self, dt, radius):\n",
        "        input_line = self.input_line\n",
        "        path = self.path\n",
        "\n",
        "        t_values = np.arange(0, 1 + dt, dt)\n",
        "        dot = Dot(color=PINK, radius=radius)\n",
        "        dot.set_stroke(\n",
        "            RED, 1,\n",
        "            opacity=0.8,\n",
        "            background=True,\n",
        "        )\n",
        "        input_dots = VGroup()\n",
        "        output_dots = VGroup()\n",
        "        for t in t_values:\n",
        "            in_dot = dot.copy()\n",
        "            out_dot = dot.copy()\n",
        "            in_dot.move_to(input_line.n2p(t))\n",
        "            out_dot.move_to(path.point_from_proportion(t))\n",
        "            input_dots.add(in_dot)\n",
        "            output_dots.add(out_dot)\n",
        "        return VGroup(input_dots, output_dots)\n",
        "\n",
        "\n",
        "class IncreaseOrderOfApproximation(ComplexFourierSeriesExample):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"FourierOneLine\",\n",
        "        \"drawing_height\": 6,\n",
        "        \"n_vectors\": 250,\n",
        "        \"parametric_function_step_size\": 0.001,\n",
        "        \"run_time\": 10,\n",
        "        # \"n_vectors\": 25,\n",
        "        # \"parametric_function_step_size\": 0.01,\n",
        "        # \"run_time\": 5,\n",
        "        \"slow_factor\": 0.05,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        path = self.get_path()\n",
        "        path.to_edge(DOWN)\n",
        "        path.set_stroke(YELLOW, 2)\n",
        "        freqs = self.get_freqs()\n",
        "        coefs = self.get_coefficients_of_path(\n",
        "            path, freqs=freqs,\n",
        "        )\n",
        "        vectors = self.get_rotating_vectors(freqs, coefs)\n",
        "        circles = self.get_circles(vectors)\n",
        "\n",
        "        n_tracker = ValueTracker(2)\n",
        "        n_label = VGroup(\n",
        "            OldTexText(\"Approximation using\"),\n",
        "            Integer(100).set_color(YELLOW),\n",
        "            OldTexText(\"vectors\")\n",
        "        )\n",
        "        n_label.arrange(RIGHT)\n",
        "        n_label.to_corner(UL)\n",
        "        n_label.add_updater(\n",
        "            lambda n: n[1].set_value(\n",
        "                n_tracker.get_value()\n",
        "            ).align_to(n[2], DOWN)\n",
        "        )\n",
        "\n",
        "        changing_path = VMobject()\n",
        "        vector_copies = VGroup()\n",
        "        circle_copies = VGroup()\n",
        "\n",
        "        def update_changing_path(cp):\n",
        "            n = n_label[1].get_value()\n",
        "            cp.become(self.get_vector_sum_path(vectors[:n]))\n",
        "            cp.set_stroke(YELLOW, 2)\n",
        "            # While we're at it...\n",
        "            vector_copies.submobjects = list(vectors[:n])\n",
        "            circle_copies.submobjects = list(circles[:n])\n",
        "\n",
        "        changing_path.add_updater(update_changing_path)\n",
        "\n",
        "        self.add(n_label, n_tracker, changing_path)\n",
        "        self.add(vector_copies, circle_copies)\n",
        "        self.play(\n",
        "            n_tracker.set_value, self.n_vectors,\n",
        "            rate_func=smooth,\n",
        "            run_time=self.run_time,\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ShowStepFunctionIn2dView(SimpleComplexExponentExample, ComplexFourierSeriesExample):\n",
        "    CONFIG = {\n",
        "        \"input_space_rect_config\": {\n",
        "            \"width\": 5,\n",
        "            \"height\": 2,\n",
        "        },\n",
        "        \"input_line_config\": {\n",
        "            \"unit_size\": 3,\n",
        "            \"x_min\": 0,\n",
        "            \"x_max\": 1,\n",
        "            \"tick_frequency\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "            \"decimal_number_config\": {\n",
        "                \"num_decimal_places\": 1,\n",
        "            }\n",
        "        },\n",
        "        \"input_numbers\": [0, 0.5, 1],\n",
        "        \"input_tex_args\": [],\n",
        "        # \"n_vectors\": 300,\n",
        "        \"n_vectors\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "        self.clear()\n",
        "\n",
        "        self.transition_from_step_function()\n",
        "        self.show_output()\n",
        "        self.show_fourier_series()\n",
        "\n",
        "    def setup_input_space(self):\n",
        "        super().setup_input_space()\n",
        "        rect = self.input_rect\n",
        "        line = self.input_line\n",
        "        # rect.stretch(1.2, 1, about_edge=UP)\n",
        "        line.shift(MED_SMALL_BUFF * UP)\n",
        "        sf = 1.2\n",
        "        line.stretch(sf, 0)\n",
        "        for n in line.numbers:\n",
        "            n.stretch(1 / sf, 0)\n",
        "\n",
        "        label = OldTexText(\"Input space\")\n",
        "        label.next_to(rect.get_bottom(), UP, SMALL_BUFF)\n",
        "        self.add(label)\n",
        "        self.input_space_label = label\n",
        "\n",
        "    def transition_from_step_function(self):\n",
        "        x_axis = self.input_line\n",
        "        input_tip = self.input_tip\n",
        "        input_label = self.input_label\n",
        "        input_rect = self.input_rect\n",
        "        input_space_label = self.input_space_label\n",
        "        plane = self.plane\n",
        "        plane.set_opacity(0)\n",
        "\n",
        "        x_axis.save_state()\n",
        "        # x_axis.center()\n",
        "        x_axis.move_to(ORIGIN, LEFT)\n",
        "        sf = 1.5\n",
        "        x_axis.stretch(sf, 0)\n",
        "        for number in x_axis.numbers:\n",
        "            number.stretch(1 / sf, 0)\n",
        "        x_axis.numbers[0].set_opacity(0)\n",
        "\n",
        "        y_axis = NumberLine(\n",
        "            unit_size=2,\n",
        "            x_min=-1.5,\n",
        "            x_max=1.5,\n",
        "            tick_frequency=0.5,\n",
        "            stroke_color=GREY_B,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        # y_axis.match_style(x_axis)\n",
        "        y_axis.rotate(90 * DEGREES)\n",
        "        y_axis.shift(x_axis.n2p(0) - y_axis.n2p(0))\n",
        "        y_axis.add_numbers(\n",
        "            -1, 0, 1,\n",
        "            direction=LEFT,\n",
        "        )\n",
        "        axes = Axes()\n",
        "        axes.x_axis = x_axis\n",
        "        axes.y_axis = y_axis\n",
        "        axes.axes = VGroup(x_axis, y_axis)\n",
        "\n",
        "        graph = VGroup(\n",
        "            Line(\n",
        "                axes.c2p(0, 1),\n",
        "                axes.c2p(0.5, 1),\n",
        "                color=RED,\n",
        "            ),\n",
        "            Line(\n",
        "                axes.c2p(0.5, -1),\n",
        "                axes.c2p(1, -1),\n",
        "                color=BLUE,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        dot1 = Dot(color=RED)\n",
        "        dot2 = Dot(color=BLUE)\n",
        "        dot1.add_updater(lambda d: d.move_to(y_axis.n2p(1)))\n",
        "        dot2.add_updater(lambda d: d.move_to(y_axis.n2p(-1)))\n",
        "        squish_graph = VGroup(dot1, dot2)\n",
        "\n",
        "        self.add(x_axis)\n",
        "        self.add(y_axis)\n",
        "        self.add(input_tip)\n",
        "        self.add(input_label)\n",
        "\n",
        "        self.play(\n",
        "            self.input_tracker.set_value, 1,\n",
        "            ShowCreation(graph),\n",
        "            run_time=3,\n",
        "            rate_func=lambda t: smooth(t, 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(\n",
        "            plane, input_rect, input_space_label,\n",
        "            x_axis, input_tip, input_label,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(input_rect),\n",
        "            FadeIn(input_space_label),\n",
        "            Restore(x_axis),\n",
        "        )\n",
        "        self.play(ReplacementTransform(graph, squish_graph))\n",
        "\n",
        "        # Rotate y-axis, fade in plane\n",
        "        y_axis.generate_target(use_deepcopy=True)\n",
        "        y_axis.target.rotate(-TAU / 4)\n",
        "        y_axis.target.shift(\n",
        "            plane.n2p(0) - y_axis.target.n2p(0)\n",
        "        )\n",
        "        y_axis.target.numbers.set_opacity(0)\n",
        "\n",
        "        plane.set_opacity(1)\n",
        "        self.play(\n",
        "            MoveToTarget(y_axis),\n",
        "            ShowCreation(plane),\n",
        "        )\n",
        "        self.play(FadeOut(y_axis))\n",
        "        self.wait()\n",
        "        self.play(self.input_tracker.set_value, 0)\n",
        "\n",
        "        self.output_dots = squish_graph\n",
        "\n",
        "    def show_output(self):\n",
        "        input_tracker = self.input_tracker\n",
        "\n",
        "        def get_output_point():\n",
        "            return self.get_output_point(input_tracker.get_value())\n",
        "\n",
        "        tip = ArrowTip(start_angle=-TAU / 4)\n",
        "        tip.set_fill(YELLOW)\n",
        "        tip.match_height(self.input_tip)\n",
        "        tip.add_updater(lambda m: m.move_to(\n",
        "            get_output_point(), DOWN,\n",
        "        ))\n",
        "        output_label = OldTexText(\"Output\")\n",
        "        output_label.add_background_rectangle()\n",
        "        output_label.add_updater(lambda m: m.next_to(\n",
        "            tip, UP, SMALL_BUFF,\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(tip),\n",
        "            FadeIn(output_label),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            input_tracker.set_value, 1,\n",
        "            run_time=8,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(input_tracker.set_value, 0)\n",
        "\n",
        "        self.output_tip = tip\n",
        "\n",
        "    def show_fourier_series(self):\n",
        "        plane = self.plane\n",
        "        input_tracker = self.input_tracker\n",
        "        output_tip = self.output_tip\n",
        "\n",
        "        self.play(\n",
        "            plane.axes.set_stroke, WHITE, 1,\n",
        "            plane.background_lines.set_stroke, GREY_B, 0.5,\n",
        "            plane.faded_lines.set_stroke, GREY_B, 0.25, 0.5,\n",
        "        )\n",
        "\n",
        "        self.vector_clock.set_value(0)\n",
        "        self.add(self.vector_clock)\n",
        "        input_tracker.add_updater(lambda m: m.set_value(\n",
        "            self.vector_clock.get_value() % 1\n",
        "        ))\n",
        "        self.add_vectors_circles_path()\n",
        "        self.remove(self.drawn_path)\n",
        "        self.add(self.vectors)\n",
        "        output_tip.clear_updaters()\n",
        "        output_tip.add_updater(lambda m: m.move_to(\n",
        "            self.vectors[-1].get_end(), DOWN\n",
        "        ))\n",
        "\n",
        "        self.run_one_cycle()\n",
        "        path = self.get_vertically_falling_tracing(\n",
        "            self.vectors[1], GREEN, rate=0.5,\n",
        "        )\n",
        "        self.add(path)\n",
        "        for x in range(3):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "    #\n",
        "    def get_freqs(self):\n",
        "        n = self.n_vectors\n",
        "        all_freqs = [\n",
        "            *range(1, n + 1 // 2, 2),\n",
        "            *range(-1, -n + 1 // 2, -2),\n",
        "        ]\n",
        "        all_freqs.sort(key=abs)\n",
        "        return all_freqs\n",
        "\n",
        "    def get_path(self):\n",
        "        path = VMobject()\n",
        "        p0, p1 = [\n",
        "            self.get_output_point(x)\n",
        "            for x in [0, 1]\n",
        "        ]\n",
        "        for p in p0, p1:\n",
        "            path.start_new_path(p)\n",
        "            path.add_line_to(p)\n",
        "        return path\n",
        "\n",
        "    def get_output_point(self, x):\n",
        "        return self.plane.n2p(self.step(x))\n",
        "\n",
        "    def step(self, x):\n",
        "        if x < 0.5:\n",
        "            return 1\n",
        "        elif x == 0.5:\n",
        "            return 0\n",
        "        else:\n",
        "            return -1\n",
        "\n",
        "\n",
        "class AddVectorsOneByOne(IntegralTrick):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"TrebleClef\",\n",
        "        # \"start_drawn\": True,\n",
        "        \"n_vectors\": 101,\n",
        "        \"path_height\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.add_vectors_circles_path()\n",
        "        self.setup_input_space()\n",
        "        self.setup_input_trackers()\n",
        "        self.setup_top_row()\n",
        "        self.setup_sum()\n",
        "\n",
        "        self.show_sum()\n",
        "\n",
        "    def show_sum(self):\n",
        "        vectors = self.vectors\n",
        "        vector_clock = self.vector_clock\n",
        "        terms = self.terms\n",
        "\n",
        "        vector_clock.suspend_updating()\n",
        "        coef_tracker = ValueTracker(0)\n",
        "\n",
        "        def update_vector(vector):\n",
        "            vector.coefficient = interpolate(\n",
        "                1, vector.original_coefficient,\n",
        "                coef_tracker.get_value()\n",
        "            )\n",
        "\n",
        "        for vector in vectors:\n",
        "            vector.original_coefficient = vector.coefficient\n",
        "            vector.add_updater(update_vector)\n",
        "\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(t[0])\n",
        "            for t in terms[:5]\n",
        "        ])\n",
        "\n",
        "        self.remove(self.drawn_path)\n",
        "        self.play(LaggedStartMap(\n",
        "            VFadeInThenOut, rects\n",
        "        ))\n",
        "        self.play(\n",
        "            coef_tracker.set_value, 1,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        vector_clock.resume_updating()\n",
        "        self.input_tracker.add_updater(\n",
        "            lambda m: m.set_value(vector_clock.get_value() % 1)\n",
        "        )\n",
        "        self.add(self.drawn_path, self.input_tracker)\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_path(self):\n",
        "        mob = SVGMobject(self.file_name)\n",
        "        path = mob.family_members_with_points()[0]\n",
        "        path.set_height(self.path_height)\n",
        "        path.move_to(self.plane.n2p(0))\n",
        "        path.set_stroke(YELLOW, 0)\n",
        "        path.set_fill(opacity=0)\n",
        "        return path\n",
        "\n",
        "\n",
        "class DE4Thumbnail(ComplexFourierSeriesExample):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"FourierOneLine\",\n",
        "        \"start_drawn\": True,\n",
        "        \"n_vectors\": 300,\n",
        "        \"parametric_function_step_size\": 0.0025,\n",
        "        \"drawn_path_stroke_width\": 7,\n",
        "        \"drawing_height\": 6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        path = self.get_path()\n",
        "        path.to_edge(DOWN)\n",
        "        path.set_stroke(YELLOW, 2)\n",
        "        freqs = self.get_freqs()\n",
        "        coefs = self.get_coefficients_of_path(path, freqs=freqs)\n",
        "        vectors = self.get_rotating_vectors(freqs, coefs)\n",
        "        circles = self.get_circles(vectors)\n",
        "\n",
        "        ns = [10, 50, 250]\n",
        "        approxs = VGroup(*[\n",
        "            self.get_vector_sum_path(vectors[:n])\n",
        "            for n in ns\n",
        "        ])\n",
        "        approxs.set_height(4)\n",
        "        approxs.arrange(RIGHT, buff=1.0)\n",
        "        approxs.set_width(FRAME_WIDTH - 2)\n",
        "        # approxs.set_y(-0.5)\n",
        "        for a, c, w in zip(approxs, [BLUE, GREEN, YELLOW], [4, 3, 2]):\n",
        "            shadows = VGroup()\n",
        "            for w2 in zip(np.linspace(1, 15, 10)):\n",
        "                shadow = a.deepcopy()\n",
        "                shadow.set_stroke(c, w2, opacity=0.05)\n",
        "                shadows.add(shadow)\n",
        "            a.set_stroke(c, w)\n",
        "            # a.set_stroke(c, w + w / 2, background=True)\n",
        "            # a.add_to_back(shadows)\n",
        "            self.add(shadows)\n",
        "\n",
        "        labels = VGroup()\n",
        "        for n, approx in zip(ns, approxs):\n",
        "            label = OldTex(\"n = \", str(n))\n",
        "            label[1].match_color(approx)\n",
        "            label.scale(2)\n",
        "            label.next_to(approx, UP, MED_LARGE_BUFF)\n",
        "            label.shift_onto_screen()\n",
        "            labels.add(label)\n",
        "        for label in labels:\n",
        "            label.align_to(labels[-1], DOWN)\n",
        "        title = Text(\"Drawn with circles\")\n",
        "        title.set_width(FRAME_WIDTH - 4)\n",
        "        title.next_to(approxs, DOWN)\n",
        "        title.shift_onto_screen(buff=0.1)\n",
        "        title.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.add(approxs)\n",
        "        self.add(labels)\n",
        "        self.add(title)\n",
        "\n",
        "        return\n",
        "        # Old\n",
        "        name = OldTexText(\"Fourier series\")\n",
        "        name.to_edge(UP)\n",
        "        name.set_color(YELLOW)\n",
        "        subname = OldTexText(\"a.k.a ``everything is rotations''\")\n",
        "        subname.match_width(name)\n",
        "        subname.next_to(name, DOWN, SMALL_BUFF)\n",
        "\n",
        "        names = VGroup(name, subname)\n",
        "        names.set_width(8)\n",
        "        names.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add_vectors_circles_path()\n",
        "        n = 6\n",
        "        self.circles[n:].set_opacity(0)\n",
        "        self.circles[:n].set_stroke(width=3)\n",
        "        path = self.drawn_path\n",
        "        # path.set_stroke(BLACK, 8, background=True)\n",
        "        # path = self.path\n",
        "        # path.set_stroke(YELLOW, 5)\n",
        "        # path.set_stroke(BLACK, 8, background=True)\n",
        "        self.add(path, self.circles, self.vectors)\n",
        "\n",
        "        self.update_mobjects(0)\n"
    ]
}