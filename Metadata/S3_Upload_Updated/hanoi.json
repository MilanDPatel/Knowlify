{
    "topic": "[Mathematical Concept: Pythagorean Theorem]  The code demonstrates",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "class CountingScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"base\" : 10,\n",
        "        \"power_colors\" : [YELLOW, MAROON_B, RED, GREEN, BLUE, PURPLE_D],\n",
        "        \"counting_dot_starting_position\" : (FRAME_X_RADIUS-1)*RIGHT + (FRAME_Y_RADIUS-1)*UP,\n",
        "        \"count_dot_starting_radius\" : 0.5,\n",
        "        \"dot_configuration_height\" : 2,\n",
        "        \"ones_configuration_location\" : UP+2*RIGHT,\n",
        "        \"num_scale_factor\" : 2,\n",
        "        \"num_start_location\" : 2*DOWN,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.dots = VGroup()\n",
        "        self.number = 0        \n",
        "        self.number_mob = VGroup(OldTex(str(self.number)))\n",
        "        self.number_mob.scale(self.num_scale_factor)\n",
        "        self.number_mob.shift(self.num_start_location)\n",
        "        self.digit_width = self.number_mob.get_width()\n",
        "\n",
        "        self.initialize_configurations()\n",
        "        self.arrows = VGroup()\n",
        "        self.add(self.number_mob)\n",
        "\n",
        "    def get_template_configuration(self):\n",
        "        #This should probably be replaced for non-base-10 counting scenes\n",
        "        down_right = (0.5)*RIGHT + (np.sqrt(3)/2)*DOWN\n",
        "        result = []\n",
        "        for down_right_steps in range(5):\n",
        "            for left_steps in range(down_right_steps):\n",
        "                result.append(\n",
        "                    down_right_steps*down_right + left_steps*LEFT\n",
        "                )\n",
        "        return reversed(result[:self.base])\n",
        "\n",
        "    def get_dot_template(self):\n",
        "        #This should be replaced for non-base-10 counting scenes\n",
        "        down_right = (0.5)*RIGHT + (np.sqrt(3)/2)*DOWN\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                point, \n",
        "                radius = 0.25,\n",
        "                fill_opacity = 0,\n",
        "                stroke_width = 2,\n",
        "                stroke_color = WHITE,\n",
        "            )\n",
        "            for point in self.get_template_configuration()\n",
        "        ])\n",
        "        dots[-1].set_stroke(width = 0)\n",
        "        dots.set_height(self.dot_configuration_height)\n",
        "        return dots\n",
        "\n",
        "    def initialize_configurations(self):\n",
        "        self.dot_templates = []\n",
        "        self.dot_template_iterators = []\n",
        "        self.curr_configurations = []\n",
        "\n",
        "    def add_configuration(self):\n",
        "        new_template = self.get_dot_template()\n",
        "        new_template.move_to(self.ones_configuration_location)\n",
        "        left_vect = (new_template.get_width()+LARGE_BUFF)*LEFT\n",
        "        new_template.shift(\n",
        "            left_vect*len(self.dot_templates)\n",
        "        )\n",
        "        self.dot_templates.append(new_template)\n",
        "        self.dot_template_iterators.append(\n",
        "            it.cycle(new_template)\n",
        "        )\n",
        "        self.curr_configurations.append(VGroup())\n",
        "\n",
        "    def count(self, max_val, run_time_per_anim = 1):\n",
        "        for x in range(max_val):\n",
        "            self.increment(run_time_per_anim)\n",
        "\n",
        "    def increment(self, run_time_per_anim = 1, added_anims = [], total_run_time = None):\n",
        "        run_all_at_once = (total_run_time is not None)\n",
        "        if run_all_at_once:\n",
        "            num_rollovers = self.get_num_rollovers()\n",
        "            run_time_per_anim = float(total_run_time)/(num_rollovers+1)\n",
        "        moving_dot = Dot(\n",
        "            self.counting_dot_starting_position,\n",
        "            radius = self.count_dot_starting_radius,\n",
        "            color = self.power_colors[0],\n",
        "        )\n",
        "        moving_dot.generate_target()\n",
        "        moving_dot.set_fill(opacity = 0)\n",
        "\n",
        "        continue_rolling_over = True\n",
        "        place = 0\n",
        "        self.number += 1\n",
        "        added_anims = list(added_anims) #Silly python objects...\n",
        "        added_anims += self.get_new_configuration_animations()\n",
        "        while continue_rolling_over:          \n",
        "            moving_dot.target.replace(\n",
        "                next(self.dot_template_iterators[place])\n",
        "            )\n",
        "            if run_all_at_once:\n",
        "                denom = float(num_rollovers+1)\n",
        "                start_t = place/denom\n",
        "                def get_modified_rate_func(anim):\n",
        "                    return lambda t : anim.original_rate_func(\n",
        "                        start_t + t/denom\n",
        "                    )\n",
        "                for anim in added_anims:\n",
        "                    if not hasattr(anim, \"original_rate_func\"):\n",
        "                        anim.original_rate_func = anim.rate_func\n",
        "                    anim.rate_func = get_modified_rate_func(anim)\n",
        "            self.play(\n",
        "                MoveToTarget(moving_dot), \n",
        "                *added_anims, \n",
        "                run_time = run_time_per_anim\n",
        "            )\n",
        "            self.curr_configurations[place].add(moving_dot)\n",
        "            if not run_all_at_once:\n",
        "                added_anims = []\n",
        "\n",
        "\n",
        "            if len(self.curr_configurations[place].split()) == self.base:\n",
        "                full_configuration = self.curr_configurations[place]\n",
        "                self.curr_configurations[place] = VGroup()\n",
        "                place += 1\n",
        "                center = full_configuration.get_center_of_mass()\n",
        "                radius = 0.6*max(\n",
        "                    full_configuration.get_width(),\n",
        "                    full_configuration.get_height(),\n",
        "                )\n",
        "                circle = Circle(\n",
        "                    radius = radius,\n",
        "                    stroke_width = 0,\n",
        "                    fill_color = self.power_colors[place],\n",
        "                    fill_opacity = 0.5,\n",
        "                )\n",
        "                circle.move_to(center)\n",
        "                moving_dot = VGroup(circle, full_configuration)\n",
        "                moving_dot.generate_target()\n",
        "                moving_dot[0].set_fill(opacity = 0)\n",
        "            else:\n",
        "                continue_rolling_over = False\n",
        "        self.play(*self.get_digit_increment_animations())\n",
        "\n",
        "    def get_new_configuration_animations(self):\n",
        "        if self.is_perfect_power():\n",
        "            self.add_configuration()\n",
        "            return [FadeIn(self.dot_templates[-1])]\n",
        "        else:\n",
        "            return []\n",
        "\n",
        "    def get_digit_increment_animations(self):\n",
        "        result = []\n",
        "        new_number_mob = self.get_number_mob(self.number)\n",
        "        new_number_mob.move_to(self.number_mob, RIGHT)\n",
        "        if self.is_perfect_power():\n",
        "            place = len(new_number_mob.split())-1\n",
        "            arrow = Arrow(\n",
        "                new_number_mob[place].get_top(),\n",
        "                self.dot_templates[place].get_bottom(),\n",
        "                color = self.power_colors[place]\n",
        "            )\n",
        "            self.arrows.add(arrow)\n",
        "            result.append(ShowCreation(arrow))\n",
        "        result.append(Transform(\n",
        "            self.number_mob, new_number_mob,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        return result\n",
        "\n",
        "    def get_number_mob(self, num):\n",
        "        result = VGroup()\n",
        "        place = 0\n",
        "        while num > 0:\n",
        "            digit = OldTex(str(num % self.base))\n",
        "            if place >= len(self.power_colors):\n",
        "                self.power_colors += self.power_colors\n",
        "            digit.set_color(self.power_colors[place])\n",
        "            digit.scale(self.num_scale_factor)\n",
        "            digit.move_to(result, RIGHT)\n",
        "            digit.shift(place*(self.digit_width+SMALL_BUFF)*LEFT)\n",
        "            result.add(digit)\n",
        "            num /= self.base\n",
        "            place += 1\n",
        "        return result\n",
        "\n",
        "    def is_perfect_power(self):\n",
        "        number = self.number\n",
        "        while number > 1:\n",
        "            if number%self.base != 0:\n",
        "                return False\n",
        "            number /= self.base\n",
        "        return True\n",
        "\n",
        "    def get_num_rollovers(self):\n",
        "        next_number = self.number + 1\n",
        "        result = 0\n",
        "        while next_number%self.base == 0:\n",
        "            result += 1\n",
        "            next_number /= self.base\n",
        "        return result\n",
        "\n",
        "class BinaryCountingScene(CountingScene):\n",
        "    CONFIG = {\n",
        "        \"base\" : 2,\n",
        "        \"dot_configuration_height\" : 1,\n",
        "        \"ones_configuration_location\" : UP+5*RIGHT\n",
        "    }\n",
        "    def get_template_configuration(self):\n",
        "        return [ORIGIN, UP]\n",
        "\n",
        "class CountInDecimal(CountingScene):\n",
        "    def construct(self):\n",
        "        for x in range(11):\n",
        "            self.increment()\n",
        "        for x in range(85):\n",
        "            self.increment(0.25)\n",
        "        for x in range(20):\n",
        "            self.increment()\n",
        "\n",
        "class CountInTernary(CountingScene):\n",
        "    CONFIG = {\n",
        "        \"base\" : 3,\n",
        "        \"dot_configuration_height\" : 1,\n",
        "        \"ones_configuration_location\" : UP+4*RIGHT\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.count(27)\n",
        "\n",
        "    # def get_template_configuration(self):\n",
        "    #     return [ORIGIN, UP]\n",
        "\n",
        "class CountTo27InTernary(CountInTernary):\n",
        "    def construct(self):\n",
        "        for x in range(27):\n",
        "            self.increment()\n",
        "        self.wait()\n",
        "\n",
        "class CountInBinaryTo256(BinaryCountingScene):\n",
        "    def construct(self):\n",
        "        self.count(256, 0.25)\n",
        "\n",
        "class TowersOfHanoiScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"disk_start_and_end_colors\" : [BLUE_E, BLUE_A],\n",
        "        \"num_disks\" : 5,\n",
        "        \"peg_width\" : 0.25,\n",
        "        \"peg_height\" : 2.5,\n",
        "        \"peg_spacing\" : 4,\n",
        "        \"include_peg_labels\" : True,\n",
        "        \"middle_peg_bottom\" : 0.5*DOWN,\n",
        "        \"disk_height\" : 0.4,\n",
        "        \"disk_min_width\" : 1,\n",
        "        \"disk_max_width\" : 3,\n",
        "        \"default_disk_run_time_off_peg\" : 1,\n",
        "        \"default_disk_run_time_on_peg\" : 2,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.add_pegs()\n",
        "        self.add_disks()\n",
        "\n",
        "    def add_pegs(self):\n",
        "        peg = Rectangle(\n",
        "            height = self.peg_height,\n",
        "            width = self.peg_width, \n",
        "            stroke_width = 0,\n",
        "            fill_color = GREY_BROWN,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        peg.move_to(self.middle_peg_bottom, DOWN)\n",
        "        self.pegs = VGroup(*[\n",
        "            peg.copy().shift(vect)\n",
        "            for vect in (self.peg_spacing*LEFT, ORIGIN, self.peg_spacing*RIGHT)\n",
        "        ])\n",
        "        self.add(self.pegs)\n",
        "        if self.include_peg_labels:\n",
        "            self.peg_labels = VGroup(*[\n",
        "                OldTex(char).next_to(peg, DOWN)\n",
        "                for char, peg in zip(\"ABC\", self.pegs)\n",
        "            ])\n",
        "            self.add(self.peg_labels)\n",
        "\n",
        "    def add_disks(self):\n",
        "        self.disks = VGroup(*[\n",
        "            Rectangle(\n",
        "                height = self.disk_height,\n",
        "                width = width,\n",
        "                fill_color = color,\n",
        "                fill_opacity = 0.8,\n",
        "                stroke_width = 0,\n",
        "            )\n",
        "            for width, color in zip(\n",
        "                np.linspace(\n",
        "                    self.disk_min_width, \n",
        "                    self.disk_max_width,\n",
        "                    self.num_disks\n",
        "                ),\n",
        "                color_gradient(\n",
        "                    self.disk_start_and_end_colors,\n",
        "                    self.num_disks\n",
        "                )\n",
        "            )\n",
        "        ])\n",
        "        for number, disk in enumerate(self.disks):\n",
        "            label = OldTex(str(number))\n",
        "            label.set_color(BLACK)\n",
        "            label.set_height(self.disk_height/2)\n",
        "            label.move_to(disk)\n",
        "            disk.add(label)\n",
        "            disk.label = label\n",
        "        self.reset_disks(run_time = 0)\n",
        "\n",
        "        self.add(self.disks)\n",
        "\n",
        "    def reset_disks(self, **kwargs):\n",
        "        self.disks.generate_target()\n",
        "        self.disks.target.arrange(DOWN, buff = 0)\n",
        "        self.disks.target.move_to(self.pegs[0], DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(self.disks), \n",
        "            **kwargs\n",
        "        )\n",
        "        self.disk_tracker = [\n",
        "            set(range(self.num_disks)),\n",
        "            set([]),\n",
        "            set([])\n",
        "        ]\n",
        "\n",
        "    def disk_index_to_peg_index(self, disk_index):\n",
        "        for index, disk_set in enumerate(self.disk_tracker):\n",
        "            if disk_index in disk_set:\n",
        "                return index\n",
        "        raise Exception(\"Somehow this disk wasn't accounted for...\")\n",
        "\n",
        "    def min_disk_index_on_peg(self, peg_index):\n",
        "        disk_index_set = self.disk_tracker[peg_index]\n",
        "        if disk_index_set:\n",
        "            return min(self.disk_tracker[peg_index])\n",
        "        else:\n",
        "            return self.num_disks\n",
        "\n",
        "    def bottom_point_for_next_disk(self, peg_index):\n",
        "        min_disk_index = self.min_disk_index_on_peg(peg_index)\n",
        "        if min_disk_index >= self.num_disks:\n",
        "            return self.pegs[peg_index].get_bottom()\n",
        "        else:\n",
        "            return self.disks[min_disk_index].get_top()\n",
        "\n",
        "    def get_next_disk_0_peg(self):\n",
        "        curr_peg_index = self.disk_index_to_peg_index(0)\n",
        "        return (curr_peg_index+1)%3\n",
        "\n",
        "    def get_available_peg(self, disk_index):\n",
        "        if disk_index == 0:\n",
        "            return self.get_next_disk_0_peg()\n",
        "        for index in range(len(list(self.pegs))):\n",
        "            if self.min_disk_index_on_peg(index) > disk_index:\n",
        "                return index\n",
        "        raise Exception(\"Tower's of Honoi rule broken: No available disks\")\n",
        "\n",
        "    def set_disk_config(self, peg_indices):\n",
        "        assert(len(peg_indices) == self.num_disks)\n",
        "        self.disk_tracker = [set([]) for x in range(3)]\n",
        "        for n, peg_index in enumerate(peg_indices):\n",
        "            disk_index = self.num_disks - n - 1\n",
        "            disk = self.disks[disk_index]\n",
        "            peg = self.pegs[peg_index]\n",
        "            disk.move_to(peg.get_bottom(), DOWN)\n",
        "            n_disks_here = len(self.disk_tracker[peg_index])\n",
        "            disk.shift(disk.get_height()*n_disks_here*UP)\n",
        "            self.disk_tracker[peg_index].add(disk_index)\n",
        "\n",
        "    def move_disk(self, disk_index, **kwargs):\n",
        "        next_peg_index = self.get_available_peg(disk_index)\n",
        "        self.move_disk_to_peg(disk_index, next_peg_index, **kwargs)\n",
        "\n",
        "    def move_subtower_to_peg(self, num_disks, next_peg_index, **kwargs):\n",
        "        disk_indices = list(range(num_disks))\n",
        "        peg_indices = list(map(self.disk_index_to_peg_index, disk_indices))\n",
        "        if len(set(peg_indices)) != 1:\n",
        "            warnings.warn(\"These disks don't make up a tower right now\")\n",
        "        self.move_disks_to_peg(disk_indices, next_peg_index, **kwargs)\n",
        "\n",
        "    def move_disk_to_peg(self, disk_index, next_peg_index, **kwargs):\n",
        "        self.move_disks_to_peg([disk_index], next_peg_index, **kwargs)\n",
        "\n",
        "    def move_disks_to_peg(self, disk_indices, next_peg_index, run_time = None, stay_on_peg = True, added_anims = []):\n",
        "        if run_time is None:\n",
        "            if stay_on_peg is True:\n",
        "                run_time = self.default_disk_run_time_on_peg\n",
        "            else:\n",
        "                run_time = self.default_disk_run_time_off_peg\n",
        "        disks = VGroup(*[self.disks[index] for index in disk_indices])\n",
        "        max_disk_index = max(disk_indices)\n",
        "        next_peg = self.pegs[next_peg_index]        \n",
        "        curr_peg_index = self.disk_index_to_peg_index(max_disk_index)\n",
        "        curr_peg = self.pegs[curr_peg_index]\n",
        "        if self.min_disk_index_on_peg(curr_peg_index) != max_disk_index:\n",
        "            warnings.warn(\"Tower's of Hanoi rule broken: disk has crap on top of it\")\n",
        "        target_bottom_point = self.bottom_point_for_next_disk(next_peg_index)\n",
        "        path_arc = np.sign(curr_peg_index-next_peg_index)*np.pi/3\n",
        "        if stay_on_peg:\n",
        "            self.play(\n",
        "                Succession(\n",
        "                    ApplyMethod(disks.next_to, curr_peg, UP, 0),\n",
        "                    ApplyMethod(disks.next_to, next_peg, UP, 0, path_arc = path_arc),\n",
        "                    ApplyMethod(disks.move_to, target_bottom_point, DOWN),\n",
        "                ),\n",
        "                *added_anims,\n",
        "                run_time = run_time,\n",
        "                rate_func = lambda t : smooth(t, 2)\n",
        "            )\n",
        "        else:\n",
        "            self.play(\n",
        "                ApplyMethod(disks.move_to, target_bottom_point, DOWN),\n",
        "                *added_anims,\n",
        "                path_arc = path_arc*2,\n",
        "                run_time = run_time,\n",
        "                rate_func = lambda t : smooth(t, 2)\n",
        "            )\n",
        "        for disk_index in disk_indices:\n",
        "            self.disk_tracker[curr_peg_index].remove(disk_index)\n",
        "            self.disk_tracker[next_peg_index].add(disk_index)\n",
        "\n",
        "class ConstrainedTowersOfHanoiScene(TowersOfHanoiScene):\n",
        "    def get_next_disk_0_peg(self):\n",
        "        if not hasattr(self, \"total_disk_0_movements\"):\n",
        "            self.total_disk_0_movements = 0\n",
        "        curr_peg_index = self.disk_index_to_peg_index(0)        \n",
        "        if (self.total_disk_0_movements/2)%2 == 0:\n",
        "            result = curr_peg_index + 1\n",
        "        else:\n",
        "            result = curr_peg_index - 1\n",
        "        self.total_disk_0_movements += 1\n",
        "        return result\n",
        "\n",
        "def get_ruler_sequence(order = 4):\n",
        "    if order == -1:\n",
        "        return []\n",
        "    else:\n",
        "        smaller = get_ruler_sequence(order - 1)\n",
        "        return smaller + [order] + smaller\n",
        "\n",
        "def get_ternary_ruler_sequence(order = 4):\n",
        "    if order == -1:\n",
        "        return []\n",
        "    else:\n",
        "        smaller = get_ternary_ruler_sequence(order-1)\n",
        "        return smaller+[order]+smaller+[order]+smaller\n",
        "\n",
        "class SolveHanoi(TowersOfHanoiScene):\n",
        "    def construct(self):\n",
        "        self.wait()\n",
        "        for x in get_ruler_sequence(self.num_disks-1):\n",
        "            self.move_disk(x, stay_on_peg = False)\n",
        "        self.wait()\n",
        "\n",
        "class SolveConstrainedHanoi(ConstrainedTowersOfHanoiScene):\n",
        "    def construct(self):\n",
        "        self.wait()\n",
        "        for x in get_ternary_ruler_sequence(self.num_disks-1):\n",
        "            self.move_disk(x, run_time = 0.5, stay_on_peg = False)\n",
        "        self.wait()\n",
        "\n",
        "class Keith(PiCreature):\n",
        "    CONFIG = {\n",
        "        \"color\" : GREEN_D\n",
        "    }\n",
        "        \n",
        "def get_binary_tex_mobs(num_list):\n",
        "    result = VGroup()\n",
        "    zero_width = OldTex(\"0\").get_width()\n",
        "    nudge = zero_width + SMALL_BUFF\n",
        "    for num in num_list:\n",
        "        bin_string = bin(num)[2:]#Strip off the \"0b\" prefix\n",
        "        bits = VGroup(*list(map(Tex, bin_string)))\n",
        "        for n, bit in enumerate(bits):\n",
        "            bit.shift(n*nudge*RIGHT)\n",
        "        bits.move_to(ORIGIN, RIGHT)\n",
        "        result.add(bits)\n",
        "    return result\n",
        "\n",
        "def get_base_b_tex_mob(number, base, n_digits):\n",
        "    assert(number < base**n_digits)\n",
        "    curr_digit = n_digits - 1\n",
        "    zero = OldTex(\"0\")\n",
        "    zero_width = zero.get_width()\n",
        "    zero_height = zero.get_height()\n",
        "    result = VGroup()\n",
        "    for place in range(n_digits):\n",
        "        remainder = number%base\n",
        "        digit_mob = OldTex(str(remainder))\n",
        "        digit_mob.set_height(zero_height)\n",
        "        digit_mob.shift(place*(zero_width+SMALL_BUFF)*LEFT)\n",
        "        result.add(digit_mob)\n",
        "        number = (number - remainder)/base\n",
        "    return result.center()\n",
        "\n",
        "def get_binary_tex_mob(number, n_bits = 4):\n",
        "    return get_base_b_tex_mob(number, 2, n_bits)\n",
        "\n",
        "def get_ternary_tex_mob(number, n_trits = 4):\n",
        "    return get_base_b_tex_mob(number, 3, n_trits)\n",
        "\n",
        "\n",
        "####################\n",
        "\n",
        "class IntroduceKeith(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer(mode = \"happy\")\n",
        "        keith = Keith(mode = \"dance_kick\")\n",
        "        keith_image = ImageMobject(\"keith_schwarz\", invert = False)\n",
        "        # keith_image = Rectangle()\n",
        "        keith_image.set_height(FRAME_HEIGHT - 2)\n",
        "        keith_image.next_to(ORIGIN, LEFT)\n",
        "        keith.move_to(keith_image, DOWN+RIGHT)\n",
        "        morty.next_to(keith, buff = LARGE_BUFF, aligned_edge = DOWN)\n",
        "        morty.make_eye_contact(keith)\n",
        "        randy = Randolph().next_to(keith, LEFT, LARGE_BUFF, aligned_edge = DOWN)\n",
        "        randy.shift_onto_screen()\n",
        "\n",
        "        bubble = keith.get_bubble(SpeechBubble, width = 7)\n",
        "        bubble.write(\"01101011 $\\\\Rightarrow$ Towers of Hanoi\")\n",
        "        zero_width = bubble.content[0].get_width()\n",
        "        one_width = bubble.content[1].get_width()        \n",
        "        for mob in bubble.content[:8]:\n",
        "            if abs(mob.get_width() - zero_width) < 0.01:\n",
        "                mob.set_color(GREEN)\n",
        "            else:\n",
        "                mob.set_color(YELLOW)\n",
        "\n",
        "        bubble.resize_to_content()\n",
        "        bubble.pin_to(keith)\n",
        "        VGroup(bubble, bubble.content).shift(DOWN)\n",
        "\n",
        "        randy.bubble = randy.get_bubble(SpeechBubble, height = 3)\n",
        "        randy.bubble.write(\"Wait, what's \\\\\\\\ Towers of Hanoi?\")\n",
        "\n",
        "        title = OldTexText(\"Keith Schwarz (Computer scientist)\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(keith_image, morty)\n",
        "        self.play(Write(title))\n",
        "        self.play(FadeIn(keith, run_time = 2))\n",
        "        self.play(FadeOut(keith_image), Animation(keith))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            keith.set_height, morty.get_height(),\n",
        "            keith.next_to, morty, LEFT, LARGE_BUFF,\n",
        "            run_time = 1.5\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, bubble\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.wait()\n",
        "        original_content = bubble.content\n",
        "        bubble.write(\"I'm usually meh \\\\\\\\ on puzzles\")\n",
        "        self.play(\n",
        "            keith.change_mode, \"hesitant\",\n",
        "            Transform(original_content, bubble.content),\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"happy\",\n",
        "            morty.look_at, keith.eyes\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        bubble.write(\"But \\\\emph{analyzing} puzzles!\")\n",
        "        VGroup(*bubble.content[3:12]).set_color(YELLOW)\n",
        "        self.play(\n",
        "            keith.change_mode, \"hooray\",\n",
        "            Transform(original_content, bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, keith.eyes,\n",
        "            keith.change_mode, \"plain\",\n",
        "            keith.look_at, randy.eyes,\n",
        "            morty.change_mode, \"plain\",\n",
        "            morty.look_at, randy.eyes,\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(original_content),\n",
        "            ShowCreation(randy.bubble),\n",
        "            Write(randy.bubble.content)\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.play(\n",
        "            keith.change_mode, \"hooray\",\n",
        "            keith.look_at, randy.eyes\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceTowersOfHanoi(TowersOfHanoiScene):\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        self.add_title()\n",
        "        self.show_setup()\n",
        "        self.note_disk_labels()\n",
        "        self.show_more_disk_possibility()\n",
        "        self.move_full_tower()\n",
        "        self.move_single_disk()\n",
        "        self.cannot_move_disk_onto_smaller_disk()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Towers of Hanoi\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_setup(self):\n",
        "        self.pegs.save_state()\n",
        "        bottom = self.pegs.get_bottom()\n",
        "        self.pegs.stretch_to_fit_height(0)\n",
        "        self.pegs.move_to(bottom)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.pegs.restore, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Write(self.peg_labels)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.bring_in_disks()\n",
        "        self.wait()\n",
        "\n",
        "    def bring_in_disks(self):\n",
        "        peg = self.pegs[0]\n",
        "        disk_groups = VGroup()\n",
        "        for disk in self.disks:\n",
        "            top = Circle(radius = disk.get_width()/2)\n",
        "            inner = Circle(radius = self.peg_width/2)\n",
        "            inner.flip()\n",
        "            top.add_subpath(inner.points)\n",
        "            top.set_stroke(width = 0)\n",
        "            top.set_fill(disk.get_color())\n",
        "            top.rotate(np.pi/2, RIGHT)\n",
        "            top.move_to(disk, UP)\n",
        "            bottom = top.copy()\n",
        "            bottom.move_to(disk, DOWN)\n",
        "            group = VGroup(disk, top, bottom)\n",
        "            group.truly_original_state = group.copy()\n",
        "            group.next_to(peg, UP, 0)\n",
        "            group.rotate(-np.pi/24, RIGHT)\n",
        "            group.save_state()\n",
        "            group.rotate(-11*np.pi/24, RIGHT)\n",
        "            disk.set_fill(opacity = 0)\n",
        "            disk_groups.add(group)\n",
        "        disk_groups.arrange()\n",
        "        disk_groups.next_to(self.peg_labels, DOWN)\n",
        "        \n",
        "        self.play(FadeIn(\n",
        "            disk_groups, \n",
        "            run_time = 2, \n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        for group in reversed(list(disk_groups)):\n",
        "            self.play(group.restore)\n",
        "            self.play(Transform(group, group.truly_original_state))\n",
        "        self.remove(disk_groups)\n",
        "        self.add(self.disks)\n",
        "\n",
        "    def note_disk_labels(self):\n",
        "        labels = [disk.label for disk in self.disks]\n",
        "        last = VGroup().save_state()\n",
        "        for label in labels:\n",
        "            label.save_state()\n",
        "            self.play(\n",
        "                label.scale, 2,\n",
        "                label.set_color, YELLOW,\n",
        "                last.restore,\n",
        "                run_time = 0.5\n",
        "            )\n",
        "            last = label\n",
        "        self.play(last.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def show_more_disk_possibility(self):\n",
        "        original_num_disks = self.num_disks\n",
        "        original_disk_height = self.disk_height\n",
        "        original_disks = self.disks\n",
        "        original_disks_copy = original_disks.copy()\n",
        "\n",
        "        #Hacky\n",
        "        self.num_disks = 10\n",
        "        self.disk_height = 0.3\n",
        "        self.add_disks()\n",
        "        new_disks = self.disks\n",
        "        self.disks = original_disks\n",
        "        self.remove(new_disks)\n",
        "\n",
        "        self.play(Transform(self.disks, new_disks))\n",
        "        self.wait()\n",
        "        self.play(Transform(self.disks, original_disks_copy))\n",
        "\n",
        "        self.remove(self.disks)\n",
        "        self.disks = original_disks_copy\n",
        "        self.add(self.disks)\n",
        "        self.wait()\n",
        "\n",
        "        self.num_disks = original_num_disks\n",
        "        self.disk_height = original_disk_height\n",
        "\n",
        "    def move_full_tower(self):\n",
        "        self.move_subtower_to_peg(self.num_disks, 1, run_time = 2)\n",
        "        self.wait()\n",
        "        self.reset_disks(run_time = 1, lag_ratio = 0.5)\n",
        "        self.wait()\n",
        "\n",
        "    def move_single_disk(self):\n",
        "        for x in 0, 1, 0:\n",
        "            self.move_disk(x)\n",
        "        self.wait()\n",
        "\n",
        "    def cannot_move_disk_onto_smaller_disk(self):\n",
        "        also_not_allowed = OldTexText(\"Not allowed\")\n",
        "        also_not_allowed.to_edge(UP)\n",
        "        also_not_allowed.set_color(RED)\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.set_fill(RED, opacity = 0.5)\n",
        "\n",
        "        disk = self.disks[2]\n",
        "        disk.save_state()\n",
        "        self.move_disks_to_peg([2], 2, added_anims = [\n",
        "            Transform(self.title, also_not_allowed, run_time = 1)\n",
        "        ])\n",
        "        cross.replace(disk)\n",
        "        self.play(FadeIn(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(cross),\n",
        "            FadeOut(self.title),\n",
        "            disk.restore\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ExampleFirstMoves(TowersOfHanoiScene):\n",
        "    def construct(self):\n",
        "        ruler_sequence = get_ruler_sequence(4)\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.set_fill(RED, 0.7)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.disks[0].set_fill, YELLOW,\n",
        "            self.disks[0].label.set_color, BLACK\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_disk(0)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.disks[1].set_fill, YELLOW_D,\n",
        "            self.disks[1].label.set_color, BLACK\n",
        "        )\n",
        "        self.move_disk_to_peg(1, 1)\n",
        "        cross.replace(self.disks[1])\n",
        "        self.play(FadeIn(cross))\n",
        "        self.wait()\n",
        "        self.move_disk_to_peg(1, 2, added_anims = [FadeOut(cross)])\n",
        "        self.wait()\n",
        "        for x in ruler_sequence[2:9]:\n",
        "            self.move_disk(x)\n",
        "        for x in ruler_sequence[9:]:\n",
        "            self.move_disk(x, run_time = 0.5, stay_on_peg = False)\n",
        "        self.wait()\n",
        "\n",
        "class KeithShowingBinary(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        keith.next_to(morty, LEFT, buff = 2*LARGE_BUFF)\n",
        "        randy = Randolph()\n",
        "        randy.next_to(keith, LEFT, buff = 2*LARGE_BUFF)\n",
        "        randy.bubble = randy.get_bubble(SpeechBubble)\n",
        "        randy.bubble.set_fill(BLACK, opacity = 1)\n",
        "        randy.bubble.write(\"Hold on...how does \\\\\\\\ binary work again?\")\n",
        "\n",
        "        binary_tex_mobs = get_binary_tex_mobs(list(range(16)))\n",
        "        binary_tex_mobs.shift(keith.get_corner(UP+LEFT))\n",
        "        binary_tex_mobs.shift(0.5*(UP+RIGHT))\n",
        "        bits_list = binary_tex_mobs.split()\n",
        "        bits = bits_list.pop(0)\n",
        "\n",
        "        def get_bit_flip():\n",
        "            return Transform(\n",
        "                bits, bits_list.pop(0),\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.7)\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            keith.change_mode, \"wave_1\",\n",
        "            keith.look_at, bits,\n",
        "            morty.look_at, bits,\n",
        "            Write(bits)\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(get_bit_flip())\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, bits,\n",
        "            get_bit_flip()\n",
        "        )\n",
        "        while bits_list:\n",
        "            added_anims = []\n",
        "            if random.random() < 0.2:\n",
        "                if random.random() < 0.5:\n",
        "                    added_anims.append(Blink(keith))\n",
        "                else:\n",
        "                    added_anims.append(Blink(morty))\n",
        "            self.play(get_bit_flip(), *added_anims)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            morty.change_mode, \"plain\",\n",
        "            morty.look_at, randy.eyes,\n",
        "            keith.change_mode, \"plain\",\n",
        "            keith.look_at, randy.eyes,\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            ShowCreation(randy.bubble),\n",
        "            Write(randy.bubble.content)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(morty.change_mode, \"hooray\")\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class FocusOnRhythm(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Focus on rhythm\")\n",
        "        title.scale(1.5)\n",
        "        letters = list(reversed(title[-6:]))\n",
        "        self.play(Write(title, run_time = 1))\n",
        "        sequence = get_ruler_sequence(5)\n",
        "        for x in sequence:\n",
        "            movers = VGroup(*letters[:x+1])\n",
        "            self.play(\n",
        "                movers.shift, 0.2*DOWN,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 0.25\n",
        "            )\n",
        "\n",
        "class IntroduceBase10(Scene):\n",
        "    def construct(self):\n",
        "        self.expand_example_number()\n",
        "        self.list_digits()\n",
        "\n",
        "    def expand_example_number(self):\n",
        "        title = OldTexText(\"``Base 10''\")\n",
        "        title.to_edge(UP)\n",
        "        number = OldTex(\"137\")\n",
        "        number.next_to(title, DOWN)\n",
        "        number.shift(2*LEFT)\n",
        "\n",
        "        colors = [RED, MAROON_B, YELLOW]\n",
        "        expansion = OldTex(\n",
        "            \"1(100) + \",\n",
        "            \"3(10) + \",\n",
        "            \"7\"\n",
        "        )\n",
        "        expansion.next_to(number, DOWN, buff = LARGE_BUFF, aligned_edge = RIGHT)        \n",
        "        arrows = VGroup()\n",
        "        number.generate_target()\n",
        "\n",
        "        for color, digit, term in zip(colors, number.target, expansion):\n",
        "            digit.set_color(color)\n",
        "            term.set_color(color)\n",
        "            arrow = Arrow(digit, term.get_top())\n",
        "            arrow.set_color(color)\n",
        "            arrows.add(arrow)\n",
        "        expansion.save_state()\n",
        "        for digit, term in zip(number, expansion):\n",
        "            Transform(term, digit).update(1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(number),\n",
        "            ShowCreation(arrows),\n",
        "            ApplyMethod(\n",
        "                expansion.restore, lag_ratio = 0.5),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        self.title = title\n",
        "\n",
        "    def list_digits(self):\n",
        "        digits = OldTexText(\"\"\"\n",
        "            0, 1, 2, 3, 4,\n",
        "            5, 6, 7, 8, 9\n",
        "        \"\"\")\n",
        "        digits.next_to(self.title, DOWN, buff = LARGE_BUFF)\n",
        "        digits.shift(2*RIGHT)\n",
        "        self.play(Write(digits))\n",
        "        self.wait()\n",
        "\n",
        "class RhythmOfDecimalCounting(CountingScene):\n",
        "    CONFIG = {\n",
        "        \"ones_configuration_location\" : 2*UP+2*RIGHT,\n",
        "        \"num_start_location\" : DOWN\n",
        "    }\n",
        "    def construct(self):\n",
        "        for x in range(10):\n",
        "            self.increment()\n",
        "        brace = Brace(self.number_mob)\n",
        "        two_digits = brace.get_text(\"Two digits\")\n",
        "        one_brace = Brace(self.number_mob[-1])\n",
        "        tens_place = one_brace.get_text(\"Ten's place\")\n",
        "        ten_group = self.curr_configurations[1][0]\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(two_digits, run_time = 1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Transform(brace, one_brace),\n",
        "            Transform(two_digits, tens_place)\n",
        "        )\n",
        "        self.wait()\n",
        "        ten_group.save_state()\n",
        "        self.play(\n",
        "            ten_group.scale, 7,\n",
        "            ten_group.shift, 2*(DOWN+LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ten_group.restore,\n",
        "            *list(map(FadeOut, [brace, two_digits]))\n",
        "        )\n",
        "\n",
        "        for x in range(89):\n",
        "            self.increment(run_time_per_anim = 0.25)\n",
        "        self.increment(run_time_per_anim = 1)\n",
        "        self.wait()\n",
        "\n",
        "        hundred_group = self.curr_configurations[2][0]\n",
        "        hundred_group.save_state()\n",
        "        self.play(\n",
        "            hundred_group.scale, 14,\n",
        "            hundred_group.to_corner, DOWN+LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(hundred_group.restore)\n",
        "        self.wait()\n",
        "        groups = [\n",
        "            VGroup(*pair)\n",
        "            for pair in zip(self.dot_templates, self.curr_configurations)\n",
        "        ]\n",
        "        self.play(\n",
        "            groups[2].to_edge, RIGHT,\n",
        "            MaintainPositionRelativeTo(groups[1], groups[2]),\n",
        "            MaintainPositionRelativeTo(groups[0], groups[2]),\n",
        "            self.number_mob.to_edge, RIGHT, LARGE_BUFF,\n",
        "            FadeOut(self.arrows)\n",
        "        )\n",
        "\n",
        "class DecimalCountingAtHundredsScale(CountingScene):\n",
        "    CONFIG = {\n",
        "        \"power_colors\" : [RED, GREEN, BLUE, PURPLE_D],\n",
        "        \"counting_dot_starting_position\" : (FRAME_X_RADIUS+1)*RIGHT + (FRAME_Y_RADIUS-2)*UP,\n",
        "        \"ones_configuration_location\" : 2*UP+5.7*RIGHT,\n",
        "        \"num_start_location\" : DOWN + 3*RIGHT\n",
        "    }\n",
        "    def construct(self):\n",
        "        added_zeros = OldTex(\"00\")\n",
        "        added_zeros.scale(self.num_scale_factor)\n",
        "        added_zeros.next_to(self.number_mob, RIGHT, SMALL_BUFF, aligned_edge = DOWN)\n",
        "        added_zeros.set_color_by_gradient(MAROON_B, YELLOW)\n",
        "        self.add(added_zeros)\n",
        "        self.increment(run_time_per_anim = 0)\n",
        "\n",
        "        VGroup(self.number_mob, added_zeros).to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        VGroup(self.dot_templates[0], self.curr_configurations[0]).to_edge(RIGHT)\n",
        "        Transform(\n",
        "            self.arrows[0], \n",
        "            Arrow(self.number_mob, self.dot_templates[0], color = self.power_colors[0])\n",
        "        ).update(1)\n",
        "\n",
        "        for x in range(10):\n",
        "            this_range = list(range(8)) if x == 0 else list(range(9))\n",
        "            for y in this_range:\n",
        "                self.increment(run_time_per_anim = 0.25)\n",
        "            self.increment(run_time_per_anim = 1)\n",
        "\n",
        "class IntroduceBinaryCounting(BinaryCountingScene):\n",
        "    CONFIG = {\n",
        "        \"ones_configuration_location\" : UP+5*RIGHT,\n",
        "        \"num_start_location\" : DOWN+2*RIGHT\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_name()\n",
        "        self.initial_counting()\n",
        "        self.show_self_similarity()\n",
        "\n",
        "    def introduce_name(self):\n",
        "        title = OldTexText(\"Binary (base 2):\", \"0, 1\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.number_mob.set_fill(opacity = 0)\n",
        "\n",
        "        brace = Brace(title[1], buff = SMALL_BUFF)\n",
        "        bits = OldTexText(\"bi\", \"ts\", arg_separator = \"\")\n",
        "        bits.submobjects.insert(1, VectorizedPoint(bits.get_center()))\n",
        "        binary_digits = OldTexText(\"bi\", \"nary digi\", \"ts\", arg_separator = \"\")\n",
        "        for mob in bits, binary_digits:\n",
        "            mob.next_to(brace, DOWN, buff = SMALL_BUFF)\n",
        "        VGroup(brace, bits, binary_digits).set_color(BLUE)\n",
        "        binary_digits[1].set_color(BLUE_E)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(bits)\n",
        "        )\n",
        "        self.wait()\n",
        "        bits.save_state()\n",
        "        self.play(Transform(bits, binary_digits))\n",
        "        self.wait()\n",
        "        self.play(bits.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def initial_counting(self):\n",
        "        randy = Randolph().to_corner(DOWN+LEFT)\n",
        "        bubble = randy.get_bubble(ThoughtBubble, height = 3.4, width = 5)\n",
        "        bubble.write(\n",
        "            \"Not ten, not ten \\\\\\\\\",\n",
        "            \"\\\\quad not ten, not ten...\"\n",
        "        )\n",
        "\n",
        "        self.play(self.number_mob.set_fill, self.power_colors[0], 1)\n",
        "        self.increment()\n",
        "        self.wait()\n",
        "        self.start_dot = self.curr_configurations[0][0]\n",
        "\n",
        "        ##Up to 10\n",
        "        self.increment()\n",
        "        brace = Brace(self.number_mob[1])\n",
        "        twos_place = brace.get_text(\"Two's place\")\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(twos_place)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            ShowCreation(bubble)\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change_mode, \"hesitant\",\n",
        "            randy.look_at, self.number_mob,\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.wait()\n",
        "        curr_content = bubble.content\n",
        "        bubble.write(\"$1 \\\\! \\\\cdot \\\\! 2+$\", \"$0$\")\n",
        "        bubble.content[0][0].set_color(self.power_colors[1])\n",
        "        self.play(\n",
        "            Transform(curr_content, bubble.content),\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, self.number_mob\n",
        "        )\n",
        "        self.remove(curr_content)\n",
        "        self.add(bubble.content)\n",
        "\n",
        "        #Up to 11\n",
        "        zero = bubble.content[-1]\n",
        "        zero.set_color(self.power_colors[0])\n",
        "        one = OldTex(\"1\").replace(zero, dim_to_match = 1)\n",
        "        one.set_color(zero.get_color())\n",
        "        self.play(Blink(randy))\n",
        "        self.increment(added_anims = [Transform(zero, one)])\n",
        "        self.wait()\n",
        "\n",
        "        #Up to 100\n",
        "        curr_content = bubble.content\n",
        "        bubble.write(\n",
        "            \"$1 \\\\!\\\\cdot\\\\! 4 + $\",\n",
        "            \"$0 \\\\!\\\\cdot\\\\! 2 + $\",\n",
        "            \"$0$\",\n",
        "        )\n",
        "        colors = reversed(self.power_colors[:3])\n",
        "        for piece, color in zip(bubble.content.submobjects, colors):\n",
        "            piece[0].set_color(color)\n",
        "        self.increment(added_anims = [Transform(curr_content, bubble.content)])\n",
        "        four_brace = Brace(self.number_mob[-1])\n",
        "        fours_place = four_brace.get_text(\"Four's place\")\n",
        "        self.play(\n",
        "            Transform(brace, four_brace),\n",
        "            Transform(twos_place, fours_place),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(*list(map(FadeOut, [bubble, curr_content])))\n",
        "\n",
        "        #Up to 1000\n",
        "        for x in range(4):\n",
        "            self.increment()\n",
        "        brace.target = Brace(self.number_mob[-1])\n",
        "        twos_place.target = brace.get_text(\"Eight's place\")\n",
        "        self.play(\n",
        "            randy.change_mode, \"happy\",\n",
        "            randy.look_at, self.number_mob,\n",
        "            *list(map(MoveToTarget, [brace, twos_place]))\n",
        "        )\n",
        "        for x in range(8):\n",
        "            self.increment(total_run_time = 1)\n",
        "        self.wait()\n",
        "        for x in range(8):\n",
        "            self.increment(total_run_time = 1.5)\n",
        "\n",
        "    def show_self_similarity(self):\n",
        "        cover_rect = Rectangle()\n",
        "        cover_rect.set_width(FRAME_WIDTH)\n",
        "        cover_rect.set_height(FRAME_HEIGHT)\n",
        "        cover_rect.set_stroke(width = 0)\n",
        "        cover_rect.set_fill(BLACK, opacity = 0.85)\n",
        "        big_dot = self.curr_configurations[-1][0].copy()\n",
        "        self.play(\n",
        "            FadeIn(cover_rect),\n",
        "            Animation(big_dot)\n",
        "        )\n",
        "        self.play(\n",
        "            big_dot.center,\n",
        "            big_dot.set_height, FRAME_HEIGHT-2,\n",
        "            big_dot.to_edge, LEFT,\n",
        "            run_time = 5\n",
        "        )\n",
        "\n",
        "class BinaryCountingAtEveryScale(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_bits\" : 4,\n",
        "        \"show_title\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Count to %d (which is %s in binary)\"%(\n",
        "            2**self.num_bits-1, bin(2**self.num_bits-1)[2:]\n",
        "        ))\n",
        "        title.to_edge(UP)\n",
        "        if self.show_title:\n",
        "            self.add(title)\n",
        "\n",
        "        bit_mobs = [\n",
        "            get_binary_tex_mob(n, self.num_bits)\n",
        "            for n in range(2**self.num_bits)\n",
        "        ]\n",
        "        curr_bits = bit_mobs[0]\n",
        "\n",
        "        lower_brace = Brace(VGroup(*curr_bits[1:]))\n",
        "        do_a_thing = lower_brace.get_text(\"Do a thing\")\n",
        "        VGroup(lower_brace, do_a_thing).set_color(YELLOW)\n",
        "        upper_brace = Brace(curr_bits, UP)\n",
        "        roll_over = upper_brace.get_text(\"Roll over\")\n",
        "        VGroup(upper_brace, roll_over).set_color(MAROON_B)\n",
        "        again = OldTexText(\"again\")\n",
        "        again.next_to(do_a_thing, RIGHT, 2*SMALL_BUFF)\n",
        "        again.set_color(YELLOW)\n",
        "\n",
        "        self.add(curr_bits, lower_brace, do_a_thing)\n",
        "\n",
        "        def get_run_through(mobs):\n",
        "            return Succession(*[\n",
        "                Transform(\n",
        "                    curr_bits, mob, \n",
        "                    rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "                )\n",
        "                for mob in mobs\n",
        "            ], run_time = 1)\n",
        "\n",
        "        for bit_mob in bit_mobs:\n",
        "            curr_bits.align_data_and_family(bit_mob)\n",
        "            bit_mob.set_color(YELLOW)\n",
        "            bit_mob[0].set_color(MAROON_B)\n",
        "        self.play(get_run_through(bit_mobs[1:2**(self.num_bits-1)]))\n",
        "        self.play(*list(map(FadeIn, [upper_brace, roll_over])))\n",
        "        self.play(Transform(\n",
        "            VGroup(*reversed(list(curr_bits))),\n",
        "            VGroup(*reversed(list(bit_mobs[2**(self.num_bits-1)]))),\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            get_run_through(bit_mobs[2**(self.num_bits-1)+1:]),\n",
        "            Write(again)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class BinaryCountingAtSmallestScale(BinaryCountingAtEveryScale):\n",
        "    CONFIG = {\n",
        "        \"num_bits\" : 2,\n",
        "        \"show_title\" : True,\n",
        "    }\n",
        "\n",
        "class BinaryCountingAtMediumScale(BinaryCountingAtEveryScale):\n",
        "    CONFIG = {\n",
        "        \"num_bits\" : 4,\n",
        "        \"show_title\" : True,\n",
        "    }\n",
        "\n",
        "class BinaryCountingAtLargeScale(BinaryCountingAtEveryScale):\n",
        "    CONFIG = {\n",
        "        \"num_bits\" : 8,\n",
        "        \"show_title\" : True,\n",
        "    }\n",
        "\n",
        "class IntroduceSolveByCounting(TowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 4\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_bit_mobs()\n",
        "        for disk in self.disks:\n",
        "            disk.original_fill_color = disk.get_color()\n",
        "        braces = [\n",
        "            Brace(VGroup(*self.curr_bit_mob[:n]))\n",
        "            for n in range(1, self.num_disks+1)\n",
        "        ]\n",
        "        word_list = [\n",
        "            brace.get_text(text)\n",
        "            for brace, text in zip(braces, [\n",
        "                \"Only flip last bit\",\n",
        "                \"Roll over once\",\n",
        "                \"Roll over twice\",\n",
        "                \"Roll over three times\",\n",
        "            ])\n",
        "        ]\n",
        "        brace = braces[0].copy()\n",
        "        words = word_list[0].copy()\n",
        "\n",
        "        ##First increment\n",
        "        self.play(self.get_increment_animation())\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words, run_time = 1)\n",
        "        )\n",
        "        disk = self.disks[0]\n",
        "        last_bit = self.curr_bit_mob[0]\n",
        "        last_bit.save_state()\n",
        "        self.play(\n",
        "            disk.set_fill, YELLOW,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            last_bit.set_fill, YELLOW,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_disk(0, run_time = 2)\n",
        "        self.play(\n",
        "            last_bit.restore,\n",
        "            disk.set_fill, disk.original_fill_color,\n",
        "            self.disks[0][1].set_fill, BLACK\n",
        "        )\n",
        "\n",
        "        ##Second increment\n",
        "        self.play(\n",
        "            self.get_increment_animation(),\n",
        "            Transform(words, word_list[1]),\n",
        "            Transform(brace, braces[1]),\n",
        "        )\n",
        "        disk = self.disks[1]\n",
        "        twos_bit = self.curr_bit_mob[1]\n",
        "        twos_bit.save_state()\n",
        "        self.play(\n",
        "            disk.set_fill, MAROON_B,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            twos_bit.set_fill, MAROON_B,\n",
        "        )\n",
        "        self.move_disk(1, run_time = 2)\n",
        "        self.wait()\n",
        "        self.move_disk_to_peg(1, 1, stay_on_peg = False)\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.replace(disk)\n",
        "        cross.set_fill(RED, opacity = 0.5)\n",
        "        self.play(FadeIn(cross))\n",
        "        self.wait()\n",
        "        self.move_disk_to_peg(\n",
        "            1, 2, stay_on_peg = False, \n",
        "            added_anims = [FadeOut(cross)]\n",
        "        )\n",
        "        self.play(\n",
        "            disk.set_fill, disk.original_fill_color,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            twos_bit.restore,\n",
        "            Transform(brace, braces[0]),\n",
        "            Transform(words, word_list[0]),\n",
        "        )\n",
        "        self.move_disk(\n",
        "            0, \n",
        "            added_anims = [self.get_increment_animation()],\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ##Fourth increment\n",
        "        self.play(\n",
        "            Transform(brace, braces[2]),\n",
        "            Transform(words, word_list[2]),\n",
        "        )\n",
        "        self.play(self.get_increment_animation())\n",
        "        disk = self.disks[2]\n",
        "        fours_bit = self.curr_bit_mob[2]\n",
        "        fours_bit.save_state()\n",
        "        self.play(\n",
        "            disk.set_fill, RED,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            fours_bit.set_fill, RED\n",
        "        )\n",
        "        self.move_disk(2, run_time = 2)\n",
        "        self.play(\n",
        "            disk.set_fill, disk.original_fill_color,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            fours_bit.restore,\n",
        "            FadeOut(brace),\n",
        "            FadeOut(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        for disk_index in 0, 1, 0:\n",
        "            self.play(self.get_increment_animation())\n",
        "            self.move_disk(disk_index)\n",
        "        self.wait()\n",
        "\n",
        "        ##Eighth incremement\n",
        "        brace = braces[3]\n",
        "        words = word_list[3]\n",
        "        self.play(\n",
        "            self.get_increment_animation(),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words, run_time = 1)\n",
        "        )\n",
        "        disk = self.disks[3]\n",
        "        eights_bit = self.curr_bit_mob[3]\n",
        "        eights_bit.save_state()\n",
        "        self.play(\n",
        "            disk.set_fill, GREEN,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            eights_bit.set_fill, GREEN\n",
        "        )\n",
        "        self.move_disk(3, run_time = 2)\n",
        "        self.play(\n",
        "            disk.set_fill, disk.original_fill_color,\n",
        "            disk[1].set_fill, BLACK,\n",
        "            eights_bit.restore,\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [brace, words])))\n",
        "        for disk_index in get_ruler_sequence(2):\n",
        "            self.play(self.get_increment_animation())\n",
        "            self.move_disk(disk_index, stay_on_peg = False)\n",
        "        self.wait()\n",
        "\n",
        "    def initialize_bit_mobs(self):\n",
        "        bit_mobs = VGroup(*[\n",
        "            get_binary_tex_mob(n, self.num_disks)\n",
        "            for n in range(2**(self.num_disks))\n",
        "        ])\n",
        "        bit_mobs.scale(2)\n",
        "        self.bit_mobs_iter = it.cycle(bit_mobs)\n",
        "        self.curr_bit_mob = next(self.bit_mobs_iter)\n",
        "\n",
        "        for bit_mob in bit_mobs:\n",
        "            bit_mob.align_data_and_family(self.curr_bit_mob)\n",
        "            for bit, disk in zip(bit_mob, reversed(list(self.disks))):\n",
        "                bit.set_color(disk.get_color())\n",
        "        bit_mobs.next_to(self.peg_labels, DOWN)\n",
        "\n",
        "        self.add(self.curr_bit_mob)\n",
        "\n",
        "    def get_increment_animation(self):\n",
        "        return Succession(\n",
        "            Transform(\n",
        "                self.curr_bit_mob, next(self.bit_mobs_iter),\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = -np.pi/3\n",
        "            ),\n",
        "            Animation(self.curr_bit_mob)\n",
        "        )\n",
        "\n",
        "class SolveSixDisksByCounting(IntroduceSolveByCounting):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 6,\n",
        "        \"stay_on_peg\" : False,\n",
        "        \"run_time_per_move\" : 0.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_bit_mobs()\n",
        "        for disk_index in get_ruler_sequence(self.num_disks-1):\n",
        "            self.play(\n",
        "                self.get_increment_animation(),\n",
        "                run_time = self.run_time_per_move,\n",
        "            )\n",
        "            self.move_disk(\n",
        "                disk_index,\n",
        "                stay_on_peg = self.stay_on_peg,\n",
        "                run_time = self.run_time_per_move,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class RecursionTime(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith().shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer().shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "\n",
        "        keith_kick = keith.copy().change_mode(\"dance_kick\")\n",
        "        keith_kick.scale(1.3)\n",
        "        keith_kick.shift(0.5*LEFT)\n",
        "        keith_kick.look_at(morty.eyes)\n",
        "        keith_hooray = keith.copy().change_mode(\"hooray\")\n",
        "\n",
        "        self.add(keith, morty)\n",
        "\n",
        "        bubble = keith.get_bubble(SpeechBubble, height = 2)\n",
        "        bubble.write(\"Recursion time!!!\")\n",
        "        VGroup(bubble, bubble.content).shift(UP)\n",
        "\n",
        "        self.play(\n",
        "            Transform(keith, keith_kick),\n",
        "            morty.change_mode, \"happy\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            Transform(keith, keith_hooray),\n",
        "            bubble.content.set_color_by_gradient, BLUE_A, BLUE_E\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class RecursiveSolution(TowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 4,\n",
        "        \"middle_peg_bottom\" : 2*DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        # VGroup(*self.get_mobjects()).shift(1.5*DOWN)\n",
        "        big_disk = self.disks[-1]\n",
        "        self.eyes = Eyes(big_disk)\n",
        "        title = OldTexText(\"Move 4-tower\")\n",
        "        sub_steps = OldTexText(\n",
        "            \"Move 3-tower,\",\n",
        "            \"Move disk 3,\",\n",
        "            \"Move 3-tower\",\n",
        "        )\n",
        "        sub_steps[1].set_color(GREEN)\n",
        "        sub_step_brace = Brace(sub_steps, UP)\n",
        "        sub_sub_steps = OldTexText(\n",
        "            \"Move 2-tower,\",\n",
        "            \"Move disk 2,\",\n",
        "            \"Move 2-tower\",\n",
        "        )\n",
        "        sub_sub_steps[1].set_color(RED)\n",
        "        sub_sub_steps_brace = Brace(sub_sub_steps, UP)\n",
        "        steps = VGroup(\n",
        "            title, sub_step_brace, sub_steps, \n",
        "            sub_sub_steps_brace, sub_sub_steps\n",
        "        )\n",
        "        steps.arrange(DOWN)\n",
        "        steps.scale(0.7)\n",
        "        steps.to_edge(UP)\n",
        "        VGroup(sub_sub_steps_brace, sub_sub_steps).next_to(sub_steps[-1], DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "\n",
        "        ##Big disk is frustrated\n",
        "        self.play(\n",
        "            FadeIn(self.eyes),\n",
        "            big_disk.set_fill, GREEN,\n",
        "            big_disk.label.set_fill, BLACK,\n",
        "        )\n",
        "        big_disk.add(self.eyes)        \n",
        "        self.blink()\n",
        "        self.wait()\n",
        "        self.change_mode(\"angry\")\n",
        "        for x in range(2):\n",
        "            self.wait()\n",
        "            self.shake(big_disk)\n",
        "            self.blink()\n",
        "            self.wait()\n",
        "        self.change_mode(\"plain\")\n",
        "        self.look_at(self.peg_labels[2])\n",
        "        self.look_at(self.disks[0])\n",
        "        self.blink()\n",
        "\n",
        "        #Subtower move\n",
        "        self.move_subtower_to_peg(3, 1, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[1]),\n",
        "            FadeIn(sub_step_brace),\n",
        "            Write(sub_steps[0], run_time = 1)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.move_disk_to_peg(0, 0, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0].get_top())\n",
        "        ])\n",
        "        self.shake(big_disk)\n",
        "        self.move_disk_to_peg(0, 2, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2].get_bottom())\n",
        "        ])\n",
        "        self.change_mode(\"angry\")\n",
        "        self.move_disk_to_peg(0, 1, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.disks[1].get_top())\n",
        "        ])\n",
        "        self.blink()\n",
        "\n",
        "        #Final moves for big case\n",
        "        self.move_disk(3, run_time = 2, added_anims = [\n",
        "            Write(sub_steps[1])\n",
        "        ])\n",
        "        self.look_at(self.disks[1])\n",
        "        self.blink()\n",
        "        bubble = SpeechBubble()\n",
        "        bubble.write(\"I'm set!\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.pin_to(big_disk)\n",
        "        bubble.add_content(bubble.content)\n",
        "        bubble.set_fill(BLACK, opacity = 0.7)\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.blink()\n",
        "        self.play(*list(map(FadeOut, [bubble, bubble.content])))\n",
        "        big_disk.remove(self.eyes)\n",
        "        self.move_subtower_to_peg(3, 2, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2].get_top()),\n",
        "            Write(sub_steps[2])\n",
        "        ])\n",
        "        self.play(FadeOut(self.eyes))\n",
        "        self.wait()\n",
        "\n",
        "        #Highlight subproblem\n",
        "        self.play(\n",
        "            VGroup(*self.disks[:3]).move_to, self.pegs[1], DOWN\n",
        "        )\n",
        "        self.disk_tracker = [set([]), set([0, 1, 2]), set([3])]\n",
        "        arc = Arc(-5*np.pi/6, start_angle = 5*np.pi/6)\n",
        "        arc.add_tip()\n",
        "        arc.set_color(YELLOW)\n",
        "        arc.set_width(\n",
        "            VGroup(*self.pegs[1:]).get_width()*0.8\n",
        "        )\n",
        "        arc.next_to(self.disks[0], UP+RIGHT, buff = SMALL_BUFF)\n",
        "        q_mark = OldTexText(\"?\")\n",
        "        q_mark.next_to(arc, UP)\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(q_mark),\n",
        "            sub_steps[-1].set_color, YELLOW\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(sub_sub_steps_brace),\n",
        "            *list(map(FadeOut, [arc, q_mark]))\n",
        "        )\n",
        "\n",
        "        #Disk 2 frustration\n",
        "        big_disk = self.disks[2]\n",
        "        self.eyes.move_to(big_disk.get_top(), DOWN)\n",
        "        self.play(\n",
        "            FadeIn(self.eyes),\n",
        "            big_disk.set_fill, RED,\n",
        "            big_disk.label.set_fill, BLACK\n",
        "        )\n",
        "        big_disk.add(self.eyes)\n",
        "        self.change_mode(\"sad\")\n",
        "        self.look_at(self.pegs[1].get_top())\n",
        "        self.shake(big_disk)\n",
        "        self.blink()\n",
        "\n",
        "        #Move sub-sub-tower\n",
        "        self.move_subtower_to_peg(2, 0, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0].get_bottom()),\n",
        "            Write(sub_sub_steps[0])\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.move_disk_to_peg(2, 2, run_time = 2, added_anims = [\n",
        "            Write(sub_sub_steps[1])\n",
        "        ])\n",
        "        self.look_at(self.disks[0])\n",
        "        big_disk.remove(self.eyes)\n",
        "        self.move_subtower_to_peg(2, 2, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2].get_top()),\n",
        "            Write(sub_sub_steps[2])\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.look_at(self.disks[-1])\n",
        "\n",
        "        #Move eyes\n",
        "        self.play(FadeOut(self.eyes))\n",
        "        self.eyes.move_to(self.disks[1].get_top(), DOWN)\n",
        "        self.play(FadeIn(self.eyes))\n",
        "        self.blink()\n",
        "        self.play(FadeOut(self.eyes))\n",
        "        self.eyes.move_to(self.disks[3].get_top(), DOWN)\n",
        "        self.play(FadeIn(self.eyes))\n",
        "\n",
        "        #Show process one last time\n",
        "        big_disk = self.disks[3]\n",
        "        big_disk.add(self.eyes)\n",
        "        self.move_subtower_to_peg(3, 1, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0])\n",
        "        ])\n",
        "        self.move_disk_to_peg(3, 0, run_time = 2)\n",
        "        big_disk.remove(self.eyes)\n",
        "        self.move_subtower_to_peg(3, 0, run_time = 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0].get_top())\n",
        "        ])\n",
        "        self.blink()\n",
        "\n",
        "    def shake(self, mobject, direction = UP, added_anims = []):\n",
        "        self.play(\n",
        "            mobject.shift, 0.2*direction, rate_func = wiggle,\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def blink(self):\n",
        "        self.play(self.eyes.blink_anim())\n",
        "\n",
        "    def look_at(self, point_or_mobject):\n",
        "        self.play(self.eyes.look_at_anim(point_or_mobject))\n",
        "\n",
        "    def change_mode(self, mode):\n",
        "        self.play(self.eyes.change_mode_anim(mode))\n",
        "\n",
        "class KeithSaysBigToSmall(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        keith.shift(2.5*DOWN + 3*LEFT)\n",
        "        bubble = keith.get_bubble(SpeechBubble, height = 4.5)\n",
        "        bubble.write(\"\"\"\n",
        "            Big problem\n",
        "            $\\\\Downarrow$\n",
        "            Smaller problem\n",
        "        \"\"\")\n",
        "\n",
        "        self.add(keith)\n",
        "        self.play(Blink(keith))\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(keith))\n",
        "        self.wait()\n",
        "\n",
        "class CodeThisUp(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        keith.shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "        point = 2*UP+3*RIGHT\n",
        "        bubble = keith.get_bubble(SpeechBubble, width = 4.5, height = 3)\n",
        "        bubble.write(\"This is the \\\\\\\\ most efficient\")\n",
        "        self.add(morty, keith)\n",
        "\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            keith.look_at, point\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, point\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            keith.change_mode, \"hooray\",\n",
        "            keith.look_at, morty.eyes\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            keith.look_at, morty.eyes,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "            morty.change_mode, \"happy\",\n",
        "            morty.look_at, keith.eyes,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class HanoiSolutionCode(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class NoRoomForInefficiency(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.shift(2.5*DOWN+3*LEFT)\n",
        "        bubble = morty.get_bubble(SpeechBubble, width = 4)\n",
        "        bubble.write(\"No room for \\\\\\\\ inefficiency\")\n",
        "        VGroup(morty, bubble, bubble.content).to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            morty.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class WhyDoesBinaryAchieveThis(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        keith.shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "        bubble = morty.get_bubble(SpeechBubble, width = 5, height = 3)\n",
        "        bubble.write(\"\"\"\n",
        "            Why does counting\n",
        "            in binary work?\n",
        "        \"\"\")\n",
        "        self.add(morty, keith)\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"confused\",\n",
        "            morty.look_at, keith.eyes,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(keith.change_mode, \"happy\")\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class BothAreSelfSimilar(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.shift(2.5*DOWN+3*LEFT)\n",
        "        bubble = morty.get_bubble(SpeechBubble)\n",
        "        bubble.write(\"Both are self-similar\")\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class LargeScaleHanoiDecomposition(TowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 8,\n",
        "        \"peg_height\" : 3.5,\n",
        "        \"middle_peg_bottom\" : 2*DOWN,\n",
        "        \"disk_max_width\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.move_subtower_to_peg(7, 1, stay_on_peg = False)\n",
        "        self.wait()\n",
        "        self.move_disk(7, stay_on_peg = False)\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(7, 2, stay_on_peg = False)\n",
        "        self.wait()\n",
        "\n",
        "class SolveTwoDisksByCounting(SolveSixDisksByCounting):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 2,\n",
        "        \"stay_on_peg\" : False,\n",
        "        \"run_time_per_move\" : 1,\n",
        "        \"disk_max_width\" : 1.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_bit_mobs()\n",
        "        for disk_index in 0, 1, 0:\n",
        "            self.play(self.get_increment_animation())\n",
        "            self.move_disk(\n",
        "                disk_index, \n",
        "                stay_on_peg = False,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class ShowFourDiskFourBitsParallel(IntroduceSolveByCounting):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 4,\n",
        "        \"subtask_run_time\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_bit_mobs()\n",
        "        self.counting_subtask()\n",
        "        self.wait()\n",
        "        self.disk_subtask()\n",
        "        self.wait()\n",
        "        self.play(self.get_increment_animation())\n",
        "        self.move_disk(\n",
        "            self.num_disks-1, \n",
        "            stay_on_peg = False,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.counting_subtask()\n",
        "        self.wait()\n",
        "        self.disk_subtask()\n",
        "        self.wait()\n",
        "\n",
        "    def disk_subtask(self):\n",
        "        sequence = get_ruler_sequence(self.num_disks-2)\n",
        "        run_time = float(self.subtask_run_time)/len(sequence)\n",
        "        for disk_index in get_ruler_sequence(self.num_disks-2):\n",
        "            self.move_disk(\n",
        "                disk_index, \n",
        "                run_time = run_time,\n",
        "                stay_on_peg = False,\n",
        "            )\n",
        "        # curr_peg = self.disk_index_to_peg_index(0)\n",
        "        # self.move_subtower_to_peg(self.num_disks-1, curr_peg+1)\n",
        "\n",
        "    def counting_subtask(self):\n",
        "        num_tasks = 2**(self.num_disks-1)-1\n",
        "        run_time = float(self.subtask_run_time)/num_tasks\n",
        "        # for x in range(num_tasks):\n",
        "        #     self.play(\n",
        "        #         self.get_increment_animation(),\n",
        "        #         run_time = run_time\n",
        "        #     )\n",
        "        self.play(\n",
        "            Succession(*[\n",
        "                self.get_increment_animation()\n",
        "                for x in range(num_tasks)\n",
        "            ]),\n",
        "            rate_func=linear,\n",
        "            run_time = self.subtask_run_time\n",
        "        )\n",
        "\n",
        "    def get_increment_animation(self):\n",
        "        return Transform(\n",
        "            self.curr_bit_mob, next(self.bit_mobs_iter),\n",
        "            path_arc = -np.pi/3,\n",
        "        )\n",
        " \n",
        "class ShowThreeDiskThreeBitsParallel(ShowFourDiskFourBitsParallel):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 3,\n",
        "        \"subtask_run_time\" : 1\n",
        "    }\n",
        "\n",
        "class ShowFiveDiskFiveBitsParallel(ShowFourDiskFourBitsParallel):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 5,\n",
        "        \"subtask_run_time\" : 2\n",
        "    }\n",
        "\n",
        "class ShowSixDiskSixBitsParallel(ShowFourDiskFourBitsParallel):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 6,\n",
        "        \"subtask_run_time\" : 2\n",
        "    }\n",
        "\n",
        "class CoolRight(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN)\n",
        "        bubble = SpeechBubble()\n",
        "        bubble.write(\"Cool! right?\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.pin_to(morty)\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"surprised\",\n",
        "            morty.look, OUT,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        curr_content = bubble.content\n",
        "        bubble.write(\"It gets \\\\\\\\ better...\")\n",
        "        self.play(\n",
        "            Transform(curr_content, bubble.content),\n",
        "            morty.change_mode, \"hooray\",\n",
        "            morty.look, OUT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "############ Part 2 ############\n",
        "\n",
        "class MentionLastVideo(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        keith.shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "        point = 2*UP\n",
        "\n",
        "        name = OldTexText(\"\"\"\n",
        "            Keith Schwarz\n",
        "            (Computer Scientist)\n",
        "        \"\"\")\n",
        "        name.to_corner(UP+LEFT)\n",
        "        arrow = Arrow(name.get_bottom(), keith.get_top())\n",
        "\n",
        "        self.add(morty, keith)\n",
        "        self.play(\n",
        "            keith.change_mode, \"raise_right_hand\",\n",
        "            keith.look_at, point,\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, point\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.play(Write(name))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change_mode, \"confused\",\n",
        "            morty.look_at, point\n",
        "        )\n",
        "        self.play(Blink(keith))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change_mode, \"surprised\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceConstrainedTowersOfHanoi(ConstrainedTowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"middle_peg_bottom\" : 2*DOWN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Constrained\", \"Towers of Hanoi\")\n",
        "        title.set_color_by_tex(\"Constrained\", YELLOW)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.add_arcs()\n",
        "        self.disks.save_state()\n",
        "        for index in 0, 0, 1, 0:\n",
        "            self.move_disk(index)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.play(self.disks.restore)\n",
        "        self.disk_tracker = [set(range(self.num_disks)), set([]), set([])]\n",
        "        self.wait()\n",
        "        self.move_disk_to_peg(0, 1)\n",
        "        self.move_disk_to_peg(1, 2)\n",
        "        self.play(ShowCreation(self.big_curved_arrow))\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.scale(2)\n",
        "        cross.set_fill(RED)\n",
        "        cross.move_to(self.big_curved_arrow.get_top())\n",
        "        big_cross = cross.copy()\n",
        "        big_cross.replace(self.disks[1])\n",
        "        big_cross.set_fill(opacity = 0.5)\n",
        "        self.play(FadeIn(cross))\n",
        "        self.play(FadeIn(big_cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def add_arcs(self):\n",
        "        arc = Arc(start_angle = np.pi/6, angle = 2*np.pi/3)\n",
        "        curved_arrow1 = VGroup(arc, arc.copy().flip())\n",
        "        curved_arrow2 = curved_arrow1.copy()\n",
        "        curved_arrows = [curved_arrow1, curved_arrow2]\n",
        "        for curved_arrow in curved_arrows:\n",
        "            for arc in curved_arrow:\n",
        "                arc.add_tip(tip_length = 0.15)\n",
        "                arc.set_color(YELLOW)\n",
        "        peg_sets = (self.pegs[:2], self.pegs[1:])\n",
        "        for curved_arrow, pegs in zip(curved_arrows, peg_sets):\n",
        "            peg_group = VGroup(*pegs)\n",
        "            curved_arrow.set_width(0.7*peg_group.get_width())\n",
        "            curved_arrow.next_to(peg_group, UP)\n",
        "\n",
        "        self.play(ShowCreation(curved_arrow1))\n",
        "        self.play(ShowCreation(curved_arrow2))\n",
        "        self.wait()\n",
        "\n",
        "        big_curved_arrow = Arc(start_angle = 5*np.pi/6, angle = -2*np.pi/3)\n",
        "        big_curved_arrow.set_width(0.9*self.pegs.get_width())\n",
        "        big_curved_arrow.next_to(self.pegs, UP)\n",
        "        big_curved_arrow.add_tip(tip_length = 0.4)\n",
        "        big_curved_arrow.set_color(WHITE)\n",
        "        self.big_curved_arrow = big_curved_arrow\n",
        "\n",
        "class StillRecruse(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith()\n",
        "        keith.shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "        point = 2*UP+3*RIGHT\n",
        "        bubble = keith.get_bubble(SpeechBubble, width = 4.5, height = 3)\n",
        "        bubble.write(\"You can still\\\\\\\\ use recursion\")\n",
        "        self.add(morty, keith)\n",
        "\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(morty.change_mode, \"hooray\")\n",
        "        self.play(Blink(keith))\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class RecursiveSolutionToConstrained(RecursiveSolution):\n",
        "    CONFIG = {\n",
        "        \"middle_peg_bottom\" : 2*DOWN,\n",
        "        \"num_disks\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        big_disk = self.disks[-1]\n",
        "        self.eyes = Eyes(big_disk)\n",
        "\n",
        "        #Define steps breakdown text\n",
        "        title = OldTexText(\"Move 4-tower\")\n",
        "        subdivisions = [\n",
        "            OldTexText(\n",
        "                \"\\\\tiny Move %d-tower,\"%d,\n",
        "                \"Move disk %d,\"%d,\n",
        "                \"\\\\, Move %d-tower, \\\\,\"%d,\n",
        "                \"Move disk %d,\"%d,\n",
        "                \"Move %d-tower\"%d,\n",
        "            ).set_color_by_tex(\"Move disk %d,\"%d, color)\n",
        "            for d, color in [(3, GREEN), (2, RED), (1, BLUE_C)]\n",
        "        ]\n",
        "        sub_steps, sub_sub_steps = subdivisions[:2]\n",
        "        for steps in subdivisions:\n",
        "            steps.set_width(FRAME_WIDTH-1)\n",
        "        subdivisions.append(\n",
        "            OldTexText(\"\\\\tiny Move disk 0, Move disk 0\").set_color(BLUE)\n",
        "        )\n",
        "        braces = [\n",
        "            Brace(steps, UP)\n",
        "            for steps in subdivisions\n",
        "        ]\n",
        "        sub_steps_brace, sub_sub_steps_brace = braces[:2]\n",
        "        steps = VGroup(title, *it.chain(*list(zip(\n",
        "            braces, subdivisions\n",
        "        ))))\n",
        "        steps.arrange(DOWN)\n",
        "        steps.to_edge(UP)\n",
        "\n",
        "        steps_to_fade = VGroup(\n",
        "            title, sub_steps_brace,\n",
        "            *list(sub_steps[:2]) + list(sub_steps[3:])\n",
        "        )\n",
        "        self.add(title)\n",
        "\n",
        "        #Initially move big disk\n",
        "        self.play(\n",
        "            FadeIn(self.eyes),\n",
        "            big_disk.set_fill, GREEN,\n",
        "            big_disk.label.set_fill, BLACK\n",
        "        )\n",
        "        big_disk.add(self.eyes)\n",
        "        big_disk.save_state()\n",
        "        self.blink()\n",
        "        self.look_at(self.pegs[2])\n",
        "        self.move_disk_to_peg(self.num_disks-1, 2, stay_on_peg = False)\n",
        "        self.look_at(self.pegs[0])\n",
        "        self.blink()\n",
        "        self.play(big_disk.restore, path_arc = np.pi/3)\n",
        "        self.disk_tracker = [set(range(self.num_disks)), set([]), set([])]\n",
        "        self.look_at(self.pegs[0].get_top())\n",
        "        self.change_mode(\"angry\")\n",
        "        self.shake(big_disk)\n",
        "        self.wait()\n",
        "\n",
        "        #Talk about tower blocking\n",
        "        tower = VGroup(*self.disks[:self.num_disks-1])\n",
        "        blocking = OldTexText(\"Still\\\\\\\\\", \"Blocking\")\n",
        "        blocking.set_color(RED)\n",
        "        blocking.to_edge(LEFT)\n",
        "        blocking.shift(2*UP)\n",
        "        arrow = Arrow(blocking.get_bottom(), tower.get_top(), buff = SMALL_BUFF)\n",
        "        new_arrow = Arrow(blocking.get_bottom(), self.pegs[1], buff = SMALL_BUFF)\n",
        "        VGroup(arrow, new_arrow).set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            Write(blocking[1]),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.shake(tower, RIGHT, added_anims = [Animation(big_disk)])\n",
        "        self.blink()\n",
        "        self.shake(big_disk)\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 1, added_anims = [\n",
        "            Transform(arrow, new_arrow),\n",
        "            self.eyes.look_at_anim(self.pegs[1])\n",
        "        ])\n",
        "        self.play(Write(blocking[0]))\n",
        "        self.shake(big_disk, RIGHT)\n",
        "        self.wait()\n",
        "        self.blink()\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sub_steps_brace))\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 2, added_anims = [\n",
        "            FadeOut(blocking),\n",
        "            FadeOut(arrow),\n",
        "            self.eyes.change_mode_anim(\"plain\", thing_to_look_at = self.pegs[2]),\n",
        "            Write(sub_steps[0], run_time = 1),\n",
        "        ])\n",
        "        self.blink()\n",
        "\n",
        "        #Proceed through actual process\n",
        "        self.move_disk_to_peg(self.num_disks-1, 1, added_anims = [\n",
        "            Write(sub_steps[1], run_time = 1),\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 0, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0]),\n",
        "            Write(sub_steps[2], run_time = 1),\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.move_disk_to_peg(self.num_disks-1, 2, added_anims = [\n",
        "            Write(sub_steps[3], run_time = 1),\n",
        "        ])\n",
        "        self.wait()\n",
        "        big_disk.remove(self.eyes)\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2].get_top()),\n",
        "            Write(sub_steps[4], run_time = 1),\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.play(FadeOut(self.eyes))\n",
        "\n",
        "        #Ask about subproblem\n",
        "        sub_sub_steps_brace.set_color(WHITE)\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 0, added_anims = [\n",
        "            steps_to_fade.fade, 0.7,\n",
        "            sub_steps[2].set_color, WHITE,\n",
        "            sub_steps[2].scale, 1.2,\n",
        "            FadeIn(sub_sub_steps_brace)\n",
        "        ])\n",
        "        num_disks = self.num_disks-1\n",
        "        big_disk = self.disks[num_disks-1]\n",
        "        self.eyes.move_to(big_disk.get_top(), DOWN)\n",
        "        self.play(\n",
        "            FadeIn(self.eyes),\n",
        "            big_disk.set_fill, RED,\n",
        "            big_disk.label.set_fill, BLACK,\n",
        "        )\n",
        "        big_disk.add(self.eyes)        \n",
        "        self.blink()\n",
        "\n",
        "        #Solve subproblem\n",
        "        self.move_subtower_to_peg(num_disks-1, 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2]),\n",
        "            Write(sub_sub_steps[0], run_time = 1)\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.move_disk_to_peg(num_disks-1, 1, added_anims = [\n",
        "            Write(sub_sub_steps[1], run_time = 1)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(num_disks-1, 0, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[0]),\n",
        "            Write(sub_sub_steps[2], run_time = 1)\n",
        "        ])\n",
        "        self.blink()\n",
        "        self.move_disk_to_peg(num_disks-1, 2, added_anims = [\n",
        "            Write(sub_sub_steps[3], run_time = 1)\n",
        "        ])\n",
        "        self.wait()\n",
        "        big_disk.remove(self.eyes)\n",
        "        self.move_subtower_to_peg(num_disks-1, 2, added_anims = [\n",
        "            self.eyes.look_at_anim(self.pegs[2].get_top()),\n",
        "            Write(sub_sub_steps[4], run_time = 1)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        #Show smallest subdivisions\n",
        "        smaller_subdivision = VGroup(\n",
        "            *list(subdivisions[2:]) + \\\n",
        "            list(braces[2:])\n",
        "        )\n",
        "        last_subdivisions = [VGroup(braces[-1], subdivisions[-1])]\n",
        "        for vect in LEFT, RIGHT:\n",
        "            group = last_subdivisions[0].copy()\n",
        "            group.to_edge(vect)\n",
        "            steps.add(group)\n",
        "            smaller_subdivision.add(group)\n",
        "            last_subdivisions.append(group)\n",
        "        smaller_subdivision.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            steps.shift, \n",
        "            (FRAME_Y_RADIUS-sub_sub_steps.get_top()[1]-MED_SMALL_BUFF)*UP,\n",
        "            self.eyes.look_at_anim(steps)\n",
        "        )\n",
        "        self.play(ApplyMethod(\n",
        "            VGroup(VGroup(braces[-2], subdivisions[-2])).set_fill, None, 1,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.blink()\n",
        "        for mob in last_subdivisions:\n",
        "            self.play(\n",
        "                ApplyMethod(mob.set_fill, None, 1),\n",
        "                self.eyes.look_at_anim(mob)\n",
        "            )\n",
        "        self.blink()\n",
        "        self.play(FadeOut(self.eyes))\n",
        "        self.wait()\n",
        "\n",
        "        #final movements\n",
        "        movements = [\n",
        "            (0, 1),\n",
        "            (0, 0),\n",
        "            (1, 1),\n",
        "            (0, 1),\n",
        "            (0, 2),\n",
        "            (1, 0),\n",
        "            (0, 1),\n",
        "            (0, 0),\n",
        "        ]\n",
        "        for disk_index, peg_index in movements:\n",
        "            self.move_disk_to_peg(\n",
        "                disk_index, peg_index, \n",
        "                stay_on_peg = False\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class SimpleConstrainedBreakdown(TowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 4\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 2)\n",
        "        self.wait()\n",
        "        self.move_disk(self.num_disks-1)\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 0)\n",
        "        self.wait()\n",
        "        self.move_disk(self.num_disks-1)\n",
        "        self.wait()\n",
        "        self.move_subtower_to_peg(self.num_disks-1, 2)\n",
        "        self.wait()\n",
        "\n",
        "class SolveConstrainedByCounting(ConstrainedTowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 5,\n",
        "        \"ternary_mob_scale_factor\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        ternary_mobs = VGroup()\n",
        "        for num in range(3**self.num_disks):\n",
        "            ternary_mob = get_ternary_tex_mob(num, self.num_disks)\n",
        "            ternary_mob.scale(self.ternary_mob_scale_factor)\n",
        "            ternary_mob.set_color_by_gradient(*self.disk_start_and_end_colors)\n",
        "            ternary_mobs.add(ternary_mob)\n",
        "        ternary_mobs.next_to(self.peg_labels, DOWN)\n",
        "        self.ternary_mob_iter = it.cycle(ternary_mobs)\n",
        "        self.curr_ternary_mob = next(self.ternary_mob_iter)\n",
        "        self.add(self.curr_ternary_mob)\n",
        "\n",
        "        for index in get_ternary_ruler_sequence(self.num_disks-1):\n",
        "            self.move_disk(index, stay_on_peg = False, added_anims = [\n",
        "                self.increment_animation()\n",
        "            ])\n",
        "\n",
        "    def increment_animation(self):\n",
        "        return Succession(\n",
        "            Transform(\n",
        "                self.curr_ternary_mob, next(self.ternary_mob_iter),\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = np.pi/6,\n",
        "            ),\n",
        "            Animation(self.curr_ternary_mob),\n",
        "        )\n",
        "\n",
        "class CompareNumberSystems(Scene):\n",
        "    def construct(self):\n",
        "        base_ten = OldTexText(\"Base ten\")\n",
        "        base_ten.to_corner(UP+LEFT).shift(RIGHT)\n",
        "        binary = OldTexText(\"Binary\")\n",
        "        binary.to_corner(UP+RIGHT).shift(LEFT)\n",
        "        ternary = OldTexText(\"Ternary\")\n",
        "        ternary.to_edge(UP)\n",
        "        ternary.set_color(YELLOW)\n",
        "        titles = [base_ten, binary, ternary]\n",
        "\n",
        "        zero_to_nine = OldTexText(\"\"\"\n",
        "            0, 1, 2, 3, 4,\n",
        "            5, 6, 7, 8, 9\n",
        "        \"\"\")\n",
        "        zero_to_nine.next_to(base_ten, DOWN, buff = LARGE_BUFF)\n",
        "        zero_one = OldTexText(\"0, 1\")\n",
        "        zero_one.next_to(binary, DOWN, buff = LARGE_BUFF)\n",
        "        zero_one_two = OldTexText(\"0, 1, 2\")\n",
        "        zero_one_two.next_to(ternary, DOWN, buff = LARGE_BUFF)\n",
        "        zero_one_two.set_color_by_gradient(BLUE, GREEN)\n",
        "\n",
        "        symbols = [zero_to_nine, zero_one, zero_one_two]\n",
        "        names = [\"Digits\", \"Bits\", \"Trits?\"]\n",
        "        for mob, text in zip(symbols, names):\n",
        "            mob.brace = Brace(mob)\n",
        "            mob.name = mob.brace.get_text(text)\n",
        "        zero_one_two.name.set_color_by_gradient(BLUE, GREEN)\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        dots.next_to(zero_one.name, RIGHT, aligned_edge = DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        keith = Keith()\n",
        "        keith.shift(2*DOWN+3*LEFT)\n",
        "        keith.look_at(zero_one_two)\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "\n",
        "        for title, symbol in zip(titles, symbols):\n",
        "            self.play(FadeIn(title))\n",
        "            added_anims = []\n",
        "            if title is not ternary:\n",
        "                added_anims += [\n",
        "                    FadeIn(symbol.brace),\n",
        "                    FadeIn(symbol.name)\n",
        "                ]\n",
        "            self.play(Write(symbol, run_time = 2), *added_anims)\n",
        "            self.wait()\n",
        "        self.play(FadeIn(keith))\n",
        "        self.play(keith.change_mode, \"confused\")\n",
        "        self.play(keith.look_at, zero_to_nine)\n",
        "        self.play(keith.look_at, zero_one)\n",
        "        self.play(\n",
        "            GrowFromCenter(zero_one_two.brace),\n",
        "            Write(zero_one_two.name),\n",
        "            keith.look_at, zero_one_two,\n",
        "        )\n",
        "        self.play(keith.change_mode, \"sassy\")\n",
        "        self.play(Blink(keith))\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"sassy\",\n",
        "            morty.look_at, zero_one_two\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.shrug,\n",
        "            morty.look_at, keith.eyes,\n",
        "            keith.shrug,\n",
        "            keith.look_at, morty.eyes\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"hesitant\",\n",
        "            morty.look_at, zero_one.name,\n",
        "            keith.change_mode, \"erm\",\n",
        "            keith.look_at, zero_one.name\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Write(dots, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceTernaryCounting(CountingScene):\n",
        "    CONFIG = {\n",
        "        \"base\" : 3,\n",
        "        \"counting_dot_starting_position\" : (FRAME_X_RADIUS-1)*RIGHT + (FRAME_Y_RADIUS-1)*UP,\n",
        "        \"count_dot_starting_radius\" : 0.5,\n",
        "        \"dot_configuration_height\" : 1,\n",
        "        \"ones_configuration_location\" : UP+2*RIGHT,\n",
        "        \"num_scale_factor\" : 2,\n",
        "        \"num_start_location\" : DOWN+RIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        for x in range(2):\n",
        "            self.increment()\n",
        "        self.wait()\n",
        "        self.increment()\n",
        "        brace = Brace(self.number_mob[-1])\n",
        "        threes_place = brace.get_text(\"Three's place\")\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(threes_place)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(6):\n",
        "            self.increment()\n",
        "            self.wait()\n",
        "        new_brace = Brace(self.number_mob[-1])\n",
        "        nines_place = new_brace.get_text(\"Nine's place\")\n",
        "        self.play(\n",
        "            Transform(brace, new_brace),\n",
        "            Transform(threes_place, nines_place),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(9):\n",
        "            self.increment()\n",
        "\n",
        "class TernaryCountingSelfSimilarPattern(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_trits\" : 3,\n",
        "        \"colors\" : CountingScene.CONFIG[\"power_colors\"][:3],\n",
        "    }\n",
        "    def construct(self):\n",
        "        colors = self.colors\n",
        "\n",
        "        title = OldTexText(\"Count to \" + \"2\"*self.num_trits)\n",
        "        for i, color in enumerate(colors):\n",
        "            title[-i-1].set_color(color)\n",
        "        steps = VGroup(*list(map(TexText, [\n",
        "            \"Count to %s,\"%(\"2\"*(self.num_trits-1)),\n",
        "            \"Roll over,\",\n",
        "            \"Count to %s,\"%(\"2\"*(self.num_trits-1)),\n",
        "            \"Roll over,\",\n",
        "            \"Count to %s,\"%(\"2\"*(self.num_trits-1)),\n",
        "        ])))\n",
        "        steps.arrange(RIGHT)\n",
        "        for step in steps[::2]:\n",
        "            for i, color in enumerate(colors[:-1]):\n",
        "                step[-i-2].set_color(color)\n",
        "        VGroup(*steps[1::2]).set_color(colors[-1])\n",
        "        steps.set_width(FRAME_WIDTH-1)\n",
        "        brace = Brace(steps, UP)\n",
        "        word_group = VGroup(title, brace, steps)\n",
        "        word_group.arrange(DOWN)\n",
        "        word_group.to_edge(UP)\n",
        "\n",
        "        ternary_mobs = VGroup(*[\n",
        "            get_ternary_tex_mob(n, n_trits = self.num_trits)\n",
        "            for n in range(3**self.num_trits)\n",
        "        ])\n",
        "        ternary_mobs.scale(2)\n",
        "        ternary_mob_iter = it.cycle(ternary_mobs)\n",
        "        curr_ternary_mob = next(ternary_mob_iter)\n",
        "\n",
        "        for trits in ternary_mobs:\n",
        "            trits.align_data_and_family(curr_ternary_mob)\n",
        "            for trit, color in zip(trits, colors):\n",
        "                trit.set_color(color)\n",
        "        def get_increment():\n",
        "            return Transform(\n",
        "                curr_ternary_mob, next(ternary_mob_iter),\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = -np.pi/3\n",
        "            )\n",
        "\n",
        "        self.add(curr_ternary_mob, title)\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        for i, step in enumerate(steps):\n",
        "            self.play(Write(step, run_time = 1))\n",
        "            if i%2 == 0:\n",
        "                self.play(\n",
        "                    Succession(*[\n",
        "                        get_increment()\n",
        "                        for x in range(3**(self.num_trits-1)-1)\n",
        "                    ]),\n",
        "                    run_time = 1\n",
        "                )\n",
        "            else:\n",
        "                self.play(get_increment())\n",
        "            self.wait()\n",
        "\n",
        "class TernaryCountingSelfSimilarPatternFiveTrits(TernaryCountingSelfSimilarPattern):\n",
        "    CONFIG = {\n",
        "        \"num_trits\" : 5,\n",
        "        \"colors\" : color_gradient([YELLOW, PINK, RED], 5),\n",
        "    }\n",
        "\n",
        "class CountInTernary(IntroduceTernaryCounting):\n",
        "    def construct(self):\n",
        "        for x in range(9):\n",
        "            self.increment()\n",
        "        self.wait()\n",
        "\n",
        "class SolveConstrainedWithTernaryCounting(ConstrainedTowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 4,\n",
        "    }    \n",
        "    def construct(self):\n",
        "        for x in range(3**self.num_disks-1):\n",
        "            self.increment(run_time = 0.75)\n",
        "        self.wait()\n",
        "\n",
        "    def setup(self):\n",
        "        ConstrainedTowersOfHanoiScene.setup(self)\n",
        "        ternary_mobs = VGroup(*[\n",
        "            get_ternary_tex_mob(x)\n",
        "            for x in range(3**self.num_disks)\n",
        "        ])\n",
        "        ternary_mobs.scale(2)\n",
        "        ternary_mobs.next_to(self.peg_labels, DOWN)\n",
        "\n",
        "        for trits in ternary_mobs:\n",
        "            trits.align_data_and_family(ternary_mobs[0])\n",
        "            trits.set_color_by_gradient(*self.disk_start_and_end_colors)\n",
        "        self.ternary_mob_iter = it.cycle(ternary_mobs)            \n",
        "        self.curr_ternary_mob = self.ternary_mob_iter.next().copy()            \n",
        "        self.disk_index_iter = it.cycle(\n",
        "            get_ternary_ruler_sequence(self.num_disks-1)\n",
        "        )\n",
        "        self.ternary_mobs = ternary_mobs\n",
        "\n",
        "    def increment(self, run_time = 1, stay_on_peg = False):\n",
        "        self.increment_number(run_time)\n",
        "        self.move_next_disk(run_time, stay_on_peg)\n",
        "\n",
        "    def increment_number(self, run_time = 1):\n",
        "        self.play(Transform(\n",
        "            self.curr_ternary_mob, next(self.ternary_mob_iter),\n",
        "            path_arc = -np.pi/3,\n",
        "            lag_ratio = 0.5, \n",
        "            run_time = run_time,\n",
        "        ))\n",
        "\n",
        "    def move_next_disk(self, run_time = None, stay_on_peg = False):\n",
        "        self.move_disk(\n",
        "            next(self.disk_index_iter), \n",
        "            run_time = run_time,\n",
        "            stay_on_peg = stay_on_peg\n",
        "        )\n",
        "\n",
        "class DescribeSolutionByCountingToConstrained(SolveConstrainedWithTernaryCounting):\n",
        "    def construct(self):\n",
        "        braces = [\n",
        "            Brace(VGroup(*self.curr_ternary_mob[:n+1]))\n",
        "            for n in range(self.num_disks)\n",
        "        ]\n",
        "        words = [\n",
        "            brace.get_text(text)\n",
        "            for brace, text in zip(braces, [\n",
        "                \"Only flip last trit\",\n",
        "                \"Roll over once\",\n",
        "                \"Roll over twice\",\n",
        "                \"Roll over three times\",\n",
        "            ])\n",
        "        ]\n",
        "\n",
        "        #Count 1, 2\n",
        "        color = YELLOW\n",
        "        brace = braces[0]\n",
        "        word = words[0]\n",
        "        words[0].set_color(color)\n",
        "        self.increment_number()        \n",
        "        self.play(\n",
        "            FadeIn(brace),\n",
        "            Write(word, run_time = 1),\n",
        "            self.curr_ternary_mob[0].set_color, color\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.disks[0].set_fill, color,\n",
        "            self.disks[0].label.set_fill, BLACK,\n",
        "        )\n",
        "        self.move_next_disk(stay_on_peg = True)\n",
        "        self.wait()\n",
        "        self.ternary_mobs[2][0].set_color(color)\n",
        "        self.increment_number()\n",
        "        self.move_next_disk(stay_on_peg = True)\n",
        "        self.wait()\n",
        "        \n",
        "        #Count 10\n",
        "        color = MAROON_B\n",
        "        words[1].set_color(color)\n",
        "        self.increment_number()\n",
        "        self.play(\n",
        "            Transform(brace, braces[1]),\n",
        "            Transform(word, words[1]),\n",
        "            self.curr_ternary_mob[1].set_color, color\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.disks[1].set_fill, color,\n",
        "            self.disks[1].label.set_fill, BLACK,\n",
        "        )\n",
        "        self.move_next_disk(stay_on_peg = True)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, word])))\n",
        "\n",
        "        #Count up to 22\n",
        "        for x in range(5):\n",
        "            self.increment()\n",
        "            self.wait()\n",
        "\n",
        "        #Count to 100\n",
        "        color = RED\n",
        "        words[2].set_color(color)\n",
        "\n",
        "        self.wait()\n",
        "        self.increment_number()\n",
        "        self.play(\n",
        "            FadeIn(braces[2]),\n",
        "            Write(words[2], run_time = 1),\n",
        "            self.curr_ternary_mob[2].set_fill, color,\n",
        "            self.disks[2].set_fill, color,\n",
        "            self.disks[2].label.set_fill, BLACK,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_next_disk(stay_on_peg = True)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [braces[2], words[2]])))\n",
        "\n",
        "        for x in range(20):\n",
        "            self.increment()\n",
        "\n",
        "class Describe2222(Scene):\n",
        "    def construct(self):\n",
        "        ternary_mob = OldTex(\"2222\").scale(1.5)\n",
        "        brace = Brace(ternary_mob)\n",
        "        description = brace.get_text(\"$3^4 - 1 = 80$\")\n",
        "        VGroup(ternary_mob, brace, description).scale(1.5)\n",
        "\n",
        "        self.add(ternary_mob)\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(description))\n",
        "        self.wait()\n",
        "\n",
        "class KeithAsksAboutConfigurations(Scene):\n",
        "    def construct(self):\n",
        "        keith = Keith().shift(2*DOWN+3*LEFT)\n",
        "        morty = Mortimer().shift(2*DOWN+3*RIGHT)\n",
        "        keith.make_eye_contact(morty)\n",
        "        bubble = keith.get_bubble(SpeechBubble)\n",
        "        bubble.write(\"Think about how many \\\\\\\\ configurations there are.\")\n",
        "\n",
        "        self.add(keith, morty)\n",
        "        self.play(Blink(keith))\n",
        "        self.play(\n",
        "            keith.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change_mode, \"pondering\")\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutConfigurations(SolveConstrainedWithTernaryCounting):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\"How many configurations?\")\n",
        "        question.scale(1.5)\n",
        "        question.to_edge(UP)\n",
        "        self.add(question)\n",
        "\n",
        "        for x in range(15):\n",
        "            self.remove(self.curr_ternary_mob)\n",
        "            self.wait(2)\n",
        "            for y in range(7):\n",
        "                self.increment(run_time = 0)\n",
        "\n",
        "class AnswerConfigurationsCount(TowersOfHanoiScene):\n",
        "    CONFIG = {\n",
        "        \"middle_peg_bottom\" : 2.5*DOWN,\n",
        "        \"num_disks\" : 4,\n",
        "        \"peg_height\" : 1.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        answer = OldTexText(\"$3^4 = 81$ configurations\")\n",
        "        answer.to_edge(UP)\n",
        "        self.add(answer)\n",
        "\n",
        "        parentheticals = self.get_parentheticals(answer)\n",
        "\n",
        "        self.prepare_disks()\n",
        "\n",
        "        for parens, disk in zip(parentheticals, reversed(list(self.disks))):\n",
        "            VGroup(parens, parens.brace, parens.three).set_color(disk.get_color())\n",
        "            self.play(\n",
        "                Write(parens, run_time = 1),\n",
        "                FadeIn(disk)\n",
        "            )\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    disk.next_to, self.pegs[2], UP,\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                GrowFromCenter(parens.brace),\n",
        "                Write(parens.three, run_time = 1)\n",
        "            )\n",
        "            x_diff = disk.saved_state.get_center()[0]-disk.get_center()[0]\n",
        "            self.play(\n",
        "                disk.shift, x_diff*RIGHT\n",
        "            )\n",
        "            self.play(disk.restore)\n",
        "            self.wait()\n",
        "\n",
        "    def get_parentheticals(self, top_mob):\n",
        "        parentheticals = VGroup(*reversed([\n",
        "            OldTex(\"\"\"\n",
        "                \\\\left(\n",
        "                    \\\\begin{array}{c}\n",
        "                        \\\\text{Choices for} \\\\\\\\\n",
        "                        \\\\text{disk %d}\n",
        "                    \\\\end{array}\n",
        "                \\\\right)\n",
        "            \"\"\"%d)\n",
        "            for d in range(self.num_disks)\n",
        "        ]))\n",
        "        parentheticals.arrange()\n",
        "        parentheticals.set_width(FRAME_WIDTH-1)\n",
        "        parentheticals.next_to(top_mob, DOWN)\n",
        "        for parens in parentheticals:\n",
        "            brace = Brace(parens)\n",
        "            three = brace.get_text(\"$3$\")\n",
        "            parens.brace = brace\n",
        "            parens.three = three\n",
        "        return parentheticals\n",
        "\n",
        "    def prepare_disks(self):\n",
        "        configuration = [1, 2, 1, 0]\n",
        "        for n, peg_index in enumerate(configuration):\n",
        "            disk_index = self.num_disks-n-1\n",
        "            disk = self.disks[disk_index]\n",
        "            top = Circle(radius = disk.get_width()/2)\n",
        "            inner = Circle(radius = self.peg_width/2)\n",
        "            inner.flip()\n",
        "            top.add_subpath(inner.points)\n",
        "            top.set_stroke(width = 0)\n",
        "            top.set_fill(disk.get_color())\n",
        "            top.rotate(np.pi/2, RIGHT)\n",
        "            top.move_to(disk, UP)\n",
        "            bottom = top.copy()\n",
        "            bottom.move_to(disk, DOWN)\n",
        "            disk.remove(disk.label)\n",
        "            disk.add(top, bottom, disk.label)\n",
        "            self.move_disk_to_peg(disk_index, peg_index, run_time = 0)\n",
        "            if disk_index == 0:\n",
        "                disk.move_to(self.pegs[peg_index].get_bottom(), DOWN)\n",
        "        for disk in self.disks:\n",
        "            disk.save_state()\n",
        "            disk.rotate(np.pi/30, RIGHT)\n",
        "            disk.next_to(self.pegs[0], UP)\n",
        "        self.remove(self.disks)\n",
        "\n",
        "class ThisIsMostEfficientText(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"This is the most efficient solution\")\n",
        "        text.set_width(FRAME_WIDTH - 1)\n",
        "        text.to_edge(DOWN)\n",
        "        self.play(Write(text))\n",
        "        self.wait(2)\n",
        "\n",
        "class RepeatingConfiguraiton(Scene):\n",
        "    def construct(self):\n",
        "        dots = VGroup(*[Dot() for x in range(10)])\n",
        "        arrows = VGroup(*[Arrow(LEFT, RIGHT) for x in range(9)])\n",
        "        arrows.add(VGroup())\n",
        "        arrows.scale(0.5)\n",
        "        group = VGroup(*it.chain(*list(zip(dots, arrows))))\n",
        "        group.arrange()\n",
        "        title = OldTexText(\"Same state twice\")\n",
        "        title.shift(3*UP)\n",
        "        special_dots = VGroup(dots[2], dots[6])\n",
        "        special_arrows = VGroup(*[\n",
        "            Arrow(title.get_bottom(), dot, color = RED)\n",
        "            for dot in special_dots\n",
        "        ])\n",
        "        mid_mobs = VGroup(*group[5:14])\n",
        "        mid_arrow = Arrow(dots[2], dots[7], tip_length = 0.125)\n",
        "        more_efficient = OldTexText(\"More efficient\")\n",
        "        more_efficient.next_to(mid_arrow, UP)\n",
        "\n",
        "        self.play(ShowCreation(group, run_time = 2))\n",
        "        self.play(Write(title))\n",
        "        self.play(\n",
        "            ShowCreation(special_arrows),\n",
        "            special_dots.set_color, RED\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mid_mobs.shift, 2*DOWN,\n",
        "            FadeOut(special_arrows)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(mid_arrow),\n",
        "            Write(more_efficient)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ShowSomeGraph(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Graphs\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        nodes = VGroup(*list(map(Dot, [\n",
        "            2*LEFT, \n",
        "            UP,\n",
        "            DOWN,\n",
        "            2*RIGHT,\n",
        "            2*RIGHT+2*UP,\n",
        "            2*RIGHT+2*DOWN,\n",
        "            4*RIGHT+2*UP,\n",
        "        ])))\n",
        "        edge_pairs = [\n",
        "            (0, 1),\n",
        "            (0, 2),\n",
        "            (1, 3),\n",
        "            (2, 3),\n",
        "            (3, 4),\n",
        "            (3, 5),\n",
        "            (4, 6),\n",
        "        ]\n",
        "        edges = VGroup()\n",
        "        for i, j in edge_pairs:\n",
        "            edges.add(Line(\n",
        "                nodes[i].get_center(), \n",
        "                nodes[j].get_center(), \n",
        "            ))\n",
        "\n",
        "        self.play(Write(title))\n",
        "        for mob in nodes, edges:\n",
        "            mob.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "            self.play(ShowCreation(\n",
        "                mob, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2,\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "class SierpinskiGraphScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 3,\n",
        "        \"towers_config\" : {\n",
        "            \"num_disks\" : 3,\n",
        "            \"peg_height\" : 1.5,\n",
        "            \"peg_spacing\" : 2,\n",
        "            \"include_peg_labels\" : False,\n",
        "            \"disk_min_width\" : 1,\n",
        "            \"disk_max_width\" : 2,\n",
        "        },\n",
        "        \"preliminary_node_radius\" : 1,\n",
        "        \"center_to_island_length\" : 2.0,\n",
        "        \"include_towers\" : True,\n",
        "        \"start_color\" : RED,\n",
        "        \"end_color\" : GREEN,\n",
        "        \"graph_stroke_width\" : 2,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.initialize_nodes()\n",
        "        self.add(self.nodes)\n",
        "\n",
        "        self.initialize_edges()\n",
        "        self.add(self.edges)\n",
        "\n",
        "    def initialize_nodes(self):\n",
        "        circles = self.get_node_circles(self.num_disks)\n",
        "        circles.set_color_by_gradient(self.start_color, self.end_color)\n",
        "        circles.set_fill(BLACK, opacity = 0.7)\n",
        "        circles.set_stroke(width = self.graph_stroke_width)\n",
        "\n",
        "        self.nodes = VGroup()\n",
        "        for circle in circles.get_family():\n",
        "            if not isinstance(circle, Circle):\n",
        "                continue\n",
        "            node = VGroup()\n",
        "            node.add(circle)\n",
        "            node.circle = circle\n",
        "            self.nodes.add(node)\n",
        "        if self.include_towers:\n",
        "            self.add_towers_to_nodes()\n",
        "        self.nodes.set_height(FRAME_HEIGHT-2)\n",
        "        self.nodes.to_edge(UP)\n",
        "\n",
        "    def get_node_circles(self, order = 3):\n",
        "        if order == 0:\n",
        "            return Circle(radius = self.preliminary_node_radius)\n",
        "        islands = [self.get_node_circles(order-1) for x in range(3)]\n",
        "        for island, angle in (islands[0], np.pi/6), (islands[2], 5*np.pi/6):\n",
        "            island.rotate(\n",
        "                np.pi,\n",
        "                rotate_vector(RIGHT, angle),\n",
        "                about_point = island.get_center_of_mass()\n",
        "            )\n",
        "        for n, island in enumerate(islands):\n",
        "            vect = rotate_vector(RIGHT, -5*np.pi/6-n*2*np.pi/3)\n",
        "            island.scale(0.5)\n",
        "            island.shift(vect)\n",
        "        return VGroup(*islands)\n",
        "\n",
        "    def add_towers_to_nodes(self):\n",
        "        towers_scene = ConstrainedTowersOfHanoiScene(**self.towers_config)\n",
        "        tower_scene_group = VGroup(*towers_scene.get_mobjects())\n",
        "        ruler_sequence = get_ternary_ruler_sequence(self.num_disks-1)\n",
        "        self.disks = VGroup(*[VGroup() for x in range(self.num_disks)])\n",
        "\n",
        "        for disk_index, node in zip(ruler_sequence+[0], self.nodes):\n",
        "            towers = tower_scene_group.copy()\n",
        "            for mob in towers:\n",
        "                if hasattr(mob, \"label\"):\n",
        "                    self.disks[int(mob.label.tex_string)].add(mob)\n",
        "            towers.set_width(0.85*node.get_width())\n",
        "            towers.move_to(node)\n",
        "            node.towers = towers\n",
        "            node.add(towers)\n",
        "            towers_scene.move_disk(disk_index, run_time = 0)            \n",
        "\n",
        "    def distance_between_nodes(self, i, j):\n",
        "        return get_norm(\n",
        "            self.nodes[i].get_center()-\\\n",
        "            self.nodes[j].get_center()\n",
        "        )\n",
        "\n",
        "    def initialize_edges(self):\n",
        "        edges = VGroup()\n",
        "        self.edge_dict = {}\n",
        "        min_distance = self.distance_between_nodes(0, 1)\n",
        "        min_distance *= 1.1 ##Just a little buff to be sure\n",
        "        node_radius = self.nodes[0].get_width()/2\n",
        "        for i, j in it.combinations(list(range(3**self.num_disks)), 2):\n",
        "            center1 = self.nodes[i].get_center()\n",
        "            center2 = self.nodes[j].get_center()\n",
        "            vect = center1-center2\n",
        "            distance = get_norm(center1 - center2)\n",
        "            if distance < min_distance:\n",
        "                edge = Line(\n",
        "                    center1 - (vect/distance)*node_radius,\n",
        "                    center2 + (vect/distance)*node_radius,\n",
        "                    color = self.nodes[i].circle.get_stroke_color(),\n",
        "                    stroke_width = self.graph_stroke_width,\n",
        "                )\n",
        "                edges.add(edge)\n",
        "                self.edge_dict[self.node_indices_to_key(i, j)] = edge\n",
        "        self.edges = edges\n",
        "\n",
        "    def node_indices_to_key(self, i, j):\n",
        "        return \",\".join(map(str, sorted([i, j])))\n",
        "\n",
        "    def node_indices_to_edge(self, i, j):\n",
        "        key = self.node_indices_to_key(i, j)\n",
        "        if key not in self.edge_dict:\n",
        "            warnings.warn(\"(%d, %d) is not an edge\"%(i, j))\n",
        "            return VGroup()\n",
        "        return self.edge_dict[key]\n",
        "\n",
        "    def zoom_into_node(self, node_index, order = 0):\n",
        "        start_index = node_index - node_index%(3**order)\n",
        "        node_indices = [start_index + r for r in range(3**order)]\n",
        "        self.zoom_into_nodes(node_indices)\n",
        "\n",
        "    def zoom_into_nodes(self, node_indices):\n",
        "        nodes = VGroup(*[\n",
        "            self.nodes[index].circle\n",
        "            for index in node_indices\n",
        "        ])\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        if nodes.get_width()/nodes.get_height() > FRAME_X_RADIUS/FRAME_Y_RADIUS:\n",
        "            scale_factor = (FRAME_WIDTH-2)/nodes.get_width()\n",
        "        else:\n",
        "            scale_factor = (FRAME_HEIGHT-2)/nodes.get_height()\n",
        "        self.play(\n",
        "            everything.shift, -nodes.get_center(),\n",
        "            everything.scale, scale_factor\n",
        "        )\n",
        "        self.remove(everything)\n",
        "        self.add(*everything)\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceGraphStructure(SierpinskiGraphScene):\n",
        "    CONFIG = {\n",
        "        \"include_towers\" : True, \n",
        "        \"graph_stroke_width\" : 3,\n",
        "        \"num_disks\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.nodes, self.edges)\n",
        "        self.introduce_nodes()\n",
        "        self.define_edges()\n",
        "        self.tour_structure()\n",
        "\n",
        "    def introduce_nodes(self):\n",
        "        self.play(FadeIn(\n",
        "            self.nodes,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        vect = LEFT\n",
        "        for index in 3, 21, 8, 17, 10, 13:\n",
        "            node = self.nodes[index]\n",
        "            node.save_state()\n",
        "            self.play(\n",
        "                node.set_height, FRAME_HEIGHT-2,\n",
        "                node.next_to, ORIGIN, vect\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(node.restore)\n",
        "            node.saved_state = None\n",
        "            vect = -vect\n",
        "\n",
        "    def define_edges(self):\n",
        "        nodes = [self.nodes[i] for i in (12, 14)]\n",
        "        for node, vect in zip(nodes, [LEFT, RIGHT]):\n",
        "            node.save_state()\n",
        "            node.generate_target()\n",
        "            node.target.set_height(5)\n",
        "            node.target.center()\n",
        "            node.target.to_edge(vect)\n",
        "            arc = Arc(angle = -2*np.pi/3, start_angle = 5*np.pi/6)\n",
        "            if vect is RIGHT:\n",
        "                arc.flip()\n",
        "            arc.set_width(0.8*node.target.towers.get_width())\n",
        "            arc.next_to(node.target.towers, UP)\n",
        "            arc.add_tip()\n",
        "            arc.set_color(YELLOW)\n",
        "            node.arc = arc\n",
        "\n",
        "        self.play(*list(map(MoveToTarget, nodes)))\n",
        "        edge = Line(\n",
        "            nodes[0].get_right(), nodes[1].get_left(),\n",
        "            color = YELLOW,\n",
        "            stroke_width = 6,\n",
        "        )\n",
        "        edge.target = self.node_indices_to_edge(12, 14)\n",
        "        self.play(ShowCreation(edge))\n",
        "        self.wait()\n",
        "        for node in nodes:\n",
        "            self.play(ShowCreation(node.arc))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            FadeOut(node.arc)\n",
        "            for node in nodes\n",
        "        ])\n",
        "        self.play(\n",
        "            MoveToTarget(edge),\n",
        "            *[node.restore for node in nodes]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(self.edges, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "    def tour_structure(self):\n",
        "        for n in range(3):\n",
        "            self.zoom_into_node(n)\n",
        "        self.zoom_into_node(0, 1)\n",
        "        self.play(\n",
        "            self.disks[0].set_color, YELLOW,\n",
        "            *[\n",
        "                ApplyMethod(disk.label.set_color, BLACK)\n",
        "                for disk in self.disks[0]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.zoom_into_node(0, 3)\n",
        "        self.zoom_into_node(15, 1)\n",
        "        self.wait()\n",
        "        self.zoom_into_node(20, 1)\n",
        "        self.wait()\n",
        "\n",
        "class DescribeTriforcePattern(SierpinskiGraphScene):\n",
        "    CONFIG = {\n",
        "        \"index_pairs\" : [(7, 1), (2, 3), (5, 6)],\n",
        "        \"scale\" : 2,\n",
        "        \"disk_color\" : MAROON_B,\n",
        "        \"include_towers\" : True,\n",
        "        \"first_connect_0_and_2_islands\" : True, #Dumb that I have to do this\n",
        "    }\n",
        "    def construct(self):\n",
        "        index_pair = self.index_pairs[0]\n",
        "        self.zoom_into_node(index_pair[0], self.scale)\n",
        "        self.play(\n",
        "            self.disks[self.scale-1].set_color, self.disk_color,\n",
        "            *[\n",
        "                ApplyMethod(disk.label.set_color, BLACK)\n",
        "                for disk in self.disks[self.scale-1]\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        nodes = [self.nodes[i] for i in index_pair]\n",
        "        for node, vect in zip(nodes, [LEFT, RIGHT]):\n",
        "            node.save_state()\n",
        "            node.generate_target()\n",
        "            node.target.set_height(6)\n",
        "            node.target.center().next_to(ORIGIN, vect)\n",
        "\n",
        "        self.play(*list(map(MoveToTarget, nodes)))\n",
        "        self.wait()\n",
        "        self.play(*[node.restore for node in nodes])\n",
        "        bold_edges = [\n",
        "            self.node_indices_to_edge(*pair).copy().set_stroke(self.disk_color, 6)\n",
        "            for pair in self.index_pairs\n",
        "        ]\n",
        "        self.play(ShowCreation(bold_edges[0]))\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShowCreation, bold_edges[1:])))\n",
        "        self.wait()\n",
        "\n",
        "        power_of_three = 3**(self.scale-1)\n",
        "        index_sets = [\n",
        "            list(range(0, power_of_three)),\n",
        "            list(range(power_of_three, 2*power_of_three)),\n",
        "            list(range(2*power_of_three, 3*power_of_three)),\n",
        "        ]\n",
        "        if self.first_connect_0_and_2_islands:\n",
        "            index_sets = [index_sets[0], index_sets[2], index_sets[1]]\n",
        "        islands = [\n",
        "            VGroup(*[self.nodes[i] for i in index_set])\n",
        "            for index_set in index_sets\n",
        "        ]\n",
        "        def wiggle_island(island):\n",
        "            return ApplyMethod(\n",
        "                island.rotate, np.pi/12, \n",
        "                run_time = 1,\n",
        "                rate_func = wiggle\n",
        "            )\n",
        "        self.play(*list(map(wiggle_island, islands[:2])))\n",
        "        self.wait()\n",
        "        self.play(wiggle_island(islands[2]))\n",
        "        self.wait()\n",
        "        for index_set in index_sets:\n",
        "            self.zoom_into_nodes(index_set)\n",
        "        self.zoom_into_nodes(list(it.chain(*index_sets)))\n",
        "        self.wait()\n",
        "\n",
        "class TriforcePatternWord(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"Triforce \\\\\\\\ pattern\")\n",
        "        word.scale(2)\n",
        "        word.to_corner(DOWN+RIGHT)\n",
        "        self.play(Write(word))\n",
        "        self.wait(2)\n",
        "\n",
        "class DescribeOrderTwoPattern(DescribeTriforcePattern):\n",
        "    CONFIG = {\n",
        "        \"index_pairs\" : [(8, 9), (17, 18), (4, 22)],\n",
        "        \"scale\" : 3,\n",
        "        \"disk_color\" : RED,\n",
        "        \"first_connect_0_and_2_islands\" : False,\n",
        "    }\n",
        "\n",
        "class BiggerTowers(SierpinskiGraphScene):\n",
        "    CONFIG = {\n",
        "        \"num_disks\" : 6,\n",
        "        \"include_towers\" : False\n",
        "    }\n",
        "    def construct(self):\n",
        "        for order in range(3, 7):\n",
        "            self.zoom_into_node(0, order)\n",
        "\n",
        "class ShowPathThroughGraph(SierpinskiGraphScene):\n",
        "    CONFIG = {\n",
        "        \"include_towers\" : True\n",
        "    }\n",
        "    def construct(self):\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                n1.get_center(),\n",
        "                n2.get_center(),\n",
        "                tip_length = 0.15,\n",
        "                buff = 0.15\n",
        "            )\n",
        "            for n1, n2 in zip(self.nodes, self.nodes[1:])\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            arrows,\n",
        "            rate_func=linear,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        for index in range(9):\n",
        "            self.zoom_into_node(index)\n",
        "\n",
        "class MentionFinalAnimation(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN+3*RIGHT)\n",
        "        bubble = morty.get_bubble(SpeechBubble, width = 6)\n",
        "        bubble.write(\"Before the final\\\\\\\\ animation...\")\n",
        "\n",
        "        self.add(morty)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"speaking\",\n",
        "            morty.look_at, bubble.content,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class PatreonThanks(Scene):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"CrypticSwarm\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Juan    Batiz-Benet\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Einar Johansen\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "\n",
        "        n_patrons = len(self.specific_patrons)\n",
        "        special_thanks = OldTexText(\"Special thanks to:\")\n",
        "        special_thanks.set_color(YELLOW)\n",
        "        special_thanks.shift(3*UP)\n",
        "\n",
        "        left_patrons = VGroup(*list(map(TexText, \n",
        "            self.specific_patrons[:n_patrons/2]\n",
        "        )))\n",
        "        right_patrons = VGroup(*list(map(TexText, \n",
        "            self.specific_patrons[n_patrons/2:]\n",
        "        )))\n",
        "        for patrons, vect in (left_patrons, LEFT), (right_patrons, RIGHT):\n",
        "            patrons.arrange(DOWN, aligned_edge = LEFT)\n",
        "            patrons.next_to(special_thanks, DOWN)\n",
        "            patrons.to_edge(vect, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(morty.change_mode, \"gracious\")\n",
        "        self.play(Write(special_thanks, run_time = 1))\n",
        "        self.play(\n",
        "            Write(left_patrons),\n",
        "            morty.look_at, left_patrons\n",
        "        )\n",
        "        self.play(\n",
        "            Write(right_patrons),\n",
        "            morty.look_at, right_patrons\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        for patrons in left_patrons, right_patrons:\n",
        "            for index in 0, -1:\n",
        "                self.play(morty.look_at, patrons[index])\n",
        "                self.wait()\n",
        "\n",
        "class MortyLookingAtRectangle(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        url = OldTexText(\"www.desmos.com/careers\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.shift_onto_screen()\n",
        "        url.save_state()\n",
        "        url.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "\n",
        "        self.play(morty.change_mode, \"raise_right_hand\")\n",
        "        self.play(Write(url))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            url.restore,\n",
        "            morty.change_mode, \"happy\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class ShowSierpinskiCurvesOfIncreasingOrder(Scene):\n",
        "    CONFIG = {\n",
        "        \"sierpinski_graph_scene_config\" :{\n",
        "            \"include_towers\" : False\n",
        "        },\n",
        "        \"min_order\" : 2,\n",
        "        \"max_order\" : 7,\n",
        "        \"path_stroke_width\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        graph_scenes = [\n",
        "            SierpinskiGraphScene(\n",
        "                num_disks = order,\n",
        "                **self.sierpinski_graph_scene_config\n",
        "            )\n",
        "            for order in range(self.min_order, self.max_order+1)\n",
        "        ]\n",
        "        paths = [self.get_path(scene) for scene in graph_scenes]\n",
        "        graphs = []\n",
        "        for scene in graph_scenes:\n",
        "            graphs.append(scene.nodes)\n",
        "        for graph in graphs:\n",
        "            graph.set_fill(opacity = 0)\n",
        "\n",
        "        graph, path = graphs[0], paths[0]\n",
        "\n",
        "        self.add(graph)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(path, run_time = 3, rate_func=linear))\n",
        "        self.wait()   \n",
        "        self.play(graph.fade, 0.5, Animation(path))\n",
        "        for other_graph in graphs[1:]:\n",
        "            other_graph.fade(0.5)\n",
        "        self.wait()\n",
        "        for new_graph, new_path in zip(graphs[1:], paths[1:]):\n",
        "            self.play(\n",
        "                Transform(graph, new_graph),\n",
        "                Transform(path, new_path),\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.path = path\n",
        "\n",
        "    def get_path(self, graph_scene):\n",
        "        path = VGroup()\n",
        "        nodes = graph_scene.nodes\n",
        "        for n1, n2, n3 in zip(nodes, nodes[1:], nodes[2:]):\n",
        "            segment = VMobject()\n",
        "            segment.set_points_as_corners([\n",
        "                n1.get_center(),\n",
        "                n2.get_center(),\n",
        "                n3.get_center(),\n",
        "            ])\n",
        "            path.add(segment)\n",
        "        path.set_color_by_gradient(\n",
        "            graph_scene.start_color,\n",
        "            graph_scene.end_color,\n",
        "        )\n",
        "        path.set_stroke(\n",
        "            width = self.path_stroke_width - graph_scene.num_disks/2\n",
        "        )\n",
        "        return path\n",
        "\n",
        "class Part1Thumbnail(Scene):\n",
        "    CONFIG = {\n",
        "        \"part_number\" : 1,\n",
        "        \"sierpinski_order\" : 5\n",
        "    }\n",
        "    def construct(self):\n",
        "        toh_scene = TowersOfHanoiScene(\n",
        "            peg_spacing = 2,\n",
        "            part_number = 1,\n",
        "        )\n",
        "        toh_scene.remove(toh_scene.peg_labels)\n",
        "        toh_scene.pegs[2].set_fill(opacity = 0.5)\n",
        "        toh = VGroup(*toh_scene.get_mobjects())\n",
        "        toh.scale(2)\n",
        "        toh.to_edge(DOWN)\n",
        "        self.add(toh)\n",
        "\n",
        "        sierpinski_scene = ShowSierpinskiCurvesOfIncreasingOrder(\n",
        "            min_order = self.sierpinski_order,\n",
        "            max_order = self.sierpinski_order,\n",
        "            skip_animations = True,\n",
        "        )\n",
        "        sierpinski_scene.path.set_stroke(width = 10)        \n",
        "        sierpinski = VGroup(*sierpinski_scene.get_mobjects())\n",
        "        sierpinski.scale(0.9)\n",
        "        sierpinski.to_corner(DOWN+RIGHT)\n",
        "        self.add(sierpinski)\n",
        "\n",
        "        binary = OldTex(\"01011\")\n",
        "        binary.set_color_by_tex(\"0\", GREEN)\n",
        "        binary.set_color_by_tex(\"1\", BLUE)\n",
        "        binary.set_color_by_gradient(GREEN, RED)\n",
        "        binary.add_background_rectangle()\n",
        "        binary.background_rectangle.set_fill(opacity = 0.5)\n",
        "        # binary.set_fill(opacity = 0.5)\n",
        "        binary.scale(4)\n",
        "        binary.to_corner(UP+LEFT)\n",
        "        self.add(binary)\n",
        "\n",
        "        part = OldTexText(\"Part %d\"%self.part_number)\n",
        "        part.scale(4)\n",
        "        part.to_corner(UP+RIGHT)\n",
        "        part.add_background_rectangle()\n",
        "        self.add(part)\n",
        "\n",
        "class Part2Thumbnail(Part1Thumbnail):\n",
        "    CONFIG = {\n",
        "        \"part_number\" : 2\n",
        "    }\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}