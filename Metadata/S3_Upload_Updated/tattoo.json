{
    "topic": "else:                 color = self.x_line_colors",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class TrigRepresentationsScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"unit_length\" : 1.5,\n",
        "        \"arc_radius\" : 0.5,\n",
        "        \"axes_color\" : WHITE,\n",
        "        \"circle_color\" : RED,\n",
        "        \"theta_color\" : YELLOW,\n",
        "        \"theta_height\" : 0.3,\n",
        "        \"theta_value\" : np.pi/5,\n",
        "        \"x_line_colors\" : MAROON_B,\n",
        "        \"y_line_colors\" : BLUE,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.init_axes()\n",
        "        self.init_circle()\n",
        "        self.init_theta_group()\n",
        "\n",
        "    def init_axes(self):\n",
        "        self.axes = Axes(\n",
        "            unit_size = self.unit_length,\n",
        "        )\n",
        "        self.axes.set_color(self.axes_color)\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def init_circle(self):\n",
        "        self.circle = Circle(\n",
        "            radius = self.unit_length,\n",
        "            color = self.circle_color\n",
        "        )\n",
        "        self.add(self.circle)\n",
        "\n",
        "    def init_theta_group(self):\n",
        "        self.theta_group = self.get_theta_group()\n",
        "        self.add(self.theta_group)\n",
        "\n",
        "    def add_trig_lines(self, *funcs, **kwargs):\n",
        "        lines = VGroup(*[\n",
        "            self.get_trig_line(func, **kwargs)\n",
        "            for func in funcs\n",
        "        ])\n",
        "        self.add(*lines)\n",
        "\n",
        "    def get_theta_group(self):\n",
        "        arc = Arc(\n",
        "            self.theta_value, \n",
        "            radius = self.arc_radius,\n",
        "            color = self.theta_color,\n",
        "        )\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.shift(1.5*arc.point_from_proportion(0.5))\n",
        "        theta.set_color(self.theta_color)\n",
        "        theta.set_height(self.theta_height)\n",
        "        line = Line(ORIGIN, self.get_circle_point())\n",
        "        dot = Dot(line.get_end(), radius = 0.05)\n",
        "        return VGroup(line, arc, theta, dot)\n",
        "\n",
        "    def get_circle_point(self):\n",
        "        return rotate_vector(self.unit_length*RIGHT, self.theta_value)\n",
        "\n",
        "    def get_trig_line(self, func_name = \"sin\", color = None):\n",
        "        assert(func_name in [\"sin\", \"tan\", \"sec\", \"cos\", \"cot\", \"csc\"])\n",
        "        is_co = func_name in [\"cos\", \"cot\", \"csc\"]\n",
        "        if color is None:\n",
        "            if is_co:\n",
        "                color = self.y_line_colors \n",
        "            else:\n",
        "                color = self.x_line_colors\n",
        "\n",
        "        #Establish start point\n",
        "        if func_name in [\"sin\", \"cos\", \"tan\", \"cot\"]:\n",
        "            start_point = self.get_circle_point()\n",
        "        else:\n",
        "            start_point = ORIGIN\n",
        "\n",
        "        #Establish end point\n",
        "        if func_name is \"sin\":\n",
        "            end_point = start_point[0]*RIGHT\n",
        "        elif func_name is \"cos\":\n",
        "            end_point = start_point[1]*UP\n",
        "        elif func_name in [\"tan\", \"sec\"]:\n",
        "            end_point = (1./np.cos(self.theta_value))*self.unit_length*RIGHT\n",
        "        elif func_name in [\"cot\", \"csc\"]:\n",
        "            end_point = (1./np.sin(self.theta_value))*self.unit_length*UP\n",
        "        return Line(start_point, end_point, color = color)\n",
        "\n",
        "class Introduce(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Something different today!\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play_student_changes(\"thinking\", \"happy\", \"sassy\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class ReactionsToTattoo(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        modes = [\n",
        "            \"horrified\",\n",
        "            \"hesitant\",\n",
        "            \"pondering\",\n",
        "            \"thinking\",\n",
        "            \"sassy\",\n",
        "        ]\n",
        "        tattoo_on_math = OldTexText(\"Tattoo on \\\\\\\\ math\")\n",
        "        tattoo_on_math.to_edge(UP)\n",
        "        self.wait(2)\n",
        "        for mode in modes:\n",
        "            self.play(\n",
        "                self.pi_creature.change_mode, mode,\n",
        "                self.pi_creature.look, UP+RIGHT\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play(\n",
        "            Write(tattoo_on_math),\n",
        "            self.pi_creature.change_mode, \"hooray\",\n",
        "            self.pi_creature.look, UP\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = Randolph()\n",
        "        randy.next_to(ORIGIN, DOWN)\n",
        "        return randy\n",
        "\n",
        "class IntroduceCSC(TrigRepresentationsScene):\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        Cam_S_C = OldTexText(\"Cam\", \"S.\", \"C.\")\n",
        "        CSC = OldTexText(\"C\", \"S\", \"C\", arg_separator = \"\")\n",
        "        csc_of_theta = OldTexText(\"c\", \"s\", \"c\", \"(\\\\theta)\", arg_separator = \"\")\n",
        "        csc, of_theta = VGroup(*csc_of_theta[:3]), csc_of_theta[-1]\n",
        "        of_theta[1].set_color(YELLOW)\n",
        "        CSC.move_to(csc, DOWN)\n",
        "\n",
        "        csc_line = self.get_trig_line(\"csc\")\n",
        "        csc_line.set_stroke(width = 8)\n",
        "        cot_line = self.get_trig_line(\"cot\")\n",
        "        cot_line.set_color(WHITE)\n",
        "        brace = Brace(csc_line, LEFT)\n",
        "\n",
        "        self.play(Write(Cam_S_C))\n",
        "        self.wait()\n",
        "        self.play(Transform(Cam_S_C, CSC))\n",
        "        self.wait()\n",
        "        self.play(Transform(Cam_S_C, csc))\n",
        "        self.remove(Cam_S_C)\n",
        "        self.add(csc)\n",
        "        self.play(Write(of_theta))\n",
        "        self.wait(2)\n",
        "\n",
        "        csc_of_theta.add_to_back(BackgroundRectangle(csc))\n",
        "        self.play(\n",
        "            ShowCreation(self.axes),\n",
        "            ShowCreation(self.circle),\n",
        "            GrowFromCenter(brace),            \n",
        "            csc_of_theta.rotate, np.pi/2,\n",
        "            csc_of_theta.next_to, brace, LEFT,\n",
        "            path_arc = np.pi/2,\n",
        "        )\n",
        "        self.play(Write(self.theta_group, run_time = 1))\n",
        "        self.play(ShowCreation(cot_line))\n",
        "        self.play(\n",
        "            ShowCreation(csc_line),\n",
        "            csc.set_color, csc_line.get_color(),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class TeachObscureTrigFunctions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"$\\\\sec(\\\\theta)$, \",\n",
        "            \"$\\\\csc(\\\\theta)$, \",\n",
        "            \"$\\\\cot(\\\\theta)$\",\n",
        "        )\n",
        "        content = self.teacher.bubble.content.copy()\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.student_says(\n",
        "            \"But why?\",\n",
        "            target_mode = \"pleading\",\n",
        "            added_anims = [content.to_corner, UP+RIGHT]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.get_teacher().change_mode, \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class CanYouExplainTheTattoo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            Wait, can you explain\n",
        "            the actual tattoo here?\n",
        "        \"\"\")\n",
        "        self.random_blink()\n",
        "        self.play(self.get_teacher().change_mode, \"hooray\")\n",
        "        self.wait()\n",
        "\n",
        "class ExplainTrigFunctionDistances(TrigRepresentationsScene, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"use_morty\" : False,\n",
        "        \"alt_theta_val\" : 2*np.pi/5,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        TrigRepresentationsScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_angle()\n",
        "        self.show_sine_and_cosine()\n",
        "        self.show_tangent_and_cotangent()\n",
        "        self.show_secant_and_cosecant()\n",
        "        self.explain_cosecant()\n",
        "        self.summarize_full_group()\n",
        "\n",
        "    def introduce_angle(self):\n",
        "        self.remove(self.circle)\n",
        "        self.remove(self.theta_group)\n",
        "        line, arc, theta, dot = self.theta_group\n",
        "        line.rotate(-self.theta_value)\n",
        "        brace = Brace(line, UP, buff = SMALL_BUFF)\n",
        "        one = brace.get_text(\"1\", buff = SMALL_BUFF)\n",
        "        VGroup(line, brace, one).rotate(self.theta_value)\n",
        "        one.rotate(-self.theta_value)\n",
        "        self.circle.rotate(self.theta_value)\n",
        "\n",
        "        words = OldTexText(\"Corresponding point\")\n",
        "        words.next_to(dot, UP+RIGHT, buff = 1.5*LARGE_BUFF)\n",
        "        words.shift_onto_screen()\n",
        "        arrow = Arrow(words.get_bottom(), dot, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            ShowCreation(arc),\n",
        "        )\n",
        "        self.play(Write(theta))\n",
        "        self.play(self.pi_creature.change_mode, \"pondering\")\n",
        "        self.play(\n",
        "            ShowCreation(self.circle),\n",
        "            Rotating(line, rate_func = smooth, in_place = False),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow),\n",
        "            ShowCreation(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(one)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            words, arrow, brace, one\n",
        "        ])))\n",
        "        self.radial_line_label = VGroup(brace, one)\n",
        "\n",
        "    def show_sine_and_cosine(self):\n",
        "        sin_line, sin_brace, sin_text = sin_group = self.get_line_brace_text(\"sin\")\n",
        "        cos_line, cos_brace, cos_text = cos_group = self.get_line_brace_text(\"cos\")\n",
        "\n",
        "        self.play(ShowCreation(sin_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(sin_brace),\n",
        "            Write(sin_text),\n",
        "        )\n",
        "        self.play(self.pi_creature.change_mode, \"happy\")\n",
        "        self.play(ShowCreation(cos_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(cos_brace),\n",
        "            Write(cos_text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_mode(\"well\")\n",
        "\n",
        "        mover = VGroup(\n",
        "            sin_group,\n",
        "            cos_group,\n",
        "            self.theta_group,\n",
        "        )\n",
        "        thetas = np.linspace(self.theta_value, self.alt_theta_val, 100)\n",
        "        targets = []\n",
        "        for theta in thetas:\n",
        "            self.theta_value = theta\n",
        "            targets.append(VGroup(\n",
        "                self.get_line_brace_text(\"sin\"),\n",
        "                self.get_line_brace_text(\"cos\"),\n",
        "                self.get_theta_group()\n",
        "            ))\n",
        "        self.play(Succession(\n",
        "            *[\n",
        "                Transform(mover, target, rate_func=linear)\n",
        "                for target in targets\n",
        "            ],\n",
        "            run_time = 5, \n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.theta_value = thetas[0]\n",
        "\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait()\n",
        "        self.sin_group, self.cos_group = sin_group, cos_group\n",
        "\n",
        "    def show_tangent_and_cotangent(self):\n",
        "        tan_group = self.get_line_brace_text(\"tan\")\n",
        "        cot_group = self.get_line_brace_text(\"cot\")\n",
        "        tan_text = tan_group[-1]\n",
        "        cot_text = cot_group[-1]\n",
        "        line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        line.rotate(self.theta_value)\n",
        "        line.move_to(self.theta_group[-1])\n",
        "        line.set_stroke(width = 2)\n",
        "\n",
        "        sin_tex = \"{\\\\sin(\\\\theta)}\"\n",
        "        cos_tex = \"{\\\\cos(\\\\theta)}\"\n",
        "        tan_frac = OldTex(\"= \\\\frac\" + sin_tex + cos_tex)\n",
        "        cot_frac = OldTex(\"= \\\\frac\" + cos_tex + sin_tex)\n",
        "        tan_frac.to_corner(UP+LEFT)\n",
        "        tan_frac.shift(2*RIGHT)\n",
        "        cot_frac.next_to(tan_frac, DOWN)\n",
        "\n",
        "\n",
        "        self.change_mode(\"pondering\")\n",
        "        for frac, text in (tan_frac, tan_text), (cot_frac, cot_text):\n",
        "            VGroup(frac[5], frac[-2]).set_color(YELLOW)\n",
        "            frac.scale(0.7)\n",
        "            text.save_state()\n",
        "            text.next_to(frac, LEFT)\n",
        "            self.play(Write(VGroup(text, frac)))\n",
        "            self.wait()\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            tan_frac, cot_frac, self.sin_group, self.cos_group\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            self.theta_group[-1].set_color, YELLOW,\n",
        "            ShowCreation(line),\n",
        "            self.pi_creature.change_mode, 'pondering'\n",
        "        )\n",
        "        small_lines = VGroup()\n",
        "        for group in tan_group, cot_group:\n",
        "            small_line, brace, text = group\n",
        "            self.play(\n",
        "                ShowCreation(small_line),\n",
        "                GrowFromCenter(brace),\n",
        "                text.restore,\n",
        "            )\n",
        "            self.wait()\n",
        "            small_lines.add(small_line)\n",
        "        self.play(FadeOut(line), Animation(small_lines))\n",
        "\n",
        "        mover = VGroup(\n",
        "            tan_group,\n",
        "            cot_group,\n",
        "            self.theta_group,\n",
        "        )\n",
        "        thetas = np.linspace(self.theta_value, self.alt_theta_val, 100)\n",
        "        targets = []\n",
        "        for theta in thetas:\n",
        "            self.theta_value = theta\n",
        "            targets.append(VGroup(\n",
        "                self.get_line_brace_text(\"tan\"),\n",
        "                self.get_line_brace_text(\"cot\"),\n",
        "                self.get_theta_group()\n",
        "            ))\n",
        "        self.play(Succession(\n",
        "            *[\n",
        "                Transform(mover, target, rate_func=linear)\n",
        "                for target in targets\n",
        "            ], \n",
        "            run_time = 5, \n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.theta_value = thetas[0]\n",
        "\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "        self.tangent_line = self.get_tangent_line()\n",
        "        self.add(self.tangent_line)\n",
        "        self.play(*it.chain(*[\n",
        "            list(map(FadeOut, [tan_group, cot_group])),\n",
        "            [Animation(self.theta_group[-1])]\n",
        "        ]))\n",
        "\n",
        "    def show_secant_and_cosecant(self):\n",
        "        sec_group = self.get_line_brace_text(\"sec\")\n",
        "        csc_group = self.get_line_brace_text(\"csc\")\n",
        "        sec_line, sec_brace, sec_text = sec_group\n",
        "        csc_line, csc_brace, csc_text = csc_group\n",
        "\n",
        "        sec_frac = OldTex(\"= \\\\frac{1}{\\\\cos(\\\\theta)}\")\n",
        "        sec_frac.to_corner(UP+LEFT).shift(2*RIGHT)\n",
        "        csc_frac = OldTex(\"= \\\\frac{1}{\\\\sin(\\\\theta)}\")\n",
        "        csc_frac.next_to(sec_frac, DOWN)\n",
        "\n",
        "        sec_dot, csc_dot = [\n",
        "            Dot(line.get_end(), color = line.get_color())\n",
        "            for line in (sec_line, csc_line)\n",
        "        ]\n",
        "        sec_group.add(sec_dot)\n",
        "        csc_group.add(csc_dot)\n",
        "\n",
        "        for text, frac in (sec_text, sec_frac), (csc_text, csc_frac):\n",
        "            frac[-2].set_color(YELLOW)\n",
        "            frac.scale(0.7)\n",
        "            text.save_state()\n",
        "            text.next_to(frac, LEFT)\n",
        "            frac.add_to_back(text.copy())\n",
        "            self.play(\n",
        "                Write(frac),\n",
        "                self.pi_creature.change_mode, \"erm\"\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        for group in sec_group, csc_group:\n",
        "            line, brace, text, dot = group\n",
        "            dot.save_state()\n",
        "            dot.move_to(text)\n",
        "            dot.set_fill(opacity = 0)\n",
        "            self.play(dot.restore)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(brace),\n",
        "                text.restore,\n",
        "                self.pi_creature.change_mode, \"pondering\"\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        mover = VGroup(\n",
        "            sec_group,\n",
        "            csc_group,\n",
        "            self.theta_group,\n",
        "            self.tangent_line,\n",
        "        )\n",
        "        thetas = np.linspace(self.theta_value, self.alt_theta_val, 100)\n",
        "        targets = []\n",
        "        for theta in thetas:\n",
        "            self.theta_value = theta\n",
        "            new_sec_group = self.get_line_brace_text(\"sec\")\n",
        "            new_csc_group = self.get_line_brace_text(\"csc\")\n",
        "            for group in new_sec_group, new_csc_group:\n",
        "                line = group[0]\n",
        "                group.add(\n",
        "                    Dot(line.get_end(), color = line.get_color())\n",
        "                )\n",
        "            targets.append(VGroup(\n",
        "                new_sec_group,\n",
        "                new_csc_group,\n",
        "                self.get_theta_group(),\n",
        "                self.get_tangent_line(),\n",
        "            ))\n",
        "        self.play(Succession(\n",
        "            *[\n",
        "                Transform(mover, target, rate_func=linear)\n",
        "                for target in targets\n",
        "            ], \n",
        "            run_time = 5, \n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.theta_value = thetas[0]\n",
        "\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            sec_group, sec_frac\n",
        "        ])))\n",
        "        self.csc_group = csc_group\n",
        "        self.csc_frac =csc_frac\n",
        "\n",
        "    def explain_cosecant(self):\n",
        "        sin_group = self.get_line_brace_text(\"sin\")\n",
        "        sin_line, sin_brace, sin_text = sin_group\n",
        "        csc_line, csc_brace, csc_text, csc_dot = self.csc_group\n",
        "        csc_subgroup = VGroup(csc_brace, csc_text)\n",
        "\n",
        "        arc_theta = VGroup(*self.theta_group[1:3]).copy()\n",
        "        arc_theta.rotate(-np.pi/2)\n",
        "        arc_theta.shift(csc_line.get_end())\n",
        "        arc_theta[1].rotate(np.pi/2)\n",
        "\n",
        "        radial_line = self.theta_group[0]\n",
        "\n",
        "        tri1 = Polygon(\n",
        "            ORIGIN, radial_line.get_end(), sin_line.get_end(),\n",
        "            color = GREEN,\n",
        "            stroke_width = 8,\n",
        "        )\n",
        "        tri2 = Polygon(\n",
        "            csc_line.get_end(), ORIGIN, radial_line.get_end(),\n",
        "            color = GREEN,\n",
        "            stroke_width = 8,\n",
        "        )\n",
        "\n",
        "        opp_over_hyp = OldTex(\n",
        "            \"\\\\frac{\\\\text{Opposite}}{\\\\text{Hypotenuse}} =\"\n",
        "        )\n",
        "        frac1 = OldTex(\"\\\\frac{\\\\sin(\\\\theta)}{1}\")\n",
        "        frac1.next_to(opp_over_hyp)\n",
        "        frac1[-4].set_color(YELLOW)\n",
        "        frac2 = OldTex(\"= \\\\frac{1}{\\\\csc(\\\\theta)}\")\n",
        "        frac2.next_to(frac1)\n",
        "        frac2[-2].set_color(YELLOW)\n",
        "        frac_group = VGroup(opp_over_hyp, frac1, frac2)\n",
        "        frac_group.set_width(FRAME_X_RADIUS-1)\n",
        "        frac_group.next_to(ORIGIN, RIGHT).to_edge(UP)\n",
        "\n",
        "        question = OldTexText(\"Why is this $\\\\theta$?\")\n",
        "        question.set_color(YELLOW)\n",
        "        question.to_corner(UP+RIGHT)\n",
        "        arrow = Arrow(question.get_bottom(), arc_theta)\n",
        "\n",
        "        one_brace, one = self.radial_line_label\n",
        "        one.move_to(one_brace.get_center_of_mass())\n",
        "\n",
        "        self.play(ShowCreation(tri1))\n",
        "        self.play(\n",
        "            ApplyMethod(tri1.rotate, np.pi/12, rate_func = wiggle),\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        tri1.save_state()\n",
        "        self.play(Transform(tri1, tri2, path_arc = np.pi/2))\n",
        "        self.play(Write(arc_theta))\n",
        "        self.play(ApplyMethod(\n",
        "            tri1.rotate, np.pi/12, \n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(arrow),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [question, arrow])))\n",
        "\n",
        "\n",
        "        self.play(Write(opp_over_hyp))\n",
        "        self.wait()\n",
        "        csc_subgroup.save_state()\n",
        "        self.play(\n",
        "            tri1.restore,\n",
        "            csc_subgroup.fade, 0.7\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(sin_line),\n",
        "            GrowFromCenter(sin_brace),\n",
        "            Write(sin_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(one))\n",
        "        self.wait()\n",
        "        self.play(Write(frac1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(tri1, tri2),\n",
        "            FadeOut(sin_group)\n",
        "        )\n",
        "        self.play(\n",
        "            radial_line.rotate, np.pi/12,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(csc_subgroup.restore)\n",
        "        self.wait()\n",
        "        self.play(Write(frac2))\n",
        "        self.change_mode(\"happy\")\n",
        "        self.play(FadeOut(opp_over_hyp))\n",
        "        self.reciprocate(frac1, frac2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            one, self.csc_group, tri1,\n",
        "            frac1, frac2, self.csc_frac,\n",
        "            arc_theta\n",
        "        ])))\n",
        "\n",
        "    def reciprocate(self, frac1, frac2):\n",
        "        # Not general, meant only for these definitions:\n",
        "        # frac1 = OldTex(\"\\\\frac{\\\\sin(\\\\theta)}{1}\")\n",
        "        # frac2 = OldTex(\"= \\\\frac{1}{\\\\csc(\\\\theta)}\")\n",
        "        num1 = VGroup(*frac1[:6])\n",
        "        dem1 = frac1[-1]\n",
        "        num2 = frac2[1]\n",
        "        dem2 = VGroup(*frac2[-6:])\n",
        "        group = VGroup(frac1, frac2)\n",
        "\n",
        "        self.play(\n",
        "            group.scale, 1/0.7,\n",
        "            group.to_corner, UP+RIGHT,\n",
        "        )\n",
        "        self.play(\n",
        "            num1.move_to, dem1,\n",
        "            dem1.move_to, num1,\n",
        "            num2.move_to, dem2,\n",
        "            dem2.move_to, num2,\n",
        "            path_arc = np.pi\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dem2.move_to, frac2[2],\n",
        "            VGroup(*frac2[1:3]).set_fill, BLACK, 0\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def summarize_full_group(self):\n",
        "        scale_factor = 1.5\n",
        "        theta_subgroup = VGroup(self.theta_group[0], self.theta_group[-1])\n",
        "        self.play(*it.chain(*[\n",
        "            [mob.scale, scale_factor]\n",
        "            for mob in [\n",
        "                self.circle, self.axes, \n",
        "                theta_subgroup, self.tangent_line\n",
        "            ]\n",
        "        ]))\n",
        "        self.unit_length *= scale_factor\n",
        "\n",
        "        to_fade = VGroup()\n",
        "        for func_name in [\"sin\", \"tan\", \"sec\", \"cos\", \"cot\", \"csc\"]:\n",
        "            line, brace, text = self.get_line_brace_text(func_name)\n",
        "            if func_name in [\"sin\", \"cos\"]:\n",
        "                angle = line.get_angle()\n",
        "                if np.cos(angle) < 0:\n",
        "                    angle += np.pi\n",
        "                if func_name is \"sin\":\n",
        "                    target = line.get_center()+0.2*LEFT+0.1*DOWN\n",
        "                else:\n",
        "                    target = VGroup(brace, line).get_center_of_mass()\n",
        "                text.scale(0.75)\n",
        "                text.rotate(angle)\n",
        "                text.move_to(target)\n",
        "                line.set_stroke(width = 6)\n",
        "                self.play(\n",
        "                    ShowCreation(line),\n",
        "                    Write(text, run_time = 1)\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    ShowCreation(line),\n",
        "                    GrowFromCenter(brace),\n",
        "                    Write(text, run_time = 1)\n",
        "                )\n",
        "            if func_name in [\"sec\", \"csc\", \"cot\"]:\n",
        "                to_fade.add(*self.get_mobjects_from_last_animation())\n",
        "            if func_name is \"sec\":\n",
        "                self.wait()\n",
        "        self.wait()\n",
        "        self.change_mode(\"surprised\")\n",
        "        self.wait(2)\n",
        "        self.remove(self.tangent_line)\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            self.pi_creature.change_mode, \"sassy\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_line_brace_text(self, func_name = \"sin\"):\n",
        "        line = self.get_trig_line(func_name)\n",
        "        angle = line.get_angle()\n",
        "        vect = rotate_vector(UP, angle)\n",
        "        vect = np.round(vect, 1)\n",
        "        if (vect[1] < 0) ^ (func_name is \"sec\"):\n",
        "            vect = -vect\n",
        "            angle += np.pi\n",
        "        brace = Brace(\n",
        "            Line(\n",
        "                line.get_length()*LEFT/2,\n",
        "                line.get_length()*RIGHT/2,\n",
        "            ), \n",
        "            UP\n",
        "        )\n",
        "        brace.rotate(angle)\n",
        "        brace.shift(line.get_center())\n",
        "        brace.set_color(line.get_color())\n",
        "        text = OldTex(\"\\\\%s(\\\\theta)\"%func_name)\n",
        "        text.scale(0.75)\n",
        "        text[-2].set_color(self.theta_color)\n",
        "        text.add_background_rectangle()\n",
        "        text.next_to(brace.get_center_of_mass(), vect, buff = 1.2*MED_SMALL_BUFF)\n",
        "        return VGroup(line, brace, text)\n",
        "\n",
        "    def get_tangent_line(self):\n",
        "        return Line(\n",
        "            self.unit_length*(1./np.sin(self.theta_value))*UP,\n",
        "            self.unit_length*(1./np.cos(self.theta_value))*RIGHT,\n",
        "            color = GREY\n",
        "        )\n",
        "\n",
        "class RenameAllInTermsOfSine(Scene):\n",
        "    def construct(self):\n",
        "        texs = [\n",
        "            \"\\\\sin(\\\\theta)\",\n",
        "            \"\\\\cos(\\\\theta)\",\n",
        "            \"\\\\tan(\\\\theta)\",\n",
        "            \"\\\\csc(\\\\theta)\",\n",
        "            \"\\\\sec(\\\\theta)\",\n",
        "            \"\\\\cot(\\\\theta)\",\n",
        "        ]\n",
        "        shift_vals = [\n",
        "            4*LEFT+3*UP,\n",
        "            4*LEFT+UP,\n",
        "            4*LEFT+DOWN,\n",
        "            4*RIGHT+3*UP,\n",
        "            4*RIGHT+UP,\n",
        "            4*RIGHT+DOWN,\n",
        "        ]\n",
        "        equivs = [\n",
        "            \"\",\n",
        "            \"= \\\\sin(90^\\\\circ - \\\\theta)\",\n",
        "            \"= \\\\frac{\\\\sin(\\\\theta)}{\\\\sin(90^\\\\circ - \\\\theta)}\",\n",
        "            \"= \\\\frac{1}{\\\\sin(\\\\theta)}\",\n",
        "            \"= \\\\frac{1}{\\\\sin(90^\\\\circ - \\\\theta)}\",\n",
        "            \"= \\\\frac{\\\\sin(90^\\\\circ - \\\\theta)}{\\\\sin(\\\\theta)}\",\n",
        "        ]\n",
        "        mobs = VGroup(*list(map(Tex, texs)))\n",
        "        sin, cos, tan = mobs[:3]\n",
        "        sin.target_color = YELLOW\n",
        "        cos.target_color = GREEN\n",
        "        tan.target_color = RED\n",
        "\n",
        "        rhs_mobs = VGroup(*list(map(Tex, equivs)))\n",
        "        rhs_mobs.submobjects[0] = VectorizedPoint()\n",
        "        for mob, shift_val in zip(mobs, shift_vals):\n",
        "            mob.shift(shift_val)\n",
        "        self.play(Write(mobs))\n",
        "        self.wait()\n",
        "        for mob, rhs_mob in zip(mobs, rhs_mobs):\n",
        "            rhs_mob.next_to(mob)\n",
        "            rhs_mob.set_color(sin.target_color)\n",
        "            mob.save_state()\n",
        "            mob.generate_target()\n",
        "            VGroup(mob.target, rhs_mob).move_to(mob)\n",
        "        sin.target.set_color(sin.target_color)\n",
        "        self.play(*it.chain(*[\n",
        "            list(map(MoveToTarget, mobs)),\n",
        "            [Write(rhs_mobs)]\n",
        "        ]))\n",
        "        self.wait(2)\n",
        "\n",
        "        anims = []\n",
        "        for mob, rhs_mob in list(zip(mobs, rhs_mobs))[1:3]:\n",
        "            anims += [\n",
        "                FadeOut(rhs_mob),\n",
        "                mob.restore,\n",
        "                mob.set_color, mob.target_color,\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "        new_rhs_mobs = [\n",
        "            OldTex(\"=\\\\frac{1}{\\\\%s(\\\\theta)}\"%s).set_color(color)\n",
        "            for s, color in [\n",
        "                (\"cos\", cos.target_color),\n",
        "                (\"tan\", tan.target_color),\n",
        "            ]\n",
        "        ]\n",
        "        anims = []\n",
        "        for mob, rhs, new_rhs in zip(mobs[-2:], rhs_mobs[-2:], new_rhs_mobs):\n",
        "            new_rhs.next_to(mob)\n",
        "            VGroup(mob.target, new_rhs).move_to(\n",
        "                VGroup(mob, rhs)\n",
        "            )\n",
        "            anims += [\n",
        "                MoveToTarget(mob),\n",
        "                Transform(rhs, new_rhs)\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        self.wait(2)\n",
        "\n",
        "class MisMatchOfCoPrefix(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        eq1 = OldTex(\n",
        "            \"\\\\text{secant}(\\\\theta) = \\\\frac{1}{\\\\text{cosine}(\\\\theta)}\"\n",
        "        )\n",
        "        eq2 = OldTex(\n",
        "            \"\\\\text{cosecant}(\\\\theta) = \\\\frac{1}{\\\\text{sine}(\\\\theta)}\"\n",
        "        )\n",
        "        eq1.to_corner(UP+LEFT)\n",
        "        eq1.to_edge(LEFT)\n",
        "        eq2.next_to(eq1, DOWN, buff = LARGE_BUFF)\n",
        "        eqs = VGroup(eq1, eq2)\n",
        "\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"speaking\",\n",
        "            Write(eqs),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, eqs)\n",
        "                for pi in self.get_students()\n",
        "            ]\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.play(\n",
        "            VGroup(*eq1[-9:-7]).set_color, YELLOW,\n",
        "            VGroup(*eq2[:2]).set_color, YELLOW,\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"confused\")\n",
        "                for pi in self.get_students()\n",
        "            ]\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "\n",
        "class Credit(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "        morty.to_edge(RIGHT)\n",
        "\n",
        "        headphones = Headphones(height = 1)\n",
        "        headphones.move_to(morty.eyes, aligned_edge = DOWN)\n",
        "        headphones.shift(0.1*DOWN)\n",
        "\n",
        "        url = OldTexText(\"www.audibletrial.com/3blue1brown\")\n",
        "        url.scale(0.8)\n",
        "        url.to_corner(UP+RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        book = ImageMobject(\"zen_and_motorcycles\")\n",
        "        book.set_height(5)\n",
        "        book.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        border = Rectangle(color = WHITE)\n",
        "        border.replace(book, stretch = True)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Book recommendation!\",\n",
        "            target_mode = \"surprised\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeIn(headphones),\n",
        "            morty.change_mode, \"thinking\",\n",
        "            FadeOut(morty.bubble),\n",
        "            FadeOut(morty.bubble.content),\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.play(morty.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, url\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change_mode, \"happy\",\n",
        "            morty.look_at, book\n",
        "        )\n",
        "        self.play(FadeIn(book))\n",
        "        self.play(ShowCreation(border))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"thinking\",\n",
        "            morty.look_at, book\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(4)\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}