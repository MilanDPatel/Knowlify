{
    "topic": "The mathematical concept being demonstrated is the multivariable chain rule, which is a fundamental tool in calculus",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class HoldUpMultivariableChainRule(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Multivariable chain rule\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        screen = ScreenRectangle()\n",
        "        screen.next_to(title, DOWN)\n",
        "\n",
        "        morty = self.teacher\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(screen)\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"confused\", look_at=screen\n",
        "        )\n",
        "        self.look_at(screen)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ComputationalNetwork(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"x_color\": YELLOW,\n",
        "        \"f_color\": BLUE,\n",
        "        \"g_color\": GREEN,\n",
        "        \"h_color\": RED,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.draw_network()\n",
        "        self.walk_through_parts()\n",
        "        self.write_dh_dx_goal()\n",
        "        self.feed_forward_input()\n",
        "        self.compare_x_and_h_wiggling()\n",
        "        self.expand_out_h_as_function_of_x()\n",
        "        self.show_four_derivatives()\n",
        "        self.show_chain_rule()\n",
        "        self.talk_through_mvcr_parts()\n",
        "        self.plug_in_expressions()\n",
        "        self.plug_in_values()\n",
        "        self.discuss_meaning_of_result()\n",
        "\n",
        "    def draw_network(self):\n",
        "        x = OldTex(\"x\")\n",
        "        f_formula = OldTex(\"f\", \"=\", \"x\", \"^2\")\n",
        "        g_formula = OldTex(\"g\", \"=\", \"\\\\cos(\\\\pi\", \"x\", \")\")\n",
        "        h_formula = OldTex(\"h\", \"=\", \"f\", \"^2\", \"g\")\n",
        "\n",
        "        self.tex_to_color_map = {\n",
        "            \"x\": self.x_color,\n",
        "            \"f\": self.f_color,\n",
        "            \"g\": self.g_color,\n",
        "            \"h\": self.h_color,\n",
        "        }\n",
        "\n",
        "        formulas = VGroup(x, f_formula, g_formula, h_formula)\n",
        "        formula_groups = VGroup()\n",
        "        for formula in formulas:\n",
        "            formula.box = SurroundingRectangle(formula)\n",
        "            formula.box.set_color(WHITE)\n",
        "            formula.group = VGroup(formula, formula.box)\n",
        "            formula.set_color_by_tex_to_color_map(\n",
        "                self.tex_to_color_map\n",
        "            )\n",
        "            formula_groups.add(formula.group)\n",
        "        f_formula.box.match_width(\n",
        "            g_formula.box, stretch=True, about_edge=LEFT\n",
        "        )\n",
        "\n",
        "        fg_group = VGroup(f_formula.group, g_formula.group)\n",
        "        fg_group.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        fg_group.to_edge(UP)\n",
        "        x.group.next_to(fg_group, LEFT, buff=2)\n",
        "        h_formula.group.next_to(fg_group, RIGHT, buff=2)\n",
        "\n",
        "        xf_line = Line(x.box.get_right(), f_formula.box.get_left())\n",
        "        xg_line = Line(x.box.get_right(), g_formula.box.get_left())\n",
        "        fh_line = Line(f_formula.box.get_right(), h_formula.box.get_left())\n",
        "        gh_line = Line(g_formula.box.get_right(), h_formula.box.get_left())\n",
        "\n",
        "        graph_edges = VGroup(\n",
        "            xf_line, xg_line, fh_line, gh_line\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(x),\n",
        "            FadeIn(x.box),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(xf_line),\n",
        "            ShowCreation(xg_line),\n",
        "            ReplacementTransform(x.box.copy(), f_formula.box),\n",
        "            ReplacementTransform(x.box.copy(), g_formula.box),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(f_formula),\n",
        "            Write(g_formula),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(fh_line),\n",
        "            ShowCreation(gh_line),\n",
        "            ReplacementTransform(f_formula.box.copy(), h_formula.box),\n",
        "            ReplacementTransform(g_formula.box.copy(), h_formula.box),\n",
        "        )\n",
        "        self.play(Write(h_formula))\n",
        "        self.wait()\n",
        "\n",
        "        network = VGroup(formula_groups, graph_edges)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            x, f_formula, g_formula, h_formula,\n",
        "            xf_line, xg_line, fh_line, gh_line,\n",
        "            formulas, formula_groups,\n",
        "            graph_edges, network\n",
        "        )\n",
        "\n",
        "    def walk_through_parts(self):\n",
        "        x = self.x\n",
        "        f_formula = self.f_formula\n",
        "        g_formula = self.g_formula\n",
        "        h_formula = self.h_formula\n",
        "\n",
        "        def indicate(mob):\n",
        "            return ShowCreationThenDestructionAround(\n",
        "                mob,\n",
        "                surrounding_rectangle_config={\n",
        "                    \"buff\": 0.5 * SMALL_BUFF,\n",
        "                    \"color\": mob.get_color()\n",
        "                }\n",
        "            )\n",
        "\n",
        "        for formula in f_formula, g_formula:\n",
        "            self.play(indicate(formula[0]))\n",
        "            self.play(ReplacementTransform(\n",
        "                x.copy(),\n",
        "                formula.get_parts_by_tex(\"x\"),\n",
        "                path_arc=PI / 3\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(indicate(h_formula[0]))\n",
        "        self.play(ReplacementTransform(\n",
        "            f_formula[0].copy(),\n",
        "            h_formula.get_part_by_tex(\"f\"),\n",
        "            path_arc=PI / 3\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            g_formula[0].copy(),\n",
        "            h_formula.get_part_by_tex(\"g\"),\n",
        "            path_arc=PI / 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def write_dh_dx_goal(self):\n",
        "        deriv = OldTex(\n",
        "            \"{dh\", \"\\\\over\", \"dx}\", \"(\", \"2\", \")\"\n",
        "        )\n",
        "        deriv.set_color_by_tex_to_color_map(\n",
        "            self.tex_to_color_map\n",
        "        )\n",
        "        deriv.scale(1.5)\n",
        "        deriv.move_to(DOWN)\n",
        "\n",
        "        self.play(FadeInFromDown(deriv[:3]))\n",
        "        self.play(ShowCreationThenDestructionAround(deriv[:3]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(deriv[3:]))\n",
        "        self.wait()\n",
        "\n",
        "        self.dh_dx_at_two = deriv\n",
        "\n",
        "    def feed_forward_input(self):\n",
        "        formula_groups = self.formula_groups\n",
        "        x, f_formula, g_formula, h_formula = self.formulas\n",
        "        dh_dx_at_two = self.dh_dx_at_two\n",
        "\n",
        "        values = [2, 4, 1, 16]\n",
        "        value_labels = VGroup()\n",
        "        for formula_group, value in zip(formula_groups, values):\n",
        "            label = OldTex(\"=\", str(value))\n",
        "            eq, value_mob = label\n",
        "            eq.rotate(90 * DEGREES)\n",
        "            eq.next_to(value_mob, UP, SMALL_BUFF)\n",
        "            var = formula_group[0][0]\n",
        "            label[1].match_color(var)\n",
        "            # label.next_to(formula_group, DOWN, SMALL_BUFF)\n",
        "            label.next_to(var, DOWN, SMALL_BUFF)\n",
        "            eq.add_background_rectangle(buff=SMALL_BUFF, opacity=1)\n",
        "            value_labels.add(label)\n",
        "        x_val_label, f_val_label, g_val_label, h_val_label = value_labels\n",
        "        two, four, one, sixteen = [vl[1] for vl in value_labels]\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                dh_dx_at_two.get_part_by_tex(\"2\").copy(),\n",
        "                two,\n",
        "            ),\n",
        "            Write(x_val_label[0])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        two_copy1 = two.copy()\n",
        "        two_copy2 = two.copy()\n",
        "        four_copy = four.copy()\n",
        "        one_copy = one.copy()\n",
        "        x_in_f = f_formula.get_part_by_tex(\"x\")\n",
        "        x_in_g = g_formula.get_part_by_tex(\"x\")\n",
        "        f_in_h = h_formula.get_part_by_tex(\"f\")\n",
        "        g_in_h = h_formula.get_part_by_tex(\"g\")\n",
        "\n",
        "        self.play(\n",
        "            two_copy1.move_to, x_in_f, DOWN,\n",
        "            x_in_f.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(f_val_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            two_copy2.move_to, x_in_g, DOWN,\n",
        "            x_in_g.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(g_val_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            four_copy.move_to, f_in_h, DOWN,\n",
        "            f_in_h.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "        self.play(\n",
        "            one_copy.move_to, g_in_h, DOWN,\n",
        "            g_in_h.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(h_val_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.value_labels = value_labels\n",
        "        self.revert_to_formula_animations = [\n",
        "            ApplyMethod(term.set_fill, {\"opacity\": 1})\n",
        "            for term in (x_in_f, x_in_g, f_in_h, g_in_h)\n",
        "        ] + [\n",
        "            FadeOut(term)\n",
        "            for term in (two_copy1, two_copy2, four_copy, one_copy)\n",
        "        ]\n",
        "\n",
        "    def compare_x_and_h_wiggling(self):\n",
        "        x_val = self.value_labels[0][1]\n",
        "        h_val = self.value_labels[3][1]\n",
        "\n",
        "        x_line = NumberLine(\n",
        "            x_min=0,\n",
        "            x_max=4,\n",
        "            include_numbers=True,\n",
        "            numbers_to_show=[0, 2, 4],\n",
        "            unit_size=0.75,\n",
        "        )\n",
        "        x_line.next_to(\n",
        "            x_val, DOWN, LARGE_BUFF,\n",
        "            aligned_edge=RIGHT\n",
        "        )\n",
        "        h_line = NumberLine(\n",
        "            x_min=0,\n",
        "            x_max=32,\n",
        "            include_numbers=True,\n",
        "            big_tick_numbers=[0, 16, 32],\n",
        "            numbers_to_show=[0, 16, 32],\n",
        "            tick_frequency=1,\n",
        "            tick_size=0.05,\n",
        "            unit_size=1.0 / 12,\n",
        "        )\n",
        "        h_line.next_to(\n",
        "            h_val, DOWN, LARGE_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "\n",
        "        x_dot = Dot(color=self.x_color)\n",
        "        x_dot.move_to(x_line.number_to_point(2))\n",
        "        x_arrow = Arrow(self.x.get_bottom(), x_dot.get_top())\n",
        "        x_arrow.match_color(x_dot)\n",
        "\n",
        "        h_dot = Dot(color=self.h_color)\n",
        "        h_dot.move_to(h_line.number_to_point(16))\n",
        "        h_arrow = Arrow(self.h_formula[0].get_bottom(), h_dot.get_top())\n",
        "        h_arrow.match_color(h_dot)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            ShowCreation(h_line),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(x_arrow),\n",
        "            GrowArrow(h_arrow),\n",
        "            ReplacementTransform(x_val.copy(), x_dot),\n",
        "            ReplacementTransform(h_val.copy(), h_dot),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                x_dot.shift, 0.25 * RIGHT,\n",
        "                h_dot.shift, 0.35 * RIGHT,\n",
        "                rate_func=wiggle,\n",
        "                run_time=1,\n",
        "            )\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            x_line, h_line,\n",
        "            x_dot, h_dot,\n",
        "            x_arrow, h_arrow,\n",
        "        )\n",
        "\n",
        "    def expand_out_h_as_function_of_x(self):\n",
        "        self.play(*self.revert_to_formula_animations)\n",
        "\n",
        "        deriv = self.dh_dx_at_two\n",
        "\n",
        "        expanded_formula = OldTex(\n",
        "            \"h = x^4 \\\\cos(\\\\pi x)\",\n",
        "            tex_to_color_map=self.tex_to_color_map\n",
        "        )\n",
        "        expanded_formula.move_to(deriv)\n",
        "        cross = Cross(expanded_formula)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(expanded_formula),\n",
        "            deriv.scale, 1.0 / 1.5,\n",
        "            deriv.shift, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(expanded_formula, cross)),\n",
        "            deriv.shift, UP,\n",
        "        )\n",
        "        for edge in self.graph_edges:\n",
        "            self.play(ShowCreationThenDestruction(\n",
        "                edge.copy().set_stroke(YELLOW, 6)\n",
        "            ))\n",
        "\n",
        "    def show_four_derivatives(self):\n",
        "        lines = self.graph_edges\n",
        "        xf_line, xg_line, fh_line, gh_line = lines\n",
        "\n",
        "        df_dx = OldTex(\"df\", \"\\\\over\", \"dx\")\n",
        "        dg_dx = OldTex(\"dg\", \"\\\\over\", \"dx\")\n",
        "        dh_df = OldTex(\"\\\\partial h\", \"\\\\over\", \"\\\\partial f\")\n",
        "        dh_dg = OldTex(\"\\\\partial h\", \"\\\\over\", \"\\\\partial g\")\n",
        "        derivatives = VGroup(df_dx, dg_dx, dh_df, dh_dg)\n",
        "\n",
        "        df_dx.next_to(xf_line.get_center(), UP, SMALL_BUFF)\n",
        "        dg_dx.next_to(xg_line.get_center(), DOWN, SMALL_BUFF)\n",
        "        dh_df.next_to(fh_line.get_center(), UP, SMALL_BUFF)\n",
        "        dh_dg.next_to(gh_line.get_center(), DOWN, SMALL_BUFF)\n",
        "\n",
        "        partial_terms = VGroup(\n",
        "            dh_df[0][0],\n",
        "            dh_df[2][0],\n",
        "            dh_dg[0][0],\n",
        "            dh_dg[2][0],\n",
        "        )\n",
        "        partial_term_rects = VGroup(*[\n",
        "            SurroundingRectangle(pt, buff=0.05)\n",
        "            for pt in partial_terms\n",
        "        ])\n",
        "        partial_term_rects.set_stroke(width=0)\n",
        "        partial_term_rects.set_fill(TEAL, 0.5)\n",
        "\n",
        "        self.play(FadeOut(self.value_labels))\n",
        "        for derivative in derivatives:\n",
        "            derivative.set_color_by_tex_to_color_map(self.tex_to_color_map)\n",
        "            derivative.add_to_back(derivative.copy().set_stroke(BLACK, 5))\n",
        "            self.play(FadeInFromDown(derivative))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, partial_term_rects),\n",
        "            Animation(derivatives)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, partial_term_rects),\n",
        "            Animation(derivatives)\n",
        "        )\n",
        "\n",
        "        self.derivatives = derivatives\n",
        "\n",
        "    def show_chain_rule(self):\n",
        "        dh_dx_at_two = self.dh_dx_at_two\n",
        "        dh_dx = dh_dx_at_two[:3]\n",
        "        at_two = dh_dx_at_two[3:]\n",
        "        derivatives = self.derivatives.copy()\n",
        "        df_dx, dg_dx, dh_df, dh_dg = derivatives\n",
        "\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        self.play(\n",
        "            frame.shift, 3 * UP,\n",
        "            dh_dx.to_edge, UP,\n",
        "            dh_dx.shift, 3 * LEFT + 3 * UP,\n",
        "            at_two.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "\n",
        "        for deriv in derivatives:\n",
        "            deriv.generate_target()\n",
        "        rhs = VGroup(\n",
        "            OldTex(\"=\"),\n",
        "            df_dx.target, dh_df.target,\n",
        "            OldTex(\"+\"),\n",
        "            dg_dx.target, dh_dg.target\n",
        "        )\n",
        "        rhs.arrange(\n",
        "            RIGHT,\n",
        "            buff=2 * SMALL_BUFF,\n",
        "        )\n",
        "        rhs.next_to(dh_dx, RIGHT)\n",
        "        for deriv in derivatives:\n",
        "            y = rhs[0].get_center()[1]\n",
        "            alt_y = deriv.target[2].get_center()[1]\n",
        "            deriv.target.shift((y - alt_y) * UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(rhs[::3]),\n",
        "            LaggedStartMap(MoveToTarget, derivatives)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.chain_rule_derivatives = derivatives\n",
        "        self.chain_rule_rhs = rhs\n",
        "\n",
        "    def talk_through_mvcr_parts(self):\n",
        "        derivatives = self.derivatives\n",
        "        cr_derivatives = self.chain_rule_derivatives\n",
        "\n",
        "        df_dx, dg_dx, dh_df, dh_dg = cr_derivatives\n",
        "\n",
        "        df, dx1 = df_dx[1::2]\n",
        "        dg, dx2 = dg_dx[1::2]\n",
        "        del_h1, del_f = dh_df[1::2]\n",
        "        del_h2, del_g = dh_dg[1::2]\n",
        "        terms = VGroup(df, dx1, dg, dx2, del_h1, del_f, del_h2, del_g)\n",
        "        for term in terms:\n",
        "            term.rect = SurroundingRectangle(\n",
        "                term,\n",
        "                buff=0.5 * SMALL_BUFF,\n",
        "                stroke_width=0,\n",
        "                fill_color=TEAL,\n",
        "                fill_opacity=0.5\n",
        "            )\n",
        "        for derivative in derivatives:\n",
        "            derivative.rect = SurroundingRectangle(\n",
        "                derivative,\n",
        "                color=TEAL\n",
        "            )\n",
        "\n",
        "        del_h_sub_f = OldTex(\"f\")\n",
        "        del_h_sub_f.scale(0.5)\n",
        "        del_h_sub_f.next_to(del_h1.get_corner(DR), RIGHT, buff=0)\n",
        "        del_h_sub_f.set_color(self.f_color)\n",
        "\n",
        "        lines = self.graph_edges\n",
        "        top_lines = lines[::2].copy()\n",
        "        bottom_lines = lines[1::2].copy()\n",
        "        for group in top_lines, bottom_lines:\n",
        "            group.set_stroke(YELLOW, 6)\n",
        "\n",
        "        self.add_foreground_mobjects(cr_derivatives)\n",
        "        rect = dx1.rect.copy()\n",
        "        rect.save_state()\n",
        "        rect.scale(3)\n",
        "        rect.set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            rect.restore,\n",
        "            FadeIn(derivatives[0].rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(rect, df.rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.replace, df_dx, {\"stretch\": True},\n",
        "            rect.scale, 1.1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(rect, del_f.rect),\n",
        "            FadeOut(derivatives[0].rect),\n",
        "            FadeIn(derivatives[2].rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(rect, del_h1.rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            del_f[1].copy(), del_h_sub_f,\n",
        "            path_arc=PI,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            del_h_sub_f.shift, UR,\n",
        "            del_h_sub_f.fade, 1,\n",
        "            rate_func=running_start,\n",
        "            remover=True\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(rect, del_f.rect),\n",
        "            ReplacementTransform(rect.copy(), df.rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(3):\n",
        "            self.play(ShowCreationThenDestruction(\n",
        "                top_lines,\n",
        "                lag_ratio=1,\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.replace, cr_derivatives[1::2], {\"stretch\": True},\n",
        "            rect.scale, 1.1,\n",
        "            FadeOut(df.rect),\n",
        "            FadeOut(derivatives[2].rect),\n",
        "            FadeIn(derivatives[1].rect),\n",
        "            FadeIn(derivatives[3].rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(rect, dg.rect),\n",
        "            FadeOut(derivatives[3].rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(rect, dx2.rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(rect, del_h2.rect),\n",
        "            FadeOut(derivatives[1].rect),\n",
        "            FadeIn(derivatives[3].rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(rect, del_g.rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.replace, cr_derivatives, {\"stretch\": True},\n",
        "            rect.scale, 1.1,\n",
        "            FadeOut(derivatives[3].rect)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.play(*[\n",
        "                ShowCreationThenDestruction(\n",
        "                    group,\n",
        "                    lag_ratio=1,\n",
        "                )\n",
        "                for group in (top_lines, bottom_lines)\n",
        "            ])\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect))\n",
        "        self.remove_foreground_mobject(cr_derivatives)\n",
        "\n",
        "    def plug_in_expressions(self):\n",
        "        lhs = VGroup(\n",
        "            self.dh_dx_at_two[:3],\n",
        "            self.chain_rule_rhs[::3],\n",
        "            self.chain_rule_derivatives,\n",
        "        )\n",
        "        lhs.generate_target()\n",
        "        lhs.target.to_edge(LEFT)\n",
        "        df_dx, dg_dx, dh_df, dh_dg = self.chain_rule_derivatives\n",
        "\n",
        "        formulas = self.formulas\n",
        "        x, f_formula, g_formula, h_formula = formulas\n",
        "\n",
        "        full_derivative = OldTex(\n",
        "            \"=\",\n",
        "            \"(\", \"2\", \"x\", \")\",\n",
        "            \"(\", \"2\", \"f\", \"g\", \")\",\n",
        "            \"+\",\n",
        "            \"(\", \"-\\\\sin(\", \"\\\\pi\", \"x\", \")\", \"\\\\pi\", \")\",\n",
        "            \"(\", \"f\", \"^2\", \")\"\n",
        "        )\n",
        "        full_derivative.next_to(lhs.target, RIGHT)\n",
        "        full_derivative.set_color_by_tex_to_color_map(\n",
        "            self.tex_to_color_map\n",
        "        )\n",
        "\n",
        "        self.play(MoveToTarget(lhs))\n",
        "        self.play(Write(full_derivative[0]))\n",
        "\n",
        "        # df/dx\n",
        "        self.play(\n",
        "            f_formula.shift, UP,\n",
        "            df_dx.shift, 0.5 * DOWN\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                f_formula[2:].copy(),\n",
        "                full_derivative[2:4],\n",
        "            ),\n",
        "            FadeIn(full_derivative[1:5:3])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            f_formula.shift, DOWN,\n",
        "            df_dx.shift, 0.5 * UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # dg/dx\n",
        "        self.play(\n",
        "            g_formula.shift, 0.75 * UP,\n",
        "            dg_dx.shift, 0.5 * DOWN\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                g_formula[2:].copy(),\n",
        "                full_derivative[12:17],\n",
        "            ),\n",
        "            FadeIn(full_derivative[11:18:6]),\n",
        "            Write(full_derivative[10]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            g_formula.shift, 0.75 * DOWN,\n",
        "            dg_dx.shift, 0.5 * UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # dh/df\n",
        "        self.play(\n",
        "            h_formula.shift, UP,\n",
        "            dh_df.shift, 0.5 * DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                h_formula[2:].copy(),\n",
        "                full_derivative[6:9],\n",
        "            ),\n",
        "            FadeIn(full_derivative[5:10:4])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dh_df.shift, 0.5 * UP\n",
        "        )\n",
        "\n",
        "        # dh/dg\n",
        "        self.play(\n",
        "            dh_dg.shift, 0.5 * DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                h_formula[2:].copy(),\n",
        "                full_derivative[19:21],\n",
        "            ),\n",
        "            FadeIn(full_derivative[18:22:3])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            h_formula.shift, DOWN,\n",
        "            dh_dg.shift, 0.5 * UP\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.full_derivative = full_derivative\n",
        "\n",
        "    def plug_in_values(self):\n",
        "        full_derivative = self.full_derivative\n",
        "        value_labels = self.value_labels\n",
        "\n",
        "        rhs = OldTex(\n",
        "            \"\"\"\n",
        "            =\n",
        "            (2 \\\\cdot 2)\n",
        "            (2 \\\\cdot 4 \\\\cdot 1) +\n",
        "            (-\\\\sin(\\\\pi 2)\\\\pi)(4^2)\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"2\": self.x_color,\n",
        "                \"4\": self.f_color,\n",
        "                \"1\": self.g_color,\n",
        "                \"^2\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        rhs.next_to(full_derivative, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        result = OldTex(\"=\", \"32\", \"+\", \"0\")\n",
        "        result.next_to(rhs, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(LaggedStartMap(Write, value_labels))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            full_derivative.copy(), rhs,\n",
        "            lag_ratio=0.5,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(result))\n",
        "        self.wait()\n",
        "\n",
        "    def discuss_meaning_of_result(self):\n",
        "        x_dot = self.x_dot\n",
        "        h_dot = self.h_dot\n",
        "\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                x_dot.shift, 0.25 * RIGHT,\n",
        "                h_dot.shift, RIGHT,\n",
        "                run_time=2,\n",
        "                rate_func=lambda t: wiggle(t, 4)\n",
        "            )\n",
        "            self.wait()\n"
    ]
}