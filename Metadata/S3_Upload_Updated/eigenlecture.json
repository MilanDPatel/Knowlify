{
    "topic": "The mathematical concept being demonstrated is the change of coordinates from Cartesian to polar coordinates. The code shows",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2021.matrix_exp import *\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def get_intensity_colors(values, cmap_name='viridis'):\n",
        "    \"\"\"\n",
        "    Convert a value between 0 and 1 to a color using a perceptually uniform colormap.\n",
        "\n",
        "    Args:\n",
        "        value (np.array): Array of values between 0 and 1\n",
        "        cmap_name (str): Name of colormap (default: 'viridis')\n",
        "\n",
        "    Returns:\n",
        "        np.array: RGB color values as (r,g,b) where each component is between 0 and 1\n",
        "    \"\"\"\n",
        "    cmap = plt.get_cmap(cmap_name)\n",
        "    return cmap(values)[:, :3]  # Only return RGB, exclude alpha\n",
        "\n",
        "\n",
        "class TexScratchPad(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # ODE\n",
        "        tex = Tex(R\"\"\"\n",
        "            \\left[\\begin{array}{c} x'(t) \\\\ y'(t) \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{cc} 1 & 2 \\\\ 3 & 1 \\end{array}\\right]\n",
        "            \\left[\\begin{array}{c} x(t) \\\\ y(t) \\end{array}\\right]\n",
        "        \"\"\")\n",
        "\n",
        "        # ODE in new coordinates\n",
        "        tex = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{c} \\tilde{x}'(t) \\\\ \\tilde{y}'(t) \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{cc} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{array}\\right]\n",
        "            \\left[\\begin{array}{c} \\tilde{x}(t) \\\\ \\tilde{y}(t) \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "\n",
        "        # Solution to ODE in new coordinates\n",
        "        tex = Tex(\n",
        "            R\"\"\"\n",
        "            \\tilde{x}(t) = \\tilde{x}_0 e^{\\lambda_1 t} \\\\\n",
        "            \\tilde{y}(t) = \\tilde{y}_0 e^{\\lambda_2 t} \\\\\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(tex)\n",
        "\n",
        "        # Meaning of the alternate coordinates\n",
        "        tex = Tex(\n",
        "            R\"\"\"\n",
        "            x \\hat{\\textbf{\\i}} + y \\hat{\\textbf{\\j}} =\n",
        "            \\tilde{x} \\vec{\\textbf{v}}_1 + \\tilde{y} \\vec{\\textbf{v}}_2\n",
        "            \"\"\",\n",
        "            t2c={\n",
        "                R\"\\lambda_1\": TEAL,\n",
        "                R\"\\lambda_2\": YELLOW,\n",
        "                R\"\\vec{\\textbf{v}}_1\": TEAL,\n",
        "                R\"\\vec{\\textbf{v}}_2\": YELLOW,\n",
        "                R\"\\hat{\\textbf{\\i}}\": GREEN,\n",
        "                R\"\\hat{\\textbf{\\j}}\": RED,\n",
        "            }\n",
        "        )\n",
        "        self.add(tex)\n",
        "\n",
        "        # Change of basis matrix\n",
        "        mat_tex = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} a & b \\\\ c & d \\end{array}\\right]\n",
        "            \"\"\",\n",
        "        )\n",
        "        old_cols = VGroup(\n",
        "            mat_tex[1:4:2],\n",
        "            mat_tex[2:5:2],\n",
        "        )\n",
        "        old_cols.set_opacity(0)\n",
        "        new_cols = VGroup(\n",
        "            Tex(R\"\\vec{\\textbf{v}}_1\").set_color(TEAL),\n",
        "            Tex(R\"\\vec{\\textbf{v}}_2\").set_color(YELLOW),\n",
        "        )\n",
        "        for new_col, old_col in zip(new_cols, old_cols):\n",
        "            lines = Line(UP, DOWN).set_height(0.35).replicate(2)\n",
        "            lines[0].next_to(new_col, UP, SMALL_BUFF)\n",
        "            lines[1].next_to(new_col, DOWN, SMALL_BUFF)\n",
        "            new_col.add(lines)\n",
        "            new_col.match_height(mat_tex)\n",
        "            new_col.move_to(old_col)\n",
        "        new_cols[1].align_to(new_cols[0], UP)\n",
        "        cob_matrix = VGroup(mat_tex, new_cols)\n",
        "\n",
        "        og_matrix = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} a & b \\\\ c & d \\end{array}\\right]\n",
        "            \"\"\",\n",
        "        )\n",
        "\n",
        "        inv_cob = cob_matrix.copy()\n",
        "        inv_cob.add(Tex(R\"-1\", font_size=24).next_to(inv_cob, RIGHT, SMALL_BUFF, aligned_edge=UP))\n",
        "\n",
        "        diag_matrix = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "\n",
        "        expr = VGroup(\n",
        "            inv_cob, og_matrix, cob_matrix,\n",
        "            Tex(\"=\"), diag_matrix\n",
        "        )\n",
        "        expr.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(expr)\n",
        "\n",
        "        # Show powers\n",
        "        diag_matrix = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{array}\\right]^n = \n",
        "            \\left[\\begin{array}{cc} \\lambda_1^n & 0 \\\\ 0 & \\lambda_2^n \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(diag_matrix)\n",
        "\n",
        "        # Solve\n",
        "        diag_matrix = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} 0 & 1 \\\\ 1 & 1 \\end{array}\\right]^n = \n",
        "            \\left[\\begin{array}{cc} \\lambda_1^n & 0 \\\\ 0 & \\lambda_2^n \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(diag_matrix)\n",
        "\n",
        "        # Write eigenvectors\n",
        "        eigen1_equation = Tex(\n",
        "            R\"\"\"\n",
        "            \\left[\\begin{array}{cc} 0 & 1 \\\\ 1 & 1 \\end{array}\\right]\n",
        "            \\left[\\begin{array}{c} 1  \\\\ \\lambda_1 \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{c} \\lambda_1  \\\\ \\lambda_1 + 1 \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{c} \\lambda_1  \\\\ \\lambda_1^2 \\end{array}\\right] =\n",
        "            \\lambda_1 \\left[\\begin{array}{c} 1  \\\\ \\lambda_1 \\end{array}\\right] =\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        eigen1 = Tex(\n",
        "            R\"\"\"\n",
        "            \\vec{\\textbf{v}}_1 = \\left[\\begin{array}{c} 1  \\\\ \\lambda_1 \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        eigen2 = Tex(\n",
        "            R\"\"\"\n",
        "            \\vec{\\textbf{v}}_2 = \\left[\\begin{array}{c} 1 \\\\ \\lambda_2 \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(eigen2)\n",
        "\n",
        "        # Eigen matrix\n",
        "        fib_cob = Tex(\n",
        "            R\"\"\"\n",
        "            S = \\left[\\begin{array}{cc} 1 & 1  \\\\ \\lambda_1 & \\lambda_2 \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(fib_cob)\n",
        "\n",
        "        # Fibonacci expression\n",
        "        fib_expr = Tex(\n",
        "            R\"\"\"\n",
        "            A^n \\left[\\begin{array}{c} 0 \\\\ 1 \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{c} F_n \\\\ F_{n + 1} \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(fib_expr)\n",
        "\n",
        "        # Fib formula\n",
        "        fib_formula = Tex(\n",
        "            R\"\"\"\n",
        "            F_n = \\frac{\\lambda_1^n - \\lambda_2^n}{\\lambda_1 - \\lambda_2}\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(fib_formula)\n",
        "\n",
        "        # Translation\n",
        "        diag_matrix = Tex(\n",
        "            R\"\"\"\n",
        "            S \\left[\\begin{array}{cc} \\lambda_1^n & 0 \\\\ 0 & \\lambda_2^n \\end{array}\\right] S^{-1} = \n",
        "            A^n\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(diag_matrix)\n",
        "\n",
        "        # Matrix\n",
        "        tex = Tex(R\"\"\"\n",
        "            \\left[\\begin{array}{cc} 3 & 1 \\\\ 0 & 2 \\end{array}\\right]\n",
        "        \"\"\")\n",
        "        tex[1:4:2].set_color(GREEN)\n",
        "        tex[2:5:2].set_color(RED)\n",
        "        self.add(tex)\n",
        "\n",
        "        # Basis\n",
        "        basis_syms = VGroup(\n",
        "            Tex(R\"\\hat{\\textbf{\\i}}\").set_color(GREEN),\n",
        "            Tex(R\"\\hat{\\textbf{\\j}}\").set_color(RED),\n",
        "        )\n",
        "        basis_syms.arrange(RIGHT)\n",
        "        self.add(basis_syms)\n",
        "\n",
        "        # Equation\n",
        "        tex = Tex(R\"\"\"\n",
        "            \\left[\\begin{array}{c} x \\\\ y \\end{array}\\right] =\n",
        "            \\left[\\begin{array}{c} 1 \\\\ 1 + \\sqrt{5} \\end{array}\\right]\n",
        "        \"\"\", t2c={R\"\\lambda\": TEAL})\n",
        "        self.add(tex)\n",
        "\n",
        "        # List bases\n",
        "        tex = Tex(R\"\"\"\n",
        "            \\left[\\begin{array}{c} 1 \\\\ 0 \\end{array}\\right],\n",
        "            \\left[\\begin{array}{c} 0 \\\\ 1 \\end{array}\\right]\n",
        "        \"\"\")\n",
        "        self.add(tex)\n",
        "\n",
        "        # Diagonal matrix\n",
        "        tex = Tex(\n",
        "            R\"\"\"\n",
        "                \\left[\\begin{array}{cc} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{array}\\right]\n",
        "            \"\"\",\n",
        "            t2c={R\"\\lambda_1\": TEAL, R\"\\lambda_2\": YELLOW}\n",
        "        )\n",
        "        self.add(tex)\n",
        "\n",
        "\n",
        "def get_vector_field_and_stream_lines(\n",
        "    func, coordinate_system,\n",
        "    # Vector config\n",
        "    vector_stroke_width=5,\n",
        "    vector_opacity=0.5,\n",
        "    density=4,\n",
        "    # Streamline config\n",
        "    sample_freq=5,\n",
        "    n_samples_per_line=10,\n",
        "    solution_time=1,\n",
        "    arc_len=3,  # Does nothing\n",
        "    time_width=0.5,\n",
        "    line_color=WHITE,\n",
        "    line_width=3,\n",
        "    line_opacity=1.0,\n",
        "):\n",
        "    # Vector field\n",
        "    vector_field = VectorField(\n",
        "        func, axes,\n",
        "        density=density,\n",
        "        stroke_width=vector_stroke_width,\n",
        "        stroke_opacity=vector_opacity,\n",
        "    )\n",
        "\n",
        "    # Streamlines\n",
        "    stream_lines = StreamLines(\n",
        "        func, axes,\n",
        "        density=sample_freq,\n",
        "        n_samples_per_line=n_samples_per_line,\n",
        "        solution_time=solution_time,\n",
        "        magnitude_range=vector_field.magnitude_range,\n",
        "        color_by_magnitude=False,\n",
        "        stroke_color=line_color,\n",
        "        stroke_width=line_width,\n",
        "        stroke_opacity=line_opacity,\n",
        "    )\n",
        "    animated_lines = AnimatedStreamLines(\n",
        "        stream_lines,\n",
        "        line_anim_config=dict(time_width=time_width),\n",
        "        rate_multiple=0.25,\n",
        "    )\n",
        "\n",
        "    return vector_field, animated_lines\n",
        "\n",
        "\n",
        "class VectorFieldSolution(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        mat = np.array([[1, 2], [3, 1]])\n",
        "        # mat = np.array([[2, 0], [0, -1]])\n",
        "        axes = NumberPlane((-4, 4), (-2, 2), faded_line_ratio=1)\n",
        "        axes.set_height(FRAME_HEIGHT)\n",
        "        axes.background_lines.set_stroke(BLUE, 1)\n",
        "        axes.faded_lines.set_stroke(BLUE, 0.5, 0.5)\n",
        "        axes.add_coordinate_labels(font_size=36)\n",
        "\n",
        "        def func(v):\n",
        "            return 0.5 * np.dot(v, mat.T)\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Calculate eigen vectors\n",
        "        eigenvalues, eigenvectors = np.linalg.eig(mat)\n",
        "        eigenlines = VGroup(\n",
        "            Line(-v, v).set_length(10)\n",
        "            for v in eigenvectors.T\n",
        "        )\n",
        "        eigenlines.set_stroke(TEAL, 5)\n",
        "\n",
        "        # Show the flow\n",
        "        config = dict()\n",
        "        # config = dict(step_multiple=0.5, vector_stroke_width=8)\n",
        "        vector_field, animated_lines = get_vector_field_and_stream_lines(func, axes, **config)\n",
        "\n",
        "        self.add(vector_field, animated_lines)\n",
        "        vector_field.set_stroke(opacity=1)\n",
        "        self.play(vector_field.animate.set_stroke(opacity=0.5))\n",
        "        self.wait(10)\n",
        "        self.play(ShowCreation(eigenlines))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class Transformation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Apply matrix\n",
        "        mat = np.array([[1, 2], [3, 1]])\n",
        "\n",
        "        ghost_plane = NumberPlane(faded_line_ratio=0)\n",
        "        ghost_plane.set_stroke(GREY, 1)\n",
        "        plane = self.get_plane()\n",
        "        basis = VGroup(\n",
        "            self.get_updated_vector((1, 0), plane, GREEN),\n",
        "            self.get_updated_vector((0, 1), plane, RED),\n",
        "        )\n",
        "\n",
        "        self.add(ghost_plane, plane, basis)\n",
        "        self.play(\n",
        "            plane.animate.apply_matrix(mat),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fade out\n",
        "        self.play(FadeOut(VGroup(ghost_plane, plane, basis)))\n",
        "\n",
        "        # Show matrix in new coordinate system\n",
        "        eigenvalues, eigenvectors = np.linalg.eig(mat)\n",
        "        eigenplane = self.get_plane()\n",
        "        eigenplane.apply_matrix(eigenvectors, about_point=ORIGIN)\n",
        "\n",
        "        eigenbasis = VGroup(\n",
        "            self.get_updated_vector((1, 0), eigenplane, TEAL),\n",
        "            self.get_updated_vector((0, 1), eigenplane, YELLOW),\n",
        "        )\n",
        "\n",
        "        self.add(eigenplane, eigenbasis)\n",
        "        self.play(\n",
        "            eigenplane.animate.apply_matrix(mat),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_plane(self, x_range=(-16, 16), y_range=(-8, 8)):\n",
        "        return NumberPlane(x_range, y_range, faded_line_ratio=1)\n",
        "\n",
        "    def get_updated_vector(self, coords, coord_system, color=YELLOW, thickness=4, **kwargs):\n",
        "        vect = Vector(RIGHT, fill_color=color, thickness=thickness, **kwargs)\n",
        "        vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            coord_system.get_origin(),\n",
        "            coord_system.c2p(*coords),\n",
        "        ))\n",
        "        return vect\n"
    ]
}