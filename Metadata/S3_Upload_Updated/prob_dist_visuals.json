{
    "topic": "demonstrates the concept of probability distributions and how they can be used to model real-world",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.eop.reusable_imports import *\n",
        "\n",
        "\n",
        "class ProbabilityDistributions(PiCreatureScene):\n",
        "\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "        \"color\": MAROON_E,\n",
        "        \"flip_at_start\": False,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "\n",
        "        lag_ratio = 0.2\n",
        "        run_time = 3\n",
        "        \n",
        "\n",
        "# WEATHER FORECAST\n",
        "\n",
        "    \n",
        "        unit_rect = Rectangle(\n",
        "            height = 3, width = 3\n",
        "        ).shift(DOWN)\n",
        "\n",
        "        p_rain = 0.23\n",
        "        p_sun = 1 - p_rain\n",
        "        opacity = 0.7\n",
        "\n",
        "        rain_rect = unit_rect.copy().stretch(p_rain, 0)\n",
        "        rain_rect.align_to(unit_rect, LEFT)\n",
        "        rain_rect.set_fill(color = BLUE, opacity = opacity)\n",
        "        rain_rect.set_stroke(width = 0)\n",
        "\n",
        "        sun_rect = unit_rect.copy().stretch(p_sun, 0)\n",
        "        sun_rect.next_to(rain_rect, RIGHT, buff = 0)\n",
        "        sun_rect.set_fill(color = YELLOW, opacity = opacity)\n",
        "        sun_rect.set_stroke(width = 0)\n",
        "\n",
        "        self.add(unit_rect, rain_rect, sun_rect)\n",
        "\n",
        "        rain = SVGMobject(file_name = \"rain\").scale(0.25)\n",
        "        sun = SVGMobject(file_name = \"sun\").scale(0.35)\n",
        "\n",
        "        rain.flip().move_to(rain_rect)\n",
        "        sun.move_to(sun_rect)\n",
        "\n",
        "        self.add(rain, sun)\n",
        "\n",
        "\n",
        "        text_scale =  0.7\n",
        "\n",
        "        brace_rain = Brace(rain_rect, UP)\n",
        "        p_rain_label = OldTexText(\"$P($rain$)=$\").scale(text_scale)\n",
        "        p_rain_decimal = DecimalNumber(p_rain).scale(text_scale)\n",
        "        p_rain_decimal.next_to(p_rain_label)\n",
        "        p_rain_whole_label = VGroup(p_rain_label, p_rain_decimal)\n",
        "        p_rain_whole_label.next_to(brace_rain, UP)\n",
        "\n",
        "        brace_sun = Brace(sun_rect, DOWN)\n",
        "        p_sun_label = OldTexText(\"$P($sunshine$)=$\").scale(text_scale)\n",
        "        p_sun_decimal = DecimalNumber(p_sun).scale(text_scale)\n",
        "        p_sun_decimal.next_to(p_sun_label)\n",
        "        p_sun_whole_label = VGroup(p_sun_label, p_sun_decimal)\n",
        "        p_sun_whole_label.next_to(brace_sun, DOWN)\n",
        "\n",
        "        self.add(brace_rain, p_rain_whole_label, brace_sun, p_sun_whole_label)\n",
        "\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "\n",
        "        # new_p_rain = 0.68\n",
        "        # new_p_sun = 1 - new_p_rain\n",
        "\n",
        "        # new_rain_rect = unit_rect.copy().stretch(new_p_rain, 0)\n",
        "        # new_rain_rect.align_to(unit_rect, LEFT)\n",
        "        # new_rain_rect.set_fill(color = BLUE, opacity = opacity)\n",
        "        # new_rain_rect.set_stroke(width = 0)\n",
        "\n",
        "        # new_sun_rect = unit_rect.copy().stretch(new_p_sun, 0)\n",
        "        # new_sun_rect.next_to(new_rain_rect, RIGHT, buff = 0)\n",
        "        # new_sun_rect.set_fill(color = YELLOW, opacity = opacity)\n",
        "        # new_sun_rect.set_stroke(width = 0)\n",
        "\n",
        "        # new_rain = SVGMobject(file_name = \"rain\").scale(0.35)\n",
        "        # new_sun = SVGMobject(file_name = \"sun\").scale(0.35)\n",
        "\n",
        "        # new_rain.flip().move_to(new_rain_rect)\n",
        "        # new_sun.move_to(new_sun_rect)\n",
        "\n",
        "        # new_brace_rain = Brace(new_rain_rect, UP)\n",
        "        # new_p_rain_label = OldTexText(\"$P($rain$)=$\").scale(text_scale)\n",
        "        # new_p_rain_decimal = DecimalNumber(new_p_rain).scale(text_scale)\n",
        "        # new_p_rain_decimal.next_to(new_p_rain_label)\n",
        "        # new_p_rain_whole_label = VGroup(new_p_rain_label, new_p_rain_decimal)\n",
        "        # new_p_rain_whole_label.next_to(new_brace_rain, UP)\n",
        "\n",
        "        \n",
        "        # new_brace_sun = Brace(new_sun_rect, DOWN)\n",
        "        # new_p_sun_label = OldTexText(\"$P($sunshine$)=$\").scale(text_scale)\n",
        "        # new_p_sun_decimal = DecimalNumber(new_p_sun).scale(text_scale)\n",
        "        # new_p_sun_decimal.next_to(new_p_sun_label)\n",
        "        # new_p_sun_whole_label = VGroup(new_p_sun_label, new_p_sun_decimal)\n",
        "        # new_p_sun_whole_label.next_to(new_brace_sun, DOWN)\n",
        "\n",
        "        # def rain_update_func(alpha):\n",
        "        #     return alpha * new_p_rain + (1 - alpha) * p_rain\n",
        "\n",
        "        # def sun_update_func(alpha):\n",
        "        #     return 1 - rain_update_func(alpha)\n",
        "\n",
        "        # update_p_rain = ChangingDecimal(\n",
        "        #     p_rain_decimal, rain_update_func,\n",
        "        #     tracked_mobject = p_rain_label,\n",
        "        #     run_time = run_time\n",
        "        # )\n",
        "        # update_p_sun = ChangingDecimal(\n",
        "        #     p_sun_decimal, sun_update_func,\n",
        "        #     tracked_mobject = p_sun_label,\n",
        "        #     run_time = run_time\n",
        "        # )\n",
        "\n",
        "        # self.play(\n",
        "        #     Transform(rain_rect, new_rain_rect, run_time = run_time),\n",
        "        #     Transform(sun_rect, new_sun_rect, run_time = run_time),\n",
        "        #     Transform(rain, new_rain, run_time = run_time),\n",
        "        #     Transform(sun, new_sun, run_time = run_time),\n",
        "        #     Transform(brace_rain, new_brace_rain, run_time = run_time),\n",
        "        #     Transform(brace_sun, new_brace_sun, run_time = run_time),\n",
        "        #     Transform(p_rain_label, new_p_rain_label, run_time = run_time),\n",
        "        #     Transform(p_sun_label, new_p_sun_label, run_time = run_time),\n",
        "        #     update_p_rain,\n",
        "        #     update_p_sun\n",
        "        # )\n",
        "\n",
        "\n",
        "\n",
        "        # move the forecast into a corner\n",
        "\n",
        "        forecast = VGroup(\n",
        "            rain_rect, sun_rect, rain, sun, brace_rain, brace_sun,\n",
        "            p_rain_whole_label, p_sun_whole_label, unit_rect\n",
        "        )\n",
        "\n",
        "        forecast.target = forecast.copy().scale(0.5)\n",
        "        forecast.target.to_corner(UL)\n",
        "\n",
        "        self.play(MoveToTarget(forecast))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(brace_rain),\n",
        "            FadeOut(brace_sun),\n",
        "            FadeOut(p_rain_whole_label),\n",
        "            FadeOut(p_sun_whole_label),\n",
        "        )\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "# DOUBLE DICE THROW\n",
        "\n",
        "        cell_size = 0.5\n",
        "        dice_table = TwoDiceTable(cell_size = cell_size, label_scale = 0.7)\n",
        "        dice_table.shift(0.8 * DOWN)\n",
        "        dice_unit_rect = SurroundingRectangle(\n",
        "            dice_table.cells, buff = 0,\n",
        "            stroke_color=WHITE\n",
        "        )\n",
        "\n",
        "        dice_table_grouped_cells = VGroup()\n",
        "\n",
        "        for i in range(6):\n",
        "            dice_table_grouped_cells.add(VGroup(*[\n",
        "                VGroup(\n",
        "                    dice_table.cells[6 * i - 5 * k],\n",
        "                    dice_table.labels[6 * i - 5 * k],\n",
        "                )\n",
        "                for k in range(i + 1)\n",
        "            ]))\n",
        "\n",
        "        for i in range(5):\n",
        "            dice_table_grouped_cells.add(VGroup(*[\n",
        "                VGroup(\n",
        "                    dice_table.cells[31 + i - 5 * k],\n",
        "                    dice_table.labels[31 + i - 5 * k],\n",
        "                )\n",
        "                for k in range(5 - i)\n",
        "            ]))\n",
        "\n",
        "        # self.play(\n",
        "        #     FadeIn(dice_unit_rect),\n",
        "        #     FadeIn(dice_table.rows)\n",
        "        # )\n",
        "\n",
        "        # for (cell, label) in zip(dice_table.cells, dice_table.labels):\n",
        "        #     cell.add(label)\n",
        "\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(FadeIn, dice_table_grouped_cells,\n",
        "        #         lag_ratio = lag_ratio, run_time = run_time)\n",
        "        # )\n",
        "        self.play(\n",
        "            FadeIn(dice_table_grouped_cells),\n",
        "            FadeIn(dice_unit_rect),\n",
        "            FadeIn(dice_table.rows)\n",
        "        )\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            dice_table_grouped_cells.space_out_submobjects, {\"factor\" : 1.5},\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "        dice_table.add(dice_unit_rect)\n",
        "        dice_table_target = dice_table.deepcopy()\n",
        "        dice_table_target.scale(0.5)\n",
        "        dice_table_target.to_corner(UR, buff=LARGE_BUFF)\n",
        "        dice_table_target.shift(0.4 * UP)\n",
        "\n",
        "        self.play(Transform(dice_table, dice_table_target))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(dice_table.rows),\n",
        "            FadeOut(dice_unit_rect),\n",
        "        )\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "# TITLE\n",
        "\n",
        "        text = OldTexText(\"Probability distributions\")\n",
        "        text.to_edge(UP)\n",
        "        text_rect = SurroundingRectangle(text, buff=MED_SMALL_BUFF)\n",
        "        text_rect.match_color(text)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(text),\n",
        "            ShowCreation(text_rect)\n",
        "        )\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "# COIN FLIP\n",
        "\n",
        "\n",
        "        brick_row = BrickRow(3, height = 2, width = 10)\n",
        "        coin_flip_rect = VGroup(brick_row)\n",
        "\n",
        "        tallies = VGroup()\n",
        "        for (i, brick) in enumerate(brick_row.rects):\n",
        "            tally = TallyStack(3 - i, i)\n",
        "            tally.move_to(brick)\n",
        "            tallies.add(tally)\n",
        "        coin_flip_rect.add(tallies)\n",
        "\n",
        "        coin_flip_rect.scale(0.65).shift(RIGHT)\n",
        "        self.play(FadeIn(coin_flip_rect))\n",
        "\n",
        "        counts = [1, 3, 3, 1]\n",
        "        braces = VGroup()\n",
        "        labels = VGroup()\n",
        "        for (rect, count) in zip(brick_row.rects, counts):\n",
        "            label = OldTex(\"{\" + str(count) + \"\\\\over 8}\").scale(0.5)\n",
        "            brace = Brace(rect, DOWN)\n",
        "            label.next_to(brace, DOWN)\n",
        "            braces.add(brace)\n",
        "            labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(braces),\n",
        "            FadeIn(labels)\n",
        "        )\n",
        "\n",
        "        coin_flip_rect.add(braces, labels)\n",
        "\n",
        "\n",
        "        self.wait(6)\n",
        "\n",
        "        outcomes = brick_row.get_outcome_rects_for_level(3, with_labels = True,\n",
        "            inset = True)\n",
        "        outcomes.scale(0.65)\n",
        "        outcomes.move_to(brick_row.get_center())\n",
        "        outcome_braces = VGroup(*[\n",
        "            Brace(outcome, DOWN) for outcome in outcomes\n",
        "        ])\n",
        "        outcome_labels = VGroup(*[\n",
        "            OldTex(\"{1\\over 8}\").scale(0.5).next_to(brace, DOWN)\n",
        "            for brace in outcome_braces\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(tallies),\n",
        "            FadeIn(outcomes),\n",
        "            FadeOut(braces),\n",
        "            FadeOut(labels),\n",
        "            FadeIn(outcome_braces),\n",
        "            FadeIn(outcome_labels)\n",
        "        )\n",
        "\n",
        "\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}