{
    "topic": "The mathematical concept being demonstrated in this code is the visualization of Fourier series using complex exponentials.",
    "code": [
        "from manim_imports_ext import *\n",
        "# import scipy\n",
        "\n",
        "\n",
        "class FourierCirclesScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 10,\n",
        "        \"big_radius\": 2,\n",
        "        \"colors\": [\n",
        "            BLUE_D,\n",
        "            BLUE_C,\n",
        "            BLUE_E,\n",
        "            GREY_BROWN,\n",
        "        ],\n",
        "        \"circle_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"vector_config\": {\n",
        "            \"buff\": 0,\n",
        "            \"max_tip_length_to_length_ratio\": 0.35,\n",
        "            \"fill_opacity\": 0.75,\n",
        "        },\n",
        "        \"circle_config\": {\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_opacity\": 0.75,\n",
        "        },\n",
        "        \"base_frequency\": 1,\n",
        "        \"slow_factor\": 0.25,\n",
        "        \"center_point\": ORIGIN,\n",
        "        \"parametric_function_step_size\": 0.01,\n",
        "        \"drawn_path_color\": YELLOW,\n",
        "        \"drawn_path_stroke_width\": 2,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.slow_factor_tracker = ValueTracker(\n",
        "            self.slow_factor\n",
        "        )\n",
        "        self.vector_clock = ValueTracker(0)\n",
        "        self.vector_clock.add_updater(\n",
        "            lambda m, dt: m.increment_value(\n",
        "                self.get_slow_factor() * dt\n",
        "            )\n",
        "        )\n",
        "        self.add(self.vector_clock)\n",
        "\n",
        "    def get_slow_factor(self):\n",
        "        return self.slow_factor_tracker.get_value()\n",
        "\n",
        "    def get_vector_time(self):\n",
        "        return self.vector_clock.get_value()\n",
        "\n",
        "    #\n",
        "    def get_freqs(self):\n",
        "        n = self.n_vectors\n",
        "        all_freqs = list(range(n // 2, -n // 2, -1))\n",
        "        all_freqs.sort(key=abs)\n",
        "        return all_freqs\n",
        "\n",
        "    def get_coefficients(self):\n",
        "        return [complex(0) for x in range(self.n_vectors)]\n",
        "\n",
        "    def get_color_iterator(self):\n",
        "        return it.cycle(self.colors)\n",
        "\n",
        "    def get_rotating_vectors(self, freqs=None, coefficients=None):\n",
        "        vectors = VGroup()\n",
        "        self.center_tracker = VectorizedPoint(self.center_point)\n",
        "\n",
        "        if freqs is None:\n",
        "            freqs = self.get_freqs()\n",
        "        if coefficients is None:\n",
        "            coefficients = self.get_coefficients()\n",
        "\n",
        "        last_vector = None\n",
        "        for freq, coefficient in zip(freqs, coefficients):\n",
        "            if last_vector is not None:\n",
        "                center_func = last_vector.get_end\n",
        "            else:\n",
        "                center_func = self.center_tracker.get_location\n",
        "            vector = self.get_rotating_vector(\n",
        "                coefficient=coefficient,\n",
        "                freq=freq,\n",
        "                center_func=center_func\n",
        "            )\n",
        "            vectors.add(vector)\n",
        "            last_vector = vector\n",
        "        return vectors\n",
        "\n",
        "    def get_rotating_vector(self, coefficient, freq, center_func):\n",
        "        vector = Vector(RIGHT, **self.vector_config)\n",
        "        vector.scale(abs(coefficient))\n",
        "        if abs(coefficient) == 0:\n",
        "            phase = 0\n",
        "        else:\n",
        "            phase = np.log(coefficient).imag\n",
        "        vector.rotate(phase, about_point=ORIGIN)\n",
        "        vector.freq = freq\n",
        "        vector.coefficient = coefficient\n",
        "        vector.center_func = center_func\n",
        "        vector.add_updater(self.update_vector)\n",
        "        return vector\n",
        "\n",
        "    def update_vector(self, vector, dt):\n",
        "        time = self.get_vector_time()\n",
        "        coef = vector.coefficient\n",
        "        freq = vector.freq\n",
        "        phase = np.log(coef).imag\n",
        "\n",
        "        vector.set_length(abs(coef))\n",
        "        vector.set_angle(phase + time * freq * TAU)\n",
        "        vector.shift(vector.center_func() - vector.get_start())\n",
        "        return vector\n",
        "\n",
        "    def get_circles(self, vectors):\n",
        "        return VGroup(*[\n",
        "            self.get_circle(\n",
        "                vector,\n",
        "                color=color\n",
        "            )\n",
        "            for vector, color in zip(\n",
        "                vectors,\n",
        "                self.get_color_iterator()\n",
        "            )\n",
        "        ])\n",
        "\n",
        "    def get_circle(self, vector, color=BLUE):\n",
        "        circle = Circle(color=color, **self.circle_config)\n",
        "        circle.center_func = vector.get_start\n",
        "        circle.radius_func = vector.get_length\n",
        "        circle.add_updater(self.update_circle)\n",
        "        return circle\n",
        "\n",
        "    def update_circle(self, circle):\n",
        "        circle.set_width(2 * circle.radius_func())\n",
        "        circle.move_to(circle.center_func())\n",
        "        return circle\n",
        "\n",
        "    def get_vector_sum_path(self, vectors, color=YELLOW):\n",
        "        coefs = [v.coefficient for v in vectors]\n",
        "        freqs = [v.freq for v in vectors]\n",
        "        center = vectors[0].get_start()\n",
        "\n",
        "        path = ParametricCurve(\n",
        "            lambda t: center + reduce(op.add, [\n",
        "                complex_to_R3(coef * np.exp(TAU * 1j * freq * t))\n",
        "                for coef, freq in zip(coefs, freqs)\n",
        "            ]),\n",
        "            t_min=0,\n",
        "            t_max=1,\n",
        "            color=color,\n",
        "            step_size=self.parametric_function_step_size,\n",
        "        )\n",
        "        return path\n",
        "\n",
        "    # TODO, this should be a general animated mobect\n",
        "    def get_drawn_path_alpha(self):\n",
        "        return self.get_vector_time()\n",
        "\n",
        "    def get_drawn_path(self, vectors, stroke_width=None, fade_rate=0.2, **kwargs):\n",
        "        if stroke_width is None:\n",
        "            stroke_width = self.drawn_path_stroke_width\n",
        "        path = self.get_vector_sum_path(vectors, **kwargs)\n",
        "        path.set_stroke(self.drawn_path_color, stroke_width)\n",
        "        self.add_path_fader(path, fade_rate)\n",
        "        return path\n",
        "\n",
        "    def add_path_fader(self, path, fade_rate=0.2):\n",
        "        stroke_width = np.max(path.get_stroke_width())\n",
        "        stroke_opacity = np.max(path.get_stroke_opacity())\n",
        "\n",
        "        def update_path(path_, dt):\n",
        "            alpha = self.get_vector_time()\n",
        "            n = path_.get_num_points()\n",
        "            fade_factors = (np.linspace(0, 1, n) - alpha) % 1\n",
        "            fade_factors = fade_factors**fade_rate\n",
        "            path_.set_stroke(\n",
        "                width=stroke_width * fade_factors,\n",
        "                opacity=stroke_opacity * fade_factors,\n",
        "            )\n",
        "            return path_\n",
        "\n",
        "        path.add_updater(update_path)\n",
        "        return path\n",
        "\n",
        "    def get_y_component_wave(self,\n",
        "                             vectors,\n",
        "                             left_x=1,\n",
        "                             color=PINK,\n",
        "                             n_copies=2,\n",
        "                             right_shift_rate=5):\n",
        "        path = self.get_vector_sum_path(vectors)\n",
        "        wave = ParametricCurve(\n",
        "            lambda t: op.add(\n",
        "                right_shift_rate * t * LEFT,\n",
        "                path.function(t)[1] * UP\n",
        "            ),\n",
        "            t_min=path.t_min,\n",
        "            t_max=path.t_max,\n",
        "            color=color,\n",
        "        )\n",
        "        wave_copies = VGroup(*[\n",
        "            wave.copy()\n",
        "            for x in range(n_copies)\n",
        "        ])\n",
        "        wave_copies.arrange(RIGHT, buff=0)\n",
        "        top_point = wave_copies.get_top()\n",
        "        wave.creation = ShowCreation(\n",
        "            wave,\n",
        "            run_time=(1 / self.get_slow_factor()),\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        cycle_animation(wave.creation)\n",
        "        wave.add_updater(lambda m: m.shift(\n",
        "            (m.get_left()[0] - left_x) * LEFT\n",
        "        ))\n",
        "\n",
        "        def update_wave_copies(wcs):\n",
        "            index = int(\n",
        "                wave.creation.total_time * self.get_slow_factor()\n",
        "            )\n",
        "            wcs[:index].match_style(wave)\n",
        "            wcs[index:].set_stroke(width=0)\n",
        "            wcs.next_to(wave, RIGHT, buff=0)\n",
        "            wcs.align_to(top_point, UP)\n",
        "        wave_copies.add_updater(update_wave_copies)\n",
        "\n",
        "        return VGroup(wave, wave_copies)\n",
        "\n",
        "    def get_wave_y_line(self, vectors, wave):\n",
        "        return DashedLine(\n",
        "            vectors[-1].get_end(),\n",
        "            wave[0].get_end(),\n",
        "            stroke_width=1,\n",
        "            dash_length=DEFAULT_DASH_LENGTH * 0.5,\n",
        "        )\n",
        "\n",
        "    # Computing Fourier series\n",
        "    # i.e. where all the math happens\n",
        "    def get_coefficients_of_path(self, path, n_samples=10000, freqs=None):\n",
        "        if freqs is None:\n",
        "            freqs = self.get_freqs()\n",
        "        dt = 1 / n_samples\n",
        "        ts = np.arange(0, 1, dt)\n",
        "        samples = np.array([\n",
        "            path.point_from_proportion(t)\n",
        "            for t in ts\n",
        "        ])\n",
        "        samples -= self.center_point\n",
        "        complex_samples = samples[:, 0] + 1j * samples[:, 1]\n",
        "\n",
        "        result = []\n",
        "        for freq in freqs:\n",
        "            riemann_sum = np.array([\n",
        "                np.exp(-TAU * 1j * freq * t) * cs\n",
        "                for t, cs in zip(ts, complex_samples)\n",
        "            ]).sum() * dt\n",
        "            result.append(riemann_sum)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class FourierSeriesIntroBackground4(FourierCirclesScene):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 4,\n",
        "        \"center_point\": 4 * LEFT,\n",
        "        \"run_time\": 30,\n",
        "        \"big_radius\": 1.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        circles = self.get_circles()\n",
        "        path = self.get_drawn_path(circles)\n",
        "        wave = self.get_y_component_wave(circles)\n",
        "        h_line = always_redraw(\n",
        "            lambda: self.get_wave_y_line(circles, wave)\n",
        "        )\n",
        "\n",
        "        # Why?\n",
        "        circles.update(-1 / self.camera.frame_rate)\n",
        "        #\n",
        "        self.add(circles, path, wave, h_line)\n",
        "        self.wait(self.run_time)\n",
        "\n",
        "    def get_ks(self):\n",
        "        return np.arange(1, 2 * self.n_vectors + 1, 2)\n",
        "\n",
        "    def get_freqs(self):\n",
        "        return self.base_frequency * self.get_ks()\n",
        "\n",
        "    def get_coefficients(self):\n",
        "        return self.big_radius / self.get_ks()\n",
        "\n",
        "\n",
        "class FourierSeriesIntroBackground8(FourierSeriesIntroBackground4):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 8,\n",
        "    }\n",
        "\n",
        "\n",
        "class FourierSeriesIntroBackground12(FourierSeriesIntroBackground4):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 12,\n",
        "    }\n",
        "\n",
        "\n",
        "class FourierSeriesIntroBackground20(FourierSeriesIntroBackground4):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 20,\n",
        "    }\n",
        "\n",
        "\n",
        "class FourierOfPiSymbol(FourierCirclesScene):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 101,\n",
        "        \"center_point\": ORIGIN,\n",
        "        \"slow_factor\": 0.1,\n",
        "        \"n_cycles\": 1,\n",
        "        \"tex\": \"\\\\pi\",\n",
        "        \"start_drawn\": False,\n",
        "        \"max_circle_stroke_width\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_vectors_circles_path()\n",
        "        for n in range(self.n_cycles):\n",
        "            self.run_one_cycle()\n",
        "\n",
        "    def add_vectors_circles_path(self):\n",
        "        path = self.get_path()\n",
        "        coefs = self.get_coefficients_of_path(path)\n",
        "\n",
        "        for freq, coef in zip(self.get_freqs(), coefs):\n",
        "            print(freq, \"\\t\", coef)\n",
        "\n",
        "        vectors = self.get_rotating_vectors(coefficients=coefs)\n",
        "        circles = self.get_circles(vectors)\n",
        "        self.set_decreasing_stroke_widths(circles)\n",
        "        # approx_path = self.get_vector_sum_path(circles)\n",
        "        drawn_path = self.get_drawn_path(vectors)\n",
        "        if self.start_drawn:\n",
        "            self.vector_clock.increment_value(1)\n",
        "\n",
        "        self.add(path)\n",
        "        self.add(vectors)\n",
        "        self.add(circles)\n",
        "        self.add(drawn_path)\n",
        "\n",
        "        self.vectors = vectors\n",
        "        self.circles = circles\n",
        "        self.path = path\n",
        "        self.drawn_path = drawn_path\n",
        "\n",
        "    def run_one_cycle(self):\n",
        "        time = 1 / self.slow_factor\n",
        "        self.wait(time)\n",
        "\n",
        "    def set_decreasing_stroke_widths(self, circles):\n",
        "        mcsw = self.max_circle_stroke_width\n",
        "        for k, circle in zip(it.count(1), circles):\n",
        "            circle.set_stroke(width=max(\n",
        "                # mcsw / np.sqrt(k),\n",
        "                mcsw / k,\n",
        "                mcsw,\n",
        "            ))\n",
        "        return circles\n",
        "\n",
        "    def get_path(self):\n",
        "        tex_mob = OldTex(self.tex)\n",
        "        tex_mob.set_height(6)\n",
        "        path = tex_mob.family_members_with_points()[0]\n",
        "        path.set_fill(opacity=0)\n",
        "        path.set_stroke(WHITE, 1)\n",
        "        return path\n",
        "\n",
        "\n",
        "class FourierOfTexPaths(FourierOfPiSymbol):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 100,\n",
        "        \"name_color\": WHITE,\n",
        "        \"animated_name\": \"Abc\",\n",
        "        \"conjoined\": False,\n",
        "        \"time_per_symbol\": 5,\n",
        "        \"slow_factor\": 1 / 5,\n",
        "        \"parametric_function_step_size\": 0.001,\n",
        "        \"max_circle_stroke_width\": 1.0,\n",
        "        \"vector_config\": {\n",
        "            \"buff\": 0,\n",
        "            \"fill_opacity\": 0.75,\n",
        "            \"thickness\": 0.02,\n",
        "            \"max_tip_length_to_length_ratio\": 0.5,\n",
        "            \"max_width_to_length_ratio\": 0.05,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        name = OldTexText(self.animated_name)\n",
        "\n",
        "        if self.conjoined:\n",
        "            new_name = VMobject()\n",
        "            for path in name.family_members_with_points():\n",
        "                new_name.append_points(path.get_points())\n",
        "            name = new_name\n",
        "\n",
        "        max_width = FRAME_WIDTH - 2\n",
        "        max_height = FRAME_HEIGHT - 2\n",
        "        name.set_width(max_width)\n",
        "        if name.get_height() > max_height:\n",
        "            name.set_height(max_height)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "\n",
        "        vectors = None\n",
        "        circles = None\n",
        "        for path in name.family_members_with_points():\n",
        "            subpaths = [path.get_points()] if self.conjoined else path.get_subpaths()\n",
        "            for subpath in subpaths:\n",
        "                sp_mob = VMobject()\n",
        "                sp_mob.set_points(subpath)\n",
        "                sp_mob.insert_n_curves(10)\n",
        "                sp_mob.set_color(\"#2561d9\")\n",
        "                coefs = self.get_coefficients_of_path(sp_mob)\n",
        "                new_vectors = self.get_rotating_vectors(coefficients=coefs)\n",
        "                new_circles = self.get_circles(new_vectors)\n",
        "                self.set_decreasing_stroke_widths(new_circles)\n",
        "\n",
        "                drawn_path = self.get_drawn_path(new_vectors)\n",
        "                drawn_path.clear_updaters()\n",
        "                drawn_path.set_stroke(self.name_color, 1.5)\n",
        "                drawn_path.set_fill(opacity=0)\n",
        "\n",
        "                static_vectors = self.get_rotating_vectors(coefficients=coefs)\n",
        "                static_circles = self.get_circles(static_vectors)\n",
        "                self.set_decreasing_stroke_widths(static_circles)\n",
        "                static_vectors.clear_updaters()\n",
        "                static_circles.clear_updaters()\n",
        "\n",
        "                if vectors is None:\n",
        "                    vectors = static_vectors.deepcopy()\n",
        "                    circles = static_circles.deepcopy()\n",
        "                    vectors.scale(0)\n",
        "                    circles.scale(0)\n",
        "\n",
        "                self.play(\n",
        "                    Transform(vectors, static_vectors, remover=True),\n",
        "                    Transform(circles, static_circles, remover=True),\n",
        "                    frame.set_max_width, 1.25 * name.get_width(),\n",
        "                    frame.move_to, path,\n",
        "                )\n",
        "\n",
        "                self.add(drawn_path, new_vectors, new_circles)\n",
        "                self.vector_clock.set_value(0)\n",
        "                self.play(\n",
        "                    ShowCreation(drawn_path),\n",
        "                    rate_func=linear,\n",
        "                    run_time=self.time_per_symbol\n",
        "                )\n",
        "                self.remove(new_vectors, new_circles)\n",
        "                self.add(static_vectors, static_circles)\n",
        "\n",
        "                vectors = static_vectors\n",
        "                circles = static_circles\n",
        "        self.play(\n",
        "            FadeOut(vectors),\n",
        "            Restore(frame),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class FourierOfPiSymbol5(FourierOfPiSymbol):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 5,\n",
        "        \"run_time\": 10,\n",
        "    }\n",
        "\n",
        "\n",
        "class FourierOfTrebleClef(FourierOfPiSymbol):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 101,\n",
        "        \"run_time\": 10,\n",
        "        \"start_drawn\": True,\n",
        "        \"file_name\": \"TrebleClef\",\n",
        "        \"height\": 7.5,\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        shape = SVGMobject(self.file_name)\n",
        "        return shape\n",
        "\n",
        "    def get_path(self):\n",
        "        shape = self.get_shape()\n",
        "        path = shape.family_members_with_points()[0]\n",
        "        path.set_height(self.height)\n",
        "        path.set_fill(opacity=0)\n",
        "        path.set_stroke(WHITE, 0)\n",
        "        return path\n",
        "\n",
        "\n",
        "class FourierOfIP(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"IP_logo2\",\n",
        "        \"height\": 6,\n",
        "        \"n_vectors\": 100,\n",
        "    }\n",
        "\n",
        "    # def construct(self):\n",
        "    #     path = self.get_path()\n",
        "    #     self.add(path)\n",
        "\n",
        "    def get_shape(self):\n",
        "        shape = SVGMobject(self.file_name)\n",
        "        return shape\n",
        "\n",
        "    def get_path(self):\n",
        "        shape = self.get_shape()\n",
        "        path = shape.family_members_with_points()[0]\n",
        "        path.add_line_to(path.get_start())\n",
        "        # path.make_smooth()\n",
        "\n",
        "        path.set_height(self.height)\n",
        "        path.set_fill(opacity=0)\n",
        "        path.set_stroke(WHITE, 0)\n",
        "        return path\n",
        "\n",
        "\n",
        "class FourierOfEighthNote(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"file_name\": \"EighthNote\"\n",
        "    }\n",
        "\n",
        "\n",
        "class FourierOfN(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"height\": 6,\n",
        "        \"n_vectors\": 1000,\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        return OldTex(\"N\")\n",
        "\n",
        "\n",
        "class FourierNailAndGear(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"height\": 6,\n",
        "        \"n_vectors\": 200,\n",
        "        \"run_time\": 100,\n",
        "        \"slow_factor\": 0.01,\n",
        "        \"parametric_function_step_size\": 0.0001,\n",
        "        \"arrow_config\": {\n",
        "            \"tip_length\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        shape = SVGMobject(\"Nail_And_Gear\")[1]\n",
        "        return shape\n",
        "\n",
        "\n",
        "class FourierBatman(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"height\": 4,\n",
        "        \"n_vectors\": 100,\n",
        "        \"run_time\": 10,\n",
        "        \"arrow_config\": {\n",
        "            \"tip_length\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        shape = SVGMobject(\"BatmanLogo\")[1]\n",
        "        return shape\n",
        "\n",
        "\n",
        "class FourierHeart(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"height\": 4,\n",
        "        \"n_vectors\": 100,\n",
        "        \"run_time\": 10,\n",
        "        \"arrow_config\": {\n",
        "            \"tip_length\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        shape = SuitSymbol(\"hearts\")\n",
        "        return shape\n",
        "\n",
        "    def get_drawn_path(self, *args, **kwargs):\n",
        "        kwargs[\"stroke_width\"] = 5\n",
        "        path = super().get_drawn_path(*args, **kwargs)\n",
        "        path.set_color(PINK)\n",
        "        return path\n",
        "\n",
        "\n",
        "class FourierNDQ(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"height\": 4,\n",
        "        \"n_vectors\": 1000,\n",
        "        \"run_time\": 10,\n",
        "        \"arrow_config\": {\n",
        "            \"tip_length\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        path = VMobject()\n",
        "        shape = OldTex(\"NDQ\")\n",
        "        for sp in shape.family_members_with_points():\n",
        "            path.append_points(sp.get_points())\n",
        "        return path\n",
        "\n",
        "\n",
        "class FourierGoogleG(FourierOfTrebleClef):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 10,\n",
        "        \"height\": 5,\n",
        "        \"g_colors\": [\n",
        "            \"#4285F4\",\n",
        "            \"#DB4437\",\n",
        "            \"#F4B400\",\n",
        "            \"#0F9D58\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def get_shape(self):\n",
        "        g = SVGMobject(\"google_logo\")[5]\n",
        "        g.center()\n",
        "        self.add(g)\n",
        "        return g\n",
        "\n",
        "    def get_drawn_path(self, *args, **kwargs):\n",
        "        kwargs[\"stroke_width\"] = 7\n",
        "        path = super().get_drawn_path(*args, **kwargs)\n",
        "\n",
        "        blue, red, yellow, green = self.g_colors\n",
        "\n",
        "        path[:250].set_color(blue)\n",
        "        path[250:333].set_color(green)\n",
        "        path[333:370].set_color(yellow)\n",
        "        path[370:755].set_color(red)\n",
        "        path[755:780].set_color(yellow)\n",
        "        path[780:860].set_color(green)\n",
        "        path[860:].set_color(blue)\n",
        "\n",
        "        return path\n",
        "\n",
        "\n",
        "class ExplainCircleAnimations(FourierCirclesScene):\n",
        "    CONFIG = {\n",
        "        \"n_vectors\": 100,\n",
        "        \"center_point\": 2 * DOWN,\n",
        "        \"n_top_circles\": 9,\n",
        "        \"path_height\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_path()\n",
        "        self.add_circles()\n",
        "        self.wait(8)\n",
        "        self.organize_circles_in_a_row()\n",
        "        self.show_frequencies()\n",
        "        self.show_examples_for_frequencies()\n",
        "        self.show_as_vectors()\n",
        "        self.show_vector_sum()\n",
        "        self.tweak_starting_vectors()\n",
        "\n",
        "    def add_path(self):\n",
        "        self.path = self.get_path()\n",
        "        self.add(self.path)\n",
        "\n",
        "    def add_circles(self):\n",
        "        coefs = self.get_coefficients_of_path(self.path)\n",
        "        self.circles = self.get_circles(coefficients=coefs)\n",
        "\n",
        "        self.add(self.circles)\n",
        "        self.drawn_path = self.get_drawn_path(self.circles)\n",
        "        self.add(self.drawn_path)\n",
        "\n",
        "    def organize_circles_in_a_row(self):\n",
        "        circles = self.circles\n",
        "        top_circles = circles[:self.n_top_circles].copy()\n",
        "\n",
        "        center_trackers = VGroup()\n",
        "        for circle in top_circles:\n",
        "            tracker = VectorizedPoint(circle.center_func())\n",
        "            circle.center_func = tracker.get_location\n",
        "            center_trackers.add(tracker)\n",
        "            tracker.freq = circle.freq\n",
        "            tracker.circle = circle\n",
        "\n",
        "        center_trackers.submobjects.sort(\n",
        "            key=lambda m: m.freq\n",
        "        )\n",
        "        center_trackers.generate_target()\n",
        "        right_buff = 1.45\n",
        "        center_trackers.target.arrange(RIGHT, buff=right_buff)\n",
        "        center_trackers.target.to_edge(UP, buff=1.25)\n",
        "\n",
        "        self.add(top_circles)\n",
        "        self.play(\n",
        "            MoveToTarget(center_trackers),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.top_circles = top_circles\n",
        "        self.center_trackers = center_trackers\n",
        "\n",
        "    def show_frequencies(self):\n",
        "        center_trackers = self.center_trackers\n",
        "\n",
        "        freq_numbers = VGroup()\n",
        "        for ct in center_trackers:\n",
        "            number = Integer(ct.freq)\n",
        "            number.next_to(ct, DOWN, buff=1)\n",
        "            freq_numbers.add(number)\n",
        "            ct.circle.number = number\n",
        "\n",
        "        ld, rd = [\n",
        "            OldTex(\"\\\\dots\")\n",
        "            for x in range(2)\n",
        "        ]\n",
        "        ld.next_to(freq_numbers, LEFT, MED_LARGE_BUFF)\n",
        "        rd.next_to(freq_numbers, RIGHT, MED_LARGE_BUFF)\n",
        "        freq_numbers.add_to_back(ld)\n",
        "        freq_numbers.add(rd)\n",
        "\n",
        "        freq_word = OldTexText(\"Frequencies\")\n",
        "        freq_word.scale(1.5)\n",
        "        freq_word.set_color(YELLOW)\n",
        "        freq_word.next_to(freq_numbers, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown, freq_numbers\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(freq_word),\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeAround, freq_numbers,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.freq_numbers = freq_numbers\n",
        "        self.freq_word = freq_word\n",
        "\n",
        "    def show_examples_for_frequencies(self):\n",
        "        top_circles = self.top_circles\n",
        "        c1, c2, c3 = [\n",
        "            list(filter(\n",
        "                lambda c: c.freq == k,\n",
        "                top_circles\n",
        "            ))[0]\n",
        "            for k in (1, 2, 3)\n",
        "        ]\n",
        "\n",
        "        neg_circles = VGroup(*filter(\n",
        "            lambda c: c.freq < 0,\n",
        "            top_circles\n",
        "        ))\n",
        "\n",
        "        for c in [c1, c2, c3, *neg_circles]:\n",
        "            c.rect = SurroundingRectangle(c)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(c2.rect),\n",
        "            WiggleOutThenIn(c2.number),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(c2.rect, c1.rect),\n",
        "        )\n",
        "        self.play(FadeOut(c1.rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(c3.rect),\n",
        "            WiggleOutThenIn(c3.number),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(c3.rect),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ShowCreationThenFadeOut(c.rect)\n",
        "                for c in neg_circles\n",
        "            ])\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(self.freq_word))\n",
        "\n",
        "    def show_as_vectors(self):\n",
        "        top_circles = self.top_circles\n",
        "        top_vectors = self.get_rotating_vectors(top_circles)\n",
        "        top_vectors.set_color(WHITE)\n",
        "\n",
        "        original_circles = top_circles.copy()\n",
        "        self.play(\n",
        "            FadeIn(top_vectors),\n",
        "            top_circles.set_opacity, 0,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            top_circles.match_style, original_circles\n",
        "        )\n",
        "        self.remove(top_vectors)\n",
        "\n",
        "        self.top_vectors = top_vectors\n",
        "\n",
        "    def show_vector_sum(self):\n",
        "        trackers = self.center_trackers.copy()\n",
        "        trackers.sort(\n",
        "            submob_func=lambda t: abs(t.circle.freq - 0.1)\n",
        "        )\n",
        "        plane = self.plane = NumberPlane(\n",
        "            x_min=-3,\n",
        "            x_max=3,\n",
        "            y_min=-2,\n",
        "            y_max=2,\n",
        "            axis_config={\n",
        "                \"stroke_color\": GREY_B,\n",
        "            }\n",
        "        )\n",
        "        plane.set_stroke(width=1)\n",
        "        plane.fade(0.5)\n",
        "        plane.move_to(self.center_point)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.drawn_path),\n",
        "            FadeOut(self.circles),\n",
        "            self.slow_factor_tracker.set_value, 0.05,\n",
        "        )\n",
        "        self.add(plane, self.path)\n",
        "        self.play(FadeIn(plane))\n",
        "\n",
        "        new_circles = VGroup()\n",
        "        last_tracker = None\n",
        "        for tracker in trackers:\n",
        "            if last_tracker:\n",
        "                tracker.new_location_func = last_tracker.circle.get_start\n",
        "            else:\n",
        "                tracker.new_location_func = lambda: self.center_point\n",
        "\n",
        "            original_circle = tracker.circle\n",
        "            tracker.circle = original_circle.copy()\n",
        "            tracker.circle.center_func = tracker.get_location\n",
        "            new_circles.add(tracker.circle)\n",
        "\n",
        "            self.add(tracker, tracker.circle)\n",
        "            start_point = tracker.get_location()\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    tracker, lambda t, a: t.move_to(\n",
        "                        interpolate(\n",
        "                            start_point,\n",
        "                            tracker.new_location_func(),\n",
        "                            a,\n",
        "                        )\n",
        "                    ),\n",
        "                    run_time=2\n",
        "                )\n",
        "            )\n",
        "            tracker.add_updater(lambda t: t.move_to(\n",
        "                t.new_location_func()\n",
        "            ))\n",
        "            self.wait(2)\n",
        "            last_tracker = tracker\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "        self.clear()\n",
        "        self.slow_factor_tracker.set_value(0.1)\n",
        "        self.add(\n",
        "            self.top_circles,\n",
        "            self.freq_numbers,\n",
        "            self.path,\n",
        "        )\n",
        "        self.add_circles()\n",
        "        for tc in self.top_circles:\n",
        "            for c in self.circles:\n",
        "                if c.freq == tc.freq:\n",
        "                    tc.rotate(\n",
        "                        angle_of_vector(c.get_start() - c.get_center()) -\n",
        "                        angle_of_vector(tc.get_start() - tc.get_center())\n",
        "                    )\n",
        "        self.wait(10)\n",
        "\n",
        "    def tweak_starting_vectors(self):\n",
        "        top_circles = self.top_circles\n",
        "        circles = self.circles\n",
        "        path = self.path\n",
        "        drawn_path = self.drawn_path\n",
        "\n",
        "        new_path = self.get_new_path()\n",
        "        new_coefs = self.get_coefficients_of_path(new_path)\n",
        "        new_circles = self.get_circles(coefficients=new_coefs)\n",
        "\n",
        "        new_top_circles = VGroup()\n",
        "        new_top_vectors = VGroup()\n",
        "        for top_circle in top_circles:\n",
        "            for circle in new_circles:\n",
        "                if circle.freq == top_circle.freq:\n",
        "                    new_top_circle = circle.copy()\n",
        "                    new_top_circle.center_func = top_circle.get_center\n",
        "                    new_top_vector = self.get_rotating_vector(\n",
        "                        new_top_circle\n",
        "                    )\n",
        "                    new_top_circles.add(new_top_circle)\n",
        "                    new_top_vectors.add(new_top_vector)\n",
        "\n",
        "        self.play(\n",
        "            self.slow_factor_tracker.set_value, 0,\n",
        "            FadeOut(drawn_path)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(top_circles, new_top_circles),\n",
        "            ReplacementTransform(circles, new_circles),\n",
        "            FadeOut(path),\n",
        "            run_time=3,\n",
        "        )\n",
        "        new_drawn_path = self.get_drawn_path(\n",
        "            new_circles, stroke_width=4,\n",
        "        )\n",
        "        self.add(new_drawn_path)\n",
        "        self.slow_factor_tracker.set_value(0.1)\n",
        "        self.wait(20)\n",
        "\n",
        "    #\n",
        "    def configure_path(self, path):\n",
        "        path.set_stroke(WHITE, 1)\n",
        "        path.set_fill(BLACK, opacity=1)\n",
        "        path.set_height(self.path_height)\n",
        "        path.move_to(self.center_point)\n",
        "        return path\n",
        "\n",
        "    def get_path(self):\n",
        "        tex = OldTex(\"f\")\n",
        "        path = tex.family_members_with_points()[0]\n",
        "        self.configure_path(path)\n",
        "        return path\n",
        "        # return Square().set_height(3)\n",
        "\n",
        "    def get_new_path(self):\n",
        "        shape = SVGMobject(\"TrebleClef\")\n",
        "        path = shape.family_members_with_points()[0]\n",
        "        self.configure_path(path)\n",
        "        path.scale(1.5, about_edge=DOWN)\n",
        "        return path\n"
    ]
}