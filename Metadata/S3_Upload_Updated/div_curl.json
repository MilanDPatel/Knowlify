{
    "topic": "demonstrates the concept of a \"Joukowsky map\" which is a mathematical function",
    "code": [
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "# Quick note to anyone coming to this file with the\n",
        "# intent of recreating animations from the video.  Some\n",
        "# of these, especially those involving AnimatedStreamLines,\n",
        "# can take an extremely long time to run, but much of the\n",
        "# computational cost is just for giving subtle little effects\n",
        "# which don't matter too much.  Switching the line_anim_class\n",
        "# to ShowPassingFlash will give significant speedups, as will\n",
        "# increasing the values of delta_x and delta_y in sampling for\n",
        "# the stream lines.  Certainly while developing, things were not\n",
        "# run at production quality.\n",
        "\n",
        "FOX_COLOR = \"#DF7F20\"\n",
        "RABBIT_COLOR = \"#C6D6EF\"\n",
        "\n",
        "\n",
        "# Warning, this file uses ContinualChangingDecimal,\n",
        "# which has since been been deprecated.  Use a mobject\n",
        "# updater instead\n",
        "\n",
        "\n",
        "# Helper functions\n",
        "def joukowsky_map(z):\n",
        "    if z == 0:\n",
        "        return 0\n",
        "    return z + fdiv(1, z)\n",
        "\n",
        "\n",
        "def inverse_joukowsky_map(w):\n",
        "    u = 1 if w.real >= 0 else -1\n",
        "    return (w + u * np.sqrt(w**2 - 4)) / 2\n",
        "\n",
        "\n",
        "def derivative(func, dt=1e-7):\n",
        "    return lambda z: (func(z + dt) - func(z)) / dt\n",
        "\n",
        "\n",
        "def negative_gradient(potential_func, dt=1e-7):\n",
        "    def result(p):\n",
        "        output = potential_func(p)\n",
        "        dx = dt * RIGHT\n",
        "        dy = dt * UP\n",
        "        dz = dt * OUT\n",
        "        return -np.array([\n",
        "            (potential_func(p + dx) - output) / dt,\n",
        "            (potential_func(p + dy) - output) / dt,\n",
        "            (potential_func(p + dz) - output) / dt,\n",
        "        ])\n",
        "    return result\n",
        "\n",
        "\n",
        "def divergence(vector_func, dt=1e-7):\n",
        "    def result(point):\n",
        "        value = vector_func(point)\n",
        "        return sum([\n",
        "            (vector_func(point + dt * RIGHT) - value)[i] / dt\n",
        "            for i, vect in enumerate([RIGHT, UP, OUT])\n",
        "        ])\n",
        "    return result\n",
        "\n",
        "\n",
        "def two_d_curl(vector_func, dt=1e-7):\n",
        "    def result(point):\n",
        "        value = vector_func(point)\n",
        "        return op.add(\n",
        "            (vector_func(point + dt * RIGHT) - value)[1] / dt,\n",
        "            -(vector_func(point + dt * UP) - value)[0] / dt,\n",
        "        )\n",
        "    return result\n",
        "\n",
        "\n",
        "def cylinder_flow_vector_field(point, R=1, U=1):\n",
        "    z = R3_to_complex(point)\n",
        "    # return complex_to_R3(1.0 / derivative(joukowsky_map)(z))\n",
        "    return complex_to_R3(derivative(joukowsky_map)(z).conjugate())\n",
        "\n",
        "\n",
        "def cylinder_flow_magnitude_field(point):\n",
        "    return get_norm(cylinder_flow_vector_field(point))\n",
        "\n",
        "\n",
        "def vec_tex(s):\n",
        "    return \"\\\\vec{\\\\textbf{%s}}\" % s\n",
        "\n",
        "\n",
        "def four_swirls_function(point):\n",
        "    x, y = point[:2]\n",
        "    result = (y**3 - 4 * y) * RIGHT + (x**3 - 16 * x) * UP\n",
        "    result *= 0.05\n",
        "    norm = get_norm(result)\n",
        "    if norm == 0:\n",
        "        return result\n",
        "    # result *= 2 * sigmoid(norm) / norm\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_force_field_func(*point_strength_pairs, **kwargs):\n",
        "    radius = kwargs.get(\"radius\", 0.5)\n",
        "\n",
        "    def func(point):\n",
        "        result = np.array(ORIGIN)\n",
        "        for center, strength in point_strength_pairs:\n",
        "            to_center = center - point\n",
        "            norm = get_norm(to_center)\n",
        "            if norm == 0:\n",
        "                continue\n",
        "            elif norm < radius:\n",
        "                to_center /= radius**3\n",
        "            elif norm >= radius:\n",
        "                to_center /= norm**3\n",
        "            to_center *= -strength\n",
        "            result += to_center\n",
        "        return result\n",
        "    return func\n",
        "\n",
        "\n",
        "def get_charged_particles(color, sign, radius=0.1):\n",
        "    result = Circle(\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=0.5,\n",
        "        fill_color=color,\n",
        "        fill_opacity=0.8,\n",
        "        radius=radius\n",
        "    )\n",
        "    sign = OldTex(sign)\n",
        "    sign.set_stroke(WHITE, 1)\n",
        "    sign.set_width(0.5 * result.get_width())\n",
        "    sign.move_to(result)\n",
        "    result.add(sign)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_proton(radius=0.1):\n",
        "    return get_charged_particles(RED, \"+\", radius)\n",
        "\n",
        "\n",
        "def get_electron(radius=0.05):\n",
        "    return get_charged_particles(BLUE, \"-\", radius)\n",
        "\n",
        "\n",
        "def preditor_prey_vector_field(point):\n",
        "    alpha = 30.0\n",
        "    beta = 1.0\n",
        "    gamma = 30.0\n",
        "    delta = 1.0\n",
        "    x, y = point[:2]\n",
        "    result = 0.05 * np.array([\n",
        "        alpha * x - beta * x * y,\n",
        "        delta * x * y - gamma * y,\n",
        "        0,\n",
        "    ])\n",
        "    return rotate(result, 1 * DEGREES)\n",
        "\n",
        "# Mobjects\n",
        "\n",
        "# TODO, this is untested after turning it from a\n",
        "# ContinualAnimation into a VGroup\n",
        "class JigglingSubmobjects(VGroup):\n",
        "    CONFIG = {\n",
        "        \"amplitude\": 0.05,\n",
        "        \"jiggles_per_second\": 1,\n",
        "    }\n",
        "\n",
        "    def __init__(self, group, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        for submob in group.submobjects:\n",
        "            submob.jiggling_direction = rotate_vector(\n",
        "                RIGHT, np.random.random() * TAU,\n",
        "            )\n",
        "            submob.jiggling_phase = np.random.random() * TAU\n",
        "            self.add(submob)\n",
        "        self.add_updater(lambda m, dt: m.update(dt))\n",
        "\n",
        "    def update(self, dt):\n",
        "        for submob in self.submobjects:\n",
        "            submob.jiggling_phase += dt * self.jiggles_per_second * TAU\n",
        "            submob.shift(\n",
        "                self.amplitude *\n",
        "                submob.jiggling_direction *\n",
        "                np.sin(submob.jiggling_phase) * dt\n",
        "            )\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class Introduction(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"stream_lines_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 1.0 / 8,\n",
        "                \"delta_y\": 1.0 / 8,\n",
        "                \"y_min\": -8.5,\n",
        "                \"y_max\": 8.5,\n",
        "            }\n",
        "        },\n",
        "        \"vector_field_config\": {},\n",
        "        \"virtual_time\": 3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Divergence\n",
        "        def div_func(p):\n",
        "            return p / 3\n",
        "        div_vector_field = VectorField(\n",
        "            div_func, **self.vector_field_config\n",
        "        )\n",
        "        stream_lines = StreamLines(\n",
        "            div_func, **self.stream_lines_config\n",
        "        )\n",
        "        stream_lines.shuffle()\n",
        "        div_title = self.get_title(\"Divergence\")\n",
        "\n",
        "        self.add(div_vector_field)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowPassingFlash, stream_lines),\n",
        "            FadeIn(div_title[0]),\n",
        "            *list(map(GrowFromCenter, div_title[1]))\n",
        "        )\n",
        "\n",
        "        # Curl\n",
        "        def curl_func(p):\n",
        "            return rotate_vector(p / 3, 90 * DEGREES)\n",
        "\n",
        "        curl_vector_field = VectorField(\n",
        "            curl_func, **self.vector_field_config\n",
        "        )\n",
        "        stream_lines = StreamLines(\n",
        "            curl_func, **self.stream_lines_config\n",
        "        )\n",
        "        stream_lines.shuffle()\n",
        "        curl_title = self.get_title(\"Curl\")\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(div_vector_field, curl_vector_field),\n",
        "            ReplacementTransform(\n",
        "                div_title, curl_title,\n",
        "                path_arc=90 * DEGREES\n",
        "            ),\n",
        "        )\n",
        "        self.play(ShowPassingFlash(stream_lines, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "    def get_title(self, word):\n",
        "        title = OldTexText(word)\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        title.add_background_rectangle()\n",
        "        return title\n",
        "\n",
        "\n",
        "class ShowWritingTrajectory(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_screen()\n",
        "        self.show_meandering_path()\n",
        "        self.show_previous_video()\n",
        "\n",
        "    def add_screen(self):\n",
        "        self.screen.scale(1.4, about_edge=UL)\n",
        "        self.add(self.screen)\n",
        "\n",
        "    def show_meandering_path(self):\n",
        "        solid_path = VMobject().set_points_smoothly([\n",
        "            3 * UP + 2 * RIGHT,\n",
        "            2 * UP + 4 * RIGHT,\n",
        "            3.5 * UP + 3.5 * RIGHT,\n",
        "            2 * UP + 3 * RIGHT,\n",
        "            3 * UP + 7 * RIGHT,\n",
        "            3 * UP + 5 * RIGHT,\n",
        "            UP + 6 * RIGHT,\n",
        "            2 * RIGHT,\n",
        "            2 * UP + 2 * RIGHT,\n",
        "            self.screen.get_right()\n",
        "        ])\n",
        "        step = 1.0 / 80\n",
        "        dashed_path = VGroup(*[\n",
        "            VMobject().pointwise_become_partial(\n",
        "                solid_path, x, x + step / 2\n",
        "            )\n",
        "            for x in np.arange(0, 1 + step, step)\n",
        "        ])\n",
        "        arrow = Arrow(\n",
        "            solid_path.get_points()[-2],\n",
        "            solid_path.get_points()[-1],\n",
        "            buff=0\n",
        "        )\n",
        "        dashed_path.add(arrow.tip)\n",
        "        dashed_path.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                dashed_path,\n",
        "                rate_func=bezier([0, 0, 1, 1]),\n",
        "                run_time=5,\n",
        "            ),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*[\"sassy\"] * 3)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, dashed_path,\n",
        "                lambda m: (m.scale, 0),\n",
        "                remover=True\n",
        "            ),\n",
        "            self.teacher.change, \"tease\",\n",
        "            self.change_students(\n",
        "                *[\"pondering\"] * 3,\n",
        "                look_at=self.screen\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def show_previous_video(self):\n",
        "        screen = self.screen\n",
        "\n",
        "        arrow = Vector(LEFT, color=WHITE)\n",
        "        arrow.next_to(screen, RIGHT)\n",
        "        prev_words = OldTexText(\"Previous video\")\n",
        "        prev_words.next_to(arrow, RIGHT)\n",
        "\n",
        "        screen.generate_target()\n",
        "        screen.target.set_height(3.75)\n",
        "        screen.target.to_corner(UR)\n",
        "        complex_words = OldTexText(\"Complex derivatives\")\n",
        "        complex_words.next_to(\n",
        "            screen.target, LEFT,\n",
        "            buff=2 * SMALL_BUFF + arrow.get_length()\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(prev_words)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            arrow.flip,\n",
        "            arrow.next_to, screen.target, LEFT, SMALL_BUFF,\n",
        "            MoveToTarget(screen),\n",
        "            FadeOut(prev_words),\n",
        "            Write(complex_words),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            path_arc=30 * DEGREES\n",
        "        )\n",
        "        self.play_student_changes(\"erm\", \"sassy\", \"confused\")\n",
        "        self.look_at(screen)\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"sassy\")\n",
        "        self.wait(2)\n",
        "\n",
        "        bubble = self.teacher.get_bubble(\n",
        "            bubble_type=SpeechBubble,\n",
        "            height=3, width=5\n",
        "        )\n",
        "        complex_words.generate_target()\n",
        "        complex_words.target.move_to(bubble.get_bubble_center())\n",
        "        # self.play(\n",
        "        #     FadeOut(screen),\n",
        "        #     FadeOut(arrow),\n",
        "        #     ShowCreation(bubble),\n",
        "        #     self.teacher.change, \"hooray\",\n",
        "        #     MoveToTarget(complex_words),\n",
        "        # )\n",
        "\n",
        "        s0 = self.students[0]\n",
        "        s0.target_center = s0.get_center()\n",
        "\n",
        "        def update_s0(s0, dt):\n",
        "            s0.target_center += dt * LEFT * 0.5\n",
        "            s0.move_to(s0.target_center)\n",
        "\n",
        "        self.add(Mobject.add_updater(s0, update_s0))\n",
        "        self.play_student_changes(\"tired\", \"horrified\", \"sad\")\n",
        "        self.play(s0.look, LEFT)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TestVectorField(Scene):\n",
        "    CONFIG = {\n",
        "        \"func\": cylinder_flow_vector_field,\n",
        "        \"flow_time\": 15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        lines = StreamLines(\n",
        "            four_swirls_function,\n",
        "            virtual_time=3,\n",
        "            min_magnitude=0,\n",
        "            max_magnitude=2,\n",
        "        )\n",
        "        self.add(AnimatedStreamLines(\n",
        "            lines,\n",
        "            line_anim_class=ShowPassingFlash\n",
        "        ))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class CylinderModel(Scene):\n",
        "    CONFIG = {\n",
        "        \"production_quality_flow\": True,\n",
        "        \"vector_field_func\": cylinder_flow_vector_field,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.show_numbers()\n",
        "        self.show_contour_lines()\n",
        "        self.show_flow()\n",
        "        self.apply_joukowsky_map()\n",
        "\n",
        "    def add_plane(self):\n",
        "        self.plane = ComplexPlane()\n",
        "        self.plane.add_coordinates()\n",
        "        self.plane.coordinate_labels.submobjects.pop(-1)\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Complex Plane\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        title.add_background_rectangle()\n",
        "        self.title = title\n",
        "        self.add(title)\n",
        "\n",
        "    def show_numbers(self):\n",
        "        run_time = 5\n",
        "\n",
        "        unit_circle = self.unit_circle = Circle(\n",
        "            radius=self.plane.unit_size,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=0,\n",
        "            stroke_color=YELLOW\n",
        "        )\n",
        "        dot = Dot()\n",
        "        dot_update = UpdateFromFunc(\n",
        "            dot, lambda d: d.move_to(unit_circle.point_from_proportion(1))\n",
        "        )\n",
        "        exp_tex = OldTex(\"e^{\", \"0.00\", \"i}\")\n",
        "        zero = exp_tex.get_part_by_tex(\"0.00\")\n",
        "        zero.fade(1)\n",
        "        exp_tex_update = UpdateFromFunc(\n",
        "            exp_tex, lambda et: et.next_to(dot, UR, SMALL_BUFF)\n",
        "        )\n",
        "        exp_decimal = DecimalNumber(\n",
        "            0, num_decimal_places=2,\n",
        "            include_background_rectangle=True,\n",
        "            color=YELLOW\n",
        "        )\n",
        "        exp_decimal.replace(zero)\n",
        "        exp_decimal_update = ChangeDecimalToValue(\n",
        "            exp_decimal, TAU,\n",
        "            position_update_func=lambda mob: mob.move_to(zero),\n",
        "            run_time=run_time,\n",
        "        )\n",
        "\n",
        "        sample_numbers = [\n",
        "            complex(-5, 2),\n",
        "            complex(2, 2),\n",
        "            complex(3, 1),\n",
        "            complex(-5, -2),\n",
        "            complex(-4, 1),\n",
        "        ]\n",
        "        sample_labels = VGroup()\n",
        "        for z in sample_numbers:\n",
        "            sample_dot = Dot(self.plane.number_to_point(z))\n",
        "            sample_label = DecimalNumber(\n",
        "                z,\n",
        "                num_decimal_places=0,\n",
        "                include_background_rectangle=True,\n",
        "            )\n",
        "            sample_label.next_to(sample_dot, UR, SMALL_BUFF)\n",
        "            sample_labels.add(VGroup(sample_dot, sample_label))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(unit_circle, run_time=run_time),\n",
        "            VFadeIn(exp_tex),\n",
        "            UpdateFromAlphaFunc(\n",
        "                exp_decimal,\n",
        "                lambda ed, a: ed.set_fill(opacity=a)\n",
        "            ),\n",
        "            dot_update,\n",
        "            exp_tex_update,\n",
        "            exp_decimal_update,\n",
        "            LaggedStartMap(\n",
        "                FadeIn, sample_labels,\n",
        "                remover=True,\n",
        "                rate_func=there_and_back,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(exp_tex),\n",
        "            FadeOut(exp_decimal),\n",
        "            FadeOut(dot),\n",
        "            unit_circle.set_fill, BLACK, {\"opacity\": 1},\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_contour_lines(self):\n",
        "        warped_grid = self.warped_grid = self.get_warpable_grid()\n",
        "        h_line = Line(3 * LEFT, 3 * RIGHT, color=WHITE)  # Hack\n",
        "        func_label = self.get_func_label()\n",
        "\n",
        "        self.remove(self.plane)\n",
        "        self.add_foreground_mobjects(self.unit_circle, self.title)\n",
        "        self.play(\n",
        "            warped_grid.apply_complex_function, inverse_joukowsky_map,\n",
        "            Animation(h_line, remover=True)\n",
        "        )\n",
        "        self.play(Write(func_label))\n",
        "        self.add_foreground_mobjects(func_label)\n",
        "        self.wait()\n",
        "\n",
        "    def show_flow(self):\n",
        "        stream_lines = self.get_stream_lines()\n",
        "        stream_lines_copy = stream_lines.copy()\n",
        "        stream_lines_copy.set_stroke(YELLOW, 1)\n",
        "        stream_lines_animation = self.get_stream_lines_animation(\n",
        "            stream_lines\n",
        "        )\n",
        "\n",
        "        tiny_buff = 0.0001\n",
        "        v_lines = VGroup(*[\n",
        "            Line(\n",
        "                UP, ORIGIN,\n",
        "                path_arc=0,\n",
        "                n_arc_anchors=20,\n",
        "            ).shift(x * RIGHT)\n",
        "            for x in np.linspace(0, 1, 5)\n",
        "        ])\n",
        "        v_lines.match_background_image_file(stream_lines)\n",
        "        fast_lines, slow_lines = [\n",
        "            VGroup(*[\n",
        "                v_lines.copy().next_to(point, vect, tiny_buff)\n",
        "                for point, vect in it.product(h_points, [UP, DOWN])\n",
        "            ])\n",
        "            for h_points in [\n",
        "                [0.5 * LEFT, 0.5 * RIGHT],\n",
        "                [2 * LEFT, 2 * RIGHT],\n",
        "            ]\n",
        "        ]\n",
        "        for lines in fast_lines, slow_lines:\n",
        "            lines.apply_complex_function(inverse_joukowsky_map)\n",
        "\n",
        "        self.add(stream_lines_animation)\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(\n",
        "                stream_lines_copy,\n",
        "                lag_ratio=0,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(fast_lines))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(fast_lines, slow_lines))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(slow_lines),\n",
        "            VFadeOut(stream_lines_animation.mobject)\n",
        "        )\n",
        "        self.remove(stream_lines_animation)\n",
        "\n",
        "    def apply_joukowsky_map(self):\n",
        "        shift_val = 0.1 * LEFT + 0.2 * UP\n",
        "        scale_factor = get_norm(RIGHT - shift_val)\n",
        "        movers = VGroup(self.warped_grid, self.unit_circle)\n",
        "        self.unit_circle.insert_n_curves(50)\n",
        "\n",
        "        stream_lines = self.get_stream_lines()\n",
        "        stream_lines.scale(scale_factor)\n",
        "        stream_lines.shift(shift_val)\n",
        "        stream_lines.apply_complex_function(joukowsky_map)\n",
        "\n",
        "        self.play(\n",
        "            movers.scale, scale_factor,\n",
        "            movers.shift, shift_val,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            movers.apply_complex_function, joukowsky_map,\n",
        "            ShowCreationThenFadeAround(self.func_label),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add(self.get_stream_lines_animation(stream_lines))\n",
        "        self.wait(20)\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_func_label(self):\n",
        "        func_label = self.func_label = OldTex(\"f(z) = z + 1 / z\")\n",
        "        func_label.add_background_rectangle()\n",
        "        func_label.next_to(self.title, DOWN, MED_SMALL_BUFF)\n",
        "        return func_label\n",
        "\n",
        "    def get_warpable_grid(self):\n",
        "        top_grid = NumberPlane()\n",
        "        top_grid.prepare_for_nonlinear_transform()\n",
        "        bottom_grid = top_grid.copy()\n",
        "        tiny_buff = 0.0001\n",
        "        top_grid.next_to(ORIGIN, UP, buff=tiny_buff)\n",
        "        bottom_grid.next_to(ORIGIN, DOWN, buff=tiny_buff)\n",
        "        result = VGroup(top_grid, bottom_grid)\n",
        "        result.add(*[\n",
        "            Line(\n",
        "                ORIGIN, FRAME_WIDTH * RIGHT / 2,\n",
        "                color=WHITE,\n",
        "                path_arc=0,\n",
        "                n_arc_anchors=100,\n",
        "            ).next_to(ORIGIN, vect, buff=2)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ])\n",
        "        # This line is a bit of a hack\n",
        "        h_line = Line(LEFT, RIGHT, color=WHITE)\n",
        "        h_line.set_points([LEFT, LEFT, RIGHT, RIGHT])\n",
        "        h_line.scale(2)\n",
        "        result.add(h_line)\n",
        "        return result\n",
        "\n",
        "    def get_stream_lines(self):\n",
        "        func = self.vector_field_func\n",
        "        if self.production_quality_flow:\n",
        "            delta_x = 0.5\n",
        "            delta_y = 0.1\n",
        "        else:\n",
        "            delta_x = 1\n",
        "            # delta_y = 1\n",
        "            delta_y = 0.1\n",
        "        return StreamLines(\n",
        "            func,\n",
        "            start_points_generator_config={\n",
        "                \"x_min\": -8,\n",
        "                \"x_max\": -7,\n",
        "                \"y_min\": -4,\n",
        "                \"y_max\": 4,\n",
        "                \"delta_x\": delta_x,\n",
        "                \"delta_y\": delta_y,\n",
        "                \"n_repeats\": 1,\n",
        "                \"noise_factor\": 0.1,\n",
        "            },\n",
        "            stroke_width=2,\n",
        "            virtual_time=15,\n",
        "        )\n",
        "\n",
        "    def get_stream_lines_animation(self, stream_lines):\n",
        "        if self.production_quality_flow:\n",
        "            line_anim_class = ShowPassingFlashWithThinningStrokeWidth\n",
        "        else:\n",
        "            line_anim_class = ShowPassingFlash\n",
        "        return AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            line_anim_class=line_anim_class,\n",
        "        )\n",
        "\n",
        "\n",
        "class OkayNotToUnderstand(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"It's okay not to \\\\\\\\ understand this just yet.\"\n",
        "        )\n",
        "        morty = Mortimer()\n",
        "        morty.change(\"confused\")\n",
        "        words.next_to(morty, UP)\n",
        "        self.add(morty, words)\n",
        "\n",
        "\n",
        "class ThatsKindOfInteresting(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Cool!\", target_mode=\"hooray\",\n",
        "            index=2,\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ElectricField(CylinderModel, MovingCameraScene):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.setup_warped_grid()\n",
        "        self.show_uniform_field()\n",
        "        self.show_moving_charges()\n",
        "        self.show_field_lines()\n",
        "\n",
        "    def setup_warped_grid(self):\n",
        "        warped_grid = self.warped_grid = self.get_warpable_grid()\n",
        "        warped_grid.save_state()\n",
        "        func_label = self.get_func_label()\n",
        "        unit_circle = self.unit_circle = Circle(\n",
        "            radius=self.plane.unit_size,\n",
        "            stroke_color=YELLOW,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1\n",
        "        )\n",
        "\n",
        "        self.add_foreground_mobjects(self.title, func_label, unit_circle)\n",
        "        self.remove(self.plane)\n",
        "        self.play(\n",
        "            warped_grid.apply_complex_function, inverse_joukowsky_map,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_uniform_field(self):\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            lambda p: UP,\n",
        "            colors=[BLUE_E, WHITE, RED]\n",
        "        )\n",
        "        protons, electrons = groups = [\n",
        "            VGroup(*[method(radius=0.2) for x in range(20)])\n",
        "            for method in (get_proton, get_electron)\n",
        "        ]\n",
        "        for group in groups:\n",
        "            group.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            random.shuffle(group.submobjects)\n",
        "        protons.next_to(FRAME_HEIGHT * DOWN / 2, DOWN)\n",
        "        electrons.next_to(FRAME_HEIGHT * UP / 2, UP)\n",
        "\n",
        "        self.play(\n",
        "            self.warped_grid.restore,\n",
        "            FadeOut(self.unit_circle),\n",
        "            FadeOut(self.title),\n",
        "            FadeOut(self.func_label),\n",
        "            LaggedStartMap(GrowArrow, vector_field)\n",
        "        )\n",
        "        self.remove_foreground_mobjects(self.title, self.func_label)\n",
        "        self.wait()\n",
        "        for group, vect in (protons, UP), (electrons, DOWN):\n",
        "            self.play(LaggedStartMap(\n",
        "                ApplyMethod, group,\n",
        "                lambda m: (m.shift, (FRAME_HEIGHT + 1) * vect),\n",
        "                run_time=3,\n",
        "                rate_func=rush_into\n",
        "            ))\n",
        "\n",
        "    def show_moving_charges(self):\n",
        "        unit_circle = self.unit_circle\n",
        "\n",
        "        protons = VGroup(*[\n",
        "            get_proton().move_to(\n",
        "                rotate_vector(0.275 * n * RIGHT, angle)\n",
        "            )\n",
        "            for n in range(4)\n",
        "            for angle in np.arange(\n",
        "                0, TAU, TAU / (6 * n) if n > 0 else TAU\n",
        "            )\n",
        "        ])\n",
        "        jiggling_protons = JigglingSubmobjects(protons)\n",
        "        electrons = VGroup(*[\n",
        "            get_electron().move_to(\n",
        "                proton.get_center() +\n",
        "                proton.radius * rotate_vector(RIGHT, angle)\n",
        "            )\n",
        "            for proton in protons\n",
        "            for angle in [np.random.random() * TAU]\n",
        "        ])\n",
        "        jiggling_electrons = JigglingSubmobjects(electrons)\n",
        "        electrons.generate_target()\n",
        "        for electron in electrons.target:\n",
        "            y_part = electron.get_center()[1]\n",
        "            if y_part > 0:\n",
        "                electron.shift(2 * y_part * DOWN)\n",
        "\n",
        "        # New vector field\n",
        "        def new_electric_field(point):\n",
        "            if get_norm(point) < 1:\n",
        "                return ORIGIN\n",
        "            vect = cylinder_flow_vector_field(point)\n",
        "            return rotate_vector(vect, 90 * DEGREES)\n",
        "        new_vector_field = VectorField(\n",
        "            new_electric_field,\n",
        "            colors=self.vector_field.colors\n",
        "        )\n",
        "\n",
        "        warped_grid = self.warped_grid\n",
        "\n",
        "        self.play(GrowFromCenter(unit_circle))\n",
        "        self.add(jiggling_protons, jiggling_electrons)\n",
        "        self.add_foreground_mobjects(\n",
        "            self.vector_field, unit_circle, protons, electrons\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(VFadeIn, protons),\n",
        "            LaggedStartMap(VFadeIn, electrons),\n",
        "        )\n",
        "        self.play(\n",
        "            self.camera.frame.scale, 0.7,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(electrons),  # More indication?\n",
        "            warped_grid.apply_complex_function, inverse_joukowsky_map,\n",
        "            Transform(\n",
        "                self.vector_field,\n",
        "                new_vector_field\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "    def show_field_lines(self):\n",
        "        h_lines = VGroup(*[\n",
        "            Line(\n",
        "                5 * LEFT, 5 * RIGHT,\n",
        "                path_arc=0,\n",
        "                n_arc_anchors=50,\n",
        "                stroke_color=GREY_B,\n",
        "                stroke_width=2,\n",
        "            ).shift(y * UP)\n",
        "            for y in np.arange(-3, 3.25, 0.25)\n",
        "            if y != 0\n",
        "        ])\n",
        "        h_lines.apply_complex_function(inverse_joukowsky_map)\n",
        "        for h_line in h_lines:\n",
        "            h_line.save_state()\n",
        "\n",
        "        voltage = DecimalNumber(\n",
        "            10, num_decimal_places=1,\n",
        "            unit=\"\\\\, V\",\n",
        "            color=YELLOW,\n",
        "            include_background_rectangle=True,\n",
        "        )\n",
        "        vp_prop = 0.1\n",
        "        voltage_point = VectorizedPoint(\n",
        "            h_lines[4].point_from_proportion(vp_prop)\n",
        "        )\n",
        "\n",
        "        def get_voltage(dummy_arg):\n",
        "            y = voltage_point.get_center()[1]\n",
        "            return 10 - y\n",
        "\n",
        "        voltage_update = voltage.add_updater(\n",
        "            lambda d: d.set_value(get_voltage),\n",
        "        )\n",
        "        voltage.add_updater(\n",
        "            lambda d: d.next_to(\n",
        "                voltage_point, UP, SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(\n",
        "            h_lines,\n",
        "            run_time=2,\n",
        "            lag_ratio=0\n",
        "        ))\n",
        "        self.add(voltage_update)\n",
        "        self.add_foreground_mobjects(voltage)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                voltage, lambda m, a: m.set_fill(opacity=a)\n",
        "            ),\n",
        "            h_lines[4].set_stroke, YELLOW, 4,\n",
        "        )\n",
        "        for hl1, hl2 in zip(h_lines[4:], h_lines[5:]):\n",
        "            self.play(\n",
        "                voltage_point.move_to,\n",
        "                hl2.point_from_proportion(vp_prop),\n",
        "                hl1.restore,\n",
        "                hl2.set_stroke, YELLOW, 3,\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class AskQuestions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        div_tex = OldTex(\"\\\\nabla \\\\cdot\", vec_tex(\"v\"))\n",
        "        curl_tex = OldTex(\"\\\\nabla \\\\times\", vec_tex(\"v\"))\n",
        "        div_name = OldTexText(\"Divergence\")\n",
        "        curl_name = OldTexText(\"Curl\")\n",
        "        div = VGroup(div_name, div_tex)\n",
        "        curl = VGroup(curl_name, curl_tex)\n",
        "        for group in div, curl:\n",
        "            group[1].set_color_by_tex(vec_tex(\"v\"), YELLOW)\n",
        "            group.arrange(DOWN)\n",
        "        topics = VGroup(div, curl)\n",
        "        topics.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        topics.move_to(self.hold_up_spot, DOWN)\n",
        "        div.save_state()\n",
        "        div.move_to(self.hold_up_spot, DOWN)\n",
        "        screen = self.screen\n",
        "\n",
        "        self.student_says(\n",
        "            \"What does fluid flow have \\\\\\\\ to do with electricity?\",\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"And you mentioned \\\\\\\\ complex numbers?\",\n",
        "            index=0,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeInFromDown(div),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeOut(self.students[0].bubble),\n",
        "            FadeOut(self.students[0].bubble.content),\n",
        "            self.change_students(*[\"pondering\"] * 3)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(curl),\n",
        "            div.restore\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(self.screen)\n",
        "        self.wait()\n",
        "        self.play_all_student_changes(\"hooray\", look_at=screen)\n",
        "        self.wait(3)\n",
        "\n",
        "        topics.generate_target()\n",
        "        topics.target.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        arrow = OldTex(\"\\\\leftrightarrow\")\n",
        "        arrow.scale(2)\n",
        "        arrow.next_to(topics.target, RIGHT, buff=LARGE_BUFF)\n",
        "        screen.next_to(arrow, RIGHT, LARGE_BUFF)\n",
        "        complex_analysis = OldTexText(\"Complex analysis\")\n",
        "        complex_analysis.next_to(screen, UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(topics),\n",
        "            self.change_students(\n",
        "                \"confused\", \"sassy\", \"erm\",\n",
        "                look_at=topics.target\n",
        "            ),\n",
        "            self.teacher.change, \"pondering\", screen\n",
        "        )\n",
        "        self.play(\n",
        "            Write(arrow),\n",
        "            FadeInFromDown(complex_analysis)\n",
        "        )\n",
        "        self.look_at(screen)\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class ScopeMeiosis(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"flip_at_start\": True,\n",
        "            \"color\": GREY_BROWN,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DR,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        section_titles = VGroup(*list(map(TexText, [\n",
        "            \"Background on div/curl\",\n",
        "            \"Conformal maps\",\n",
        "            \"Conformal map $\\\\Rightarrow\" +\n",
        "            \"\\\\text{div}\\\\textbf{F} = \" +\n",
        "            \"\\\\text{curl}\\\\textbf{F} = 0$\",\n",
        "            \"Complex derivatives\",\n",
        "        ])))\n",
        "        sections = VGroup(*[\n",
        "            VGroup(title, self.get_lines(title, 3))\n",
        "            for title in section_titles\n",
        "        ])\n",
        "        sections.arrange(\n",
        "            DOWN, buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        sections.to_edge(UP)\n",
        "\n",
        "        top_title = section_titles[0]\n",
        "        lower_sections = sections[1:]\n",
        "\n",
        "        self.add(sections)\n",
        "        modes = [\n",
        "            \"pondering\",\n",
        "            \"pondering\",\n",
        "            \"bump\",\n",
        "            \"bump\",\n",
        "            \"concerned_musician\",\n",
        "            \"concerned_musician\",\n",
        "        ]\n",
        "\n",
        "        for n, mode in zip(list(range(6)), modes):\n",
        "            if n % 2 == 1:\n",
        "                top_title = lines\n",
        "                lines = self.get_lines(top_title, 4)\n",
        "            else:\n",
        "                lines = self.get_lines(top_title, 6)\n",
        "            lower_sections.generate_target()\n",
        "            lower_sections.target.next_to(\n",
        "                lines, DOWN, MED_LARGE_BUFF, LEFT,\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(lines),\n",
        "                MoveToTarget(lower_sections),\n",
        "                morty.change, mode, lines,\n",
        "            )\n",
        "\n",
        "    def get_lines(self, title, n_lines):\n",
        "        lines = VGroup(*[\n",
        "            Line(3 * LEFT, 3 * RIGHT, color=GREY_B)\n",
        "            for x in range(n_lines)\n",
        "        ])\n",
        "        lines.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        lines.next_to(\n",
        "            title, DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        lines[-1].pointwise_become_partial(\n",
        "            lines[-1], 0, random.random()\n",
        "        )\n",
        "        return lines\n",
        "\n",
        "\n",
        "class WhyAreYouTellingUsThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Cool story bro...\\\\\\\\ how about the actual math?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.play_student_changes(\"angry\", \"sassy\", \"angry\")\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class TopicsAndConnections(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot(8 * np.array([\n",
        "                random.random(),\n",
        "                random.random(),\n",
        "                0\n",
        "            ]))\n",
        "            for n in range(5)\n",
        "        ])\n",
        "        topics = VGroup(*[\n",
        "            OldTexText(word).next_to(\n",
        "                dot, RIGHT, SMALL_BUFF\n",
        "            )\n",
        "            for dot, word in zip(dots, [\n",
        "                \"Divergence/curl\",\n",
        "                \"Fluid flow\",\n",
        "                \"Electricity and magnetism\",\n",
        "                \"Conformal maps\",\n",
        "                \"Complex numbers\"\n",
        "            ])\n",
        "        ])\n",
        "        for topic in topics:\n",
        "            topic.add_to_back(\n",
        "                topic.copy().set_stroke(BLACK, 2)\n",
        "            )\n",
        "\n",
        "        VGroup(dots, topics).center()\n",
        "        for dot in dots:\n",
        "            dot.save_state()\n",
        "            dot.scale(3)\n",
        "            dot.set_fill(opacity=0)\n",
        "\n",
        "        connections = VGroup(*[\n",
        "            DashedLine(d1.get_center(), d2.get_center())\n",
        "            for d1, d2 in it.combinations(dots, 2)\n",
        "        ])\n",
        "        connections.set_stroke(YELLOW, 2)\n",
        "\n",
        "        full_rect = FullScreenFadeRectangle()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, dots,\n",
        "                lambda d: (d.restore,)\n",
        "            ),\n",
        "            LaggedStartMap(Write, topics),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, connections),\n",
        "            Animation(topics),\n",
        "            Animation(dots),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(full_rect),\n",
        "            Animation(topics[0]),\n",
        "            Animation(dots[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OnToTheLesson(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"On to the lesson!\")\n",
        "        words.scale(1.5)\n",
        "        self.add(words)\n",
        "        self.play(FadeInFromDown(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IntroduceVectorField(Scene):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            # \"delta_x\": 2,\n",
        "            # \"delta_y\": 2,\n",
        "            \"delta_x\": 0.5,\n",
        "            \"delta_y\": 0.5,\n",
        "        },\n",
        "        \"stream_line_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                # \"delta_x\": 1,\n",
        "                # \"delta_y\": 1,\n",
        "                \"delta_x\": 0.25,\n",
        "                \"delta_y\": 0.25,\n",
        "            },\n",
        "            \"virtual_time\": 3,\n",
        "        },\n",
        "        \"stream_line_animation_config\": {\n",
        "            # \"line_anim_class\": ShowPassingFlash,\n",
        "            \"line_anim_class\": ShowPassingFlashWithThinningStrokeWidth,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.points_to_vectors()\n",
        "        self.show_fluid_flow()\n",
        "        self.show_gravitational_force()\n",
        "        self.show_magnetic_force()\n",
        "        self.show_fluid_flow()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = NumberPlane()\n",
        "        plane.add_coordinates()\n",
        "        plane.remove(plane.coordinate_labels[-1])\n",
        "        self.add(plane)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Vector field\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        title.add_background_rectangle(opacity=1, buff=SMALL_BUFF)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def points_to_vectors(self):\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            four_swirls_function,\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        dots = VGroup()\n",
        "        for vector in vector_field:\n",
        "            dot = Dot(radius=0.05)\n",
        "            dot.move_to(vector.get_start())\n",
        "            dot.target = vector\n",
        "            dots.add(dot)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, dots))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(MoveToTarget, dots, remover=True))\n",
        "        self.add(vector_field)\n",
        "        self.wait()\n",
        "\n",
        "    def show_fluid_flow(self):\n",
        "        vector_field = self.vector_field\n",
        "        stream_lines = StreamLines(\n",
        "            vector_field.func,\n",
        "            **self.stream_line_config\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            **self.stream_line_animation_config\n",
        "        )\n",
        "\n",
        "        self.add(stream_line_animation)\n",
        "        self.play(\n",
        "            vector_field.set_fill, {\"opacity\": 0.5}\n",
        "        )\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            vector_field.set_fill, {\"opacity\": 1},\n",
        "            VFadeOut(stream_line_animation.mobject),\n",
        "        )\n",
        "        self.remove(stream_line_animation)\n",
        "\n",
        "    def show_gravitational_force(self):\n",
        "        earth = self.earth = ImageMobject(\"earth\")\n",
        "        moon = self.moon = ImageMobject(\"moon\", height=1)\n",
        "        earth_center = 3 * RIGHT + 2 * UP\n",
        "        moon_center = 3 * LEFT + DOWN\n",
        "        earth.move_to(earth_center)\n",
        "        moon.move_to(moon_center)\n",
        "\n",
        "        gravity_func = get_force_field_func((earth_center, -6), (moon_center, -1))\n",
        "        gravity_field = VectorField(\n",
        "            gravity_func,\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "\n",
        "        self.add_foreground_mobjects(earth, moon)\n",
        "        self.play(\n",
        "            GrowFromCenter(earth),\n",
        "            GrowFromCenter(moon),\n",
        "            Transform(self.vector_field, gravity_field),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.vector_field.func = gravity_field.func\n",
        "        self.wait()\n",
        "\n",
        "    def show_magnetic_force(self):\n",
        "        magnetic_func = get_force_field_func(\n",
        "            (3 * LEFT, -1), (3 * RIGHT, +1)\n",
        "        )\n",
        "        magnetic_field = VectorField(\n",
        "            magnetic_func,\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        magnet = VGroup(*[\n",
        "            Rectangle(\n",
        "                width=3.5,\n",
        "                height=1,\n",
        "                stroke_width=0,\n",
        "                fill_opacity=1,\n",
        "                fill_color=color\n",
        "            )\n",
        "            for color in (BLUE, RED)\n",
        "        ])\n",
        "        magnet.arrange(RIGHT, buff=0)\n",
        "        for char, vect in (\"S\", LEFT), (\"N\", RIGHT):\n",
        "            letter = OldTexText(char)\n",
        "            edge = magnet.get_edge_center(vect)\n",
        "            letter.next_to(edge, -vect, buff=MED_LARGE_BUFF)\n",
        "            magnet.add(letter)\n",
        "\n",
        "        self.add_foreground_mobjects(magnet)\n",
        "        self.play(\n",
        "            self.earth.scale, 0,\n",
        "            self.moon.scale, 0,\n",
        "            DrawBorderThenFill(magnet),\n",
        "            Transform(self.vector_field, magnetic_field),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.vector_field.func = magnetic_field.func\n",
        "        self.remove_foreground_mobjects(self.earth, self.moon)\n",
        "\n",
        "\n",
        "class QuickNoteOnDrawingThese(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Quick note on \\\\\\\\ drawing vector fields\",\n",
        "            bubble_config={\"width\": 5, \"height\": 3},\n",
        "            added_anims=[self.change_students(\n",
        "                \"confused\", \"erm\", \"sassy\"\n",
        "            )]\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShorteningLongVectors(IntroduceVectorField):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_title()\n",
        "        self.contrast_adjusted_and_non_adjusted()\n",
        "\n",
        "    def contrast_adjusted_and_non_adjusted(self):\n",
        "        func = four_swirls_function\n",
        "        unadjusted = VectorField(\n",
        "            func, length_func=lambda n: n, colors=[WHITE],\n",
        "        )\n",
        "        adjusted = VectorField(func)\n",
        "        for v1, v2 in zip(adjusted, unadjusted):\n",
        "            v1.save_state()\n",
        "            v1.target = v2\n",
        "\n",
        "        self.add(adjusted)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, adjusted,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, adjusted,\n",
        "            lambda m: (m.restore,),\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TimeDependentVectorField(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ChangingElectricField(Scene):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        particles = self.get_particles()\n",
        "        vector_field = self.get_vector_field()\n",
        "\n",
        "        def update_vector_field(vector_field):\n",
        "            new_field = self.get_vector_field()\n",
        "            Transform(vector_field, new_field).update(1)\n",
        "            vector_field.func = new_field.func\n",
        "\n",
        "        def update_particles(particles, dt):\n",
        "            func = vector_field.func\n",
        "            for particle in particles:\n",
        "                force = func(particle.get_center())\n",
        "                particle.velocity += force * dt\n",
        "                particle.shift(particle.velocity * dt)\n",
        "\n",
        "        self.add(\n",
        "            Mobject.add_updater(vector_field, update_vector_field),\n",
        "            Mobject.add_updater(particles, update_particles),\n",
        "        )\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_particles(self):\n",
        "        particles = self.particles = VGroup()\n",
        "        for n in range(9):\n",
        "            if n % 2 == 0:\n",
        "                particle = get_proton(radius=0.2)\n",
        "                particle.charge = +1\n",
        "            else:\n",
        "                particle = get_electron(radius=0.2)\n",
        "                particle.charge = -1\n",
        "            particle.velocity = np.random.normal(0, 0.1, 3)\n",
        "            particles.add(particle)\n",
        "            particle.shift(np.random.normal(0, 0.2, 3))\n",
        "\n",
        "        particles.arrange_in_grid(buff=LARGE_BUFF)\n",
        "        return particles\n",
        "\n",
        "    def get_vector_field(self):\n",
        "        func = get_force_field_func(*list(zip(\n",
        "            list(map(Mobject.get_center, self.particles)),\n",
        "            [p.charge for p in self.particles]\n",
        "        )))\n",
        "        self.vector_field = VectorField(func, **self.vector_field_config)\n",
        "        return self.vector_field\n",
        "\n",
        "\n",
        "class InsertAirfoildTODO(TODOStub):\n",
        "    CONFIG = {\"message\": \"Insert airfoil flow animation\"}\n",
        "\n",
        "\n",
        "class ThreeDVectorField(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ThreeDVectorFieldEquation(Scene):\n",
        "    def construct(self):\n",
        "        vector = Matrix([\n",
        "            \"yz\",\n",
        "            \"xz\",\n",
        "            \"xy\",\n",
        "        ])\n",
        "        vector.set_height(FRAME_HEIGHT - 1)\n",
        "        self.add(vector)\n",
        "\n",
        "\n",
        "class GravityFluidFlow(IntroduceVectorField):\n",
        "    def construct(self):\n",
        "        self.vector_field = VectorField(\n",
        "            lambda p: np.array(ORIGIN),\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        self.show_gravitational_force()\n",
        "        self.show_fluid_flow()\n",
        "\n",
        "\n",
        "class TotallyToScale(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Totally drawn to scale. \\\\\\\\ Don't even worry about it.\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.add_background_rectangle()\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# TODO: Revisit this\n",
        "class FluidFlowAsHillGradient(CylinderModel, ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"production_quality_flow\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        def potential(point):\n",
        "            x, y = point[:2]\n",
        "            result = 2 - 0.01 * op.mul(\n",
        "                ((x - 4)**2 + y**2),\n",
        "                ((x + 4)**2 + y**2)\n",
        "            )\n",
        "            return max(-10, result)\n",
        "\n",
        "        vector_field_func = negative_gradient(potential)\n",
        "\n",
        "        stream_lines = StreamLines(\n",
        "            vector_field_func,\n",
        "            virtual_time=3,\n",
        "            color_lines_by_magnitude=False,\n",
        "            start_points_generator_config={\n",
        "                \"delta_x\": 0.2,\n",
        "                \"delta_y\": 0.2,\n",
        "            }\n",
        "        )\n",
        "        for line in stream_lines:\n",
        "            line.get_points()[:, 2] = np.apply_along_axis(\n",
        "                potential, 1, line.get_points()\n",
        "            )\n",
        "        stream_lines_animation = self.get_stream_lines_animation(\n",
        "            stream_lines\n",
        "        )\n",
        "\n",
        "        plane = NumberPlane()\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(stream_lines_animation)\n",
        "        self.wait(3)\n",
        "        self.begin_ambient_camera_rotation(rate=0.1)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class DefineDivergence(ChangingElectricField):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            \"length_func\": lambda norm: 0.3,\n",
        "            \"min_magnitude\": 0,\n",
        "            \"max_magnitude\": 1,\n",
        "        },\n",
        "        \"stream_line_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 0.125,\n",
        "                \"delta_y\": 0.125,\n",
        "            },\n",
        "            \"virtual_time\": 5,\n",
        "            \"n_anchors_per_line\": 10,\n",
        "            \"min_magnitude\": 0,\n",
        "            \"max_magnitude\": 1,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"stream_line_animation_config\": {\n",
        "            \"line_anim_class\": ShowPassingFlash,\n",
        "        },\n",
        "        \"flow_time\": 10,\n",
        "        \"random_seed\": 7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.draw_vector_field()\n",
        "        self.show_flow()\n",
        "        self.point_out_sources_and_sinks()\n",
        "        self.show_divergence_values()\n",
        "\n",
        "    def draw_vector_field(self):\n",
        "        particles = self.get_particles()\n",
        "        random.shuffle(particles.submobjects)\n",
        "        particles.remove(particles[0])\n",
        "        particles.arrange_in_grid(\n",
        "            n_cols=4, buff=3\n",
        "        )\n",
        "        for particle in particles:\n",
        "            particle.shift(\n",
        "                np.random.normal(0, 0.75) * RIGHT,\n",
        "                np.random.normal(0, 0.5) * UP,\n",
        "            )\n",
        "            particle.shift_onto_screen(buff=2 * LARGE_BUFF)\n",
        "            particle.charge *= 0.125\n",
        "        vector_field = self.get_vector_field()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, vector_field),\n",
        "            LaggedStartMap(GrowFromCenter, particles),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, particles))\n",
        "\n",
        "    def show_flow(self):\n",
        "        stream_lines = StreamLines(\n",
        "            self.vector_field.func,\n",
        "            **self.stream_line_config\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            **self.stream_line_animation_config\n",
        "        )\n",
        "        self.add(stream_line_animation)\n",
        "        self.wait(self.flow_time)\n",
        "\n",
        "    def point_out_sources_and_sinks(self):\n",
        "        particles = self.particles\n",
        "        self.positive_points, self.negative_points = [\n",
        "            [\n",
        "                particle.get_center()\n",
        "                for particle in particles\n",
        "                if u * particle.charge > 0\n",
        "            ]\n",
        "            for u in (+1, -1)\n",
        "        ]\n",
        "        pair_of_vector_circle_groups = VGroup()\n",
        "        for point_set in self.positive_points, self.negative_points:\n",
        "            vector_circle_groups = VGroup()\n",
        "            for point in point_set:\n",
        "                vector_circle_group = VGroup()\n",
        "                for angle in np.linspace(0, TAU, 12, endpoint=False):\n",
        "                    step = 0.5 * rotate_vector(RIGHT, angle)\n",
        "                    vect = self.vector_field.get_vector(point + step)\n",
        "                    vect.set_color(WHITE)\n",
        "                    vect.set_stroke(width=2)\n",
        "                    vector_circle_group.add(vect)\n",
        "                vector_circle_groups.add(vector_circle_group)\n",
        "            pair_of_vector_circle_groups.add(vector_circle_groups)\n",
        "\n",
        "            self.play(\n",
        "                self.vector_field.set_fill, {\"opacity\": 0.5},\n",
        "                LaggedStartMap(\n",
        "                    LaggedStartMap, vector_circle_groups,\n",
        "                    lambda vcg: (GrowArrow, vcg),\n",
        "                ),\n",
        "            )\n",
        "            self.wait(4)\n",
        "            self.play(FadeOut(vector_circle_groups))\n",
        "        self.play(self.vector_field.set_fill, {\"opacity\": 1})\n",
        "        self.positive_vector_circle_groups = pair_of_vector_circle_groups[0]\n",
        "        self.negative_vector_circle_groups = pair_of_vector_circle_groups[1]\n",
        "        self.wait()\n",
        "\n",
        "    def show_divergence_values(self):\n",
        "        positive_points = self.positive_points\n",
        "        negative_points = self.negative_points\n",
        "        div_func = divergence(self.vector_field.func)\n",
        "\n",
        "        circle = Circle(color=WHITE, radius=0.2)\n",
        "        circle.add(Dot(circle.get_center(), radius=0.02))\n",
        "        circle.move_to(positive_points[0])\n",
        "\n",
        "        div_tex = OldTex(\n",
        "            \"\\\\text{div} \\\\, \\\\textbf{F}(x, y) = \"\n",
        "        )\n",
        "        div_tex.add_background_rectangle()\n",
        "        div_tex_update = Mobject.add_updater(\n",
        "            div_tex, lambda m: m.next_to(circle, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        div_value = DecimalNumber(\n",
        "            0,\n",
        "            num_decimal_places=1,\n",
        "            include_background_rectangle=True,\n",
        "            include_sign=True,\n",
        "        )\n",
        "        div_value_update = ContinualChangingDecimal(\n",
        "            div_value,\n",
        "            lambda a: np.round(div_func(circle.get_center()), 1),\n",
        "            position_update_func=lambda m: m.next_to(div_tex, RIGHT, SMALL_BUFF),\n",
        "            include_sign=True,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            FadeIn(div_tex),\n",
        "            FadeIn(div_value),\n",
        "        )\n",
        "        self.add(div_tex_update)\n",
        "        self.add(div_value_update)\n",
        "\n",
        "        self.wait()\n",
        "        for point in positive_points[1:-1]:\n",
        "            self.play(circle.move_to, point)\n",
        "            self.wait(1.5)\n",
        "        for point in negative_points:\n",
        "            self.play(circle.move_to, point)\n",
        "            self.wait(2)\n",
        "        self.wait(4)\n",
        "        # self.remove(div_tex_update)\n",
        "        # self.remove(div_value_update)\n",
        "        # self.play(\n",
        "        #     ApplyMethod(circle.scale, 0, remover=True),\n",
        "        #     FadeOut(div_tex),\n",
        "        #     FadeOut(div_value),\n",
        "        # )\n",
        "\n",
        "\n",
        "class DefineDivergenceJustFlow(DefineDivergence):\n",
        "    CONFIG = {\n",
        "        \"flow_time\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.draw_vector_field()\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.clear()\n",
        "        self.show_flow()\n",
        "\n",
        "\n",
        "class DefineDivergenceSymbols(Scene):\n",
        "    def construct(self):\n",
        "        tex_mob = OldTex(\n",
        "            \"\\\\text{div}\",\n",
        "            \"\\\\textbf{F}\",\n",
        "            \"(x, y)\",\n",
        "            \"=\",\n",
        "        )\n",
        "        div, F, xy, eq = tex_mob\n",
        "        output = DecimalNumber(0, include_sign=True)\n",
        "        output.next_to(tex_mob, RIGHT)\n",
        "        time_tracker = ValueTracker()\n",
        "        always_shift(time_tracker, rate=1)\n",
        "        self.add(time_tracker)\n",
        "        output_animation = ContinualChangingDecimal(\n",
        "            output, lambda a: 3 * np.cos(int(time_tracker.get_value())),\n",
        "        )\n",
        "\n",
        "        F.set_color(BLUE)\n",
        "        xy.set_color(YELLOW)\n",
        "\n",
        "        F_brace = Brace(F, UP, buff=SMALL_BUFF)\n",
        "        F_label = F_brace.get_text(\n",
        "            \"Vector field function\",\n",
        "        )\n",
        "        F_label.match_color(F)\n",
        "        xy_brace = Brace(xy, DOWN, buff=SMALL_BUFF)\n",
        "        xy_label = xy_brace.get_text(\"Some point\")\n",
        "        xy_label.match_color(xy)\n",
        "        output_brace = Brace(output, UP, buff=SMALL_BUFF)\n",
        "        output_label = output_brace.get_text(\n",
        "            \"Measure of how much \\\\\\\\ \"\n",
        "            \"$(x, y)$ ``generates'' fluid\"\n",
        "        )\n",
        "        brace_label_pairs = [\n",
        "            (F_brace, F_label),\n",
        "            (xy_brace, xy_label),\n",
        "            (output_brace, output_label),\n",
        "        ]\n",
        "\n",
        "        self.add(tex_mob, output_animation)\n",
        "        fade_anims = []\n",
        "        for brace, label in brace_label_pairs:\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                FadeInFromDown(label),\n",
        "                *fade_anims\n",
        "            )\n",
        "            self.wait(2)\n",
        "            fade_anims = list(map(FadeOut, [brace, label]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DivergenceAtSlowFastPoint(Scene):\n",
        "    CONFIG = {\n",
        "        \"vector_field_config\": {\n",
        "            \"length_func\": lambda norm: 0.1 + 0.4 * norm / 4.0,\n",
        "            \"min_magnitude\": 0,\n",
        "            \"max_magnitude\": 3,\n",
        "        },\n",
        "        \"stream_lines_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 0.125,\n",
        "                \"delta_y\": 0.125,\n",
        "            },\n",
        "            \"virtual_time\": 1,\n",
        "            \"min_magnitude\": 0,\n",
        "            \"max_magnitude\": 3,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        def func(point):\n",
        "            return 3 * sigmoid(point[0]) * RIGHT\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            func, **self.vector_field_config\n",
        "        )\n",
        "\n",
        "        circle = Circle(color=WHITE)\n",
        "        slow_words = OldTexText(\"Slow flow in\")\n",
        "        fast_words = OldTexText(\"Fast flow out\")\n",
        "        words = VGroup(slow_words, fast_words)\n",
        "        for word, vect in zip(words, [LEFT, RIGHT]):\n",
        "            word.add_background_rectangle()\n",
        "            word.next_to(circle, vect)\n",
        "\n",
        "        div_tex = OldTex(\n",
        "            \"\\\\text{div}\\\\,\\\\textbf{F}(x, y) > 0\"\n",
        "        )\n",
        "        div_tex.add_background_rectangle()\n",
        "        div_tex.next_to(circle, UP)\n",
        "\n",
        "        self.add(vector_field)\n",
        "        self.add_foreground_mobjects(circle, div_tex)\n",
        "        self.begin_flow()\n",
        "        self.wait(2)\n",
        "        for word in words:\n",
        "            self.add_foreground_mobjects(word)\n",
        "            self.play(Write(word))\n",
        "        self.wait(8)\n",
        "\n",
        "    def begin_flow(self):\n",
        "        stream_lines = StreamLines(\n",
        "            self.vector_field.func,\n",
        "            **self.stream_lines_config\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(stream_lines)\n",
        "        stream_line_animation.update(3)\n",
        "        self.add(stream_line_animation)\n",
        "\n",
        "\n",
        "class DivergenceAsNewFunction(Scene):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.show_vector_field_function()\n",
        "        self.show_divergence_function()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = NumberPlane()\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "\n",
        "    def show_vector_field_function(self):\n",
        "        func = self.func\n",
        "        unscaled_vector_field = VectorField(\n",
        "            func,\n",
        "            length_func=lambda norm: norm,\n",
        "            colors=[BLUE_C, YELLOW, RED],\n",
        "            delta_x=np.inf,\n",
        "            delta_y=np.inf,\n",
        "        )\n",
        "\n",
        "        in_dot = Dot(color=PINK)\n",
        "        in_dot.move_to(3.75 * LEFT + 1.25 * UP)\n",
        "\n",
        "        def get_input():\n",
        "            return in_dot.get_center()\n",
        "\n",
        "        def get_out_vect():\n",
        "            return unscaled_vector_field.get_vector(get_input())\n",
        "\n",
        "        # Tex\n",
        "        func_tex = OldTex(\n",
        "            \"\\\\textbf{F}(\", \"+0.00\", \",\", \"+0.00\", \")\", \"=\",\n",
        "        )\n",
        "        dummy_in_x, dummy_in_y = func_tex.get_parts_by_tex(\"+0.00\")\n",
        "        func_tex.add_background_rectangle()\n",
        "        rhs = DecimalMatrix(\n",
        "            [[0], [0]],\n",
        "            element_to_mobject_config={\n",
        "                \"num_decimal_places\": 2,\n",
        "                \"include_sign\": True,\n",
        "            },\n",
        "            include_background_rectangle=True\n",
        "        )\n",
        "        rhs.next_to(func_tex, RIGHT)\n",
        "        dummy_out_x, dummy_out_y = rhs.get_mob_matrix().flatten()\n",
        "\n",
        "        VGroup(func_tex, rhs).to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        VGroup(\n",
        "            dummy_in_x, dummy_in_y,\n",
        "            dummy_out_x, dummy_out_y,\n",
        "        ).set_fill(BLACK, opacity=0)\n",
        "\n",
        "        # Changing decimals\n",
        "        in_x, in_y, out_x, out_y = [\n",
        "            DecimalNumber(0, include_sign=True)\n",
        "            for x in range(4)\n",
        "        ]\n",
        "        VGroup(in_x, in_y).set_color(in_dot.get_color())\n",
        "        VGroup(out_x, out_y).set_color(get_out_vect().get_fill_color())\n",
        "        in_x_update = ContinualChangingDecimal(\n",
        "            in_x, lambda a: get_input()[0],\n",
        "            position_update_func=lambda m: m.move_to(dummy_in_x)\n",
        "        )\n",
        "        in_y_update = ContinualChangingDecimal(\n",
        "            in_y, lambda a: get_input()[1],\n",
        "            position_update_func=lambda m: m.move_to(dummy_in_y)\n",
        "        )\n",
        "        out_x_update = ContinualChangingDecimal(\n",
        "            out_x, lambda a: func(get_input())[0],\n",
        "            position_update_func=lambda m: m.move_to(dummy_out_x)\n",
        "        )\n",
        "        out_y_update = ContinualChangingDecimal(\n",
        "            out_y, lambda a: func(get_input())[1],\n",
        "            position_update_func=lambda m: m.move_to(dummy_out_y)\n",
        "        )\n",
        "\n",
        "        self.add(func_tex, rhs)\n",
        "        # self.add(Mobject.add_updater(\n",
        "        #     rhs, lambda m: m.next_to(func_tex, RIGHT)\n",
        "        # ))\n",
        "\n",
        "        # Where those decimals actually change\n",
        "        self.add(in_x_update, in_y_update)\n",
        "\n",
        "        in_dot.save_state()\n",
        "        in_dot.move_to(ORIGIN)\n",
        "        self.play(in_dot.restore)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                VGroup(mob.copy().fade(1)),\n",
        "                VGroup(out_x, out_y),\n",
        "            )\n",
        "            for mob in (in_x, in_y)\n",
        "        ])\n",
        "        out_vect = get_out_vect()\n",
        "        VGroup(out_x, out_y).match_style(out_vect)\n",
        "        out_vect.save_state()\n",
        "        out_vect.move_to(rhs)\n",
        "        out_vect.set_fill(opacity=0)\n",
        "        self.play(out_vect.restore)\n",
        "        self.out_vect_update = Mobject.add_updater(\n",
        "            out_vect,\n",
        "            lambda ov: Transform(ov, get_out_vect()).update(1)\n",
        "        )\n",
        "\n",
        "        self.add(self.out_vect_update)\n",
        "        self.add(out_x_update, out_y_update)\n",
        "\n",
        "        self.add(Mobject.add_updater(\n",
        "            VGroup(out_x, out_y),\n",
        "            lambda m: m.match_style(out_vect)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        for vect in DOWN, 2 * RIGHT, UP:\n",
        "            self.play(\n",
        "                in_dot.shift, 3 * vect,\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.in_dot = in_dot\n",
        "        self.out_vect = out_vect\n",
        "        self.func_equation = VGroup(func_tex, rhs)\n",
        "        self.out_x, self.out_y = out_x, out_y\n",
        "        self.in_x, self.in_y = out_x, out_y\n",
        "        self.in_x_update = in_x_update\n",
        "        self.in_y_update = in_y_update\n",
        "        self.out_x_update = out_x_update\n",
        "        self.out_y_update = out_y_update\n",
        "\n",
        "    def show_divergence_function(self):\n",
        "        vector_field = VectorField(self.func)\n",
        "        vector_field.remove(*[\n",
        "            v for v in vector_field\n",
        "            if v.get_start()[0] < 0 and v.get_start()[1] > 2\n",
        "        ])\n",
        "        vector_field.set_fill(opacity=0.5)\n",
        "        in_dot = self.in_dot\n",
        "\n",
        "        def get_neighboring_points(step_sizes=[0.3], n_angles=12):\n",
        "            point = in_dot.get_center()\n",
        "            return list(it.chain(*[\n",
        "                [\n",
        "                    point + step_size * step\n",
        "                    for step in compass_directions(n_angles)\n",
        "                ]\n",
        "                for step_size in step_sizes\n",
        "            ]))\n",
        "\n",
        "        def get_vector_ring():\n",
        "            return VGroup(*[\n",
        "                vector_field.get_vector(point)\n",
        "                for point in get_neighboring_points()\n",
        "            ])\n",
        "\n",
        "        def get_stream_lines():\n",
        "            return StreamLines(\n",
        "                self.func,\n",
        "                start_points_generator=get_neighboring_points,\n",
        "                start_points_generator_config={\n",
        "                    \"step_sizes\": np.arange(0.1, 0.5, 0.1)\n",
        "                },\n",
        "                virtual_time=1,\n",
        "                stroke_width=3,\n",
        "            )\n",
        "\n",
        "        def show_flow():\n",
        "            stream_lines = get_stream_lines()\n",
        "            random.shuffle(stream_lines.submobjects)\n",
        "            self.play(LaggedStartMap(\n",
        "                ShowCreationThenDestruction,\n",
        "                stream_lines,\n",
        "                remover=True\n",
        "            ))\n",
        "\n",
        "        vector_ring = get_vector_ring()\n",
        "        vector_ring_update = Mobject.add_updater(\n",
        "            vector_ring,\n",
        "            lambda vr: Transform(vr, get_vector_ring()).update(1)\n",
        "        )\n",
        "\n",
        "        func_tex, rhs = self.func_equation\n",
        "        out_x, out_y = self.out_x, self.out_y\n",
        "        out_x_update = self.out_x_update\n",
        "        out_y_update = self.out_y_update\n",
        "        div_tex = OldTex(\"\\\\text{div}\")\n",
        "        div_tex.add_background_rectangle()\n",
        "        div_tex.move_to(func_tex, LEFT)\n",
        "        div_tex.shift(2 * SMALL_BUFF * RIGHT)\n",
        "\n",
        "        self.remove(out_x_update, out_y_update)\n",
        "        self.remove(self.out_vect_update)\n",
        "        self.add(self.in_x_update, self.in_y_update)\n",
        "        self.play(\n",
        "            func_tex.next_to, div_tex, RIGHT, SMALL_BUFF,\n",
        "            {\"submobject_to_align\": func_tex[1][0]},\n",
        "            Write(div_tex),\n",
        "            FadeOut(self.out_vect),\n",
        "            FadeOut(out_x),\n",
        "            FadeOut(out_y),\n",
        "            FadeOut(rhs),\n",
        "        )\n",
        "        # This line is a dumb hack around a Scene bug\n",
        "        self.add(*[\n",
        "            Mobject.add_updater(\n",
        "                mob, lambda m: m.set_fill(None, 0)\n",
        "            )\n",
        "            for mob in (out_x, out_y)\n",
        "        ])\n",
        "        self.add_foreground_mobjects(div_tex)\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, vector_field),\n",
        "            LaggedStartMap(GrowArrow, vector_ring),\n",
        "        )\n",
        "        self.add(vector_ring_update)\n",
        "        self.wait()\n",
        "\n",
        "        div_func = divergence(self.func)\n",
        "        div_rhs = DecimalNumber(\n",
        "            0, include_sign=True,\n",
        "            include_background_rectangle=True\n",
        "        )\n",
        "        div_rhs_update = ContinualChangingDecimal(\n",
        "            div_rhs, lambda a: div_func(in_dot.get_center()),\n",
        "            position_update_func=lambda d: d.next_to(func_tex, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(div_rhs))\n",
        "        self.add(div_rhs_update)\n",
        "        show_flow()\n",
        "\n",
        "        for vect in 2 * RIGHT, 3 * DOWN, 2 * LEFT, 2 * LEFT:\n",
        "            self.play(in_dot.shift, vect, run_time=3)\n",
        "            show_flow()\n",
        "        self.wait()\n",
        "\n",
        "    def func(self, point):\n",
        "        x, y = point[:2]\n",
        "        return np.sin(x + y) * RIGHT + np.sin(y * x / 3) * UP\n",
        "\n",
        "\n",
        "class DivergenceZeroCondition(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"For actual (incompressible) fluid flow:\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{div} \\\\, \\\\textbf{F} = 0 \\\\quad \\\\text{everywhere}\"\n",
        "        )\n",
        "        equation.next_to(title, DOWN)\n",
        "\n",
        "        for mob in title, equation:\n",
        "            mob.add_background_rectangle(buff=MED_SMALL_BUFF / 2)\n",
        "            self.add_foreground_mobjects(mob)\n",
        "        self.wait(1)\n",
        "\n",
        "\n",
        "class PureCylinderFlow(Scene):\n",
        "    def construct(self):\n",
        "        self.add_vector_field()\n",
        "        self.begin_flow()\n",
        "        self.add_circle()\n",
        "        self.wait(5)\n",
        "\n",
        "    def add_vector_field(self):\n",
        "        vector_field = VectorField(\n",
        "            cylinder_flow_vector_field,\n",
        "        )\n",
        "        for vector in vector_field:\n",
        "            if get_norm(vector.get_start()) < 1:\n",
        "                vector_field.remove(vector)\n",
        "        vector_field.set_fill(opacity=0.75)\n",
        "        self.modify_vector_field(vector_field)\n",
        "        self.add_foreground_mobjects(vector_field)\n",
        "\n",
        "    def begin_flow(self):\n",
        "        stream_lines = StreamLines(\n",
        "            cylinder_flow_vector_field,\n",
        "            colors=[BLUE_E, BLUE_D, BLUE_C],\n",
        "            start_points_generator_config={\n",
        "                \"delta_x\": 0.125,\n",
        "                \"delta_y\": 0.125,\n",
        "            },\n",
        "            virtual_time=5,\n",
        "        )\n",
        "        self.add(stream_lines)\n",
        "        for stream_line in stream_lines:\n",
        "            if get_norm(stream_line.get_points()[0]) < 1:\n",
        "                stream_lines.remove(stream_line)\n",
        "\n",
        "        self.modify_flow(stream_lines)\n",
        "\n",
        "        stream_line_animation = AnimatedStreamLines(stream_lines)\n",
        "        stream_line_animation.update(3)\n",
        "\n",
        "        self.add(stream_line_animation)\n",
        "\n",
        "    def add_circle(self):\n",
        "        circle = Circle(\n",
        "            radius=1,\n",
        "            stroke_color=YELLOW,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        self.modify_flow(circle)\n",
        "        self.add_foreground_mobjects(circle)\n",
        "\n",
        "    def modify_flow(self, mobject):\n",
        "        pass\n",
        "\n",
        "    def modify_vector_field(self, vector_field):\n",
        "        pass\n",
        "\n",
        "\n",
        "class PureAirfoilFlow(PureCylinderFlow):\n",
        "    def modify_flow(self, mobject):\n",
        "        vect = 0.1 * LEFT + 0.2 * UP\n",
        "        mobject.scale(get_norm(vect - RIGHT))\n",
        "        mobject.shift(vect)\n",
        "        mobject.apply_complex_function(joukowsky_map)\n",
        "        return mobject\n",
        "\n",
        "    def modify_vector_field(self, vector_field):\n",
        "        def func(z):\n",
        "            w = complex(-0.1, 0.2)\n",
        "            n = abs(w - 1)\n",
        "            return joukowsky_map(inverse_joukowsky_map(z) - w / n)\n",
        "\n",
        "        def new_vector_field_func(point):\n",
        "            z = R3_to_complex(point)\n",
        "            return complex_to_R3(derivative(func)(z).conjugate())\n",
        "\n",
        "        vf = VectorField(new_vector_field_func, delta_y=0.33)\n",
        "        Transform(vector_field, vf).update(1)\n",
        "        vf.set_fill(opacity=0.5)\n",
        "\n",
        "\n",
        "class IntroduceCurl(IntroduceVectorField):\n",
        "    CONFIG = {\n",
        "        \"stream_line_animation_config\": {\n",
        "            \"line_anim_class\": ShowPassingFlash,\n",
        "        },\n",
        "        \"stream_line_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 0.125,\n",
        "                \"delta_y\": 0.125,\n",
        "            },\n",
        "            \"virtual_time\": 1,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_vector_field()\n",
        "        self.begin_flow()\n",
        "        self.show_rotation()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = Title(\n",
        "            \"Curl\",\n",
        "            match_underline_width_to_text=True,\n",
        "            scale_factor=1.5,\n",
        "        )\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def show_vector_field(self):\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            four_swirls_function,\n",
        "            **self.vector_field_config\n",
        "        )\n",
        "        vector_field.submobjects.sort(\n",
        "            key=lambda v: v.get_length()\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, vector_field))\n",
        "        self.wait()\n",
        "\n",
        "    def begin_flow(self):\n",
        "        stream_lines = StreamLines(\n",
        "            self.vector_field.func,\n",
        "            **self.stream_line_config\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "            **self.stream_line_animation_config\n",
        "        )\n",
        "\n",
        "        self.add(stream_line_animation)\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_rotation(self):\n",
        "        clockwise_arrows, counterclockwise_arrows = [\n",
        "            VGroup(*[\n",
        "                self.get_rotation_arrows(clockwise=cw).move_to(point)\n",
        "                for point in points\n",
        "            ])\n",
        "            for cw, points in [\n",
        "                (True, [2 * UP, 2 * DOWN]),\n",
        "                (False, [4 * LEFT, 4 * RIGHT]),\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        for group, u in (counterclockwise_arrows, +1), (clockwise_arrows, -1):\n",
        "            for arrows in group:\n",
        "                label = OldTex(\n",
        "                    \"\\\\text{curl} \\\\, \\\\textbf{F}\",\n",
        "                    \">\" if u > 0 else \"<\",\n",
        "                    \"0\"\n",
        "                )\n",
        "                label.add_background_rectangle()\n",
        "                label.next_to(arrows, DOWN)\n",
        "                self.add_foreground_mobjects(label)\n",
        "                always_rotate(arrows, rate=u * 30 * DEGREES)\n",
        "                self.play(\n",
        "                    FadeIn(arrows),\n",
        "                    FadeIn(label)\n",
        "                )\n",
        "        self.wait(2)\n",
        "        for group in counterclockwise_arrows, clockwise_arrows:\n",
        "            self.play(FocusOn(group[0]))\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    group,\n",
        "                    lambda mob, alpha: mob.set_color(\n",
        "                        interpolate_color(WHITE, PINK, alpha)\n",
        "                    ).set_stroke(\n",
        "                        width=interpolate(5, 10, alpha)\n",
        "                    ),\n",
        "                    rate_func=there_and_back,\n",
        "                    run_time=2\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(6)\n",
        "\n",
        "    # Helpers\n",
        "    def get_rotation_arrows(self, clockwise=True, width=1):\n",
        "        result = VGroup(*[\n",
        "            Arrow(\n",
        "                *points,\n",
        "                buff=2 * SMALL_BUFF,\n",
        "                path_arc=90 * DEGREES\n",
        "            ).set_stroke(width=5)\n",
        "            for points in adjacent_pairs(compass_directions(4, RIGHT))\n",
        "        ])\n",
        "        if clockwise:\n",
        "            result.flip()\n",
        "        result.set_width(width)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShearCurl(IntroduceCurl):\n",
        "    def construct(self):\n",
        "        self.show_vector_field()\n",
        "        self.begin_flow()\n",
        "        self.wait(2)\n",
        "        self.comment_on_relevant_region()\n",
        "\n",
        "    def show_vector_field(self):\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            self.func, **self.vector_field_config\n",
        "        )\n",
        "        vector_field.submobjects.key=sort(\n",
        "            key=lambda a: a.get_length()\n",
        "        )\n",
        "        self.play(LaggedStartMap(GrowArrow, vector_field))\n",
        "\n",
        "    def comment_on_relevant_region(self):\n",
        "        circle = Circle(color=WHITE, radius=0.75)\n",
        "        circle.next_to(ORIGIN, UP, LARGE_BUFF)\n",
        "        self.play(ShowCreation(circle))\n",
        "\n",
        "        slow_words, fast_words = words = [\n",
        "            OldTexText(\"Slow flow below\"),\n",
        "            OldTexText(\"Fast flow above\")\n",
        "        ]\n",
        "        for word, vect in zip(words, [DOWN, UP]):\n",
        "            word.add_background_rectangle(buff=SMALL_BUFF)\n",
        "            word.next_to(circle, vect)\n",
        "            self.add_foreground_mobjects(word)\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "\n",
        "        twig = Rectangle(\n",
        "            height=0.8 * 2 * circle.radius,\n",
        "            width=SMALL_BUFF,\n",
        "            stroke_width=0,\n",
        "            fill_color=GREY_BROWN,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        twig.add(Dot(twig.get_center()))\n",
        "        twig.move_to(circle)\n",
        "        always_rotate(\n",
        "            twig, rate=-90 * DEGREES,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(twig, UP))\n",
        "        self.add(twig_rotation)\n",
        "        self.wait(16)\n",
        "\n",
        "    # Helpers\n",
        "    def func(self, point):\n",
        "        return 0.5 * point[1] * RIGHT\n",
        "\n",
        "\n",
        "class FromKAWrapper(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        screen = self.screen\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\n",
        "                \"pondering\", \"confused\", \"hooray\",\n",
        "            )\n",
        "        )\n",
        "        self.look_at(screen)\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\"erm\", \"happy\", \"confused\")\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"Our focus is \\\\\\\\ the 2d version\",\n",
        "            bubble_config={\"width\": 4, \"height\": 3},\n",
        "            added_anims=[self.change_students(\n",
        "                \"happy\", \"hooray\", \"happy\"\n",
        "            )]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowCurlAtVariousPoints(IntroduceCurl):\n",
        "    CONFIG = {\n",
        "        \"func\": four_swirls_function,\n",
        "        \"sample_points\": [\n",
        "            4 * RIGHT,\n",
        "            2 * UP,\n",
        "            4 * LEFT,\n",
        "            2 * DOWN,\n",
        "            ORIGIN,\n",
        "            3 * RIGHT + 2 * UP,\n",
        "            3 * LEFT + 2 * UP,\n",
        "        ],\n",
        "        \"vector_field_config\": {\n",
        "            \"fill_opacity\": 0.75\n",
        "        },\n",
        "        \"stream_line_config\": {\n",
        "            \"virtual_time\": 5,\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 0.25,\n",
        "                \"delta_y\": 0.25,\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.show_vector_field()\n",
        "        self.begin_flow()\n",
        "        self.show_curl_at_points()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = NumberPlane()\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "        self.plane = plane\n",
        "\n",
        "    def show_curl_at_points(self):\n",
        "        dot = Dot()\n",
        "        circle = Circle(radius=0.25, color=WHITE)\n",
        "        circle.move_to(dot)\n",
        "        circle_update = Mobject.add_updater(\n",
        "            circle,\n",
        "            lambda m: m.move_to(dot)\n",
        "        )\n",
        "\n",
        "        curl_tex = OldTex(\n",
        "            \"\\\\text{curl} \\\\, \\\\textbf{F}(x, y) = \"\n",
        "        )\n",
        "        curl_tex.add_background_rectangle(buff=0.025)\n",
        "        curl_tex_update = Mobject.add_updater(\n",
        "            curl_tex,\n",
        "            lambda m: m.next_to(circle, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        curl_func = two_d_curl(self.func)\n",
        "        curl_value = DecimalNumber(\n",
        "            0, include_sign=True,\n",
        "            include_background_rectangle=True,\n",
        "        )\n",
        "        curl_value_update = ContinualChangingDecimal(\n",
        "            curl_value,\n",
        "            lambda a: curl_func(dot.get_center()),\n",
        "            position_update_func=lambda m: m.next_to(\n",
        "                curl_tex, RIGHT, buff=0\n",
        "            ),\n",
        "            include_background_rectangle=True,\n",
        "            include_sign=True,\n",
        "        )\n",
        "\n",
        "        points = self.sample_points\n",
        "        self.add(dot, circle_update)\n",
        "        self.play(\n",
        "            dot.move_to, points[0],\n",
        "            VFadeIn(dot),\n",
        "            VFadeIn(circle),\n",
        "        )\n",
        "        curl_tex_update.update(0)\n",
        "        curl_value_update.update(0)\n",
        "        self.play(Write(curl_tex), FadeIn(curl_value))\n",
        "        self.add(curl_tex_update, curl_value_update)\n",
        "        self.wait()\n",
        "        for point in points[1:]:\n",
        "            self.play(dot.move_to, point, run_time=3)\n",
        "            self.wait(2)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class IllustrationUseVennDiagram(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\"Divergence \\\\& Curl\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        useful_for = OldTexText(\"Useful for\")\n",
        "        useful_for.next_to(title, DOWN)\n",
        "        useful_for.set_color(BLUE)\n",
        "\n",
        "        fluid_flow = OldTexText(\"Fluid \\\\\\\\ flow\")\n",
        "        fluid_flow.next_to(ORIGIN, UL)\n",
        "        ff_circle = Circle(color=YELLOW)\n",
        "        ff_circle.surround(fluid_flow, stretch=True)\n",
        "        fluid_flow.match_color(ff_circle)\n",
        "\n",
        "        big_circle = Circle(\n",
        "            fill_color=BLUE,\n",
        "            fill_opacity=0.2,\n",
        "            stroke_color=BLUE,\n",
        "        )\n",
        "        big_circle.stretch_to_fit_width(9)\n",
        "        big_circle.stretch_to_fit_height(6)\n",
        "        big_circle.next_to(useful_for, DOWN, SMALL_BUFF)\n",
        "\n",
        "        illustrated_by = OldTexText(\"Illustrated by\")\n",
        "        illustrated_by.next_to(\n",
        "            big_circle.point_from_proportion(3. / 8), UL\n",
        "        )\n",
        "        illustrated_by.match_color(ff_circle)\n",
        "        illustrated_by_arrow = Arrow(\n",
        "            illustrated_by.get_bottom(),\n",
        "            ff_circle.get_left(),\n",
        "            path_arc=90 * DEGREES,\n",
        "            color=YELLOW,\n",
        "        )\n",
        "        illustrated_by_arrow.pointwise_become_partial(\n",
        "            illustrated_by_arrow, 0, 0.95\n",
        "        )\n",
        "\n",
        "        examples = VGroup(\n",
        "            OldTexText(\"Electricity\"),\n",
        "            OldTexText(\"Magnetism\"),\n",
        "            OldTexText(\"Phase flow\"),\n",
        "            OldTexText(\"Stokes' theorem\"),\n",
        "        )\n",
        "        points = [\n",
        "            2 * RIGHT + 0.5 * UP,\n",
        "            2 * RIGHT + 0.5 * DOWN,\n",
        "            2 * DOWN,\n",
        "            2 * LEFT + DOWN,\n",
        "        ]\n",
        "        for example, point in zip(examples, points):\n",
        "            example.move_to(point)\n",
        "\n",
        "        self.play(Write(title), run_time=1)\n",
        "        self.play(\n",
        "            Write(illustrated_by),\n",
        "            ShowCreation(illustrated_by_arrow),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(ff_circle),\n",
        "            FadeIn(fluid_flow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(useful_for),\n",
        "            DrawBorderThenFill(big_circle),\n",
        "            Animation(fluid_flow),\n",
        "            Animation(ff_circle),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, examples,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MaxwellsEquations(Scene):\n",
        "    CONFIG = {\n",
        "        \"faded_opacity\": 0.3,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_equations()\n",
        "        self.circle_gauss_law()\n",
        "        self.circle_magnetic_divergence()\n",
        "        self.circle_curl_equations()\n",
        "\n",
        "    def add_equations(self):\n",
        "        title = Title(\"Maxwell's equations\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        tex_to_color_map = {\n",
        "            \"\\\\textbf{E}\": BLUE,\n",
        "            \"\\\\textbf{B}\": YELLOW,\n",
        "            \"\\\\rho\": WHITE,\n",
        "        }\n",
        "\n",
        "        equations = self.equations = VGroup(*[\n",
        "            OldTex(\n",
        "                tex, tex_to_color_map=tex_to_color_map\n",
        "            )\n",
        "            for tex in [\n",
        "                \"\"\"\n",
        "                    \\\\text{div} \\\\, \\\\textbf{E} =\n",
        "                    {\\\\rho \\\\over \\\\varepsilon_0}\n",
        "                \"\"\",\n",
        "                \"\"\"\\\\text{div} \\\\, \\\\textbf{B} = 0\"\"\",\n",
        "                \"\"\"\n",
        "                    \\\\text{curl} \\\\, \\\\textbf{E} =\n",
        "                    -{\\\\partial \\\\textbf{B} \\\\over \\\\partial t}\n",
        "                \"\"\",\n",
        "                \"\"\"\n",
        "                    \\\\text{curl} \\\\, \\\\textbf{B} =\n",
        "                    \\\\mu_0 \\\\left(\n",
        "                        \\\\textbf{J} + \\\\varepsilon_0\n",
        "                        {\\\\partial \\\\textbf{E} \\\\over \\\\partial t}\n",
        "                    \\\\right)\n",
        "                \"\"\",\n",
        "            ]\n",
        "        ])\n",
        "        equations.arrange(\n",
        "            DOWN, aligned_edge=LEFT,\n",
        "            buff=MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        field_definitions = VGroup(*[\n",
        "            OldTex(text, tex_to_color_map=tex_to_color_map)\n",
        "            for text in [\n",
        "                \"\\\\text{Electric field: } \\\\textbf{E}\",\n",
        "                \"\\\\text{Magnetic field: } \\\\textbf{B}\",\n",
        "            ]\n",
        "        ])\n",
        "        field_definitions.arrange(\n",
        "            RIGHT, buff=MED_LARGE_BUFF\n",
        "        )\n",
        "        field_definitions.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        equations.next_to(field_definitions, DOWN, MED_LARGE_BUFF)\n",
        "        field_definitions.shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(field_definitions)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, equations,\n",
        "            run_time=3,\n",
        "            lag_range=0.4\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def circle_gauss_law(self):\n",
        "        equation = self.equations[0]\n",
        "        rect = SurroundingRectangle(equation)\n",
        "        rect.set_color(RED)\n",
        "        rho = equation.get_part_by_tex(\"\\\\rho\")\n",
        "        sub_rect = SurroundingRectangle(rho)\n",
        "        sub_rect.match_color(rect)\n",
        "        rho_label = OldTexText(\"Charge density\")\n",
        "        rho_label.next_to(sub_rect, RIGHT)\n",
        "        rho_label.match_color(sub_rect)\n",
        "        gauss_law = OldTexText(\"Gauss's law\")\n",
        "        gauss_law.next_to(rect, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(gauss_law, run_time=1),\n",
        "            self.equations[1:].set_fill, {\"opacity\": self.faded_opacity}\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(rect, sub_rect),\n",
        "            FadeOut(gauss_law),\n",
        "            FadeIn(rho_label),\n",
        "            rho.match_color, sub_rect,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.equations.to_edge, LEFT,\n",
        "            MaintainPositionRelativeTo(rho_label, equation),\n",
        "            MaintainPositionRelativeTo(sub_rect, equation),\n",
        "            VFadeOut(rho_label),\n",
        "            VFadeOut(sub_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def circle_magnetic_divergence(self):\n",
        "        equations = self.equations\n",
        "        rect = SurroundingRectangle(equations[1])\n",
        "\n",
        "        self.play(\n",
        "            equations[0].set_fill, {\"opacity\": self.faded_opacity},\n",
        "            equations[1].set_fill, {\"opacity\": 1.0},\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "    def circle_curl_equations(self):\n",
        "        equations = self.equations\n",
        "        rect = SurroundingRectangle(equations[2:])\n",
        "        randy = Randolph(height=2)\n",
        "        randy.flip()\n",
        "        randy.next_to(rect, RIGHT, aligned_edge=DOWN)\n",
        "        randy.look_at(rect)\n",
        "\n",
        "        self.play(\n",
        "            equations[1].set_fill, {\"opacity\": self.faded_opacity},\n",
        "            equations[2:].set_fill, {\"opacity\": 1.0},\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            randy.change, \"confused\",\n",
        "            VFadeIn(randy),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look_at, 2 * RIGHT)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            randy.change, \"pondering\",\n",
        "            randy.look_at, rect,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThatWeKnowOf(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"*That we know of!\")\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class IllustrateGaussLaw(DefineDivergence, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"flow_time\": 10,\n",
        "        \"stream_line_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 1.0 / 16,\n",
        "                \"delta_y\": 1.0 / 16,\n",
        "                \"x_min\": -2,\n",
        "                \"x_max\": 2,\n",
        "                \"y_min\": -1.5,\n",
        "                \"y_max\": 1.5,\n",
        "            },\n",
        "            \"color_lines_by_magnitude\": True,\n",
        "            \"colors\": [BLUE_E, BLUE_D, BLUE_C],\n",
        "            \"stroke_width\": 3,\n",
        "        },\n",
        "        \"stream_line_animation_config\": {\n",
        "            \"line_anim_class\": ShowPassingFlashWithThinningStrokeWidth,\n",
        "            \"line_anim_config\": {\n",
        "                \"n_segments\": 5,\n",
        "            }\n",
        "        },\n",
        "        \"final_frame_width\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        particles = self.get_particles()\n",
        "        vector_field = self.get_vector_field()\n",
        "\n",
        "        self.add_foreground_mobjects(vector_field)\n",
        "        self.add_foreground_mobjects(particles)\n",
        "        self.zoom_in()\n",
        "        self.show_flow()\n",
        "\n",
        "    def get_particles(self):\n",
        "        particles = VGroup(\n",
        "            get_proton(radius=0.1),\n",
        "            get_electron(radius=0.1),\n",
        "        )\n",
        "        particles.arrange(RIGHT, buff=2.25)\n",
        "        particles.shift(0.25 * UP)\n",
        "        for particle, sign in zip(particles, [+1, -1]):\n",
        "            particle.charge = sign\n",
        "\n",
        "        self.particles = particles\n",
        "        return particles\n",
        "\n",
        "    def zoom_in(self):\n",
        "        self.play(\n",
        "            self.camera_frame.set_width, self.final_frame_width,\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "\n",
        "class IllustrateGaussMagnetic(IllustrateGaussLaw):\n",
        "    CONFIG = {\n",
        "        \"final_frame_width\": 7,\n",
        "        \"stream_line_config\": {\n",
        "            \"start_points_generator_config\": {\n",
        "                \"delta_x\": 1.0 / 16,\n",
        "                \"delta_y\": 1.0 / 16,\n",
        "                \"x_min\": -3.5,\n",
        "                \"x_max\": 3.5,\n",
        "                \"y_min\": -2,\n",
        "                \"y_max\": 2,\n",
        "            },\n",
        "            \"color_lines_by_magnitude\": True,\n",
        "            \"colors\": [BLUE_E, BLUE_D, BLUE_C],\n",
        "            \"stroke_width\": 3,\n",
        "        },\n",
        "        \"stream_line_animation_config\": {\n",
        "            \"start_up_time\": 0,\n",
        "        },\n",
        "        \"flow_time\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_wires()\n",
        "        self.show_vector_field()\n",
        "        self.zoom_in()\n",
        "        self.show_flow()\n",
        "\n",
        "    def add_wires(self):\n",
        "        top, bottom = [\n",
        "            Circle(\n",
        "                radius=0.275,\n",
        "                stroke_color=WHITE,\n",
        "                fill_color=BLACK,\n",
        "                fill_opacity=1\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ]\n",
        "        top.add(OldTex(\"\\\\times\").scale(0.5))\n",
        "        bottom.add(Dot().scale(0.5))\n",
        "        top.move_to(1 * UP)\n",
        "        bottom.move_to(1 * DOWN)\n",
        "\n",
        "        self.add_foreground_mobjects(top, bottom)\n",
        "\n",
        "    def show_vector_field(self):\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            self.func, **self.vector_field_config\n",
        "        )\n",
        "        vector_field.submobjects.sort(\n",
        "            key=lambda a: -a1.get_length()\n",
        "        )\n",
        "        self.play(LaggedStartMap(GrowArrow, vector_field))\n",
        "        self.add_foreground_mobjects(\n",
        "            vector_field, *self.foreground_mobjects\n",
        "        )\n",
        "\n",
        "    def func(self, point):\n",
        "        x, y = point[:2]\n",
        "        top_part = np.array([(y - 1.0), -x, 0])\n",
        "        bottom_part = np.array([-(y + 1.0), x, 0])\n",
        "        norm = get_norm\n",
        "        return 1 * op.add(\n",
        "            top_part / (norm(top_part) * norm(point - UP) + 0.1),\n",
        "            bottom_part / (norm(bottom_part) * norm(point - DOWN) + 0.1),\n",
        "            # top_part / (norm(top_part)**2 + 1),\n",
        "            # bottom_part / (norm(bottom_part)**2 + 1),\n",
        "        )\n",
        "\n",
        "\n",
        "class IllustrateEMCurlEquations(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class RelevantInNonSpatialCircumstances(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "                $\\\\textbf{div}$ and $\\\\textbf{curl}$ are \\\\\\\\\n",
        "                even useful in some \\\\\\\\\n",
        "                non-spatial problems\n",
        "            \"\"\",\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"sassy\", \"confused\", \"hesitant\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShowTwoPopulations(Scene):\n",
        "    CONFIG = {\n",
        "        \"total_num_animals\": 80,\n",
        "        \"start_num_foxes\": 40,\n",
        "        \"start_num_rabbits\": 20,\n",
        "        \"animal_height\": 0.5,\n",
        "        \"final_wait_time\": 30,\n",
        "        \"count_word_scale_val\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_animals()\n",
        "        self.evolve_system()\n",
        "\n",
        "    def introduce_animals(self):\n",
        "        foxes = self.foxes = VGroup(*[\n",
        "            self.get_fox()\n",
        "            for n in range(self.total_num_animals)\n",
        "        ])\n",
        "        rabbits = self.rabbits = VGroup(*[\n",
        "            self.get_rabbit()\n",
        "            for n in range(self.total_num_animals)\n",
        "        ])\n",
        "        foxes[self.start_num_foxes:].set_fill(opacity=0)\n",
        "        rabbits[self.start_num_rabbits:].set_fill(opacity=0)\n",
        "\n",
        "        fox, rabbit = examples = VGroup(foxes[0], rabbits[0])\n",
        "        for mob in examples:\n",
        "            mob.save_state()\n",
        "            mob.set_height(3)\n",
        "        examples.arrange(LEFT, buff=2)\n",
        "\n",
        "        preditor, prey = words = VGroup(\n",
        "            OldTexText(\"Predator\"),\n",
        "            OldTexText(\"Prey\")\n",
        "        )\n",
        "        for mob, word in zip(examples, words):\n",
        "            word.scale(1.5)\n",
        "            word.next_to(mob, UP)\n",
        "            self.play(\n",
        "                FadeInFromDown(mob),\n",
        "                Write(word, run_time=1),\n",
        "            )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, examples,\n",
        "                lambda m: (m.restore,)\n",
        "            ),\n",
        "            LaggedStartMap(FadeOut, words),\n",
        "            *[\n",
        "                LaggedStartMap(\n",
        "                    FadeIn,\n",
        "                    group[1:],\n",
        "                    run_time=4,\n",
        "                    lag_ratio=0.1,\n",
        "                    rate_func=lambda t: np.clip(smooth(2 * t), 0, 1)\n",
        "                )\n",
        "                for group in [foxes, rabbits]\n",
        "            ]\n",
        "        )\n",
        "\n",
        "    def evolve_system(self):\n",
        "        foxes = self.foxes\n",
        "        rabbits = self.rabbits\n",
        "        phase_point = VectorizedPoint(\n",
        "            self.start_num_rabbits * RIGHT +\n",
        "            self.start_num_foxes * UP\n",
        "        )\n",
        "        self.add(move_along_vector_field(\n",
        "            phase_point,\n",
        "            preditor_prey_vector_field,\n",
        "        ))\n",
        "\n",
        "        def get_num_rabbits():\n",
        "            return phase_point.get_center()[0]\n",
        "\n",
        "        def get_num_foxes():\n",
        "            return phase_point.get_center()[1]\n",
        "\n",
        "        def get_updater(pop_size_getter):\n",
        "            def update(animals):\n",
        "                target_num = pop_size_getter()\n",
        "                for n, animal in enumerate(animals):\n",
        "                    animal.set_fill(\n",
        "                        opacity=np.clip(target_num - n, 0, 1)\n",
        "                    )\n",
        "                target_int = int(np.ceil(target_num))\n",
        "                tail = animals.submobjects[target_int:]\n",
        "                random.shuffle(tail)\n",
        "                animals.submobjects[target_int:] = tail\n",
        "\n",
        "            return update\n",
        "\n",
        "        self.add(Mobject.add_updater(\n",
        "            foxes, get_updater(get_num_foxes)\n",
        "        ))\n",
        "        self.add(Mobject.add_updater(\n",
        "            rabbits, get_updater(get_num_rabbits)\n",
        "        ))\n",
        "\n",
        "        # Add counts for foxes and rabbits\n",
        "        labels = self.get_pop_labels()\n",
        "        num_foxes = Integer(10)\n",
        "        num_foxes.scale(self.count_word_scale_val)\n",
        "        num_foxes.next_to(labels[0], RIGHT)\n",
        "        num_foxes.align_to(labels[0][0][1], DOWN)\n",
        "        num_rabbits = Integer(10)\n",
        "        num_rabbits.scale(self.count_word_scale_val)\n",
        "        num_rabbits.next_to(labels[1], RIGHT)\n",
        "        num_rabbits.align_to(labels[1][0][1], DOWN)\n",
        "\n",
        "        num_foxes.add_updater(lambda d: d.set_value(get_num_foxes()))\n",
        "        num_rabbits.add_updater(lambda d: d.set_value(get_num_rabbits()))\n",
        "\n",
        "        self.add(num_foxes, num_rabbits)\n",
        "\n",
        "        for count in num_foxes, num_rabbits:\n",
        "            self.add(Mobject.add_updater(\n",
        "                count, self.update_count_color,\n",
        "            ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(labels),\n",
        "            *[\n",
        "                UpdateFromAlphaFunc(count, lambda m, a: m.set_fill(opacity=a))\n",
        "                for count in (num_foxes, num_rabbits)\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.wait(self.final_wait_time)\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_animal(self, name, color):\n",
        "        result = SVGMobject(\n",
        "            file_name=name,\n",
        "            height=self.animal_height,\n",
        "            fill_color=color,\n",
        "        )\n",
        "        # for submob in result.family_members_with_points():\n",
        "            # if submob.is_subpath:\n",
        "            #     submob.is_subpath = False\n",
        "            #     submob.set_fill(\n",
        "            #         interpolate_color(color, BLACK, 0.8),\n",
        "            #         opacity=1\n",
        "            #     )\n",
        "        x_shift, y_shift = [\n",
        "            (2 * random.random() - 1) * max_val\n",
        "            for max_val in [\n",
        "                FRAME_WIDTH / 2 - 2,\n",
        "                FRAME_HEIGHT / 2 - 2\n",
        "            ]\n",
        "        ]\n",
        "        result.shift(x_shift * RIGHT + y_shift * UP)\n",
        "        return result\n",
        "\n",
        "    def get_fox(self):\n",
        "        return self.get_animal(\"fox\", FOX_COLOR)\n",
        "\n",
        "    def get_rabbit(self):\n",
        "        # return self.get_animal(\"rabbit\", WHITE)\n",
        "        return self.get_animal(\"bunny\", RABBIT_COLOR)\n",
        "\n",
        "    def get_pop_labels(self):\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"\\\\# Foxes: \"),\n",
        "            OldTexText(\"\\\\# Rabbits: \"),\n",
        "        )\n",
        "        for label in labels:\n",
        "            label.scale(self.count_word_scale_val)\n",
        "        labels.arrange(RIGHT, buff=2)\n",
        "        labels.to_edge(UP)\n",
        "        return labels\n",
        "\n",
        "    def update_count_color(self, count):\n",
        "        count.set_fill(interpolate_color(\n",
        "            BLUE, RED, (count.number - 20) / 30.0\n",
        "        ))\n",
        "        return count\n",
        "\n",
        "\n",
        "class PhaseSpaceOfPopulationModel(ShowTwoPopulations, PiCreatureScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"origin\": 5 * LEFT + 2.5 * DOWN,\n",
        "        \"vector_field_config\": {\n",
        "            \"max_magnitude\": 50,\n",
        "        },\n",
        "        \"pi_creatures_start_on_screen\": False,\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"height\": 1.8\n",
        "        },\n",
        "        \"flow_time\": 10,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_example_point()\n",
        "        self.write_differential_equations()\n",
        "        self.add_vectors()\n",
        "        self.show_phase_flow()\n",
        "\n",
        "    def add_axes(self):\n",
        "        axes = self.axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=55,\n",
        "            x_axis_config={\"unit_size\": 0.15},\n",
        "            y_min=0,\n",
        "            y_max=55,\n",
        "            y_axis_config={\"unit_size\": 0.09},\n",
        "            axis_config={\n",
        "                \"tick_frequency\": 10,\n",
        "            },\n",
        "        )\n",
        "        axes.shift(self.origin)\n",
        "        for axis in axes.x_axis, axes.y_axis:\n",
        "            axis.add_numbers(*list(range(10, 60, 10)))\n",
        "\n",
        "        axes_labels = self.axes_labels = VGroup(*[\n",
        "            VGroup(\n",
        "                method().set_height(0.75),\n",
        "                OldTexText(\"Population\"),\n",
        "            ).arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            for method in (self.get_rabbit, self.get_fox)\n",
        "        ])\n",
        "        for axis, label, vect in zip(axes, axes_labels, [RIGHT, UP]):\n",
        "            label.next_to(\n",
        "                axis, vect,\n",
        "                submobject_to_align=label[0]\n",
        "            )\n",
        "\n",
        "        self.add(axes, axes_labels)\n",
        "\n",
        "    def add_example_point(self):\n",
        "        axes = self.axes\n",
        "        origin = self.origin\n",
        "        x = self.start_num_rabbits\n",
        "        y = self.start_num_foxes\n",
        "        point = axes.coords_to_point(x, y)\n",
        "        x_point = axes.coords_to_point(x, 0)\n",
        "        y_point = axes.coords_to_point(0, y)\n",
        "        v_line = DashedLine(x_point, point)\n",
        "        h_line = DashedLine(y_point, point)\n",
        "        v_line.set_color(FOX_COLOR)\n",
        "        h_line.set_color(GREY_B)\n",
        "        dot = Dot(point)\n",
        "\n",
        "        coord_pair = OldTex(\n",
        "            \"(10, 10)\", isolate=[\"10\"]\n",
        "        )\n",
        "        pop_sizes = VGroup(Integer(10), Integer(10))\n",
        "        pop_sizes[0].set_color(GREY_B)\n",
        "        pop_sizes[1].set_color(FOX_COLOR)\n",
        "        tens = coord_pair.get_parts_by_tex(\"10\")\n",
        "        tens.fade(1)\n",
        "\n",
        "        def get_pop_size_update(i):\n",
        "            return ContinualChangingDecimal(\n",
        "                pop_sizes[i],\n",
        "                lambda a: int(np.round(\n",
        "                    axes.point_to_coords(dot.get_center())[i]\n",
        "                )),\n",
        "                position_update_func=lambda m: m.move_to(tens[i])\n",
        "            )\n",
        "        coord_pair.add_background_rectangle()\n",
        "        coord_pair_update = Mobject.add_updater(\n",
        "            coord_pair, lambda m: m.next_to(dot, UR, SMALL_BUFF)\n",
        "        )\n",
        "        pop_sizes_updates = [get_pop_size_update(i) for i in (0, 1)]\n",
        "\n",
        "        phase_space = OldTexText(\"``Phase space''\")\n",
        "        phase_space.set_color(YELLOW)\n",
        "        phase_space.scale(1.5)\n",
        "        phase_space.to_edge(UP)\n",
        "        phase_space.shift(2 * RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(ShowCreation(h_line))\n",
        "        dot.save_state()\n",
        "        dot.move_to(origin)\n",
        "        self.add(coord_pair_update)\n",
        "        self.add(*pop_sizes_updates)\n",
        "        self.play(\n",
        "            dot.restore,\n",
        "            VFadeIn(coord_pair),\n",
        "            UpdateFromAlphaFunc(pop_sizes, lambda m, a: m.set_fill(opacity=a)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(phase_space))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(VGroup(h_line, v_line, phase_space)))\n",
        "        self.play(Rotating(\n",
        "            dot,\n",
        "            about_point=axes.coords_to_point(30, 30),\n",
        "            rate_func=smooth,\n",
        "        ))\n",
        "\n",
        "        self.dot = dot\n",
        "        self.coord_pair = coord_pair\n",
        "        self.coord_pair_update = coord_pair_update\n",
        "        self.pop_sizes = pop_sizes\n",
        "        self.pop_sizes_updates = pop_sizes_updates\n",
        "\n",
        "    def write_differential_equations(self):\n",
        "        equations = self.get_equations()\n",
        "        equations.shift(2 * DOWN)\n",
        "        rect = SurroundingRectangle(equations, color=YELLOW)\n",
        "        rect.set_fill(BLACK, 0.8)\n",
        "        title = OldTexText(\"Differential equations\")\n",
        "        title.next_to(rect, UP)\n",
        "        title.set_color(rect.get_stroke_color())\n",
        "        self.differential_equation_group = VGroup(\n",
        "            rect, equations, title\n",
        "        )\n",
        "        self.differential_equation_group.to_corner(UR)\n",
        "\n",
        "        randy = self.pi_creature\n",
        "        randy.next_to(rect, DL)\n",
        "\n",
        "        self.play(\n",
        "            Write(title, run_time=1),\n",
        "            ShowCreation(rect)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, equations),\n",
        "            randy.change, \"confused\", equations,\n",
        "            VFadeIn(randy),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def add_vectors(self):\n",
        "        origin = self.axes.coords_to_point(0, 0)\n",
        "        dot = self.dot\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        def rescaled_field(point):\n",
        "            x, y = self.axes.point_to_coords(point)\n",
        "            result = preditor_prey_vector_field(np.array([x, y, 0]))\n",
        "            return self.axes.coords_to_point(*result[:2]) - origin\n",
        "\n",
        "        self.vector_field_config.update({\n",
        "            \"x_min\": origin[0] + 0.5,\n",
        "            \"x_max\": self.axes.get_right()[0] + 1,\n",
        "            \"y_min\": origin[1] + 0.5,\n",
        "            \"y_max\": self.axes.get_top()[1],\n",
        "        })\n",
        "        vector_field = VectorField(\n",
        "            rescaled_field, **self.vector_field_config\n",
        "        )\n",
        "\n",
        "        def get_dot_vector():\n",
        "            vector = vector_field.get_vector(dot.get_center())\n",
        "            vector.scale(1, about_point=vector.get_start())\n",
        "            return vector\n",
        "\n",
        "        dot_vector = get_dot_vector()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, vector_field),\n",
        "            randy.change, \"thinking\", dot,\n",
        "            Animation(self.differential_equation_group)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Animation(dot),\n",
        "            vector_field.set_fill, {\"opacity\": 0.2},\n",
        "            Animation(self.differential_equation_group),\n",
        "            GrowArrow(dot_vector),\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dot.move_to, dot_vector.get_end(),\n",
        "            dot.align_to, dot, RIGHT,\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            dot.move_to, dot_vector.get_end(),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for x in range(6):\n",
        "            new_dot_vector = get_dot_vector()\n",
        "            fade_anims = [\n",
        "                FadeOut(dot_vector),\n",
        "                FadeIn(new_dot_vector),\n",
        "                Animation(dot),\n",
        "            ]\n",
        "            if x == 4:\n",
        "                fade_anims += [\n",
        "                    vector_field.set_fill, {\"opacity\": 0.5},\n",
        "                    FadeOut(randy),\n",
        "                    FadeOut(self.differential_equation_group),\n",
        "                ]\n",
        "            self.play(*fade_anims)\n",
        "            dot_vector = new_dot_vector\n",
        "            self.play(dot.move_to, dot_vector.get_end())\n",
        "\n",
        "        dot_movement = move_along_vector_field(\n",
        "            dot, lambda p: 0.3 * vector_field.func(p)\n",
        "        )\n",
        "        self.add(dot_movement)\n",
        "        self.play(FadeOut(dot_vector))\n",
        "        self.wait(10)\n",
        "        self.play(\n",
        "            vector_field.set_fill, {\"opacity\": 1.0},\n",
        "            VFadeOut(dot),\n",
        "            VFadeOut(self.coord_pair),\n",
        "            UpdateFromAlphaFunc(self.pop_sizes, lambda m, a: m.set_fill(opacity=1 - a)),\n",
        "        )\n",
        "        self.remove(\n",
        "            dot_movement,\n",
        "            self.coord_pair_update,\n",
        "            *self.pop_sizes_updates\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.vector_field = vector_field\n",
        "\n",
        "    def show_phase_flow(self):\n",
        "        vector_field = self.vector_field\n",
        "        stream_lines = StreamLines(\n",
        "            vector_field.func,\n",
        "            start_points_generator_config={\n",
        "                \"x_min\": vector_field.x_min,\n",
        "                \"x_max\": vector_field.x_max,\n",
        "                \"y_min\": vector_field.y_min,\n",
        "                \"y_max\": vector_field.y_max,\n",
        "                \"delta_x\": 0.25,\n",
        "                \"delta_y\": 0.25,\n",
        "            },\n",
        "            min_magnitude=vector_field.min_magnitude,\n",
        "            max_magnitude=vector_field.max_magnitude,\n",
        "            virtual_time=4,\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(\n",
        "            stream_lines,\n",
        "        )\n",
        "        self.add(stream_line_animation)\n",
        "        self.add_foreground_mobjects(vector_field)\n",
        "        self.wait(self.flow_time)\n",
        "        self.play(\n",
        "            self.camera_frame.scale, 1.5, {\"about_point\": self.origin},\n",
        "            run_time=self.flow_time,\n",
        "        )\n",
        "        self.wait(self.flow_time)\n",
        "\n",
        "    #\n",
        "    def get_equations(self):\n",
        "        variables = [\"X\", \"YY\"]\n",
        "        equations = OldTex(\n",
        "            \"\"\"\n",
        "                {dX \\\\over dt} =\n",
        "                X \\\\cdot (\\\\alpha - \\\\beta YY \\\\,) \\\\\\\\\n",
        "                \\\\quad \\\\\\\\\n",
        "                {dYY \\\\over dt} =\n",
        "                YY \\\\cdot (\\\\delta X - \\\\gamma)\n",
        "            \"\"\",\n",
        "            isolate=variables\n",
        "        )\n",
        "        animals = [self.get_rabbit(), self.get_fox().flip()]\n",
        "        for char, animal in zip(variables, animals):\n",
        "            for part in equations.get_parts_by_tex(char):\n",
        "                animal_copy = animal.copy()\n",
        "                animal_copy.set_height(0.5)\n",
        "                animal_copy.move_to(part, DL)\n",
        "                part.become(animal_copy)\n",
        "        return equations\n",
        "\n",
        "\n",
        "class PhaseFlowWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"``Phase flow''\")\n",
        "        words.scale(2)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PhaseFlowQuestions(Scene):\n",
        "    def construct(self):\n",
        "        questions = VGroup(\n",
        "            OldTexText(\n",
        "                \"Which points does the flow \\\\\\\\\" +\n",
        "                \"converge to?  Diverge away from?\",\n",
        "            ),\n",
        "            OldTexText(\"Where are there cycles?\"),\n",
        "        )\n",
        "        questions.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        questions.to_corner(UR)\n",
        "        for question in questions:\n",
        "            self.play(FadeInFromDown(question))\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class ToolsBeyondDivAndCurlForODEs(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DOWN,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        div_curl = OldTexText(\"div \\\\\\\\\", \"curl\")\n",
        "        div_curl.set_color_by_tex(\"div\", BLUE)\n",
        "        div_curl.set_color_by_tex(\"curl\", YELLOW)\n",
        "        div_curl.next_to(morty.get_corner(UL), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        jacobian = OldTexText(\"Analyze the \\\\\\\\ Jacobian\")\n",
        "        jacobian.set_color(GREEN)\n",
        "        jacobian.next_to(morty.get_corner(UR), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        flow_intuitions = OldTexText(\"Flow-based intuitions\")\n",
        "        flow_intuitions.next_to(\n",
        "            VGroup(div_curl, jacobian),\n",
        "            UP, buff=1.5\n",
        "        )\n",
        "        arrow1 = Arrow(div_curl.get_top(), flow_intuitions.get_bottom())\n",
        "        arrow2 = Arrow(flow_intuitions.get_bottom(), jacobian.get_top())\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(div_curl),\n",
        "            morty.change, \"raise_left_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(jacobian),\n",
        "            morty.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                flow_intuitions.copy().fade(1).move_to(div_curl),\n",
        "                flow_intuitions,\n",
        "            ),\n",
        "            GrowArrow(arrow1),\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(0.5)\n",
        "        self.play(GrowArrow(arrow2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutComputation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Sure, but how do you \\\\\\\\\" +\n",
        "            \"\\\\emph{compute} $\\\\textbf{div}$ and $\\\\textbf{curl}$?\",\n",
        "            target_mode=\"sassy\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"sassy\", \"angry\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"Are you familiar \\\\\\\\\" +\n",
        "            \"with my work \\\\\\\\\" +\n",
        "            \"at Khan Academy?\",\n",
        "            target_mode=\"speaking\",\n",
        "            bubble_config={\"width\": 4, \"height\": 3}\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            * 3 * [\"pondering\"],\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class QuickWordsOnNotation(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Quick words on notation:\")\n",
        "        words.scale(1.5)\n",
        "        self.play(FadeInFromDown(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NablaNotation(PiCreatureScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DL,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_notation()\n",
        "        self.show_expansion()\n",
        "        self.zoom_out()\n",
        "\n",
        "    def show_notation(self):\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        tex_to_color_map = {\n",
        "            \"\\\\text{div}\": BLUE,\n",
        "            \"\\\\nabla \\\\cdot\": BLUE,\n",
        "            \"\\\\text{curl}\": YELLOW,\n",
        "            \"\\\\nabla \\\\times\": YELLOW,\n",
        "        }\n",
        "        div_equation = OldTex(\n",
        "            \"\\\\text{div} \\\\, \\\\textbf{F} = \\\\nabla \\\\cdot \\\\textbf{F}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        div_nabla = div_equation.get_part_by_tex(\"\\\\nabla\")\n",
        "        curl_equation = OldTex(\n",
        "            \"\\\\text{curl} \\\\, \\\\textbf{F} = \\\\nabla \\\\times \\\\textbf{F}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        curl_nabla = curl_equation.get_part_by_tex(\"\\\\nabla\")\n",
        "        equations = VGroup(div_equation, curl_equation)\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        equations.next_to(morty, UP, 2)\n",
        "        equations.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(div_equation),\n",
        "            morty.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(WiggleOutThenIn(div_nabla, scale_value=1.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(curl_equation),\n",
        "            morty.change, \"raise_left_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(WiggleOutThenIn(curl_nabla, scale_value=1.5))\n",
        "        self.wait()\n",
        "\n",
        "        self.equations = equations\n",
        "\n",
        "    def show_expansion(self):\n",
        "        equations = self.equations\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        nabla_vector = Matrix([\n",
        "            [\"\\\\partial \\\\over \\\\partial x\"],\n",
        "            [\"\\\\partial \\\\over \\\\partial y\"],\n",
        "        ], v_buff=1.5)\n",
        "        F_vector = Matrix([\n",
        "            [\"\\\\textbf{F}_x\"],\n",
        "            [\"\\\\textbf{F}_y\"],\n",
        "        ], v_buff=1.2)\n",
        "        nabla_vector.match_height(F_vector)\n",
        "\n",
        "        div_lhs, curl_lhs = lhs_groups = VGroup(*[\n",
        "            VGroup(\n",
        "                nabla_vector.deepcopy(),\n",
        "                OldTex(tex).scale(1.5),\n",
        "                F_vector.copy(),\n",
        "                OldTex(\"=\")\n",
        "            )\n",
        "            for tex in (\"\\\\cdot\", \"\\\\times\")\n",
        "        ])\n",
        "        colors = [BLUE, YELLOW]\n",
        "        for lhs, color in zip(lhs_groups, colors):\n",
        "            lhs.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            VGroup(lhs[0].brackets, lhs[1]).set_color(color)\n",
        "        div_lhs.to_edge(UP)\n",
        "        curl_lhs.next_to(div_lhs, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        div_rhs = OldTex(\n",
        "            \"{\\\\partial F_x \\\\over \\\\partial x} + \" +\n",
        "            \"{\\\\partial F_y \\\\over \\\\partial y}\"\n",
        "        )\n",
        "        curl_rhs = OldTex(\n",
        "            \"{\\\\partial F_y \\\\over \\\\partial x} - \" +\n",
        "            \"{\\\\partial F_x \\\\over \\\\partial y}\"\n",
        "        )\n",
        "        rhs_groups = VGroup(div_rhs, curl_rhs)\n",
        "        for rhs, lhs in zip(rhs_groups, lhs_groups):\n",
        "            rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        for rhs, tex, color in zip(rhs_groups, [\"div\", \"curl\"], colors):\n",
        "            rhs.rect = SurroundingRectangle(rhs, color=color)\n",
        "            rhs.label = OldTex(\n",
        "                \"\\\\text{%s}\" % tex,\n",
        "                \"\\\\, \\\\textbf{F}\"\n",
        "            )\n",
        "            rhs.label.set_color(color)\n",
        "            rhs.label.next_to(rhs.rect, UP)\n",
        "\n",
        "        for i in 0, 1:\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    equations[i][2].copy(),\n",
        "                    lhs_groups[i][0].brackets\n",
        "                ),\n",
        "                ReplacementTransform(\n",
        "                    equations[i][3].copy(),\n",
        "                    lhs_groups[i][2],\n",
        "                ),\n",
        "                morty.change, \"pondering\",\n",
        "                *[\n",
        "                    GrowFromPoint(mob, equations[i].get_right())\n",
        "                    for mob in [\n",
        "                        lhs_groups[i][0].get_entries(),\n",
        "                        lhs_groups[i][1],\n",
        "                        lhs_groups[i][3]\n",
        "                    ]\n",
        "                ],\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        for rhs in rhs_groups:\n",
        "            self.play(\n",
        "                Write(rhs),\n",
        "                morty.change, 'confused'\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(rhs.rect),\n",
        "                FadeInFromDown(rhs.label),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(morty.change, \"erm\")\n",
        "        self.wait(3)\n",
        "\n",
        "    def zoom_out(self):\n",
        "        screen_rect = self.camera_frame.copy()\n",
        "        screen_rect.set_stroke(WHITE, 3)\n",
        "        screen_rect.scale(1.01)\n",
        "        words = OldTexText(\"Something deeper at play...\")\n",
        "        words.scale(1.3)\n",
        "        words.next_to(screen_rect, UP)\n",
        "\n",
        "        self.add(screen_rect)\n",
        "        self.play(\n",
        "            self.camera_frame.set_height, FRAME_HEIGHT + 3,\n",
        "            Write(words, rate_func=squish_rate_func(smooth, 0.3, 1)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DivCurlDotCross(Scene):\n",
        "    def construct(self):\n",
        "        rects = VGroup(*[\n",
        "            ScreenRectangle(height=2.5)\n",
        "            for n in range(4)\n",
        "        ])\n",
        "        rects.arrange_in_grid(n_rows=2, buff=LARGE_BUFF)\n",
        "        rects[2:].shift(MED_LARGE_BUFF * DOWN)\n",
        "        titles = VGroup(*list(map(TexText, [\n",
        "            \"Divergence\", \"Curl\",\n",
        "            \"Dot product\", \"Cross product\"\n",
        "        ])))\n",
        "        for title, rect in zip(titles, rects):\n",
        "            title.next_to(rect, UP)\n",
        "\n",
        "        self.add(rects, titles)\n",
        "\n",
        "\n",
        "class ShowDotProduct(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"prod_tex\": \"\\\\cdot\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        plane = NumberPlane()\n",
        "        v1 = Vector(RIGHT, color=BLUE)\n",
        "        v2 = Vector(UP, color=YELLOW)\n",
        "\n",
        "        dot_product = OldTex(\n",
        "            \"\\\\vec{\\\\textbf{v}}\", self.prod_tex,\n",
        "            \"\\\\vec{\\\\textbf{w}}\", \"=\"\n",
        "        )\n",
        "        dot_product.set_color_by_tex_to_color_map({\n",
        "            \"textbf{v}\": BLUE,\n",
        "            \"textbf{w}\": YELLOW,\n",
        "        })\n",
        "        dot_product.add_background_rectangle()\n",
        "        dot_product.next_to(2.25 * UP, RIGHT)\n",
        "        dot_product_value = DecimalNumber(\n",
        "            1.0,\n",
        "            include_background_rectangle=True,\n",
        "        )\n",
        "        dot_product_value.next_to(dot_product)\n",
        "        dot_product_value_update = ContinualChangingDecimal(\n",
        "            dot_product_value,\n",
        "            lambda a: self.get_product(v1, v2),\n",
        "            include_background_rectangle=True,\n",
        "        )\n",
        "\n",
        "        self.camera_frame.set_height(4)\n",
        "        self.camera_frame.move_to(DL, DL)\n",
        "        self.add(plane)\n",
        "        self.add(dot_product, dot_product_value_update)\n",
        "        self.add_additional_continual_animations(v1, v2)\n",
        "        self.add_foreground_mobjects(v1, v2)\n",
        "        for n in range(5):\n",
        "            self.play(\n",
        "                Rotate(v1, 45 * DEGREES, about_point=ORIGIN),\n",
        "                Rotate(v2, -45 * DEGREES, about_point=ORIGIN),\n",
        "                run_time=3,\n",
        "                rate_func=there_and_back\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "    def get_product(self, v1, v2):\n",
        "        return np.dot(v1.get_vector(), v2.get_vector())\n",
        "\n",
        "    def add_additional_continual_animations(self, v1, v2):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ShowCrossProduct(ShowDotProduct):\n",
        "    CONFIG = {\n",
        "        \"prod_tex\": \"\\\\times\"\n",
        "    }\n",
        "\n",
        "    def get_product(self, v1, v2):\n",
        "        return get_norm(\n",
        "            np.cross(v1.get_vector(), v2.get_vector())\n",
        "        )\n",
        "\n",
        "    def add_additional_continual_animations(self, v1, v2):\n",
        "        square = Square(\n",
        "            stroke_color=YELLOW,\n",
        "            stroke_width=3,\n",
        "            fill_color=YELLOW,\n",
        "            fill_opacity=0.2,\n",
        "        )\n",
        "\n",
        "        self.add(Mobject.add_updater(\n",
        "            square,\n",
        "            lambda s: s.set_points_as_corners([\n",
        "                ORIGIN,\n",
        "                v1.get_end(),\n",
        "                v1.get_end() + v2.get_end(),\n",
        "                v2.get_end(),\n",
        "            ])\n",
        "        ))\n",
        "\n",
        "\n",
        "class DivergenceTinyNudgesView(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"scale_factor\": 0.25,\n",
        "        \"point\": ORIGIN,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_vector_field()\n",
        "        self.zoom_in()\n",
        "        self.take_tiny_step()\n",
        "        self.show_dot_product()\n",
        "        self.show_circle_of_values()\n",
        "        self.switch_to_curl_words()\n",
        "        self.rotate_difference_vectors()\n",
        "\n",
        "    def add_vector_field(self):\n",
        "        plane = self.plane = NumberPlane()\n",
        "\n",
        "        def func(p):\n",
        "            x, y = p[:2]\n",
        "            result = np.array([\n",
        "                np.sin(x + 0.1),\n",
        "                np.cos(2 * y),\n",
        "                0\n",
        "            ])\n",
        "            result /= (get_norm(result)**0.5 + 1)\n",
        "            return result\n",
        "\n",
        "        vector_field = self.vector_field = VectorField(\n",
        "            func,\n",
        "            length_func=lambda n: 0.5 * sigmoid(n),\n",
        "            # max_magnitude=1.0,\n",
        "        )\n",
        "        self.add(plane)\n",
        "        self.add(vector_field)\n",
        "\n",
        "    def zoom_in(self):\n",
        "        point = self.point\n",
        "        vector_field = self.vector_field\n",
        "        sf = self.scale_factor\n",
        "\n",
        "        vector_field.vector_config.update({\n",
        "            \"rectangular_stem_width\": 0.02,\n",
        "            \"tip_length\": 0.1,\n",
        "        })\n",
        "        vector_field.length_func = lambda n: n\n",
        "        vector = vector_field.get_vector(point)\n",
        "\n",
        "        input_dot = Dot(point).scale(sf)\n",
        "        input_words = OldTexText(\"$(x_0, y_0)$\").scale(sf)\n",
        "        input_words.next_to(input_dot, DL, SMALL_BUFF * sf)\n",
        "        output_words = OldTexText(\"Output\").scale(sf)\n",
        "        output_words.add_background_rectangle()\n",
        "        output_words.next_to(vector.get_top(), UP, sf * SMALL_BUFF)\n",
        "        output_words.match_color(vector)\n",
        "\n",
        "        self.play(\n",
        "            self.camera_frame.scale, sf,\n",
        "            self.camera_frame.move_to, point,\n",
        "            FadeOut(vector_field),\n",
        "            FadeIn(vector),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add_foreground_mobjects(input_dot)\n",
        "        self.play(\n",
        "            FadeIn(input_dot, SMALL_BUFF * DL),\n",
        "            Write(input_words),\n",
        "        )\n",
        "        self.play(\n",
        "            Indicate(vector),\n",
        "            Write(output_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            point, vector, input_dot,\n",
        "            input_words, output_words,\n",
        "        )\n",
        "\n",
        "    def take_tiny_step(self):\n",
        "        sf = self.scale_factor\n",
        "        vector_field = self.vector_field\n",
        "        point = self.point\n",
        "        vector = self.vector\n",
        "        output_words = self.output_words\n",
        "        input_dot = self.input_dot\n",
        "\n",
        "        nudge = 0.5 * RIGHT\n",
        "        nudged_point = point + nudge\n",
        "\n",
        "        new_vector = vector_field.get_vector(nudged_point)\n",
        "        new_vector.set_color(YELLOW)\n",
        "        new_dot = Dot(nudged_point).scale(sf)\n",
        "        step_vector = Arrow(\n",
        "            point, nudged_point,\n",
        "            buff=0,\n",
        "            color=TEAL,\n",
        "            **vector_field.vector_config\n",
        "        )\n",
        "        step_vector.set_stroke(BLACK, 0.5)\n",
        "\n",
        "        new_output_words = OldTexText(\"New output\").scale(sf)\n",
        "        new_output_words.add_background_rectangle()\n",
        "        new_output_words.next_to(new_vector.get_end(), UP, sf * SMALL_BUFF)\n",
        "        new_output_words.match_color(new_vector)\n",
        "        step_words = OldTexText(\"Step\").scale(sf)\n",
        "        step_words.next_to(step_vector, UP, buff=0)\n",
        "        step_words.set_color(step_vector.get_fill_color())\n",
        "        step_words.add_background_rectangle()\n",
        "        small_step_words = OldTexText(\"(think tiny step)\").scale(sf)\n",
        "        small_step_words.next_to(\n",
        "            step_words, RIGHT,\n",
        "            buff=sf * MED_SMALL_BUFF,\n",
        "        )\n",
        "        small_step_words.add_background_rectangle()\n",
        "        small_step_words.match_style(step_words)\n",
        "\n",
        "        shifted_vector = vector.copy().shift(nudge)\n",
        "        diff_vector = Arrow(\n",
        "            shifted_vector.get_end(),\n",
        "            new_vector.get_end(),\n",
        "            buff=0,\n",
        "            color=RED,\n",
        "            **vector_field.vector_config\n",
        "        )\n",
        "        diff_words = OldTexText(\"Difference\").scale(sf)\n",
        "        diff_words.add_background_rectangle()\n",
        "        diff_words.next_to(diff_vector.get_start(), UR, buff=2 * sf * SMALL_BUFF)\n",
        "        diff_words.match_color(diff_vector)\n",
        "        diff_words.rotate(\n",
        "            diff_vector.get_angle(),\n",
        "            about_point=diff_vector.get_start()\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(step_vector),\n",
        "            Write(step_words),\n",
        "            ReplacementTransform(input_dot.copy(), new_dot)\n",
        "        )\n",
        "        self.add_foreground_mobjects(new_dot)\n",
        "        self.play(FadeIn(small_step_words))\n",
        "        self.play(FadeOut(small_step_words))\n",
        "        self.play(\n",
        "            ReplacementTransform(vector.copy(), new_vector),\n",
        "            ReplacementTransform(output_words.copy(), new_output_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            vector.copy(), shifted_vector,\n",
        "            path_arc=-TAU / 4\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(output_words),\n",
        "            FadeOut(new_output_words),\n",
        "            GrowArrow(diff_vector),\n",
        "            Write(diff_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            vector.scale, 0, {\"about_point\": vector.get_start()},\n",
        "            shifted_vector.scale, 0, {\"about_point\": shifted_vector.get_start()},\n",
        "            ReplacementTransform(\n",
        "                new_vector,\n",
        "                diff_vector.copy().shift(-vector.get_vector()),\n",
        "                remover=True\n",
        "            ),\n",
        "            diff_vector.shift, -vector.get_vector(),\n",
        "            MaintainPositionRelativeTo(diff_words, diff_vector),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            step_vector, step_words,\n",
        "            diff_vector, diff_words,\n",
        "        )\n",
        "\n",
        "    def show_dot_product(self):\n",
        "        sf = self.scale_factor\n",
        "        point = self.point\n",
        "        step_vector = self.step_vector\n",
        "        step_words = self.step_words\n",
        "        diff_vector = self.diff_vector\n",
        "        diff_words = self.diff_words\n",
        "        vects = VGroup(step_vector, diff_vector)\n",
        "\n",
        "        moving_step_vector = step_vector.copy()\n",
        "        moving_diff_vector = diff_vector.copy()\n",
        "\n",
        "        def update_moving_diff_vector(dv):\n",
        "            step = moving_step_vector.get_vector()\n",
        "            o1 = self.vector_field.get_vector(point).get_vector()\n",
        "            o2 = self.vector_field.get_vector(point + step).get_vector()\n",
        "            diff = o2 - o1\n",
        "            dv.put_start_and_end_on(\n",
        "                moving_step_vector.get_end(),\n",
        "                moving_step_vector.get_end() + diff,\n",
        "            )\n",
        "        self.moving_diff_vector_update = Mobject.add_updater(\n",
        "            moving_diff_vector,\n",
        "            update_moving_diff_vector\n",
        "        )\n",
        "        self.add(self.moving_diff_vector_update)\n",
        "\n",
        "        div_text = self.get_operator_text(\"div\")\n",
        "\n",
        "        step_words_copy = step_words.copy()\n",
        "        diff_words_copy = diff_words.copy()\n",
        "        copies = VGroup(step_words_copy, diff_words_copy)\n",
        "\n",
        "        substrings = [\"Step\", \"Difference\"]\n",
        "        dot_product = OldTexText(\n",
        "            \"(Step) $\\\\cdot$ (Difference)\",\n",
        "            isolate=substrings,\n",
        "            arg_separator=\"\",\n",
        "        ).scale(sf)\n",
        "        group = VGroup(div_text, dot_product)\n",
        "        group.arrange(RIGHT, buff=sf * MED_SMALL_BUFF)\n",
        "        group.next_to(\n",
        "            self.camera_frame.get_top(), DOWN,\n",
        "            buff=sf * MED_SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        for substring, mob, vect in zip(substrings, copies, vects):\n",
        "            part = dot_product.get_part_by_tex(substring)\n",
        "            mob.generate_target()\n",
        "            mob.target.rotate(-vect.get_angle())\n",
        "            mob.target.replace(part)\n",
        "            # part.set_fill(opacity=0)\n",
        "            part.match_color(mob)\n",
        "        dot_product.add_background_rectangle()\n",
        "\n",
        "        brace = Brace(\n",
        "            dot_product.copy().scale(1 / sf, about_point=ORIGIN), DOWN,\n",
        "            buff=SMALL_BUFF\n",
        "        ).scale(sf, about_point=ORIGIN)\n",
        "        dp_kwargs = {\n",
        "            \"include_sign\": True,\n",
        "        }\n",
        "        dot_product_value = DecimalNumber(1.0, **dp_kwargs)\n",
        "        dot_product_value.scale(sf)\n",
        "        dot_product_value.next_to(brace, DOWN, sf * SMALL_BUFF)\n",
        "        dot_product_value_update = ContinualChangingDecimal(\n",
        "            dot_product_value,\n",
        "            lambda a: np.dot(\n",
        "                moving_step_vector.get_vector(),\n",
        "                moving_diff_vector.get_vector(),\n",
        "            ),\n",
        "            **dp_kwargs\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(dot_product),\n",
        "            LaggedStartMap(MoveToTarget, copies)\n",
        "        )\n",
        "        self.remove(copies)\n",
        "        self.play(FadeIn(div_text))\n",
        "        self.play(ShowPassingFlashAround(\n",
        "            div_text[1:3],\n",
        "            surrounding_rectangle_config={\"buff\": sf * SMALL_BUFF}\n",
        "        ))\n",
        "        self.add(BackgroundRectangle(dot_product_value))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(dot_product_value),\n",
        "        )\n",
        "        self.add(dot_product_value_update)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            div_text, dot_product,\n",
        "            moving_step_vector,\n",
        "            moving_diff_vector,\n",
        "            dot_product_value,\n",
        "            dot_product_value_update,\n",
        "            brace,\n",
        "        )\n",
        "\n",
        "    def show_circle_of_values(self):\n",
        "        point = self.point\n",
        "        moving_step_vector = self.moving_step_vector\n",
        "        moving_diff_vector = self.moving_diff_vector\n",
        "\n",
        "        all_diff_vectors = VGroup()\n",
        "        all_step_vectors = VGroup()\n",
        "        # Loop around\n",
        "        n_samples = 12\n",
        "        angle = TAU / n_samples\n",
        "        self.add_foreground_mobjects(self.step_words)\n",
        "        for n in range(n_samples):\n",
        "            self.play(\n",
        "                Rotating(\n",
        "                    moving_step_vector,\n",
        "                    radians=angle,\n",
        "                    about_point=point,\n",
        "                    run_time=15.0 / n_samples,\n",
        "                    rate_func=linear,\n",
        "                )\n",
        "            )\n",
        "            step_vector_copy = moving_step_vector.copy()\n",
        "            diff_vector_copy = moving_diff_vector.copy()\n",
        "            diff_vector_copy.set_stroke(BLACK, 0.5)\n",
        "            self.add(step_vector_copy, diff_vector_copy)\n",
        "            all_step_vectors.add(step_vector_copy)\n",
        "            all_diff_vectors.add(diff_vector_copy)\n",
        "        self.remove(\n",
        "            self.step_vector, self.diff_vector,\n",
        "            self.moving_step_vector, self.moving_diff_vector,\n",
        "            self.moving_diff_vector_update,\n",
        "            self.dot_product_value_update\n",
        "        )\n",
        "        self.remove_foreground_mobjects(self.step_words)\n",
        "        self.play(\n",
        "            FadeOut(self.brace),\n",
        "            FadeOut(self.dot_product_value),\n",
        "            FadeOut(self.step_words),\n",
        "            FadeOut(self.diff_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for s in 0.6, -0.6:\n",
        "            for step, diff in zip(all_step_vectors, all_diff_vectors):\n",
        "                diff.generate_target()\n",
        "                diff.target.put_start_and_end_on(\n",
        "                    step.get_end(),\n",
        "                    step.get_end() + s * step.get_vector()\n",
        "                )\n",
        "            self.play(\n",
        "                all_step_vectors.set_fill, {\"opacity\": 0.5},\n",
        "                LaggedStartMap(\n",
        "                    MoveToTarget, all_diff_vectors,\n",
        "                    run_time=3\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.show_stream_lines(lambda p: s * (p - point))\n",
        "            self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            all_step_vectors, all_diff_vectors,\n",
        "        )\n",
        "\n",
        "    def switch_to_curl_words(self):\n",
        "        sf = self.scale_factor\n",
        "        div_text = self.div_text\n",
        "        dot_product = self.dot_product\n",
        "\n",
        "        curl_text = self.get_operator_text(\"curl\")\n",
        "        cross_product = OldTexText(\n",
        "            \"(Step) $\\\\times$ (Difference)\",\n",
        "            tex_to_color_map={\n",
        "                \"Step\": TEAL,\n",
        "                \"Difference\": RED\n",
        "            },\n",
        "            arg_separator=\"\",\n",
        "        ).scale(sf)\n",
        "        cross_product.add_background_rectangle(opacity=1)\n",
        "\n",
        "        group = VGroup(curl_text, cross_product)\n",
        "        group.arrange(RIGHT, buff=sf * MED_SMALL_BUFF)\n",
        "        group.next_to(self.camera_frame.get_top(), sf * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            dot_product.shift, sf * DOWN,\n",
        "            dot_product.fade, 1,\n",
        "            remover=True\n",
        "        )\n",
        "        self.play(FadeIn(cross_product, sf * DOWN))\n",
        "        self.play(\n",
        "            div_text.shift, sf * DOWN,\n",
        "            div_text.fade, 1,\n",
        "            remover=True\n",
        "        )\n",
        "        self.play(FadeIn(curl_text, sf * DOWN))\n",
        "        self.wait()\n",
        "\n",
        "    def rotate_difference_vectors(self):\n",
        "        point = self.point\n",
        "        all_step_vectors = self.all_step_vectors\n",
        "        all_diff_vectors = self.all_diff_vectors\n",
        "\n",
        "        for s in 0.6, -0.6:\n",
        "            for step, diff in zip(all_step_vectors, all_diff_vectors):\n",
        "                diff.generate_target()\n",
        "                diff.target.put_start_and_end_on(\n",
        "                    step.get_end(),\n",
        "                    step.get_end() + s * rotate_vector(\n",
        "                        step.get_vector(),\n",
        "                        90 * DEGREES\n",
        "                    )\n",
        "                )\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    MoveToTarget, all_diff_vectors,\n",
        "                    run_time=2\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.show_stream_lines(\n",
        "                lambda p: s * rotate_vector((p - point), 90 * DEGREES)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            all_step_vectors, all_diff_vectors,\n",
        "        )\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_operator_text(self, operator):\n",
        "        text = OldTexText(\n",
        "            operator + \"\\\\,\",\n",
        "            \"$\\\\textbf{F}(x_0, y_0)\\\\,$\",\n",
        "            \"corresponds to average of\",\n",
        "            arg_separator=\"\"\n",
        "        ).scale(self.scale_factor)\n",
        "        text.set_color_by_tex(operator, YELLOW)\n",
        "        text.add_background_rectangle()\n",
        "        return text\n",
        "\n",
        "    def show_stream_lines(self, func):\n",
        "        point = self.point\n",
        "        stream_lines = StreamLines(\n",
        "            func,\n",
        "            start_points_generator_config={\n",
        "                \"x_min\": point[0] - 2,\n",
        "                \"x_max\": point[0] + 2,\n",
        "                \"y_min\": point[1] - 1,\n",
        "                \"y_max\": point[1] + 1,\n",
        "                \"delta_x\": 0.025,\n",
        "                \"delta_y\": 0.025,\n",
        "            },\n",
        "            virtual_time=1,\n",
        "        )\n",
        "        random.shuffle(stream_lines.submobjects)\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowPassingFlash,\n",
        "            stream_lines,\n",
        "            run_time=4,\n",
        "        ))\n",
        "\n",
        "\n",
        "class ZToHalfFlowNearWall(ComplexTransformationScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"num_anchors_to_add_per_line\": 200,\n",
        "        \"plane_config\": {\"y_radius\": 8}\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        ComplexTransformationScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        # self.camera.frame.shift(2 * UP)\n",
        "        self.camera.frame.scale(0.5, about_point=ORIGIN)\n",
        "\n",
        "        plane = NumberPlane(\n",
        "            x_radius=15,\n",
        "            y_radius=25,\n",
        "            y_unit_size=0.5,\n",
        "            secondary_line_ratio=0,\n",
        "        )\n",
        "        plane.next_to(ORIGIN, UP, buff=0.001)\n",
        "        horizontal_lines = VGroup(*[l for l in list(planes) + [plane.axes[0]] if np.abs(l.get_center()[0]) < 0.1])\n",
        "        plane.set_stroke(MAROON_B, width=2)\n",
        "        horizontal_lines.set_stroke(BLUE, width=2)\n",
        "\n",
        "        self.prepare_for_transformation(plane)\n",
        "        self.add_transformable_mobjects(plane)\n",
        "\n",
        "        self.background.set_stroke(width=2)\n",
        "        for label in self.background.coordinate_labels:\n",
        "            label.set_stroke(width=0)\n",
        "            label.scale(0.75, about_edge=UR)\n",
        "\n",
        "        words = OldTexText(\"(Idealized) Flow \\\\\\\\\", \"near a wall\")\n",
        "        words.scale(0.75)\n",
        "        words.add_background_rectangle_to_submobjects()\n",
        "        words.next_to(0.75 * UP, LEFT, MED_LARGE_BUFF)\n",
        "        equation = OldTex(\"z \\\\rightarrow z^{1/2}\")\n",
        "        equation.scale(0.75)\n",
        "        equation.add_background_rectangle()\n",
        "        equation.next_to(words, UP)\n",
        "\n",
        "        self.apply_complex_function(\n",
        "            lambda x: x**(1. / 2),\n",
        "            added_anims=[Write(equation)]\n",
        "        )\n",
        "        self.play(Write(words, run_time=1))\n",
        "\n",
        "        def func(point):\n",
        "            z = R3_to_complex(point)\n",
        "            d_half = derivative(lambda z: z**2)\n",
        "            return complex_to_R3(d_half(z).conjugate())\n",
        "\n",
        "        stream_lines = StreamLines(\n",
        "            func,\n",
        "            start_points_generator_config={\n",
        "                \"x_min\": 0.01,\n",
        "                \"y_min\": 0.01,\n",
        "                \"delta_x\": 0.125,\n",
        "                \"delta_y\": 0.125,\n",
        "            },\n",
        "            virtual_time=3,\n",
        "            stroke_width=2,\n",
        "            max_magnitude=10,\n",
        "        )\n",
        "        stream_line_animation = AnimatedStreamLines(stream_lines)\n",
        "\n",
        "        self.add(stream_line_animation)\n",
        "        self.wait(7)\n",
        "\n",
        "\n",
        "class IncmpressibleAndIrrotational(Scene):\n",
        "    def construct(self):\n",
        "        div_0 = OldTexText(\"div$\\\\textbf{F} = 0$\")\n",
        "        curl_0 = OldTexText(\"curl$\\\\textbf{F}$ = 0\")\n",
        "        incompressible = OldTexText(\"Incompressible\")\n",
        "        irrotational = OldTexText(\"Irrotational\")\n",
        "\n",
        "        for text in [div_0, curl_0, incompressible, irrotational]:\n",
        "            self.stylize_word_for_background(text)\n",
        "\n",
        "        div_0.to_edge(UP)\n",
        "        curl_0.next_to(div_0, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        for op, word in (div_0, incompressible), (curl_0, irrotational):\n",
        "            op.generate_target()\n",
        "            group = VGroup(op.target, word)\n",
        "            group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "            group.move_to(op)\n",
        "\n",
        "        self.play(FadeInFromDown(div_0))\n",
        "        self.play(FadeInFromDown(curl_0))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(div_0),\n",
        "            FadeInFromDown(incompressible),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(curl_0),\n",
        "            FadeInFromDown(irrotational),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(VGroup(curl_0, irrotational))\n",
        "        question = OldTexText(\"Does this actually happen?\")\n",
        "        question.next_to(rect, DOWN)\n",
        "        question.match_color(rect)\n",
        "        self.stylize_word_for_background(question)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "    def stylize_word_for_background(self, word):\n",
        "        word.add_background_rectangle()\n",
        "\n",
        "\n",
        "class NoChargesOverlay(Scene):\n",
        "    def construct(self):\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        rect.set_fill(BLUE_D, 0.75)\n",
        "        circle = Circle(radius=1.5, num_anchors=5000)\n",
        "        circle.rotate(135 * DEGREES)\n",
        "        rect.add_subpath(circle.get_points())\n",
        "\n",
        "        words = OldTexText(\"No charges outside wire\")\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(rect, words)\n",
        "\n",
        "\n",
        "# End message\n",
        "class BroughtToYouBy(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"pi_creatures_start_on_screen\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.brought_to_you_by()\n",
        "        self.just_you_and_me()\n",
        "\n",
        "    def brought_to_you_by(self):\n",
        "        so_words = OldTexText(\"So\", \"...\", arg_separator=\"\")\n",
        "        so_words.scale(2)\n",
        "\n",
        "        btyb = OldTexText(\"Brought to you\", \"by\")\n",
        "        btyb.scale(1.5)\n",
        "        btyb_line = Line(LEFT, RIGHT)\n",
        "        btyb_line.next_to(btyb, RIGHT, SMALL_BUFF)\n",
        "        btyb_line.align_to(btyb[0], DOWN)\n",
        "        btyb_group = VGroup(btyb, btyb_line)\n",
        "        btyb_group.center()\n",
        "\n",
        "        you_word = OldTexText(\"\\\\emph{you}\")\n",
        "        you_word.set_color(YELLOW)\n",
        "        you_word.scale(1.75)\n",
        "        you_word.move_to(btyb_line)\n",
        "        you_word.align_to(btyb, DOWN)\n",
        "\n",
        "        only_word = OldTexText(\"(only)\")\n",
        "        only_word.scale(1.25)\n",
        "        only_brace = Brace(only_word, DOWN, buff=SMALL_BUFF)\n",
        "        only_group = VGroup(only_word, only_brace)\n",
        "        only_group.next_to(\n",
        "            VGroup(btyb[0][-1], btyb[1][0]), UP, SMALL_BUFF\n",
        "        )\n",
        "        only_group.set_color(RED)\n",
        "\n",
        "        full_group = VGroup(btyb_group, only_group, you_word)\n",
        "        full_group.generate_target()\n",
        "        full_group.target.scale(0.4)\n",
        "        full_group.target.to_corner(UL)\n",
        "\n",
        "        patreon_logo = PatreonLogo()\n",
        "        patreon_logo.scale(0.4)\n",
        "        patreon_logo.next_to(full_group.target, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(so_words[0]),\n",
        "            LaggedStartMap(\n",
        "                DrawBorderThenFill, so_words[1],\n",
        "                run_time=5\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            so_words.shift, DOWN,\n",
        "            so_words.fade, 1,\n",
        "            remover=True\n",
        "        )\n",
        "        self.play(FadeInFromDown(btyb_group))\n",
        "        self.wait()\n",
        "        self.play(Write(you_word))\n",
        "        self.play(\n",
        "            GrowFromCenter(only_brace),\n",
        "            Write(only_word)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(\n",
        "            full_group,\n",
        "            rate_func=running_start,\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, patreon_logo\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def just_you_and_me(self):\n",
        "        randy, morty = self.pi_creatures\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.change(\"pondering\")\n",
        "        math = OldTex(\"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\")\n",
        "        math.scale(2)\n",
        "        math.move_to(self.pi_creatures)\n",
        "\n",
        "        spiral = Line(0.5 * RIGHT, 0.5 * RIGHT + 70 * UP)\n",
        "        spiral.insert_n_curves(1000)\n",
        "        from _2017.eoc.zeta import zeta\n",
        "        spiral.apply_complex_function(zeta)\n",
        "        step = 0.1\n",
        "        spiral = VGroup(*[\n",
        "            VMobject().pointwise_become_partial(\n",
        "                spiral, a, a + step\n",
        "            )\n",
        "            for a in np.arange(0, 1, step)\n",
        "        ])\n",
        "        spiral.set_color_by_gradient(BLUE, YELLOW, RED)\n",
        "        spiral.scale(0.5)\n",
        "        spiral.move_to(math)\n",
        "\n",
        "        self.play(FadeInFromDown(randy))\n",
        "        self.play(FadeInFromDown(morty))\n",
        "        self.play(\n",
        "            Write(math),\n",
        "            randy.change, \"hooray\",\n",
        "            morty.change, \"hooray\",\n",
        "        )\n",
        "        self.look_at(math)\n",
        "        self.play(\n",
        "            ShowCreation(spiral, run_time=6, rate_func=linear),\n",
        "            math.scale, 0.5,\n",
        "            math.shift, 3 * UP,\n",
        "            randy.change, \"thinking\",\n",
        "            morty.change, \"thinking\",\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeOut, spiral, run_time=3))\n",
        "        self.wait(3)\n",
        "\n",
        "    # Helpers\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        randy.to_edge(DOWN).shift(4 * LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.to_edge(DOWN).shift(4 * RIGHT)\n",
        "        return VGroup(randy, morty)\n",
        "\n",
        "\n",
        "class ThoughtsOnAds(Scene):\n",
        "    def construct(self):\n",
        "        title = Title(\n",
        "            \"Internet advertising\",\n",
        "            match_underline_width_to_text=True,\n",
        "            underline_buff=SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        line = NumberLine(\n",
        "            color=GREY_B,\n",
        "            x_min=0,\n",
        "            x_max=12,\n",
        "            big_tick_numbers=[]\n",
        "        )\n",
        "        line.move_to(DOWN)\n",
        "\n",
        "        arrows = VGroup(Vector(2 * LEFT), Vector(2 * RIGHT))\n",
        "        arrows.arrange(RIGHT, buff=2)\n",
        "        arrows.next_to(line, DOWN)\n",
        "\n",
        "        misaligned = OldTexText(\"Misaligned\")\n",
        "        misaligned.next_to(arrows[0], DOWN)\n",
        "        aligned = OldTexText(\"Well-aligned\")\n",
        "        aligned.next_to(arrows[1], DOWN)\n",
        "\n",
        "        VGroup(arrows[0], misaligned).set_color(RED)\n",
        "        VGroup(arrows[1], aligned).set_color(BLUE)\n",
        "\n",
        "        left_text = OldTexText(\n",
        "            \"Any website presented \\\\\\\\\",\n",
        "            \"as a click-maximizing \\\\\\\\ slideshow\"\n",
        "        )\n",
        "        left_text.scale(0.8)\n",
        "        left_text.next_to(line, UP, buff=MED_LARGE_BUFF)\n",
        "        left_text.to_edge(LEFT)\n",
        "\n",
        "        viewer, brand, creator = vcb = VGroup(\n",
        "            *list(map(TexText, [\"viewer\", \"brand\", \"creator\"]))\n",
        "        )\n",
        "        brand.next_to(creator, LEFT, LARGE_BUFF)\n",
        "        viewer.next_to(vcb[1:], UP, LARGE_BUFF)\n",
        "        arrow_config = {\n",
        "            \"path_arc\": 60 * DEGREES,\n",
        "            \"tip_length\": 0.15,\n",
        "        }\n",
        "        vcb_arrows = VGroup(*[\n",
        "            VGroup(\n",
        "                Arrow(p1, p2, **arrow_config),\n",
        "                Arrow(p2, p1, **arrow_config),\n",
        "            )\n",
        "            for p1, p2 in [\n",
        "                (creator.get_left(), brand.get_right()),\n",
        "                (brand.get_top(), viewer.get_bottom()),\n",
        "                (viewer.get_bottom(), creator.get_top()),\n",
        "            ]\n",
        "        ])\n",
        "        vcb_arrows.set_stroke(width=2)\n",
        "        vcb_arrows.set_color(BLUE)\n",
        "        vcb_group = VGroup(vcb, vcb_arrows)\n",
        "        vcb_group.next_to(line, UP, buff=MED_LARGE_BUFF)\n",
        "        vcb_group.to_edge(RIGHT)\n",
        "\n",
        "        knob = RegularPolygon(n=3, start_angle=-90 * DEGREES)\n",
        "        knob.set_height(0.25)\n",
        "        knob.set_stroke(width=0)\n",
        "        knob.set_fill(YELLOW, 1)\n",
        "        knob.move_to(line.get_left(), DOWN)\n",
        "\n",
        "        right_rect = Rectangle(\n",
        "            width=3,\n",
        "            height=0.25,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=2,\n",
        "            fill_color=BLUE,\n",
        "            fill_opacity=0.5\n",
        "        )\n",
        "        right_rect.move_to(line, RIGHT)\n",
        "        right_rect_label = Group(\n",
        "            ImageMobject(\"3b1b_logo\", height=1),\n",
        "            OldTexText(\"(hopefully)\").scale(0.8)\n",
        "        )\n",
        "        right_rect_label.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        # OldTexText(\n",
        "        #     \"Where I hope \\\\\\\\ I've been\"\n",
        "        # )\n",
        "        right_rect_label.next_to(\n",
        "            right_rect, UP, SMALL_BUFF\n",
        "        )\n",
        "        # right_rect_label.set_color(BLUE)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(\n",
        "            Write(misaligned),\n",
        "            Write(aligned),\n",
        "            *list(map(GrowArrow, arrows)),\n",
        "            run_time=1\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(left_text),\n",
        "            FadeIn(knob, 2 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, vcb),\n",
        "            LaggedStartMap(ShowCreation, vcb_arrows),\n",
        "            ApplyMethod(\n",
        "                knob.move_to, line.get_right(), DOWN,\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(vcb_group.shift, 2 * UP)\n",
        "        self.play(\n",
        "            DrawBorderThenFill(right_rect),\n",
        "            FadeIn(right_rect_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HoldUpPreviousPromo(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"default_pi_creature_kwargs\": {\n",
        "            \"color\": GREY_BROWN,\n",
        "            \"flip_at_start\": True,\n",
        "        },\n",
        "        \"default_pi_creature_start_corner\": DR,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        screen_rect = ScreenRectangle(height=5)\n",
        "        screen_rect.to_corner(UL)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(screen_rect),\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class GoalWrapper(Scene):\n",
        "    def construct(self):\n",
        "        goal = OldTexText(\n",
        "            \"Goal: Teach/remind people \\\\\\\\ that they love math\"\n",
        "        )\n",
        "        goal.to_edge(UP)\n",
        "        self.add(goal)\n",
        "\n",
        "        screen_rect = ScreenRectangle(height=6)\n",
        "        screen_rect.next_to(goal, DOWN)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PeopleValueGraph(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\": \"People reached\",\n",
        "        \"y_axis_label\": \"Value per person\",\n",
        "        \"x_min\": 0,\n",
        "        \"x_max\": 12,\n",
        "        \"x_axis_width\": 11,\n",
        "        \"y_max\": 8,\n",
        "        \"y_axis_height\": 5,\n",
        "        \"graph_origin\": 2 * DOWN + 5 * LEFT,\n",
        "        \"riemann_rectangles_config\": {\n",
        "            \"dx\": 0.01,\n",
        "            \"stroke_width\": 0,\n",
        "            \"start_color\": GREEN,\n",
        "            \"end_color\": BLUE,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.tweak_labels()\n",
        "        self.add_curve()\n",
        "        self.comment_on_incentives()\n",
        "        self.change_curve()\n",
        "\n",
        "    def tweak_labels(self):\n",
        "        self.add_foreground_mobjects(self.x_axis_label_mob)\n",
        "        self.y_axis_label_mob.to_edge(LEFT)\n",
        "\n",
        "    def add_curve(self):\n",
        "        graph = self.graph = self.get_graph(\n",
        "            lambda x: 7 * np.exp(-0.5 * x),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "    def comment_on_incentives(self):\n",
        "        reach_arrow = Vector(5 * RIGHT)\n",
        "        reach_arrow.next_to(\n",
        "            self.x_axis, DOWN,\n",
        "            buff=SMALL_BUFF,\n",
        "            aligned_edge=RIGHT\n",
        "        )\n",
        "        reach_words = OldTexText(\"Maximize reach?\")\n",
        "        reach_words.next_to(reach_arrow, DOWN, buff=SMALL_BUFF)\n",
        "        reach_words.match_color(reach_arrow)\n",
        "\n",
        "        area = self.area = self.get_riemann_rectangles(\n",
        "            self.graph, **self.riemann_rectangles_config\n",
        "        )\n",
        "        area_words = OldTexText(\"Maximize this area\")\n",
        "        area_words.set_color(BLUE)\n",
        "        area_words.move_to(self.coords_to_point(4, 5))\n",
        "        area_arrow = Arrow(\n",
        "            area_words.get_bottom(),\n",
        "            self.coords_to_point(1.5, 2)\n",
        "        )\n",
        "\n",
        "        self.play(GrowArrow(reach_arrow))\n",
        "        self.play(Write(reach_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, area),\n",
        "            Animation(self.graph),\n",
        "            Animation(self.axes),\n",
        "            Write(area_words),\n",
        "            GrowArrow(area_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.area_label_group = VGroup(area_words, area_arrow)\n",
        "\n",
        "    def change_curve(self):\n",
        "        new_graph = self.get_graph(\n",
        "            lambda x: interpolate(\n",
        "                7 * np.exp(-0.01 * x),\n",
        "                7 * np.exp(-3 * x),\n",
        "                smooth(np.clip(x / 5, 0, 1))\n",
        "            )\n",
        "        )\n",
        "        new_area = self.get_riemann_rectangles(\n",
        "            new_graph, **self.riemann_rectangles_config\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.area, new_area),\n",
        "            Transform(self.graph, new_graph),\n",
        "            self.area_label_group[0].shift, RIGHT,\n",
        "            Animation(self.area_label_group),\n",
        "            Animation(self.axes),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DivCurlEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Keith Smith\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Desmos \",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Andrew Sachs\",\n",
        "            \"Devin Scott\",\n",
        "            \"Akash Kumar\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Fela \",\n",
        "            \"Fred Ehrsam\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Marek Cirkos\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Cooper Jones\",\n",
        "            \"James Hughes\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Chris Giddings\",\n",
        "            \"Song Gao\",\n",
        "            \"Alexander Feldman\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"John Griffith\",\n",
        "            \"Chris Connett\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Bong Choung\",\n",
        "            \"Ignacio Freiberg\",\n",
        "            \"Zhilong Yang\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Eric Younge\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"James H. Park\",\n",
        "            \"Norton Wang\",\n",
        "            \"Kevin Le\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"David MacCumber\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"Dave B\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"George Chiesa\",\n",
        "            \"supershabam \",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Awoo \",\n",
        "            \"Dr . David G. Stork\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon \",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Sh\\\\`im\\\\'in Ku\\\\=ang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n"
    ]
}