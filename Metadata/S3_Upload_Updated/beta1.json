{
    "topic": "demonstrates the concept of a binomial distribution and its relationship with the beta function.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2020.beta.helpers import *\n",
        "\n",
        "import scipy.stats\n",
        "\n",
        "OUTPUT_DIRECTORY = \"bayes/beta1\"\n",
        "\n",
        "\n",
        "# Scenes\n",
        "class BarChartTest(Scene):\n",
        "    def construct(self):\n",
        "        bar_chart = BarChart()\n",
        "        bar_chart.to_edge(DOWN)\n",
        "        self.add(bar_chart)\n",
        "\n",
        "\n",
        "class Thumbnail1(Scene):\n",
        "    def construct(self):\n",
        "        p1 = \"$96\\\\%$\"\n",
        "        p2 = \"$93\\\\%$\"\n",
        "        n1 = \"50\"\n",
        "        n2 = \"200\"\n",
        "        t2c = {\n",
        "            p1: BLUE,\n",
        "            p2: YELLOW,\n",
        "            n1: BLUE_C,\n",
        "            n2: YELLOW,\n",
        "        }\n",
        "        kw = {\"tex_to_color_map\": t2c}\n",
        "        text = VGroup(\n",
        "            OldTexText(f\"{p1} with {n1} reviews\", **kw),\n",
        "            OldTexText(\"vs.\", **kw),\n",
        "            OldTexText(f\"{p2} with {n2} reviews\", **kw),\n",
        "        )\n",
        "        text.scale(2)\n",
        "        text.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        text.set_width(FRAME_WIDTH - 1)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class AltThumbnail1(Scene):\n",
        "    def construct(self):\n",
        "        N = 20\n",
        "        n_trials = 10000\n",
        "        p = 0.7\n",
        "        outcomes = (np.random.random((N, n_trials)) < p).sum(0)\n",
        "        counts = []\n",
        "        for k in range(N + 1):\n",
        "            counts.append((outcomes == k).sum())\n",
        "\n",
        "        hist = Histogram(\n",
        "            counts,\n",
        "            y_max=0.3,\n",
        "            y_tick_freq=0.05,\n",
        "            y_axis_numbers_to_show=[10, 20, 30],\n",
        "            x_label_freq=10,\n",
        "        )\n",
        "        hist.set_width(FRAME_WIDTH - 1)\n",
        "        hist.bars.set_submobject_colors_by_gradient(YELLOW, YELLOW, GREEN, BLUE)\n",
        "        hist.bars.set_stroke(WHITE, 2)\n",
        "\n",
        "        title = OldTexText(\"Binomial distribution\")\n",
        "        title.set_width(12)\n",
        "        title.to_corner(UR, buff=0.8)\n",
        "        title.add_background_rectangle()\n",
        "\n",
        "        self.add(hist)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "class Thumbnail2(Scene):\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        graph = get_beta_graph(axes, 2, 2)\n",
        "        # sub_graph = axes.get_graph(\n",
        "        #     lambda x: (1 - x) * graph.underlying_function(x)\n",
        "        # )\n",
        "        # sub_graph.add_line_to(axes.c2p(1, 0))\n",
        "        # sub_graph.add_line_to(axes.c2p(0, 0))\n",
        "        # sub_graph.set_stroke(YELLOW, 4)\n",
        "        # sub_graph.set_fill(YELLOW_D, 1)\n",
        "\n",
        "        new_graph = get_beta_graph(axes, 9, 2)\n",
        "        new_graph.set_stroke(GREEN, 4)\n",
        "        new_graph.set_fill(GREEN, 0.5)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph)\n",
        "        self.add(new_graph)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            axes.input_to_graph_point(0.5, graph),\n",
        "            axes.input_to_graph_point(0.8, new_graph),\n",
        "            path_arc=-90 * DEGREES,\n",
        "            buff=0.3\n",
        "        )\n",
        "        self.add(arrow)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"P(H|D) = {P(H)P(D|H) \\\\over P(D)}\",\n",
        "            tex_to_color_map={\n",
        "                \"H\": YELLOW,\n",
        "                \"D\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        formula.next_to(axes.c2p(0, 3), RIGHT, LARGE_BUFF)\n",
        "        formula.set_height(1.5)\n",
        "        formula.to_edge(LEFT)\n",
        "        formula.to_edge(UP, LARGE_BUFF)\n",
        "        formula.add_to_back(BackgroundRectangle(formula[:4], buff=0.25))\n",
        "\n",
        "        self.add(formula)\n",
        "\n",
        "    def get_axes(self, y_max=3, y_height=4.5, y_unit=0.5):\n",
        "        axes = get_beta_dist_axes(y_max=y_max, y_unit=y_unit)\n",
        "        axes.y_axis.set_height(y_height, about_point=axes.c2p(0, 0))\n",
        "        axes.to_edge(DOWN)\n",
        "        axes.scale(0.9)\n",
        "        return axes\n",
        "\n",
        "\n",
        "class Thumbnail3(Thumbnail2):\n",
        "    def construct(self):\n",
        "        axes = self.get_axes(y_max=4, y_height=6)\n",
        "        axes.set_height(7)\n",
        "        graph = get_beta_graph(axes, 9, 2)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph)\n",
        "\n",
        "        label = OldTex(\n",
        "            \"\\\\text{Beta}(10, 3)\",\n",
        "            tex_to_color_map={\n",
        "                \"10\": GREEN,\n",
        "                \"3\": RED,\n",
        "            }\n",
        "        )\n",
        "        label = get_beta_label(9, 2)\n",
        "        label.set_height(1.25)\n",
        "        label.next_to(axes.c2p(0, 3), RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.add(label)\n",
        "\n",
        "\n",
        "class HighlightReviewParts(Scene):\n",
        "    CONFIG = {\n",
        "        \"reverse_order\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup up rectangles\n",
        "        rects = VGroup(*[Rectangle() for x in range(3)])\n",
        "        rects.set_stroke(width=0)\n",
        "        rects.set_fill(GREY, 0.5)\n",
        "\n",
        "        rects.set_height(1.35, stretch=True)\n",
        "        rects.set_width(9.75, stretch=True)\n",
        "\n",
        "        rects[0].move_to([-0.2, 0.5, 0])\n",
        "        rects[1].next_to(rects[0], DOWN, buff=0)\n",
        "        rects[2].next_to(rects[1], DOWN, buff=0)\n",
        "\n",
        "        rects[2].set_height(1, stretch=True, about_edge=UP)\n",
        "\n",
        "        inv_rects = VGroup()\n",
        "        for rect in rects:\n",
        "            fsr = FullScreenFadeRectangle()\n",
        "            fsr.append_points(rect.get_points()[::-1])\n",
        "            inv_rects.add(fsr)\n",
        "\n",
        "        inv_rects.set_fill(BLACK, 0.85)\n",
        "\n",
        "        # Set up labels\n",
        "        ratings = [100, 96, 93]\n",
        "        n_reviews = [10, 50, 200]\n",
        "        colors = [PINK, BLUE, YELLOW]\n",
        "\n",
        "        review_labels = VGroup()\n",
        "        for rect, rating, nr, color in zip(rects, ratings, n_reviews, colors):\n",
        "            label = OldTex(\n",
        "                f\"{nr}\", \"\\\\text{ reviews }\",\n",
        "                f\"{rating}\", \"\\\\%\",\n",
        "            )\n",
        "            label[2:].set_color(color)\n",
        "            label.set_height(1)\n",
        "            label.next_to(rect, UP, aligned_edge=RIGHT)\n",
        "            label.set_stroke(BLACK, 4, background=True)\n",
        "            fix_percent(label[3][0])\n",
        "            review_labels.add(label)\n",
        "\n",
        "        # Animations\n",
        "        curr_fsr = inv_rects[0]\n",
        "        curr_label = None\n",
        "\n",
        "        tuples = list(zip(inv_rects, review_labels))\n",
        "        if self.reverse_order:\n",
        "            tuples = reversed(tuples)\n",
        "            curr_fsr = inv_rects[-1]\n",
        "\n",
        "        for fsr, label in tuples:\n",
        "            if curr_fsr is fsr:\n",
        "                self.play(VFadeIn(fsr))\n",
        "            else:\n",
        "                self.play(\n",
        "                    Transform(curr_fsr, fsr),\n",
        "                    MoveToTarget(curr_label),\n",
        "                )\n",
        "\n",
        "            first, second = label[2:], label[:2]\n",
        "            if self.reverse_order:\n",
        "                first, second = second, first\n",
        "\n",
        "            self.add(first)\n",
        "            self.wait(2)\n",
        "            self.add(second)\n",
        "            self.wait(2)\n",
        "\n",
        "            label.generate_target()\n",
        "            label.target.scale(0.3)\n",
        "            if curr_label is None:\n",
        "                label.target.to_corner(UR)\n",
        "                label.target.shift(MED_LARGE_BUFF * LEFT)\n",
        "            else:\n",
        "                label.target.next_to(curr_label, DOWN)\n",
        "\n",
        "            curr_label = label\n",
        "        self.play(MoveToTarget(curr_label))\n",
        "        self.wait()\n",
        "\n",
        "        br = BackgroundRectangle(review_labels, buff=0.25)\n",
        "        br.set_fill(BLACK, 0.85)\n",
        "        br.set_width(FRAME_WIDTH)\n",
        "        br.set_height(FRAME_HEIGHT, stretch=True)\n",
        "        br.center()\n",
        "        self.add(br, review_labels)\n",
        "        self.play(\n",
        "            FadeOut(curr_fsr),\n",
        "            FadeIn(br),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowThreeCases(Scene):\n",
        "    def construct(self):\n",
        "        titles = self.get_titles()\n",
        "        reviews = self.get_reviews(titles)\n",
        "        for review in reviews:\n",
        "            review.match_x(reviews[2])\n",
        "\n",
        "        # Introduce everything\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, titles,\n",
        "            lambda m: (m, DOWN),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.play(LaggedStart(*[\n",
        "            LaggedStartMap(\n",
        "                FadeInFromLarge, review,\n",
        "                lag_ratio=0.1\n",
        "            )\n",
        "            for review in reviews\n",
        "        ], lag_ratio=0.1))\n",
        "        self.add(reviews)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(reviews[2]))\n",
        "        self.wait()\n",
        "\n",
        "        # Suspicious of 100%\n",
        "        randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.set_height(2)\n",
        "        randy.next_to(\n",
        "            reviews[0], RIGHT, LARGE_BUFF,\n",
        "            aligned_edge=UP,\n",
        "        )\n",
        "        randy.look_at(reviews[0])\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"sassy\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        # Low number means it could be a fluke.\n",
        "        review = reviews[0]\n",
        "\n",
        "        review.generate_target()\n",
        "        review.target.scale(2)\n",
        "        review.target.arrange(RIGHT)\n",
        "        review.target.move_to(review)\n",
        "\n",
        "        self.play(MoveToTarget(review))\n",
        "\n",
        "        alt_negs = [1, 2, 1, 0]\n",
        "        alt_reviews = VGroup()\n",
        "        for k in alt_negs:\n",
        "            alt_reviews.add(self.get_plusses_and_minuses(titles[0], 1, 10, k))\n",
        "        for ar in alt_reviews:\n",
        "            for m1, m2 in zip(ar, review):\n",
        "                m1.replace(m2)\n",
        "\n",
        "        alt_percents = VGroup(*[\n",
        "            OldTex(str(10 * (10 - k)) + \"\\\\%\")\n",
        "            for k in alt_negs\n",
        "        ])\n",
        "        hundo = titles[0][0]\n",
        "        for ap in alt_percents:\n",
        "            fix_percent(ap.family_members_with_points()[-1])\n",
        "            ap.match_style(hundo)\n",
        "            ap.match_height(hundo)\n",
        "            ap.move_to(hundo, RIGHT)\n",
        "\n",
        "        last_review = review\n",
        "        last_percent = hundo\n",
        "        for ar, ap in zip(alt_reviews, alt_percents):\n",
        "            self.play(\n",
        "                FadeIn(ar, 0.5 * DOWN, lag_ratio=0.2),\n",
        "                FadeOut(last_review),\n",
        "                FadeIn(ap, 0.5 * DOWN),\n",
        "                FadeOut(last_percent, 0.5 * UP),\n",
        "                run_time=1.5\n",
        "            )\n",
        "            last_review = ar\n",
        "            last_percent = ap\n",
        "        self.remove(last_review, last_percent)\n",
        "        self.add(titles, *reviews)\n",
        "\n",
        "        # How do you think about the tradeoff?\n",
        "        p1 = titles[1][0]\n",
        "        p2 = titles[2][0]\n",
        "        nums = VGroup(p1, p2)\n",
        "        lower_reviews = reviews[1:]\n",
        "        lower_reviews.generate_target()\n",
        "        lower_reviews.target.arrange(LEFT, buff=1.5)\n",
        "        lower_reviews.target.center()\n",
        "        nums.generate_target()\n",
        "        for nt, review in zip(nums.target, lower_reviews.target):\n",
        "            nt.next_to(review, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        nums.target[0].match_y(nums.target[1])\n",
        "\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            MoveToTarget(lower_reviews),\n",
        "            MoveToTarget(nums),\n",
        "            FadeOut(titles[1][1:]),\n",
        "            FadeOut(titles[2][1:]),\n",
        "            FadeOut(titles[0]),\n",
        "            FadeOut(reviews[0]),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        greater_than = OldTex(\">\")\n",
        "        greater_than.scale(2)\n",
        "        greater_than.move_to(midpoint(\n",
        "            reviews[2].get_right(),\n",
        "            reviews[1].get_left(),\n",
        "        ))\n",
        "        less_than = greater_than.copy().flip()\n",
        "        less_than.match_height(nums[0][0])\n",
        "        less_than.match_y(nums, DOWN)\n",
        "\n",
        "        nums.generate_target()\n",
        "        nums.target[1].next_to(less_than, LEFT, MED_LARGE_BUFF)\n",
        "        nums.target[0].next_to(less_than, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        squares = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                submob, buff=0.01,\n",
        "                stroke_color=GREY_B,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "            for submob in reviews[2]\n",
        "        ])\n",
        "        squares.shuffle()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeOut, squares,\n",
        "                lag_ratio=0.5 / len(squares),\n",
        "                run_time=3,\n",
        "            ),\n",
        "            Write(greater_than),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(nums),\n",
        "            TransformFromCopy(\n",
        "                greater_than, less_than,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_titles(self):\n",
        "        titles = VGroup(\n",
        "            OldTexText(\n",
        "                \"$100\\\\%$ \\\\\\\\\",\n",
        "                \"10 reviews\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"$96\\\\%$ \\\\\\\\\",\n",
        "                \"50 reviews\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"$93\\\\%$ \\\\\\\\\",\n",
        "                \"200 reviews\"\n",
        "            ),\n",
        "        )\n",
        "        colors = [PINK, BLUE, YELLOW]\n",
        "        for title, color in zip(titles, colors):\n",
        "            fix_percent(title[0][-1])\n",
        "            title[0].set_color(color)\n",
        "\n",
        "        titles.scale(1.25)\n",
        "        titles.arrange(DOWN, buff=1.5)\n",
        "        titles.to_corner(UL)\n",
        "        return titles\n",
        "\n",
        "    def get_reviews(self, titles):\n",
        "        return VGroup(\n",
        "            self.get_plusses_and_minuses(\n",
        "                titles[0], 5, 2, 0,\n",
        "            ),\n",
        "            self.get_plusses_and_minuses(\n",
        "                titles[1], 5, 10, 2,\n",
        "            ),\n",
        "            self.get_plusses_and_minuses(\n",
        "                titles[2], 8, 25, 14,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def get_plusses_and_minuses(self, title, n_rows, n_cols, n_minus):\n",
        "        check = OldTex(CMARK_TEX, color=GREEN)\n",
        "        cross = OldTex(XMARK_TEX, color=RED)\n",
        "        checks = VGroup(*[\n",
        "            check.copy() for x in range(n_rows * n_cols)\n",
        "        ])\n",
        "        checks.arrange_in_grid(n_rows=n_rows, n_cols=n_cols)\n",
        "        checks.scale(0.5)\n",
        "        # if checks.get_height() > title.get_height():\n",
        "        #     checks.match_height(title)\n",
        "        checks.next_to(title, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        for check in random.sample(list(checks), n_minus):\n",
        "            mob = cross.copy()\n",
        "            mob.replace(check, dim_to_match=0)\n",
        "            check.become(mob)\n",
        "\n",
        "        return checks\n",
        "\n",
        "\n",
        "class PreviewThreeVideos(Scene):\n",
        "    def construct(self):\n",
        "        # Write equations\n",
        "        equations = VGroup(\n",
        "            OldTex(\"{10\", \"\\\\over\", \"10}\", \"=\", \"100\\\\%\"),\n",
        "            OldTex(\"{48\", \"\\\\over\", \"50}\", \"=\", \"96\\\\%\"),\n",
        "            OldTex(\"{186\", \"\\\\over\", \"200}\", \"=\", \"93\\\\%\"),\n",
        "        )\n",
        "        equations.arrange(RIGHT, buff=3)\n",
        "        equations.to_edge(UP)\n",
        "\n",
        "        colors = [PINK, BLUE, YELLOW]\n",
        "        for eq, color in zip(equations, colors):\n",
        "            eq[-1].set_color(color)\n",
        "            fix_percent(eq[-1][-1])\n",
        "\n",
        "        vs_labels = VGroup(*[TexText(\"vs.\") for x in range(2)])\n",
        "        for eq1, eq2, vs in zip(equations, equations[1:], vs_labels):\n",
        "            vs.move_to(midpoint(eq1.get_right(), eq2.get_left()))\n",
        "\n",
        "        self.add(equations)\n",
        "        self.add(vs_labels)\n",
        "\n",
        "        # Show topics\n",
        "        title = OldTexText(\"To be explained:\")\n",
        "        title.set_height(0.7)\n",
        "        title.next_to(equations, DOWN, LARGE_BUFF)\n",
        "        title.to_edge(LEFT)\n",
        "        title.add(Underline(title))\n",
        "\n",
        "        topics = VGroup(\n",
        "            OldTexText(\"Binomial distributions\"),\n",
        "            OldTexText(\"Bayesian updating\"),\n",
        "            OldTexText(\"Probability density functions\"),\n",
        "            OldTexText(\"Beta distribution\"),\n",
        "        )\n",
        "        topics.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        topics.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        topics.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        bullets = VGroup()\n",
        "        for topic in topics:\n",
        "            bullet = Dot()\n",
        "            bullet.next_to(topic, LEFT)\n",
        "            bullets.add(bullet)\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            Write(bullets),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeIn(topic, lag_ratio=0.1)\n",
        "            for topic in topics\n",
        "        ], run_time=3, lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        # Show videos\n",
        "        images = [\n",
        "            ImageMobject(os.path.join(\n",
        "                consts.VIDEO_DIR,\n",
        "                OUTPUT_DIRECTORY,\n",
        "                \"images\",\n",
        "                name\n",
        "            ))\n",
        "            for name in [\"Thumbnail1\", \"Thumbnail2\", \"Thumbnail3\"]\n",
        "        ]\n",
        "        thumbnails = Group()\n",
        "        for image in images:\n",
        "            image.set_width(FRAME_WIDTH / 3 - 1)\n",
        "            rect = SurroundingRectangle(image, buff=0)\n",
        "            rect.set_stroke(WHITE, 3)\n",
        "            rect.set_fill(BLACK, 1)\n",
        "            thumbnails.add(Group(rect, image))\n",
        "\n",
        "        thumbnails.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        for topic, i in zip(topics, [0, 1, 1, 2]):\n",
        "            thumbnail = thumbnails[i]\n",
        "            topic.generate_target()\n",
        "            topic.target.scale(0.6)\n",
        "            topic.target.next_to(thumbnail, DOWN, aligned_edge=LEFT)\n",
        "        topics[2].target.next_to(\n",
        "            topics[1].target, DOWN,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title, LEFT),\n",
        "            FadeOut(bullets, LEFT),\n",
        "            LaggedStartMap(MoveToTarget, topics),\n",
        "            LaggedStartMap(FadeIn, thumbnails),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        tn_groups = Group(\n",
        "            Group(thumbnails[0], topics[0]),\n",
        "            Group(thumbnails[1], topics[1], topics[2]),\n",
        "            Group(thumbnails[2], topics[3]),\n",
        "        )\n",
        "\n",
        "        setup_words = OldTexText(\"Set up the model\")\n",
        "        analysis_words = OldTexText(\"Analysis\")\n",
        "        for words in [setup_words, analysis_words]:\n",
        "            words.scale(topics[0][0].get_height() / words[0][0].get_height())\n",
        "            words.set_color(YELLOW)\n",
        "        setup_words.move_to(topics[0], UL)\n",
        "        analysis_words.next_to(topics[3], DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        def set_opacity(mob, alpha):\n",
        "            for sm in mob.family_members_with_points():\n",
        "                sm.set_opacity(alpha)\n",
        "            return mob\n",
        "\n",
        "        self.play(ApplyFunction(lambda m: set_opacity(m, 0.2), tn_groups[1:]))\n",
        "        self.play(\n",
        "            FadeIn(setup_words, lag_ratio=0.1),\n",
        "            topics[0].next_to, setup_words, DOWN, {\"aligned_edge\": LEFT},\n",
        "        )\n",
        "        tn_groups[0].add(setup_words)\n",
        "        self.wait(2)\n",
        "        for i in 0, 1:\n",
        "            self.play(\n",
        "                ApplyFunction(lambda m: set_opacity(m, 0.2), tn_groups[i]),\n",
        "                ApplyFunction(lambda m: set_opacity(m, 1), tn_groups[i + 1]),\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play(FadeIn(analysis_words, 0.25 * UP))\n",
        "        tn_groups[2].add(analysis_words)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(setup_words),\n",
        "            FadeOut(topics[0]),\n",
        "            FadeOut(tn_groups[1]),\n",
        "            FadeOut(tn_groups[2]),\n",
        "            FadeOut(vs_labels, UP),\n",
        "            FadeOut(equations, UP),\n",
        "            ApplyFunction(lambda m: set_opacity(m, 1), thumbnails[0]),\n",
        "        )\n",
        "        thumbnails[0].generate_target()\n",
        "        # thumbnails[0].target.set_width(FRAME_WIDTH)\n",
        "        # thumbnails[0].target.center()\n",
        "        thumbnails[0].target.to_edge(UP)\n",
        "        self.play(MoveToTarget(thumbnails[0], run_time=4))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LetsLookAtOneAnswer(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        self.teacher_says(\n",
        "            \"Let me show you\\\\\\\\one answer.\",\n",
        "            added_anims=[\n",
        "                self.change_students(\"pondering\", \"thinking\", \"pondering\")\n",
        "            ]\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.play_all_student_changes(\"thinking\", look_at=self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class LaplacesRuleOfSuccession(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        title = OldTexText(\"How to read a rating\")\n",
        "        title.set_height(0.75)\n",
        "        title.to_edge(UP)\n",
        "        underline = Underline(title)\n",
        "        underline.scale(1.2)\n",
        "        self.add(title, underline)\n",
        "\n",
        "        data = get_checks_and_crosses(11 * [True] + [False], width=10)\n",
        "        data.shift(DOWN)\n",
        "        underlines = get_underlines(data)\n",
        "\n",
        "        real_data = data[:10]\n",
        "        fake_data = data[10:]\n",
        "\n",
        "        def get_review_label(num, denom):\n",
        "            result = VGroup(\n",
        "                Integer(num, color=GREEN),\n",
        "                OldTexText(\"out of\"),\n",
        "                Integer(denom),\n",
        "            )\n",
        "            result.arrange(RIGHT)\n",
        "            result.set_height(0.6)\n",
        "            return result\n",
        "\n",
        "        review_label = get_review_label(10, 10)\n",
        "        review_label.next_to(data[:10], UP, MED_LARGE_BUFF)\n",
        "\n",
        "        # Show initial review\n",
        "        self.add(review_label)\n",
        "        self.add(underlines[:10])\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(real_data, int_func=np.ceil),\n",
        "            CountInFrom(review_label[0], 0),\n",
        "            rate_func=lambda t: smooth(t, 3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fake data\n",
        "        fd_rect = SurroundingRectangle(VGroup(fake_data, underlines[10:]))\n",
        "        fd_rect.set_stroke(WHITE, 2)\n",
        "        fd_rect.set_fill(GREY_E, 1)\n",
        "\n",
        "        fd_label = OldTexText(\"Pretend you see\\\\\\\\two more\")\n",
        "        fd_label.next_to(fd_rect, DOWN)\n",
        "        fd_label.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fd_label, UP),\n",
        "            DrawBorderThenFill(fd_rect),\n",
        "            ShowCreation(underlines[10:])\n",
        "        )\n",
        "        self.wait()\n",
        "        for mark in data[10:]:\n",
        "            self.play(Write(mark))\n",
        "        self.wait()\n",
        "\n",
        "        # Update rating\n",
        "        review_center = VectorizedPoint(review_label.get_center())\n",
        "        pretend_label = OldTexText(\"Pretend that it's\")\n",
        "        pretend_label.match_width(review_label)\n",
        "        pretend_label.next_to(review_label, UP, MED_LARGE_BUFF)\n",
        "        pretend_label.match_x(data)\n",
        "        pretend_label.set_color(BLUE_D)\n",
        "\n",
        "        old_review_label = VGroup(Integer(0), OldTexText(\"out of\"), Integer(0))\n",
        "        old_review_label.become(review_label)\n",
        "\n",
        "        self.add(old_review_label, review_label)\n",
        "        self.play(\n",
        "            review_center.set_x, data.get_center()[0],\n",
        "            MaintainPositionRelativeTo(review_label, review_center),\n",
        "            UpdateFromAlphaFunc(\n",
        "                review_label[0],\n",
        "                lambda m, a: m.set_value(int(interpolate(10, 11, a)))\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                review_label[2],\n",
        "                lambda m, a: m.set_value(int(interpolate(10, 12, a)))\n",
        "            ),\n",
        "            FadeIn(pretend_label, LEFT),\n",
        "            old_review_label.scale, 0.5,\n",
        "            old_review_label.set_opacity, 0.5,\n",
        "            old_review_label.to_edge, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show fraction\n",
        "        eq = OldTex(\n",
        "            \"{11\", \"\\\\over\", \"12}\",\n",
        "            \"\\\\approx\", \"91.7\\\\%\"\n",
        "        )\n",
        "        fix_percent(eq[-1][-1])\n",
        "        eq.set_color_by_tex(\"11\", GREEN)\n",
        "\n",
        "        eq.next_to(pretend_label, RIGHT)\n",
        "        eq.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(eq))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(eq))\n",
        "        self.wait()\n",
        "\n",
        "        # Remove clutter\n",
        "        old_review_label.generate_target()\n",
        "        old_review_label.target.next_to(title, DOWN, LARGE_BUFF)\n",
        "        old_review_label.target.to_edge(LEFT)\n",
        "        old_review_label.target.set_opacity(1)\n",
        "        arrow = Vector(0.5 * RIGHT)\n",
        "        arrow.next_to(old_review_label.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(old_review_label),\n",
        "            FadeIn(arrow),\n",
        "            eq.next_to, arrow, RIGHT,\n",
        "            FadeOut(\n",
        "                VGroup(\n",
        "                    fake_data,\n",
        "                    underlines,\n",
        "                    pretend_label,\n",
        "                    review_label,\n",
        "                    fd_rect, fd_label,\n",
        "                ),\n",
        "                DOWN,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            real_data.match_width, old_review_label.target,\n",
        "            real_data.next_to, old_review_label.target, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show 48 of 50 case\n",
        "        # Largely copied from above...not great\n",
        "        data = get_checks_and_crosses(\n",
        "            48 * [True] + 2 * [False] + [True, False],\n",
        "            width=FRAME_WIDTH - 1,\n",
        "        )\n",
        "        data.shift(DOWN)\n",
        "        underlines = get_underlines(data)\n",
        "\n",
        "        review_label = get_review_label(48, 50)\n",
        "        review_label.next_to(data, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        true_data = data[:-2]\n",
        "        fake_data = data[-2:]\n",
        "\n",
        "        fd_rect.replace(fake_data, stretch=True)\n",
        "        fd_rect.stretch(1.2, 0)\n",
        "        fd_rect.stretch(2.2, 1)\n",
        "        fd_rect.shift(0.025 * DOWN)\n",
        "        fd_label.next_to(fd_rect, DOWN, LARGE_BUFF)\n",
        "        fd_label.shift_onto_screen()\n",
        "        fd_arrow = Arrow(fd_label.get_top(), fd_rect.get_corner(DL))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(underlines[:-2]),\n",
        "            ShowIncreasingSubsets(true_data, int_func=np.ceil),\n",
        "            CountInFrom(review_label[0], 0),\n",
        "            UpdateFromAlphaFunc(\n",
        "                review_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(fd_label),\n",
        "            GrowArrow(fd_arrow),\n",
        "            FadeIn(fd_rect),\n",
        "            Write(fake_data),\n",
        "            Write(underlines[-2:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pretend it's 49 / 52\n",
        "        old_review_label = VGroup(Integer(0), OldTexText(\"out of\"), Integer(0))\n",
        "        old_review_label.become(review_label)\n",
        "        review_center = VectorizedPoint(review_label.get_center())\n",
        "\n",
        "        self.play(\n",
        "            review_center.set_x, data.get_center()[0] + 3,\n",
        "            MaintainPositionRelativeTo(review_label, review_center),\n",
        "            UpdateFromAlphaFunc(\n",
        "                review_label[0],\n",
        "                lambda m, a: m.set_value(int(interpolate(48, 49, a)))\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                review_label[2],\n",
        "                lambda m, a: m.set_value(int(interpolate(50, 52, a)))\n",
        "            ),\n",
        "            old_review_label.scale, 0.5,\n",
        "            old_review_label.to_edge, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow2 = Vector(0.5 * RIGHT)\n",
        "        arrow2.next_to(old_review_label, RIGHT)\n",
        "\n",
        "        eq2 = OldTex(\n",
        "            \"{49\", \"\\\\over\", \"52}\",\n",
        "            \"\\\\approx\", \"94.2\\\\%\"\n",
        "        )\n",
        "        fix_percent(eq2[-1][-1])\n",
        "        eq2[0].set_color(GREEN)\n",
        "        eq2.next_to(arrow2, RIGHT)\n",
        "        eq2.save_state()\n",
        "        eq2[1].set_opacity(0)\n",
        "        eq2[3:].set_opacity(0)\n",
        "        eq2[0].replace(review_label[0])\n",
        "        eq2[2].replace(review_label[2])\n",
        "\n",
        "        self.play(\n",
        "            Restore(eq2, run_time=1.5),\n",
        "            FadeIn(arrow2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        faders = VGroup(\n",
        "            fd_rect, fd_arrow, fd_label,\n",
        "            fake_data, underlines,\n",
        "            review_label,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(faders),\n",
        "            true_data.match_width, old_review_label,\n",
        "            true_data.next_to, old_review_label, DOWN,\n",
        "        )\n",
        "\n",
        "        # 200 review case\n",
        "        final_review_label = get_review_label(186, 200)\n",
        "        final_review_label.match_height(old_review_label)\n",
        "        final_review_label.move_to(old_review_label, LEFT)\n",
        "        final_review_label.shift(\n",
        "            arrow2.get_center() -\n",
        "            arrow.get_center()\n",
        "        )\n",
        "\n",
        "        data = get_checks_and_crosses([True] * 186 + [False] * 14 + [True, False])\n",
        "        data[:200].arrange_in_grid(10, 20, buff=0)\n",
        "        data[-2:].next_to(data[:200], DOWN, buff=0)\n",
        "        data.set_width(FRAME_WIDTH / 2 - 1)\n",
        "        data.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        data.to_edge(DOWN)\n",
        "        for mark in data:\n",
        "            mark.scale(0.5)\n",
        "\n",
        "        true_data = data[:-2]\n",
        "        fake_data = data[-2:]\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                final_review_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "            CountInFrom(final_review_label[0], 0),\n",
        "            ShowIncreasingSubsets(true_data),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow3 = Vector(0.5 * RIGHT)\n",
        "        arrow3.next_to(final_review_label, RIGHT)\n",
        "\n",
        "        eq3 = OldTex(\n",
        "            \"{187\", \"\\\\over\", \"202}\",\n",
        "            \"\\\\approx\", \"92.6\\\\%\"\n",
        "        )\n",
        "        fix_percent(eq3[-1][-1])\n",
        "        eq3[0].set_color(GREEN)\n",
        "        eq3.next_to(arrow3, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow3),\n",
        "            FadeIn(eq3),\n",
        "            Write(fake_data)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            true_data.match_width, final_review_label,\n",
        "            true_data.next_to, final_review_label, DOWN,\n",
        "            FadeOut(fake_data)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Make a selection\n",
        "        rect = SurroundingRectangle(VGroup(eq2, old_review_label))\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            eq2[-1].set_color, YELLOW,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Retitle\n",
        "        name = OldTexText(\"Laplace's rule of succession\")\n",
        "        name.match_height(title)\n",
        "        name.move_to(title)\n",
        "        name.set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(name),\n",
        "            FadeOut(title, UP),\n",
        "            underline.match_width, name,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait...why?\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.play(\n",
        "            self.students[0].change, \"confused\", self.screen,\n",
        "            self.students[1].change, \"confused\", self.screen,\n",
        "            self.teacher.change, \"tease\", self.students[2].eyes,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.student_says(\n",
        "            \"Is that really\\\\\\\\the answer?\",\n",
        "            target_mode=\"raise_right_hand\",\n",
        "            added_anims=[self.teacher.change, \"thinking\"],\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\"Let's dive in!\", target_mode=\"hooray\")\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class BinomialName(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Probabilities of probabilities\\\\\\\\\", \"Part 1\")\n",
        "        text.set_width(FRAME_WIDTH - 1)\n",
        "        text[0].set_color(BLUE)\n",
        "        self.add(text[0])\n",
        "        self.play(Write(text[1], run_time=2))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WhatsTheModel(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_questions()\n",
        "        self.introduce_buyer_and_seller()\n",
        "\n",
        "        for x in range(3):\n",
        "            self.play(*self.experience_animations(self.seller, self.buyer))\n",
        "        self.wait()\n",
        "\n",
        "        self.add_probability_label()\n",
        "        self.bring_up_goal()\n",
        "\n",
        "    def add_questions(self):\n",
        "        questions = VGroup(\n",
        "            OldTexText(\"What's the model?\"),\n",
        "            OldTexText(\"What are you optimizing?\"),\n",
        "        )\n",
        "        for question, vect in zip(questions, [LEFT, RIGHT]):\n",
        "            question.move_to(vect * FRAME_WIDTH / 4)\n",
        "        questions.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        questions.scale(1.5)\n",
        "\n",
        "        # Intro questions\n",
        "        self.play(FadeIn(questions[0]))\n",
        "        self.play(FadeIn(questions[1], UP))\n",
        "        self.wait()\n",
        "        questions[1].save_state()\n",
        "\n",
        "        self.questions = questions\n",
        "\n",
        "    def introduce_buyer_and_seller(self):\n",
        "        if hasattr(self, \"questions\"):\n",
        "            questions = self.questions\n",
        "            added_anims = [\n",
        "                questions[0].to_edge, UP,\n",
        "                questions[1].set_opacity, 0.5,\n",
        "                questions[1].scale, 0.25,\n",
        "                questions[1].to_corner, UR,\n",
        "            ]\n",
        "        else:\n",
        "            added_anims = []\n",
        "\n",
        "        seller = Randolph(mode=\"coin_flip_1\")\n",
        "        seller.to_edge(LEFT)\n",
        "        seller.label = OldTexText(\"Seller\")\n",
        "\n",
        "        buyer = Mortimer()\n",
        "        buyer.to_edge(RIGHT)\n",
        "        buyer.label = OldTexText(\"Buyer\")\n",
        "\n",
        "        VGroup(buyer, seller).shift(DOWN)\n",
        "\n",
        "        labels = VGroup()\n",
        "        for pi in seller, buyer:\n",
        "            pi.set_height(2)\n",
        "            pi.label.scale(1.5)\n",
        "            pi.label.next_to(pi, DOWN, MED_LARGE_BUFF)\n",
        "            labels.add(pi.label)\n",
        "        buyer.make_eye_contact(seller)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown, VGroup(seller, buyer, *labels),\n",
        "                lag_ratio=0.2\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.buyer = buyer\n",
        "        self.seller = seller\n",
        "\n",
        "    def add_probability_label(self):\n",
        "        seller = self.seller\n",
        "        buyer = self.buyer\n",
        "\n",
        "        label = get_prob_positive_experience_label()\n",
        "        label.add(OldTex(\"=\").next_to(label, RIGHT))\n",
        "        rhs = DecimalNumber(0.75)\n",
        "        rhs.next_to(label, RIGHT)\n",
        "        rhs.align_to(label[0], DOWN)\n",
        "        label.add(rhs)\n",
        "        label.scale(1.5)\n",
        "        label.next_to(seller, UP, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        rhs.set_color(YELLOW)\n",
        "        brace = Brace(rhs, UP)\n",
        "        success_rate = brace.get_text(\"Success rate\")[0]\n",
        "        s_sym = brace.get_tex(\"s\").scale(1.5, about_edge=DOWN)\n",
        "        success_rate.match_color(rhs)\n",
        "        s_sym.match_color(rhs)\n",
        "\n",
        "        self.add(label)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(success_rate, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(success_rate[0], s_sym),\n",
        "            FadeOut(success_rate, 0.1 * RIGHT, lag_ratio=0.1),\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(*self.experience_animations(seller, buyer, arc=30 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        grey_box = SurroundingRectangle(rhs, buff=SMALL_BUFF)\n",
        "        grey_box.set_stroke(GREY_E, 0.5)\n",
        "        grey_box.set_fill(GREY_D, 1)\n",
        "        lil_q_marks = OldTex(\"???\")\n",
        "        lil_q_marks.scale(0.5)\n",
        "        lil_q_marks.next_to(buyer, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(rhs, 0.5 * DOWN),\n",
        "            FadeIn(grey_box, 0.5 * UP),\n",
        "            FadeIn(lil_q_marks, DOWN),\n",
        "            buyer.change, \"confused\", grey_box,\n",
        "        )\n",
        "        rhs.set_opacity(0)\n",
        "        for x in range(2):\n",
        "            self.play(*self.experience_animations(seller, buyer, arc=30 * DEGREES))\n",
        "        self.play(buyer.change, \"confused\", lil_q_marks)\n",
        "        self.play(Blink(buyer))\n",
        "\n",
        "        self.prob_group = VGroup(\n",
        "            label, grey_box, brace, s_sym,\n",
        "        )\n",
        "        self.buyer_q_marks = lil_q_marks\n",
        "\n",
        "    def bring_up_goal(self):\n",
        "        prob_group = self.prob_group\n",
        "        questions = self.questions\n",
        "        questions.generate_target()\n",
        "        questions.target[1].replace(questions[0], dim_to_match=1)\n",
        "        questions.target[1].match_style(questions[0])\n",
        "        questions.target[0].replace(questions[1], dim_to_match=1)\n",
        "        questions.target[0].match_style(questions[1])\n",
        "\n",
        "        prob_group.generate_target()\n",
        "        prob_group.target.scale(0.5)\n",
        "        prob_group.target.next_to(self.seller, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.buyer_q_marks),\n",
        "            self.buyer.change, \"pondering\", questions[0],\n",
        "            self.seller.change, \"pondering\", questions[0],\n",
        "            MoveToTarget(prob_group),\n",
        "            MoveToTarget(questions),\n",
        "        )\n",
        "        self.play(self.seller.change, \"coin_flip_1\")\n",
        "        for x in range(3):\n",
        "            self.play(*self.experience_animations(self.seller, self.buyer))\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def experience_animations(self, seller, buyer, arc=-30 * DEGREES, p=0.75):\n",
        "        positive = (random.random() < p)\n",
        "        words = OldTexText(\n",
        "            \"Positive\\\\\\\\experience\"\n",
        "            if positive else\n",
        "            \"Negative\\\\\\\\experience\"\n",
        "        )\n",
        "        words.set_color(GREEN if positive else RED)\n",
        "        if positive:\n",
        "            new_mode = random.choice([\n",
        "                \"hooray\",\n",
        "                \"coin_flip_1\",\n",
        "            ])\n",
        "        else:\n",
        "            new_mode = random.choice([\n",
        "                \"tired\",\n",
        "                \"angry\",\n",
        "                \"sad\",\n",
        "            ])\n",
        "\n",
        "        words.move_to(seller.get_corner(UR))\n",
        "        result = [\n",
        "            ApplyMethod(\n",
        "                words.move_to, buyer.get_corner(UL),\n",
        "                path_arc=arc,\n",
        "                run_time=2\n",
        "            ),\n",
        "            VFadeInThenOut(words, run_time=2),\n",
        "            ApplyMethod(\n",
        "                buyer.change, new_mode, seller.eyes,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                seller.change, \"coin_flip_2\", buyer.eyes,\n",
        "                rate_func=there_and_back,\n",
        "            ),\n",
        "        ]\n",
        "        return result\n",
        "\n",
        "\n",
        "class IsSellerOne100(Scene):\n",
        "    def construct(self):\n",
        "        self.add_review()\n",
        "        self.show_probability()\n",
        "        self.show_simulated_reviews()\n",
        "\n",
        "    def add_review(self):\n",
        "        reviews = VGroup(*[Tex(CMARK_TEX) for x in range(10)])\n",
        "        reviews.arrange(RIGHT)\n",
        "        reviews.scale(2)\n",
        "        reviews.set_color(GREEN)\n",
        "        reviews.next_to(ORIGIN, UP)\n",
        "\n",
        "        blanks = VGroup(*[\n",
        "            Line(LEFT, RIGHT).match_width(rev).next_to(rev, DOWN, SMALL_BUFF)\n",
        "            for rev in reviews\n",
        "        ])\n",
        "        blanks.shift(0.25 * reviews[0].get_width() * LEFT)\n",
        "\n",
        "        label = OldTexText(\n",
        "            \" out of \",\n",
        "        )\n",
        "        tens = VGroup(*[Integer(10) for x in range(2)])\n",
        "        tens[0].next_to(label, LEFT)\n",
        "        tens[1].next_to(label, RIGHT)\n",
        "        tens.set_color(GREEN)\n",
        "        label.add(tens)\n",
        "        label.scale(2)\n",
        "        label.next_to(reviews, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(label)\n",
        "        self.add(blanks)\n",
        "        tens[0].to_count = reviews\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(reviews, int_func=np.ceil),\n",
        "            UpdateFromAlphaFunc(\n",
        "                tens[0],\n",
        "                lambda m, a: m.set_color(\n",
        "                    interpolate_color(RED, GREEN, a)\n",
        "                ).set_value(len(m.to_count))\n",
        "            ),\n",
        "            run_time=2,\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.review_group = VGroup(reviews, blanks, label)\n",
        "\n",
        "    def show_probability(self):\n",
        "        review_group = self.review_group\n",
        "\n",
        "        prob_label = get_prob_positive_experience_label()\n",
        "        prob_label.add(OldTex(\"=\").next_to(prob_label, RIGHT))\n",
        "        rhs = DecimalNumber(1)\n",
        "        rhs.next_to(prob_label, RIGHT)\n",
        "        rhs.set_color(YELLOW)\n",
        "        prob_label.add(rhs)\n",
        "        prob_label.scale(2)\n",
        "        prob_label.to_corner(UL)\n",
        "\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.set_color(YELLOW)\n",
        "        q_mark.match_height(rhs)\n",
        "        q_mark.reference = rhs\n",
        "        q_mark.add_updater(lambda m: m.next_to(m.reference, RIGHT))\n",
        "\n",
        "        rhs_rect = SurroundingRectangle(rhs, buff=0.2)\n",
        "        rhs_rect.set_color(RED)\n",
        "\n",
        "        not_necessarily = OldTexText(\"Not necessarily!\")\n",
        "        not_necessarily.set_color(RED)\n",
        "        not_necessarily.scale(1.5)\n",
        "        not_necessarily.next_to(prob_label, DOWN, 1.5)\n",
        "        arrow = Arrow(\n",
        "            not_necessarily.get_top(),\n",
        "            rhs_rect.get_corner(DL),\n",
        "            buff=MED_SMALL_BUFF,\n",
        "        )\n",
        "        arrow.set_color(RED)\n",
        "\n",
        "        rhs.set_value(0)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(rhs, 1),\n",
        "            UpdateFromAlphaFunc(\n",
        "                prob_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "            FadeIn(q_mark),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(rhs_rect),\n",
        "            Write(not_necessarily),\n",
        "            ShowCreation(arrow),\n",
        "            review_group.to_edge, DOWN,\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(rhs, 0.95),\n",
        "            FadeOut(rhs_rect),\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(not_necessarily),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.prob_label_group = VGroup(\n",
        "            prob_label, rhs, q_mark,\n",
        "        )\n",
        "\n",
        "    def show_simulated_reviews(self):\n",
        "        prob_label_group = self.prob_label_group\n",
        "        review_group = self.review_group\n",
        "\n",
        "        # Set up decimals\n",
        "        random.seed(2)\n",
        "        decimals = VGroup()\n",
        "        for x in range(10):\n",
        "            dec = DecimalNumber()\n",
        "            decimals.add(dec)\n",
        "\n",
        "        def randomize_decimals(decimals):\n",
        "            for dec in decimals:\n",
        "                value = random.random()\n",
        "                dec.set_value(value)\n",
        "                if value > 0.95:\n",
        "                    dec.set_color(RED)\n",
        "                else:\n",
        "                    dec.set_color(WHITE)\n",
        "\n",
        "        randomize_decimals(decimals)\n",
        "\n",
        "        decimals.set_height(0.3)\n",
        "        decimals.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        decimals.next_to(ORIGIN, DOWN)\n",
        "        decimals[0].set_value(0.42)\n",
        "        decimals[0].set_color(WHITE)\n",
        "        decimals[1].set_value(0.97)\n",
        "        decimals[1].set_color(RED)\n",
        "\n",
        "        random_label = OldTexText(\"Random number\\\\\\\\in [0, 1]\")\n",
        "        random_label.scale(0.7)\n",
        "        random_label.next_to(decimals[0], DOWN)\n",
        "        random_label.set_color(GREY_B)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for dec in decimals:\n",
        "            arrow = Vector(0.4 * UP)\n",
        "            arrow.next_to(dec, UP)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        # Set up marks\n",
        "        def get_marks(decs, arrows):\n",
        "            marks = VGroup()\n",
        "            for dec, arrow in zip(decs, arrows):\n",
        "                if dec.get_value() < 0.95:\n",
        "                    mark = OldTex(CMARK_TEX)\n",
        "                    mark.set_color(GREEN)\n",
        "                else:\n",
        "                    mark = OldTex(XMARK_TEX)\n",
        "                    mark.set_color(RED)\n",
        "                mark.set_height(0.5)\n",
        "                mark.next_to(arrow, UP)\n",
        "                marks.add(mark)\n",
        "            return marks\n",
        "\n",
        "        marks = get_marks(decimals, arrows)\n",
        "\n",
        "        lt_p95 = OldTex(\"< 0.95\")\n",
        "        gte_p95 = OldTex(\"\\\\ge 0.95\")\n",
        "        for label in lt_p95, gte_p95:\n",
        "            label.match_height(decimals[0])\n",
        "\n",
        "        lt_p95.next_to(decimals[0], RIGHT, MED_SMALL_BUFF)\n",
        "        gte_p95.next_to(decimals[1], RIGHT, MED_SMALL_BUFF)\n",
        "        lt_p95.set_color(GREEN)\n",
        "        gte_p95.set_color(RED)\n",
        "\n",
        "        # Introduce simulation\n",
        "        review_group.save_state()\n",
        "        self.play(\n",
        "            review_group.scale, 0.25,\n",
        "            review_group.to_corner, UR,\n",
        "            Write(random_label),\n",
        "            CountInFrom(decimals[0], 0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(lt_p95, LEFT))\n",
        "        self.play(\n",
        "            GrowArrow(arrows[0]),\n",
        "            FadeIn(marks[0], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(lt_p95, 0.5 * RIGHT),\n",
        "            FadeIn(gte_p95, 0.5 * LEFT),\n",
        "        )\n",
        "        self.play(\n",
        "            random_label.match_x, decimals[1],\n",
        "            CountInFrom(decimals[1], 0),\n",
        "            UpdateFromAlphaFunc(\n",
        "                decimals[1],\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(arrows[1]),\n",
        "            FadeIn(marks[1], DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                CountInFrom, decimals[2:],\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                decimals[2:],\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "            FadeOut(gte_p95),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.add(decimals)\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows[2:]),\n",
        "            LaggedStartMap(FadeInFromDown, marks[2:]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.add(arrows, marks)\n",
        "        self.wait()\n",
        "\n",
        "        # Add new rows\n",
        "        decimals.arrows = arrows\n",
        "        decimals.add_updater(lambda d: d.next_to(d.arrows, DOWN))\n",
        "        added_anims = [FadeOut(random_label)]\n",
        "        rows = VGroup(marks)\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                arrows.shift, DOWN,\n",
        "                UpdateFromFunc(decimals, randomize_decimals),\n",
        "                *added_anims,\n",
        "            )\n",
        "            added_anims = []\n",
        "            new_marks = get_marks(decimals, arrows)\n",
        "            self.play(LaggedStartMap(FadeInFromDown, new_marks))\n",
        "            self.wait()\n",
        "            rows.add(new_marks)\n",
        "\n",
        "        # Create a stockpile of new rows\n",
        "        added_rows = VGroup()\n",
        "        decimals.clear_updaters()\n",
        "        decimals.save_state()\n",
        "        for x in range(100):\n",
        "            randomize_decimals(decimals)\n",
        "            added_rows.add(get_marks(decimals, arrows))\n",
        "        decimals.restore()\n",
        "\n",
        "        # Compress rows\n",
        "        rows.generate_target()\n",
        "        for group in rows.target, added_rows:\n",
        "            group.scale(0.3)\n",
        "            for row in group:\n",
        "                row.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            group.arrange(DOWN, buff=0.2)\n",
        "        rows.target.next_to(prob_label_group, DOWN, MED_LARGE_BUFF)\n",
        "        rows.target.set_x(-3.5)\n",
        "\n",
        "        nr = 15\n",
        "        added_rows[:nr].move_to(rows.target, UP)\n",
        "        added_rows[nr:2 * nr].move_to(rows.target, UP)\n",
        "        added_rows[nr:2 * nr].shift(3.5 * RIGHT)\n",
        "        added_rows[2 * nr:3 * nr].move_to(rows.target, UP)\n",
        "        added_rows[2 * nr:3 * nr].shift(7 * RIGHT)\n",
        "        added_rows = added_rows[4:3 * nr]\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rows),\n",
        "            FadeOut(decimals),\n",
        "            FadeOut(arrows),\n",
        "        )\n",
        "        self.play(ShowIncreasingSubsets(added_rows), run_time=3)\n",
        "\n",
        "        # Show scores\n",
        "        all_rows = VGroup(*rows, *added_rows)\n",
        "        scores = VGroup()\n",
        "        ten_rects = VGroup()\n",
        "        for row in all_rows:\n",
        "            score = Integer(sum([\n",
        "                mark.get_color() == Color(GREEN)\n",
        "                for mark in row\n",
        "            ]))\n",
        "            score.match_height(row)\n",
        "            score.next_to(row, RIGHT)\n",
        "            if score.get_value() == 10:\n",
        "                score.set_color(TEAL)\n",
        "                ten_rects.add(SurroundingRectangle(score))\n",
        "            scores.add(score)\n",
        "\n",
        "        ten_rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(FadeIn(scores))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, ten_rects))\n",
        "        self.play(LaggedStartMap(FadeOut, ten_rects))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show alternate possibilities\n",
        "        prob = DecimalNumber(0.95)\n",
        "        prob.set_color(YELLOW)\n",
        "        template = prob_label_group[0][-1]\n",
        "        prob.match_height(template)\n",
        "        prob.move_to(template, LEFT)\n",
        "        rect = BackgroundRectangle(template, buff=SMALL_BUFF)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        self.add(rect)\n",
        "        self.add(prob)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOutAndShift, all_rows, lag_ratio=0.01),\n",
        "            LaggedStartMap(FadeOutAndShift, scores, lag_ratio=0.01),\n",
        "            Restore(review_group),\n",
        "        )\n",
        "        for value in [0.9, 0.99, 0.8, 0.95]:\n",
        "            self.play(ChangeDecimalToValue(prob, value))\n",
        "            self.wait()\n",
        "\n",
        "    # No longer used\n",
        "    def show_random_numbers(self):\n",
        "        prob_label_group = self.prob_label_group\n",
        "\n",
        "        random.seed(2)\n",
        "        rows = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Integer(\n",
        "                    random.randint(0, 99)\n",
        "                ).move_to(0.85 * x * RIGHT)\n",
        "                for x in range(10)\n",
        "            ])\n",
        "            for y in range(10 * 2)\n",
        "        ])\n",
        "        rows.arrange_in_grid(n_cols=2, buff=MED_LARGE_BUFF)\n",
        "        rows[:10].shift(LEFT)\n",
        "        rows.set_height(5.5)\n",
        "        rows.center().to_edge(DOWN)\n",
        "\n",
        "        lt_95 = VGroup(*[\n",
        "            mob\n",
        "            for row in rows\n",
        "            for mob in row\n",
        "            if mob.get_value() < 95\n",
        "        ])\n",
        "\n",
        "        square = Square()\n",
        "        square.set_stroke(width=0)\n",
        "        square.set_fill(YELLOW, 0.5)\n",
        "        square.set_width(1.5 * rows[0][0].get_height())\n",
        "        # highlights = VGroup(*[\n",
        "        #     square.copy().move_to(mob)\n",
        "        #     for row in rows\n",
        "        #     for mob in row\n",
        "        #     if mob.get_value() < 95\n",
        "        # ])\n",
        "\n",
        "        row_rects = VGroup(*[\n",
        "            SurroundingRectangle(row)\n",
        "            for row in rows\n",
        "            if all([m.get_value() < 95 for m in row])\n",
        "        ])\n",
        "        row_rects.set_stroke(GREEN, 2)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowIncreasingSubsets, rows,\n",
        "                run_time=3,\n",
        "                lag_ratio=0.25,\n",
        "            ),\n",
        "            FadeOut(self.review_group, DOWN),\n",
        "            prob_label_group.set_height, 0.75,\n",
        "            prob_label_group.to_corner, UL,\n",
        "        )\n",
        "        self.wait()\n",
        "        # self.add(highlights, rows)\n",
        "        self.play(\n",
        "            # FadeIn(highlights)\n",
        "            lt_95.set_fill, BLUE,\n",
        "            lt_95.set_stroke, BLUE, 2, {\"background\": True},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, row_rects))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LookAtAllPossibleSuccessRates(Scene):\n",
        "    def construct(self):\n",
        "        axes = get_beta_dist_axes(y_max=6, y_unit=1)\n",
        "        dist = scipy.stats.beta(10, 2)\n",
        "        graph = axes.get_graph(dist.pdf)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        flat_graph = graph.copy()\n",
        "        flat_graph.get_points()[:, 1] = axes.c2p(0, 0)[1]\n",
        "        flat_graph.set_stroke(YELLOW, 3)\n",
        "\n",
        "        x_labels = axes.x_axis.numbers\n",
        "        x_labels.set_opacity(0)\n",
        "\n",
        "        sellers = VGroup(*[\n",
        "            self.get_example_seller(label.get_value())\n",
        "            for label in x_labels\n",
        "        ])\n",
        "        sellers.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        sellers.set_width(FRAME_WIDTH - 1)\n",
        "        sellers.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        sellers.generate_target()\n",
        "        for seller, label in zip(sellers.target, x_labels):\n",
        "            seller.next_to(label, DOWN)\n",
        "            seller[0].set_opacity(0)\n",
        "            seller[1].set_opacity(0)\n",
        "            seller[2].replace(label, dim_to_match=1)\n",
        "\n",
        "        x_label = OldTexText(\"All possible success rates\")\n",
        "        x_label.next_to(axes.c2p(0.5, 0), UP)\n",
        "        x_label.shift(2 * LEFT)\n",
        "\n",
        "        y_axis_label = OldTexText(\n",
        "            \"A kind of probability\\\\\\\\\",\n",
        "            \"of probabilities\"\n",
        "        )\n",
        "        y_axis_label.scale(0.75)\n",
        "        y_axis_label.next_to(axes.y_axis, RIGHT)\n",
        "        y_axis_label.to_edge(UP)\n",
        "        y_axis_label[1].set_color(YELLOW)\n",
        "\n",
        "        graph_label = OldTexText(\n",
        "            \"Some notion of likelihood\\\\\\\\\",\n",
        "            \"for each one\"\n",
        "        )\n",
        "        graph_label[1].align_to(graph_label[0], LEFT)\n",
        "        graph_label.next_to(graph.get_boundary_point(UP), UP)\n",
        "        graph_label.shift(0.5 * DOWN)\n",
        "        graph_label.to_edge(RIGHT)\n",
        "\n",
        "        x_axis_line = Line(axes.c2p(0, 0), axes.c2p(1, 0))\n",
        "        x_axis_line.set_stroke(YELLOW, 3)\n",
        "\n",
        "        shuffled_sellers = VGroup(*sellers)\n",
        "        shuffled_sellers.shuffle()\n",
        "        self.play(GrowFromCenter(shuffled_sellers[0]))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromPoint, shuffled_sellers[1:],\n",
        "            lambda m: (m, sellers.get_center())\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(sellers),\n",
        "            FadeIn(axes),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            x_label.shift, 4 * RIGHT,\n",
        "            UpdateFromAlphaFunc(\n",
        "                x_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "                rate_func=there_and_back,\n",
        "            ),\n",
        "            ShowCreation(x_axis_line),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(FadeOut(x_axis_line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(graph_label),\n",
        "            ReplacementTransform(flat_graph, graph),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(y_axis_label))\n",
        "\n",
        "        # Show probabilities\n",
        "        x_tracker = ValueTracker(0.5)\n",
        "\n",
        "        prob_label = get_prob_positive_experience_label(True, True, True)\n",
        "        prob_label.next_to(axes.c2p(0, 2), RIGHT, MED_LARGE_BUFF)\n",
        "        prob_label.decimal.tracker = x_tracker\n",
        "        prob_label.decimal.add_updater(\n",
        "            lambda m: m.set_value(m.tracker.get_value())\n",
        "        )\n",
        "\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.set_stroke(YELLOW, 2)\n",
        "        v_line.tracker = x_tracker\n",
        "        v_line.graph = graph\n",
        "        v_line.axes = axes\n",
        "        v_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                m.axes.x_axis.n2p(m.tracker.get_value()),\n",
        "                m.axes.input_to_graph_point(m.tracker.get_value(), m.graph),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(v_line)\n",
        "        for x in [0.95, 0.8, 0.9]:\n",
        "            self.play(\n",
        "                x_tracker.set_value, x,\n",
        "                run_time=4,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def get_example_seller(self, success_rate):\n",
        "        randy = Randolph(mode=\"coin_flip_1\", height=1)\n",
        "        label = OldTex(\"s = \")\n",
        "        decimal = DecimalNumber(success_rate)\n",
        "        decimal.match_height(label)\n",
        "        decimal.next_to(label[-1], RIGHT)\n",
        "        label.set_color(YELLOW)\n",
        "        decimal.set_color(YELLOW)\n",
        "        VGroup(label, decimal).next_to(randy, DOWN)\n",
        "        result = VGroup(randy, label, decimal)\n",
        "        result.randy = randy\n",
        "        result.label = label\n",
        "        result.decimal = decimal\n",
        "        return result\n",
        "\n",
        "\n",
        "class AskAboutUnknownProbabilities(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        unknown_title, prob_title = titles = self.get_titles()\n",
        "\n",
        "        v_line = Line(UP, DOWN)\n",
        "        v_line.set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke([WHITE, GREY_B], 3)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(titles, DOWN)\n",
        "\n",
        "        processes = VGroup(\n",
        "            get_random_coin(shuffle_time=1),\n",
        "            get_random_die(shuffle_time=1.5),\n",
        "            get_random_card(shuffle_time=2),\n",
        "        )\n",
        "        processes.arrange(DOWN, buff=0.7)\n",
        "        processes.next_to(unknown_title, DOWN, LARGE_BUFF)\n",
        "        processes_rect = BackgroundRectangle(processes)\n",
        "        processes_rect.set_fill(BLACK, 1)\n",
        "\n",
        "        prob_labels = VGroup(\n",
        "            OldTex(\"P(\", \"00\", \")\", \"=\", \"1 / 2\"),\n",
        "            OldTex(\"P(\", \"00\", \")\", \"=\", \"1 / 6}\"),\n",
        "            OldTex(\"P(\", \"00\", \")\", \"=\", \"1 / 52}\"),\n",
        "        )\n",
        "        prob_labels.scale(1.5)\n",
        "        prob_labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        prob_labels.match_x(prob_title)\n",
        "        for pl, pr in zip(prob_labels, processes):\n",
        "            pl.match_y(pr)\n",
        "            content = pr[1].copy()\n",
        "            content.replace(pl[1], dim_to_match=0)\n",
        "            pl.replace_submobject(1, content)\n",
        "\n",
        "        # Putting numbers to the unknown\n",
        "        number_rects = VGroup(*[\n",
        "            SurroundingRectangle(pl[-1])\n",
        "            for pl in prob_labels\n",
        "        ])\n",
        "        number_rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "        for pl in prob_labels:\n",
        "            pl.save_state()\n",
        "            pl[:3].match_x(prob_title)\n",
        "            pl[3:].match_x(prob_title)\n",
        "            pl.set_opacity(0)\n",
        "\n",
        "        self.add(processes)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, titles),\n",
        "            LaggedStart(\n",
        "                ShowCreation(v_line),\n",
        "                ShowCreation(h_line),\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "            LaggedStartMap(Restore, prob_labels),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait(10)\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(\n",
        "        #         ShowCreationThenFadeOut,\n",
        "        #         number_rects,\n",
        "        #         run_time=3,\n",
        "        #     )\n",
        "        # )\n",
        "        # self.wait(2)\n",
        "\n",
        "        # Highlight coin flip\n",
        "        fade_rects = VGroup(*[\n",
        "            VGroup(\n",
        "                BackgroundRectangle(pl, buff=MED_SMALL_BUFF),\n",
        "                BackgroundRectangle(pr, buff=MED_SMALL_BUFF),\n",
        "            )\n",
        "            for pl, pr in zip(prob_labels, processes)\n",
        "        ])\n",
        "        fade_rects.set_fill(BLACK, 0.8)\n",
        "\n",
        "        prob_half = prob_labels[0]\n",
        "        half = prob_half[-1]\n",
        "        half_underline = Line(LEFT, RIGHT)\n",
        "        half_underline.set_width(half.get_width() + MED_SMALL_BUFF)\n",
        "        half_underline.next_to(half, DOWN, buff=SMALL_BUFF)\n",
        "        half_underline.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rects[1]),\n",
        "            FadeIn(fade_rects[2]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(fade_rects[0]),\n",
        "            FadeOut(fade_rects[1]),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(fade_rects[0]),\n",
        "            FadeOut(fade_rects[2]),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Transition to question\n",
        "        processes.suspend_updating()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(unknown_title, UP),\n",
        "                FadeOut(prob_title, UP),\n",
        "                lag_ratio=0.2,\n",
        "            ),\n",
        "            FadeOut(h_line, UP, lag_ratio=0.1),\n",
        "            FadeOut(processes, LEFT, lag_ratio=0.1),\n",
        "            FadeOut(prob_labels[1]),\n",
        "            FadeOut(prob_labels[2]),\n",
        "            v_line.rotate, 90 * DEGREES,\n",
        "            v_line.shift, 0.6 * FRAME_HEIGHT * UP,\n",
        "            prob_half.center,\n",
        "            prob_half.to_edge, UP,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(prob_half)\n",
        "\n",
        "        arrow = Vector(UP)\n",
        "        arrow.next_to(half, DOWN)\n",
        "        question = OldTexText(\"What exactly does\\\\\\\\this mean?\")\n",
        "        question.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(question, UP),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(question, RIGHT),\n",
        "            Rotate(arrow, 90 * DEGREES),\n",
        "            VFadeOut(arrow),\n",
        "        )\n",
        "\n",
        "        # Show long run averages\n",
        "        self.show_many_coins(20, 50)\n",
        "        self.show_many_coins(40, 100)\n",
        "\n",
        "        # Make probability itself unknown\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.set_color(YELLOW)\n",
        "        q_marks.replace(half, dim_to_match=0)\n",
        "\n",
        "        randy = Randolph(mode=\"confused\")\n",
        "        randy.center()\n",
        "        randy.look_at(prob_half)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(half, UP),\n",
        "            FadeIn(q_marks, DOWN),\n",
        "        )\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # self.embed()\n",
        "\n",
        "    def get_titles(self):\n",
        "        unknown_label = OldTexText(\"Random process\")\n",
        "        prob_label = OldTexText(\"Long-run frequency\")\n",
        "        titles = VGroup(unknown_label, prob_label)\n",
        "        titles.scale(1.25)\n",
        "\n",
        "        unknown_label.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "        prob_label.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        titles.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        titles.set_color(BLUE)\n",
        "        return titles\n",
        "\n",
        "    def show_many_coins(self, n_rows, n_cols):\n",
        "        coin_choices = VGroup(\n",
        "            get_coin(\"H\"),\n",
        "            get_coin(\"T\"),\n",
        "        )\n",
        "        coin_choices.set_stroke(width=0)\n",
        "        coins = VGroup(*[\n",
        "            random.choice(coin_choices).copy()\n",
        "            for x in range(n_rows * n_cols)\n",
        "        ])\n",
        "\n",
        "        def organize_coins(coin_group):\n",
        "            coin_group.scale(1 / coin_group[0].get_height())\n",
        "            coin_group.arrange_in_grid(n_rows=n_rows)\n",
        "            coin_group.set_width(FRAME_WIDTH - 1)\n",
        "            coin_group.to_edge(DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        organize_coins(coins)\n",
        "\n",
        "        sorted_coins = VGroup()\n",
        "        for coin in coins:\n",
        "            coin.generate_target()\n",
        "            sorted_coins.add(coin.target)\n",
        "        sorted_coins.submobjects.sort(key=lambda m: m.symbol)\n",
        "        organize_coins(sorted_coins)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, coins,\n",
        "            lambda m: (m, 0.2 * DOWN),\n",
        "            run_time=3,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, coins,\n",
        "            path_arc=30 * DEGREES,\n",
        "            run_time=2,\n",
        "            lag_ratio=1 / len(coins),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(coins))\n",
        "\n",
        "\n",
        "class AskProbabilityOfCoins(Scene):\n",
        "    def construct(self):\n",
        "        condition = VGroup(\n",
        "            OldTexText(\"If you've seen\"),\n",
        "            Integer(80, color=BLUE_C),\n",
        "            get_coin(\"H\").set_height(0.5),\n",
        "            OldTexText(\"and\"),\n",
        "            Integer(20, color=RED_C),\n",
        "            get_coin(\"T\").set_height(0.5),\n",
        "        )\n",
        "        condition.arrange(RIGHT)\n",
        "        condition.to_edge(UP)\n",
        "        self.add(condition)\n",
        "\n",
        "        question = OldTex(\n",
        "            \"\\\\text{What is }\",\n",
        "            \"P(\", \"00\", \")\", \"?\"\n",
        "        )\n",
        "        coin = get_coin(\"H\")\n",
        "        coin.replace(question.get_part_by_tex(\"00\"))\n",
        "        question.replace_submobject(\n",
        "            question.index_of_part_by_tex(\"00\"),\n",
        "            coin\n",
        "        )\n",
        "        question.next_to(condition, DOWN)\n",
        "        self.add(question)\n",
        "\n",
        "        values = [\"H\"] * 80 + [\"T\"] * 20\n",
        "        random.shuffle(values)\n",
        "\n",
        "        coins = VGroup(*[\n",
        "            get_coin(symbol)\n",
        "            for symbol in values\n",
        "        ])\n",
        "        coins.arrange_in_grid(10, 10, buff=MED_SMALL_BUFF)\n",
        "        coins.set_width(5)\n",
        "        coins.next_to(question, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coins),\n",
        "            run_time=8,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class RunCarFactory(Scene):\n",
        "    def construct(self):\n",
        "        # Factory\n",
        "        factory = SVGMobject(file_name=\"factory\")\n",
        "        factory.set_fill(GREY_D)\n",
        "        factory.set_stroke(width=0)\n",
        "        factory.flip()\n",
        "        factory.set_height(6)\n",
        "        factory.to_edge(LEFT)\n",
        "\n",
        "        self.add(factory)\n",
        "\n",
        "        # Dumb hack\n",
        "        points = factory[0].get_points()\n",
        "        l1 = Line(points[-200], points[-216])\n",
        "        l2 = Line(points[-300], points[-318])\n",
        "        for line in l1, l2:\n",
        "            square = Square()\n",
        "            square.set_fill(BLACK, 1)\n",
        "            square.set_stroke(width=0)\n",
        "            square.replace(line)\n",
        "            factory.add(square)\n",
        "\n",
        "        rect = Rectangle()\n",
        "        rect.match_style(factory)\n",
        "        rect.set_height(1.1)\n",
        "        rect.set_width(6.75, stretch=True)\n",
        "        rect.move_to(factory, DL)\n",
        "\n",
        "        # Get cars\n",
        "        car = Car(color=interpolate_color(BLUE_E, GREY_C, 0.5))\n",
        "        car.set_height(0.9)\n",
        "        for tire in car.get_tires():\n",
        "            tire.set_fill(GREY_C)\n",
        "            tire.set_stroke(BLACK)\n",
        "        car.randy.set_opacity(0)\n",
        "        car.move_to(rect.get_corner(DR))\n",
        "\n",
        "        cars = VGroup()\n",
        "        n_cars = 20\n",
        "        for x in range(n_cars):\n",
        "            cars.add(car.copy())\n",
        "\n",
        "        for car in cars[4], cars[6]:\n",
        "            scratch = VMobject()\n",
        "            scratch.start_new_path(UP)\n",
        "            scratch.add_line_to(0.25 * DL)\n",
        "            scratch.add_line_to(0.25 * UR)\n",
        "            scratch.add_line_to(DOWN)\n",
        "            scratch.set_stroke([RED_A, RED_C], [0.1, 2, 2, 0.1])\n",
        "            scratch.set_height(0.25)\n",
        "            scratch.move_to(car)\n",
        "            scratch.shift(0.1 * DOWN)\n",
        "            car.add(scratch)\n",
        "\n",
        "        self.add(cars, rect)\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveCar, cars,\n",
        "            lambda m: (m, m.get_corner(DR) + 10 * RIGHT),\n",
        "            lag_ratio=0.3,\n",
        "            rate_func=linear,\n",
        "            run_time=1.5 * n_cars,\n",
        "        ))\n",
        "        self.remove(cars)\n",
        "\n",
        "\n",
        "class CarFactoryNumbers(Scene):\n",
        "    def construct(self):\n",
        "        # Test words\n",
        "        denom_words = OldTexText(\n",
        "            \"in a test of 100 cars\",\n",
        "            tex_to_color_map={\"100\": BLUE},\n",
        "        )\n",
        "        denom_words.to_corner(UR)\n",
        "\n",
        "        numer_words = OldTexText(\n",
        "            \"2 defects found\",\n",
        "            tex_to_color_map={\"2\": RED}\n",
        "        )\n",
        "        numer_words.move_to(denom_words, LEFT)\n",
        "\n",
        "        self.play(Write(denom_words, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            denom_words.next_to, numer_words, DOWN, {\"aligned_edge\": LEFT},\n",
        "            FadeIn(numer_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Question words\n",
        "        question = VGroup(\n",
        "            OldTexText(\"How do you plan\"),\n",
        "            OldTexText(\"for\"),\n",
        "            Integer(int(1e6), color=BLUE),\n",
        "            OldTexText(\"cars?\")\n",
        "        )\n",
        "        question[1:].arrange(RIGHT, aligned_edge=DOWN)\n",
        "        question[2].shift(\n",
        "            (question[2][1].get_bottom()[1] - question[2][0].get_bottom()[1]) * UP\n",
        "        )\n",
        "        question[1:].next_to(question[0], DOWN, aligned_edge=LEFT)\n",
        "        question.next_to(denom_words, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                question,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "            CountInFrom(question[2], 0, run_time=1.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ComplainAboutSimplisticModel(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        axes = self.get_experience_graph()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\", axes,\n",
        "            self.change_students(\n",
        "                \"pondering\", \"erm\", \"sassy\",\n",
        "                look_at=axes,\n",
        "            ),\n",
        "            ShowCreation(\n",
        "                axes.graph,\n",
        "                run_time=3,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        student = self.students[2]\n",
        "        bubble = SpeechBubble(\n",
        "            direction=LEFT,\n",
        "            height=3,\n",
        "            width=5,\n",
        "        )\n",
        "        bubble.pin_to(student)\n",
        "        bubble.write(\"What about something\\\\\\\\like this?\")\n",
        "\n",
        "        self.play(\n",
        "            axes.next_to, student, UL,\n",
        "            VFadeOut(axes.graph),\n",
        "            FadeIn(bubble),\n",
        "            Write(bubble.content, run_time=1),\n",
        "            student.change, \"raise_left_hand\",\n",
        "            self.students[0].change, \"thinking\", axes,\n",
        "            self.students[1].change, \"thinking\", axes,\n",
        "            self.teacher.change, \"happy\",\n",
        "        )\n",
        "\n",
        "        new_graph = VMobject()\n",
        "        new_graph.set_points_as_corners([\n",
        "            axes.c2p(0, 0.75),\n",
        "            axes.c2p(2, 0.9),\n",
        "            axes.c2p(4, 0.5),\n",
        "            axes.c2p(6, 0.75),\n",
        "            axes.c2p(8, 0.55),\n",
        "            axes.c2p(10, 0.95),\n",
        "        ])\n",
        "        new_graph.make_smooth()\n",
        "        new_graph.set_stroke([YELLOW, RED, GREEN], 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(new_graph),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, new_graph)\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_experience_graph(self):\n",
        "        axes = Axes(\n",
        "            x_min=-1,\n",
        "            x_max=10,\n",
        "            y_min=0,\n",
        "            y_max=1.25,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 5,\n",
        "                \"tick_frequency\": 0.25,\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        )\n",
        "        axes.set_stroke(GREY_B, 1)\n",
        "        axes.set_height(3)\n",
        "        y_label = OldTexText(\"Experience quality\")\n",
        "        y_label.scale(0.5)\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, SMALL_BUFF)\n",
        "        axes.add(y_label)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for x in range(10):\n",
        "            lines.add(\n",
        "                Line(axes.c2p(x, 0), axes.c2p(x + 0.9, 0))\n",
        "            )\n",
        "        lines.set_stroke(RED, 3)\n",
        "        for line in lines:\n",
        "            if random.random() < 0.5:\n",
        "                line.set_y(axes.c2p(0, 1)[1])\n",
        "                line.set_stroke(GREEN)\n",
        "\n",
        "        axes.add(lines)\n",
        "        axes.graph = lines\n",
        "\n",
        "        rect = BackgroundRectangle(axes, buff=0.25)\n",
        "        rect.set_stroke(WHITE, 1)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "\n",
        "        axes.add_to_back(rect)\n",
        "        axes.to_corner(UR)\n",
        "\n",
        "        return axes\n",
        "\n",
        "\n",
        "class ComingUpWrapper(Scene):\n",
        "    def construct(self):\n",
        "        background = FullScreenFadeRectangle()\n",
        "        background.set_fill(GREY_E, 1)\n",
        "\n",
        "        title = OldTexText(\"What's coming...\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_height(6)\n",
        "        rect.set_stroke(WHITE)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(background, rect)\n",
        "        self.play(FadeInFromDown(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PreviewBeta(Scene):\n",
        "    def construct(self):\n",
        "        axes = get_beta_dist_axes(label_y=True)\n",
        "        axes.y_axis.remove(axes.y_axis.numbers)\n",
        "        marks = get_plusses_and_minuses(p=0.75)\n",
        "        marks.next_to(axes.y_axis.get_top(), DR, buff=0.75)\n",
        "\n",
        "        beta_label = get_beta_label(0, 0)\n",
        "        beta_label.next_to(marks, UR, buff=LARGE_BUFF)\n",
        "        beta_label.to_edge(UP)\n",
        "        bl_left = beta_label.get_left()\n",
        "\n",
        "        beta_container = VGroup()\n",
        "        graph_container = VGroup()\n",
        "        n_graphs = 2\n",
        "        for x in range(n_graphs):\n",
        "            graph_container.add(VMobject())\n",
        "\n",
        "        def get_counts(marks):\n",
        "            is_plusses = [m.is_plus for m in marks]\n",
        "            p = sum(is_plusses)\n",
        "            n = len(is_plusses) - p\n",
        "            return p, n\n",
        "\n",
        "        def update_beta(container):\n",
        "            counts = get_counts(marks)\n",
        "            new_label = get_beta_label(*counts)\n",
        "            new_label.move_to(bl_left, LEFT)\n",
        "            container.set_submobjects([new_label])\n",
        "            return container\n",
        "\n",
        "        def update_graph(container):\n",
        "            counts = get_counts(marks)\n",
        "            new_graph = get_beta_graph(axes, *counts)\n",
        "            new_graphs = [*container[1:], new_graph]\n",
        "            for g, a in zip(new_graphs, np.linspace(0.2, 1, n_graphs)):\n",
        "                g.set_opacity(a)\n",
        "\n",
        "            container.set_submobjects(new_graphs)\n",
        "            return container\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(marks),\n",
        "            UpdateFromFunc(\n",
        "                beta_container,\n",
        "                update_beta,\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                graph_container,\n",
        "                update_graph,\n",
        "            ),\n",
        "            run_time=15,\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskInverseQuestion(WhatsTheModel):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.introduce_buyer_and_seller()\n",
        "        self.bs_group = VGroup(\n",
        "            self.buyer,\n",
        "            self.seller,\n",
        "            self.buyer.label,\n",
        "            self.seller.label,\n",
        "        )\n",
        "        self.bs_group.to_edge(DOWN)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.add_probability_label()\n",
        "        self.show_many_review_animations()\n",
        "        self.ask_question()\n",
        "\n",
        "    def add_probability_label(self):\n",
        "        label = get_prob_positive_experience_label(True, True, False)\n",
        "        label.decimal.set_value(0.95)\n",
        "        label.next_to(self.seller, UP, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(label)\n",
        "        self.probability_label = label\n",
        "\n",
        "    def show_many_review_animations(self):\n",
        "        for x in range(7):\n",
        "            self.play(*self.experience_animations(\n",
        "                self.seller,\n",
        "                self.buyer,\n",
        "                arc=30 * DEGREES,\n",
        "                p=0.95,\n",
        "            ))\n",
        "\n",
        "    def ask_question(self):\n",
        "        pis = [self.buyer, self.seller]\n",
        "        labels = VGroup(\n",
        "            self.get_prob_review_label(10, 0),\n",
        "            self.get_prob_review_label(48, 2),\n",
        "            self.get_prob_review_label(186, 14),\n",
        "        )\n",
        "        labels.arrange(DOWN)\n",
        "        labels.to_edge(UP)\n",
        "\n",
        "        labels[0].save_state()\n",
        "        labels[0].set_opacity(0)\n",
        "        words = labels[0][-3:-1]\n",
        "        words.set_opacity(1)\n",
        "        words.scale(1.5)\n",
        "        words.center().to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(labels[0]),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, 'pondering', labels)\n",
        "                for pi in pis\n",
        "            ]\n",
        "        )\n",
        "        self.play(Blink(pis[0]))\n",
        "        self.play(Blink(pis[1]))\n",
        "        self.play(LaggedStartMap(FadeInFromDown, labels[1:]))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Succinct\n",
        "        short_label = OldTex(\n",
        "            \"P(\\\\text{data} | s)\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{data}\": GREY_B,\n",
        "                \"s\": YELLOW\n",
        "            }\n",
        "        )\n",
        "        short_label.scale(2)\n",
        "        short_label.next_to(labels, DOWN, LARGE_BUFF),\n",
        "        rect = SurroundingRectangle(short_label, buff=MED_SMALL_BUFF)\n",
        "        bs_group = self.bs_group\n",
        "        bs_group.add(self.probability_label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(short_label, UP),\n",
        "            bs_group.scale, 0.5, {\"about_edge\": DOWN},\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "    def get_prob_review_label(self, n_positive, n_negative):\n",
        "        label = OldTex(\n",
        "            \"P(\",\n",
        "            f\"{n_positive}\\\\,{CMARK_TEX}\", \",\\\\,\",\n",
        "            f\"{n_negative}\\\\,{XMARK_TEX}\",\n",
        "            \"\\\\,\\\\text{ Given that }\",\n",
        "            \"s = 0.95\",\n",
        "            \")\",\n",
        "        )\n",
        "        label.set_color_by_tex_to_color_map({\n",
        "            CMARK_TEX: GREEN,\n",
        "            XMARK_TEX: RED,\n",
        "            \"0.95\": YELLOW,\n",
        "        })\n",
        "        return label\n",
        "\n",
        "\n",
        "class SimulationsOf10Reviews(Scene):\n",
        "    CONFIG = {\n",
        "        \"s\": 0.95,\n",
        "        \"histogram_height\": 5,\n",
        "        \"histogram_width\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Add s label\n",
        "        s_label = OldTex(\"s = 0.95\")\n",
        "        s_label.set_height(0.3)\n",
        "        s_label.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        s_label.set_color(YELLOW)\n",
        "        self.add(s_label)\n",
        "        self.camera.frame.shift(LEFT)\n",
        "        s_label.shift(LEFT)\n",
        "\n",
        "        # Add random row\n",
        "        np.random.seed(0)\n",
        "        row = get_random_num_row(self.s)\n",
        "        count = self.get_count(row)\n",
        "        count.add_updater(\n",
        "            lambda m: m.set_value(\n",
        "                sum([s.positive for s in row.syms])\n",
        "            )\n",
        "        )\n",
        "\n",
        "        def update_nums(nums):\n",
        "            for num in nums:\n",
        "                num.set_value(np.random.random())\n",
        "\n",
        "        row.nums.save_state()\n",
        "        row.nums.set_color(WHITE)\n",
        "        self.play(\n",
        "            UpdateFromFunc(row.nums, update_nums),\n",
        "            run_time=2,\n",
        "        )\n",
        "        row.nums.restore()\n",
        "        self.wait()\n",
        "\n",
        "        self.add(count)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(row.syms),\n",
        "            run_time=2,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        count.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        # Histogram\n",
        "        data = np.zeros(11)\n",
        "        histogram = self.get_histogram(data)\n",
        "\n",
        "        stacks = VGroup()\n",
        "        for bar in histogram.bars:\n",
        "            stacks.add(VGroup(bar.copy()))\n",
        "\n",
        "        def put_into_histogram(row_count_group):\n",
        "            row, count = row_count_group\n",
        "            count.clear_updaters()\n",
        "            index = int(count.get_value())\n",
        "            stack = stacks[index]\n",
        "\n",
        "            row.set_width(stack.get_width() - SMALL_BUFF)\n",
        "            row.next_to(stack, UP, SMALL_BUFF)\n",
        "            count.replace(histogram.axes.x_labels[index])\n",
        "            stack.add(row)\n",
        "            return row_count_group\n",
        "\n",
        "        # Random samples in histogram\n",
        "        self.play(\n",
        "            FadeIn(histogram),\n",
        "            ApplyFunction(\n",
        "                put_into_histogram,\n",
        "                VGroup(row, count),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            row = get_random_num_row(self.s)\n",
        "            count = self.get_count(row)\n",
        "            group = VGroup(row, count)\n",
        "            self.play(FadeIn(group, lag_ratio=0.2))\n",
        "            self.wait(0.5)\n",
        "            self.play(\n",
        "                ApplyFunction(\n",
        "                    put_into_histogram,\n",
        "                    VGroup(row, count),\n",
        "                )\n",
        "            )\n",
        "\n",
        "        # More!\n",
        "        for x in range(40):\n",
        "            row = get_random_num_row(self.s)\n",
        "            count = self.get_count(row)\n",
        "            lower_group = VGroup(row, count).copy()\n",
        "            put_into_histogram(lower_group)\n",
        "            self.add(row, count, lower_group)\n",
        "            self.wait(0.1)\n",
        "            self.remove(row, count)\n",
        "\n",
        "        data = np.array([len(stack) - 1 for stack in stacks])\n",
        "        self.add(row, count)\n",
        "        self.play(\n",
        "            FadeOut(stacks),\n",
        "            FadeOut(count),\n",
        "            histogram.bars.become, histogram.get_bars(data),\n",
        "            histogram.axes.y_labels.set_opacity, 1,\n",
        "            histogram.axes.h_lines.set_opacity, 1,\n",
        "            histogram.axes.y_axis.set_opacity, 1,\n",
        "        )\n",
        "        self.remove(stacks)\n",
        "\n",
        "        arrow = Vector(0.5 * DOWN)\n",
        "        arrow.set_stroke(width=5)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow.next_to(histogram.bars[10], UP, SMALL_BUFF)\n",
        "\n",
        "        def update(dummy):\n",
        "            new_row = get_random_num_row(self.s)\n",
        "            row.become(new_row)\n",
        "            count = sum([m.positive for m in new_row.nums])\n",
        "            data[count] += 1\n",
        "            histogram.bars.become(histogram.get_bars(data))\n",
        "            arrow.next_to(histogram.bars[count], UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(arrow)\n",
        "        self.play(\n",
        "            UpdateFromFunc(Group(row, arrow, histogram.bars), update),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_histogram(self, data):\n",
        "        histogram = Histogram(\n",
        "            data,\n",
        "            bar_colors=[RED, RED, BLUE, GREEN],\n",
        "            height=self.histogram_height,\n",
        "            width=self.histogram_width,\n",
        "        )\n",
        "        histogram.to_edge(DOWN)\n",
        "\n",
        "        histogram.axes.y_labels.set_opacity(0)\n",
        "        histogram.axes.h_lines.set_opacity(0)\n",
        "        return histogram\n",
        "\n",
        "    def get_count(self, row):\n",
        "        count = Integer()\n",
        "        count.set_height(0.75)\n",
        "        count.next_to(row, DOWN, buff=0.65)\n",
        "        count.set_value(sum([s.positive for s in row.syms]))\n",
        "        return count\n",
        "\n",
        "\n",
        "class SimulationsOf10ReviewsSquished(SimulationsOf10Reviews):\n",
        "    CONFIG = {\n",
        "        \"histogram_height\": 2,\n",
        "        \"histogram_width\": 11,\n",
        "    }\n",
        "\n",
        "    def get_histogram(self, data):\n",
        "        hist = super().get_histogram(data)\n",
        "        hist.to_edge(UP, buff=1.5)\n",
        "        return hist\n",
        "\n",
        "\n",
        "class SimulationsOf50Reviews(Scene):\n",
        "    CONFIG = {\n",
        "        \"s\": 0.95,\n",
        "        \"histogram_config\": {\n",
        "            \"x_label_freq\": 5,\n",
        "            \"y_axis_numbers_to_show\": range(10, 70, 10),\n",
        "            \"y_max\": 0.6,\n",
        "            \"y_tick_freq\": 0.1,\n",
        "            \"height\": 5,\n",
        "            \"bar_colors\": [BLUE],\n",
        "        },\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_s_label()\n",
        "\n",
        "        data = np.zeros(51)\n",
        "        histogram = self.get_histogram(data)\n",
        "\n",
        "        row = self.get_row()\n",
        "        count = self.get_count(row)\n",
        "        original_count = count.get_value()\n",
        "        count.set_value(0)\n",
        "\n",
        "        self.add(histogram)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(row),\n",
        "            ChangeDecimalToValue(count, original_count)\n",
        "        )\n",
        "\n",
        "        # Run many samples\n",
        "        arrow = Vector(0.5 * DOWN)\n",
        "        arrow.set_stroke(width=5)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow.next_to(histogram.bars[10], UP, SMALL_BUFF)\n",
        "\n",
        "        total_data_label = VGroup(\n",
        "            OldTexText(\"Total samples: \"),\n",
        "            Integer(1),\n",
        "        )\n",
        "        total_data_label.arrange(RIGHT)\n",
        "        total_data_label.next_to(row, DOWN)\n",
        "        total_data_label.add_updater(\n",
        "            lambda m: m[1].set_value(data.sum())\n",
        "        )\n",
        "\n",
        "        def update(dummy, n_added_data_points=0):\n",
        "            new_row = self.get_row()\n",
        "            row.become(new_row)\n",
        "            num_positive = sum([m.positive for m in new_row])\n",
        "            count.set_value(num_positive)\n",
        "            data[num_positive] += 1\n",
        "            if n_added_data_points:\n",
        "                values = np.random.random((n_added_data_points, 50))\n",
        "                counts = (values < self.s).sum(1)\n",
        "                for i in range(len(data)):\n",
        "                    data[i] += (counts == i).sum()\n",
        "            histogram.bars.become(histogram.get_bars(data))\n",
        "            histogram.bars.set_fill(GREY_C)\n",
        "            histogram.bars[48].set_fill(GREEN)\n",
        "            arrow.next_to(histogram.bars[num_positive], UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(arrow, total_data_label)\n",
        "        group = VGroup(histogram.bars, row, count, arrow)\n",
        "        self.play(\n",
        "            UpdateFromFunc(group, update),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromFunc(\n",
        "                group,\n",
        "                lambda m: update(m, 1000)\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        random.seed(0)\n",
        "        np.random.seed(0)\n",
        "        update(group)\n",
        "        self.wait()\n",
        "\n",
        "        # Show 48 bar\n",
        "        axes = histogram.axes\n",
        "        y = choose(50, 48) * (self.s)**48 * (1 - self.s)**2\n",
        "        line = DashedLine(\n",
        "            axes.c2p(0, y),\n",
        "            axes.c2p(51, y),\n",
        "        )\n",
        "        label = OldTex(\"{:.1f}\\\\%\".format(100 * y))\n",
        "        fix_percent(label.family_members_with_points()[-1])\n",
        "        label.next_to(line, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeInFromPoint(label, line.get_start())\n",
        "        )\n",
        "\n",
        "    def add_s_label(self):\n",
        "        s_label = OldTex(\"s = 0.95\")\n",
        "        s_label.set_height(0.3)\n",
        "        s_label.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        s_label.shift(0.8 * DOWN)\n",
        "        s_label.set_color(YELLOW)\n",
        "        self.add(s_label)\n",
        "\n",
        "    def get_histogram(self, data):\n",
        "        histogram = Histogram(\n",
        "            data, **self.histogram_config\n",
        "        )\n",
        "        histogram.to_edge(DOWN)\n",
        "        return histogram\n",
        "\n",
        "    def get_row(self, n=50):\n",
        "        row = get_random_checks_and_crosses(n, self.s)\n",
        "        row.move_to(3.5 * UP)\n",
        "        return row\n",
        "\n",
        "    def get_count(self, row):\n",
        "        count = Integer(sum([m.positive for m in row]))\n",
        "        count.set_height(0.3)\n",
        "        count.next_to(row, RIGHT)\n",
        "        return count\n",
        "\n",
        "\n",
        "class ShowBinomialFormula(SimulationsOf50Reviews):\n",
        "    CONFIG = {\n",
        "        \"histogram_config\": {\n",
        "            \"x_label_freq\": 5,\n",
        "            \"y_axis_numbers_to_show\": range(10, 40, 10),\n",
        "            \"y_max\": 0.3,\n",
        "            \"y_tick_freq\": 0.1,\n",
        "            \"height\": 2.5,\n",
        "            \"bar_colors\": [BLUE],\n",
        "        },\n",
        "        \"random_seed\": 0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Add histogram\n",
        "        dist = scipy.stats.binom(50, self.s)\n",
        "        data = np.array([\n",
        "            dist.pmf(x)\n",
        "            for x in range(0, 51)\n",
        "        ])\n",
        "        histogram = self.get_histogram(data)\n",
        "        histogram.bars.set_fill(GREY_C)\n",
        "        histogram.bars[48].set_fill(GREEN)\n",
        "        self.add(histogram)\n",
        "\n",
        "        row = self.get_row()\n",
        "        self.add(row)\n",
        "\n",
        "        # Formula\n",
        "        prob_label = get_prob_review_label(48, 2)\n",
        "        eq = OldTex(\"=\")\n",
        "        formula = get_binomial_formula(50, 48, self.s)\n",
        "\n",
        "        equation = VGroup(\n",
        "            prob_label,\n",
        "            eq,\n",
        "            formula,\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.next_to(histogram, UP, LARGE_BUFF)\n",
        "        equation.to_edge(RIGHT)\n",
        "\n",
        "        prob_label.save_state()\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(histogram.bars[48], UP, SMALL_BUFF)\n",
        "        prob_label.next_to(arrow, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(prob_label),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        for mob in prob_label[1::2]:\n",
        "            line = Underline(mob)\n",
        "            line.match_color(mob)\n",
        "            self.play(ShowCreationThenDestruction(line))\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            Restore(prob_label),\n",
        "            FadeIn(equation[1:], lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.explain_n_choose_k(row, formula)\n",
        "\n",
        "        # Circle formula parts\n",
        "        rect1 = SurroundingRectangle(formula[4:8])\n",
        "        rect2 = SurroundingRectangle(formula[8:])\n",
        "        rect1.set_stroke(GREEN, 2)\n",
        "        rect2.set_stroke(RED, 2)\n",
        "\n",
        "        for rect in rect1, rect2:\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(rect))\n",
        "\n",
        "        # Show numerical answer\n",
        "        eq2 = OldTex(\"=\")\n",
        "        value = DecimalNumber(dist.pmf(48), num_decimal_places=5)\n",
        "        rhs = VGroup(eq2, value)\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.match_y(eq)\n",
        "        rhs.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        self.play(\n",
        "            FadeIn(value, LEFT),\n",
        "            FadeIn(eq2),\n",
        "            equation.next_to, eq2, LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show alternate values of k\n",
        "        n = 50\n",
        "        for k in it.chain(range(47, 42, -1), range(43, 51), [49, 48]):\n",
        "            new_prob_label = get_prob_review_label(k, n - k)\n",
        "            new_prob_label.replace(prob_label)\n",
        "            prob_label.become(new_prob_label)\n",
        "            new_formula = get_binomial_formula(n, k, self.s)\n",
        "            new_formula.replace(formula)\n",
        "            formula.set_submobjects(new_formula)\n",
        "\n",
        "            value.set_value(dist.pmf(k))\n",
        "            histogram.bars.set_fill(GREY_B)\n",
        "            histogram.bars[k].set_fill(GREEN)\n",
        "            arrow.next_to(histogram.bars[k], UP, SMALL_BUFF)\n",
        "\n",
        "            new_row = get_checks_and_crosses((n - k) * [False] + k * [True])\n",
        "            new_row.replace(row)\n",
        "            row.become(new_row)\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Name it as the Binomial distribution\n",
        "        long_equation = VGroup(prob_label, eq, formula, eq2, value)\n",
        "        bin_name = OldTexText(\"Binomial\", \" Distribution\")\n",
        "        bin_name.scale(1.5)\n",
        "        bin_name.next_to(histogram, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        underline = Underline(bin_name[0])\n",
        "        underline.set_stroke(PINK, 2)\n",
        "        nck_rect = SurroundingRectangle(formula[:4])\n",
        "        nck_rect.set_stroke(PINK, 2)\n",
        "\n",
        "        self.play(\n",
        "            long_equation.next_to, self.slots, DOWN, MED_LARGE_BUFF,\n",
        "            long_equation.to_edge, RIGHT,\n",
        "            FadeIn(bin_name, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenDestruction(underline))\n",
        "        self.wait()\n",
        "        bools = [True] * 50\n",
        "        bools[random.randint(0, 49)] = False\n",
        "        bools[random.randint(0, 49)] = False\n",
        "        row.become(get_checks_and_crosses(bools).replace(row))\n",
        "        self.play(ShowIncreasingSubsets(row, run_time=4))\n",
        "        self.wait()\n",
        "\n",
        "        # Show likelihood and posterior labels\n",
        "        likelihood_label = OldTex(\n",
        "            \"P(\",\n",
        "            \"\\\\text{data}\", \"\\\\,|\\\\,\",\n",
        "            \"\\\\text{success rate}\",\n",
        "            \")\",\n",
        "        )\n",
        "        posterior_label = OldTex(\n",
        "            \"P(\",\n",
        "            \"\\\\text{success rate}\",\n",
        "            \"\\\\,|\\\\,\",\n",
        "            \"\\\\text{data}\",\n",
        "            \")\",\n",
        "        )\n",
        "        for label in (likelihood_label, posterior_label):\n",
        "            label.set_color_by_tex_to_color_map({\n",
        "                \"data\": GREEN,\n",
        "                \"success\": YELLOW,\n",
        "            })\n",
        "\n",
        "        likelihood_label.next_to(\n",
        "            prob_label, DOWN, LARGE_BUFF, aligned_edge=LEFT\n",
        "        )\n",
        "\n",
        "        right_arrow = Vector(RIGHT)\n",
        "        right_arrow.next_to(likelihood_label, RIGHT)\n",
        "        ra_label = OldTexText(\"But we want\")\n",
        "        ra_label.match_width(right_arrow)\n",
        "        ra_label.next_to(right_arrow, UP, SMALL_BUFF)\n",
        "        posterior_label.next_to(right_arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(likelihood_label, UP),\n",
        "            bin_name.set_height, 0.4,\n",
        "            bin_name.set_y, histogram.axes.c2p(0, .25)[1]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(right_arrow),\n",
        "            FadeIn(ra_label, 0.5 * LEFT),\n",
        "        )\n",
        "        anims = []\n",
        "        for i, j in enumerate([0, 3, 2, 1, 4]):\n",
        "            anims.append(\n",
        "                TransformFromCopy(\n",
        "                    likelihood_label[i],\n",
        "                    posterior_label[j],\n",
        "                    path_arc=-45 * DEGREES,\n",
        "                    run_time=2,\n",
        "                )\n",
        "            )\n",
        "        self.play(*anims)\n",
        "        self.add(posterior_label)\n",
        "        self.wait()\n",
        "\n",
        "        # Prepare for new plot\n",
        "        histogram.add(bin_name)\n",
        "        always(arrow.next_to, histogram.bars[48], UP, SMALL_BUFF)\n",
        "        self.play(\n",
        "            FadeOut(likelihood_label),\n",
        "            FadeOut(posterior_label),\n",
        "            FadeOut(right_arrow),\n",
        "            FadeOut(ra_label),\n",
        "            FadeOut(row, UP),\n",
        "            FadeOut(self.slots, UP),\n",
        "            histogram.scale, 0.7,\n",
        "            histogram.to_edge, UP,\n",
        "            arrow.scale, 0.5,\n",
        "            arrow.set_stroke, None, 4,\n",
        "            long_equation.center,\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.add(arrow)\n",
        "\n",
        "        # x_labels = histogram.axes.x_labels\n",
        "        # underline = Underline(x_labels)\n",
        "        # underline.set_stroke(GREEN, 3)\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(\n",
        "        #         ApplyFunction, x_labels,\n",
        "        #         lambda mob: (\n",
        "        #             lambda m: m.scale(1.5).set_color(GREEN),\n",
        "        #             mob,\n",
        "        #         ),\n",
        "        #         rate_func=there_and_back,\n",
        "        #     ),\n",
        "        #     ShowCreationThenDestruction(underline),\n",
        "        # )\n",
        "        # num_checks = OldTex(\"\\\\# \" + CMARK_TEX)\n",
        "        # num_checks.set_color(GREEN)\n",
        "        # num_checks.next_to(\n",
        "        #     x_labels, RIGHT,\n",
        "        #     MED_LARGE_BUFF,\n",
        "        #     aligned_edge=DOWN,\n",
        "        # )\n",
        "        # self.play(Write(num_checks))\n",
        "        # self.wait()\n",
        "\n",
        "        low_axes = get_beta_dist_axes(y_max=0.3, y_unit=0.1, label_y=False)\n",
        "        low_axes.y_axis.set_height(\n",
        "            2,\n",
        "            about_point=low_axes.c2p(0, 0),\n",
        "            stretch=True,\n",
        "        )\n",
        "        low_axes.to_edge(DOWN)\n",
        "        low_axes.x_axis.numbers.set_color(YELLOW)\n",
        "        y_label_copies = histogram.axes.y_labels.copy()\n",
        "        y_label_copies.set_height(0.6 * low_axes.get_height())\n",
        "        y_label_copies.next_to(low_axes, LEFT, 0, aligned_edge=UP)\n",
        "        y_label_copies.shift(SMALL_BUFF * UP)\n",
        "        low_axes.y_axis.add(y_label_copies)\n",
        "        low_axes.y_axis.set_opacity(0)\n",
        "\n",
        "        # Show alternate values of s\n",
        "        s_tracker = ValueTracker(self.s)\n",
        "\n",
        "        s_tip = ArrowTip(start_angle=-90 * DEGREES)\n",
        "        s_tip.set_color(YELLOW)\n",
        "        s_tip.axis = low_axes.x_axis\n",
        "        s_tip.st = s_tracker\n",
        "        s_tip.add_updater(\n",
        "            lambda m: m.next_to(m.axis.n2p(m.st.get_value()), UP, buff=0)\n",
        "        )\n",
        "\n",
        "        pl_decimal = DecimalNumber(self.s)\n",
        "        pl_decimal.set_color(YELLOW)\n",
        "        pl_decimal.replace(prob_label[-2][2:])\n",
        "        prob_label[-2][2:].set_opacity(0)\n",
        "\n",
        "        s_label = VGroup(prob_label[-2][:2], pl_decimal).copy()\n",
        "        sl_rect = SurroundingRectangle(s_label)\n",
        "        sl_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.add(pl_decimal)\n",
        "        self.play(\n",
        "            ShowCreation(sl_rect),\n",
        "            Write(low_axes),\n",
        "        )\n",
        "        self.play(\n",
        "            s_label.next_to, s_tip, UP, 0.2, ORIGIN, s_label[1],\n",
        "            ReplacementTransform(sl_rect, s_tip)\n",
        "        )\n",
        "        always(s_label.next_to, s_tip, UP, 0.2, ORIGIN, s_label[1])\n",
        "\n",
        "        decimals = VGroup(pl_decimal, s_label[1], formula[5], formula[9])\n",
        "        decimals.s_tracker = s_tracker\n",
        "\n",
        "        histogram.s_tracker = s_tracker\n",
        "        histogram.n = n\n",
        "        histogram.rhs_value = value\n",
        "\n",
        "        def update_decimals(decs):\n",
        "            for dec in decs:\n",
        "                dec.set_value(decs.s_tracker.get_value())\n",
        "\n",
        "        def update_histogram(hist):\n",
        "            new_dist = scipy.stats.binom(hist.n, hist.s_tracker.get_value())\n",
        "            new_data = np.array([\n",
        "                new_dist.pmf(x)\n",
        "                for x in range(0, 51)\n",
        "            ])\n",
        "            new_bars = hist.get_bars(new_data)\n",
        "            new_bars.match_style(hist.bars)\n",
        "            hist.bars.become(new_bars)\n",
        "            hist.rhs_value.set_value(new_dist.pmf(48))\n",
        "\n",
        "        bar_copy = histogram.bars[48].copy()\n",
        "        value.initial_config[\"num_decimal_places\"] = 3\n",
        "        value.set_value(value.get_value())\n",
        "        bar_copy.next_to(value, RIGHT, aligned_edge=DOWN)\n",
        "        bar_copy.add_updater(\n",
        "            lambda m: m.set_height(\n",
        "                max(\n",
        "                    histogram.bars[48].get_height() * 0.75,\n",
        "                    1e-6,\n",
        "                ),\n",
        "                stretch=True,\n",
        "                about_edge=DOWN,\n",
        "            )\n",
        "        )\n",
        "        self.add(bar_copy)\n",
        "\n",
        "        self.add(histogram)\n",
        "        self.add(decimals)\n",
        "        for s in [0.95, 0.5, 0.99, 0.9]:\n",
        "            self.play(\n",
        "                s_tracker.set_value, s,\n",
        "                UpdateFromFunc(decimals, update_decimals),\n",
        "                UpdateFromFunc(histogram, update_histogram),\n",
        "                UpdateFromFunc(value, lambda m: m),\n",
        "                UpdateFromFunc(s_label, lambda m: m.update),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Plot\n",
        "        def func(x):\n",
        "            return scipy.stats.binom(50, x).pmf(48) + 1e-5\n",
        "        graph = low_axes.get_graph(func, step_size=0.05)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.axes = low_axes\n",
        "        v_line.st = s_tracker\n",
        "        v_line.graph = graph\n",
        "        v_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                m.axes.c2p(m.st.get_value(), 0),\n",
        "                m.axes.input_to_graph_point(\n",
        "                    m.st.get_value(),\n",
        "                    m.graph,\n",
        "                ),\n",
        "            )\n",
        "        )\n",
        "        v_line.set_stroke(GREEN, 2)\n",
        "        dot = Dot()\n",
        "        dot.line = v_line\n",
        "        dot.set_height(0.05)\n",
        "        dot.add_updater(lambda m: m.move_to(m.line.get_end()))\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                histogram.bars[48].stretch, 2, 1, {\"about_edge\": DOWN},\n",
        "                rate_func=there_and_back,\n",
        "                run_time=2,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(low_axes.y_axis.set_opacity, 1)\n",
        "        self.play(\n",
        "            FadeIn(graph),\n",
        "            FadeOut(s_label),\n",
        "            FadeOut(s_tip),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(histogram.bars[48], v_line),\n",
        "            FadeIn(dot),\n",
        "        )\n",
        "\n",
        "        self.add(histogram)\n",
        "        decimals.remove(decimals[1])\n",
        "        for s in [0.9, 0.96, 1, 0.8, 0.96]:\n",
        "            self.play(\n",
        "                s_tracker.set_value, s,\n",
        "                UpdateFromFunc(decimals, update_decimals),\n",
        "                UpdateFromFunc(histogram, update_histogram),\n",
        "                UpdateFromFunc(value, lambda m: m),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Write formula\n",
        "        clean_form = OldTex(\n",
        "            \"P(\", \"\\\\text{data}\", \"\\\\,|\\\\,\", \"{s}\", \")\", \"=\",\n",
        "            \"c\", \"\\\\cdot\",\n",
        "            \"{s}\", \"^{\\\\#\" + CMARK_TEX + \"}\",\n",
        "            \"(1 - \", \"{s}\", \")\", \"^{\\\\#\" + XMARK_TEX + \"}\",\n",
        "            tex_to_color_map={\n",
        "                \"{s}\": YELLOW,\n",
        "                \"\\\\#\" + CMARK_TEX: GREEN,\n",
        "                \"\\\\#\" + XMARK_TEX: RED,\n",
        "            }\n",
        "        )\n",
        "        clean_form.next_to(formula, DOWN, MED_LARGE_BUFF)\n",
        "        clean_form.save_state()\n",
        "        clean_form[:6].align_to(equation[1], RIGHT)\n",
        "        clean_form[6].match_x(formula[2])\n",
        "        clean_form[7].set_opacity(0)\n",
        "        clean_form[7].next_to(clean_form[6], RIGHT, SMALL_BUFF)\n",
        "        clean_form[8:11].match_x(formula[4:8])\n",
        "        clean_form[11:].match_x(formula[8:])\n",
        "        clean_form.saved_state.move_to(clean_form, LEFT)\n",
        "\n",
        "        fade_rects = VGroup(\n",
        "            BackgroundRectangle(equation[:2]),\n",
        "            BackgroundRectangle(formula),\n",
        "            BackgroundRectangle(VGroup(eq2, bar_copy)),\n",
        "        )\n",
        "        fade_rects.set_fill(BLACK, 0.8)\n",
        "        fade_rects[1].set_fill(opacity=0)\n",
        "\n",
        "        pre_c = formula[:4].copy()\n",
        "        pre_s = formula[4:8].copy()\n",
        "        pre_1ms = formula[8:].copy()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rects),\n",
        "            FadeIn(clean_form[:6])\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(clean_form[3]))\n",
        "        self.wait()\n",
        "        for cf, pre in (clean_form[6], pre_c), (clean_form[8:11], pre_s), (clean_form[11:], pre_1ms):\n",
        "            self.play(\n",
        "                GrowFromPoint(cf, pre.get_center()),\n",
        "                pre.move_to, cf,\n",
        "                pre.scale, 0,\n",
        "            )\n",
        "            self.remove(pre)\n",
        "            self.wait()\n",
        "\n",
        "        self.wait()\n",
        "        self.play(Restore(clean_form))\n",
        "\n",
        "        # Show with 480 and 20\n",
        "        top_fade_rect = BackgroundRectangle(histogram)\n",
        "        top_fade_rect.shift(SMALL_BUFF * DOWN)\n",
        "        top_fade_rect.scale(1.5, about_edge=DOWN)\n",
        "        top_fade_rect.set_fill(BLACK, 0)\n",
        "\n",
        "        new_formula = get_binomial_formula(500, 480, 0.96)\n",
        "        new_formula.move_to(formula)\n",
        "\n",
        "        def func500(x):\n",
        "            return scipy.stats.binom(500, x).pmf(480) + 1e-5\n",
        "\n",
        "        graph500 = low_axes.get_graph(func500, step_size=0.05)\n",
        "        graph500.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.play(\n",
        "            top_fade_rect.set_opacity, 1,\n",
        "            fade_rects.set_opacity, 1,\n",
        "            FadeIn(new_formula)\n",
        "        )\n",
        "\n",
        "        self.clear()\n",
        "        self.add(new_formula, clean_form, low_axes, graph, v_line, dot)\n",
        "        self.add(low_axes.y_axis)\n",
        "\n",
        "        self.play(TransformFromCopy(graph, graph500))\n",
        "        self.wait()\n",
        "\n",
        "        y_axis = low_axes.y_axis\n",
        "        y_axis.save_state()\n",
        "        sf = 3\n",
        "        y_axis.stretch(sf, 1, about_point=low_axes.c2p(0, 0))\n",
        "        for label in y_label_copies:\n",
        "            label.stretch(1 / sf, 1)\n",
        "\n",
        "        v_line.suspend_updating()\n",
        "        v_line.graph = graph500\n",
        "        self.play(\n",
        "            Restore(y_axis, rate_func=reverse_smooth),\n",
        "            graph.stretch, sf, 1, {\"about_edge\": DOWN},\n",
        "            graph500.stretch, sf, 1, {\"about_edge\": DOWN},\n",
        "        )\n",
        "        v_line.resume_updating()\n",
        "        self.add(v_line, dot)\n",
        "\n",
        "        sub_decimals = VGroup(new_formula[5], new_formula[9])\n",
        "        sub_decimals.s_tracker = s_tracker\n",
        "\n",
        "        for s in [0.94, 0.98, 0.96]:\n",
        "            self.play(\n",
        "                s_tracker.set_value, s,\n",
        "                UpdateFromFunc(sub_decimals, update_decimals),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def explain_n_choose_k(self, row, formula):\n",
        "        row.add_updater(lambda m: m)\n",
        "\n",
        "        brace = Brace(formula[:4], UP, buff=SMALL_BUFF)\n",
        "        words = brace.get_text(\"``50 choose 48''\")\n",
        "\n",
        "        slots = self.slots = VGroup()\n",
        "        for sym in row:\n",
        "            line = Underline(sym)\n",
        "            line.scale(0.9)\n",
        "            slots.add(line)\n",
        "        for slot in slots:\n",
        "            slot.match_y(slots[0])\n",
        "\n",
        "        formula[1].counted = slots\n",
        "        k_rect = SurroundingRectangle(formula[2])\n",
        "        k_rect.set_stroke(GREEN, 2)\n",
        "\n",
        "        checks = VGroup()\n",
        "        for sym in row:\n",
        "            if sym.positive:\n",
        "                checks.add(sym)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeInFromDown(words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(words))\n",
        "        formula.save_state()\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(slots),\n",
        "            UpdateFromFunc(\n",
        "                formula[1],\n",
        "                lambda m: m.set_value(len(m.counted))\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        formula.restore()\n",
        "        self.add(formula)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, checks,\n",
        "                lambda m: (m.shift, 0.3 * DOWN),\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            ShowCreationThenFadeOut(k_rect),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.remove(checks)\n",
        "        self.add(row)\n",
        "        self.wait()\n",
        "\n",
        "        # Example orderings\n",
        "        row_target = VGroup()\n",
        "        for sym in row:\n",
        "            sym.generate_target()\n",
        "            row_target.add(sym.target)\n",
        "\n",
        "        row_target.sort(submob_func=lambda m: -int(m.positive))\n",
        "        row_target.arrange(\n",
        "            RIGHT, buff=get_norm(row[0].get_right() - row[1].get_left())\n",
        "        )\n",
        "        row_target.move_to(row)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, row,\n",
        "                path_arc=30 * DEGREES,\n",
        "                lag_ratio=0,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        row.sort()\n",
        "        self.play(Swap(*row[-3:-1]))\n",
        "        self.add(row)\n",
        "        self.wait()\n",
        "\n",
        "        # All orderings\n",
        "        nck_count = Integer(2)\n",
        "        nck_count.next_to(brace, UP)\n",
        "        nck_top = nck_count.get_top()\n",
        "        always(nck_count.move_to, nck_top, UP)\n",
        "\n",
        "        combs = list(it.combinations(range(50), 48))\n",
        "        bool_lists = [\n",
        "            [i in comb for i in range(50)]\n",
        "            for comb in combs\n",
        "        ]\n",
        "        row.counter = nck_count\n",
        "        row.bool_lists = bool_lists\n",
        "\n",
        "        def update_row(r):\n",
        "            i = r.counter.get_value() - 1\n",
        "            new_row = get_checks_and_crosses(r.bool_lists[i])\n",
        "            new_row.replace(r, dim_to_match=0)\n",
        "            r.set_submobjects(new_row)\n",
        "\n",
        "        row.add_updater(update_row)\n",
        "        self.add(row)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(nck_count, choose(50, 48)),\n",
        "            run_time=10,\n",
        "        )\n",
        "        row.clear_updaters()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(nck_count),\n",
        "            FadeOut(brace),\n",
        "        )\n",
        "\n",
        "\n",
        "class StateIndependence(Scene):\n",
        "    def construct(self):\n",
        "        row = get_random_checks_and_crosses()\n",
        "        row.to_edge(UP)\n",
        "        # self.add(row)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for m1, m2 in zip(row, row[1:]):\n",
        "            arrow = Arrow(\n",
        "                m1.get_bottom() + 0.025 * DOWN,\n",
        "                m2.get_bottom(),\n",
        "                path_arc=145 * DEGREES,\n",
        "                max_stroke_width_to_length_ratio=10,\n",
        "                max_tip_length_to_length_ratio=0.5,\n",
        "            )\n",
        "            arrow.tip.rotate(-10 * DEGREES)\n",
        "            arrow.shift(SMALL_BUFF * DOWN)\n",
        "            arrow.set_color(YELLOW)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        words = OldTexText(\"No influence\")\n",
        "        words.set_height(0.25)\n",
        "        words.next_to(arrows[0], DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrows[0]),\n",
        "            FadeIn(words)\n",
        "        )\n",
        "        for i in range(10):\n",
        "            self.play(\n",
        "                words.next_to, arrows[i + 1], DOWN,\n",
        "                FadeOut(arrows[i]),\n",
        "                ShowCreation(arrows[i + 1])\n",
        "            )\n",
        "            last_arrow = arrows[i + 1]\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(last_arrow),\n",
        "        )\n",
        "\n",
        "\n",
        "class IllustrateBinomialSetupWithCoins(Scene):\n",
        "    def construct(self):\n",
        "        coins = [\n",
        "            get_coin(\"H\"),\n",
        "            get_coin(\"T\"),\n",
        "        ]\n",
        "\n",
        "        coin_row = VGroup()\n",
        "        for x in range(12):\n",
        "            coin_row.add(random.choice(coins).copy())\n",
        "\n",
        "        coin_row.arrange(RIGHT)\n",
        "        coin_row.to_edge(UP)\n",
        "\n",
        "        first_coin = get_random_coin(shuffle_time=2, total_time=2)\n",
        "        first_coin.move_to(coin_row[0])\n",
        "\n",
        "        brace = Brace(coin_row, UP)\n",
        "        brace_label = brace.get_text(\"$N$ times\")\n",
        "\n",
        "        prob_label = OldTex(\n",
        "            \"P(\\\\# 00 = k)\",\n",
        "            tex_to_color_map={\n",
        "                \"00\": WHITE,\n",
        "                \"k\": GREEN,\n",
        "            }\n",
        "        )\n",
        "        heads = get_coin(\"H\")\n",
        "        template = prob_label.get_part_by_tex(\"00\")\n",
        "        heads.replace(template)\n",
        "        prob_label.replace_submobject(\n",
        "            prob_label.index_of_part(template),\n",
        "            heads,\n",
        "        )\n",
        "        prob_label.set_height(1)\n",
        "        prob_label.next_to(coin_row, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.camera.frame.set_height(1.5 * FRAME_HEIGHT)\n",
        "\n",
        "        self.add(first_coin)\n",
        "        for x in range(4):\n",
        "            self.wait()\n",
        "            first_coin.suspend_updating()\n",
        "            self.wait()\n",
        "            first_coin.resume_updating()\n",
        "\n",
        "        self.remove(first_coin)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coin_row, int_func=np.ceil),\n",
        "            GrowFromPoint(brace, brace.get_left()),\n",
        "            FadeIn(brace_label, 3 * LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(prob_label, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WriteLikelihoodFunction(Scene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\n",
        "            \"f({s}) = (\\\\text{const.})\",\n",
        "            \"{s}^{\\\\#\" + CMARK_TEX + \"}\",\n",
        "            \"(1 - {s})^{\\\\#\" + XMARK_TEX, \"}\",\n",
        "            tex_to_color_map={\n",
        "                \"{s}\": YELLOW,\n",
        "                \"\\\\#\" + CMARK_TEX: GREEN,\n",
        "                \"\\\\#\" + XMARK_TEX: RED,\n",
        "            }\n",
        "        )\n",
        "        formula.scale(2)\n",
        "\n",
        "        rect1 = SurroundingRectangle(formula[3:6])\n",
        "        rect2 = SurroundingRectangle(formula[6:])\n",
        "\n",
        "        self.play(FadeInFromDown(formula))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeOut(rect1))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeOut(rect2))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(formula)\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class Guess96Percent(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.set_height(1)\n",
        "\n",
        "        bubble = SpeechBubble(height=2, width=3)\n",
        "        bubble.pin_to(randy)\n",
        "        words = OldTexText(\"96$\\\\%$, right?\")\n",
        "        fix_percent(words[0][2])\n",
        "        bubble.add_content(words)\n",
        "\n",
        "        arrow = Vector(2 * RIGHT + DOWN)\n",
        "        arrow.next_to(randy, RIGHT)\n",
        "        arrow.shift(2 * UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            ShowCreation(bubble),\n",
        "            Write(words),\n",
        "        )\n",
        "        self.play(randy.change, \"shruggie\", randy.get_right() + RIGHT)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        for x in range(2):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class LikelihoodGraphFor10of10(ShowBinomialFormula):\n",
        "    CONFIG = {\n",
        "        \"histogram_config\": {\n",
        "            \"x_label_freq\": 2,\n",
        "            \"y_axis_numbers_to_show\": range(25, 125, 25),\n",
        "            \"y_max\": 1,\n",
        "            \"y_tick_freq\": 0.25,\n",
        "            \"height\": 2,\n",
        "            \"bar_colors\": [BLUE],\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Add histogram\n",
        "        dist = scipy.stats.binom(10, self.s)\n",
        "        data = np.array([\n",
        "            dist.pmf(x)\n",
        "            for x in range(0, 11)\n",
        "        ])\n",
        "        histogram = self.get_histogram(data)\n",
        "        histogram.bars.set_fill(GREY_C)\n",
        "        histogram.bars[10].set_fill(GREEN)\n",
        "        histogram.to_edge(UP)\n",
        "\n",
        "        x_label = OldTex(\"\\\\#\" + CMARK_TEX)\n",
        "        x_label.set_color(GREEN)\n",
        "        x_label.next_to(histogram.axes.x_axis.get_end(), RIGHT)\n",
        "        histogram.add(x_label)\n",
        "        self.add(histogram)\n",
        "\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(histogram.bars[10], UP, SMALL_BUFF)\n",
        "        self.add(arrow)\n",
        "\n",
        "        # Add formula\n",
        "        prob_label = get_prob_review_label(10, 0)\n",
        "        eq = OldTex(\"=\")\n",
        "        formula = get_binomial_formula(10, 10, self.s)\n",
        "        eq2 = OldTex(\"=\")\n",
        "        value = DecimalNumber(dist.pmf(10), num_decimal_places=2)\n",
        "\n",
        "        equation = VGroup(prob_label, eq, formula, eq2, value)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.next_to(histogram, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        # Add lower axes\n",
        "        low_axes = get_beta_dist_axes(y_max=1, y_unit=0.25, label_y=False)\n",
        "        low_axes.y_axis.set_height(\n",
        "            2,\n",
        "            about_point=low_axes.c2p(0, 0),\n",
        "            stretch=True,\n",
        "        )\n",
        "        low_axes.to_edge(DOWN)\n",
        "        low_axes.x_axis.numbers.set_color(YELLOW)\n",
        "        y_label_copies = histogram.axes.y_labels.copy()\n",
        "        y_label_copies.set_height(0.7 * low_axes.get_height())\n",
        "        y_label_copies.next_to(low_axes, LEFT, 0, aligned_edge=UP)\n",
        "        y_label_copies.shift(SMALL_BUFF * UP)\n",
        "        low_axes.y_axis.add(y_label_copies)\n",
        "\n",
        "        # Add lower plot\n",
        "        s_tracker = ValueTracker(self.s)\n",
        "\n",
        "        def func(x):\n",
        "            return x**10\n",
        "        graph = low_axes.get_graph(func, step_size=0.05)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.axes = low_axes\n",
        "        v_line.st = s_tracker\n",
        "        v_line.graph = graph\n",
        "        v_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                m.axes.c2p(m.st.get_value(), 0),\n",
        "                m.axes.input_to_graph_point(\n",
        "                    m.st.get_value(),\n",
        "                    m.graph,\n",
        "                ),\n",
        "            )\n",
        "        )\n",
        "        v_line.set_stroke(GREEN, 2)\n",
        "        dot = Dot()\n",
        "        dot.line = v_line\n",
        "        dot.set_height(0.05)\n",
        "        dot.add_updater(lambda m: m.move_to(m.line.get_end()))\n",
        "\n",
        "        # Show simpler formula\n",
        "        brace = Brace(formula, DOWN, buff=SMALL_BUFF)\n",
        "        simpler_formula = OldTex(\"s\", \"^{10}\")\n",
        "        simpler_formula.set_color_by_tex(\"s\", YELLOW)\n",
        "        simpler_formula.set_color_by_tex(\"10\", GREEN)\n",
        "        simpler_formula.next_to(brace, DOWN)\n",
        "\n",
        "        rects = VGroup(\n",
        "            BackgroundRectangle(formula[:4]),\n",
        "            BackgroundRectangle(formula[8:]),\n",
        "        )\n",
        "        rects.set_opacity(0.75)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(FadeIn(equation))\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rects),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(simpler_formula, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show various values of s\n",
        "        pl_decimal = DecimalNumber(self.s)\n",
        "        pl_decimal.set_color(YELLOW)\n",
        "        pl_decimal.replace(prob_label[-2][2:])\n",
        "        prob_label[-2][2:].set_opacity(0)\n",
        "\n",
        "        decimals = VGroup(pl_decimal, formula[5], formula[9])\n",
        "        decimals.s_tracker = s_tracker\n",
        "\n",
        "        histogram.s_tracker = s_tracker\n",
        "        histogram.n = 10\n",
        "        histogram.rhs_value = value\n",
        "\n",
        "        def update_decimals(decs):\n",
        "            for dec in decs:\n",
        "                dec.set_value(decs.s_tracker.get_value())\n",
        "\n",
        "        def update_histogram(hist):\n",
        "            new_dist = scipy.stats.binom(hist.n, hist.s_tracker.get_value())\n",
        "            new_data = np.array([\n",
        "                new_dist.pmf(x)\n",
        "                for x in range(0, 11)\n",
        "            ])\n",
        "            new_bars = hist.get_bars(new_data)\n",
        "            new_bars.match_style(hist.bars)\n",
        "            hist.bars.become(new_bars)\n",
        "            hist.rhs_value.set_value(new_dist.pmf(10))\n",
        "\n",
        "        self.add(histogram)\n",
        "        self.add(decimals, rects)\n",
        "        self.play(\n",
        "            FadeIn(low_axes),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            FadeIn(dot),\n",
        "        )\n",
        "        self.add(graph, v_line, dot)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.wait()\n",
        "\n",
        "        always(arrow.next_to, histogram.bars[10], UP, SMALL_BUFF)\n",
        "        for s in [0.8, 1]:\n",
        "            self.play(\n",
        "                s_tracker.set_value, s,\n",
        "                UpdateFromFunc(decimals, update_decimals),\n",
        "                UpdateFromFunc(histogram, update_histogram),\n",
        "                UpdateFromFunc(value, lambda m: m),\n",
        "                run_time=5,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class StateNeedForBayesRule(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        axes = get_beta_dist_axes(y_max=1, y_unit=0.25, label_y=False)\n",
        "        axes.y_axis.set_height(\n",
        "            2,\n",
        "            about_point=axes.c2p(0, 0),\n",
        "            stretch=True,\n",
        "        )\n",
        "        axes.set_width(5)\n",
        "        graph = axes.get_graph(lambda x: x**10)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        alt_graph = graph.copy()\n",
        "        alt_graph.add_line_to(axes.c2p(1, 0))\n",
        "        alt_graph.add_line_to(axes.c2p(0, 0))\n",
        "        alt_graph.set_stroke(width=0)\n",
        "        alt_graph.set_fill(BLUE_E, 1)\n",
        "\n",
        "        plot = VGroup(axes, alt_graph, graph)\n",
        "\n",
        "        student0, student1, student2 = self.students\n",
        "        plot.next_to(student2.get_corner(UL), UP, MED_LARGE_BUFF)\n",
        "        plot.shift(LEFT)\n",
        "\n",
        "        v_lines = VGroup(\n",
        "            DashedLine(axes.c2p(0.8, 0), axes.c2p(0.8, 1)),\n",
        "            DashedLine(axes.c2p(1, 0), axes.c2p(1, 1)),\n",
        "        )\n",
        "        v_lines.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                ApplyMethod(student0.change, \"pondering\", plot),\n",
        "                ApplyMethod(student1.change, \"pondering\", plot),\n",
        "                ApplyMethod(student2.change, \"raise_left_hand\", plot),\n",
        "            ),\n",
        "            FadeIn(plot, DOWN),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.play(*map(ShowCreation, v_lines))\n",
        "        self.play(\n",
        "            self.teacher.change, \"tease\",\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    v_line.move_to,\n",
        "                    axes.c2p(0.9, 0),\n",
        "                    DOWN,\n",
        "                )\n",
        "                for v_line in v_lines\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"thinking\", \"thinking\", \"pondering\",\n",
        "            look_at=v_lines,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"But first...\",\n",
        "            added_anims=[\n",
        "                FadeOut(plot, LEFT),\n",
        "                FadeOut(v_lines, LEFT),\n",
        "                self.change_students(\n",
        "                    \"erm\", \"erm\", \"erm\",\n",
        "                    look_at=self.teacher.eyes,\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class Part1EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adam D\u0159\u00ednek\",\n",
        "            \"Aidan Shenkman\",\n",
        "            \"Alan Stein\",\n",
        "            \"Alex Mijalis\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Andrew Cary\",\n",
        "            \"Andrew R. Whalley\",\n",
        "            \"Aravind C V\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Ashwin Siddarth\",\n",
        "            \"Austin Goodman\",\n",
        "            \"Avi Finkel\",\n",
        "            \"Awoo\",\n",
        "            \"Axel Ericsson\",\n",
        "            \"Ayan Doss\",\n",
        "            \"AZsorcerer\",\n",
        "            \"Barry Fam\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Bradley Pirtle\",\n",
        "            \"Brandon Huang\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Britton Finley\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Calvin Lin\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Charlie N\",\n",
        "            \"Chenna Kautilya\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"cinterloper\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Colwyn Fritze-Moor\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Corey Ogburn\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Dan Herbatschek\",\n",
        "            \"Daniel Herrera C\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"dave nicponski\",\n",
        "            \"David B. Hill\",\n",
        "            \"David Clark\",\n",
        "            \"David Gow\",\n",
        "            \"Delton Ding\",\n",
        "            \"Dominik Wagner\",\n",
        "            \"Douglas Cantrell\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Farzaneh Sarafraz\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Frank R. Brown, Jr.\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"Ivan Sorokin\",\n",
        "            \"Jacob Baxter\",\n",
        "            \"Jacob Harmon\",\n",
        "            \"Jacob Hartmann\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jake Vartuli - Schonberg\",\n",
        "            \"Jalex Stark\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jayne Gabriele\",\n",
        "            \"Jean-Manuel Izaret\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Jimmy Yang\",\n",
        "            \"John C. Vesey\",\n",
        "            \"John Haley\",\n",
        "            \"John Le\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Heckerman\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Josh Kinnear\",\n",
        "            \"Joshua Claeys\",\n",
        "            \"Juan Benet\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Karl Niu\",\n",
        "            \"Kartik Cating-Subramanian\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Killian McGuinness\",\n",
        "            \"Kros Dai\",\n",
        "            \"L0j1k\",\n",
        "            \"LAI Oscar\",\n",
        "            \"Lambda GPU Workstations\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Manoj Rewatkar - RITEK SOLUTIONS\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Mark Heising\",\n",
        "            \"Mark Mann\",\n",
        "            \"Martin Price\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Godbolt\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matt Russell\",\n",
        "            \"Matteo Delabre\",\n",
        "            \"Matthew Bouchard\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Mia Parent\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Michael W White\",\n",
        "            \"Mirik Gogri\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nicholas Cahill\",\n",
        "            \"Nikita Lesnikov\",\n",
        "            \"Oleg Leonov\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Patrick Lucas\",\n",
        "            \"Pavel Dubov\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Pierre Lancien\",\n",
        "            \"Quantopian\",\n",
        "            \"Randy C. Will\",\n",
        "            \"rehmi post\",\n",
        "            \"Rex Godby\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Roman Sergeychik\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Samuel Judge\",\n",
        "            \"SansWord Huang\",\n",
        "            \"Scott Gray\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"soekul\",\n",
        "            \"Solara570\",\n",
        "            \"Steve Huynh\",\n",
        "            \"Steve Sperandeo\",\n",
        "            \"Steven Braun\",\n",
        "            \"Steven Siddals\",\n",
        "            \"Stevie Metke\",\n",
        "            \"supershabam\",\n",
        "            \"Suteerth Vishnu\",\n",
        "            \"Suthen Thomas\",\n",
        "            \"Tal Einav\",\n",
        "            \"Taras Bobrovytsky\",\n",
        "            \"Tauba Auerbach\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Thomas J Sargent\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Tihan Seale\",\n",
        "            \"Tyler VanValkenburg\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Veritasium\",\n",
        "            \"Vignesh Ganapathi Subramanian\",\n",
        "            \"Vinicius Reis\",\n",
        "            \"Xuanji Li\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yavor Ivanov\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Yu Jun\",\n",
        "            \"Yurii Monastyrshyn\",\n",
        "        ],\n",
        "    }\n"
    ]
}