{
    "topic": "demonstrates the concept of factoring a polynomial with given roots.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.quintic.roots_and_coefs import *\n",
        "\n",
        "# Introduction\n",
        "\n",
        "\n",
        "class IntroduceUnsolvability(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class TableOfContents(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "# Preliminaries on polynomials\n",
        "\n",
        "\n",
        "class ConstructPolynomialWithGivenRoots(Scene):\n",
        "    root_color = YELLOW\n",
        "\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        axes = self.add_axes()\n",
        "\n",
        "        # Add challenge\n",
        "        challenge = VGroup(\n",
        "            Text(\"Can you construct a cubic polynomial\"),\n",
        "            OldTex(\n",
        "                \"P(x) = x^3 + c_2 x^2 + c_1 x + c_0\",\n",
        "                tex_to_color_map={\n",
        "                    \"c_2\": RED_B,\n",
        "                    \"c_1\": RED_B,\n",
        "                    \"c_0\": RED_B,\n",
        "                }\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"with roots at $x = 1$, $x = 2$, and $x = 4$?\",\n",
        "                tex_to_color_map={\n",
        "                    \"$x = 1$\": self.root_color,\n",
        "                    \"$x = 2$\": self.root_color,\n",
        "                    \"$x = 4$\": self.root_color,\n",
        "                }\n",
        "            )\n",
        "        )\n",
        "        challenge.scale(0.7)\n",
        "        challenge.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        challenge.to_corner(UL)\n",
        "\n",
        "        self.add(challenge)\n",
        "\n",
        "        # Add graph\n",
        "        roots = [1, 2, 4]\n",
        "        coefs = roots_to_coefficients(roots)\n",
        "        graph = axes.get_graph(lambda x: poly(x, coefs))\n",
        "        graph.set_color(BLUE)\n",
        "\n",
        "        root_dots = Group(*(GlowDot(axes.c2p(x, 0)) for x in roots))\n",
        "        root_dots.set_color(self.root_color)\n",
        "\n",
        "        x_terms = challenge[2].get_parts_by_tex(\"x = \")\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(x_term.copy(), dot)\n",
        "                for x_term, dot in zip(x_terms, root_dots)\n",
        "            ), lag_ratio=0.7, run_time=3)\n",
        "        )\n",
        "        self.add(graph, root_dots)\n",
        "        self.play(ShowCreation(graph, run_time=3, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "        # Show factored solution\n",
        "        factored = factored_poly_tex(roots)\n",
        "        factored.match_height(challenge[1])\n",
        "        factored.next_to(challenge, DOWN, LARGE_BUFF)\n",
        "\n",
        "        rects = VGroup(*(\n",
        "            SurroundingRectangle(\n",
        "                factored[i:i + 5],\n",
        "                stroke_width=1,\n",
        "                stroke_color=BLUE,\n",
        "                buff=0.05\n",
        "            )\n",
        "            for i in range(1, 12, 5)\n",
        "        ))\n",
        "        arrows = VGroup(*(\n",
        "            Vector(DOWN).next_to(dot, UP, buff=0)\n",
        "            for dot in root_dots\n",
        "        ))\n",
        "        zeros_eqs = VGroup(*(\n",
        "            OldTex(\n",
        "                f\"P({r}) = 0\",\n",
        "                font_size=24\n",
        "            ).next_to(rect, UP, SMALL_BUFF)\n",
        "            for r, rect in zip(roots, rects)\n",
        "        ))\n",
        "\n",
        "        self.play(FadeIn(factored, DOWN))\n",
        "        self.wait()\n",
        "        to_fade = VGroup()\n",
        "        for rect, arrow, eq in zip(rects, arrows, zeros_eqs):\n",
        "            self.play(\n",
        "                ShowCreation(rect),\n",
        "                FadeIn(eq),\n",
        "                ShowCreation(arrow),\n",
        "                FadeOut(to_fade)\n",
        "            )\n",
        "            self.wait(2)\n",
        "            to_fade = VGroup(rect, arrow, eq)\n",
        "        self.play(FadeOut(to_fade))\n",
        "\n",
        "        # Expand solution\n",
        "        x_terms = factored[2::5]\n",
        "        root_terms = VGroup(*(\n",
        "            VGroup(m1, m2)\n",
        "            for m1, m2 in zip(factored[3::5], factored[4::5])\n",
        "        ))\n",
        "\n",
        "        expanded = OldTex(\n",
        "            \"&x^3 \",\n",
        "            \"-1x^2\", \"-2x^2\", \"-4x^2 \\\\\\\\\",\n",
        "            \"&+(-1)(-2)x\", \"+(-1)(-4)x\", \"+(-2)(-4)x\\\\\\\\\",\n",
        "            \"&+(-1)(-2)(-4)\",\n",
        "        )\n",
        "        for i, part in enumerate(expanded):\n",
        "            if i in [1, 2, 3]:\n",
        "                part[:2].set_color(self.root_color)\n",
        "            elif i in [4, 5, 6, 7]:\n",
        "                part[2:4].set_color(self.root_color)\n",
        "                part[6:8].set_color(self.root_color)\n",
        "            if i == 7:\n",
        "                part[10:12].set_color(self.root_color)\n",
        "\n",
        "        expanded.scale(0.7)\n",
        "        expanded.next_to(factored[1], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        equals = factored[0][-1].copy()\n",
        "        equals.match_y(expanded[0][0])\n",
        "\n",
        "        self.add(equals)\n",
        "        expanded_iter = iter(expanded)\n",
        "        for k in range(4):\n",
        "            for tup in it.combinations(range(3), k):\n",
        "                factored[1:].set_opacity(0.5)\n",
        "                rects = VGroup()\n",
        "                for i in range(3):\n",
        "                    mob = root_terms[i] if (i in tup) else x_terms[i]\n",
        "                    mob.set_opacity(1)\n",
        "                    rect = SurroundingRectangle(mob, buff=SMALL_BUFF)\n",
        "                    rect.set_min_height(0.45, about_edge=DOWN)\n",
        "                    rects.add(rect)\n",
        "                rects.set_stroke(BLUE, 2)\n",
        "                expanded_term = next(expanded_iter)\n",
        "                expanded_rect = SurroundingRectangle(\n",
        "                    expanded_term, buff=SMALL_BUFF\n",
        "                )\n",
        "                expanded_rect.match_style(rects)\n",
        "\n",
        "                self.add(rects, expanded_rect)\n",
        "                self.add(expanded_term)\n",
        "                self.wait()\n",
        "                self.remove(rects, expanded_rect)\n",
        "        factored.set_opacity(1)\n",
        "        self.add(expanded)\n",
        "        self.wait()\n",
        "\n",
        "        # Cleaner expansion\n",
        "        cleaner_expanded = expanded_poly_tex(roots, vertical=False)\n",
        "        cleaner_expanded.scale(0.7)\n",
        "        cleaner_expanded.shift(expanded[0][0].get_center() - cleaner_expanded[0][0][0].get_center())\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(expanded[0], cleaner_expanded[0]),\n",
        "            TransformMatchingShapes(\n",
        "                expanded[1:4],\n",
        "                cleaner_expanded[1],\n",
        "            ),\n",
        "            expanded[4:].animate.next_to(cleaner_expanded[1], DOWN, aligned_edge=LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                expanded[4:7],\n",
        "                cleaner_expanded[2],\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                expanded[7],\n",
        "                cleaner_expanded[3],\n",
        "            )\n",
        "        )\n",
        "        back_rect = BackgroundRectangle(cleaner_expanded, buff=SMALL_BUFF)\n",
        "        self.add(back_rect, cleaner_expanded)\n",
        "        self.play(FadeIn(back_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Evaluate\n",
        "        answer = OldTex(\n",
        "            \"= x^3 -7x^2 + 14x -8\",\n",
        "            tex_to_color_map={\n",
        "                \"-7\": RED_B,\n",
        "                \"14\": RED_B,\n",
        "                \"-8\": RED_B,\n",
        "            }\n",
        "        )\n",
        "        answer.scale(0.7)\n",
        "        answer.next_to(equals, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(FadeIn(answer, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Note the symmetry\n",
        "        randy = Randolph(height=1)\n",
        "        randy.to_corner(DL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        randy.change(\"tease\")\n",
        "        randy.save_state()\n",
        "        randy.change(\"plain\").set_opacity(0)\n",
        "\n",
        "        bubble = SpeechBubble(width=3, height=1, stroke_width=2)\n",
        "        bubble.move_to(randy.get_corner(UR), LEFT)\n",
        "        bubble.shift(0.45 * UP + 0.1 * LEFT)\n",
        "        bubble.add_content(Text(\"Note the symmetry!\"))\n",
        "\n",
        "        self.play(Restore(randy))\n",
        "        self.play(ShowCreation(bubble), Write(bubble.content))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        factored.save_state()\n",
        "        cleaner_expanded.save_state()\n",
        "        for alt_roots in [(2, 4, 1), (4, 2, 1), (1, 4, 2), (1, 2, 4)]:\n",
        "            alt_factored = factored_poly_tex(alt_roots)\n",
        "            alt_factored.replace(factored)\n",
        "            alt_expanded = expanded_poly_tex(alt_roots, vertical=False)\n",
        "            alt_expanded.replace(cleaner_expanded)\n",
        "            movers, targets = [\n",
        "                VGroup(*(\n",
        "                    group.get_parts_by_tex(str(root))\n",
        "                    for root in alt_roots\n",
        "                    for group in groups\n",
        "                ))\n",
        "                for groups in [(factored, *cleaner_expanded), (alt_factored, *alt_expanded)]\n",
        "            ]\n",
        "\n",
        "            self.play(\n",
        "                TransformMatchingShapes(movers, targets, path_arc=PI / 2, run_time=1.5),\n",
        "                randy.animate.look_at(movers),\n",
        "            )\n",
        "            self.remove(targets, factored, cleaner_expanded)\n",
        "            factored.become(alt_factored)\n",
        "            cleaner_expanded.become(alt_expanded)\n",
        "            self.add(factored, cleaner_expanded)\n",
        "            self.wait()\n",
        "        factored.restore()\n",
        "        cleaner_expanded.restore()\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "        )\n",
        "\n",
        "        # Reverse question\n",
        "        top_lhs = OldTex(\"P(x)\").match_height(factored)\n",
        "        top_lhs.next_to(answer, LEFT).align_to(factored, LEFT)\n",
        "        top_lhs.set_opacity(0)\n",
        "        coef_poly = VGroup(top_lhs, answer)\n",
        "        coef_poly.generate_target()\n",
        "        coef_poly.target.set_opacity(1).to_edge(UP)\n",
        "\n",
        "        full_factored = VGroup(back_rect, factored, equals, cleaner_expanded)\n",
        "        full_factored.generate_target()\n",
        "        full_factored.target.next_to(coef_poly.target, DOWN, buff=0.75, aligned_edge=LEFT)\n",
        "        full_factored.target.set_opacity(0.5)\n",
        "\n",
        "        self.add(full_factored, coef_poly)\n",
        "        self.play(\n",
        "            FadeOut(challenge, UP),\n",
        "            MoveToTarget(full_factored),\n",
        "            MoveToTarget(coef_poly),\n",
        "        )\n",
        "\n",
        "        new_challenge = Text(\"Find the roots!\")\n",
        "        new_challenge.add_background_rectangle(buff=0.1)\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(coef_poly, RIGHT)\n",
        "        new_challenge.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(new_challenge, 0.5 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show general expansion\n",
        "        rs = [f\"r_{i}\" for i in range(3)]\n",
        "        gen_factored = factored_poly_tex(rs, root_colors=[YELLOW, GREEN])\n",
        "        gen_expanded = expanded_poly_tex(rs, vertical=False, root_colors=[YELLOW, GREEN])\n",
        "        for gen, old in (gen_factored, factored), (gen_expanded, cleaner_expanded):\n",
        "            gen.match_height(old)\n",
        "            gen.move_to(old, LEFT)\n",
        "\n",
        "        self.play(FadeTransformPieces(factored, gen_factored))\n",
        "        self.wait()\n",
        "        for i in range(1, 4):\n",
        "            self.play(\n",
        "                cleaner_expanded[0].animate.set_opacity(1),\n",
        "                equals.animate.set_opacity(1),\n",
        "                FadeTransformPieces(cleaner_expanded[i], gen_expanded[i]),\n",
        "                cleaner_expanded[i + 1:].animate.next_to(gen_expanded[i], RIGHT, SMALL_BUFF)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.remove(cleaner_expanded)\n",
        "        self.add(gen_expanded)\n",
        "\n",
        "        full_factored = VGroup(back_rect, gen_factored, equals, gen_expanded)\n",
        "\n",
        "        # Show system of equations\n",
        "        system = get_symmetric_system([7, 14, 8], root_colors=[YELLOW, GREEN])\n",
        "        system.next_to(full_factored, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        coef_terms = answer[1::2]\n",
        "        rhss = [term[2:-2] for term in gen_expanded[1:]]\n",
        "\n",
        "        for coef, rhs, eq in zip(coef_terms, rhss, system):\n",
        "            self.play(\n",
        "                FadeTransform(coef.copy(), eq[0]),\n",
        "                FadeIn(eq[1]),\n",
        "                FadeTransform(rhs.copy(), eq[2:]),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        cubic_example = VGroup(coef_poly, full_factored, system)\n",
        "\n",
        "        # Show quintic\n",
        "        q_roots = [-1, 1, 2, 4, 6]\n",
        "        q_coefs = roots_to_coefficients(q_roots)\n",
        "        q_poly = poly_tex(q_coefs)\n",
        "        q_poly_factored = factored_poly_tex(\n",
        "            [f\"r_{i}\" for i in range(5)],\n",
        "            root_colors=[YELLOW, GREEN]\n",
        "        )\n",
        "        VGroup(q_poly, q_poly_factored).scale(0.8)\n",
        "        q_poly.to_corner(UL)\n",
        "        q_poly_factored.next_to(q_poly, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(cubic_example, DOWN),\n",
        "            FadeOut(VGroup(arrow, new_challenge), DOWN),\n",
        "            FadeIn(q_poly, DOWN)\n",
        "        )\n",
        "\n",
        "        y_scale_factor = 0.1\n",
        "        new_graph = axes.get_graph(\n",
        "            lambda x: y_scale_factor * poly(x, q_coefs),\n",
        "            x_range=(-1.2, 6.2)\n",
        "        )\n",
        "        new_root_dots = Group(*(\n",
        "            GlowDot(axes.c2p(x, 0))\n",
        "            for x in q_roots\n",
        "        ))\n",
        "        new_graph.match_style(graph)\n",
        "        axes.save_state()\n",
        "        graph.save_state()\n",
        "        root_dots.save_state()\n",
        "        self.play(\n",
        "            Transform(graph, new_graph),\n",
        "            Transform(root_dots, new_root_dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        root_terms = q_poly_factored.get_parts_by_tex(\"r_\")\n",
        "        self.play(\n",
        "            FadeIn(q_poly_factored, lag_ratio=0.1, run_time=2),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(dot.copy(), term, remover=True)\n",
        "                for dot, term in zip(root_dots, root_terms)\n",
        "            ), lag_ratio=0.5, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Quintic system\n",
        "        signed_coefs = [\n",
        "            (-1)**k * c for\n",
        "            k, c in zip(it.count(1), q_coefs[-2::-1])\n",
        "        ]\n",
        "        q_system, q_system_full = [\n",
        "            get_symmetric_system(\n",
        "                signed_coefs,\n",
        "                abbreviate=abbrev,\n",
        "                root_colors=[YELLOW, GREEN],\n",
        "            )\n",
        "            for abbrev in [True, False]\n",
        "        ]\n",
        "        for mob in q_system, q_system_full:\n",
        "            mob.scale(0.8)\n",
        "            mob.next_to(q_poly_factored, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        root_tuple_groups = VGroup(*(\n",
        "            VGroup(*(\n",
        "                VGroup(*tup)\n",
        "                for tup in it.combinations(root_terms, k)\n",
        "            ))\n",
        "            for k in range(1, 6)\n",
        "        ))\n",
        "\n",
        "        for equation, tuple_group in zip(q_system, root_tuple_groups):\n",
        "            self.play(FadeIn(equation))\n",
        "            self.wait(0.25)\n",
        "\n",
        "            rects_group = VGroup(*(\n",
        "                VGroup(*(\n",
        "                    SurroundingRectangle(term).set_stroke(BLUE, 2)\n",
        "                    for term in tup\n",
        "                ))\n",
        "                for tup in tuple_group\n",
        "            ))\n",
        "            terms_column = VGroup(*(\n",
        "                VGroup(*tup).copy().arrange(RIGHT, buff=SMALL_BUFF)\n",
        "                for tup in tuple_group\n",
        "            ))\n",
        "            terms_column.arrange(DOWN)\n",
        "            terms_column.move_to(4 * RIGHT).to_edge(UP)\n",
        "\n",
        "            anims = [\n",
        "                ShowSubmobjectsOneByOne(rects_group, rate_func=linear),\n",
        "                ShowIncreasingSubsets(terms_column, rate_func=linear, int_func=np.ceil),\n",
        "            ]\n",
        "            if equation is q_system[1]:\n",
        "                anims.append(\n",
        "                    Group(axes, graph, root_dots).animate.scale(\n",
        "                        0.5, about_point=axes.c2p(5, -3)\n",
        "                    )\n",
        "                )\n",
        "            self.play(*anims, run_time=0.25 * len(terms_column))\n",
        "            self.remove(rects_group)\n",
        "            self.wait()\n",
        "            self.play(FadeOut(terms_column))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        self.play(\n",
        "            frame.animate.replace(q_system_full, dim_to_match=0).scale(1.1),\n",
        "            FadeIn(q_system_full, lag_ratio=0.1),\n",
        "            FadeOut(q_system),\n",
        "            Group(axes, graph, root_dots).animate.shift(2 * DOWN),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Back to cubic\n",
        "        self.play(\n",
        "            Restore(axes),\n",
        "            Restore(graph),\n",
        "            Restore(root_dots),\n",
        "            FadeOut(q_system_full, 2 * DOWN),\n",
        "            FadeOut(q_poly, 2 * DOWN),\n",
        "            FadeOut(q_poly_factored, 2 * DOWN),\n",
        "            FadeIn(cubic_example, 2 * DOWN),\n",
        "            Restore(frame),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Can you always factor?\n",
        "        question = Text(\"Is this always possible?\")\n",
        "        question.add_background_rectangle(buff=0.1)\n",
        "        question.next_to(gen_factored, RIGHT, buff=2)\n",
        "        question.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        arrow = Arrow(question.get_left(), gen_factored.get_corner(UR))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question),\n",
        "            ShowCreation(arrow),\n",
        "            FlashAround(gen_factored, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(question), FadeOut(arrow))\n",
        "\n",
        "        const_dec = DecimalNumber(8)\n",
        "        top_const_dec = const_dec.copy()\n",
        "        for dec, mob, vect in (const_dec, system[2][0], RIGHT), (top_const_dec, answer[-1][1], LEFT):\n",
        "            dec.match_height(mob)\n",
        "            dec.move_to(mob, vect)\n",
        "            dec.set_color(RED)\n",
        "            mob.set_opacity(0)\n",
        "            self.add(dec)\n",
        "        answer[-1][0].set_color(RED)\n",
        "\n",
        "        top_const_dec.add_updater(lambda m: m.set_value(const_dec.get_value()))\n",
        "\n",
        "        def get_coefs():\n",
        "            return [-const_dec.get_value(), 14, -7, 1]\n",
        "\n",
        "        def get_roots():\n",
        "            return coefficients_to_roots(get_coefs())\n",
        "\n",
        "        def update_graph(graph):\n",
        "            graph.become(axes.get_graph(lambda x: poly(x, get_coefs())))\n",
        "            graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        def update_root_dots(dots):\n",
        "            roots = get_roots()\n",
        "            for root, dot in zip(roots, dots):\n",
        "                if abs(root.imag) > 1e-8:\n",
        "                    dot.set_opacity(0)\n",
        "                else:\n",
        "                    dot.move_to(axes.c2p(root.real, 0))\n",
        "                    dot.set_opacity(1)\n",
        "\n",
        "        graph.add_updater(update_graph)\n",
        "        self.remove(*root_dots, *new_root_dots)\n",
        "        root_dots = root_dots[:3]\n",
        "        root_dots.add_updater(update_root_dots)\n",
        "        self.add(root_dots)\n",
        "\n",
        "        example_constants = [5, 6, 9, 6.28]\n",
        "        for const in example_constants:\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(const_dec, const),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show complex plane\n",
        "        plane = ComplexPlane(\n",
        "            (-1, 6), (-3, 3)\n",
        "        )\n",
        "        plane.replace(axes.x_axis.ticks, dim_to_match=0)\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        plane.save_state()\n",
        "        plane.rotate(PI / 2, LEFT)\n",
        "        plane.set_opacity(0)\n",
        "\n",
        "        real_label = Text(\"Real numbers\")\n",
        "        real_label.next_to(root_dots, UP, SMALL_BUFF)\n",
        "        complex_label = Text(\"Complex numbers\")\n",
        "        complex_label.set_backstroke()\n",
        "        complex_label.next_to(plane.saved_state.get_corner(UR), DL, SMALL_BUFF)\n",
        "\n",
        "        graph.clear_updaters()\n",
        "        root_dots.clear_updaters()\n",
        "        axes.generate_target(use_deepcopy=True)\n",
        "        axes.target.y_axis.set_opacity(0)\n",
        "        axes.target.x_axis.numbers.set_opacity(1)\n",
        "        self.play(\n",
        "            Uncreate(graph),\n",
        "            Write(real_label),\n",
        "            MoveToTarget(axes),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.add(plane, root_dots, real_label)\n",
        "        self.play(\n",
        "            Restore(plane),\n",
        "            FadeOut(axes.x_axis),\n",
        "            FadeTransform(real_label, complex_label),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            VGroup(coef_poly, top_const_dec).animate.next_to(plane, UP),\n",
        "            gen_factored.animate.next_to(plane, UP, buff=1.2),\n",
        "            FadeOut(equals),\n",
        "            FadeOut(gen_expanded),\n",
        "            frame.animate.shift(DOWN),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        eq_zero = OldTex(\"= 0\")\n",
        "        eq_zero.scale(0.7)\n",
        "        eq_zero.next_to(top_const_dec, RIGHT, SMALL_BUFF)\n",
        "        eq_zero.shift(0.2 * LEFT)\n",
        "        self.play(\n",
        "            Write(eq_zero),\n",
        "            VGroup(coef_poly, top_const_dec).animate.shift(0.2 * LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show constant tweaking again\n",
        "        def update_complex_roots(root_dots):\n",
        "            for root, dot in zip(get_roots(), root_dots):\n",
        "                dot.move_to(plane.n2p(root))\n",
        "\n",
        "        root_dots.add_updater(update_complex_roots)\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(const_dec),\n",
        "            FlashAround(top_const_dec),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(const_dec, 4),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        root_eqs = VGroup(*(\n",
        "            VGroup(OldTex(f\"r_{i} \", \"=\"), DecimalNumber(root, num_decimal_places=3)).arrange(RIGHT)\n",
        "            for i, root in enumerate(get_roots())\n",
        "        ))\n",
        "        root_eqs.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        for eq in root_eqs:\n",
        "            eq[0][0].set_color(YELLOW)\n",
        "        root_eqs.next_to(system, UP)\n",
        "        root_eqs.align_to(gen_factored, UP)\n",
        "        self.play(\n",
        "            FadeIn(root_eqs),\n",
        "            VGroup(system, const_dec).animate.next_to(root_eqs, DOWN, LARGE_BUFF),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(root_eqs))\n",
        "\n",
        "        example_constants = [4, 7, 9, 5]\n",
        "        for const in example_constants:\n",
        "            self.play(\n",
        "                ChangeDecimalToValue(const_dec, const),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def add_axes(self):\n",
        "        x_range = (-1, 6)\n",
        "        y_range = (-3, 11)\n",
        "        axes = Axes(\n",
        "            x_range, y_range,\n",
        "            axis_config=dict(include_tip=False, numbers_to_exclude=[]),\n",
        "            widith=abs(op.sub(*x_range)),\n",
        "            height=abs(op.sub(*y_range)),\n",
        "        )\n",
        "        axes.set_height(FRAME_HEIGHT - 1)\n",
        "        axes.to_edge(RIGHT)\n",
        "        axes.x_axis.add_numbers(font_size=24)\n",
        "        axes.x_axis.numbers[1].set_opacity(0)\n",
        "\n",
        "        self.add(axes)\n",
        "        return axes\n",
        "\n",
        "\n",
        "class FactsAboutRootsToCoefficients(RootCoefScene):\n",
        "    coefs = [-5, 14, -7, 1]\n",
        "    coef_plane_config = {\n",
        "        \"x_range\": (-15.0, 15.0, 5.0),\n",
        "        \"y_range\": (-10, 10, 5),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"height\": 20,\n",
        "        \"width\": 30,\n",
        "    }\n",
        "    root_plane_config = {\n",
        "        \"x_range\": (-1.0, 6.0),\n",
        "        \"y_range\": (-3.0, 3.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    plane_height = 3.5\n",
        "    planes_center = 1.5 * DOWN\n",
        "\n",
        "    def construct(self):\n",
        "        # Play with coefficients, confined to real axis\n",
        "        self.wait()\n",
        "        self.add_constant_decimals()\n",
        "        self.add_graph()\n",
        "        self.lock_coef_imag = True\n",
        "        self.wait(note=\"Move around c0\")\n",
        "        self.lock_coef_imag = False\n",
        "\n",
        "        self.decimal_poly.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(self.decimal_poly, DOWN),\n",
        "            FadeOut(self.graph_group, DOWN),\n",
        "        )\n",
        "\n",
        "        # Show the goal\n",
        "        self.add_system()\n",
        "        self.add_solver_functions()\n",
        "\n",
        "        # Why that's really weird\n",
        "        self.play(\n",
        "            self.coef_system.animate.set_opacity(0.2),\n",
        "            self.root_system[1:].animate.set_opacity(0.2),\n",
        "        )\n",
        "        self.wait(note=\"Show loops with c0\")\n",
        "\n",
        "        # Why something like this must be possible\n",
        "        brace = Brace(self.coef_system, RIGHT)\n",
        "        properties = VGroup(\n",
        "            Text(\"Continuous\"),\n",
        "            Text(\"Symmetric\"),\n",
        "        )\n",
        "        properties.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        properties.next_to(brace, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            self.root_system.animate.set_opacity(0),\n",
        "            self.coef_system.animate.set_opacity(1),\n",
        "        )\n",
        "        self.wait()\n",
        "        for words in properties:\n",
        "            self.play(Write(words, run_time=1))\n",
        "            self.wait()\n",
        "\n",
        "        self.swap_root_symbols()\n",
        "        self.wait(note=\"Physically swap roots\")\n",
        "\n",
        "        # What this implies about our functions\n",
        "        brace.generate_target()\n",
        "        brace.target.rotate(PI)\n",
        "        brace.target.next_to(self.root_system, LEFT)\n",
        "        left_group = VGroup(properties, self.coef_system)\n",
        "        left_group.generate_target()\n",
        "        left_group.target.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        left_group.target.set_height(1)\n",
        "        left_group.target.to_corner(UL)\n",
        "        left_group.target.set_opacity(0.5)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(brace, path_arc=PI / 2),\n",
        "            MoveToTarget(left_group),\n",
        "            self.root_system.animate.set_opacity(1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        restriction = VGroup(\n",
        "            Text(\"Cannot(!) be both\"),\n",
        "            Text(\"Continuous and single-valued\", t2c={\n",
        "                \"Continuous\": YELLOW,\n",
        "                \"single-valued\": BLUE,\n",
        "            })\n",
        "        )\n",
        "        restriction.scale(0.8)\n",
        "        restriction.arrange(DOWN)\n",
        "        restriction.next_to(brace, LEFT)\n",
        "\n",
        "        self.play(FadeIn(restriction))\n",
        "        self.wait(note=\"Move c0, emphasize multiplicity of outputs\")\n",
        "\n",
        "        # Impossibility result\n",
        "        words = Text(\"Cannot be built from \")\n",
        "        symbols = OldTex(\n",
        "            \"+,\\\\,\", \"-,\\\\,\", \"\\\\times,\\\\,\", \"/,\\\\,\", \"\\\\text{exp}\\\\\\\\\",\n",
        "            \"\\\\sin,\\\\,\", \"\\\\cos,\\\\,\", \"| \\\\cdot |,\\\\,\", \"\\\\dots\",\n",
        "        )\n",
        "        impossibility = VGroup(words, symbols)\n",
        "        impossibility.arrange(RIGHT)\n",
        "        impossibility.match_width(restriction)\n",
        "        impossibility.next_to(restriction, DOWN, aligned_edge=RIGHT)\n",
        "        impossible_rect = SurroundingRectangle(impossibility)\n",
        "        impossible_rect.set_stroke(RED, 2)\n",
        "\n",
        "        arrow = OldTex(\"\\\\Downarrow\", font_size=36)\n",
        "        arrow.next_to(impossible_rect, UP, SMALL_BUFF)\n",
        "        restriction.generate_target()\n",
        "        restriction.target.scale(1.0).next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(impossibility[0]),\n",
        "            FadeIn(arrow),\n",
        "            ShowCreation(impossible_rect),\n",
        "            MoveToTarget(restriction),\n",
        "        )\n",
        "        for symbol in symbols:\n",
        "            self.wait(0.25)\n",
        "            self.add(symbol)\n",
        "        self.wait()\n",
        "\n",
        "        # Show discontinuous example\n",
        "        to_fade = VGroup(\n",
        "            restriction[0],\n",
        "            restriction[1].get_part_by_text(\"Continuous and\"),\n",
        "            arrow,\n",
        "            impossibility,\n",
        "            impossible_rect,\n",
        "        )\n",
        "        to_fade.save_state()\n",
        "        self.play(*(m.animate.fade(0.8) for m in to_fade))\n",
        "\n",
        "        root_tracers = VGroup(*(d.tracer for d in self.root_dots))\n",
        "        self.remove(root_tracers)\n",
        "        self.continuous_roots = False\n",
        "        self.root_dots[0].set_fill(BLUE)\n",
        "        self.r_dot_labels[0].set_fill(BLUE)\n",
        "        self.root_dots[1].set_fill(GREEN)\n",
        "        self.r_dot_labels[1].set_fill(GREEN)\n",
        "        self.wait(note=\"Show discontinuous behavior\")\n",
        "        self.add(self.get_tracers(self.root_dots))\n",
        "        self.wait(note=\"Turn tracers back on\")\n",
        "        self.continuous_roots = True\n",
        "\n",
        "        # Represent as a multivalued function\n",
        "        f_name = \"\\\\text{cubic\\\\_solve}\"\n",
        "        t2c = dict([\n",
        "            (f\"{sym}_{i}\", color)\n",
        "            for i in range(3)\n",
        "            for sym, color in [\n",
        "                (\"r\", self.root_color),\n",
        "                (\"c\", self.coef_color),\n",
        "            ]\n",
        "        ])\n",
        "        t2c[f_name] = GREY_A\n",
        "        mvf = OldTex(\n",
        "            f\"{f_name}(c_0, c_1, c_2)\\\\\\\\\", \"=\\\\\\\\\", \"\\\\left\\\\{r_0, r_1, r_2\\\\right\\\\}\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        mvf.get_part_by_tex(\"=\").rotate(PI / 2).match_x(mvf.slice_by_tex(None, \"=\"))\n",
        "        mvf.slice_by_tex(\"left\").match_x(mvf.get_part_by_tex(\"=\"))\n",
        "        mvf.move_to(self.root_system, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(self.root_system, mvf),\n",
        "            restriction[1].get_part_by_text(\"single-valued\").animate.fade(0.8),\n",
        "        )\n",
        "        self.wait(note=\"Labeling is an artifact\")\n",
        "        self.play(FadeOut(self.r_dot_labels))\n",
        "        self.wait()\n",
        "\n",
        "    def add_c_labels(self):\n",
        "        super().add_c_labels()\n",
        "        self.c_dot_labels[2].clear_updaters()\n",
        "        self.c_dot_labels[2].add_updater(\n",
        "            lambda l: l.next_to(l.dot, DL, buff=0)\n",
        "        )\n",
        "        return self.c_dot_labels\n",
        "\n",
        "    def add_constant_decimals(self):\n",
        "        dummy = \"+10.00\"\n",
        "        polynomial = OldTex(\n",
        "            f\"x^3 {dummy}x^2 {dummy}x {dummy}\",\n",
        "            isolate=[dummy],\n",
        "            font_size=40,\n",
        "        )\n",
        "        polynomial.next_to(self.coef_poly, UP, LARGE_BUFF)\n",
        "        decimals = DecimalNumber(100, include_sign=True, edge_to_fix=LEFT).replicate(3)\n",
        "        for dec, part in zip(decimals, polynomial.get_parts_by_tex(dummy)):\n",
        "            dec.match_height(part)\n",
        "            dec.move_to(part, LEFT)\n",
        "            part.set_opacity(0)\n",
        "            polynomial.add(dec)\n",
        "        polynomial.decimals = decimals\n",
        "\n",
        "        def update_poly(polynomial):\n",
        "            for dec, coef in zip(polynomial.decimals, self.get_coefs()[-2::-1]):\n",
        "                dec.set_value(coef.real)\n",
        "            polynomial.decimals.set_fill(RED, 1)\n",
        "            return polynomial\n",
        "\n",
        "        update_poly(polynomial)\n",
        "        VGroup(polynomial[0], decimals[0]).next_to(\n",
        "            polynomial[2], LEFT, SMALL_BUFF, aligned_edge=DOWN\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(polynomial, UP, suspend_updating=True))\n",
        "        polynomial.add_updater(update_poly)\n",
        "        self.decimal_poly = polynomial\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.decimal_poly\n",
        "        axes = Axes(\n",
        "            (0, 6), (-4, 10),\n",
        "            axis_config=dict(tick_size=0.025),\n",
        "            width=3, height=2,\n",
        "        )\n",
        "        axes.set_height(2)\n",
        "        axes.move_to(self.root_plane)\n",
        "        axes.to_edge(UP, buff=SMALL_BUFF)\n",
        "\n",
        "        graph = always_redraw(\n",
        "            lambda: axes.get_graph(\n",
        "                lambda x: poly(x, self.get_coefs()).real\n",
        "            ).set_stroke(BLUE, 2)\n",
        "        )\n",
        "\n",
        "        root_dots = GlowDot()\n",
        "        root_dots.add_updater(lambda d: d.set_points([\n",
        "            axes.c2p(r.real, 0)\n",
        "            for r in self.get_roots()\n",
        "            if abs(r.imag) < 1e-5\n",
        "        ]))\n",
        "\n",
        "        arrow = Arrow(self.decimal_poly.get_right(), axes)\n",
        "\n",
        "        graph_group = Group(axes, graph, root_dots)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(graph_group, shift=UR),\n",
        "        )\n",
        "\n",
        "        graph_group.add(arrow)\n",
        "        self.graph_group = graph_group\n",
        "\n",
        "    def add_system(self):\n",
        "        c_parts = self.get_c_symbols(self.coef_poly)\n",
        "        system = get_symmetric_system(\n",
        "            (f\"c_{i}\" for i in reversed(range(len(self.coef_dots)))),\n",
        "            signed=True,\n",
        "        )\n",
        "        system.scale(0.8)\n",
        "        system.next_to(self.coef_poly, UP, LARGE_BUFF)\n",
        "        system.align_to(self.coef_plane, LEFT)\n",
        "\n",
        "        self.add(system)\n",
        "\n",
        "        kw = dict(lag_ratio=0.8, run_time=2.5)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(c, line[0])\n",
        "                for c, line in zip(c_parts, system)\n",
        "            ), **kw),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(line[1:], lag_ratio=0.1)\n",
        "                for line in system\n",
        "            ), **kw)\n",
        "        )\n",
        "        self.add(system)\n",
        "        self.coef_system = system\n",
        "        self.wait()\n",
        "\n",
        "    def add_solver_functions(self):\n",
        "        func_name = \"\\\\text{cubic\\\\_solve}\"\n",
        "        t2c = dict((\n",
        "            (f\"{sym}_{i}\", color)\n",
        "            for i in range(3)\n",
        "            for sym, color in [\n",
        "                (\"c\", self.coef_color),\n",
        "                (\"r\", self.root_color),\n",
        "                (func_name, GREY_A),\n",
        "            ]\n",
        "        ))\n",
        "        kw = dict(tex_to_color_map=t2c)\n",
        "        lines = VGroup(*(\n",
        "            OldTex(f\"r_{i} = {func_name}_{i}(c_0, c_1, c_2)\", **kw)\n",
        "            for i in range(3)\n",
        "        ))\n",
        "        lines.scale(0.8)\n",
        "        lines.arrange(DOWN, aligned_edge=LEFT)\n",
        "        lines.match_y(self.coef_system)\n",
        "        lines.align_to(self.root_plane, LEFT)\n",
        "\n",
        "        kw = dict(lag_ratio=0.7, run_time=2)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(r, line[0])\n",
        "                for r, line in zip(self.get_r_symbols(self.root_poly), lines)\n",
        "            ), **kw),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(line[1:], lag_ratio=0.1)\n",
        "                for line in lines\n",
        "            ), **kw),\n",
        "        )\n",
        "        self.add(lines)\n",
        "        self.root_system = lines\n",
        "        self.wait()\n",
        "\n",
        "    def swap_root_symbols(self):\n",
        "        system = self.coef_system\n",
        "        cs = [f\"c_{i}\" for i in reversed(range(len(self.coef_dots)))]\n",
        "        rs = [f\"r_{{{i}}}\" for i in range(len(self.root_dots))]\n",
        "\n",
        "        for tup in [(1, 2, 0), (2, 0, 1), (0, 1, 2)]:\n",
        "            rs = [f\"r_{{{i}}}\" for i in tup]\n",
        "            alt_system = get_symmetric_system(cs, roots=rs, signed=True)\n",
        "            alt_system.replace(system)\n",
        "            self.play(*(\n",
        "                TransformMatchingTex(\n",
        "                    l1, l2,\n",
        "                    path_arc=PI / 2,\n",
        "                    lag_ratio=0.01,\n",
        "                    run_time=2\n",
        "                )\n",
        "                for l1, l2 in zip(system, alt_system)\n",
        "            ))\n",
        "            self.remove(system)\n",
        "            system = alt_system\n",
        "            self.add(system)\n",
        "            self.wait()\n",
        "        self.coef_system = system\n",
        "\n",
        "\n",
        "class ComplicatedSingleValuedFunction(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class SolvabilityChart(Scene):\n",
        "    def construct(self):\n",
        "        # Preliminary terms\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(10)\n",
        "\n",
        "        words = self.get_words(frame)\n",
        "        equations = self.get_equations(words)\n",
        "        s_words = self.get_solvability_words(equations)\n",
        "        gen_form_words = Text(\"General form\")\n",
        "        gen_form_words.match_x(equations, LEFT)\n",
        "        gen_form_words.match_y(s_words, UP)\n",
        "        lines = self.get_lines(\n",
        "            rows=VGroup(s_words, *words),\n",
        "            cols=VGroup(words, equations, *s_words),\n",
        "        )\n",
        "        row_lines, col_lines = lines\n",
        "        marks = self.get_marks(equations, s_words)\n",
        "\n",
        "        # Shift colums\n",
        "        marks[1].save_state()\n",
        "        s_words[1].save_state()\n",
        "        frame.save_state()\n",
        "        frame.set_height(9, about_edge=DL)\n",
        "        frame.shift(LEFT)\n",
        "        VGroup(marks[1], s_words[1]).next_to(col_lines[1], RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        solvable_word = OldTexText(\"Can you solve\\\\\\\\for $x$?\")\n",
        "        solvable_word.move_to(s_words[1], DOWN)\n",
        "\n",
        "        # Cover rects\n",
        "        cover_rect = Rectangle()\n",
        "        cover_rect.set_fill(BLACK, 1)\n",
        "        cover_rect.set_stroke(BLACK, 0)\n",
        "        cover_rect.replace(frame, stretch=True)\n",
        "        cover_rect.add(VectorizedPoint(cover_rect.get_top() + 0.025 * UP))\n",
        "        cover_rect.move_to(row_lines[1], UL).shift(LEFT)\n",
        "        right_cover_rect = cover_rect.copy()\n",
        "        right_cover_rect.next_to(s_words[1], RIGHT, buff=MED_LARGE_BUFF)\n",
        "        right_cover_rect.match_y(frame)\n",
        "\n",
        "        self.add(words, equations, solvable_word)\n",
        "        self.add(row_lines, col_lines[:2])\n",
        "        self.add(right_cover_rect, cover_rect)\n",
        "\n",
        "        # Axes\n",
        "        axes = self.get_axes(frame)\n",
        "        coefs = np.array([1, 0.5, 0, 0, 0, 0])\n",
        "        coef_tracker = ValueTracker(coefs)\n",
        "        get_coefs = coef_tracker.get_value\n",
        "        graph = always_redraw(lambda: axes.get_graph(\n",
        "            lambda x: poly(x, get_coefs()),\n",
        "            stroke_color=BLUE,\n",
        "            stroke_width=2,\n",
        "        ))\n",
        "        root_dots = GlowDot()\n",
        "        root_dots.add_updater(lambda m: m.set_points([\n",
        "            axes.c2p(r.real, 0)\n",
        "            for r in coefficients_to_roots(get_coefs())\n",
        "            if abs(r.imag) < 1e-5 and abs(r.real) < 5\n",
        "        ]))\n",
        "        self.add(axes)\n",
        "\n",
        "        # Linear equation\n",
        "        tex_kw = dict(tex_to_color_map=self.get_tex_to_color_map())\n",
        "        lin_solution = OldTex(\"x = {-{b} \\\\over {a}}\", **tex_kw)\n",
        "        lin_solution.scale(1.2)\n",
        "        lin_solution.next_to(equations[0], DOWN, buff=2.0)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(root_dots, rate_func=squish_rate_func(smooth, 0.3, 0.4)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(\n",
        "            equations[0].copy(), lin_solution\n",
        "        ))\n",
        "        self.play(Write(marks[1][0]))\n",
        "        self.wait()\n",
        "\n",
        "        # Quadratic\n",
        "        quadratic_formula = get_quadratic_formula(lhs=\"x = \", **tex_kw)\n",
        "        quadratic_formula.next_to(equations[1], DOWN, buff=2.0)\n",
        "        new_coefs = 0.2 * np.array([*roots_to_coefficients([-3, 2]), 0, 0, 0])\n",
        "\n",
        "        self.play(\n",
        "            cover_rect.animate.move_to(row_lines[2], UL).shift(LEFT),\n",
        "            FadeOut(lin_solution, DOWN),\n",
        "        )\n",
        "        self.play(coef_tracker.animate.set_value(new_coefs))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(\n",
        "            equations[1].copy(), quadratic_formula,\n",
        "        ))\n",
        "        self.play(Write(marks[1][1]))\n",
        "        self.wait()\n",
        "\n",
        "        # Cubic\n",
        "        key_to_color = dict([\n",
        "            (TransformMatchingShapes.get_mobject_key(OldTex(c)[0][0]), color)\n",
        "            for c, color in self.get_tex_to_color_map().items()\n",
        "        ])\n",
        "        full_cubic = get_full_cubic_formula(lhs=\"x = \")\n",
        "        full_cubic.set_width(9)\n",
        "        full_cubic.next_to(equations[2], DOWN, buff=1.0).shift(LEFT)\n",
        "        for sm in full_cubic[0]:\n",
        "            key = TransformMatchingShapes.get_mobject_key(sm)\n",
        "            sm.set_color(key_to_color.get(key, WHITE))\n",
        "        new_coefs = 0.05 * np.array([*roots_to_coefficients([-4, -1, 3]), 0, 0])\n",
        "\n",
        "        self.play(\n",
        "            cover_rect.animate.move_to(row_lines[3], UL).shift(LEFT),\n",
        "            FadeOut(quadratic_formula, DOWN),\n",
        "        )\n",
        "        self.play(coef_tracker.animate.set_value(new_coefs))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(\n",
        "            equations[2].copy(), full_cubic,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "    def get_words(self, frame):\n",
        "        words = VGroup(*map(Text, (\n",
        "            \"Linear\",\n",
        "            \"Quadratic\",\n",
        "            \"Cubic\",\n",
        "            \"Quartic\",\n",
        "            \"Quintic\",\n",
        "            \"Sextic\",\n",
        "        )))\n",
        "        words.add(OldTex(\"\\\\vdots\"))\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        words.next_to(frame.get_corner(DL), UR, buff=1.0)\n",
        "        words.shift(0.5 * LEFT)\n",
        "        words[-1].match_x(words[-2])\n",
        "        return words\n",
        "\n",
        "    def get_equations(self, words):\n",
        "        kw = dict(tex_to_color_map=self.get_tex_to_color_map())\n",
        "        equations = VGroup(\n",
        "            OldTex(\"{a}x + {b} = 0\", **kw),\n",
        "            OldTex(\"{a}x^2 + {b}x + {c} = 0\", **kw),\n",
        "            OldTex(\"{a}x^3 + {b}x^2 + {c}x + {d} = 0\", **kw),\n",
        "            OldTex(\"{a}x^4 + \\\\cdots + {d}x + {e} = 0\", **kw),\n",
        "            OldTex(\"{a}x^5 + \\\\cdots + {e}x + {f} = 0\", **kw),\n",
        "            OldTex(\"{a}x^6 + \\\\cdots + {f}x + {g} = 0\", **kw),\n",
        "            OldTex(\"\\\\vdots\", **kw),\n",
        "        )\n",
        "        equations.arrange(DOWN, aligned_edge=LEFT)\n",
        "        equations.next_to(words, RIGHT, LARGE_BUFF)\n",
        "        for eq, word in zip(equations, words):\n",
        "            dy = word[-1].get_bottom()[1] - eq[0][0].get_bottom()[1]\n",
        "            eq.shift(dy * UP)\n",
        "        equations[-1].match_y(words[-1])\n",
        "        equations[-1].match_x(equations[-2])\n",
        "        return equations\n",
        "\n",
        "    def get_solvability_words(self, equations):\n",
        "        operations = [\"+\", \"-\", \"\\\\times\", \"/\", \"\\\\sqrt[n]{\\\\quad}\"]\n",
        "        arith, radicals = (\n",
        "            \"$\" + \" ,\\\\, \".join(operations[s]) + \"$\"\n",
        "            for s in (slice(None, -1), slice(None))\n",
        "        )\n",
        "        s_words = VGroup(\n",
        "            OldTexText(\"Solvable\", \" using\\\\\\\\\", arith),\n",
        "            OldTexText(\"Solvable\", \" using\\\\\\\\\", radicals),\n",
        "            OldTexText(\"Solvable\\\\\\\\\", \"numerically\"),\n",
        "        )\n",
        "        s_words.arrange(RIGHT, buff=LARGE_BUFF, aligned_edge=UP)\n",
        "        s_words.next_to(equations, UR, buff=MED_LARGE_BUFF)\n",
        "        s_words.shift(MED_LARGE_BUFF * RIGHT)\n",
        "\n",
        "        return s_words\n",
        "\n",
        "    def get_lines(self, rows, cols, color=GREY_A, width=2):\n",
        "        row_line = Line(cols.get_left(), cols.get_right())\n",
        "        row_lines = row_line.replicate(len(rows) - 1)\n",
        "        for r1, r2, rl in zip(rows, rows[1:], row_lines):\n",
        "            rl.match_y(midpoint(r1.get_bottom(), r2.get_top()))\n",
        "\n",
        "        col_line = Line(rows.get_top(), rows.get_bottom())\n",
        "        col_lines = col_line.replicate(len(cols) - 1)\n",
        "        for c1, c2, cl in zip(cols, cols[1:], col_lines):\n",
        "            cl.match_x(midpoint(c1.get_right(), c2.get_left()))\n",
        "\n",
        "        col_lines[0].match_height(Group(row_lines, Point(col_lines.get_bottom())), about_edge=DOWN)\n",
        "\n",
        "        lines = VGroup(row_lines, col_lines)\n",
        "        lines.set_stroke(color, width)\n",
        "        return lines\n",
        "\n",
        "    def get_marks(self, equations, solvability_words):\n",
        "        pre_marks = [\n",
        "            \"cxxxxxx\",\n",
        "            \"ccccxxx\",\n",
        "            \"ccccccc\",\n",
        "        ]\n",
        "        marks = VGroup(*(\n",
        "            VGroup(*(\n",
        "                Checkmark() if pm == 'c' else Exmark()\n",
        "                for pm in pm_list\n",
        "            ))\n",
        "            for pm_list in pre_marks\n",
        "        ))\n",
        "        for mark_group, s_word in zip(marks, solvability_words):\n",
        "            mark_group.match_x(s_word)\n",
        "            for mark, eq in zip(mark_group, equations):\n",
        "                mark.match_y(eq)\n",
        "        return marks\n",
        "\n",
        "    def get_axes(self, frame):\n",
        "        axes = Axes((-5, 5), (-5, 5), height=10, width=10)\n",
        "        axes.set_width(4)\n",
        "        axes.next_to(frame.get_corner(DR), UL)\n",
        "        axes.add(OldTex(\"x\", font_size=24).next_to(axes.x_axis.get_right(), DOWN, SMALL_BUFF))\n",
        "        axes.add(OldTex(\"y\", font_size=24).next_to(axes.y_axis.get_top(), LEFT, SMALL_BUFF))\n",
        "        return axes\n",
        "\n",
        "    def get_tex_to_color_map(self):\n",
        "        chars = \"abcdefg\"\n",
        "        colors = color_gradient([RED_B, RED_C, RED_D], len(chars))\n",
        "        return dict(\n",
        "            (f\"{{{char}}}\", color)\n",
        "            for char, color in zip(chars, colors)\n",
        "        )\n",
        "\n",
        "\n",
        "class StudySqrt(RadicalScene):\n",
        "    n = 2\n",
        "    c = 2.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Show simple equation\n",
        "        kw = dict(tex_to_color_map={\"c\": self.coef_color})\n",
        "        equations = VGroup(\n",
        "            OldTex(\"x^2 - c = 0\", **kw),\n",
        "            OldTex(\"x =\", \"\\\\sqrt{c}\", **kw),\n",
        "        )\n",
        "        equations.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        equations.to_edge(UP)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(FadeIn(equations[0], UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                equations[0].copy(),\n",
        "                equations[1],\n",
        "                path_arc=PI / 2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sqrt_label = equations[1][1:].copy()\n",
        "\n",
        "        # Add decimal labels, show square roots of real c\n",
        "        c_label = VGroup(\n",
        "            OldTex(\"c = \", tex_to_color_map={\"c\": self.coef_color}),\n",
        "            DecimalNumber(self.c),\n",
        "        )\n",
        "        c_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        c_label.next_to(self.coef_poly, UP, buff=1.5)\n",
        "        c_label[1].add_updater(lambda d: d.set_value(self.get_c().real))\n",
        "\n",
        "        def update_root_dec(root_dec):\n",
        "            c_real = self.get_c().real\n",
        "            root_dec.unit = \"\" if c_real > 0 else \"i\"\n",
        "            root_dec.set_value((-1)**root_dec.index * math.sqrt(abs(c_real)))\n",
        "\n",
        "        r_labels = VGroup(*(\n",
        "            VGroup(OldTex(f\"r_{i}\", \"=\"), DecimalNumber(self.c, include_sign=True))\n",
        "            for i in range(2)\n",
        "        ))\n",
        "        for i, r_label in enumerate(r_labels):\n",
        "            r_label.arrange(RIGHT)\n",
        "            r_label[1].align_to(r_label[0][0][0], DOWN)\n",
        "            r_label[0][0].set_color(self.root_color)\n",
        "            r_label[1].index = i\n",
        "            r_label[1].add_updater(update_root_dec)\n",
        "\n",
        "        r_labels.arrange(DOWN, buff=0.75)\n",
        "        r_labels.match_x(self.root_plane)\n",
        "        r_labels.match_y(c_label)\n",
        "\n",
        "        sqrt_arrow = Arrow(self.coef_plane, self.root_plane)\n",
        "        sqrt_arrow.match_y(c_label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(c_label),\n",
        "            ShowCreation(sqrt_arrow),\n",
        "            sqrt_label.animate.next_to(sqrt_arrow, UP),\n",
        "            FadeOut(equations),\n",
        "        )\n",
        "        self.play(FadeIn(r_labels))\n",
        "        self.lock_coef_imag = True\n",
        "        self.wait(note=\"Move c along real line\")\n",
        "        self.lock_coef_imag = False\n",
        "\n",
        "        # Focus just on one root\n",
        "        root_dots = self.root_dots\n",
        "        root_tracers = VGroup(*(d.tracer for d in root_dots))\n",
        "        root_labels = self.r_dot_labels\n",
        "        self.play(\n",
        "            r_labels[0].animate.match_y(c_label),\n",
        "            FadeOut(r_labels[1], DOWN),\n",
        "            root_dots[1].animate.set_opacity(0.5),\n",
        "            root_dots[1].tracer.animate.set_stroke(opacity=0.5),\n",
        "            root_labels[1].animate.set_opacity(0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        r_label = r_labels[0]\n",
        "\n",
        "        # Vary the angle of c\n",
        "        self.show_angle_variation(c_label, r_label, sqrt_arrow)\n",
        "        self.play(\n",
        "            sqrt_arrow.animate.set_width(1.75).match_y(self.root_plane),\n",
        "            MaintainPositionRelativeTo(sqrt_label, sqrt_arrow)\n",
        "        )\n",
        "\n",
        "        # Discontinuous square root\n",
        "        option = VGroup(\n",
        "            OldTexText(\"One option:\", color=BLUE),\n",
        "            OldTexText(\"\\\\\\\\Make\", \" $\\\\sqrt{\\\\quad}$\", \" single-valued, but discontinuous\", font_size=36),\n",
        "        )\n",
        "        option.arrange(DOWN, buff=0.5)\n",
        "        option[1][1].align_to(option[1][0], DOWN)\n",
        "        option.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        np_tex = Code(\"Python: numpy.sqrt(c)\")\n",
        "        np_tex.match_width(self.root_plane)\n",
        "        np_tex.next_to(self.root_plane, UP)\n",
        "\n",
        "        sqrt_dot = Dot(**self.dot_style)\n",
        "        sqrt_dot.set_color(BLUE)\n",
        "        sqrt_dot.add_updater(lambda d: d.move_to(self.root_plane.n2p(np.sqrt(self.get_c()))))\n",
        "        sqrt_label = Code(\"sqrt(c)\")\n",
        "        sqrt_label.scale(0.75)\n",
        "        sqrt_label.add_updater(lambda m: m.next_to(sqrt_dot, UR, buff=0))\n",
        "\n",
        "        self.play(FadeIn(option, UP))\n",
        "        self.wait()\n",
        "        self.remove(root_tracers)\n",
        "        self.play(\n",
        "            self.root_dots.animate.set_opacity(0),\n",
        "            FadeOut(self.root_poly),\n",
        "            FadeOut(root_labels),\n",
        "            FadeIn(np_tex),\n",
        "            FadeIn(sqrt_dot),\n",
        "            FadeIn(sqrt_label),\n",
        "        )\n",
        "        self.wait(note=\"Show discontinuity\")\n",
        "\n",
        "        # Taylor series\n",
        "        taylor_series = OldTex(\n",
        "            \"\\\\sqrt{x} \\\\approx\",\n",
        "            \"1\",\n",
        "            \"+ \\\\frac{1}{2}(x - 1)\",\n",
        "            \"- \\\\frac{1}{8}(x - 1)^2\",\n",
        "            \"+ \\\\frac{1}{16}(x - 1)^3\",\n",
        "            \"- \\\\frac{5}{128}(x - 1)^4\",\n",
        "            \"+ \\\\cdots\",\n",
        "            font_size=36,\n",
        "        )\n",
        "        ts_title = Text(\"What about a Taylor series?\")\n",
        "        ts_title.set_color(GREEN)\n",
        "        ts_group = VGroup(ts_title, taylor_series)\n",
        "        ts_group.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        ts_group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        def f(x, n):\n",
        "            return sum((\n",
        "                gen_choose(1 / 2, k) * (x - 1)**k\n",
        "                for k in range(n)\n",
        "            ))\n",
        "\n",
        "        brace = Brace(taylor_series[1:-1], DOWN, buff=SMALL_BUFF)\n",
        "        upper_f_label = brace.get_tex(\"f_4(x)\", buff=SMALL_BUFF)\n",
        "        upper_f_label.set_color(GREEN)\n",
        "\n",
        "        f_dot = Dot(**self.dot_style)\n",
        "        f_dot.set_color(GREEN)\n",
        "        f_dot.add_updater(lambda d: d.move_to(self.root_plane.n2p(f(self.get_c(), 4))))\n",
        "        f_label = OldTex(\"f_4(x)\", font_size=24, color=GREEN)\n",
        "        f_label.add_updater(lambda m: m.next_to(f_dot, DL, buff=SMALL_BUFF))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(np_tex),\n",
        "            FadeIn(ts_group, UP),\n",
        "            FadeOut(option, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(upper_f_label, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(upper_f_label, f_label),\n",
        "            GrowFromPoint(f_dot, upper_f_label.get_center()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        anims = [\n",
        "            brace.animate.become(Brace(taylor_series[1:], DOWN, buff=SMALL_BUFF))\n",
        "        ]\n",
        "        for label in (upper_f_label, f_label):\n",
        "            new_label = OldTex(\"f_{50}(x)\")\n",
        "            new_label.replace(label, 1)\n",
        "            new_label.match_style(label)\n",
        "            anims.append(Transform(label, new_label, suspend_updating=False))\n",
        "        self.play(*anims)\n",
        "        f_dot.clear_updaters()\n",
        "        f_dot.add_updater(lambda d: d.move_to(self.root_plane.n2p(f(self.get_c(), 50))))\n",
        "        self.wait()\n",
        "\n",
        "        disc = Circle(radius=self.root_plane.x_axis.get_unit_size())\n",
        "        disc.move_to(self.root_plane.n2p(1))\n",
        "        disc.set_stroke(BLUE_B, 2)\n",
        "        disc.set_fill(BLUE_B, 0.2)\n",
        "        self.play(FadeIn(disc))\n",
        "        self.wait()\n",
        "\n",
        "        # Back to normal\n",
        "        ts_group.add(brace, upper_f_label)\n",
        "        root_labels.set_opacity(1)\n",
        "        self.play(\n",
        "            FadeOut(ts_group, UP),\n",
        "            *map(FadeOut, (disc, f_label, f_dot, sqrt_label, sqrt_dot)),\n",
        "            FadeIn(root_labels),\n",
        "            FadeIn(self.root_poly),\n",
        "            root_dots.animate.set_opacity(1),\n",
        "        )\n",
        "        self.add(root_tracers, *root_labels)\n",
        "        self.wait()\n",
        "\n",
        "    def show_angle_variation(self, c_label, r_label, arrow):\n",
        "        angle_color = TEAL\n",
        "        self.last_theta = 0\n",
        "\n",
        "        def get_theta():\n",
        "            angle = np.log(self.get_c()).imag\n",
        "            diff = angle - self.last_theta\n",
        "            diff = (diff + PI) % TAU - PI\n",
        "            self.last_theta += diff\n",
        "            return self.last_theta\n",
        "\n",
        "        circle = Circle(radius=self.coef_plane.x_axis.get_unit_size())\n",
        "        circle.set_stroke(angle_color, 1)\n",
        "        circle.move_to(self.coef_plane.get_origin())\n",
        "\n",
        "        left_exp_label, right_exp_label = (\n",
        "            self.get_exp_label(\n",
        "                get_theta=func,\n",
        "                color=angle_color\n",
        "            ).move_to(label[-1], DL)\n",
        "            for label, func in [\n",
        "                (c_label, get_theta),\n",
        "                (r_label, lambda: get_theta() / self.n),\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        below_arrow_tex = Tex(\n",
        "            \"e^{x} \\\\rightarrow e^{x /\" + str(self.n) + \"}\",\n",
        "            font_size=36,\n",
        "            tex_to_color_map={\"\\\\theta\": angle_color},\n",
        "        )\n",
        "        below_arrow_tex.next_to(arrow, DOWN)\n",
        "\n",
        "        angle_labels = VGroup(\n",
        "            self.get_angle_label(self.coef_dots[0], self.coef_plane, \"\\\\theta\", get_theta),\n",
        "            self.get_angle_label(\n",
        "                self.root_dots[0], self.root_plane,\n",
        "                f\"\\\\theta / {self.n}\",\n",
        "                lambda: get_theta() / self.n,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        self.add(circle, self.coef_dots)\n",
        "        self.lock_coef_norm = True\n",
        "        self.tie_roots_to_coefs()\n",
        "        self.play(\n",
        "            FadeIn(circle),\n",
        "            FadeIn(angle_labels),\n",
        "            self.coef_dots[0].animate.move_to(self.coef_plane.n2p(1)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(c_label[-1], UP),\n",
        "            FadeOut(r_label[-1], UP),\n",
        "            FadeIn(left_exp_label, UP),\n",
        "            FadeIn(right_exp_label, UP),\n",
        "        )\n",
        "        self.wait(note=\"Rotate c a bit\")\n",
        "        self.play(Write(below_arrow_tex))\n",
        "        self.wait(note=\"Show full rotation, then two rotations\")\n",
        "\n",
        "        # Remove stuff\n",
        "        self.play(LaggedStart(*map(FadeOut, (\n",
        "            circle, angle_labels,\n",
        "            left_exp_label, right_exp_label,\n",
        "            c_label[:-1], r_label[:-1],\n",
        "            below_arrow_tex,\n",
        "        ))))\n",
        "        self.lock_coef_norm = False\n",
        "\n",
        "    def get_exp_label(self, get_theta, color=GREEN):\n",
        "        result = OldTex(\"e^{\", \"2\\\\pi i \\\\cdot\", \"0.00}\")\n",
        "        decimal = DecimalNumber()\n",
        "        decimal.replace(result[2], dim_to_match=1)\n",
        "        result.replace_submobject(2, decimal)\n",
        "        result.add_updater(lambda m: m.note_changed_family())\n",
        "        result.add_updater(lambda m: m[-1].set_color(color))\n",
        "        result.add_updater(lambda m: m[-1].set_value(get_theta() / TAU))\n",
        "        return result\n",
        "\n",
        "\n",
        "class CubeRootBehavior(StudySqrt):\n",
        "    n = 3\n",
        "    c = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        arrows, labels = self.get_radical_labels()\n",
        "        self.add(arrows, labels)\n",
        "\n",
        "        c_label = OldTex(\"c = \", \"1.00\", tex_to_color_map={\"c\": self.coef_color})\n",
        "        r_label = OldTex(\"r_0 = \", \"1.00\", tex_to_color_map={\"r_0\": self.root_color})\n",
        "        c_label.match_x(self.coef_plane)\n",
        "        c_label.to_edge(UP, buff=1.0)\n",
        "        r_label.match_x(self.root_plane)\n",
        "        r_label.match_y(c_label)\n",
        "        right_arrow_group = VGroup(arrows[0], labels[0])\n",
        "        right_arrow_group.save_state()\n",
        "\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            right_arrow_group.animate.to_edge(UP),\n",
        "            *map(FadeIn, (c_label, r_label))\n",
        "        )\n",
        "        self.show_angle_variation(c_label, r_label, right_arrow_group[0])\n",
        "        self.play(Restore(right_arrow_group))\n",
        "\n",
        "    def add_labeled_arrow(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class FifthRootBehavior(CubeRootBehavior):\n",
        "    n = 5\n",
        "\n",
        "\n",
        "class SummarizeRootsToCyclesBehavior(Scene):\n",
        "    def construct(self):\n",
        "        pass\n"
    ]
}