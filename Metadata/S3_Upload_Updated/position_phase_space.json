{
    "topic": "demonstrates the concept of position-momentum phase space and its relationship with the motion",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.clacks.question import Block\n",
        "from _2019.clacks.question import Wall\n",
        "from _2019.clacks.question import ClackFlashes\n",
        "\n",
        "\n",
        "class PositionPhaseSpaceScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"rescale_coordinates\": True,\n",
        "        \"wall_x\": -6,\n",
        "        \"wall_config\": {\n",
        "            \"height\": 1.6,\n",
        "            \"tick_spacing\": 0.35,\n",
        "            \"tick_length\": 0.2,\n",
        "        },\n",
        "        \"wall_height\": 1.5,\n",
        "        \"floor_y\": -3.5,\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 10,\n",
        "            \"distance\": 9,\n",
        "            \"velocity\": -1,\n",
        "            \"width\": 1.6,\n",
        "        },\n",
        "        \"block2_config\": {\n",
        "            \"mass\": 1,\n",
        "            \"distance\": 4,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -0.5,\n",
        "            \"x_max\": 31,\n",
        "            \"y_min\": -0.5,\n",
        "            \"y_max\": 10.5,\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 0.4,\n",
        "                \"tick_frequency\": 2,\n",
        "            },\n",
        "            \"y_axis_config\": {\n",
        "                \"unit_size\": 0.4,\n",
        "                \"tick_frequency\": 2,\n",
        "            },\n",
        "        },\n",
        "        \"axes_center\": 5 * LEFT + 0.65 * DOWN,\n",
        "        \"ps_dot_config\": {\n",
        "            \"fill_color\": RED,\n",
        "            \"background_stroke_width\": 1,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "            \"radius\": 0.05,\n",
        "        },\n",
        "        \"ps_d2_label_vect\": RIGHT,\n",
        "        \"ps_x_line_config\": {\n",
        "            \"color\": GREEN,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"ps_y_line_config\": {\n",
        "            \"color\": RED,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"clack_sound\": \"clack\",\n",
        "        \"mirror_line_class\": Line,\n",
        "        \"mirror_line_style\": {\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 1,\n",
        "        },\n",
        "        \"d1_eq_d2_line_color\": MAROON_B,\n",
        "        \"d1_eq_d2_tex\": \"d1 = d2\",\n",
        "        \"trajectory_style\": {\n",
        "            \"stroke_color\": YELLOW,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"ps_velocity_vector_length\": 0.75,\n",
        "        \"ps_velocity_vector_config\": {\n",
        "            \"color\": PINK,\n",
        "            \"rectangular_stem_width\": 0.025,\n",
        "            \"tip_length\": 0.15,\n",
        "        },\n",
        "        \"block_velocity_vector_length_multiple\": 2,\n",
        "        \"block_velocity_vector_config\": {\n",
        "            \"color\": PINK,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.total_sliding_time = 0\n",
        "        self.all_items = [\n",
        "            self.get_floor(),\n",
        "            self.get_wall(),\n",
        "            self.get_blocks(),\n",
        "            self.get_axes(),\n",
        "            self.get_phase_space_point(),\n",
        "            self.get_phase_space_x_line(),\n",
        "            self.get_phase_space_y_line(),\n",
        "            self.get_phase_space_dot(),\n",
        "            self.get_phase_space_d1_label(),\n",
        "            self.get_phase_space_d2_label(),\n",
        "            self.get_d1_brace(),\n",
        "            self.get_d2_brace(),\n",
        "            self.get_d1_label(),\n",
        "            self.get_d2_label(),\n",
        "            self.get_d1_eq_d2_line(),\n",
        "            self.get_d1_eq_d2_label(),\n",
        "            self.get_d2_eq_w2_line(),\n",
        "            self.get_d2_eq_w2_label(),\n",
        "        ]\n",
        "\n",
        "    def get_floor_wall_corner(self):\n",
        "        return self.wall_x * RIGHT + self.floor_y * UP\n",
        "\n",
        "    def get_mass_ratio(self):\n",
        "        return op.truediv(\n",
        "            self.block1.mass,\n",
        "            self.block2.mass,\n",
        "        )\n",
        "\n",
        "    def d1_to_x(self, d1):\n",
        "        if self.rescale_coordinates:\n",
        "            d1 *= np.sqrt(self.block1.mass)\n",
        "        return d1\n",
        "\n",
        "    def d2_to_y(self, d2):\n",
        "        if self.rescale_coordinates:\n",
        "            d2 *= np.sqrt(self.block2.mass)\n",
        "        return d2\n",
        "\n",
        "    def ds_to_point(self, d1, d2):\n",
        "        return self.axes.coords_to_point(\n",
        "            self.d1_to_x(d1), self.d2_to_y(d2),\n",
        "        )\n",
        "\n",
        "    def point_to_ds(self, point):\n",
        "        x, y = self.axes.point_to_coords(point)\n",
        "        if self.rescale_coordinates:\n",
        "            x /= np.sqrt(self.block1.mass)\n",
        "            y /= np.sqrt(self.block2.mass)\n",
        "        return (x, y)\n",
        "\n",
        "    def get_d1(self):\n",
        "        return self.get_ds()[0]\n",
        "\n",
        "    def get_d2(self):\n",
        "        return self.get_ds()[1]\n",
        "\n",
        "    def get_ds(self):\n",
        "        return self.point_to_ds(self.ps_point.get_location())\n",
        "\n",
        "    # Relevant for sliding\n",
        "    def tie_blocks_to_ps_point(self):\n",
        "        def update_blocks(blocks):\n",
        "            d1, d2 = self.point_to_ds(self.ps_point.get_location())\n",
        "            b1, b2 = blocks\n",
        "            corner = self.get_floor_wall_corner()\n",
        "            b1.move_to(corner + d1 * RIGHT, DL)\n",
        "            b2.move_to(corner + d2 * RIGHT, DR)\n",
        "        self.blocks.add_updater(update_blocks)\n",
        "\n",
        "    def time_to_ds(self, time):\n",
        "        # Deals in its own phase space, different\n",
        "        # from the one displayed\n",
        "        m1 = self.block1.mass\n",
        "        m2 = self.block2.mass\n",
        "        v1 = self.block1.velocity\n",
        "        start_d1 = self.block1_config[\"distance\"]\n",
        "        start_d2 = self.block2_config[\"distance\"]\n",
        "        w2 = self.block2.width\n",
        "        start_d2 += w2\n",
        "        ps_speed = np.sqrt(m1) * abs(v1)\n",
        "        theta = np.arctan(np.sqrt(m2 / m1))\n",
        "\n",
        "        def ds_to_ps_point(d1, d2):\n",
        "            return np.array([\n",
        "                d1 * np.sqrt(m1),\n",
        "                d2 * np.sqrt(m2),\n",
        "                0\n",
        "            ])\n",
        "\n",
        "        def ps_point_to_ds(point):\n",
        "            return (\n",
        "                point[0] / np.sqrt(m1),\n",
        "                point[1] / np.sqrt(m2),\n",
        "            )\n",
        "\n",
        "        ps_point = ds_to_ps_point(start_d1, start_d2)\n",
        "        wedge_corner = ds_to_ps_point(w2, w2)\n",
        "        ps_point -= wedge_corner\n",
        "        # Pass into the mirror worlds\n",
        "        ps_point += time * ps_speed * LEFT\n",
        "        # Reflect back to the real world\n",
        "        angle = angle_of_vector(ps_point)\n",
        "        n = int(angle / theta)\n",
        "        if n % 2 == 0:\n",
        "            ps_point = rotate_vector(ps_point, -n * theta)\n",
        "        else:\n",
        "            ps_point = rotate_vector(\n",
        "                ps_point,\n",
        "                -(n + 1) * theta,\n",
        "            )\n",
        "            ps_point[1] = abs(ps_point[1])\n",
        "        ps_point += wedge_corner\n",
        "        return ps_point_to_ds(ps_point)\n",
        "\n",
        "    def get_clack_data(self):\n",
        "        # Copying from time_to_ds.  Not great, but\n",
        "        # maybe I'll factor things out properly later.\n",
        "        m1 = self.block1.mass\n",
        "        m2 = self.block2.mass\n",
        "        v1 = self.block1.velocity\n",
        "        w2 = self.block2.get_width()\n",
        "        h2 = self.block2.get_height()\n",
        "        start_d1, start_d2 = self.get_ds()\n",
        "        ps_speed = np.sqrt(m1) * abs(v1)\n",
        "        theta = np.arctan(np.sqrt(m2 / m1))\n",
        "\n",
        "        def ds_to_ps_point(d1, d2):\n",
        "            return np.array([\n",
        "                d1 * np.sqrt(m1),\n",
        "                d2 * np.sqrt(m2),\n",
        "                0\n",
        "            ])\n",
        "\n",
        "        def ps_point_to_ds(point):\n",
        "            return (\n",
        "                point[0] / np.sqrt(m1),\n",
        "                point[1] / np.sqrt(m2),\n",
        "            )\n",
        "\n",
        "        ps_point = ds_to_ps_point(start_d1, start_d2)\n",
        "        wedge_corner = ds_to_ps_point(w2, w2)\n",
        "        ps_point -= wedge_corner\n",
        "        y = ps_point[1]\n",
        "\n",
        "        clack_data = []\n",
        "        for k in range(1, int(PI / theta) + 1):\n",
        "            clack_ps_point = np.array([\n",
        "                y / np.tan(k * theta), y, 0\n",
        "            ])\n",
        "            time = get_norm(ps_point - clack_ps_point) / ps_speed\n",
        "            reflected_point = rotate_vector(\n",
        "                clack_ps_point,\n",
        "                -2 * np.ceil((k - 1) / 2) * theta\n",
        "            )\n",
        "            d1, d2 = ps_point_to_ds(reflected_point + wedge_corner)\n",
        "            loc1 = self.get_floor_wall_corner() + h2 * UP / 2 + d2 * RIGHT\n",
        "            if k % 2 == 0:\n",
        "                loc1 += w2 * LEFT\n",
        "            loc2 = self.ds_to_point(d1, d2)\n",
        "            clack_data.append((time, loc1, loc2))\n",
        "        return clack_data\n",
        "\n",
        "    def tie_ps_point_to_time_tracker(self):\n",
        "        if not hasattr(self, \"sliding_time_tracker\"):\n",
        "            self.sliding_time_tracker = self.get_time_tracker()\n",
        "\n",
        "        def update_ps_point(p):\n",
        "            time = self.sliding_time_tracker.get_value()\n",
        "            ds = self.time_to_ds(time)\n",
        "            p.move_to(self.ds_to_point(*ds))\n",
        "\n",
        "        self.ps_point.add_updater(update_ps_point)\n",
        "        self.add(self.sliding_time_tracker, self.ps_point)\n",
        "\n",
        "    def add_clack_flashes(self):\n",
        "        if hasattr(self, \"flash_anims\"):\n",
        "            self.add(*self.flash_anims)\n",
        "        else:\n",
        "            clack_data = self.get_clack_data()\n",
        "            self.clack_times = [\n",
        "                time for (time, loc1, loc2) in clack_data\n",
        "            ]\n",
        "            self.block_flashes = ClackFlashes([\n",
        "                (loc1, time)\n",
        "                for (time, loc1, loc2) in clack_data\n",
        "            ])\n",
        "            self.ps_flashes = ClackFlashes([\n",
        "                (loc2, time)\n",
        "                for (time, loc1, loc2) in clack_data\n",
        "            ])\n",
        "            self.flash_anims = [self.block_flashes, self.ps_flashes]\n",
        "            for anim in self.flash_anims:\n",
        "                anim.get_time = self.sliding_time_tracker.get_value\n",
        "            self.add(*self.flash_anims)\n",
        "\n",
        "    def get_continually_building_trajectory(self):\n",
        "        trajectory = VMobject()\n",
        "        self.trajectory = trajectory\n",
        "        trajectory.set_style(**self.trajectory_style)\n",
        "\n",
        "        def get_point():\n",
        "            return np.array(self.ps_point.get_location())\n",
        "\n",
        "        points = [get_point(), get_point()]\n",
        "        trajectory.set_points_as_corners(points)\n",
        "        epsilon = 0.001\n",
        "\n",
        "        def update_trajectory(trajectory):\n",
        "            new_point = get_point()\n",
        "            p1, p2 = trajectory.get_anchors()[-2:]\n",
        "            angle = angle_between_vectors(\n",
        "                p2 - p1,\n",
        "                new_point - p2,\n",
        "            )\n",
        "            if angle > epsilon:\n",
        "                points.append(new_point)\n",
        "            else:\n",
        "                points[-1] = new_point\n",
        "            trajectory.set_points_as_corners(points)\n",
        "\n",
        "        trajectory.add_updater(update_trajectory)\n",
        "        return trajectory\n",
        "\n",
        "    def begin_sliding(self, show_trajectory=True):\n",
        "        self.tie_ps_point_to_time_tracker()\n",
        "        self.add_clack_flashes()\n",
        "        if show_trajectory:\n",
        "            if hasattr(self, \"trajectory\"):\n",
        "                self.trajectory.resume_updating()\n",
        "            else:\n",
        "                self.add(self.get_continually_building_trajectory())\n",
        "\n",
        "    def end_sliding(self):\n",
        "        self.update_mobjects(dt=0)\n",
        "        self.ps_point.clear_updaters()\n",
        "        if hasattr(self, \"sliding_time_tracker\"):\n",
        "            self.remove(self.sliding_time_tracker)\n",
        "        if hasattr(self, \"flash_anims\"):\n",
        "            self.remove(*self.flash_anims)\n",
        "        if hasattr(self, \"trajectory\"):\n",
        "            self.trajectory.suspend_updating()\n",
        "        old_total_sliding_time = self.total_sliding_time\n",
        "        new_total_sliding_time = self.sliding_time_tracker.get_value()\n",
        "        self.total_sliding_time = new_total_sliding_time\n",
        "        for time in self.clack_times:\n",
        "            if old_total_sliding_time < time < new_total_sliding_time:\n",
        "                offset = time - new_total_sliding_time\n",
        "                self.add_sound(\n",
        "                    \"clack\",\n",
        "                    time_offset=offset,\n",
        "                )\n",
        "\n",
        "    def slide(self, time, stop_condition=None):\n",
        "        self.begin_sliding()\n",
        "        self.wait(time, stop_condition)\n",
        "        self.end_sliding()\n",
        "\n",
        "    def slide_until(self, stop_condition, max_time=60):\n",
        "        self.slide(max_time, stop_condition=stop_condition)\n",
        "\n",
        "    def get_ps_point_change_anim(self, d1, d2, **added_kwargs):\n",
        "        b1 = self.block1\n",
        "        ps_speed = np.sqrt(b1.mass) * abs(b1.velocity)\n",
        "        curr_d1, curr_d2 = self.get_ds()\n",
        "        distance = get_norm([curr_d1 - d1, curr_d2 - d2])\n",
        "\n",
        "        # Default\n",
        "        kwargs = {\n",
        "            \"run_time\": (distance / ps_speed),\n",
        "            \"rate_func\": linear,\n",
        "        }\n",
        "        kwargs.update(added_kwargs)\n",
        "        return ApplyMethod(\n",
        "            self.ps_point.move_to,\n",
        "            self.ds_to_point(d1, d2),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    # Mobject getters\n",
        "    def get_floor(self):\n",
        "        floor = self.floor = Line(\n",
        "            self.wall_x * RIGHT,\n",
        "            FRAME_WIDTH * RIGHT / 2,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=3,\n",
        "        )\n",
        "        floor.move_to(self.get_floor_wall_corner(), LEFT)\n",
        "        return floor\n",
        "\n",
        "    def get_wall(self):\n",
        "        wall = self.wall = Wall(**self.wall_config)\n",
        "        wall.move_to(self.get_floor_wall_corner(), DR)\n",
        "        return wall\n",
        "\n",
        "    def get_blocks(self):\n",
        "        blocks = self.blocks = VGroup()\n",
        "        for n in [1, 2]:\n",
        "            config = getattr(self, \"block{}_config\".format(n))\n",
        "            block = Block(**config)\n",
        "            block.move_to(self.get_floor_wall_corner(), DL)\n",
        "            block.shift(config[\"distance\"] * RIGHT)\n",
        "            block.label.move_to(block)\n",
        "            block.label.set_fill(BLACK)\n",
        "            block.label.set_stroke(WHITE, 1, background=True)\n",
        "            self.blocks.add(block)\n",
        "        self.block1, self.block2 = blocks\n",
        "        return blocks\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = self.axes = Axes(**self.axes_config)\n",
        "        axes.set_stroke(GREY_B, 2)\n",
        "        axes.shift(\n",
        "            self.axes_center - axes.coords_to_point(0, 0)\n",
        "        )\n",
        "        axes.labels = self.get_axes_labels(axes)\n",
        "        axes.add(axes.labels)\n",
        "        axes.added_lines = self.get_added_axes_lines(axes)\n",
        "        axes.add(axes.added_lines)\n",
        "        return axes\n",
        "\n",
        "    def get_added_axes_lines(self, axes):\n",
        "        c2p = axes.coords_to_point\n",
        "        x_mult = y_mult = 1\n",
        "        if self.rescale_coordinates:\n",
        "            x_mult = np.sqrt(self.block1.mass)\n",
        "            y_mult = np.sqrt(self.block2.mass)\n",
        "        y_lines = VGroup(*[\n",
        "            Line(\n",
        "                c2p(0, 0), c2p(0, axes.y_max * y_mult + 1),\n",
        "            ).move_to(c2p(x, 0), DOWN)\n",
        "            for x in np.arange(0, axes.x_max) * x_mult\n",
        "        ])\n",
        "        x_lines = VGroup(*[\n",
        "            Line(\n",
        "                c2p(0, 0), c2p(axes.x_max * x_mult, 0),\n",
        "            ).move_to(c2p(0, y), LEFT)\n",
        "            for y in np.arange(0, axes.y_max) * y_mult\n",
        "        ])\n",
        "        line_groups = VGroup(x_lines, y_lines)\n",
        "        for lines in line_groups:\n",
        "            lines.set_stroke(BLUE, 1, 0.5)\n",
        "            lines[1::2].set_stroke(width=0.5, opacity=0.25)\n",
        "        return line_groups\n",
        "\n",
        "    def get_axes_labels(self, axes, with_sqrts=None):\n",
        "        if with_sqrts is None:\n",
        "            with_sqrts = self.rescale_coordinates\n",
        "        x_label = OldTex(\"x\", \"=\", \"d_1\")\n",
        "        y_label = OldTex(\"y\", \"=\", \"d_2\")\n",
        "        labels = VGroup(x_label, y_label)\n",
        "        if with_sqrts:\n",
        "            additions = map(Tex, [\n",
        "                \"\\\\sqrt{m_1}\", \"\\\\sqrt{m_2}\"\n",
        "            ])\n",
        "            for label, addition in zip(labels, additions):\n",
        "                addition.move_to(label[2], DL)\n",
        "                label[2].next_to(\n",
        "                    addition, RIGHT, SMALL_BUFF,\n",
        "                    aligned_edge=DOWN\n",
        "                )\n",
        "                addition[2:].set_color(BLUE)\n",
        "                label.submobjects.insert(2, addition)\n",
        "        x_label.next_to(axes.x_axis.get_right(), DL, MED_SMALL_BUFF)\n",
        "        y_label.next_to(axes.y_axis.get_top(), DR, MED_SMALL_BUFF)\n",
        "        for label in labels:\n",
        "            label.shift_onto_screen()\n",
        "        return labels\n",
        "\n",
        "    def get_phase_space_point(self):\n",
        "        ps_point = self.ps_point = VectorizedPoint()\n",
        "        ps_point.move_to(self.ds_to_point(\n",
        "            self.block1.distance,\n",
        "            self.block2.distance + self.block2.width\n",
        "        ))\n",
        "        self.tie_blocks_to_ps_point()\n",
        "        return ps_point\n",
        "\n",
        "    def get_phase_space_x_line(self):\n",
        "        def get_x_line():\n",
        "            origin = self.axes.coords_to_point(0, 0)\n",
        "            point = self.ps_point.get_location()\n",
        "            y_axis_point = np.array(origin)\n",
        "            y_axis_point[1] = point[1]\n",
        "            return DashedLine(\n",
        "                y_axis_point, point,\n",
        "                **self.ps_x_line_config,\n",
        "            )\n",
        "        self.x_line = always_redraw(get_x_line)\n",
        "        return self.x_line\n",
        "\n",
        "    def get_phase_space_y_line(self):\n",
        "        def get_y_line():\n",
        "            origin = self.axes.coords_to_point(0, 0)\n",
        "            point = self.ps_point.get_location()\n",
        "            x_axis_point = np.array(origin)\n",
        "            x_axis_point[0] = point[0]\n",
        "            return DashedLine(\n",
        "                x_axis_point, point,\n",
        "                **self.ps_y_line_config,\n",
        "            )\n",
        "        self.y_line = always_redraw(get_y_line)\n",
        "        return self.y_line\n",
        "\n",
        "    def get_phase_space_dot(self):\n",
        "        self.ps_dot = ps_dot = Dot(**self.ps_dot_config)\n",
        "        ps_dot.add_updater(lambda m: m.move_to(self.ps_point))\n",
        "        return ps_dot\n",
        "\n",
        "    def get_d_label(self, n, get_d):\n",
        "        label = VGroup(\n",
        "            OldTex(\"d_{}\".format(n), \"=\"),\n",
        "            DecimalNumber(),\n",
        "        )\n",
        "        color = GREEN if n == 1 else RED\n",
        "        label[0].set_color_by_tex(\"d_\", color)\n",
        "        label.scale(0.7)\n",
        "        label.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        def update_value(label):\n",
        "            lhs, rhs = label\n",
        "            rhs.set_value(get_d())\n",
        "            rhs.next_to(\n",
        "                lhs, RIGHT, SMALL_BUFF,\n",
        "                aligned_edge=DOWN,\n",
        "            )\n",
        "        label.add_updater(update_value)\n",
        "        return label\n",
        "\n",
        "    def get_phase_space_d_label(self, n, get_d, line, vect):\n",
        "        label = self.get_d_label(n, get_d)\n",
        "        label.add_updater(\n",
        "            lambda m: m.next_to(line, vect, SMALL_BUFF)\n",
        "        )\n",
        "        return label\n",
        "\n",
        "    def get_phase_space_d1_label(self):\n",
        "        self.ps_d1_label = self.get_phase_space_d_label(\n",
        "            1, self.get_d1, self.x_line, UP,\n",
        "        )\n",
        "        return self.ps_d1_label\n",
        "\n",
        "    def get_phase_space_d2_label(self):\n",
        "        self.ps_d2_label = self.get_phase_space_d_label(\n",
        "            2, self.get_d2, self.y_line,\n",
        "            self.ps_d2_label_vect,\n",
        "        )\n",
        "        return self.ps_d2_label\n",
        "\n",
        "    def get_d_brace(self, get_right_point):\n",
        "        line = Line(LEFT, RIGHT).set_width(6)\n",
        "\n",
        "        def get_brace():\n",
        "            right_point = get_right_point()\n",
        "            left_point = np.array(right_point)\n",
        "            left_point[0] = self.wall_x\n",
        "            line.put_start_and_end_on(left_point, right_point)\n",
        "            return Brace(line, UP, buff=SMALL_BUFF)\n",
        "\n",
        "        brace = always_redraw(get_brace)\n",
        "        return brace\n",
        "\n",
        "    def get_d1_brace(self):\n",
        "        self.d1_brace = self.get_d_brace(\n",
        "            lambda: self.block1.get_corner(UL)\n",
        "        )\n",
        "        return self.d1_brace\n",
        "\n",
        "    def get_d2_brace(self):\n",
        "        self.d2_brace = self.get_d_brace(\n",
        "            lambda: self.block2.get_corner(UR)\n",
        "        )\n",
        "        # self.flip_brace_nip()\n",
        "        return self.d2_brace\n",
        "\n",
        "    def flip_brace_nip(self, brace):\n",
        "        nip_index = (len(brace) // 2) - 1\n",
        "        nip = brace[nip_index:nip_index + 2]\n",
        "        rect = brace[nip_index - 1]\n",
        "        center = rect.get_center()\n",
        "        center[0] = nip.get_center()[0]\n",
        "        nip.rotate(PI, about_point=center)\n",
        "\n",
        "    def get_brace_d_label(self, n, get_d, brace, vect, buff):\n",
        "        label = self.get_d_label(n, get_d)\n",
        "        label.add_updater(\n",
        "            lambda m: m.next_to(brace, vect, buff)\n",
        "        )\n",
        "        return label\n",
        "\n",
        "    def get_d1_label(self):\n",
        "        self.d1_label = self.get_brace_d_label(\n",
        "            1, self.get_d1, self.d1_brace, UP, SMALL_BUFF,\n",
        "        )\n",
        "        return self.d1_label\n",
        "\n",
        "    def get_d2_label(self):\n",
        "        self.d2_label = self.get_brace_d_label(\n",
        "            2, self.get_d2, self.d2_brace, UP, 0\n",
        "        )\n",
        "        return self.d2_label\n",
        "\n",
        "    def get_d1_eq_d2_line(self):\n",
        "        start = self.ds_to_point(0, 0)\n",
        "        end = self.ds_to_point(15, 15)\n",
        "        line = self.d1_eq_d2_line = self.mirror_line_class(start, end)\n",
        "        line.set_style(**self.mirror_line_style)\n",
        "        line.set_color(self.d1_eq_d2_line_color)\n",
        "        return self.d1_eq_d2_line\n",
        "\n",
        "    def get_d1_eq_d2_label(self):\n",
        "        label = OldTex(self.d1_eq_d2_tex)\n",
        "        label.scale(0.75)\n",
        "        line = self.d1_eq_d2_line\n",
        "        point = interpolate(\n",
        "            line.get_start(), line.get_end(),\n",
        "            0.7,\n",
        "        )\n",
        "        label.next_to(point, DR, SMALL_BUFF)\n",
        "        label.match_color(line)\n",
        "        label.set_stroke(BLACK, 5, background=True)\n",
        "        self.d1_eq_d2_label = label\n",
        "        return label\n",
        "\n",
        "    def get_d2_eq_w2_line(self):\n",
        "        w2 = self.block2.width\n",
        "        start = self.ds_to_point(0, w2)\n",
        "        end = np.array(start)\n",
        "        end[0] = FRAME_WIDTH / 2\n",
        "        self.d2_eq_w2_line = self.mirror_line_class(start, end)\n",
        "        self.d2_eq_w2_line.set_style(**self.mirror_line_style)\n",
        "        return self.d2_eq_w2_line\n",
        "\n",
        "    def get_d2_eq_w2_label(self):\n",
        "        label = OldTex(\"d2 = \\\\text{block width}\")\n",
        "        label.scale(0.75)\n",
        "        label.next_to(self.d2_eq_w2_line, UP, SMALL_BUFF)\n",
        "        label.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        self.d2_eq_w2_label = label\n",
        "        return label\n",
        "\n",
        "    def get_time_tracker(self, time=0):\n",
        "        time_tracker = self.time_tracker = ValueTracker(time)\n",
        "        time_tracker.add_updater(\n",
        "            lambda m, dt: m.increment_value(dt)\n",
        "        )\n",
        "        return time_tracker\n",
        "\n",
        "    # Things associated with velocity\n",
        "    def get_ps_velocity_vector(self, trajectory):\n",
        "        vector = Vector(\n",
        "            self.ps_velocity_vector_length * LEFT,\n",
        "            **self.ps_velocity_vector_config,\n",
        "        )\n",
        "\n",
        "        def update_vector(v):\n",
        "            anchors = trajectory.get_anchors()\n",
        "            index = len(anchors) - 2\n",
        "            vect = np.array(ORIGIN)\n",
        "            while get_norm(vect) == 0 and index > 0:\n",
        "                p0, p1 = anchors[index:index + 2]\n",
        "                vect = p1 - p0\n",
        "                index -= 1\n",
        "            angle = angle_of_vector(vect)\n",
        "            point = self.ps_point.get_location()\n",
        "            v.set_angle(angle)\n",
        "            v.shift(point - v.get_start())\n",
        "        vector.add_updater(update_vector)\n",
        "        self.ps_velocity_vector = vector\n",
        "        return vector\n",
        "\n",
        "    def get_block_velocity_vectors(self, ps_vect):\n",
        "        blocks = self.blocks\n",
        "        vectors = VGroup(*[\n",
        "            Vector(LEFT, **self.block_velocity_vector_config)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        # TODO: Put in config\n",
        "        vectors[0].set_color(GREEN)\n",
        "        vectors[1].set_color(RED)\n",
        "\n",
        "        def update_vectors(vs):\n",
        "            v_2d = ps_vect.get_vector()[:2]\n",
        "            v_2d *= self.block_velocity_vector_length_multiple\n",
        "            for v, coord, block in zip(vs, v_2d, blocks):\n",
        "                v.put_start_and_end_on(ORIGIN, coord * RIGHT)\n",
        "                start = block.get_edge_center(v.get_vector())\n",
        "                v.shift(start)\n",
        "        vectors.add_updater(update_vectors)\n",
        "\n",
        "        self.block_velocity_vectors = vectors\n",
        "        return vectors\n",
        "\n",
        "\n",
        "class IntroducePositionPhaseSpace(PositionPhaseSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"rescale_coordinates\": False,\n",
        "        \"d1_eq_d2_tex\": \"x = y\",\n",
        "        \"block1_config\": {\n",
        "            \"velocity\": 1.5,\n",
        "        },\n",
        "        \"slide_wait_time\": 12,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_coordinates()\n",
        "        self.show_xy_line()\n",
        "        self.let_process_play_out()\n",
        "        self.show_w2_line()\n",
        "\n",
        "    def show_coordinates(self):\n",
        "        ps_point = self.ps_point\n",
        "        axes = self.axes\n",
        "\n",
        "        self.play(Write(axes.added_lines))\n",
        "        self.play(FadeInFromLarge(self.ps_dot, scale_factor=10))\n",
        "        self.play(\n",
        "            ShowCreation(self.x_line),\n",
        "            GrowFromPoint(\n",
        "                self.d1_brace,\n",
        "                self.d1_brace.get_left(),\n",
        "            ),\n",
        "            Indicate(axes.labels[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(self.ps_d1_label),\n",
        "            FadeInFromDown(self.d1_label),\n",
        "        )\n",
        "        self.play(ps_point.shift, 0.5 * LEFT)\n",
        "        self.play(ps_point.shift, 0.5 * RIGHT)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(self.y_line),\n",
        "            GrowFromPoint(\n",
        "                self.d2_brace,\n",
        "                self.d2_brace.get_left(),\n",
        "            ),\n",
        "            Indicate(axes.labels[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(self.ps_d2_label),\n",
        "            FadeInFromDown(self.d2_label),\n",
        "        )\n",
        "        self.play(ps_point.shift, 0.5 * UP)\n",
        "        self.play(ps_point.shift, 0.5 * DOWN)\n",
        "        self.wait()\n",
        "        self.play(Rotating(\n",
        "            ps_point,\n",
        "            about_point=ps_point.get_location() + 0.5 * RIGHT,\n",
        "            run_time=3,\n",
        "            rate_func=smooth,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_xy_line(self):\n",
        "        ps_point = self.ps_point\n",
        "        ps_point.save_state()\n",
        "        d1, d2 = self.point_to_ds(ps_point.get_location())\n",
        "\n",
        "        xy_line = self.d1_eq_d2_line\n",
        "        xy_label = self.d1_eq_d2_label\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(xy_line),\n",
        "            Write(xy_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ps_point.move_to, self.ds_to_point(d2, d2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        for d in [3, 7]:\n",
        "            self.play(\n",
        "                ps_point.move_to, self.ds_to_point(d, d),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(ps_point.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def let_process_play_out(self):\n",
        "        self.begin_sliding()\n",
        "        sliding_trajectory = self.get_continually_building_trajectory()\n",
        "        self.add(sliding_trajectory, self.ps_dot)\n",
        "        self.wait(self.slide_wait_time)\n",
        "\n",
        "    def show_w2_line(self):\n",
        "        line = self.d2_eq_w2_line\n",
        "        label = self.d2_eq_w2_label\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(FadeInFromDown(label))\n",
        "        self.wait(self.slide_wait_time)\n",
        "        self.end_sliding()\n",
        "        self.wait(self.slide_wait_time)\n",
        "\n",
        "\n",
        "class SpecialShowPassingFlash(ShowPassingFlash):\n",
        "    CONFIG = {\n",
        "        \"max_time_width\": 0.1,\n",
        "    }\n",
        "\n",
        "    def get_bounds(self, alpha):\n",
        "        tw = self.time_width\n",
        "        max_tw = self.max_time_width\n",
        "        upper = interpolate(0, 1 + max_tw, alpha)\n",
        "        lower = upper - tw\n",
        "        upper = min(upper, 1)\n",
        "        lower = max(lower, 0)\n",
        "        return (lower, upper)\n",
        "\n",
        "\n",
        "class EqualMassCase(PositionPhaseSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 1,\n",
        "            \"width\": 1,\n",
        "            \"velocity\": 1.5,\n",
        "        },\n",
        "        \"rescale_coordinates\": False,\n",
        "        \"d1_eq_d2_tex\": \"x = y\",\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.d1_eq_d2_label,\n",
        "            self.d2_eq_w2_line,\n",
        "            self.d2_eq_w2_label,\n",
        "            self.ps_dot,\n",
        "            self.x_line,\n",
        "            self.y_line,\n",
        "            self.ps_d1_label,\n",
        "            self.ps_d2_label,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_same_mass()\n",
        "        self.show_first_point()\n",
        "        self.up_to_first_collision()\n",
        "        self.up_to_second_collision()\n",
        "        self.up_to_third_collision()\n",
        "\n",
        "        self.fade_distance_indicators()\n",
        "        self.show_beam_bouncing()\n",
        "\n",
        "    def show_same_mass(self):\n",
        "        blocks = self.blocks\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, blocks,\n",
        "            lag_ratio=0.8,\n",
        "            run_time=1,\n",
        "        ))\n",
        "\n",
        "    def show_first_point(self):\n",
        "        ps_dot = self.ps_dot\n",
        "        ps_point = self.ps_point\n",
        "        d1, d2 = self.get_ds()\n",
        "\n",
        "        self.play(FocusOn(ps_dot))\n",
        "        self.play(ShowCreationThenFadeOut(\n",
        "            Circle(color=RED).replace(ps_dot).scale(2),\n",
        "            run_time=1\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ps_point.move_to, self.ds_to_point(d1 - 1, d2),\n",
        "            rate_func=wiggle,\n",
        "            run_time=3,\n",
        "        )\n",
        "        # self.play(ps_point.move_to, self.ds_to_point(d1, d2))\n",
        "        self.wait()\n",
        "\n",
        "    def up_to_first_collision(self):\n",
        "        ps_point = self.ps_point\n",
        "        d1, d2 = self.get_ds()\n",
        "        block1 = self.block1\n",
        "        block2 = self.block2\n",
        "        xy_line = self.d1_eq_d2_line\n",
        "        xy_line_label = self.d1_eq_d2_label\n",
        "\n",
        "        block_arrow = Vector(LEFT, color=RED)\n",
        "        block_arrow.block = block1\n",
        "        block_arrow.add_updater(\n",
        "            lambda m: m.shift(\n",
        "                m.block.get_center() - m.get_start()\n",
        "            )\n",
        "        )\n",
        "        ps_arrow = Vector(LEFT, color=RED)\n",
        "        ps_arrow.next_to(ps_point, DL, buff=SMALL_BUFF)\n",
        "\n",
        "        block_labels = VGroup(block1.label, block2.label)\n",
        "        block_label_copies = block_labels.copy()\n",
        "\n",
        "        def update_bl_copies(bl_copies):\n",
        "            for bc, b in zip(bl_copies, block_labels):\n",
        "                bc.move_to(b)\n",
        "        block_label_copies.add_updater(update_bl_copies)\n",
        "\n",
        "        trajectory = self.get_continually_building_trajectory()\n",
        "\n",
        "        self.add(block_arrow, ps_arrow, block_label_copies)\n",
        "        self.play(\n",
        "            GrowArrow(block_arrow),\n",
        "            GrowArrow(ps_arrow),\n",
        "        )\n",
        "        self.add(trajectory)\n",
        "        self.play(self.get_ps_point_change_anim(d2, d2))\n",
        "        block_arrow.block = block2\n",
        "        ps_arrow.rotate(90 * DEGREES)\n",
        "        ps_arrow.next_to(ps_point, DR, SMALL_BUFF)\n",
        "        self.add_sound(self.clack_sound)\n",
        "        self.play(\n",
        "            Flash(ps_point),\n",
        "            Flash(block1.get_left()),\n",
        "            self.get_ps_point_change_anim(d2, d2 - 1)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowPassingFlash(\n",
        "                xy_line.copy().set_stroke(YELLOW, 3)\n",
        "            ),\n",
        "            Indicate(xy_line_label),\n",
        "        )\n",
        "\n",
        "        trajectory.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "        self.ps_arrow = ps_arrow\n",
        "        self.block_arrow = block_arrow\n",
        "\n",
        "    def up_to_second_collision(self):\n",
        "        trajectory = self.trajectory\n",
        "        ps_point = self.ps_point\n",
        "        ps_arrow = self.ps_arrow\n",
        "        block_arrow = self.block_arrow\n",
        "\n",
        "        d1, d2 = self.get_ds()\n",
        "        w2 = self.block2.get_width()\n",
        "\n",
        "        trajectory.resume_updating()\n",
        "        self.play(self.get_ps_point_change_anim(d1, w2))\n",
        "        block_arrow.rotate(PI)\n",
        "        ps_arrow.rotate(PI)\n",
        "        ps_arrow.next_to(ps_point, UR, SMALL_BUFF)\n",
        "        self.add_sound(self.clack_sound)\n",
        "        self.play(\n",
        "            Flash(self.block2.get_left()),\n",
        "            Flash(ps_point),\n",
        "            self.get_ps_point_change_anim(d1, w2 + 1)\n",
        "        )\n",
        "\n",
        "        trajectory.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "    def up_to_third_collision(self):\n",
        "        trajectory = self.trajectory\n",
        "        ps_point = self.ps_point\n",
        "        ps_arrow = self.ps_arrow\n",
        "        block_arrow = self.block_arrow\n",
        "        d1, d2 = self.get_ds()\n",
        "\n",
        "        trajectory.resume_updating()\n",
        "        self.play(self.get_ps_point_change_anim(d1, d1))\n",
        "        block_arrow.block = self.block1\n",
        "        ps_arrow.rotate(-90 * DEGREES)\n",
        "        ps_arrow.next_to(ps_point, DR, SMALL_BUFF)\n",
        "        self.add_sound(self.clack_sound)\n",
        "        self.play(\n",
        "            Flash(self.block2.get_left()),\n",
        "            Flash(ps_point.get_location()),\n",
        "            self.get_ps_point_change_anim(d1 + 10, d1)\n",
        "        )\n",
        "        trajectory.suspend_updating()\n",
        "\n",
        "    def fade_distance_indicators(self):\n",
        "        trajectory = self.trajectory\n",
        "        self.play(\n",
        "            trajectory.set_stroke, {\"width\": 1},\n",
        "            *map(FadeOut, [\n",
        "                self.ps_arrow,\n",
        "                self.block_arrow,\n",
        "                self.x_line,\n",
        "                self.y_line,\n",
        "                self.ps_d1_label,\n",
        "                self.ps_d2_label,\n",
        "            ])\n",
        "        )\n",
        "        trajectory.clear_updaters()\n",
        "\n",
        "    def show_beam_bouncing(self):\n",
        "        d1, d2 = self.get_ds()\n",
        "        d1 = int(d1)\n",
        "        d2 = int(d2)\n",
        "        # w2 = self.block2.get_width()\n",
        "        ps_point = self.ps_point\n",
        "\n",
        "        points = []\n",
        "        while d1 > d2:\n",
        "            points.append(self.ds_to_point(d1, d2))\n",
        "            d1 -= 1\n",
        "        while d2 >= 1:\n",
        "            points.append(self.ds_to_point(d1, d2))\n",
        "            d2 -= 1\n",
        "        points += list(reversed(points))[1:]\n",
        "        trajectory = VMobject()\n",
        "        trajectory.set_points_as_corners(points)\n",
        "        flashes = [\n",
        "            SpecialShowPassingFlash(\n",
        "                trajectory.copy().set_stroke(YELLOW, width=6 - n),\n",
        "                time_width=(0.01 * n),\n",
        "                max_time_width=0.05,\n",
        "                remover=True\n",
        "            )\n",
        "            for n in np.arange(0, 6, 0.25)\n",
        "        ]\n",
        "        flash_mob = flashes[0].mobject  # Lol\n",
        "\n",
        "        def update_ps_point_from_flas_mob(ps_point):\n",
        "            if len(flash_mob.get_points()) > 0:\n",
        "                ps_point.move_to(flash_mob.get_points()[-1])\n",
        "            else:\n",
        "                ps_point.move_to(trajectory.get_points()[0])\n",
        "\n",
        "        # Mirror words\n",
        "        xy_line = self.d1_eq_d2_line\n",
        "        w2_line = self.d2_eq_w2_line\n",
        "        lines = VGroup(xy_line, w2_line)\n",
        "        for line in lines:\n",
        "            word = OldTexText(\"Mirror\")\n",
        "            word.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "            word.rotate(line.get_angle(), about_point=ORIGIN)\n",
        "            word.shift(line.get_center())\n",
        "            line.word = word\n",
        "\n",
        "        for line in lines:\n",
        "            line.set_stroke(GREY_B)\n",
        "            line.set_sheen(1, LEFT)\n",
        "            self.play(\n",
        "                Write(line.word),\n",
        "                line.set_sheen, 1, RIGHT,\n",
        "                line.set_stroke, {\"width\": 2},\n",
        "                run_time=1,\n",
        "            )\n",
        "\n",
        "        # TODO, clacks?\n",
        "        for x in range(3):\n",
        "            self.play(\n",
        "                UpdateFromFunc(\n",
        "                    ps_point,\n",
        "                    update_ps_point_from_flas_mob,\n",
        "                ),\n",
        "                *flashes,\n",
        "                run_time=3,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class FailedAngleRelation(PositionPhaseSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"distance\": 10,\n",
        "            \"velocity\": -1.5,\n",
        "        },\n",
        "        \"block2_config\": {\n",
        "            \"distance\": 5,\n",
        "        },\n",
        "        \"rescale_coordinates\": False,\n",
        "        \"trajectory_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "            self.ps_dot,\n",
        "            self.x_line,\n",
        "            self.y_line,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.d1_eq_d2_label,\n",
        "            self.d2_eq_w2_line,\n",
        "            self.d2_eq_w2_label,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_first_collision()\n",
        "        self.show_angles()\n",
        "\n",
        "    def show_first_collision(self):\n",
        "        self.slide_until(lambda: self.get_ds()[1] < 2)\n",
        "\n",
        "    def show_angles(self):\n",
        "        trajectory = self.trajectory\n",
        "        arcs = self.get_arcs(trajectory)\n",
        "        equation = self.get_word_equation()\n",
        "        equation.next_to(\n",
        "            trajectory.get_points()[0], UR, MED_SMALL_BUFF,\n",
        "            index_of_submobject_to_align=0,\n",
        "        )\n",
        "\n",
        "        for arc in arcs:\n",
        "            line = Line(ORIGIN, RIGHT)\n",
        "            line.set_stroke(WHITE, 2)\n",
        "            line.rotate(arc.start_angle)\n",
        "            line.shift(arc.arc_center - line.get_start())\n",
        "            arc.line = line\n",
        "\n",
        "        arc1, arc2 = arcs\n",
        "        arc1.arrow = Arrow(\n",
        "            equation[0].get_left(), arc1.get_right(),\n",
        "            buff=SMALL_BUFF,\n",
        "            color=WHITE,\n",
        "            path_arc=0,\n",
        "        )\n",
        "        arc2.arrow = Arrow(\n",
        "            equation[2].get_corner(DL),\n",
        "            arc2.get_left(),\n",
        "            path_arc=-120 * DEGREES,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        arc2.arrow.pointwise_become_partial(arc.arrow, 0, 0.95)\n",
        "\n",
        "        arc1.word = equation[0]\n",
        "        arc2.word = equation[1:]\n",
        "\n",
        "        for arc in arcs:\n",
        "            self.play(\n",
        "                FadeIn(arc.word, LEFT),\n",
        "                GrowArrow(arc.arrow, path_arc=arc.arrow.path_arc),\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(arc),\n",
        "                arc.line.rotate, arc.angle,\n",
        "                {\"about_point\": arc.line.get_start()},\n",
        "                UpdateFromAlphaFunc(\n",
        "                    arc.line,\n",
        "                    lambda m, a: m.set_stroke(\n",
        "                        opacity=(there_and_back(a)**0.5)\n",
        "                    )\n",
        "                ),\n",
        "            )\n",
        "\n",
        "    #\n",
        "    def get_arcs(self, trajectory):\n",
        "        p0, p1, p2 = trajectory.get_anchors()[1:4]\n",
        "        arc_config = {\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 2,\n",
        "            \"radius\": 0.5,\n",
        "            \"arc_center\": p1,\n",
        "        }\n",
        "        arc1 = Arc(\n",
        "            start_angle=0,\n",
        "            angle=45 * DEGREES,\n",
        "            **arc_config\n",
        "        )\n",
        "        a2_start = angle_of_vector(DL)\n",
        "        a2_angle = angle_between_vectors((p2 - p1), DL)\n",
        "        arc2 = Arc(\n",
        "            start_angle=a2_start,\n",
        "            angle=a2_angle,\n",
        "            **arc_config\n",
        "        )\n",
        "        return VGroup(arc1, arc2)\n",
        "\n",
        "    def get_word_equation(self):\n",
        "        result = VGroup(\n",
        "            OldTexText(\"Angle of incidence\"),\n",
        "            OldTex(\"\\\\ne\").rotate(90 * DEGREES),\n",
        "            OldTexText(\"Angle of reflection\")\n",
        "        )\n",
        "        result.arrange(DOWN)\n",
        "        result.set_stroke(BLACK, 5, background=True)\n",
        "        return result\n",
        "\n",
        "\n",
        "class UnscaledPositionPhaseSpaceMass10(FailedAngleRelation):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 10\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.slide(self.wait_time)\n",
        "\n",
        "\n",
        "class UnscaledPositionPhaseSpaceMass100(UnscaledPositionPhaseSpaceMass10):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 100\n",
        "        }\n",
        "    }\n",
        "\n",
        "\n",
        "class RescaleCoordinates(PositionPhaseSpaceScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"rescale_coordinates\": False,\n",
        "        \"ps_d2_label_vect\": LEFT,\n",
        "        \"axes_center\": 6 * LEFT + 0.65 * DOWN,\n",
        "        \"block1_config\": {\"distance\": 7},\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        PositionPhaseSpaceScene.setup(self)\n",
        "        MovingCameraScene.setup(self)\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.d1_eq_d2_label,\n",
        "            self.d2_eq_w2_line,\n",
        "            self.ps_dot,\n",
        "            self.x_line,\n",
        "            self.y_line,\n",
        "            self.ps_d1_label,\n",
        "            self.ps_d2_label,\n",
        "            self.d1_brace,\n",
        "            self.d2_brace,\n",
        "            self.d1_label,\n",
        "            self.d2_label,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_rescaling()\n",
        "        self.comment_on_ugliness()\n",
        "        self.put_into_frame()\n",
        "\n",
        "    def show_rescaling(self):\n",
        "        axes = self.axes\n",
        "        blocks = self.blocks\n",
        "        to_stretch = VGroup(\n",
        "            axes.added_lines,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.ps_point,\n",
        "        )\n",
        "        m1 = self.block1.mass\n",
        "        new_axes_labels = self.get_axes_labels(axes, with_sqrts=True)\n",
        "\n",
        "        # Show label\n",
        "        def show_label(index, block, vect):\n",
        "            self.play(\n",
        "                ShowCreationThenFadeAround(axes.labels[index])\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    axes.labels[index],\n",
        "                    VGroup(\n",
        "                        *new_axes_labels[index][:2],\n",
        "                        new_axes_labels[index][3]\n",
        "                    ),\n",
        "                ),\n",
        "                GrowFromCenter(new_axes_labels[index][2])\n",
        "            )\n",
        "            group = VGroup(\n",
        "                new_axes_labels[index][2][-2:].copy(),\n",
        "                OldTex(\"=\"),\n",
        "                block.label.copy(),\n",
        "            )\n",
        "            group.generate_target()\n",
        "            group.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            group.target.next_to(block, vect)\n",
        "            group[1].scale(0)\n",
        "            group[1].move_to(group.target[1])\n",
        "            group.target[2].set_fill(WHITE)\n",
        "            group.target[2].set_stroke(width=0, background=True)\n",
        "            self.play(MoveToTarget(\n",
        "                group,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                run_time=3\n",
        "            ))\n",
        "            self.remove(group)\n",
        "            self.wait()\n",
        "\n",
        "        show_label(0, self.block1, RIGHT)\n",
        "\n",
        "        # The stretch\n",
        "        blocks.suspend_updating()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                to_stretch.stretch, np.sqrt(m1), 0,\n",
        "                {\"about_point\": axes.coords_to_point(0, 0)},\n",
        "            ),\n",
        "            self.d1_eq_d2_label.shift, 6 * RIGHT,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.rescale_coordinates = True\n",
        "        blocks.resume_updating()\n",
        "        self.wait()\n",
        "\n",
        "        # Show wiggle\n",
        "        d1, d2 = self.get_ds()\n",
        "        for new_d1 in [d1 - 2, d1]:\n",
        "            self.play(self.get_ps_point_change_anim(\n",
        "                new_d1, d2,\n",
        "                rate_func=smooth,\n",
        "                run_time=2,\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        # Change y-coord\n",
        "        show_label(1, self.block2, LEFT)\n",
        "\n",
        "        axes.remove(axes.labels)\n",
        "        self.remove(axes.labels)\n",
        "        axes.labels = new_axes_labels\n",
        "        axes.add(axes.labels)\n",
        "        self.add(axes)\n",
        "\n",
        "    def comment_on_ugliness(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        randy = Randolph(height=1.7)\n",
        "        randy.flip()\n",
        "        randy.next_to(self.d2_eq_w2_line, UP, buff=0)\n",
        "        randy.to_edge(RIGHT)\n",
        "        randy.change(\"sassy\")\n",
        "        randy.save_state()\n",
        "        randy.fade(1)\n",
        "        randy.change(\"plain\")\n",
        "\n",
        "        self.play(Restore(randy))\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, \"Hideous!\",\n",
        "                bubble_config={\"height\": 1.5, \"width\": 2},\n",
        "                target_mode=\"angry\",\n",
        "                look_at=axes.labels[0]\n",
        "            )\n",
        "        )\n",
        "        self.play(randy.look_at, axes.labels[1])\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                randy, target_mode=\"confused\"\n",
        "            )\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look_at, axes.labels[0])\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "    def put_into_frame(self):\n",
        "        rect = ScreenRectangle(height=FRAME_HEIGHT + 10)\n",
        "        inner_rect = ScreenRectangle(height=FRAME_HEIGHT)\n",
        "        rect.add_subpath(inner_rect.get_points()[::-1])\n",
        "        rect.set_fill(\"#333333\", opacity=1)\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        self.begin_sliding()\n",
        "        self.add(rect)\n",
        "        self.play(\n",
        "            frame.scale, 1.5,\n",
        "            {\"about_point\": frame.get_bottom() + UP},\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(self.wait_time)\n",
        "        self.end_sliding()\n",
        "\n",
        "    #\n",
        "    def get_ds(self):\n",
        "        if self.rescale_coordinates:\n",
        "            return super().get_ds()\n",
        "        return (\n",
        "            self.block1_config[\"distance\"],\n",
        "            self.block2_config[\"distance\"],\n",
        "        )\n",
        "\n",
        "\n",
        "class RescaleCoordinatesMass16(RescaleCoordinates):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 16,\n",
        "            \"distance\": 10,\n",
        "        },\n",
        "        \"rescale_coordinates\": True,\n",
        "        \"wait_time\": 20,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.put_into_frame()\n",
        "\n",
        "\n",
        "class RescaleCoordinatesMass64(RescaleCoordinatesMass16):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 64,\n",
        "            \"distance\": 6,\n",
        "        },\n",
        "        \"block2_config\": {\"distance\": 3},\n",
        "    }\n",
        "\n",
        "\n",
        "class RescaleCoordinatesMass100(RescaleCoordinatesMass16):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 100,\n",
        "            \"distance\": 6,\n",
        "            \"velocity\": 0.5,\n",
        "        },\n",
        "        \"block2_config\": {\"distance\": 2},\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class IntroduceVelocityVector(PositionPhaseSpaceScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"zoom\": True,\n",
        "        \"ps_x_line_config\": {\n",
        "            \"color\": WHITE,\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "        },\n",
        "        \"ps_y_line_config\": {\n",
        "            \"color\": WHITE,\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_opacity\": 0.5,\n",
        "        },\n",
        "        \"axes_center\": 6 * LEFT + 0.65 * DOWN,\n",
        "        \"slide_time\": 20,\n",
        "        \"new_vect_config\": {\n",
        "            \"tip_length\": 0.1,\n",
        "            \"rectangular_stem_width\": 0.02,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        PositionPhaseSpaceScene.setup(self)\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.d1_eq_d2_label,\n",
        "            self.d2_eq_w2_line,\n",
        "            self.x_line,\n",
        "            self.y_line,\n",
        "            self.ps_dot,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_velocity_vector()\n",
        "        self.contrast_with_physical_velocities()\n",
        "        self.zoom_in_on_vector()\n",
        "        self.break_down_components()\n",
        "        self.zoom_out()\n",
        "        self.relate_x_dot_y_dot_to_v1_v2()\n",
        "        self.calculate_magnitude()\n",
        "        self.let_process_play_out()\n",
        "\n",
        "    def show_velocity_vector(self):\n",
        "        self.slide(2)\n",
        "        ps_vect = self.get_ps_velocity_vector(self.trajectory)\n",
        "        self.play(GrowArrow(ps_vect))\n",
        "        self.play(ShowCreationThenFadeAround(ps_vect))\n",
        "        self.wait()\n",
        "\n",
        "    def contrast_with_physical_velocities(self):\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        block_vectors = self.get_block_velocity_vectors(ps_vect)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, block_vectors))\n",
        "        self.play(Rotating(\n",
        "            ps_vect,\n",
        "            angle=TAU,\n",
        "            about_point=ps_vect.get_start(),\n",
        "            run_time=5,\n",
        "            rate_func=smooth,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.slide_until(lambda: self.get_d2() < 2.5)\n",
        "\n",
        "    def zoom_in_on_vector(self):\n",
        "        if not self.zoom:\n",
        "            self.wait(3)\n",
        "            return\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        new_vect = Arrow(\n",
        "            ps_vect.get_start(),\n",
        "            ps_vect.get_end(),\n",
        "            buff=0,\n",
        "            **self.new_vect_config\n",
        "        )\n",
        "        new_vect.match_style(ps_vect)\n",
        "\n",
        "        camera_frame = self.camera_frame\n",
        "        camera_frame.save_state()\n",
        "        point = self.ps_point.get_location()\n",
        "        point += MED_SMALL_BUFF * DOWN\n",
        "        self.play(\n",
        "            camera_frame.scale, 0.25, {\"about_point\": point},\n",
        "            Transform(ps_vect, new_vect),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def break_down_components(self):\n",
        "        # Create vectors\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        start = ps_vect.get_start()\n",
        "        end = ps_vect.get_end()\n",
        "        ul_corner = np.array(start)\n",
        "        dr_corner = np.array(start)\n",
        "        ul_corner[0] = end[0]\n",
        "        dr_corner[1] = end[1]\n",
        "\n",
        "        x_vect = Arrow(\n",
        "            start, ul_corner,\n",
        "            buff=0,\n",
        "            **self.new_vect_config\n",
        "        )\n",
        "        y_vect = Arrow(\n",
        "            start, dr_corner,\n",
        "            buff=0,\n",
        "            **self.new_vect_config\n",
        "        )\n",
        "        x_vect.set_fill(GREEN, opacity=0.75)\n",
        "        y_vect.set_fill(RED, opacity=0.75)\n",
        "        vects = VGroup(x_vect, y_vect)\n",
        "\n",
        "        # Projection lines\n",
        "        x_line, y_line = [\n",
        "            DashedLine(\n",
        "                ps_vect.get_end(),\n",
        "                vect.get_end(),\n",
        "                dash_length=0.01,\n",
        "                color=vect.get_color(),\n",
        "            )\n",
        "            for vect in (x_vect, y_vect)\n",
        "        ]\n",
        "        self.projection_lines = VGroup(x_line, y_line)\n",
        "\n",
        "        # Vector labels\n",
        "        dx_label = OldTex(\"\\\\frac{dx}{dt}\")\n",
        "        dy_label = OldTex(\"\\\\frac{dy}{dt}\")\n",
        "        labels = VGroup(dx_label, dy_label)\n",
        "        for label, arrow, direction in zip(labels, vects, [UP, RIGHT]):\n",
        "            label.scale(0.25)\n",
        "            buff = 0.25 * SMALL_BUFF\n",
        "            label.next_to(arrow, direction, buff=buff)\n",
        "        label.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        if not self.zoom:\n",
        "            self.grow_labels(labels)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(ps_vect, x_vect),\n",
        "            ShowCreation(x_line),\n",
        "        )\n",
        "        self.play(FadeIn(dx_label, 0.25 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(ps_vect, y_vect),\n",
        "            ShowCreation(y_line),\n",
        "        )\n",
        "        self.play(FadeIn(dy_label, 0.25 * LEFT))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about dx_dt\n",
        "        randy = Randolph()\n",
        "        randy.match_height(dx_label)\n",
        "        randy.next_to(dx_label, LEFT, SMALL_BUFF)\n",
        "        randy.change(\"confused\", dx_label)\n",
        "        randy.save_state()\n",
        "        randy.fade(1)\n",
        "        randy.change(\"plain\")\n",
        "\n",
        "        self.play(Restore(randy))\n",
        "        self.play(WiggleOutThenIn(dx_label))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        self.derivative_labels = labels\n",
        "        self.component_vectors = vects\n",
        "\n",
        "    def zoom_out(self):\n",
        "        if not self.zoom:\n",
        "            self.wait(2)\n",
        "            return\n",
        "        labels = self.derivative_labels\n",
        "        self.play(\n",
        "            Restore(self.camera_frame),\n",
        "            ApplyFunction(self.grow_labels, labels),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "    def relate_x_dot_y_dot_to_v1_v2(self):\n",
        "        derivative_labels = self.derivative_labels.copy()\n",
        "        dx_label, dy_label = derivative_labels\n",
        "        x_label, y_label = self.axes.labels\n",
        "        m_part = x_label[2]\n",
        "        block1 = self.block1\n",
        "        block_vectors = self.block_velocity_vectors\n",
        "\n",
        "        x_eq = x_label[1]\n",
        "        dx_eq = OldTex(\"=\")\n",
        "        dx_eq.next_to(\n",
        "            x_eq, DOWN,\n",
        "            buff=LARGE_BUFF,\n",
        "            aligned_edge=RIGHT,\n",
        "        )\n",
        "        for label in derivative_labels:\n",
        "            label.generate_target()\n",
        "            label.target.scale(1.5)\n",
        "        dx_label.target.next_to(dx_eq, LEFT)\n",
        "        dx_rhs = OldTex(\"\\\\sqrt{m_1}\", \"v_1\")\n",
        "        dx_rhs[0][2:].set_color(BLUE)\n",
        "        dx_rhs[1].set_color(GREEN)\n",
        "        dx_rhs.next_to(dx_eq, RIGHT)\n",
        "        alt_v1 = dx_rhs[1].copy()\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(x_label))\n",
        "        self.play(MoveToTarget(dx_label))\n",
        "        self.play(TransformFromCopy(x_eq, dx_eq))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(block1, m_part).shift, SMALL_BUFF * UP,\n",
        "            rate_func=wiggle,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.d1_brace.update()\n",
        "        self.d1_label.update()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(x_label[3]),\n",
        "            FadeIn(self.d1_brace),\n",
        "            FadeIn(self.d1_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(x_label[3], dx_rhs[1]),\n",
        "            TransformFromCopy(x_label[2], VGroup(dx_rhs[0])),\n",
        "        )\n",
        "        block_vectors.suspend_updating()\n",
        "        self.play(alt_v1.next_to, block_vectors[0], UP, SMALL_BUFF)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                block_vectors[0], 10 * DEGREES,\n",
        "                about_point=block_vectors[0].get_start(),\n",
        "                rate_func=wiggle,\n",
        "                run_time=1,\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeOut(alt_v1))\n",
        "        block_vectors.resume_updating()\n",
        "        self.wait()\n",
        "\n",
        "        # dy_label\n",
        "        y_eq = y_label[1]\n",
        "        dy_eq = OldTex(\"=\")\n",
        "        dy_eq.next_to(y_eq, DOWN, LARGE_BUFF)\n",
        "        dy_label.target.next_to(dy_eq, LEFT)\n",
        "        dy_rhs = OldTex(\"\\\\sqrt{m_2}\", \"v_2\")\n",
        "        dy_rhs[0][2:].set_color(BLUE)\n",
        "        dy_rhs[1].set_color(RED)\n",
        "        dy_rhs.next_to(dy_eq, RIGHT)\n",
        "        VGroup(dy_label.target, dy_eq, dy_rhs).align_to(y_label, LEFT)\n",
        "        alt_v2 = dy_rhs[1].copy()\n",
        "        self.play(MoveToTarget(dy_label))\n",
        "        self.play(\n",
        "            Write(dy_eq),\n",
        "            Write(dy_rhs),\n",
        "        )\n",
        "        self.play(alt_v2.next_to, block_vectors[1], UP, SMALL_BUFF)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(alt_v2))\n",
        "        self.wait()\n",
        "\n",
        "        self.derivative_equations = VGroup(\n",
        "            VGroup(dx_label, dx_eq, dx_rhs),\n",
        "            VGroup(dy_label, dy_eq, dy_rhs),\n",
        "        )\n",
        "\n",
        "    def calculate_magnitude(self):\n",
        "        corner_rect = Rectangle(\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=1,\n",
        "            height=2.5,\n",
        "            width=8.5,\n",
        "        )\n",
        "        corner_rect.to_corner(UR, buff=0)\n",
        "\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        big_ps_vect = Arrow(\n",
        "            ps_vect.get_start(), ps_vect.get_end(),\n",
        "            buff=0,\n",
        "        )\n",
        "        big_ps_vect.match_style(ps_vect)\n",
        "        big_ps_vect.scale(1.5)\n",
        "        magnitude_bars = OldTex(\"||\", \"||\")\n",
        "        magnitude_bars.match_height(\n",
        "            big_ps_vect, stretch=True\n",
        "        )\n",
        "        rhs_scale_val = 0.8\n",
        "        rhs = OldTex(\n",
        "            \"=\\\\sqrt{\"\n",
        "            \"\\\\left( dx/dt \\\\right)^2 + \"\n",
        "            \"\\\\left( dy/dt \\\\right)^2\"\n",
        "            \"}\"\n",
        "        )\n",
        "        rhs.scale(rhs_scale_val)\n",
        "        group = VGroup(\n",
        "            magnitude_bars[0], big_ps_vect,\n",
        "            magnitude_bars[1], rhs\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "        group.next_to(corner_rect.get_corner(UL), DR)\n",
        "\n",
        "        new_rhs = OldTex(\n",
        "            \"=\", \"\\\\sqrt\", \"{m_1(v_1)^2 + m_2(v_2)^2}\",\n",
        "            tex_to_color_map={\n",
        "                \"m_1\": BLUE,\n",
        "                \"m_2\": BLUE,\n",
        "                \"v_1\": GREEN,\n",
        "                \"v_2\": RED,\n",
        "            }\n",
        "        )\n",
        "        new_rhs.scale(rhs_scale_val)\n",
        "        new_rhs.next_to(rhs, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        final_rhs = OldTex(\n",
        "            \"=\", \"\\\\sqrt{2(\\\\text{Kinetic energy})}\"\n",
        "        )\n",
        "        final_rhs.scale(rhs_scale_val)\n",
        "        final_rhs.next_to(new_rhs, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(corner_rect),\n",
        "            TransformFromCopy(ps_vect, big_ps_vect)\n",
        "        )\n",
        "        self.play(Write(magnitude_bars), Write(rhs[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(rhs[1:]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(new_rhs, UP))\n",
        "        for equation in self.derivative_equations:\n",
        "            self.play(ShowCreationThenFadeAround(equation))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(final_rhs, UP))\n",
        "        self.wait()\n",
        "\n",
        "    def let_process_play_out(self):\n",
        "        self.play(*map(FadeOut, [\n",
        "            self.projection_lines,\n",
        "            self.derivative_labels,\n",
        "            self.component_vectors,\n",
        "            self.d1_brace,\n",
        "            self.d1_label,\n",
        "        ]))\n",
        "        self.add(self.blocks, self.derivative_equations)\n",
        "        self.blocks.resume_updating()\n",
        "        self.slide(self.slide_time)\n",
        "\n",
        "    #\n",
        "    def grow_labels(self, labels):\n",
        "        for label, vect in zip(labels, [DOWN, LEFT]):\n",
        "            p = label.get_edge_center(vect)\n",
        "            p += SMALL_BUFF * vect\n",
        "            label.scale(2.5, about_point=p)\n",
        "        return labels\n",
        "\n",
        "\n",
        "class IntroduceVelocityVectorWithoutZoom(IntroduceVelocityVector):\n",
        "    CONFIG = {\n",
        "        \"zoom\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowMomentumConservation(IntroduceVelocityVector):\n",
        "    CONFIG = {\n",
        "        \"ps_velocity_vector_length\": 1.25,\n",
        "        \"block_velocity_vector_length_multiple\": 1,\n",
        "        \"block1_config\": {\n",
        "            \"distance\": 7,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_max\": 11,\n",
        "        },\n",
        "        \"axes_center\": 6.5 * LEFT + 1.2 * DOWN,\n",
        "        \"floor_y\": -3.75,\n",
        "        \"wait_time\": 15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_velocity_vectors()\n",
        "        self.contrast_d1_d2_line_with_xy_line()\n",
        "        self.rearrange_for_slope()\n",
        "        self.up_to_first_collision()\n",
        "        self.ask_what_next()\n",
        "        self.show_conservation_of_momentum()\n",
        "        self.show_rate_of_change_vector()\n",
        "        self.show_sqrty_m_vector()\n",
        "        self.show_dot_product()\n",
        "        self.show_same_angles()\n",
        "        self.show_horizontal_bounce()\n",
        "        self.let_process_play_out()\n",
        "\n",
        "    def add_velocity_vectors(self):\n",
        "        self.slide(1)\n",
        "        self.ps_vect = self.get_ps_velocity_vector(self.trajectory)\n",
        "        self.block_vectors = self.get_block_velocity_vectors(self.ps_vect)\n",
        "        self.play(\n",
        "            GrowArrow(self.ps_vect),\n",
        "            LaggedStartMap(GrowArrow, self.block_vectors, run_time=1),\n",
        "        )\n",
        "        self.add(self.ps_vect, self.block_vectors)\n",
        "\n",
        "    def contrast_d1_d2_line_with_xy_line(self):\n",
        "        line = self.d1_eq_d2_line\n",
        "        label = self.d1_eq_d2_label\n",
        "        label.to_edge(RIGHT, buff=1.1)\n",
        "        label.shift(0.65 * DOWN)\n",
        "\n",
        "        xy_line = line.copy()\n",
        "        xy_line.set_stroke(YELLOW, 3)\n",
        "        xy_line.set_angle(45 * DEGREES)\n",
        "        xy_label = OldTex(\"x = y\")\n",
        "        xy_label.next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "        xy_label.rotate(45 * DEGREES, about_point=ORIGIN)\n",
        "        xy_label.shift(xy_line.point_from_proportion(0.2))\n",
        "        self.xy_group = VGroup(xy_line, xy_label)\n",
        "\n",
        "        self.play(\n",
        "            ShowPassingFlash(\n",
        "                line.copy().set_stroke(YELLOW, 4)\n",
        "            ),\n",
        "            Write(label),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(line, xy_line, run_time=2)\n",
        "        )\n",
        "        self.play(Write(xy_label))\n",
        "        self.wait()\n",
        "\n",
        "    def rearrange_for_slope(self):\n",
        "        eqs = VGroup(*reversed(self.axes.labels)).copy()\n",
        "        y_eq, x_eq = eqs\n",
        "        for eq in eqs:\n",
        "            point = VectorizedPoint(eq[1].get_center())\n",
        "            eq.submobjects.insert(1, point)\n",
        "            eq.submobjects[3] = eq[3].submobjects[0]\n",
        "            eq.generate_target()\n",
        "        eqs_targets = VGroup(*[eq.target for eq in eqs])\n",
        "\n",
        "        new_eqs = VGroup(\n",
        "            OldTex(\"{y\", \"\\\\over\", \"\\\\sqrt{m_2}}\", \"=\", \"d_2\"),\n",
        "            OldTex(\"{x\", \"\\\\over\", \"\\\\sqrt{m_1}}\", \"=\", \"d_1\"),\n",
        "        )\n",
        "        new_x_eq, new_y_eq = new_eqs\n",
        "        # Shuffle to align with x_eq and y_eq\n",
        "        for new_eq in new_eqs:\n",
        "            new_eq[2][2:].set_color(BLUE)\n",
        "            new_eq.submobjects = [new_eq[i] for i in [0, 1, 3, 2, 4]]\n",
        "\n",
        "        eqs_targets.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        eqs_targets.move_to(RIGHT).to_edge(UP)\n",
        "        for eq, new_eq in zip(eqs_targets, new_eqs):\n",
        "            new_eq.move_to(eq)\n",
        "\n",
        "        self.play(LaggedStartMap(MoveToTarget, eqs, lag_ratio=0.7))\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                eq, new_eq,\n",
        "                path_arc=-90 * DEGREES,\n",
        "            )\n",
        "            for eq, new_eq in zip(eqs, new_eqs)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        # Shuffle back\n",
        "        for eq in eqs:\n",
        "            eq[2][2:].set_color(BLUE)\n",
        "            eq.submobjects = [eq[i] for i in [0, 1, 3, 2, 4]]\n",
        "\n",
        "        # Set equal\n",
        "        equals = OldTex(\"=\")\n",
        "        for eq in eqs:\n",
        "            eq.generate_target()\n",
        "        VGroup(\n",
        "            x_eq.target[4],\n",
        "            x_eq.target[3],\n",
        "            x_eq.target[:3],\n",
        "        ).arrange(RIGHT)\n",
        "        for p1, p2 in zip(x_eq, x_eq.target):\n",
        "            p2.align_to(p1, DOWN)\n",
        "        group = VGroup(y_eq.target, equals, x_eq.target)\n",
        "        group.arrange(RIGHT)\n",
        "        x_eq.target.align_to(y_eq.target, DOWN)\n",
        "        equals.align_to(y_eq.target[3], DOWN)\n",
        "        group.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        group.to_edge(RIGHT, buff=3)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(y_eq),\n",
        "            MoveToTarget(x_eq, path_arc=90 * DEGREES),\n",
        "            GrowFromCenter(equals)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Simplify\n",
        "        final_eq = OldTex(\n",
        "            \"y\", \"=\",\n",
        "            \"{\\\\sqrt{m_2}\", \"\\\\over\", \"\\\\sqrt{m_1}}\",\n",
        "            \"x\",\n",
        "        )\n",
        "        for part in final_eq.get_parts_by_tex(\"sqrt\"):\n",
        "            part[2:].set_color(BLUE)\n",
        "        m_part = final_eq[2:5]\n",
        "\n",
        "        final_eq.next_to(group, DOWN)\n",
        "        final_eq.shift(0.4 * UP)\n",
        "        movers = VGroup(\n",
        "            y_eq[0], equals.submobjects[0],\n",
        "            y_eq[2], y_eq[1], x_eq[2],\n",
        "            x_eq[0]\n",
        "        ).copy()\n",
        "        for mover, part in zip(movers, final_eq):\n",
        "            mover.target = part\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, movers,\n",
        "                path_arc=30 * DEGREES,\n",
        "                lag_ratio=0.9\n",
        "            ),\n",
        "            VGroup(x_eq, equals, y_eq).scale,\n",
        "            0.7, {\"about_edge\": UP},\n",
        "        )\n",
        "        self.remove(movers)\n",
        "        self.add(final_eq)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight slope\n",
        "        flash_line = self.d1_eq_d2_line.copy()\n",
        "        flash_line.set_stroke(YELLOW, 5)\n",
        "        self.play(ShowPassingFlash(flash_line))\n",
        "        self.play(ShowCreationThenFadeAround(m_part))\n",
        "        self.wait()\n",
        "\n",
        "        # Tuck away slope in mind\n",
        "        slope = m_part.copy()\n",
        "        slope.generate_target()\n",
        "        randy = Randolph(height=1.5)\n",
        "        randy.next_to(final_eq, LEFT, MED_SMALL_BUFF)\n",
        "        randy.align_to(self.d2_eq_w2_line, DOWN)\n",
        "        bubble = ThoughtBubble(\n",
        "            height=1.3, width=1.3, direction=RIGHT,\n",
        "        )\n",
        "        bubble.pin_to(randy)\n",
        "        slope.target.scale(0.5)\n",
        "        slope.target.move_to(bubble.get_bubble_center())\n",
        "        randy.change(\"pondering\", slope.target)\n",
        "        randy.save_state()\n",
        "        randy.change(\"plane\")\n",
        "        randy.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            Restore(randy),\n",
        "            Write(bubble),\n",
        "            MoveToTarget(slope)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        self.thinking_on_slope_group = VGroup(\n",
        "            randy, bubble, slope,\n",
        "        )\n",
        "\n",
        "        self.to_fade = VGroup(\n",
        "            eqs, equals, final_eq,\n",
        "            self.thinking_on_slope_group,\n",
        "            self.xy_group,\n",
        "        )\n",
        "\n",
        "    def up_to_first_collision(self):\n",
        "        self.begin_sliding()\n",
        "        self.play(FadeOut(self.to_fade))\n",
        "        self.wait_until(\n",
        "            lambda: abs(self.ps_velocity_vector.get_vector()[1]) > 0.01\n",
        "        )\n",
        "        self.end_sliding()\n",
        "        self.wait(3 + 3 / 60)  # Final cut reasons\n",
        "\n",
        "    def ask_what_next(self):\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        question = OldTexText(\"What next?\")\n",
        "        question.set_background_stroke(color=BLACK, width=3)\n",
        "        question.next_to(self.ps_point, UP)\n",
        "\n",
        "        self.play(FadeIn(question, DOWN))\n",
        "        ps_vect.suspend_updating()\n",
        "        angles = [0.75 * PI, -0.5 * PI, -0.25 * PI]\n",
        "        for last_angle, angle in zip(np.cumsum([0] + angles), angles):\n",
        "            # This is dumb and shouldn't be needed\n",
        "            ps_vect.rotate(last_angle, about_point=ps_vect.get_start())\n",
        "            target = ps_vect.copy()\n",
        "            target.rotate(\n",
        "                angle,\n",
        "                about_point=ps_vect.get_start()\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    ps_vect, target,\n",
        "                    path_arc=angle\n",
        "                ),\n",
        "            )\n",
        "        ps_vect.resume_updating()\n",
        "\n",
        "        self.whats_next_question = question\n",
        "\n",
        "    def show_conservation_of_momentum(self):\n",
        "        equation = self.get_momentum_equation()\n",
        "\n",
        "        # Main equation\n",
        "        self.play(FadeInFromDown(equation))\n",
        "        for part in equation[:2], equation[3:5]:\n",
        "            outline = part.copy()\n",
        "            outline.set_fill(opacity=0)\n",
        "            outline.set_stroke(YELLOW, 3)\n",
        "            self.play(ShowPassingFlash(\n",
        "                outline,\n",
        "                run_time=1.5\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Dot product\n",
        "        dot_product = self.get_dot_product()\n",
        "        dot_product.next_to(equation, DOWN)\n",
        "        sqrty_m_array = dot_product[0]\n",
        "\n",
        "        x_label, y_label = self.axes.labels\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.whats_next_question),\n",
        "            FadeIn(dot_product),\n",
        "            Transform(\n",
        "                x_label[2].copy(),\n",
        "                sqrty_m_array.get_entries()[0],\n",
        "                remover=True,\n",
        "            ),\n",
        "            Transform(\n",
        "                y_label[2].copy(),\n",
        "                sqrty_m_array.get_entries()[1],\n",
        "                remover=True,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        self.momentum_equation = equation\n",
        "        self.dot_product = dot_product\n",
        "\n",
        "    def show_rate_of_change_vector(self):\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        original_d_array = self.dot_product[2]\n",
        "\n",
        "        d_array = original_d_array.copy()\n",
        "        d_array.generate_target()\n",
        "        d_array.scale(0.75)\n",
        "        d_array.add_updater(lambda m: m.next_to(\n",
        "            ps_vect.get_end(),\n",
        "            np.sign(ps_vect.get_vector()[0]) * RIGHT,\n",
        "            SMALL_BUFF\n",
        "        ))\n",
        "\n",
        "        self.play(TransformFromCopy(original_d_array, d_array))\n",
        "        self.wait()\n",
        "\n",
        "        self.d_array = d_array\n",
        "\n",
        "    def show_sqrty_m_vector(self):\n",
        "        original_sqrty_m_array = self.dot_product[0]\n",
        "        sqrty_m_vector = Arrow(\n",
        "            self.ds_to_point(0, 0),\n",
        "            # self.ds_to_point(1, 1),\n",
        "            self.ds_to_point(2, 2),\n",
        "            buff=0,\n",
        "            color=YELLOW,\n",
        "        )\n",
        "\n",
        "        sqrty_m_array = original_sqrty_m_array.deepcopy()\n",
        "        sqrty_m_array.scale(0.75)\n",
        "        sqrty_m_array.next_to(\n",
        "            sqrty_m_vector.get_end(), UP, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        rise = DashedLine(\n",
        "            sqrty_m_vector.get_end(),\n",
        "            sqrty_m_vector.get_corner(DR),\n",
        "            color=RED,\n",
        "        )\n",
        "        run = DashedLine(\n",
        "            sqrty_m_vector.get_corner(DR),\n",
        "            sqrty_m_vector.get_start(),\n",
        "            color=GREEN,\n",
        "        )\n",
        "        sqrty_m_array.add_background_to_entries()\n",
        "        run_label, rise_label = sqrty_m_array.get_entries().copy()\n",
        "        rise_label.next_to(rise, RIGHT, SMALL_BUFF)\n",
        "        run_label.next_to(run, DOWN, SMALL_BUFF)\n",
        "\n",
        "        randy_group = self.thinking_on_slope_group\n",
        "        randy_group.align_to(self.d2_eq_w2_line, DOWN)\n",
        "        randy_group.to_edge(LEFT)\n",
        "        randy_group.shift(2 * RIGHT)\n",
        "\n",
        "        self.play(GrowArrow(sqrty_m_vector))\n",
        "        self.play(TransformFromCopy(\n",
        "            original_sqrty_m_array, sqrty_m_array,\n",
        "        ))\n",
        "        self.play(FadeIn(randy_group))\n",
        "        self.play(\n",
        "            ShowCreation(rise),\n",
        "            TransformFromCopy(\n",
        "                sqrty_m_array.get_entries()[1],\n",
        "                rise_label,\n",
        "            ),\n",
        "        )\n",
        "        self.add(run, randy_group)\n",
        "        self.play(\n",
        "            ShowCreation(run),\n",
        "            TransformFromCopy(\n",
        "                sqrty_m_array.get_entries()[0],\n",
        "                run_label,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy_group))\n",
        "        self.play(FadeOut(VGroup(\n",
        "            rise, run, rise_label, run_label,\n",
        "        )))\n",
        "\n",
        "        # move to ps_point\n",
        "        point = self.ps_point.get_location()\n",
        "        sqrty_m_vector.generate_target()\n",
        "        sqrty_m_vector.target.shift(\n",
        "            point - sqrty_m_vector.get_start()\n",
        "        )\n",
        "        sqrty_m_array.generate_target()\n",
        "        sqrty_m_array.target.next_to(\n",
        "            sqrty_m_vector.target.get_end(),\n",
        "            RIGHT, SMALL_BUFF,\n",
        "        )\n",
        "        sqrty_m_array.target.shift(SMALL_BUFF * UP)\n",
        "        self.play(\n",
        "            MoveToTarget(sqrty_m_vector),\n",
        "            MoveToTarget(sqrty_m_array),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        self.sqrty_m_vector = sqrty_m_vector\n",
        "        self.sqrty_m_array = sqrty_m_array\n",
        "\n",
        "    def show_dot_product(self):\n",
        "        # Highlight arrays\n",
        "        d_array = self.d_array\n",
        "        big_d_array = self.dot_product[2]\n",
        "        m_array = self.sqrty_m_array\n",
        "        big_m_array = self.dot_product[0]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(big_d_array),\n",
        "            ShowCreationThenFadeAround(d_array),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(big_m_array),\n",
        "            ShowCreationThenFadeAround(m_array),\n",
        "        )\n",
        "\n",
        "        # Before and after\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        theta = np.arctan(np.sqrt(self.block2.mass / self.block1.mass))\n",
        "        self.theta = theta\n",
        "\n",
        "        ps_vect.suspend_updating()\n",
        "        kwargs = {\"about_point\": ps_vect.get_start()}\n",
        "        for x in range(2):\n",
        "            for u in [-1, 1]:\n",
        "                ps_vect.rotate(u * 2 * theta, **kwargs)\n",
        "                self.update_mobjects(dt=0)\n",
        "                self.wait()\n",
        "        ps_vect.resume_updating()\n",
        "\n",
        "        # Circle\n",
        "        circle = Circle(\n",
        "            radius=ps_vect.get_length(),\n",
        "            arc_center=ps_vect.get_start(),\n",
        "            color=RED,\n",
        "            stroke_width=1,\n",
        "        )\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                ps_vect,\n",
        "                about_point=ps_vect.get_start(),\n",
        "                run_time=5,\n",
        "                rate_func=lambda t: smooth(t, 3),\n",
        "            ),\n",
        "            FadeIn(circle),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ps_vect_circle = circle\n",
        "\n",
        "    def show_same_angles(self):\n",
        "        # circle = self.ps_vect_circle\n",
        "        ps_vect = self.ps_velocity_vector\n",
        "        ps_point = self.ps_point\n",
        "        point = ps_point.get_center()\n",
        "        ghost_ps_vect = ps_vect.copy()\n",
        "        ghost_ps_vect.clear_updaters()\n",
        "        ghost_ps_vect.set_fill(opacity=0.5)\n",
        "        theta = self.theta\n",
        "        ghost_ps_vect.rotate(\n",
        "            -2 * theta,\n",
        "            about_point=ghost_ps_vect.get_start(),\n",
        "        )\n",
        "\n",
        "        arc1 = Arc(\n",
        "            start_angle=PI,\n",
        "            angle=theta,\n",
        "            arc_center=point,\n",
        "            radius=0.5,\n",
        "            color=WHITE,\n",
        "        )\n",
        "        arc2 = arc1.copy()\n",
        "        arc2.rotate(theta, about_point=point)\n",
        "        arc3 = arc1.copy()\n",
        "        arc3.rotate(PI, about_point=point)\n",
        "        arc1.set_color(BLUE)\n",
        "\n",
        "        line_pair = VGroup(*[\n",
        "            Line(point, point + LEFT).rotate(\n",
        "                angle, about_point=point\n",
        "            )\n",
        "            for angle in [0, theta]\n",
        "        ])\n",
        "        line_pair.set_stroke(width=0)\n",
        "\n",
        "        ps_vect.suspend_updating()\n",
        "        self.play(\n",
        "            ShowCreation(arc1),\n",
        "            FadeIn(ghost_ps_vect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(ps_vect, 2 * theta, about_point=point)\n",
        "        )\n",
        "        self.begin_sliding()\n",
        "        ps_vect.resume_updating()\n",
        "        self.play(GrowFromPoint(arc2, point))\n",
        "        self.wait(0.5)\n",
        "        self.end_sliding()\n",
        "        self.play(\n",
        "            TransformFromCopy(arc1, arc3, path_arc=-PI),\n",
        "            Rotate(line_pair, -PI, about_point=point),\n",
        "            UpdateFromAlphaFunc(\n",
        "                line_pair, lambda m, a: m.set_stroke(\n",
        "                    width=there_and_back(a)**0.5\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "        # Show light beam along trajectory\n",
        "        self.show_trajectory_beam_bounce()\n",
        "        self.wait()\n",
        "\n",
        "        # TODO: Add labels for angles?\n",
        "\n",
        "        self.play(FadeOut(VGroup(\n",
        "            self.ps_vect_circle, ghost_ps_vect, arc1\n",
        "        )))\n",
        "\n",
        "    def show_horizontal_bounce(self):\n",
        "        self.slide_until(\n",
        "            lambda: self.ps_velocity_vector.get_vector()[1] > 0\n",
        "        )\n",
        "        point = self.ps_point.get_location()\n",
        "        theta = self.theta\n",
        "        arc1 = Arc(\n",
        "            start_angle=0,\n",
        "            angle=2 * theta,\n",
        "            radius=0.5,\n",
        "            arc_center=point,\n",
        "        )\n",
        "        arc2 = arc1.copy()\n",
        "        arc2.rotate(PI - 2 * theta, about_point=point)\n",
        "        arcs = VGroup(arc1, arc2)\n",
        "\n",
        "        self.slide(0.5)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, arcs,\n",
        "            lag_ratio=0.75,\n",
        "        ))\n",
        "        self.show_trajectory_beam_bounce()\n",
        "\n",
        "    def let_process_play_out(self):\n",
        "        self.slide(self.wait_time)\n",
        "        self.wait(10)  # Just to be sure...\n",
        "\n",
        "    #\n",
        "    def show_trajectory_beam_bounce(self, n_times=2):\n",
        "        # Show light beam along trajectory\n",
        "        beam = self.trajectory.copy()\n",
        "        beam.clear_updaters()\n",
        "        beam.set_stroke(YELLOW, 3)\n",
        "        for x in range(n_times):\n",
        "            self.play(ShowPassingFlash(\n",
        "                beam,\n",
        "                run_time=2,\n",
        "                rate_func=bezier([0, 0, 1, 1])\n",
        "            ))\n",
        "\n",
        "    def get_momentum_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"m_1\", \"v_1\", \"+\", \"m_2\", \"v_2\",\n",
        "            \"=\", \"\\\\text{const.}\",\n",
        "            tex_to_color_map={\n",
        "                \"m_1\": BLUE,\n",
        "                \"m_2\": BLUE,\n",
        "                \"v_1\": RED,\n",
        "                \"v_2\": RED,\n",
        "            }\n",
        "        )\n",
        "        equation.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        return equation\n",
        "\n",
        "    def get_dot_product(self,\n",
        "                        m1=\"\\\\sqrt{m_1}\", m2=\"\\\\sqrt{m_2}\",\n",
        "                        d1=\"dx/dt\", d2=\"dy/dt\"):\n",
        "        sqrty_m = Matrix([[m1], [m2]])\n",
        "        deriv_array = Matrix([[d1], [d2]])\n",
        "        for entry in sqrty_m.get_entries():\n",
        "            if \"sqrt\" in entry.get_tex():\n",
        "                entry[2:].set_color(BLUE)\n",
        "        for matrix in sqrty_m, deriv_array:\n",
        "            matrix.add_to_back(BackgroundRectangle(matrix))\n",
        "            matrix.get_brackets().scale(0.9)\n",
        "            matrix.set_height(1.25)\n",
        "        dot = OldTex(\"\\\\cdot\")\n",
        "        rhs = OldTex(\"= \\\\text{const.}\")\n",
        "        dot_product = VGroup(\n",
        "            sqrty_m, dot, deriv_array, rhs\n",
        "        )\n",
        "        dot_product.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        return dot_product\n",
        "\n",
        "\n",
        "class JustTheProcessNew(PositionPhaseSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 16,\n",
        "            \"velocity\": -2\n",
        "        },\n",
        "        \"wait_time\": 10,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add(\n",
        "            self.floor,\n",
        "            self.wall,\n",
        "            self.blocks,\n",
        "            self.axes,\n",
        "            self.d1_eq_d2_line,\n",
        "            self.d2_eq_w2_line,\n",
        "        )\n",
        "\n",
        "    def construct(self):\n",
        "        self.slide(self.wait_time)\n"
    ]
}