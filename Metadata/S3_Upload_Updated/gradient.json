{
    "topic": "The mathematical concept being demonstrated is the gradient descent algorithm, specifically the visualization of how it works for",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "# Warning, this file uses ContinualChangingDecimal,\n",
        "# which has since been been deprecated.  Use a mobject\n",
        "# updater instead\n",
        "\n",
        "\n",
        "class GradientDescentWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Gradient descent\")\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowSimpleMultivariableFunction(Scene):\n",
        "    def construct(self):\n",
        "        scale_val = 1.5\n",
        "\n",
        "        func_tex = OldTex(\n",
        "            \"C(\", \"x_1,\", \"x_2,\", \"\\\\dots,\", \"x_n\", \")\", \"=\",\n",
        "        )\n",
        "        func_tex.scale(scale_val)\n",
        "        func_tex.shift(2 * LEFT)\n",
        "        alt_func_tex = OldTex(\n",
        "            \"C(\", \"x,\", \"y\", \")\", \"=\"\n",
        "        )\n",
        "        alt_func_tex.scale(scale_val)\n",
        "        for tex in func_tex, alt_func_tex:\n",
        "            tex.set_color_by_tex_to_color_map({\n",
        "                \"C(\": RED,\n",
        "                \")\": RED,\n",
        "            })\n",
        "        alt_func_tex.move_to(func_tex, RIGHT)\n",
        "        inputs = func_tex[1:-2]\n",
        "        self.add(func_tex)\n",
        "\n",
        "        many_inputs = OldTex(*[\n",
        "            \"x_{%d}, \" % d for d in range(1, 25)\n",
        "        ])\n",
        "        many_inputs.set_width(FRAME_WIDTH)\n",
        "        many_inputs.to_edge(UL)\n",
        "\n",
        "        inputs_brace = Brace(inputs, UP)\n",
        "        inputs_brace_text = inputs_brace.get_text(\"Multiple inputs\")\n",
        "\n",
        "        decimal = DecimalNumber(0)\n",
        "        decimal.scale(scale_val)\n",
        "        decimal.next_to(tex, RIGHT)\n",
        "        value_tracker = ValueTracker(0)\n",
        "        always_shift(value_tracker, rate=0.5)\n",
        "        self.add(value_tracker)\n",
        "        decimal_change = ContinualChangingDecimal(\n",
        "            decimal,\n",
        "            lambda a: 1 + np.sin(value_tracker.get_value())\n",
        "        )\n",
        "        self.add(decimal_change)\n",
        "\n",
        "        output_brace = Brace(decimal, DOWN)\n",
        "        output_brace_text = output_brace.get_text(\"Single output\")\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(GrowFromCenter(inputs_brace))\n",
        "        self.play(Write(inputs_brace_text))\n",
        "        self.play(GrowFromCenter(output_brace))\n",
        "        self.play(Write(output_brace_text))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                inputs,\n",
        "                many_inputs[:len(inputs)]\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn,\n",
        "                many_inputs[len(inputs):]\n",
        "            ),\n",
        "            FadeOut(inputs_brace),\n",
        "            FadeOut(inputs_brace_text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                func_tex[0], alt_func_tex[0]\n",
        "            ),\n",
        "            Write(alt_func_tex[1:3]),\n",
        "            LaggedStartMap(FadeOutAndShiftDown, many_inputs)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShowGraphWithVectors(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowFunction(Scene):\n",
        "    def construct(self):\n",
        "        func = OldTex(\n",
        "            \"f(x, y) = e^{-x^2 + \\\\cos(2y)}\",\n",
        "            tex_to_color_map={\n",
        "                \"x\": BLUE,\n",
        "                \"y\": RED,\n",
        "            }\n",
        "        )\n",
        "        func.scale(1.5)\n",
        "        self.play(FadeInFromDown(func))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowExampleFunctionGraph(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ShowGradient(Scene):\n",
        "    def construct(self):\n",
        "        lhs = OldTex(\n",
        "            \"\\\\nabla f(x, y)=\",\n",
        "            tex_to_color_map={\"x\": BLUE, \"y\": RED}\n",
        "        )\n",
        "        vector = Matrix([\n",
        "            [\"\\\\partial f / \\\\partial x\"],\n",
        "            [\"\\\\partial f / \\\\partial y\"],\n",
        "        ], v_buff=1)\n",
        "        gradient = VGroup(lhs, vector)\n",
        "        gradient.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        gradient.scale(1.5)\n",
        "\n",
        "        del_x, del_y = partials = vector.get_entries()\n",
        "        background_rects = VGroup()\n",
        "        for partial, color in zip(partials, [BLUE, RED]):\n",
        "            partial[-1].set_color(color)\n",
        "            partial.rect = SurroundingRectangle(\n",
        "                partial, buff=MED_SMALL_BUFF\n",
        "            )\n",
        "            partial.rect.set_stroke(width=0)\n",
        "            partial.rect.set_fill(color=color, opacity=0.5)\n",
        "            background_rects.add(partial.rect.copy())\n",
        "        background_rects.set_fill(opacity=0.1)\n",
        "\n",
        "        partials.set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, gradient),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, background_rects,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for partial in partials:\n",
        "            self.play(DrawBorderThenFill(partial.rect))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(partial.rect))\n",
        "        self.wait()\n",
        "        for partial in partials:\n",
        "            self.play(Write(partial))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ExampleGraphHoldXConstant(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ExampleGraphHoldYConstant(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TakePartialDerivatives(Scene):\n",
        "    def construct(self):\n",
        "        tex_to_color_map = {\n",
        "            \"x\": BLUE,\n",
        "            \"y\": RED,\n",
        "        }\n",
        "        func_tex = OldTex(\n",
        "            \"f\", \"(\", \"x\", \",\", \"y\", \")\", \"=\",\n",
        "            \"e^{\", \"-x^2\", \"+ \\\\cos(2y)}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        partial_x = OldTex(\n",
        "            \"{\\\\partial\", \"f\", \"\\\\over\", \"\\\\partial\", \"x}\", \"=\",\n",
        "            \"\\\\left(\", \"e^\", \"{-x^2\", \"+ \\\\cos(2y)}\", \"\\\\right)\",\n",
        "            \"(\", \"-2\", \"x\", \")\",\n",
        "            tex_to_color_map=tex_to_color_map,\n",
        "        )\n",
        "        partial_y = OldTex(\n",
        "            \"{\\\\partial\", \"f\", \"\\\\over\", \"\\\\partial\", \"y}\", \"=\",\n",
        "            \"\\\\left(\", \"e^\", \"{-x^2\", \"+ \\\\cos(\", \"2\", \"y)}\", \"\\\\right)\",\n",
        "            \"(\", \"-\\\\sin(\", \"2\", \"y)\", \"\\\\cdot 2\", \")\",\n",
        "            tex_to_color_map=tex_to_color_map,\n",
        "        )\n",
        "        partials = VGroup(partial_x, partial_y)\n",
        "        for mob in func_tex, partials:\n",
        "            mob.scale(1.5)\n",
        "\n",
        "        func_tex.move_to(2 * UP + 3 * LEFT)\n",
        "        for partial in partials:\n",
        "            partial.next_to(func_tex, DOWN, buff=LARGE_BUFF)\n",
        "            top_eq_x = func_tex.get_part_by_tex(\"=\").get_center()[0]\n",
        "            low_eq_x = partial.get_part_by_tex(\"=\").get_center()[0]\n",
        "            partial.shift((top_eq_x - low_eq_x) * RIGHT)\n",
        "\n",
        "        index = func_tex.index_of_part_by_tex(\"e^\")\n",
        "        exp_rect = SurroundingRectangle(func_tex[index + 1:], buff=0)\n",
        "        exp_rect.set_stroke(width=0)\n",
        "        exp_rect.set_fill(GREEN, opacity=0.5)\n",
        "\n",
        "        xs = func_tex.get_parts_by_tex(\"x\", substring=False)\n",
        "        ys = func_tex.get_parts_by_tex(\"y\", substring=False)\n",
        "        for terms in xs, ys:\n",
        "            terms.rects = VGroup(*[\n",
        "                SurroundingRectangle(term, buff=0.5 * SMALL_BUFF)\n",
        "                for term in terms\n",
        "            ])\n",
        "            terms.arrows = VGroup(*[\n",
        "                Vector(0.5 * DOWN).next_to(rect, UP, SMALL_BUFF)\n",
        "                for rect in terms.rects\n",
        "            ])\n",
        "        treat_as_constant = OldTexText(\"Treat as a constant\")\n",
        "        treat_as_constant.next_to(ys.arrows[1], UP)\n",
        "\n",
        "        # Start to show partial_x\n",
        "        self.play(FadeInFromDown(func_tex))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(func_tex[0].copy(), partial_x[1]),\n",
        "            Write(partial_x[0]),\n",
        "            Write(partial_x[2:4]),\n",
        "            Write(partial_x[6]),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(func_tex[2].copy(), partial_x[4])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label y as constant\n",
        "        self.play(LaggedStartMap(ShowCreation, ys.rects))\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, ys.arrows, lag_ratio=0.8),\n",
        "            Write(treat_as_constant)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Perform partial_x derivative\n",
        "        self.play(FadeIn(exp_rect), Animation(func_tex))\n",
        "        self.wait()\n",
        "        pxi1 = 8\n",
        "        pxi2 = 15\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                func_tex[7:].copy(),\n",
        "                partial_x[pxi1:pxi2],\n",
        "            ),\n",
        "            FadeIn(partial_x[pxi1 - 1:pxi1]),\n",
        "            FadeIn(partial_x[pxi2]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                partial_x[10:12].copy(),\n",
        "                partial_x[pxi2 + 2:pxi2 + 4],\n",
        "                path_arc=-(TAU / 4)\n",
        "            ),\n",
        "            FadeIn(partial_x[pxi2 + 1]),\n",
        "            FadeIn(partial_x[-1]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Swap out partial_x for partial_y\n",
        "        self.play(\n",
        "            FadeOutAndShiftDown(partial_x),\n",
        "            FadeOut(ys.rects),\n",
        "            FadeOut(ys.arrows),\n",
        "            FadeOut(treat_as_constant),\n",
        "            FadeOut(exp_rect),\n",
        "            Animation(func_tex)\n",
        "        )\n",
        "        self.play(FadeInFromDown(partial_y[:7]))\n",
        "        self.wait()\n",
        "\n",
        "        treat_as_constant.next_to(xs.arrows[1], UP, SMALL_BUFF)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, xs.rects),\n",
        "            LaggedStartMap(GrowArrow, xs.arrows),\n",
        "            Write(treat_as_constant),\n",
        "            lag_ratio=0.8\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show same outer derivative\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                func_tex[7:].copy(),\n",
        "                partial_x[pxi1:pxi2],\n",
        "            ),\n",
        "            FadeIn(partial_x[pxi1 - 2:pxi1]),\n",
        "            FadeIn(partial_x[pxi2]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                partial_y[12:16].copy(),\n",
        "                partial_y[pxi2 + 3:pxi2 + 7],\n",
        "                path_arc=-(TAU / 4)\n",
        "            ),\n",
        "            FadeIn(partial_y[pxi2 + 2]),\n",
        "            FadeIn(partial_y[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            partial_y[-5].copy(),\n",
        "            partial_y[-2],\n",
        "            path_arc=-PI\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowDerivativeAtExamplePoint(Scene):\n",
        "    def construct(self):\n",
        "        tex_to_color_map = {\n",
        "            \"x\": BLUE,\n",
        "            \"y\": RED,\n",
        "        }\n",
        "        func_tex = OldTex(\n",
        "            \"f\", \"(\", \"x\", \",\", \"y\", \")\", \"=\",\n",
        "            \"e^{\", \"-x^2\", \"+ \\\\cos(2y)}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        gradient_tex = OldTex(\n",
        "            \"\\\\nabla\", \"f\", \"(\", \"x\", \",\", \"y\", \")\", \"=\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "\n",
        "        partial_vect = Matrix([\n",
        "            [\"{\\\\partial f / \\\\partial x}\"],\n",
        "            [\"{\\\\partial f / \\\\partial y}\"],\n",
        "        ])\n",
        "        partial_vect.get_mob_matrix()[0, 0][-1].set_color(BLUE)\n",
        "        partial_vect.get_mob_matrix()[1, 0][-1].set_color(RED)\n",
        "        result_vector = self.get_result_vector(\"x\", \"y\")\n",
        "\n",
        "        gradient = VGroup(\n",
        "            gradient_tex,\n",
        "            partial_vect,\n",
        "            OldTex(\"=\"),\n",
        "            result_vector\n",
        "        )\n",
        "        gradient.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        func_tex.to_edge(UP)\n",
        "        gradient.next_to(func_tex, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        example_lhs = OldTex(\n",
        "            \"\\\\nabla\", \"f\", \"(\", \"1\", \",\", \"3\", \")\", \"=\",\n",
        "            tex_to_color_map={\"1\": BLUE, \"3\": RED},\n",
        "        )\n",
        "        example_result_vector = self.get_result_vector(\"1\", \"3\")\n",
        "        example_rhs = DecimalMatrix([[-1.92], [0.54]])\n",
        "        example = VGroup(\n",
        "            example_lhs,\n",
        "            example_result_vector,\n",
        "            OldTex(\"=\"),\n",
        "            example_rhs,\n",
        "        )\n",
        "        example.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        example.next_to(gradient, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(func_tex, gradient)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(gradient_tex.copy(), example_lhs),\n",
        "            ReplacementTransform(result_vector.copy(), example_result_vector),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(example[2:]))\n",
        "        self.wait()\n",
        "\n",
        "    def get_result_vector(self, x, y):\n",
        "        result_vector = Matrix([\n",
        "            [\"e^{-%s^2 + \\\\cos(2\\\\cdot %s)} (-2\\\\cdot %s)\" % (x, y, x)],\n",
        "            [\"e^{-%s^2 + \\\\cos(2\\\\cdot %s)} \\\\big(-\\\\sin(2\\\\cdot %s) \\\\cdot 2\\\\big)\" % (x, y, y)],\n",
        "        ], v_buff=1.2, element_alignment_corner=ORIGIN)\n",
        "\n",
        "        x_terms = VGroup(\n",
        "            result_vector.get_mob_matrix()[0, 0][2],\n",
        "            result_vector.get_mob_matrix()[1, 0][2],\n",
        "            result_vector.get_mob_matrix()[0, 0][-2],\n",
        "        )\n",
        "        y_terms = VGroup(\n",
        "            result_vector.get_mob_matrix()[0, 0][11],\n",
        "            result_vector.get_mob_matrix()[1, 0][11],\n",
        "            result_vector.get_mob_matrix()[1, 0][-5],\n",
        "        )\n",
        "        x_terms.set_color(BLUE)\n",
        "        y_terms.set_color(RED)\n",
        "        return result_vector\n"
    ]
}