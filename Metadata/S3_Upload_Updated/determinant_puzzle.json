{
    "topic": "demonstrates the concept of matrix multiplication and the order in which it is performed.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class WorkOutNumerically(Scene):\n",
        "    CONFIG = {\n",
        "        \"M1_COLOR\": TEAL,\n",
        "        \"M2_COLOR\": PINK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_question()\n",
        "        self.add_example()\n",
        "        self.compute_rhs()\n",
        "        self.compute_lhs()\n",
        "\n",
        "    def add_question(self):\n",
        "        equation = self.original_equation = OldTex(\n",
        "            \"\\\\det(\", \"M_1\", \"M_2\", \")\", \"=\",\n",
        "            \"\\\\det(\", \"M_1\", \")\",\n",
        "            \"\\\\det(\", \"M_2\", \")\",\n",
        "        )\n",
        "        equation.set_color_by_tex_to_color_map({\n",
        "            \"M_1\": self.M1_COLOR,\n",
        "            \"M_2\": self.M2_COLOR,\n",
        "        })\n",
        "        challenge = OldTexText(\"Explain in one sentence\")\n",
        "        challenge.set_color(YELLOW)\n",
        "        group = VGroup(challenge, equation)\n",
        "        group.arrange(DOWN)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(Write(challenge))\n",
        "        self.wait()\n",
        "\n",
        "    def add_example(self):\n",
        "        M1 = self.M1 = Matrix([[2, -1], [1, 1]])\n",
        "        M1.set_color(self.M1_COLOR)\n",
        "        self.M1_copy = M1.copy()\n",
        "        M2 = self.M2 = Matrix([[-1, 4], [1, 1]])\n",
        "        M2.set_color(self.M2_COLOR)\n",
        "        self.M2_copy = M2.copy()\n",
        "        eq_parts = OldTex(\n",
        "            \"\\\\det\", \"\\\\big(\", \"\\\\big)\", \"=\",\n",
        "            \"\\\\det\", \"\\\\big(\", \"\\\\big)\",\n",
        "            \"\\\\det\", \"\\\\big(\", \"\\\\big)\",\n",
        "        )\n",
        "        for part in eq_parts.get_parts_by_tex(\"\\\\big\"):\n",
        "            part.scale(2)\n",
        "            part.stretch(1.5, 1)\n",
        "        i1, i2, i3 = [\n",
        "            eq_parts.index_of_part(part) + 1\n",
        "            for part in eq_parts.get_parts_by_tex(\"\\\\big(\")\n",
        "        ]\n",
        "        equation = self.equation_with_numbers = VGroup(*it.chain(\n",
        "            eq_parts[:i1], [M1, M2],\n",
        "            eq_parts[i1:i2], [self.M1_copy],\n",
        "            eq_parts[i2:i3], [self.M2_copy],\n",
        "            eq_parts[i3:],\n",
        "        ))\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        eq_parts.get_part_by_tex(\"=\").shift(0.2 * SMALL_BUFF * DOWN)\n",
        "        equation.set_width(FRAME_WIDTH - 2 * LARGE_BUFF)\n",
        "        equation.next_to(self.original_equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, equation))\n",
        "\n",
        "    def compute_rhs(self):\n",
        "        M1, M2 = self.M1_copy, self.M2_copy\n",
        "\n",
        "        line1 = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\big(\", \"2\", \"\\\\cdot\", \"2\", \"-\",\n",
        "                \"(-1)\", \"\\\\cdot\", \"1\", \"\\\\big)\"\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"\\\\big(\", \"-1\", \"\\\\cdot\", \"1\", \"-\",\n",
        "                \"4\", \"\\\\cdot\", \"1\", \"\\\\big)\"\n",
        "            ),\n",
        "        )\n",
        "        line1.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        line1[0].set_color(self.M1_COLOR)\n",
        "        line1[1].set_color(self.M2_COLOR)\n",
        "        indices = [1, 3, 5, 7]\n",
        "\n",
        "        line2 = OldTex(\"(3)\", \"(-5)\")\n",
        "        line2.match_style(line1)\n",
        "        line3 = OldTex(\"-15\")\n",
        "        arrows = [Tex(\"\\\\downarrow\") for x in range(2)]\n",
        "        lines = VGroup(line1, arrows[0], line2, arrows[1], line3)\n",
        "        lines.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        lines.next_to(self.equation_with_numbers, DOWN, buff=MED_LARGE_BUFF)\n",
        "        lines.to_edge(RIGHT)\n",
        "\n",
        "        for matrix, det in zip([M1, M2], line1):\n",
        "            numbers = VGroup(*[det[i] for i in indices])\n",
        "            numbers_iter = iter(numbers)\n",
        "            non_numbers = VGroup(*[m for m in det if m not in numbers])\n",
        "            matrix_numbers = VGroup(*[\n",
        "                matrix.mob_matrix[i][j].copy()\n",
        "                for i, j in ((0, 0), (1, 1), (0, 1), (1, 0))\n",
        "            ])\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeIn, non_numbers, run_time=1),\n",
        "                LaggedStartMap(\n",
        "                    ReplacementTransform,\n",
        "                    matrix_numbers,\n",
        "                    lambda m: (m, next(numbers_iter)),\n",
        "                    path_arc=TAU / 6\n",
        "                ),\n",
        "            )\n",
        "        self.play(LaggedStartMap(FadeIn, lines[1:], run_time=3))\n",
        "\n",
        "    def compute_lhs(self):\n",
        "        matrix = Matrix([[-3, 7], [0, 5]])\n",
        "        matrix.set_color(BLUE)\n",
        "        matrix.scale(0.8)\n",
        "        empty_det_tex = OldTex(\"\\\\det\", \"\\\\big(\", \"\\\\big)\")\n",
        "        empty_det_tex[1:].scale(1.5)\n",
        "        empty_det_tex[1:].match_height(matrix, stretch=True)\n",
        "        det_tex = VGroup(empty_det_tex[:2], matrix, *empty_det_tex[2:])\n",
        "        det_tex.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(\n",
        "            det_tex,\n",
        "            OldTex(\"\\\\downarrow\"),\n",
        "            OldTex(\"(-3)(5) - (7)(0)\").scale(0.8),\n",
        "            OldTex(\"\\\\downarrow\"),\n",
        "            OldTex(\"-15\"),\n",
        "        )\n",
        "        group.arrange(DOWN, buff=2 * SMALL_BUFF)\n",
        "        # group.set_height(0.4*FRAME_HEIGHT)\n",
        "        group.next_to(self.equation_with_numbers, DOWN)\n",
        "        group.shift(FRAME_WIDTH * LEFT / 4)\n",
        "\n",
        "        self.play(FadeIn(empty_det_tex))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(M.copy(), matrix)\n",
        "            for M in (self.M1, self.M2)\n",
        "        ])\n",
        "        self.play(LaggedStartMap(FadeIn, group[1:]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LetsGoInOneSentence(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Here we go, \\\\\\\\\", \"one sentence!\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.teacher_says(\n",
        "            \"Or three...\", \"\",\n",
        "            target_mode=\"guilty\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"sassy\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SuccessiveLinearTransformations(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"matrix_2\": [[3, -1], [0, 1]],\n",
        "        \"matrix_1\": [[2, 3], [-1. / 3, 2]],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.create_product_and_inverse()\n",
        "        self.scale_area_successively()\n",
        "        self.apply_transformations_successively()\n",
        "        self.scale_area_successively(\n",
        "            \"\\\\det(M_2)\", \"\\\\det(M_1)\", \"\\\\det(M_1 M_2)\",\n",
        "            reset=False\n",
        "        )\n",
        "        # self.show_det_as_scaling_factor()\n",
        "\n",
        "    def create_product_and_inverse(self):\n",
        "        self.matrix_product = np.dot(self.matrix_1, self.matrix_2)\n",
        "        self.matrix_product_inverse = np.linalg.inv(self.matrix_product)\n",
        "\n",
        "    def scale_area_successively(self, tex2=\"3\", tex1=\"5\", tex_prod=\"15\", reset=True):\n",
        "        self.add_unit_square()\n",
        "        t1 = \"$%s \\\\, \\\\cdot $\" % tex1\n",
        "        t2 = \"$%s \\\\, \\\\cdot $\" % tex2\n",
        "        t3 = \"Area\"\n",
        "        areas = VGroup(\n",
        "            OldTexText(\"\", \"\", t3),\n",
        "            OldTexText(\"\", t2, t3),\n",
        "            OldTexText(t1, t2, t3),\n",
        "        )\n",
        "        areas.scale(0.8)\n",
        "        areas.move_to(self.square)\n",
        "        area = areas[0]\n",
        "        self.add_moving_mobject(area, areas[1])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(self.square),\n",
        "            Write(area),\n",
        "            Animation(self.basis_vectors)\n",
        "        )\n",
        "        self.apply_matrix(self.matrix_2)\n",
        "        self.wait()\n",
        "        self.add_moving_mobject(area, areas[2])\n",
        "        self.apply_matrix(self.matrix_1)\n",
        "        self.wait()\n",
        "\n",
        "        product = VGroup(area[:2])\n",
        "        brace = Brace(product, DOWN, buff=SMALL_BUFF)\n",
        "        brace_tex = brace.get_tex(tex_prod, buff=SMALL_BUFF)\n",
        "        brace_tex.scale(0.8, about_edge=UP)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_tex)\n",
        "        )\n",
        "        self.wait()\n",
        "        if reset:\n",
        "            self.play(\n",
        "                FadeOut(VGroup(self.square, area, brace, brace_tex)),\n",
        "                Animation(self.plane),\n",
        "                Animation(self.basis_vectors)\n",
        "            )\n",
        "            self.transformable_mobjects.remove(self.square)\n",
        "            self.moving_mobjects = []\n",
        "            self.reset_plane()\n",
        "        self.wait()\n",
        "\n",
        "    def apply_transformations_successively(self):\n",
        "        M1, M2, all_space = expression = OldTex(\n",
        "            \"M_1\", \"M_2\", \"\\\\text{(All 2d space)}\"\n",
        "        )\n",
        "        expression.set_color_by_tex_to_color_map({\n",
        "            \"M_1\": TEAL,\n",
        "            \"M_2\": PINK,\n",
        "        })\n",
        "        expression.shift(FRAME_WIDTH * LEFT / 4)\n",
        "        expression.to_edge(UP)\n",
        "        for part in expression:\n",
        "            part.add_background_rectangle()\n",
        "            part.background_rectangle.stretch(1.05, 0)\n",
        "        M1.save_state()\n",
        "        M1.move_to(ORIGIN)\n",
        "        M1.fade(1)\n",
        "\n",
        "        # Apply one after the other\n",
        "        self.play(\n",
        "            FocusOn(M2, run_time=1),\n",
        "            FadeIn(VGroup(M2, all_space))\n",
        "        )\n",
        "        self.add_foreground_mobjects(M2, all_space)\n",
        "        self.apply_matrix(self.matrix_2)\n",
        "        self.wait()\n",
        "        self.play(M1.restore)\n",
        "        self.add_foreground_mobjects(M1)\n",
        "        self.apply_matrix(self.matrix_1)\n",
        "        self.wait()\n",
        "\n",
        "        # Show full composition\n",
        "        rp, lp = parens = OldTex(\"()\")\n",
        "        matrices = VGroup(M1, M2)\n",
        "        matrices.generate_target()\n",
        "        parens.match_height(matrices)\n",
        "        lp.move_to(matrices, RIGHT)\n",
        "        matrices.target.next_to(lp, LEFT, SMALL_BUFF)\n",
        "        rp.next_to(matrices.target, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.reset_plane()\n",
        "        self.play(\n",
        "            MoveToTarget(matrices),\n",
        "            *list(map(GrowFromCenter, parens))\n",
        "        )\n",
        "        self.apply_matrix(self.matrix_product)\n",
        "        self.wait()\n",
        "        self.reset_plane()\n",
        "\n",
        "    def show_det_as_scaling_factor(self):\n",
        "        pass\n",
        "\n",
        "    ###\n",
        "\n",
        "    def reset_plane(self):\n",
        "        plane_and_bases = VGroup(self.plane, self.basis_vectors)\n",
        "        self.play(FadeOut(plane_and_bases))\n",
        "        self.apply_matrix(self.matrix_product_inverse, run_time=0)\n",
        "        self.play(FadeIn(plane_and_bases))\n"
    ]
}