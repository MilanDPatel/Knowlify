{
    "topic": "The mathematical concept being demonstrated is the Pythagorean theorem, specifically the relationship between the sides",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "SPACE_UNIT_TO_PLANE_UNIT = 0.75\n",
        "\n",
        "class Chapter6OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"Do not ask whether a \",\n",
        "            \"statement is true until\",\n",
        "            \"you know what it means.\"\n",
        "        ],\n",
        "        \"author\" : \"Errett Bishop\"\n",
        "    }\n",
        "\n",
        "class ThisWasConfusing(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Implicit differentiation\")\n",
        "        words.move_to(self.get_teacher().get_corner(UP+LEFT), DOWN+RIGHT)\n",
        "        words.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "            words.set_fill, None, 1,\n",
        "            words.shift, 0.5*UP\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"confused\"]*3,\n",
        "            look_at = words,\n",
        "            added_anims = [Animation(self.get_teacher())]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"confused\",\n",
        "            self.get_teacher().look_at, words,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class SlopeOfCircleExample(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_X_RADIUS/SPACE_UNIT_TO_PLANE_UNIT,\n",
        "            \"y_radius\" : FRAME_Y_RADIUS/SPACE_UNIT_TO_PLANE_UNIT,\n",
        "            \"space_unit_to_x_unit\" : SPACE_UNIT_TO_PLANE_UNIT,\n",
        "            \"space_unit_to_y_unit\" : SPACE_UNIT_TO_PLANE_UNIT,\n",
        "        },\n",
        "        \"example_point\" : (3, 4),\n",
        "        \"circle_radius\" : 5,\n",
        "        \"circle_color\" : YELLOW,\n",
        "        \"example_color\" : MAROON_B,\n",
        "        \"zoom_factor\" : 20,\n",
        "        \"zoomed_canvas_corner\" : UP+LEFT,\n",
        "        \"zoomed_canvas_corner_buff\" : MED_SMALL_BUFF,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.introduce_circle()\n",
        "        self.talk_through_pythagorean_theorem()\n",
        "        self.draw_example_slope()\n",
        "        self.show_perpendicular_radius()\n",
        "        self.show_dx_and_dy()\n",
        "        self.write_slope_as_dy_dx()\n",
        "        self.point_out_this_is_not_a_graph()\n",
        "        self.perform_implicit_derivative()\n",
        "        self.show_final_slope()\n",
        "\n",
        "    def setup_plane(self):\n",
        "        self.plane = NumberPlane(**self.plane_kwargs)\n",
        "        self.planes.fade()\n",
        "        self.plane.add(self.plane.get_axis_labels())\n",
        "        self.plane.add_coordinates()\n",
        "\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def introduce_circle(self):\n",
        "        circle = Circle(\n",
        "            radius = self.circle_radius*SPACE_UNIT_TO_PLANE_UNIT,\n",
        "            color = self.circle_color,\n",
        "        )\n",
        "        equation = OldTex(\"x^2 + y^2 = 5^2\")\n",
        "        equation.add_background_rectangle()\n",
        "        equation.next_to(\n",
        "            circle.point_from_proportion(1./8), \n",
        "            UP+RIGHT\n",
        "        )\n",
        "        equation.to_edge(RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(circle, run_time = 2))\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "\n",
        "        self.circle = circle\n",
        "        self.circle_equation = equation\n",
        "\n",
        "    def talk_through_pythagorean_theorem(self):\n",
        "        point = self.plane.num_pair_to_point(self.example_point)\n",
        "        x_axis_point = point[0]*RIGHT\n",
        "        dot = Dot(point, color = self.example_color)\n",
        "\n",
        "        x_line = Line(ORIGIN, x_axis_point, color = GREEN)\n",
        "        y_line = Line(x_axis_point, point, color = RED)\n",
        "        radial_line = Line(ORIGIN, point, color = self.example_color)\n",
        "        lines = VGroup(radial_line, x_line, y_line)\n",
        "        labels = VGroup()\n",
        "\n",
        "        self.play(ShowCreation(dot))\n",
        "        for line, tex in zip(lines, \"5xy\"):\n",
        "            label = OldTex(tex)\n",
        "            label.set_color(line.get_color())\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(\n",
        "                line.get_center(), \n",
        "                rotate_vector(UP, line.get_angle()),\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Write(label)\n",
        "            )\n",
        "            labels.add(label)\n",
        "\n",
        "        full_group = VGroup(dot, lines, labels)\n",
        "        start_angle = angle_of_vector(point)\n",
        "        end_angle = np.pi/12\n",
        "        spatial_radius = get_norm(point)\n",
        "        def update_full_group(group, alpha):\n",
        "            dot, lines, labels = group\n",
        "            angle = interpolate(start_angle, end_angle, alpha)\n",
        "            new_point = spatial_radius*rotate_vector(RIGHT, angle)\n",
        "            new_x_axis_point = new_point[0]*RIGHT\n",
        "            dot.move_to(new_point)\n",
        "\n",
        "            radial_line, x_line, y_line = lines\n",
        "            x_line.put_start_and_end_on(ORIGIN, new_x_axis_point)\n",
        "            y_line.put_start_and_end_on(new_x_axis_point, new_point)\n",
        "            radial_line.put_start_and_end_on(ORIGIN, new_point)\n",
        "            for line, label in zip(lines, labels):\n",
        "                label.next_to(\n",
        "                    line.get_center(), \n",
        "                    rotate_vector(UP, line.get_angle()),\n",
        "                    buff = SMALL_BUFF\n",
        "                )\n",
        "            return group\n",
        "\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            full_group, update_full_group,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 5,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Move labels to equation\n",
        "        movers = labels.copy()\n",
        "        pairs = list(zip(\n",
        "            [movers[1], movers[2], movers[0]],\n",
        "            self.circle_equation[1][0:-1:3]\n",
        "        ))\n",
        "        self.play(*[\n",
        "            ApplyMethod(m1.replace, m2)\n",
        "            for m1, m2 in pairs\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*list(map(FadeOut, [lines, labels, movers])))\n",
        "        self.remove(full_group)\n",
        "        self.add(dot)\n",
        "        self.wait()\n",
        "\n",
        "        self.example_point_dot = dot\n",
        "\n",
        "    def draw_example_slope(self):\n",
        "        point = self.example_point_dot.get_center()\n",
        "        line = Line(ORIGIN, point)\n",
        "        line.set_color(self.example_color)\n",
        "        line.rotate(np.pi/2)\n",
        "        line.scale(2)\n",
        "        line.move_to(point)\n",
        "\n",
        "        word = OldTexText(\"Slope?\")\n",
        "        word.next_to(line.get_start(), UP, aligned_edge = LEFT)\n",
        "        word.add_background_rectangle()\n",
        "\n",
        "        coords = OldTex(\"(%d, %d)\"%self.example_point)\n",
        "        coords.add_background_rectangle()\n",
        "        coords.scale(0.7)\n",
        "        coords.next_to(point, LEFT)\n",
        "        coords.shift(SMALL_BUFF*DOWN)\n",
        "        coords.set_color(self.example_color)\n",
        "\n",
        "        self.play(GrowFromCenter(line))\n",
        "        self.play(Write(word))\n",
        "        self.wait()\n",
        "        self.play(Write(coords))\n",
        "        self.wait()\n",
        "\n",
        "        self.tangent_line = line\n",
        "        self.slope_word = word\n",
        "        self.example_point_coords_mob = coords\n",
        "\n",
        "    def show_perpendicular_radius(self):\n",
        "        point = self.example_point_dot.get_center()\n",
        "        radial_line = Line(ORIGIN, point, color = RED)\n",
        "\n",
        "        perp_mark = VGroup(\n",
        "            Line(UP, UP+RIGHT),\n",
        "            Line(UP+RIGHT, RIGHT),\n",
        "        )\n",
        "        perp_mark.scale(0.2)\n",
        "        perp_mark.set_stroke(width = 2)\n",
        "        perp_mark.rotate(radial_line.get_angle()+np.pi)\n",
        "        perp_mark.shift(point)\n",
        "\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(ShowCreation(perp_mark))\n",
        "        self.wait()\n",
        "        self.play(Indicate(perp_mark))\n",
        "        self.wait()\n",
        "        \n",
        "        morty =  Mortimer().flip().to_corner(DOWN+LEFT)\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            morty, \"Suppose you \\\\\\\\ don't know this.\",\n",
        "        ))\n",
        "        to_fade =self.get_mobjects_from_last_animation()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*list(map(FadeOut, to_fade)))\n",
        "        self.play(*list(map(FadeOut, [radial_line, perp_mark])))\n",
        "        self.wait()\n",
        "\n",
        "    def show_dx_and_dy(self):\n",
        "        dot = self.example_point_dot\n",
        "        point = dot.get_center()\n",
        "        step_vect = rotate_vector(point, np.pi/2)\n",
        "        step_length = 1./self.zoom_factor\n",
        "        step_vect *= step_length/get_norm(step_vect)\n",
        "\n",
        "        step_line = Line(ORIGIN, LEFT)\n",
        "        step_line.set_color(WHITE)\n",
        "        brace = Brace(step_line, DOWN)\n",
        "        step_text = brace.get_text(\"Step\", buff = SMALL_BUFF)\n",
        "        step_group = VGroup(step_line, brace, step_text)\n",
        "        step_group.rotate(angle_of_vector(point) - np.pi/2)\n",
        "        step_group.scale(1./self.zoom_factor)\n",
        "        step_group.shift(point)\n",
        "\n",
        "        interim_point = step_line.get_corner(UP+RIGHT)\n",
        "        dy_line = Line(point, interim_point)\n",
        "        dx_line = Line(interim_point, point+step_vect)\n",
        "        dy_line.set_color(RED)\n",
        "        dx_line.set_color(GREEN)\n",
        "        for line, tex in (dx_line, \"dx\"), (dy_line, \"dy\"):\n",
        "            label = OldTex(tex)\n",
        "            label.scale(1./self.zoom_factor)\n",
        "            next_to_vect = np.round(\n",
        "                rotate_vector(DOWN, line.get_angle())\n",
        "            )\n",
        "            label.next_to(\n",
        "                line, next_to_vect,\n",
        "                buff = MED_SMALL_BUFF/self.zoom_factor\n",
        "            )\n",
        "            label.set_color(line.get_color())\n",
        "            line.label = label\n",
        "\n",
        "        self.activate_zooming()\n",
        "        self.little_rectangle.move_to(step_line.get_center())\n",
        "        self.little_rectangle.save_state()\n",
        "        self.little_rectangle.scale(self.zoom_factor)\n",
        "        self.wait()        \n",
        "        self.play(\n",
        "            self.little_rectangle.restore,\n",
        "            dot.scale, 1./self.zoom_factor,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(step_line))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(step_text))\n",
        "        self.wait()\n",
        "        for line in dy_line, dx_line:\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(Write(line.label))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.step_group = step_group\n",
        "        self.dx_line = dx_line\n",
        "        self.dy_line = dy_line\n",
        "\n",
        "    def write_slope_as_dy_dx(self):\n",
        "        slope_word = self.slope_word\n",
        "        new_slope_word = OldTexText(\"Slope =\")\n",
        "        new_slope_word.add_background_rectangle()\n",
        "        new_slope_word.next_to(ORIGIN, RIGHT)\n",
        "        new_slope_word.shift(slope_word.get_center()[1]*UP)\n",
        "\n",
        "        dy_dx = OldTex(\"\\\\frac{dy}{dx}\")\n",
        "        VGroup(*dy_dx[:2]).set_color(RED)\n",
        "        VGroup(*dy_dx[-2:]).set_color(GREEN)\n",
        "        dy_dx.next_to(new_slope_word, RIGHT)\n",
        "        dy_dx.add_background_rectangle()\n",
        "\n",
        "        self.play(Transform(slope_word, new_slope_word))\n",
        "        self.play(Write(dy_dx))\n",
        "        self.wait()\n",
        "\n",
        "        self.dy_dx = dy_dx\n",
        "\n",
        "    def point_out_this_is_not_a_graph(self):\n",
        "        equation = self.circle_equation\n",
        "        x = equation[1][0]\n",
        "        y = equation[1][3]\n",
        "        brace = Brace(equation, DOWN)\n",
        "        brace_text = brace.get_text(\n",
        "            \"Not $y = f(x)$\",\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        brace_text.set_color(RED)\n",
        "        alt_brace_text = brace.get_text(\"Implicit curve\")\n",
        "        for text in brace_text, alt_brace_text:\n",
        "            text.add_background_rectangle()\n",
        "            text.to_edge(RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        new_circle = self.circle.copy()\n",
        "        new_circle.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Indicate(x))\n",
        "        self.wait()\n",
        "        self.play(Indicate(y))\n",
        "        self.wait()\n",
        "        self.play(Transform(brace_text, alt_brace_text))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(new_circle, run_time = 2),\n",
        "            Animation(brace_text)\n",
        "        )\n",
        "        self.play(new_circle.set_stroke, None, 0)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, brace_text])))\n",
        "        self.wait()\n",
        "\n",
        "    def perform_implicit_derivative(self):\n",
        "        equation = self.circle_equation\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.next_to(ORIGIN, LEFT)\n",
        "        morty.to_edge(DOWN, buff = SMALL_BUFF)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(morty, UP)\n",
        "\n",
        "        rect = Rectangle(\n",
        "            width = FRAME_X_RADIUS - SMALL_BUFF, \n",
        "            height = FRAME_Y_RADIUS - SMALL_BUFF,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8,\n",
        "        )\n",
        "        rect.to_corner(DOWN+RIGHT, buff = 0)\n",
        "\n",
        "        derivative = OldTex(\"2x\\\\,dx + 2y\\\\,dy = 0\")\n",
        "        dx = VGroup(*derivative[2:4])\n",
        "        dy = VGroup(*derivative[7:9])\n",
        "        dx.set_color(GREEN)\n",
        "        dy.set_color(RED)\n",
        "\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(morty),            \n",
        "            equation.next_to, ORIGIN, DOWN, MED_LARGE_BUFF,\n",
        "            equation.shift, FRAME_X_RADIUS*RIGHT/2,\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change_mode, \"confused\",\n",
        "            morty.look_at, equation\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        derivative.next_to(equation, DOWN)\n",
        "        derivative.shift(\n",
        "            equation[1][-3].get_center()[0]*RIGHT - \\\n",
        "            derivative[-2].get_center()[0]*RIGHT\n",
        "        )\n",
        "\n",
        "\n",
        "        #Differentiate\n",
        "        self.play(\n",
        "            morty.look_at, derivative[0],\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    equation[1][i].copy(),\n",
        "                    derivative[j],\n",
        "                )\n",
        "                for i, j in ((1, 0), (0, 1))\n",
        "            ]\n",
        "        )\n",
        "        self.play(Write(dx, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                equation[1][i].copy(),\n",
        "                derivative[j],\n",
        "            )\n",
        "            for i, j in ((2, 4), (3, 6), (4, 5))\n",
        "        ])\n",
        "        self.play(Write(dy, run_time = 1))\n",
        "        self.play(Blink(morty)) \n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                equation[1][i].copy(),\n",
        "                derivative[j],\n",
        "            )\n",
        "            for i, j in ((-3, -2), (-2, -1), (-1, -1))\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        #React\n",
        "        self.play(morty.change_mode, \"erm\")\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Write(q_marks))\n",
        "        self.wait()\n",
        "        self.play(Indicate(dx), morty.look_at, dx)\n",
        "        self.play(Indicate(dy), morty.look_at, dy)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"shruggie\",\n",
        "            FadeOut(q_marks)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, derivative,\n",
        "        )\n",
        "\n",
        "        #Rearrange\n",
        "        x, y, eq = np.array(derivative)[[1, 6, 9]]\n",
        "        final_form = OldTex(\n",
        "            \"\\\\frac{dy}{dx} = \\\\frac{-x}{y}\"\n",
        "        )\n",
        "        new_dy = VGroup(*final_form[:2])\n",
        "        new_dx = VGroup(*final_form[3:5])\n",
        "        new_dy.set_color(dy.get_color())\n",
        "        new_dx.set_color(dx.get_color())\n",
        "        new_dy.add(final_form[2])\n",
        "        new_x = VGroup(*final_form[6:8])\n",
        "        new_y = VGroup(*final_form[8:10])\n",
        "        new_eq = final_form[5]\n",
        "\n",
        "        final_form.next_to(derivative, DOWN)\n",
        "        final_form.shift((eq.get_center()[0]-new_eq.get_center()[0])*RIGHT)\n",
        "\n",
        "\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                mover.copy(), target,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi/2,\n",
        "            )\n",
        "            for mover, target in [\n",
        "                (dy, new_dy), \n",
        "                (dx, new_dx), \n",
        "                (eq, new_eq), \n",
        "                (x, new_x), \n",
        "                (y, new_y)\n",
        "            ]\n",
        "        ] + [\n",
        "            morty.look_at, final_form\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        self.morty = morty\n",
        "        self.neg_x_over_y = VGroup(*final_form[6:])\n",
        "\n",
        "    def show_final_slope(self):\n",
        "        morty = self.morty\n",
        "        dy_dx = self.dy_dx\n",
        "        coords = self.example_point_coords_mob\n",
        "        x, y = coords[1][1].copy(), coords[1][3].copy()        \n",
        "\n",
        "        frac = self.neg_x_over_y.copy()\n",
        "        frac.generate_target()\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.add_background_rectangle()\n",
        "        eq.next_to(dy_dx, RIGHT)\n",
        "        frac.target.next_to(eq, RIGHT)\n",
        "        frac.target.shift(SMALL_BUFF*DOWN)\n",
        "        rect = BackgroundRectangle(frac.target)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            MoveToTarget(frac),\n",
        "            Write(eq),\n",
        "            morty.look_at, rect,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FocusOn(coords), morty.look_at, coords)\n",
        "        self.play(Indicate(coords))\n",
        "        scale_factor = 1.4\n",
        "        self.play(\n",
        "            x.scale, scale_factor,\n",
        "            x.set_color, GREEN,\n",
        "            x.move_to, frac[1],\n",
        "            FadeOut(frac[1]),\n",
        "            y.scale, scale_factor,\n",
        "            y.set_color, RED,\n",
        "            y.move_to, frac[3], DOWN,\n",
        "            y.shift, SMALL_BUFF*UP,\n",
        "            FadeOut(frac[3]),\n",
        "            morty.look_at, frac,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "class NameImplicitDifferentation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"``Implicit differentiation''\")\n",
        "\n",
        "        equation = OldTex(\"x^2\", \"+\", \"y^2\", \"=\", \"5^2\")\n",
        "        derivative = OldTex(\n",
        "            \"2x\\\\,dx\", \"+\", \"2y\\\\,dy\", \"=\", \"0\"\n",
        "        )\n",
        "        VGroup(*derivative[0][2:]).set_color(GREEN)\n",
        "        VGroup(*derivative[2][2:]).set_color(RED)\n",
        "        arrow = Arrow(ORIGIN, DOWN, buff = SMALL_BUFF)\n",
        "        group = VGroup(title, equation, arrow, derivative)\n",
        "        group.arrange(DOWN)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        self.add(title, equation)\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"confused\"]*3,\n",
        "            look_at = derivative,\n",
        "            added_anims = [ReplacementTransform(equation.copy(), derivative)]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"Don't worry...\",\n",
        "            added_anims = [\n",
        "                group.scale, 0.7,\n",
        "                group.to_corner, UP+LEFT,\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class Ladder(VMobject):\n",
        "    CONFIG = {\n",
        "        \"height\" : 4,\n",
        "        \"width\" : 1,\n",
        "        \"n_rungs\" : 7,\n",
        "    }\n",
        "    def init_points(self):\n",
        "        left_line, right_line = [\n",
        "            Line(ORIGIN, self.height*UP).shift(self.width*vect/2.0)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ]\n",
        "        rungs = [\n",
        "            Line(\n",
        "                left_line.point_from_proportion(a),\n",
        "                right_line.point_from_proportion(a),\n",
        "            )\n",
        "            for a in np.linspace(0, 1, 2*self.n_rungs+1)[1:-1:2]\n",
        "        ]\n",
        "        self.add(left_line, right_line, *rungs)\n",
        "        self.center()\n",
        "\n",
        "class RelatedRatesExample(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"start_x\" : 3.0,\n",
        "        \"start_y\" : 4.0,\n",
        "        \"wall_dimensions\" : [0.3, 5, 5],\n",
        "        \"wall_color\" : color_gradient([GREY_BROWN, BLACK], 4)[1],\n",
        "        \"wall_center\" : 1.5*LEFT+0.5*UP,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_ladder()\n",
        "        self.write_related_rates()\n",
        "        self.measure_ladder()\n",
        "        self.slide_ladder()\n",
        "        self.ponder_question()\n",
        "        self.write_equation()\n",
        "        self.isolate_x_of_t()\n",
        "        self.discuss_lhs_as_function()\n",
        "        self.let_dt_pass()\n",
        "        self.take_derivative_of_rhs()\n",
        "        self.take_derivative_of_lhs()\n",
        "        self.bring_back_velocity_arrows()\n",
        "        self.replace_terms_in_final_form()\n",
        "        self.write_final_solution()\n",
        "\n",
        "    def introduce_ladder(self):\n",
        "        ladder = Ladder(height = self.get_ladder_length())\n",
        "\n",
        "        wall = Prism(\n",
        "            dimensions = self.wall_dimensions,\n",
        "            fill_color = self.wall_color,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        wall.rotate(np.pi/12, UP)\n",
        "        wall.shift(self.wall_center)\n",
        "\n",
        "        ladder.generate_target()\n",
        "        ladder.fallen = ladder.copy()\n",
        "        ladder.target.rotate(self.get_ladder_angle(), LEFT)\n",
        "        ladder.fallen.rotate(np.pi/2, LEFT)\n",
        "        for ladder_copy in ladder.target, ladder.fallen:\n",
        "            ladder_copy.rotate(-5*np.pi/12, UP)\n",
        "            ladder_copy.next_to(wall, LEFT, 0, DOWN)\n",
        "            ladder_copy.shift(0.8*RIGHT) ##BAD!\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ladder, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(wall),\n",
        "            MoveToTarget(ladder),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ladder = ladder\n",
        "\n",
        "    def write_related_rates(self):\n",
        "        words = OldTexText(\"Related rates\")\n",
        "        words.to_corner(UP+RIGHT)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.related_rates_words = words\n",
        "\n",
        "    def measure_ladder(self):\n",
        "        ladder = self.ladder\n",
        "        ladder_brace = self.get_ladder_brace(ladder)\n",
        "\n",
        "        x_and_y_lines = self.get_x_and_y_lines(ladder)\n",
        "        x_line, y_line = x_and_y_lines\n",
        "\n",
        "        y_label = OldTex(\"%dm\"%int(self.start_y))\n",
        "        y_label.next_to(y_line, LEFT, buff = SMALL_BUFF)\n",
        "        y_label.set_color(y_line.get_color())\n",
        "\n",
        "        x_label = OldTex(\"%dm\"%int(self.start_x))\n",
        "        x_label.next_to(x_line, UP)\n",
        "        x_label.set_color(x_line.get_color())\n",
        "\n",
        "        self.play(Write(ladder_brace))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(y_line), Write(y_label))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(x_line), Write(x_label))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [x_label, y_label])))\n",
        "\n",
        "        self.ladder_brace = ladder_brace\n",
        "        self.x_and_y_lines = x_and_y_lines\n",
        "        self.numerical_x_and_y_labels = VGroup(x_label, y_label)\n",
        "\n",
        "    def slide_ladder(self):\n",
        "        ladder = self.ladder\n",
        "        brace = self.ladder_brace\n",
        "        x_and_y_lines = self.x_and_y_lines\n",
        "        x_line, y_line = x_and_y_lines\n",
        "\n",
        "        down_arrow, left_arrow = [\n",
        "            Arrow(ORIGIN, vect, color = YELLOW, buff = 0)\n",
        "            for vect in (DOWN, LEFT)\n",
        "        ]\n",
        "        down_arrow.shift(y_line.get_start()+MED_SMALL_BUFF*RIGHT)\n",
        "        left_arrow.shift(x_line.get_start()+SMALL_BUFF*DOWN)\n",
        "\n",
        "        # speed_label = OldTex(\"1 \\\\text{m}/\\\\text{s}\")\n",
        "        speed_label = OldTex(\"1 \\\\frac{\\\\text{m}}{\\\\text{s}}\")\n",
        "        speed_label.next_to(down_arrow, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(left_arrow, DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "\n",
        "        added_anims = [\n",
        "            UpdateFromFunc(brace, self.update_brace),\n",
        "            UpdateFromFunc(x_and_y_lines, self.update_x_and_y_lines),\n",
        "            Animation(down_arrow),\n",
        "        ]\n",
        "        self.play(ShowCreation(down_arrow))\n",
        "        self.play(Write(speed_label))\n",
        "        self.let_ladder_fall(ladder, *added_anims)\n",
        "        self.wait()\n",
        "        self.reset_ladder(ladder, *added_anims)\n",
        "        self.play(ShowCreation(left_arrow))\n",
        "        self.play(Write(q_marks))\n",
        "        self.wait()\n",
        "        self.let_ladder_fall(ladder, *added_anims)\n",
        "        self.wait()\n",
        "        self.reset_ladder(ladder, *added_anims)\n",
        "        self.wait()\n",
        "\n",
        "        self.dy_arrow = down_arrow\n",
        "        self.dy_label = speed_label\n",
        "        self.dx_arrow = left_arrow\n",
        "        self.dx_label = q_marks\n",
        "\n",
        "    def ponder_question(self):\n",
        "        randy = Randolph(mode = \"pondering\")\n",
        "        randy.flip()\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, self.ladder.get_top()\n",
        "        )\n",
        "        self.play(randy.look_at, self.ladder.get_bottom())\n",
        "        self.play(randy.look_at, self.ladder.get_top())\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Give names\"\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            randy, randy.bubble, randy.bubble.content\n",
        "        ])))\n",
        "\n",
        "    def write_equation(self):\n",
        "        self.x_and_y_labels = self.get_x_and_y_labels()\n",
        "        x_label, y_label = self.x_and_y_labels\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"x(t)\", \"^2\", \"+\", \"y(t)\", \"^2\", \"=\", \"5^2\"\n",
        "        )\n",
        "        equation[0].set_color(GREEN)\n",
        "        equation[3].set_color(RED)\n",
        "        equation.next_to(self.related_rates_words, DOWN, buff = MED_LARGE_BUFF)\n",
        "        equation.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(y_label))\n",
        "        self.wait()\n",
        "        self.let_ladder_fall(\n",
        "            self.ladder,\n",
        "            y_label.shift, self.start_y*DOWN/2,\n",
        "            *self.get_added_anims_for_ladder_fall()[:-1],\n",
        "            rate_func = lambda t : 0.2*there_and_back(t),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(FocusOn(x_label))\n",
        "        self.play(Write(x_label))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(x_label.copy(), equation[0]),\n",
        "            ReplacementTransform(y_label.copy(), equation[3]),\n",
        "            Write(VGroup(*np.array(equation)[[1, 2, 4, 5, 6]]))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.let_ladder_fall(\n",
        "            self.ladder,\n",
        "            *self.get_added_anims_for_ladder_fall(),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 6\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "\n",
        "    def isolate_x_of_t(self):\n",
        "        alt_equation = OldTex(\n",
        "            \"x(t)\", \"=\", \"\\\\big(5^2\", \"-\", \"y(t)\", \"^2 \\\\big)\", \"^{1/2}\",\n",
        "        )\n",
        "        alt_equation[0].set_color(GREEN)\n",
        "        alt_equation[4].set_color(RED)\n",
        "        alt_equation.next_to(self.equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "        alt_equation.to_edge(RIGHT)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.next_to(\n",
        "            alt_equation, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        randy.look_at(alt_equation)\n",
        "\n",
        "        find_dx_dt = OldTex(\"\\\\text{Find } \\\\,\", \"\\\\frac{dx}{dt}\")\n",
        "        find_dx_dt.next_to(randy, RIGHT, aligned_edge = UP)\n",
        "        find_dx_dt[1].set_color(GREEN)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"raise_right_hand\", \n",
        "            randy.look_at, alt_equation,\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    self.equation[i].copy(), \n",
        "                    alt_equation[j],\n",
        "                    path_arc = np.pi/2,\n",
        "                    run_time = 3,\n",
        "                    rate_func = squish_rate_func(\n",
        "                        smooth, j/12.0, (j+6)/12.0\n",
        "                    )\n",
        "                )\n",
        "                for i, j in enumerate([0, 6, 3, 4, 5, 1, 2])\n",
        "            ]\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(find_dx_dt),\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, find_dx_dt,\n",
        "        )\n",
        "        self.let_ladder_fall(\n",
        "            self.ladder, *self.get_added_anims_for_ladder_fall(),\n",
        "            run_time = 8,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            randy, find_dx_dt, alt_equation\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "    def discuss_lhs_as_function(self):\n",
        "        equation = self.equation\n",
        "        lhs = VGroup(*equation[:5])\n",
        "        brace = Brace(lhs, DOWN)\n",
        "        function_of_time = brace.get_text(\n",
        "            \"Function of time\"\n",
        "        )\n",
        "        constant_words = OldTexText(\n",
        "            \"\"\"that happens to\n",
        "            be constant\"\"\"\n",
        "        )\n",
        "        constant_words.set_color(YELLOW)\n",
        "        constant_words.next_to(function_of_time, DOWN)\n",
        "\n",
        "        derivative = OldTex(\n",
        "            \"\\\\frac{d\\\\left(x(t)^2 + y(t)^2 \\\\right)}{dt}\"\n",
        "        )\n",
        "        derivative.next_to(equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "        derivative.shift( ##Align x terms\n",
        "            equation[0][0].get_center()[0]*RIGHT-\\\n",
        "            derivative[2].get_center()[0]*RIGHT\n",
        "        )\n",
        "        derivative_interior = lhs.copy()\n",
        "        derivative_interior.move_to(VGroup(*derivative[2:13]))\n",
        "        derivative_scaffold = VGroup(\n",
        "            *list(derivative[:2])+list(derivative[13:])\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(function_of_time)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(constant_words))\n",
        "        self.let_ladder_fall(\n",
        "            self.ladder, *self.get_added_anims_for_ladder_fall(),\n",
        "            run_time = 6,\n",
        "            rate_func = lambda t : 0.5*there_and_back(t)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            brace, constant_words, function_of_time\n",
        "        ])))\n",
        "        self.play(\n",
        "            ReplacementTransform(lhs.copy(), derivative_interior),\n",
        "            Write(derivative_scaffold),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.derivative = VGroup(\n",
        "            derivative_scaffold, derivative_interior\n",
        "        )\n",
        "\n",
        "    def let_dt_pass(self):\n",
        "        dt_words = OldTexText(\"After\", \"$dt$\", \"seconds...\")\n",
        "        dt_words.to_corner(UP+LEFT)\n",
        "        dt = dt_words[1]\n",
        "        dt.set_color(YELLOW)\n",
        "        dt_brace = Brace(dt, buff = SMALL_BUFF)\n",
        "        dt_brace_text = dt_brace.get_text(\"Think 0.01\", buff = SMALL_BUFF)\n",
        "        dt_brace_text.set_color(dt.get_color())\n",
        "\n",
        "        shadow_ladder = self.ladder.copy()\n",
        "        shadow_ladder.fade(0.5)\n",
        "\n",
        "        x_line, y_line = self.x_and_y_lines\n",
        "        y_top = y_line.get_start()\n",
        "        x_left = x_line.get_start()\n",
        "\n",
        "        self.play(Write(dt_words, run_time = 2))\n",
        "        self.play(\n",
        "            GrowFromCenter(dt_brace),\n",
        "            Write(dt_brace_text, run_time = 2)\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.dy_arrow, self.dy_label, \n",
        "            self.dx_arrow, self.dx_label, \n",
        "        ])))\n",
        "        self.add(shadow_ladder)\n",
        "        self.let_ladder_fall(\n",
        "            self.ladder, *self.get_added_anims_for_ladder_fall(),\n",
        "            rate_func = lambda t : 0.1*smooth(t),\n",
        "            run_time = 1\n",
        "        )\n",
        "\n",
        "        new_y_top = y_line.get_start()\n",
        "        new_x_left = x_line.get_start()\n",
        "\n",
        "        dy_line = Line(y_top, new_y_top)\n",
        "        dy_brace = Brace(dy_line, RIGHT, buff = SMALL_BUFF)\n",
        "        dy_label = dy_brace.get_text(\"$dy$\", buff = SMALL_BUFF)\n",
        "        dy_label.set_color(RED)\n",
        "\n",
        "        dx_line = Line(x_left, new_x_left)\n",
        "        dx_brace = Brace(dx_line, DOWN, buff = SMALL_BUFF)\n",
        "        dx_label = dx_brace.get_text(\"$dx$\")\n",
        "        dx_label.set_color(GREEN)\n",
        "\n",
        "        VGroup(dy_line, dx_line).set_color(YELLOW)\n",
        "\n",
        "        for line, brace, label in (dy_line, dy_brace, dy_label), (dx_line, dx_brace, dx_label):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(brace),\n",
        "                Write(label),\n",
        "                run_time = 1\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Indicate(self.derivative[1]))\n",
        "        self.wait()\n",
        "\n",
        "        self.dy_group = VGroup(dy_line, dy_brace, dy_label)\n",
        "        self.dx_group = VGroup(dx_line, dx_brace, dx_label)\n",
        "        self.shadow_ladder = shadow_ladder\n",
        "\n",
        "    def take_derivative_of_rhs(self):\n",
        "        derivative = self.derivative\n",
        "        equals_zero = OldTex(\"= 0\")\n",
        "        equals_zero.next_to(derivative)\n",
        "\n",
        "        rhs = self.equation[-1]\n",
        "\n",
        "        self.play(Write(equals_zero))\n",
        "        self.wait()\n",
        "        self.play(FocusOn(rhs))\n",
        "        self.play(Indicate(rhs))\n",
        "        self.wait()\n",
        "        self.reset_ladder(\n",
        "            self.ladder, \n",
        "            *self.get_added_anims_for_ladder_fall()+[\n",
        "                Animation(self.dy_group),\n",
        "                Animation(self.dx_group),\n",
        "            ],\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equals_zero = equals_zero\n",
        "\n",
        "    def take_derivative_of_lhs(self):\n",
        "        derivative_scaffold, equation = self.derivative\n",
        "        equals_zero_copy = self.equals_zero.copy()\n",
        "\n",
        "        lhs_derivative = OldTex(\n",
        "            \"2\", \"x(t)\", \"\\\\frac{dx}{dt}\", \"+\",\n",
        "            \"2\", \"y(t)\", \"\\\\frac{dy}{dt}\",\n",
        "        )\n",
        "        lhs_derivative[1].set_color(GREEN)\n",
        "        VGroup(*lhs_derivative[2][:2]).set_color(GREEN)\n",
        "        lhs_derivative[5].set_color(RED)\n",
        "        VGroup(*lhs_derivative[6][:2]).set_color(RED)\n",
        "        lhs_derivative.next_to(\n",
        "            derivative_scaffold, DOWN,\n",
        "            aligned_edge = RIGHT,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        equals_zero_copy.next_to(lhs_derivative, RIGHT)\n",
        "\n",
        "        pairs = [\n",
        "            (0, 1), (1, 0), #x^2 -> 2x\n",
        "            (2, 3), (3, 5), (4, 4), #+y^2 -> +2y\n",
        "        ]\n",
        "        def perform_replacement(index_pairs):\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    equation[i].copy(), lhs_derivative[j],\n",
        "                    path_arc = np.pi/2,\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for i, j in index_pairs\n",
        "            ])\n",
        "\n",
        "        perform_replacement(pairs[:2])\n",
        "        self.play(Write(lhs_derivative[2]))\n",
        "        self.wait()\n",
        "        self.play(Indicate(\n",
        "            VGroup(\n",
        "                *list(lhs_derivative[:2])+\\\n",
        "                list(lhs_derivative[2][:2])\n",
        "            ),\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.play(Indicate(VGroup(*lhs_derivative[2][3:])))\n",
        "        self.wait(2)\n",
        "        perform_replacement(pairs[2:])\n",
        "        self.play(Write(lhs_derivative[6]))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FocusOn(self.equals_zero))\n",
        "        self.play(ReplacementTransform(\n",
        "            self.equals_zero.copy(),\n",
        "            equals_zero_copy\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        lhs_derivative.add(equals_zero_copy)\n",
        "        self.lhs_derivative = lhs_derivative\n",
        "\n",
        "    def bring_back_velocity_arrows(self):\n",
        "        dx_dy_group = VGroup(self.dx_group, self.dy_group)\n",
        "        arrow_group = VGroup(\n",
        "            self.dy_arrow, self.dy_label,\n",
        "            self.dx_arrow, self.dx_label,\n",
        "        )\n",
        "        ladder_fall_args = [self.ladder] + self.get_added_anims_for_ladder_fall()\n",
        "\n",
        "\n",
        "        self.reset_ladder(*ladder_fall_args + [\n",
        "            FadeOut(dx_dy_group),\n",
        "            FadeOut(self.derivative),\n",
        "            FadeOut(self.equals_zero),\n",
        "            self.lhs_derivative.shift, 2*UP,\n",
        "        ])\n",
        "        self.remove(self.shadow_ladder)\n",
        "        self.play(FadeIn(arrow_group))\n",
        "        self.let_ladder_fall(*ladder_fall_args)\n",
        "        self.wait()\n",
        "        self.reset_ladder(*ladder_fall_args)\n",
        "        self.wait()\n",
        "\n",
        "    def replace_terms_in_final_form(self):\n",
        "        x_label, y_label = self.x_and_y_labels\n",
        "        num_x_label, num_y_label = self.numerical_x_and_y_labels\n",
        "\n",
        "        new_lhs_derivative = OldTex(\n",
        "            \"2\", \"(%d)\"%int(self.start_x), \"\\\\frac{dx}{dt}\", \"+\",\n",
        "            \"2\", \"(%d)\"%int(self.start_y), \"(-1)\",\n",
        "            \"= 0\"\n",
        "        )\n",
        "        new_lhs_derivative[1].set_color(GREEN)\n",
        "        VGroup(*new_lhs_derivative[2][:2]).set_color(GREEN)\n",
        "        new_lhs_derivative[5].set_color(RED)\n",
        "        new_lhs_derivative.next_to(\n",
        "            self.lhs_derivative, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "        def fill_in_equation_part(*indices):\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    self.lhs_derivative[i].copy(),\n",
        "                    new_lhs_derivative[i],\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for i in indices\n",
        "            ])\n",
        "\n",
        "        self.play(FadeOut(y_label), FadeIn(num_y_label))\n",
        "        fill_in_equation_part(3, 4, 5)\n",
        "        self.play(FadeOut(x_label), FadeIn(num_x_label))\n",
        "        for indices in [(0, 1), (6,), (2, 7)]:\n",
        "            fill_in_equation_part(*indices)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.new_lhs_derivative = new_lhs_derivative\n",
        "\n",
        "    def write_final_solution(self):\n",
        "        solution = OldTex(\n",
        "            \"\\\\frac{dx}{dt} = \\\\frac{4}{3}\"\n",
        "        )\n",
        "        for i in 0, 1, -1:\n",
        "            solution[i].set_color(GREEN)\n",
        "        solution[-3].set_color(RED)\n",
        "        solution.next_to(\n",
        "            self.new_lhs_derivative, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "\n",
        "        box = Rectangle(color = YELLOW)\n",
        "        box.replace(solution)\n",
        "        box.scale(1.5)\n",
        "\n",
        "        self.play(Write(solution))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(box))\n",
        "        self.wait()\n",
        "\n",
        "    #########\n",
        "\n",
        "    def get_added_anims_for_ladder_fall(self):\n",
        "        return [\n",
        "            UpdateFromFunc(self.ladder_brace, self.update_brace),\n",
        "            UpdateFromFunc(self.x_and_y_lines, self.update_x_and_y_lines),\n",
        "            UpdateFromFunc(self.x_and_y_labels, self.update_x_and_y_labels),\n",
        "        ]\n",
        "\n",
        "    def let_ladder_fall(self, ladder, *added_anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", self.start_y)\n",
        "        kwargs[\"rate_func\"] = kwargs.get(\"rate_func\", None)\n",
        "        self.play(\n",
        "            Transform(ladder, ladder.fallen),\n",
        "            *added_anims,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def reset_ladder(self, ladder, *added_anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        self.play(\n",
        "            Transform(ladder, ladder.target),\n",
        "            *added_anims,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def update_brace(self, brace):\n",
        "        Transform(\n",
        "            brace, self.get_ladder_brace(self.ladder)\n",
        "        ).update(1)\n",
        "        return brace\n",
        "\n",
        "    def update_x_and_y_lines(self, x_and_y_lines):\n",
        "        Transform(\n",
        "            x_and_y_lines,\n",
        "            self.get_x_and_y_lines(self.ladder)\n",
        "        ).update(1)\n",
        "        return x_and_y_lines\n",
        "\n",
        "    def update_x_and_y_labels(self, x_and_y_labels):\n",
        "        Transform(\n",
        "            x_and_y_labels,\n",
        "            self.get_x_and_y_labels()\n",
        "        ).update(1)\n",
        "        return x_and_y_labels\n",
        "\n",
        "    def get_ladder_brace(self, ladder):\n",
        "        vect = rotate_vector(LEFT, -self.get_ladder_angle())\n",
        "        brace = Brace(ladder, vect)        \n",
        "        length_string = \"%dm\"%int(self.get_ladder_length())\n",
        "        length_label = brace.get_text(\n",
        "            length_string, use_next_to = False\n",
        "        )\n",
        "        brace.add(length_label)\n",
        "        brace.length_label = length_label\n",
        "        return brace\n",
        "\n",
        "    def get_x_and_y_labels(self):\n",
        "        x_line, y_line = self.x_and_y_lines\n",
        "\n",
        "        x_label = OldTex(\"x(t)\")\n",
        "        x_label.set_color(x_line.get_color())\n",
        "        x_label.next_to(x_line, DOWN, buff = SMALL_BUFF)\n",
        "\n",
        "        y_label = OldTex(\"y(t)\")\n",
        "        y_label.set_color(y_line.get_color())\n",
        "        y_label.next_to(y_line, LEFT, buff = SMALL_BUFF)\n",
        "\n",
        "        return VGroup(x_label, y_label)\n",
        "\n",
        "    def get_x_and_y_lines(self, ladder):\n",
        "        bottom_point, top_point = np.array(ladder[1].get_start_and_end())\n",
        "        interim_point = top_point[0]*RIGHT + bottom_point[1]*UP\n",
        "        interim_point += SMALL_BUFF*DOWN\n",
        "        y_line = Line(top_point, interim_point)\n",
        "        y_line.set_color(RED)\n",
        "        x_line = Line(bottom_point, interim_point)\n",
        "        x_line.set_color(GREEN)\n",
        "\n",
        "        return VGroup(x_line, y_line)\n",
        "\n",
        "    def get_ladder_angle(self):\n",
        "        if hasattr(self, \"ladder\"):\n",
        "            c1 = self.ladder.get_corner(UP+RIGHT)\n",
        "            c2 = self.ladder.get_corner(DOWN+LEFT)\n",
        "            vect = c1-c2\n",
        "            return np.pi/2 - angle_of_vector(vect)\n",
        "        else:\n",
        "            return np.arctan(self.start_x/self.start_y)\n",
        "\n",
        "    def get_ladder_length(self):\n",
        "        return get_norm([self.start_x, self.start_y])\n",
        "\n",
        "class LightweightLadderScene(RelatedRatesExample):\n",
        "    CONFIG = {\n",
        "        \"skip_animations\" : True\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_ladder()\n",
        "        self.measure_ladder()\n",
        "        self.add(self.numerical_x_and_y_labels)\n",
        "\n",
        "class LightweightCircleExample(SlopeOfCircleExample):\n",
        "    CONFIG = {\n",
        "        \"skip_animations\" : True,\n",
        "        \"plane_kwargs\" : {\n",
        "            \"x_radius\" : 5,\n",
        "            \"y_radius\" : 5,\n",
        "            \"space_unit_to_x_unit\" : SPACE_UNIT_TO_PLANE_UNIT,\n",
        "            \"space_unit_to_y_unit\" : SPACE_UNIT_TO_PLANE_UNIT,\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.introduce_circle()\n",
        "        self.talk_through_pythagorean_theorem()\n",
        "        self.draw_example_slope()\n",
        "\n",
        "        self.remove(self.circle_equation)\n",
        "        self.remove(self.slope_word)\n",
        "        self.example_point_coords_mob.scale(\n",
        "            1.5, about_point = self.example_point_coords_mob.get_corner(UP+RIGHT)\n",
        "        )\n",
        "        self.plane.axis_labels[0].shift(3*LEFT)\n",
        "\n",
        "class CompareLadderAndCircle(PiCreatureScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.introduce_both_scenes()\n",
        "        self.show_derivatives()\n",
        "        self.comment_on_ladder_derivative()\n",
        "        self.comment_on_circle_derivative()\n",
        "\n",
        "    def introduce_both_scenes(self):\n",
        "        ladder_scene = LightweightLadderScene()\n",
        "        ladder_mobs = VGroup(*ladder_scene.get_top_level_mobjects())\n",
        "        circle_scene = LightweightCircleExample()\n",
        "        circle_mobs = VGroup(*circle_scene.get_top_level_mobjects())\n",
        "        for mobs, vect in (ladder_mobs, LEFT), (circle_mobs, RIGHT):\n",
        "            mobs.set_height(FRAME_Y_RADIUS-MED_LARGE_BUFF)\n",
        "            mobs.next_to(\n",
        "                self.pi_creature.get_corner(UP+vect), UP,\n",
        "                buff = SMALL_BUFF,\n",
        "                aligned_edge = -vect\n",
        "            )\n",
        "\n",
        "        ladder_mobs.save_state()\n",
        "        ladder_mobs.fade(1)\n",
        "        ladder_mobs.rotate(np.pi/3, UP)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "            self.pi_creature.look_at, ladder_mobs,\n",
        "            ApplyMethod(ladder_mobs.restore, run_time = 2)\n",
        "        )\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_left_hand\",\n",
        "            self.pi_creature.look_at, circle_mobs,\n",
        "            Write(circle_mobs, run_time = 2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            circle_mobs.to_edge, RIGHT,\n",
        "            ladder_mobs.to_edge, LEFT,\n",
        "        )\n",
        "\n",
        "    def show_derivatives(self):\n",
        "        equation = OldTex(\n",
        "            \"x\", \"^2\", \"+\", \"y\", \"^2\", \"= 5^2\"\n",
        "        )\n",
        "        derivative = OldTex(\n",
        "            \"2\", \"x\", \"dx\", \"+\", \"2\", \"y\", \"dy\", \"=0\"\n",
        "        )\n",
        "        self.color_equations(equation, derivative)\n",
        "        equation.to_edge(UP)\n",
        "        equation.shift(MED_LARGE_BUFF*LEFT)\n",
        "        derivative.next_to(equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(equation),\n",
        "            self.pi_creature.change_mode, \"plain\",\n",
        "            self.pi_creature.look_at, equation\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                equation[i].copy(), derivative[j],\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            for i, j in enumerate([1, 0, 3, 5, 4, 7])\n",
        "        ]+[\n",
        "            Write(derivative[j])\n",
        "            for j in (2, 6)\n",
        "        ])\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look_at, derivative\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "        self.derivative = derivative\n",
        "\n",
        "    def comment_on_ladder_derivative(self):\n",
        "        equation = self.equation\n",
        "        derivative = self.derivative\n",
        "\n",
        "        time_equation = OldTex(\n",
        "            \"x(t)\", \"^2\", \"+\", \"y(t)\", \"^2\", \"= 5^2\"\n",
        "        )\n",
        "        time_derivative = OldTex(\n",
        "            \"2\", \"x(t)\", \"\\\\frac{dx}{dt}\", \"+\", \n",
        "            \"2\", \"y(t)\", \"\\\\frac{dy}{dt}\", \"=0\"\n",
        "        )\n",
        "        self.color_equations(time_equation, time_derivative)\n",
        "        time_equation.move_to(equation)\n",
        "        time_derivative.move_to(derivative, UP)\n",
        "\n",
        "        brace = Brace(time_derivative)\n",
        "        brace_text = brace.get_text(\"A rate\")\n",
        "\n",
        "        equation.save_state()\n",
        "        derivative.save_state()\n",
        "\n",
        "        self.play(Transform(equation, time_equation))\n",
        "        self.wait()\n",
        "        self.play(Transform(derivative, time_derivative))\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(brace_text))\n",
        "        self.change_mode(\"hooray\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            equation.restore,\n",
        "            derivative.restore,\n",
        "            FadeOut(brace),\n",
        "            FadeOut(brace_text),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def comment_on_circle_derivative(self):\n",
        "        derivative = self.derivative\n",
        "        dx = derivative.get_part_by_tex(\"dx\")\n",
        "        dy = derivative.get_part_by_tex(\"dy\")\n",
        "\n",
        "        for mob in dx, dy:\n",
        "            brace = Brace(mob)\n",
        "            brace.next_to(mob[0], DOWN, buff = SMALL_BUFF, aligned_edge = LEFT)\n",
        "            text = brace.get_text(\"No $dt$\", buff = SMALL_BUFF)\n",
        "            text.set_color(YELLOW)\n",
        "\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "            self.pi_creature.look, DOWN+LEFT\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    #######\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Mortimer().to_edge(DOWN)\n",
        "        return self.pi_creature\n",
        "\n",
        "    def color_equations(self, equation, derivative):\n",
        "        for mob in equation[0], derivative[1]:\n",
        "            mob.set_color(GREEN)\n",
        "        for mob in equation[3], derivative[5]:\n",
        "            mob.set_color(RED)\n",
        "\n",
        "class TwoVariableFunctionAndDerivative(SlopeOfCircleExample):\n",
        "    CONFIG = {\n",
        "        \"zoomed_canvas_corner\" : DOWN+RIGHT,\n",
        "        \"zoomed_canvas_frame_shape\" : (3, 4),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.write_equation()\n",
        "        self.show_example_point()\n",
        "        self.shift_example_point((4, 4))\n",
        "        self.shift_example_point((3, 3))\n",
        "        self.shift_example_point(self.example_point)\n",
        "        self.take_derivative_symbolically()\n",
        "        self.show_dx_dy_step()\n",
        "        self.plug_in_example_values()\n",
        "        self.ask_about_equalling_zero()\n",
        "        self.show_tangent_step()\n",
        "        self.point_out_equalling_zero()\n",
        "        self.show_tangent_line()\n",
        "\n",
        "    def write_equation(self):\n",
        "        equation = OldTex(\"x\", \"^2\", \"+\", \"y\", \"^2\")\n",
        "        equation.add_background_rectangle()\n",
        "\n",
        "        brace = Brace(equation, UP, buff = SMALL_BUFF)\n",
        "        s_expression = self.get_s_expression(\"x\", \"y\")\n",
        "        s_rect, s_of_xy = s_expression\n",
        "        s, xy = s_of_xy\n",
        "        s_expression.next_to(brace, UP, buff = SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(equation, s_expression, brace)\n",
        "        group.shift(FRAME_WIDTH*LEFT/3)\n",
        "        group.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        s.save_state()\n",
        "        s.next_to(brace, UP)\n",
        "\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(s))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(s_rect),\n",
        "            s.restore, \n",
        "            GrowFromCenter(xy)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "        self.s_expression = s_expression\n",
        "\n",
        "    def show_example_point(self):\n",
        "        point = self.plane.num_pair_to_point(self.example_point)\n",
        "        dot = Dot(point, color = self.example_color)\n",
        "        new_s_expression = self.get_s_expression(*self.example_point)\n",
        "        new_s_expression.next_to(dot, UP+RIGHT, buff = 0)\n",
        "        new_s_expression.set_color(self.example_color)\n",
        "        equals_25 = OldTex(\"=%d\"%int(get_norm(self.example_point)**2))\n",
        "        equals_25.set_color(YELLOW)\n",
        "        equals_25.next_to(new_s_expression, RIGHT, align_using_submobjects = True)\n",
        "        equals_25.add_background_rectangle()\n",
        "\n",
        "        circle = Circle(\n",
        "            radius = self.circle_radius*self.plane.space_unit_to_x_unit,\n",
        "            color = self.circle_color,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.s_expression.copy(),\n",
        "                new_s_expression\n",
        "            ),\n",
        "            ShowCreation(dot)\n",
        "        )\n",
        "        self.play(ShowCreation(circle), Animation(dot))\n",
        "        self.play(Write(equals_25))\n",
        "        self.wait()\n",
        "\n",
        "        self.example_point_dot = dot\n",
        "        self.example_point_label = VGroup(\n",
        "            new_s_expression, equals_25\n",
        "        )\n",
        "\n",
        "    def shift_example_point(self, coords):\n",
        "        point = self.plane.num_pair_to_point(coords)\n",
        "        s_expression = self.get_s_expression(*coords)\n",
        "        s_expression.next_to(point, UP+RIGHT, buff = SMALL_BUFF)\n",
        "        s_expression.set_color(self.example_color)\n",
        "        result = coords[0]**2 + coords[1]**2\n",
        "        rhs = OldTex(\"=%d\"%int(result))\n",
        "        rhs.add_background_rectangle()\n",
        "        rhs.set_color(YELLOW)\n",
        "        rhs.next_to(s_expression, RIGHT, align_using_submobjects = True)\n",
        "        point_label = VGroup(s_expression, rhs)\n",
        "\n",
        "        self.play(\n",
        "            self.example_point_dot.move_to, point,\n",
        "            Transform(self.example_point_label, point_label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def take_derivative_symbolically(self):\n",
        "        equation = self.equation\n",
        "        derivative = OldTex(\n",
        "            \"dS =\", \"2\", \"x\", \"\\\\,dx\", \"+\", \"2\", \"y\", \"\\\\,dy\",\n",
        "        )\n",
        "        derivative[2].set_color(GREEN)\n",
        "        derivative[6].set_color(RED)\n",
        "        derivative.next_to(equation, DOWN, buff = MED_LARGE_BUFF)\n",
        "        derivative.add_background_rectangle()\n",
        "        derivative.to_edge(LEFT)\n",
        "\n",
        "        self.play(*[\n",
        "            FadeIn(derivative[0])\n",
        "        ]+[\n",
        "            ReplacementTransform(\n",
        "                self.s_expression[1][0].copy(),\n",
        "                derivative[1][0],\n",
        "            )\n",
        "        ]+[\n",
        "            Write(derivative[1][j])\n",
        "            for j in (3, 7)\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                equation[1][i].copy(), derivative[1][j],\n",
        "                path_arc = np.pi/2,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, (j-1)/12., (j+6)/12.)\n",
        "            )\n",
        "            for i, j in enumerate([2, 1, 4, 6, 5])\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        self.derivative = derivative\n",
        "\n",
        "    def show_dx_dy_step(self):\n",
        "        dot = self.example_point_dot\n",
        "        s_label = self.example_point_label\n",
        "        rhs = s_label[-1]\n",
        "        s_label.remove(rhs)\n",
        "\n",
        "        point = dot.get_center()\n",
        "        vect = 2*LEFT + DOWN\n",
        "        new_point = point + vect*0.6/self.zoom_factor\n",
        "        interim_point = new_point[0]*RIGHT + point[1]*UP\n",
        "\n",
        "        dx_line = Line(point, interim_point, color = GREEN)\n",
        "        dy_line = Line(interim_point, new_point, color = RED)\n",
        "        for line, tex, vect in (dx_line, \"dx\", UP), (dy_line, \"dy\", LEFT):\n",
        "            label = OldTex(tex)\n",
        "            label.set_color(line.get_color())\n",
        "            label.next_to(line, vect, buff = SMALL_BUFF)\n",
        "            label.add_background_rectangle()\n",
        "            label.scale(\n",
        "                1./self.zoom_factor, \n",
        "                about_point = line.get_center()\n",
        "            )\n",
        "            line.label = label\n",
        "\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle        \n",
        "        lil_rect.move_to(dot)\n",
        "        lil_rect.shift(0.05*lil_rect.get_width()*LEFT)\n",
        "        lil_rect.shift(0.2*lil_rect.get_height()*DOWN)\n",
        "        lil_rect.save_state()\n",
        "        lil_rect.set_height(FRAME_Y_RADIUS - MED_LARGE_BUFF)\n",
        "        lil_rect.move_to(s_label, UP)\n",
        "        lil_rect.shift(MED_SMALL_BUFF*UP)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(rhs),\n",
        "            dot.scale, 1./self.zoom_factor, point,\n",
        "            s_label.scale, 1./self.zoom_factor, point,\n",
        "            lil_rect.restore,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        for line in dx_line, dy_line:\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(Write(line.label, run_time = 1))\n",
        "            self.wait()\n",
        "\n",
        "        new_dot = Dot(color = dot.get_color())\n",
        "        new_s_label = self.get_s_expression(\n",
        "            \"%d + dx\"%int(self.example_point[0]),\n",
        "            \"%d + dy\"%int(self.example_point[1]),\n",
        "        )\n",
        "        new_dot.set_height(dot.get_height())\n",
        "        new_dot.move_to(new_point)\n",
        "        new_s_label.set_height(s_label.get_height())\n",
        "        new_s_label.scale(0.8)\n",
        "        new_s_label.next_to(\n",
        "            new_dot, DOWN, \n",
        "            buff = SMALL_BUFF/self.zoom_factor, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        new_s_label.shift(MED_LARGE_BUFF*LEFT/self.zoom_factor)\n",
        "        new_s_label.set_color(self.example_color)\n",
        "        VGroup(*new_s_label[1][1][3:5]).set_color(GREEN)\n",
        "        VGroup(*new_s_label[1][1][-3:-1]).set_color(RED)\n",
        "\n",
        "        self.play(ShowCreation(new_dot))\n",
        "        self.play(Write(new_s_label))\n",
        "        self.wait()\n",
        "\n",
        "        ds = self.derivative[1][0]\n",
        "        self.play(FocusOn(ds))\n",
        "        self.play(Indicate(ds))\n",
        "        self.wait()\n",
        "\n",
        "        self.tiny_step_group = VGroup(\n",
        "            dx_line, dx_line.label,\n",
        "            dy_line, dy_line.label,\n",
        "            s_label, new_s_label, new_dot\n",
        "        )\n",
        "\n",
        "    def plug_in_example_values(self):\n",
        "        deriv_example = OldTex(\n",
        "            \"dS =\", \"2\", \"(3)\", \"\\\\,(-0.02)\", \"+\", \"2\", \"(4)\", \"\\\\,(-0.01)\",\n",
        "        )\n",
        "\n",
        "        deriv_example[2].set_color(GREEN)\n",
        "        deriv_example[6].set_color(RED)\n",
        "        deriv_example.add_background_rectangle()\n",
        "        deriv_example.scale(0.8)\n",
        "        deriv_example.next_to(ORIGIN, UP, buff = SMALL_BUFF)\n",
        "        deriv_example.to_edge(LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        def add_example_parts(*indices):\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    self.derivative[1][i].copy(),\n",
        "                    deriv_example[1][i],\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for i in indices\n",
        "            ])\n",
        "\n",
        "        self.play(FadeIn(deriv_example[0]))\n",
        "        add_example_parts(0)\n",
        "        self.wait()\n",
        "        add_example_parts(1, 2, 4, 5, 6)\n",
        "        self.wait(2)\n",
        "        add_example_parts(3)\n",
        "        self.wait()\n",
        "        add_example_parts(7)\n",
        "        self.wait()\n",
        "\n",
        "        #React\n",
        "        randy = Randolph()\n",
        "        randy.next_to(ORIGIN, LEFT)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, deriv_example.get_left()\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look_at, deriv_example.get_right())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Indicate(self.equation),\n",
        "            randy.look_at, self.equation\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"thinking\",\n",
        "            randy.look_at, self.big_rectangle\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Approximately\",\n",
        "            target_mode = \"sassy\"\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(randy))\n",
        "        self.play(randy.look_at, deriv_example)\n",
        "        self.play(FadeOut(deriv_example))\n",
        "        self.wait()\n",
        "\n",
        "        self.randy = randy\n",
        "\n",
        "    def ask_about_equalling_zero(self):\n",
        "        dot = self.example_point_dot\n",
        "        randy = self.randy\n",
        "\n",
        "        equals_zero = OldTex(\"=0\")\n",
        "        equals_zero.set_color(YELLOW)\n",
        "        equals_zero.add_background_rectangle()\n",
        "        equals_zero.next_to(self.derivative, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(equals_zero),\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, equals_zero\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"plain\",\n",
        "            randy.look_at, self.big_rectangle,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.tiny_step_group),\n",
        "            self.little_rectangle.move_to, dot,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equals_zero = equals_zero\n",
        "\n",
        "    def show_tangent_step(self):\n",
        "        dot = self.example_point_dot\n",
        "        randy = self.randy\n",
        "\n",
        "        point = dot.get_center()\n",
        "        step_vect = rotate_vector(point, np.pi/2)/get_norm(point)\n",
        "        new_point = point + step_vect/self.zoom_factor\n",
        "        interim_point = point[0]*RIGHT + new_point[1]*UP\n",
        "        new_dot = dot.copy().move_to(new_point)\n",
        "\n",
        "        step_line = Line(point, new_point, color = WHITE)\n",
        "        dy_line = Line(point, interim_point, color = RED)\n",
        "        dx_line = Line(interim_point, new_point, color = GREEN)\n",
        "\n",
        "        s_label = OldTex(\"S = 25\")\n",
        "        s_label.set_color(self.example_color)\n",
        "        s_label.next_to(\n",
        "            point, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "        s_label.scale(1./self.zoom_factor, about_point = point)\n",
        "        arrow1, arrow2 = [\n",
        "            Arrow(\n",
        "                s_label.get_top(), mob,\n",
        "                preserve_tip_size_when_scaling = False,\n",
        "                color = self.example_color,\n",
        "                buff = SMALL_BUFF/self.zoom_factor,\n",
        "                tip_length = 0.15/self.zoom_factor\n",
        "            )\n",
        "            for mob in (dot, new_dot)\n",
        "        ]\n",
        "\n",
        "        for line, tex, vect in (dy_line, \"dy\", RIGHT), (dx_line, \"dx\", UP):\n",
        "            label = OldTex(tex)\n",
        "            label.set_color(line.get_color())\n",
        "            label.next_to(line, vect)\n",
        "            label.scale(\n",
        "                1./self.zoom_factor, \n",
        "                about_point = line.get_center()\n",
        "            )\n",
        "            line.label = label\n",
        "\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(Write(label))\n",
        "        self.play(ShowCreation(new_dot))\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, self.big_rectangle\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(s_label))\n",
        "        self.play(ShowCreation(arrow1))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(arrow1.copy(), arrow2))\n",
        "        self.wait(2)\n",
        "\n",
        "    def point_out_equalling_zero(self):\n",
        "        derivative = self.derivative\n",
        "        equals_zero = self.equals_zero\n",
        "        randy = self.randy\n",
        "\n",
        "        self.play(\n",
        "            FocusOn(equals_zero),\n",
        "            self.randy.look_at, equals_zero\n",
        "        )\n",
        "        self.play(Indicate(equals_zero, color = RED))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"happy\")\n",
        "        self.play(randy.look_at, self.big_rectangle)\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_tangent_line(self):\n",
        "        randy = self.randy\n",
        "        point = self.example_point_dot.get_center()\n",
        "        line = Line(ORIGIN, 5*RIGHT)\n",
        "        line.rotate(angle_of_vector(point)+np.pi/2)\n",
        "        line.move_to(point)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Approximately...\",\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(RemovePiCreatureBubble(randy))\n",
        "        self.play(\n",
        "            GrowFromCenter(line),\n",
        "            randy.look_at, line\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.little_rectangle.scale, self.zoom_factor/2,\n",
        "            run_time = 4,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ############\n",
        "\n",
        "    def get_s_expression(self, x, y):\n",
        "        result = OldTex(\"S\", \"(%s, %s)\"%(str(x), str(y)))\n",
        "        result.add_background_rectangle()\n",
        "        return result\n",
        "\n",
        "class TryOtherExamples(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\"\\\\sin(x)y^2 = x\")\n",
        "        formula.next_to(\n",
        "            self.get_teacher().get_corner(UP+LEFT), UP,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"\"\"Nothing special\n",
        "            about $x^2 + y^2 = 25$\"\"\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            self.get_teacher(),\n",
        "            target_mode = \"raise_right_hand\"\n",
        "        ))\n",
        "        self.play(Write(formula, run_time = 1))\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "        self.play(formula.to_corner, UP+LEFT)\n",
        "        self.wait()\n",
        "\n",
        "class AlternateExample(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"example_color\" : MAROON_B,\n",
        "        \"zoom_factor\" : 10,\n",
        "        \"zoomed_canvas_corner\" : DOWN+RIGHT,\n",
        "        \"zoomed_canvas_frame_shape\" : (3, 4),\n",
        "    }\n",
        "    def construct(self): \n",
        "        self.add_plane()\n",
        "        self.draw_graph()\n",
        "        self.emphasize_meaning_of_points()\n",
        "        self.zoom_in()\n",
        "        self.show_tiny_step()\n",
        "        self.ask_about_derivatives()\n",
        "        self.differentiate_lhs()\n",
        "        self.differentiate_rhs()\n",
        "        self.put_step_on_curve()\n",
        "        self.emphasize_equality()\n",
        "        self.manipulate_to_find_dy_dx()\n",
        "\n",
        "    def add_plane(self):\n",
        "        formula = OldTex(\"\\\\sin(x)y^2 = x\")\n",
        "        formula.to_corner(UP+LEFT)\n",
        "        formula.add_background_rectangle()\n",
        "\n",
        "        plane = NumberPlane(\n",
        "            space_unit_to_x_unit = 0.75,\n",
        "            x_radius = FRAME_WIDTH,\n",
        "        )\n",
        "        plane.fade()\n",
        "        plane.add_coordinates()\n",
        "\n",
        "        self.add(formula)\n",
        "        self.play(Write(plane, run_time = 2), Animation(formula))\n",
        "        self.wait()\n",
        "\n",
        "        self.plane = plane\n",
        "        self.formula = formula\n",
        "        self.lhs = VGroup(*formula[1][:8])\n",
        "        self.rhs = VGroup(formula[1][-1])\n",
        "\n",
        "    def draw_graph(self):\n",
        "        graphs = VGroup(*[\n",
        "            FunctionGraph(\n",
        "                lambda x : u*np.sqrt(x/np.sin(x)),\n",
        "                num_steps = 200,\n",
        "                x_min = x_min+0.1,\n",
        "                x_max = x_max-0.1,\n",
        "            )\n",
        "            for u in [-1, 1]\n",
        "            for x_min, x_max in [\n",
        "                (-4*np.pi, -2*np.pi),\n",
        "                (-np.pi, np.pi),\n",
        "                (2*np.pi, 4*np.pi),\n",
        "            ]\n",
        "        ])\n",
        "        graphs.stretch(self.plane.space_unit_to_x_unit, dim = 0)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                graphs, \n",
        "                run_time = 3, \n",
        "                lag_ratio = 0\n",
        "            ),\n",
        "            Animation(self.formula)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.graphs = graphs\n",
        "\n",
        "    def emphasize_meaning_of_points(self):\n",
        "        graph = self.graphs[4]\n",
        "        dot = Dot(color = self.example_color)\n",
        "        label = OldTex(\"(x, y)\")\n",
        "        label.add_background_rectangle()\n",
        "        label.set_color(self.example_color)\n",
        "\n",
        "        def update_dot(dot, alpha):\n",
        "            prop = interpolate(0.9, 0.1, alpha)\n",
        "            point = graph.point_from_proportion(prop)\n",
        "            dot.move_to(point)\n",
        "            return dot\n",
        "\n",
        "        def update_label(label):\n",
        "            point = dot.get_center()\n",
        "            vect = np.array(point)/get_norm(point)\n",
        "            vect[0] *= 2\n",
        "            vect[1] *= -1\n",
        "            label.move_to(\n",
        "                point + vect*0.4*label.get_width()\n",
        "            )\n",
        "\n",
        "        update_dot(dot, 0)\n",
        "        update_label(label)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(dot),\n",
        "            Write(label),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(dot, update_dot),\n",
        "            UpdateFromFunc(label, update_label),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                label[1][i].copy().move_to, self.formula[1][j],\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, count/6., count/6.+2./3)\n",
        "            )\n",
        "            for count, (i, j) in enumerate([(1, 4), (1, 9), (3, 6)])\n",
        "        ])\n",
        "        movers = self.get_mobjects_from_last_animation()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(dot, update_dot),\n",
        "            UpdateFromFunc(label, update_label),\n",
        "            run_time = 3,\n",
        "            rate_func = lambda t : 1-smooth(t)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(mover.set_fill, None, 0, remover = True)\n",
        "            for mover in movers\n",
        "        ])\n",
        "\n",
        "        self.dot = dot\n",
        "        self.label = label\n",
        "\n",
        "    def zoom_in(self):\n",
        "        dot = self.dot\n",
        "        label = self.label\n",
        "\n",
        "        self.activate_zooming()\n",
        "        self.little_rectangle.scale(self.zoom_factor)\n",
        "        self.little_rectangle.move_to(dot)\n",
        "        self.wait()\n",
        "        for mob in VGroup(dot, label), self.little_rectangle:\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    mob.scale, 1./self.zoom_factor,\n",
        "                    method_kwargs = {\"about_point\" : dot.get_center()},\n",
        "                    run_time = 1,\n",
        "                )\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def show_tiny_step(self):\n",
        "        dot = self.dot\n",
        "        label = self.label\n",
        "        point = dot.get_center()\n",
        "        step_vect = 1.2*(UP+LEFT)/float(self.zoom_factor)\n",
        "        new_point = point + step_vect\n",
        "        interim_point = new_point[0]*RIGHT + point[1]*UP\n",
        "\n",
        "        dx_line = Line(point, interim_point, color = GREEN)\n",
        "        dy_line = Line(interim_point, new_point, color = RED)\n",
        "        for line, tex, vect in (dx_line, \"dx\", DOWN), (dy_line, \"dy\", LEFT):\n",
        "            label = OldTex(tex)\n",
        "            label.next_to(line, vect, buff = SMALL_BUFF)\n",
        "            label.set_color(line.get_color())\n",
        "            label.scale(1./self.zoom_factor, about_point = line.get_center())\n",
        "            label.add_background_rectangle()\n",
        "            line.label = label\n",
        "\n",
        "        arrow = Arrow(\n",
        "            point, new_point, buff = 0,\n",
        "            tip_length = 0.15/self.zoom_factor,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        for line in dx_line, dy_line:\n",
        "            self.play(ShowCreation(line), Animation(arrow))\n",
        "            self.play(Write(line.label, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "        self.step_group = VGroup(\n",
        "            arrow, dx_line, dx_line.label, dy_line, dy_line.label\n",
        "        )\n",
        "\n",
        "    def ask_about_derivatives(self):\n",
        "        formula = self.formula\n",
        "        lhs, rhs = self.lhs, self.rhs\n",
        "\n",
        "        word = OldTexText(\"Change?\")\n",
        "        word.add_background_rectangle()\n",
        "        word.next_to(\n",
        "            Line(lhs.get_center(), rhs.get_center()),\n",
        "            DOWN, buff = 1.5*LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(word, part)\n",
        "            for part in (lhs, rhs)\n",
        "        ])\n",
        "\n",
        "        self.play(FocusOn(formula))\n",
        "        self.play(\n",
        "            Write(word),\n",
        "            ShowCreation(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [word, arrows])))\n",
        "\n",
        "    def differentiate_lhs(self):\n",
        "        formula = self.formula\n",
        "        lhs = self.lhs\n",
        "        brace = Brace(lhs, DOWN, buff = SMALL_BUFF)\n",
        "        sine_x = VGroup(*lhs[:6])\n",
        "        sine_rect = BackgroundRectangle(sine_x)\n",
        "        y_squared = VGroup(*lhs[6:])\n",
        "\n",
        "        mnemonic = OldTexText(\n",
        "            \"``\", \n",
        "            \"Left\", \" d-Right\", \" + \",\n",
        "            \"Right\",  \" d-Left\"\n",
        "            \"''\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        mnemonic.set_color_by_tex(\"d-Right\", RED)\n",
        "        mnemonic.set_color_by_tex(\"d-Left\", GREEN)\n",
        "        mnemonic.add_background_rectangle()\n",
        "        mnemonic.set_width(FRAME_X_RADIUS-2*MED_LARGE_BUFF)\n",
        "        mnemonic.next_to(ORIGIN, UP)\n",
        "        mnemonic.to_edge(LEFT)\n",
        "\n",
        "        derivative = OldTex(\n",
        "            \"\\\\sin(x)\", \"(2y\\\\,dy)\", \"+\", \n",
        "            \"y^2\", \"(\\\\cos(x)\\\\,dx)\",\n",
        "        )\n",
        "        derivative.set_color_by_tex(\"dx\", GREEN)\n",
        "        derivative.set_color_by_tex(\"dy\", RED)\n",
        "        derivative.set_width(FRAME_X_RADIUS - 2*MED_LARGE_BUFF)\n",
        "        derivative.next_to(\n",
        "            brace, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        derivative_rects = [\n",
        "            BackgroundRectangle(VGroup(*subset))\n",
        "            for subset in (derivative[:2], derivative[2:])\n",
        "        ]\n",
        "        derivative_rects[1].stretch(1.05, dim = 0)\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(mnemonic))\n",
        "        self.wait()\n",
        "        pairs = [\n",
        "            (sine_rect, derivative_rects[0]),\n",
        "            (sine_x, derivative[0]),\n",
        "            (y_squared, derivative[1]),\n",
        "            (sine_rect, derivative_rects[1]),\n",
        "            (y_squared, derivative[2]),\n",
        "            (y_squared, derivative[3]),\n",
        "            (sine_x, derivative[4]),\n",
        "        ]\n",
        "        for pairs_subset in pairs[:3], pairs[3:]:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(m1.copy(), m2, path_arc = np.pi/2)\n",
        "                for m1, m2 in pairs_subset\n",
        "            ])\n",
        "            self.wait()\n",
        "            self.play(Indicate(pairs_subset[-1][1]))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(FadeOut(mnemonic))\n",
        "\n",
        "        self.lhs_derivative = VGroup(*derivative_rects+[derivative])\n",
        "        self.lhs_brace = brace\n",
        "\n",
        "    def differentiate_rhs(self):\n",
        "        lhs_derivative = self.lhs_derivative\n",
        "        lhs_brace = self.lhs_brace\n",
        "        rhs = self.rhs\n",
        "\n",
        "        equals, dx = equals_dx = OldTex(\"=\", \"dx\")\n",
        "        equals_dx.scale(0.9)\n",
        "        equals_dx.set_color_by_tex(\"dx\", GREEN)\n",
        "        equals_dx.add_background_rectangle()\n",
        "        equals_dx.next_to(lhs_derivative, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        circle = Circle(color = GREEN)\n",
        "        circle.replace(self.rhs)\n",
        "        circle.scale(1.7)\n",
        "\n",
        "        arrow = Arrow(rhs.get_right(), dx.get_top())\n",
        "        arrow.set_color(GREEN)\n",
        "\n",
        "        self.play(ReplacementTransform(lhs_brace, circle))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(equals_dx))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [circle, arrow])))\n",
        "\n",
        "        self.equals_dx = equals_dx\n",
        "\n",
        "    def put_step_on_curve(self):\n",
        "        dot = self.dot\n",
        "        point = dot.get_center()\n",
        "        graph = self.graphs[4]\n",
        "        arrow, dx_line, dx_line.label, dy_line, dy_line.label = self.step_group\n",
        "\n",
        "        #Find graph point at right x_val\n",
        "        arrow_end = arrow.get_end()\n",
        "        graph_points = [\n",
        "            graph.point_from_proportion(alpha)\n",
        "            for alpha in np.linspace(0, 1, 1000)\n",
        "        ]\n",
        "        distances = np.apply_along_axis(\n",
        "            lambda p : np.abs(p[0] - arrow_end[0]),\n",
        "            1, graph_points\n",
        "        )\n",
        "        index = np.argmin(distances)\n",
        "        new_end_point = graph_points[index]\n",
        "\n",
        "        lil_rect = self.little_rectangle\n",
        "        self.play(\n",
        "            arrow.put_start_and_end_on, point, new_end_point,\n",
        "            dy_line.put_start_and_end_on, \n",
        "                dy_line.get_start(), new_end_point,\n",
        "            MaintainPositionRelativeTo(dy_line.label, dy_line),\n",
        "            lil_rect.shift, lil_rect.get_height()*DOWN/3,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def emphasize_equality(self):\n",
        "        self.play(FocusOn(self.lhs))\n",
        "        self.wait()\n",
        "        for mob in self.lhs, self.rhs:\n",
        "            self.play(Indicate(mob))\n",
        "        self.wait()\n",
        "\n",
        "    def manipulate_to_find_dy_dx(self):\n",
        "        full_derivative = VGroup(\n",
        "            self.lhs_derivative, self.equals_dx\n",
        "        )\n",
        "        brace = Brace(full_derivative, DOWN, buff = SMALL_BUFF)\n",
        "        words = brace.get_text(\n",
        "            \"Commonly, solve for\", \"$dy/dx$\",\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        VGroup(*words[1][:2]).set_color(RED)\n",
        "        VGroup(*words[1][3:]).set_color(GREEN)\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.look_at(full_derivative)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change_mode, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutNaturalLog(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        exp_deriv = OldTex(\"\\\\frac{d(e^x)}{dx} = e^x\")\n",
        "        for i in 2, 3, 9, 10:\n",
        "            exp_deriv[i].set_color(BLUE)\n",
        "        log_deriv = OldTex(\"\\\\frac{d(\\\\ln(x))}{dx} = ???\")\n",
        "        VGroup(*log_deriv[2:2+5]).set_color(GREEN)\n",
        "\n",
        "        for deriv in exp_deriv, log_deriv:\n",
        "            deriv.next_to(self.get_teacher().get_corner(UP+LEFT), UP)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"\"\"We can find\n",
        "            new derivatives\"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            self.get_teacher(),\n",
        "            target_mode = \"raise_right_hand\"\n",
        "        ))\n",
        "        self.play(Write(exp_deriv))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(log_deriv),\n",
        "            exp_deriv.next_to, log_deriv, UP, LARGE_BUFF,\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"confused\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class DerivativeOfNaturalLog(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"zoom_factor\" : 10,\n",
        "        \"zoomed_canvas_corner\" : DOWN+RIGHT,\n",
        "        \"example_color\" : MAROON_B,\n",
        "    }\n",
        "    def construct(self):\n",
        "        should_skip_animations = self.skip_animations\n",
        "        self.skip_animations = True\n",
        "\n",
        "        self.add_plane()\n",
        "        self.draw_graph()\n",
        "        self.describe_as_implicit_curve()\n",
        "        self.slope_gives_derivative()\n",
        "        self.rearrange_equation()\n",
        "        self.take_derivative()\n",
        "        self.show_tiny_nudge()\n",
        "        self.note_derivatives()\n",
        "        self.solve_for_dy_dx()\n",
        "        self.skip_animations = should_skip_animations\n",
        "        self.show_slope_above_x()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = NumberPlane()\n",
        "        plane.fade()\n",
        "        plane.add_coordinates()\n",
        "        self.add(plane)\n",
        "        self.plane = plane\n",
        "\n",
        "    def draw_graph(self):\n",
        "        graph = FunctionGraph(\n",
        "            np.log, \n",
        "            x_min = 0.01, \n",
        "            x_max = FRAME_X_RADIUS,\n",
        "            num_steps = 100\n",
        "        )\n",
        "        formula = OldTex(\"y = \\\\ln(x)\")\n",
        "        formula.next_to(ORIGIN, LEFT, buff = MED_LARGE_BUFF)\n",
        "        formula.to_edge(UP)\n",
        "        formula.add_background_rectangle()\n",
        "\n",
        "        self.add(formula)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.wait()\n",
        "\n",
        "        self.formula = formula\n",
        "        self.graph = graph\n",
        "\n",
        "    def describe_as_implicit_curve(self):\n",
        "        formula = self.formula #y = ln(x)\n",
        "        graph = self.graph\n",
        "\n",
        "        dot = Dot(color = self.example_color)\n",
        "        label = OldTex(\"(x, y)\")\n",
        "        label.add_background_rectangle()\n",
        "        label.set_color(self.example_color)\n",
        "\n",
        "        def update_dot(dot, alpha):\n",
        "            prop = interpolate(0.1, 0.7, alpha)\n",
        "            point = graph.point_from_proportion(prop)\n",
        "            dot.move_to(point)\n",
        "            return dot\n",
        "\n",
        "        def update_label(label):\n",
        "            point = dot.get_center()\n",
        "            vect = point - FRAME_Y_RADIUS*(DOWN+RIGHT)\n",
        "            vect = vect/get_norm(vect)\n",
        "            label.move_to(\n",
        "                point + vect*0.5*label.get_width()\n",
        "            )\n",
        "\n",
        "        update_dot(dot, 0)\n",
        "        update_label(label)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [dot, label])))\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(dot, update_dot),\n",
        "            UpdateFromFunc(label, update_label),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        xy_start = VGroup(label[1][1], label[1][3]).copy()\n",
        "        xy_end = VGroup(formula[1][5], formula[1][0]).copy()\n",
        "        xy_end.set_color(self.example_color)\n",
        "        self.play(Transform(\n",
        "            xy_start, xy_end,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(dot, update_dot),\n",
        "            UpdateFromFunc(label, update_label),\n",
        "            run_time = 3,\n",
        "            rate_func = lambda t : 1-0.6*smooth(t),\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [xy_start, label])))\n",
        "\n",
        "        self.dot = dot\n",
        "\n",
        "    def slope_gives_derivative(self):\n",
        "        dot = self.dot\n",
        "        point = dot.get_center()\n",
        "        line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        slope = 1./point[0]\n",
        "        line.rotate(np.arctan(slope))\n",
        "        line.move_to(point)\n",
        "\n",
        "        new_point = line.point_from_proportion(0.6)\n",
        "        interim_point = point[0]*RIGHT + new_point[1]*UP\n",
        "        dy_line = Line(point, interim_point, color = RED)\n",
        "        dx_line = Line(interim_point, new_point, color = GREEN)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\text{Slope} = \",\n",
        "            \"\\\\frac{dy}{dx} = \",\n",
        "            \"\\\\frac{d(\\\\ln(x))}{dx}\",\n",
        "        )\n",
        "        VGroup(*equation[1][:2]).set_color(RED)\n",
        "        VGroup(*equation[2][:8]).set_color(RED)\n",
        "        VGroup(*equation[1][3:5]).set_color(GREEN)\n",
        "        VGroup(*equation[2][-2:]).set_color(GREEN)\n",
        "        for part in equation:\n",
        "            rect = BackgroundRectangle(part)\n",
        "            rect.stretch_in_place(1.2, 0)\n",
        "            part.add_to_back(rect)\n",
        "        equation.scale(0.8)\n",
        "        equation.next_to(ORIGIN, RIGHT)\n",
        "        equation.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(line),\n",
        "            Animation(dot)\n",
        "        )\n",
        "        self.play(ShowCreation(VGroup(dy_line, dx_line)))\n",
        "        for part in equation:\n",
        "            self.play(Write(part, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.dx_line, self.dy_line = dx_line, dy_line\n",
        "        self.slope_equation = equation\n",
        "        self.tangent_line = line\n",
        "\n",
        "    def rearrange_equation(self):\n",
        "        formula = self.formula\n",
        "        y, eq = formula[1][:2]\n",
        "        ln = VGroup(*formula[1][2:4])\n",
        "        x = formula[1][5]\n",
        "\n",
        "        new_formula = OldTex(\"e\", \"^y\", \"=\", \"x\")\n",
        "        e, new_y, new_eq, new_x = new_formula\n",
        "        new_formula.next_to(\n",
        "            formula, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "        )\n",
        "        rect = BackgroundRectangle(new_formula)\n",
        "\n",
        "        y = new_y.copy().replace(y)\n",
        "        self.play(Indicate(formula, scale_factor = 1))\n",
        "        self.play(ReplacementTransform(ln.copy(), e))\n",
        "        self.play(ReplacementTransform(y, new_y))\n",
        "        self.play(ReplacementTransform(eq.copy(), new_eq))\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Animation(VGroup(e, new_y, new_eq)),\n",
        "            ReplacementTransform(x.copy(), new_x)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for mob in e, new_y, new_x:\n",
        "            self.play(Indicate(mob))\n",
        "        self.wait()\n",
        "\n",
        "        self.new_formula = new_formula\n",
        "\n",
        "    def take_derivative(self):\n",
        "        new_formula = self.new_formula\n",
        "        e, y, eq, x = new_formula\n",
        "        derivative = OldTex(\"e\", \"^y\", \"\\\\,dy\", \"=\", \"dx\")\n",
        "        new_e, new_y, dy, new_eq, dx = derivative\n",
        "        derivative.next_to(new_formula, DOWN, MED_LARGE_BUFF)\n",
        "        derivative.add_background_rectangle()\n",
        "        dx.set_color(GREEN)\n",
        "        dy.set_color(RED)\n",
        "\n",
        "        pairs = [\n",
        "            (VGroup(e, y), VGroup(new_e, new_y)),\n",
        "            (new_y, dy),\n",
        "            (eq, new_eq),\n",
        "            (x, dx)\n",
        "        ]\n",
        "        for start, target in pairs:\n",
        "            self.play(\n",
        "                ReplacementTransform(start.copy(), target)\n",
        "            )\n",
        "        self.play(FadeIn(derivative[0]), Animation(derivative[1]))\n",
        "        self.remove(derivative, pairs[0][1])\n",
        "        self.add(derivative)\n",
        "        self.wait()\n",
        "\n",
        "        self.derivative = derivative\n",
        "\n",
        "    def show_tiny_nudge(self):\n",
        "        dot = self.dot\n",
        "        point = dot.get_center()\n",
        "        dx_line = self.dx_line\n",
        "        dy_line = self.dy_line\n",
        "        group = VGroup(dot, dx_line, dy_line)\n",
        "        self.play(group.scale, 1./self.zoom_factor, point)\n",
        "        for line, tex, vect in (dx_line, \"dx\", UP), (dy_line, \"dy\", LEFT):\n",
        "            label = OldTex(tex)\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(line, vect, buff = SMALL_BUFF)\n",
        "            label.set_color(line.get_color())\n",
        "            label.scale(\n",
        "                1./self.zoom_factor, \n",
        "                about_point = line.get_center()\n",
        "            )\n",
        "            line.label = label\n",
        "\n",
        "        self.activate_zooming()\n",
        "        lil_rect = self.little_rectangle\n",
        "        lil_rect.move_to(group)\n",
        "        lil_rect.scale(self.zoom_factor)\n",
        "        self.play(lil_rect.scale, 1./self.zoom_factor)\n",
        "        self.play(Write(dx_line.label))\n",
        "        self.play(Write(dy_line.label))\n",
        "        self.wait()\n",
        "\n",
        "    def note_derivatives(self):\n",
        "        e, y, dy, eq, dx = self.derivative[1]\n",
        "\n",
        "        self.play(FocusOn(e))\n",
        "        self.play(Indicate(VGroup(e, y, dy)))\n",
        "        self.wait()\n",
        "        self.play(Indicate(dx))\n",
        "        self.wait()\n",
        "\n",
        "    def solve_for_dy_dx(self):\n",
        "        e, y, dy, eq, dx = self.derivative[1]\n",
        "        ey_group = VGroup(e, y)\n",
        "        original_rect = self.derivative[0]\n",
        "\n",
        "        rearranged = OldTex(\n",
        "            \"{dy \\\\over \", \" dx}\", \"=\", \"{1 \\\\over \", \"e\", \"^y}\"\n",
        "        )\n",
        "        new_dy, new_dx, new_eq, one_over, new_e, new_y = rearranged\n",
        "        new_ey_group = VGroup(new_e, new_y)\n",
        "        new_dx.set_color(GREEN)\n",
        "        new_dy.set_color(RED)\n",
        "        rearranged.shift(eq.get_center() - new_eq.get_center())\n",
        "        rearranged.shift(MED_SMALL_BUFF*DOWN)\n",
        "        new_rect = BackgroundRectangle(rearranged)\n",
        "\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                m1, m2, \n",
        "                run_time = 2,\n",
        "                path_arc = -np.pi/2,\n",
        "            )\n",
        "            for m1, m2 in [\n",
        "                (original_rect, new_rect),\n",
        "                (dx, new_dx),\n",
        "                (dy, new_dy),\n",
        "                (eq, new_eq),\n",
        "                (ey_group, new_ey_group),\n",
        "                (e.copy(), one_over)\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        #Change denominator\n",
        "        e, y, eq, x = self.new_formula\n",
        "        ey_group = VGroup(e, y).copy()\n",
        "        ey_group.set_color(YELLOW)\n",
        "        x_copy = x.copy()\n",
        "\n",
        "        self.play(new_ey_group.set_color, YELLOW)\n",
        "        self.play(Transform(new_ey_group, ey_group))\n",
        "        self.play(\n",
        "            new_ey_group.set_color, WHITE,\n",
        "            x_copy.set_color, YELLOW\n",
        "        )\n",
        "        self.play(x_copy.next_to, one_over, DOWN, MED_SMALL_BUFF)\n",
        "        self.wait(2)\n",
        "\n",
        "        equals_one_over_x = VGroup(\n",
        "            new_eq, one_over, x_copy\n",
        "        ).copy()\n",
        "        rect = BackgroundRectangle(equals_one_over_x)\n",
        "        rect.stretch_in_place(1.1, dim = 0)\n",
        "        equals_one_over_x.add_to_back(rect)\n",
        "\n",
        "        self.play(\n",
        "            equals_one_over_x.next_to, \n",
        "            self.slope_equation, RIGHT, 0,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_slope_above_x(self):\n",
        "        line = self.tangent_line\n",
        "        start_x = line.get_center()[0]\n",
        "        target_x = 0.2\n",
        "        graph = FunctionGraph(\n",
        "            lambda x : 1./x, \n",
        "            x_min = 0.1,\n",
        "            x_max = FRAME_X_RADIUS,\n",
        "            num_steps = 100,\n",
        "            color = PINK,\n",
        "        )\n",
        "\n",
        "        def update_line(line, alpha):\n",
        "            x = interpolate(start_x, target_x, alpha)\n",
        "            point = x*RIGHT + np.log(x)*UP\n",
        "            angle = np.arctan(1./x)\n",
        "            line.rotate(angle - line.get_angle())\n",
        "            line.move_to(point)\n",
        "\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            line, update_line,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 6\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(graph, run_time = 3))\n",
        "        self.wait()\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            line, update_line,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 6\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class FinalWords(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"This is a peek into \\\\\\\\\",\n",
        "            \"Multivariable\", \"calculus\"\n",
        "        )\n",
        "        mvc = VGroup(*words[1:])\n",
        "        words.set_color_by_tex(\"Multivariable\", YELLOW)\n",
        "        formula = OldTex(\"f(x, y) = \\\\sin(x)y^2\")\n",
        "        formula.next_to(self.get_teacher().get_corner(UP+LEFT), UP)\n",
        "\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(\"erm\", \"hooray\", \"sassy\")\n",
        "        self.play(\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            FadeOut(VGroup(*words[:1])),\n",
        "            mvc.to_corner, UP+LEFT,\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            self.teacher.look_at, formula,\n",
        "            Write(formula, run_time = 2),\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"thinking\")\n",
        "        self.wait(3)\n",
        "\n",
        "        ##Show series\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        video = series[5]\n",
        "        lim = OldTex(\"\\\\lim_{h \\\\to 0} \\\\frac{f(x+h)-f(x)}{h}\")\n",
        "        self.play(\n",
        "            FadeOut(mvc),\n",
        "            FadeOut(formula),\n",
        "            self.teacher.change_mode, \"plain\",\n",
        "            FadeIn(\n",
        "                series, run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            video.set_color, YELLOW,\n",
        "            video.shift, video.get_height()*DOWN/2\n",
        "        )\n",
        "        lim.next_to(video, DOWN)\n",
        "        self.play(\n",
        "            Write(lim),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"pondering\", pi.look_at, lim]\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ])\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class Chapter6PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali  Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Nathan Pellegrin\",\n",
        "            \"Karan Bhargava\", \n",
        "            \"Justin Helps\",\n",
        "            \"Ankit   Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Daan Smedinga\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Nils Schneider\",\n",
        "            \"Albert Nguyen\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(AlternateExample):\n",
        "    def construct(self):\n",
        "        title = VGroup(*list(map(TexText, [\n",
        "            \"Implicit\", \"Differentiation\"\n",
        "        ])))\n",
        "        title.arrange(DOWN)\n",
        "        title.scale(3)\n",
        "        title.next_to(ORIGIN, UP)\n",
        "\n",
        "        for word in title:\n",
        "            word.add_background_rectangle()\n",
        "\n",
        "        self.add_plane()\n",
        "        self.draw_graph()\n",
        "        self.graphs.set_stroke(width = 8)\n",
        "        self.remove(self.formula)\n",
        "        self.add(title)\n"
    ]
}