{
    "topic": "The mathematical concept being demonstrated is the dot product. The code is using Manim to visualize the",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.lost_lecture import ShowWord\n",
        "from _2019.clacks.solution2.mirror_scenes import ReflectWorldThroughMirrorNew\n",
        "from _2019.clacks.question import Thumbnail\n",
        "\n",
        "\n",
        "class WrapperScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"title\": \"Title\",\n",
        "        \"shade_of_grey\": \"#333333\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title = OldTexText(self.title)\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        big_rect = self.get_big_rect()\n",
        "        screen_rect = self.get_screen_rect()\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(big_rect, screen_rect)\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            FadeIn(title, DOWN),\n",
        "            FadeIn(screen_rect, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_big_rect(self):\n",
        "        big_rect = FullScreenFadeRectangle()\n",
        "        big_rect.set_fill(self.shade_of_grey, 1)\n",
        "        return big_rect\n",
        "\n",
        "    def get_screen_rect(self, height=6):\n",
        "        screen_rect = ScreenRectangle(height=height)\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        return screen_rect\n",
        "\n",
        "\n",
        "class ComingUpWrapper(WrapperScene):\n",
        "    CONFIG = {\"title\": \"Coming up...\"}\n",
        "\n",
        "\n",
        "class LastVideoWrapper(WrapperScene):\n",
        "    CONFIG = {\"title\": \"Last time...\"}\n",
        "\n",
        "\n",
        "class LeftEdge(Scene):\n",
        "    CONFIG = {\n",
        "        \"text\": \"Left edge\",\n",
        "        \"vect\": LEFT,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        words = OldTexText(self.text)\n",
        "        arrow = Vector(self.vect)\n",
        "        arrow.match_width(words)\n",
        "        arrow.next_to(words, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(words),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RightEdge(LeftEdge):\n",
        "    CONFIG = {\n",
        "        \"text\": \"Right edge\",\n",
        "        \"vect\": RIGHT,\n",
        "    }\n",
        "\n",
        "\n",
        "class NoteOnEnergyLostToSound(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\n",
        "            \"Yeah yeah, the clack sound\\\\\\\\\"\n",
        "            \"would require energy, but\\\\\\\\\"\n",
        "            \"don't let accuracy get in the\\\\\\\\\"\n",
        "            \"way of delight!\",\n",
        "            alignment=\"\",\n",
        "        ))\n",
        "\n",
        "\n",
        "class DotProductVideoWrapper(WrapperScene):\n",
        "    CONFIG = {\"title\": \"Dot product\"}\n",
        "\n",
        "\n",
        "class Rectangle(Scene):\n",
        "    def construct(self):\n",
        "        rect = ScreenRectangle(height=FRAME_HEIGHT - 0.25)\n",
        "        rect.set_stroke(WHITE, 6)\n",
        "        self.add(rect)\n",
        "\n",
        "\n",
        "class ShowRectangleCreation(Scene):\n",
        "    def construct(self):\n",
        "        rect = ScreenRectangle(height=2)\n",
        "        rect.set_stroke(YELLOW, 6)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class ShowDotProductMeaning(Scene):\n",
        "    def construct(self):\n",
        "        v_vect = Vector(2 * RIGHT, color=YELLOW)\n",
        "        w_vect = Vector(3 * RIGHT, color=PINK)\n",
        "        dot = Dot(color=RED)\n",
        "        dot.shift(DOWN)\n",
        "\n",
        "        v_vect.angle_tracker = ValueTracker()\n",
        "        w_vect.angle_tracker = ValueTracker()\n",
        "\n",
        "        def update_vect(vect):\n",
        "            target = vect.angle_tracker.get_value()\n",
        "            vect.rotate(target - vect.get_angle())\n",
        "            vect.shift(dot.get_center() - vect.get_start())\n",
        "\n",
        "        v_vect.add_updater(update_vect)\n",
        "        w_vect.add_updater(update_vect)\n",
        "\n",
        "        v_label = OldTex(\"\\\\vec{\\\\textbf{v}}\")\n",
        "        v_label.vect = v_vect\n",
        "        w_label = OldTex(\"\\\\vec{\\\\textbf{w}}\")\n",
        "        w_label.vect = w_vect\n",
        "        for label in v_label, w_label:\n",
        "            label.match_color(label.vect)\n",
        "            label.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        def update_label(label):\n",
        "            target = np.array(label.vect.get_end())\n",
        "            target += 0.25 * normalize(label.vect.get_vector())\n",
        "            label.move_to(target)\n",
        "\n",
        "        v_label.add_updater(update_label)\n",
        "        w_label.add_updater(update_label)\n",
        "\n",
        "        title = OldTex(\n",
        "            \"\\\\vec{\\\\textbf{w}}\",\n",
        "            \"\\\\cdot\",\n",
        "            \"\\\\vec{\\\\textbf{v}}\",\n",
        "            \"=\",\n",
        "            \"||\", \"\\\\vec{\\\\textbf{w}}\", \"||\",\n",
        "            \"\\\\cdot\",\n",
        "            \"||\", \"\\\\vec{\\\\textbf{v}}\", \"||\",\n",
        "            \"\\\\cdot\",\n",
        "            \"\\\\cos(\\\\theta)\"\n",
        "        )\n",
        "        title.set_color_by_tex_to_color_map({\n",
        "            \"textbf{v}\": v_vect.get_color(),\n",
        "            \"textbf{w}\": w_vect.get_color(),\n",
        "        })\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        def get_w_line():\n",
        "            center = dot.get_center()\n",
        "            direction = w_vect.get_vector()\n",
        "            return Line(\n",
        "                center - 3 * direction,\n",
        "                center + 3 * direction,\n",
        "                stroke_color=GREY_B,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "        w_line = always_redraw(get_w_line)\n",
        "\n",
        "        def get_proj_v():\n",
        "            center = dot.get_center()\n",
        "            v = v_vect.get_vector()\n",
        "            w = w_vect.get_vector()\n",
        "            w_unit = normalize(w)\n",
        "            result = Vector(np.dot(v, w_unit) * w_unit)\n",
        "            result.set_fill(v_vect.get_color(), 0.5)\n",
        "            result.shift(center - result.get_start())\n",
        "            return result\n",
        "        proj_v = always_redraw(get_proj_v)\n",
        "\n",
        "        def get_proj_line():\n",
        "            return DashedLine(\n",
        "                v_vect.get_end(),\n",
        "                proj_v.get_end(),\n",
        "                stroke_width=1,\n",
        "                dash_length=0.025,\n",
        "            )\n",
        "        proj_line = always_redraw(get_proj_line)\n",
        "\n",
        "        template_line = Line(LEFT, RIGHT)\n",
        "\n",
        "        def get_vect_brace(vect):\n",
        "            brace = Brace(template_line, UP, buff=SMALL_BUFF)\n",
        "            brace.set_width(vect.get_length(), stretch=True)\n",
        "            angle = vect.get_angle() % TAU\n",
        "            if angle < PI:\n",
        "                angle += PI\n",
        "            brace.rotate(angle, about_point=ORIGIN)\n",
        "            brace.shift(vect.get_center())\n",
        "            return brace\n",
        "        w_brace = always_redraw(\n",
        "            lambda: get_vect_brace(w_vect)\n",
        "        )\n",
        "        proj_v_brace = always_redraw(\n",
        "            lambda: get_vect_brace(proj_v)\n",
        "        )\n",
        "\n",
        "        def get_arc():\n",
        "            center = dot.get_center()\n",
        "            a1 = w_vect.get_angle()\n",
        "            a2 = v_vect.get_angle()\n",
        "            arc = Arc(\n",
        "                start_angle=a1,\n",
        "                angle=a2 - a1,\n",
        "                radius=0.5,\n",
        "                arc_center=center,\n",
        "            )\n",
        "            theta = OldTex(\"\\\\theta\")\n",
        "            p = arc.point_from_proportion(0.5)\n",
        "            theta.move_to(\n",
        "                center + 1.5 * (p - center)\n",
        "            )\n",
        "            return VGroup(arc, theta)\n",
        "        arc = always_redraw(get_arc)\n",
        "\n",
        "        self.add(\n",
        "            title[:3],\n",
        "            w_vect, v_vect, dot,\n",
        "            w_label, v_label,\n",
        "        )\n",
        "        self.play(\n",
        "            v_vect.angle_tracker.set_value, 170 * DEGREES,\n",
        "            w_vect.angle_tracker.set_value, 45 * DEGREES,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        w_brace.update()\n",
        "        self.play(\n",
        "            GrowFromCenter(w_brace),\n",
        "            Write(title[3:7])\n",
        "        )\n",
        "\n",
        "        self.add(w_line, w_vect, w_label, dot)\n",
        "        self.play(ShowCreation(w_line))\n",
        "        proj_v.update()\n",
        "        self.play(\n",
        "            ShowCreation(proj_line),\n",
        "            TransformFromCopy(v_vect, proj_v),\n",
        "        )\n",
        "        self.add(proj_v, proj_line, dot)\n",
        "        proj_v_brace.update()\n",
        "        self.play(\n",
        "            GrowFromCenter(proj_v_brace),\n",
        "            FadeInFromDown(title[7:])\n",
        "        )\n",
        "        arc.update()\n",
        "        self.play(Write(arc))\n",
        "        self.wait()\n",
        "\n",
        "        for angle in [135, 225, 270, 90, 150]:\n",
        "            self.play(\n",
        "                v_vect.angle_tracker.set_value, angle * DEGREES,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class FinalComment(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\n",
        "            \"Thoughts on what ending should go here?\\\\\\\\\"\n",
        "            \"See the Patreon post.\"\n",
        "        ))\n",
        "\n",
        "\n",
        "class FourtyFiveDegreeLine(Scene):\n",
        "    CONFIG = {\n",
        "        \"angle\": 45 * DEGREES,\n",
        "        \"label_config\": {\n",
        "            \"num_decimal_places\": 0,\n",
        "            \"unit\": \"^\\\\circ\",\n",
        "            \"label_height\": 0.3,\n",
        "        },\n",
        "        \"degrees\": True\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        angle = self.angle\n",
        "        arc = Arc(angle, radius=1)\n",
        "        label = DecimalNumber(0, **self.label_config)\n",
        "        label.set_height(self.label_config[\"label_height\"])\n",
        "        label.next_to(arc, RIGHT)\n",
        "        label.shift(0.5 * SMALL_BUFF * UP)\n",
        "        line1 = Line(ORIGIN, 3 * RIGHT)\n",
        "        line2 = line1.copy()\n",
        "\n",
        "        if self.degrees:\n",
        "            target_value = int(angle / DEGREES)\n",
        "        else:\n",
        "            target_value = angle\n",
        "\n",
        "        self.add(line1, label)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(label, target_value),\n",
        "            ShowCreation(arc),\n",
        "            Rotate(line2, angle, about_point=ORIGIN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ArctanSqrtPoint1Angle(FourtyFiveDegreeLine):\n",
        "    CONFIG = {\n",
        "        \"angle\": np.arctan(np.sqrt(0.1)),\n",
        "    }\n",
        "\n",
        "\n",
        "class AskAboutAddingThetaToItself(Scene):\n",
        "    CONFIG = {\n",
        "        \"theta\": np.arctan(0.25),\n",
        "        \"wait_time\": 0.25,\n",
        "        \"wedge_radius\": 3,\n",
        "        \"theta_symbol_scale_val\": 0.5,\n",
        "        \"number_height\": 0.2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        theta = self.theta\n",
        "        groups = self.get_groups(theta)\n",
        "        horizon = self.get_horizon()\n",
        "        counter = ValueTracker(0)\n",
        "        dynamic_ineq = self.get_dynamic_inequality(counter)\n",
        "        semicircle = self.get_semicircle()\n",
        "\n",
        "        self.add(horizon)\n",
        "        self.add(dynamic_ineq)\n",
        "\n",
        "        for n in range(len(groups)):\n",
        "            counter.set_value(n + 1)\n",
        "            if n < len(groups) - 1:\n",
        "                groups[n][-1].set_color(YELLOW)\n",
        "                if n > 0:\n",
        "                    groups[n - 1][-1].set_color(WHITE)\n",
        "            self.add(groups[:n + 1])\n",
        "            self.add_sound(\"pen_click\", gain=-20)\n",
        "            self.wait(self.wait_time)\n",
        "        self.wait(0.5)\n",
        "\n",
        "        counter.set_value(counter.get_value() - 1)\n",
        "        self.remove(groups[-1])\n",
        "        self.add_sound(\"pen_click\", gain=-20)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(semicircle))\n",
        "        self.play(FadeOut(semicircle))\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_group(self, theta):\n",
        "        # Define group\n",
        "        wedge_radius = self.wedge_radius\n",
        "        wedge = VGroup(\n",
        "            Line(ORIGIN, wedge_radius * RIGHT),\n",
        "            Line(ORIGIN, wedge_radius * RIGHT).rotate(\n",
        "                theta, about_point=ORIGIN\n",
        "            ),\n",
        "        )\n",
        "        wedge.set_stroke((WHITE, GREY), 2)\n",
        "        arc = Arc(theta, radius=1)\n",
        "        theta_symbol = OldTex(\"\\\\theta\")\n",
        "        tssv = self.theta_symbol_scale_val\n",
        "        theta_symbol.scale(tssv)\n",
        "        theta_symbol.next_to(arc, RIGHT, tssv / 2)\n",
        "        theta_symbol.shift(tssv * SMALL_BUFF * UP)\n",
        "\n",
        "        return VGroup(wedge, arc, theta_symbol)\n",
        "\n",
        "    def get_groups(self, theta):\n",
        "        group = self.get_group(theta)\n",
        "        angles = [k * theta for k in range(int(PI / theta) + 1)]\n",
        "        groups = VGroup(*[\n",
        "            group.copy().rotate(angle, about_point=ORIGIN)\n",
        "            for angle in angles\n",
        "        ])\n",
        "        # colors = it.cycle([BLUE_D, BLUE_B, BLUE_C, GREY_BROWN])\n",
        "        colors = it.cycle([BLUE_D, GREY_BROWN])\n",
        "        for n, angle, group, color in zip(it.count(1), angles, groups, colors):\n",
        "            wedge, arc, symbol = group\n",
        "            symbol.rotate(-angle)\n",
        "            arc.set_color(color)\n",
        "            number = Integer(n)\n",
        "            number.set_height(self.number_height)\n",
        "            number.move_to(center_of_mass([\n",
        "                wedge[0].get_end(),\n",
        "                wedge[1].get_end(),\n",
        "            ]))\n",
        "            group.add(number)\n",
        "        groups[-1][-1].set_color(RED)\n",
        "\n",
        "        return groups\n",
        "\n",
        "    def get_horizon(self):\n",
        "        horizon = DashedLine(5 * LEFT, 5 * RIGHT)\n",
        "        horizon.set_stroke(WHITE, 1)\n",
        "        return horizon\n",
        "\n",
        "    def get_semicircle(self):\n",
        "        return Arc(\n",
        "            start_angle=0,\n",
        "            angle=PI,\n",
        "            radius=self.wedge_radius / 2,\n",
        "            color=YELLOW,\n",
        "            stroke_width=4,\n",
        "        )\n",
        "\n",
        "    def get_inequality(self):\n",
        "        ineq = OldTex(\n",
        "            \"N\", \"\\\\cdot\", \"\\\\theta\", \"<\",\n",
        "            \"\\\\pi\", \"=\", \"3.1415926\\\\dots\"\n",
        "        )\n",
        "        N = ineq.get_part_by_tex(\"N\")\n",
        "        self.pi_symbol = ineq.get_part_by_tex(\"\\\\pi\")\n",
        "        N.set_color(YELLOW)\n",
        "        # ineq[-3:].set_color(BLUE)\n",
        "\n",
        "        brace = Brace(N, UP, buff=SMALL_BUFF)\n",
        "        text = brace.get_text(\"Maximum\", buff=SMALL_BUFF)\n",
        "        group = VGroup(ineq, brace, text)\n",
        "        group.next_to(ORIGIN, DOWN, MED_LARGE_BUFF)\n",
        "        return group\n",
        "\n",
        "    def get_dynamic_inequality(self, counter):\n",
        "        multiple = Integer(0)\n",
        "        dot = OldTex(\"\\\\cdot\")\n",
        "        theta_tex = OldTex(\"({:.2f})\".format(self.theta))\n",
        "        eq = OldTex(\"=\")\n",
        "        value = DecimalNumber(0)\n",
        "        ineq = OldTex(\"<\")\n",
        "        pi = OldTex(\"\\\\pi\", \"=\", \"3.1415926\\\\dots\")\n",
        "        # pi.set_color(BLUE)\n",
        "        group = VGroup(\n",
        "            multiple, dot, theta_tex,\n",
        "            eq, value,\n",
        "            ineq, pi\n",
        "        )\n",
        "        group.arrange(RIGHT, buff=0.2)\n",
        "        group.next_to(ORIGIN, DOWN, buff=LARGE_BUFF)\n",
        "        theta_brace = Brace(group[2], DOWN, buff=SMALL_BUFF)\n",
        "        theta_symbol = theta_brace.get_tex(\"\\\\theta\")\n",
        "        group.add(theta_brace, theta_symbol)\n",
        "        # group.align_to(self.pi_symbol, RIGHT)\n",
        "\n",
        "        def get_count():\n",
        "            return int(counter.get_value())\n",
        "\n",
        "        def get_product():\n",
        "            return get_count() * self.theta\n",
        "\n",
        "        def is_greater_than_pi():\n",
        "            return get_product() > PI\n",
        "\n",
        "        def get_color():\n",
        "            return RED if is_greater_than_pi() else YELLOW\n",
        "\n",
        "        def get_ineq():\n",
        "            result = OldTex(\n",
        "                \">\" if is_greater_than_pi() else \"<\"\n",
        "            )\n",
        "            result.set_color(get_color())\n",
        "            result.move_to(ineq)\n",
        "            return result\n",
        "        dynamic_ineq = always_redraw(get_ineq)\n",
        "        group.remove(ineq)\n",
        "        group.add(dynamic_ineq)\n",
        "\n",
        "        multiple.add_updater(lambda m: m.set_value(get_count()))\n",
        "        multiple.add_updater(lambda m: m.next_to(dot, LEFT, 0.2))\n",
        "        multiple.add_updater(lambda m: m.set_color(get_color()))\n",
        "        value.add_updater(lambda m: m.set_value(get_product()))\n",
        "\n",
        "        return group\n",
        "\n",
        "\n",
        "class AskAboutAddingThetaToItselfThetaPoint1(AskAboutAddingThetaToItself):\n",
        "    CONFIG = {\n",
        "        \"theta\": 0.1,\n",
        "        \"wait_time\": 0.1,\n",
        "        \"theta_symbol_scale_val\": 0.25,\n",
        "        \"number_height\": 0.15,\n",
        "    }\n",
        "\n",
        "\n",
        "class AskAboutAddingThetaToItselfThetaPoint2(AskAboutAddingThetaToItself):\n",
        "    CONFIG = {\n",
        "        \"theta\": 0.2,\n",
        "        \"wait_time\": 0.1,\n",
        "    }\n",
        "\n",
        "\n",
        "class FinalFormula(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Final answer: \")\n",
        "        t2c_map = {\n",
        "            \"\\\\theta\": BLUE,\n",
        "            \"m_1\": GREEN,\n",
        "            \"m_2\": RED,\n",
        "        }\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"\\\\left\\\\lfloor\",\n",
        "            \"{\\\\pi\", \"\\\\over\", \"\\\\theta}\",\n",
        "            \"\\\\right\\\\rfloor\"\n",
        "        )\n",
        "        formula.set_color_by_tex_to_color_map(t2c_map)\n",
        "        group = VGroup(text, formula)\n",
        "        group.arrange(RIGHT)\n",
        "        group.scale(1.5)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        self.play(Write(text))\n",
        "        self.play(FadeIn(formula))\n",
        "        self.play(ShowCreationThenFadeAround(formula))\n",
        "        self.wait()\n",
        "\n",
        "        theta_eq = OldTex(\n",
        "            \"\\\\theta\", \"=\", \"\\\\arctan\", \"\\\\left(\",\n",
        "            \"\\\\sqrt\",\n",
        "            \"{{m_2\", \"\\\\over\", \"m_1}}\",\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        theta_eq.set_color_by_tex_to_color_map(t2c_map)\n",
        "        theta_eq.scale(1.5)\n",
        "        theta_eq.next_to(group, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(TransformFromCopy(\n",
        "            formula.get_part_by_tex(\"\\\\theta\"),\n",
        "            theta_eq.get_part_by_tex(\"\\\\theta\"),\n",
        "        ))\n",
        "        self.play(Write(theta_eq[1:]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReviewWrapper(WrapperScene):\n",
        "    CONFIG = {\"title\": \"To review:\"}\n",
        "\n",
        "\n",
        "class SurprisedRandy(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        self.play(randy.change, \"surprised\", 3 * UR)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwoSolutionsWrapper(WrapperScene):\n",
        "    def construct(self):\n",
        "        big_rect = self.get_big_rect()\n",
        "        screen_rects = VGroup(*[\n",
        "            self.get_screen_rect(height=3)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        screen_rects.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        title = OldTexText(\"Two solutions\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        screen_rects.next_to(title, DOWN, LARGE_BUFF)\n",
        "\n",
        "        # pi creatures\n",
        "        pis = VGroup(\n",
        "            Randolph(color=BLUE_D),\n",
        "            Randolph(color=BLUE_E),\n",
        "            Randolph(color=BLUE_B),\n",
        "            Mortimer().scale(1.2)\n",
        "        )\n",
        "        pis.set_height(2)\n",
        "        pis.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        pis.to_edge(DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(big_rect, title, pis)\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, screen_rects.copy().set_fill(opacity=0),\n",
        "                lag_ratio=0.8\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, screen_rects,\n",
        "                lag_ratio=0.8\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, pis,\n",
        "                lambda pi: (pi.change, \"pondering\", screen_rects[0])\n",
        "            ),\n",
        "        )\n",
        "        self.play(Blink(random.choice(pis)))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, pis,\n",
        "            lambda pi: (pi.change, \"thinking\", screen_rects[1])\n",
        "        ))\n",
        "        self.play(Blink(random.choice(pis)))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FinalQuote(Scene):\n",
        "    def construct(self):\n",
        "        quote_text = \"\"\"\n",
        "            A change of perspective\\\\\\\\\n",
        "            is worth 80 IQ points.\n",
        "        \"\"\"\n",
        "        quote_parts = [s for s in quote_text.split(\" \") if s]\n",
        "        quote = OldTexText(\n",
        "            *quote_parts,\n",
        "        )\n",
        "        quote.scale(1.2)\n",
        "        quote.shift(2 * RIGHT + UP)\n",
        "\n",
        "        image = ImageMobject(\"AlanKay\")\n",
        "        image.set_height(6)\n",
        "        image.to_corner(UL)\n",
        "        image.shift(2 * LEFT + 0.5 * UP)\n",
        "        name = OldTexText(\"Alan Kay\")\n",
        "        name.scale(1.5)\n",
        "        name.next_to(image, DOWN)\n",
        "        name.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(image),\n",
        "            Write(name),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for word in quote:\n",
        "            self.play(ShowWord(word))\n",
        "            self.wait(0.005 * len(word)**1.5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adam Kozak\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Andreas Benjamin Br\u00f6ssel\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Ankalagon\",\n",
        "            \"Antonio Juarez\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Awoo\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Bob Sanderson\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Chad Hurst\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Cooper Jones\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Danger Dai\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"dave nicponski\",\n",
        "            \"David Clark\",\n",
        "            \"David Gow\",\n",
        "            \"Delton Ding\",\n",
        "            \"Devarsh Desai\",\n",
        "            \"eaglle\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Evan Phillips\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Florian Chudigiewitsch\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Graham\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"J\",\n",
        "            \"j eduardo perez\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"James Hughes\",\n",
        "            \"Jan Pijpers\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"John Griffith\",\n",
        "            \"John Haley\",\n",
        "            \"John Shaughnessy\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Juan Benet\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"L0j1k\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Magnus Lysfjord\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Mark Heising\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matt Russell\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Mauricio Collares\",\n",
        "            \"Michael Faust\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Mike Coleman\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nathan Jessurun\",\n",
        "            \"Nero Li\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Quantopian\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Richard Barthel\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"Richard Comish\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Robert Teed\",\n",
        "            \"Roobie\",\n",
        "            \"Roy Larson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Samuel D. Judge\",\n",
        "            \"Scott Gray\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"soekul\",\n",
        "            \"Solara570\",\n",
        "            \"Song Gao\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Tihan Seale\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Xavier Bernard\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yaw Etse\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Yu Jun\",\n",
        "            \"Zach Cardwell\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class ClacksSolution2Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        self.add_scene1()\n",
        "        self.add_scene2()\n",
        "\n",
        "        arrow = Arrow(\n",
        "            self.block_word.get_top(),\n",
        "            self.light_dot.get_bottom(),\n",
        "            tip_length=0.75,\n",
        "            rectangular_stem_width=0.2,\n",
        "            color=RED,\n",
        "            buff=0.5,\n",
        "        )\n",
        "        arrow.add_to_back(arrow.copy().set_stroke(BLACK, 20))\n",
        "        self.add(arrow)\n",
        "        return\n",
        "\n",
        "        arrow = OldTex(\"\\\\Updownarrow\")\n",
        "        arrow.set_height(2)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow.set_stroke(Color(\"red\"), 2, background=True)\n",
        "        self.add(arrow)\n",
        "\n",
        "    def add_scene1(self):\n",
        "        scene1 = Thumbnail(\n",
        "            sliding_blocks_config={\n",
        "                \"block1_config\": {\n",
        "                    \"label_text\": \"$100^{d}$ kg\",\n",
        "                    \"distance\": 8,\n",
        "                },\n",
        "            }\n",
        "        )\n",
        "        group = Group(*scene1.mobjects)\n",
        "        group.scale(0.75, about_point=ORIGIN)\n",
        "        group.shift(1.5 * DOWN + 3 * LEFT)\n",
        "        scene1.remove(scene1.question)\n",
        "        self.add(*scene1.mobjects)\n",
        "\n",
        "        black_rect = FullScreenFadeRectangle(fill_opacity=1)\n",
        "        black_rect.shift(3.5 * UP)\n",
        "        self.add(black_rect)\n",
        "\n",
        "        word = OldTexText(\"Blocks\")\n",
        "        word.set_color(YELLOW)\n",
        "        word.scale(3)\n",
        "        word.to_corner(DR, buff=LARGE_BUFF)\n",
        "        word.shift(0.5 * LEFT)\n",
        "        self.block_word = word\n",
        "        self.add(word)\n",
        "\n",
        "    def add_scene2(self):\n",
        "        scene2 = ReflectWorldThroughMirrorNew(\n",
        "            skip_animations=True,\n",
        "            file_writer_config={\n",
        "                \"write_to_movie\": False,\n",
        "            },\n",
        "            end_at_animation_number=18,\n",
        "            # center=1.5 * DOWN,\n",
        "            center=ORIGIN,\n",
        "        )\n",
        "        worlds = VGroup(scene2.world, *scene2.reflected_worlds)\n",
        "        mirrors = VGroup(*[rw[1] for rw in worlds])\n",
        "        mirrors.set_stroke(width=5)\n",
        "        triangles = VGroup(*[rw[0] for rw in worlds])\n",
        "        trajectories = VGroup(\n",
        "            scene2.trajectory,\n",
        "            *scene2.reflected_trajectories\n",
        "        )\n",
        "        trajectories.set_stroke(YELLOW, 1)\n",
        "\n",
        "        beams1, beams2 = [\n",
        "            scene2.get_shooting_beam_anims(\n",
        "                path,\n",
        "                max_stroke_width=20,\n",
        "                max_time_width=1,\n",
        "                num_flashes=50,\n",
        "            )\n",
        "            for path in [\n",
        "                scene2.trajectory,\n",
        "                scene2.ghost_trajectory,\n",
        "            ]\n",
        "        ]\n",
        "        beams = beams1 + beams2\n",
        "        beams = beams2\n",
        "        flashes = VGroup()\n",
        "        for beam in beams:\n",
        "            beam.update(0.5)\n",
        "            flashes.add(beam.mobject)\n",
        "\n",
        "        dot = self.light_dot = Dot(color=YELLOW, radius=0.1)\n",
        "        dot.move_to(flashes[0].get_left())\n",
        "        flashes.add(dot)\n",
        "\n",
        "        self.add(triangles, mirrors)\n",
        "        # self.add(randys)\n",
        "        self.add(trajectories[0].set_stroke(width=2))\n",
        "        self.add(flashes)\n",
        "\n",
        "        word = OldTexText(\"Light beam\")\n",
        "        word.scale(3.5)\n",
        "        word.set_color(YELLOW)\n",
        "        # word.set_stroke(BLACK, 25, background=True)\n",
        "        word.add_to_back(word.copy().set_stroke(\n",
        "            BLACK, 25,\n",
        "        ))\n",
        "        word.next_to(dot, UR)\n",
        "        word.shift(-word.get_center()[0] * RIGHT)\n",
        "        word.shift(SMALL_BUFF * RIGHT)\n",
        "        self.light_word = word\n",
        "        self.add(word)\n"
    ]
}