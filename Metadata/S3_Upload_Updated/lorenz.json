{
    "topic": "demonstrates the Lorenz attractor, a famous chaotic system that exhibits complex and",
    "code": [
        "from manim_imports_ext import *\n",
        "from scipy.integrate import solve_ivp\n",
        "\n",
        "\n",
        "def lorenz_system(t, state, sigma=10, rho=28, beta=8 / 3):\n",
        "    x, y, z = state\n",
        "    dxdt = sigma * (y - x)\n",
        "    dydt = x * (rho - z) - y\n",
        "    dzdt = x * y - beta * z\n",
        "    return [dxdt, dydt, dzdt]\n",
        "\n",
        "\n",
        "def ode_solution_points(function, state0, time, dt=0.01):\n",
        "    solution = solve_ivp(\n",
        "        function,\n",
        "        t_span=(0, time),\n",
        "        y0=state0,\n",
        "        t_eval=np.arange(0, time, dt)\n",
        "    )\n",
        "    return solution.y.T\n",
        "\n",
        "\n",
        "def for_later():\n",
        "    tail = VGroup(\n",
        "        TracingTail(dot, time_traced=3).match_color(dot)\n",
        "        for dot in dots\n",
        "    )\n",
        "\n",
        "\n",
        "class LorenzAttractor(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up axes\n",
        "        axes = ThreeDAxes(\n",
        "            x_range=(-50, 50, 5),\n",
        "            y_range=(-50, 50, 5),\n",
        "            z_range=(-0, 50, 5),\n",
        "            width=16,\n",
        "            height=16,\n",
        "            depth=8,\n",
        "        )\n",
        "        axes.set_width(FRAME_WIDTH)\n",
        "        axes.center()\n",
        "\n",
        "        self.frame.reorient(43, 76, 1, IN, 10)\n",
        "        self.frame.add_updater(lambda m, dt: m.increment_theta(dt * 3 * DEGREES))\n",
        "        self.add(axes)\n",
        "\n",
        "        # Add the equations\n",
        "        equations = Tex(\n",
        "            R\"\"\"\n",
        "            \\begin{aligned}\n",
        "            \\frac{\\mathrm{d} x}{\\mathrm{~d} t} & =\\sigma(y-x) \\\\\n",
        "            \\frac{\\mathrm{d} y}{\\mathrm{~d} t} & =x(\\rho-z)-y \\\\\n",
        "            \\frac{\\mathrm{d} z}{\\mathrm{~d} t} & =x y-\\beta z\n",
        "            \\end{aligned}\n",
        "            \"\"\",\n",
        "            t2c={\n",
        "                \"x\": RED,\n",
        "                \"y\": GREEN,\n",
        "                \"z\": BLUE,\n",
        "            },\n",
        "            font_size=30\n",
        "        )\n",
        "        equations.fix_in_frame()\n",
        "        equations.to_corner(UL)\n",
        "        equations.set_backstroke()\n",
        "        self.play(Write(equations))\n",
        "\n",
        "        # Compute a set of solutions\n",
        "        epsilon = 1e-5\n",
        "        evolution_time = 30\n",
        "        n_points = 10\n",
        "        states = [\n",
        "            [10, 10, 10 + n * epsilon]\n",
        "            for n in range(n_points)\n",
        "        ]\n",
        "        colors = color_gradient([BLUE_E, BLUE_A], len(states))\n",
        "\n",
        "        curves = VGroup()\n",
        "        for state, color in zip(states, colors):\n",
        "            points = ode_solution_points(lorenz_system, state, evolution_time)\n",
        "            curve = VMobject().set_points_smoothly(axes.c2p(*points.T))\n",
        "            curve.set_stroke(color, 1, opacity=0.25)\n",
        "            curves.add(curve)\n",
        "\n",
        "        curves.set_stroke(width=2, opacity=1)\n",
        "\n",
        "        # Display dots moving along those trajectories\n",
        "        dots = Group(GlowDot(color=color, radius=0.25) for color in colors)\n",
        "\n",
        "        def update_dots(dots, curves=curves):\n",
        "            for dot, curve in zip(dots, curves):\n",
        "                dot.move_to(curve.get_end())\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        tail = VGroup(\n",
        "            TracingTail(dot, time_traced=3).match_color(dot)\n",
        "            for dot in dots\n",
        "        )\n",
        "\n",
        "        self.add(dots)\n",
        "        self.add(tail)\n",
        "        curves.set_opacity(0)\n",
        "        self.play(\n",
        "            *(\n",
        "                ShowCreation(curve, rate_func=linear)\n",
        "                for curve in curves\n",
        "            ),\n",
        "            run_time=evolution_time,\n",
        "        )\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass"
    ]
}