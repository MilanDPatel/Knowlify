{
    "topic": "demonstrates the concept of collision and reflection in physics. It tracks the state of a block",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "LITTLE_BLOCK_COLOR = \"#51463E\"\n",
        "\n",
        "\n",
        "class StateTracker(ValueTracker):\n",
        "    \"\"\"\n",
        "    Tracks the state of the block collision process as a 4d vector\n",
        "    [\n",
        "        x1 * sqrt(m1),\n",
        "        x2 * sqrt(m2),\n",
        "        v1 * sqrt(m1),\n",
        "        v2 * sqrt(m2),\n",
        "    ]\n",
        "    \"\"\"\n",
        "\n",
        "    def __init__(self, blocks, initial_positions=[8, 5], initial_velocities=[-1, 0]):\n",
        "        sqrt_m1, sqrt_m2 = self.sqrt_mass_vect = np.sqrt([b.mass for b in blocks])\n",
        "        self.theta = math.atan2(sqrt_m2, sqrt_m1)\n",
        "\n",
        "        self.state0 = np.array([\n",
        "            *np.array(initial_positions) * self.sqrt_mass_vect,\n",
        "            *np.array(initial_velocities) * self.sqrt_mass_vect,\n",
        "        ])\n",
        "\n",
        "        super().__init__(self.state0.copy())\n",
        "\n",
        "    def set_time(self, t):\n",
        "        pos0 = self.state0[0:2]\n",
        "        vel0 = self.state0[2:4]\n",
        "\n",
        "        self.set_value([*(pos0 + t * vel0), *vel0])\n",
        "\n",
        "    def reflect_vect(self, vect):\n",
        "        n_reflections = self.get_n_collisions()\n",
        "        rot_angle = -2 * self.theta * ((n_reflections + 1) // 2)\n",
        "        result = rotate_vector_2d(vect, rot_angle)\n",
        "        result[1] *= (-1)**(n_reflections % 2)\n",
        "        return result\n",
        "\n",
        "    def get_block_positions(self):\n",
        "        scaled_pos = self.get_value()[0:2]\n",
        "        norm = get_norm(scaled_pos)\n",
        "\n",
        "        rot_scaled_pos = self.reflect_vect(scaled_pos)\n",
        "        return rot_scaled_pos / self.sqrt_mass_vect\n",
        "\n",
        "    def get_scaled_block_velocities(self):\n",
        "        return self.reflect_vect(self.get_value()[2:4])\n",
        "\n",
        "    def get_block_velocities(self):\n",
        "        return self.get_scaled_block_velocities() / self.sqrt_mass_vect\n",
        "\n",
        "    def get_kinetic_energy(self):\n",
        "        v1, v2 = self.get_value()[2:4]\n",
        "        return v1**2 + v2**2\n",
        "\n",
        "    def get_momentum(self):\n",
        "        v1, v2 = self.get_block_velocities()\n",
        "        m1, m2 = self.sqrt_mass_vect**2\n",
        "        return m1 * v1 + m2 * v2\n",
        "\n",
        "    def get_n_collisions(self):\n",
        "        state = self.get_value()  # First two coords are [sqrt(m1) * d1, sqrt(m2) * d2]\n",
        "        angle = math.atan2(state[1], state[0])\n",
        "        return int(angle / self.theta)\n",
        "\n",
        "    def time_from_last_collision(self):\n",
        "        state = self.get_value()\n",
        "        angle = math.atan2(state[1], state[0])\n",
        "        n_collisions = int(angle / self.theta)\n",
        "        if n_collisions == 0:\n",
        "            return 0\n",
        "        collisions_angle = n_collisions * self.theta\n",
        "        rot_state = rotate_vector_2d(state[:2], collisions_angle - angle)\n",
        "        collision_state = rot_state * (state[1] / rot_state[1])  # Rescale to match y coordinate\n",
        "        return (collision_state[0] - state[0]) / state[2]\n",
        "\n",
        "\n",
        "class ClackAnimation(Restore):\n",
        "    def __init__(self, point, run_time=0.25, **kwargs):\n",
        "        circles = Circle(radius=0.25).replicate(3)\n",
        "        circles.move_to(point)\n",
        "        circles.set_stroke(YELLOW, 0, 0)\n",
        "        circles.save_state()\n",
        "        circles.scale(0.1)\n",
        "        circles.set_stroke(YELLOW, 2, 1)\n",
        "\n",
        "        super().__init__(circles, lag_ratio=0.1, run_time=run_time, **kwargs)\n",
        "\n",
        "\n",
        "class Blocks(InteractiveScene):\n",
        "    initial_positions = [10.5, 8]\n",
        "    initial_velocities = [-0.975, 0]\n",
        "    masses = [10, 1]\n",
        "    widths = [1.0, 0.5]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    three_d = True\n",
        "    clack_sound = \"clack.wav\"\n",
        "    reverse_clack_sound = \"reverse_clack.wav\"\n",
        "    floor_width = 13\n",
        "    floor_depth = 1.5\n",
        "    wall_height = 2\n",
        "    block_shading = [0.5, 0.5, 0]\n",
        "    field_of_view = 45 * DEG\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        self.frame.set_field_of_view(self.field_of_view)\n",
        "\n",
        "        self.floor_wall = self.get_floor_and_wall_3d() if self.three_d else self.get_floor_and_wall_2d()\n",
        "        self.floor, self.wall = self.floor_wall\n",
        "        self.blocks = self.get_block_pair(self.floor, three_d=self.three_d)\n",
        "\n",
        "        self.state_tracker = StateTracker(self.blocks, self.initial_positions, self.initial_velocities)\n",
        "        self.time_tracker = ValueTracker(0)\n",
        "        self.state_tracker.f_always.set_time(self.time_tracker.get_value)\n",
        "\n",
        "        self.bind_blocks_to_state(self.blocks, self.floor, self.state_tracker)\n",
        "\n",
        "        self.listen_for_clacks = True\n",
        "        self.last_collision_count = self.state_tracker.get_n_collisions()\n",
        "        self.last_clack_time = 0\n",
        "        self.flashes = []\n",
        "\n",
        "        self.add(self.state_tracker)\n",
        "        self.add(self.time_tracker)\n",
        "        self.add(self.floor_wall)\n",
        "        self.add(self.blocks)\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup the experiment\n",
        "        light_source = self.camera.light_source\n",
        "        light_source.set_z(3)\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        blocks = self.blocks\n",
        "        floor = self.floor\n",
        "        state_tracker = self.state_tracker\n",
        "        time_tracker = self.time_tracker\n",
        "\n",
        "        for block in blocks:\n",
        "            block.mass_label.set_opacity(0)\n",
        "\n",
        "        # Set up equations\n",
        "        kw = dict(t2c={\n",
        "            \"m_1\": BLUE,\n",
        "            \"m_2\": BLUE,\n",
        "            \"v_1\": RED,\n",
        "            \"v_2\": RED,\n",
        "        })\n",
        "        ke_equation = Tex(R\"\\frac{1}{2} m_1 (v_1)^2 + \\frac{1}{2}m_2 (v_2)^2 = \\text{E}\", **kw)\n",
        "        p_equation = Tex(R\"m_1 v_1 + m_2 v_2 = \\text{P}\", **kw)\n",
        "        equations = VGroup(ke_equation, p_equation)\n",
        "        equations.arrange(DOWN, buff=0.75)\n",
        "        equations.to_edge(UP, buff=0.5)\n",
        "        equations.fix_in_frame()\n",
        "\n",
        "        # Introductory shot\n",
        "        frame.reorient(-42, -3, 0, (-2.08, -2.25, -1.87), 6.95)\n",
        "        stop_time = 12\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            FadeIn(ke_equation, shift=0.5 * UP, time_span=(7, 8)),\n",
        "            FadeIn(p_equation, shift=0.5 * UP, time_span=(10, 11)),\n",
        "            time_tracker.animate.set_value(stop_time).set_anim_args(rate_func=linear),\n",
        "            run_time=stop_time\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(equations)\n",
        "\n",
        "        # Add velocity vectors\n",
        "        vel = state_tracker.get_block_velocities()\n",
        "        marked_velocity = ValueTracker(vel)\n",
        "        marked_velocity.f_always.set_value(state_tracker.get_block_velocities)\n",
        "        self.add(marked_velocity)\n",
        "        velocity_vectors = VGroup(\n",
        "            self.get_velocity_vector(blocks[0], lambda: marked_velocity.get_value()[0]),\n",
        "            self.get_velocity_vector(blocks[1], lambda: marked_velocity.get_value()[1]),\n",
        "        )\n",
        "        velocity_vectors.update()\n",
        "        velocity_vectors.set_z_index(1)\n",
        "\n",
        "        # Highlight kinetic energy of each one\n",
        "        self.play(\n",
        "            frame.animate.reorient(-12, 3, 0, (-3.41, -1.48, 0.01), 4.63),\n",
        "            blocks[0].mass_label.animate.set_opacity(1),\n",
        "            blocks[1].mass_label.animate.set_opacity(1),\n",
        "            VFadeIn(velocity_vectors),\n",
        "            FadeOut(p_equation, time_span=(1, 2)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight corresponding terms\n",
        "        tex = [\"m_1\", \"v_1\", \"m_2\", \"v_2\"]\n",
        "        labels = [\n",
        "            blocks[0][2],\n",
        "            velocity_vectors[0][1],\n",
        "            blocks[1][2],\n",
        "            velocity_vectors[1][1],\n",
        "        ]\n",
        "\n",
        "        last_rects = VGroup()\n",
        "        for tex, label in zip(tex, labels):\n",
        "            rects = VGroup(\n",
        "                SurroundingRectangle(ke_equation[tex], buff=0.05),\n",
        "                SurroundingRectangle(label, buff=0.05),\n",
        "            )\n",
        "            rects[0].set_stroke(YELLOW, 5)\n",
        "            rects[1].set_stroke(YELLOW, 3)\n",
        "            self.play(\n",
        "                FadeOut(last_rects),\n",
        "                ShowCreation(rects, lag_ratio=0),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # Show constant energy\n",
        "        dec_equation = Tex(R\"\\frac{1}{2}(10)(+0.00)^2 + \\frac{1}{2}(1)(+0.00)^2 = +0.00\", font_size=42)\n",
        "        dec_equation.next_to(ke_equation, DOWN, LARGE_BUFF)\n",
        "\n",
        "        terms = dec_equation.make_number_changeable(\"+0.00\", replace_all=True, include_sign=True)\n",
        "        dec_equation.fix_in_frame()\n",
        "        dec_equation[\"(1)\"].set_color(BLUE)\n",
        "        dec_equation[\"(10)\"].set_color(BLUE)\n",
        "        terms[:2].set_color(RED)\n",
        "        terms[0].f_always.set_value(lambda: state_tracker.get_block_velocities()[0])\n",
        "        terms[1].f_always.set_value(lambda: state_tracker.get_block_velocities()[1])\n",
        "        terms[2].set_value(state_tracker.get_kinetic_energy())\n",
        "        terms.update()\n",
        "\n",
        "        label_targets = VGroup(dec_equation[\"(10)\"], terms[0], dec_equation[\"(1)\"], terms[1]).copy()\n",
        "        label_targets.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(dec_equation, time_span=(1.5, 2)),\n",
        "            Transform(VGroup(*labels).copy().clear_updaters(), label_targets, remover=True, run_time=2, lag_ratio=1e-3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(time_tracker.animate.increment_value(1), rate_func=there_and_back, run_time=6)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            time_tracker.animate.increment_value(10).set_anim_args(rate_func=linear),\n",
        "            frame.animate.reorient(-1, 3, 0, (-1.59, -0.79, 0.17), 6.46),\n",
        "            run_time=10,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        dec_equation.clear_updaters()\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(12),\n",
        "            frame.animate.reorient(-12, 3, 0, (-3.41, -1.48, 0.01), 4.63),\n",
        "            FadeOut(dec_equation),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight momentum\n",
        "        self.play(\n",
        "            ke_equation.animate.set_opacity(0.2),\n",
        "            FadeIn(p_equation),\n",
        "            time_tracker.animate.increment_value(-1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the net momentum calculation (much copying here)\n",
        "        p_dec_equation = Tex(R\"(10)(+0.00) + (1)(+0.00) = +0.00\", font_size=42)\n",
        "        p_terms = p_dec_equation.make_number_changeable(\"+0.00\", replace_all=True, include_sign=True)\n",
        "        p_terms[:2].set_color(RED)\n",
        "        p_dec_equation[\"(1)\"].set_color(BLUE)\n",
        "        p_dec_equation[\"(10)\"].set_color(BLUE)\n",
        "        p_dec_equation.fix_in_frame()\n",
        "        p_dec_equation.next_to(p_equation, DOWN, buff=0.75)\n",
        "\n",
        "        p_terms[0].f_always.set_value(lambda: state_tracker.get_block_velocities()[0])\n",
        "        p_terms[1].f_always.set_value(lambda: state_tracker.get_block_velocities()[1])\n",
        "        p_terms[2].f_always.set_value(state_tracker.get_momentum)\n",
        "\n",
        "        label_targets = VGroup(p_dec_equation[\"(10)\"], p_terms[0], p_dec_equation[\"(1)\"], p_terms[1]).copy()\n",
        "        label_targets.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-2, 2, 0, (-2.82, -0.66, 0.11), 5.96),\n",
        "            VFadeIn(p_dec_equation),\n",
        "            Transform(VGroup(*labels).copy().clear_updaters(), label_targets, remover=True),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            time_tracker.animate.increment_value(8).set_anim_args(rate_func=linear),\n",
        "            frame.animate.reorient(6, -1, 0, (-0.7, -0.25, -0.17), 7.75),\n",
        "            run_time=16,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reset\n",
        "        marked_velocity.clear_updaters()\n",
        "        blocks.clear_updaters()\n",
        "        self.remove(state_tracker)\n",
        "\n",
        "        state_tracker = StateTracker(blocks, [9.5, 8], [-1, 0])\n",
        "        time_tracker.set_value(0)\n",
        "        state_tracker.add_updater(lambda m: m.set_time(time_tracker.get_value()))\n",
        "        self.state_tracker = state_tracker\n",
        "        self.bind_blocks_to_state(blocks, floor, state_tracker)\n",
        "        self.add(state_tracker)\n",
        "\n",
        "        p_dec_equation.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(p_dec_equation, 2 * LEFT),\n",
        "            frame.animate.to_default_state(),\n",
        "            equations.animate.set_width(4.5).arrange(DOWN, buff=0.5).set_opacity(1).to_corner(UL),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight velocity terms\n",
        "        v_terms = VGroup(\n",
        "            eq[f\"v_{n}\"]\n",
        "            for eq in equations\n",
        "            for n in [1, 2]\n",
        "        )\n",
        "        v_point = Point([*marked_velocity.get_value(), 0])\n",
        "        v_point.target = v_point.generate_target()\n",
        "        v_point.target.move_to([*state_tracker.get_block_velocities(), 0])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FlashAround, v_terms, lag_ratio=0.1, time_width=1.0, time_span=(0, 2)),\n",
        "            MoveToTarget(v_point, path_arc=PI),\n",
        "            UpdateFromFunc(marked_velocity, lambda m: m.set_value(v_point.get_center()[:2])),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Introduce coordinate plane\n",
        "        plane = NumberPlane((-4, 4, 1), (-4, 4, 1), faded_line_ratio=1)\n",
        "        plane.set_height(5)\n",
        "        plane.to_corner(UR, buff=0.25)\n",
        "        plane.shift(2.0 * LEFT)\n",
        "        plane.axes.set_stroke(WHITE, 1)\n",
        "        plane.background_lines.set_stroke(BLUE, 1, 0.5)\n",
        "        plane.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "\n",
        "        state_point = Group(\n",
        "            TrueDot(radius=0.05).make_3d(),\n",
        "            GlowDot(radius=0.2),\n",
        "        )\n",
        "        state_point.set_color(RED)\n",
        "        state_point.add_updater(lambda m: m.move_to(plane.c2p(*marked_velocity.get_value())))\n",
        "\n",
        "        kw[\"font_size\"] = 36\n",
        "        x_label, y_label = axis_labels = VGroup(\n",
        "            Tex(\"x = v_1\", **kw),\n",
        "            Tex(\"y = v_2\", **kw),\n",
        "        )\n",
        "        x_label.next_to(plane.x_axis.get_right(), UR, SMALL_BUFF)\n",
        "        x_label.shift_onto_screen(buff=SMALL_BUFF)\n",
        "        y_label.next_to(plane.y_axis.get_top(), DR, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(plane, lag_ratio=2e-2))\n",
        "        self.play(\n",
        "            Write(x_label[:2]),\n",
        "            TransformFromCopy(ke_equation[\"v_1\"][0], x_label[\"v_1\"][0]),\n",
        "            FadeIn(state_point),\n",
        "        )\n",
        "        self.add(x_label)\n",
        "        self.play(\n",
        "            marked_velocity.animate.set_value([3, 0]),\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(y_label[:2]),\n",
        "            TransformFromCopy(ke_equation[\"v_2\"][0], y_label[\"v_2\"][0]),\n",
        "        )\n",
        "        self.add(y_label)\n",
        "        self.play(\n",
        "            marked_velocity.animate.set_value([-1, 3]),\n",
        "            run_time=5,\n",
        "            rate_func=wiggle,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Let it play forward\n",
        "        marked_velocity.add_updater(lambda m: m.set_value(state_tracker.get_block_velocities()))\n",
        "        self.add(state_tracker, marked_velocity)\n",
        "\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(10),\n",
        "            run_time=10,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "        # Show coordinates\n",
        "        coord_label = Tex(R\"(+0.00, +0.00)\", font_size=36)\n",
        "        coord_label.set_color(RED)\n",
        "        terms = coord_label.make_number_changeable(\"+0.00\", replace_all=True, include_sign=True)\n",
        "        for term, v in zip(terms, state_tracker.get_block_velocities()):\n",
        "            term.set_value(v)\n",
        "        coord_label.next_to(state_point, UR, buff=0)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(velocity_vectors[0][1].copy().clear_updaters(), terms[0]),\n",
        "            TransformFromCopy(velocity_vectors[1][1].copy().clear_updaters(), terms[1]),\n",
        "            FadeIn(coord_label[0::2]),\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Insertion\n",
        "        if False:\n",
        "            # This is just for a certain scene we're plugging in,\n",
        "            # not meant to be part of the main scene\n",
        "            self.remove(equations)\n",
        "            self.frame.set_field_of_view(1 * DEG)\n",
        "            self.camera.light_source.set_z(3)\n",
        "\n",
        "            blocks.clear_updaters()\n",
        "            blocks.scale(1.2)\n",
        "            velocity_vectors.scale(0.8)\n",
        "            blocks.arrange(LEFT, buff=LARGE_BUFF, aligned_edge=DOWN)\n",
        "            blocks[0][0].set_opacity(0.5)\n",
        "            blocks[1][0].set_opacity(0.5)\n",
        "            blocks.next_to(plane, LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "            marked_velocity.clear_updaters()\n",
        "\n",
        "            # Many random points\n",
        "            for _ in range(15):\n",
        "                coords = np.random.uniform(-4, 4, 2)\n",
        "                self.play(marked_velocity.animate.set_value(coords))\n",
        "                self.wait()\n",
        "\n",
        "        # Back up and add tail (Maybe just fade to here)\n",
        "        self.play(\n",
        "            FadeOut(coord_label),\n",
        "            time_tracker.animate.set_value(0).set_anim_args(run_time=2)\n",
        "        )\n",
        "\n",
        "        traced_path = self.get_traced_path(state_point)\n",
        "        self.add(traced_path)\n",
        "\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(45),\n",
        "            run_time=25,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        traced_path.clear_updaters()\n",
        "\n",
        "        # Highlight the conservation of energy\n",
        "        ke_rect = SurroundingRectangle(ke_equation).set_stroke(YELLOW, 2)\n",
        "        question = Text(\"How would you plot this?\", font_size=36)\n",
        "        question.next_to(ke_rect, DOWN)\n",
        "        question.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(p_equation),\n",
        "            ShowCreation(ke_rect),\n",
        "            Write(question, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        time_tracker.set_value(0)\n",
        "        blocks.update()\n",
        "\n",
        "        # Show xy equation\n",
        "        xy_equation = Tex(R\"5.00 {x}^2 + 0.50 {y}^2 = \\text{E}\", font_size=36)\n",
        "        xy_equation[\"{x}\"].set_color(RED)\n",
        "        xy_equation[\"{y}\"].set_color(RED)\n",
        "        xy_equation.next_to(question, DOWN, buff=MED_LARGE_BUFF)\n",
        "        x_coef = xy_equation.make_number_changeable(\"5.00\")\n",
        "        y_coef = xy_equation.make_number_changeable(\"0.50\")\n",
        "\n",
        "        ellipse = Circle(radius=plane.x_axis.get_unit_size())\n",
        "        ellipse.set_stroke(YELLOW, 2)\n",
        "        ellipse.stretch(math.sqrt(10), 1)\n",
        "        ellipse.move_to(plane.c2p(0, 0))\n",
        "\n",
        "        state_point.set_z_index(1)\n",
        "\n",
        "        self.play(FadeIn(xy_equation, DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            traced_path.animate.set_stroke(WHITE, 1, 0.25),\n",
        "            ShowCreation(ellipse),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize squish\n",
        "        self.play(\n",
        "            FadeOut(state_point),\n",
        "            FadeOut(traced_path),\n",
        "            FadeOut(ke_rect),\n",
        "            FadeOut(question),\n",
        "            VGroup(\n",
        "                ke_equation, xy_equation\n",
        "            ).animate.arrange(DOWN, buff=0.5).next_to(plane, LEFT, buff=LARGE_BUFF),\n",
        "        )\n",
        "        underlines = VGroup(\n",
        "            Underline(x_coef, buff=SMALL_BUFF),\n",
        "            Underline(ke_equation[\"m_1\"], buff=SMALL_BUFF),\n",
        "        )\n",
        "        underlines.set_color(YELLOW)\n",
        "\n",
        "        l_squish_arrows = Vector(0.75 * RIGHT).get_grid(4, 1, v_buff=0.75)\n",
        "        l_squish_arrows.next_to(plane.get_origin(), LEFT, buff=0.75)\n",
        "        r_squish_arrows = l_squish_arrows.copy().flip(about_point=plane.get_origin())\n",
        "        squish_arrows = VGroup(*l_squish_arrows, *r_squish_arrows)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, squish_arrows, lag_ratio=1e-2, run_time=1))\n",
        "        self.play(\n",
        "            ShowCreation(underlines, lag_ratio=0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(squish_arrows), FadeOut(underlines))\n",
        "\n",
        "        # Show the size of the ellipse\n",
        "        marked_velocity.suspend_updating()\n",
        "        E_rects = VGroup(\n",
        "            SurroundingRectangle(ke_equation[R\"\\text{E}\"], buff=SMALL_BUFF),\n",
        "            SurroundingRectangle(xy_equation[R\"\\text{E}\"], buff=SMALL_BUFF),\n",
        "        )\n",
        "        E_rects.set_stroke(YELLOW, 1)\n",
        "        self.play(ShowCreation(E_rects, lag_ratio=0))\n",
        "        self.play(\n",
        "            marked_velocity.animate.set_value([-0.5, 0]),\n",
        "            ellipse.animate.scale(0.25),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(FadeOut(E_rects))\n",
        "        marked_velocity.resume_updating()\n",
        "\n",
        "        # Show the experiment play out one more time\n",
        "        traced_path = self.get_traced_path(state_point)\n",
        "        self.add(traced_path, state_point)\n",
        "\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(20),\n",
        "            run_time=20,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        traced_path.clear_updaters()\n",
        "\n",
        "        # Stretch into a circle\n",
        "        state_point.clear_updaters()\n",
        "        new_ke_eq = Tex(\n",
        "            R\"\\left(\\sqrt{m_1} \\cdot v_1\\right)^2 + \\left(\\sqrt{m_2} \\cdot v_2\\right)^2 = 2 \\text{E}\",\n",
        "            **kw\n",
        "        )\n",
        "        new_xy_eq = Tex(R\"x^2 + y^2 = 2\\text{E}\", **kw)\n",
        "        new_xy_eq.scale(48 / 36)\n",
        "        ke_equation.target = ke_equation.generate_target()\n",
        "        stack = VGroup(\n",
        "            ke_equation.target,\n",
        "            new_ke_eq,\n",
        "            new_xy_eq,\n",
        "        )\n",
        "        stack.arrange(DOWN, buff=0.5)\n",
        "        stack.next_to(plane, LEFT, buff=1.0)\n",
        "\n",
        "        self.play(\n",
        "            Group(ellipse, traced_path, state_point).animate.stretch(math.sqrt(10), 0, about_point=plane.get_origin()),\n",
        "            FadeOut(axis_labels, time_span=(0, 1)),\n",
        "            LaggedStart(\n",
        "                MoveToTarget(ke_equation),\n",
        "                FadeOut(xy_equation, DOWN),\n",
        "                FadeIn(new_ke_eq),\n",
        "                FadeIn(new_xy_eq),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight circle equation\n",
        "        rect = SurroundingRectangle(new_xy_eq)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        words = Text(\"Equation for a circle\", font_size=36)\n",
        "        words.next_to(rect, DOWN)\n",
        "        words.set_color(YELLOW)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(words),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show new axis labels\n",
        "        x_axis_label, y_axis_label = axis_labels = VGroup(\n",
        "            Tex(R\"x = \\sqrt{m_1} \\cdot v_1\", **kw),\n",
        "            Tex(R\"y = \\sqrt{m_2} \\cdot v_2\", **kw),\n",
        "        )\n",
        "        axis_labels.scale(30 / 36)\n",
        "        x_axis_label.next_to(plane.x_axis.get_right(), DR, SMALL_BUFF)\n",
        "        y_axis_label.next_to(plane.y_axis.get_top(), DR, SMALL_BUFF)\n",
        "\n",
        "        x_rhs_tex = R\"\\sqrt{m_1} \\cdot v_1\"\n",
        "        y_rhs_tex = R\"\\sqrt{m_2} \\cdot v_2\"\n",
        "\n",
        "        rect2 = SurroundingRectangle(new_ke_eq[R\"\\left(\\sqrt{m_1} \\cdot v_1\\right)^2\"])\n",
        "        rect2.match_style(rect)\n",
        "\n",
        "        self.play(\n",
        "            rect.animate.surround(new_xy_eq[\"x^2\"]),\n",
        "            FadeIn(rect2),\n",
        "            FadeOut(words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(new_xy_eq[\"x\"][0], x_axis_label[\"x\"][0]),\n",
        "            TransformFromCopy(new_ke_eq[x_rhs_tex][0], x_axis_label[x_rhs_tex][0]),\n",
        "            Write(x_axis_label[\"=\"][0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            rect.animate.surround(new_xy_eq[\"y^2\"]),\n",
        "            rect2.animate.surround(new_ke_eq[R\"\\left(\\sqrt{m_2} \\cdot v_2\\right)^2\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(new_xy_eq[\"y\"][0], y_axis_label[\"y\"][0]),\n",
        "            TransformFromCopy(new_ke_eq[y_rhs_tex][0], y_axis_label[y_rhs_tex][0]),\n",
        "            Write(y_axis_label[\"=\"][0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(new_xy_eq),\n",
        "            rect2.animate.surround(VGroup(ke_equation, new_ke_eq)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect), FadeOut(rect2))\n",
        "        self.wait()\n",
        "\n",
        "        # Roll back to the beginning once more\n",
        "        state_point.add_updater(lambda m: m.move_to(\n",
        "            plane.c2p(*state_tracker.get_scaled_block_velocities())\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(0),\n",
        "            FadeOut(new_ke_eq),\n",
        "            FadeOut(new_xy_eq),\n",
        "            FadeOut(traced_path),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Shrinking circle\n",
        "        if False:\n",
        "            # For an insertion\n",
        "            time_tracker.clear_updaters()\n",
        "            time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "            last_n_collisions = state_tracker.get_n_collisions()\n",
        "\n",
        "            ghost_circles = VGroup()\n",
        "            self.add(ghost_circles)\n",
        "            self.add(self.get_traced_path(state_point))\n",
        "            for _ in range(10):\n",
        "                self.wait_until(lambda: state_tracker.get_n_collisions() > last_n_collisions)\n",
        "                ghost_circles.add(ellipse.copy().set_stroke(opacity=0.25))\n",
        "                ellipse.scale(0.9)\n",
        "                time_tracker.set_value(time_tracker.get_value() / 0.9)\n",
        "                time_tracker.increment_value(1 / 30)\n",
        "                state_tracker.state0[2:] *= 0.9\n",
        "                last_n_collisions = state_tracker.get_n_collisions()\n",
        "\n",
        "        # Show the regions of the state space\n",
        "        region = Square()\n",
        "        region.set_fill(RED, 0.25)\n",
        "        region.set_stroke(RED, 0)\n",
        "        region.replace(plane, stretch=True)\n",
        "        region.stretch(0.5, 0, about_edge=LEFT)\n",
        "        region.save_state()\n",
        "        region.stretch(1e-5, 0, about_edge=RIGHT)\n",
        "\n",
        "        self.play(Restore(region))\n",
        "        self.wait()\n",
        "        self.play(region.animate.stretch(0, 1).set_stroke(RED, 2))\n",
        "        self.wait()\n",
        "        self.play(region.animate.scale(0, about_point=state_point.get_center()))\n",
        "        self.remove(region)\n",
        "        self.wait()\n",
        "\n",
        "        # Think through first collision\n",
        "        self.play(time_tracker.animate.set_value(2), run_time=2, rate_func=linear)\n",
        "\n",
        "        big_block_rect, lil_block_rect = rects = VGroup(\n",
        "            SurroundingRectangle(Group(blocks[i], velocity_vectors[i]), buff=buff)\n",
        "            for i, buff in zip([0, 1], [0.25, 0.1])\n",
        "        )\n",
        "        rects.set_stroke(RED, 2)\n",
        "        x_rect, y_rect = xy_rects = Square().replicate(2)\n",
        "        xy_rects.set_stroke(RED, width=0).set_fill(RED, 0.2)\n",
        "        xy_rects.replace(plane, stretch=True)\n",
        "        y_rect.stretch(0.5, 1, about_edge=DOWN)\n",
        "        x_rect.stretch(0.05, 0, about_point=plane.c2p(-2.7, 0))\n",
        "\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(lil_block_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(lil_block_rect, y_rect))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(big_block_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(big_block_rect, x_rect))\n",
        "        self.play(x_rect.animate.shift(0.2 * RIGHT), run_time=4, rate_func=lambda t: wiggle(t, 5))\n",
        "        self.wait()\n",
        "\n",
        "        # Constrain to circle\n",
        "        state_point.clear_updaters()\n",
        "        marked_velocity.clear_updaters()\n",
        "        marked_velocity.add_updater(\n",
        "            lambda m: m.set_value(\n",
        "                np.array(plane.p2c(state_point.get_center())) / state_tracker.sqrt_mass_vect\n",
        "            )\n",
        "        )\n",
        "        arc = Arc(190 * DEG, 50 * DEG, radius=0.5 * ellipse.get_width(), arc_center=plane.get_center())\n",
        "        arc.set_stroke(RED, 5)\n",
        "\n",
        "        self.play(Rotate(state_point, TAU, about_point=plane.get_origin(), run_time=5))\n",
        "        self.play(\n",
        "            ReplacementTransform(x_rect, arc),\n",
        "            ReplacementTransform(y_rect, arc),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                state_point,\n",
        "                25 * DEG,\n",
        "                about_point=plane.get_center(),\n",
        "                rate_func=lambda t: wiggle(t, 5),\n",
        "                run_time=8,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring in conservation of momentum\n",
        "        p_equation.next_to(ke_equation, DOWN)\n",
        "        new_p_eq = Tex(\n",
        "            R\"\\sqrt{m_1}\\left(\\sqrt{m_1} \\cdot v_1\\right) + \\sqrt{m_2}\\left(\\sqrt{m_2} \\cdot v_2\\right) = P\",\n",
        "            **kw\n",
        "        )\n",
        "        new_p_eq.next_to(p_equation, DOWN, buff=0.75)\n",
        "        p_xy_eq = Tex(R\"\\sqrt{m_1} x + \\sqrt{m_2} y = P\", **kw)\n",
        "        p_xy_eq.next_to(new_p_eq, DOWN, buff=0.75)\n",
        "\n",
        "        p1_rects, p2_rects = p_rects = VGroup(\n",
        "            VGroup(\n",
        "                SurroundingRectangle(p_equation[f\"m_{i} v_{i}\"]),\n",
        "                SurroundingRectangle(p_xy_eq[Rf\"\\sqrt{{m_{i}}} {x}\"]),\n",
        "            )\n",
        "            for i, x in [(1, \"x\"), (2, \"y\")]\n",
        "        )\n",
        "        p_rects.set_stroke(GREEN, 2)\n",
        "\n",
        "        self.play(\n",
        "            ke_equation.animate.to_edge(UP).set_opacity(0.33),\n",
        "            FadeIn(p_equation),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(p_equation.copy(), new_p_eq))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                new_p_eq.copy(),\n",
        "                p_xy_eq,\n",
        "                key_map={\n",
        "                    R\"\\left(\\sqrt{m_1} \\cdot v_1\\right)\": \"x\",\n",
        "                    R\"\\left(\\sqrt{m_2} \\cdot v_2\\right)\": \"y\",\n",
        "                }\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(p1_rects, lag_ratio=0))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(p1_rects, p2_rects))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(p2_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the momentum line\n",
        "        p_line = Line(LEFT, RIGHT)\n",
        "        p_line.set_width(6)\n",
        "        p_line.set_stroke(GREEN, 3)\n",
        "        p_line.rotate(-90 * DEG + state_tracker.theta)\n",
        "        p_line.move_to(ellipse.get_left())\n",
        "\n",
        "        slope_eq = Tex(R\"\\text{Slope} = -\\sqrt{m_1 \\over m_2}\", font_size=36)\n",
        "        slope_eq.next_to(p_line.pfp(0.6), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(p_line),\n",
        "            FadeOut(arc),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(slope_eq))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(slope_eq))\n",
        "        self.play(\n",
        "            Group(p_line, state_point).animate.shift(4 * RIGHT),\n",
        "            run_time=8,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Note the two intersection points\n",
        "        point2 = state_point.get_center().copy()\n",
        "        state_point.add_updater(lambda m: m.move_to(plane.c2p(*state_tracker.get_scaled_block_velocities())))\n",
        "        self.play(time_tracker.animate.set_value(0), run_time=2)\n",
        "        point1 = state_point.get_center().copy()\n",
        "        self.wait()\n",
        "        state_point.suspend_updating()\n",
        "\n",
        "        intersection_arrows = VGroup(\n",
        "            Vector(0.5 * DL).next_to(point, UR, buff=SMALL_BUFF)\n",
        "            for point in [point1, point2]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            state_point.animate.move_to(p_line.get_start()),\n",
        "            rate_func=lambda t: wiggle(t, 5),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(GrowArrow, intersection_arrows, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        state_point.resume_updating()\n",
        "        traced_path = self.get_traced_path(state_point)\n",
        "        self.add(traced_path)\n",
        "        self.play(time_tracker.animate.set_value(2), run_time=2, rate_func=linear)\n",
        "        traced_path.suspend_updating()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(intersection_arrows),\n",
        "            FadeOut(new_p_eq),\n",
        "            FadeOut(p_xy_eq),\n",
        "            ke_equation.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "        # Little block off wall\n",
        "        traced_path.resume_updating()\n",
        "        self.play(time_tracker.animate.set_value(7), run_time=5, rate_func=linear)\n",
        "        traced_path.suspend_updating()\n",
        "        self.wait()\n",
        "\n",
        "        state_point.suspend_updating()\n",
        "        self.play(\n",
        "            state_point.animate.move_to(point2),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            p_line.animate.move_to(plane.c2p(state_tracker.get_momentum() / math.sqrt(self.masses[0]))),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Let play out for a while\n",
        "        p_line.add_updater(\n",
        "            lambda m: m.move_to(plane.c2p(state_tracker.get_momentum() / math.sqrt(self.masses[0])))\n",
        "        )\n",
        "\n",
        "        traced_path.resume_updating()\n",
        "        state_point.resume_updating()\n",
        "\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(25),\n",
        "            run_time=(25 - time_tracker.get_value()),\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "        # Show the end zone\n",
        "        endzone_line = Line(\n",
        "            plane.get_origin(),\n",
        "            plane.c2p(*(state_tracker.sqrt_mass_vect * 4)),\n",
        "        )\n",
        "        endzone_line.set_stroke(WHITE, 2)\n",
        "        endzone = Polygon(\n",
        "            endzone_line.get_end(),\n",
        "            plane.get_origin(),\n",
        "            plane.c2p(10, 0),\n",
        "        )\n",
        "        endzone.set_fill(GREEN, 0.25)\n",
        "        endzone.set_stroke(width=0)\n",
        "\n",
        "        ur_quadrant = Square(4.0)\n",
        "        ur_quadrant.set_fill(GREEN, 0.25).set_stroke(width=0)\n",
        "        ur_quadrant.move_to(plane.get_origin(), DL)\n",
        "\n",
        "        endzone_line_label = Tex(R\"v_1 = v_2\", **kw)\n",
        "        endzone_line_label.next_to(ORIGIN, UP, buff=SMALL_BUFF)\n",
        "        slope_label = Tex(R\"y = x \\cdot \\sqrt{m_2 / m_1}\", **kw)\n",
        "        slope_label.scale(20 / kw[\"font_size\"])\n",
        "        slope_label.next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "\n",
        "        VGroup(\n",
        "            endzone_line_label, slope_label\n",
        "        ).rotate(state_tracker.theta, about_point=ORIGIN).shift(endzone_line.pfp(0.45))\n",
        "\n",
        "        time_tracker.clear_updaters()\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.wait(5)\n",
        "        self.play(FadeOut(p_line), FadeIn(ur_quadrant))\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            FadeOut(ur_quadrant),\n",
        "            FadeIn(endzone)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(ShowCreation(endzone_line), Write(endzone_line_label))\n",
        "        self.wait(2)\n",
        "        self.play(Write(slope_label))\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_floor_and_wall_2d(\n",
        "        self,\n",
        "        width=13,\n",
        "        stroke_width=2,\n",
        "        height=2,\n",
        "        tick_spacing=0.5,\n",
        "        tick_vect=0.25 * DL,\n",
        "        buff_to_bottom=0.75,\n",
        "    ):\n",
        "        floor = Line(LEFT, RIGHT)\n",
        "        floor.set_width(width)\n",
        "        floor.center()\n",
        "        floor.to_edge(DOWN, buff=buff_to_bottom)\n",
        "        dl_point = floor.get_left()\n",
        "\n",
        "        wall = Line(ORIGIN, UP)\n",
        "        wall.set_height(height)\n",
        "        wall.move_to(dl_point, DOWN)\n",
        "\n",
        "        ticks = VGroup()\n",
        "        for y in np.arange(tick_spacing, height + tick_spacing, tick_spacing):\n",
        "            start = dl_point + y * UP\n",
        "            ticks.add(Line(start, start + tick_vect))\n",
        "\n",
        "        result = VGroup(floor, VGroup(wall, ticks))\n",
        "        result.set_stroke(WHITE, stroke_width)\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_floor_and_wall_3d(\n",
        "        self,\n",
        "        buff_to_bottom=0.75,\n",
        "        color=GREY_D,\n",
        "        shading=(0.2, 0.2, 0.2)\n",
        "    ):\n",
        "        floor = Square3D(resolution=(20, 20))\n",
        "        floor.rotate(90 * DEG, LEFT)\n",
        "        floor.set_shape(self.floor_width, 0, self.floor_depth)\n",
        "        floor.to_edge(DOWN, buff=buff_to_bottom)\n",
        "\n",
        "        wall = Square3D()\n",
        "        wall.rotate(90 * DEG, UP)\n",
        "        wall.set_shape(0, self.wall_height, self.floor_depth)\n",
        "        wall.move_to(floor.get_left(), DOWN)\n",
        "\n",
        "        result = Group(floor, wall)\n",
        "        result.set_color(color)\n",
        "        result.set_shading(*shading)\n",
        "        result.to_corner(DL)\n",
        "\n",
        "        for part, vect in zip(result, [OUT, RIGHT]):\n",
        "            part.data['d_normal_point'] = part.data['point'] + 1e-3 * vect\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_block_pair(self, floor, three_d=False):\n",
        "        return Group(\n",
        "            self.get_block(mass, color, width, floor, three_d=three_d)\n",
        "            for mass, color, width in zip(self.masses, self.colors, self.widths)\n",
        "        )\n",
        "\n",
        "    def get_block(\n",
        "        self,\n",
        "        mass,\n",
        "        color,\n",
        "        width,\n",
        "        floor,\n",
        "        font_size=24,\n",
        "        three_d=False,\n",
        "        stroke_width=2,\n",
        "        shading=None,\n",
        "        floor_buff=0.01,\n",
        "    ):\n",
        "        if shading is None:\n",
        "            shading = self.block_shading\n",
        "        if three_d:\n",
        "            body = Cube()\n",
        "            body.set_color(color)\n",
        "            body.set_shading(*shading)\n",
        "\n",
        "            shell = VCube()\n",
        "            shell.set_fill(opacity=0)\n",
        "            shell.set_stroke(WHITE, width=1)\n",
        "            shell.set_anti_alias_width(3)\n",
        "            shell.replace(body)\n",
        "            shell.apply_depth_test()\n",
        "            shell.set_anti_alias_width(1)\n",
        "\n",
        "            block = Group(body, shell)\n",
        "        else:\n",
        "            block = Square()\n",
        "            block.set_stroke(WHITE, stroke_width)\n",
        "            block.set_fill(color, 1)\n",
        "            block.set_shading(*shading)\n",
        "\n",
        "        block.set_width(width)\n",
        "        block.next_to(floor, UP, buff=floor_buff)\n",
        "        block.mass = mass\n",
        "\n",
        "        mass_label = Tex(R\"10 \\, \\text{kg}\", font_size=font_size)\n",
        "        mass_label.make_number_changeable(\"10\", edge_to_fix=RIGHT).set_value(mass)\n",
        "        mass_label.next_to(block, UP, buff=SMALL_BUFF)\n",
        "        if three_d:\n",
        "            mass_label.set_backstroke(BLACK, 1)\n",
        "\n",
        "        block.add(mass_label)\n",
        "        block.mass_label = mass_label\n",
        "\n",
        "        return block\n",
        "\n",
        "    def bind_blocks_to_state(self, blocks, floor, state_tracker):\n",
        "        min_x = floor.get_x(LEFT) + blocks[1].get_width()\n",
        "\n",
        "        def update_blocks(blocks):\n",
        "            pos = state_tracker.get_block_positions()\n",
        "            blocks[0].set_x(min_x + pos[0], LEFT)\n",
        "            blocks[1].set_x(min_x + pos[1], RIGHT)\n",
        "\n",
        "        blocks.add_updater(update_blocks)\n",
        "\n",
        "    def get_velocity_vector(\n",
        "        self,\n",
        "        block,\n",
        "        vel_function,\n",
        "        thickness=2,\n",
        "        scale_factor=0.5,\n",
        "        color=RED,\n",
        "        backstroke_width=1,\n",
        "        label_backstroke_width=1,\n",
        "        num_decimal_places=2,\n",
        "        max_width=1.0,\n",
        "        font_size=18\n",
        "    ):\n",
        "        vector = Vector(RIGHT, thickness=thickness)\n",
        "        vector.set_fill(RED)\n",
        "        vector.set_backstroke(BLACK, backstroke_width)\n",
        "\n",
        "        def update_vector(vector):\n",
        "            start = block[0].get_zenith() + 0.1 * DOWN\n",
        "            vel = vel_function()\n",
        "            width = max_width * math.tanh(scale_factor * vel)\n",
        "            vector.put_start_and_end_on(start, start + width * RIGHT)\n",
        "            return vector\n",
        "\n",
        "        vector.add_updater(update_vector)\n",
        "\n",
        "        label = DecimalNumber(\n",
        "            0,\n",
        "            num_decimal_places=num_decimal_places,\n",
        "            font_size=font_size\n",
        "        )\n",
        "        label.set_fill(RED)\n",
        "        label.set_backstroke(BLACK, label_backstroke_width)\n",
        "        label.add_updater(lambda m: m.set_value(vel_function()).next_to(\n",
        "            vector.get_start(), UP, buff=0.1\n",
        "        ))\n",
        "        # label.always.next_to(vector, UP, buff=0.05)\n",
        "        # label.f_always.set_value(vel_function)\n",
        "\n",
        "        return VGroup(vector, label)\n",
        "\n",
        "    def get_traced_path(self, state_point):\n",
        "        return TracedPath(state_point.get_center, stroke_color=RED, stroke_width=1)\n",
        "\n",
        "    def check_for_clacks(self):\n",
        "        n_collisions = self.state_tracker.get_n_collisions()\n",
        "\n",
        "        if n_collisions == self.last_collision_count:\n",
        "            return\n",
        "        if n_collisions % 2 == 0:\n",
        "            point = self.blocks[1][0].get_left()\n",
        "        else:\n",
        "            point = self.blocks[1][0].get_right()\n",
        "\n",
        "        time_since = self.state_tracker.time_from_last_collision()\n",
        "\n",
        "        if n_collisions > self.last_collision_count:\n",
        "            flash = turn_animation_into_updater(ClackAnimation(point))\n",
        "            flash.update(dt=time_since)\n",
        "            flash.time = self.time - time_since\n",
        "            self.flashes.append(flash)\n",
        "            self.add(flash)\n",
        "\n",
        "        sound_file = self.clack_sound if n_collisions > self.last_collision_count else self.reverse_clack_sound\n",
        "        self.add_sound(sound_file, time_offset=-time_since)\n",
        "\n",
        "        for flash in self.flashes:\n",
        "            if flash.time < self.time - 0.25:\n",
        "                self.remove(flash)\n",
        "                self.flashes.remove(flash)\n",
        "\n",
        "        self.last_collision_count = n_collisions\n",
        "\n",
        "    def update_frame(self, dt=0, force_draw=False):\n",
        "        if dt > 0 and self.listen_for_clacks:\n",
        "            self.check_for_clacks()\n",
        "        super().update_frame(dt, force_draw)\n",
        "\n",
        "\n",
        "class BasicBlockCount(Blocks):\n",
        "    initial_positions = [10, 7]\n",
        "    initial_velocities = [-2, 0]\n",
        "    masses = [10, 1]\n",
        "    widths = [1.0, 0.5]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    total_time = 30\n",
        "    field_of_view = 10 * DEG\n",
        "    floor_width = 15\n",
        "    floor_depth = 6\n",
        "    wall_height = 5\n",
        "    initial_orientation = (0, 0, 0)\n",
        "    samples = 4\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_count_label()\n",
        "        self.frame.reorient(*self.initial_orientation)\n",
        "        # Test\n",
        "\n",
        "        self.play(\n",
        "            self.time_tracker.animate.set_value(self.total_time),\n",
        "            run_time=self.total_time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    def add_count_label(self):\n",
        "        count_label = Tex(R\"\\# \\text{Collisions} = 0\")\n",
        "        count = count_label.make_number_changeable(\"0\")\n",
        "        count.f_always.set_value(self.state_tracker.get_n_collisions)\n",
        "        count_label.to_corner(UL)\n",
        "        count_label.fix_in_frame()\n",
        "        self.count_label = count_label\n",
        "        self.add(count_label)\n",
        "\n",
        "\n",
        "class PreviewClip(BasicBlockCount):\n",
        "    initial_velocities = [-0.75, 0]\n",
        "    masses = [100, 1]\n",
        "    widths = [2.0, 0.5]\n",
        "    initial_positions = [10, 7]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    floor_depth = 2\n",
        "    wall_height = 2\n",
        "\n",
        "    def construct(self):\n",
        "        # Basic shot\n",
        "        frame = self.frame\n",
        "        frame.reorient(-46, -6, 0, (0.41, -2.47, 1.07), 3.59)\n",
        "        self.add(self.wall)\n",
        "        self.add_count_label()\n",
        "        self.time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.play(\n",
        "            frame.animate.reorient(-46, -4, 0, (-0.78, -2.2, -0.17), 5.41),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-4, -4, 0, (-2.38, -1.95, -0.99), 6.58),\n",
        "            run_time=12,\n",
        "        )\n",
        "        self.play(frame.animate.reorient(-3, -2, 0, (1.68, -0.59, -0.79), 9.86), run_time=20)\n",
        "\n",
        "\n",
        "class BasicBlockCount1e1(BasicBlockCount):\n",
        "    initial_positions = [6, 3]\n",
        "    initial_velocities = [-2, 0]\n",
        "    masses = [1, 1]\n",
        "    widths = [0.5, 0.5]\n",
        "    colors = [LITTLE_BLOCK_COLOR, LITTLE_BLOCK_COLOR]\n",
        "    total_time = 15\n",
        "\n",
        "\n",
        "class BasicBlockCount4(BasicBlockCount):\n",
        "    initial_positions = [8, 5]\n",
        "    initial_velocities = [-2, 0]\n",
        "    masses = [4, 1]\n",
        "    widths = [1.0, 0.75]\n",
        "    colors = [BLUE_D, LITTLE_BLOCK_COLOR]\n",
        "    total_time = 15\n",
        "\n",
        "\n",
        "class BasicBlockCount16Faster(BasicBlockCount):\n",
        "    initial_positions = [8, 5]\n",
        "    initial_velocities = [-2, 0]\n",
        "    masses = [16, 1]\n",
        "    widths = [1.5, 0.75]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    total_time = 15\n",
        "\n",
        "\n",
        "class BasicBlockCount64Slower(BasicBlockCount):\n",
        "    initial_positions = [5, 3]\n",
        "    initial_velocities = [-1.0, 0]\n",
        "    masses = [64, 1]\n",
        "    widths = [2.0, 0.75]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.5), LITTLE_BLOCK_COLOR]\n",
        "    total_time = 30\n",
        "\n",
        "\n",
        "class BasicBlockCount256(BasicBlockCount):\n",
        "    initial_positions = [5, 3]\n",
        "    initial_velocities = [-1.5, 0]\n",
        "    masses = [256, 1]\n",
        "    widths = [2.5, 0.75]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.8), LITTLE_BLOCK_COLOR]\n",
        "    total_time = 20\n",
        "\n",
        "\n",
        "class BasicBlockCount1e2(BasicBlockCount):\n",
        "    initial_positions = [8, 5]\n",
        "    initial_velocities = [-1, 0]\n",
        "    masses = [100, 1]\n",
        "    widths = [1.0, 0.5]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    total_time = 30\n",
        "\n",
        "\n",
        "class BasicBlockCount1e4(BasicBlockCount1e2):\n",
        "    masses = [int(1e4), 1]\n",
        "    widths = [1.5, 0.5]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.5), LITTLE_BLOCK_COLOR]\n",
        "    total_time = 40\n",
        "\n",
        "\n",
        "class BasicBlockCount1e6(BasicBlockCount1e2):\n",
        "    masses = [int(1e6), 1]\n",
        "    widths = [2.0, 0.5]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.8), LITTLE_BLOCK_COLOR]\n",
        "\n",
        "\n",
        "class BasicBlockCount1e8(BasicBlockCount1e2):\n",
        "    masses = [int(1e8), 1]\n",
        "    widths = [3.0, 0.5]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.95), LITTLE_BLOCK_COLOR]\n",
        "    block_shading = [0.25, 0.25, 0]\n",
        "    initial_orientation = (-7, 1, 0)\n",
        "\n",
        "\n",
        "class BasicBlockCount1e10(BasicBlockCount1e2):\n",
        "    masses = [int(1e10), 1]\n",
        "    widths = [3.0, 0.5]\n",
        "    initial_positions = [5, 3]\n",
        "    colors = [BLACK, LITTLE_BLOCK_COLOR]\n",
        "    block_shading = [0.1, 0.1, 0]\n",
        "    initial_orientation = (-7, 1, 0)\n",
        "    total_time = 20\n",
        "\n",
        "\n",
        "class SlowMoBlockCount(BasicBlockCount1e4):\n",
        "    time_to_slomo = 7.95\n",
        "    wall_height = 3\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add_count_label()\n",
        "\n",
        "        time_tracker = self.time_tracker\n",
        "        rate_tracker = ValueTracker(1)\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(rate_tracker.get_value() * dt))\n",
        "        self.add(time_tracker)\n",
        "\n",
        "        slowdown_label = Tex(R\"100 \\text{x } \\text{Slower}\")\n",
        "        slowdown_label.next_to(self.count_label, DOWN)\n",
        "        slowdown_label.set_color(RED)\n",
        "        factor_label = slowdown_label.make_number_changeable(\"100\", edge_to_fix=UR)\n",
        "        factor_label.add_updater(lambda m: m.set_value(int(1 / rate_tracker.get_value())).fix_in_frame())\n",
        "        slowdown_label.fix_in_frame()\n",
        "\n",
        "        self.slowdown_label = slowdown_label\n",
        "        self.rate_tracker = rate_tracker\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-1, 0, 0, (-5.94, -2.36, -1.0), 3.80).set_field_of_view(25 * DEG),\n",
        "            run_time=self.time_to_slomo\n",
        "        )\n",
        "        self.clack_sound = \"slow_clack\"\n",
        "\n",
        "        self.rate_tracker.set_value(0.01)\n",
        "        self.add(self.slowdown_label)\n",
        "        self.wait(7)\n",
        "\n",
        "        self.rate_tracker.set_value(1.0)\n",
        "        self.remove(self.slowdown_label)\n",
        "        self.clack_sound = \"clack\"\n",
        "        self.play(\n",
        "            self.frame.animate.to_default_state().set_field_of_view(15 * DEG),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class SlowMoBlockCount1e6(SlowMoBlockCount):\n",
        "    masses = [int(1e6), 1]\n",
        "    widths = [2.0, 0.5]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.8), LITTLE_BLOCK_COLOR]\n",
        "    time_to_slomo = 7.97\n",
        "    slow_factor = 2000\n",
        "    time_in_slo_mo = 10 / 2000\n",
        "    time_after = 10\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        rate_tracker = self.rate_tracker\n",
        "\n",
        "        # Test\n",
        "        self.play(\n",
        "            frame.animate.reorient(-9, 3, 0, (-4.25, -1.33, -0.98), 5.70).set_field_of_view(25 * DEG),\n",
        "            run_time=7.90\n",
        "        )\n",
        "\n",
        "        self.clack_sound = \"slow_clack\"\n",
        "        self.add(self.slowdown_label)\n",
        "        rate_tracker.set_value(1e-2)\n",
        "        self.wait(8)\n",
        "\n",
        "        rate_tracker.set_value(1e-3)\n",
        "        self.clack_sound = \"super_slow_clack\"\n",
        "        self.wait(7)\n",
        "\n",
        "        rate_tracker.set_value(1e-4)\n",
        "        self.clack_sound = \"super_super_slow_clack\"\n",
        "        self.wait(10)\n",
        "\n",
        "        rate_tracker.set_value(1e-3)\n",
        "        self.clack_sound = \"super_slow_clack\"\n",
        "        self.wait()\n",
        "\n",
        "        self.clack_sound = \"slow_clack\"\n",
        "        self.add(self.slowdown_label)\n",
        "        rate_tracker.set_value(1e-2)\n",
        "        self.wait()\n",
        "\n",
        "        rate_tracker.set_value(1)\n",
        "        self.remove(self.slowdown_label)\n",
        "        self.clack_sound = \"clack\"\n",
        "        self.play(frame.animate.to_default_state().set_field_of_view(10 * DEG), run_time=5)\n",
        "        self.wait(15)\n",
        "\n",
        "\n",
        "class SlowMoBlockCount1e8(SlowMoBlockCount):\n",
        "    masses = [int(1e8), 1]\n",
        "    widths = [3.0, 0.5]\n",
        "    colors = [interpolate_color(BLUE_E, BLACK, 0.95), LITTLE_BLOCK_COLOR]\n",
        "    block_shading = [0.25, 0.25, 0]\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        rate_tracker = self.rate_tracker\n",
        "\n",
        "        # Test\n",
        "        self.play(\n",
        "            frame.animate.reorient(-8, -6, 0, (-4.15, -1.22, -0.96), 6.18).set_field_of_view(25 * DEG),\n",
        "            run_time=7.98\n",
        "        )\n",
        "\n",
        "        self.clack_sound = \"slow_clack\"\n",
        "        self.add(self.slowdown_label)\n",
        "        rate_tracker.set_value(1e-2)\n",
        "        self.wait()\n",
        "\n",
        "        rate_tracker.set_value(1e-3)\n",
        "        self.clack_sound = \"super_slow_clack\"\n",
        "        self.wait()\n",
        "\n",
        "        rate_tracker.set_value(1e-4)\n",
        "        self.clack_sound = \"super_super_slow_clack\"\n",
        "        self.wait(10)\n",
        "\n",
        "        rate_tracker.set_value(1e-3)\n",
        "        self.clack_sound = \"super_slow_clack\"\n",
        "        self.wait()\n",
        "\n",
        "        self.clack_sound = \"slow_clack\"\n",
        "        self.add(self.slowdown_label)\n",
        "        rate_tracker.set_value(1e-2)\n",
        "        self.wait()\n",
        "\n",
        "        rate_tracker.set_value(1)\n",
        "        self.remove(self.slowdown_label)\n",
        "        self.clack_sound = \"clack\"\n",
        "        self.play(frame.animate.to_default_state().set_field_of_view(10 * DEG), run_time=5)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class IntroduceSetup(BasicBlockCount):\n",
        "    masses = [16, 1]\n",
        "\n",
        "    def construct(self):\n",
        "        frame = self.frame\n",
        "        time_tracker = self.time_tracker\n",
        "        self.add_count_label()\n",
        "        count_label = self.count_label\n",
        "        self.remove(count_label)\n",
        "\n",
        "        # Describe the setup\n",
        "        floor_label = Text(\"Frictionless plane\")\n",
        "        floor_label.next_to(self.floor, UP, SMALL_BUFF)\n",
        "        floor_label.shift(2 * LEFT)\n",
        "        floor_label.set_backstroke(BLACK, 3)\n",
        "        alt_floor = self.floor.copy()\n",
        "        alt_floor.set_color(YELLOW, opacity=0.5)\n",
        "        alt_floor.shift(1e-3 * UP)\n",
        "        alt_floor.save_state()\n",
        "        alt_floor.stretch(0, 0, about_edge=LEFT)\n",
        "\n",
        "        time_tracker.clear_updaters()\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.wait(6)\n",
        "        self.add(floor_label, self.blocks)\n",
        "        self.play(\n",
        "            Write(floor_label),\n",
        "            Restore(alt_floor),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(alt_floor), FadeOut(floor_label))\n",
        "        self.wait(2)\n",
        "        time_tracker.clear_updaters()\n",
        "\n",
        "        # Back up\n",
        "        self.play(time_tracker.animate.set_value(0), run_time=2)\n",
        "\n",
        "        # Label\n",
        "        blocks = self.blocks\n",
        "        lil_block_rect = SurroundingRectangle(blocks[1])\n",
        "        lil_block_label = Text(\"Initially stationary\")\n",
        "        lil_block_label.set_color(YELLOW)\n",
        "        lil_block_label.next_to(lil_block_rect, UP, buff=1.5)\n",
        "        lil_block_arrow = Arrow(lil_block_label.get_bottom(), lil_block_rect.get_top())\n",
        "        lil_block_arrow.set_fill(YELLOW)\n",
        "\n",
        "        big_block_vect = Vector(1.5 * LEFT, thickness=4)\n",
        "        big_block_vect.set_fill(RED)\n",
        "        big_block_vect.shift(blocks[0][0].get_center())\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(lil_block_label),\n",
        "            ShowCreation(lil_block_rect),\n",
        "            GrowArrow(lil_block_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lil_block_rect.animate.surround(blocks[0]).set_stroke(opacity=0),\n",
        "            FadeOut(lil_block_label, shift=2 * RIGHT),\n",
        "            ReplacementTransform(lil_block_arrow, big_block_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Let it play out\n",
        "        big_block_vect.add_updater(lambda m: m.shift(blocks[0][0].get_center() - m.get_start()))\n",
        "        time_tracker.clear_updaters()\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(1.5 * dt))\n",
        "\n",
        "        self.play(\n",
        "            VFadeOut(big_block_vect),\n",
        "            VFadeIn(self.count_label),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ThumbnailShot(BasicBlockCount):\n",
        "    initial_velocities = [-0.75, 0]\n",
        "    masses = [int(1e6), 1]\n",
        "    widths = [1.0, 0.5]\n",
        "    initial_positions = [3, 2]\n",
        "    colors = [BLUE_E, LITTLE_BLOCK_COLOR]\n",
        "    floor_depth = 2\n",
        "    wall_height = 2\n",
        "\n",
        "    def construct(self):\n",
        "        # Orient\n",
        "        frame = self.frame\n",
        "        frame.reorient(-40, -5, 0, (-3.45, -2.54, -0.34), 3.00)\n",
        "\n",
        "        blocks = self.blocks\n",
        "        blocks.deactivate_depth_test()\n",
        "        for block in blocks:\n",
        "            block[2].set_opacity(0).scale(0, about_point=block[0].get_top())\n",
        "            for cube in block[:2]:\n",
        "                cube[1].set_opacity(0)\n",
        "                cube[2].set_opacity(0)\n",
        "                cube[5].set_opacity(0)\n",
        "\n",
        "        # Add speed lines\n",
        "        speed_lines = Line(ORIGIN, 1.5 * RIGHT).get_grid(7, 1)\n",
        "        speed_lines.set_stroke(YELLOW, width=(5, 0))\n",
        "        speed_lines.arrange_to_fit_height(0.8 * blocks[0][0].get_height())\n",
        "        speed_lines.next_to(blocks[0][0], RIGHT, buff=0.05, aligned_edge=OUT)\n",
        "\n",
        "        self.add(speed_lines)\n",
        "\n",
        "        lil_speed_lines = speed_lines[1:-1].copy()\n",
        "        lil_speed_lines.flip()\n",
        "        lil_speed_lines.set_shape(0.8, 0.3)\n",
        "        lil_speed_lines.next_to(blocks[1], LEFT, buff=0.05)\n",
        "        self.add(lil_speed_lines)\n",
        "\n",
        "        # Test\n",
        "\n",
        "    def old(self):\n",
        "        # Add ghosts\n",
        "        block_template = blocks[0].copy()\n",
        "        block_template.clear_updaters()\n",
        "        for a in np.linspace(0, 1, 4):\n",
        "            ghost_block = block_template.copy()\n",
        "            ghost_block.set_opacity(interpolate(0.9, 0.1, a))\n",
        "            ghost_block.shift(a * 2 * RIGHT)\n",
        "            self.add(ghost_block)\n",
        "        self.add(blocks)\n",
        "\n",
        "class MovementOfWall(Blocks):\n",
        "    initial_positions = [6, 5]\n",
        "    initial_velocities = [-2, 0]\n",
        "    masses = [1, 1]\n",
        "    widths = [0.5, 0.5]\n",
        "    colors = [LITTLE_BLOCK_COLOR, LITTLE_BLOCK_COLOR]\n",
        "\n",
        "    def construct(self):\n",
        "        # Nudge the wall\n",
        "        frame = self.frame\n",
        "        frame.reorient(-2, -4, 0, (-6.01, -2.36, -2.04), 6.24)\n",
        "\n",
        "        time_tracker = self.time_tracker\n",
        "        time_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        wall = self.wall\n",
        "        ghost_wall = wall.copy().set_opacity(0.5)\n",
        "        nudge = 0.25 * LEFT\n",
        "        brace = Brace(Line(ORIGIN, nudge), UP, tex_string=R\"\\underbrace{\\quad\\qquad}\")\n",
        "        brace.next_to(wall, UP, SMALL_BUFF, aligned_edge=RIGHT)\n",
        "        brace.save_state()\n",
        "        brace.stretch(0, 0, about_edge=RIGHT).set_fill(opacity=0)\n",
        "\n",
        "        self.wait(3)\n",
        "        self.add(ghost_wall)\n",
        "        self.play(\n",
        "            wall.animate.shift(nudge),\n",
        "            Restore(brace),\n",
        "            rate_func=rush_from\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Make it massive\n",
        "        time_tracker.clear_updaters()\n",
        "        block = Cube()\n",
        "        block.set_shape(0.5, self.wall_height, self.floor_depth)\n",
        "        block.move_to(ghost_wall, DR)\n",
        "        block.set_color(GREY_D)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(Group(wall, ghost_wall, brace)),\n",
        "            FadeIn(block),\n",
        "        )\n",
        "        self.play(block.animate.set_height(10, about_edge=UP, stretch=True), run_time=3)\n",
        "\n",
        "        time_tracker.set_value(0)\n",
        "        self.play(time_tracker.animate.set_value(6), run_time=6, rate_func=linear)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CirclePuzzle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        x_axis, y_axis = axes = VGroup(Line(1.5 * LEFT, 1.5 * RIGHT), Line(UP, DOWN))\n",
        "        axes.set_stroke(WHITE, 2, 0.33)\n",
        "        axes.set_height(7)\n",
        "        kw = dict(\n",
        "            t2c={\n",
        "                f\"v_1\": RED,\n",
        "                f\"v_2\": RED,\n",
        "                f\"m_1\": BLUE,\n",
        "                f\"m_2\": BLUE,\n",
        "            },\n",
        "            font_size=24\n",
        "        )\n",
        "        axis_labels = VGroup(\n",
        "            Tex(R\"x = \\sqrt{m_1} \\cdot v_1\", **kw).next_to(x_axis.get_right(), DOWN),\n",
        "            Tex(R\"y = \\sqrt{m_2} \\cdot v_2\", **kw).next_to(y_axis.get_top(), RIGHT),\n",
        "        )\n",
        "\n",
        "        self.add(axes, axis_labels)\n",
        "\n",
        "        # Add circle\n",
        "        circle = Circle(radius=3)\n",
        "        circle.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "\n",
        "        # Set up lines\n",
        "        slope_tracker = ValueTracker(-4)\n",
        "        get_slope = slope_tracker.get_value\n",
        "        lines = self.get_lines(circle, get_slope())\n",
        "\n",
        "        state_point = Group(\n",
        "            TrueDot(radius=0.05).make_3d(),\n",
        "            GlowDot(radius=0.2),\n",
        "        )\n",
        "        state_point.set_color(RED)\n",
        "        state_point.move_to(circle.get_left())\n",
        "\n",
        "        self.play(FadeIn(state_point, shift=2 * DR, scale=0.25))\n",
        "        self.wait()\n",
        "\n",
        "        # Note the slope\n",
        "        slope_label = Tex(R\"\\text{Slope} = -4.0\", font_size=36)\n",
        "        slope_label.next_to(lines[0].get_center(), RIGHT)\n",
        "        slope_dec = slope_label.make_number_changeable(\"-4.0\")\n",
        "        count_label = Tex(R\"\\# \\text{Lines} = 1\", font_size=36)\n",
        "        count = count_label.make_number_changeable(\"1\")\n",
        "        count_label.to_corner(UL)\n",
        "        right_shift = (slope_dec.get_width() - count.get_width()) * RIGHT\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lines[0]),\n",
        "            state_point.animate.move_to(lines[0].get_end()),\n",
        "            FadeIn(slope_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            slope_label.animate.next_to(count_label, DOWN, aligned_edge=RIGHT).shift(right_shift),\n",
        "            VFadeIn(count_label),\n",
        "            ChangeDecimalToValue(count, 2),\n",
        "            ShowCreation(lines[1]),\n",
        "            state_point.animate.move_to(lines[1].get_end()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show remaining lines\n",
        "        for line in lines[2:]:\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                state_point.animate.move_to(line.get_end()),\n",
        "                ChangeDecimalToValue(count, count.get_value() + 1)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.add(lines)\n",
        "\n",
        "        # Show the end zone\n",
        "        endzone = self.get_end_zone(-1.0 / get_slope())\n",
        "        self.play(FadeIn(endzone))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask the question\n",
        "        count_rect = SurroundingRectangle(count_label)\n",
        "        count_rect.set_stroke(PINK, 3)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (line.animate.set_stroke(PINK, 5).set_anim_args(rate_func=there_and_back)\n",
        "                for line in lines),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=6\n",
        "            ),\n",
        "            ShowCreation(count_rect)\n",
        "        )\n",
        "\n",
        "        # Vary the slope\n",
        "        self.add(lines)\n",
        "        lines.f_always.set_submobjects(lambda: self.get_lines(circle, get_slope()))\n",
        "        count.f_always.set_value(lambda: len(lines))\n",
        "        slope_dec.f_always.set_value(get_slope)\n",
        "        endzone.f_always.become(lambda: self.get_end_zone(-1.0 / get_slope()))\n",
        "        updated_pieces = [lines, count, slope_dec, endzone]\n",
        "\n",
        "        slope_rect = SurroundingRectangle(slope_label)\n",
        "        slope_rect.add_updater(lambda m: m.set_width(\n",
        "            slope_label.get_width() + 2 * SMALL_BUFF,\n",
        "            stretch=True,\n",
        "            about_edge=LEFT\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(count_rect, slope_rect, suspend_mobject_updating=True),\n",
        "            FadeOut(state_point),\n",
        "        )\n",
        "        self.play(\n",
        "            slope_tracker.animate.set_value(-10),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=10\n",
        "        )\n",
        "        for piece in updated_pieces:\n",
        "            piece.suspend_updating()\n",
        "\n",
        "        # Show slope equation\n",
        "        rhs = Tex(R\"= -\\sqrt{m_1 / m_2}\", **kw)\n",
        "        rhs.scale(1.5)\n",
        "        rhs.next_to(slope_label, RIGHT)\n",
        "\n",
        "        mass_equations = VGroup(\n",
        "            Tex(R\"m_1 = 16\", **kw),\n",
        "            Tex(R\"m_2 = 1\", **kw),\n",
        "        )\n",
        "        mass_equations.scale(1.5)\n",
        "        mass_equations.arrange(DOWN, aligned_edge=LEFT)\n",
        "        mass_equations.next_to(slope_label, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(rhs),\n",
        "            FadeOut(slope_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs[\"m_1\"][0], mass_equations[0][\"m_1\"][0]),\n",
        "            TransformFromCopy(rhs[\"m_2\"][0], mass_equations[1][\"m_2\"][0]),\n",
        "            FadeIn(mass_equations[0][2:]),\n",
        "            FadeIn(mass_equations[1][2:]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(mass_equations)\n",
        "\n",
        "        # Increase slope\n",
        "        mass_tracker = ValueTracker(16)\n",
        "        get_mass_ratio = mass_tracker.get_value\n",
        "        m1_dec = mass_equations[0].make_number_changeable(\"16\")\n",
        "        m1_dec.add_updater(lambda m: m.set_value(get_mass_ratio()))\n",
        "\n",
        "        for piece in updated_pieces:\n",
        "            piece.resume_updating()\n",
        "\n",
        "        slope_tracker.add_updater(lambda m: m.set_value(-math.sqrt(int(get_mass_ratio()))))\n",
        "\n",
        "        self.add(slope_tracker)\n",
        "        self.play(\n",
        "            mass_tracker.animate.set_value(100),\n",
        "            rate_func=lambda t: there_and_back_with_pause(t, 0.1),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        for piece in updated_pieces:\n",
        "            piece.suspend_updating()\n",
        "\n",
        "        # Clear labels\n",
        "        self.play(FadeOut(mass_equations), FadeOut(rhs))\n",
        "\n",
        "        # Show arcs\n",
        "        points = np.array([line.get_start() for line in lines] + [lines[-1].get_end()])\n",
        "        dots = Group(state_point.copy().move_to(point) for point in points)\n",
        "        arcs = self.get_arcs(points, slope=get_slope())\n",
        "        for arc in arcs:\n",
        "            arc.save_state()\n",
        "            arc.scale(1.25, about_point=ORIGIN)\n",
        "            arc.set_stroke(width=10, opacity=0)\n",
        "\n",
        "        state_point.move_to(lines[0].get_start())\n",
        "        self.add(dots[0])\n",
        "        for line, dot in zip(lines, dots[1:]):\n",
        "            self.play(state_point.animate.move_to(dot), run_time=0.5)\n",
        "            self.add(dot)\n",
        "        self.add(dots)\n",
        "        self.play(FadeOut(state_point))\n",
        "\n",
        "        self.play(LaggedStartMap(Restore, arcs, lag_ratio=0.25, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Stack the arcs\n",
        "        theta = math.atan(-1.0 / get_slope())\n",
        "        stacked_arcs = VGroup(\n",
        "            arc.copy().rotate(PI - angle_of_vector(arc.pfp(0.5)))\n",
        "            for arc in arcs\n",
        "        )\n",
        "        stacked_arcs.arrange(RIGHT, buff=0.1)\n",
        "        stacked_arcs.to_corner(DL)\n",
        "\n",
        "        self.remove(circle)\n",
        "        self.play(\n",
        "            arcs.animate.set_stroke(opacity=0.25),\n",
        "            TransformFromCopy(arcs, stacked_arcs, lag_ratio=0.35, run_time=4),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                stacked_arcs,\n",
        "                arcs.copy().set_stroke(opacity=1),\n",
        "                remover=True,\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "            arcs.animate.set_stroke(opacity=1),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show just two lines\n",
        "        self.play(\n",
        "            lines[:3].animate.set_stroke(opacity=0.15),\n",
        "            lines[5:].animate.set_stroke(opacity=0.15),\n",
        "            arcs[:4].animate.set_stroke(opacity=0.15),\n",
        "            arcs[5:].animate.set_stroke(opacity=0.15),\n",
        "            FadeOut(dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Mark the 2*theta arc\n",
        "        lil_arc = Arc(-90 * DEG, theta, radius=1.5, arc_center=points[4])\n",
        "        theta_label = Tex(R\"\\theta\")\n",
        "        theta_label.next_to(lil_arc.pfp(0.5), DOWN, SMALL_BUFF)\n",
        "        new_lines = VGroup(\n",
        "            Line(points[3], ORIGIN),\n",
        "            Line(ORIGIN, points[5]),\n",
        "        )\n",
        "        new_lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        lil_two_arc = Arc(-PI + 4 * theta, 2 * theta, radius=1.0, arc_center=ORIGIN)\n",
        "        two_theta_label = Tex(R\"2\\theta\")\n",
        "        two_theta_label.next_to(lil_two_arc.pfp(0.9), DL, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lil_arc),\n",
        "            Write(theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[3:5], new_lines),\n",
        "            TransformFromCopy(lil_arc, lil_two_arc),\n",
        "            TransformFromCopy(theta_label, two_theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(lil_two_arc, arcs[4]),\n",
        "            two_theta_label.animate.next_to(arcs[4].pfp(0.5), DOWN, SMALL_BUFF),\n",
        "            new_lines.animate.set_stroke(WHITE, 1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the other lower arcs\n",
        "        theta_group = VGroup(lil_arc, theta_label)\n",
        "        for n in range(6, len(lines), 2):\n",
        "            self.play(\n",
        "                lines[n - 3:n - 1].animate.set_stroke(opacity=0.15),\n",
        "                lines[n - 1:n + 1].animate.set_stroke(opacity=1),\n",
        "                theta_group.animate.shift(points[n] - points[n - 2]),\n",
        "                Rotate(new_lines, 2 * theta, about_point=ORIGIN),\n",
        "                two_theta_label.animate.next_to(arcs[n].pfp(0.5), arcs[n].pfp(0.5), SMALL_BUFF),\n",
        "                arcs[n - 2].animate.set_stroke(opacity=0.25),\n",
        "                arcs[n].animate.set_stroke(opacity=1)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show the upper arcs as well\n",
        "        self.play(\n",
        "            theta_group.animate.rotate(PI, about_point=points[10]).shift(points[1] - points[10]).scale(0.75, about_point=points[1]),\n",
        "            Rotate(new_lines, -12 * theta, about_point=ORIGIN),\n",
        "            two_theta_label.animate.next_to(arcs[1].pfp(0.5), arcs[1].pfp(0.5), buff=0.05),\n",
        "            lines[9:11].animate.set_stroke(opacity=0.15),\n",
        "            lines[0:2].animate.set_stroke(opacity=1),\n",
        "            arcs[10].animate.set_stroke(opacity=0.15),\n",
        "            arcs[1].animate.set_stroke(opacity=1),\n",
        "            FadeOut(axis_labels),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for n in range(3, len(lines), 2):\n",
        "            self.play(\n",
        "                lines[n - 3:n - 1].animate.set_stroke(opacity=0.15),\n",
        "                lines[n - 1:n + 1].animate.set_stroke(opacity=1),\n",
        "                theta_group.animate.shift(points[n] - points[n - 2]),\n",
        "                Rotate(new_lines, -2 * theta, about_point=ORIGIN),\n",
        "                two_theta_label.animate.next_to(arcs[n].pfp(0.5), arcs[n].pfp(0.5), SMALL_BUFF),\n",
        "                arcs[n - 2].animate.set_stroke(opacity=0.25),\n",
        "                arcs[n].animate.set_stroke(opacity=1)\n",
        "            )\n",
        "            self.wait()\n",
        "        state_point.move_to(lines[0].get_start())\n",
        "        self.play(\n",
        "            FadeOut(two_theta_label),\n",
        "            FadeOut(new_lines),\n",
        "            FadeOut(theta_group),\n",
        "            arcs[-1].animate.set_stroke(opacity=0.15),\n",
        "            lines[-2:].animate.set_stroke(opacity=0.15),\n",
        "            FadeIn(state_point),\n",
        "        )\n",
        "\n",
        "        # Show the process of dropping arcs while bouncing along diagram\n",
        "        two_theta_labels = VGroup()\n",
        "        past_state_points = Group()\n",
        "        self.add(past_state_points)\n",
        "        for line, arc in zip(lines, arcs):\n",
        "            ghost_line = line.copy()\n",
        "            ghost_arc = arc.copy()\n",
        "            line.set_stroke(opacity=1)\n",
        "            arc.set_stroke(opacity=1)\n",
        "\n",
        "            two_theta_label = Tex(R\"2\\theta\", font_size=36)\n",
        "            two_theta_label.next_to(arc.pfp(0.5), arc.pfp(0.5), buff=0.05)\n",
        "            two_theta_labels.add(two_theta_label)\n",
        "\n",
        "            arc.save_state()\n",
        "            arc.scale(1.25, about_point=ORIGIN)\n",
        "            arc.set_stroke(width=12, opacity=0)\n",
        "\n",
        "            past_state_points.add(state_point.copy())\n",
        "            self.play(\n",
        "                Animation(ghost_line, remover=True),\n",
        "                Animation(ghost_arc, remover=True),\n",
        "                ShowCreation(line),\n",
        "                state_point.animate.move_to(line.get_end()),\n",
        "                Restore(arc),\n",
        "                FadeIn(two_theta_label, arc.saved_state.pfp(0.5) - arc.pfp(0.5)),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize endzone line\n",
        "        max_x = 8\n",
        "        endzone_line = Line(ORIGIN, max_x * RIGHT + max_x * -1.0 / get_slope() * UP)\n",
        "        full_screen_rect = FullScreenFadeRectangle()\n",
        "        full_screen_rect.set_fill(BLACK, 0.8)\n",
        "        bold_lines = lines[0::2].copy()\n",
        "\n",
        "        self.add(full_screen_rect, bold_lines)\n",
        "        self.play(\n",
        "            FadeIn(full_screen_rect),\n",
        "            ShowCreation(endzone_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(full_screen_rect),\n",
        "            FadeOut(bold_lines),\n",
        "            FadeOut(endzone_line),\n",
        "        )\n",
        "\n",
        "        # Show end zone condition\n",
        "        wedge = arcs[-1].copy()\n",
        "        wedge.add_line_to(ORIGIN)\n",
        "        wedge.add_line_to(arcs[-1].get_start())\n",
        "        wedge.set_fill(PINK, 0.5)\n",
        "        wedge.set_stroke(width=0)\n",
        "        wedge.add(arcs[-1].copy().set_stroke(PINK))\n",
        "\n",
        "        self.play(FadeIn(wedge))\n",
        "        for angle in [-2 * theta, 10 * DEG, -10 * DEG, 5 * DEG, -5 * DEG]:\n",
        "            self.play(Rotate(wedge, angle, about_point=ORIGIN))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(FadeOut(wedge))\n",
        "\n",
        "        # Bring back the mass ratio labels\n",
        "        slope_label_rect = SurroundingRectangle(slope_label)\n",
        "        slope_label_rect.set_stroke(YELLOW, 2)\n",
        "        self.play(\n",
        "            FadeIn(circle),\n",
        "            FadeOut(two_theta_labels, lag_ratio=0.1),\n",
        "            FadeOut(arcs, lag_ratio=0.1),\n",
        "            FadeOut(past_state_points, lag_ratio=0.1),\n",
        "            FadeOut(state_point),\n",
        "        )\n",
        "        self.play(ShowCreation(slope_label_rect))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rhs),\n",
        "            FadeIn(mass_equations),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            slope_label_rect.animate.surround(mass_equations).stretch(1.2, 0, about_edge=LEFT),\n",
        "        )\n",
        "\n",
        "        # Scale back up to 100\n",
        "        self.add(lines)\n",
        "        for piece in updated_pieces:\n",
        "            piece.resume_updating()\n",
        "        self.play(\n",
        "            mass_tracker.animate.set_value(100),\n",
        "            rhs.animate.shift(0.1 * RIGHT),\n",
        "            run_time=5,\n",
        "        )\n",
        "        for piece in updated_pieces:\n",
        "            piece.suspend_updating()\n",
        "\n",
        "        # Make room\n",
        "        frame = self.frame\n",
        "        shift_value = 2.25 * LEFT\n",
        "        line_index = 13\n",
        "\n",
        "        movers = VGroup(count_label, slope_label, rhs, mass_equations)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(slope_label_rect, shift=shift_value),\n",
        "            lines[:line_index + 1].animate.set_stroke(opacity=0.1),\n",
        "            lines[line_index + 2:].animate.set_stroke(opacity=0.1),\n",
        "            frame.animate.shift(shift_value),\n",
        "            movers.animate.shift(shift_value),\n",
        "        )\n",
        "\n",
        "        # Show the slope\n",
        "        dy_line = lines[line_index].copy().rotate(PI)\n",
        "        dy_line.set_stroke(PINK, 3, 1)\n",
        "        dx_line = Line(\n",
        "            dy_line.get_end(),\n",
        "            find_intersection(\n",
        "                dy_line.get_end(),\n",
        "                RIGHT,\n",
        "                lines[line_index + 1].get_start(),\n",
        "                lines[line_index + 1].get_vector(),\n",
        "            )\n",
        "        )\n",
        "        dx_line.set_stroke(RED, 5)\n",
        "\n",
        "        dy_label = Tex(R\"\\Delta y\", font_size=36).match_color(dy_line)\n",
        "        dx_label = Tex(R\"\\Delta x\", font_size=36).match_color(dx_line)\n",
        "        dy_label.next_to(dy_line, LEFT, SMALL_BUFF).shift(0.25 * DOWN)\n",
        "        dx_label.next_to(dx_line, UP, SMALL_BUFF)\n",
        "\n",
        "        slope_tex_kw = dict(\n",
        "            t2c={\n",
        "                R\"\\Delta y\": PINK,\n",
        "                R\"\\Delta x\": RED,\n",
        "            },\n",
        "            font_size=36\n",
        "        )\n",
        "        new_slope_eq = Tex(R\"\\text{Slope} = {\\Delta y \\over \\Delta x}\", **slope_tex_kw)\n",
        "        new_slope_eq.next_to(slope_label, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(new_slope_eq, DOWN),\n",
        "            mass_equations.animate.to_edge(DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dy_line),\n",
        "            TransformFromCopy(new_slope_eq[R\"\\Delta y\"][0], dy_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dx_line),\n",
        "            TransformFromCopy(new_slope_eq[R\"\\Delta x\"][0], dx_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the angle\n",
        "        theta = math.atan(-1 / get_slope())\n",
        "        point = dy_line.get_start()\n",
        "        arc = Arc(-90 * DEG, theta, radius=2.25, arc_center=point)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=36)\n",
        "        theta_label.next_to(arc, DOWN, SMALL_BUFF)\n",
        "\n",
        "        tan_eq = Tex(R\"\\tan(\\theta) = {\\Delta x \\over -\\Delta y}\", **slope_tex_kw)\n",
        "        tan_eq.next_to(new_slope_eq, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_label),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(theta_label, tan_eq[R\"\\theta\"]),\n",
        "            Write(tan_eq[R\"\\tan(\"]),\n",
        "            Write(tan_eq[R\") = \"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(dx_label, tan_eq[R\"\\Delta x\"][0]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(dy_label, tan_eq[R\"\\Delta y\"][0]),\n",
        "            Write(tan_eq[R\"\\over\"]),\n",
        "            Write(tan_eq[R\"-\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Relate tangent to slope\n",
        "        kw[\"font_size\"] = 36\n",
        "        new_rhs = Tex(R\"= \\sqrt{m_2 / m_1}\", **kw)\n",
        "        new_rhs.next_to(tan_eq, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        new_rhs_brace = Brace(new_rhs[1:], UP, SMALL_BUFF)\n",
        "        ratio_example = new_rhs_brace.get_text(\"0.1\", buff=SMALL_BUFF, font_size=36)\n",
        "\n",
        "        arctan_eq = Tex(R\"\\theta = \\arctan\\left(\\sqrt{m_2 / m_1}\\right)\", **kw)\n",
        "        arctan_eq.next_to(tan_eq, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        example_arctan = Tex(R\"\\theta = \\arctan(0.1)\", font_size=36)\n",
        "        example_arctan.next_to(arctan_eq, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        example_arctan_rect = SurroundingRectangle(example_arctan)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(new_slope_eq[R\"\\Delta y\"], tan_eq[R\"\\Delta y\"], path_arc=-90 * DEG),\n",
        "                TransformFromCopy(new_slope_eq[R\"\\Delta x\"], tan_eq[R\"\\Delta x\"], path_arc=-90 * DEG),\n",
        "                run_time=2\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                rhs.copy(),\n",
        "                new_rhs,\n",
        "                path_arc=-90 * DEG,\n",
        "                run_time=2,\n",
        "                lag_ratio=0.01,\n",
        "                matched_keys=[\"m_1\", \"m_2\", R\"\\sqrt\"],\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(new_rhs_brace),\n",
        "            TransformFromCopy(mass_equations.copy().clear_updaters(), ratio_example),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(tan_eq[R\"\\tan\"], arctan_eq[R\"\\arctan\"]),\n",
        "            TransformFromCopy(tan_eq[R\"(\"], arctan_eq[R\"\\left(\"]),\n",
        "            TransformFromCopy(tan_eq[R\")\"], arctan_eq[R\"\\right)\"]),\n",
        "            TransformFromCopy(tan_eq[R\"\\theta\"], arctan_eq[R\"\\theta\"]),\n",
        "            TransformFromCopy(tan_eq[R\"=\"], arctan_eq[R\"=\"]),\n",
        "            TransformFromCopy(new_rhs[R\"\\sqrt{m_2 / m_1}\"], arctan_eq[R\"\\sqrt{m_2 / m_1}\"]),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(example_arctan, DOWN))\n",
        "        self.play(ShowCreation(example_arctan_rect))\n",
        "        self.wait()\n",
        "\n",
        "    def get_lines(self, circle, slope, stroke_color=WHITE, stroke_width=2):\n",
        "        theta = math.atan(-1.0 / slope)\n",
        "        radius = 0.5 * circle.get_width()\n",
        "\n",
        "        top_point = circle.get_left()\n",
        "        low_point = rotate_vector(top_point, 2 * theta)\n",
        "\n",
        "        result = VGroup()\n",
        "\n",
        "        while True:\n",
        "            if math.atan2(top_point[1], top_point[0]) < theta:\n",
        "                # In the end zone\n",
        "                break\n",
        "            result.add(Line(top_point, low_point))\n",
        "            top_point = rotate_vector(top_point, -2 * theta)\n",
        "            if top_point[1] < 0:\n",
        "                break\n",
        "            result.add(Line(low_point, top_point))\n",
        "            low_point = rotate_vector(low_point, 2 * theta)\n",
        "\n",
        "        result.set_stroke(stroke_color, stroke_width)\n",
        "        return result\n",
        "\n",
        "    def get_end_zone(self, slope, max_x=8, color=GREEN, opacity=0.25):\n",
        "        zone = Polygon(\n",
        "            max_x * RIGHT + slope * max_x * UP,\n",
        "            ORIGIN, \n",
        "            max_x * RIGHT\n",
        "        )\n",
        "        zone.set_stroke(color, 0)\n",
        "        zone.set_fill(color, opacity)\n",
        "        label = Text(\"End Zone\", font_size=36)\n",
        "        label.set_color(color)\n",
        "        label.next_to(zone.get_bottom(), UP, SMALL_BUFF)\n",
        "        label.to_edge(RIGHT, buff=0.5)\n",
        "\n",
        "        return VGroup(zone, label)\n",
        "\n",
        "    def get_arcs(self, points, slope):\n",
        "        # Test\n",
        "        theta = math.atan(-1.0 / slope)\n",
        "        arcs = VGroup()\n",
        "        for i in range(-1, len(points) - 2):\n",
        "            arc = Line(\n",
        "                points[max(i, 0)],\n",
        "                points[i + 2],\n",
        "                path_arc=-2 * theta * (-1)**(i % 2)\n",
        "            )\n",
        "            color = [BLUE, BLUE, RED, RED][i % 4]\n",
        "            arc.set_stroke(color, width=4)\n",
        "            arcs.add(arc)\n",
        "\n",
        "        return arcs\n"
    ]
}