{
    "topic": "The mathematical concept being demonstrated is the relationship between pi and tau, specifically how they are related through",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from script_wrapper import command_line_create_scene\n",
        "from .generate_logo import LogoGeneration\n",
        "\n",
        "POEM_LINES = \"\"\"Fixed poorly in notation with that two,\n",
        "you shine so loud that you deserve a name.\n",
        "Late though we are to make a change, it's true,\n",
        "We can extol you 'til you have pi's fame.\n",
        "One might object, ``Conventions matter not!\n",
        "Great formulae cast truths transcending names.''\n",
        "I've noticed, though, how language molds my thoughts;\n",
        "the natural terms make heart and head the same.\n",
        "So lose the two inside your autograph,\n",
        "then guide our thoughts without your ``better'' half.\n",
        "Wonders math imparts become so neat\n",
        "when phrased with you, and pi remains off-screen.\n",
        "Sine and exp both cycle to your beat.\n",
        "Jive with Fourier, and forms are clean.\n",
        "``Wait! Area of circles'', pi would say,\n",
        "``sticks oddly to one half when tau's preferred.''\n",
        "More to you then!  For write it in this way,\n",
        "then links to triangles can be inferred.\n",
        "Nix pi, then all within geometry\n",
        "shines clean and clear, as if by poetry.\"\"\".split(\"\\n\")\n",
        "\n",
        "DIGIT_TO_WORD = {\n",
        "    '0' : \"Zero\",\n",
        "    '1' : \"One\",\n",
        "    '2' : \"Two\",\n",
        "    '3' : \"Three\",\n",
        "    '4' : \"Four\",\n",
        "    '5' : \"Five\",\n",
        "    '6' : \"Six\",\n",
        "    '7' : \"Seven\",\n",
        "    '8' : \"Eight\",\n",
        "    '9' : \"Nine\",\n",
        "}\n",
        "\n",
        "FORMULAE = [\n",
        "    \"e^{x + \\\\tau i} = e^{x}\",\n",
        "    \"&\\\\Leftrightarrow\",\n",
        "    \"e^{x + 2\\\\pi i} = e^{x} \\\\\\\\\",\n",
        "    \"A = \\\\frac{1}{2} \\\\tau r^2\",\n",
        "    \"&\\\\Leftrightarrow\",\n",
        "    \"A = \\\\pi r^2 \\\\\\\\\",\n",
        "    \"n! \\\\sim \\\\sqrt{\\\\tau n}\\\\left(\\\\frac{n}{e}\\\\right)^n\",\n",
        "    \"&\\\\Leftrightarrow\",\n",
        "    \"n! \\\\sim \\\\sqrt{2\\\\pi n}\\\\left(\\\\frac{n}{e}\\\\right)^n \\\\\\\\\",\n",
        "    # \"\\\\sum_{n = 0}^\\\\infty \\\\frac{(-1)^n}{2n+1} = \\\\frac{\\\\tau}{8}\",\n",
        "    # \"&\\\\Leftrightarrow\",\n",
        "    # \"\\\\sum_{n = 0}^\\\\infty \\\\frac{(-1)^n}{2n+1} = \\\\frac{\\\\pi}{4} \\\\\\\\\",\n",
        "]\n",
        "\n",
        "DIGITS = list(map(str, list(\"62831853071795864769\")))\n",
        "DIGITS[1] = \".\" + DIGITS[1] #2->.2\n",
        "\n",
        "BUFF = 1.0\n",
        "\n",
        "MOVIE_PREFIX = \"tau_poem/\"\n",
        "\n",
        "class Welcome(LogoGeneration):\n",
        "    def construct(self):\n",
        "        text = \"Happy $\\\\tau$ Day, from 3Blue1Brown!\"\n",
        "        self.add(OldTexText(text).to_edge(UP))\n",
        "        LogoGeneration.construct(self)\n",
        "\n",
        "class HappyTauDayWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Happy Tau Day Everybody!\").scale(2)\n",
        "        tau = TauCreature().move_to(2*LEFT + UP)\n",
        "        pi = PiCreature().move_to(2*RIGHT + 3*DOWN)\n",
        "        pi.set_color(\"red\")\n",
        "        self.add(words, tau, pi)\n",
        "        self.wait()\n",
        "        self.play(BlinkPiCreature(tau))\n",
        "        self.play(BlinkPiCreature(pi))\n",
        "\n",
        "class TauPoem(Scene):\n",
        "    args_list = [(x,) for x in range(len(POEM_LINES))]\n",
        "    @staticmethod\n",
        "    def args_to_string(line_num, *ignore):\n",
        "        return str(line_num)\n",
        "\n",
        "    def __init__(self, line_num, *args, **kwargs):\n",
        "        self.line_num = line_num\n",
        "        self.anim_kwargs = {\n",
        "            \"run_time\" : 4.0,\n",
        "        }\n",
        "        self.line_num_to_method = {\n",
        "            0  : self.line0,\n",
        "            1  : self.line1,\n",
        "            2  : self.line2,\n",
        "            3  : self.line3,\n",
        "            4  : self.line4,\n",
        "            5  : self.line5,\n",
        "            6  : self.line6,\n",
        "            7  : self.line7,\n",
        "            8  : self.line8,\n",
        "            9  : self.line9,\n",
        "            10 : self.line10,\n",
        "            11 : self.line11,\n",
        "            12 : self.line12,\n",
        "            13 : self.line13,\n",
        "            14 : self.line14,\n",
        "            15 : self.line15,\n",
        "            16 : self.line16,\n",
        "            17 : self.line17,\n",
        "            18 : self.line18,\n",
        "            19 : self.line19,\n",
        "        }\n",
        "        Scene.__init__(self, *args, **kwargs)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_line_and_number()\n",
        "        self.line_num_to_method[self.line_num]()\n",
        "        self.first_word_to_last_digit()\n",
        "\n",
        "    def add_line_and_number(self):\n",
        "        self.first_digits, new_digit, last_digits = OldTex([\n",
        "            \"\".join(DIGITS[:self.line_num]),\n",
        "            DIGITS[self.line_num],\n",
        "            \"\".join(DIGITS[(self.line_num+1):]),\n",
        "        ]).to_edge(UP, buff=0.2).split()\n",
        "        line_str = POEM_LINES[self.line_num]\n",
        "        if self.line_num == 0:\n",
        "            index = line_str.index(\"ed \")\n",
        "        elif self.line_num == 10:\n",
        "            index = line_str.index(\"ders\")\n",
        "        else:\n",
        "            index = line_str.index(\" \")\n",
        "        first_word, rest_of_line = OldTexText(\n",
        "            [line_str[:index], line_str[index:]]\n",
        "        ).to_edge(UP).shift(BUFF*DOWN).split()\n",
        "        first_word.shift(0.15*RIGHT) #Stupid\n",
        "        number_word = OldTexText(DIGIT_TO_WORD[DIGITS[self.line_num][-1]])\n",
        "        number_word.shift(first_word.get_center())\n",
        "        number_word.shift(BUFF * UP / 2)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : squish_rate_func(smooth),\n",
        "        }\n",
        "        self.add(first_word, rest_of_line, self.first_digits)\n",
        "        self.first_word  = first_word\n",
        "        self.number_word = number_word\n",
        "        self.new_digit   = new_digit\n",
        "\n",
        "    def first_word_to_last_digit(self):\n",
        "        if self.line_num == 19:\n",
        "            shift_val = FRAME_Y_RADIUS*DOWN\n",
        "            self.new_digit.shift(shift_val)\n",
        "            self.play(ApplyMethod(\n",
        "                self.first_digits.shift, shift_val, run_time = 2.0\n",
        "            ))\n",
        "            self.wait(2)\n",
        "        self.play_over_time_range(0, 2,\n",
        "            Transform(\n",
        "                deepcopy(self.first_word), self.number_word,\n",
        "                rate_func = squish_rate_func(smooth)\n",
        "            )\n",
        "        )\n",
        "        self.play_over_time_range(2, 4,\n",
        "            Transform(\n",
        "                self.number_word, self.new_digit,\n",
        "                rate_func = squish_rate_func(smooth)                \n",
        "            )\n",
        "        )\n",
        "\n",
        "    def line0(self):\n",
        "        two, pi = OldTex([\"2\", \"\\\\pi\"]).scale(2).split()\n",
        "        self.add(two, pi)\n",
        "        two_copy = deepcopy(two).rotate(np.pi/10).set_color(\"yellow\")\n",
        "        self.play(Transform(\n",
        "            two, two_copy,\n",
        "            rate_func = squish_rate_func(\n",
        "                lambda t : wiggle(t),\n",
        "                0.4, 0.9,\n",
        "            ),\n",
        "            **self.anim_kwargs\n",
        "        ))\n",
        "\n",
        "    def line1(self):\n",
        "        two_pi = OldTex([\"2\", \"\\\\pi\"]).scale(2)\n",
        "        tau = TauCreature()\n",
        "        tau.to_symbol()\n",
        "        sphere = Mobject()\n",
        "        sphere.interpolate(\n",
        "            two_pi, \n",
        "            Sphere().set_color(\"yellow\"),\n",
        "            0.8\n",
        "        )\n",
        "        self.add(two_pi)\n",
        "        self.wait()\n",
        "        self.play(CounterclockwiseTransform(\n",
        "            two_pi, sphere,\n",
        "            rate_func = lambda t : 2*smooth(t/2)\n",
        "        ))\n",
        "        self.remove(two_pi)\n",
        "        self.play(CounterclockwiseTransform(\n",
        "            sphere, tau,\n",
        "            rate_func = lambda t : 2*(smooth(t/2+0.5)-0.5)\n",
        "        ))\n",
        "        self.remove(sphere)\n",
        "        self.add(tau)\n",
        "        self.wait()\n",
        "\n",
        "    def line2(self):\n",
        "        tau = TauCreature()\n",
        "        tau.make_sad()\n",
        "        tau.mouth.points = np.array(sorted(\n",
        "            tau.mouth.points, \n",
        "            lambda p0, p1 : cmp(p0[0], p1[0])\n",
        "        ))\n",
        "        blinked = deepcopy(tau).blink()\n",
        "        for eye in blinked.eyes:\n",
        "            eye.set_color(\"black\")\n",
        "        self.add(*set(tau.parts).difference(tau.white_parts))\n",
        "        self.play(*[\n",
        "            Transform(*eyes)\n",
        "            for eyes in zip(blinked.eyes, tau.eyes)\n",
        "        ])\n",
        "        self.play(ShowCreation(tau.mouth))\n",
        "        self.wait(2)\n",
        "\n",
        "    def line3(self):\n",
        "        tau = TauCreature().make_sad()\n",
        "        pi = PiCreature()\n",
        "        self.add(*tau.parts)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(tau.leg, pi.left_leg),\n",
        "            ShowCreation(pi.right_leg),\n",
        "            run_time = 1.0,\n",
        "        )\n",
        "        self.play(*[\n",
        "            Transform(*parts)\n",
        "            for parts in zip(tau.white_parts, pi.white_parts)\n",
        "        ])\n",
        "        self.remove(*tau.parts + pi.parts)\n",
        "        self.play(BlinkPiCreature(pi))\n",
        "\n",
        "    def pi_speaking(self, text):\n",
        "        pi = PiCreature()\n",
        "        pi.set_color(\"red\").give_straight_face()\n",
        "        pi.shift(3*DOWN + LEFT)\n",
        "        bubble = SpeechBubble().speak_from(pi)\n",
        "        bubble.write(text)\n",
        "        return pi, bubble\n",
        "\n",
        "    def line4(self):\n",
        "        pi, bubble = self.pi_speaking(\"Conventions matter \\\\\\\\ not!\")\n",
        "        self.add(pi)\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            Point(bubble.tip).set_color(\"black\"),\n",
        "            bubble\n",
        "        ))\n",
        "\n",
        "\n",
        "    def line5(self):\n",
        "        pi, bubble = self.pi_speaking(\"\"\"\n",
        "            Great formulae cast \\\\\\\\ \n",
        "            truths transcending \\\\\\\\\n",
        "            names.\n",
        "        \"\"\")\n",
        "        self.add(pi, bubble)\n",
        "\n",
        "        formulae = OldTex(FORMULAE, size = \"\\\\small\")\n",
        "        formulae.scale(1.25)\n",
        "        formulae.to_corner([1, -1, 0])\n",
        "        self.play(FadeIn(formulae))\n",
        "\n",
        "    def line6(self):\n",
        "        bubble = ThoughtBubble()\n",
        "        self.play(ApplyFunction(\n",
        "            lambda p : 2 * p /  get_norm(p),\n",
        "            bubble,\n",
        "            rate_func = wiggle,\n",
        "            run_time = 3.0,\n",
        "        ))\n",
        "\n",
        "    def line7(self):\n",
        "        bubble = ThoughtBubble()\n",
        "        heart = ImageMobject(\"heart\")\n",
        "        heart.scale(0.5).shift(DOWN).set_color(\"red\")\n",
        "        for mob in bubble, heart:\n",
        "            mob.sort_points(get_norm)\n",
        "\n",
        "        self.add(bubble)\n",
        "        self.wait()\n",
        "        self.remove(bubble)\n",
        "        bubble_copy = deepcopy(bubble)\n",
        "        self.play(CounterclockwiseTransform(bubble_copy, heart))\n",
        "        self.wait()\n",
        "        self.remove(bubble_copy)\n",
        "        self.play(CounterclockwiseTransform(heart, bubble))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def line8(self):\n",
        "        pi = PiCreature().give_straight_face()\n",
        "        tau = TauCreature()\n",
        "        two = ImageMobject(\"big2\").scale(0.5).shift(1.6*LEFT + 0.1*DOWN)\n",
        "\n",
        "        self.add(two, *pi.parts)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(pi.left_leg, tau.leg),\n",
        "            Transform(\n",
        "                pi.right_leg, \n",
        "                Point(pi.right_leg.get_points()[0,:]).set_color(\"black\")\n",
        "            ),\n",
        "            Transform(pi.mouth, tau.mouth),\n",
        "            CounterclockwiseTransform(\n",
        "                two, \n",
        "                Dot(two.get_center()).set_color(\"black\")\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def line9(self):\n",
        "        tau = TauCreature()\n",
        "        pi = PiCreature().set_color(\"red\").give_straight_face()\n",
        "        pi.scale(0.2).move_to(tau.arm.get_points()[-1,:])\n",
        "        point = Point(pi.get_center()).set_color(\"black\")\n",
        "        vanish_local = 3*(LEFT + UP)\n",
        "        new_pi = deepcopy(pi)\n",
        "        new_pi.scale(0.01)\n",
        "        new_pi.rotate(np.pi)\n",
        "        new_pi.shift(vanish_local)\n",
        "        Mobject.set_color(new_pi, \"black\")\n",
        "\n",
        "        self.add(tau)\n",
        "        self.wait()\n",
        "        self.play(Transform(point, pi))\n",
        "        self.remove(point)\n",
        "        self.add(pi)\n",
        "        self.play(WaveArm(tau),Transform(pi, new_pi))\n",
        "\n",
        "    def line10(self):\n",
        "        formulae = OldTex(FORMULAE, \"\\\\small\")\n",
        "        formulae.scale(1.5).to_edge(DOWN)\n",
        "        self.add(formulae)\n",
        "\n",
        "    def line11(self):\n",
        "        formulae = OldTex(FORMULAE, \"\\\\small\")\n",
        "        formulae.scale(1.5).to_edge(DOWN)\n",
        "        formulae = formulae.split()\n",
        "        f_copy = deepcopy(formulae)\n",
        "        for mob, count in zip(f_copy, it.count()):\n",
        "            if count%3 == 0:\n",
        "                mob.to_edge(LEFT).shift(RIGHT*(FRAME_X_RADIUS-1))\n",
        "            else:\n",
        "                mob.shift(FRAME_WIDTH*RIGHT)\n",
        "        self.play(*[\n",
        "            Transform(*mobs, run_time = 2.0)\n",
        "            for mobs in zip(formulae, f_copy)\n",
        "        ])\n",
        "\n",
        "    def line12(self):\n",
        "        interval_size = 0.5\n",
        "        axes_center = FRAME_X_RADIUS*LEFT/2\n",
        "        grid_center = FRAME_X_RADIUS*RIGHT/2\n",
        "        radius = FRAME_X_RADIUS / 2.0\n",
        "        axes = Axes(\n",
        "            radius = radius,\n",
        "            interval_size = interval_size\n",
        "        )\n",
        "        axes.shift(axes_center)\n",
        "        def sine_curve(t):\n",
        "            t += 1\n",
        "            result = np.array((-np.pi*t, np.sin(np.pi*t), 0))\n",
        "            result *= interval_size\n",
        "            result += axes_center\n",
        "            return result\n",
        "        sine = ParametricCurve(sine_curve)\n",
        "        sine_period = Line(\n",
        "            axes_center,\n",
        "            axes_center + 2*np.pi*interval_size*RIGHT\n",
        "        )\n",
        "        grid = Grid(radius = radius).shift(grid_center)\n",
        "        circle = Circle().scale(interval_size).shift(grid_center)\n",
        "        grid.add(OldTex(\"e^{ix}\").shift(grid_center+UP+RIGHT))\n",
        "        circle.set_color(\"white\")\n",
        "        tau_line = Line(\n",
        "            *[np.pi*interval_size*vect for vect in (LEFT, RIGHT)],\n",
        "            density = 5*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        tau_line.set_color(\"red\")\n",
        "        tau = OldTex(\"\\\\tau\")\n",
        "        tau.shift(tau_line.get_center() + 0.5*UP)\n",
        "\n",
        "        self.add(axes, grid)\n",
        "        self.play(\n",
        "            TransformAnimations(\n",
        "                ShowCreation(sine),\n",
        "                ShowCreation(deepcopy(sine).shift(2*np.pi*interval_size*RIGHT)),\n",
        "                run_time = 2.0,\n",
        "                rate_func = smooth\n",
        "            ),\n",
        "            ShowCreation(circle)\n",
        "        )\n",
        "        self.play(\n",
        "            CounterclockwiseTransform(sine_period, tau_line),\n",
        "            CounterclockwiseTransform(circle, deepcopy(tau_line)),\n",
        "            FadeOut(axes),\n",
        "            FadeOut(grid),\n",
        "            FadeOut(sine),\n",
        "            FadeIn(tau),            \n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def line13(self):\n",
        "        formula = form_start, two_pi, form_end = OldTex([\n",
        "            \"\\\\hat{f^{(n)}}(\\\\xi) = (\",\n",
        "            \"2\\\\pi\",\n",
        "            \"i\\\\xi)^n \\\\hat{f}(\\\\xi)\"\n",
        "        ]).shift(DOWN).split()\n",
        "        tau = TauCreature().center()\n",
        "        tau.scale(two_pi.get_width()/tau.get_width())\n",
        "        tau.shift(two_pi.get_center()+0.2*UP)\n",
        "        tau.rewire_part_attributes()\n",
        "\n",
        "        self.add(*formula)\n",
        "        self.wait()\n",
        "        self.play(CounterclockwiseTransform(two_pi, tau))\n",
        "        self.remove(two_pi)\n",
        "        self.play(BlinkPiCreature(tau))\n",
        "        self.wait()\n",
        "\n",
        "    def line14(self):\n",
        "        pi, bubble = self.pi_speaking(\n",
        "            \"Wait! Area \\\\\\\\ of circles\"\n",
        "        )\n",
        "        self.add(pi)\n",
        "        self.play(\n",
        "            Transform(Point(bubble.tip).set_color(\"black\"), bubble)\n",
        "        )\n",
        "\n",
        "    def line15(self):\n",
        "        pi, bubble = self.pi_speaking(\n",
        "            \"sticks oddly \\\\\\\\ to one half when \\\\\\\\ tau's preferred.\"\n",
        "        )\n",
        "        formula = form_start, half, form_end = OldTex([\n",
        "            \"A = \",\n",
        "            \"\\\\frac{1}{2}\",\n",
        "            \"\\\\tau r^2\"\n",
        "        ]).split()\n",
        "\n",
        "        self.add(pi, bubble, *formula)\n",
        "        self.wait(2)\n",
        "        self.play(ApplyMethod(half.set_color, \"yellow\"))\n",
        "\n",
        "    def line16(self):\n",
        "        self.add(OldTex(\n",
        "            \"\\\\frac{1}{2}\\\\tau r^2\"\n",
        "        ).scale(2).shift(DOWN))\n",
        "\n",
        "    def line17(self):\n",
        "        circle = Dot(\n",
        "            radius = 1, \n",
        "            density = 4*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        blue_rgb = np.array(Color(\"blue\").get_rgb())\n",
        "        white_rgb = np.ones(3)\n",
        "        circle.rgbas = np.array([\n",
        "            alpha * blue_rgb + (1 - alpha) * white_rgb\n",
        "            for alpha in np.arange(0, 1, 1.0/len(circle.rgbas))\n",
        "        ])\n",
        "        for index in range(circle.points.shape[0]):\n",
        "            circle.rgbas\n",
        "        def trianglify(xxx_todo_changeme):\n",
        "            (x, y, z) = xxx_todo_changeme\n",
        "            norm = get_norm((x, y, z))\n",
        "            comp = complex(x, y)*complex(0, 1)\n",
        "            return (\n",
        "                norm * np.log(comp).imag,\n",
        "                -norm,\n",
        "                0\n",
        "            )\n",
        "        tau_r = OldTex(\"\\\\tau r\").shift(1.3*DOWN)\n",
        "        r = OldTex(\"r\").shift(0.2*RIGHT + 0.7*DOWN)\n",
        "        lines = [\n",
        "            Line(DOWN+np.pi*LEFT, DOWN+np.pi*RIGHT),\n",
        "            Line(ORIGIN, DOWN)\n",
        "        ]\n",
        "        for line in lines:\n",
        "            line.set_color(\"red\")\n",
        "\n",
        "        self.play(ApplyFunction(trianglify, circle, run_time = 2.0))\n",
        "        self.add(tau_r, r)\n",
        "        self.play(*[\n",
        "            ShowCreation(line, run_time = 1.0)\n",
        "            for line in lines\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def line18(self):\n",
        "        tau = TauCreature()\n",
        "        tau.shift_eyes()\n",
        "        tau.move_to(DOWN)\n",
        "        pi = PiCreature()\n",
        "        pi.set_color(\"red\")\n",
        "        pi.move_to(DOWN + 3*LEFT)\n",
        "        mad_tau = deepcopy(tau).make_mean()\n",
        "        mad_tau.arm.wag(0.5*UP, LEFT, 2.0)\n",
        "        sad_pi  = deepcopy(pi).shift_eyes().make_sad()\n",
        "        blinked_tau = deepcopy(tau).blink()\n",
        "        blinked_pi  = deepcopy(pi).blink()\n",
        "\n",
        "        self.add(*pi.parts + tau.parts)\n",
        "        self.wait(0.8)\n",
        "        self.play(*[\n",
        "            Transform(*eyes, run_time = 0.2, rate_func = rush_into)\n",
        "            for eyes in [\n",
        "                (tau.left_eye, blinked_tau.left_eye),\n",
        "                (tau.right_eye, blinked_tau.right_eye),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(tau.left_eye, tau.right_eye)\n",
        "        self.play(*[\n",
        "            Transform(*eyes, run_time = 0.2, rate_func = rush_from)\n",
        "            for eyes in [\n",
        "                (blinked_tau.left_eye, mad_tau.left_eye),\n",
        "                (blinked_tau.right_eye, mad_tau.right_eye),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(blinked_tau.left_eye, blinked_tau.right_eye)\n",
        "        self.add(mad_tau.left_eye, mad_tau.right_eye)\n",
        "        self.play(\n",
        "            Transform(tau.arm, mad_tau.arm),\n",
        "            Transform(tau.mouth, mad_tau.mouth),\n",
        "            run_time = 0.5\n",
        "        )\n",
        "        self.remove(*tau.parts + blinked_tau.parts)\n",
        "        self.add(*mad_tau.parts)\n",
        "\n",
        "        self.play(*[\n",
        "            Transform(*eyes, run_time = 0.2, rate_func = rush_into)\n",
        "            for eyes in [\n",
        "                (pi.left_eye, blinked_pi.left_eye),\n",
        "                (pi.right_eye, blinked_pi.right_eye),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(pi.left_eye, pi.right_eye)\n",
        "        self.play(*[\n",
        "            Transform(*eyes, run_time = 0.2, rate_func = rush_from)\n",
        "            for eyes in [\n",
        "                (blinked_pi.left_eye, sad_pi.left_eye),\n",
        "                (blinked_pi.right_eye, sad_pi.right_eye),\n",
        "            ]\n",
        "        ] + [\n",
        "            Transform(pi.mouth, sad_pi.mouth, run_time = 0.2)\n",
        "        ])\n",
        "        self.remove(*blinked_pi.parts + pi.parts + sad_pi.parts)\n",
        "        self.play(\n",
        "            WalkPiCreature(sad_pi, DOWN+4*LEFT),\n",
        "            run_time = 1.0\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def line19(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    command_line_create_scene(MOVIE_PREFIX)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}