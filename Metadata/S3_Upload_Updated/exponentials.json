{
    "topic": "The mathematical concept being demonstrated is the value of pi (\u03c0).",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.laplace.shm import ShowFamilyOfComplexSolutions\n",
        "\n",
        "\n",
        "S_COLOR = YELLOW\n",
        "T_COLOR = BLUE\n",
        "\n",
        "\n",
        "def get_exp_graph_icon(s, t_range=(0, 7), y_max=4, pos_real_scalar=0.1, neg_real_scalar=0.2, width=1, height=1):\n",
        "    axes = Axes(\n",
        "        t_range,\n",
        "        (-y_max, y_max),\n",
        "        width=width,\n",
        "        height=height,\n",
        "        axis_config=dict(tick_size=0.035, stroke_width=1)\n",
        "    )\n",
        "    scalar = pos_real_scalar if s.real > 0 else neg_real_scalar\n",
        "    new_s = complex(s.real * scalar, s.imag)\n",
        "    graph = axes.get_graph(lambda t: np.exp(new_s * t).real)\n",
        "    graph.set_stroke(YELLOW, 2)\n",
        "    rect = SurroundingRectangle(axes)\n",
        "    rect.set_fill(BLACK, 1)\n",
        "    rect.set_stroke(WHITE, 1)\n",
        "    return VGroup(rect, axes, graph)\n",
        "\n",
        "\n",
        "class IntroduceEulersFormula(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add plane\n",
        "        plane = ComplexPlane(\n",
        "            (-2, 2), (-2, 2),\n",
        "            width=6, height=6,\n",
        "        )\n",
        "        plane.background_lines.set_stroke(BLUE, 1)\n",
        "        plane.faded_lines.set_stroke(BLUE, 0.5, 0.5)\n",
        "        plane.to_edge(LEFT)\n",
        "\n",
        "        plane.add_coordinate_labels([1, -1])\n",
        "        i_labels = VGroup(\n",
        "            Tex(R\"i\", font_size=36).next_to(plane.n2p(1j), UL, SMALL_BUFF),\n",
        "            Tex(R\"-i\", font_size=36).next_to(plane.n2p(-1j), DL, SMALL_BUFF),\n",
        "        )\n",
        "        plane.add(i_labels)\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "        # Show pi\n",
        "        pi_color = RED\n",
        "        arc = Arc(0, PI, radius=plane.x_axis.get_unit_size(), arc_center=plane.n2p(0))\n",
        "        arc.set_stroke(pi_color, 5)\n",
        "        t_tracker = ValueTracker(0)\n",
        "        t_dec = DecimalNumber(0)\n",
        "        t_dec.set_color(pi_color)\n",
        "        t_dec.add_updater(lambda m: m.set_value(t_tracker.get_value()))\n",
        "        t_dec.add_updater(lambda m: m.move_to(plane.n2p(1.3 * np.exp(0.9 * t_tracker.get_value() * 1j))))\n",
        "\n",
        "        pi = Tex(R\"\\pi\", font_size=72)\n",
        "        pi.set_color(pi_color)\n",
        "        pi.set_backstroke(BLACK, 3)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            t_tracker.animate.set_value(PI),\n",
        "            VFadeIn(t_dec, time_span=(0, 1)),\n",
        "            run_time=2\n",
        "        )\n",
        "        pi.move_to(t_dec, DR)\n",
        "        self.play(\n",
        "            FadeOut(t_dec),\n",
        "            FadeIn(pi),\n",
        "            run_time=0.5\n",
        "        )\n",
        "\n",
        "        # Write formula\n",
        "        formula = Tex(R\"e^{\\pi i} = -1\", font_size=90, t2c={R\"\\pi\": RED, \"i\": BLUE})\n",
        "        formula.set_x(FRAME_WIDTH / 4).to_edge(UP)\n",
        "        cliche = Text(\"Clich\u00e9?\", font_size=72)\n",
        "        cliche.next_to(formula, DOWN, LARGE_BUFF)\n",
        "\n",
        "        randy = Randolph(height=2)\n",
        "        randy.next_to(plane, RIGHT, LARGE_BUFF, aligned_edge=DOWN)\n",
        "        randy.body.set_backstroke(BLACK)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(pi, formula[R\"\\pi\"][0]),\n",
        "            FadeTransform(i_labels[0].copy(), formula[\"i\"][0]),\n",
        "            Write(formula[\"=\"][0]),\n",
        "            TransformFromCopy(plane.coordinate_labels[1], formula[\"-1\"][0]),\n",
        "            Write(formula[\"e\"][0]),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    # TransformFromCopy(formula[c1][0], cliche[c2][0])\n",
        "                    FadeTransform(formula[c1][0].copy(), cliche[c2][0])\n",
        "                    for c1, c2 in zip(\n",
        "                        [\"e\", \"1\", \"i\", \"e\", R\"\\pi\", \"e\", \"1\"],\n",
        "                        \"Clich\u00e9?\",\n",
        "                    )\n",
        "                ),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=3\n",
        "            ),\n",
        "            VFadeIn(randy),\n",
        "            randy.says(\"This again?\", mode=\"sassy\", bubble_direction=LEFT)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.add(cliche)\n",
        "\n",
        "        # Show many thumbnails\n",
        "        plane_group = VGroup(plane, arc, pi)\n",
        "        plane_group.set_z_index(-1)\n",
        "        thumbnails = Group(\n",
        "            Group(ImageMobject(f\"https://img.youtube.com/vi/{slug}/maxresdefault.jpg\"))\n",
        "            for slug in [\n",
        "                \"-dhHrg-KbJ0\",  # Mathologer\n",
        "                \"f8CXG7dS-D0\",  # Welch Labs\n",
        "                \"ZxYOEwM6Wbk\",  # 3b1b\n",
        "                \"LE2uwd9V5vw\",  # Khan Academy\n",
        "                \"CRj-sbi2i2I\",  # Numberphile\n",
        "                \"v0YEaeIClKY\",  # Other 3b1b\n",
        "                \"sKtloBAuP74\",\n",
        "                \"IUTGFQpKaPU\",  # Po shen lo\n",
        "            ]\n",
        "        )\n",
        "        thumbnails.set_width(4)\n",
        "        thumbnails.arrange(DOWN, buff=-0.8)\n",
        "        thumbnails[4:].align_to(thumbnails, UP).shift(0.5 * DOWN)\n",
        "        thumbnails.to_corner(UL)\n",
        "        for n, tn in enumerate(thumbnails):\n",
        "            tn.add_to_back(SurroundingRectangle(tn, buff=0).set_stroke(WHITE, 1))\n",
        "            tn.shift(0.4 * n * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(randy.bubble, time_span=(0, 1)),\n",
        "            randy.change(\"raise_left_hand\", thumbnails).set_anim_args(time_span=(0, 1)),\n",
        "            plane_group.animate.set_width(3.5).next_to(formula, DOWN, MED_LARGE_BUFF).set_anim_args(time_span=(0, 2)),\n",
        "            FadeOut(cliche, 3 * RIGHT, lag_ratio=-0.02, time_span=(0.5, 2.0)),\n",
        "            LaggedStartMap(FadeIn, thumbnails, shift=UP, lag_ratio=0.5),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Fail to explain\n",
        "        thumbnails.generate_target()\n",
        "        for tn, vect in zip(thumbnails.target, compass_directions(len(thumbnails))):\n",
        "            vect[0] *= 1.5\n",
        "            tn.set_height(1.75)\n",
        "            tn.move_to(3 * vect)\n",
        "\n",
        "        formula.generate_target()\n",
        "        q_marks = Tex(R\"???\", font_size=90)\n",
        "        VGroup(formula.target, q_marks).arrange(DOWN, buff=MED_LARGE_BUFF).center()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(thumbnails, lag_ratio=0.01, run_time=2),\n",
        "            FadeOut(randy, DOWN),\n",
        "            FadeOut(plane_group, DOWN),\n",
        "            MoveToTarget(formula),\n",
        "            Write(q_marks)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, thumbnails, shift=DOWN, lag_ratio=0.5, run_time=4))\n",
        "        self.wait()\n",
        "\n",
        "        # Show constant meanings\n",
        "        e_copy = formula[\"e\"][0].copy()\n",
        "\n",
        "        circle = Circle(radius=1)\n",
        "        circle.to_edge(UP, buff=LARGE_BUFF)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "        arc = circle.copy().pointwise_become_partial(circle, 0, 0.5)\n",
        "        arc.set_stroke(pi_color, 5)\n",
        "        radius = Line(circle.get_center(), circle.get_right())\n",
        "        radius.set_stroke(WHITE, 1)\n",
        "        radius_label = Tex(R\"1\", font_size=24)\n",
        "        radius_label.next_to(radius, DOWN, SMALL_BUFF)\n",
        "        pi_label = Tex(R\"\\pi\").set_color(pi_color)\n",
        "        pi_label.next_to(circle, UP, buff=SMALL_BUFF)\n",
        "        circle_group = VGroup(circle, arc, radius_label, radius, pi_label)\n",
        "\n",
        "        i_eq = Tex(R\"i^2 = -1\", t2c={\"i\": BLUE}, font_size=90)\n",
        "        i_eq.move_to(circle).set_x(5)\n",
        "\n",
        "        self.play(\n",
        "            formula.animate.shift(DOWN),\n",
        "            FadeOut(e_copy, 3 * UP + 5 * LEFT),\n",
        "            FadeOut(q_marks, DOWN)\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(formula[R\"\\pi\"][0], pi_label),\n",
        "            LaggedStartMap(FadeIn, VGroup(circle, radius, radius_label)),\n",
        "            ShowCreation(arc),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(formula[\"i\"][0].copy(), i_eq[\"i\"][0]),\n",
        "            Write(i_eq[1:], time_span=(0.75, 1.75)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Question marks over i\n",
        "        i_rect = SurroundingRectangle(formula[\"i\"], buff=0.05)\n",
        "        i_rect.set_stroke(YELLOW, 2)\n",
        "        q_marks = Tex(R\"???\", font_size=24)\n",
        "        q_marks.match_color(i_rect)\n",
        "        q_marks.next_to(i_rect, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(i_rect),\n",
        "            FadeIn(q_marks, 0.25 * UP, lag_ratio=0.25)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Who cares (To overlay)\n",
        "        frame = self.frame\n",
        "        back_rect = FullScreenRectangle()\n",
        "        back_rect.fix_in_frame()\n",
        "        back_rect.set_z_index(-1),\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(circle_group, i_eq, VGroup(i_rect, q_marks))),\n",
        "            FadeOut(circle_group),\n",
        "            frame.animate.set_y(-3.5),\n",
        "            FadeIn(back_rect),\n",
        "            formula.animate.set_fill(WHITE),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExpGraph(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up graph\n",
        "        axes = Axes((-1, 4), (0, 20), width=10, height=6)\n",
        "        axes.to_edge(RIGHT)\n",
        "        x_axis_label = Tex(\"t\")\n",
        "        x_axis_label.next_to(axes.x_axis.get_right(), UL, MED_SMALL_BUFF)\n",
        "        axes.add(x_axis_label)\n",
        "\n",
        "        graph = axes.get_graph(np.exp)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        title = Tex(R\"\\frac{d}{dt} e^t = e^t\", t2c={\"t\": GREY_B}, font_size=60)\n",
        "        title.to_edge(UP)\n",
        "        title.match_x(axes.c2p(1.5, 0))\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(graph)\n",
        "        self.add(title)\n",
        "\n",
        "        # Add height tracker\n",
        "        t_tracker = ValueTracker(1)\n",
        "        get_t = t_tracker.get_value\n",
        "        v_line = always_redraw(\n",
        "            lambda: axes.get_v_line_to_graph(get_t(), graph, line_func=Line).set_stroke(RED, 3)\n",
        "        )\n",
        "        height_label = Tex(R\"e^t\", font_size=42)\n",
        "        height_label.always.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "        height_label_height = height_label.get_height()\n",
        "        height_label.add_updater(lambda m: m.set_height(\n",
        "            min(height_label_height, 0.7 * v_line.get_height())\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line, suspend_mobject_updating=True),\n",
        "            FadeIn(height_label, UP, suspend_mobject_updating=True),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add tangent line\n",
        "        tangent_line = always_redraw(\n",
        "            lambda: axes.get_tangent_line(get_t(), graph, length=10).set_stroke(BLUE_A, 1)\n",
        "        )\n",
        "        unit_size = axes.x_axis.get_unit_size()\n",
        "        unit_line = Line(axes.c2p(0, 0), axes.c2p(1, 0))\n",
        "        unit_line.add_updater(lambda m: m.move_to(v_line.get_end(), LEFT))\n",
        "        unit_line.set_stroke(WHITE, 2)\n",
        "        unit_label = Integer(1, font_size=24)\n",
        "        unit_label.add_updater(lambda m: m.next_to(unit_line.pfp(0.6), UP, 0.5 * SMALL_BUFF))\n",
        "        tan_v_line = always_redraw(\n",
        "            lambda: v_line.copy().shift(v_line.get_vector() + unit_size * RIGHT)\n",
        "        )\n",
        "\n",
        "        deriv_label = Tex(R\"\\frac{d}{dt} e^t = e^t\", font_size=42)\n",
        "        deriv_label[R\"\\frac{d}{dt}\"].scale(0.75, about_edge=RIGHT)\n",
        "        deriv_label_height = deriv_label.get_height()\n",
        "        deriv_label.add_updater(lambda m: m.set_height(\n",
        "            min(deriv_label_height, 0.8 * v_line.get_height())\n",
        "        ))\n",
        "        deriv_label.always.next_to(tan_v_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(tangent_line, suspend_mobject_updating=True))\n",
        "        self.play(\n",
        "            VFadeIn(unit_line),\n",
        "            VFadeIn(unit_label),\n",
        "            VFadeIn(tan_v_line, suspend_mobject_updating=True),\n",
        "            TransformFromCopy(title, deriv_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(v_line.copy().clear_updaters(), tan_v_line, path_arc=45 * DEG),\n",
        "            FadeTransform(height_label.copy(), deriv_label[\"e^t\"][1], path_arc=45 * DEG, remover=True),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move it around\n",
        "        for t in [2.35, 0, 1, 2]:\n",
        "            self.play(t_tracker.animate.set_value(t), run_time=5)\n",
        "\n",
        "\n",
        "class DefiningPropertyOfExp(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Key property\n",
        "        tex_kw = dict(t2c={\"{t}\": GREY_B, \"x\": BLUE})\n",
        "        equation = Tex(R\"\\frac{d}{d{t}} e^{t} = e^{t}\", font_size=90, **tex_kw)\n",
        "\n",
        "        exp_parts = equation[\"e^{t}\"]\n",
        "        ddt = equation[R\"\\frac{d}{d{t}}\"]\n",
        "\n",
        "        self.play(Write(exp_parts[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(ddt, scale=2))\n",
        "        self.play(\n",
        "            Write(equation[\"=\"]),\n",
        "            TransformFromCopy(*exp_parts, path_arc=PI / 2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Differential Equation\n",
        "        ode = Tex(R\"x'(t) = x(t)\", font_size=72, **tex_kw)\n",
        "        ode.move_to(equation).to_edge(UP)\n",
        "        ode_label = Text(\"Differential\\nEquation\", font_size=36)\n",
        "        ode_label.next_to(ode, LEFT, LARGE_BUFF, aligned_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(equation.copy(), ode),\n",
        "            FadeIn(ode_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Initial condition\n",
        "        frame = self.frame\n",
        "        abs_ic = Tex(R\"x(0) = 1\", font_size=72, **tex_kw)\n",
        "        exp_ic = Tex(R\"e^{0} = 1\", font_size=90, t2c={\"0\": GREY_B})\n",
        "        abs_ic.next_to(ode, RIGHT, buff=2.0)\n",
        "        exp_ic.match_x(abs_ic).match_y(equation).shift(0.1 * UP)\n",
        "        ic_label = Text(\"Initial\\nCondition\", font_size=36)\n",
        "        ic_label.next_to(abs_ic, RIGHT, buff=0.75)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(abs_ic, RIGHT),\n",
        "            FadeIn(exp_ic, RIGHT),\n",
        "            frame.animate.set_x(2),\n",
        "            Write(ic_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Scroll down\n",
        "        self.play(frame.animate.set_y(-2.5), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExampleExponentials(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show the family\n",
        "        pass\n",
        "\n",
        "        # Highlight -1 + i term\n",
        "\n",
        "        # Show e^t as its own derivative\n",
        "\n",
        "\n",
        "class ImaginaryInputsToTheTaylorSeries(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add complex plane\n",
        "        plane = ComplexPlane(\n",
        "            (-6, 6),\n",
        "            (-4, 4),\n",
        "            background_line_style=dict(stroke_color=BLUE, stroke_width=1),\n",
        "            faded_line_style=dict(stroke_color=BLUE, stroke_width=0.5, stroke_opacity=0.5),\n",
        "        )\n",
        "        plane.set_height(5)\n",
        "        plane.to_edge(DOWN, buff=0)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "        # Add \u03c0i dot\n",
        "        dot = GlowDot(color=YELLOW)\n",
        "        dot.move_to(plane.n2p(PI * 1j))\n",
        "        pi_i_label = Tex(R\"\\pi i\", font_size=30).set_color(YELLOW)\n",
        "        pi_i_label.next_to(dot, RIGHT, buff=-0.1).align_to(plane.n2p(3j), DOWN)\n",
        "\n",
        "        self.add(dot, pi_i_label)\n",
        "\n",
        "        # Show false equation\n",
        "        false_eq = Tex(R\"e^x = e \\cdot e \\cdots e \\cdot e\", t2c={\"x\": BLUE}, font_size=60)\n",
        "        false_eq.to_edge(UP).shift(2 * LEFT)\n",
        "        brace = Brace(false_eq[3:], DOWN)\n",
        "        brace_tex = brace.get_tex(R\"x \\text{ times}\")\n",
        "        brace_tex[0].set_color(BLUE)\n",
        "\n",
        "        nonsense = TexText(R\"Nonsense if $x$ \\\\ is complex\")\n",
        "        nonsense.next_to(VGroup(false_eq, brace_tex), RIGHT, LARGE_BUFF)\n",
        "        nonsense.set_color(RED)\n",
        "\n",
        "        self.add(false_eq)\n",
        "        self.play(GrowFromCenter(brace), FadeIn(brace_tex, lag_ratio=0.1))\n",
        "        self.play(FadeIn(nonsense, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Make it the real equation\n",
        "        gen_poly = self.get_series(\"x\")\n",
        "        gen_poly.to_edge(LEFT).to_edge(UP, MED_SMALL_BUFF)\n",
        "\n",
        "        epii = self.get_series(R\"\\pi i\", use_parens=True, in_tex_color=YELLOW)\n",
        "        epii.next_to(gen_poly, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.remove(false_eq)\n",
        "        self.play(\n",
        "            TransformFromCopy(false_eq[:2], gen_poly[0]),\n",
        "            FadeOut(false_eq[2:], 0.5 * DOWN, lag_ratio=0.05),\n",
        "            FadeOut(nonsense),\n",
        "            FadeOut(brace, 0.5 * DOWN),\n",
        "            FadeOut(brace_tex, 0.25 * DOWN),\n",
        "            Write(gen_poly[1:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Plug in \u03c0i\n",
        "        vectors = self.get_spiral_vectors(plane, PI)\n",
        "        buff = 0.5 * SMALL_BUFF\n",
        "        labels = VGroup(\n",
        "            Tex(R\"\\pi i\", font_size=30).next_to(vectors[1], RIGHT, buff),\n",
        "            Tex(R\"(\\pi^2 / 2) \\cdot i^2\", font_size=30).next_to(vectors[2], UP, buff),\n",
        "            Tex(R\"(\\pi^3 / 6) \\cdot i^3\", font_size=30).next_to(vectors[3], LEFT, buff),\n",
        "            Tex(R\"(\\pi^4 / 24) \\cdot i^4\", font_size=30).next_to(vectors[4], DOWN, buff),\n",
        "        )\n",
        "        labels.set_color(YELLOW)\n",
        "        labels.set_backstroke(BLACK, 5)\n",
        "\n",
        "        for n in range(0, len(gen_poly), 2):\n",
        "            anims = [\n",
        "                LaggedStart(\n",
        "                    TransformMatchingTex(gen_poly[n].copy(), epii[n], run_time=1),\n",
        "                    TransformFromCopy(gen_poly[n + 1], epii[n + 1]),\n",
        "                    gen_poly[n + 2:].animate.align_to(epii[n + 2:], LEFT),\n",
        "                    lag_ratio=0.05\n",
        "                ),\n",
        "            ]\n",
        "            k = (n - 1) // 2\n",
        "            if k >= 0:\n",
        "                anims.append(GrowArrow(vectors[k]))\n",
        "            if k == 1:\n",
        "                anims.append(FadeTransform(pi_i_label, labels[0]))\n",
        "            elif 2 <= k <= len(labels):\n",
        "                anims.append(FadeIn(labels[k - 1]))\n",
        "            if k >= 1:\n",
        "                anims.append(dot.animate.set_width(0.5).move_to(vectors[k].get_end()))\n",
        "            self.play(*anims)\n",
        "        for vector in vectors[7:]:\n",
        "            self.play(GrowArrow(vector), dot.animate.move_to(vector.get_end()))\n",
        "        self.wait()\n",
        "\n",
        "        # Step through terms individually\n",
        "        labels.add_to_back(VectorizedPoint().move_to(vectors[0]))\n",
        "        for n in range(5):\n",
        "            rect1 = SurroundingRectangle(epii[2 * n + 2])\n",
        "            rect2 = SurroundingRectangle(VGroup(vectors[n], labels[n]))\n",
        "            self.play(\n",
        "                FadeIn(rect1),\n",
        "                self.fade_all_but(epii, 2 * n + 2),\n",
        "                self.fade_all_but(vectors, n),\n",
        "                self.fade_all_but(labels, n),\n",
        "                dot.animate.set_opacity(0.1),\n",
        "            )\n",
        "            self.play(Transform(rect1, rect2))\n",
        "            self.play(FadeOut(rect1))\n",
        "        self.play(*(\n",
        "            mob.animate.set_fill(opacity=1)\n",
        "            for mob in [epii, vectors, labels]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Swap out i for t\n",
        "        e_to_it = self.get_series(\"it\", use_parens=True, in_tex_color=GREEN)\n",
        "        for sm1, sm2 in zip(e_to_it, epii):\n",
        "            sm1.move_to(sm2)\n",
        "\n",
        "        t_tracker = ValueTracker(PI)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        t_label = Tex(R\"t = 3.14\", t2c={\"t\": GREEN})\n",
        "        t_label.next_to(e_to_it, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        t_rhs = t_label.make_number_changeable(\"3.14\")\n",
        "        t_rhs.add_updater(lambda m: m.set_value(get_t()))\n",
        "\n",
        "        vectors.add_updater(lambda m: m.become(self.get_spiral_vectors(plane, get_t(), 20)))\n",
        "        dot.f_always.move_to(vectors[-1].get_end)\n",
        "\n",
        "        max_theta = TAU\n",
        "        semi_circle = Arc(0, max_theta, radius=plane.x_axis.get_unit_size(), arc_center=plane.n2p(0))\n",
        "        semi_circle.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(epii, e_to_it, lag_ratio=0.01, run_time=2),\n",
        "            FadeOut(labels),\n",
        "            FadeIn(t_label),\n",
        "        )\n",
        "        self.add(vectors)\n",
        "        self.play(t_tracker.animate.set_value(0), run_time=5)\n",
        "        self.play(\n",
        "            t_tracker.animate.set_value(max_theta),\n",
        "            ShowCreation(semi_circle),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.play(t_tracker.animate.set_value(PI), run_time=6)\n",
        "        self.wait()\n",
        "\n",
        "    def get_series(self, in_tex=\"x\", use_parens=False, in_tex_color=BLUE, buff=0.2):\n",
        "        paren_tex = f\"({in_tex})\" if use_parens else in_tex\n",
        "        kw = dict(t2c={in_tex: in_tex_color})\n",
        "        terms = VGroup(\n",
        "            Tex(fR\"e^{{{in_tex}}}\", **kw),\n",
        "            Tex(\"=\"),\n",
        "            Tex(fR\"1\"),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(fR\"{in_tex}\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(fR\"\\frac{{1}}{{2}} {paren_tex}^2\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(fR\"\\frac{{1}}{{6}} {paren_tex}^3\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(fR\"\\frac{{1}}{{24}} {paren_tex}^4\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(R\"\\cdots\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "            Tex(fR\"\\frac{{1}}{{n!}} {paren_tex}^n\", **kw),\n",
        "            Tex(R\"+\"),\n",
        "        )\n",
        "        terms.arrange(RIGHT, buff=buff)\n",
        "        terms[0].scale(1.25, about_edge=DR)\n",
        "        return terms\n",
        "\n",
        "    def get_spiral_vectors(\n",
        "        self,\n",
        "        plane,\n",
        "        t,\n",
        "        n_terms=10,\n",
        "        # colors=[GREEN, YELLOW, GREEN_E, YELLOW_E]\n",
        "        colors=[GREEN_E, GREEN_C, GREEN_B, GREEN_A],\n",
        "    ):\n",
        "        values = [(t * 1j)**n / math.factorial(n) for n in range(n_terms)]\n",
        "        vectors = VGroup(\n",
        "            Arrow(plane.n2p(0), plane.n2p(value), buff=0, fill_color=color)\n",
        "            for value, color in zip(values, it.cycle(colors))\n",
        "        )\n",
        "        for v1, v2 in zip(vectors, vectors[1:]):\n",
        "            v2.shift(v1.get_end() - v2.get_start())\n",
        "        return vectors\n",
        "\n",
        "    def fade_all_but(self, group, index):\n",
        "        group.target = group.generate_target()\n",
        "        group.target.set_fill(opacity=0.4)\n",
        "        group.target[index].set_fill(opacity=1)\n",
        "        return MoveToTarget(group)\n",
        "\n",
        "\n",
        "class ComplexExpGraph(InteractiveScene):\n",
        "    s_value = 1j\n",
        "    orientation1 = (-77, -1, 0, (1.01, -0.1, 3.21), 7.55)\n",
        "    orientation2 = (-33, -2, 0, (1.68, -0.09, 3.79), 10.88)\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up parts\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.scale(0.75)\n",
        "        moving_plane = plane.copy()\n",
        "\n",
        "        t_axis = NumberLine((0, 12))\n",
        "        t_axis.rotate(90 * DEG, DOWN)\n",
        "        t_axis.shift(-t_axis.n2p(0))\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(t_axis)\n",
        "\n",
        "        # Trackers and graph\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "        s = self.s_value\n",
        "\n",
        "        def get_z():\n",
        "            return np.exp(s * get_t())\n",
        "\n",
        "        def z_to_point(z):\n",
        "            return plane.n2p(z) + get_t() * OUT\n",
        "\n",
        "        moving_plane.add_updater(lambda m: m.move_to(t_axis.n2p(get_t())))\n",
        "        point = GlowDot()\n",
        "        point.add_updater(lambda m: m.move_to(z_to_point(get_z())))\n",
        "        vector = Vector()\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            z_to_point(0),\n",
        "            z_to_point(get_z())\n",
        "        ))\n",
        "        graph = TracedPath(vector.get_end, stroke_color=TEAL)\n",
        "\n",
        "        t_label = Tex(\"t = 0.00\", font_size=30)\n",
        "        t_label_rhs = t_label.make_number_changeable(\"0.00\")\n",
        "        t_label_rhs.add_updater(lambda m: m.set_value(get_t()))\n",
        "        t_label.add_updater(lambda m: m.next_to(moving_plane, UP, SMALL_BUFF))\n",
        "\n",
        "        self.add(t_tracker, moving_plane, vector, point, graph)\n",
        "        self.add(t_label)\n",
        "        frame.reorient(*self.orientation1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(*self.orientation2),\n",
        "            t_tracker.animate.set_value(12).set_anim_args(rate_func=linear),\n",
        "            VFadeIn(t_axis, time_span=(0, 1)),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, -89, -90, (0.06, -0.62, 5.27), 7.42).set_field_of_view(1 * DEG),\n",
        "            FadeOut(plane),\n",
        "            FadeOut(moving_plane),\n",
        "            FadeOut(t_label),\n",
        "            FadeOut(point),\n",
        "            FadeOut(vector),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "\n",
        "class AltComplexExpGraph(ComplexExpGraph):\n",
        "    s_value = -0.2 + 1j\n",
        "    orientation1 = (-37, -1, 0, (0.08, 0.1, 0.08), 6)\n",
        "    orientation2 = (-21, -5, 0, (1.47, -0.44, 3.88), 12.29)\n",
        "\n",
        "\n",
        "class SPlane(InteractiveScene):\n",
        "    tex_to_color_map = {\"s\": YELLOW, \"t\": BLUE, R\"\\omega\": PINK}\n",
        "    s_plane_x_range = (-2, 2)\n",
        "    s_label_font_size = 36\n",
        "    s_label_config = dict(\n",
        "        hide_zero_components_on_complex=True,\n",
        "        include_sign=True,\n",
        "        num_decimal_places=1,\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Trackers\n",
        "        s_tracker = self.s_tracker = ComplexValueTracker(-1)\n",
        "        t_tracker = self.t_tracker = ValueTracker(0)\n",
        "        get_s = s_tracker.get_value\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        # Add s plane\n",
        "        s_plane = self.get_s_plane()\n",
        "        s_dot, s_label = self.get_s_dot_and_label(s_plane, get_s)\n",
        "        self.add(s_plane, s_dot, s_label)\n",
        "\n",
        "        # Add exp plane\n",
        "        exp_plane = self.get_exp_plane()\n",
        "        exp_plane_label = self.get_exp_plane_label(exp_plane)\n",
        "        output_dot, output_label = self.get_output_dot_and_label(exp_plane, get_s, get_t)\n",
        "        output_path = self.get_output_path(exp_plane, get_t, get_s)\n",
        "\n",
        "        self.add(exp_plane, exp_plane_label, output_path, output_dot, output_label)\n",
        "\n",
        "        # Add e^{st} graph\n",
        "        axes = self.get_graph_axes()\n",
        "        graph = self.get_dynamic_exp_graph(axes, get_s)\n",
        "        v_line = self.get_graph_v_line(axes, get_t, get_s)\n",
        "\n",
        "        self.add(axes, graph, v_line)\n",
        "\n",
        "        # Move s around, end at i\n",
        "        s_tracker.set_value(-1)\n",
        "        self.play(s_tracker.animate.set_value(0.2), run_time=4)\n",
        "        self.play(s_tracker.animate.set_value(0), run_time=2)\n",
        "        self.play(s_tracker.animate.set_value(1j), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "        # Let time tick forward\n",
        "        frame = self.frame\n",
        "        self.play_time_forward(\n",
        "            3 * TAU,\n",
        "            added_anims=[frame.animate.set_x(3).set_height(12).set_anim_args(time_span=(6, 15))],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            t_tracker.animate.set_value(0),\n",
        "            frame.animate.set_x(1.5).set_height(10),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Set s to 2i, then add vectors\n",
        "        t2c = {\"2i\": YELLOW, **self.tex_to_color_map}\n",
        "        exp_2it_label = Tex(R\"e^{2i t}\", t2c=t2c)\n",
        "        exp_2it_label.move_to(exp_plane_label, RIGHT)\n",
        "\n",
        "        self.play(s_tracker.animate.set_value(2j), run_time=2)\n",
        "        self.play(\n",
        "            FadeOut(exp_plane_label, 0.5 * UP),\n",
        "            FadeIn(exp_2it_label, 0.5 * UP),\n",
        "        )\n",
        "        self.play_time_forward(TAU)\n",
        "\n",
        "        # Show the derivative\n",
        "        exp_plane.target = exp_plane.generate_target()\n",
        "        exp_plane.target.align_to(axes.c2p(0, 0), LEFT)\n",
        "\n",
        "        deriv_expression = Tex(R\"\\frac{d}{dt} e^{2i t} = 2i \\cdot e^{2i t}\", t2c=t2c)\n",
        "        deriv_expression.next_to(exp_plane.target, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                ReplacementTransform(exp_2it_label, deriv_expression[\"e^{2i t}\"][0], path_arc=-90 * DEG),\n",
        "                MoveToTarget(exp_plane),\n",
        "                Write(deriv_expression[R\"\\frac{d}{dt}\"]),\n",
        "                lag_ratio=0.2\n",
        "            ),\n",
        "            frame.animate.reorient(0, 0, 0, (1, 0, 0.0), 9.25),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            Write(deriv_expression[\"=\"]),\n",
        "            TransformFromCopy(*deriv_expression[\"e^{2i t}\"], path_arc=-90 * DEGREES),\n",
        "            FadeTransform(deriv_expression[\"e^{2i t}\"][0][1:3].copy(), deriv_expression[R\"2i\"][1], path_arc=-90 * DEG),\n",
        "            Write(deriv_expression[R\"\\cdot\"]),\n",
        "            lag_ratio=0.25,\n",
        "            run_time=1.5\n",
        "        ))\n",
        "        self.add(deriv_expression)\n",
        "        self.wait()\n",
        "\n",
        "        # Step through derivative parts\n",
        "        v_part, p_part, i_part, two_part = parts = VGroup(\n",
        "            deriv_expression[R\"\\frac{d}{dt} e^{2i t}\"][0],\n",
        "            deriv_expression[R\"e^{2i t}\"][1],\n",
        "            deriv_expression[R\"i\"][1],\n",
        "            deriv_expression[R\"2\"][1],\n",
        "        )\n",
        "        colors = [GREEN, BLUE, YELLOW, YELLOW]\n",
        "        labels = VGroup(Text(\"Velocity\"), Text(\"Position\"), Tex(R\"90^{\\circ}\"), Text(\"Stretch\"))\n",
        "        for part, color, label in zip(parts, colors, labels):\n",
        "            part.rect = SurroundingRectangle(part, buff=0.05)\n",
        "            part.rect.set_stroke(color, 2)\n",
        "            label.set_color(color)\n",
        "            label.next_to(part.rect, DOWN)\n",
        "            part.label = label\n",
        "\n",
        "        p_vect, v_vect = vectors = self.get_pv_vectors(exp_plane, get_t, get_s)\n",
        "        for vector in vectors:\n",
        "            vector.suspend_updating()\n",
        "        p_vect_copy = p_vect.copy().clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_part.rect),\n",
        "            FadeIn(v_part.label),\n",
        "            GrowArrow(v_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(v_part.rect, p_part.rect),\n",
        "            FadeTransform(v_part.label, p_part.label),\n",
        "            GrowArrow(p_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(p_part.rect, i_part.rect),\n",
        "            FadeTransform(p_part.label, i_part.label),\n",
        "            p_vect_copy.animate.rotate(90 * DEG, about_point=exp_plane.n2p(0)).shift(p_vect.get_vector())\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(i_part.rect, two_part.rect),\n",
        "            FadeTransform(i_part.label, two_part.label),\n",
        "            Transform(p_vect_copy, v_vect, remover=True)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(two_part.rect), FadeOut(two_part.label))\n",
        "\n",
        "        vectors.resume_updating()\n",
        "        self.play_time_forward(TAU)\n",
        "\n",
        "        # Label this angular frequency with omega\n",
        "        imag_exp = Tex(R\"e^{i \\omega t}\", t2c=self.tex_to_color_map, font_size=60)\n",
        "        imag_exp.move_to(deriv_expression, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(deriv_expression, 0.5 * UP),\n",
        "            FadeIn(imag_exp, 0.5 * UP),\n",
        "        )\n",
        "        t_tracker.set_value(0)\n",
        "        output_path.suspend_updating()\n",
        "        self.play(s_tracker.animate.set_value(1.5j), run_time=3)\n",
        "        output_path.resume_updating()\n",
        "        self.play_time_forward(TAU * 4 / 3)\n",
        "\n",
        "        # Move to other complex values, end at -0.5 + i\n",
        "        t_max_tracker = ValueTracker(20 * TAU)\n",
        "        new_output_path = self.get_output_path(exp_plane, t_max_tracker.get_value, get_s)\n",
        "        output_path.match_updaters(new_output_path)\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(imag_exp, time_span=(0, 1)),\n",
        "            s_tracker.animate.set_value(-0.2 + 1.5j),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(s_tracker.animate.set_value(-0.2 + 1j), run_time=2)\n",
        "        self.play(s_tracker.animate.set_value(-0.5 + 1j), run_time=2)\n",
        "        self.play_time_forward(TAU)\n",
        "\n",
        "        # Split up the exponential to e^{-0.5t} * e^{it}\n",
        "        t2c = {\"-0.5\": YELLOW, \"i\": YELLOW, \"t\": BLUE}\n",
        "        lines = VGroup(\n",
        "            Tex(R\"e^{(-0.5 + i)t}\", t2c=t2c),\n",
        "            Tex(R\"\\left(e^{-0.5t} \\right) \\left(e^{it} \\right)\", t2c=t2c)\n",
        "        )\n",
        "        lines.arrange(DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        lines.next_to(exp_plane, RIGHT, LARGE_BUFF, aligned_edge=UP)\n",
        "\n",
        "        dec_brace = Brace(lines[1][R\"\\left(e^{-0.5t} \\right)\"], DOWN, SMALL_BUFF)\n",
        "        rot_brace = Brace(lines[1][R\"\\left(e^{it} \\right)\"], DOWN, SMALL_BUFF)\n",
        "        dec_label = dec_brace.get_text(\"Decay\")\n",
        "        rot_label = rot_brace.get_text(\"Rotation\")\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(lines[0], time_span=(0.5, 1)),\n",
        "            FadeTransform(s_label[-1].copy(), lines[0][\"-0.5 + i\"])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(lines[0].copy(), lines[1], run_time=1, lag_ratio=0.01)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(dec_brace),\n",
        "            FadeIn(dec_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(dec_brace, rot_brace),\n",
        "            FadeTransform(dec_label, rot_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(rot_brace),\n",
        "            FadeOut(rot_label),\n",
        "            t_tracker.animate.set_value(0).set_anim_args(run_time=3)\n",
        "        )\n",
        "\n",
        "        # Show multiplication by s\n",
        "        s_vect = Arrow(s_plane.n2p(0), s_plane.n2p(get_s()), buff=0, fill_color=YELLOW)\n",
        "        one_vect = Arrow(s_plane.n2p(0), s_plane.n2p(1), buff=0, fill_color=BLUE)\n",
        "        arc = Line(\n",
        "            s_plane.n2p(0.3),\n",
        "            s_plane.n2p(0.3 * get_s()),\n",
        "            path_arc=s_vect.get_angle(),\n",
        "            buff=0.1\n",
        "        )\n",
        "        arc.add_tip(length=0.25, width=0.25)\n",
        "        times_s_label = Tex(R\"\\times s\")\n",
        "        times_s_label.next_to(arc.pfp(0.5), UR, SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(one_vect),\n",
        "            FadeIn(arc),\n",
        "            FadeIn(times_s_label),\n",
        "            FadeIn(s_vect),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(one_vect, s_vect, path_arc=s_vect.get_angle()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(one_vect, p_vect),\n",
        "            TransformFromCopy(s_vect, v_vect),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Show spiraling inward\n",
        "        self.play_time_forward(2 * TAU)\n",
        "\n",
        "        self.play(FadeOut(VGroup(arc, times_s_label, lines)))\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        s_vect.add_updater(lambda m: m.put_start_and_end_on(s_plane.n2p(0), s_plane.n2p(get_s())))\n",
        "        self.add(s_vect)\n",
        "\n",
        "        # Tour various values on the s plane\n",
        "        values = [\n",
        "            -0.1 + 2j,\n",
        "            -0.1 - 2j,\n",
        "            -0.1 + 0.5j,\n",
        "            +0.05 + 0.5j,\n",
        "            -0.5 + 0.5j,\n",
        "            -0.1 + 0.5j,\n",
        "        ]\n",
        "        for value in values:\n",
        "            self.play(s_tracker.animate.set_value(value), run_time=5)\n",
        "            if value == values[0]:\n",
        "                self.play_time_forward(TAU)\n",
        "                self.t_tracker.set_value(0)\n",
        "\n",
        "        self.play_time_forward(4 * TAU)\n",
        "\n",
        "    def get_s_plane(self):\n",
        "        s_plane = ComplexPlane(self.s_plane_x_range, self.s_plane_x_range)\n",
        "        s_plane.set_width(7)\n",
        "        s_plane.to_edge(LEFT, buff=SMALL_BUFF)\n",
        "        s_plane.add_coordinate_labels(font_size=16)\n",
        "        return s_plane\n",
        "\n",
        "    def get_s_dot_and_label(self, s_plane, get_s):\n",
        "        s_dot = Group(\n",
        "            Dot(radius=0.05, fill_color=YELLOW),\n",
        "            GlowDot(color=YELLOW),\n",
        "        )\n",
        "        s_dot.add_updater(lambda m: m.move_to(s_plane.n2p(get_s())))\n",
        "\n",
        "        s_label = Tex(R\"s = +0.5\", font_size=self.s_label_font_size)\n",
        "        s_rhs = s_label.make_number_changeable(\"+0.5\", **self.s_label_config)\n",
        "        s_rhs.f_always.set_value(get_s)\n",
        "        s_label.set_color(S_COLOR)\n",
        "        s_label.set_backstroke(BLACK, 5)\n",
        "        s_label.always.next_to(s_dot[0], UR, SMALL_BUFF)\n",
        "\n",
        "        return Group(s_dot, s_label)\n",
        "\n",
        "    def get_exp_plane(self, x_range=(-2, 2)):\n",
        "        exp_plane = ComplexPlane(x_range, x_range)\n",
        "        exp_plane.background_lines.set_stroke(width=1)\n",
        "        exp_plane.faded_lines.set_stroke(opacity=0.25)\n",
        "        exp_plane.set_width(4)\n",
        "        exp_plane.to_corner(DR).shift(0.5 * LEFT)\n",
        "\n",
        "        return exp_plane\n",
        "\n",
        "    def get_exp_plane_label(self, exp_plane, font_size=60):\n",
        "        label = Tex(R\"e^{st}\", font_size=font_size, t2c=self.tex_to_color_map)\n",
        "        label.set_backstroke(BLACK, 5)\n",
        "        label.next_to(exp_plane.get_corner(UL), DL, 0.2)\n",
        "        return label\n",
        "\n",
        "    def get_output_dot_and_label(self, exp_plane, get_s, get_t, label_direction=UR, s_tex=\"s\"):\n",
        "        output_dot = Group(\n",
        "            TrueDot(color=GREEN),\n",
        "            GlowDot(color=GREEN)\n",
        "        )\n",
        "        output_dot.add_updater(lambda m: m.move_to(exp_plane.n2p(np.exp(get_s() * get_t()))))\n",
        "\n",
        "        output_label = Tex(Rf\"e^{{{s_tex} \\cdot 0.00}}\", font_size=36, t2c=self.tex_to_color_map)\n",
        "        t_label = output_label.make_number_changeable(\"0.00\")\n",
        "        t_label.set_color(BLUE)\n",
        "        s_term = output_label[\"s\"][0][0]\n",
        "        t_label.set_height(s_term.get_height() * 1.2, about_edge=LEFT)\n",
        "        t_label.f_always.set_value(get_t)\n",
        "        t_label.always.match_y(s_term, DOWN)\n",
        "        output_label.always.next_to(output_dot, label_direction, buff=SMALL_BUFF, aligned_edge=LEFT, index_of_submobject_to_align=0),\n",
        "        output_label.set_backstroke(BLACK, 3)\n",
        "\n",
        "        return Group(output_dot, output_label)\n",
        "\n",
        "    def get_graph_axes(\n",
        "        self,\n",
        "        x_range=(0, 24),\n",
        "        y_range=(-2, 2),\n",
        "        width=15,\n",
        "        height=2,\n",
        "    ):\n",
        "        axes = Axes(x_range, y_range, width=width, height=height)\n",
        "        x_axis_label = Tex(R\"t\", font_size=36, t2c=self.tex_to_color_map)\n",
        "        y_axis_label = Tex(R\"\\text{Re}\\left[e^{st}\\right]\", font_size=36, t2c=self.tex_to_color_map)\n",
        "        x_axis_label.next_to(axes.x_axis.get_right(), UP, buff=0.15)\n",
        "        y_axis_label.next_to(axes.y_axis.get_top(), UP, SMALL_BUFF)\n",
        "        axes.add(x_axis_label)\n",
        "        axes.add(y_axis_label)\n",
        "        axes.next_to(ORIGIN, RIGHT, MED_LARGE_BUFF)\n",
        "        axes.to_edge(UP, buff=0.5)\n",
        "        x_axis_label.shift_onto_screen(buff=MED_LARGE_BUFF)\n",
        "        return axes\n",
        "\n",
        "    def get_dynamic_exp_graph(self, axes, get_s, delta_t=0.1, stroke_color=TEAL, stroke_width=3):\n",
        "        graph = Line().set_stroke(stroke_color, stroke_width)\n",
        "        t_samples = np.arange(*axes.x_range[:2], 0.1)\n",
        "\n",
        "        def update_graph(graph):\n",
        "            s = get_s()\n",
        "            values = np.exp(s * t_samples)\n",
        "            xs = values.astype(np.complex128).real\n",
        "            graph.set_points_smoothly(axes.c2p(t_samples, xs))\n",
        "\n",
        "        graph.add_updater(update_graph)\n",
        "        return graph\n",
        "\n",
        "    def get_graph_v_line(self, axes, get_t, get_s):\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.set_stroke(WHITE, 2)\n",
        "        v_line.f_always.put_start_and_end_on(\n",
        "            lambda: axes.c2p(get_t(), 0),\n",
        "            lambda: axes.c2p(get_t(), np.exp(get_s() * get_t()).real),\n",
        "        )\n",
        "        return v_line\n",
        "\n",
        "    def get_output_path(self, exp_plane, get_t, get_s, delta_t=1 / 30, color=TEAL, stroke_width=2):\n",
        "        path = VMobject()\n",
        "        path.set_points([ORIGIN])\n",
        "        path.set_stroke(color, stroke_width)\n",
        "\n",
        "        def get_path_points():\n",
        "            t_range = np.arange(0, get_t(), delta_t)\n",
        "            if len(t_range) == 0:\n",
        "                t_range = np.array([0])\n",
        "            values = np.exp(t_range * get_s())\n",
        "            return np.array([exp_plane.n2p(z) for z in values])\n",
        "\n",
        "        path.f_always.set_points_smoothly(get_path_points)\n",
        "        return path\n",
        "\n",
        "    def play_time_forward(self, time, added_anims=[]):\n",
        "        self.t_tracker.set_value(0)\n",
        "        self.play(\n",
        "            self.t_tracker.animate.set_value(time).set_anim_args(rate_func=linear),\n",
        "            *added_anims,\n",
        "            run_time=time,\n",
        "        )\n",
        "\n",
        "    def get_pv_vectors(self, exp_plane, get_t, get_s, thickness=3, colors=[BLUE, YELLOW]):\n",
        "        p_vect = Vector(RIGHT, fill_color=colors[0], thickness=thickness)\n",
        "        v_vect = Vector(RIGHT, fill_color=colors[1], thickness=thickness)\n",
        "        p_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            exp_plane.n2p(0),\n",
        "            exp_plane.n2p(np.exp(get_t() * get_s()))\n",
        "        ))\n",
        "        v_vect.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            exp_plane.n2p(0),\n",
        "            exp_plane.n2p(get_s() * np.exp(get_t() * get_s()))\n",
        "        ).shift(p_vect.get_vector()))\n",
        "\n",
        "        return VGroup(p_vect, v_vect)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def setup_for_square_frame(self):\n",
        "        # For an insert\n",
        "        axes.next_to(s_plane, UP, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        exp_plane.match_height(s_plane).next_to(s_plane, RIGHT, buff=1.5)\n",
        "        exp_plane_label.set_height(1).next_to(exp_plane, RIGHT, aligned_edge=UP)\n",
        "        output_label.set_fill(opacity=0).set_stroke(opacity=0)\n",
        "        self.add(exp_plane_label)\n",
        "\n",
        "        axes[:-2].stretch(2.5, 1, about_edge=DOWN)\n",
        "        axes.x_axis.ticks.stretch(1 / 2.5, 1)\n",
        "        axes[-2].next_to(axes.x_axis.get_right(), UP, MED_SMALL_BUFF)\n",
        "        axes[-1].next_to(axes.y_axis.get_top(), RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.frame.reorient(0, 0, 0, (1.0, 2.68, 0.0), 16.00)\n",
        "\n",
        "    def old_material(self):\n",
        "        # Collapse the graph\n",
        "        output_dot = GlowDot(color=GREEN)\n",
        "        output_dot.move_to(axes.x_axis.n2p(1))\n",
        "        output_label = Tex(R\"e^{s \\cdot 0.00}\", **tex_kw, font_size=36)\n",
        "        t_tracker.set_value(0)\n",
        "        t_label = output_label.make_number_changeable(\"0.00\")\n",
        "        t_label.set_color(BLUE)\n",
        "        t_label.match_height(output_label[\"s\"], about_edge=LEFT)\n",
        "        t_label.f_always.set_value(get_t)\n",
        "        output_label.add_updater(lambda m: m.next_to(output_dot, UP, SMALL_BUFF, LEFT).shift(0.2 * DR))\n",
        "\n",
        "        graph.clear_updaters()\n",
        "        self.remove(axes)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(VGroup(axes.x_axis, x_axis_label, graph)),\n",
        "            AnimationGroup(\n",
        "                Rotate(axes.y_axis, -90 * DEG),\n",
        "                TransformMatchingTex(y_axis_label, output_label, run_time=1.5),\n",
        "            ),\n",
        "            FadeIn(output_dot),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "\n",
        "\n",
        "class FamilyOfRealExp(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Graphs\n",
        "        axes = Axes((-1, 8), (-1, 5))\n",
        "        axes.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        s_tracker = ValueTracker(0.5)\n",
        "        get_s = s_tracker.get_value\n",
        "        graph = axes.get_graph(lambda t: np.exp(t))\n",
        "        graph.set_stroke(BLUE)\n",
        "        axes.bind_graph_to_func(graph, lambda t: np.exp(get_s() * t))\n",
        "\n",
        "        label = Tex(R\"e^{st}\", font_size=90)\n",
        "        label.move_to(UP)\n",
        "        label[\"s\"].set_color(YELLOW)\n",
        "\n",
        "        self.add(axes, label)\n",
        "        self.play(ShowCreation(graph, suspend_mobject_updating=True))\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-1),\n",
        "            graph.animate.set_color(YELLOW),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ForcedOscillatorSolutionForm(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Create linear combination\n",
        "        exp_texs = [Rf\"e^{{s_{n} t}}\" for n in range(1, 5)]\n",
        "        const_texs = [Rf\"c_{n}\" for n in range(1, 5)]\n",
        "        terms = [\" \".join(pair) for pair in zip(const_texs, exp_texs)]\n",
        "        solution = Tex(\"x(t) = \" + \" + \".join(terms), isolate=[*exp_texs, *const_texs])\n",
        "        solution.to_edge(RIGHT)\n",
        "\n",
        "        solution[re.compile(r's_\\w+')].set_color(YELLOW)\n",
        "        solution[re.compile(r'c_\\w+')].set_color(BLUE)\n",
        "\n",
        "        cut_index = solution.submobjects.index(solution[\"+\"][1][0])\n",
        "        first_two = solution[:cut_index]\n",
        "        last_two = solution[cut_index:]\n",
        "\n",
        "        first_two.save_state()\n",
        "        first_two.to_edge(RIGHT, buff=1.5)\n",
        "\n",
        "        self.add(first_two)\n",
        "\n",
        "        # Not this\n",
        "        ex_mark = Exmark(font_size=72).set_color(RED)\n",
        "        checkmark = Checkmark(font_size=72).set_color(GREEN)\n",
        "        ex_mark.next_to(first_two, UP, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        checkmark.next_to(first_two.saved_state, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        nope = Text(\"Nope!\", font_size=60).set_fill(border_width=4)\n",
        "        nope.match_color(ex_mark)\n",
        "        nope.next_to(ex_mark, RIGHT)\n",
        "\n",
        "        actually = Text(\"Actually...\", font_size=60)\n",
        "        actually.set_fill(border_width=2)\n",
        "        actually.match_color(checkmark)\n",
        "        actually.next_to(checkmark, RIGHT, SMALL_BUFF, aligned_edge=DOWN, index_of_submobject_to_align=0)\n",
        "\n",
        "        self.play(Write(ex_mark), Write(nope))\n",
        "\n",
        "        # Freely tune coefficients\n",
        "        c_trackers = ValueTracker(0).replicate(2)\n",
        "\n",
        "        def get_c_values():\n",
        "            return [tracker.get_value() for tracker in c_trackers]\n",
        "\n",
        "        number_lines = VGroup(\n",
        "            NumberLine((-3, 3), width=2).rotate(90 * DEG).next_to(solution[c_tex], DOWN)\n",
        "            for c_tex in const_texs[:2]\n",
        "        )\n",
        "        for line in number_lines:\n",
        "            line.set_width(0.1, stretch=True)\n",
        "            line.add_numbers(font_size=12, direction=LEFT, buff=0.1)\n",
        "\n",
        "        tips = ArrowTip().rotate(PI).set_height(0.2).replicate(2)\n",
        "        tips.set_color(BLUE)\n",
        "\n",
        "        def update_tips(tips):\n",
        "            for tip, line, value in zip(tips, number_lines, get_c_values()):\n",
        "                tip.move_to(line.n2p(value), LEFT)\n",
        "            return tips\n",
        "\n",
        "        tips.add_updater(update_tips)\n",
        "\n",
        "        c_labels = VGroup(DecimalNumber(0, font_size=24) for _ in range(2))\n",
        "\n",
        "        def update_c_labels(c_labels):\n",
        "            for label, tip, value in zip(c_labels, tips, get_c_values()):\n",
        "                label.set_value(value)\n",
        "                label.next_to(tip, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        c_labels.add_updater(update_c_labels)\n",
        "\n",
        "        def random_tuning_animation(run_time=2, lag_ratio=0.25):\n",
        "            return LaggedStart(\n",
        "                *(\n",
        "                    tracker.animate.set_value(random.uniform(-3, 3))\n",
        "                    for tracker in c_trackers\n",
        "                ),\n",
        "                lag_ratio=lag_ratio,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(number_lines),\n",
        "            VFadeIn(tips),\n",
        "            VFadeIn(c_labels),\n",
        "            random_tuning_animation()\n",
        "        )\n",
        "        for _ in range(6):\n",
        "            self.play(random_tuning_animation())\n",
        "        self.wait()\n",
        "\n",
        "        # Show four particulcar exponentials\n",
        "        plane = ComplexPlane((-3, 3), (-2, 2))\n",
        "        plane.set_height(3.25)\n",
        "        plane.to_corner(UL)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "        plane.coordinate_labels[-1].set_opacity(0)\n",
        "\n",
        "        s_values = [1.5j, -1.5j, -0.3 + 1.0j, -0.3 - 1.0j]\n",
        "        s_dots = Group(\n",
        "            GlowDot(plane.n2p(s))\n",
        "            for s in s_values\n",
        "        )\n",
        "        s_labels = VGroup(\n",
        "            Tex(Rf\"s_{n}\", font_size=24).set_color(YELLOW).next_to(dot, vect, buff=-0.1)\n",
        "            for n, dot, vect in zip(it.count(1), s_dots, [RIGHT, RIGHT, LEFT, LEFT])\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(number_lines, lag_ratio=0.1),\n",
        "            FadeOut(tips, lag_ratio=0.1),\n",
        "            FadeOut(c_labels, lag_ratio=0.1),\n",
        "            FadeOut(VGroup(ex_mark, nope), LEFT),\n",
        "            FadeIn(VGroup(checkmark, actually), LEFT),\n",
        "            Restore(first_two),\n",
        "            FadeIn(last_two, LEFT),\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(plane),\n",
        "            LaggedStartMap(FadeIn, s_dots),\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    FadeTransform(solution[f\"s_{n + 1}\"].copy(), s_labels[n])\n",
        "                    for n in range(4)\n",
        "                )\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on constants\n",
        "        const_rects = VGroup(\n",
        "            SurroundingRectangle(solution[c_tex], buff=0.075)\n",
        "            for c_tex in const_texs\n",
        "        )\n",
        "        const_rects.set_stroke(BLUE, 2)\n",
        "\n",
        "        underlines = VGroup(\n",
        "            Line(c1.get_bottom(), c2.get_bottom(), path_arc=40 * DEG)\n",
        "            for c1, c2 in it.combinations(const_rects, 2)\n",
        "        )\n",
        "        underlines.set_stroke(TEAL, 2)\n",
        "        underlines.insert_n_curves(10)\n",
        "\n",
        "        underlines = VGroup(\n",
        "            Vector(0.75 * UP, thickness=4).next_to(rect, DOWN, buff=0)\n",
        "            for rect in const_rects\n",
        "        )\n",
        "        underlines.set_fill(BLUE)\n",
        "\n",
        "        constraint_words = TexText(\"Only specific $c_n$ work\")\n",
        "        constraint_words.set_fill(BLUE, border_width=1)\n",
        "        constraint_words.match_width(underlines)\n",
        "        constraint_words.next_to(underlines, DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(constraint_words, lag_ratio=0.1),\n",
        "            FadeOut(checkmark),\n",
        "            FadeOut(actually),\n",
        "            LaggedStartMap(ShowCreation, const_rects, lag_ratio=0.25),\n",
        "            LaggedStartMap(GrowArrow, underlines),\n",
        "        )\n",
        "        self.play(FadeOut(const_rects, lag_ratio=0.1))\n",
        "\n",
        "        # Add exponential parts\n",
        "        if False:\n",
        "            # For an insertion\n",
        "            for term, s in zip(exp_texs, s_values):\n",
        "                exp_diagram = self.get_exponential_diagram(solution[term], s)\n",
        "                self.add(exp_diagram)\n",
        "            self.wait(24)\n",
        "\n",
        "        # Ask about each part\n",
        "        term_rects = VGroup(\n",
        "            SurroundingRectangle(solution[term], buff=0.1).set_stroke(TEAL, 2)\n",
        "            for term in terms\n",
        "        )\n",
        "        s_rects = VGroup(\n",
        "            SurroundingRectangle(solution[exp_tex][0][1:3], buff=0.05).set_stroke(YELLOW, 2)\n",
        "            for exp_tex in exp_texs\n",
        "        )\n",
        "\n",
        "        moving_rects = const_rects.copy()\n",
        "        self.remove(const_rects)\n",
        "\n",
        "        anim_kw = dict(lag_ratio=0.25, run_time=1.5)\n",
        "        self.play(\n",
        "            FadeOut(constraint_words),\n",
        "            FadeOut(underlines),\n",
        "            Transform(moving_rects, term_rects, **anim_kw)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(moving_rects, s_rects, **anim_kw))\n",
        "        self.wait()\n",
        "        self.play(Transform(moving_rects, const_rects, **anim_kw))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(moving_rects, **anim_kw))\n",
        "\n",
        "    def get_exponential_diagram(self, term, s, c=1.0, color=PINK):\n",
        "        plane = ComplexPlane((-1, 1), (-1, 1))\n",
        "        plane.set_width(1.25)\n",
        "        plane.next_to(term, UP)\n",
        "\n",
        "        t_tracker = ValueTracker()\n",
        "        get_t = t_tracker.get_value\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "\n",
        "        vector = Vector(thickness=2, fill_color=color)\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.n2p(0),\n",
        "            plane.n2p(c * np.exp(s * get_t())),\n",
        "        ))\n",
        "\n",
        "        tail = TracingTail(vector.get_end, stroke_color=color, time_traced=2, stroke_width=(0, 4))\n",
        "        path = TracedPath(vector.get_end, stroke_color=color, stroke_width=1, stroke_opacity=0.75)\n",
        "\n",
        "        return Group(plane, t_tracker, vector, tail, path)\n",
        "\n",
        "\n",
        "class BreakingDownFunctions(ForcedOscillatorSolutionForm):\n",
        "    def construct(self):\n",
        "        # A s plane on the left, output plane on the right\n",
        "        s_plane, out_plane = planes = VGroup(\n",
        "            ComplexPlane((-2, 2), (-2, 2)),\n",
        "            ComplexPlane((-2, 2), (-2, 2)),\n",
        "        )\n",
        "        for plane in planes:\n",
        "            plane.set_height(5)\n",
        "            plane.add_coordinate_labels(font_size=16)\n",
        "\n",
        "        out_plane.center().to_edge(DOWN)\n",
        "        s_plane.move_to(out_plane).to_edge(LEFT)\n",
        "\n",
        "        self.add(out_plane)\n",
        "\n",
        "        # Write a function as a sum, above the output plane\n",
        "        n_range = list(range(1, 6))\n",
        "        exp_texs = [Rf\"e^{{s_{n} t}}\" for n in n_range]\n",
        "        const_texs = [Rf\"c_{n}\" for n in n_range]\n",
        "        terms = [\" \".join(pair) for pair in zip(const_texs, exp_texs)]\n",
        "        solution = Tex(\"x(t) = \" + \" + \".join(terms), isolate=[*exp_texs, *const_texs])\n",
        "\n",
        "        solution[re.compile(r's_\\w+')].set_color(YELLOW)\n",
        "        solution[re.compile(r'c_\\w+')].set_color(BLUE)\n",
        "\n",
        "        solution.next_to(out_plane, UP)\n",
        "\n",
        "        self.add(solution)\n",
        "\n",
        "        # Exp animations\n",
        "        s_values = [-0.2 + 2j, -0.2 - 2j, -0.1 + 1j, -0.1 - 1j, -0.2]\n",
        "        c_values = [1j, -1j, 0.8, 0.8, -0.75]\n",
        "        colors = color_gradient([PINK, MAROON_B], len(n_range), interp_by_hsl=False)\n",
        "        exp_diagrams = Group()\n",
        "        for term, s, c, color in zip(terms, s_values, c_values, colors):\n",
        "            part = solution[term]\n",
        "            if len(part) == 0:\n",
        "                continue\n",
        "            exp_diagram = self.get_exponential_diagram(part, s, c, color)\n",
        "            self.add(*exp_diagram)\n",
        "            exp_diagrams.add(exp_diagram)\n",
        "\n",
        "        # Set up the output\n",
        "        center_point = VectorizedPoint(out_plane.n2p(0))\n",
        "        all_vects = Vector().replicate(len(n_range))\n",
        "        scale_factor = out_plane.x_axis.get_unit_size() / exp_diagrams[0][0].x_axis.get_unit_size()\n",
        "\n",
        "        for diagram, vect, previous in zip(exp_diagrams, all_vects, [center_point, *all_vects]):\n",
        "            vect.clone = diagram[2]\n",
        "            vect.previous = previous\n",
        "            vect.add_updater(lambda m: m.become(m.clone).scale(scale_factor))\n",
        "            vect.add_updater(lambda m: m.shift(m.previous.get_end() - m.get_start()))\n",
        "\n",
        "        self.add(all_vects)\n",
        "\n",
        "        # Add output graph\n",
        "        graph = VMobject()\n",
        "        graph.set_stroke(RED, 3)\n",
        "        graph.start_new_path(all_vects[-1].get_end())\n",
        "\n",
        "        def update_graph(graph, dt):\n",
        "            graph.shift(0.25 * dt * DOWN)\n",
        "            graph.add_line_to(all_vects[-1].get_end())\n",
        "\n",
        "        graph.add_updater(update_graph)\n",
        "\n",
        "        self.add(graph)\n",
        "\n",
        "        self.wait(20)\n",
        "        self.play(VFadeOut(graph), VFadeOut(all_vects))\n",
        "        exp_diagrams.suspend_updating()\n",
        "\n",
        "        # Collapse to the s plane\n",
        "        out_plane.generate_target()\n",
        "        plane_group = VGroup(s_plane, out_plane.target)\n",
        "        plane_group.arrange(RIGHT, buff=2)\n",
        "        plane_group.to_edge(DOWN)\n",
        "        compact_equation = Tex(\n",
        "            R\"x(t) = \\sum_{n=1}^{N} c_n e^{{s_n} t}\",\n",
        "            t2c={\"c_n\": BLUE, \"s_n\": YELLOW},\n",
        "            isolate=[\"n=1\", \"N\"]\n",
        "        )\n",
        "        compact_equation.next_to(out_plane.target, UP)\n",
        "        compact_equation_start = compact_equation[:-4]\n",
        "\n",
        "        s_dot = GlowDot()\n",
        "        s_dot.move_to(s_plane.n2p(s_values[2]))\n",
        "        s_label = Tex(R\"s\").set_color(YELLOW)\n",
        "        s_label.always.next_to(s_dot, UL, buff=-0.1)\n",
        "        s_plane_title = Text(R\"S-plane\", font_size=60)\n",
        "        s_plane_title.next_to(s_plane, UP)\n",
        "        s_plane_title.set_color(YELLOW)\n",
        "\n",
        "        exp_graph = VMobject()\n",
        "        exp_graph.set_stroke(PINK, 2)\n",
        "\n",
        "        def update_exp_graph(exp_graph):\n",
        "            s = s_plane.p2n(s_dot.get_center())\n",
        "            anchors = np.array([\n",
        "                out_plane.n2p(np.exp(s * t))\n",
        "                for t in np.arange(0, 100, 0.1)\n",
        "            ])\n",
        "            exp_graph.set_points_as_corners(anchors)\n",
        "\n",
        "        exp_graph.add_updater(update_exp_graph)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(out_plane),\n",
        "            LaggedStart(*(\n",
        "                exp_diagram.animate.scale(scale_factor).move_to(out_plane.target)\n",
        "                for exp_diagram in exp_diagrams\n",
        "            ), lag_ratio=0.01),\n",
        "            AnimationGroup(*(\n",
        "                ReplacementTransform(solution[t1], compact_equation[t2])\n",
        "                for t1, t2 in [\n",
        "                    (\"x(t) = \", \"x(t) = \"),\n",
        "                    (re.compile(r'c_\\w+'), \"c_n\"),\n",
        "                    (re.compile(r's_\\w+'), \"s_n\"),\n",
        "                    (\"e\", \"e\"),\n",
        "                    (\"t\", \"t\"),\n",
        "                    (\"+\", R\"\\sum_{n=1}^{N}\"),\n",
        "                ]\n",
        "            )),\n",
        "            lag_ratio=0.2,\n",
        "            run_time=2\n",
        "        ))\n",
        "        exp_graph.update()\n",
        "        self.play(\n",
        "            FadeIn(s_plane),\n",
        "            TransformFromCopy(compact_equation[\"s_n\"][0], s_label),\n",
        "            FadeTransform(compact_equation[\"s_n\"][0].copy(), s_dot),\n",
        "            Write(s_plane_title),\n",
        "            FadeOut(exp_diagrams[2]),\n",
        "            FadeIn(exp_graph, suspend_mobject_updating=True),\n",
        "            compact_equation_start.animate.set_opacity(0.4)\n",
        "        )\n",
        "        self.remove(exp_diagrams)\n",
        "        self.wait()\n",
        "\n",
        "        # Growth, decay and oscillation\n",
        "        arrows = VGroup(\n",
        "            Arrow(s_plane.n2p(0), s_plane.n2p(z), thickness=4, fill_color=GREY_A)\n",
        "            for z in [2, -2, 2j, -2j]\n",
        "        )\n",
        "        arrows.set_fill(GREY_A, 1)\n",
        "        arrow_labels = VGroup(\n",
        "            Text(\"Growth\", font_size=36).next_to(arrows[0], UP, buff=0),\n",
        "            Text(\"Decay\", font_size=36).next_to(arrows[1], UP, buff=0),\n",
        "            Text(\"Oscillation\", font_size=36).rotate(-90 * DEG).next_to(arrows[3], RIGHT, buff=SMALL_BUFF),\n",
        "        )\n",
        "        rot_vect = Vector(2 * RIGHT, fill_color=RED, thickness=5)\n",
        "        rot_vect.shift(out_plane.n2p(0) - rot_vect.get_start())\n",
        "        rot_vect.rotate(-45 * DEG, about_point=out_plane.n2p(0))\n",
        "        rot_vect.add_updater(lambda m, dt: m.rotate(2 * dt, about_point=out_plane.n2p(0)))\n",
        "\n",
        "        self.play(\n",
        "            s_dot.animate.shift(0.2 * RIGHT).set_anim_args(run_time=1),\n",
        "            GrowArrow(arrows[0]),\n",
        "            FadeIn(arrow_labels[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            s_dot.animate.shift(0.2 * LEFT).set_anim_args(run_time=1),\n",
        "            GrowArrow(arrows[1]),\n",
        "            FadeIn(arrow_labels[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            # s_dot.animate.shift(3 * DOWN).set_anim_args(run_time=4, rate_func=there_and_back),\n",
        "            GrowArrow(arrows[2]),\n",
        "            GrowArrow(arrows[3]),\n",
        "            FadeIn(arrow_labels[2]),\n",
        "            VFadeIn(rot_vect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(VFadeOut(rot_vect))\n",
        "\n",
        "        # Show multiple s\n",
        "        frame = self.frame\n",
        "        s_values[:2] = [-1.5 + 0.5j, -1.5 - 0.5j]\n",
        "        s_values.extend([-0.8 + 1.5j, -0.8 - 1.5j])\n",
        "        s_dots = Group(GlowDot(s_plane.n2p(s)) for s in s_values)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(arrow_labels),\n",
        "            FadeOut(out_plane),\n",
        "            FadeOut(exp_graph),\n",
        "            FadeIn(s_dots, lag_ratio=0.5),\n",
        "            FadeOut(s_dot),\n",
        "            FadeOut(s_label),\n",
        "            compact_equation.animate.set_height(2.0).set_opacity(1).next_to(s_plane, RIGHT, LARGE_BUFF),\n",
        "            frame.animate.match_y(s_plane),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Infinite\n",
        "        inf = Tex(R\"\\infty\", font_size=60)\n",
        "        N = compact_equation[\"N\"][0]\n",
        "        inf.move_to(N)\n",
        "\n",
        "        dot_line = Group(\n",
        "            GlowDot(s_plane.n2p(complex(-0.5, b)))\n",
        "            for b in np.linspace(-2, 2, 25)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(N, time_width=1),\n",
        "            # Transform(N, inf, path_arc=20 * DEG),\n",
        "            FadeTransform(N, inf, path_arc=20 * DEG),\n",
        "            ShowIncreasingSubsets(dot_line, run_time=5, rate_func=linear),\n",
        "            ReplacementTransform(s_dots, dot_line[:len(s_dots)].copy().set_opacity(0))\n",
        "        )\n",
        "\n",
        "        # Continuous range\n",
        "        integral_eq = Tex(\n",
        "            R\"x(t) = \\int_{\\gamma} c(s) e^{st} ds\",\n",
        "            t2c={\"s\": YELLOW, R\"\\gamma\": YELLOW}\n",
        "        )\n",
        "        integral_eq.replace(compact_equation, dim_to_match=1)\n",
        "        integral_eq.shift(0.5 * RIGHT)\n",
        "        line = Line(dot_line.get_bottom(), dot_line.get_top())\n",
        "        line.set_stroke(YELLOW, 2)\n",
        "        thick_line = line.copy().set_stroke(width=6)\n",
        "        thick_line.insert_n_curves(100)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(compact_equation[t1], integral_eq[t2])\n",
        "                for t1, t2 in [\n",
        "                    (\"x(t) = \", \"x(t) =\"),\n",
        "                    (R\"\\sum_{n=1}^{N}\", R\"\\int_{\\gamma}\"),\n",
        "                    (R\"n=1\", R\"\\gamma\"),\n",
        "                    (\"c_n\", \"c(s)\"),\n",
        "                    (R\"e^{{s_n} t}\", R\"e^{st}\"),\n",
        "                ]\n",
        "            )),\n",
        "            FadeIn(integral_eq[R\"ds\"]),\n",
        "            LaggedStartMap(FadeOut, dot_line, lag_ratio=0.5, scale=0.25, time_span=(0.3, 2)),\n",
        "            VShowPassingFlash(thick_line, run_time=2),\n",
        "            ShowCreation(line, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Thumbnail(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Spiral\n",
        "        spiral_color = TEAL\n",
        "        s = -0.15 + 2j\n",
        "        max_t = 3\n",
        "        thick_stroke_width = (5, 25)\n",
        "\n",
        "        plane = ComplexPlane(\n",
        "            (-4, 4),\n",
        "            (-2, 2)\n",
        "        )\n",
        "        plane.set_height(11)\n",
        "        plane.center()\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "\n",
        "        plane.axes.set_stroke(WHITE, 5)\n",
        "        plane.background_lines.set_stroke(BLUE, 3)\n",
        "        plane.faded_lines.set_stroke(BLUE, 2, 0.25)\n",
        "\n",
        "        curve = ParametricCurve(\n",
        "            lambda t: plane.n2p(np.exp(s * t)),\n",
        "            t_range=(0, 40, 0.1)\n",
        "        )\n",
        "        partial_curve = ParametricCurve(\n",
        "            lambda t: plane.n2p(np.exp(s * t)),\n",
        "            t_range=(0, max_t, 0.1)\n",
        "        )\n",
        "        curve.set_stroke(spiral_color, 2, 0.5)\n",
        "        partial_curve.set_stroke(spiral_color, width=thick_stroke_width, opacity=(0.5, 1))\n",
        "\n",
        "        dot = Group(TrueDot(radius=0.2), GlowDot(radius=0.75))\n",
        "        dot.set_color(spiral_color)\n",
        "        dot.move_to(partial_curve.get_end())\n",
        "\n",
        "        self.add(plane, curve)\n",
        "        self.add(partial_curve)\n",
        "        self.add(dot)\n",
        "\n",
        "        vectors = VGroup(\n",
        "            self.get_vector(plane, s, t, color=BLUE)\n",
        "            for t in np.linspace(0, max_t, 10)\n",
        "        )\n",
        "        self.add(vectors)\n",
        "\n",
        "    def get_vector(self, plane, s, t, scale_factor=0.5, thickness=5, color=YELLOW):\n",
        "        vect = Vector(RIGHT, thickness=thickness, fill_color=color)\n",
        "        vect.put_start_and_end_on(plane.n2p(0), scale_factor * plane.n2p(s * np.exp(s * t)))\n",
        "        vect.shift(plane.n2p(np.exp(s * t)) - plane.n2p(0))\n",
        "        return vect\n",
        "\n",
        "    def get_formula(self):\n",
        "        # Formula\n",
        "        formula = Tex(R\"e^{st}\", t2c={\"s\": YELLOW, \"t\": BLUE}, font_size=200)\n",
        "        formula.next_to(plane, LEFT, buff=2.0)\n",
        "\n",
        "        s_rect = SurroundingRectangle(formula[\"s\"], buff=0.1)\n",
        "        s_rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        abi = Tex(\"a + bi\", font_size=72)\n",
        "        abi.next_to(formula, UP, LARGE_BUFF)\n",
        "        abi.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        arrow = Arrow(s_rect.get_top(), abi.get_corner(DR), buff=0.05)\n",
        "\n",
        "        self.add(formula)\n",
        "        self.add(s_rect)\n",
        "        self.add(arrow)\n",
        "        self.add(abi)\n",
        "\n",
        "\n",
        "class Thumbnail2(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        theta = 140 * DEG\n",
        "        z = np.exp(theta * 1j)\n",
        "\n",
        "        plane_color = BLUE\n",
        "        path_color = YELLOW\n",
        "        vect_color = WHITE\n",
        "\n",
        "        plane = ComplexPlane(\n",
        "            (-4, 4),\n",
        "            (-2, 2)\n",
        "        )\n",
        "        plane.set_height(10)\n",
        "        plane.center()\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "        plane.axes.set_stroke(WHITE, 3)\n",
        "        plane.background_lines.set_stroke(plane_color, 4)\n",
        "        plane.faded_lines.set_stroke(plane_color, 3, 0.35)\n",
        "\n",
        "        unit_size = plane.x_axis.get_unit_size()\n",
        "\n",
        "        arrow = Arrow(\n",
        "            plane.n2p(1),\n",
        "            plane.n2p(z),\n",
        "            buff=0,\n",
        "            path_arc=theta,\n",
        "            thickness=12,\n",
        "            fill_color=YELLOW,\n",
        "        )\n",
        "        arrow.scale(0.965, about_point=plane.n2p(1))\n",
        "        arrow.set_fill(border_width=3)\n",
        "\n",
        "        path = Arc(0, theta, radius=unit_size)\n",
        "        path.set_stroke(path_color, width=(2, 30))\n",
        "        dot = Group(TrueDot(radius=0.2), GlowDot(radius=0.75))\n",
        "        dot.set_color(path_color)\n",
        "        dot.move_to(path.get_end())\n",
        "\n",
        "        n_vects = 8\n",
        "        vectors = VGroup(\n",
        "            Vector(2.5 * UP, thickness=8).set_fill(vect_color, opacity**2).put_start_on(plane.n2p(1)).rotate(phi, about_point=plane.n2p(0))\n",
        "            for phi, opacity in zip(np.linspace(0, theta, n_vects), np.linspace(0.5, 1, n_vects))\n",
        "        )\n",
        "        vectors.set_fill(border_width=3)\n",
        "\n",
        "        circle = Circle(radius=unit_size)\n",
        "        circle.set_stroke(GREY, 5)\n",
        "\n",
        "        d_line = DashedLine(plane.n2p(0), plane.n2p(z))\n",
        "        d_line.set_stroke(WHITE, 3)\n",
        "        arc = Arc(0, theta, radius=0.5)\n",
        "        arc.set_stroke(WHITE, 5)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=72)\n",
        "        theta_label.next_to(arc.pfp(0.5), UR, SMALL_BUFF)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(circle)\n",
        "        self.add(d_line)\n",
        "        self.add(vectors)\n",
        "        self.add(path)\n",
        "        self.add(dot)\n",
        "        self.add(arc)\n",
        "        self.add(theta_label)\n",
        "\n",
        "\n",
        "### For Main Laplace video\n",
        "\n",
        "\n",
        "class RecapSPlane(SPlane):\n",
        "    def construct(self):\n",
        "        # Trackers\n",
        "        s_tracker = self.s_tracker = ComplexValueTracker(-1)\n",
        "        t_tracker = self.t_tracker = ValueTracker(0)\n",
        "        get_s = s_tracker.get_value\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        # Add s plane\n",
        "        s_plane = self.get_s_plane()\n",
        "        s_dot, s_label = self.get_s_dot_and_label(s_plane, get_s)\n",
        "        self.add(s_plane, s_dot, s_label)\n",
        "\n",
        "        # Add exp plane\n",
        "        exp_plane = self.get_exp_plane()\n",
        "        exp_plane_label = self.get_exp_plane_label(exp_plane)\n",
        "        output_dot, output_label = self.get_output_dot_and_label(exp_plane, get_s, get_t)\n",
        "        output_path = self.get_output_path(exp_plane, get_t, get_s)\n",
        "        output_path.set_clip_plane(RIGHT, -s_plane.get_x(RIGHT))\n",
        "\n",
        "        max_t = 50\n",
        "        output_path_preview = self.get_output_path(exp_plane, lambda: max_t, get_s)\n",
        "        output_path_preview.set_stroke(opacity=0.5)\n",
        "        for path in [output_path, output_path_preview]:\n",
        "            path.set_clip_plane(RIGHT, -s_plane.get_x(RIGHT))\n",
        "\n",
        "        self.add(exp_plane, exp_plane_label, output_path_preview, output_path, output_dot, output_label)\n",
        "\n",
        "        # Add e^{st} graph\n",
        "        axes = self.get_graph_axes()\n",
        "        axes.x_axis.scale(0.5, 0, about_edge=LEFT)\n",
        "        graph = self.get_dynamic_exp_graph(axes, get_s)\n",
        "        v_line = self.get_graph_v_line(axes, get_t, get_s)\n",
        "        graph.set_clip_plane(UP, -axes.get_y(DOWN))\n",
        "        v_line.set_clip_plane(UP, -axes.get_y(DOWN))\n",
        "        axes_background = BackgroundRectangle(axes)\n",
        "        axes_background.set_fill(BLACK, 1)\n",
        "        axes_background.align_to(s_plane.get_right(), LEFT).shift(1e-2 * RIGHT)\n",
        "        axes_background.stretch(1.2, 1, about_edge=DOWN)\n",
        "\n",
        "        self.add(axes_background, axes, graph, v_line)\n",
        "\n",
        "        # Pre-preamble\n",
        "        s_tracker.set_value(-0.3)\n",
        "        self.play(s_tracker.animate.increment_value(1.5j), run_time=4)\n",
        "        self.play(t_tracker.animate.set_value(TAU / 1.5), run_time=5, rate_func=linear)\n",
        "        self.play(s_tracker.animate.set_value(1.5j), run_time=3)\n",
        "        t_tracker.set_value(0)\n",
        "\n",
        "        # Play around\n",
        "        s_tracker.set_value(0)\n",
        "        self.play(s_tracker.animate.increment_value(1.5j), run_time=4)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.add(t_tracker)\n",
        "        self.wait(4.5)\n",
        "        self.play(s_tracker.animate.increment_value(-0.2))\n",
        "        self.wait(2)\n",
        "        for step in [-0.8, 1.2, -0.4]:\n",
        "            self.play(s_tracker.animate.increment_value(step), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DefineSPlane(SPlane):\n",
        "    def construct(self):\n",
        "        # Trackers\n",
        "        s_tracker = self.s_tracker = ComplexValueTracker(-1)\n",
        "        t_tracker = self.t_tracker = ValueTracker(0)\n",
        "        get_s = s_tracker.get_value\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        # Add s plane\n",
        "        s_plane = self.get_s_plane()\n",
        "        s_dot, s_label = self.get_s_dot_and_label(s_plane, get_s)\n",
        "        self.add(s_plane, s_dot, s_label)\n",
        "\n",
        "        # Add exp plane\n",
        "        exp_plane = self.get_exp_plane()\n",
        "        exp_plane_label = self.get_exp_plane_label(exp_plane)\n",
        "        output_dot, output_label = self.get_output_dot_and_label(exp_plane, get_s, get_t)\n",
        "        output_path = self.get_output_path(exp_plane, get_t, get_s)\n",
        "        output_path.set_clip_plane(RIGHT, -s_plane.get_x(RIGHT))\n",
        "\n",
        "        max_t = 50\n",
        "        output_path_preview = self.get_output_path(exp_plane, lambda: max_t, get_s)\n",
        "        output_path_preview.set_stroke(opacity=0.5)\n",
        "        for path in [output_path, output_path_preview]:\n",
        "            path.set_clip_plane(RIGHT, -s_plane.get_x(RIGHT))\n",
        "\n",
        "        self.add(exp_plane, exp_plane_label, output_path_preview, output_path, output_dot, output_label)\n",
        "\n",
        "        # Add e^{st} graph\n",
        "        axes = self.get_graph_axes()\n",
        "        axes.x_axis.scale(0.5, 0, about_edge=LEFT)\n",
        "        graph = self.get_dynamic_exp_graph(axes, get_s)\n",
        "        v_line = self.get_graph_v_line(axes, get_t, get_s)\n",
        "        graph.set_clip_plane(UP, -axes.get_y(DOWN))\n",
        "        v_line.set_clip_plane(UP, -axes.get_y(DOWN))\n",
        "        axes_background = BackgroundRectangle(axes)\n",
        "        axes_background.set_fill(BLACK, 1)\n",
        "        axes_background.align_to(s_plane.get_right(), LEFT).shift(1e-2 * RIGHT)\n",
        "        axes_background.stretch(1.2, 1, about_edge=DOWN)\n",
        "\n",
        "        self.add(axes_background, axes, graph, v_line)\n",
        "\n",
        "        # Go!\n",
        "        t_tracker.clear_updaters()\n",
        "        t_tracker.set_value(0)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.add(t_tracker)\n",
        "        s_tracker.set_value(0)\n",
        "        self.play(s_tracker.animate.set_value(-0.1 + 1.5j), run_time=3)\n",
        "        self.wait(3)\n",
        "\n",
        "        # Name the plane\n",
        "        frame = self.frame\n",
        "        s_plane_name = Text(\"S-plane\", font_size=90)\n",
        "        s_plane_name.next_to(s_plane, UP)\n",
        "        s_plane_name.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (0.49, 0.34, 0.0), 9.65).set_anim_args(time_span=(0, 2)),\n",
        "            FlashAround(s_plane, time_width=1.5, buff=MED_SMALL_BUFF, stroke_width=5),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(s_tracker.animate.set_value(-0.2 - 1j), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(Write(s_plane_name))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show exp pieces\n",
        "        s_samples = [complex(a, b) for a in range(-2, 3) for b in range(-2, 3)]\n",
        "        exp_pieces = VGroup(\n",
        "            get_exp_graph_icon(s).move_to(s_plane.n2p(0.85 * s))\n",
        "            for s in s_samples\n",
        "        )\n",
        "\n",
        "        dots = VGroup(Dot(radius=0.1).move_to(piece) for piece in exp_pieces)\n",
        "        dots.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, dots, scale=5, lag_ratio=0.05, run_time=2),\n",
        "            VFadeOut(output_label),\n",
        "            FadeOut(output_dot),\n",
        "            VFadeOut(s_label),\n",
        "            FadeOut(s_dot),\n",
        "        )\n",
        "        t_tracker.clear_updaters()\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            (FadeTransform(dot, piece)\n",
        "            for dot, piece in zip(dots, exp_pieces)),\n",
        "            lag_ratio=0.05,\n",
        "            run_time=3,\n",
        "            group_type=Group,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Associate with complex\n",
        "        rect = SurroundingRectangle(exp_pieces[6], buff=SMALL_BUFF)\n",
        "        rect.set_stroke(TEAL, 3)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.surround(VGroup(exp_plane, exp_plane_label)))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "        # Go through imaginary partsg\n",
        "        rows = VGroup(exp_pieces[n::5] for n in range(0, 5))\n",
        "        for row in rows:\n",
        "            row.save_state()\n",
        "        self.play(rows.animate.fade(0.7))\n",
        "        self.play(Restore(rows[2]))\n",
        "        self.play(\n",
        "            rows[2].animate.fade(0.7),\n",
        "            Restore(rows[1]),\n",
        "            Restore(rows[3]),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(rows[0]),\n",
        "            Restore(rows[4]),\n",
        "            rows[1].animate.fade(0.7),\n",
        "            rows[3].animate.fade(0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*(Restore(row) for row in rows))\n",
        "\n",
        "        # Show columns\n",
        "        cols = VGroup(exp_pieces[n:n + 5] for n in range(0, 25, 5))\n",
        "        for col in cols:\n",
        "            col.save_state()\n",
        "        last = VectorizedPoint()\n",
        "        self.play(cols.animate.fade(0.7))\n",
        "        for col in cols:\n",
        "            self.play(\n",
        "                last.animate.fade(0.7),\n",
        "                Restore(col),\n",
        "            )\n",
        "            last = col\n",
        "\n",
        "        self.play(*(Restore(col) for col in cols))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BreakingDownCosine(ShowFamilyOfComplexSolutions):\n",
        "    tex_to_color_map = {\"+i\": YELLOW, \"-i\": YELLOW}\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up various planes\n",
        "        left_planes, left_plane_labels = self.get_left_planes(label_texs=[R\"e^{+it}\", R\"e^{-it}\"])\n",
        "        rot_vects, tails, t_tracker = self.get_rot_vects(left_planes)\n",
        "\n",
        "        right_plane = self.get_right_plane(x_range=(-2, 2))\n",
        "        right_plane.next_to(left_planes, RIGHT, buff=2.0)\n",
        "        right_plane.add_coordinate_labels(font_size=16)\n",
        "        vect_sum = self.get_rot_vect_sum(right_plane, t_tracker)\n",
        "        for vect in vect_sum:\n",
        "            vect.coef_tracker.set_value(0.5)\n",
        "\n",
        "        output_dot = Group(TrueDot(), GlowDot()).set_color(YELLOW)\n",
        "        output_dot.f_always.move_to(vect_sum[1].get_end)\n",
        "\n",
        "        self.add(t_tracker)\n",
        "        self.add(left_planes, left_plane_labels)\n",
        "        self.add(rot_vects, tails, t_tracker)\n",
        "\n",
        "        self.add(right_plane)\n",
        "        self.add(vect_sum)\n",
        "        self.add(output_dot)\n",
        "        self.wait(12)\n",
        "\n",
        "        # Show each part\n",
        "        for vect in vect_sum:\n",
        "            vect.coef_tracker.set_value(1)\n",
        "\n",
        "        inner_arrows = VGroup(Arrow(2 * v, v, buff=0) for v in compass_directions(8))\n",
        "        inner_arrows.set_fill(YELLOW)\n",
        "        inner_arrows.move_to(right_plane)\n",
        "\n",
        "        self.remove(vect_sum, output_dot)\n",
        "        for i in [0, 1]:\n",
        "            # self.play(ReplacementTransform(rot_vects[i].copy().clear_updaters(), vect_sum[i]))\n",
        "            self.play(TransformFromCopy(rot_vects[i], vect_sum[i], suspend_mobject_updating=True))\n",
        "            self.wait(3)\n",
        "\n",
        "        self.wait(15)\n",
        "        self.play(\n",
        "            *(vs.coef_tracker.animate.set_value(0.5) for vs in vect_sum),\n",
        "            LaggedStartMap(GrowArrow, inner_arrows, lag_ratio=1e-2, run_time=1)\n",
        "        )\n",
        "        self.play(FadeOut(inner_arrows))\n",
        "        self.wait(12)\n"
    ]
}