{
    "topic": "The mathematical concept being demonstrated is the behavior of a photon passing through a polarization filter. The",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from tqdm import tqdm as ProgressDisplay\n",
        "\n",
        "from .waves import *\n",
        "from functools import reduce\n",
        "\n",
        "#force_skipping\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "class PhotonPassesCompletelyOrNotAtAll(DirectionOfPolarizationScene):\n",
        "    CONFIG = {\n",
        "        \"pol_filter_configs\" : [{\n",
        "            \"include_arrow_label\" : False,\n",
        "            \"label_tex\" : \"\\\\text{Filter}\",\n",
        "        }],\n",
        "        \"EMWave_config\" : {\n",
        "            \"wave_number\" : 0,\n",
        "            \"A_vect\" : [0, 1, 1],\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT + DOWN + 1.5*OUT,\n",
        "        },\n",
        "        \"start_theta\" : -0.9*np.pi,\n",
        "        \"target_theta\" : -0.6*np.pi,\n",
        "        \"apply_filter\" : True,\n",
        "        \"lower_portion_shift\" : 3*IN,\n",
        "        \"show_M_vects\" : True,\n",
        "    }\n",
        "    def setup(self):\n",
        "        DirectionOfPolarizationScene.setup(self)\n",
        "        if not self.show_M_vects:\n",
        "            for M_vect in self.em_wave.M_vects:\n",
        "                M_vect.set_fill(opacity = 0)\n",
        "        self.update_mobjects()\n",
        "        for vect in it.chain(self.em_wave.E_vects, self.em_wave.M_vects):\n",
        "            vect.reset_normal_vector()\n",
        "        self.remove(self.em_wave)\n",
        "\n",
        "    def construct(self):\n",
        "        pol_filter = self.pol_filter\n",
        "        pol_filter.shift(0.5*OUT)\n",
        "        lower_filter = pol_filter.copy()\n",
        "        lower_filter.save_state()\n",
        "        pol_filter.remove(pol_filter.label)\n",
        "\n",
        "        passing_words = OldTexText(\"Photon\", \"passes through\\\\\\\\\", \"entirely\")\n",
        "        passing_words.set_color(GREEN)\n",
        "        filtered_words = OldTexText(\"Photon\", \"is blocked\\\\\\\\\", \"entirely\")\n",
        "        filtered_words.set_color(RED)\n",
        "        for words in passing_words, filtered_words:\n",
        "            words.next_to(ORIGIN, UP+LEFT)\n",
        "            words.shift(2*UP)\n",
        "            words.add_background_rectangle()\n",
        "            words.rotate(np.pi/2, RIGHT)\n",
        "        filtered_words.shift(self.lower_portion_shift)\n",
        "\n",
        "        passing_photon = WavePacket(\n",
        "            run_time = 2,\n",
        "            get_filtered = False,\n",
        "            em_wave = self.em_wave.copy()\n",
        "        )\n",
        "        lower_em_wave = self.em_wave.copy()\n",
        "        lower_em_wave.mobject.shift(self.lower_portion_shift)\n",
        "        lower_em_wave.start_point += self.lower_portion_shift\n",
        "        filtered_photon = WavePacket(\n",
        "            run_time = 2,\n",
        "            get_filtered = True,\n",
        "            em_wave = lower_em_wave.copy()\n",
        "        )\n",
        "        green_flash = ApplyMethod(\n",
        "            pol_filter.set_fill, GREEN,\n",
        "            rate_func = squish_rate_func(there_and_back, 0.4, 0.6),\n",
        "            run_time = passing_photon.run_time\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(pol_filter),\n",
        "            Write(pol_filter.label, run_time = 2),\n",
        "        )\n",
        "        self.move_camera(theta = self.target_theta)\n",
        "        self.play(\n",
        "            FadeIn(passing_words),\n",
        "            passing_photon,\n",
        "            green_flash,\n",
        "        )\n",
        "        self.play(\n",
        "            lower_filter.restore,\n",
        "            lower_filter.shift, self.lower_portion_shift,\n",
        "            FadeIn(filtered_words)\n",
        "        )\n",
        "        red_flash = ApplyMethod(\n",
        "            lower_filter.set_fill, RED,\n",
        "            rate_func = squish_rate_func(there_and_back, 0.4, 0.6),\n",
        "            run_time = filtered_photon.run_time\n",
        "        )\n",
        "        for x in range(4):\n",
        "            self.play(\n",
        "                passing_photon,\n",
        "                filtered_photon,\n",
        "                green_flash,\n",
        "                red_flash,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class PhotonPassesCompletelyOrNotAtAllForWavesVideo(PhotonPassesCompletelyOrNotAtAll):\n",
        "    CONFIG = {\n",
        "        \"show_M_vects\" : False,\n",
        "    }    \n",
        "\n",
        "class DirectionOfPolarization(DirectionOfPolarizationScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.pol_filter)\n",
        "        self.axes.z_axis.rotate(np.pi/2, OUT)\n",
        "        words = OldTexText(\"Polarization direction\")\n",
        "        words.next_to(ORIGIN, UP+RIGHT, LARGE_BUFF)\n",
        "        words.shift(2*UP)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "        words.rotate(-np.pi/2, OUT)\n",
        "\n",
        "        em_wave = self.em_wave\n",
        "\n",
        "        self.add(em_wave)\n",
        "        self.wait(2)\n",
        "        self.move_camera(\n",
        "            phi = self.target_phi,\n",
        "            theta = self.target_theta\n",
        "        )\n",
        "        self.play(Write(words, run_time = 1))\n",
        "        for angle in 2*np.pi/3, -np.pi/3, np.pi/4:\n",
        "            self.change_polarization_direction(angle)\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "class PhotonsThroughPerpendicularFilters(PhotonPassesCompletelyOrNotAtAll):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [-2, 2],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : 0},\n",
        "            {\"filter_angle\" : np.pi/2},\n",
        "        ],\n",
        "        \"start_theta\" : -0.9*np.pi,\n",
        "        \"target_theta\" : -0.6*np.pi,\n",
        "        \"EMWave_config\" : {\n",
        "            \"A_vect\" : [0, 0, 1],\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT + DOWN + OUT,\n",
        "        },\n",
        "        \"apply_filter\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        photons = self.get_photons()\n",
        "        prob_text = self.get_probability_text()\n",
        "        self.pol_filters = VGroup(*reversed(self.pol_filters))\n",
        "        ninety_filter, zero_filter = self.pol_filters\n",
        "        self.remove(*self.pol_filters)\n",
        "\n",
        "        self.play(DrawBorderThenFill(zero_filter), run_time = 1)\n",
        "        self.add_foreground_mobject(zero_filter)\n",
        "        self.move_camera(\n",
        "            theta = self.target_theta,\n",
        "            added_anims = [ApplyFunction(\n",
        "                self.reposition_filter_label,\n",
        "                zero_filter\n",
        "            )]\n",
        "        )\n",
        "        self.reposition_filter_label(ninety_filter)\n",
        "        self.play(self.get_photons()[2])\n",
        "        self.play(FadeIn(ninety_filter))\n",
        "        self.add_foreground_mobject(ninety_filter)\n",
        "        self.shoot_photon()\n",
        "        self.shoot_photon()\n",
        "        self.play(FadeIn(prob_text))\n",
        "        for x in range(6):\n",
        "            self.shoot_photon()\n",
        "\n",
        "    def reposition_filter_label(self, pf):\n",
        "        pf.arrow_label.rotate(np.pi/2, OUT)\n",
        "        pf.arrow_label.next_to(pf.arrow, RIGHT)\n",
        "        return pf\n",
        "\n",
        "\n",
        "    def shoot_photon(self, *added_anims):\n",
        "        photon = self.get_photons()[1]\n",
        "        pol_filter = self.pol_filters[0]\n",
        "        absorption = self.get_filter_absorption_animation(pol_filter, photon)\n",
        "        self.play(photon, absorption)\n",
        "\n",
        "\n",
        "    def get_photons(self):\n",
        "        self.reference_line.rotate(np.pi/4)\n",
        "        self.update_mobjects()\n",
        "        return [\n",
        "            WavePacket(\n",
        "                filter_distance = FRAME_X_RADIUS + x,\n",
        "                get_filtered = True,\n",
        "                em_wave = self.em_wave.copy(),\n",
        "                run_time = 1,\n",
        "            )\n",
        "            for x in (-2, 2, 10)\n",
        "        ]\n",
        "\n",
        "    def get_probability_text(self, prob = 0):\n",
        "        prob_text = OldTex(\n",
        "            \"P(\", \"\\\\substack\", \"{\\\\text{photons that make it} \\\\\\\\ \", \n",
        "            \" \\\\text{here } \", \"\\\\text{make it}\", \n",
        "            \" \\\\text{ here} }\", \")\", \"=\", str(int(prob*100)), \"\\\\%\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        here1, here2 = prob_text.get_parts_by_tex(\"here\")\n",
        "        here1.set_color(GREEN)\n",
        "        here2.set_color(RED)\n",
        "        prob_text.add_background_rectangle()\n",
        "        prob_text.next_to(ORIGIN, UP+RIGHT)\n",
        "        prob_text.shift(2.5*UP+LEFT)\n",
        "        prob_text.rotate(np.pi/2, RIGHT)\n",
        "        arrows = [\n",
        "            Arrow(\n",
        "                here.get_edge_center(IN),\n",
        "                DOWN+OUT + x*RIGHT,\n",
        "                color = here.get_color(),\n",
        "                normal_vector = DOWN+OUT,\n",
        "            )\n",
        "            for here, x in ((here1, 0), (here2, 4))\n",
        "        ]\n",
        "        prob_text.add(*arrows)\n",
        "\n",
        "        return prob_text\n",
        "\n",
        "class MoreFiltersMoreLight(FilterScene):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : list(range(-2, 3)),\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\n",
        "                \"include_arrow_label\" : False,\n",
        "                \"filter_angle\" : angle\n",
        "            }\n",
        "            for angle in np.linspace(0, np.pi/2, 5)\n",
        "        ],\n",
        "        \"ambient_rotation_rate\" : 0,\n",
        "        \"arrow_rgb\" : (0, 0, 0),\n",
        "        \"background_rgb\" : (245, 245, 245), \n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.axes)\n",
        "        pfs = VGroup(*reversed(self.pol_filters))\n",
        "        self.color_filters(pfs)\n",
        "        self.remove(pfs)\n",
        "        self.build_color_map(pfs)\n",
        "        self.add(pfs[0], pfs[2], pfs[4])\n",
        "        pfs.center().scale(1.5)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi = 0.9*np.pi/2,\n",
        "            theta = -0.95*np.pi,\n",
        "        )\n",
        "        self.play(\n",
        "            Animation(pfs[0]),\n",
        "            pfs[2].shift, 3*OUT,\n",
        "            Animation(pfs[4]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Animation(pfs[0]),\n",
        "            pfs[2].shift, 3*IN,\n",
        "            Animation(pfs[4]),\n",
        "        )\n",
        "\n",
        "        pfs[1].shift(8*OUT)\n",
        "        self.play(\n",
        "            Animation(pfs[0]),\n",
        "            pfs[1].shift, 8*IN,\n",
        "            Animation(VGroup(pfs[2], pfs[4])),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pfs[3].shift(8*OUT)\n",
        "        self.play(\n",
        "            Animation(VGroup(*pfs[:3])),\n",
        "            pfs[3].shift, 8*IN,\n",
        "            Animation(VGroup(*pfs[4:])),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def color_filters(self, pfs):\n",
        "        colors = [RED, GREEN, BLUE, MAROON_B, PURPLE_C]\n",
        "        for pf, color in zip(pfs, colors):\n",
        "            pf.set_fill(color, 0.5)\n",
        "            pf.arrow.set_fill(WHITE, 1)\n",
        "        turn_off_3d_shading(pfs)\n",
        "\n",
        "    def build_color_map(self, pfs):\n",
        "        phi, theta = self.camera.get_phi(), self.camera.get_theta()\n",
        "        self.set_camera_orientation(np.pi/2, -np.pi)\n",
        "\n",
        "        self.original_rgbas = [(255, 255, 255)]\n",
        "        self.new_rgbas = [self.arrow_rgb]\n",
        "        for bool_array in it.product(*5*[[True, False]]):\n",
        "            pfs_to_use = VGroup(*[\n",
        "                pf\n",
        "                for pf, b in zip(pfs, bool_array)\n",
        "                if b\n",
        "            ])\n",
        "            self.camera.capture_mobject(pfs_to_use)\n",
        "            frame = self.camera.get_image()\n",
        "            h, w, three = frame.shape\n",
        "            rgb = frame[3*h/8, 7*w/12]\n",
        "            self.original_rgbas.append(rgb)\n",
        "\n",
        "            angles = [pf.filter_angle for pf in pfs_to_use]\n",
        "            p = 0.5\n",
        "            for a1, a2 in zip(angles, angles[1:]):\n",
        "                p *= np.cos(a2 - a1)**2\n",
        "            new_rgb = (255*p*np.ones(3)).astype(int)\n",
        "            if not any(bool_array):\n",
        "                new_rgb = self.background_rgb\n",
        "\n",
        "            self.new_rgbas.append(new_rgb)\n",
        "            self.camera.reset()\n",
        "        self.set_camera_orientation(phi, theta)\n",
        "\n",
        "    def update_frame(self, mobjects = None, image = None):\n",
        "        FilterScene.update_frame(self, mobjects)\n",
        "\n",
        "    def get_frame(self):\n",
        "        frame = FilterScene.get_frame(self)\n",
        "        bool_arrays = [\n",
        "            (frame[:,:,0] == r) & (frame[:,:,1] == g) & (frame[:,:,2] == b)\n",
        "            for (r, g, b) in self.original_rgbas\n",
        "        ]\n",
        "        for ba, new_rgb in zip(bool_arrays, self.new_rgbas):\n",
        "            frame[ba] = new_rgb\n",
        "        covered = reduce(\n",
        "            lambda b1, b2 : b1 | b2,\n",
        "            bool_arrays\n",
        "        )\n",
        "        frame[~covered] = [65, 65, 65]\n",
        "        return frame\n",
        "\n",
        "class MoreFiltersMoreLightBlackBackground(MoreFiltersMoreLight):\n",
        "    CONFIG = {\n",
        "        \"arrow_rgb\" : (255, 255, 255),\n",
        "        \"background_rgb\" : (0, 0, 0),    \n",
        "    }\n",
        "\n",
        "class ConfusedPiCreature(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        self.play(\n",
        "            randy.change, \"confused\", 3*(UP+RIGHT),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "class AngryPiCreature(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.pi_creature_says(\n",
        "            \"No, \\\\emph{locality} \\\\\\\\ must be wrong!\",\n",
        "            target_mode = \"angry\",\n",
        "            look_at = 2*RIGHT,\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().shift(DOWN+3*LEFT)\n",
        "\n",
        "class ShowALittleMath(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        exp1 = OldTex(\n",
        "            \"|\", \"\\\\psi\", \"\\\\rangle = \",\n",
        "            \"\\\\alpha\", \"|\\\\uparrow\\\\rangle\", \n",
        "            \"+\", \"\\\\beta\", \"|\\\\rightarrow\\\\rangle\"\n",
        "        )\n",
        "        exp2 = OldTex(\n",
        "            \"|| \\\\langle\", \"\\\\psi\", \"|\", \"\\\\psi\", \"\\\\rangle ||^2\",\n",
        "            \"= \", \"\\\\alpha\", \"^2\", \"+\", \"\\\\beta\", \"^2\"\n",
        "        )\n",
        "        color_map = {\n",
        "            \"alpha\" : GREEN,\n",
        "            \"beta\" : RED,\n",
        "            \"psi\" : BLUE\n",
        "        }\n",
        "        for exp in exp1, exp2:\n",
        "            exp.set_color_by_tex_to_color_map(color_map)\n",
        "        exp1.next_to(self.teacher.get_corner(UP+LEFT), UP, LARGE_BUFF)\n",
        "\n",
        "        exp2.move_to(exp1)\n",
        "\n",
        "        self.play(\n",
        "            Write(exp1, run_time = 2),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(exp1.shift, UP)\n",
        "        self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    exp1.get_parts_by_tex(tex).copy(),\n",
        "                    exp2.get_parts_by_tex(tex).copy(),\n",
        "                )\n",
        "                for tex in list(color_map.keys())\n",
        "        ] + [Write(exp2, run_time = 2)])\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = exp2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class SecondVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Some light quantum mechanics\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        screen_rect = ScreenRectangle(height = 6)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class BasicsOfPolarization(DirectionOfPolarizationScene):\n",
        "    CONFIG = {\n",
        "        \"apply_filter\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_rectangles()\n",
        "        self.show_continual_wave()\n",
        "        self.show_photons()\n",
        "\n",
        "    def show_continual_wave(self):\n",
        "        em_wave = self.em_wave\n",
        "\n",
        "        title = OldTexText(\"Waves in the ``electromagnetic field''\")\n",
        "        title.to_edge(UP)\n",
        "        subtitle = OldTexText(\"Polarization = Direction of\", \"wiggling\")\n",
        "        subtitle.set_color_by_tex(\"wiggling\", BLUE)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        for words in title, subtitle:\n",
        "            words.add_background_rectangle()\n",
        "            words.rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(subtitle, run_time = 2),\n",
        "            FadeIn(self.rectangles)\n",
        "        )\n",
        "        self.change_polarization_direction(np.pi/2, run_time = 3)\n",
        "        self.wait()\n",
        "        self.change_polarization_direction(-np.pi/12, run_time = 2)\n",
        "        self.move_camera(theta = -0.95*np.pi)\n",
        "        self.change_polarization_direction(-np.pi/6, run_time = 2)\n",
        "        self.change_polarization_direction(np.pi/6, run_time = 2)\n",
        "        self.move_camera(theta = -0.6*np.pi)\n",
        "        self.change_polarization_direction(-np.pi/6, run_time = 2)\n",
        "        self.change_polarization_direction(np.pi/6, run_time = 2)\n",
        "        self.change_polarization_direction(-5*np.pi/12, run_time = 2)\n",
        "        self.play(\n",
        "            FadeOut(em_wave.mobject),\n",
        "            FadeOut(self.rectangles),\n",
        "        )\n",
        "        self.remove(em_wave)\n",
        "        self.reference_line.put_start_and_end_on(ORIGIN, RIGHT)\n",
        "\n",
        "    def show_photons(self):\n",
        "        quantum_left_words = OldTexText(\n",
        "            \"Quantum\", \"$\\\\Rightarrow$\",\n",
        "        )\n",
        "        quantum_left_words.next_to(ORIGIN, UP+RIGHT)\n",
        "        quantum_left_words.shift(UP)\n",
        "        quantum_right_words = OldTexText(\n",
        "            \"Completely through\", \"or \\\\\\\\\",\n",
        "            \"Completely blocked\",\n",
        "        )\n",
        "        quantum_right_words.scale(0.8)\n",
        "        quantum_right_words.next_to(quantum_left_words, buff = 0)\n",
        "        quantum_right_words.set_color_by_tex(\"through\", GREEN)\n",
        "        quantum_right_words.set_color_by_tex(\"blocked\", RED)\n",
        "        quantum_words = VGroup(quantum_left_words, quantum_right_words)\n",
        "        quantum_words.rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        prob_eq = OldTex(\n",
        "            \"&P(\", \"\\\\text{Pass}\", \")\", \"=\", \"p\\\\\\\\\",\n",
        "            \"&P(\", \"\\\\text{Blocked}\", \")\", \"=\", \"1-p\",\n",
        "        )\n",
        "        prob_eq.set_color_by_tex_to_color_map({\n",
        "            \"Pass\" : GREEN,\n",
        "            \"Blocked\" : RED,\n",
        "        })\n",
        "        prob_eq.next_to(ORIGIN, DOWN+RIGHT)\n",
        "        prob_eq.shift(RIGHT)\n",
        "        prob_eq.rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        config = dict(self.EMWave_config)\n",
        "        config.update({\n",
        "            \"wave_number\" : 0,\n",
        "            \"A_vect\" : [0, 1, -1],\n",
        "        })\n",
        "        self.em_wave = EMWave(**config)\n",
        "        self.update_mobjects()\n",
        "        passing_photon = WavePacket(\n",
        "            em_wave = self.em_wave.copy(),\n",
        "            run_time = 1.5,\n",
        "        )\n",
        "        filtered_photon = WavePacket(\n",
        "            em_wave = self.em_wave.copy(),\n",
        "            get_filtered = True,\n",
        "            run_time = 1.5,\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            quantum_words,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        anim_sets = [\n",
        "            [passing_photon],\n",
        "            [\n",
        "                filtered_photon,\n",
        "                self.get_filter_absorption_animation(\n",
        "                    self.pol_filter,\n",
        "                    filtered_photon\n",
        "                )\n",
        "            ],\n",
        "        ]\n",
        "\n",
        "        for index in 0, 1:\n",
        "            self.play(*anim_sets[index])\n",
        "        self.play(\n",
        "            # FadeIn(prob_eq, lag_ratio = 0.5),\n",
        "            passing_photon\n",
        "        )\n",
        "        for index in 1, 0, 0, 1:\n",
        "            self.play(*anim_sets[index])\n",
        "\n",
        "class AngleToProbabilityChart(Scene):\n",
        "    def construct(self):\n",
        "        left_title = OldTexText(\"Angle between \\\\\\\\ filters\")\n",
        "        left_title.to_corner(UP+LEFT)\n",
        "        right_title = OldTexText(\n",
        "            \"Probability that photons passing \\\\\\\\\",\n",
        "            \"through the first pass through the second\"\n",
        "        )\n",
        "        right_title.next_to(left_title, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.to_edge(UP, buff = 2)\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        v_line.next_to(left_title, RIGHT, MED_LARGE_BUFF)\n",
        "        v_line.to_edge(UP, buff = 0)\n",
        "        VGroup(h_line, v_line).set_color(BLUE)\n",
        "        self.add(left_title, right_title, h_line, v_line)\n",
        "\n",
        "        angles = [0, 22.5, 45, 67.5, 90]\n",
        "        angle_mobs = VGroup(*[\n",
        "            OldTex(str(angle) + \"^\\\\circ\")\n",
        "            for angle in angles\n",
        "        ])\n",
        "        angle_mobs.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        angle_mobs.next_to(left_title, DOWN, LARGE_BUFF)\n",
        "\n",
        "        probs = [\n",
        "            np.cos(angle*np.pi/180.0)**2\n",
        "            for angle in angles\n",
        "        ]\n",
        "        prob_mobs = VGroup(*[\n",
        "            OldTex(\"%.1f\"%(100*prob) + \"\\\\%\")\n",
        "            for prob in probs\n",
        "        ])\n",
        "        prob_mobs.set_color(YELLOW)\n",
        "\n",
        "        angle_prob_pairs = list(zip(angle_mobs, prob_mobs))\n",
        "        for angle_mob, prob_mob in angle_prob_pairs:\n",
        "            prob_mob.next_to(angle_mob, RIGHT, buff = 3)\n",
        "        for prob_mob in prob_mobs[1:]:\n",
        "            prob_mob.align_to(prob_mobs[0], LEFT)\n",
        "\n",
        "\n",
        "        for i in [0, 4, 2, 1, 3]:\n",
        "            self.play(FadeIn(angle_mobs[i]))\n",
        "            self.play(ReplacementTransform(\n",
        "                angle_mobs[i].copy(), prob_mobs[i]\n",
        "            ))\n",
        "\n",
        "        explanation = OldTexText(\"Based on $\\\\cos(\\\\theta)^2$\")\n",
        "        explanation.next_to(prob_mobs, RIGHT, LARGE_BUFF)\n",
        "        self.play(Write(explanation, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "class ShowVariousFilterPairsWithPhotonsOverTime(PhotonsThroughPerpendicularFilters):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [-2, 2, 2, 2, 2],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : angle}\n",
        "            for angle in (0, 0, np.pi/2, np.pi/4, np.pi/8)\n",
        "        ],\n",
        "        \"apply_filter\" : False,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PhotonsThroughPerpendicularFilters.setup(self)\n",
        "        self.new_filters = self.pol_filters[2:]\n",
        "        self.remove(*self.new_filters)\n",
        "        self.pol_filters = self.pol_filters[:2]\n",
        "\n",
        "    def construct(self):\n",
        "        self.photons = self.get_photons()\n",
        "\n",
        "        self.add_filters()\n",
        "        self.add_probability_text()\n",
        "        self.show_photons()\n",
        "        for pol_filter in self.new_filters:\n",
        "            self.change_to_new_filter(pol_filter)\n",
        "            self.show_photons()\n",
        "\n",
        "    def add_filters(self):\n",
        "        self.remove(*self.pol_filters[1:])\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            self.pol_filters[0].copy().set_fill(BLACK, 1),\n",
        "            self.pol_filters[1]\n",
        "        ))\n",
        "        self.move_camera(\n",
        "            theta = -0.65*np.pi,\n",
        "            added_anims = list(it.chain(*[\n",
        "                 [\n",
        "                    pf.arrow_label.rotate, np.pi/2, OUT,\n",
        "                    pf.arrow_label.next_to, pf.arrow, RIGHT\n",
        "                 ]\n",
        "                for pf in self.pol_filters[:2]\n",
        "            ]))\n",
        "        )\n",
        "        for pf in self.new_filters:\n",
        "            pf.arrow_label.rotate(np.pi/2, OUT)\n",
        "            pf.arrow_label.next_to(pf.arrow, RIGHT)\n",
        "\n",
        "        self.second_filter = self.pol_filters[1]\n",
        "        self.add_foreground_mobject(self.second_filter)\n",
        "\n",
        "    def add_probability_text(self):\n",
        "        prob_text = self.get_probability_text(self.get_prob())\n",
        "        self.play(FadeIn(prob_text))\n",
        "        self.prob_text = prob_text\n",
        "\n",
        "    def show_photons(self, n_photons = 5):\n",
        "        p = self.get_prob()\n",
        "        blocked_photon = copy.deepcopy(self.photons[0])\n",
        "        blocked_photon.rate_func = squish_rate_func(\n",
        "            lambda x : x, 0, 0.5,\n",
        "        )\n",
        "        first_absorption = self.get_filter_absorption_animation(\n",
        "            self.pol_filters[0], blocked_photon\n",
        "        )\n",
        "        first_absorption.rate_func = squish_rate_func(\n",
        "            first_absorption.rate_func, 0, 0.5,\n",
        "        )\n",
        "\n",
        "        photons = [\n",
        "            copy.deepcopy(self.photons[2 if q <= p else 1])\n",
        "            for q in np.arange(0, 1, 1./n_photons)\n",
        "        ]\n",
        "        random.shuffle(photons)\n",
        "        for photon in photons:\n",
        "            photon.rate_func = squish_rate_func(\n",
        "                lambda x : x, 0.5, 1\n",
        "            )\n",
        "            added_anims = []\n",
        "            if photon.filter_distance == FRAME_X_RADIUS + 2:\n",
        "                absorption = self.get_filter_absorption_animation(\n",
        "                    self.second_filter, photon\n",
        "                )\n",
        "                absorption.rate_func = squish_rate_func(\n",
        "                    absorption.rate_func, 0.5, 1\n",
        "                )\n",
        "                added_anims.append(absorption)\n",
        "            self.play(\n",
        "                blocked_photon,\n",
        "                first_absorption,\n",
        "                photon, \n",
        "                *added_anims\n",
        "            )\n",
        "        self.wait()\n",
        "        \n",
        "    def change_to_new_filter(self, pol_filter, added_anims = None):\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "        self.play(\n",
        "            Transform(self.second_filter, pol_filter),\n",
        "            *added_anims\n",
        "        )\n",
        "        self.second_filter.filter_angle = pol_filter.filter_angle\n",
        "        new_prob_text = self.get_probability_text(self.get_prob())\n",
        "        new_prob_text[1][-2].set_color(YELLOW)\n",
        "        self.play(Transform(self.prob_text, new_prob_text))\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_prob(self, pol_filter = None):\n",
        "        if pol_filter is None:\n",
        "            pol_filter = self.second_filter\n",
        "        return np.cos(pol_filter.filter_angle)**2\n",
        "\n",
        "class ShowVariousFilterPairs(ShowVariousFilterPairsWithPhotonsOverTime):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [],\n",
        "        \"filter_z_coordinates\" : [2.5, 0, -2.5],\n",
        "        \"angles\" : [0, np.pi/4, np.pi/2],\n",
        "        \"n_lines\" : 20,\n",
        "        \"new_group_shift_val\" : 2.5*IN,\n",
        "        \"prev_group_shift_val\" : 1.75*IN,\n",
        "        \"ambient_rotation_rate\" : 0.015,\n",
        "        \"line_start_length\" : 16,\n",
        "        \"line_end_length\" : 16,\n",
        "        \"lines_depth\" : 1.2,\n",
        "        \"lines_shift_vect\" : SMALL_BUFF*OUT,\n",
        "    }\n",
        "    def setup(self):\n",
        "        ShowVariousFilterPairsWithPhotonsOverTime.setup(self)\n",
        "        self.remove(*self.pol_filters)\n",
        "        self.prev_groups = VGroup()\n",
        "        self.remove(self.axes)\n",
        "        self.setup_filters()\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.prob_texts = VGroup()\n",
        "\n",
        "    def setup_filters(self):\n",
        "        self.filter_pairs = []\n",
        "        zs = self.filter_z_coordinates\n",
        "        for non_zero_angle, z in zip(self.angles, zs):\n",
        "            filter_pair = VGroup()\n",
        "            for angle, x in (0, -3), (non_zero_angle, 3):\n",
        "                pf = PolarizingFilter(filter_angle = angle)\n",
        "                pf.scale(0.7)\n",
        "                pf.rotate(np.pi/2, RIGHT)\n",
        "                pf.rotate(np.pi/2, IN)\n",
        "                pf.shift(x*RIGHT + z*OUT)\n",
        "                pf.arrow_label.rotate(np.pi/2, OUT)\n",
        "                pf.arrow_label.next_to(pf.arrow, RIGHT, SMALL_BUFF)\n",
        "\n",
        "                filter_pair.add(pf)\n",
        "            self.filter_pairs.append(filter_pair)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_top_filters()\n",
        "        self.show_light(self.filter_pairs[0])\n",
        "        self.turn_one_filter_pair_into_another(0, 2)\n",
        "        self.show_light(self.filter_pairs[2])\n",
        "        self.turn_one_filter_pair_into_another(2, 1)\n",
        "        self.show_light(self.filter_pairs[1])\n",
        "\n",
        "    def add_top_filters(self):\n",
        "        pf1, pf2 = pair = self.filter_pairs[0]\n",
        "        for pf in pair:\n",
        "            pf.save_state()\n",
        "            pf.arrow_label.rotate(np.pi/2, IN)\n",
        "            pf.arrow_label.next_to(pf.arrow, UP, SMALL_BUFF)\n",
        "            pf.shift(2*IN)\n",
        "\n",
        "        self.add(pf1)\n",
        "        self.play(\n",
        "            ReplacementTransform(pf1.copy().fade(1), pf2),\n",
        "            Animation(pf1)\n",
        "        )\n",
        "        self.move_camera(\n",
        "            0.9*np.pi/2, -0.6*np.pi,\n",
        "            added_anims = [\n",
        "                pf.restore \n",
        "                for pf in pair\n",
        "            ]\n",
        "        )\n",
        "\n",
        "    def show_light(self, filter_pair):\n",
        "        pf1, pf2 = filter_pair\n",
        "        lines_to_pf1 = self.get_lines(None, pf1)\n",
        "        vect = lines_to_pf1[1].get_center() - lines_to_pf1[0].get_center()\n",
        "        lines_to_pf1.add(*lines_to_pf1.copy().shift(vect/2))\n",
        "        lines_to_pf2 = self.get_lines(pf1, pf2)\n",
        "        lines_from_pf2 = self.get_lines(pf2)\n",
        "\n",
        "        prob = self.get_prob(pf2)\n",
        "        n_black = int(prob*len(lines_from_pf2))\n",
        "        VGroup(*lines_from_pf2[n_black:]).set_stroke(BLACK, 0)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"lag_ratio\" : 0,\n",
        "        }\n",
        "\n",
        "        self.play(ShowCreation(lines_to_pf1, run_time = 2./3, **kwargs))\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_pf2, **kwargs),\n",
        "            Animation(VGroup(pf1, lines_to_pf1)),\n",
        "            run_time = 1./6,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines_from_pf2, **kwargs),\n",
        "            Animation(VGroup(pf2, lines_to_pf2, pf1, lines_to_pf1)),\n",
        "            run_time = 2./3,\n",
        "        )\n",
        "\n",
        "        group = VGroup(\n",
        "            lines_from_pf2, pf2, lines_to_pf2, pf1, lines_to_pf2\n",
        "        )\n",
        "\n",
        "        #Write probability\n",
        "        prob_text = self.get_probability_text(pf2)\n",
        "        self.play(Write(prob_text, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "        self.prob_texts.add(prob_text)\n",
        "\n",
        "    def turn_one_filter_pair_into_another(self, i1, i2):\n",
        "        mover = self.filter_pairs[i1].copy()\n",
        "        mover.set_stroke(width = 0)\n",
        "        mover.set_fill(opacity = 0)\n",
        "        target = self.filter_pairs[i2]\n",
        "        self.play(ReplacementTransform(mover, target))\n",
        "\n",
        "    def get_probability_text(self, pol_filter = None):\n",
        "        if pol_filter is None:\n",
        "            pol_filter = self.second_filter\n",
        "        prob = self.get_prob(pol_filter)\n",
        "        prob_mob = OldTexText(str(int(prob*100)) + \"\\\\%\", \" pass\")\n",
        "        prob_mob.scale(0.7)\n",
        "        prob_mob.rotate(np.pi/2, RIGHT)\n",
        "        prob_mob.next_to(pol_filter.arrow_label, RIGHT)\n",
        "        prob_mob.set_color(\n",
        "            list(Color(RED).range_to(GREEN, 11))[int(prob*10)]\n",
        "        )\n",
        "        return prob_mob\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_lines(\n",
        "        self, filter1 = None, filter2 = None, \n",
        "        ratio = 1.0,\n",
        "        remove_from_bottom = False,\n",
        "        ):\n",
        "        # n = int(ratio*self.n_lines)\n",
        "        n = self.n_lines\n",
        "        start, end = [\n",
        "            (f.point_from_proportion(0.75) if f is not None else None)\n",
        "            for f in (filter1, filter2)\n",
        "        ]\n",
        "        if start is None:\n",
        "            start = end + self.line_start_length*LEFT\n",
        "        if end is None:\n",
        "            end = start + self.line_end_length*RIGHT\n",
        "        nudge = (float(self.lines_depth)/self.n_lines)*OUT\n",
        "        lines = VGroup(*[\n",
        "            Line(start, end).shift(z*nudge)\n",
        "            for z in range(n)\n",
        "        ])\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "        lines.move_to(start, IN+LEFT)\n",
        "        lines.shift(self.lines_shift_vect)\n",
        "        n_to_block = int((1-ratio)*self.n_lines)\n",
        "        if remove_from_bottom:\n",
        "            to_block = lines[:n_to_block]\n",
        "        else:\n",
        "            to_block = lines[len(lines)-n_to_block:]\n",
        "        VGroup(*to_block).set_stroke(width = 0)\n",
        "        return lines\n",
        "\n",
        "class ShowVariousFilterPairsFrom0To45(ShowVariousFilterPairs):\n",
        "    CONFIG = {\n",
        "        \"angles\" : [0, np.pi/8, np.pi/4]\n",
        "    }\n",
        "    def construct(self):\n",
        "        ShowVariousFilterPairs.construct(self)\n",
        "        self.mention_probabilities()\n",
        "\n",
        "    def mention_probabilities(self):\n",
        "        rects = VGroup()\n",
        "        for prob_text in self.prob_texts:\n",
        "            prob_text.rotate(np.pi/2, LEFT)\n",
        "            rect = SurroundingRectangle(prob_text, color = BLUE)\n",
        "            VGroup(prob_text, rect).rotate(np.pi/2, RIGHT)\n",
        "            rects.add(rect)\n",
        "\n",
        "        cosines = VGroup(*[\n",
        "            OldTex(\"\\\\cos^2(%s^\\\\circ)\"%str(x))\n",
        "            for x in (45, 22.5)\n",
        "        ])\n",
        "        cosines.scale(0.8)\n",
        "        # cosines.set_color(BLUE)\n",
        "        cosines.rotate(np.pi/2, RIGHT)\n",
        "        for cos, rect in zip(cosines, rects[1:]):\n",
        "            cos.next_to(rect, OUT, SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, rects))\n",
        "        self.wait()\n",
        "        self.play(*list(map(Write, cosines)), run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "class ForgetPreviousActions(ShowVariousFilterPairs):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [-6, -2, 2, 2, 2],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : angle}\n",
        "            for angle in (np.pi/4, 0, np.pi/4, np.pi/3, np.pi/6)\n",
        "        ],\n",
        "        \"start_theta\" : -0.6*np.pi,\n",
        "        \"EMWave_config\" : {\n",
        "            \"wave_number\" : 0,\n",
        "            \"start_point\" : FRAME_X_RADIUS*LEFT + DOWN,\n",
        "        },\n",
        "        \"apply_filter\" : False,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PhotonsThroughPerpendicularFilters.setup(self)\n",
        "        self.remove(self.axes)\n",
        "\n",
        "        VGroup(*self.pol_filters).shift(IN)\n",
        "\n",
        "        for pf in self.pol_filters:\n",
        "            pf.arrow_label.rotate(np.pi/2, OUT)\n",
        "            pf.arrow_label.next_to(pf.arrow, RIGHT)\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "\n",
        "    def construct(self):\n",
        "        front_filter = self.pol_filters[0]\n",
        "        first_filter = self.pol_filters[1]\n",
        "        possible_second_filters = self.pol_filters[2:]\n",
        "        for pf in possible_second_filters:\n",
        "            prob_text = self.get_probability_text(pf)\n",
        "            prob_text.scale(1.3, about_point = prob_text.get_left())\n",
        "            pf.add(prob_text)\n",
        "\n",
        "        second_filter = possible_second_filters[0].copy()\n",
        "        self.second_filter = second_filter\n",
        "        self.pol_filters = VGroup(\n",
        "            first_filter, second_filter\n",
        "        )\n",
        "        self.remove(front_filter)\n",
        "        self.remove(*possible_second_filters)\n",
        "        self.add(second_filter)\n",
        "        self.apply_filter = True\n",
        "        self.update_mobjects()\n",
        "        self.photons = self.get_photons()[1:]\n",
        "\n",
        "        group = VGroup(*self.pol_filters)\n",
        "        rect1 = SurroundingRectangle(group)\n",
        "        rect1.rotate(np.pi/2, RIGHT)\n",
        "        rect1.rescale_to_fit(group.get_depth()+MED_SMALL_BUFF, 2, True)\n",
        "        rect1.stretch_in_place(1.2, 0)\n",
        "        prob_words = OldTexText(\n",
        "            \"Probabilities depend only\\\\\\\\\",\n",
        "            \"on this angle difference\"\n",
        "        )\n",
        "        prob_words.add_background_rectangle()\n",
        "        prob_words.rotate(np.pi/2, RIGHT)\n",
        "        prob_words.next_to(rect1, OUT)\n",
        "\n",
        "        self.add(rect1)\n",
        "        self.play(FadeIn(prob_words))\n",
        "        for index in 1, 2:\n",
        "            self.shoot_photon()\n",
        "            self.play(Transform(\n",
        "                second_filter, possible_second_filters[index]\n",
        "            ))\n",
        "\n",
        "        rect2 = SurroundingRectangle(front_filter, color = RED)\n",
        "        rect2.rotate(np.pi/2, RIGHT)\n",
        "        rect2.rescale_to_fit(front_filter.get_depth()+MED_SMALL_BUFF, 2, True)\n",
        "        rect2.stretch_in_place(1.5, 0)\n",
        "        ignore_words = OldTexText(\"Photon \\\\\\\\\", \"``forgets'' this\")\n",
        "        ignore_words.add_background_rectangle()\n",
        "        ignore_words.rotate(np.pi/2, RIGHT)\n",
        "        ignore_words.next_to(rect2, OUT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect2), \n",
        "            Write(ignore_words, run_time = 1),\n",
        "            FadeIn(front_filter),\n",
        "            run_time = 1.5,\n",
        "        )\n",
        "        self.shoot_photon()\n",
        "        for index in 0, 1, 2:\n",
        "            self.play(Transform(\n",
        "                second_filter, possible_second_filters[index]\n",
        "            ))\n",
        "            self.shoot_photon()\n",
        "\n",
        "    def shoot_photon(self):\n",
        "        photon = random.choice(self.photons)\n",
        "        added_anims = []\n",
        "        if photon.filter_distance == FRAME_X_RADIUS + 2:\n",
        "            added_anims.append(\n",
        "                ApplyMethod(\n",
        "                    self.second_filter.set_color, RED,\n",
        "                    rate_func = squish_rate_func(there_and_back, 0.5, 0.7)\n",
        "                )\n",
        "            )\n",
        "        self.play(photon, *added_anims, run_time = 1.5)\n",
        "\n",
        "class IntroduceLabeledFilters(ShowVariousFilterPairs):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [-5, -2, 1],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : angle}\n",
        "            for angle in [0, np.pi/8, np.pi/4]\n",
        "        ],\n",
        "        \"start_phi\" : 0.9*np.pi/2,\n",
        "        \"start_theta\" : -0.85*np.pi,\n",
        "        \"target_theta\" : -0.65*np.pi,\n",
        "        \"lines_depth\" : 1.7,\n",
        "        \"lines_shift_vect\" : MED_SMALL_BUFF*OUT,\n",
        "        \"line_start_length\" : 3,\n",
        "        \"line_end_length\" : 9,\n",
        "        \"ambient_rotation_rate\" : 0.005,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PhotonsThroughPerpendicularFilters.setup(self)\n",
        "        self.remove(self.axes)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_letters_to_labels()\n",
        "        self.introduce_filters()\n",
        "        self.reposition_camera()\n",
        "        self.separate_cases()\n",
        "        self.show_bottom_lines()\n",
        "        self.comment_on_half_blocked_by_C()\n",
        "        self.show_top_lines()\n",
        "        self.comment_on_those_blocked_by_B()\n",
        "        self.show_sum()\n",
        "\n",
        "    def add_letters_to_labels(self):\n",
        "        for char, pf, color in zip(\"ABC\", self.pol_filters, [RED, GREEN, BLUE]):\n",
        "            label = OldTexText(char)\n",
        "            label.scale(0.9)\n",
        "            label.add_background_rectangle()\n",
        "            label.set_color(color)\n",
        "            label.rotate(np.pi/2, RIGHT)\n",
        "            label.rotate(np.pi/2, IN)\n",
        "            label.next_to(pf.arrow_label, UP)\n",
        "            pf.arrow_label.add(label)\n",
        "            pf.arrow_label.next_to(pf.arrow, OUT, SMALL_BUFF)\n",
        "        self.remove(*self.pol_filters)\n",
        "\n",
        "    def introduce_filters(self):\n",
        "        self.A_filter, self.B_filter, self.C_filter = self.pol_filters\n",
        "        for pf in self.pol_filters:\n",
        "            pf.save_state()\n",
        "            pf.shift(4*OUT)\n",
        "            pf.fade(1)\n",
        "            self.play(pf.restore)\n",
        "            self.wait()\n",
        "\n",
        "    def reposition_camera(self):\n",
        "        self.move_camera(\n",
        "            theta = self.target_theta, \n",
        "            added_anims = list(it.chain(*[\n",
        "                [\n",
        "                    pf.arrow_label.rotate, np.pi/2, OUT,\n",
        "                    pf.arrow_label.next_to, pf.arrow, RIGHT\n",
        "                ]\n",
        "                for pf in self.pol_filters\n",
        "            ]))\n",
        "        )\n",
        "\n",
        "    def separate_cases(self):\n",
        "        self.lower_pol_filters = VGroup(\n",
        "            self.A_filter.deepcopy(),\n",
        "            self.C_filter.deepcopy(),\n",
        "        )\n",
        "        self.lower_pol_filters.save_state()\n",
        "        self.lower_pol_filters.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            self.lower_pol_filters.restore,\n",
        "            self.lower_pol_filters.shift, 3*IN,\n",
        "            self.pol_filters.shift, 1.5*OUT,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_bottom_lines(self):\n",
        "        A, C = self.lower_pol_filters\n",
        "        lines_to_A = self.get_lines(None, A)\n",
        "        vect = lines_to_A[1].get_center() - lines_to_A[0].get_center()\n",
        "        lines_to_A.add(*lines_to_A.copy().shift(vect/2))\n",
        "        lines_to_C = self.get_lines(A, C)\n",
        "        lines_from_C = self.get_lines(C, ratio = 0.5)\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"lag_ratio\" : 0,\n",
        "            \"run_time\" : 1./3,\n",
        "        }\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_A),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_C),\n",
        "            Animation(VGroup(A, lines_to_A)),\n",
        "            **kwargs\n",
        "        )\n",
        "        kwargs[\"run_time\"] = 3*kwargs[\"run_time\"]\n",
        "        self.play(\n",
        "            ShowCreation(lines_from_C),\n",
        "            Animation(VGroup(C, lines_to_C, A, lines_to_A)),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "        line_group = VGroup(lines_from_C, C, lines_to_C, A, lines_to_A)\n",
        "        self.remove(*line_group)\n",
        "        self.add_foreground_mobject(line_group)\n",
        "\n",
        "        self.bottom_lines_group = line_group\n",
        "\n",
        "    def comment_on_half_blocked_by_C(self):\n",
        "        arrow = Arrow(\n",
        "            ORIGIN, 3.5*RIGHT,\n",
        "            path_arc = -0.9*np.pi,\n",
        "            color = BLUE,\n",
        "            stroke_width = 5,\n",
        "        )\n",
        "        words = OldTexText(\"50\\\\% blocked\")\n",
        "        words.set_color(BLUE)\n",
        "        words.next_to(arrow, RIGHT, buff = 0)\n",
        "        group = VGroup(arrow, words)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.shift(1.7*IN + 0.5*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.blocked_at_C_words = words\n",
        "        self.blocked_at_C_label_group = VGroup(arrow, words)\n",
        "\n",
        "    def show_top_lines(self):\n",
        "        A, B, C = self.pol_filters\n",
        "        lines_to_A = self.get_lines(None, A)\n",
        "        vect = lines_to_A[1].get_center() - lines_to_A[0].get_center()\n",
        "        lines_to_A.add(*lines_to_A.copy().shift(vect/2))\n",
        "        lines_to_B = self.get_lines(A, B)\n",
        "        lines_to_C = self.get_lines(B, C, ratio = 0.85, remove_from_bottom = True)\n",
        "        lines_from_C = self.get_lines(C, ratio = 0.85**2, remove_from_bottom = True)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"lag_ratio\" : 0,\n",
        "            \"run_time\" : 1./5,\n",
        "        }\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_A),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_B),\n",
        "            Animation(VGroup(A, lines_to_A)),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines_to_C),\n",
        "            Animation(VGroup(B, lines_to_B, A, lines_to_A)),\n",
        "            **kwargs\n",
        "        )\n",
        "        kwargs[\"run_time\"] = 3*kwargs[\"run_time\"]\n",
        "        self.play(\n",
        "            ShowCreation(lines_from_C),\n",
        "            Animation(VGroup(C, lines_to_C, B, lines_to_B, A, lines_to_A)),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "        line_group = VGroup(\n",
        "            lines_from_C, C, lines_to_C, B, lines_to_B, A, lines_to_A\n",
        "        )\n",
        "        self.remove(*line_group)\n",
        "        self.add_foreground_mobject(line_group)\n",
        "\n",
        "        self.top_lines_group = line_group\n",
        "\n",
        "    def comment_on_those_blocked_by_B(self):\n",
        "        arrow0 = Arrow(\n",
        "            2*LEFT, 0.5*(UP+RIGHT),\n",
        "            path_arc = 0.8*np.pi,\n",
        "            color = WHITE,\n",
        "            stroke_width = 5,\n",
        "            buff = 0\n",
        "        )\n",
        "        arrow1 = Arrow(\n",
        "            2*LEFT, ORIGIN,\n",
        "            path_arc = 0.8*np.pi,\n",
        "            color = GREEN,\n",
        "            stroke_width = 5,\n",
        "            buff = 0\n",
        "        )\n",
        "        arrow2 = arrow1.copy()\n",
        "        arrow2.next_to(arrow1, RIGHT, buff = LARGE_BUFF)\n",
        "        words1 = OldTexText(\"15\\\\%\", \"blocked\")\n",
        "        words1.set_color(GREEN)\n",
        "        words2 = words1.copy()\n",
        "        words1.next_to(arrow1, DOWN, buff = SMALL_BUFF)\n",
        "        words2.next_to(arrow2, DOWN, buff = SMALL_BUFF)\n",
        "        words2.shift(MED_LARGE_BUFF*RIGHT)\n",
        "\n",
        "        words0 = OldTexText(\"85\\\\%\", \"pass\")\n",
        "        words0.move_to(words1)\n",
        "\n",
        "        group = VGroup(arrow0, arrow1, arrow2, words0, words1, words2)\n",
        "        group.rotate(np.pi/2, RIGHT)\n",
        "        group.shift(0.8*LEFT+1.5*OUT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow0),\n",
        "            Write(words0, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(words0, words1),\n",
        "            ReplacementTransform(arrow0, arrow1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow2),\n",
        "            Write(words2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.fifteens = VGroup(words1, words2)\n",
        "        self.blocked_at_B_label_group = VGroup(\n",
        "            words1, words2, arrow1, arrow2\n",
        "        )\n",
        "\n",
        "    def show_sum(self):\n",
        "        fifteen1, fifteen2 = self.fifteens\n",
        "        fifty = self.blocked_at_C_words\n",
        "        plus = OldTex(\"+\").rotate(np.pi/2, RIGHT)\n",
        "        plus.move_to(Line(fifteen1.get_right(), fifteen2.get_left()))\n",
        "        equals = OldTex(\"=\").rotate(np.pi/2, RIGHT)\n",
        "        equals.next_to(fifteen2, RIGHT, 2*SMALL_BUFF)\n",
        "        q_mark = OldTex(\"?\").rotate(np.pi/2, RIGHT)\n",
        "        q_mark.next_to(equals, OUT, SMALL_BUFF)\n",
        "        q_mark.set_color(RED)\n",
        "        randy = Randolph(mode = \"confused\").flip()\n",
        "        randy.scale(0.7)\n",
        "        randy.rotate(np.pi/2, RIGHT)\n",
        "        randy.move_to(fifty)\n",
        "        randy.shift(0.5*RIGHT)\n",
        "        randy.look_at(equals)\n",
        "        blinked = randy.copy()\n",
        "        blinked.rotate(np.pi/2, LEFT)\n",
        "        blinked.blink()\n",
        "        blinked.rotate(np.pi/2, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            fifteen1.set_color, YELLOW,\n",
        "            Write(plus)\n",
        "        )\n",
        "        self.play(\n",
        "            fifteen2.set_color, YELLOW,\n",
        "            Write(equals)\n",
        "        )\n",
        "        self.play(\n",
        "            fifty.next_to, equals, RIGHT, 2*SMALL_BUFF,\n",
        "            Write(q_mark),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            randy, blinked, \n",
        "            rate_func = squish_rate_func(there_and_back)\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceLabeledFiltersNoRotation(IntroduceLabeledFilters):\n",
        "    CONFIG = {\n",
        "        \"ambient_rotation_rate\" : 0,\n",
        "        \"target_theta\" : -0.55*np.pi,\n",
        "    }\n",
        "\n",
        "class RemoveBFromLabeledFilters(IntroduceLabeledFiltersNoRotation):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        IntroduceLabeledFiltersNoRotation.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.setup_start()\n",
        "        self.show_filter_B_removal()\n",
        "        self.fade_in_labels()\n",
        "\n",
        "    def show_sum(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "    def setup_start(self):\n",
        "        self.remove(self.blocked_at_C_label_group)\n",
        "        self.remove(self.blocked_at_B_label_group)\n",
        "        self.remove(self.bottom_lines_group)\n",
        "        self.top_lines_group.save_state()\n",
        "        self.top_lines_group.shift(2*IN)\n",
        "\n",
        "    def show_filter_B_removal(self):\n",
        "        top_lines_group = self.top_lines_group\n",
        "        bottom_lines_group = self.bottom_lines_group\n",
        "\n",
        "\n",
        "        mover = top_lines_group.copy()\n",
        "        mover.save_state()\n",
        "        mover.fade(1)\n",
        "\n",
        "        sl1, sC, sl2, sB, sl3, sA, sl4 = mover\n",
        "        tl1, tC, tl2, tA, tl3 = bottom_lines_group\n",
        "\n",
        "        for line in tl2:\n",
        "            line.scale(0.5, about_point = line.get_end())\n",
        "\n",
        "        kwargs = {\n",
        "            \"lag_ratio\" : 0,\n",
        "            \"rate_func\" : None,\n",
        "        }\n",
        "\n",
        "        self.play(\n",
        "            top_lines_group.shift, 2*OUT,\n",
        "            mover.restore,\n",
        "            mover.shift, 2.5*IN,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(sB.shift, 4*IN, rate_func = running_start),\n",
        "            FadeOut(sl1),\n",
        "            Animation(sC),\n",
        "            FadeOut(sl2),\n",
        "        )\n",
        "        self.play(ShowCreation(tl2, run_time = 0.25, **kwargs))\n",
        "        self.play(\n",
        "            ShowCreation(tl1, run_time = 0.5, **kwargs),\n",
        "            Animation(sC),\n",
        "            Animation(tl2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def fade_in_labels(self):\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            self.blocked_at_B_label_group,\n",
        "            self.blocked_at_C_label_group,\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "class NumbersSuggestHiddenVariablesAreImpossible(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"These numbers suggest\\\\\\\\\",\n",
        "            \"no hidden variables\"\n",
        "        )\n",
        "        self.play_student_changes(\"erm\", \"sassy\", \"confused\")\n",
        "        self.wait(3)\n",
        "\n",
        "class VennDiagramProofByContradiction(Scene):\n",
        "    CONFIG = {\n",
        "        \"circle_colors\" : [RED, GREEN, BLUE]\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_venn_diagram_sections()\n",
        "        self.draw_venn_diagram()\n",
        "        self.show_100_photons()\n",
        "        self.show_one_photon_answering_questions()\n",
        "        self.put_all_photons_in_A()\n",
        "        self.separate_by_B()\n",
        "        self.separate_by_C()\n",
        "        self.show_two_relevant_subsets()\n",
        "\n",
        "    def draw_venn_diagram(self, send_to_corner = True):\n",
        "        A, B, C = venn_diagram = VGroup(*[\n",
        "            Circle(\n",
        "                radius = 3,\n",
        "                stroke_width = 3,\n",
        "                stroke_color = c,\n",
        "                fill_opacity = 0.2,\n",
        "                fill_color = c,\n",
        "            ).shift(vect)\n",
        "            for c, vect in zip(\n",
        "                self.circle_colors,\n",
        "                compass_directions(3, UP)\n",
        "            )\n",
        "        ])\n",
        "        self.A_to_B_vect = B.get_center() - A.get_center()\n",
        "        self.A_to_C_vect = C.get_center() - A.get_center()\n",
        "\n",
        "        venn_diagram.center()\n",
        "        labels = VGroup()\n",
        "        alt_labels = VGroup()\n",
        "        props = [1./12, 0.5, 0]\n",
        "        angles = [0, np.pi/8, np.pi/4]\n",
        "        for circle, char, prop, angle in zip(venn_diagram, \"ABC\", props, angles):\n",
        "            label, alt_label = [\n",
        "                OldTexText(\n",
        "                    \"%s \\\\\\\\\"%start,\n",
        "                    \"through\", char + \"$\\\\! \\\\uparrow$\"\n",
        "                ).set_color_by_tex(char, circle.get_color())\n",
        "                for start in (\"Would pass\", \"Pass\")\n",
        "            ]\n",
        "            for mob in label, alt_label:\n",
        "                mob[-1][-1].rotate(-angle)\n",
        "                mob[-1][-1].shift(0.5*SMALL_BUFF*UP)\n",
        "            center = circle.get_center()\n",
        "            label.move_to(center)\n",
        "            label.generate_target()\n",
        "            point = circle.point_from_proportion(prop)\n",
        "            alt_label.scale(2)\n",
        "            for mob in label.target, alt_label:\n",
        "                mob.next_to(point, point-center, SMALL_BUFF)\n",
        "\n",
        "            circle.label = label\n",
        "            circle.alt_label = alt_label\n",
        "            labels.add(label)\n",
        "            alt_labels.add(alt_label)\n",
        "\n",
        "        last_circle = None\n",
        "        for circle in venn_diagram:\n",
        "            added_anims = []\n",
        "            if last_circle:\n",
        "                added_anims.append(MoveToTarget(last_circle.label))\n",
        "            self.play(\n",
        "                DrawBorderThenFill(circle, run_time = 2),\n",
        "                Write(circle.label, run_time = 2),\n",
        "                *added_anims\n",
        "            )\n",
        "            last_circle = circle\n",
        "        self.play(MoveToTarget(last_circle.label))\n",
        "        self.wait()\n",
        "\n",
        "        if hasattr(self, \"A_segments\"):\n",
        "            A.add(self.A_segments)\n",
        "\n",
        "        if send_to_corner:\n",
        "            group = VGroup(venn_diagram, labels)\n",
        "            target = VGroup(venn_diagram.copy(), alt_labels)\n",
        "            target.scale(0.25)\n",
        "            target.to_corner(UP+RIGHT)\n",
        "            self.play(Transform(group, target))\n",
        "            self.remove(group)\n",
        "            for circle in venn_diagram:\n",
        "                circle.label = circle.alt_label\n",
        "                self.add(circle)\n",
        "        for circle in venn_diagram:\n",
        "            self.add(circle.label)\n",
        "\n",
        "        self.venn_diagram = venn_diagram\n",
        "\n",
        "    def show_100_photons(self):\n",
        "        photon = FunctionGraph(\n",
        "            lambda x : -np.cos(3*np.pi*x)*np.exp(-x*x),\n",
        "            x_min = -2, \n",
        "            x_max = 2,\n",
        "            color = YELLOW,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "        photon.shift(LEFT + 2*UP)\n",
        "        eyes = Eyes(photon)\n",
        "        photon.eyes = eyes\n",
        "\n",
        "        hundred, photon_word, s = words = OldTexText(\n",
        "            \"100 \", \"Photon\", \"s\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.next_to(eyes, UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(photon),\n",
        "            FadeIn(photon.eyes),\n",
        "            Write(photon_word, run_time = 1.5)\n",
        "        )\n",
        "        photon.add(photon.eyes)\n",
        "\n",
        "        #Split to hundred\n",
        "        photons = VGroup(*[photon.deepcopy() for x in range(100)])\n",
        "        self.arrange_photons_in_circle(photons)\n",
        "        photons.set_height(6)\n",
        "        photons.next_to(words, DOWN)\n",
        "        photons.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(hundred), Write(s),\n",
        "            ReplacementTransform(\n",
        "                VGroup(photon), photons,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.photons = photons\n",
        "        self.photon_words = words\n",
        "\n",
        "    def show_one_photon_answering_questions(self):\n",
        "        photon = self.photons[89]\n",
        "        photon.save_state()\n",
        "        photon.generate_target()\n",
        "\n",
        "        answers = OldTexText(\n",
        "            \"Pass through A?\", \"Yes\\\\\\\\\",\n",
        "            \"Pass through B?\", \"No\\\\\\\\\",\n",
        "            \"Pass through C?\", \"No\\\\\\\\\",\n",
        "        )\n",
        "        answers.set_color_by_tex_to_color_map({\n",
        "            \"Yes\" : GREEN,\n",
        "            \"No\" : RED,\n",
        "        })\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.add_content(answers)\n",
        "        bubble.resize_to_content() \n",
        "        answers.shift(SMALL_BUFF*(RIGHT+UP))\n",
        "        bubble_group = VGroup(bubble, answers)\n",
        "        bubble_group.scale(0.25)\n",
        "        bubble_group.next_to(photon, UP+RIGHT, buff = 0)\n",
        "\n",
        "        group = VGroup(photon, bubble_group)\n",
        "        group.save_state()\n",
        "        bubble_group.set_fill(opacity = 0)\n",
        "        bubble_group.set_stroke(width = 0)\n",
        "\n",
        "        self.play(\n",
        "            group.restore,\n",
        "            group.scale, 4,\n",
        "            group.to_corner, DOWN + RIGHT,\n",
        "        )\n",
        "        self.play(photon.eyes.blink_anim())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(bubble_group),\n",
        "            photon.restore,\n",
        "        )\n",
        "\n",
        "    def put_all_photons_in_A(self):\n",
        "        A, B, C = circles = self.venn_diagram[:3]\n",
        "        A_group, B_group, C_group = [\n",
        "            VGroup(circle, circle.label)\n",
        "            for circle in circles\n",
        "        ]\n",
        "        B_group.save_state()\n",
        "        C_group.save_state()\n",
        "\n",
        "        A.generate_target()\n",
        "        A.target.scale(4)\n",
        "        A.target.shift(\n",
        "            (FRAME_Y_RADIUS-MED_LARGE_BUFF)*UP - \\\n",
        "            A.target.get_top()\n",
        "        )\n",
        "        A.label.generate_target()\n",
        "        A.label.target.scale(2)\n",
        "        A.label.target.next_to(\n",
        "            A.target.point_from_proportion(0.1),\n",
        "            UP+RIGHT, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            B_group.fade, 1,\n",
        "            C_group.fade, 1,\n",
        "            MoveToTarget(A),\n",
        "            MoveToTarget(A.label),\n",
        "            FadeOut(self.photon_words),\n",
        "            self.photons.set_height,\n",
        "                0.85*A.target.get_height(),\n",
        "            self.photons.space_out_submobjects, 0.8,\n",
        "            self.photons.move_to, A.target,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.A_group = A_group\n",
        "        self.B_group = B_group\n",
        "        self.C_group = C_group\n",
        "\n",
        "    def separate_by_B(self):\n",
        "        A_group = self.A_group\n",
        "        B_group = self.B_group\n",
        "        photons = self.photons\n",
        "        B = B_group[0]\n",
        "\n",
        "        B.target, B.label.target = B_group.saved_state\n",
        "        B.target.scale(4)\n",
        "        B.target.move_to(A_group[0])\n",
        "        B.target.shift(self.A_to_B_vect)\n",
        "        B.label.target.scale(2)\n",
        "        B.label.target.next_to(\n",
        "            B.target.point_from_proportion(0.55),\n",
        "            LEFT, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        B_center = B.target.get_center()\n",
        "        photons.sort(\n",
        "            lambda p : get_norm(p-B_center)\n",
        "        )\n",
        "        in_B = VGroup(*photons[:85])\n",
        "        out_of_B = VGroup(*photons[85:])\n",
        "        out_of_B.sort(lambda p : np.dot(p, 2*UP+LEFT))\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(B),\n",
        "            MoveToTarget(B.label),\n",
        "            in_B.shift, 0.5*DOWN+0.2*LEFT,\n",
        "            out_of_B.scale, 1./0.8,\n",
        "            out_of_B.shift, 0.15*(UP+RIGHT),\n",
        "        )\n",
        "\n",
        "        words1 = OldTexText(\"85 also \\\\\\\\\", \"pass \", \"B\")\n",
        "        words1.set_color_by_tex(\"B\", GREEN)\n",
        "        words1.scale(0.8)\n",
        "        words1.next_to(A_group, LEFT, LARGE_BUFF).shift(UP)\n",
        "        arrow1 = Arrow(\n",
        "            words1.get_right(), \n",
        "            in_B.get_corner(UP+LEFT) + MED_LARGE_BUFF*(DOWN+RIGHT)\n",
        "        )\n",
        "        arrow1.set_color(GREEN)\n",
        "\n",
        "        words2 = OldTexText(\"15 blocked \\\\\\\\\", \"by \", \"B\")\n",
        "        words2.set_color_by_tex(\"B\", GREEN)\n",
        "        words2.scale(0.8)\n",
        "        words2.next_to(A_group, LEFT, MED_LARGE_BUFF, UP)\n",
        "        arrow2 = Arrow(words2.get_right(), out_of_B[-1])\n",
        "        arrow2.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            Write(words1, run_time = 1),\n",
        "            ShowCreation(arrow1),\n",
        "            self.in_A_in_B.set_fill, GREEN, 0.5,\n",
        "            Animation(in_B),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(words1, words2),\n",
        "            ReplacementTransform(arrow1, arrow2),\n",
        "            self.in_A_in_B.set_fill, None, 0,\n",
        "            Animation(in_B),\n",
        "            self.in_A_out_B.set_fill, RED, 0.5,\n",
        "            Animation(out_of_B)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ApplyMethod(\n",
        "            VGroup(self.in_A_out_B, out_of_B).shift,\n",
        "            MED_LARGE_BUFF*UP, \n",
        "            rate_func = wiggle,\n",
        "            run_time = 1.5,\n",
        "        ))\n",
        "        self.wait(0.5)\n",
        "\n",
        "        self.in_B = in_B\n",
        "        self.out_of_B = out_of_B\n",
        "        self.out_of_B_words = words2\n",
        "        self.out_of_B_arrow = arrow2\n",
        "\n",
        "    def separate_by_C(self):\n",
        "        A_group = self.A_group\n",
        "        B_group = self.B_group\n",
        "        C_group = self.C_group\n",
        "        in_B = self.in_B\n",
        "        A, B, C = self.venn_diagram\n",
        "\n",
        "        C.target, C.label.target = C_group.saved_state\n",
        "        C.target.scale(4)\n",
        "        C.target.move_to(A)\n",
        "        C.target.shift(self.A_to_C_vect)\n",
        "        C_center = C.target.get_center()\n",
        "        C.label.target.scale(2)\n",
        "        C.label.target.next_to(\n",
        "            C.target.point_from_proportion(0),\n",
        "            DOWN+RIGHT, buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        in_B.sort(\n",
        "            lambda p : get_norm(p - C_center)\n",
        "        )\n",
        "        in_C = VGroup(*in_B[:-11])\n",
        "        out_of_C = VGroup(*in_B[-11:])\n",
        "        in_C_out_B = VGroup(*self.out_of_B[:6])\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"$15\\\\%$\", \"passing\", \"B \\\\\\\\\",\n",
        "            \"get blocked by \", \"C\",\n",
        "        )\n",
        "        words.scale(0.8)\n",
        "        words.set_color_by_tex_to_color_map({\n",
        "            \"B\" : GREEN,\n",
        "            \"C\" : BLUE,\n",
        "        })\n",
        "        words.next_to(self.out_of_B_words, DOWN, LARGE_BUFF)\n",
        "        words.to_edge(LEFT)\n",
        "        percent = words[0]\n",
        "        pound = OldTex(\"\\\\#\")\n",
        "        pound.move_to(percent, RIGHT)\n",
        "        less_than_15 = OldTex(\"<15\")\n",
        "        less_than_15.next_to(words, DOWN)\n",
        "\n",
        "\n",
        "        arrow = Arrow(words.get_right(), out_of_C)\n",
        "        arrow.set_color(GREEN)\n",
        "\n",
        "        C_copy = C.copy()\n",
        "        C_copy.set_fill(BLACK, opacity = 1)\n",
        "\n",
        "        self.play(\n",
        "            self.in_A_in_B.set_fill, GREEN, 0.5,\n",
        "            rate_func = there_and_back,\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(C),\n",
        "            MoveToTarget(C.label),\n",
        "            in_C.shift, 0.2*DOWN+0.15*RIGHT,\n",
        "            out_of_C.shift, SMALL_BUFF*(UP+LEFT),\n",
        "            in_C_out_B.shift, 0.3*DOWN\n",
        "        )\n",
        "        self.play(\n",
        "            self.in_A_in_B_out_C.set_fill, GREEN, 0.5,\n",
        "            Write(words, run_time = 1),\n",
        "            ShowCreation(arrow),\n",
        "            Animation(out_of_C),\n",
        "        )\n",
        "        self.play(ApplyMethod(\n",
        "            VGroup(self.in_A_in_B_out_C, out_of_C).shift,\n",
        "            MED_LARGE_BUFF*UP,\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.wait()\n",
        "        C.save_state()\n",
        "        self.play(C.set_fill, BLACK, 1)\n",
        "        self.wait()\n",
        "        self.play(C.restore)\n",
        "        self.wait(2)\n",
        "        self.play(Transform(percent, pound))\n",
        "        self.play(Write(less_than_15, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "        self.in_C = in_C\n",
        "        self.out_of_C = out_of_C\n",
        "        words.add(less_than_15)\n",
        "        self.out_of_C_words = words\n",
        "        self.out_of_C_arrow = arrow\n",
        "\n",
        "    def show_two_relevant_subsets(self):\n",
        "        A, B, C = self.venn_diagram\n",
        "\n",
        "        all_out_of_C = VGroup(*it.chain(\n",
        "            self.out_of_B[6:],\n",
        "            self.out_of_C,\n",
        "        ))\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        photon_groups = [all_out_of_C, self.out_of_C, self.out_of_B]\n",
        "        regions = [self.in_A_out_C, self.in_A_in_B_out_C, self.in_A_out_B]\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                m.scale, 0.7, \n",
        "                method_kwargs = {\n",
        "                    \"about_point\" : FRAME_Y_RADIUS*DOWN\n",
        "                }\n",
        "            )\n",
        "            for m in everything\n",
        "        ])\n",
        "\n",
        "        terms = VGroup(\n",
        "            OldTex(\"N(\", \"A\", \"\\\\checkmark\", \",\", \"C\", \")\", \"\\\\le\"),\n",
        "            OldTex(\n",
        "                \"N(\", \"A\", \"\\\\checkmark\", \",\", \n",
        "                \"B\", \"\\\\checkmark\", \",\", \"C\", \")\"\n",
        "            ),\n",
        "            OldTex(\"+\\\\, N(\", \"A\", \"\\\\checkmark\", \",\", \"B\", \")\"),\n",
        "        )\n",
        "        terms.arrange(RIGHT)\n",
        "        terms.to_edge(UP)\n",
        "        for term, index, group in zip(terms, [-3, -2, -2], photon_groups):\n",
        "            term.set_color_by_tex(\"checkmark\", \"#00ff00\")\n",
        "            cross = Cross(term[index])\n",
        "            cross.set_color(\"#ff0000\")\n",
        "            cross.set_stroke(width = 8)\n",
        "            term[index].add(cross)\n",
        "\n",
        "        less_than = terms[0][-1]\n",
        "        terms[0].remove(less_than)\n",
        "        plus = terms[2][0][0]\n",
        "        terms[2][0].remove(plus)\n",
        "        rects = list(map(SurroundingRectangle, terms))\n",
        "        terms[2][0].add_to_back(plus)\n",
        "        last_rects = VGroup(*rects[1:])\n",
        "\n",
        "        should_be_50 = OldTexText(\"Should be 50 \\\\\\\\\", \"...somehow\")\n",
        "        should_be_50.scale(0.8)\n",
        "        should_be_50.next_to(rects[0], DOWN)\n",
        "\n",
        "        lt_fifteen = VGroup(self.out_of_C_words[-1]).copy()\n",
        "        something_lt_15 = OldTexText(\"(Something\", \"$<15$\", \")\")\n",
        "        something_lt_15.scale(0.8)\n",
        "        something_lt_15.next_to(rects[1], DOWN)\n",
        "        lt_fifteen.target = something_lt_15\n",
        "\n",
        "        fifteen = VGroup(*self.out_of_B_words[0][:2]).copy()\n",
        "        fifteen.generate_target()\n",
        "        fifteen.target.scale(1.5)\n",
        "        fifteen.target.next_to(rects[2], DOWN)\n",
        "\n",
        "        nums = [should_be_50, lt_fifteen, fifteen]\n",
        "\n",
        "        cross = Cross(less_than)\n",
        "        cross.set_color(\"#ff0000\")\n",
        "        cross.set_stroke(width = 8)\n",
        "\n",
        "        tweaser_group = VGroup(\n",
        "            self.in_A_in_B_out_C.copy(),\n",
        "            self.in_A_out_B.copy(),\n",
        "        )\n",
        "        tweaser_group.set_fill(TEAL, 1)\n",
        "        tweaser_group.set_stroke(TEAL, 5)\n",
        "\n",
        "        #Fade out B circle\n",
        "        faders = VGroup(\n",
        "            B, B.label,\n",
        "            self.out_of_B_words, self.out_of_C_words,\n",
        "            self.out_of_B_arrow, self.out_of_C_arrow,\n",
        "            *regions[1:]\n",
        "        )\n",
        "        faders.save_state()\n",
        "\n",
        "        self.play(faders.fade, 1)\n",
        "        self.play(Write(terms[0]), run_time = 1)\n",
        "        self.wait()\n",
        "        self.photon_thinks_in_A_out_C()\n",
        "        regions[0].set_stroke(YELLOW, width = 8)\n",
        "        regions[0].set_fill(YELLOW, opacity = 0.25)\n",
        "        self.play(\n",
        "            VGroup(regions[0], all_out_of_C).shift, 0.5*UP,\n",
        "            run_time = 1.5,\n",
        "            rate_func = wiggle,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Photons jump\n",
        "        self.photons.save_state()\n",
        "        self.play(Write(should_be_50[0], run_time = 1))\n",
        "        self.photons_jump_to_A_not_C_region()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            faders.restore,\n",
        "            self.photons.restore,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            faders.restore,\n",
        "            regions[0].set_fill, None, 0,\n",
        "            Animation(self.photons)\n",
        "        )\n",
        "\n",
        "        #Funny business\n",
        "        everything_copy = everything.copy().scale(1./3)\n",
        "        braces = VGroup(\n",
        "            Brace(everything_copy, LEFT),\n",
        "            Brace(everything_copy, RIGHT),\n",
        "        ).scale(3)\n",
        "        funny_business = OldTexText(\"Funny business\")\n",
        "        funny_business.scale(1.5)\n",
        "        funny_business.to_edge(UP)\n",
        "        funny_business.shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(funny_business),\n",
        "            *list(map(Write, braces)),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(less_than),\n",
        "            *list(map(FadeOut, [funny_business, braces]))\n",
        "        )\n",
        "\n",
        "        for term, group, region, num in zip(terms, photon_groups, regions, nums)[1:]:\n",
        "            group.set_stroke(WHITE)\n",
        "            self.play(Write(term, run_time = 1))\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    VGroup(region, group).shift, 0.5*UP,\n",
        "                    rate_func = wiggle,\n",
        "                    run_time = 1.5,\n",
        "                ),\n",
        "            )\n",
        "            self.play(MoveToTarget(num))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(rects[0]))\n",
        "        self.play(\n",
        "            VGroup(regions[0], all_out_of_C).shift, 0.5*UP,\n",
        "            run_time = 1.5,\n",
        "            rate_func = wiggle,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(rects[0], last_rects))\n",
        "        self.in_A_out_B.save_state()\n",
        "        self.in_A_in_B_out_C.save_state()\n",
        "        self.play(\n",
        "            self.in_A_out_B.set_fill, YELLOW, 0.5,\n",
        "            self.in_A_in_B_out_C.set_fill, YELLOW, 0.5,\n",
        "            Animation(self.photons)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(rects[0]),\n",
        "            self.in_A_out_B.restore,\n",
        "            self.in_A_in_B_out_C.restore,\n",
        "            Animation(self.in_A_out_C),\n",
        "            Animation(self.photons)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(should_be_50[1]),\n",
        "            ShowCreation(cross)\n",
        "        )\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        contradiction = OldTexText(\"Contradiction!\")\n",
        "        contradiction.next_to(morty, UP, aligned_edge = RIGHT)\n",
        "        contradiction.set_color(RED)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change, \"confused\", should_be_50,\n",
        "            Write(contradiction, run_time = 1)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "    def photons_jump_to_A_not_C_region(self):\n",
        "        in_C = self.in_C\n",
        "        in_C.sort(lambda p : np.dot(p, DOWN+RIGHT))\n",
        "        movers = VGroup(*self.in_C[:30])\n",
        "        for mover in movers:\n",
        "            mover.generate_target()\n",
        "            mover.target.shift(1.2*UP + 0.6*LEFT)\n",
        "            mover.target.set_stroke(WHITE)\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, movers,\n",
        "            path_arc = np.pi,\n",
        "            lag_ratio = 0.3\n",
        "        ))\n",
        "\n",
        "    def photon_thinks_in_A_out_C(self):\n",
        "        photon = self.photons[-1]\n",
        "        photon.save_state()\n",
        "        photon.generate_target()\n",
        "        photon.target.scale(4)\n",
        "        photon.target.center().to_edge(LEFT).shift(DOWN)\n",
        "        bubble = ThoughtBubble()\n",
        "        content = OldTex(\"A\", \"\\\\checkmark\", \",\", \"C\")\n",
        "        content.set_color_by_tex(\"checkmark\", \"#00ff00\")\n",
        "        cross = Cross(content[-1])\n",
        "        cross.set_color(\"#ff0000\")\n",
        "        content.add(cross)\n",
        "        bubble.add_content(content)\n",
        "        bubble.resize_to_content()\n",
        "        bubble.add(bubble.content)\n",
        "        bubble.pin_to(photon.target).shift(SMALL_BUFF*RIGHT)\n",
        "        bubble.save_state()\n",
        "        bubble.scale(0.25)\n",
        "        bubble.move_to(photon.get_corner(UP+RIGHT), DOWN+LEFT)\n",
        "        bubble.fade()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(photon),\n",
        "            bubble.restore,\n",
        "        )\n",
        "        self.play(photon.eyes.blink_anim())\n",
        "        self.play(\n",
        "            photon.restore, \n",
        "            FadeOut(bubble)\n",
        "        )\n",
        "\n",
        "\n",
        "    #######\n",
        "\n",
        "    def setup_venn_diagram_sections(self):\n",
        "        in_A_out_B, in_A_in_B_out_C, in_A_out_C, in_A_in_B = segments = VGroup(*[\n",
        "            SVGMobject(\n",
        "                file_name = \"VennDiagram_\" + s,\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 0.5,\n",
        "                fill_color = YELLOW,\n",
        "            )\n",
        "            for s in (\"in_A_out_B\", \"in_A_in_B_out_C\", \"in_A_out_C\", \"in_A_in_B\")\n",
        "        ])\n",
        "\n",
        "        in_A_out_B.scale(2.59)\n",
        "        in_A_out_B.move_to(3.74*UP + 2.97*RIGHT, UP+RIGHT)\n",
        "\n",
        "        in_A_in_B_out_C.scale(1.84)\n",
        "        in_A_in_B_out_C.move_to(2.23*UP, UP+RIGHT)\n",
        "\n",
        "        in_A_out_C.scale(2.56)\n",
        "        in_A_out_C.move_to(3*LEFT + (3.69)*UP, UP+LEFT)\n",
        "\n",
        "        in_A_in_B.scale(2.24)\n",
        "        in_A_in_B.move_to(2.23*UP + 3*LEFT, UP+LEFT)\n",
        "\n",
        "        segments.set_fill(BLACK, opacity = 0)\n",
        "\n",
        "        self.in_A_out_B = in_A_out_B\n",
        "        self.in_A_in_B_out_C = in_A_in_B_out_C\n",
        "        self.in_A_out_C = in_A_out_C\n",
        "        self.in_A_in_B = in_A_in_B\n",
        "        self.A_segments = segments\n",
        "\n",
        "    def arrange_photons_in_circle(self, photons):\n",
        "        R = np.sqrt(len(photons) / np.pi)\n",
        "        pairs = []\n",
        "        rejected = []\n",
        "        for x, y in it.product(*[list(range(-int(R)-1, int(R)+2))]*2):\n",
        "            if x**2 + y**2 < R**2:\n",
        "                pairs.append((x, y))\n",
        "            else:\n",
        "                rejected.append((x, y))\n",
        "        rejected.sort(\n",
        "            kay=lambda x, y: (x**2 + y**2)\n",
        "        )\n",
        "        for i in range(len(photons) - len(pairs)):\n",
        "            pairs.append(rejected.pop())\n",
        "        for photon, (x, y) in zip(photons, pairs):\n",
        "            photon.set_width(0.7)\n",
        "            photon.move_to(x*RIGHT + y*UP)\n",
        "        return photons\n",
        "\n",
        "class PonderingPiCreature(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN).shift(3*LEFT)\n",
        "        self.play(randy.change, \"pondering\", UP+RIGHT)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "class ReEmphasizeVennDiagram(VennDiagramProofByContradiction):\n",
        "    def construct(self):\n",
        "        self.draw_venn_diagram(send_to_corner = False)\n",
        "        self.rescale_diagram()\n",
        "        self.setup_faded_circles()\n",
        "        self.shift_B_circle()\n",
        "        self.shift_C_circle()\n",
        "        self.show_A_not_C_region()\n",
        "        self.shorten_labels()\n",
        "        self.show_inequality_with_circle()\n",
        "        # self.emphasize_containment()\n",
        "        self.write_50_percent()\n",
        "        self.write_assumption()\n",
        "        self.adjust_circles()\n",
        "\n",
        "    def rescale_diagram(self):\n",
        "        group = VGroup(self.venn_diagram, *[\n",
        "            c.label for c in self.venn_diagram\n",
        "        ])\n",
        "        self.play(\n",
        "            group.scale, 0.7,\n",
        "            group.to_edge, DOWN, MED_SMALL_BUFF,\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add_foreground_mobjects(*group)\n",
        "\n",
        "    def setup_faded_circles(self):\n",
        "        self.circles = self.venn_diagram[:3]\n",
        "        self.black_circles = VGroup(*[\n",
        "            circ.copy().set_stroke(width = 0).set_fill(BLACK, 1)\n",
        "            for circ in self.circles\n",
        "        ])\n",
        "        self.filled_circles = VGroup(*[\n",
        "            circ.copy().set_stroke(width = 0).set_fill(circ.get_color(), 1)\n",
        "            for circ in self.circles\n",
        "        ])\n",
        "\n",
        "    def shift_B_circle(self):\n",
        "        A, B, C = self.circles\n",
        "        A0, B0, C0 = self.black_circles\n",
        "        A1, B1, C1 = self.filled_circles\n",
        "\n",
        "        words = OldTexText(\"Should be 15\\\\% \\\\\\\\ of circle \", \"A\")\n",
        "        words.scale(0.7)\n",
        "        words.set_color_by_tex(\"A\", RED)\n",
        "        words.next_to(A, UP, LARGE_BUFF)\n",
        "        words.shift(RIGHT)\n",
        "        arrow = Arrow(\n",
        "            words.get_bottom(),\n",
        "            A.get_top() + MED_SMALL_BUFF*RIGHT,\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(A1))\n",
        "        self.play(FadeIn(B0))\n",
        "        self.play(\n",
        "            FadeIn(words, lag_ratio = 0.5),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        vect = 0.6*(A.get_center() - B.get_center())\n",
        "        self.play(\n",
        "            B0.shift, vect,\n",
        "            B.shift, vect,\n",
        "            B.label.shift, vect,\n",
        "            run_time = 2,\n",
        "            rate_func = running_start,\n",
        "        )\n",
        "        B1.shift(vect)\n",
        "        self.wait()\n",
        "\n",
        "        self.in_A_out_B_words = words\n",
        "        self.in_A_out_B_arrow = arrow\n",
        "        for mob in words, arrow:\n",
        "            mob.save_state()\n",
        "\n",
        "    def shift_C_circle(self):\n",
        "        A, B, C = self.circles\n",
        "        A0, B0, C0 = self.black_circles\n",
        "        A1, B1, C1 = self.filled_circles\n",
        "\n",
        "        words = OldTexText(\"Should be 15\\\\% \\\\\\\\ of circle \", \"B\")\n",
        "        words.scale(0.7)\n",
        "        words.set_color_by_tex(\"B\", GREEN)\n",
        "        words.next_to(B, LEFT)\n",
        "        words.shift(2.5*UP)\n",
        "        arrow = Arrow(\n",
        "            words.get_bottom(),\n",
        "            B.point_from_proportion(0.4),\n",
        "            color = GREEN\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(A1),\n",
        "            FadeOut(B0),\n",
        "            self.in_A_out_B_words.fade, 1,\n",
        "            self.in_A_out_B_arrow.fade, 1,\n",
        "            FadeIn(B1),\n",
        "            FadeIn(words, lag_ratio = 0.5),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.play(FadeIn(C0))\n",
        "        self.wait(2)\n",
        "        vect = 0.5*(B.get_center() - C.get_center())\n",
        "        self.play(\n",
        "            C0.shift, vect,\n",
        "            C.shift, vect,\n",
        "            C.label.shift, vect,\n",
        "            run_time = 2,\n",
        "            rate_func = running_start,\n",
        "        )\n",
        "        C1.shift(vect)\n",
        "        self.wait()\n",
        "\n",
        "        for mob in words, arrow:\n",
        "            mob.save_state()\n",
        "        self.in_B_out_C_words = words\n",
        "        self.in_B_out_C_arrow = arrow\n",
        "\n",
        "    def show_A_not_C_region(self):\n",
        "        A, B, C = self.circles\n",
        "        A0, B0, C0 = self.black_circles\n",
        "        A1, B1, C1 = self.filled_circles\n",
        "        A1_yellow_copy = A1.copy().set_fill(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(B1),\n",
        "            FadeOut(C0),\n",
        "            self.in_B_out_C_words.fade, 1,\n",
        "            self.in_B_out_C_arrow.fade, 1,\n",
        "            FadeIn(A1_yellow_copy)\n",
        "        )\n",
        "        self.play(FadeIn(C0))\n",
        "        self.wait()\n",
        "        self.A1_yellow_copy = A1_yellow_copy\n",
        "\n",
        "    def shorten_labels(self):\n",
        "        A, B, C = self.circles\n",
        "        A0, B0, C0 = self.black_circles\n",
        "        A1, B1, C1 = self.filled_circles\n",
        "        for circle in A, B, C:\n",
        "            circle.pre_label = VGroup(*circle.label[:-1])\n",
        "            circle.letter = circle.label[-1]\n",
        "\n",
        "        self.play(\n",
        "            A.pre_label.fade, 1,\n",
        "            A.letter.scale, 2,\n",
        "            A.letter.move_to, A.pre_label, LEFT,\n",
        "            B.pre_label.fade, 1,\n",
        "            B.letter.scale, 2, B.letter.get_right(),\n",
        "            C.pre_label.fade, 1,\n",
        "            C.letter.scale, 2,\n",
        "            C.letter.move_to, C.pre_label, LEFT,\n",
        "            C.letter.shift, DOWN+0.5*LEFT,\n",
        "        )\n",
        "        for circle in A, B, C:\n",
        "            circle.remove(circle.label)\n",
        "            self.remove(circle.label)\n",
        "            circle.add(circle.letter)\n",
        "            self.add(circle.letter)\n",
        "\n",
        "    def show_inequality_with_circle(self):\n",
        "        A, B, C = self.circles\n",
        "        A0, B0, C0 = self.black_circles\n",
        "        A1, B1, C1 = self.filled_circles\n",
        "        A1_yellow_copy = self.A1_yellow_copy\n",
        "\n",
        "        inequality = VGroup(\n",
        "            OldTex(\"N(\", \"A\", \"\\\\checkmark\", \",\", \"C\", \")\"),\n",
        "            OldTex(\"N(\", \"B\", \"\\\\checkmark\", \",\", \"C\", \")\"),\n",
        "            OldTex(\"N(\", \"A\", \"\\\\checkmark\", \",\", \"B\", \")\"),\n",
        "        )\n",
        "        inequality.arrange(RIGHT)\n",
        "        for tex in inequality:\n",
        "            tex.set_color_by_tex(\"checkmark\", \"#00ff00\")\n",
        "            if len(tex) > 1:\n",
        "                cross = Cross(tex[-2], color = \"#ff0000\")\n",
        "                cross.set_stroke(width = 8)\n",
        "                tex[-2].add(cross)\n",
        "        inequality.space_out_submobjects(2.1)\n",
        "        big_le = OldTex(\"\\\\le\").scale(2)\n",
        "        big_plus = OldTex(\"+\").scale(2)\n",
        "        big_le.move_to(2.75*LEFT)\n",
        "        big_plus.move_to(2.25*RIGHT)\n",
        "\n",
        "        groups = VGroup(*[\n",
        "            VGroup(\n",
        "                m2.copy(), m1.copy(),\n",
        "                VGroup(*self.circles).copy()\n",
        "            )\n",
        "            for m1, m2 in [(C0, A1_yellow_copy), (C0, B1), (B0, A1)]\n",
        "        ])\n",
        "        for group, vect in zip(groups[1:], [UP, 5*RIGHT+UP]):\n",
        "            group.scale(0.5)\n",
        "            group.shift(vect)\n",
        "            group.save_state()\n",
        "            group.shift(-vect[0]*RIGHT + 5*LEFT)\n",
        "        inequality.shift(2.25*DOWN + 0.25*LEFT)\n",
        "\n",
        "        self.in_B_out_C_words.restore()\n",
        "        self.in_B_out_C_words.move_to(2*UP)\n",
        "        self.in_A_out_B_words.restore()\n",
        "        self.in_A_out_B_words.move_to(5*RIGHT+2*UP)\n",
        "\n",
        "        self.clear()\n",
        "        self.play(\n",
        "            groups[0].scale, 0.5,\n",
        "            groups[0].shift, 5*LEFT + UP,\n",
        "            Write(inequality[0], run_time = 1),\n",
        "            FadeIn(big_le),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(groups[1]))\n",
        "        self.play(\n",
        "            groups[1].restore, \n",
        "            FadeIn(inequality[1]),\n",
        "            FadeIn(self.in_B_out_C_words),\n",
        "            FadeIn(big_plus),\n",
        "        )\n",
        "        self.play(FadeIn(groups[2]))\n",
        "        self.play(\n",
        "            groups[2].restore,\n",
        "            FadeIn(inequality[2]),\n",
        "            FadeIn(self.in_A_out_B_words),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.groups = groups\n",
        "        self.inequality = inequality\n",
        "\n",
        "    def emphasize_containment(self):\n",
        "        groups = self.groups\n",
        "        c1, c2 = [VGroup(*group[:2]).copy() for group in groups[1:]]\n",
        "        foreground = VGroup(groups[0][-1], *groups[1:])\n",
        "\n",
        "        rect = SurroundingRectangle(groups[0])\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                c1.shift, 4*LEFT,\n",
        "                path_arc = -np.pi/2,\n",
        "            ),\n",
        "            Animation(foreground)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                c2.shift, 8*LEFT,\n",
        "                path_arc = -np.pi/2,\n",
        "            ),\n",
        "            Animation(c1),\n",
        "            Animation(foreground),\n",
        "            run_time = 1.5\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(c2),\n",
        "            FadeOut(c1),\n",
        "            Animation(foreground),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def write_50_percent(self):\n",
        "        words = OldTexText(\n",
        "            \"Should be 50\\\\% \\\\\\\\ of circle \", \"A\",\n",
        "            \"...somehow\"\n",
        "        )\n",
        "        words.scale(0.7)\n",
        "        words.set_color_by_tex(\"A\", RED)\n",
        "        words.move_to(5*LEFT + 2*UP)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "    def write_assumption(self):\n",
        "        words = OldTexText(\"Assume circles have the same size$^*$\")\n",
        "        words.scale(0.8)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        footnote = OldTexText(\"\"\"\n",
        "            *If you prefer, you can avoid the need for that \n",
        "            assumption by swapping the roles of A and C here \n",
        "            and writing a second inequality for added constraint.\n",
        "        \"\"\")\n",
        "        footnote.scale(0.5)\n",
        "        footnote.to_corner(DOWN+RIGHT)\n",
        "        footnote.add(words[-1])\n",
        "        words.remove(words[-1])\n",
        "\n",
        "        self.footnote = footnote\n",
        "\n",
        "        self.play(FadeIn(words))\n",
        "\n",
        "    def adjust_circles(self):\n",
        "        groups = self.groups\n",
        "        A_group = VGroup(\n",
        "            groups[0][0],\n",
        "            groups[2][0],\n",
        "            groups[0][2][0],\n",
        "            groups[1][2][0],\n",
        "            groups[2][2][0],\n",
        "        )\n",
        "        B_group = VGroup(\n",
        "            groups[1][0],\n",
        "            groups[2][1],\n",
        "            groups[0][2][1],\n",
        "            groups[1][2][1],\n",
        "            groups[2][2][1],\n",
        "        )\n",
        "        C_group = VGroup(\n",
        "            groups[0][1],\n",
        "            groups[1][1],\n",
        "            groups[0][2][2],\n",
        "            groups[1][2][2],\n",
        "            groups[2][2][2],\n",
        "        )\n",
        "\n",
        "        def center_of_mass(mob):\n",
        "            return np.apply_along_axis(np.mean, 0, mob.get_points())\n",
        "\n",
        "        movers = [A_group, B_group, C_group]\n",
        "        A_ref, B_ref, C_ref = [g[4] for g in movers]\n",
        "        B_center = center_of_mass(B_ref)\n",
        "        B_to_A = center_of_mass(A_ref) - B_center\n",
        "        B_to_C = center_of_mass(C_ref) - B_center\n",
        "\n",
        "        A_freq = 1\n",
        "        C_freq = -0.7\n",
        "\n",
        "        self.time = 0\n",
        "        dt = 1 / self.camera.frame_rate\n",
        "\n",
        "        def move_around(total_time):\n",
        "            self.time\n",
        "            t_range = list(range(int(total_time/dt)))\n",
        "            for x in ProgressDisplay(t_range):\n",
        "                self.time += dt\n",
        "                new_B_to_A = rotate_vector(B_to_A, self.time*A_freq)\n",
        "                new_B_to_C = rotate_vector(B_to_C, self.time*C_freq)\n",
        "                A_group.shift(B_center + new_B_to_A - center_of_mass(A_ref))\n",
        "                C_group.shift(B_center + new_B_to_C - center_of_mass(C_ref))\n",
        "                self.wait(dt)\n",
        "\n",
        "        move_around(3)\n",
        "        self.add(self.footnote)\n",
        "        move_around(1)\n",
        "        self.remove(self.footnote)\n",
        "        move_around(15)\n",
        "\n",
        "class NoFirstMeasurementPreferenceBasedOnDirection(ShowVariousFilterPairs):\n",
        "    CONFIG = {\n",
        "        \"filter_x_coordinates\" : [0, 0, 0],\n",
        "        \"pol_filter_configs\" : [\n",
        "            {\"filter_angle\" : angle}\n",
        "            for angle in (0, np.pi/8, np.pi/4)\n",
        "        ],\n",
        "        \"lines_depth\" : 1.2,\n",
        "        \"lines_shift_vect\" : SMALL_BUFF*OUT,\n",
        "        \"n_lines\" : 30,\n",
        "    }\n",
        "    def setup(self):\n",
        "        DirectionOfPolarization.setup(self)\n",
        "        self.remove(self.axes, self.em_wave)\n",
        "        zs = [2.5, 0, -2.5]\n",
        "        chars = \"ABC\"\n",
        "        colors = [RED, GREEN, BLUE]\n",
        "        for z, char, color, pf in zip(zs, chars, colors, self.pol_filters):\n",
        "            pf.scale(0.7)\n",
        "            pf.move_to(z*OUT)\n",
        "            label = OldTexText(char)\n",
        "            label.add_background_rectangle()\n",
        "            label.set_color(color)\n",
        "            label.scale(0.7)\n",
        "            label.rotate(np.pi/2, RIGHT)\n",
        "            label.rotate(-np.pi/2, OUT)\n",
        "            label.next_to(pf.arrow_label, UP, SMALL_BUFF)\n",
        "            pf.arrow_label.add(label)\n",
        "\n",
        "            self.add_foreground_mobject(pf)\n",
        "\n",
        "    def construct(self):\n",
        "        self.reposition_camera()\n",
        "        self.show_lines()\n",
        "\n",
        "    def reposition_camera(self):\n",
        "        words = OldTexText(\"No statistical preference\")\n",
        "        words.to_corner(UP+LEFT)\n",
        "        words.rotate(np.pi/2, RIGHT)\n",
        "        self.move_camera(\n",
        "            theta = -0.6*np.pi,\n",
        "            added_anims = list(it.chain(*[\n",
        "                [\n",
        "                    pf.arrow_label.rotate, np.pi/2, OUT,\n",
        "                    pf.arrow_label.next_to, pf.arrow, OUT+RIGHT, SMALL_BUFF\n",
        "                ]\n",
        "                for pf in self.pol_filters\n",
        "            ] + [[FadeIn(words)]]))\n",
        "        )\n",
        "\n",
        "    def show_lines(self):\n",
        "        all_pre_lines = VGroup()\n",
        "        all_post_lines = VGroup()\n",
        "        for pf in self.pol_filters:\n",
        "            pre_lines = self.get_lines(None, pf)\n",
        "            post_lines = self.get_lines(pf, None)\n",
        "            VGroup(\n",
        "                *random.sample(post_lines, self.n_lines/2)\n",
        "            ).set_stroke(BLACK, 0)\n",
        "            all_pre_lines.add(*pre_lines)\n",
        "            all_post_lines.add(*post_lines)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\" : None,\n",
        "            \"lag_ratio\" : 0\n",
        "        }\n",
        "        self.play(ShowCreation(all_pre_lines, **kwargs))\n",
        "        self.play(\n",
        "            ShowCreation(all_post_lines, **kwargs),\n",
        "            Animation(self.pol_filters),\n",
        "            Animation(all_pre_lines),\n",
        "        )\n",
        "        self.add_foreground_mobject(all_pre_lines)\n",
        "        self.wait(7)\n"
    ]
}