{
    "topic": "demonstrates the concept of a neural network and its ability to classify images. It",
    "code": [
        "#!/usr/bin/env python\n",
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "import sys\n",
        "import os.path\n",
        "from functools import reduce\n",
        "\n",
        "sys.path.append(os.path.join(os.path.dirname(__file__), '..'))\n",
        "from constants import *\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from _2017.nn.network import *\n",
        "from _2017.nn.part1 import *\n",
        "\n",
        "\n",
        "class Test(Scene):\n",
        "    def construct(self):\n",
        "        network = get_pretrained_network()\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        self.show_weight_rows(network, index = 0)\n",
        "        # self.show_maximizing_inputs(network)\n",
        "        # self.show_all_activation_images(network, test_data)\n",
        "\n",
        "        # group = Group()\n",
        "        # for k in range(10):\n",
        "        #     v = np.zeros((10, 1))\n",
        "        #     v[k] = 1\n",
        "        #     h_group = Group()\n",
        "        #     for W, b in reversed(zip(network.weights, network.biases)):\n",
        "        #         h_group.add(MNistMobject(v))\n",
        "        #         v = np.dot(W.T, sigmoid_inverse(v) - b)\n",
        "        #         v = sigmoid(v)\n",
        "        #     h_group.add(MNistMobject(v))\n",
        "        #     h_group.arrange(LEFT)\n",
        "        #     group.add(h_group)\n",
        "        # group.arrange(DOWN)\n",
        "        # group.set_height(FRAME_HEIGHT - 1)\n",
        "        # self.add(group)\n",
        "\n",
        "\n",
        "    def show_random_results(self):\n",
        "        group = Group(*[\n",
        "            Group(*[\n",
        "                MNistMobject(a)\n",
        "                for a in network.get_activation_of_all_layers(\n",
        "                    np.random.randn(784, 1)\n",
        "                )\n",
        "            ]).arrange(RIGHT)\n",
        "            for x in range(10)\n",
        "        ]).arrange(DOWN)\n",
        "        group.set_height(FRAME_HEIGHT - 1)\n",
        "        self.add(group)\n",
        "\n",
        "    def show_weight_rows(self, network, index):\n",
        "        group = VGroup()\n",
        "        for row in network.weights[index]:\n",
        "            mob = PixelsFromVect(np.zeros(row.size))\n",
        "            for n, pixel in zip(row, mob):\n",
        "                color = GREEN if n > 0 else RED\n",
        "                opacity = 2*(sigmoid(abs(n)) - 0.5)\n",
        "                pixel.set_fill(color, opacity = opacity)\n",
        "            group.add(mob)\n",
        "        group.arrange_in_grid()\n",
        "        group.set_height(FRAME_HEIGHT - 1)\n",
        "        self.add(group)\n",
        "\n",
        "    def show_all_activation_images(self, network, test_data):\n",
        "        image_samples = Group(*[\n",
        "            self.get_activation_images(digit, network, test_data)\n",
        "            for digit in range(10)\n",
        "        ])\n",
        "        image_samples.arrange_in_grid(\n",
        "            n_rows = 2, buff = LARGE_BUFF\n",
        "        )\n",
        "        image_samples.set_height(FRAME_HEIGHT - 1)\n",
        "        self.add(image_samples)\n",
        "\n",
        "    def get_activation_images(self, digit, network, test_data, n_examples = 8):\n",
        "        input_vectors = [\n",
        "            data[0] \n",
        "            for data in test_data\n",
        "            if data[1] == digit\n",
        "        ]\n",
        "        activation_iamges = Group(*[\n",
        "            Group(*[\n",
        "                MNistMobject(a)\n",
        "                for a in network.get_activation_of_all_layers(vect)\n",
        "            ]).arrange(RIGHT)\n",
        "            for vect in input_vectors[:n_examples]\n",
        "        ]).arrange(DOWN)\n",
        "        activation_iamges.set_height(FRAME_HEIGHT - 1)\n",
        "        return activation_iamges\n",
        "\n",
        "    def show_two_blend(self):\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        vects = [\n",
        "            data[0]\n",
        "            for data in training_data[:30]\n",
        "            if np.argmax(data[1]) == 2\n",
        "        ]\n",
        "        mean_vect = reduce(op.add, vects)/len(vects)\n",
        "        self.add(MNistMobject(mean_vect))\n",
        "\n",
        "    def show_maximizing_inputs(self, network):\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        layer = 1\n",
        "        n_neurons = DEFAULT_LAYER_SIZES[layer]\n",
        "        groups = Group()\n",
        "        for k in range(n_neurons):\n",
        "            out = np.zeros(n_neurons)\n",
        "            out[k] = 1\n",
        "            in_vect = maximizing_input(network, layer, out)\n",
        "            new_out = network.get_activation_of_all_layers(in_vect)[layer]\n",
        "            group = Group(*list(map(MNistMobject, [in_vect, new_out])))\n",
        "            group.arrange(DOWN+RIGHT, SMALL_BUFF)\n",
        "            groups.add(group)\n",
        "        groups.arrange_in_grid()\n",
        "        groups.set_height(FRAME_HEIGHT - 1)\n",
        "        self.add(groups)\n",
        "\n",
        "    def show_test_input(self, network):\n",
        "        training_data, validation_data, test_data = load_data_wrapper()\n",
        "        group = Group(*[\n",
        "            self.get_set(network, test)\n",
        "            for test in test_data[3:20]\n",
        "            if test[1] in [4, 9]\n",
        "        ])\n",
        "        group.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        group.set_height(FRAME_HEIGHT - 1)\n",
        "        self.play(FadeIn(group))\n",
        "\n",
        "    def get_set(self, network, test):\n",
        "        test_in, test_out = test\n",
        "        activations = network.get_activation_of_all_layers(test_in)\n",
        "        group = Group(*list(map(MNistMobject, activations)))\n",
        "        group.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        return group\n",
        "\n",
        "    # def show_frame(self):\n",
        "    #     pass\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    save_pretrained_network()\n",
        "    test_network()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}