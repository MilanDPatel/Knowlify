{
    "topic": "The mathematical concept being demonstrated is the wave-like motion of a photon as it travels",
    "code": [
        "import numpy as np\n",
        "import itertools as it\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from from_3b1b.old.brachistochrone.curves import \\\n",
        "    Cycloid, PathSlidingScene, RANDY_SCALE_FACTOR, TryManyPaths\n",
        "\n",
        "\n",
        "class Lens(Arc):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 2,\n",
        "        \"angle\" : np.pi/2,\n",
        "        \"color\" : BLUE_B,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        Arc.__init__(self, self.angle, **kwargs)\n",
        "\n",
        "    def init_points(self):\n",
        "        Arc.init_points(self)\n",
        "        self.rotate(-np.pi/4)\n",
        "        self.shift(-self.get_left())\n",
        "        self.add_points(self.copy().rotate(np.pi).points)\n",
        "\n",
        "\n",
        "\n",
        "class PhotonScene(Scene):\n",
        "    def wavify(self, mobject):\n",
        "        result = mobject.copy()\n",
        "        result.ingest_submobjects()\n",
        "        tangent_vectors = result.get_points()[1:]-result.get_points()[:-1]\n",
        "        lengths = np.apply_along_axis(\n",
        "            get_norm, 1, tangent_vectors\n",
        "        )\n",
        "        thick_lengths = lengths.repeat(3).reshape((len(lengths), 3))\n",
        "        unit_tangent_vectors = tangent_vectors/thick_lengths\n",
        "        rot_matrix = np.transpose(rotation_matrix(np.pi/2, OUT))\n",
        "        normal_vectors = np.dot(unit_tangent_vectors, rot_matrix)\n",
        "        # total_length = np.sum(lengths)\n",
        "        times = np.cumsum(lengths)\n",
        "        nudge_sizes = 0.1*np.sin(2*np.pi*times)\n",
        "        thick_nudge_sizes = nudge_sizes.repeat(3).reshape((len(nudge_sizes), 3))\n",
        "        nudges = thick_nudge_sizes*normal_vectors\n",
        "        result.get_points()[1:] += nudges\n",
        "        return result\n",
        "\n",
        "\n",
        "    def photon_run_along_path(self, path, color = YELLOW, **kwargs):\n",
        "        if \"rate_func\" not in kwargs:\n",
        "            kwargs[\"rate_func\"] = None\n",
        "        photon = self.wavify(path)\n",
        "        photon.set_color(color)\n",
        "        return ShowPassingFlash(photon, **kwargs)\n",
        "\n",
        "\n",
        "class SimplePhoton(PhotonScene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Light\")\n",
        "        text.to_edge(UP)\n",
        "        self.play(ShimmerIn(text))\n",
        "        self.play(self.photon_run_along_path(\n",
        "            Cycloid(), rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MultipathPhotonScene(PhotonScene):\n",
        "    CONFIG = {\n",
        "        \"num_paths\" : 5\n",
        "    }\n",
        "    def run_along_paths(self, **kwargs):\n",
        "        paths = self.get_paths()\n",
        "        colors = Color(YELLOW).range_to(WHITE, len(paths))\n",
        "        for path, color in zip(paths, colors):\n",
        "            path.set_color(color)\n",
        "        photon_runs = [\n",
        "            self.photon_run_along_path(path)\n",
        "            for path in paths\n",
        "        ]\n",
        "        for photon_run, path in zip(photon_runs, paths):\n",
        "            self.play(\n",
        "                photon_run,\n",
        "                ShowCreation(\n",
        "                    path,\n",
        "                    rate_func = lambda t : 0.9*smooth(t)\n",
        "                ), \n",
        "                **kwargs\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def generate_paths(self):\n",
        "        raise Exception(\"Not Implemented\")\n",
        "\n",
        "\n",
        "class PhotonThroughLens(MultipathPhotonScene):\n",
        "    def construct(self):\n",
        "        self.lens = Lens()\n",
        "        self.add(self.lens)\n",
        "        self.run_along_paths()\n",
        "\n",
        "\n",
        "    def get_paths(self):\n",
        "        interval_values = np.arange(self.num_paths).astype('float')\n",
        "        interval_values /= (self.num_paths-1.)\n",
        "        first_contact = [\n",
        "            self.lens.point_from_proportion(0.4*v+0.55)\n",
        "            for v in reversed(interval_values)\n",
        "        ]\n",
        "        second_contact = [\n",
        "            self.lens.point_from_proportion(0.3*v + 0.1)\n",
        "            for v in interval_values\n",
        "        ]\n",
        "        focal_point = 2*RIGHT\n",
        "        return [\n",
        "            Mobject(\n",
        "                Line(FRAME_X_RADIUS*LEFT + fc[1]*UP, fc),\n",
        "                Line(fc, sc),\n",
        "                Line(sc, focal_point),\n",
        "                Line(focal_point, 6*focal_point-5*sc)\n",
        "            ).ingest_submobjects()\n",
        "            for fc, sc in zip(first_contact, second_contact)\n",
        "        ]\n",
        "\n",
        "class TransitionToOptics(PhotonThroughLens):\n",
        "    def construct(self):\n",
        "        optics = OldTexText(\"Optics\")\n",
        "        optics.to_edge(UP)\n",
        "        self.add(optics)\n",
        "        self.has_started = False\n",
        "        PhotonThroughLens.construct(self)\n",
        "\n",
        "    def play(self, *args, **kwargs):\n",
        "        if not self.has_started:\n",
        "            self.has_started = True\n",
        "            everything = Mobject(*self.mobjects)\n",
        "            vect = FRAME_WIDTH*RIGHT\n",
        "            everything.shift(vect)\n",
        "            self.play(ApplyMethod(\n",
        "                everything.shift, -vect,\n",
        "                rate_func = rush_from\n",
        "            ))\n",
        "        Scene.play(self, *args, **kwargs)\n",
        "\n",
        "\n",
        "class PhotonOffMirror(MultipathPhotonScene):\n",
        "    def construct(self):\n",
        "        self.mirror = Line(*FRAME_Y_RADIUS*np.array([DOWN, UP]))\n",
        "        self.mirror.set_color(GREY)\n",
        "        self.add(self.mirror)\n",
        "        self.run_along_paths()\n",
        "\n",
        "    def get_paths(self):\n",
        "        interval_values = np.arange(self.num_paths).astype('float')\n",
        "        interval_values /= (self.num_paths-1)\n",
        "        anchor_points = [\n",
        "            self.mirror.point_from_proportion(0.6*v+0.3)\n",
        "            for v in interval_values\n",
        "        ]\n",
        "        start_point = 5*LEFT+3*UP\n",
        "        end_points = []\n",
        "        for point in anchor_points:\n",
        "            vect = start_point-point\n",
        "            vect[1] *= -1\n",
        "            end_points.append(point+2*vect)\n",
        "        return [\n",
        "            Mobject(\n",
        "                Line(start_point, anchor_point), \n",
        "                Line(anchor_point, end_point)\n",
        "            ).ingest_submobjects()\n",
        "            for anchor_point, end_point in zip(anchor_points, end_points)\n",
        "        ]\n",
        "\n",
        "class PhotonsInWater(MultipathPhotonScene):\n",
        "    def construct(self):\n",
        "        water = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        self.add(water)\n",
        "        self.run_along_paths()\n",
        "\n",
        "    def get_paths(self):\n",
        "        x, y = -3, 3\n",
        "        start_point = x*RIGHT + y*UP\n",
        "        angles = np.arange(np.pi/18, np.pi/3, np.pi/18)\n",
        "        midpoints = y*np.arctan(angles)\n",
        "        end_points = midpoints + FRAME_Y_RADIUS*np.arctan(2*angles)\n",
        "        return [\n",
        "            Mobject(\n",
        "                Line(start_point, [midpoint, 0, 0]),\n",
        "                Line([midpoint, 0, 0], [end_point, -FRAME_Y_RADIUS, 0])\n",
        "            ).ingest_submobjects()\n",
        "            for midpoint, end_point in zip(midpoints, end_points)\n",
        "        ]\n",
        "\n",
        "\n",
        "class ShowMultiplePathsScene(PhotonScene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Which path minimizes travel time?\")\n",
        "        text.to_edge(UP)\n",
        "        self.generate_start_and_end_points()\n",
        "        point_a = Dot(self.start_point)\n",
        "        point_b = Dot(self.end_point)\n",
        "        A = OldTexText(\"A\").next_to(point_a, UP)\n",
        "        B = OldTexText(\"B\").next_to(point_b, DOWN)\n",
        "        paths = self.get_paths()\n",
        "\n",
        "        for point, letter in [(point_a, A), (point_b, B)]:\n",
        "            self.play(\n",
        "                ShowCreation(point),\n",
        "                ShimmerIn(letter)\n",
        "            )\n",
        "        self.play(ShimmerIn(text))\n",
        "        curr_path = paths[0].copy()\n",
        "        curr_path_copy = curr_path.copy().ingest_submobjects()\n",
        "        self.play(\n",
        "            self.photon_run_along_path(curr_path),\n",
        "            ShowCreation(curr_path_copy, rate_func = rush_into)\n",
        "        )\n",
        "        self.remove(curr_path_copy)\n",
        "        for path in paths[1:] + [paths[0]]:\n",
        "            self.play(Transform(curr_path, path, run_time = 4))\n",
        "        self.wait()\n",
        "        self.path = curr_path.ingest_submobjects()\n",
        "\n",
        "    def generate_start_and_end_points(self):\n",
        "        raise Exception(\"Not Implemented\")\n",
        "\n",
        "    def get_paths(self):\n",
        "        raise Exception(\"Not implemented\")\n",
        "\n",
        "\n",
        "class ShowMultiplePathsThroughLens(ShowMultiplePathsScene):\n",
        "    def construct(self):\n",
        "        self.lens = Lens()\n",
        "        self.add(self.lens)\n",
        "        ShowMultiplePathsScene.construct(self)\n",
        "\n",
        "    def generate_start_and_end_points(self):\n",
        "        self.start_point = 3*LEFT + UP\n",
        "        self.end_point = 2*RIGHT\n",
        "\n",
        "    def get_paths(self):\n",
        "        alphas = [0.25, 0.4, 0.58, 0.75]\n",
        "        lower_right, upper_right, upper_left, lower_left = list(map(\n",
        "            self.lens.point_from_proportion, alphas\n",
        "        ))\n",
        "        return [\n",
        "            Mobject(\n",
        "                Line(self.start_point, a),\n",
        "                Line(a, b),\n",
        "                Line(b, self.end_point)\n",
        "            ).set_color(color)\n",
        "            for (a, b), color in zip(\n",
        "                [\n",
        "                    (upper_left, upper_right),\n",
        "                    (upper_left, lower_right),\n",
        "                    (lower_left, lower_right),\n",
        "                    (lower_left, upper_right),\n",
        "                ],\n",
        "                Color(YELLOW).range_to(WHITE, 4)\n",
        "            )\n",
        "        ]\n",
        "\n",
        "\n",
        "class ShowMultiplePathsOffMirror(ShowMultiplePathsScene):\n",
        "    def construct(self):\n",
        "        mirror = Line(*FRAME_Y_RADIUS*np.array([DOWN, UP]))\n",
        "        mirror.set_color(GREY)\n",
        "        self.add(mirror)\n",
        "        ShowMultiplePathsScene.construct(self)\n",
        "\n",
        "    def generate_start_and_end_points(self):\n",
        "        self.start_point = 4*LEFT + 2*UP\n",
        "        self.end_point = 4*LEFT + 2*DOWN\n",
        "\n",
        "    def get_paths(self):\n",
        "        return [\n",
        "            Mobject(\n",
        "                Line(self.start_point, midpoint),\n",
        "                Line(midpoint, self.end_point)\n",
        "            ).set_color(color)\n",
        "            for midpoint, color in zip(\n",
        "                [2*UP, 2*DOWN],\n",
        "                Color(YELLOW).range_to(WHITE, 2)\n",
        "            )\n",
        "        ]\n",
        "\n",
        "\n",
        "class ShowMultiplePathsInWater(ShowMultiplePathsScene):\n",
        "    def construct(self):\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        self.generate_start_and_end_points()\n",
        "        straight = Line(self.start_point, self.end_point)\n",
        "        slow = OldTexText(\"Slow\")\n",
        "        slow.rotate(np.arctan(straight.get_slope()))\n",
        "        slow.shift(straight.get_points()[int(0.7*straight.get_num_points())])\n",
        "        slow.shift(0.5*DOWN)\n",
        "        too_long = OldTexText(\"Too long\")\n",
        "        too_long.shift(UP)\n",
        "        air = OldTexText(\"Air\").shift(2*UP)\n",
        "        water = OldTexText(\"Water\").shift(2*DOWN)\n",
        "\n",
        "        self.add(glass)\n",
        "        self.play(GrowFromCenter(air))\n",
        "        self.play(GrowFromCenter(water))\n",
        "        self.wait()\n",
        "        self.remove(air, water)\n",
        "        ShowMultiplePathsScene.construct(self)\n",
        "        self.play(\n",
        "            Transform(self.path, straight)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(slow))\n",
        "        self.wait()\n",
        "        self.remove(slow)\n",
        "        self.leftmost.ingest_submobjects()\n",
        "        self.play(Transform(self.path, self.leftmost, run_time = 3))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(too_long))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def generate_start_and_end_points(self):\n",
        "        self.start_point = 3*LEFT + 2*UP\n",
        "        self.end_point = 3*RIGHT + 2*DOWN\n",
        "\n",
        "    def get_paths(self):\n",
        "        self.leftmost, self.rightmost = result = [\n",
        "            Mobject(\n",
        "                Line(self.start_point, midpoint),\n",
        "                Line(midpoint, self.end_point)\n",
        "            ).set_color(color)\n",
        "            for midpoint, color in zip(\n",
        "                [3*LEFT, 3*RIGHT],\n",
        "                Color(YELLOW).range_to(WHITE, 2)\n",
        "            )\n",
        "        ]\n",
        "        return result\n",
        "\n",
        "\n",
        "class StraightLinesFastestInConstantMedium(PhotonScene):\n",
        "    def construct(self):\n",
        "        kwargs = {\"size\" : \"\\\\Large\"}\n",
        "        left = OldTexText(\"Speed of light is constant\", **kwargs)\n",
        "        arrow = OldTex(\"\\\\Rightarrow\", **kwargs)\n",
        "        right = OldTexText(\"Staight path is fastest\", **kwargs)\n",
        "        left.next_to(arrow, LEFT)\n",
        "        right.next_to(arrow, RIGHT)\n",
        "        squaggle, line = self.get_paths()        \n",
        "\n",
        "        self.play(*list(map(ShimmerIn, [left, arrow, right])))\n",
        "        self.play(ShowCreation(squaggle))\n",
        "        self.play(self.photon_run_along_path(\n",
        "            squaggle, run_time = 2, rate_func=linear\n",
        "        ))\n",
        "        self.play(Transform(\n",
        "            squaggle, line, \n",
        "            path_func = path_along_arc(np.pi)\n",
        "        ))\n",
        "        self.play(self.photon_run_along_path(line, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def get_paths(self):\n",
        "        squaggle = ParametricCurve(\n",
        "            lambda t : (0.5*t+np.cos(t))*RIGHT+np.sin(t)*UP,\n",
        "            start = -np.pi,\n",
        "            end = 2*np.pi\n",
        "        )\n",
        "        squaggle.shift(2*UP)\n",
        "        start, end = squaggle.get_points()[0], squaggle.get_points()[-1]\n",
        "        line = Line(start, end)\n",
        "        result = [squaggle, line]\n",
        "        for mob in result:\n",
        "            mob.set_color(BLUE_D)\n",
        "        return result\n",
        "\n",
        "class PhtonBendsInWater(PhotonScene, ZoomedScene):\n",
        "    def construct(self):\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        kwargs = {\n",
        "            \"density\" : self.zoom_factor*DEFAULT_POINT_DENSITY_1D\n",
        "        }\n",
        "        top_line = Line(FRAME_Y_RADIUS*UP+2*LEFT, ORIGIN, **kwargs)\n",
        "        extension = Line(ORIGIN, FRAME_Y_RADIUS*DOWN+2*RIGHT, **kwargs)\n",
        "        bottom_line = Line(ORIGIN, FRAME_Y_RADIUS*DOWN+RIGHT, **kwargs)\n",
        "        path1 = Mobject(top_line, extension)\n",
        "        path2 = Mobject(top_line, bottom_line)\n",
        "        for mob in path1, path2:\n",
        "            mob.ingest_submobjects()\n",
        "        extension.set_color(RED)\n",
        "        theta1 = np.arctan(bottom_line.get_slope())\n",
        "        theta2 = np.arctan(extension.get_slope())\n",
        "        arc = Arc(theta2-theta1, start_angle = theta1, radius = 2)\n",
        "        question_mark = OldTexText(\"$\\\\theta$?\")\n",
        "        question_mark.shift(arc.get_center()+0.5*DOWN+0.25*RIGHT)\n",
        "        wave = self.wavify(path2)\n",
        "        wave.set_color(YELLOW)\n",
        "        wave.scale(0.5)\n",
        "\n",
        "        self.add(glass)\n",
        "        self.play(ShowCreation(path1))\n",
        "        self.play(Transform(path1, path2))\n",
        "        self.wait()\n",
        "        # self.activate_zooming()\n",
        "        self.wait()        \n",
        "        self.play(ShowPassingFlash(\n",
        "            wave, run_time = 3, rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(extension))\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            ShimmerIn(question_mark)\n",
        "        )\n",
        "\n",
        "class LightIsFasterInAirThanWater(ShowMultiplePathsInWater):\n",
        "    def construct(self):\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        equation = OldTex(\"v_{\\\\text{air}} > v_{\\\\text{water}}\")\n",
        "        equation.to_edge(UP)\n",
        "        path = Line(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "        path1 = path.copy().shift(2*UP)\n",
        "        path2 = path.copy().shift(2*DOWN)\n",
        "\n",
        "        self.add(glass)\n",
        "        self.play(ShimmerIn(equation))\n",
        "        self.wait()\n",
        "        photon_runs = []\n",
        "        photon_runs.append(self.photon_run_along_path(\n",
        "            path1, rate_func = lambda t : min(1, 1.2*t)\n",
        "        ))\n",
        "        photon_runs.append(self.photon_run_along_path(path2))\n",
        "        self.play(*photon_runs, **{\"run_time\" : 2})\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GeometryOfGlassSituation(ShowMultiplePathsInWater):\n",
        "    def construct(self):\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        self.generate_start_and_end_points()\n",
        "        left = self.start_point[0]*RIGHT\n",
        "        right = self.end_point[0]*RIGHT\n",
        "        start_x = interpolate(left, right, 0.2)\n",
        "        end_x = interpolate(left, right, 1.0)\n",
        "        left_line = Line(self.start_point, left, color = RED_D)\n",
        "        right_line = Line(self.end_point, right, color = RED_D)\n",
        "        h_1, h_2 = list(map(Tex, [\"h_1\", \"h_2\"]))\n",
        "        h_1.next_to(left_line, LEFT)\n",
        "        h_2.next_to(right_line, RIGHT)\n",
        "        point_a = Dot(self.start_point)\n",
        "        point_b = Dot(self.end_point)\n",
        "        A = OldTexText(\"A\").next_to(point_a, UP)\n",
        "        B = OldTexText(\"B\").next_to(point_b, DOWN)\n",
        "\n",
        "        x = start_x\n",
        "        left_brace = Brace(Mobject(Point(left), Point(x)))\n",
        "        right_brace = Brace(Mobject(Point(x), Point(right)), UP)\n",
        "        x_mob = OldTex(\"x\")\n",
        "        x_mob.next_to(left_brace, DOWN)\n",
        "        w_minus_x = OldTex(\"w-x\")\n",
        "        w_minus_x.next_to(right_brace, UP)\n",
        "        top_line = Line(self.start_point, x)\n",
        "        bottom_line = Line(x, self.end_point)\n",
        "        top_dist = OldTex(\"\\\\sqrt{h_1^2+x^2}\")\n",
        "        top_dist.scale(0.5)\n",
        "        a = 0.3\n",
        "        n = top_line.get_num_points()\n",
        "        point = top_line.get_points()[int(a*n)]\n",
        "        top_dist.next_to(Point(point), RIGHT, buff = 0.3)\n",
        "        bottom_dist = OldTex(\"\\\\sqrt{h_2^2+(w-x)^2}\")\n",
        "        bottom_dist.scale(0.5)\n",
        "        n = bottom_line.get_num_points()\n",
        "        point = bottom_line.get_points()[int((1-a)*n)]\n",
        "        bottom_dist.next_to(Point(point), LEFT, buff = 1)\n",
        "\n",
        "        end_top_line = Line(self.start_point, end_x)\n",
        "        end_bottom_line = Line(end_x, self.end_point)\n",
        "        end_brace = Brace(Mobject(Point(left), Point(end_x)))\n",
        "        end_x_mob = OldTex(\"x\").next_to(end_brace, DOWN)\n",
        "\n",
        "        axes = Mobject(\n",
        "            NumberLine(),\n",
        "            NumberLine().rotate(np.pi/2).shift(7*LEFT)\n",
        "        )\n",
        "        graph = FunctionGraph(\n",
        "            lambda x : 0.4*(x+1)*(x-3)+4,\n",
        "            x_min = -2,\n",
        "            x_max = 4\n",
        "        )\n",
        "        graph.set_color(YELLOW)\n",
        "        Mobject(axes, graph).scale(0.2).to_corner(UP+RIGHT, buff = 1)\n",
        "        axes.add(OldTex(\"x\", size = \"\\\\small\").next_to(axes, RIGHT))\n",
        "        axes.add(OldTexText(\"Travel time\", size = \"\\\\small\").next_to(\n",
        "            axes, UP\n",
        "        ))\n",
        "        new_graph = graph.copy()\n",
        "        midpoint = new_graph.get_points()[new_graph.get_num_points()/2]\n",
        "        new_graph.filter_out(lambda p : p[0] < midpoint[0])\n",
        "        new_graph.reverse_points()\n",
        "        pairs_for_end_transform = [\n",
        "            (mob, mob.copy())\n",
        "            for mob in (top_line, bottom_line, left_brace, x_mob)\n",
        "        ]\n",
        "\n",
        "        self.add(glass, point_a, point_b, A, B)\n",
        "        line = Mobject(top_line, bottom_line).ingest_submobjects()\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(left_brace), \n",
        "            GrowFromCenter(x_mob)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(right_brace), \n",
        "            GrowFromCenter(w_minus_x)\n",
        "        )\n",
        "        self.play(ShowCreation(left_line), ShimmerIn(h_1))\n",
        "        self.play(ShowCreation(right_line), GrowFromCenter(h_2))\n",
        "        self.play(ShimmerIn(top_dist))\n",
        "        self.play(GrowFromCenter(bottom_dist))\n",
        "        self.wait(3)\n",
        "        self.clear()\n",
        "        self.add(glass, point_a, point_b, A, B, \n",
        "                 top_line, bottom_line, left_brace, x_mob)\n",
        "        self.play(ShowCreation(axes))\n",
        "        kwargs = {\n",
        "            \"run_time\" : 4,\n",
        "        }\n",
        "        self.play(*[\n",
        "            Transform(*pair, **kwargs)\n",
        "            for pair in [\n",
        "                (top_line, end_top_line),\n",
        "                (bottom_line, end_bottom_line),\n",
        "                (left_brace, end_brace),\n",
        "                (x_mob, end_x_mob)\n",
        "            ]\n",
        "        ]+[ShowCreation(graph, **kwargs)])\n",
        "        self.wait()\n",
        "        self.show_derivatives(graph)\n",
        "        line = self.show_derivatives(new_graph)\n",
        "        self.add(line)\n",
        "        self.play(*[\n",
        "            Transform(*pair, rate_func = lambda x : 0.3*smooth(x))\n",
        "            for pair in pairs_for_end_transform\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def show_derivatives(self, graph, run_time = 2):\n",
        "        step = self.frame_duration/run_time\n",
        "        for a in smooth(np.arange(0, 1-step, step)):\n",
        "            index = int(a*graph.get_num_points())\n",
        "            p1, p2 = graph.get_points()[index], graph.get_points()[index+1]\n",
        "            line = Line(LEFT, RIGHT)\n",
        "            line.rotate(angle_of_vector(p2-p1))\n",
        "            line.shift(p1)\n",
        "            self.add(line)\n",
        "            self.wait(self.frame_duration)\n",
        "            self.remove(line)\n",
        "        return line\n",
        "\n",
        "\n",
        "class Spring(Line):\n",
        "    CONFIG = {\n",
        "        \"num_loops\" : 5,\n",
        "        \"loop_radius\" : 0.3,\n",
        "        \"color\" : GREY\n",
        "    }\n",
        "\n",
        "    def init_points(self):\n",
        "        ## self.start, self.end\n",
        "        length = get_norm(self.end-self.start)\n",
        "        angle = angle_of_vector(self.end-self.start)\n",
        "        micro_radius = self.loop_radius/length\n",
        "        m = 2*np.pi*(self.num_loops+0.5)\n",
        "        def loop(t):\n",
        "            return micro_radius*(\n",
        "                RIGHT + np.cos(m*t)*LEFT + np.sin(m*t)*UP\n",
        "            )\n",
        "        new_epsilon = self.epsilon/(m*micro_radius)/length\n",
        "\n",
        "        self.add_points([\n",
        "            t*RIGHT + loop(t)\n",
        "            for t in np.arange(0, 1, new_epsilon)\n",
        "        ])\n",
        "        self.scale(length/(1+2*micro_radius))\n",
        "        self.rotate(angle)\n",
        "        self.shift(self.start)\n",
        "\n",
        "\n",
        "class SpringSetup(ShowMultiplePathsInWater):\n",
        "    def construct(self):\n",
        "        self.ring_shift_val = 6*RIGHT\n",
        "        self.slide_kwargs = {\n",
        "            \"rate_func\" : there_and_back,\n",
        "            \"run_time\" : 5\n",
        "        }\n",
        "\n",
        "        self.setup_background()\n",
        "        rod = Region(\n",
        "            lambda x, y : (abs(x) < 5) & (abs(y) < 0.05),\n",
        "            color = GOLD_E\n",
        "        )\n",
        "        ring = Arc(\n",
        "            angle = 11*np.pi/6,\n",
        "            start_angle = -11*np.pi/12,\n",
        "            radius = 0.2,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        ring.shift(-self.ring_shift_val/2)\n",
        "        self.generate_springs(ring)                \n",
        "\n",
        "\n",
        "        self.add_rod_and_ring(rod, ring)\n",
        "        self.slide_ring(ring)\n",
        "        self.wait()\n",
        "        self.add_springs()\n",
        "        self.add_force_definitions()\n",
        "        self.slide_system(ring)\n",
        "        self.show_horizontal_component(ring)\n",
        "        self.show_angles(ring)\n",
        "        self.show_equation()\n",
        "\n",
        "\n",
        "    def setup_background(self):\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        self.generate_start_and_end_points()\n",
        "        point_a = Dot(self.start_point)\n",
        "        point_b = Dot(self.end_point)\n",
        "        A = OldTexText(\"A\").next_to(point_a, UP)\n",
        "        B = OldTexText(\"B\").next_to(point_b, DOWN)\n",
        "        self.add(glass, point_a, point_b, A, B)\n",
        "\n",
        "    def generate_springs(self, ring):\n",
        "        self.start_springs, self.end_springs = [\n",
        "            Mobject(\n",
        "                Spring(self.start_point, r.get_top()),\n",
        "                Spring(self.end_point, r.get_bottom())\n",
        "            )\n",
        "            for r in (ring, ring.copy().shift(self.ring_shift_val))\n",
        "        ]\n",
        "        \n",
        "    def add_rod_and_ring(self, rod, ring):\n",
        "        rod_word = OldTexText(\"Rod\")\n",
        "        rod_word.next_to(Point(), UP)\n",
        "        ring_word = OldTexText(\"Ring\")\n",
        "        ring_word.next_to(ring, UP)\n",
        "        self.wait()\n",
        "        self.add(rod)\n",
        "        self.play(ShimmerIn(rod_word))\n",
        "        self.wait()\n",
        "        self.remove(rod_word)\n",
        "        self.play(ShowCreation(ring))\n",
        "        self.play(ShimmerIn(ring_word))\n",
        "        self.wait()\n",
        "        self.remove(ring_word)\n",
        "\n",
        "    def slide_ring(self, ring):\n",
        "        self.play(ApplyMethod(\n",
        "            ring.shift, self.ring_shift_val,\n",
        "            **self.slide_kwargs\n",
        "        ))\n",
        "\n",
        "    def add_springs(self):\n",
        "        colors = iter([BLACK, BLUE_E])\n",
        "        for spring in self.start_springs.split():\n",
        "            circle = Circle(color = next(colors))\n",
        "            circle.reverse_points()\n",
        "            circle.scale(spring.loop_radius)\n",
        "            circle.shift(spring.get_points()[0])\n",
        "\n",
        "            self.play(Transform(circle, spring))\n",
        "            self.remove(circle)\n",
        "            self.add(spring)\n",
        "            self.wait()\n",
        "\n",
        "    def add_force_definitions(self):\n",
        "        top_force = OldTex(\"F_1 = \\\\dfrac{1}{v_{\\\\text{air}}}\")\n",
        "        bottom_force = OldTex(\"F_2 = \\\\dfrac{1}{v_{\\\\text{water}}}\")\n",
        "        top_spring, bottom_spring = self.start_springs.split()\n",
        "        top_force.next_to(top_spring)\n",
        "        bottom_force.next_to(bottom_spring, DOWN, buff = -0.5)\n",
        "        words = OldTexText(\"\"\"\n",
        "            The force in a real spring is \n",
        "            proportional to that spring's length\n",
        "        \"\"\")\n",
        "        words.to_corner(UP+RIGHT)\n",
        "        for force in top_force, bottom_force:\n",
        "            self.play(GrowFromCenter(force))\n",
        "            self.wait()\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait(3)\n",
        "        self.remove(top_force, bottom_force, words)\n",
        "\n",
        "    def slide_system(self, ring):\n",
        "        equilibrium_slide_kwargs = dict(self.slide_kwargs)\n",
        "        def jiggle_to_equilibrium(t):\n",
        "            return 0.7*(1+((1-t)**2)*(-np.cos(10*np.pi*t)))\n",
        "        equilibrium_slide_kwargs = {\n",
        "            \"rate_func\" : jiggle_to_equilibrium,\n",
        "            \"run_time\" : 3\n",
        "        }\n",
        "        start = Mobject(ring, self.start_springs)\n",
        "        end = Mobject(\n",
        "            ring.copy().shift(self.ring_shift_val),\n",
        "            self.end_springs\n",
        "        )\n",
        "        for kwargs in self.slide_kwargs, equilibrium_slide_kwargs:\n",
        "            self.play(Transform(start, end, **kwargs))\n",
        "            self.wait()\n",
        "    \n",
        "    def show_horizontal_component(self, ring):\n",
        "        v_right = Vector(ring.get_top(), RIGHT)\n",
        "        v_left = Vector(ring.get_bottom(), LEFT)\n",
        "        self.play(*list(map(ShowCreation, [v_right, v_left])))\n",
        "        self.wait()\n",
        "        self.remove(v_right, v_left)\n",
        "\n",
        "    def show_angles(self, ring):\n",
        "        ring_center = ring.get_center()\n",
        "        lines, arcs, thetas = [], [], []\n",
        "        counter = it.count(1)\n",
        "        for point in self.start_point, self.end_point:\n",
        "            line = Line(point, ring_center, color = GREY)\n",
        "            angle = np.pi/2-np.abs(np.arctan(line.get_slope()))\n",
        "            arc = Arc(angle, radius = 0.5).rotate(np.pi/2)\n",
        "            if point is self.end_point:\n",
        "                arc.rotate(np.pi)\n",
        "            theta = OldTex(\"\\\\theta_%d\"%next(counter))\n",
        "            theta.scale(0.5)\n",
        "            theta.shift(2*arc.get_center())\n",
        "            arc.shift(ring_center)\n",
        "            theta.shift(ring_center)\n",
        "\n",
        "            lines.append(line)\n",
        "            arcs.append(arc)\n",
        "            thetas.append(theta)\n",
        "        vert_line = Line(2*UP, 2*DOWN)\n",
        "        vert_line.shift(ring_center)\n",
        "        top_spring, bottom_spring = self.start_springs.split()\n",
        "\n",
        "        self.play(\n",
        "            Transform(ring, Point(ring_center)),\n",
        "            Transform(top_spring, lines[0]),\n",
        "            Transform(bottom_spring, lines[1])\n",
        "        )\n",
        "        self.play(ShowCreation(vert_line))\n",
        "        anims = []\n",
        "        for arc, theta in zip(arcs, thetas):\n",
        "            anims += [\n",
        "                ShowCreation(arc),\n",
        "                GrowFromCenter(theta)\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def show_equation(self):\n",
        "        equation = OldTex([\n",
        "            \"\\\\left(\\\\dfrac{1}{\\\\phantom{v_air}}\\\\right)\",\n",
        "            \"\\\\sin(\\\\theta_1)\", \n",
        "            \"=\", \n",
        "            \"\\\\left(\\\\dfrac{1}{\\\\phantom{v_water}}\\\\right)\",\n",
        "            \"\\\\sin(\\\\theta_2)\"\n",
        "        ])\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        frac1, sin1, equals, frac2, sin2 = equation.split()\n",
        "        v_air, v_water = [\n",
        "            OldTex(\"v_{\\\\text{%s}}\"%s, size = \"\\\\Large\")\n",
        "            for s in (\"air\", \"water\")\n",
        "        ]\n",
        "        v_air.next_to(Point(frac1.get_center()), DOWN)\n",
        "        v_water.next_to(Point(frac2.get_center()), DOWN)\n",
        "        frac1.add(v_air)\n",
        "        frac2.add(v_water)\n",
        "        f1, f2 = [\n",
        "            OldTex(\"F_%d\"%d, size = \"\\\\Large\") \n",
        "            for d in (1, 2)\n",
        "        ]\n",
        "        f1.next_to(sin1, LEFT)\n",
        "        f2.next_to(equals, RIGHT)\n",
        "        sin2_start = sin2.copy().next_to(f2, RIGHT)\n",
        "        bar1 = OldTex(\"\\\\dfrac{\\\\qquad}{\\\\qquad}\")\n",
        "        bar2 = bar1.copy()\n",
        "        bar1.next_to(sin1, DOWN)\n",
        "        bar2.next_to(sin2, DOWN)        \n",
        "        v_air_copy = v_air.copy().next_to(bar1, DOWN)\n",
        "        v_water_copy = v_water.copy().next_to(bar2, DOWN)\n",
        "        bars = Mobject(bar1, bar2)\n",
        "        new_eq = equals.copy().center().shift(bars.get_center())\n",
        "        snells = OldTexText(\"Snell's Law\")\n",
        "        snells.set_color(YELLOW)\n",
        "        snells.shift(new_eq.get_center()[0]*RIGHT)\n",
        "        snells.shift(UP)\n",
        "\n",
        "        anims = []\n",
        "        for mob in f1, sin1, equals, f2, sin2_start:\n",
        "            anims.append(ShimmerIn(mob))\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "        for f, frac in (f1, frac1), (f2, frac2):\n",
        "            target = frac.copy().ingest_submobjects()\n",
        "            also = []\n",
        "            if f is f2:\n",
        "                also.append(Transform(sin2_start, sin2))\n",
        "                sin2 = sin2_start\n",
        "            self.play(Transform(f, target), *also)\n",
        "            self.remove(f)\n",
        "            self.add(frac)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(frac1),\n",
        "            FadeOut(frac2),\n",
        "            Transform(v_air, v_air_copy),\n",
        "            Transform(v_water, v_water_copy),\n",
        "            ShowCreation(bars),\n",
        "            Transform(equals, new_eq)\n",
        "        )\n",
        "        self.wait()\n",
        "        frac1 = Mobject(sin1, bar1, v_air)\n",
        "        frac2 = Mobject(sin2, bar2, v_water)\n",
        "        for frac, vect in (frac1, LEFT), (frac2, RIGHT):\n",
        "            self.play(ApplyMethod(\n",
        "                frac.next_to, equals, vect\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(snells))\n",
        "        self.wait()\n",
        "\n",
        "class WhatGovernsTheSpeedOfLight(PhotonScene, PathSlidingScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        self.add_cycloid_end_points()   \n",
        "\n",
        "        self.add(self.cycloid)\n",
        "        self.slide(randy, self.cycloid)\n",
        "        self.play(self.photon_run_along_path(self.cycloid))\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "class WhichPathWouldLightTake(PhotonScene, TryManyPaths):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            [\"Which path \", \"would \\\\emph{light} take\", \"?\"]\n",
        "        )\n",
        "        words.split()[1].set_color(YELLOW)\n",
        "        words.to_corner(UP+RIGHT)\n",
        "        self.add_cycloid_end_points()\n",
        "\n",
        "        anims = [\n",
        "            self.photon_run_along_path(\n",
        "                path, \n",
        "                rate_func = smooth\n",
        "            )\n",
        "            for path in  self.get_paths()\n",
        "        ]\n",
        "        self.play(anims[0], ShimmerIn(words))\n",
        "        for anim in anims[1:]:\n",
        "            self.play(anim)\n",
        "\n",
        "\n",
        "\n",
        "class StateSnellsLaw(PhotonScene):\n",
        "    def construct(self):\n",
        "        point_a = 3*LEFT+3*UP\n",
        "        point_b = 1.5*RIGHT+3*DOWN\n",
        "        midpoint = ORIGIN\n",
        "\n",
        "        lines, arcs, thetas = [], [], []\n",
        "        counter = it.count(1)\n",
        "        for point in point_a, point_b:\n",
        "            line = Line(point, midpoint, color = RED_D)\n",
        "            angle = np.pi/2-np.abs(np.arctan(line.get_slope()))\n",
        "            arc = Arc(angle, radius = 0.5).rotate(np.pi/2)\n",
        "            if point is point_b:\n",
        "                arc.rotate(np.pi)\n",
        "                line.reverse_points()\n",
        "            theta = OldTex(\"\\\\theta_%d\"%next(counter))\n",
        "            theta.scale(0.5)\n",
        "            theta.shift(2*arc.get_center())\n",
        "            arc.shift(midpoint)\n",
        "            theta.shift(midpoint)\n",
        "\n",
        "            lines.append(line)\n",
        "            arcs.append(arc)\n",
        "            thetas.append(theta)\n",
        "        vert_line = Line(2*UP, 2*DOWN)\n",
        "        vert_line.shift(midpoint)\n",
        "        path = Mobject(*lines).ingest_submobjects()\n",
        "        glass = Region(lambda x, y : y < 0, color = BLUE_E)\n",
        "        self.add(glass)\n",
        "        equation = OldTex([\n",
        "            \"\\\\dfrac{\\\\sin(\\\\theta_1)}{v_{\\\\text{air}}}\",\n",
        "            \"=\",            \n",
        "            \"\\\\dfrac{\\\\sin(\\\\theta_2)}{v_{\\\\text{water}}}\",\n",
        "        ])\n",
        "        equation.to_corner(UP+RIGHT)\n",
        "        exp1, equals, exp2 = equation.split()\n",
        "        snells_law = OldTexText(\"Snell's Law:\")\n",
        "        snells_law.set_color(YELLOW)\n",
        "        snells_law.to_edge(UP)\n",
        "\n",
        "        self.play(ShimmerIn(snells_law))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(path))\n",
        "        self.play(self.photon_run_along_path(path))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(vert_line))\n",
        "        self.play(*list(map(ShowCreation, arcs)))\n",
        "        self.play(*list(map(GrowFromCenter, thetas)))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(exp1))\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShimmerIn, [equals, exp2])))\n",
        "        self.wait()\n",
        "        \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}