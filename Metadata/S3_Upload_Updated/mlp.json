{
    "topic": "The mathematical concept being demonstrated is the Transformer architecture, specifically the attention mechanism and the multilayer",
    "code": [
        "import torch\n",
        "from scipy.stats import norm\n",
        "\n",
        "from _2024.transformers.helpers import *\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class LastTwoChapters(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show last two chapters\n",
        "        frame = self.frame\n",
        "        self.camera.light_source.set_z(15)\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        thumbnails = self.get_thumbnails()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, thumbnails, shift=UP, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show transformer schematic\n",
        "        blocks = Group(self.get_block() for x in range(10))\n",
        "        blocks[1::2].stretch(2, 2).set_opacity(1)\n",
        "\n",
        "        blocks.arrange(OUT, buff=0.5)\n",
        "        blocks.set_depth(8, stretch=True)\n",
        "        blocks.set_opacity(0.8)\n",
        "        blocks.apply_depth_test()\n",
        "\n",
        "        trans_title = Text(\"Transformer\", font_size=96)\n",
        "        trans_title.next_to(blocks, UP, buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-32, 0, 0, (0.56, 2.48, 0.32), 12.75),\n",
        "            thumbnails.animate.scale(0.5).arrange(RIGHT, buff=2.0).to_edge(UP, buff=0.25),\n",
        "            LaggedStartMap(FadeIn, blocks, shift=0.25 * UP, scale=1.5, lag_ratio=0.1),\n",
        "            FadeIn(trans_title, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Break out transformer as sequence of blocks\n",
        "        att_blocks = blocks[0::2]\n",
        "        mlp_blocks = blocks[1::2]\n",
        "\n",
        "        att_title = Text(\"Attention\", font_size=72)\n",
        "        mlp_title_full = Text(\"Multilayer Perceptron\", font_size=72)\n",
        "        mlp_title = Text(\"MLP\", font_size=72)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-3, -2, 0, (0.23, 2.57, 0.3), 12.75),\n",
        "            trans_title.animate.shift(2 * UP),\n",
        "            att_blocks.animate.shift(4 * LEFT),\n",
        "            mlp_blocks.animate.shift(4 * RIGHT),\n",
        "        )\n",
        "\n",
        "        att_icon = self.get_att_icon(att_blocks[-1])\n",
        "        mlp_icon = self.get_mlp_icon(mlp_blocks[-1])\n",
        "        att_title.next_to(att_blocks[-1], UP, buff=0.75)\n",
        "        for title in [mlp_title, mlp_title_full]:\n",
        "            title.next_to(mlp_blocks[-1], UP, buff=0.75)\n",
        "        self.play(\n",
        "            FadeIn(att_icon, lag_ratio=1e-3),\n",
        "            FadeIn(att_title, UP),\n",
        "            trans_title.animate.scale(0.75).set_opacity(0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(mlp_icon),\n",
        "            FadeIn(mlp_title_full, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(mlp_title_full, mlp_title)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show sports facts\n",
        "        sport_facts = VGroup(\n",
        "            Text(line)\n",
        "            for line in Path(DATA_DIR, \"athlete_sports.txt\").read_text().split(\"\\n\")\n",
        "        )\n",
        "        for fact in sport_facts:\n",
        "            fact.next_to(trans_title, UP)\n",
        "            fact.shift(random.uniform(-3, 3) * RIGHT)\n",
        "            fact.shift(random.uniform(0, 3) * UP)\n",
        "\n",
        "        self.remove(mlp_icon, mlp_title)\n",
        "        self.play(\n",
        "            FadeOut(thumbnails),\n",
        "            FadeOut(trans_title),\n",
        "            LaggedStart(\n",
        "                (Succession(FadeIn(fact), fact.animate.scale(0.5).set_opacity(0).move_to(mlp_blocks))\n",
        "                for fact in sport_facts),\n",
        "                lag_ratio=0.15,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask what is the MLP\n",
        "        rect = SurroundingRectangle(Group(mlp_blocks, mlp_title), buff=1.0)\n",
        "        rect.stretch(0.8, 1)\n",
        "        rect.match_z(mlp_blocks[-1])\n",
        "        question = Text(\"What are these?\", font_size=90)\n",
        "        question.next_to(rect, UP, buff=3.0)\n",
        "        question.match_color(rect)\n",
        "        question.set_fill(border_width=0.5)\n",
        "        arrow = Arrow(question, rect)\n",
        "        arrow.match_color(rect)\n",
        "\n",
        "        self.play(\n",
        "            Group(att_blocks, att_title).animate.fade(0.5),\n",
        "            ShowCreation(rect),\n",
        "            Write(question),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_thumbnails(self):\n",
        "        folder = \"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2024/transformers/Thumbnails\"\n",
        "        images = [\n",
        "            ImageMobject(str(Path(folder, \"Chapter5_TN5\"))),\n",
        "            ImageMobject(str(Path(folder, \"Chapter6_TN4\"))),\n",
        "        ]\n",
        "        thumbnails = Group(\n",
        "            Group(\n",
        "                SurroundingRectangle(image, buff=0).set_stroke(WHITE, 3),\n",
        "                image\n",
        "            )\n",
        "            for n, image in zip([5, 6], images)\n",
        "        )\n",
        "        thumbnails.set_height(3.5)\n",
        "        thumbnails.arrange(RIGHT, buff=1.0)\n",
        "        thumbnails.fix_in_frame()\n",
        "        return thumbnails\n",
        "\n",
        "    def get_att_icon(self, block, n_rows=8):\n",
        "        att_icon = Dot().get_grid(n_rows, n_rows)\n",
        "        att_icon.set_height(block.get_height() * 0.9)\n",
        "        att_icon.set_backstroke(BLACK, 0.5)\n",
        "        for dot in att_icon:\n",
        "            dot.set_fill(opacity=random.random()**5)\n",
        "        att_icon.move_to(block, OUT)\n",
        "        return att_icon\n",
        "\n",
        "    def get_mlp_icon(self, block, dot_buff=0.15, layer_buff=1.5, layer0_size=5):\n",
        "        layers = VGroup(\n",
        "            Dot().get_grid(layer0_size, 1, buff=dot_buff),\n",
        "            Dot().get_grid(2 * layer0_size, 1, buff=dot_buff),\n",
        "            Dot().get_grid(layer0_size, 1, buff=dot_buff),\n",
        "        )\n",
        "        layers.set_height(block.get_height() * 0.9)\n",
        "        layers.arrange(RIGHT, buff=layer_buff)\n",
        "        for layer in layers:\n",
        "            for dot in layer:\n",
        "                dot.set_fill(opacity=random.random())\n",
        "        layers.set_stroke(WHITE, 0.5)\n",
        "        lines = VGroup(\n",
        "            Line(dot1.get_center(), dot2.get_center(), buff=dot1.get_width() / 2)\n",
        "            for l1, l2 in zip(layers, layers[1:])\n",
        "            for dot1 in l1\n",
        "            for dot2 in l2\n",
        "        )\n",
        "        for line in lines:\n",
        "            line.set_stroke(\n",
        "                color=value_to_color(random.uniform(-10, 10)),\n",
        "                width=3 * random.random()**3\n",
        "            )\n",
        "\n",
        "        icon = VGroup(layers, lines)\n",
        "        icon.move_to(block, OUT)\n",
        "        return icon\n",
        "\n",
        "    def get_block(self, width=5, height=3, depth=1, color=GREY_D, opacity=0.8):\n",
        "        block = Cube(color=color, opacity=opacity)\n",
        "        block.deactivate_depth_test()\n",
        "        block.set_shape(width, height, depth)\n",
        "        block.set_shading(0.5, 0.5, 0.0)\n",
        "        block.sort(lambda p: np.dot(p, [-1, 1, 1]))\n",
        "        return block\n",
        "\n",
        "\n",
        "class AltLastTwoChapters(LastTwoChapters):\n",
        "    def construct(self):\n",
        "        # Show last two chapters\n",
        "        thumbnails = self.get_thumbnails()\n",
        "        thumbnails.set_height(2.0)\n",
        "        thumbnails.arrange(RIGHT, buff=2.0)\n",
        "        thumbnails.to_edge(UP)\n",
        "        for n, thumbnail in zip([5, 6], thumbnails):\n",
        "            label = Text(f\"Chapter {n}\")\n",
        "            label.next_to(thumbnail, DOWN, SMALL_BUFF)\n",
        "            thumbnail.add(label)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, thumbnails, shift=UP, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Focus on chapter 6\n",
        "        for thumbnail in thumbnails:\n",
        "            thumbnail.target = thumbnail.generate_target()\n",
        "            thumbnail.target.scale(1.25)\n",
        "            thumbnail.target[-1].scale(1.0 / 1.5).next_to(thumbnail.target[0], DOWN, SMALL_BUFF)\n",
        "        thumbnails[1].target.set_x(-2.85)\n",
        "        thumbnails[1].target.to_edge(UP, MED_SMALL_BUFF)\n",
        "        thumbnails[0].target.next_to(thumbnails[1].target, LEFT, buff=2.5)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, thumbnails)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MLPIcon(LastTwoChapters):\n",
        "    def construct(self):\n",
        "        # Add network\n",
        "        network = self.get_mlp_icon(Square(6), layer_buff=3.0, layer0_size=6)\n",
        "        self.play(Write(network, stroke_width=0.5, lag_ratio=1e-2, run_time=5))\n",
        "        self.wait()\n",
        "\n",
        "        # Propagate through\n",
        "        thick_layers = VGroup(network[1].family_members_with_points()).copy()\n",
        "        for line in thick_layers:\n",
        "            line.set_stroke(width=2 * line.get_width())\n",
        "            line.insert_n_curves(20)\n",
        "        self.play(LaggedStartMap(VShowPassingFlash, thick_layers, time_width=1.5, lag_ratio=5e-3, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MLPStepsPreview(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup framing\n",
        "        background = FullScreenRectangle()\n",
        "        top_frame, low_frame = frames = Rectangle(7, 3.25).replicate(2)\n",
        "        frames.arrange(DOWN, buff=0.5)\n",
        "        frames.to_edge(LEFT)\n",
        "        frames.set_fill(BLACK, 1)\n",
        "        frames.set_stroke(WHITE, 2)\n",
        "\n",
        "        titles = VGroup(\n",
        "            VGroup(Text(\"Structure:\"), Text(\"Easy\")),\n",
        "            VGroup(Text(\"Emergent behavior:\"), Text(\"Exceedingly challenging\")),\n",
        "        )\n",
        "        for title, frame, color in zip(titles, frames, [GREEN, RED]):\n",
        "            title.scale(2)\n",
        "            for part in title:\n",
        "                part.set_max_width(6)\n",
        "            title.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "            title.next_to(frame, RIGHT, buff=0.5)\n",
        "            title[1].set_color(color)\n",
        "\n",
        "        titles[0].save_state()\n",
        "        top_frame.save_state()\n",
        "        top_frame.set_shape(8, 6).center().to_edge(LEFT)\n",
        "        titles[0].next_to(top_frame, RIGHT, buff=0.5)\n",
        "\n",
        "        self.add(background)\n",
        "        self.add(top_frame)\n",
        "        self.add(titles[0][0])\n",
        "\n",
        "        # Add all steps\n",
        "        arrows = Vector(2.2 * RIGHT).get_grid(1, 3, buff=0.25)\n",
        "        arrows.move_to(top_frame)\n",
        "        up_proj = WeightMatrix(shape=(10, 6))\n",
        "        down_proj = WeightMatrix(shape=(6, 10))\n",
        "        VGroup(up_proj, down_proj).match_width(arrows[0])\n",
        "        up_proj.next_to(arrows[0], UP, buff=MED_SMALL_BUFF)\n",
        "        down_proj.next_to(arrows[2], UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        axes = Axes((-4, 4), (0, 4))\n",
        "        graph = axes.get_graph(lambda x: max(0, x))\n",
        "        graph.set_stroke(YELLOW, 5)\n",
        "        plot = VGroup(axes, graph)\n",
        "        plot.set_width(arrows[0].get_width() * 0.75)\n",
        "        plot.next_to(arrows[1], UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        labels = VGroup(*map(Text, [\"Linear\", \"ReLU\", \"Linear\"]))\n",
        "        for label, arrow in zip(labels, arrows):\n",
        "            label.next_to(arrow, DOWN)\n",
        "\n",
        "        structure = VGroup(arrows, labels, VGroup(up_proj, plot, down_proj))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, labels, shift=0.5 * RIGHT, lag_ratio=0.5),\n",
        "            Write(titles[0][1])\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(up_proj, shift=0.5 * UP),\n",
        "            FadeIn(down_proj, shift=0.5 * UP),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(FadeIn(plot, lag_ratio=1e-2))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Reference emergent structure\n",
        "\n",
        "        self.play(\n",
        "            Restore(top_frame),\n",
        "            Restore(titles[0]),\n",
        "            structure.animate.set_width(0.9 * top_frame.saved_state.get_width()).move_to(top_frame.saved_state),\n",
        "            FadeIn(low_frame, DOWN),\n",
        "            FadeIn(titles[1][0], DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(titles[1][1], stroke_color=RED)\n",
        "        )\n",
        "\n",
        "        # Data flying\n",
        "        kw = dict(font_size=16, shift_vect=0.5 * DOWN + 0.5 * RIGHT, word_shape=(5, 5))\n",
        "        data_modifying_matrix(self, up_proj, **kw)\n",
        "        data_modifying_matrix(self, down_proj, **kw)\n",
        "        self.wait()\n",
        "\n",
        "        # Swap out for toy example\n",
        "        toy_example_title = Text(\"Motivating Toy Example\", font_size=54)\n",
        "        toy_example_title.next_to(titles[1][0], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        strike = Line().replace(titles[1][0])\n",
        "        strike.set_stroke(RED, 8)\n",
        "\n",
        "        low_matrices = VGroup(up_proj, down_proj)\n",
        "        top_matrices = low_matrices.copy()\n",
        "        low_matrices.generate_target()\n",
        "        low_matrices.target.scale(1.75).arrange(RIGHT, buff=0.5)\n",
        "        low_matrices.target.move_to(low_frame, DOWN).shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(strike),\n",
        "            FadeOut(titles[1][1]),\n",
        "            titles[1][0].animate.set_opacity(0.5)\n",
        "        )\n",
        "        self.add(top_matrices)\n",
        "        self.play(\n",
        "            MoveToTarget(low_matrices),\n",
        "            FadeIn(toy_example_title, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write down fact\n",
        "        row_rect = SurroundingRectangle(low_matrices[0].get_rows()[0], buff=0.1)\n",
        "        col_rect = SurroundingRectangle(low_matrices[1].get_columns()[0], buff=0.1)\n",
        "        VGroup(row_rect, col_rect).set_stroke(WHITE, 1)\n",
        "        fact = Text(\"Michael Jordan plays Basketball\", font_size=36)\n",
        "        fact.next_to(frames[1].get_top(), DOWN)\n",
        "        fact.align_to(low_matrices, LEFT)\n",
        "        mj, bb = fact[\"Michael Jordan\"], fact[\"plays Basketball\"]\n",
        "        mj_brace = Brace(mj, DOWN, buff=0.1)\n",
        "        bb_brace = Brace(bb, DOWN).match_y(mj_brace)\n",
        "        mj_arrow = Arrow(row_rect, mj_brace, buff=0.05)\n",
        "        bb_arrow = Arrow(col_rect.get_top(), bb_brace, buff=0.05)\n",
        "\n",
        "        row_cover = BackgroundRectangle(low_matrices[0].get_rows()[1:], buff=0.05)\n",
        "        col_cover = BackgroundRectangle(low_matrices[1].get_columns()[1:], buff=0.05)\n",
        "        VGroup(row_cover, col_cover).set_fill(BLACK, 0.75)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(row_cover),\n",
        "            FadeIn(row_rect),\n",
        "            GrowFromCenter(mj_brace),\n",
        "            FadeIn(mj, 0.5 * UP)\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(col_cover),\n",
        "            FadeIn(col_rect),\n",
        "            GrowArrow(bb_arrow),\n",
        "            GrowFromCenter(bb_brace),\n",
        "            FadeIn(bb, 0.5 * UP)\n",
        "        )\n",
        "        self.add(*low_matrices, row_cover, col_cover, row_rect, col_rect)\n",
        "        self.play(\n",
        "            RandomizeMatrixEntries(low_matrices[0]),\n",
        "            RandomizeMatrixEntries(low_matrices[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MatricesVsIntuition(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add matrix\n",
        "        matrix = WeightMatrix(shape=(15, 15))\n",
        "        matrix.set_height(4)\n",
        "        matrix.to_edge(LEFT)\n",
        "\n",
        "        Text(\"Matrices filled with parameters\\nlearned during gradient descent\")\n",
        "        Text(\"Motivating examples which risk being\\noversimplifications of what true models do\")\n",
        "\n",
        "        self.add(matrix)\n",
        "\n",
        "\n",
        "class BasicMLPWalkThrough(InteractiveScene):\n",
        "    random_seed = 1\n",
        "\n",
        "    def construct(self):\n",
        "        # Init camera settings\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "        self.camera.light_source.set_z(15)\n",
        "\n",
        "        # Sequence of embeddings comes in to an MLP block\n",
        "        embedding_array = EmbeddingArray(shape=(6, 9))\n",
        "        embedding_array.set_width(10)\n",
        "\n",
        "        block = VCube(fill_color=GREY_D, fill_opacity=0.5)\n",
        "        block.sort(lambda p: p[2])\n",
        "        block[-1].set_fill(opacity=0)\n",
        "        block.set_stroke(GREY_B, 2, 0.25, behind=False)\n",
        "        block.set_shading(0.25, 0.25, 0.5)\n",
        "        block.set_shape(11, 4, 4)\n",
        "        block.move_to(0.5 * IN, IN)\n",
        "        block_title = Text(\"MLP\", font_size=90)\n",
        "        block_title.next_to(block, UP)\n",
        "\n",
        "        frame.reorient(-21, -12, 0, (0.34, -0.94, -0.18), 9.79)\n",
        "        frame.set_field_of_view(30 * DEGREES)\n",
        "        self.add(block, block_title)\n",
        "        self.play(FadeIn(embedding_array, shift=2 * OUT))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight one vector\n",
        "        index = 3\n",
        "        emb = embedding_array.embeddings[index]\n",
        "        highlight_rect = SurroundingRectangle(emb)\n",
        "        embedding_array.target = embedding_array.generate_target()\n",
        "        embedding_array.target.set_stroke(width=0)\n",
        "        embedding_array.target.set_opacity(0.5)\n",
        "        embedding_array.target[0][index].set_backstroke(BLACK, 2)\n",
        "        embedding_array.target[0][index].set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(embedding_array),\n",
        "            ShowCreation(highlight_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reorient\n",
        "        rot_about_up = 89 * DEGREES\n",
        "        rot_about_left = 1 * DEGREES\n",
        "        up_emb = emb.copy()  # For use down below\n",
        "        full_block = Group(block, embedding_array, highlight_rect, block_title)\n",
        "        full_block.target = full_block.generate_target()\n",
        "        full_block.target[0].set_depth(16, about_edge=IN, stretch=True)\n",
        "        full_block.target[0].set_height(5, about_edge=DOWN, stretch=True)\n",
        "        full_block.target.rotate(rot_about_up, UP)\n",
        "        full_block.target[:3].rotate(rot_about_left, LEFT)\n",
        "        full_block.target.scale(0.5)\n",
        "        full_block.target[3].rotate(90 * DEGREES, DOWN).next_to(full_block.target[0], UP, buff=0.5)\n",
        "        full_block.target.center().to_edge(DOWN, buff=0.75)\n",
        "        full_block.target[0][4].set_opacity(0.1)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-3, -2, 0, (-0.0, -2.0, 0.01), 6.48),\n",
        "            MoveToTarget(full_block),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Preview the sequence of operations\n",
        "        values = np.random.uniform(-10, 10, 9)\n",
        "        values[0] = 1.0\n",
        "        vects = VGroup(\n",
        "            NumericEmbedding(values=values, dark_color=GREY_B),\n",
        "            NumericEmbedding(values=np.clip(values, 0, np.inf), dark_color=GREY_B),\n",
        "            NumericEmbedding(length=6),\n",
        "        )\n",
        "        vects.set_width(emb.get_depth())\n",
        "        vects.arrange(RIGHT, buff=2.0)\n",
        "        vects.next_to(emb, RIGHT, buff=2.0)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Arrow(v1, v2)\n",
        "            for v1, v2 in zip([emb, *vects[:-1]], vects)\n",
        "        )\n",
        "        arrow_labels = VGroup(Text(\"Linear\"), Text(\"ReLU\"), Text(\"Linear\"))\n",
        "        arrow_labels.scale(0.5)\n",
        "\n",
        "        phases = VGroup()\n",
        "        simple_phases = VGroup()\n",
        "        for arrow, label, vect in zip(arrows, arrow_labels, vects):\n",
        "            label.next_to(arrow, UP)\n",
        "            phases.add(VGroup(arrow, label, vect))\n",
        "            simple_phases.add(VGroup(arrow, vect))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, vects, shift=RIGHT, lag_ratio=0.8),\n",
        "            LaggedStartMap(ShowCreation, arrows, lag_ratio=0.8),\n",
        "            LaggedStartMap(FadeIn, arrow_labels, lag_ratio=0.8),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the sum\n",
        "        sum_circuit, output_emb = self.get_sum_circuit(emb, vects[-1])\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(15, -4, 0, (0.82, -1.91, 0.04), 7.18),\n",
        "            ShowCreation(sum_circuit, lag_ratio=0.1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(emb, output_emb, path_arc=-30 * DEGREES),\n",
        "            TransformFromCopy(vects[2], output_emb, path_arc=-30 * DEGREES),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show all in parallel\n",
        "        simple_phases.add_to_back(highlight_rect)\n",
        "        simple_phases.add(VGroup(sum_circuit, output_emb))\n",
        "        simple_phase_copies = VGroup(\n",
        "            simple_phases.copy().match_z(emb)\n",
        "            for emb in embedding_array.embeddings\n",
        "        )\n",
        "        for sp_copy in simple_phase_copies:\n",
        "            for group in sp_copy[1:]:\n",
        "                arrow, vect = group\n",
        "                for entry in vect.get_entries():\n",
        "                    dot = Dot().scale(0.5)\n",
        "                    dot.match_color(entry)\n",
        "                    dot.set_fill(opacity=0.5)\n",
        "                    dot.move_to(entry)\n",
        "                    entry.become(dot)\n",
        "                group.fade(0.5)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, -48, 0, (0.55, -2.21, 0.18), 7.05),\n",
        "            LaggedStart((\n",
        "                TransformFromCopy(simple_phases, sp_copy)\n",
        "                for sp_copy in simple_phase_copies\n",
        "            ), lag_ratio=0.1),\n",
        "            FadeOut(block_title, time_span=(0, 1)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(frame.animate.reorient(9, -15, 0, (0.55, -2.21, 0.18), 7.05), run_time=4)\n",
        "        self.play(frame.animate.reorient(-24, -16, 0, (0.18, -2.13, 0.09), 7.63), run_time=12)\n",
        "        block_title.next_to(block, UP)\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            LaggedStartMap(FadeOut, simple_phase_copies, lag_ratio=0.1),\n",
        "            FadeIn(block_title),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show MJ -> Basketball example\n",
        "        example_fact = TexText(\"``Michael Jordan plays Basketball''\", font_size=60)\n",
        "        example_fact.to_edge(UP)\n",
        "\n",
        "        mj = TexText(\"Michael Jordan\", font_size=36)\n",
        "        mj.next_to(emb, UL)\n",
        "        mj_lines = VGroup(\n",
        "            Line(char.get_bottom(), emb.get_top(), buff=0.1, path_arc=10 * DEGREES)\n",
        "            for char in mj\n",
        "        )\n",
        "        mj_lines.set_stroke(YELLOW, 1, 0.5)\n",
        "\n",
        "        basketball = TexText(\"Basketball\", font_size=24)\n",
        "        basketball.next_to(vects[2], UP, buff=0.2)\n",
        "\n",
        "        self.play(Write(example_fact))\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(example_fact[mj.get_tex()].copy(), mj))\n",
        "        self.play(Write(mj_lines, stroke_width=2, stroke_color=YELLOW_B, lag_ratio=1e-2))\n",
        "        self.wait()\n",
        "\n",
        "        mover = emb.copy()\n",
        "        for vect in vects:\n",
        "            self.play(Transform(mover, vect, rate_func=linear))\n",
        "        self.remove(mover)\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(example_fact[basketball.get_tex()].copy(), basketball))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Multiply by the up-projection\n",
        "        up_proj = WeightMatrix(shape=(9, 6))\n",
        "        up_proj.set_height(3)\n",
        "        up_proj.to_corner(UL)\n",
        "        up_emb.set_height(2)\n",
        "        up_emb.next_to(up_proj, RIGHT)\n",
        "        up_emb[-2:].set_fill(YELLOW)  # Brackets\n",
        "\n",
        "        self.play(\n",
        "            phases[1:].animate.set_opacity(0.1),\n",
        "            sum_circuit.animate.set_stroke(opacity=0.1),\n",
        "            output_emb.animate.set_opacity(0.1),\n",
        "            FadeOut(mj),\n",
        "            FadeOut(mj_lines),\n",
        "            FadeOut(basketball),\n",
        "            FadeOut(example_fact),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(emb, up_emb))\n",
        "        self.play(FadeIn(up_proj, lag_ratio=0.01))\n",
        "        eq, rhs = show_matrix_vector_product(self, up_proj, up_emb)\n",
        "        self.wait()\n",
        "        data_modifying_matrix(self, up_proj, word_shape=(4, 7), fix_in_frame=True)\n",
        "        self.wait()\n",
        "\n",
        "        # Show machine\n",
        "        machine = MachineWithDials(\n",
        "            width=up_proj.get_width() + SMALL_BUFF,\n",
        "            height=up_proj.get_height() + SMALL_BUFF,\n",
        "            n_rows=8,\n",
        "            n_cols=9,\n",
        "        )\n",
        "        machine.move_to(up_proj)\n",
        "\n",
        "        self.play(FadeIn(machine))\n",
        "        self.play(machine.random_change_animation())\n",
        "        self.wait()\n",
        "        self.play(FadeOut(machine))\n",
        "\n",
        "        # Emphasize dot product with rows\n",
        "        n, m = up_proj.shape\n",
        "        n_rows_shown = 5\n",
        "        R_labels = VGroup(\n",
        "            Tex(R\"\\vec{\\textbf{R}}_\" + f\"{{{n}}}\")\n",
        "            for n in [*range(n_rows_shown - 1), \"n\"]\n",
        "        )\n",
        "        R_labels[-2].become(Tex(R\"\\vdots\").replace(R_labels[-2], dim_to_match=1))\n",
        "        R_labels.arrange(DOWN, buff=0.5)\n",
        "        R_labels.match_height(up_proj)\n",
        "        R_labels.move_to(up_proj)\n",
        "        h_lines = VGroup(\n",
        "            Line(up_proj.get_brackets()[0], R_labels, buff=0.1),\n",
        "            Line(R_labels, up_proj.get_brackets()[1], buff=0.1),\n",
        "        )\n",
        "        h_lines.set_stroke(GREY_A, 2)\n",
        "        row_labels = VGroup(\n",
        "            VGroup(R_label, h_lines.copy().match_y(R_label))\n",
        "            for R_label in R_labels\n",
        "        )\n",
        "        row_matrix = VGroup(\n",
        "            up_proj.get_brackets().copy(),\n",
        "            row_labels\n",
        "        )\n",
        "\n",
        "        E_label = Tex(R\"\\vec{\\textbf{E}}\")\n",
        "        E_label.match_height(R_labels[0])\n",
        "        E_label.set_color(YELLOW)\n",
        "        E_label.move_to(up_emb)\n",
        "        E_col = VGroup(\n",
        "            up_emb[-2:].copy(),\n",
        "            Line(up_emb.get_top(), E_label, buff=0.1).set_stroke(GREY_A, 2),\n",
        "            E_label,\n",
        "            Line(E_label, up_emb.get_bottom(), buff=0.1).set_stroke(GREY_A, 2),\n",
        "        )\n",
        "\n",
        "        dot_prods = VGroup()\n",
        "        for n, R_label in enumerate(R_labels):\n",
        "            if n == len(R_labels) - 2:\n",
        "                dot_prod = R_label.copy()\n",
        "            else:\n",
        "                dot_prod = VGroup(\n",
        "                    R_label.copy(),\n",
        "                    Tex(R\"\\cdot\"),\n",
        "                    E_label.copy(),\n",
        "                )\n",
        "                dot_prod.arrange(RIGHT, buff=0.1)\n",
        "                dot_prod[-1].align_to(dot_prod[0][1], DOWN)\n",
        "                dot_prod.set_width(rhs.get_width() * 0.75)\n",
        "            dot_prod.move_to(R_label)\n",
        "            dot_prods.add(dot_prod)\n",
        "        dot_prods.move_to(rhs)\n",
        "        dot_prod_rhs = VGroup(\n",
        "            rhs.get_brackets().copy(),\n",
        "            dot_prods,\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(up_proj, scale=1.1),\n",
        "            FadeIn(row_matrix, scale=1.1),\n",
        "            FadeOut(up_emb, scale=1.1),\n",
        "            FadeIn(E_col, scale=1.1),\n",
        "            FadeOut(rhs, scale=1.1),\n",
        "            FadeIn(dot_prod_rhs[0], scale=1.1),\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.wait()\n",
        "        for row_label, dot_prod in zip(row_labels, dot_prods):\n",
        "            R_label = row_label[0]\n",
        "            self.play(\n",
        "                TransformFromCopy(R_label, dot_prod[0]),\n",
        "                TransformFromCopy(R_label, dot_prod[1]),\n",
        "                TransformFromCopy(E_label, dot_prod[2]),\n",
        "                VShowPassingFlash(\n",
        "                    Line(row_label.get_left(), row_label.get_right()).set_stroke(YELLOW, 5).insert_n_curves(100),\n",
        "                    time_width=1.5\n",
        "                ),\n",
        "                VShowPassingFlash(\n",
        "                    Line(E_col.get_top(), E_col.get_bottom()).set_stroke(YELLOW, 5).insert_n_curves(100),\n",
        "                    time_width=1.5\n",
        "                ),\n",
        "                run_time=1\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # First name Michael direction\n",
        "        row_rect = SurroundingRectangle(row_labels[0])\n",
        "        row_rect.set_stroke(GREY_BROWN, 2)\n",
        "        row_rect.set_fill(GREY_BROWN, 0.25)\n",
        "        row_eq = Tex(\"=\").rotate(PI / 2)\n",
        "        row_eq.next_to(row_rect, UP, SMALL_BUFF)\n",
        "        first_name_label = Tex(R\"\\overrightarrow{\\text{First Name Michael}}\")\n",
        "        first_name_label.set_stroke(WHITE, 1)\n",
        "        first_name_label.match_width(row_rect)\n",
        "        first_name_label.next_to(row_eq, UP)\n",
        "\n",
        "        dot_prod = dot_prods[0]\n",
        "        dp_rect = SurroundingRectangle(dot_prod, buff=0.2)\n",
        "        dp_rect.set_stroke(RED)\n",
        "        dp_eq = Tex(\"=\")\n",
        "        dp_eq.next_to(dp_rect, RIGHT, SMALL_BUFF)\n",
        "        mde_rhs = VGroup(\n",
        "            Tex(R\"\\approx 1 \\quad \\text{If } \\vec{\\textbf{E}} \\text{ encodes ``First Name Michael''}\"),\n",
        "            Tex(R\"\\le 0 \\quad \\text{If not}\")\n",
        "        )\n",
        "        mde_rhs[0][R\"\\vec{\\textbf{E}}\"].set_color(YELLOW)\n",
        "        mde_rhs.scale(0.75)\n",
        "        mde_rhs.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        rhs_brace = Brace(mde_rhs, LEFT)\n",
        "        rhs_brace.next_to(dp_eq, RIGHT, SMALL_BUFF)\n",
        "        mde_rhs.next_to(rhs_brace, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(row_rect, scale=2),\n",
        "            FadeTransform(row_labels[0].copy(), first_name_label),\n",
        "            GrowFromCenter(row_eq),\n",
        "            frame.animate.reorient(0, 0, 0, (0.22, 0.54, 0.0), 9.27),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(TransformFromCopy(row_rect.copy().set_fill(opacity=0), dp_rect))\n",
        "        self.play(\n",
        "            Write(dp_eq),\n",
        "            GrowFromCenter(rhs_brace),\n",
        "            FadeIn(mde_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # \"First name Michael\" + \"Last name Jordan\"\n",
        "        fn_tex = R\"\\overrightarrow{\\text{F.N. Michael}}\"\n",
        "        ln_tex = R\"\\overrightarrow{\\text{L.N. Jordan}}\"\n",
        "        name_sum_label = Tex(f\"{fn_tex} + {ln_tex}\")\n",
        "        name_sum_label.match_width(row_rect).scale(1.2)\n",
        "        name_sum_label.next_to(row_eq, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(first_name_label, name_sum_label[:21]),\n",
        "            FadeIn(name_sum_label[21:], shift=RIGHT, scale=2),\n",
        "            FadeOut(mde_rhs),\n",
        "            FadeOut(rhs_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dist_rhs = VGroup(\n",
        "            Tex(R\"(\\vec{\\textbf{M}} + \\vec{\\textbf{J}}) \\cdot \\vec{\\textbf{E}}\"),\n",
        "            Tex(\"=\"),\n",
        "            Tex(R\"\\vec{\\textbf{M}} \\cdot \\vec{\\textbf{E}} + \\vec{\\textbf{J}} \\cdot \\vec{\\textbf{E}}\"),\n",
        "        )\n",
        "        dist_rhs.scale(0.75)\n",
        "        dist_rhs.arrange(RIGHT, buff=0.2)\n",
        "        dist_rhs.next_to(dp_eq, RIGHT)\n",
        "        for part in dist_rhs:\n",
        "            part[R\"\\vec{\\textbf{M}}\"].set_color(RED_B)\n",
        "            part[R\"\\vec{\\textbf{J}}\"].set_color(RED)\n",
        "            part[R\"\\vec{\\textbf{E}}\"].set_color(YELLOW)\n",
        "        under_brace = Brace(dist_rhs[2])\n",
        "\n",
        "        two_condition = TexText(R\"$\\approx 2$ \\; if $\\vec{\\textbf{E}}$ encodes ``Michael Jordan''\")\n",
        "        two_condition[R\"\\vec{\\textbf{E}}\"].set_color(YELLOW)\n",
        "        else_condition = TexText(R\"$\\le 1$ \\; Otherwise\")\n",
        "        VGroup(two_condition, else_condition).scale(0.75)\n",
        "        two_condition.next_to(under_brace, DOWN, aligned_edge=LEFT)\n",
        "        else_condition.next_to(two_condition, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransformPieces(name_sum_label[:21].copy(), dist_rhs[0][1:3]),\n",
        "            FadeTransformPieces(name_sum_label[21].copy(), dist_rhs[0][3]),\n",
        "            FadeTransformPieces(name_sum_label[22:].copy(), dist_rhs[0][4:6]),\n",
        "            FadeTransformPieces(dot_prod[1:].copy(), dist_rhs[0][7:]),\n",
        "            FadeIn(dist_rhs[0][0]),\n",
        "            FadeIn(dist_rhs[0][6]),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(dist_rhs[0].copy(), dist_rhs[2], lag_ratio=0.01, path_arc=-45 * DEGREES),\n",
        "            Write(dist_rhs[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_y(0.5),\n",
        "            GrowFromCenter(under_brace),\n",
        "            FadeIn(two_condition, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(else_condition, DOWN))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Go back to the numbers\n",
        "        for entry in rhs.get_entries():\n",
        "            entry.set_value(np.random.uniform(-10, 10))\n",
        "        rhs.get_entries()[0].set_value(2.0)\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                name_sum_label, row_eq, row_rect,\n",
        "                dp_rect, dp_eq, dist_rhs, under_brace,\n",
        "                two_condition, else_condition,\n",
        "            ]), lag_ratio=0.1, run_time=1),\n",
        "            frame.animate.reorient(0, 0, 0, (-0.06, -0.06, 0.0), 8.27),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(row_matrix),\n",
        "            FadeIn(up_proj),\n",
        "            FadeOut(E_col),\n",
        "            FadeIn(up_emb),\n",
        "            FadeOut(dot_prod_rhs),\n",
        "            FadeIn(rhs),\n",
        "        )\n",
        "\n",
        "        # Show other rows\n",
        "        questions = VGroup(*map(Text, [\n",
        "            \"Blah\",\n",
        "            \"Is it English?\",\n",
        "            \"Part of source code?\",\n",
        "            \"European country?\",\n",
        "            \"In quotation marks?\",\n",
        "            \"Something metallic?\",\n",
        "            \"A four-legged animal?\",\n",
        "        ]))\n",
        "        questions.scale(0.75)\n",
        "        rows = up_proj.get_rows()\n",
        "        rhs_entries = rhs.get_entries()\n",
        "        last_question = VGroup()\n",
        "        last_rect = VectorizedPoint(rows[1].get_top())\n",
        "        for index in range(1, 7):\n",
        "            for mob in [rows, rhs_entries]:\n",
        "                mob.target = mob.generate_target()\n",
        "                mob.target.set_opacity(0.25)\n",
        "                mob.target[index].set_opacity(1)\n",
        "            row_rect = SurroundingRectangle(rows[index])\n",
        "            row_rect.set_stroke(PINK, 2)\n",
        "            question = questions[index]\n",
        "            question.next_to(rows[index], UP, buff=0.15)\n",
        "            question.set_backstroke(BLACK, 3)\n",
        "            self.play(\n",
        "                MoveToTarget(rows),\n",
        "                MoveToTarget(rhs_entries),\n",
        "                FadeOut(last_question),\n",
        "                FadeIn(question),\n",
        "                FadeTransform(last_rect, row_rect, time_span=(0, 0.75)),\n",
        "                run_time=1.0\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            last_question = question\n",
        "            last_rect = row_rect\n",
        "        self.play(\n",
        "            rows.animate.set_opacity(1),\n",
        "            rhs.animate.set_opacity(1),\n",
        "            FadeOut(last_question),\n",
        "            FadeOut(last_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add a bias\n",
        "        plus = Tex(\"+\")\n",
        "        plus.next_to(up_emb, RIGHT)\n",
        "        bias = WeightMatrix(shape=(9, 1), ellipses_col=None)\n",
        "        bias.get_entries()[0].set_value(-1).set_color(RED)\n",
        "        bias.match_height(up_proj)\n",
        "        bias.next_to(plus)\n",
        "        bias_name = Text(\"Bias\")\n",
        "        bias_name.next_to(bias, UP)\n",
        "\n",
        "        eq.target = eq.generate_target()\n",
        "        eq.target.next_to(bias, RIGHT)\n",
        "        rhs.target = vects[0].copy()\n",
        "        rhs.target.replace(rhs, dim_to_match=1)\n",
        "        rhs.target.next_to(eq.target, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(plus),\n",
        "            FadeIn(bias, lag_ratio=0.1),\n",
        "            MoveToTarget(eq),\n",
        "            MoveToTarget(rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.scale(1.1, about_edge=DOWN),\n",
        "            Write(bias_name),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize the parameters are learned from data\n",
        "        data_modifying_matrix(self, bias, word_shape=(5, 1), alpha_maxes=(0.4, 0.9), fix_in_frame=True)\n",
        "        bias.get_entries()[0].set_value(-1).set_color(RED)\n",
        "\n",
        "        # Pull up the MJ example again\n",
        "        fe_rect = SurroundingRectangle(rhs.get_entries()[0], buff=0.1)  # fe = First entry\n",
        "        fe_rect.set_stroke(RED, 3)\n",
        "        fe_eq = Tex(\"=\")\n",
        "        fe_eq.next_to(fe_rect, RIGHT, SMALL_BUFF)\n",
        "        fe_expr = VGroup(dist_rhs[2].copy(), Tex(\"- 1\"))\n",
        "        fe_expr[1].set_height(fe_expr[0].get_height() * 0.8)\n",
        "        fe_expr.arrange(RIGHT)\n",
        "        fe_expr.next_to(fe_eq, RIGHT)\n",
        "\n",
        "        bias_rect = SurroundingRectangle(bias.get_entries()[0])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(fe_rect),\n",
        "            FadeIn(fe_eq, RIGHT),\n",
        "            Write(fe_expr)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(bias_rect))\n",
        "        self.wait()\n",
        "        self.play(bias_rect.animate.surround(fe_expr[1]))\n",
        "        self.wait()\n",
        "        self.play(bias_rect.animate.surround(fe_expr))\n",
        "        self.wait()\n",
        "\n",
        "        # Show what it means, but now shifted\n",
        "        conditions = VGroup(\n",
        "            TexText(R\"$\\approx 1$ \\; if $\\vec{\\textbf{E}}$ encodes ``Michael Jordan''\"),\n",
        "            TexText(R\"$\\le 0$ \\; Otherwise\"),\n",
        "        )\n",
        "        conditions[0][R\"\\vec{\\textbf{E}}\"].set_color(YELLOW)\n",
        "        conditions.scale(0.75)\n",
        "        conditions.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        under_brace = Brace(fe_expr, DOWN)\n",
        "        conditions.next_to(under_brace, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(bias_rect),\n",
        "            GrowFromCenter(under_brace),\n",
        "            FadeIn(conditions[0], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(conditions[1], 0.25 * DOWN))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-2.5, 0.44, 0.0), 9.33),\n",
        "            LaggedStart(*map(FadeOut, [\n",
        "                fe_rect, fe_eq, fe_expr,\n",
        "                under_brace, *conditions\n",
        "            ]))\n",
        "        )\n",
        "\n",
        "        # Show the matrix size\n",
        "        up_proj.refresh_bounding_box()\n",
        "        row_rects = VGroup(\n",
        "            SurroundingRectangle(row, buff=0.1)\n",
        "            for row in up_proj.get_rows()\n",
        "        )\n",
        "        row_rects.set_stroke(WHITE, 1)\n",
        "        row_rects.set_fill(GREY_C, 0.25)\n",
        "        row_rects[-2].match_width(row_rects, stretch=True)\n",
        "\n",
        "        over_brace = Brace(row_rects[0], UP, buff=SMALL_BUFF)\n",
        "        d_model = 12288\n",
        "        row_size = Integer(d_model)\n",
        "        row_size.next_to(over_brace, UP)\n",
        "        side_brace = Brace(row_rects, LEFT)\n",
        "        num_rows = Integer(4 * d_model)\n",
        "        num_rows.next_to(side_brace, LEFT)\n",
        "        num_rows_expr = Tex(R\"4 \\times 12{,}288\")\n",
        "        num_rows_expr.next_to(side_brace, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(row_rects, lag_ratio=0.5),\n",
        "            GrowFromCenter(side_brace),\n",
        "            CountInFrom(num_rows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(num_rows, num_rows_expr))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(num_rows_expr[\"12{,}288\"].copy(), row_size),\n",
        "            TransformFromCopy(side_brace, over_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(row_rects, lag_ratio=0.1))\n",
        "\n",
        "        # Calculate matrix size\n",
        "        full_product = VGroup(\n",
        "            num_rows_expr.copy(),\n",
        "            Tex(R\"\\times\"),\n",
        "            row_size.copy(),\n",
        "            Tex(Rf\"=\"),\n",
        "            Integer(4 * d_model * d_model)\n",
        "        )\n",
        "        full_product.scale(1.5)\n",
        "        full_product.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        full_product.next_to(row_rects, UP, buff=2.5)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            frame.animate.reorient(0, 0, 0, (-3.88, 1.51, 0.0), 11.35),\n",
        "            TransformFromCopy(num_rows_expr, full_product[0]),\n",
        "            FadeIn(full_product[1], UP),\n",
        "            TransformFromCopy(row_size, full_product[2]),\n",
        "            lag_ratio=0.25,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(full_product[:3], full_product[3:])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(full_product[-1], run_time=2, time_width=1.5))\n",
        "\n",
        "        # Count bias parameters\n",
        "        bias_count = Tex(R\"4 \\times 12{,}288\")\n",
        "        bias_count.match_height(full_product)\n",
        "        bias_count.match_y(full_product)\n",
        "        bias_count.match_x(bias)\n",
        "        bias_rect = SurroundingRectangle(VGroup(bias, bias_name))\n",
        "        bias_rect.set_stroke(BLUE_B)\n",
        "        bias_arrow = Arrow(bias_rect.get_top(), bias_count.get_bottom())\n",
        "        bias_arrow.match_color(bias_rect)\n",
        "        bias_count.match_color(bias_rect)\n",
        "\n",
        "        div_eq = Tex(R\"{4 \\times 12{,}288 \\over 603{,}979{,}776} \\approx 0.00008 \")\n",
        "        div_eq[R\"{4 \\times 12{,}288\"].match_color(bias_rect)\n",
        "        div_eq.next_to(frame.get_corner(UR), DL, buff=MED_LARGE_BUFF)\n",
        "        div_eq.shift(RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(bias_rect))\n",
        "        self.play(\n",
        "            GrowArrow(bias_arrow),\n",
        "            FadeInFromPoint(bias_count, bias_arrow.get_start()),\n",
        "            full_product.animate.scale(0.8).shift(3.5 * LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_x(-3.0),\n",
        "            FadeTransform(bias_count.copy(), div_eq[R\"4 \\times 12{,}288\"]),\n",
        "            Write(div_eq[R\"\\over\"]),\n",
        "            FadeTransform(full_product[-1].copy(), div_eq[R\"603{,}979{,}776}\"]),\n",
        "            Write(div_eq[R\"\\approx 0.00008\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-2.5, 0.44, 0.0), 9.33),\n",
        "            *map(FadeOut, [full_product, bias_rect, bias_arrow, bias_count, div_eq])\n",
        "        )\n",
        "\n",
        "        # Collapse\n",
        "        substrs = [R\"W_\\uparrow\", R\"\\vec{\\textbf{E}}_i\", \"+\", R\"\\vec{\\textbf{B}}_\\uparrow\"]\n",
        "        linear_expr = Tex(\" \".join(substrs))\n",
        "        W_up, E_i, plus2, B_up = [linear_expr[ss] for ss in substrs]\n",
        "        VGroup(W_up, B_up).set_color(BLUE)\n",
        "        E_i.set_color(YELLOW)\n",
        "        linear_expr.move_to(plus).shift(0.6 * LEFT)\n",
        "\n",
        "        low_emb_label = E_i.copy()\n",
        "        low_emb_label.scale(0.5).next_to(emb, UP)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-0.03, 0.03, 0.0), 8.34),\n",
        "            ReplacementTransform(up_proj, W_up, lag_ratio=1e-3),\n",
        "            FadeOut(side_brace, RIGHT, scale=0.5),\n",
        "            FadeOut(num_rows_expr, RIGHT, scale=0.5),\n",
        "            FadeOut(over_brace, DR, scale=0.5),\n",
        "            FadeOut(row_size, DR, scale=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(up_emb, E_i, lag_ratio=1e-2))\n",
        "        self.play(TransformFromCopy(E_i, low_emb_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(plus, plus2),\n",
        "            ReplacementTransform(bias, B_up, lag_ratio=1e-2),\n",
        "            FadeOut(bias_name, DL),\n",
        "            VGroup(eq, rhs).animate.next_to(B_up, RIGHT).shift(0.1 * DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add parameters below first linear arrow\n",
        "        self.play(\n",
        "            linear_expr.animate.scale(0.5).next_to(arrows[0], DOWN, buff=0.1),\n",
        "            ReplacementTransform(rhs, vects[0]),\n",
        "            FadeOut(eq, 4 * DOWN + LEFT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pull up ReLU\n",
        "        self.play(phases[1].animate.set_opacity(1))\n",
        "        phase1_copy = VGroup(vects[0], arrows[1], vects[1]).copy()\n",
        "        phase1_copy.save_state()\n",
        "\n",
        "        self.play(\n",
        "            phase1_copy.animate.scale(2.0).next_to(full_block, UP, buff=0.5),\n",
        "            frame.animate.reorient(0, 0, 0, (-0.26, 0.54, 0.0), 9.40)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Break down ReLU\n",
        "        relu_arrow = phase1_copy[1]\n",
        "        neg_arrows = VGroup()\n",
        "        pos_arrows = VGroup()\n",
        "        neg_left_rects = VGroup()\n",
        "        zero_right_rects = VGroup()\n",
        "        pos_left_rects = VGroup()\n",
        "        pos_right_rects = VGroup()\n",
        "        in_vect = phase1_copy[0]\n",
        "        out_vect = phase1_copy[2]\n",
        "        for e1, e2 in zip(in_vect.get_entries(), out_vect.get_entries()):\n",
        "            arrow = Arrow(e1, e2, buff=0.3)\n",
        "            if e1.get_value() > 0:\n",
        "                arrow.set_color(BLUE)\n",
        "                pos_arrows.add(arrow)\n",
        "                pos_left_rects.add(SurroundingRectangle(e1, color=BLUE))\n",
        "                pos_right_rects.add(SurroundingRectangle(e2, color=BLUE))\n",
        "            else:\n",
        "                arrow.set_color(RED)\n",
        "                neg_arrows.add(arrow)\n",
        "                neg_left_rects.add(SurroundingRectangle(e1, color=RED))\n",
        "                zero_right_rects.add(SurroundingRectangle(e2, color=RED))\n",
        "        VGroup(neg_left_rects, zero_right_rects, pos_left_rects, pos_right_rects).set_stroke(width=2)\n",
        "\n",
        "        self.play(ShowCreation(neg_left_rects, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(neg_left_rects, zero_right_rects, lag_ratio=0.5),\n",
        "            ShowCreation(neg_arrows, lag_ratio=0.5),\n",
        "            FadeOut(relu_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(neg_left_rects, lag_ratio=0.25),\n",
        "            FadeOut(zero_right_rects, lag_ratio=0.25),\n",
        "            FadeOut(neg_arrows, lag_ratio=0.25),\n",
        "            ShowCreation(pos_left_rects)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(pos_arrows, lag_ratio=0.5),\n",
        "            TransformFromCopy(pos_left_rects, pos_right_rects, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Graph ReLU\n",
        "        relu_title_full = Text(\"Rectified\\nLinear\\nUnit\", alignment=\"LEFT\")\n",
        "        relu_title_full.next_to(relu_arrow, UP)\n",
        "\n",
        "        axes = Axes((-4, 4), (-1, 4))\n",
        "        axes.set_width(6)\n",
        "        axes.next_to(phase1_copy, RIGHT, buff=1.0)\n",
        "        axes.add_coordinate_labels(font_size=16)\n",
        "        relu_graph = axes.get_graph(lambda x: max(0, x), discontinuities=[0])\n",
        "        relu_graph.set_stroke(YELLOW, 4)\n",
        "        plot = VGroup(axes, relu_graph)\n",
        "\n",
        "        relu_graph_label = Text(\"ReLU\")\n",
        "        relu_graph_label.match_color(relu_graph)\n",
        "        relu_graph_label.move_to(axes, UL)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_x(2.7),\n",
        "            FadeIn(relu_arrow),\n",
        "            FadeIn(relu_title_full, 0.1 * UP, lag_ratio=0.1, run_time=2),\n",
        "            FadeOut(pos_arrows, lag_ratio=0.25),\n",
        "            FadeOut(pos_left_rects, lag_ratio=0.25),\n",
        "            FadeOut(pos_right_rects, lag_ratio=0.25),\n",
        "            FadeIn(plot, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*(\n",
        "            TransformFromCopy(relu_title_full[substr], relu_graph_label[substr])\n",
        "            for substr in [\"Re\", \"L\", \"U\"]\n",
        "        ))\n",
        "        self.add(relu_graph_label)\n",
        "\n",
        "        # Recall the meaning of the first entry\n",
        "        mid_vect = phase1_copy[0]\n",
        "        conditions_rect = SurroundingRectangle(conditions, buff=0.25)\n",
        "        conditions_rect.set_stroke(YELLOW, 1)\n",
        "        under_brace = Brace(conditions_rect, DOWN, buff=SMALL_BUFF)\n",
        "        VGroup(conditions, conditions_rect, under_brace).next_to(mid_vect, UP)\n",
        "        fe_rect = SurroundingRectangle(mid_vect.get_entries()[0])\n",
        "\n",
        "        condition_group = VGroup(fe_rect, under_brace, conditions, conditions_rect)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2.61, 0.97, 0.0), 11.5),\n",
        "            ShowCreation(fe_rect),\n",
        "            GrowFromCenter(under_brace),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(fe_rect, conditions_rect),\n",
        "            FadeInFromPoint(conditions, fe_rect.get_center()),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(condition_group.animate.match_x(phase1_copy[2]))\n",
        "\n",
        "        equals = Tex(\"=\")\n",
        "        ineq = conditions[1][0]\n",
        "        equals.replace(ineq, dim_to_match=0)\n",
        "        self.play(\n",
        "            FlashAround(equals, run_time=2, time_width=1.5),\n",
        "            ineq.animate.become(equals)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2.48, 0.33, 0.0), 9.17),\n",
        "            FadeOut(condition_group, lag_ratio=0.01)\n",
        "        )\n",
        "\n",
        "        # Graph GeLU\n",
        "        gelu_title_full = Text(\"Gaussian\\nError\\nLinear\\nUnit\", font_size=42, alignment=\"LEFT\")\n",
        "        gelu_title_full.next_to(relu_arrow, UP)\n",
        "        gelu_graph = axes.get_graph(lambda x: x * norm.cdf(x))\n",
        "        gelu_graph.set_stroke(GREEN, 4)\n",
        "\n",
        "        gelu_graph_label = Text(\"GELU\")\n",
        "        gelu_graph_label.next_to(relu_graph_label, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        gelu_graph_label.match_color(gelu_graph)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(relu_title_full, gelu_title_full),\n",
        "            relu_graph_label.animate.set_fill(opacity=0.25),\n",
        "            relu_graph.animate.set_stroke(opacity=0.25),\n",
        "            ShowCreation(gelu_graph),\n",
        "            TransformFromCopy(relu_graph_label, gelu_graph_label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            gelu_graph.animate.set_stroke(opacity=0.25),\n",
        "            gelu_graph_label.animate.set_fill(opacity=0.25),\n",
        "            relu_graph.animate.set_stroke(opacity=1),\n",
        "            relu_graph_label.animate.set_fill(opacity=1),\n",
        "            FadeTransform(gelu_title_full, relu_title_full),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Describe these as neurons\n",
        "        neuron_word = Text(\"Neurons\", font_size=72)\n",
        "        neuron_word.next_to(phase1_copy, RIGHT, buff=2.5)\n",
        "        neuron_arrows = VGroup(\n",
        "            Arrow(neuron_word.get_left(), entry.get_right(), buff=0.4, stroke_width=3)\n",
        "            for entry in phase1_copy[2].get_entries()\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            plot.animate.set_width(2).next_to(relu_arrow, DOWN),\n",
        "            FadeOut(VGroup(relu_graph_label, gelu_graph_label, gelu_graph)),\n",
        "            Write(neuron_word),\n",
        "            ShowCreation(neuron_arrows, lag_ratio=0.2, run_time=3),\n",
        "            LaggedStartMap(\n",
        "                FlashAround, phase1_copy[2].get_entries(),\n",
        "                time_width=3.0,\n",
        "                lag_ratio=0.05,\n",
        "                time_span=(1, 4),\n",
        "                run_time=4\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the classic dots picture\n",
        "        blocking_rect = BackgroundRectangle(VGroup(phase1_copy), buff=0.1)\n",
        "        blocking_rect.set_fill(BLACK, 1)\n",
        "        up_emb.move_to(blocking_rect, LEFT)\n",
        "        dots = VGroup(\n",
        "            Dot(radius=0.15).move_to(entry).set_fill(WHITE, opacity=clip(entry.get_value(), 0, 1))\n",
        "            for entry in phase1_copy[2].get_entries()\n",
        "        )\n",
        "        dots.set_stroke(WHITE, 2)\n",
        "        up_emb = emb.copy()\n",
        "        up_emb.rotate(PI / 2, DOWN)\n",
        "        up_emb.rotate(1 * DEGREES)\n",
        "        up_emb.match_width(phase1_copy[0])\n",
        "        up_emb.move_to(phase1_copy[0]).shift(RIGHT)\n",
        "        up_emb[-2:].set_color(YELLOW)\n",
        "        lines = VGroup(\n",
        "            Line(entry.get_right() + 0.05 * RIGHT, dot).set_stroke(\n",
        "                color=value_to_color(random.uniform(-10, 10)),\n",
        "                width=3 * random.random()**2,\n",
        "            )\n",
        "            for entry in up_emb.get_entries()\n",
        "            for dot in dots\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(blocking_rect),\n",
        "            Write(dots),\n",
        "        )\n",
        "        self.play(TransformFromCopy(emb, up_emb))\n",
        "        self.play(ShowCreation(lines, lag_ratio=3 / len(lines)))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [up_emb, *lines, blocking_rect, *dots]), lag_ratio=0.01)\n",
        "        )\n",
        "\n",
        "        # Discuss active and inactive\n",
        "        entry = phase1_copy[2].get_entries()[0]\n",
        "        entry_rect = SurroundingRectangle(entry)\n",
        "        entry_rect.set_stroke(YELLOW, 2)\n",
        "        active_words = TexText(R\"``Michael Jordan'' neuron is \\emph{active}\")\n",
        "        active = active_words[\"active\"][0]\n",
        "        active.set_color(BLUE_B)\n",
        "        active_words.next_to(entry_rect, UP, aligned_edge=LEFT)\n",
        "        active_words.shift(LEFT)\n",
        "        inactive = TexText(R\"\\emph{inactive}\")\n",
        "        inactive.set_color(RED)\n",
        "        inactive.move_to(active, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2.45, 0.58, 0.0), 9.65),\n",
        "            ShowCreation(entry_rect),\n",
        "            Write(active_words, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(entry, 0),\n",
        "            ReplacementTransform(active, inactive[2:]),\n",
        "            GrowFromCenter(inactive[:2]),\n",
        "        )\n",
        "        active_words.add(inactive)\n",
        "        self.wait()\n",
        "\n",
        "        # Replace the ReLU diagram portion\n",
        "        self.play(\n",
        "            Restore(phase1_copy),\n",
        "            TransformMatchingStrings(relu_title_full, arrow_labels[1]),\n",
        "            plot.animate.scale(0.5).next_to(arrows[1], DOWN, SMALL_BUFF),\n",
        "            FadeOut(neuron_word, DOWN),\n",
        "            FadeOut(neuron_arrows, DOWN, lag_ratio=0.1),\n",
        "            FadeOut(entry_rect, DOWN),\n",
        "            FadeOut(active_words, DOWN, lag_ratio=0.01),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.remove(phase1_copy)\n",
        "\n",
        "        # Down projection\n",
        "        neurons = vects[1].copy()\n",
        "        neurons.target = neurons.generate_target()\n",
        "        neurons.target.set_height(4)\n",
        "        neurons.target.move_to(3 * RIGHT + 2.5 * UP)\n",
        "        down_proj = WeightMatrix(shape=(6, 9))\n",
        "        down_proj.set_height(2.75)\n",
        "        down_proj.next_to(neurons.target, LEFT)\n",
        "\n",
        "        plus = Tex(\"+\")\n",
        "        plus.next_to(neurons.target, RIGHT)\n",
        "        bias = WeightMatrix(shape=(6, 1))\n",
        "        bias.match_height(down_proj)\n",
        "        bias.next_to(plus, RIGHT)\n",
        "\n",
        "        equals = Tex(\"=\")\n",
        "        equals.next_to(bias, RIGHT)\n",
        "        rhs = vects[2].copy()\n",
        "        rhs.set_opacity(1)\n",
        "        rhs.match_height(bias)\n",
        "        rhs.next_to(equals, RIGHT)\n",
        "\n",
        "        self.play(phases[2].animate.set_opacity(1))\n",
        "        self.play(MoveToTarget(neurons))\n",
        "        self.play(FadeTransform(arrows[2].copy(), down_proj))\n",
        "        self.wait()\n",
        "        temp_eq, temp_rhs = show_matrix_vector_product(self, down_proj, neurons)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(temp_eq, DOWN),\n",
        "            FadeOut(temp_rhs, DOWN),\n",
        "            Write(plus),\n",
        "            FadeIn(bias, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            TransformFromCopy(vects[2], rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name it as the down-projection\n",
        "        over_brace = Brace(down_proj, UP)\n",
        "        name = TexText(\"``Down projection''\")\n",
        "        name.next_to(over_brace, UP)\n",
        "\n",
        "        side_brace = Brace(rhs, RIGHT)\n",
        "        dim_count = Integer(12288)\n",
        "        dim_count.next_to(side_brace, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            CountInFrom(dim_count),\n",
        "            GrowFromCenter(side_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(name),\n",
        "            GrowFromCenter(over_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show column-by-column\n",
        "        col_matrix = self.get_col_matrix(down_proj, 7)\n",
        "        bias_as_col = self.get_col_matrix(bias, 1, dots_index=None, sym=\"B\", top_index=\"\", width_multiple=0.7)\n",
        "        n_labels = VGroup(\n",
        "            Tex(f\"n_{{{m}}}\")\n",
        "            for m in [*range(6), \"m\"]\n",
        "        )\n",
        "        n_labels.arrange(DOWN, buff=0.5)\n",
        "        n_labels.match_height(neurons.get_entries())\n",
        "        n_labels.move_to(neurons.get_entries())\n",
        "        n_labels.replace_submobject(-2, Tex(R\"\\vdots\").move_to(n_labels[-2]))\n",
        "        n_labels.set_color(BLUE)\n",
        "        n_vect = VGroup(neurons[-2:].copy(), n_labels)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, [over_brace, name, side_brace, dim_count])),\n",
        "            LaggedStart(\n",
        "                FadeOut(down_proj),\n",
        "                FadeIn(col_matrix),\n",
        "                FadeOut(neurons),\n",
        "                FadeIn(n_vect),\n",
        "                FadeOut(bias),\n",
        "                FadeIn(bias_as_col),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Expand the column interpretation\n",
        "        over_brace = Brace(VGroup(col_matrix, n_vect), UP)\n",
        "        scaled_cols = VGroup(\n",
        "            VGroup(n_label, col_label[0]).copy()\n",
        "            for n_label, col_label in zip(n_labels, col_matrix[1])\n",
        "        )\n",
        "        scaled_cols.target = VGroup()\n",
        "        for pair in scaled_cols:\n",
        "            pair.target = pair.generate_target()\n",
        "            pair.target[0].scale(1.5)\n",
        "            pair.target.arrange(RIGHT, buff=0.1, aligned_edge=DOWN)\n",
        "            scaled_cols.target.add(pair.target)\n",
        "        scaled_cols.target[-2].become(Tex(R\"\\dots\"))\n",
        "        scaled_cols.target.arrange(RIGHT, buff=0.75)\n",
        "        scaled_cols.target.set_width(1.25 * over_brace.get_width())\n",
        "        scaled_cols.target.next_to(over_brace, UP, buff=0.5)\n",
        "\n",
        "        plusses = VGroup(\n",
        "            Tex(\"+\").move_to(midpoint(m1.get_right(), m2.get_left()))\n",
        "            for m1, m2 in zip(scaled_cols.target, scaled_cols.target[1:])\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-0.27, 1.04, 0.0), 11.06),\n",
        "            GrowFromCenter(over_brace),\n",
        "            LaggedStartMap(MoveToTarget, scaled_cols, lag_ratio=0.7, run_time=5),\n",
        "            LaggedStartMap(FadeIn, plusses, lag_ratio=0.7, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight each set\n",
        "        last_rects = VGroup()\n",
        "        all_rect_groups = VGroup()\n",
        "        for tup in zip(col_matrix[1], n_labels, scaled_cols):\n",
        "            rects = VGroup(SurroundingRectangle(mob) for mob in tup)\n",
        "            rects.set_stroke(YELLOW, 2)\n",
        "            self.play(\n",
        "                FadeOut(last_rects),\n",
        "                FadeIn(rects),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            all_rect_groups.add(rects)\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "\n",
        "        # First column as basketball\n",
        "        col_rect, n_rect, prod_rect = rects = all_rect_groups[0]\n",
        "        basketball = Text(\"Basketball\", font_size=60)\n",
        "        basketball.set_color(\"#F88158\")\n",
        "        basketball.next_to(col_rect, LEFT)\n",
        "        basketball.save_state()\n",
        "        basketball.rotate(-PI / 2)\n",
        "        basketball.move_to(col_rect)\n",
        "        basketball.set_opacity(0)\n",
        "\n",
        "        n0_term = scaled_cols[0][0]\n",
        "        n0_term.save_state()\n",
        "        one = Tex(\"1\", font_size=60).move_to(n0_term, DR).set_color(BLUE)\n",
        "        zero = Tex(\"0\", font_size=60).move_to(n0_term, DR).set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(col_rect),\n",
        "            col_matrix[1][1:].animate.set_opacity(0.5),\n",
        "            n_labels[1:].animate.set_opacity(0.5),\n",
        "            scaled_cols[1:].animate.set_opacity(0.5),\n",
        "            plusses.animate.set_opacity(0.5)\n",
        "        )\n",
        "        self.play(Restore(basketball, path_arc=PI / 2))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(col_rect, n_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(col_rect, prod_rect),\n",
        "            TransformFromCopy(n_rect, prod_rect),\n",
        "        )\n",
        "        self.play(Transform(n0_term, one))\n",
        "        self.wait()\n",
        "        self.play(Transform(n0_term, zero))\n",
        "        self.wait()\n",
        "        self.play(Restore(n0_term))\n",
        "        n0_term.restore()\n",
        "        self.wait()\n",
        "\n",
        "        # Cycle through columns one more time\n",
        "        rects.add(basketball)\n",
        "        for index in range(1, len(all_rect_groups)):\n",
        "            self.play(\n",
        "                FadeOut(all_rect_groups[index - 1]),\n",
        "                FadeIn(all_rect_groups[index]),\n",
        "                col_matrix[1][index].animate.set_opacity(1),\n",
        "                n_labels[index].animate.set_opacity(1),\n",
        "                scaled_cols[index].animate.set_opacity(1),\n",
        "                plusses[index - 1].animate.set_opacity(1),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(FadeOut(all_rect_groups[-1]))\n",
        "\n",
        "        # Highlight bias\n",
        "        bias_rect = SurroundingRectangle(bias)\n",
        "        bias_brace = Brace(bias_rect, UP)\n",
        "        bias_word = Text(\"Bias\")\n",
        "        bias_word.next_to(bias_brace, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(over_brace, bias_brace),\n",
        "            FadeIn(bias_rect),\n",
        "            FadeOut(plusses, lag_ratio=0.1),\n",
        "            FadeOut(scaled_cols, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(FadeIn(bias_word, 0.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*map(FadeOut, [bias_word, bias_brace, bias_rect])))\n",
        "\n",
        "        # Collpase the down projection\n",
        "        W_down = Tex(R\"W_\\downarrow\", font_size=60).set_color(BLUE)\n",
        "        B_down = Tex(R\"\\vec{\\textbf{B}}_\\downarrow\", font_size=60).set_color(BLUE_B)\n",
        "        W_down.next_to(neurons, LEFT)\n",
        "        B_down.move_to(bias_as_col)\n",
        "        WB_down = VGroup(W_down, B_down)\n",
        "        n_rect = Rectangle(1, 1)\n",
        "        n_rect.set_height(W_down.get_height())\n",
        "        n_rect.move_to(n_vect)\n",
        "        n_rect.set_fill(GREY_C)\n",
        "        n_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        down_proj_expr = VGroup(W_down, n_vect, plus, B_down)\n",
        "        down_proj_expr.target = down_proj_expr.generate_target()\n",
        "        down_proj_expr.target[1].become(VGroup(n_rect))\n",
        "        down_proj_expr.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        down_proj_expr.target.scale(0.4)\n",
        "        down_proj_expr.target.next_to(arrows[2], DOWN)\n",
        "\n",
        "        self.play(ReplacementTransform(col_matrix, W_down, lag_ratio=5e-3, run_time=2))\n",
        "        self.play(ReplacementTransform(bias_as_col, B_down, lag_ratio=1e-2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                MoveToTarget(down_proj_expr),\n",
        "                FadeOut(equals, 2 * DOWN + 0.5 * LEFT),\n",
        "                ReplacementTransform(rhs, vects[2]),\n",
        "                lag_ratio=0.25,\n",
        "                time_span=(0, 1.5),\n",
        "            ),\n",
        "            frame.animate.reorient(0, -14, 0, (-0.1, -2.03, 0.01), 6.31),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add it to the original\n",
        "        faded_sum_circuit = sum_circuit.copy()\n",
        "        sum_circuit.set_stroke(opacity=1)\n",
        "        sum_circuit.insert_n_curves(20)\n",
        "\n",
        "        self.add(faded_sum_circuit)\n",
        "        self.play(\n",
        "            frame.animate.reorient(13, -8, 0, (0.15, -2.05, 0.0), 6.52),\n",
        "            ShowCreation(sum_circuit, lag_ratio=0.5),\n",
        "            low_emb_label.animate.shift(0.2 * LEFT).set_anim_args(time_span=(0, 1)),\n",
        "            FadeOut(output_emb),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.remove(faded_sum_circuit)\n",
        "        output_emb.set_fill(opacity=1)\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(emb, output_emb, path_arc=-45 * DEGREES),\n",
        "            TransformFromCopy(vects[2], output_emb, path_arc=-45 * DEGREES),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Yet again, emphasize the MJ example\n",
        "        m_color = interpolate_color_by_hsl(GREY_BROWN, WHITE, 0.5)\n",
        "        j_color = RED_B\n",
        "        b_color = basketball.get_color()\n",
        "        m_tex = Tex(R\"\\overrightarrow{\\text{F.N. Michael}}\").set_color(m_color)\n",
        "        j_tex = Tex(R\"\\overrightarrow{\\text{L.N. Jordan}}\").set_color(j_color)\n",
        "        b_tex = Tex(R\"\\overrightarrow{\\text{Basketball}}\").set_color(b_color)\n",
        "        mj = VGroup(m_tex, Tex(\"+\"), j_tex).copy()\n",
        "        mjb = VGroup(m_tex, Tex(\"+\"), j_tex, Tex(\"+\"), b_tex).copy()\n",
        "        for tex_mob in [mj, mjb]:\n",
        "            tex_mob.set_height(0.45)\n",
        "            tex_mob.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            tex_mob.set_fill(border_width=1)\n",
        "        mj.next_to(low_emb_label, UP, buff=1.0).shift(0.5 * LEFT)\n",
        "        mjb.next_to(output_emb, UP, buff=1.5).shift(1.0 * RIGHT)\n",
        "        mj_arrow = Arrow(mj.get_bottom(), low_emb_label, buff=0.1)\n",
        "        mjb_arrow = Arrow(output_emb.get_top(), mjb.get_bottom(), buff=0.15)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(4, -6, 0, (-0.29, -1.76, 0.02), 7.70),\n",
        "            FadeIn(mj, lag_ratio=0.1),\n",
        "            ShowCreation(mj_arrow)\n",
        "        )\n",
        "        self.play(Transform(mj.copy(), emb.copy().set_opacity(0), lag_ratio=0.005, remover=True, run_time=2))\n",
        "        mover = emb.copy()\n",
        "        for vect in [*vects, output_emb]:\n",
        "            self.play(Transform(mover, vect, rate_func=linear))\n",
        "        self.remove(mover)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-3, -5, 0, (1.09, -1.48, -0.03), 9.61),\n",
        "            FadeTransform(mj.copy(), mjb[:3]),\n",
        "            FadeTransformPieces(mj.copy()[-1:], mjb[3:]),\n",
        "            ShowCreation(mjb_arrow),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            frame.animate.reorient(21, -14, 0, (-0.13, -2.21, 0.11), 6.91).set_anim_args(run_time=5),\n",
        "            LaggedStartMap(FadeOut, VGroup(mj, mj_arrow, mjb_arrow, mjb)),\n",
        "        )\n",
        "\n",
        "        # Show it done in parallel to all embeddings\n",
        "        self.play(\n",
        "            frame.animate.reorient(14, -12, 0, (0.55, -2.21, 0.18), 7.05),\n",
        "            LaggedStart((\n",
        "                TransformFromCopy(simple_phases, sp_copy)\n",
        "                for sp_copy in simple_phase_copies\n",
        "            ), lag_ratio=0.1),\n",
        "            FadeOut(block_title, time_span=(0, 1)),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(42, -23, 0, (0.55, -2.21, 0.18), 7.05),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # Show neurons?\n",
        "        sum_circuits = VGroup(\n",
        "            sum_circuit,\n",
        "            *(sp[0] for sp in simple_phase_copies),\n",
        "            *(sp[-1] for sp in simple_phase_copies),\n",
        "        )\n",
        "        n_vects = VGroup(vects[1], *(sp[2][1] for sp in simple_phase_copies))\n",
        "\n",
        "        neuron_points = np.array([\n",
        "            entry.get_center()\n",
        "            for vect in n_vects[1:]\n",
        "            for entry in vect.get_entries()\n",
        "        ])\n",
        "        neurons = DotCloud(neuron_points)\n",
        "        neurons.set_radius(0.075)\n",
        "        neurons.set_shading(0.25, 0.25, 0.5)\n",
        "        neurons.apply_depth_test()\n",
        "        rgbas = np.random.random(len(neuron_points))\n",
        "        rgbas = rgbas.repeat(4).reshape((rgbas.size, 4))\n",
        "        rgbas[:, 3] = 1\n",
        "        neurons.set_rgba_array(rgbas)\n",
        "        neuron_ellipses = VGroup(\n",
        "            n_vect.get_ellipses()\n",
        "            for n_vect in n_vects[1:]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(11, -5, 0, (0.55, -2.21, 0.18), 7.05),\n",
        "            sum_circuits.animate.set_stroke(width=1, opacity=0.2),\n",
        "            FadeOut(block[4]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-11, -5, 0, (0.55, -2.21, 0.18), 7.05).set_anim_args(run_time=4),\n",
        "            FadeOut(n_vects),\n",
        "            ShowCreation(neurons, run_time=2),\n",
        "            FadeIn(neuron_ellipses, time_span=(1, 2)),\n",
        "        )\n",
        "        self.add(neuron_ellipses)\n",
        "        self.play(frame.animate.reorient(13, -7, 0, (0.55, -2.21, 0.18), 7.05), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "    def get_sum_circuit(\n",
        "        self, in_vect, diff_vect,\n",
        "        v_buff=0.15,\n",
        "        h_buff=0.5,\n",
        "        y_diff=0.65,\n",
        "        color=YELLOW\n",
        "    ):\n",
        "        plus = VGroup(Line(UP, DOWN), Line(LEFT, RIGHT))\n",
        "        plus.scale(0.6)\n",
        "        circle = Circle(radius=1)\n",
        "        oplus = VGroup(circle, plus)\n",
        "        oplus.set_height(0.3)\n",
        "        oplus.next_to(diff_vect, RIGHT, buff=h_buff)\n",
        "\n",
        "        p0 = in_vect.get_top() + v_buff * UP\n",
        "        p1 = in_vect.get_top() + y_diff * UP\n",
        "        p2 = oplus.get_center()\n",
        "        p2[1] = p1[1]\n",
        "        p3 = oplus.get_top()\n",
        "        top_line = VMobject()\n",
        "        top_line.set_points_as_corners([p0, p1, p2, p3])\n",
        "\n",
        "        oplus.refresh_bounding_box()  # Why?\n",
        "        h_line1 = Line(diff_vect.get_right(), oplus.get_left())\n",
        "        h_line2 = Line(oplus.get_right(), oplus.get_right() + h_buff * RIGHT)\n",
        "\n",
        "        output = diff_vect.copy()\n",
        "        output.next_to(h_line2, RIGHT, buff=0)\n",
        "        for e1, e2, e3 in zip(in_vect.get_entries(), diff_vect.get_entries(), output.get_entries()):\n",
        "            e3.set_value(e1.get_value() + e2.get_value())\n",
        "\n",
        "        circuit = VGroup(top_line, oplus, h_line1, h_line2)\n",
        "        circuit.set_stroke(color, 3)\n",
        "\n",
        "        return circuit, output\n",
        "\n",
        "    def get_col_matrix(self, matrix, n_cols_shown, dots_index=-2, sym=\"C\", top_index=\"m-1\", width_multiple=1.0):\n",
        "        C_labels = VGroup(\n",
        "            Tex(Rf\"\\vec{{\\textbf{{{sym}}}}}_{{{n}}}\")\n",
        "            for n in [*range(n_cols_shown - 1), top_index]\n",
        "        )\n",
        "        C_labels.arrange(RIGHT, buff=0.5)\n",
        "        C_labels.move_to(matrix.get_entries())\n",
        "        C_labels.set_width(matrix.get_entries().get_width() * width_multiple)\n",
        "\n",
        "\n",
        "        v_lines = VGroup(\n",
        "            Line(matrix.get_bottom(), C_labels.get_bottom() + SMALL_BUFF * DOWN),\n",
        "            Line(C_labels.get_top() + SMALL_BUFF * UP, matrix.get_top()),\n",
        "        )\n",
        "        v_lines.set_stroke(WHITE, 1)\n",
        "        col_labels = VGroup(\n",
        "            VGroup(C_label, v_lines.copy().match_x(C_label))\n",
        "            for C_label in C_labels\n",
        "        )\n",
        "        if dots_index is not None:\n",
        "            dots = Tex(R\"\\hdots\")\n",
        "            dots.move_to(col_labels[dots_index])\n",
        "            col_labels.replace_submobject(dots_index, dots)\n",
        "\n",
        "        return VGroup(matrix.get_brackets().copy(), col_labels)\n",
        "\n",
        "\n",
        "class NonlinearityOfLanguage(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up axes and M + J\n",
        "        unit_size = 2.5\n",
        "\n",
        "        plane = NumberPlane(\n",
        "            axis_config=dict(\n",
        "                stroke_width=1,\n",
        "            ),\n",
        "            background_line_style=dict(\n",
        "                stroke_color=BLUE_D,\n",
        "                stroke_width=1,\n",
        "                stroke_opacity=0.75\n",
        "            ),\n",
        "            faded_line_ratio=1,\n",
        "            unit_size=unit_size,\n",
        "        )\n",
        "        m_vect = Vector(unit_size * RIGHT).rotate(60 * DEGREES, about_point=ORIGIN)\n",
        "        j_vect = m_vect.copy().rotate(-90 * DEGREES, about_point=ORIGIN)\n",
        "        m_vect.set_color(YELLOW)\n",
        "        j_vect.set_color(RED)\n",
        "        m_ghost = m_vect.copy().shift(j_vect.get_vector())\n",
        "        j_ghost = j_vect.copy().shift(m_vect.get_vector())\n",
        "        VGroup(m_ghost, j_ghost).set_stroke(opacity=0.25)\n",
        "\n",
        "        sum_point = m_ghost.get_end()\n",
        "        span_line = Line(-sum_point, sum_point)\n",
        "        span_line.set_length(2 * FRAME_WIDTH)\n",
        "        span_line.set_stroke(WHITE, 2, opacity=0.5)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(m_vect, m_ghost, j_vect, j_ghost)\n",
        "        self.add(span_line)\n",
        "\n",
        "        # Label vectors\n",
        "        m_label = Text(\"First Name Michael\")\n",
        "        j_label = Text(\"Last Name Jordan\")\n",
        "        for label, vect in [(m_label, m_vect), (j_label, j_vect)]:\n",
        "            label.scale(0.6)\n",
        "            label.match_color(vect)\n",
        "            direction = np.sign(vect.get_vector()[1]) * UP\n",
        "            label.next_to(ORIGIN, direction, buff=0.2, aligned_edge=LEFT)\n",
        "            label.rotate(vect.get_angle(), about_point=ORIGIN)\n",
        "            label.set_backstroke(BLACK, 3)\n",
        "\n",
        "        self.add(m_label)\n",
        "        self.add(j_label)\n",
        "\n",
        "        # Add dot product expression\n",
        "        expr = Tex(R\"(\\vec{\\textbf{M}} + \\vec{\\textbf{J}}) \\cdot \\textbf{E}\")\n",
        "        expr[1:3].match_color(m_vect)\n",
        "        expr[4:6].match_color(j_vect)\n",
        "        expr.to_corner(UL)\n",
        "        self.add(expr)\n",
        "\n",
        "        # Set up embedding with dot product tracker\n",
        "        emb_point = VectorizedPoint(unit_size * UL)\n",
        "        emb = Vector()\n",
        "        emb.add_updater(lambda m: m.put_start_and_end_on(ORIGIN, emb_point.get_center()))\n",
        "        normalized_sum = normalize(sum_point)\n",
        "\n",
        "        def get_line_point():\n",
        "            return normalized_sum * np.dot(normalized_sum, emb_point.get_center())\n",
        "\n",
        "        shadow = Line()\n",
        "        shadow.set_stroke(PINK, 3)\n",
        "        shadow.add_updater(lambda m: m.put_start_and_end_on(ORIGIN, get_line_point()))  # This is a long line\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.set_fill(PINK, 1)\n",
        "        dot.f_always.move_to(get_line_point)\n",
        "\n",
        "        dashed_line = always_redraw(\n",
        "            lambda: DashedLine(emb_point.get_center(), get_line_point()).set_stroke(PINK, 2)\n",
        "        )\n",
        "\n",
        "        dp_decimal = DecimalNumber(font_size=36)\n",
        "        dp_decimal.match_color(dot)\n",
        "        dp_decimal.f_always.set_value(lambda: np.dot(normalized_sum, emb_point.get_center()) * 2.0 / 3.535534)\n",
        "        dp_decimal.always.next_to(dot, DR, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(shadow, emb, dot, dashed_line, dp_decimal)\n",
        "\n",
        "        emb_point.move_to(ORIGIN + 0.01 * UP)\n",
        "        for point in [m_vect.get_end(), m_ghost.get_end(), j_vect.get_end(), m_ghost.get_end()]:\n",
        "            self.play(emb_point.animate.move_to(point), run_time=3)\n",
        "\n",
        "        # Set up names\n",
        "        names = VGroup(\n",
        "            Text(name, font_size=36)\n",
        "            for name in [\n",
        "                \"Michael Jordan\",\n",
        "                \"Michael Phelps\",\n",
        "                \"Alexis Jordan\",\n",
        "            ]\n",
        "        )\n",
        "        name_points = [\n",
        "            sum_point,\n",
        "            m_vect.get_end(),\n",
        "            j_vect.get_end(),\n",
        "        ]\n",
        "        for name, point in zip(names, name_points):\n",
        "            name.set_backstroke(BLACK, 3)\n",
        "            direction = RIGHT + np.sign(point[1]) * UP\n",
        "            name.next_to(point, direction, buff=0.1)\n",
        "\n",
        "        # Go through names\n",
        "        name = names[0].copy()\n",
        "        name_ghosts = names.copy().set_fill(opacity=0.75).set_stroke(width=0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(name, 0.5 * UP),\n",
        "            Rotate(emb_point, TAU, about_point=emb_point.get_center() + 0.15 * DL, run_time=4),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(name_ghosts[0])\n",
        "        self.play(\n",
        "            Transform(name, names[1]),\n",
        "            emb_point.animate.move_to(m_vect.get_end()),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(name_ghosts[1])\n",
        "        self.play(\n",
        "            Transform(name, names[2]),\n",
        "            emb_point.animate.move_to(j_vect.get_end()).set_anim_args(path_arc=30 * DEGREES),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.add(name_ghosts[2])\n",
        "        self.wait()\n",
        "\n",
        "        # Show other names\n",
        "        other_point = span_line.pfp(0.45)\n",
        "        other_word = Text(\"(Other)\", font_size=36)\n",
        "        other_word.set_fill(GREY_B)\n",
        "        other_word.next_to(other_point, UL, buff=0)\n",
        "\n",
        "        self.play(\n",
        "            emb_point.animate.move_to(other_point),\n",
        "            LaggedStart(\n",
        "                FadeOut(name),\n",
        "                FadeIn(other_word),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show \"yes\" vs. \"no\" regions\n",
        "        regions = FullScreenRectangle().scale(2).replicate(2)\n",
        "        regions.arrange(LEFT, buff=0)\n",
        "        regions[0].set_fill(GREEN_B, 0.35)\n",
        "        regions[1].set_fill(RED, 0.25)\n",
        "        regions.rotate(span_line.get_angle(), about_point=ORIGIN)\n",
        "        regions.shift(0.85 * sum_point)\n",
        "\n",
        "        yes_no_words = VGroup(\n",
        "            Text(\"Yes\", font_size=72).set_fill(GREEN).to_corner(UR),\n",
        "            Text(\"No\", font_size=72).set_fill(RED).to_edge(UP).shift(LEFT),\n",
        "        )\n",
        "\n",
        "        for region, word in zip(regions, yes_no_words):\n",
        "            self.play(FadeIn(region), FadeIn(word))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Superposition(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add undulating bubble to encompass N-dimensional space\n",
        "        frame = self.frame\n",
        "        bubble = self.undulating_bubble()\n",
        "        bubble_label = TexText(R\"$N$-dimensional\\\\ Space\")\n",
        "        bubble_label.set_height(1)\n",
        "        bubble_label[\"$N$\"].set_color(YELLOW)\n",
        "        bubble_label.next_to(bubble, LEFT)\n",
        "\n",
        "        self.add(bubble)\n",
        "        self.add(bubble_label)\n",
        "\n",
        "        # Preview some ideas\n",
        "        ideas = VGroup(Text(\"Latin\"), Text(\"Microphone\"), Text(\"Basketball\"), Text(\"The 1920s\"))\n",
        "        ideas.scale(0.75)\n",
        "        vectors = VGroup()\n",
        "        idea_vects = VGroup()\n",
        "        vect = DOWN\n",
        "        colors = [PINK, GREEN, ORANGE, BLUE]\n",
        "        for idea, color in zip(ideas, colors):\n",
        "            vect = rotate_vector(vect, 80 * DEGREES)\n",
        "            vector = Vector(1.25 * normalize(vect))\n",
        "            idea.next_to(vector.get_end(), vector.get_vector(), buff=SMALL_BUFF)\n",
        "            idea_vect = VGroup(vector, idea)\n",
        "            idea_vect.set_color(color)\n",
        "            idea_vect.shift(bubble.get_center())\n",
        "            idea_vects.add(idea_vect)\n",
        "\n",
        "        frame.save_state()\n",
        "        frame.scale(0.75)\n",
        "        frame.move_to(VGroup(bubble, bubble_label))\n",
        "        self.play(\n",
        "            Restore(frame, run_time=7),\n",
        "            LaggedStartMap(VFadeInThenOut, idea_vects, lag_ratio=0.5, run_time=5)\n",
        "        )\n",
        "\n",
        "        # Written conditions and answer\n",
        "        conditions = [\n",
        "            R\"$90^\\circ$ apart\",\n",
        "            R\"between $89^\\circ$ and $91^\\circ$ apart\"\n",
        "        ]\n",
        "        task1, task2 = tasks = VGroup(\n",
        "            TexText(Rf\"Choose multiple vectors,\\\\ each pair {phrase}\", font_size=42, alignment=\"\")\n",
        "            for phrase in conditions\n",
        "        )\n",
        "        task1[R\"90^\\circ\"].set_color(RED)\n",
        "        task2[R\"$89^\\circ$ and $91^\\circ$\"].set_color(BLUE)\n",
        "        task1.center().to_edge(UP)\n",
        "        task2.move_to(task1, UL)\n",
        "\n",
        "        maximum1, maximum2 = maxima = VGroup(\n",
        "            TexText(fR\"Maximum \\# of vectors: {answer}\", font_size=42)\n",
        "            for answer in [\"$N$\", R\"$\\approx \\exp(\\epsilon \\cdot N)$\"]\n",
        "        )\n",
        "        for maximum in maxima:\n",
        "            maximum.next_to(tasks, DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        maximum1[\"N\"].set_color(YELLOW)\n",
        "        maximum2[\"N\"].set_color(YELLOW)\n",
        "\n",
        "        # Add 3 vectors such that each pair is 90-degrees\n",
        "        perp_vectors = VGroup(*map(Vector, [RIGHT, UP, OUT]))\n",
        "        perp_vectors.set_shading(0.25, 0.25, 0.25)\n",
        "        perp_vectors.set_submobject_colors_by_gradient(RED, GREEN, BLUE)\n",
        "        elbows = VGroup(\n",
        "            Elbow(width=0.1).rotate(angle, axis, about_point=ORIGIN).set_stroke(WHITE, 2)\n",
        "            for angle, axis in [(0, UP), (-PI / 2, UP), (PI / 2, RIGHT)]\n",
        "        )\n",
        "        elbows.set_stroke(GREY_A, 2)\n",
        "\n",
        "        perp_group = VGroup(perp_vectors, elbows)\n",
        "        perp_group.rotate(-10 * DEGREES, UP)\n",
        "        perp_group.rotate(20 * DEGREES, RIGHT)\n",
        "        perp_group.scale(2)\n",
        "        perp_group.move_to(bubble)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(task1),\n",
        "            LaggedStartMap(GrowArrow, perp_vectors[:2], lag_ratio=0.5)\n",
        "        )\n",
        "        self.play(ShowCreation(elbows[0]))\n",
        "        self.play(\n",
        "            GrowArrow(perp_vectors[2]),\n",
        "            LaggedStartMap(ShowCreation, elbows[1:3], lag_ratio=0.5),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(perp_group, -50 * DEGREES, axis=perp_vectors[1].get_vector(), run_time=15),\n",
        "            Write(maximum1, time_span=(2, 4)),\n",
        "        )\n",
        "\n",
        "        # Relax the assumption\n",
        "        ninety_part = task1[conditions[0]]\n",
        "        cross = Cross(ninety_part)\n",
        "        crossed_part = VGroup(ninety_part, cross)\n",
        "        new_cond = task2[conditions[1]]\n",
        "        new_cond.align_to(ninety_part, LEFT)\n",
        "\n",
        "        pairs = VGroup(get_vector_pair(89), get_vector_pair(91))\n",
        "        pairs.arrange(RIGHT)\n",
        "        pairs.to_corner(UL)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(maximum1),\n",
        "            ShowCreation(cross),\n",
        "        )\n",
        "        self.play(\n",
        "            crossed_part.animate.shift(0.5 * DOWN).set_fill(opacity=0.5),\n",
        "            Write(new_cond),\n",
        "            LaggedStartMap(FadeIn, pairs, lag_ratio=0.25),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(perp_group, 50 * DEGREES, axis=perp_vectors[1].get_vector(), run_time=10)\n",
        "        )\n",
        "\n",
        "        # Struggle with 3 vectors (Sub out the title)\n",
        "        three_d_label = TexText(R\"3-dimensional\\\\ Space\")\n",
        "        three_d_label[\"3\"].set_color(BLUE)\n",
        "        three_d_label.move_to(bubble_label, UL)\n",
        "        bubble_label.save_state()\n",
        "\n",
        "        pv = perp_vectors\n",
        "        pv.save_state()\n",
        "        alt_vects = pv.copy()\n",
        "        origin = pv[0].get_start()\n",
        "        for vect in alt_vects:\n",
        "            vect.rotate(5 * DEGREES, axis=normalize(np.random.random(3)), about_point=origin)\n",
        "\n",
        "        new_vects = VGroup()\n",
        "        for (v1, v2) in it.combinations(pv, 2):\n",
        "            new_vects.add(Arrow(ORIGIN, v1.get_length() * normalize(v1.get_vector() + v2.get_vector()), buff=0).shift(origin))\n",
        "        new_vects.set_color(YELLOW)\n",
        "        new_vect = new_vects[0]\n",
        "\n",
        "        def shake(vect):\n",
        "            self.play(\n",
        "                vect.animate.rotate(5 * DEGREES, RIGHT, about_point=origin),\n",
        "                rate_func=lambda t: wiggle(t, 9)\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(three_d_label, DOWN),\n",
        "            bubble_label.animate.to_edge(DOWN).set_opacity(0.5)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(new_vect),\n",
        "            Transform(perp_vectors, alt_vects)\n",
        "        )\n",
        "        shake(new_vect)\n",
        "        self.play(\n",
        "            Restore(perp_vectors),\n",
        "            Transform(new_vect, new_vects[1])\n",
        "        )\n",
        "        shake(new_vect)\n",
        "        self.play(\n",
        "            Transform(perp_vectors, alt_vects),\n",
        "            Transform(new_vect, new_vects[2])\n",
        "        )\n",
        "        shake(new_vect)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            new_vect.animate.scale(0, about_point=origin),\n",
        "            ApplyMethod(perp_group.scale, 0, dict(about_point=origin), lag_ratio=0.25),\n",
        "            Restore(bubble_label),\n",
        "            FadeOut(three_d_label, UP),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.remove(new_vect, perp_group)\n",
        "\n",
        "        # Stack on many vectors\n",
        "        dodec = Dodecahedron()\n",
        "        vertices = [face.get_center() for face in dodec]\n",
        "        vectors = VGroup(Vector(vert) for vert in vertices)\n",
        "        vectors.set_flat_stroke(True)\n",
        "        vectors.rotate(30 * DEGREES, UR)\n",
        "        for vector in vectors:\n",
        "            vector.always.set_perpendicular_to_camera(self.frame)\n",
        "            vector.set_color(random_bright_color(hue_range=(0.5, 0.7)))\n",
        "        vectors.move_to(bubble)\n",
        "\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            FadeOut(crossed_part),\n",
        "            Write(maximum2),\n",
        "            Rotating(vectors, TAU, axis=UP, run_time=20),\n",
        "            LaggedStartMap(VFadeIn, vectors, lag_ratio=0.5, run_time=8)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Somehow communicate exponential scaling\n",
        "\n",
        "    def undulating_bubble(self):\n",
        "        bubble = ThoughtBubble(filler_shape=(6, 3))[0][-1]\n",
        "        bubble.set_stroke(WHITE, 1)\n",
        "        bubble.set_fill(GREY)\n",
        "        bubble.set_shading(0.5, 0.5, 0)\n",
        "        bubble.to_edge(DOWN)\n",
        "\n",
        "        points = bubble.get_points().copy()\n",
        "        points -= np.mean(points, 0)\n",
        "\n",
        "        def update_bubble(bubble):\n",
        "            center = bubble.get_center()\n",
        "            angles = np.apply_along_axis(angle_of_vector, 1, points)\n",
        "            stretch_factors = 1.0 + 0.05 * np.sin(6 * angles + self.time)\n",
        "            bubble.set_points(points * stretch_factors[:, np.newaxis])\n",
        "            # bubble.move_to(center)\n",
        "            bubble.set_x(0).to_edge(DOWN)\n",
        "\n",
        "        bubble.add_updater(update_bubble)\n",
        "        return bubble\n",
        "\n",
        "\n",
        "class StackOfVectors(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up the big matrix\n",
        "        rows = VGroup(\n",
        "            NumericEmbedding(shape=(1, 9), ellipses_col=-5, value_range=(-1, 1))\n",
        "            for n in range(20)\n",
        "        )\n",
        "        rows.arrange(DOWN)\n",
        "        for row in rows:\n",
        "            row.brackets[0].align_to(rows, LEFT)\n",
        "            row.brackets[1].align_to(rows, RIGHT)\n",
        "        rows.set_height(6)\n",
        "        rows.to_edge(DOWN)\n",
        "        rows[-2].become(Tex(R\"\\vdots\").replace(rows[-2], dim_to_match=1))\n",
        "        brackets = NumericEmbedding(shape=(20, 9)).brackets\n",
        "        brackets.set_height(rows.get_height() + MED_SMALL_BUFF)\n",
        "        brackets[0].next_to(rows, LEFT, SMALL_BUFF)\n",
        "        brackets[1].next_to(rows, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        top_brace = Brace(rows[0], UP)\n",
        "        top_label = top_brace.get_text(\"100-dimensional\")\n",
        "        side_brace = Brace(brackets, LEFT)\n",
        "        side_label = side_brace.get_text(\"10,000\\nvectors\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(top_brace),\n",
        "            FadeIn(top_label, lag_ratio=0.1),\n",
        "            LaggedStartMap(FadeIn, rows, shift=0.25 * DOWN, lag_ratio=0.1, run_time=3),\n",
        "            *map(GrowFromCenter, brackets)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (RandomizeMatrixEntries(row)\n",
        "                for row in rows[:-2]),\n",
        "                lag_ratio=0.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Label first vector\n",
        "        self.play(\n",
        "            GrowFromCenter(side_brace),\n",
        "            FadeIn(side_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class ShowAngleRange(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        angle_tracker = ValueTracker(10)\n",
        "        vect_pair = always_redraw(lambda: get_vector_pair(angle_tracker.get_value(), length=3, colors=(RED, GREEN)))\n",
        "\n",
        "        self.add(vect_pair)\n",
        "        self.play(\n",
        "            angle_tracker.animate.set_value(180),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            angle_tracker.animate.set_value(95),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MLPFeatures(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add neurons\n",
        "        radius = 0.15\n",
        "        layer1, layer2 = layers = VGroup(\n",
        "            Dot(radius=radius).get_grid(n, 1, buff=radius / 2)\n",
        "            for n in [8, 16]\n",
        "        )\n",
        "        layer2.arrange(DOWN, buff=radius)\n",
        "        layers.arrange(RIGHT, buff=3.0)\n",
        "        layers.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "        layers.set_stroke(WHITE, 1)\n",
        "        for neuron in layer1:\n",
        "            neuron.set_fill(opacity=random.random())\n",
        "        layer2.set_fill(opacity=0)\n",
        "\n",
        "        self.add(layers)\n",
        "\n",
        "        # Add connections\n",
        "        connections = get_network_connections(layer1, layer2)\n",
        "        self.add(connections)\n",
        "\n",
        "        # Show single-neuron features\n",
        "        features = iter([\n",
        "            \"Table\",\n",
        "            \"Slang\",\n",
        "            \"AM Radio\",\n",
        "            \"Humble\",\n",
        "            \"Notebook\",\n",
        "            \"Transparent\",\n",
        "            \"Duration\",\n",
        "            \"Madonna\",\n",
        "            \"Mirror\",\n",
        "            \"Pole Vaulting\",\n",
        "            \"Albert Einstein\",\n",
        "            \"Authentic\",\n",
        "            \"Scientific\",\n",
        "            \"Passionate\",\n",
        "            \"Bell Laboratories\",\n",
        "            \"Uzbekistan\",\n",
        "            \"Umbrella\",\n",
        "            \"Immanuel Kant\",\n",
        "            \"Baroque Music\",\n",
        "            \"Intense\",\n",
        "            \"Clock\",\n",
        "            \"Water skiing\",\n",
        "            \"Ancient Egypt\",\n",
        "            \"Ambiguous\",\n",
        "            \"Volume\",\n",
        "            \"Alexander the Great\",\n",
        "            \"Innovative\",\n",
        "            \"Religious\",\n",
        "        ])\n",
        "\n",
        "        last_neuron = VGroup()\n",
        "        last_feature_label = VGroup()\n",
        "        for neuron in layer2[:15]:\n",
        "            feature_label = Text(next(features), font_size=36)\n",
        "            feature_label.next_to(neuron, buff=SMALL_BUFF)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(last_feature_label),\n",
        "                FadeIn(feature_label),\n",
        "                last_neuron.animate.set_fill(opacity=0),\n",
        "                neuron.animate.set_fill(opacity=1),\n",
        "            )\n",
        "\n",
        "            last_neuron = neuron\n",
        "            last_feature_label = feature_label\n",
        "\n",
        "        # Show polysemantic features\n",
        "        brace = Brace(layer2, RIGHT)\n",
        "\n",
        "        def to_random_state(layer):\n",
        "            for dot in layer.generate_target():\n",
        "                dot.set_fill(opacity=random.random())\n",
        "            return MoveToTarget(layer)\n",
        "\n",
        "        self.play(\n",
        "            feature_label.animate.scale(48 / 36).next_to(brace, RIGHT),\n",
        "            GrowFromCenter(brace),\n",
        "            to_random_state(layer2),\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(12):\n",
        "            feature_label = Text(next(features))\n",
        "            feature_label.next_to(brace, RIGHT)\n",
        "            self.play(\n",
        "                FadeOut(last_feature_label),\n",
        "                FadeIn(feature_label),\n",
        "                to_random_state(layer2),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "            last_feature_label = feature_label\n",
        "\n",
        "\n",
        "class BreakDownThreeSteps(BasicMLPWalkThrough):\n",
        "    def construct(self):\n",
        "        # Add four vectors, spaced apart\n",
        "        vectors = VGroup(\n",
        "            NumericEmbedding(length=n)\n",
        "            for n in [8, 16, 16, 8]\n",
        "        )\n",
        "        vectors.set_height(6)\n",
        "        vectors.arrange(RIGHT, buff=3.5)\n",
        "        vectors[2].shift(1.1 * LEFT)\n",
        "        vectors[1].shift(0.2 * LEFT)\n",
        "        vectors.shift(DOWN)\n",
        "        for e1, e2 in zip(vectors[1].get_entries(), vectors[2].get_entries()):\n",
        "            e2.set_value(max(e1.get_value(), 0))\n",
        "\n",
        "        # Add arrows between them\n",
        "        arrows = VGroup(\n",
        "            Arrow(v1, v2)\n",
        "            for v1, v2 in zip(vectors, vectors[1:])\n",
        "        )\n",
        "        arrows.shift(DOWN)\n",
        "\n",
        "        E_sym = Tex(R\"\\vec{\\textbf{E}}\")\n",
        "        E_sym.next_to(arrows[0], LEFT).shift(0.1 * UP)\n",
        "\n",
        "        for vect in vectors:\n",
        "            vect.scale(0.75)\n",
        "            vect.shift(0.25 * UP)\n",
        "\n",
        "        # Put matrices on outer two\n",
        "        up_proj, down_proj = matrices = VGroup(\n",
        "            WeightMatrix(shape=(12, 6)),\n",
        "            WeightMatrix(shape=(6, 11)),\n",
        "        )\n",
        "        matrices.scale(0.25)\n",
        "        for arrow, mat in zip(arrows[::2], matrices):\n",
        "            mat.next_to(arrow, UP)\n",
        "\n",
        "        # Put ReLU graph on the middle\n",
        "        axes = Axes((-3, 3), (0, 3))\n",
        "        graph = axes.get_graph(lambda x: max(x, 0))\n",
        "        graph.set_color(BLUE)\n",
        "        relu = VGroup(axes, graph)\n",
        "        relu.match_width(arrows[1])\n",
        "        relu.next_to(arrows[1], UP)\n",
        "\n",
        "        # Full box\n",
        "        box = SurroundingRectangle(VGroup(arrows, matrices), buff=1.0)\n",
        "        box.set_stroke(WHITE, 2)\n",
        "        box.set_fill(GREY_E, 1)\n",
        "        title = Text(\"Multilayer Perceptron\", font_size=60)\n",
        "        title.next_to(box, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(box, title)\n",
        "\n",
        "        # Animate them all in\n",
        "        for matrix in matrices:\n",
        "            matrix.brackets.save_state()\n",
        "            matrix.brackets.stretch(0, 0).set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows, lag_ratio=0.5),\n",
        "            FadeIn(up_proj.get_rows(), lag_ratio=0.1, time_span=(0.0, 1.5)),\n",
        "            FadeIn(down_proj.get_rows(), lag_ratio=0.1, time_span=(1.5, 3.0)),\n",
        "            Restore(up_proj.brackets, time_span=(0.0, 1.5)),\n",
        "            Restore(down_proj.brackets, time_span=(1.5, 3.0)),\n",
        "            Write(relu, time_span=(1, 2)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show row replacement on the first\n",
        "        n, m = up_proj.shape\n",
        "        n_rows_shown = 8\n",
        "        R_labels = VGroup(\n",
        "            Tex(R\"\\vec{\\textbf{R}}_{\" + str(n) + \"}\")\n",
        "            for n in [*range(n_rows_shown - 1), \"n-1\"]\n",
        "        )\n",
        "        R_labels[-2].become(Tex(R\"\\vdots\").replace(R_labels[-2], dim_to_match=1))\n",
        "        R_labels.arrange(DOWN, buff=0.5)\n",
        "        R_labels.match_height(up_proj)\n",
        "        R_labels.move_to(up_proj)\n",
        "        h_lines = VGroup(\n",
        "            Line(up_proj.get_brackets()[0], R_labels, buff=0.1),\n",
        "            Line(R_labels, up_proj.get_brackets()[1], buff=0.1),\n",
        "        )\n",
        "        h_lines.set_stroke(GREY_A, 2)\n",
        "        row_labels = VGroup(\n",
        "            VGroup(R_label, h_lines.copy().match_y(R_label))\n",
        "            for R_label in R_labels\n",
        "        )\n",
        "        row_labels.set_color(YELLOW)\n",
        "        row_matrix = VGroup(\n",
        "            up_proj.get_brackets().copy(),\n",
        "            row_labels\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(up_proj.get_rows(), lag_ratio=0.1),\n",
        "            FadeIn(row_labels, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            row_labels[0][0].copy().animate.scale(2).next_to(title, UL).shift(2 * LEFT).set_opacity(0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the neurons\n",
        "        dots = VGroup(\n",
        "            Dot().set_fill(opacity=random.random()).move_to(entry)\n",
        "            for entry in vectors[2].get_columns()[0]\n",
        "        )\n",
        "        for dot in dots:\n",
        "            dot.match_x(dots[0])\n",
        "        dots.set_stroke(WHITE, 1)\n",
        "        self.play(Write(dots))\n",
        "        self.wait()\n",
        "\n",
        "        # Show column replacement on the second\n",
        "        col_matrix = self.get_col_matrix(down_proj, 8)\n",
        "        col_labels = col_matrix[1]\n",
        "        col_labels.set_color(RED_B)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(down_proj.get_columns(), lag_ratio=0.1),\n",
        "            FadeIn(col_labels, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            col_labels[0][0].copy().animate.scale(2).next_to(title, UR).shift(2 * RIGHT).set_opacity(0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        return\n",
        "        #### Trash ####\n",
        "\n",
        "        vectors[0].next_to(arrows[0], LEFT)\n",
        "        vectors[0].align_to(vectors[1], DOWN)\n",
        "        self.play(FadeIn(vectors[0]))\n",
        "        for i in (0, 1):\n",
        "            self.play(\n",
        "                FadeTransform(vectors[i].copy(), vectors[i + 1]),\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "\n",
        "class SuperpositionVectorBundle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        axes = ThreeDAxes(z_range=(-3, 3))\n",
        "        axes.scale(0.5)\n",
        "        vects = VGroup(\n",
        "            self.get_new_vector(v)\n",
        "            for v in np.identity(3)\n",
        "        )\n",
        "\n",
        "        frame.reorient(23, 71, 0, (0.0, 0.0, 0.5), 3.5)\n",
        "        frame.add_ambient_rotation(4 * DEGREES)\n",
        "        self.add(frame)\n",
        "        self.add(axes)\n",
        "        self.add(vects)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Add a new vector\n",
        "        n_vects = 10\n",
        "        for n in range(n_vects):\n",
        "            new_vect = self.get_new_vector(normalize(np.random.uniform(-1, 1, 3)))\n",
        "            # self.play(GrowArrow(new_vect))\n",
        "            vects.add(new_vect)\n",
        "            self.space_out_vectors(vects, run_time=3 + 0.5 * n)\n",
        "        self.wait(5)\n",
        "\n",
        "        # Use tensor flow to repeatedly cram more vectors into a space\n",
        "        pass\n",
        "\n",
        "    def get_new_vector(self, coords, color=None, opacity=0.9):\n",
        "        if color is None:\n",
        "            color = random_bright_color(hue_range=(0.4, 0.6), luminance_range=(0.5, 0.9))\n",
        "        vect = Vector(coords, thickness=2.0)\n",
        "        vect.set_fill(color, opacity=opacity, border_width=2)\n",
        "        vect.always.set_perpendicular_to_camera(self.frame)\n",
        "        return vect\n",
        "\n",
        "    def space_out_vectors(self, vects, run_time=4, learning_rate=0.01):\n",
        "        num_vectors = len(vects)\n",
        "        ends = np.array([v.get_end() for v in vects])\n",
        "        matrix = torch.from_numpy(ends)\n",
        "        matrix.requires_grad_(True)\n",
        "\n",
        "        optimizer = torch.optim.Adam([matrix], lr=learning_rate)\n",
        "        dot_diff_cutoff = 0.01\n",
        "        id_mat = torch.eye(num_vectors, num_vectors)\n",
        "\n",
        "        def update_vects(vects):\n",
        "            optimizer.zero_grad()\n",
        "            dot_products = matrix @ matrix.T\n",
        "            # Punish deviation from orthogonal\n",
        "            diff = dot_products - id_mat\n",
        "            # loss = (diff.abs() - dot_diff_cutoff).relu().sum()\n",
        "            loss = diff.pow(6).sum()\n",
        "\n",
        "            # Extra incentive to keep rows normalized\n",
        "            loss += num_vectors * diff.diag().pow(2).sum()\n",
        "            loss.backward()\n",
        "            optimizer.step()\n",
        "\n",
        "            for vect, arr in zip(vects, matrix):\n",
        "                vect.put_start_and_end_on(ORIGIN, arr.detach().numpy())\n",
        "\n",
        "        self.play(UpdateFromFunc(vects, update_vects, run_time=run_time))\n",
        "\n",
        "\n",
        "# Some old stubs\n",
        "\n",
        "\n",
        "class ClassicNeuralNetworksPicture(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ShowBiasBakedIntoWeightMatrix(LastTwoChapters):\n",
        "    def construct(self):\n",
        "        # Add initial blocks\n",
        "        frame = self.frame\n",
        "        square = Square(2.0)\n",
        "        att_icon = self.get_att_icon(square)\n",
        "        att_icon.set_stroke(WHITE, 1, 0.5)\n",
        "        mlp_icon = self.get_mlp_icon(square, layer_buff=1.0)\n",
        "        lnm_icon = self.get_layer_norm_icon()\n",
        "        lnm_icon.match_height(mlp_icon)\n",
        "\n",
        "        att_block = self.get_block(att_icon, \"Attention\", \"604M Parameters\", color=YELLOW)\n",
        "        mlp_block = self.get_block(mlp_icon, \"MLP\", \"1.2B Parameters\", color=BLUE)\n",
        "        lnm_block = self.get_block(lnm_icon, \"Layer Norm\", \"49K Parameters\", color=GREY_B)\n",
        "\n",
        "        blocks = VGroup(att_block, mlp_block, lnm_block)\n",
        "        blocks.arrange(RIGHT, buff=1.5)\n",
        "\n",
        "        lil_wrapper = self.get_layer_wrapper(blocks[:2].copy())\n",
        "        big_wrapper = self.get_layer_wrapper(blocks)\n",
        "\n",
        "        self.add(lil_wrapper, blocks[:2])\n",
        "        frame.match_x(blocks[:2])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.match_x(blocks),\n",
        "            ReplacementTransform(lil_wrapper, big_wrapper),\n",
        "            FadeIn(lnm_block, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(lnm_block[2], run_time=3, time_width=2))\n",
        "        self.wait()\n",
        "\n",
        "    def get_layer_norm_icon(self):\n",
        "        axes1, axes2 = all_axes = VGroup(\n",
        "            Axes((-4, 4), (0, 1, 0.25))\n",
        "            for x in range(2)\n",
        "        )\n",
        "        all_axes.set_shape(1.5, 0.5)\n",
        "        all_axes.arrange(DOWN, buff=1.0)\n",
        "        graph1 = axes1.get_graph(lambda x: 0.5 * norm.pdf(0.5 * x - 0.5))\n",
        "        graph2 = axes2.get_graph(lambda x: 1.5 * norm.pdf(x))\n",
        "        graph1.set_stroke(BLUE).set_fill(BLUE, 0.25)\n",
        "        graph2.set_stroke(BLUE).set_fill(BLUE, 0.25)\n",
        "        arrow = Arrow(axes1, axes2, buff=0.1)\n",
        "\n",
        "        return VGroup(axes1, graph1, arrow, axes2, graph2)\n",
        "\n",
        "    def get_layer_wrapper(self, blocks):\n",
        "        beige = \"#F5F5DC\"\n",
        "        rect = self.get_block(blocks, color=beige, buff=0.5, height=4)[0]\n",
        "        wrapped_arrow = self.get_wrapped_arrow(rect)\n",
        "        multiple = Tex(R\"\\times 96\")\n",
        "        multiple.next_to(wrapped_arrow, UP)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for b1, b2 in zip(blocks, blocks[1:]):\n",
        "            arrows.add(Arrow(b1[0], b2[0], buff=0.1))\n",
        "\n",
        "        return VGroup(rect, arrows, wrapped_arrow, multiple)\n",
        "\n",
        "    def get_block(\n",
        "        self, content,\n",
        "        upper_label=\"\",\n",
        "        lower_label=\"\",\n",
        "        upper_font_size=42,\n",
        "        lower_font_size=36,\n",
        "        buff=0.25,\n",
        "        height=2,\n",
        "        color=BLUE,\n",
        "        stroke_width=3,\n",
        "        fill_opacity=0.2\n",
        "    ):\n",
        "        block = SurroundingRectangle(content, buff=buff)\n",
        "        block.set_height(height, stretch=True)\n",
        "        block.round_corners(radius=0.25)\n",
        "        block.set_stroke(color, 3)\n",
        "        block.set_fill(color, fill_opacity)\n",
        "\n",
        "        low_label = Text(lower_label, font_size=lower_font_size)\n",
        "        low_label.next_to(block, DOWN, MED_SMALL_BUFF)\n",
        "        top_label = Text(upper_label, font_size=upper_font_size)\n",
        "        top_label.next_to(block, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        return VGroup(block, content, low_label, top_label)\n",
        "\n",
        "    def get_wrapped_arrow(self, big_block, buff=0.75, color=GREY_B, stroke_width=4):\n",
        "        vertices = [\n",
        "            big_block.get_corner(RIGHT),\n",
        "            big_block.get_corner(RIGHT) + buff * RIGHT,\n",
        "            big_block.get_corner(UR) + buff * UR,\n",
        "            big_block.get_corner(UL) + buff * UL,\n",
        "            big_block.get_corner(LEFT) + buff * LEFT,\n",
        "            big_block.get_corner(LEFT),\n",
        "        ]\n",
        "        line = Polygon(*vertices)\n",
        "        line.round_corners()\n",
        "        line.set_points(line.get_points()[:-2, :])\n",
        "        line.set_stroke(color, stroke_width)\n",
        "        tip = ArrowTip().move_to(line.get_end(), RIGHT)\n",
        "        tip.set_color(color)\n",
        "        line.add(tip)\n",
        "        return line\n",
        "\n",
        "\n",
        "class AlmostOrthogonal(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n"
    ]
}