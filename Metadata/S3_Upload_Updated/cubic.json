{
    "topic": "The mathematical concept being demonstrated is the cubic formula, specifically the solution of a cubic equation using",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.quintic.roots_and_coefs import *\n",
        "\n",
        "\n",
        "class CubicFormula(RootCoefScene):\n",
        "    coefs = [1, -1, 0, 1]\n",
        "    coef_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY,\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    root_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "            \"stroke_width\": 1.0,\n",
        "        }\n",
        "    }\n",
        "    sqrt_plane_config = {\n",
        "        \"x_range\": (-1.0, 1.0),\n",
        "        \"y_range\": (-1.0, 1.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": GREY_B,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"height\": 3.0,\n",
        "        \"width\": 3.0,\n",
        "    }\n",
        "    crt_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"height\": 3.0,\n",
        "        \"width\": 3.0,\n",
        "    }\n",
        "    cf_plane_config = {\n",
        "        \"x_range\": (-2.0, 2.0),\n",
        "        \"y_range\": (-2.0, 2.0),\n",
        "        \"background_line_style\": {\n",
        "            \"stroke_color\": BLUE_E,\n",
        "            \"stroke_width\": 1.0,\n",
        "        },\n",
        "        \"height\": 3.0,\n",
        "        \"width\": 3.0,\n",
        "    }\n",
        "    plane_height = 3.0\n",
        "    plane_buff = 1.0\n",
        "    planes_center = 1.6 * UP\n",
        "    lower_planes_height = 2.75\n",
        "    lower_planes_buff = 2.0\n",
        "\n",
        "    sqrt_dot_color = GREEN\n",
        "    crt_dot_colors = (RED, BLUE)\n",
        "    cf_dot_color = YELLOW\n",
        "\n",
        "    def add_planes(self):\n",
        "        super().add_planes()\n",
        "        self.root_plane_label.next_to(self.root_plane, -self.plane_arrangement)\n",
        "        self.coef_plane_label.next_to(self.coef_plane, self.plane_arrangement)\n",
        "        self.add_lower_planes()\n",
        "\n",
        "    def add_lower_planes(self):\n",
        "        sqrt_plane = ComplexPlane(**self.sqrt_plane_config)\n",
        "        crt_plane = ComplexPlane(**self.crt_plane_config)\n",
        "        cf_plane = ComplexPlane(**self.cf_plane_config)\n",
        "\n",
        "        planes = VGroup(sqrt_plane, crt_plane, cf_plane)\n",
        "        for plane in planes:\n",
        "            plane.add_coordinate_labels(font_size=16)\n",
        "        planes.set_height(self.lower_planes_height)\n",
        "        planes.arrange(RIGHT, buff=self.lower_planes_buff)\n",
        "        planes.to_edge(DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        kw = dict(\n",
        "            font_size=24,\n",
        "            tex_to_color_map={\n",
        "                \"\\\\delta_1\": GREEN,\n",
        "                \"\\\\delta_2\": GREEN,\n",
        "            },\n",
        "            background_stroke_width=3,\n",
        "            background_stroke_color=3,\n",
        "        )\n",
        "\n",
        "        sqrt_label = OldTex(\n",
        "            \"\\\\delta_1, \\\\delta_2 = \\\\sqrt{ \\\\frac{q^2}{4} + \\\\frac{p^3}{27}}\",\n",
        "            **kw\n",
        "        )\n",
        "        sqrt_label.set_backstroke()\n",
        "        sqrt_label.next_to(sqrt_plane, UP, SMALL_BUFF)\n",
        "\n",
        "        crt_labels = VGroup(\n",
        "            OldTex(\"\\\\cdot\", \"= \\\\sqrt[3]{-\\\\frac{q}{2} + \\\\delta_1}\", **kw),\n",
        "            OldTex(\"\\\\cdot\", \"= \\\\sqrt[3]{-\\\\frac{q}{2} + \\\\delta_2}\", **kw),\n",
        "        )\n",
        "        for label, color in zip(crt_labels, self.crt_dot_colors):\n",
        "            label[0].scale(4, about_edge=RIGHT)\n",
        "            label[0].set_color(color)\n",
        "            label.set_backstroke()\n",
        "        crt_labels.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        crt_labels.next_to(crt_plane, UP, SMALL_BUFF)\n",
        "\n",
        "        cf_label = OldTex(\n",
        "            \"\\\\sqrt[3]{ -\\\\frac{q}{2} + \\\\delta_1 } +\",\n",
        "            \"\\\\sqrt[3]{ -\\\\frac{q}{2} + \\\\delta_2 }\",\n",
        "            # **kw  # TODO, What the hell is going on here...\n",
        "            font_size=24,\n",
        "        )\n",
        "        cf_label.set_backstroke()\n",
        "        cf_label.next_to(cf_plane, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(planes)\n",
        "        self.add(sqrt_label)\n",
        "        self.add(crt_labels)\n",
        "        self.add(cf_label)\n",
        "\n",
        "        self.sqrt_plane = sqrt_plane\n",
        "        self.crt_plane = crt_plane\n",
        "        self.cf_plane = cf_plane\n",
        "        self.sqrt_label = sqrt_label\n",
        "        self.crt_labels = crt_labels\n",
        "        self.cf_label = cf_label\n",
        "\n",
        "    def get_coef_poly(self):\n",
        "        return OldTex(\n",
        "            \"x^3 + {0}x^2 + {p}x + {q}\",\n",
        "            tex_to_color_map={\n",
        "                \"{0}\": self.coef_color,\n",
        "                \"{p}\": self.coef_color,\n",
        "                \"{q}\": self.coef_color,\n",
        "            }\n",
        "        )\n",
        "\n",
        "    def add_c_labels(self):\n",
        "        self.c_dot_labels = self.add_dot_labels(\n",
        "            VGroup(*map(Tex, [\"q\", \"p\", \"0\"])),\n",
        "            self.coef_dots\n",
        "        )\n",
        "\n",
        "    def get_c_symbols(self, coef_poly):\n",
        "        return VGroup(*(\n",
        "            coef_poly.get_part_by_tex(tex)\n",
        "            for tex in [\"q\", \"p\", \"0\"]\n",
        "        ))\n",
        "\n",
        "    #\n",
        "    def add_dots(self):\n",
        "        super().add_dots()\n",
        "        self.add_sqrt_dots()\n",
        "        self.add_crt_dots()\n",
        "        self.add_cf_dots()\n",
        "\n",
        "    def add_sqrt_dots(self):\n",
        "        sqrt_dots = Dot(**self.dot_style).replicate(2)\n",
        "        sqrt_dots.set_color(self.sqrt_dot_color)\n",
        "\n",
        "        def update_sqrt_dots(dots):\n",
        "            q, p, zero, one = self.get_coefs()\n",
        "            disc = (q**2 / 4) + (p**3 / 27)\n",
        "            roots = get_nth_roots(disc, 2)\n",
        "            optimal_transport(dots, map(self.sqrt_plane.n2p, roots))\n",
        "            return dots\n",
        "\n",
        "        sqrt_dots.add_updater(update_sqrt_dots)\n",
        "\n",
        "        self.sqrt_dots = sqrt_dots\n",
        "        self.add(sqrt_dots)\n",
        "        self.add(self.get_tracers(sqrt_dots))\n",
        "\n",
        "        # Labels\n",
        "        self.delta_labels = self.add_dot_labels(\n",
        "            VGroup(OldTex(\"\\\\delta_1\"), OldTex(\"\\\\delta_2\")),\n",
        "            sqrt_dots\n",
        "        )\n",
        "\n",
        "    def get_deltas(self):\n",
        "        return list(map(self.sqrt_plane.p2n, (d.get_center() for d in self.sqrt_dots)))\n",
        "\n",
        "    def add_crt_dots(self):\n",
        "        crt_dots = Dot(**self.dot_style).replicate(3).replicate(2)\n",
        "        for dots, color in zip(crt_dots, self.crt_dot_colors):\n",
        "            dots.set_color(color)\n",
        "\n",
        "        def update_crt_dots(dot_triples):\n",
        "            q, p, zero, one = self.get_coefs()\n",
        "            deltas = self.get_deltas()\n",
        "\n",
        "            for delta, triple in zip(deltas, dot_triples):\n",
        "                roots = get_nth_roots(-q / 2 + delta, 3)\n",
        "                optimal_transport(triple, map(self.crt_plane.n2p, roots))\n",
        "            return dot_triples\n",
        "\n",
        "        crt_dots.add_updater(update_crt_dots)\n",
        "\n",
        "        self.add(crt_dots)\n",
        "        self.add(*(self.get_tracers(triple) for triple in crt_dots))\n",
        "\n",
        "        self.crt_dots = crt_dots\n",
        "\n",
        "    def get_cube_root_values(self):\n",
        "        return [\n",
        "            [\n",
        "                self.crt_plane.p2n(d.get_center())\n",
        "                for d in triple\n",
        "            ]\n",
        "            for triple in self.crt_dots\n",
        "        ]\n",
        "\n",
        "    def add_crt_lines(self):\n",
        "        crt_lines = VGroup(*(\n",
        "            Line(stroke_color=color, stroke_width=1).replicate(3)\n",
        "            for color in self.crt_dot_colors\n",
        "        ))\n",
        "\n",
        "        def update_crt_lines(crt_lines):\n",
        "            cube_root_values = self.get_cube_root_values()\n",
        "            origin = self.crt_plane.n2p(0)\n",
        "            for lines, triple in zip(crt_lines, cube_root_values):\n",
        "                for line, value in zip(lines, triple):\n",
        "                    line.put_start_and_end_on(origin, self.crt_plane.n2p(value))\n",
        "\n",
        "        crt_lines.add_updater(update_crt_lines)\n",
        "\n",
        "        self.add(crt_lines)\n",
        "        self.crt_lines = crt_lines\n",
        "\n",
        "    def add_cf_dots(self):\n",
        "        cf_dots = Dot(**self.dot_style).replicate(9)\n",
        "        cf_dots.set_fill(self.root_color, opacity=0.5)\n",
        "\n",
        "        def update_cf_dots(dots):\n",
        "            cube_root_values = self.get_cube_root_values()\n",
        "            for dot, (z1, z2) in zip(dots, it.product(*cube_root_values)):\n",
        "                dot.move_to(self.cf_plane.n2p(z1 + z2))\n",
        "            return dots\n",
        "\n",
        "        cf_dots.add_updater(update_cf_dots)\n",
        "\n",
        "        alt_root_dots = GlowDot()\n",
        "        alt_root_dots.add_updater(lambda m: m.set_points(\n",
        "            list(map(self.cf_plane.n2p, self.get_roots()))\n",
        "        ))\n",
        "\n",
        "        self.cf_dots = cf_dots\n",
        "        self.alt_root_dots = alt_root_dots\n",
        "\n",
        "        self.add(cf_dots)\n",
        "        self.add(self.get_tracers(cf_dots, stroke_width=0.5))\n",
        "        self.add(alt_root_dots)\n",
        "\n",
        "    def add_cf_lines(self):\n",
        "        cf_lines = VGroup(\n",
        "            Line(stroke_color=self.crt_dot_colors[0]).replicate(9),\n",
        "            Line(stroke_color=self.crt_dot_colors[1]).replicate(3),\n",
        "        )\n",
        "        cf_lines.set_stroke(width=1)\n",
        "\n",
        "        def update_cf_lines(cf_lines):\n",
        "            cube_root_values = self.get_cube_root_values()\n",
        "            for z1, line in zip(cube_root_values[1], cf_lines[1]):\n",
        "                line.put_start_and_end_on(\n",
        "                    self.cf_plane.n2p(0),\n",
        "                    self.cf_plane.n2p(z1),\n",
        "                )\n",
        "            for line, (z1, z2) in zip(cf_lines[0], it.product(*cube_root_values)):\n",
        "                line.put_start_and_end_on(\n",
        "                    self.cf_plane.n2p(z2),\n",
        "                    self.cf_plane.n2p(z1 + z2),\n",
        "                )\n",
        "\n",
        "        cf_lines.add_updater(update_cf_lines)\n",
        "\n",
        "        self.cf_lines = cf_lines\n",
        "        self.add(cf_lines)\n",
        "\n",
        "\n",
        "class CubicFormulaTest(CubicFormula):\n",
        "    def construct(self):\n",
        "        pass\n",
        "        # self.embed()\n"
    ]
}