{
    "topic": "The mathematical concept being demonstrated is the random sampling of a quantum state.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.blocks_and_grover.qc_supplements import *\n",
        "\n",
        "\n",
        "class BitString(VGroup):\n",
        "    def __init__(self, value, length=4, buff=SMALL_BUFF):\n",
        "        self.length = length\n",
        "        bit_mob = Integer(0)\n",
        "        super().__init__(bit_mob.copy() for n in range(length))\n",
        "        self.arrange(RIGHT, buff=buff)\n",
        "        self.set_value(value)\n",
        "\n",
        "    def set_value(self, value):\n",
        "        bits = bin(value)[2:].zfill(self.length)\n",
        "        for mob, bit in zip(self, bits):\n",
        "            mob.set_value(int(bit))\n",
        "\n",
        "\n",
        "class Ket(Tex):\n",
        "    def __init__(self, mobject, height_scale_factor=1.25, buff=SMALL_BUFF):\n",
        "        super().__init__(R\"| \\rangle\")\n",
        "        self.set_height(height_scale_factor * mobject.get_height())\n",
        "        self[0].next_to(mobject, LEFT, buff)\n",
        "        self[1].next_to(mobject, RIGHT, buff)\n",
        "\n",
        "\n",
        "class KetGroup(VGroup):\n",
        "    def __init__(self, mobject, **kwargs):\n",
        "        ket = Ket(mobject, **kwargs)\n",
        "        super().__init__(ket, mobject)\n",
        "\n",
        "\n",
        "class RandomSampling(Animation):\n",
        "    def __init__(\n",
        "        self,\n",
        "        mobject: Mobject,\n",
        "        samples: list,\n",
        "        weights: list[float] | None = None,\n",
        "        **kwargs\n",
        "    ):\n",
        "        self.samples = samples\n",
        "        self.weights = weights\n",
        "        super().__init__(mobject, **kwargs)\n",
        "\n",
        "    def interpolate(self, alpha: float) -> None:\n",
        "        if self.weights is None:\n",
        "            target = random.choice(self.samples)\n",
        "        else:\n",
        "            target = random.choices(self.samples, self.weights)[0]\n",
        "        self.mobject.set_submobjects(target.submobjects)\n",
        "\n",
        "\n",
        "class ContrstClassicalAndQuantum(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Titles\n",
        "        classical, quantum = symbols = VGroup(\n",
        "            get_classical_computer_symbol(),\n",
        "            get_quantum_computer_symbol(),\n",
        "        )\n",
        "        for symbol, vect in zip(symbols, [LEFT, RIGHT]):\n",
        "            symbol.set_height(1)\n",
        "            symbol.move_to(vect * FRAME_WIDTH / 4)\n",
        "            symbol.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.add(symbols)\n",
        "        self.add(v_line)\n",
        "\n",
        "        # Bits\n",
        "        frame = self.frame\n",
        "        value = ord('C')\n",
        "        short_boxed_bits = self.get_boxed_bits(12, 4)\n",
        "        boxed_bits = self.get_boxed_bits(value, 8)\n",
        "        for group in short_boxed_bits, boxed_bits:\n",
        "            group.match_x(classical)\n",
        "        boxes, bits = boxed_bits\n",
        "\n",
        "        self.add(short_boxed_bits)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(v_line, shift=2 * RIGHT),\n",
        "            FadeOut(quantum, shift=RIGHT),\n",
        "            ReplacementTransform(short_boxed_bits, boxed_bits),\n",
        "            frame.animate.match_x(classical),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Draw layers of abstraction\n",
        "        layers = Rectangle(8.0, 1.5).replicate(3)\n",
        "        layers.arrange(UP, buff=0)\n",
        "        layers.set_stroke(width=0)\n",
        "        layers.set_fill(opacity=0.5)\n",
        "        layers.set_submobject_colors_by_gradient(BLUE_E, BLUE_D, BLUE_C)\n",
        "        layers.set_z_index(-1)\n",
        "        layers.move_to(boxes)\n",
        "\n",
        "        layers_name = Text(\"Layers\\nof\\nAbstraction\", alignment=\"LEFT\")\n",
        "        layers_name.next_to(layers, RIGHT)\n",
        "\n",
        "        layer_names = VGroup(\n",
        "            Text(\"Hardware\"),\n",
        "            Text(\"Bits\"),\n",
        "            Text(\"Data types\"),\n",
        "        )\n",
        "        layer_names.set_fill(GREY_B)\n",
        "        layer_names.scale(0.6)\n",
        "        for name, layer in zip(layer_names, layers):\n",
        "            name.next_to(layer, LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        num_mob = Integer(value)\n",
        "        num_mob.move_to(layers[2])\n",
        "        character = Text(f\"'{chr(value)}'\")\n",
        "        character.move_to(layers[2]).shift(0.75 * RIGHT)\n",
        "\n",
        "        circuitry = get_bit_circuit(4)\n",
        "        circuitry.set_height(layers[2].get_height() * 0.7)\n",
        "        circuitry.move_to(layers[0])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, layers, lag_ratio=0.25, run_time=1),\n",
        "            FadeIn(layers_name, lag_ratio=1e-2),\n",
        "            Write(layer_names[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(bit, num_mob)\n",
        "                for bit in bits),\n",
        "                lag_ratio=0.02,\n",
        "            ),\n",
        "            FadeIn(layer_names[2], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            num_mob.animate.shift(0.75 * LEFT),\n",
        "            FadeIn(character, 0.5 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(circuitry),\n",
        "            FadeIn(layer_names[0], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Extend layers to the quantum case\n",
        "        new_layers_name = Text(\"Layers of Abstraction\")\n",
        "        new_layers_name.next_to(layers, DOWN)\n",
        "        new_layers_name.match_x(quantum)\n",
        "\n",
        "        layers.target = layers.generate_target()\n",
        "        layers.target.set_width(FRAME_WIDTH, stretch=True)\n",
        "        layers.target.set_x(0)\n",
        "\n",
        "        layer_names.generate_target()\n",
        "        for name, layer in zip(layer_names.target, layers.target):\n",
        "            name.next_to(layer.get_left(), RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                frame.animate.set_x(0),\n",
        "                MoveToTarget(layer_names),\n",
        "                FadeIn(quantum, RIGHT),\n",
        "                ShowCreation(v_line),\n",
        "                Transform(layers_name, new_layers_name),\n",
        "                Group(num_mob, character, boxed_bits).animate.shift(RIGHT),\n",
        "                circuitry.animate.scale(0.8).shift(RIGHT)\n",
        "            ),\n",
        "            MoveToTarget(layers, lag_ratio=0.01),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show quantum material\n",
        "        qubit_string = BitString(0, length=8)\n",
        "        qubit_string.set_value(ord(\"Q\"))\n",
        "        qubit_ket = Ket(qubit_string)\n",
        "        qubits = VGroup(qubit_ket, qubit_string)\n",
        "\n",
        "        qunit_num = Integer(ord(\"Q\"))\n",
        "        qunit_ket = Ket(qunit_num)\n",
        "        qunit = VGroup(qunit_ket, qunit_num)\n",
        "\n",
        "        ion = Group(\n",
        "            GlowDot(color=RED, radius=0.5),\n",
        "            Dot(radius=0.1).set_fill(RED, 0.5),\n",
        "            Tex(R\"+\", font_size=14).set_fill(border_width=1)\n",
        "        )\n",
        "        trapped_ions = Group(ion.copy().shift(x * RIGHT) for x in np.linspace(0, 4, 8))\n",
        "\n",
        "        for mob, layer in zip([trapped_ions, qubits, qunit], layers):\n",
        "            mob.move_to(layer).match_x(quantum)\n",
        "\n",
        "        for ion, bit in zip(trapped_ions, qubit_string):\n",
        "            if bit.get_value() == 1:\n",
        "                ion[0].set_opacity(0)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, trapped_ions))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(qubits, UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(qubits, qunit)\n",
        "        )\n",
        "        self.wait()\n",
        "        value_tracker = ValueTracker(ord(\"Q\"))\n",
        "        for value in [ord('C'), ord('Q')]:\n",
        "            self.play(\n",
        "                value_tracker.animate.set_value(value),\n",
        "                UpdateFromFunc(qunit_num, lambda m: m.set_value(int(value_tracker.get_value()))),\n",
        "                UpdateFromFunc(qubit_string, lambda m: m.set_value(int(value_tracker.get_value()))),\n",
        "                rate_func=linear,\n",
        "                run_time=1.0\n",
        "            )\n",
        "            self.wait(0.25)\n",
        "\n",
        "        # Show some measurements\n",
        "        lasers = VGroup()\n",
        "        for ion in trapped_ions:\n",
        "            point = ion.get_center()\n",
        "            laser = Line(point + 0.5 * DL, point)\n",
        "            laser.insert_n_curves(20)\n",
        "            laser.set_stroke(RED, [1, 3, 3, 3, 1])\n",
        "            lasers.add(laser)\n",
        "\n",
        "        for value in [*np.random.randint(0, 2**8, 4), ord(\"Q\")]:\n",
        "            qubit_string.generate_target()\n",
        "            qunit_num.generate_target()\n",
        "            trapped_ions.generate_target()\n",
        "            qunit_num.target.set_value(value)\n",
        "            qubit_string.target.set_value(value)\n",
        "            for ion, bit in zip(trapped_ions.target, qubit_string.target):\n",
        "                ion[0].set_opacity(1.0 - bit.get_value())\n",
        "            self.play(\n",
        "                LaggedStartMap(VShowPassingFlash, lasers, lag_ratio=0.1, time_width=2.0, run_time=2),\n",
        "                MoveToTarget(trapped_ions, lag_ratio=0.1, time_span=(0.5, 2.0)),\n",
        "                MoveToTarget(qubit_string, lag_ratio=0.1, time_span=(0.5, 2.0)),\n",
        "                MoveToTarget(qunit_num, time_span=(1.0, 1.25)),\n",
        "                Transform(qunit_ket, Ket(qunit_num.target), time_span=(1.0, 1.5)),\n",
        "            )\n",
        "\n",
        "        # Describe a ket\n",
        "        morty = Mortimer(height=5)\n",
        "        morty.move_to(np.array([13., -6., 0.]))\n",
        "        big_ket = Ket(Square(1))\n",
        "        big_ket.set_fill(border_width=3)\n",
        "        big_ket.next_to(morty.get_corner(UL), UP, MED_LARGE_BUFF)\n",
        "        big_ket_name = TexText(\"``ket''\", font_size=96)\n",
        "        big_ket_name.next_to(big_ket, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (4.66, -2.55, 0.0), 13.19),\n",
        "            morty.change(\"raise_right_hand\", big_ket),\n",
        "            VFadeIn(morty),\n",
        "            *(\n",
        "                TransformFromCopy(src, big_ket)\n",
        "                for src in [qubit_ket, qunit_ket]\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(big_ket_name, time_span=(0.75, 2.0)),\n",
        "            FlashAround(big_ket, time_width=1.5, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Refocus\n",
        "        self.remove(big_ket)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(VGroup(morty, big_ket, big_ket_name)),\n",
        "            TransformFromCopy(big_ket, qubit_ket),\n",
        "            TransformFromCopy(big_ket, qunit_ket),\n",
        "            frame.animate.to_default_state(),\n",
        "        ))\n",
        "\n",
        "        # Expand mid layer\n",
        "        mid_layer = layers[1]\n",
        "        mid_layer.set_z_index(-2)\n",
        "        mid_layer.generate_target()\n",
        "        mid_layer.target.set_height(7, stretch=True)\n",
        "        mid_layer.target.move_to(layers, UP)\n",
        "        mid_layer.target.set_fill(opacity=0.25)\n",
        "\n",
        "        target_y = -1.0\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(\n",
        "                VGroup(layers[2], num_mob, character, qunit, layer_names[2]),\n",
        "                UP,\n",
        "            ),\n",
        "            FadeOut(\n",
        "                Group(layers[0], circuitry, trapped_ions, layer_names[0]),\n",
        "                DOWN,\n",
        "            ),\n",
        "            FadeOut(layers_name, DOWN),\n",
        "            qubits.animate.set_y(target_y),\n",
        "            boxed_bits.animate.match_x(classical).set_y(target_y),\n",
        "            layer_names[1].animate.set_y(target_y),\n",
        "            MoveToTarget(mid_layer, time_span=(0.5, 2.0)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(layers[1]),\n",
        "            FadeOut(layer_names[1]),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Show state vs. what you read, classical\n",
        "        contrast = VGroup(\n",
        "            Text(\"State\"),\n",
        "            Tex(R\"=\", font_size=72),\n",
        "            Text(\"What you see\"),\n",
        "        )\n",
        "        contrast.arrange(RIGHT)\n",
        "        contrast[2].align_to(contrast[0], UP)\n",
        "        contrast.match_x(classical)\n",
        "        contrast.set_y(0.5)\n",
        "        contrast.shift(0.5 * RIGHT)\n",
        "\n",
        "        boxed_bits_copy = boxed_bits.copy()\n",
        "        boxed_bits_copy.scale(0.7)\n",
        "        boxed_bits_copy.stretch(0.8, 0)\n",
        "        for bit in boxed_bits_copy[1]:\n",
        "            bit.stretch(1 / 0.8, 0)\n",
        "        boxed_bits_copy.next_to(contrast[2], DOWN, buff=0.75)\n",
        "        boxed_bits_copy[0].set_stroke(WHITE, 1)\n",
        "\n",
        "        boxed_bits.target = boxed_bits_copy.copy()\n",
        "        boxed_bits.target.match_x(contrast[0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(contrast[::2]),\n",
        "            MoveToTarget(boxed_bits),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(contrast[1]),\n",
        "            TransformFromCopy(boxed_bits, boxed_bits_copy, path_arc=30 * DEG),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*(\n",
        "            LaggedStart(\n",
        "                (bit.animate.set_stroke(YELLOW, 3).set_anim_args(rate_func=there_and_back)\n",
        "                for bit in group[1]),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=4\n",
        "            )\n",
        "            for group in [boxed_bits, boxed_bits_copy]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show state vs. what you read, quantum\n",
        "        q_contrast = contrast.copy()\n",
        "        q_contrast.match_x(quantum)\n",
        "        ne = Tex(R\"\\ne\", font_size=72)\n",
        "        ne.move_to(q_contrast[1])\n",
        "        ne.set_color(RED)\n",
        "        q_contrast[1].become(ne)\n",
        "\n",
        "        state_vector = Vector(UR, thickness=4)\n",
        "        state_vector.set_color(TEAL)\n",
        "        state_vector.next_to(q_contrast[0], DOWN, MED_LARGE_BUFF)\n",
        "        state_vector.set_opacity(0)  # Going to overlap something else instead\n",
        "\n",
        "        state_vector_outline = state_vector.copy().set_fill(opacity=0)\n",
        "        state_vector_outline.set_stroke(BLUE_A, 3)\n",
        "        state_vector_outline.insert_n_curves(100)\n",
        "\n",
        "        qubits.generate_target()\n",
        "        qubits.target[1].space_out_submobjects(0.8)\n",
        "        qubits.target[0].become(Ket(qubits.target[1]))\n",
        "        qubits.target.match_x(q_contrast[2]).match_y(state_vector)\n",
        "\n",
        "        moving_rect = SurroundingRectangle(state_vector)\n",
        "        moving_rect.set_stroke(YELLOW, 3, 0)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(contrast, q_contrast, path_arc=-45 * DEG),\n",
        "            MoveToTarget(qubits),\n",
        "            GrowArrow(state_vector),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(moving_rect.animate.surround(qubits).set_stroke(YELLOW, 3, 1))\n",
        "        self.play(FadeOut(moving_rect))\n",
        "        self.play(\n",
        "            value_tracker.animate.set_value(0).set_anim_args(rate_func=there_and_back, run_time=4),\n",
        "            UpdateFromFunc(qubit_string, lambda m: m.set_value(int(value_tracker.get_value()))),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show randomness\n",
        "        qubit_samples = list()\n",
        "        for n in range(2**8):\n",
        "            sample = qubits.copy()\n",
        "            sample[1].set_value(n)\n",
        "            sample.shift(np.random.uniform(-0.05, 0.05, 3))\n",
        "            sample.set_stroke(TEAL, 1)\n",
        "            qubit_samples.append(sample)\n",
        "\n",
        "        labels = VGroup(Text(\"Random\"), Text(\"Deterministic\"))\n",
        "        for label, mob, color in zip(labels, [qubits, boxed_bits_copy], [TEAL, YELLOW]):\n",
        "            label.scale(0.75)\n",
        "            label.next_to(mob, DOWN, buff=MED_LARGE_BUFF)\n",
        "            label.set_color(color)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(labels),\n",
        "            RandomSampling(qubits, qubit_samples),\n",
        "        )\n",
        "        self.wait()\n",
        "        for _ in range(8):\n",
        "            self.play(RandomSampling(qubits, qubit_samples))\n",
        "            self.wait()\n",
        "\n",
        "    def get_boxed_bits(self, value, length, height=0.5):\n",
        "        boxes = Square().get_grid(1, length, buff=0)\n",
        "        boxes.set_height(height)\n",
        "        boxes.set_stroke(WHITE, 2)\n",
        "        bits = BitString(value, length)\n",
        "        for bit, box in zip(bits, boxes):\n",
        "            bit.move_to(box)\n",
        "        return VGroup(boxes, bits)\n",
        "\n",
        "\n",
        "class AmbientStateVector(InteractiveScene):\n",
        "    moving = False\n",
        "\n",
        "    def construct(self):\n",
        "        plane, axes = self.get_plane_and_axes()\n",
        "\n",
        "        frame.reorient(14, 76, 0)\n",
        "        frame.add_ambient_rotation(3 * DEG)\n",
        "        self.add(plane, axes)\n",
        "\n",
        "        # Vector\n",
        "        vector = Vector(2 * normalize([1, 1, 2]), thickness=5)\n",
        "        vector.set_fill(border_width=2)\n",
        "        vector.set_color(TEAL)\n",
        "        vector.always.set_perpendicular_to_camera(frame)\n",
        "\n",
        "        self.play(GrowArrow(vector))\n",
        "\n",
        "        if not self.moving:\n",
        "            self.wait(36)\n",
        "        else:\n",
        "            for n in range(16):\n",
        "                axis = normalize(np.random.uniform(-1, 1, 3))\n",
        "                angle = np.random.uniform(0, PI)\n",
        "                self.play(Rotate(vector, angle, axis=axis, about_point=ORIGIN))\n",
        "                self.wait()\n",
        "\n",
        "        # Show the sphere\n",
        "        frame.reorient(16, 77, 0)\n",
        "\n",
        "        sphere = Sphere(radius=2)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "        sphere.set_color(BLUE, 0.25)\n",
        "        sphere_mesh = SurfaceMesh(sphere, resolution=(41, 21))\n",
        "        sphere_mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(sphere),\n",
        "            Write(sphere_mesh, lag_ratio=1e-3),\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_plane_and_axes(self, scale_factor=2.0):\n",
        "        # Add axes\n",
        "        frame = self.frame\n",
        "        axes = ThreeDAxes((-1, 1), (-1, 1), (-1, 1))\n",
        "        plane = NumberPlane(\n",
        "            (-1, 1 - 1e-5),\n",
        "            (-1, 1 - 1e-5),\n",
        "            faded_line_ratio=5\n",
        "        )\n",
        "        plane.background_lines.set_stroke(opacity=0.5)\n",
        "        plane.faded_lines.set_stroke(opacity=0.25)\n",
        "        plane.axes.set_stroke(opacity=0.25)\n",
        "        result = VGroup(plane, axes)\n",
        "        result.scale(scale_factor)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class RotatingStateVector(AmbientStateVector):\n",
        "    moving = True\n",
        "\n",
        "\n",
        "class FlipsToCertainDirection(AmbientStateVector):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        frame = self.frame\n",
        "        plane, axes = axes_group = self.get_plane_and_axes(scale_factor=3)\n",
        "\n",
        "        vector = Vector(axes.c2p(1, 0, 0), fill_color=TEAL, thickness=5)\n",
        "        vector.always.set_perpendicular_to_camera(frame)\n",
        "\n",
        "        frame.reorient(-31, 72, 0)\n",
        "        frame.add_ambient_rotation(DEG)\n",
        "        self.add(frame)\n",
        "        self.add(plane, axes)\n",
        "        self.add(vector)\n",
        "\n",
        "        # Show some flips\n",
        "        theta = 15 * DEG\n",
        "        h_plane = Square3D()\n",
        "        h_plane.replace(plane)\n",
        "        h_plane.set_color(WHITE, 0.15)\n",
        "        diag_plane = h_plane.copy().rotate(theta, axis=DOWN)\n",
        "        ghosts = VGroup()\n",
        "\n",
        "        for n in range(1, 14):\n",
        "            axis = [UP, DOWN][n % 2]\n",
        "            shown_plane = [h_plane, diag_plane][n % 2]\n",
        "            if n == 1:\n",
        "                shown_plane = VectorizedPoint()\n",
        "            ghosts.add(vector.copy())\n",
        "            ghosts.generate_target()\n",
        "            for n, vect in enumerate(ghosts.target[::-1]):\n",
        "                vect.set_opacity(0.5 / (n + 1))\n",
        "            self.play(\n",
        "                MoveToTarget(ghosts),\n",
        "                Rotate(vector, n * theta, axis=axis, about_point=ORIGIN),\n",
        "            )\n",
        "            shown_plane.set_opacity(0.15)\n",
        "\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class DisectAQuantumComputer(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up the machine with a random pile of gates\n",
        "        wires = Line(4 * LEFT, 4 * RIGHT).replicate(4)\n",
        "        wires.arrange(DOWN, buff=0.5)\n",
        "        wires.shift(LEFT)\n",
        "\n",
        "        gates = VGroup(\n",
        "            self.get_labeled_box(wires[0], 0.1),\n",
        "            self.get_cnot(wires[1], wires[0], 0.2),\n",
        "            self.get_cnot(wires[3], wires[1], 0.3),\n",
        "            self.get_cnot(wires[2], wires[3], 0.4),\n",
        "            self.get_labeled_box(wires[3], 0.5, \"X\"),\n",
        "            self.get_labeled_box(wires[1], 0.5, \"Z\"),\n",
        "            self.get_cnot(wires[2], wires[1], 0.6),\n",
        "            self.get_labeled_box(wires[1], 0.7),\n",
        "            self.get_cnot(wires[3], wires[1], 0.8),\n",
        "            self.get_cnot(wires[0], wires[1], 0.9),\n",
        "        )\n",
        "        mes_gates = VGroup(\n",
        "            self.get_measurement(wires[0], 1),\n",
        "            self.get_measurement(wires[1], 1),\n",
        "            self.get_measurement(wires[2], 1),\n",
        "            self.get_measurement(wires[3], 1),\n",
        "        )\n",
        "\n",
        "        circuit = Group(wires, Point(), gates, mes_gates)\n",
        "        machine_rect = SurroundingRectangle(circuit)\n",
        "        machine_rect.set_stroke(TEAL, 2)\n",
        "        qc_label = get_quantum_computer_symbol(height=1)\n",
        "        qc_label.next_to(machine_rect, UP)\n",
        "\n",
        "        self.add(circuit, machine_rect, qc_label)\n",
        "\n",
        "        # Show a program running through quantum wires (TODO< show the results)\n",
        "        n_repetitions = 25\n",
        "\n",
        "        wire_glows = Group(\n",
        "            GlowDot(wire.get_start(), color=TEAL, radius=0.25)\n",
        "            for wire in wires\n",
        "        )\n",
        "        wire_glows.set_z_index(-1)\n",
        "        gate_glows = gates.copy()\n",
        "        gate_glows.set_stroke(TEAL, 1)\n",
        "        gate_glows.set_fill(opacity=0)\n",
        "        for glow in gate_glows:\n",
        "            glow.add_updater(lambda m: m.set_stroke(width=4 * np.exp(\n",
        "                -(0.5 * (m.get_x() - wire_glows.get_x()))**2\n",
        "            )))\n",
        "\n",
        "        output = self.get_random_qubits()\n",
        "        output.next_to(machine_rect, RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        for n in range(n_repetitions):\n",
        "            self.add(gate_glows)\n",
        "            wire_glows.set_x(wires.get_x(LEFT))\n",
        "            wire_glows.set_opacity(1)\n",
        "            self.play(\n",
        "                wire_glows.animate.match_x(mes_gates),\n",
        "                rate_func=linear,\n",
        "                run_time=1\n",
        "            )\n",
        "            output_value = random.randint(0, 15)\n",
        "            output[0].set_value(output_value)\n",
        "            for mes_gate, bit in zip(mes_gates, output[0]):\n",
        "                mes_gate[-1].set_stroke(opacity=0)\n",
        "                mes_gate[-1][bit.get_value()].set_stroke(opacity=1)\n",
        "            self.add(output)\n",
        "            wire_glows.set_opacity(0)\n",
        "            self.play(wire_glows.animate.shift(6 * RIGHT), rate_func=linear)\n",
        "\n",
        "        self.remove(wire_glows, gate_glows)\n",
        "\n",
        "        # Setup all 16 outputs\n",
        "        machine = Group(circuit, machine_rect, qc_label)\n",
        "        all_qubits = output.replicate(16)\n",
        "        for n, qubits in enumerate(all_qubits):\n",
        "            qubits[0].set_value(n)\n",
        "        all_qubits.arrange(DOWN)\n",
        "        all_qubits.set_height(FRAME_HEIGHT - 1)\n",
        "        all_qubits.move_to(machine, RIGHT)\n",
        "        all_qubits.set_y(0)\n",
        "\n",
        "        all_qubit_rects = VGroup(\n",
        "            SurroundingRectangle(qubits, buff=0.05).set_stroke(YELLOW, 1, 0.5)\n",
        "            for qubits in all_qubits\n",
        "        )\n",
        "        output_rect = SurroundingRectangle(output)\n",
        "\n",
        "        brace = Brace(all_qubit_rects, RIGHT, SMALL_BUFF)\n",
        "        brace_label = brace.get_tex(\"2^4 = 16\")\n",
        "        brace_label.shift(0.2 * RIGHT + 0.05 * UP)\n",
        "\n",
        "        self.play(ShowCreation(output_rect))\n",
        "        self.wait()\n",
        "        self.remove(output, output_rect)\n",
        "        self.play(\n",
        "            machine.animate.to_edge(LEFT),\n",
        "            TransformFromCopy(VGroup(output), all_qubits),\n",
        "            TransformFromCopy(VGroup(output_rect), all_qubit_rects),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show probability distribution\n",
        "        qc_label.generate_target()\n",
        "        qc_label.target.set_y(0).scale(1.5)\n",
        "        comp_to_dist_arrow = Arrow(qc_label.target, all_qubits, buff=1.0, thickness=6)\n",
        "\n",
        "        dists = [\n",
        "            np.random.randint(1, 8, 16).astype(float),\n",
        "            np.random.random(16) + 10 * np.eye(16)[10],\n",
        "            np.random.random(16) + 5,\n",
        "            np.random.randint(1, 8, 16).astype(float),\n",
        "        ]\n",
        "        for dist in dists:\n",
        "            dist /= dist.sum()\n",
        "\n",
        "        all_dist_rects = VGroup(\n",
        "            self.get_dist_bars(dist, all_qubits, width_ratio=6)\n",
        "            for dist in dists\n",
        "        )\n",
        "        dist_rects = all_dist_rects[0]\n",
        "\n",
        "        dist_rect_labels = VGroup(\n",
        "            Integer(100 * prob, unit=R\"\\%\", font_size=24, num_decimal_places=1).next_to(rect, RIGHT, SMALL_BUFF)\n",
        "            for prob, rect in zip(dists[0], dist_rects)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(machine_rect, DOWN),\n",
        "            FadeOut(circuit, DOWN),\n",
        "            MoveToTarget(qc_label)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(comp_to_dist_arrow),\n",
        "            ReplacementTransform(all_qubit_rects, dist_rects, lag_ratio=0.1),\n",
        "            FadeOut(brace, RIGHT),\n",
        "            FadeOut(brace_label, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, dist_rect_labels, shift=0.25 * RIGHT, lag_ratio=0.1, run_time=2))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(dist_rect_labels))\n",
        "        self.wait()\n",
        "        for new_rects in all_dist_rects[1:]:\n",
        "            self.play(Transform(dist_rects, new_rects, run_time=2))\n",
        "            self.wait()\n",
        "\n",
        "        # Show magnifying glass\n",
        "        if False:\n",
        "            # This is just ment for an insertion\n",
        "            dist = VGroup(all_qubits, dist_rects)\n",
        "            dist.shift(0.25 * LEFT)\n",
        "            qc_label.scale(1.5).next_to(comp_to_dist_arrow, LEFT, MED_LARGE_BUFF)\n",
        "            glass = get_magnifying_glass()\n",
        "            glass.next_to(qc_label, UL).to_edge(UP)\n",
        "            glass.save_state()\n",
        "            dist_rects.save_state()\n",
        "\n",
        "            wigglers = Superposition(\n",
        "                VGroup(VGroup(qb, bar) for qb, bar in zip(all_qubits, dist_rects)).copy(),\n",
        "                max_rot_vel=8,\n",
        "                glow_stroke_opacity=0\n",
        "            )\n",
        "\n",
        "            index = 7\n",
        "            new_dist = np.zeros(16)\n",
        "            new_dist[index] = 7\n",
        "            choice_rect = SurroundingRectangle(all_qubits[index])\n",
        "\n",
        "            new_bars = self.get_dist_bars(new_dist, all_qubits, width_ratio=3)\n",
        "            new_bars.set_stroke(width=0)\n",
        "            new_bars[index].set_stroke(WHITE, 1)\n",
        "\n",
        "            self.play(FadeIn(glass))\n",
        "            for _ in range(2):\n",
        "                self.play(\n",
        "                    glass.animate.shift(qc_label.get_center() - glass[0].get_center()).set_anim_args(path_arc=-45 * DEG),\n",
        "                    Transform(dist_rects, new_bars, time_span=(1.25, 1.5)),\n",
        "                    FadeIn(choice_rect, time_span=(1.25, 1.5)),\n",
        "                    run_time=2\n",
        "                )\n",
        "                self.wait()\n",
        "                self.play(\n",
        "                    Restore(glass, path_arc=45 * DEG),\n",
        "                    FadeOut(choice_rect, time_span=(0.25, 0.5)),\n",
        "                    run_time=1.5\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "            # Delicate state\n",
        "            wigglers.set_offset_multiple(0)\n",
        "            self.play(FadeOut(dist), FadeIn(wigglers))\n",
        "            self.play(wigglers.animate.set_offset_multiple(0.05))\n",
        "            self.wait(8)\n",
        "\n",
        "            # For the chroma key\n",
        "            qubits = all_qubits[index].copy()\n",
        "            qubits.set_width(0.7 * qc_label.get_width()).move_to(qc_label)\n",
        "            qubits.set_fill(border_width=3)\n",
        "\n",
        "            self.clear()\n",
        "            self.add(qubits)\n",
        "\n",
        "        # Label it as 4 qubit\n",
        "        title = Text(\"4 qubit quantum computer\")\n",
        "        title.next_to(qc_label, UP, buff=LARGE_BUFF)\n",
        "        title.set_backstroke(BLACK, 3)\n",
        "        underline = Underline(title, buff=-0.05)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(underline, time_span=(1, 2)),\n",
        "            Write(title, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # k qubit case\n",
        "        last_sym = title[\"4\"][0]\n",
        "        last_qubits = all_qubits\n",
        "        last_dist_rects = dist_rects\n",
        "        for k in [5, 6, \"k\"]:\n",
        "            k_sym = Tex(str(k))\n",
        "            k_sym.move_to(last_sym)\n",
        "            k_sym.set_color(YELLOW)\n",
        "\n",
        "            n_bits = k if isinstance(k, int) else 7\n",
        "\n",
        "            multi_bitstrings = VGroup(\n",
        "                BitString(n, length=n_bits)\n",
        "                for n in range(2**n_bits)\n",
        "            )\n",
        "            new_qubits = VGroup(\n",
        "                VGroup(bits, Ket(bits))\n",
        "                for bits in multi_bitstrings\n",
        "            )\n",
        "            new_qubits.arrange(DOWN)\n",
        "            new_qubits.set_height(FRAME_HEIGHT - 1)\n",
        "            new_qubits.move_to(all_qubits)\n",
        "            big_dist_rects = self.get_dist_bars(np.random.random(2**n_bits)**2, new_qubits)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(last_sym, 0.25 * UP),\n",
        "                FadeIn(k_sym, 0.25 * UP),\n",
        "                FadeOut(last_qubits),\n",
        "                FadeOut(last_dist_rects),\n",
        "                FadeIn(new_qubits),\n",
        "                FadeIn(big_dist_rects),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            last_sym = k_sym\n",
        "            last_qubits = new_qubits\n",
        "            last_dist_rects = big_dist_rects\n",
        "\n",
        "        # Count all outputs\n",
        "        brace = Brace(last_dist_rects, RIGHT, SMALL_BUFF)\n",
        "        brace_label = Tex(R\"2^k\", t2c={\"k\": YELLOW})\n",
        "        brace_label.next_to(brace, RIGHT)\n",
        "\n",
        "        bits = BitString(70, length=7)\n",
        "        longer_example = last_qubits[100].copy().set_width(2.0)\n",
        "        longer_example.next_to(brace_label, DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        down_brace = Brace(longer_example[0], DOWN, SMALL_BUFF)\n",
        "        down_brace_label = down_brace.get_tex(\"k\").set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            TransformFromCopy(last_sym, brace_label),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(last_qubits[70], longer_example),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(down_brace),\n",
        "            TransformFromCopy(brace_label[1], down_brace_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight the word qubit\n",
        "        word_rect = SurroundingRectangle(title[\"qubit\"], buff=0.1)\n",
        "        word_rect.set_stroke(YELLOW, 2)\n",
        "        self.play(ReplacementTransform(underline, word_rect))\n",
        "        self.wait()\n",
        "        title[0].set_opacity(0)\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            FadeOut(word_rect),\n",
        "            FadeOut(last_sym),\n",
        "            LaggedStartMap(FadeOut, VGroup(brace, brace_label, longer_example, down_brace, down_brace_label)),\n",
        "            FadeOut(last_qubits),\n",
        "            FadeOut(last_dist_rects),\n",
        "            FadeIn(all_qubits),\n",
        "            FadeIn(dist_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize you see only one\n",
        "        frame = self.frame\n",
        "\n",
        "        dist_rect = SurroundingRectangle(VGroup(comp_to_dist_arrow, all_qubits, dist_rects), buff=0.25)\n",
        "        dist_rect.set_stroke(BLUE, 2)\n",
        "        dist_rect.stretch(1.2, 0)\n",
        "        output.set_width(2)\n",
        "        output.next_to(dist_rect, RIGHT, buff=2.5)\n",
        "        output.align_to(all_qubits, UP)\n",
        "\n",
        "        dist_words = Text(\"Implicit\", font_size=72)\n",
        "        dist_words.next_to(dist_rect, UP)\n",
        "        output_words = Text(\"What you see\", font_size=72)\n",
        "        output_words.next_to(output, UP).match_y(dist_words)\n",
        "\n",
        "        sample_rects = VGroup(\n",
        "            SurroundingRectangle(qb, buff=0.05)\n",
        "            for qb, bar in zip(all_qubits, dist_rects)\n",
        "        )\n",
        "        sample_rects.set_stroke(YELLOW, 1)\n",
        "        sample = 6\n",
        "        output[0].set_value(sample)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            frame.animate.reorient(0, 0, 0, (4.2, 0.7, 0.0), 9.86),\n",
        "            FadeIn(dist_rect),\n",
        "            FadeIn(dist_words, lag_ratio=0.1),\n",
        "            FadeIn(output),\n",
        "            FadeIn(output_words, lag_ratio=0.1),\n",
        "            FadeIn(sample_rects[sample]),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "\n",
        "        # Don't see multiple at once\n",
        "        superposition_pieces = all_qubits.copy()\n",
        "        superposition_pieces.set_width(1.5)\n",
        "        superposition_pieces.space_out_submobjects(0.5)\n",
        "        superposition_pieces.move_to(output, UP)\n",
        "        superposition = Superposition(superposition_pieces)\n",
        "        big_cross = Cross(superposition, stroke_width=[0, 15, 15, 15, 0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(superposition),\n",
        "            FadeOut(output),\n",
        "            ShowCreation(big_cross)\n",
        "        )\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            FadeOut(superposition),\n",
        "            FadeOut(big_cross),\n",
        "        )\n",
        "\n",
        "        # Show some random samples\n",
        "        n_samples = 8\n",
        "        output_choices = output.replicate(16)\n",
        "        for n, choice, sample_rect in zip(it.count(), output_choices, sample_rects):\n",
        "            choice[0].set_value(n)\n",
        "            choice.shift(np.random.uniform(-0.1, 0.1, 3))\n",
        "            choice.set_backstroke(TEAL, 2)\n",
        "            choice.add(sample_rect)\n",
        "\n",
        "        self.remove(output, sample_rects)\n",
        "        selection = VGroup()\n",
        "        for _ in range(n_samples):\n",
        "            self.play(RandomSampling(selection, list(output_choices), weights=dists[-1]))\n",
        "            self.wait()\n",
        "\n",
        "        # Concentrate probability to one value\n",
        "        conc_dist = np.zeros(16)\n",
        "        num = 7\n",
        "        conc_dist[num] = 1\n",
        "        new_rects = self.get_dist_bars(conc_dist, all_qubits, width_ratio=2.0)\n",
        "        self.play(\n",
        "            FadeOut(selection),\n",
        "            Transform(dist_rects, new_rects),\n",
        "            dist_rect.animate.stretch(1.2, 0, about_edge=LEFT),\n",
        "            UpdateFromFunc(dist_words, lambda m: m.match_x(dist_rect)),\n",
        "            output_words.animate.shift(RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(sample_rects[num]))\n",
        "        output[0].set_value(num)\n",
        "        output.match_x(output_words)\n",
        "        self.play(TransformFromCopy(all_qubits[num], output))\n",
        "        self.wait()\n",
        "\n",
        "        # Back to another distribution\n",
        "        point1_index = 2\n",
        "        point5_index = 3\n",
        "        new_dist = np.random.random(16)\n",
        "        new_dist[point1_index] = new_dist[point5_index] = 0\n",
        "        new_dist *= (1.0 - 0.25 - 0.01) / new_dist.sum()\n",
        "        new_dist[point1_index] = 0.01\n",
        "        new_dist[point5_index] = 0.25\n",
        "\n",
        "        self.play(Transform(dist_rects, self.get_dist_bars(new_dist, all_qubits)))\n",
        "        self.remove(output, selection, sample_rects)\n",
        "        VGroup(choice[:-1] for choice in output_choices).match_x(output_words)\n",
        "        self.play(RandomSampling(selection, list(output_choices), weights=new_dist))\n",
        "        self.remove(selection)\n",
        "        self.add(output, sample_rects[num])\n",
        "        self.wait()\n",
        "\n",
        "        # Ask where the distribution comes from\n",
        "        q_marks = Tex(R\"???\", font_size=96)\n",
        "        dist_group = VGroup(all_qubits, dist_rects)\n",
        "        q_marks.next_to(dist_group, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            dist_rect.animate.surround(dist_group),\n",
        "            FadeTransformPieces(dist_words, q_marks),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dist_group.add(dist_rect)\n",
        "\n",
        "        # Introduce the state vector\n",
        "        state = np.array([random.choice([-1, 1]) * np.sqrt(p) for p in new_dist])\n",
        "        state[point5_index] = 0.5\n",
        "        state[point1_index] = -0.1\n",
        "        state_vector = DecimalMatrix(np.zeros((16, 1)), decimal_config=dict(include_sign=True, edge_to_fix=LEFT))\n",
        "        for value, elem in zip(state, state_vector.elements):\n",
        "            elem.set_value(value)\n",
        "        state_vector.match_height(all_qubits)\n",
        "        state_vector.next_to(qc_label, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        vector_title = Text(\"State Vector\", font_size=60)\n",
        "        vector_title.set_color(TEAL)\n",
        "        vector_title.next_to(state_vector, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        comp_to_dist_arrow.target = comp_to_dist_arrow.generate_target()\n",
        "        comp_to_dist_arrow.target.next_to(state_vector, RIGHT)\n",
        "\n",
        "        vect_lines = self.get_connecting_lines(qc_label, state_vector, from_buff=-0.1, to_buff=0.1)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(vect_lines, lag_ratio=0),\n",
        "            FadeInFromPoint(state_vector, qc_label.get_right()),\n",
        "            MoveToTarget(comp_to_dist_arrow),\n",
        "            dist_group.animate.next_to(comp_to_dist_arrow.target, RIGHT),\n",
        "            MaintainPositionRelativeTo(sample_rects[num], dist_group),\n",
        "            MaintainPositionRelativeTo(q_marks, dist_group),\n",
        "            VGroup(output, output_words).animate.shift(0.5 * RIGHT),\n",
        "        ))\n",
        "        self.play(Write(vector_title))\n",
        "        self.wait()\n",
        "\n",
        "        # Label the positions of the vector\n",
        "        pre_indices = VGroup(qb[0] for qb in all_qubits)\n",
        "        indices = pre_indices.copy()\n",
        "        indices.scale(0.75)\n",
        "        indices.set_color(GREY_C)\n",
        "        for bits, entry in zip(indices, state_vector.get_entries()):\n",
        "            bits.next_to(state_vector, LEFT, buff=0.2)\n",
        "            bits.match_y(entry)\n",
        "\n",
        "        self.play(\n",
        "            VGroup(qc_label, vect_lines).animate.shift(0.75 * LEFT),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(pre_bits, bits, path_arc=30 * DEG)\n",
        "                for pre_bits, bits in zip(pre_indices, indices)),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=6\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fundamental rule\n",
        "        ne_sign = Tex(R\"\\ne\", font_size=120)\n",
        "        ne_sign.move_to(comp_to_dist_arrow)\n",
        "        ne_sign.set_color(RED)\n",
        "\n",
        "        rule = Tex(R\"x \\rightarrow |x|^2\", font_size=42)\n",
        "        rule.next_to(comp_to_dist_arrow, UP, buff=SMALL_BUFF)\n",
        "\n",
        "        template_eq = Tex(R\"(+0.50)^2 = 0.25\", font_size=20)\n",
        "        entry_template = template_eq.make_number_changeable(\"+0.50\", include_sign=True)\n",
        "        percent_template = template_eq.make_number_changeable(\"0.25\")\n",
        "\n",
        "        vector_entries = state_vector.get_entries()\n",
        "\n",
        "        bar_values = VGroup()\n",
        "        for bar, entry in zip(dist_rects, vector_entries):\n",
        "            entry_template.set_value(entry.get_value())\n",
        "            percent_template.set_value(entry.get_value()**2)\n",
        "            template_eq.next_to(bar, RIGHT, SMALL_BUFF)\n",
        "            bar_values.add(template_eq.copy())\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(comp_to_dist_arrow),\n",
        "            FadeIn(ne_sign),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(comp_to_dist_arrow),\n",
        "            FadeOut(ne_sign),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(q_marks, rule, path_arc=90 * DEG, run_time=1.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dist_rect.animate.stretch(1.5, 0, about_edge=LEFT).set_anim_args(time_span=(1, 2)),\n",
        "            FadeOut(sample_rects[num]),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(entry, value[1], path_arc=-30 * DEG)\n",
        "                for entry, value in zip(vector_entries, bar_values)),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (FadeIn(value[0])\n",
        "                for value in bar_values),\n",
        "                lag_ratio=0.5,\n",
        "                time_span=(2, 6)\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (FadeIn(value[2:])\n",
        "                for value in bar_values),\n",
        "                lag_ratio=0.5,\n",
        "                time_span=(2, 6)\n",
        "            ),\n",
        "            frame.animate.reorient(0, 0, 0, (2.15, 0.04, 0.0), 7.64),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.remove(vector_title, output_words, output)\n",
        "        self.wait()\n",
        "\n",
        "        # Process the vector\n",
        "        alt_states = [normalize(np.random.uniform(-1, 1, 16)) for x in range(2)]\n",
        "        label_line = Line(UP, DOWN).set_height(1.0).next_to(qc_label.get_right(), LEFT, SMALL_BUFF)\n",
        "        entries = state_vector.get_entries()\n",
        "        comp_lines = VGroup(\n",
        "            Line(\n",
        "                label_line.pfp(alpha),\n",
        "                entry.get_center(),\n",
        "            ).insert_n_curves(20).set_stroke(\n",
        "                color=random_bright_color(hue_range=(0.3, 0.5)),\n",
        "                width=(0, 3, 3, 3, 0),\n",
        "            )\n",
        "            for alpha, entry in zip(np.linspace(0, 1, len(entries)), entries)\n",
        "        )\n",
        "        comp_lines.shuffle()\n",
        "\n",
        "        self.play(FlashAround(rule, time_width=1.5, run_time=2))\n",
        "        self.play(FadeOut(bar_values))\n",
        "        for new_state in [*alt_states, state]:\n",
        "            comp_lines.shuffle()\n",
        "            self.play(\n",
        "                LaggedStartMap(VShowPassingFlash, comp_lines, time_width=2.0, lag_ratio=0.02),\n",
        "                Transform(dist_rects, self.get_dist_bars(new_state**2, all_qubits), time_span=(0.75, 1.75)),\n",
        "                *(\n",
        "                    ChangeDecimalToValue(entry, value, time_span=(0.75, 1.75))\n",
        "                    for entry, value in zip(entries, new_state)\n",
        "                ),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        # Highlight a few examples\n",
        "        highlight_rect = SurroundingRectangle(\n",
        "            VGroup(indices[point5_index], bar_values[point5_index])\n",
        "        )\n",
        "        highlight_rect.set_stroke(YELLOW, 2, 0)\n",
        "        groups = [vector_entries, all_qubits, dist_rects, bar_values]\n",
        "        bar_values.set_opacity(0)\n",
        "\n",
        "        for index in [point5_index, point1_index]:\n",
        "            self.play(\n",
        "                frame.animate.reorient(0, 0, 0, (3.36, 0.87, 0.0), 5.60),\n",
        "                dist_rect.animate.set_stroke(opacity=0),\n",
        "                highlight_rect.animate.set_stroke(opacity=1).match_y(all_qubits[index]),\n",
        "                *(\n",
        "                    group[slc].animate.set_opacity(0.25)\n",
        "                    for group in groups\n",
        "                    for slc in [slice(0, index), slice(index + 1, None)]\n",
        "                ),\n",
        "                *(\n",
        "                    group[index].animate.set_opacity(1)\n",
        "                    for group in groups\n",
        "                ),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.play(\n",
        "                FlashAround(indices[index], buff=SMALL_BUFF, color=RED, time_width=1.5),\n",
        "                WiggleOutThenIn(indices[index]),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(TransformFromCopy(vector_entries[index], bar_values[index][1], run_time=2, path_arc=-45 * DEG))\n",
        "            self.play(FlashAround(bar_values[index][-1], buff=SMALL_BUFF, color=RED, time_width=1.5))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2.13, 1.33, 0.0), 10.48),\n",
        "            FadeOut(highlight_rect, time_span=(0, 1)),\n",
        "            FadeIn(vector_title),\n",
        "            *(\n",
        "                group.animate.set_opacity(1)\n",
        "                for group in groups\n",
        "            ),\n",
        "            FadeOut(bar_values, lag_ratio=0.01),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Concentrate value\n",
        "        if False:  # Only used for an insertion\n",
        "            # Concentrate onto one value\n",
        "            og_state = state\n",
        "            frame.reorient(0, 0, 0, (0.94, 0.34, 0.0), 9.20)\n",
        "            target_state = np.zeros(16)\n",
        "            key = 5\n",
        "            target_state[key] = 1\n",
        "            for alpha in [0.1, 0.1, 0.2, 0.25, 0.25, 0.25, 0.25, 1.0]:\n",
        "                new_state = normalize(interpolate(state, target_state, alpha))\n",
        "\n",
        "                self.play(\n",
        "                    Transform(dist_rects, self.get_dist_bars(new_state**2, all_qubits, width_ratio=4), time_span=(0.5, 1.5)),\n",
        "                    LaggedStartMap(VShowPassingFlash, comp_lines, time_width=2.0, lag_ratio=0.01, run_time=2.0),\n",
        "                    *(\n",
        "                        ChangeDecimalToValue(entry, value, time_span=(0.5, 1.5))\n",
        "                        for entry, value in zip(state_vector.elements, new_state)\n",
        "                    ),\n",
        "                )\n",
        "\n",
        "                state = new_state\n",
        "\n",
        "            # Comment on the value\n",
        "            rect = SurroundingRectangle(all_qubits[key])\n",
        "            self.play(ShowCreation(rect, run_time=2))\n",
        "\n",
        "        # Show the squares of all the values\n",
        "        sum_expr = Tex(\n",
        "            R\"x_{0}^2 + x_{1}^2 + x_{2}^2 + x_{3}^2 + \\cdots + x_{14}^2 + x_{15}^2 = 1\",\n",
        "            font_size=60\n",
        "        )\n",
        "        sum_expr.next_to(vector_title, UP, LARGE_BUFF)\n",
        "        sum_expr.match_x(frame)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (FadeTransform(vector_entries[n].copy(), sum_expr[fR\"x_{{{n}}}^2\"])\n",
        "                for n in [0, 1, 2, 3, 14, 15]),\n",
        "                lag_ratio=0.05,\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeTransformPieces(vector_entries[4:14].copy(), sum_expr[R\"\\cdots\"][0], time_span=(0.5, 2.0)),\n",
        "            Write(sum_expr[\"+\"], time_span=(0.5, 1.5)),\n",
        "            Write(sum_expr[\"= 1\"], time_span=(1, 2)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(sum_expr))\n",
        "\n",
        "        # Flip some signs\n",
        "        top_eq = Tex(R\"(+0.50)^2 = 0.25\", font_size=60)\n",
        "        top_eq.move_to(sum_expr)\n",
        "        top_value = top_eq.make_number_changeable(\"+0.50\", include_sign=True)\n",
        "\n",
        "        entry = vector_entries[point5_index]\n",
        "        entry_rect = SurroundingRectangle(entry, buff=0.1)\n",
        "        entry_rect.set_stroke(YELLOW, 1)\n",
        "        value_rect = SurroundingRectangle(top_value)\n",
        "        value_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        lines = VGroup(\n",
        "            Line(entry_rect.get_corner(UL), value_rect.get_corner(DL)),\n",
        "            Line(entry_rect.get_corner(UR), value_rect.get_corner(DR)),\n",
        "        )\n",
        "        lines.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.play(ShowCreation(entry_rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(entry_rect, value_rect),\n",
        "            TransformFromCopy(entry, top_value),\n",
        "            ShowCreation(lines, lag_ratio=0),\n",
        "            FadeOut(vector_title),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            entry.animate.set_value(-0.5),\n",
        "            top_value.animate.set_value(-0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(top_eq[0]),\n",
        "            Write(top_eq[2:]),\n",
        "            FadeOut(value_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            entry.animate.set_value(0.5),\n",
        "            top_value.animate.set_value(0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Uncreate(lines, lag_ratio=0),\n",
        "            ReplacementTransform(top_value, entry),\n",
        "            FadeOut(top_eq[0]),\n",
        "            FadeOut(top_eq[2:]),\n",
        "            FadeOut(entry_rect),\n",
        "            FadeIn(vector_title),\n",
        "            frame.animate.reorient(0, 0, 0, (0.45, 0.46, 0.0), 8.70),\n",
        "        )\n",
        "\n",
        "        # Flip some more signs\n",
        "        signs = VGroup(entry[0] for entry in vector_entries)\n",
        "        vector_entries.save_state()\n",
        "        sign_choice = VGroup(Tex(\"+\").set_color(BLUE), Tex(\"-\").set_color(RED))\n",
        "        sign_choice.set_width(1.2 * signs[0].get_width())\n",
        "        sign_choices = VGroup(\n",
        "            sign_choice.copy().move_to(sign, RIGHT)\n",
        "            for sign in signs\n",
        "        )\n",
        "\n",
        "        for n in range(3):\n",
        "            self.play(LaggedStart(*(\n",
        "                Transform(sign, random.choice(choice), path_arc=PI)\n",
        "                for sign, choice in zip(signs, sign_choices)),\n",
        "                lag_ratio=0.15,\n",
        "                run_time=2\n",
        "            ))\n",
        "        self.play(\n",
        "            Restore(vector_entries),\n",
        "        )\n",
        "\n",
        "        # Go down to two dimensions\n",
        "        small_state = normalize([1, 2])\n",
        "        small_state_vector = DecimalMatrix(small_state.reshape([2, 1]), v_buff=1.0)\n",
        "        small_state_vector.set_height(2.0)\n",
        "        small_state_vector.move_to(state_vector, RIGHT)\n",
        "\n",
        "        bits = VGroup(Integer(0), Integer(0))\n",
        "        bits.arrange(DOWN, MED_LARGE_BUFF)\n",
        "        qubits = VGroup(\n",
        "            VGroup(bit, Ket(bit))\n",
        "            for bit in bits\n",
        "        )\n",
        "        qubits.scale(1.5)\n",
        "        qubits.arrange_to_fit_height(small_state_vector.get_entries().get_height())\n",
        "        qubits.next_to(comp_to_dist_arrow, RIGHT, MED_LARGE_BUFF)\n",
        "        qubits.reverse_submobjects()\n",
        "        qubits[1][0].set_value(1)\n",
        "\n",
        "        small_dist_bars = self.get_dist_bars(small_state**2, qubits, width_ratio=2)\n",
        "\n",
        "        small_vect_lines = self.get_connecting_lines(qc_label, small_state_vector, from_buff=-0.1, to_buff=0.1)\n",
        "\n",
        "        self.remove(state_vector, all_qubits, dist_rects, vect_lines)\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(indices, scale=0.25),\n",
        "            TransformFromCopy(vect_lines, small_vect_lines),\n",
        "            TransformFromCopy(state_vector.get_brackets(), small_state_vector.get_brackets()),\n",
        "            TransformFromCopy(state_vector.get_entries(), small_state_vector.get_entries()),\n",
        "            vector_title.animate.next_to(small_state_vector, UP, MED_LARGE_BUFF),\n",
        "            FadeTransformPieces(all_qubits.copy(), qubits),\n",
        "            TransformFromCopy(dist_rects, small_dist_bars),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.add(small_state_vector)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(VGroup(small_vect_lines, small_state_vector, qubits, small_dist_bars)),\n",
        "            FadeIn(VGroup(vect_lines, indices, state_vector, all_qubits, dist_rects)),\n",
        "            vector_title.animate.next_to(state_vector, UP, MED_LARGE_BUFF),\n",
        "        )\n",
        "\n",
        "        # Apply Grover's\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (2, 0.45, 0.0), 9),\n",
        "            qc_label[1].animate.set_color(BLUE),\n",
        "        )\n",
        "        key = 12\n",
        "        state0 = np.sqrt(1.0 / 16) * np.ones(16)\n",
        "        new_states = [state0]\n",
        "        for n in range(3):\n",
        "            state = new_states[-1].copy()\n",
        "            state[key] *= -1\n",
        "            new_states.append(state)\n",
        "            new_states.append(2 * np.dot(state0, state) * state0 - state)\n",
        "\n",
        "        key_icon = get_key_icon()\n",
        "        key_entry_rect = SurroundingRectangle(VGroup(indices[key], vector_entries[key]))\n",
        "        key_entry_rect.stretch(1.25, 0, about_edge=RIGHT)\n",
        "        key_entry_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        for n, state in enumerate(new_states):\n",
        "            anims = [Transform(\n",
        "                dist_rects, self.get_dist_bars(state**2, all_qubits, width_ratio=4.0),\n",
        "                time_span=(1, 2)\n",
        "            )]\n",
        "            if n == 1:\n",
        "                # Highlight the outcomes\n",
        "                entry_rects = VGroup(SurroundingRectangle(e, buff=0.05) for e in vector_entries)\n",
        "                qubit_rects = VGroup(\n",
        "                    SurroundingRectangle(VGroup(*pair), buff=0.05)\n",
        "                    for pair in zip(all_qubits, dist_rects)\n",
        "                )\n",
        "                VGroup(entry_rects, qubit_rects).set_stroke(YELLOW, 2)\n",
        "                self.play(\n",
        "                    LaggedStartMap(VFadeInThenOut, entry_rects, lag_ratio=0.1),\n",
        "                    LaggedStartMap(VFadeInThenOut, qubit_rects, lag_ratio=0.1),\n",
        "                    run_time=6\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "                # Show the key\n",
        "                bits = indices[key]\n",
        "                bits.save_state()\n",
        "                self.play(bits.animate.scale(2).set_color(WHITE).move_to(8 * RIGHT))\n",
        "\n",
        "                key_icon.set_height(1.5 * bits.get_height())\n",
        "                key_icon.next_to(bits, LEFT, SMALL_BUFF)\n",
        "                self.play(Write(key_icon))\n",
        "                self.wait()\n",
        "\n",
        "                self.play(\n",
        "                    Restore(bits),\n",
        "                    key_icon.animate.scale(0.5).next_to(bits.saved_state, LEFT, buff=SMALL_BUFF),\n",
        "                )\n",
        "\n",
        "            if n % 2 == 1:\n",
        "                neg1 = Tex(R\"\\times -1\")\n",
        "                neg1.next_to(key_entry_rect, RIGHT)\n",
        "                neg1.set_color(YELLOW)\n",
        "                anims.append(VFadeInThenOut(neg1, run_time=2))\n",
        "                anims.append(VFadeInThenOut(key_entry_rect, run_time=2))\n",
        "                anims.append(ChangeDecimalToValue(vector_entries[key], state[key], time_span=(0.5, 1.5)))\n",
        "            else:\n",
        "                anims.append(\n",
        "                    LaggedStartMap(VShowPassingFlash, comp_lines, time_width=2.0, lag_ratio=0.005, run_time=2)\n",
        "                )\n",
        "                anims.extend([\n",
        "                    ChangeDecimalToValue(entry, value, time_span=(1, 2))\n",
        "                    for entry, value in zip(vector_entries, state)\n",
        "                ])\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "\n",
        "        # Read out from memory\n",
        "        glass = get_magnifying_glass()\n",
        "        glass.next_to(qc_label, UP, MED_LARGE_BUFF)\n",
        "        glass.scale(0.75)\n",
        "        glass.to_edge(LEFT, buff=0).shift(frame.get_x() * RIGHT)\n",
        "\n",
        "        self.play(FadeIn(glass))\n",
        "        self.play(\n",
        "            glass.animate.shift(qc_label.get_center() - glass[0].get_center()).set_anim_args(path_arc=-45 * DEG),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        qubits = all_qubits[key].copy()\n",
        "        qubits.move_to(qc_label)\n",
        "        qubits.scale(1.25)\n",
        "        black_rect = FullScreenRectangle().set_fill(BLACK, 1)\n",
        "        black_rect.fix_in_frame()\n",
        "        self.add(black_rect, qubits)\n",
        "        self.wait()\n",
        "\n",
        "    def get_labeled_box(self, wire, alpha, label=\"H\", size=0.5):\n",
        "        box = Square(size)\n",
        "        box.set_stroke(WHITE, 1)\n",
        "        box.set_fill(BLACK, 1)\n",
        "        box.move_to(wire.pfp(alpha))\n",
        "\n",
        "        vect = rotate_vector(UP, PI / 8)\n",
        "        arrow = VGroup(\n",
        "            Vector(size * vect, thickness=1).center(),\n",
        "            Vector(-size * vect, thickness=1).center(),\n",
        "        )\n",
        "        arrow.move_to(box)\n",
        "\n",
        "        label = Tex(label)\n",
        "        label.set_height(0.5 * size)\n",
        "        label.move_to(box)\n",
        "\n",
        "        return VGroup(box, label)\n",
        "\n",
        "    def get_cnot(self, wire1, wire2, alpha):\n",
        "        oplus = Tex(R\"\\oplus\")\n",
        "        dot = Dot()\n",
        "        oplus.move_to(wire1.pfp(alpha))\n",
        "        dot.move_to(wire2.pfp(alpha))\n",
        "        connector = Line(dot, oplus, buff=0)\n",
        "        connector.set_stroke(WHITE, 1)\n",
        "        return VGroup(oplus, connector, dot)\n",
        "\n",
        "    def get_measurement(self, wire, alpha, size=0.5):\n",
        "        box = Square(size)\n",
        "        box.set_stroke(WHITE, 1)\n",
        "        box.set_fill(BLACK, 1)\n",
        "        box.move_to(wire.pfp(alpha))\n",
        "        arc = Arc(PI / 4, PI / 2)\n",
        "        arc.set_width(0.7 * box.get_width())\n",
        "        arc.move_to(box)\n",
        "        arc.set_stroke(WHITE, 1)\n",
        "        lines = VGroup(Line(ORIGIN, 0.2 * vect) for vect in [UL, UR])\n",
        "        lines.move_to(box)\n",
        "        lines.set_stroke(WHITE, 1)\n",
        "        lines[1].set_stroke(opacity=0)\n",
        "        return VGroup(box, arc, lines)\n",
        "\n",
        "    def get_random_qubits(self):\n",
        "        bits = BitString(random.randint(0, 15))\n",
        "        ket = Ket(bits)\n",
        "        return VGroup(bits, ket)\n",
        "\n",
        "    def get_connecting_lines(self, from_mob, to_mob, from_buff=0, to_buff=0, stroke_color=TEAL_A, stroke_width=2):\n",
        "        l_ur = from_mob.get_corner(UR) + from_buff * UR\n",
        "        l_dr = from_mob.get_corner(DR) + from_buff * DR\n",
        "        v_ul = to_mob.get_corner(UL) + to_buff * UL\n",
        "        v_dl = to_mob.get_corner(DL) + to_buff * DL\n",
        "\n",
        "        lines = VGroup(\n",
        "            CubicBezier(l_ur, l_ur + RIGHT, v_ul + LEFT, v_ul),\n",
        "            CubicBezier(l_dr, l_dr + RIGHT, v_dl + LEFT, v_dl),\n",
        "        )\n",
        "        lines.set_stroke(TEAL_A, 2)\n",
        "        return lines\n",
        "\n",
        "    def get_dist_bars(\n",
        "        self,\n",
        "        dist,\n",
        "        objs,\n",
        "        height_ratio=0.8,\n",
        "        width_ratio=8,\n",
        "        fill_colors=(BLUE_D, GREEN),\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=1,\n",
        "    ):\n",
        "        normalized_dist = np.array(dist) / sum(dist)\n",
        "        height = objs[0].get_height() * height_ratio\n",
        "        rects = VGroup(\n",
        "            Rectangle(width_ratio * p, height).next_to(obj)\n",
        "            for p, obj in zip(normalized_dist, objs)\n",
        "        )\n",
        "        rects.set_fill(opacity=1)\n",
        "        rects.set_submobject_colors_by_gradient(*fill_colors)\n",
        "        rects.set_stroke(stroke_color, stroke_width)\n",
        "        return rects\n",
        "\n",
        "\n",
        "class Qubit(DisectAQuantumComputer):\n",
        "    def construct(self):\n",
        "        # Set up plane\n",
        "        frame = self.frame\n",
        "        plane = self.get_plane()\n",
        "        zero_label, one_label = qubit_labels = self.get_qubit_labels(plane)\n",
        "\n",
        "        frame.move_to(plane)\n",
        "        self.add(plane)\n",
        "        self.add(qubit_labels)\n",
        "\n",
        "        # Add vector\n",
        "        vector = self.get_vector(plane)\n",
        "        vector_label = DecimalMatrix([[1.0], [0.0]], bracket_h_buff=0.1, decimal_config=dict(include_sign=True))\n",
        "        vector_label.add_background_rectangle()\n",
        "        vector_label.scale(0.5)\n",
        "        vector_label.set_backstroke(BLACK, 5)\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        vector.add_updater(lambda m: m.set_angle(theta_tracker.get_value()))\n",
        "        vector.add_updater(lambda m: m.shift(plane.c2p(0, 0) - m.get_start()))\n",
        "\n",
        "        def get_state():\n",
        "            theta = theta_tracker.get_value()\n",
        "            return np.array([math.cos(theta), math.sin(theta)])\n",
        "\n",
        "        def position_label(vector_label):\n",
        "            x, y = get_state()\n",
        "            buff = SMALL_BUFF + 0.5 * interpolate(vector_label.get_width(), vector_label.get_height(), x**2)\n",
        "\n",
        "            vect = normalize(vector.get_vector())\n",
        "            vector_label.move_to(vector.get_end() + buff * vect)\n",
        "\n",
        "        def update_coordinates(vector_label):\n",
        "            for element, value in zip(vector_label.elements, get_state()):\n",
        "                element.set_value(value)\n",
        "\n",
        "        vector_label.add_updater(position_label)\n",
        "        vector_label.add_updater(update_coordinates)\n",
        "\n",
        "        self.add(vector, vector_label)\n",
        "        self.play(theta_tracker.animate.set_value(240 * DEG), run_time=5)\n",
        "        self.play(theta_tracker.animate.set_value(120 * DEG), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "        # Add rule\n",
        "        var_vect = TexMatrix([[\"x\"], [\"y\"]], bracket_h_buff=0.1)\n",
        "        var_vect.next_to(plane, RIGHT, buff=1.0)\n",
        "        var_vect.to_edge(UP)\n",
        "        var_vect.add_background_rectangle()\n",
        "\n",
        "        coord_vect = DecimalMatrix([[0], [1]], v_buff=0.5, bracket_h_buff=0.1, decimal_config=dict(include_sign=True))\n",
        "        coord_vect.scale(0.75)\n",
        "        coord_vect.next_to(var_vect, DOWN, buff=2.25, aligned_edge=RIGHT)\n",
        "        coord_vect.clear_updaters()\n",
        "        coord_vect.add_background_rectangle()\n",
        "        coord_vect.add_updater(update_coordinates)\n",
        "\n",
        "        prob_rule = VGroup(\n",
        "            Tex(R\"P(0) = x^2\"),\n",
        "            Tex(R\"P(1) = y^2\"),\n",
        "        )\n",
        "        prob_rule.arrange(DOWN)\n",
        "        prob_rule.next_to(var_vect, RIGHT, buff=1.5)\n",
        "        var_arrow = Arrow(var_vect, prob_rule, buff=0.25)\n",
        "\n",
        "        qubits = qubit_labels.copy()\n",
        "        qubits.scale(2)\n",
        "        qubits.arrange(DOWN)\n",
        "        qubits.match_y(coord_vect)\n",
        "        qubits.align_to(prob_rule, LEFT)\n",
        "        dist_bars = always_redraw(lambda: self.get_dist_bars(get_state()**2, qubits, width_ratio=1.5))\n",
        "        dist_bars.suspend_updating()\n",
        "\n",
        "        dist_arrow = Arrow(coord_vect, qubits, buff=0.25)\n",
        "        dist_arrow_label = Tex(R\"c \\rightarrow c^2\", font_size=24)\n",
        "        dist_arrow_label.next_to(dist_arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        bar_labels = VGroup(\n",
        "            Integer(25, unit=R\"\\%\", font_size=24),\n",
        "            Integer(75, unit=R\"\\%\", font_size=24),\n",
        "        )\n",
        "\n",
        "        def update_bar_labels(bar_labels):\n",
        "            for label, bar, value in zip(bar_labels, dist_bars, get_state()):\n",
        "                label.set_value(np.round(100 * value**2, 0))\n",
        "                label.next_to(bar, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        bar_labels.add_updater(update_bar_labels)\n",
        "\n",
        "        top_rule_rect = SurroundingRectangle(prob_rule[0])\n",
        "        bar_rect = SurroundingRectangle(VGroup(qubits[0], bar_labels[0]))\n",
        "        bar_rect.get_width()\n",
        "        bar_rect.set_width(3, stretch=True, about_edge=LEFT)\n",
        "        VGroup(top_rule_rect, bar_rect).set_stroke(YELLOW, 1.5)\n",
        "\n",
        "        dist_group = VGroup(coord_vect, dist_arrow, dist_arrow_label, qubits, dist_bars, bar_labels)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(vector_label.copy().clear_updaters(), var_vect),\n",
        "            frame.animate.center(),\n",
        "            GrowArrow(var_arrow),\n",
        "            FadeIn(prob_rule),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.play(ShowCreation(top_rule_rect))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            Transform(var_vect.copy(), coord_vect.copy().clear_updaters(), remover=True),\n",
        "            TransformFromCopy(var_arrow, dist_arrow),\n",
        "            FadeIn(dist_arrow_label, DOWN),\n",
        "            TransformFromCopy(VGroup(pr[1:4] for pr in prob_rule).copy(), qubits),\n",
        "            FadeTransformPieces(VGroup(pr[5:] for pr in prob_rule).copy(), dist_bars),\n",
        "            TransformFromCopy(top_rule_rect, bar_rect),\n",
        "            lag_ratio=1e-2\n",
        "        ))\n",
        "        self.add(coord_vect)\n",
        "        self.play(FadeIn(bar_labels))\n",
        "        self.wait()\n",
        "        dist_bars.resume_updating()\n",
        "        self.play(theta_tracker.animate.set_value(10 * DEG), run_time=8)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            top_rule_rect.animate.match_y(prob_rule[1]),\n",
        "            bar_rect.animate.match_y(qubits[1]),\n",
        "        )\n",
        "        self.play(theta_tracker.animate.set_value(90 * DEG), run_time=8)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(top_rule_rect), FadeOut(bar_rect))\n",
        "        self.wait()\n",
        "        self.play(theta_tracker.animate.set_value(60 * DEG), run_time=2)\n",
        "\n",
        "        # Note x^2 + y^2\n",
        "        var_group = VGroup(var_vect, var_arrow, prob_rule)\n",
        "        pythag = Tex(R\"x^2 + y^2 = 1\")\n",
        "        pythag.match_x(var_group)\n",
        "        pythag.to_edge(UP)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            var_group.animate.shift(1.5 * DOWN),\n",
        "            TransformFromCopy(prob_rule[0][\"x^2\"][0], pythag[\"x^2\"][0]),\n",
        "            Write(pythag[\"+\"][0]),\n",
        "            TransformFromCopy(prob_rule[1][\"y^2\"][0], pythag[\"y^2\"][0]),\n",
        "        ))\n",
        "        self.play(Write(pythag[\"= 1\"][0]), run_time=1)\n",
        "        self.add(pythag)\n",
        "        self.wait()\n",
        "\n",
        "        # Show vector length\n",
        "        brace = LineBrace(vector, DOWN, buff=0)\n",
        "        brace_label = brace.get_tex(R\"\\sqrt{x^2 + y^2} = 1\", font_size=36)\n",
        "        brace_label.shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        circle = Circle(radius=vector.get_length())\n",
        "        circle.move_to(plane)\n",
        "        circle.set_stroke(YELLOW, 2)\n",
        "        circle.rotate(vector.get_angle(), about_point=plane.get_center())\n",
        "\n",
        "        vector_ghost = vector.copy()\n",
        "        vector_ghost.clear_updaters()\n",
        "        vector_ghost.set_opacity(0.25)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            TransformMatchingTex(pythag.copy(), brace_label, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(vector_ghost)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            theta_tracker.animate.set_value(theta_tracker.get_value() + TAU),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.remove(vector_ghost)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            FadeOut(brace_label),\n",
        "            circle.animate.set_stroke(width=1, opacity=0.5)\n",
        "        )\n",
        "\n",
        "        # Name this as a qubit\n",
        "        title = Text(\"Qubit\", font_size=90)\n",
        "        title.next_to(plane.get_corner(UL), DR, MED_SMALL_BUFF)\n",
        "        title.set_backstroke(BLACK, 4)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "        # Illustrate collpase\n",
        "        if False:\n",
        "            # Just for an insertion\n",
        "            small_plane = self.small_plane(plane)\n",
        "            small_plane.set_z_index(-1)\n",
        "            self.remove(plane, vector_label, pythag)\n",
        "            self.add(small_plane)\n",
        "            self.remove(title)\n",
        "            theta_tracker.set_value(45 * DEG)\n",
        "\n",
        "            self.wait()\n",
        "            self.play(theta_tracker.animate.set_value(90 * DEG), run_time=0.15)\n",
        "            self.wait()\n",
        "            self.play(theta_tracker.animate.set_value(45 * DEG))\n",
        "            self.wait()\n",
        "            self.play(theta_tracker.animate.set_value(0), run_time=0.15)\n",
        "            self.wait()\n",
        "\n",
        "            # Put in the qubits\n",
        "            one = one_label.copy()\n",
        "            zero = zero_label.copy()\n",
        "            for mob in [zero, one]:\n",
        "                mob.set_height(1)\n",
        "                mob.set_fill(WHITE, 1, border_width=3)\n",
        "                mob.move_to(plane)\n",
        "\n",
        "            self.clear()\n",
        "            self.add(zero)\n",
        "\n",
        "        # Ambient change\n",
        "        theta_tracker.set_value(60 * DEG)\n",
        "        for value in [180 * DEG, 90 * DEG, 0, 120 * DEG]:\n",
        "            self.play(theta_tracker.animate.set_value(value), run_time=6)\n",
        "\n",
        "        # Show kets\n",
        "        self.play(FadeOut(vector_label))\n",
        "        self.play(theta_tracker.animate.set_value(0), run_time=2)\n",
        "\n",
        "        zero_vect = vector.copy().clear_updaters().set_fill(BLUE, 0.5)\n",
        "        self.play(zero_label.animate.scale(2).next_to(zero_vect, DOWN, buff=0))\n",
        "        self.play(\n",
        "            FlashAround(zero_label, run_time=2, time_width=1.5, color=BLUE),\n",
        "            FadeIn(zero_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(theta_tracker.animate.set_value(90 * DEG), run_time=2)\n",
        "\n",
        "        one_vect = vector.copy().clear_updaters().set_fill(GREEN, 0.5)\n",
        "        self.play(\n",
        "            one_label.animate.scale(2).next_to(one_vect, LEFT, buff=0)\n",
        "        )\n",
        "        self.play(\n",
        "            FlashAround(one_label, run_time=2, time_width=1.5, color=GREEN),\n",
        "            FadeIn(one_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # General unit vector\n",
        "        var_vect_copy = var_vect.copy()\n",
        "        self.play(theta_tracker.animate.set_value(55 * DEG), run_time=2)\n",
        "        self.play(var_vect_copy.animate.scale(0.75).next_to(vector.get_end(), UR, buff=0))\n",
        "\n",
        "        weighted_sum = Tex(R\"x|0\\rangle + y|1\\rangle\")\n",
        "        weighted_sum.next_to(vector.get_end(), RIGHT)\n",
        "        weighted_sum.shift(SMALL_BUFF * UL)\n",
        "        weighted_sum.set_backstroke(BLACK, 5)\n",
        "        red_cross = Cross(var_vect_copy)\n",
        "        red_cross.scale(1.5)\n",
        "\n",
        "        self.play(ShowCreation(red_cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(red_cross),\n",
        "            FadeTransform(var_vect_copy.get_entries()[0].copy(), weighted_sum[\"x\"]),\n",
        "            FadeTransform(var_vect_copy.get_entries()[1].copy(), weighted_sum[\"y\"]),\n",
        "            FadeOut(var_vect_copy),\n",
        "            FadeTransform(zero_label.copy(), weighted_sum[R\"|0\\rangle\"]),\n",
        "            FadeTransform(one_label.copy(), weighted_sum[R\"|1\\rangle\"]),\n",
        "            FadeIn(weighted_sum[\"+\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Prepare to show a gate\n",
        "        faders = VGroup(\n",
        "            pythag, var_group, dist_group\n",
        "        )\n",
        "        faders.clear_updaters()\n",
        "\n",
        "        plane2 = plane.copy()\n",
        "        plane2.next_to(plane, RIGHT, buff=5)\n",
        "        planes = VGroup(plane, plane2)\n",
        "\n",
        "        arrow = Arrow(plane, plane2, thickness=8)\n",
        "        arrow_label = Text(\"Hadamard gate\", font_size=60)\n",
        "        arrow_label.next_to(arrow, UP, SMALL_BUFF)\n",
        "        matrix_tex = Tex(R\"\\frac{1}{\\sqrt{2}} \\left[\\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array}\\right]\", font_size=24)\n",
        "        matrix_tex.set_fill(GREY_B)\n",
        "        matrix_tex.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_width(planes.get_width() + LARGE_BUFF).move_to(planes),\n",
        "            LaggedStartMap(FadeOut, faders, shift=0.5 * DOWN, lag_ratio=0.25),\n",
        "            zero_vect.animate.set_fill(opacity=1),\n",
        "            one_vect.animate.set_fill(opacity=1),\n",
        "            FadeIn(plane2, shift=RIGHT),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(arrow_label, lag_ratio=0.1),\n",
        "            FadeIn(matrix_tex),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Hadamard gate\n",
        "        vector.clear_updaters()\n",
        "        movers = VGroup(circle, zero_vect, one_vect, vector)\n",
        "        movers_image = movers.copy()\n",
        "        movers_image.flip(axis=rotate_vector(RIGHT, PI / 8), about_point=plane.get_center())\n",
        "        movers_image.move_to(plane2)\n",
        "\n",
        "        labels = VGroup(zero_label, one_label, weighted_sum)\n",
        "        labels.set_backstroke(BLACK, 3)\n",
        "        labels_image = VGroup(\n",
        "            Tex(R\"\\text{H}|0\\rangle\").scale(0.75).rotate(45 * DEG).next_to(movers_image[1].get_center(), UL, buff=-0.05),\n",
        "            Tex(R\"\\text{H}|1\\rangle\").scale(0.75).rotate(-45 * DEG).next_to(movers_image[2].get_center(), DL, buff=-0.05),\n",
        "            Tex(R\"\\text{H}\\big(x|0\\rangle + y|1\\rangle\\big)\").scale(0.75).next_to(movers_image[3].get_end(), RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        labels_image.set_backstroke(BLACK, 7)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(movers, movers_image, path_arc=-30 * DEG),\n",
        "            TransformFromCopy(labels, labels_image, path_arc=-30 * DEG),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go through each part\n",
        "        faders = VGroup(movers[1:], movers_image[1:], labels, labels_image)\n",
        "        for index in range(2):\n",
        "            faders.generate_target()\n",
        "            for mob in faders.target:\n",
        "                for j, part in enumerate(mob):\n",
        "                    if j == index:\n",
        "                        part.set_opacity(1)\n",
        "                    else:\n",
        "                        part.set_opacity(0.25)\n",
        "\n",
        "            rect = SurroundingRectangle(labels[index])\n",
        "            rect.set_stroke(YELLOW, 2)\n",
        "            self.play(\n",
        "                MoveToTarget(faders),\n",
        "                ShowCreation(rect),\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(movers[index + 1], movers_image[index + 1], path_arc=-30 * DEG),\n",
        "                TransformFromCopy(labels[index], labels_image[index], path_arc=-30 * DEG),\n",
        "                rect.animate.surround(labels_image[index]).set_anim_args(path_arc=-30 * DEG),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.play(FadeOut(rect))\n",
        "            self.wait()\n",
        "        self.play(faders.animate.set_fill(opacity=1))\n",
        "\n",
        "    def get_plane(self):\n",
        "        plane = NumberPlane((-2, 2), (-2, 2), faded_line_ratio=5)\n",
        "        plane.set_height(7.5)\n",
        "        plane.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        return plane\n",
        "\n",
        "    def get_small_plane(self, plane):\n",
        "        x_range = (-1, 1 - 1e-5)\n",
        "        small_plane = NumberPlane(x_range, x_range, faded_line_ratio=5)\n",
        "        small_plane.set_height(0.5 * plane.get_height())\n",
        "        small_plane.move_to(plane)\n",
        "        return small_plane\n",
        "\n",
        "    def get_qubit_labels(self, plane):\n",
        "        zero, one = bits = VGroup(Integer(0), Integer(1))\n",
        "        zero_label, one_label = qubit_labels = VGroup(\n",
        "            VGroup(Ket(bit), bit)\n",
        "            for bit in bits\n",
        "        )\n",
        "        qubit_labels.scale(0.5)\n",
        "        zero_label.next_to(plane.c2p(1, 0), DR, SMALL_BUFF)\n",
        "        one_label.next_to(plane.c2p(0, 1), DR, SMALL_BUFF)\n",
        "        return qubit_labels\n",
        "\n",
        "    def get_vector(self, plane, x=1, y=0, fill_color=TEAL, thickness=6):\n",
        "        return Arrow(\n",
        "            plane.c2p(0, 0),\n",
        "            plane.c2p(x, y),\n",
        "            buff=0,\n",
        "            thickness=thickness,\n",
        "            fill_color=fill_color\n",
        "        )\n",
        "\n",
        "    def thumbnail_insert(self):\n",
        "        # To be put above the \"note x^2 + y^2\" above\n",
        "        self.remove(vector_label)\n",
        "        self.remove(plane)\n",
        "        small_plane = self.get_small_plane(plane)\n",
        "        small_plane.set_z_index(-1)\n",
        "        small_plane.axes.set_stroke(WHITE, 4)\n",
        "        small_plane.background_lines.set_stroke(BLUE, 3)\n",
        "        small_plane.faded_lines.set_stroke(BLUE, 2, 0.8)\n",
        "        qubit_labels.set_fill(border_width=2)\n",
        "        vector.set_color(YELLOW)\n",
        "        theta_tracker.set_value(45 * DEG)\n",
        "        self.add(small_plane)\n",
        "\n",
        "        # Add glass\n",
        "        glass = get_magnifying_glass()\n",
        "        glass.set_height(5)\n",
        "        glass[0].set_fill(BLACK)\n",
        "        glass.shift(vector.get_center() - glass[0].get_center())\n",
        "        one = KetGroup(Integer(1))\n",
        "        one.set_height(1.5)\n",
        "        one.move_to(glass[0])\n",
        "        self.add(glass, one)\n",
        "\n",
        "    def z_filp_insert(self):\n",
        "        # For the clarification supplement\n",
        "        angle = theta_tracker.get_value()\n",
        "        self.play(theta_tracker.animate.set_value(angle + TAU), run_time=5)\n",
        "        theta_tracker.set_value(angle)\n",
        "\n",
        "        # Flips\n",
        "        flipper = VGroup(vector, circle, zero_vect, one_vect)\n",
        "        flipper.clear_updaters()\n",
        "        self.play(\n",
        "            Rotate(flipper, PI, axis=RIGHT, about_point=plane.c2p(0, 0), run_time=6, rate_func=there_and_back_with_pause)\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowAFewFlips(Qubit):\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        title = Text(\"Quantum Gates\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        plane = self.get_plane()\n",
        "        plane.center()\n",
        "        small_plane = self.get_small_plane(plane)\n",
        "        qubit_labels = self.get_qubit_labels(plane)\n",
        "        vector = self.get_vector(plane)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(small_plane, qubit_labels, vector)\n",
        "\n",
        "        # Show H, Z and X gates\n",
        "        lines = DashedLine(2 * LEFT, 2 * RIGHT).replicate(3)\n",
        "        for line, angle in zip(lines, [0, PI / 8, PI / 4]):\n",
        "            line.rotate(angle)\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "\n",
        "        gate_labels = VGroup(Text(c) for c in \"ZHX\")\n",
        "        gate_labels.next_to(plane.c2p(1, 1), DR)\n",
        "\n",
        "        for i in [1, 0, 2, 1, 2, 1, 0, 1]:\n",
        "            self.play(LaggedStart(\n",
        "                AnimationGroup(\n",
        "                    FadeIn(lines[i]),\n",
        "                    FadeIn(gate_labels[i])\n",
        "                ),\n",
        "                Rotate(vector, PI, axis=lines[i].get_vector(), about_point=ORIGIN),\n",
        "                lag_ratio=0.5\n",
        "            ))\n",
        "            self.play(\n",
        "                FadeOut(lines[i]),\n",
        "                FadeOut(gate_labels[i]),\n",
        "            )\n",
        "\n",
        "\n",
        "class ExponentiallyGrowingState(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Initialize vector\n",
        "        label = TexText(R\"State of a\\\\ 1 qubit computer\")\n",
        "        n_label = label.make_number_changeable(\"1\", edge_to_fix=RIGHT)\n",
        "        n_label.set_color(YELLOW)\n",
        "        label.move_to(3.5 * LEFT)\n",
        "        vect = self.get_state_vector(1)\n",
        "        vect.move_to(1.5 * RIGHT)\n",
        "\n",
        "        brace = self.get_brace_group(vect, 1)\n",
        "        brace.set_opacity(0)\n",
        "\n",
        "        self.add(label)\n",
        "        self.add(vect)\n",
        "\n",
        "        # Grow the vector\n",
        "        for n in range(2, 9):\n",
        "            new_vect = self.get_state_vector(n)\n",
        "            new_vect.move_to(vect)\n",
        "            new_brace = self.get_brace_group(new_vect, n)\n",
        "\n",
        "            n_label.set_value(n)\n",
        "            self.play(\n",
        "                ReplacementTransform(vect[0], new_vect[0]),\n",
        "                FadeTransform(vect[1], new_vect[1]),\n",
        "                FadeTransformPieces(vect[2], new_vect[2]),\n",
        "                FadeTransform(brace[0], new_brace[0]),\n",
        "                FadeTransform(brace[1], new_brace[1]),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            vect = new_vect\n",
        "            brace = new_brace\n",
        "\n",
        "        # Change to 100\n",
        "        frame = self.frame\n",
        "\n",
        "        new_brace_label = Tex(R\"2^{100}\")\n",
        "        new_brace_label.set_color(YELLOW)\n",
        "        new_brace_label.next_to(brace[0], RIGHT).shift(SMALL_BUFF * UR)\n",
        "\n",
        "        top_eq = Tex(R\"2^{100} = \" + \"{:,}\".format(2**100))\n",
        "        top_eq.next_to(vect, UP, MED_LARGE_BUFF).set_x(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(brace[1], new_brace_label),\n",
        "            ChangeDecimalToValue(n_label, 100),\n",
        "            frame.animate.set_height(9, about_edge=DOWN),\n",
        "            FadeIn(top_eq),\n",
        "            FadeTransform(vect, self.get_state_vector(n + 2).move_to(vect, RIGHT)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_state_vector(self, n):\n",
        "        # Actualy function\n",
        "        values = normalize(np.random.uniform(-1, 1, 2**n))\n",
        "        array = DecimalMatrix(\n",
        "            values.reshape((2**n, 1)),\n",
        "            decimal_config=dict(include_sign=True)\n",
        "        )\n",
        "        array.set_max_height(7)\n",
        "\n",
        "        bit_strings = VGroup(\n",
        "            BitString(k, length=n)\n",
        "            for k in range(2**n)\n",
        "        )\n",
        "        bit_strings.set_color(GREY)\n",
        "        for bits, entry in zip(bit_strings, array.get_entries()):\n",
        "            bits.set_max_height(entry.get_height())\n",
        "            bits.next_to(array, LEFT, buff=0.2)\n",
        "            bits.match_y(entry)\n",
        "\n",
        "        return VGroup(bit_strings, array.get_brackets(), array.get_entries())\n",
        "\n",
        "    def get_brace_group(self, vect, n):\n",
        "        brace = Brace(vect, RIGHT, buff=0.25)\n",
        "        label = brace.get_tex(Rf\"2^{{{n}}} = {2**n}\")\n",
        "        label.shift(SMALL_BUFF * UR)\n",
        "        return VGroup(brace, label)\n",
        "\n",
        "\n",
        "class InvisibleStateValues(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        frame = self.frame\n",
        "        n = 5\n",
        "        values = np.random.uniform(-1, 1, 2**n)\n",
        "        vect = DecimalMatrix(values.reshape(-1, 1), decimal_config=dict(include_sign=True))\n",
        "        vect.set_height(FRAME_HEIGHT - 1)\n",
        "        indices = VGroup(BitString(k, 5) for k in range(2**n))\n",
        "        for index, elem in zip(indices, vect.elements):\n",
        "            index.match_height(elem)\n",
        "            index.set_color(GREY_C)\n",
        "            index.next_to(vect, LEFT, SMALL_BUFF)\n",
        "            index.match_y(elem)\n",
        "\n",
        "        rects = VGroup(SurroundingRectangle(elem, buff=0.05) for elem in vect.elements)\n",
        "        rects.set_stroke(YELLOW, 1)\n",
        "\n",
        "        frame.set_height(2, about_edge=UP)\n",
        "        self.add(vect, indices)\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, rects, lag_ratio=0.25),\n",
        "            frame.animate.to_default_state(),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        rects.target = rects.generate_target()\n",
        "        rects.target.set_stroke(WHITE, 1)\n",
        "        rects.target.set_fill(GREY_D, 1)\n",
        "        self.play(MoveToTarget(rects, lag_ratio=0.1, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Shrink down\n",
        "        group = Group(indices, vect, Point(), rects)\n",
        "        self.play(group.animate.set_height(4).move_to(4 * RIGHT), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Revealed value\n",
        "        value = KetGroup(BitString(13, 5))\n",
        "        value.move_to(group)\n",
        "\n",
        "        self.clear()\n",
        "        self.add(value)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeDSample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up axes\n",
        "        frame = self.frame\n",
        "        x_range = y_range = z_range = (-2, 2)\n",
        "        axes = ThreeDAxes(x_range, y_range, z_range, axis_config=dict(tick_size=0.05))\n",
        "        plane = NumberPlane(x_range, y_range, faded_line_ratio=5)\n",
        "        plane.axes.set_opacity(0)\n",
        "        plane.background_lines.set_stroke(BLUE, 1, 0.5)\n",
        "        plane.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "\n",
        "        rot_vel_tracker = ValueTracker(DEG)\n",
        "\n",
        "        frame.reorient(-31, 71, 0, (0.22, 0.17, 0.13), 2.88)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(dt * rot_vel_tracker.get_value()))\n",
        "        self.add(axes, plane, Point())\n",
        "\n",
        "        # Add vector\n",
        "        vector = Vector(normalize([1, -1, 2]), thickness=2, fill_color=TEAL)\n",
        "        vector.always.set_perpendicular_to_camera(self.frame)\n",
        "        vector.set_z_index(2)\n",
        "\n",
        "        coord_array = DecimalMatrix(\n",
        "            np.zeros((3, 1)),\n",
        "            decimal_config=dict(include_sign=True)\n",
        "        )\n",
        "        coord_array.set_height(1.25)\n",
        "        coord_array.to_corner(UL)\n",
        "        coord_array.fix_in_frame()\n",
        "\n",
        "        def update_coord_array(coord_array):\n",
        "            for elem, coord in zip(coord_array.elements, vector.get_end()):\n",
        "                elem.set_value(coord)\n",
        "            coord_array.set_fill(GREY_B, border_width=1)\n",
        "\n",
        "        coord_array.add_updater(update_coord_array)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(vector),\n",
        "            VFadeIn(coord_array),\n",
        "        )\n",
        "        self.play(Rotate(vector, TAU, axis=OUT, about_point=ORIGIN, run_time=6))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show 0, 1, and 2 directions\n",
        "        symbols = VGroup(KetGroup(Integer(n)) for n in range(3))\n",
        "        symbols.scale(0.5)\n",
        "        symbols.set_backstroke(BLACK, 5)\n",
        "        symbols.rotate(90 * DEG, RIGHT)\n",
        "        directions = [UP + 0.5 * OUT, LEFT, LEFT]\n",
        "\n",
        "        for symbol, direction, trg_coords in zip(symbols, directions, np.identity(3)):\n",
        "            symbol.next_to(0.5 * trg_coords, direction, SMALL_BUFF)\n",
        "            self.play(\n",
        "                self.set_vect_anim(vector, trg_coords),\n",
        "                FadeIn(symbol, 0.25 * OUT)\n",
        "            )\n",
        "            self.play(symbol.animate.scale(0.5).next_to(trg_coords, direction, SMALL_BUFF))\n",
        "            self.wait(0.5)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Highlight a secret key\n",
        "        key_icon = get_key_icon()\n",
        "        key_icon.rotate(90 * DEG, RIGHT)\n",
        "        key_icon.match_depth(symbols[2])\n",
        "        key_icon.next_to(symbols[2], LEFT, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(key_icon, 0.25 * LEFT),\n",
        "            symbols[2].animate.set_fill(YELLOW),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Go to the balanced state\n",
        "        coord_rects = VGroup(\n",
        "            SurroundingRectangle(elem)\n",
        "            for elem in coord_array.elements\n",
        "        )\n",
        "        coord_rects.set_stroke(TEAL, 3)\n",
        "        coord_rects.fix_in_frame()\n",
        "\n",
        "        balanced_state = normalize([1, 1, 1])\n",
        "        balance_name = Text(\"balanced state\", font_size=16)\n",
        "        balance_ket = KetGroup(Text(\"b\", font_size=16), buff=0.035)\n",
        "        for mob in [balance_name, balance_ket]:\n",
        "            mob.rotate(90 * DEG, RIGHT)\n",
        "            mob.next_to(balanced_state, OUT + RIGHT, buff=0.025)\n",
        "\n",
        "        self.play(\n",
        "            self.set_vect_anim(vector, balanced_state, run_time=4),\n",
        "            FadeIn(balance_name, lag_ratio=0.1, time_span=(3, 4)),\n",
        "        )\n",
        "        self.play(LaggedStartMap(ShowCreation, coord_rects, lag_ratio=0.25))\n",
        "        self.play(LaggedStartMap(FadeOut, coord_rects, lag_ratio=0.25))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransformPieces(balance_name, balance_ket[1]),\n",
        "            Write(balance_ket[0])\n",
        "        )\n",
        "        self.play(rot_vel_tracker.animate.set_value(-DEG), run_time=3)\n",
        "        self.wait(7)\n",
        "\n",
        "        # Show the goal\n",
        "        z_vect = vector.copy()\n",
        "        z_vect.set_fill(YELLOW)\n",
        "\n",
        "        tail = TracingTail(z_vect.get_end, stroke_color=YELLOW, time_traced=3)\n",
        "        self.add(tail)\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(z_vect))\n",
        "        self.play(\n",
        "            self.set_vect_anim(z_vect, OUT, run_time=2)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.remove(tail)\n",
        "\n",
        "        # Show 2d slice\n",
        "        v_slice = NumberPlane(x_range, y_range, faded_line_ratio=5)\n",
        "        v_slice.rotate(90 * DEG, RIGHT)\n",
        "        v_slice.rotate(45 * DEG, OUT)\n",
        "        v_slice.axes.set_stroke(WHITE, 1, 0.5)\n",
        "        v_slice.background_lines.set_stroke(BLUE, 1, 1)\n",
        "        v_slice.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "\n",
        "        b_vect_ghost = vector.copy()\n",
        "        b_vect_ghost.set_fill(opacity=0.5)\n",
        "        tail = TracingTail(vector.get_end, stroke_color=TEAL, time_traced=8)\n",
        "        symbols[2].set_z_index(1)\n",
        "\n",
        "        self.add(tail)\n",
        "        self.play(\n",
        "            frame.animate.reorient(43, 79, 0, (-0.26, 0.37, 0.15), 4.97),\n",
        "            rot_vel_tracker.animate.set_value(-2 * DEG),\n",
        "            FadeIn(v_slice),\n",
        "            plane.animate.fade(0.75),\n",
        "            axes.animate.set_stroke(opacity=0.5),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.add(b_vect_ghost)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                vector,\n",
        "                TAU,\n",
        "                axis=np.cross(vector.get_end(), OUT),\n",
        "                run_time=8,\n",
        "                about_point=ORIGIN,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-1, 79, 0, (-0.13, 0.55, 1.08), 7.67),\n",
        "            coord_array.animate.set_x(0),\n",
        "            run_time=2,\n",
        "        )\n",
        "        tail.clear_updaters()\n",
        "        self.play(FadeOut(tail))\n",
        "        self.wait(20)\n",
        "\n",
        "        # Show xy line\n",
        "        xy_line = v_slice.x_axis.copy()\n",
        "        xy_line.set_stroke(WHITE, 3, 1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(67, 77, 0, (-0.57, 0.12, 0.86), 6.62),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            GrowFromCenter(xy_line),\n",
        "            self.set_vect_anim(vector, normalize(UR)),\n",
        "        )\n",
        "        self.wait(10)\n",
        "        self.play(self.set_vect_anim(vector, balanced_state))\n",
        "        self.wait(20)\n",
        "\n",
        "    def set_vect_anim(self, vector, trg_coords, run_time=1, **kwargs):\n",
        "        return Rotate(\n",
        "            vector,\n",
        "            angle_between_vectors(vector.get_end(), trg_coords),\n",
        "            axis=np.cross(vector.get_end(), trg_coords),\n",
        "            about_point=ORIGIN,\n",
        "            run_time=run_time,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def flip_along_key_axis(self):\n",
        "        # To be inserted after highlighting the key state above\n",
        "        sphere = Sphere(radius=vector.get_length())\n",
        "        mesh = SurfaceMesh(sphere, resolution=(51, 101))\n",
        "        mesh.set_stroke(WHITE, 2, 0.1)\n",
        "\n",
        "        key_vect = vector.copy()\n",
        "        key_vect.clear_updaters()\n",
        "        key_vect.set_fill(YELLOW, 0.5)\n",
        "\n",
        "        self.add(key_vect)\n",
        "        self.play(\n",
        "            self.set_vect_anim(vector, normalize([1, 1, 1])),\n",
        "            FadeIn(mesh)\n",
        "        )\n",
        "        vector.clear_updaters()\n",
        "        for _ in range(4):\n",
        "            self.play(\n",
        "                Group(mesh, vector, key_vect).animate.stretch(-1, 2, about_point=ORIGIN),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class GroversAlgorithm(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up plane\n",
        "        x_range = y_range = (-1, 1 - 1e-6)\n",
        "        plane = NumberPlane(x_range, y_range, faded_line_ratio=5)\n",
        "        plane.set_height(6)\n",
        "        plane.background_lines.set_stroke(BLUE, 1, 1)\n",
        "        plane.faded_lines.set_stroke(BLUE, 1, 0.25)\n",
        "\n",
        "        self.add(plane)\n",
        "\n",
        "        # Add key and balance directions\n",
        "        key_vect = Vector(plane.c2p(0, 1), thickness=5, fill_color=YELLOW)\n",
        "        b_vect = key_vect.copy().rotate(- np.arccos(1 / math.sqrt(3)), about_point=ORIGIN)\n",
        "        b_vect.set_fill(TEAL)\n",
        "\n",
        "        key_label, b_label = labels = VGroup(\n",
        "            KetGroup(Tex(char))\n",
        "            for char in \"kb\"\n",
        "        )\n",
        "        labels.set_submobject_colors_by_gradient(YELLOW, TEAL)\n",
        "        labels.set_backstroke(BLACK, 3)\n",
        "        for label in labels:\n",
        "            label[1].shift(0.02 * UR)\n",
        "        key_label.next_to(key_vect.get_end(), UP, SMALL_BUFF)\n",
        "        b_label.next_to(b_vect.get_end(), UR, SMALL_BUFF)\n",
        "        key_icon = get_key_icon()\n",
        "        key_icon.set_height(0.75 * key_label.get_height())\n",
        "        key_icon.next_to(key_label, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.add(key_vect, b_vect)\n",
        "        self.add(key_label, b_label, key_icon)\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight key\n",
        "        self.play(GrowArrow(key_vect))\n",
        "        self.play(FlashAround(key_label, time_width=1.5, run_time=2))\n",
        "\n",
        "        # Label the x-direction\n",
        "        x_vect = Vector(plane.c2p(1, 0), thickness=5)\n",
        "        x_vect.set_fill(WHITE)\n",
        "        x_label_example, x_label_general = x_labels = VGroup(\n",
        "            Tex(R\"\\frac{1}{\\sqrt{2}}\\big(|0\\rangle + |1\\rangle \\big)\", font_size=36),\n",
        "            Tex(R\"\\frac{1}{\\sqrt{N - 1}} \\sum_{n \\ne k} |n \\rangle\", font_size=24),\n",
        "        )\n",
        "        for label in x_labels:\n",
        "            label.next_to(x_vect.get_end(), RIGHT)\n",
        "\n",
        "        x_label_general.shift(SMALL_BUFF * DL)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(key_vect, x_vect, path_arc=-90 * DEG),\n",
        "            FadeIn(x_label_general, time_span=(0.5, 1.5)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        x_label_general.save_state()\n",
        "        self.play(\n",
        "            FadeIn(x_label_example, DOWN),\n",
        "            x_label_general.animate.fade(0.5).shift(1.25 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show component of b in the direction of key\n",
        "        rhs = Tex(R\"= \\frac{1}{\\sqrt{3}}\\big(|0\\rangle + |1\\rangle + |2\\rangle \\big)\", font_size=36)\n",
        "        rhs.next_to(b_label, RIGHT)\n",
        "        rhs.set_color(TEAL)\n",
        "\n",
        "        b_vect_proj = Vector(plane.c2p(0, plane.p2c(b_vect.get_end())[1]), thickness=5)\n",
        "        b_vect_proj.set_fill(TEAL_E, 1)\n",
        "        dashed_line = DashedLine(b_vect.get_end(), b_vect_proj.get_end())\n",
        "\n",
        "        self.play(FadeIn(rhs, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(b_vect, b_vect_proj),\n",
        "            ShowCreation(dashed_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlashAround(rhs[R\"|2\\rangle\"], time_width=1.5, run_time=3),\n",
        "            rhs[R\"|2\\rangle\"].animate.set_color(YELLOW),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Set up N\n",
        "        N_eq = Tex(R\"N = 3\")\n",
        "        dim = N_eq.make_number_changeable(\"3\", edge_to_fix=LEFT)\n",
        "        N_eq.next_to(plane, UR, LARGE_BUFF).shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(rhs),\n",
        "                Restore(x_label_general),\n",
        "                FadeOut(x_label_example, 0.5 * UP),\n",
        "            ),\n",
        "            Write(N_eq)\n",
        "        )\n",
        "\n",
        "        # Increase N\n",
        "        N_tracker = ValueTracker(3)\n",
        "        get_N = N_tracker.get_value\n",
        "\n",
        "        def update_b_vects(vects):\n",
        "            N = int(get_N())\n",
        "            x = math.sqrt(1 - 1.0 / N)\n",
        "            y = 1 / math.sqrt(N)\n",
        "            vects[0].put_start_and_end_on(plane.c2p(0, 0), plane.c2p(x, y))\n",
        "            vects[1].put_start_and_end_on(plane.c2p(0, 0), plane.c2p(0, y))\n",
        "\n",
        "        self.play(\n",
        "            N_tracker.animate.set_value(100).set_anim_args(rate_func=rush_into),\n",
        "            UpdateFromFunc(dim, lambda m: m.set_value(int(get_N()))),\n",
        "            UpdateFromFunc(VGroup(b_vect, b_vect_proj), update_b_vects),\n",
        "            UpdateFromFunc(dashed_line, lambda m: m.become(DashedLine(b_vect.get_end(), b_vect_proj.get_end()))),\n",
        "            UpdateFromFunc(b_label, lambda m: m.next_to(b_vect.get_end(), UR, SMALL_BUFF)),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reference the angle\n",
        "        alpha = math.acos(1 / math.sqrt(N_tracker.get_value()))\n",
        "        arc = Arc(90 * DEG, -alpha, radius=0.5)\n",
        "        alpha_label = Tex(R\"\\alpha\")\n",
        "        alpha_label.next_to(arc.pfp(0.5), UR, SMALL_BUFF)\n",
        "        lt_90 = Tex(R\"< 90^\\circ\")\n",
        "        lt_90.next_to(alpha_label, RIGHT).shift(0.05 * UL)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(b_vect_proj),\n",
        "            FadeOut(dashed_line),\n",
        "            ShowCreation(arc),\n",
        "            FadeIn(alpha_label),\n",
        "        )\n",
        "        self.play(Write(lt_90))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(VGroup(b_vect_proj, dashed_line), run_time=3, rate_func=there_and_back_with_pause, remover=True))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the dot product\n",
        "        frame = self.frame\n",
        "\n",
        "        b_comp_tex = R\"1 / \\sqrt{N}\"\n",
        "        b_array = TexMatrix(np.array([\n",
        "            *2 * [b_comp_tex],\n",
        "            R\"\\vdots\",\n",
        "            *3 * [b_comp_tex],\n",
        "            R\"\\vdots\",\n",
        "            *2 * [b_comp_tex],\n",
        "        ]).reshape(-1, 1))\n",
        "        k_array = TexMatrix(np.array([\n",
        "            *2 * [\"0\"],\n",
        "            R\"\\vdots\",\n",
        "            \"0\", \"1\", \"0\",\n",
        "            R\"\\vdots\",\n",
        "            *2 * [\"0\"],\n",
        "        ]).reshape(-1, 1))\n",
        "        arrays = VGroup(k_array, b_array)\n",
        "\n",
        "        for array in arrays:\n",
        "            array.set_height(6)\n",
        "\n",
        "        arrays.arrange(LEFT, buff=MED_LARGE_BUFF)\n",
        "        arrays.next_to(plane, RIGHT, buff=2.5).to_edge(DOWN, buff=MED_LARGE_BUFF)\n",
        "        dot = Tex(R\"\\cdot\", font_size=72)\n",
        "        dot.move_to(midpoint(b_array.get_right(), k_array.get_left()))\n",
        "\n",
        "        k_array_label, b_array_label = array_labels = labels.copy()\n",
        "\n",
        "        for label, arr in zip(array_labels, arrays):\n",
        "            arr.set_fill(interpolate_color(label.get_fill_color(), WHITE, 0.2), 1)\n",
        "            label.next_to(arr, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromPoint(b_array, b_label.get_center()),\n",
        "            TransformFromCopy(b_label, b_array_label),\n",
        "            N_eq.animate.to_edge(UP, MED_SMALL_BUFF).set_x(2),\n",
        "            frame.animate.set_x(4),\n",
        "            FadeOut(x_label_general),\n",
        "            FadeOut(x_vect),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromPoint(k_array, key_label.get_center()),\n",
        "            TransformFromCopy(key_label, k_array_label),\n",
        "            Write(dot),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Evaluate the dot product\n",
        "        elem_rects = VGroup(\n",
        "            SurroundingRectangle(VGroup(*elems), buff=0.05).set_width(2.5, stretch=True)\n",
        "            for elems in zip(b_array.elements, k_array.elements)\n",
        "        )\n",
        "        for rect in elem_rects:\n",
        "            rect.set_stroke(WHITE, 2)\n",
        "            rect.align_to(elem_rects[0], RIGHT)\n",
        "\n",
        "        equals = Tex(R\"=\").next_to(arrays, RIGHT)\n",
        "        rhs = Tex(R\"1 / \\sqrt{N}\")\n",
        "        rhs.next_to(equals, RIGHT)\n",
        "\n",
        "        self.play(Write(equals))\n",
        "        self.play(\n",
        "            LaggedStartMap(VFadeInThenOut, elem_rects, lag_ratio=0.2, run_time=5),\n",
        "            FadeIn(rhs, time_span=(1.75, 2.25)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show cosine expression\n",
        "        cos_expr = Tex(R\"\\cos(\\alpha) = 1 / \\sqrt{N}\", font_size=36)\n",
        "        cos_expr.next_to(alpha_label, UP, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(lt_90),\n",
        "            Write(cos_expr[R\"\\cos(\"]),\n",
        "            Write(cos_expr[R\") =\"]),\n",
        "            TransformFromCopy(alpha_label, cos_expr[R\"\\alpha\"][0]),\n",
        "            TransformFromCopy(rhs, cos_expr[R\"1 / \\sqrt{N}\"][0]),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show sine of smaller angle\n",
        "        target_thickness = 3\n",
        "\n",
        "        for vect in [b_vect, key_vect]:\n",
        "            vect.target = Arrow(ORIGIN, vect.get_end(), thickness=target_thickness, buff=0)\n",
        "            vect.target.match_style(vect)\n",
        "\n",
        "        theta = 90 * DEG - alpha\n",
        "        theta_arc = Arc(0, theta, radius=2.0)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=24)\n",
        "        theta_label.next_to(theta_arc, RIGHT, buff=0.1)\n",
        "        alpha_label.set_backstroke(BLACK, 5)\n",
        "        theta_label.set_backstroke(BLACK, 5)\n",
        "\n",
        "        sin_expr = Tex(R\"\\sin(\\theta) = 1 / \\sqrt{N}\", font_size=36)\n",
        "        sin_expr.move_to(cos_expr).set_y(-0.5)\n",
        "\n",
        "        theta_approx = Tex(R\"\\theta \\approx 1 / \\sqrt{N}\", font_size=36)\n",
        "        theta_approx.next_to(sin_expr, DOWN, aligned_edge=RIGHT)\n",
        "\n",
        "        cos_group = VGroup(arc, alpha_label, cos_expr)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(b_vect),\n",
        "            MoveToTarget(key_vect),\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(arc, theta_arc),\n",
        "                TransformFromCopy(alpha_label, theta_label),\n",
        "                TransformFromCopy(cos_expr, sin_expr),\n",
        "                lag_ratio=0.25\n",
        "            ),\n",
        "            cos_group.animate.fade(0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                sin_expr.copy(),\n",
        "                theta_approx,\n",
        "                matched_keys=[R\"1 / \\sqrt{N}\"],\n",
        "                key_map={\"=\": R\"\\approx\"}\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Put it in the corner\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(array_labels, arrays, dot, equals, rhs, cos_group, sin_expr), lag_ratio=0.25),\n",
        "            frame.animate.set_x(-2),\n",
        "            N_eq.animate.set_x(-2),\n",
        "            theta_approx.animate.to_corner(UR, buff=MED_SMALL_BUFF).shift(2 * LEFT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add vector components\n",
        "        vector = b_vect.copy()\n",
        "\n",
        "        initial_coords = 0.1 * np.ones(11)\n",
        "        vect_coords = DecimalMatrix(initial_coords.reshape(-1, 1), num_decimal_places=3, decimal_config=dict(include_sign=True))\n",
        "        vect_coords.set_height(6)\n",
        "        vect_coords.next_to(frame.get_left(), RIGHT, MED_LARGE_BUFF)\n",
        "        mid_index = len(initial_coords) // 2\n",
        "        dot_indices = [mid_index - 2, mid_index + 2]\n",
        "        arr_dots = VGroup()\n",
        "        for index in dot_indices:\n",
        "            element = vect_coords.elements[index]\n",
        "            dots = Tex(R\"\\vdots\")\n",
        "            dots.move_to(element)\n",
        "            element.become(dots)\n",
        "            arr_dots.add(element)\n",
        "\n",
        "        vect_coords.set_fill(GREY_B)\n",
        "\n",
        "        def update_vect_coords(vect_coords):\n",
        "            x, y = plane.p2c(vector.get_end())\n",
        "            x /= math.sqrt(99)\n",
        "            for n, elem in enumerate(vect_coords.elements):\n",
        "                if n in dot_indices:\n",
        "                    continue\n",
        "                elif n == mid_index:\n",
        "                    elem.set_value(y)\n",
        "                else:\n",
        "                    elem.set_value(x)\n",
        "\n",
        "        vect_coords.add_updater(update_vect_coords)\n",
        "\n",
        "        key_icon2 = get_key_icon(height=0.25)\n",
        "        key_icon2.next_to(vect_coords, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.add(vect_coords)\n",
        "        self.add(key_icon2)\n",
        "\n",
        "        # Add bars\n",
        "        min_bar_width = 0.125\n",
        "        bar_height = 0.25\n",
        "\n",
        "        dec_elements = VGroup(\n",
        "            elem for n, elem in enumerate(vect_coords.elements) if n not in dot_indices\n",
        "        )\n",
        "        bars = Rectangle(min_bar_width, bar_height).replicate(len(dec_elements))\n",
        "        bars.set_fill(opacity=1)\n",
        "        bars.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        bars.set_stroke(WHITE, 0.5)\n",
        "\n",
        "        for bar, elem in zip(bars, dec_elements):\n",
        "            bar.next_to(vect_coords, RIGHT)\n",
        "            bar.match_y(elem)\n",
        "            bar.elem = elem\n",
        "\n",
        "        def update_bars(bars):\n",
        "            x, y = plane.p2c(vector.get_end())\n",
        "            x /= math.sqrt(99)\n",
        "            mid_index = len(bars) // 2\n",
        "            for n, bar in enumerate(bars):\n",
        "                if n == mid_index:\n",
        "                    prob = 1 - 99 * (x**2)\n",
        "                else:\n",
        "                    prob = x**2\n",
        "                width = min_bar_width * np.sqrt(prob / 0.01)\n",
        "                bar.set_width(width, about_edge=LEFT, stretch=True)\n",
        "\n",
        "        self.add(bars)\n",
        "\n",
        "        # Show the flips\n",
        "        circle = Circle(radius=0.5 * plane.get_width())\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "        b_vect.set_fill(opacity=0.5)\n",
        "\n",
        "        frame.set_field_of_view(20 * DEG)\n",
        "\n",
        "        diag_line = DashedLine(-b_vect.get_end(), b_vect.get_end())\n",
        "        h_line = DashedLine(plane.get_left(), plane.get_right())\n",
        "        VGroup(h_line, diag_line).set_stroke(WHITE, 2)\n",
        "\n",
        "        flip_line = h_line.copy()\n",
        "\n",
        "        flipper = VGroup(circle, vector)\n",
        "\n",
        "        vect_ghosts = VGroup()\n",
        "\n",
        "        def right_filp(run_time=2):\n",
        "            self.play(\n",
        "                Rotate(flipper, PI, RIGHT, about_point=ORIGIN),\n",
        "                vect_ghosts.animate.set_fill(opacity=0.25),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "        def diag_flip(run_time=2, draw_time=0.5):\n",
        "            self.play(ShowCreation(diag_line, run_time=draw_time))\n",
        "            self.play(\n",
        "                flipper.animate.flip(axis=diag_line.get_vector(), about_point=ORIGIN),\n",
        "                vect_ghosts.animate.set_fill(opacity=0.25),\n",
        "                UpdateFromFunc(bars, update_bars),\n",
        "                run_time=run_time\n",
        "            )\n",
        "            self.play(FadeOut(diag_line, run_time=2 * draw_time))\n",
        "\n",
        "        self.add(vect_ghosts, vector)\n",
        "        self.play(FadeIn(circle))\n",
        "        for n in range(4):\n",
        "            vect_ghosts.add(vector.copy())\n",
        "            right_filp()\n",
        "            self.wait()\n",
        "            vect_ghosts.add(vector.copy())\n",
        "            diag_flip(draw_time=(0.5 if n < 2 else 1 / 30))\n",
        "            self.wait()\n",
        "\n",
        "        vect_ghosts.add(vect.copy()).set_fill(opacity=0.25)\n",
        "\n",
        "        # Show vertical component\n",
        "        if False:  # For an insertion\n",
        "            # Show vert component\n",
        "            self.add(diag_line)\n",
        "\n",
        "            x, y = plane.p2c(vector.get_end())\n",
        "            v_part = Arrow(plane.get_origin(), plane.c2p(0, y), thickness=4, buff=0, max_width_to_length_ratio=0.25)\n",
        "            v_part.set_fill(GREEN)\n",
        "            h_line = DashedLine(vector.get_end(), v_part.get_end())\n",
        "            brace = Brace(v_part, LEFT, buff=0.05)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(diag_line),\n",
        "                TransformFromCopy(vector, v_part),\n",
        "                ShowCreation(h_line),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(GrowFromCenter(brace))\n",
        "            self.wait()\n",
        "\n",
        "        # Show steps of 2 * theta\n",
        "        bars.add_updater(update_bars)\n",
        "\n",
        "        arcs = VGroup(\n",
        "            Arc(n * theta, 2 * theta, radius=circle.get_radius())\n",
        "            for n in range(1, len(vect_ghosts), 2)\n",
        "        )\n",
        "        for arc, color in zip(arcs, it.cycle([BLUE, RED])):\n",
        "            arc.set_stroke(color, 3)\n",
        "\n",
        "        arc_labels = VGroup(\n",
        "            Tex(R\"2\\theta\", font_size=24).next_to(arc.pfp(0.5), normalize(arc.pfp(0.5)), SMALL_BUFF)\n",
        "            for arc in arcs\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                vector,\n",
        "                -angle_between_vectors(vector.get_vector(), b_vect.get_vector()),\n",
        "                about_point=ORIGIN\n",
        "            ),\n",
        "            FadeOut(b_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        right_filp()\n",
        "        diag_flip(draw_time=0.25)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(vect_ghosts[0], vector, path_arc=theta),\n",
        "            ShowCreation(arcs[0])\n",
        "        )\n",
        "        self.play(TransformFromCopy(theta_label, arc_labels[0]))\n",
        "        self.wait()\n",
        "        for arc, label in zip(arcs[1:], arc_labels[1:]):\n",
        "            self.play(\n",
        "                Rotate(vector, 2 * theta, about_point=ORIGIN),\n",
        "                ShowCreation(arc),\n",
        "                FadeIn(label, shift=0.5 * (arc.get_end() - arc.get_start()))\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show full angle\n",
        "        quarter_arc = Arc(0, 90 * DEG)\n",
        "        ninety_label = Tex(R\"90^\\circ\")\n",
        "        pi_halves_label = Tex(R\"\\pi / 2\")\n",
        "        for label in [ninety_label, pi_halves_label]:\n",
        "            label.set_backstroke(BLACK, 5)\n",
        "            label.next_to(quarter_arc.pfp(0.5), UR, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(quarter_arc),\n",
        "            Write(ninety_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(ninety_label, pi_halves_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Calculate n steps\n",
        "        lhs = Text(\"# Repetitions\")\n",
        "        lhs.next_to(plane, RIGHT, buff=1.0).set_y(2)\n",
        "        rhs_terms = VGroup(\n",
        "            Tex(R\"\\approx {\\pi / 2 \\over 2 \\theta}\"),\n",
        "            Tex(R\"= {\\pi \\over 4} \\cdot {1 \\over \\theta}\"),\n",
        "            Tex(R\"= {\\pi \\over 4} \\sqrt{N}\"),\n",
        "        )\n",
        "        rhs_terms.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        rhs_terms.shift(lhs.get_right() + 0.2 * RIGHT + 0.05 * UP - rhs_terms[0].get_left())\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_x(3),\n",
        "            FadeOut(vect_coords),\n",
        "            FadeOut(bars),\n",
        "            FadeOut(key_icon2),\n",
        "            Write(lhs),\n",
        "            Write(rhs_terms[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, rhs_terms[1:], shift=0.5 * DOWN, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Collapse\n",
        "        self.play(LaggedStart(\n",
        "            Rotate(\n",
        "                vector,\n",
        "                -angle_between_vectors(vector.get_vector(), b_vect.get_vector()),\n",
        "                about_point=ORIGIN\n",
        "            ),\n",
        "            FadeOut(arcs),\n",
        "            FadeOut(arc_labels),\n",
        "            FadeOut(vect_ghosts),\n",
        "            FadeOut(b_vect),\n",
        "            FadeOut(theta_label),\n",
        "            FadeOut(theta_arc),\n",
        "            frame.animate.set_y(0.5),\n",
        "            N_eq.animate.shift(0.5 * UP),\n",
        "            theta_approx.animate.align_to(plane, RIGHT),\n",
        "            VGroup(lhs, rhs_terms).animate.shift(1.5 *  UP)\n",
        "        ))\n",
        "\n",
        "        # Increment to 2^20\n",
        "        new_theta = math.asin(2**(-10))\n",
        "        dim.set_value(100)\n",
        "        step_count = Tex(R\"\\frac{\\pi}{4}\\sqrt{2^{20}} = 804.248...\")\n",
        "        step_count.next_to(rhs_terms, DOWN, LARGE_BUFF)\n",
        "        step_count.to_edge(RIGHT).shift(frame.get_x() * RIGHT)\n",
        "\n",
        "        eq_two_twenty = Tex(R\"=2^{20}\")\n",
        "        eq_two_twenty.next_to(N_eq[\"=\"], DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(dim, int(2**20)),\n",
        "            Rotate(vector, new_theta - theta, about_point=ORIGIN),\n",
        "            FadeIn(eq_two_twenty, time_span=(0, 1)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(rhs_terms[-1][1:6], step_count[:5]),\n",
        "            TransformFromCopy(eq_two_twenty[1:], step_count[\"2^{20}\"][0]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(Write(step_count[\"= 804.248...\"][0]))\n",
        "        self.wait()\n",
        "\n",
        "        # Change vector\n",
        "        step_tracker = ValueTracker(0)\n",
        "        radius = 0.5 * plane.get_width()\n",
        "\n",
        "        step_label = Tex(R\"\\#\\text{Reps} = 0\", font_size=36)\n",
        "        step_label.next_to(plane.c2p(-0.6, 0), UP, SMALL_BUFF)\n",
        "        step_count = step_label.make_number_changeable(0, edge_to_fix=UL)\n",
        "        step_count.f_always.set_value(lambda: 0.5 * step_tracker.get_value())\n",
        "\n",
        "        shadows = VectorizedPoint().replicate(300)\n",
        "\n",
        "        def update_vector(vector):\n",
        "            steps = int(step_tracker.get_value())\n",
        "            if steps % 2 == 0:\n",
        "                angle = new_theta * (steps + 1)\n",
        "            else:\n",
        "                angle = -new_theta * steps\n",
        "            point = rotate_vector(radius * RIGHT, angle)\n",
        "            vector.put_start_and_end_on(ORIGIN, point)\n",
        "            shadows.remove(shadows[0])\n",
        "            shadows.add(vector.copy())\n",
        "            shadows.clear_updaters()\n",
        "            for n, shadow in enumerate(shadows[::-1]):\n",
        "                shadow.set_fill(opacity=0.75 / (n + 1))\n",
        "\n",
        "        self.play(FadeIn(step_label))\n",
        "        self.add(shadows)\n",
        "        self.add(vect_coords, bars)\n",
        "        self.play(\n",
        "            step_tracker.animate.set_value(2 * 804),\n",
        "            UpdateFromFunc(vector, update_vector),\n",
        "            frame.animate.scale(1.4, about_edge=RIGHT).set_anim_args(time_span=(0, 8)),\n",
        "            run_time=20,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.play(FadeOut(shadows, lag_ratio=0.1, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "    def key_flip_insertion(self):\n",
        "        # Test\n",
        "        self.clear()\n",
        "        key_ghost = key_vect.copy().set_fill(opacity=0.5)\n",
        "        self.add(key_ghost)\n",
        "        self.play(\n",
        "            key_vect.animate.flip(axis=RIGHT, about_edge=DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def thumbnail_insertion(self):\n",
        "        # Test\n",
        "        plane.background_lines.set_stroke(BLUE, 8, 1)\n",
        "        plane.faded_lines.set_stroke(BLUE, 5, 0.25)\n",
        "        circle.set_stroke(WHITE, 3)\n",
        "        self.remove(N_eq)\n",
        "        self.remove(theta_label)\n",
        "        self.remove(theta_arc)\n",
        "        self.remove(theta_approx)\n",
        "\n",
        "\n",
        "class TwoFlipsEqualsRotation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up planes\n",
        "        plane = NumberPlane((-2, 2), (-2, 2))\n",
        "        plane.background_lines.set_stroke(BLUE, 1, 1)\n",
        "        plane.faded_lines.set_stroke(BLUE, 1, 0.25)\n",
        "        plane.axes.set_opacity(0.5)\n",
        "\n",
        "        randy = Randolph(mode=\"pondering\", height=3)\n",
        "\n",
        "        ghost_plane = plane.copy()\n",
        "        ghost_plane.fade(0.5)\n",
        "        self.add(ghost_plane)\n",
        "\n",
        "        plane2 = plane.copy()\n",
        "        ghost_plane2 = ghost_plane.copy()\n",
        "        randy2 = randy.copy()\n",
        "        VGroup(plane2, ghost_plane2, randy2).next_to(plane, RIGHT, buff=3)\n",
        "\n",
        "        self.add(plane, randy)\n",
        "\n",
        "        # Show flips\n",
        "        theta = 15 * DEG\n",
        "        h_flip_line = DashedLine(plane.get_left(), plane.get_right())\n",
        "        diag_flip_line = h_flip_line.copy().rotate(theta)\n",
        "        flip_lines = VGroup(h_flip_line, diag_flip_line)\n",
        "        flip_lines.set_stroke(WHITE, 4)\n",
        "\n",
        "        for line in flip_lines:\n",
        "            self.play(ShowCreation(line, run_time=0.5))\n",
        "            self.play(\n",
        "                randy.animate.flip(axis=line.get_vector(), about_point=plane.get_origin()),\n",
        "                plane.animate.flip(axis=line.get_vector(), about_point=plane.get_origin()),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show rotation\n",
        "        arcs = VGroup(\n",
        "            Arc(0, 90 * DEG, radius=1),\n",
        "            Arc(180 * DEG, 90 * DEG, radius=1),\n",
        "        )\n",
        "        for arc, vect in zip(arcs, [UR, DL]):\n",
        "            arc.set_stroke(WHITE, 5)\n",
        "            arc.move_to(plane2.get_corner(vect))\n",
        "            arc.add_tip()\n",
        "\n",
        "        self.play(\n",
        "            self.frame.animate.move_to(midpoint(plane.get_center(), plane2.get_center())),\n",
        "            FadeIn(ghost_plane2),\n",
        "            FadeIn(plane2),\n",
        "            FadeIn(randy2),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(Group(plane2, Point(), randy2), 2 * theta, about_point=plane2.get_center()),\n",
        "            *map(FadeIn, arcs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show angle\n",
        "        arc = Arc(0, theta, radius=1.0)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=30)\n",
        "        theta_label.set_backstroke(BLACK, 3)\n",
        "        theta_label.next_to(arc, RIGHT, SMALL_BUFF)\n",
        "        theta_label.shift(0.025 * UP)\n",
        "\n",
        "        rot_arc = Arc(0, 2 * theta, arc_center=plane2.get_center())\n",
        "        two_theta_label = Tex(R\"2 \\theta\")\n",
        "        two_theta_label.set_backstroke(BLACK, 3)\n",
        "        two_theta_label.next_to(rot_arc, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(arc), Write(theta_label), run_time=1)\n",
        "        self.play(\n",
        "            TransformFromCopy(arc, rot_arc),\n",
        "            TransformFromCopy(theta_label, two_theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ComplexComponents(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up vectors\n",
        "        state = normalize(np.random.uniform(-1, 1, 4))\n",
        "        dec_vect = DecimalMatrix(state.reshape(-1, 1), decimal_config=dict(include_sign=True))\n",
        "        dec_vect.move_to(3 * LEFT)\n",
        "\n",
        "        indices = VGroup(BitString(n, 2) for n in range(4))\n",
        "        for index, elem in zip(indices, dec_vect.elements):\n",
        "            index.set_color(GREY_B)\n",
        "            index.match_height(elem)\n",
        "            index.next_to(dec_vect, LEFT)\n",
        "            index.match_y(elem)\n",
        "\n",
        "        x_vect, z_vect = var_vects = [\n",
        "            TexMatrix(np.array([f\"{char}_{n}\" for n in range(4)]).reshape(-1, 1))\n",
        "            for char in \"xz\"\n",
        "        ]\n",
        "        for vect in var_vects:\n",
        "            vect.match_height(dec_vect)\n",
        "            vect.move_to(dec_vect, LEFT)\n",
        "\n",
        "        self.add(dec_vect, indices)\n",
        "        self.wait()\n",
        "\n",
        "        # Real number lines and complex planes\n",
        "        number_lines = VGroup(\n",
        "            NumberLine(\n",
        "                (-1, 1, 0.1),\n",
        "                big_tick_spacing=1,\n",
        "                width=3,\n",
        "                tick_size=0.05,\n",
        "                stroke_color=GREY_C,\n",
        "            )\n",
        "            for n in range(4)\n",
        "        )\n",
        "        number_lines.arrange(DOWN, buff=1.0)\n",
        "        number_lines.next_to(dec_vect, RIGHT, buff=1.0)\n",
        "\n",
        "        complex_planes = VGroup(\n",
        "            ComplexPlane((-1, 1), (-1, 1)).replace(number_line, 0)\n",
        "            for number_line in number_lines\n",
        "        )\n",
        "\n",
        "        for number_line in number_lines:\n",
        "            number_line.add_numbers([-1, 0, 1], font_size=24, buff=0.15)\n",
        "        for plane in complex_planes:\n",
        "            plane.add_coordinate_labels(font_size=16)\n",
        "\n",
        "        complex_planes.generate_target()\n",
        "        complex_planes.target.arrange(DOWN, buff=1.0)\n",
        "        complex_planes.target.set_height(7)\n",
        "        complex_planes.target.next_to(x_vect, RIGHT, buff=2.0)\n",
        "        complex_planes.set_opacity(0)\n",
        "\n",
        "        R_labels, C_labels = [\n",
        "            VGroup(\n",
        "                Tex(Rf\"\\mathds{{{char}}}\", font_size=36).next_to(mob.get_right(), RIGHT)\n",
        "                for mob in group\n",
        "            )\n",
        "            for char, group in zip(\"RC\", [number_lines, complex_planes.target])\n",
        "        ]\n",
        "\n",
        "        # Set up dots\n",
        "        state_tracker = ComplexValueTracker(state)\n",
        "\n",
        "        dots = GlowDot(color=YELLOW).replicate(len(state))\n",
        "\n",
        "        def update_dots(dots):\n",
        "            for dot, value, plane in zip(dots, state_tracker.get_value(), complex_planes):\n",
        "                dot.move_to(plane.n2p(value))\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "\n",
        "        dot_lines = VGroup(Line() for dot in dots)\n",
        "        dot_lines.set_stroke(YELLOW, 2, 0.5)\n",
        "\n",
        "        def update_dot_lines(lines):\n",
        "            for line, x, dot in zip(lines, x_vect.elements, dots):\n",
        "                line.put_start_and_end_on(\n",
        "                    x.get_right() + 0.05 * RIGHT,\n",
        "                    dot.get_center()\n",
        "                )\n",
        "\n",
        "        update_dot_lines(dot_lines)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, number_lines, lag_ratio=0.25),\n",
        "            LaggedStartMap(FadeIn, R_labels, lag_ratio=0.25),\n",
        "            LaggedStart(\n",
        "                # (FadeInFromPoint(dot, elem.get_center())\n",
        "                (FadeTransform(elem, dot)\n",
        "                for elem, dot in zip(dec_vect.elements, dots)),\n",
        "                lag_ratio=0.05,\n",
        "                group_type=Group\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                (FadeTransform(elem.copy(), x)\n",
        "                for elem, x in zip(dec_vect.elements, x_vect.elements)),\n",
        "                lag_ratio=0.05,\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, dot_lines),\n",
        "            ReplacementTransform(dec_vect.get_brackets(), x_vect.get_brackets(), time_span=(1, 2)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add(dots, dot_lines)\n",
        "        dot_lines.add_updater(update_dot_lines)\n",
        "\n",
        "        self.play(\n",
        "            state_tracker.animate.set_value(normalize(np.random.uniform(-1, 1, 4))),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Transition to complex plane\n",
        "        number_lines.generate_target()\n",
        "        for line, plane in zip(number_lines.target, complex_planes.target):\n",
        "            line.replace(plane, 0)\n",
        "            line.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(complex_planes),\n",
        "            MoveToTarget(number_lines, remover=True),\n",
        "            *(FadeTransform(R, C) for R, C in zip(R_labels, C_labels)),\n",
        "            ReplacementTransform(x_vect, z_vect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for n in range(4):\n",
        "            self.random_state_change(state_tracker, pump_index=(0 if n == 3 else None))\n",
        "\n",
        "        # Zoom in on one value\n",
        "        frame = self.frame\n",
        "\n",
        "        plane = complex_planes[0]\n",
        "        c_dot = GlowDot(color=YELLOW, radius=0.05)\n",
        "        c_dot.move_to(dots[0])\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(1.6).move_to(plane),\n",
        "            FadeIn(c_dot),\n",
        "            FadeOut(dots),\n",
        "            FadeOut(dot_lines),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Show magnitude\n",
        "        c_line = Line(plane.c2p(0), c_dot.get_center())\n",
        "        c_line.set_stroke(YELLOW, 2)\n",
        "        big_brace_width = 3\n",
        "        brace = Brace(Line(LEFT, RIGHT).set_width(big_brace_width), DOWN)\n",
        "        brace.scale(c_line.get_length() / big_brace_width, about_point=ORIGIN)\n",
        "        brace.rotate(c_line.get_angle() + PI, about_point=ORIGIN)\n",
        "        brace.shift(c_line.get_center())\n",
        "\n",
        "        mag_label = Tex(R\"|z_0|\", font_size=12)\n",
        "        mag_label.next_to(brace.get_center(), DR, buff=0.05),\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(c_line),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(mag_label),\n",
        "        )\n",
        "\n",
        "        # Show phase\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            0, c_line.get_angle() % TAU, radius=0.1, arc_center=plane.c2p(0),\n",
        "            stroke_color=MAROON_B\n",
        "        ))\n",
        "        arc.update()\n",
        "        arc.suspend_updating()\n",
        "\n",
        "        phi_label = Tex(R\"\\varphi\", font_size=12)\n",
        "        phi_label.set_color(MAROON_B)\n",
        "        phi_label.add_updater(\n",
        "            lambda m: m.move_to(arc.pfp(0.5)).shift(0.5 * (arc.pfp(0.5) - plane.c2p(0)))\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(arc), FadeIn(phi_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Show prob\n",
        "        prob_eq = Tex(R\"\\text{Prob} = |z_0|^2\", font_size=12)\n",
        "        prob_eq.move_to(mag_label)\n",
        "        prob_eq.align_to(C_labels[0], RIGHT).shift(0.2 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(mag_label, prob_eq[\"|z_0|\"][0], path_arc=45 * DEG),\n",
        "            Write(prob_eq[R\"\\text{Prob} =\"][0]),\n",
        "            Write(prob_eq[\"2\"][0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change phase\n",
        "        c_dot.add_updater(lambda m: m.move_to(c_line.get_end()))\n",
        "        ghost_line = c_line.copy().set_stroke(opacity=0.5)\n",
        "\n",
        "        self.add(ghost_line)\n",
        "        arc.resume_updating()\n",
        "        phi = c_line.get_angle() % TAU\n",
        "        for angle in [-(1 - 1e-5) * phi, PI, phi - PI]:\n",
        "            self.play(\n",
        "                Rotate(c_line, angle, about_point=plane.n2p(0), run_time=6),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Zoom back out\n",
        "        fader = Group(prob_eq, mag_label, brace, c_line, c_dot, arc, phi_label, ghost_line)\n",
        "        fader.clear_updaters()\n",
        "        dot_lines.set_stroke(opacity=0.25)\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            FadeOut(fader),\n",
        "            FadeIn(dots),\n",
        "            FadeIn(dot_lines),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # More random motion\n",
        "        self.random_state_change(state_tracker)\n",
        "\n",
        "        dots.suspend_updating()\n",
        "        self.play(\n",
        "            *(\n",
        "                Rotate(\n",
        "                    dot,\n",
        "                    random.random() * 2 * TAU,\n",
        "                    about_point=plane.c2p(0),\n",
        "                    run_time=10,\n",
        "                    rate_func=there_and_back,\n",
        "                )\n",
        "                for dot, plane in zip(dots, complex_planes)\n",
        "            )\n",
        "        )\n",
        "        dots.resume_updating()\n",
        "\n",
        "        for n in range(4):\n",
        "            self.random_state_change(state_tracker)\n",
        "\n",
        "    def random_state_change(self, state_tracker, pump_index=None, run_time=2):\n",
        "        rands = np.random.uniform(-1, 1, 4)\n",
        "        if pump_index is not None:\n",
        "            rands[pump_index] = 4\n",
        "        mags = normalize(rands)\n",
        "        phases = np.exp(TAU * np.random.random(4) * 1j)\n",
        "        new_state = mags * phases\n",
        "        self.play(state_tracker.animate.set_value(new_state), run_time=2)\n"
    ]
}