{
    "topic": "The mathematical concept being demonstrated is the Euler's formula, which states that for a planar",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "\n",
        "\n",
        "from animation import *\n",
        "from mobject import *\n",
        "from constants import *\n",
        "from mobject.region import  *\n",
        "import displayer as disp\n",
        "from scene.scene import Scene, GraphScene\n",
        "from scene.graphs import *\n",
        "from .moser_main import EulersFormula\n",
        "from script_wrapper import command_line_create_scene\n",
        "\n",
        "MOVIE_PREFIX = \"ecf_graph_scenes/\"\n",
        "RANDOLPH_SCALE_FACTOR = 0.3\n",
        "EDGE_ANNOTATION_SCALE_FACTOR = 0.7\n",
        "DUAL_CYCLE = [3, 4, 5, 6, 1, 0, 2, 3]\n",
        "\n",
        "class EulersFormulaWords(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTex(\"V-E+F=2\"))\n",
        "\n",
        "class TheTheoremWords(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"The Theorem:\"))\n",
        "\n",
        "class ProofAtLastWords(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"The Proof At Last...\"))\n",
        "\n",
        "class DualSpanningTreeWords(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Spanning trees have duals too!\"))\n",
        "\n",
        "class PreferOtherProofDialogue(Scene):\n",
        "    def construct(self):\n",
        "        teacher = Face(\"talking\").shift(2*LEFT)\n",
        "        student = Face(\"straight\").shift(2*RIGHT)\n",
        "        teacher_bubble = SpeechBubble(LEFT).speak_from(teacher)\n",
        "        student_bubble = SpeechBubble(RIGHT).speak_from(student)\n",
        "        teacher_bubble.write(\"Look at this \\\\\\\\ elegant proof!\")\n",
        "        student_bubble.write(\"I prefer the \\\\\\\\ other proof.\")\n",
        "\n",
        "        self.add(student, teacher, teacher_bubble, teacher_bubble.text)\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            Dot(student_bubble.tip).set_color(\"black\"),\n",
        "            Mobject(student_bubble, student_bubble.text)\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.remove(teacher_bubble.text)\n",
        "        teacher_bubble.write(\"Does that make this \\\\\\\\ any less elegant?\")\n",
        "        self.add(teacher_bubble.text)\n",
        "        self.wait(2)\n",
        "\n",
        "class IllustrateDuality(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "\n",
        "        self.add(OldTexText(\"Duality\").to_edge(UP))\n",
        "        self.remove(*self.vertices)\n",
        "        def special_alpha(t):\n",
        "            if t > 0.5:\n",
        "                t = 1 - t\n",
        "            if t < 0.25:\n",
        "                return smooth(4*t)\n",
        "            else:\n",
        "                return 1\n",
        "        kwargs = {\n",
        "            \"run_time\" : 5.0,\n",
        "            \"rate_func\" : special_alpha\n",
        "        }\n",
        "        self.play(*[\n",
        "            Transform(*edge_pair, **kwargs)\n",
        "            for edge_pair in zip(self.edges, self.dual_edges)\n",
        "        ] + [\n",
        "            Transform(\n",
        "                Mobject(*[\n",
        "                    self.vertices[index]\n",
        "                    for index in cycle\n",
        "                ]),\n",
        "                dv,\n",
        "                **kwargs\n",
        "            )\n",
        "            for cycle, dv in zip(\n",
        "                self.graph.region_cycles, \n",
        "                self.dual_vertices\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceGraph(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        tweaked_graph = deepcopy(self.graph)\n",
        "        for index in 2, 4:\n",
        "            tweaked_graph.vertices[index] += 2.8*RIGHT + 1.8*DOWN\n",
        "        tweaked_self = GraphScene(tweaked_graph)\n",
        "        edges_to_remove = [\n",
        "            self.edges[self.graph.edges.index(pair)]\n",
        "            for pair in [(4, 5), (0, 5), (1, 5), (7, 1), (8, 3)]\n",
        "        ]\n",
        "\n",
        "        connected, planar, graph = OldTexText([\n",
        "            \"Connected \", \"Planar \", \"Graph\"\n",
        "        ]).to_edge(UP).split()\n",
        "        not_okay = OldTexText(\"Not Okay\").set_color(\"red\")\n",
        "        planar_explanation = OldTexText(\"\"\"\n",
        "            (``Planar'' just means we can draw it without\n",
        "             intersecting lines)\n",
        "        \"\"\", size = \"\\\\small\")\n",
        "        planar_explanation.shift(planar.get_center() + 0.5*DOWN)\n",
        "\n",
        "        self.draw_vertices()\n",
        "        self.draw_edges()\n",
        "        self.clear()\n",
        "        self.add(*self.vertices + self.edges)\n",
        "        self.wait()\n",
        "        self.add(graph)\n",
        "        self.wait()\n",
        "        kwargs = {\n",
        "            \"rate_func\" : there_and_back,\n",
        "            \"run_time\"   : 5.0\n",
        "        }\n",
        "        self.add(not_okay)\n",
        "        self.play(*[\n",
        "            Transform(*pair, **kwargs)\n",
        "            for pair in zip(\n",
        "                self.edges + self.vertices, \n",
        "                tweaked_self.edges + tweaked_self.vertices,\n",
        "            )\n",
        "        ])\n",
        "        self.remove(not_okay)\n",
        "        self.add(planar, planar_explanation)\n",
        "        self.wait(2)\n",
        "        self.remove(planar_explanation)\n",
        "        self.add(not_okay)\n",
        "        self.remove(*edges_to_remove)\n",
        "        self.play(ShowCreation(\n",
        "            Mobject(*edges_to_remove),\n",
        "            rate_func = lambda t : 1 - t,\n",
        "            run_time = 1.0\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.remove(not_okay)\n",
        "        self.add(connected, *edges_to_remove)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OldIntroduceGraphs(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.draw_vertices()        \n",
        "        self.draw_edges()\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(*self.edges)\n",
        "        self.replace_vertices_with(Face().scale(0.4))\n",
        "        friends = OldTexText(\"Friends\").scale(EDGE_ANNOTATION_SCALE_FACTOR)\n",
        "        self.annotate_edges(friends.shift((0, friends.get_height()/2, 0)))\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(vertex, Dot(point))\n",
        "            for vertex, point in zip(self.vertices, self.points)\n",
        "        ]+[\n",
        "            Transform(ann, line)\n",
        "            for ann, line in zip(\n",
        "                self.edge_annotations, \n",
        "                self.edges\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class PlanarGraphDefinition(Scene):\n",
        "    def construct(self):\n",
        "        Not, quote, planar, end_quote = OldTexText([\n",
        "            \"Not \\\\\\\\\", \"``\", \"Planar\", \"''\",\n",
        "            # \"no matter how \\\\\\\\ hard you try\"\n",
        "        ]).split()\n",
        "        shift_val = Mobject(Not, planar).to_corner().get_center()\n",
        "        Not.set_color(\"red\").shift(shift_val)\n",
        "        graphs = [\n",
        "            Mobject(*GraphScene(g).mobjects)\n",
        "            for g in [\n",
        "                CubeGraph(), \n",
        "                CompleteGraph(5),\n",
        "                OctohedronGraph()\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        self.add(quote, planar, end_quote)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(quote),\n",
        "            FadeOut(end_quote),\n",
        "            ApplyMethod(planar.shift, shift_val),\n",
        "            FadeIn(graphs[0]),\n",
        "            run_time = 1.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(graphs[0])\n",
        "        self.add(graphs[1])\n",
        "        planar.set_color(\"red\")\n",
        "        self.add(Not)\n",
        "        self.wait(2)\n",
        "        planar.set_color(\"white\")\n",
        "        self.remove(Not)\n",
        "        self.remove(graphs[1])\n",
        "        self.add(graphs[2])\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class TerminologyFromPolyhedra(GraphScene):\n",
        "    args_list = [(CubeGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        rot_kwargs = {\n",
        "            \"radians\" : np.pi / 3,\n",
        "            \"run_time\" : 5.0\n",
        "        }\n",
        "        vertices = [\n",
        "            point / 2 + OUT if abs(point[0]) == 2 else point + IN\n",
        "            for point in self.points\n",
        "        ]\n",
        "        cube = Mobject(*[\n",
        "            Line(vertices[edge[0]], vertices[edge[1]])\n",
        "            for edge in self.graph.edges\n",
        "        ])\n",
        "        cube.rotate(-np.pi/3, [0, 0, 1])\n",
        "        cube.rotate(-np.pi/3, [0, 1, 0])\n",
        "        dots_to_vertices = OldTexText(\"Dots $\\\\to$ Vertices\").to_corner()\n",
        "        lines_to_edges = OldTexText(\"Lines $\\\\to$ Edges\").to_corner()\n",
        "        regions_to_faces = OldTexText(\"Regions $\\\\to$ Faces\").to_corner()\n",
        "        \n",
        "        self.clear()\n",
        "        # self.play(TransformAnimations(\n",
        "        #     Rotating(Dodecahedron(), **rot_kwargs),\n",
        "        #     Rotating(cube, **rot_kwargs)  \n",
        "        # ))\n",
        "        self.play(Rotating(cube, **rot_kwargs))\n",
        "        self.clear()\n",
        "        self.play(*[\n",
        "            Transform(l1, l2)\n",
        "            for l1, l2 in zip(cube.split(), self.edges)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.add(dots_to_vertices)\n",
        "        self.play(*[\n",
        "            ShowCreation(dot, run_time = 1.0)\n",
        "            for dot in self.vertices\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.remove(dots_to_vertices, *self.vertices)\n",
        "        self.add(lines_to_edges)\n",
        "        self.play(ApplyMethod(\n",
        "            Mobject(*self.edges).set_color, \"yellow\"\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.clear()\n",
        "        self.add(*self.edges)\n",
        "        self.add(regions_to_faces)\n",
        "        self.generate_regions()\n",
        "        for region in self.regions:\n",
        "            self.set_color_region(region)\n",
        "        self.wait(3.0)\n",
        "\n",
        "\n",
        "class ThreePiecesOfTerminology(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        terms = cycles, spanning_trees, dual_graphs = [\n",
        "            OldTexText(phrase).shift(y*UP).to_edge()\n",
        "            for phrase, y in [\n",
        "                (\"Cycles\", 3),\n",
        "                (\"Spanning Trees\", 1),\n",
        "                (\"Dual Graphs\", -1),\n",
        "            ]\n",
        "        ]\n",
        "        self.generate_spanning_tree()\n",
        "        scale_factor = 1.2       \n",
        "        def accent(mobject, color = \"yellow\"):\n",
        "            return mobject.scale(scale_factor).set_color(color)\n",
        "        def tone_down(mobject):\n",
        "            return mobject.scale(1.0/scale_factor).set_color(\"white\")\n",
        "\n",
        "        self.add(accent(cycles))\n",
        "        self.trace_cycle(run_time = 1.0)\n",
        "        self.wait()\n",
        "        tone_down(cycles)\n",
        "        self.remove(self.traced_cycle)\n",
        "\n",
        "        self.add(accent(spanning_trees))\n",
        "        self.play(ShowCreation(self.spanning_tree), run_time = 1.0)\n",
        "        self.wait()\n",
        "        tone_down(spanning_trees)\n",
        "        self.remove(self.spanning_tree)\n",
        "\n",
        "        self.add(accent(dual_graphs, \"red\"))\n",
        "        self.generate_dual_graph()\n",
        "        for mob in self.mobjects:\n",
        "            mob.fade\n",
        "        self.play(*[\n",
        "            ShowCreation(mob, run_time = 1.0)\n",
        "            for mob in self.dual_vertices + self.dual_edges\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.clear()\n",
        "        self.play(ApplyMethod(\n",
        "            Mobject(*terms).center\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class WalkingRandolph(GraphScene):\n",
        "    args_list = [\n",
        "        (SampleGraph(), [0, 1, 7, 8]),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(graph, path):\n",
        "        return str(graph) + \"\".join(map(str, path))\n",
        "\n",
        "    def __init__(self, graph, path, *args, **kwargs):\n",
        "        self.path = path\n",
        "        GraphScene.__init__(self, graph, *args, **kwargs)\n",
        "\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        point_path = [self.get_points()[i] for i in self.path]\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDOLPH_SCALE_FACTOR)\n",
        "        randy.move_to(point_path[0])\n",
        "        for next, last in zip(point_path[1:], point_path):\n",
        "            self.play(\n",
        "                WalkPiCreature(randy, next),\n",
        "                ShowCreation(Line(last, next).set_color(\"yellow\")),\n",
        "                run_time = 2.0\n",
        "            )\n",
        "        self.randy = randy\n",
        "\n",
        "\n",
        "class PathExamples(GraphScene):\n",
        "    args_list = [(SampleGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        paths = [\n",
        "            (1, 2, 4, 5, 6),\n",
        "            (6, 7, 1, 3),\n",
        "        ]\n",
        "        non_paths = [\n",
        "            [(0, 1), (7, 8), (5, 6),],\n",
        "            [(5, 0), (0, 2), (0, 1)],\n",
        "        ]\n",
        "        valid_path = OldTexText(\"Valid \\\\\\\\ Path\").set_color(\"green\")\n",
        "        not_a_path = OldTexText(\"Not a \\\\\\\\ Path\").set_color(\"red\")\n",
        "        for mob in valid_path, not_a_path:\n",
        "            mob.to_edge(UP)\n",
        "        kwargs = {\"run_time\" : 1.0}\n",
        "        for path, non_path in zip(paths, non_paths):\n",
        "            path_lines = Mobject(*[\n",
        "                Line(\n",
        "                    self.get_points()[path[i]], \n",
        "                    self.get_points()[path[i+1]]\n",
        "                ).set_color(\"yellow\")\n",
        "                for i in range(len(path) - 1)\n",
        "            ])\n",
        "            non_path_lines = Mobject(*[\n",
        "                Line(\n",
        "                    self.get_points()[pp[0]],\n",
        "                    self.get_points()[pp[1]],\n",
        "                ).set_color(\"yellow\")\n",
        "                for pp in non_path\n",
        "            ])\n",
        "\n",
        "            self.remove(not_a_path)\n",
        "            self.add(valid_path)\n",
        "            self.play(ShowCreation(path_lines, **kwargs))\n",
        "            self.wait(2)\n",
        "            self.remove(path_lines)\n",
        "\n",
        "            self.remove(valid_path)\n",
        "            self.add(not_a_path)\n",
        "            self.play(ShowCreation(non_path_lines, **kwargs))\n",
        "            self.wait(2)\n",
        "            self.remove(non_path_lines)\n",
        "\n",
        "class IntroduceCycle(WalkingRandolph):\n",
        "    args_list = [\n",
        "        (SampleGraph(), [0, 1, 3, 2, 0])\n",
        "    ]\n",
        "    def construct(self):\n",
        "        WalkingRandolph.construct(self)\n",
        "        self.remove(self.randy)\n",
        "        encompassed_cycles = [c for c in self.graph.region_cycles if set(c).issubset(self.path)]\n",
        "        regions = [\n",
        "            self.region_from_cycle(cycle)\n",
        "            for cycle in encompassed_cycles\n",
        "        ]\n",
        "        for region in regions:\n",
        "            self.set_color_region(region)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class IntroduceRandolph(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        randy = Randolph().move_to((-3, 0, 0))\n",
        "        name = OldTexText(\"Randolph\")\n",
        "        self.play(Transform(\n",
        "            randy,\n",
        "            deepcopy(randy).scale(RANDOLPH_SCALE_FACTOR).move_to(self.get_points()[0]),\n",
        "        ))\n",
        "        self.wait()\n",
        "        name.shift((0, 1, 0))\n",
        "        self.add(name)\n",
        "        self.wait()\n",
        "\n",
        "class DefineSpanningTree(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDOLPH_SCALE_FACTOR).move_to(self.get_points()[0])\n",
        "        dollar_signs = OldTexText(\"\\\\$\\\\$\")\n",
        "        dollar_signs.scale(EDGE_ANNOTATION_SCALE_FACTOR)\n",
        "        dollar_signs = Mobject(*[\n",
        "            deepcopy(dollar_signs).shift(edge.get_center())\n",
        "            for edge in self.edges\n",
        "        ])\n",
        "        unneeded = OldTexText(\"unneeded!\")\n",
        "        unneeded.scale(EDGE_ANNOTATION_SCALE_FACTOR)\n",
        "        self.generate_spanning_tree()\n",
        "        def green_dot_at_index(index):\n",
        "            return Dot(\n",
        "                self.get_points()[index], \n",
        "                radius = 2*Dot.DEFAULT_RADIUS,\n",
        "                color = \"lightgreen\",\n",
        "            )\n",
        "        def out_of_spanning_set(point_pair):\n",
        "            stip = self.spanning_tree_index_pairs\n",
        "            return point_pair not in stip and \\\n",
        "                   tuple(reversed(point_pair)) not in stip\n",
        "        \n",
        "        self.add(randy)\n",
        "        self.accent_vertices(run_time = 2.0)\n",
        "        self.add(dollar_signs)\n",
        "        self.wait(2)\n",
        "        self.remove(dollar_signs)\n",
        "        run_time_per_branch = 0.5        \n",
        "        self.play(\n",
        "            ShowCreation(green_dot_at_index(0)),\n",
        "            run_time = run_time_per_branch\n",
        "        )\n",
        "        for pair in self.spanning_tree_index_pairs:\n",
        "            self.play(ShowCreation(\n",
        "                Line(\n",
        "                    self.get_points()[pair[0]], \n",
        "                    self.get_points()[pair[1]]\n",
        "                ).set_color(\"yellow\"),\n",
        "                run_time = run_time_per_branch\n",
        "            ))\n",
        "            self.play(ShowCreation(\n",
        "                green_dot_at_index(pair[1]),\n",
        "                run_time = run_time_per_branch\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "        unneeded_edges = list(filter(out_of_spanning_set, self.graph.edges))\n",
        "        for edge, limit in zip(unneeded_edges, list(range(5))):\n",
        "            line = Line(self.get_points()[edge[0]], self.get_points()[edge[1]])\n",
        "            line.set_color(\"red\")\n",
        "            self.play(ShowCreation(line, run_time = 1.0))\n",
        "            self.add(unneeded.center().shift(line.get_center() + 0.2*UP))\n",
        "            self.wait()\n",
        "            self.remove(line, unneeded)\n",
        "\n",
        "class NamingTree(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_spanning_tree()\n",
        "        self.generate_treeified_spanning_tree()\n",
        "        branches = self.spanning_tree.split()\n",
        "        branches_copy = deepcopy(branches)\n",
        "        treeified_branches = self.treeified_spanning_tree.split()\n",
        "        tree = OldTexText(\"``Tree''\").to_edge(UP)\n",
        "        spanning_tree = OldTexText(\"``Spanning Tree''\").to_edge(UP)\n",
        "\n",
        "        self.add(*branches)\n",
        "        self.play(\n",
        "            FadeOut(Mobject(*self.edges + self.vertices)),\n",
        "            Animation(Mobject(*branches)),\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(tree, *branches)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(b1, b2, run_time = 2)\n",
        "            for b1, b2 in zip(branches, treeified_branches)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            FadeIn(mob)\n",
        "            for mob in self.edges + self.vertices\n",
        "        ] + [\n",
        "            Transform(b1, b2, run_time = 2)\n",
        "            for b1, b2 in zip(branches, branches_copy)\n",
        "        ])\n",
        "        self.accent_vertices(run_time = 2)\n",
        "        self.remove(tree)\n",
        "        self.add(spanning_tree)\n",
        "        self.wait(2)\n",
        "\n",
        "class DualGraph(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "        self.add(OldTexText(\"Dual Graph\").to_edge(UP).shift(2*LEFT))\n",
        "        self.play(*[\n",
        "            ShowCreation(mob)\n",
        "            for mob in self.dual_edges + self.dual_vertices\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class FacebookLogo(Scene):\n",
        "    def construct(self):\n",
        "        im = ImageMobject(\"facebook_full_logo\", invert = False)\n",
        "        self.add(im.scale(0.7))\n",
        "\n",
        "\n",
        "class FacebookGraph(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        account = ImageMobject(\"facebook_silhouette\", invert = False)\n",
        "        account.scale(0.05)\n",
        "        logo = ImageMobject(\"facebook_logo\", invert = False)\n",
        "        logo.scale(0.1)\n",
        "        logo.shift(0.2*LEFT + 0.1*UP)\n",
        "        account.add(logo).center()\n",
        "        account.shift(0.2*LEFT + 0.1*UP)\n",
        "        friends = OldTex(\n",
        "            \"\\\\leftarrow \\\\text{friends} \\\\rightarrow\"\n",
        "        ).scale(0.5*EDGE_ANNOTATION_SCALE_FACTOR)\n",
        "\n",
        "        self.clear()\n",
        "        accounts = [\n",
        "            deepcopy(account).shift(point)\n",
        "            for point in self.points\n",
        "        ]\n",
        "        self.add(*accounts)\n",
        "        self.wait()\n",
        "        self.annotate_edges(friends)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            CounterclockwiseTransform(account, vertex)\n",
        "            for account, vertex in zip(accounts, self.vertices)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(ann, edge)\n",
        "            for ann, edge in zip(self.edge_annotations, self.edges)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class FacebookGraphAsAbstractSet(Scene):\n",
        "    def construct(self):\n",
        "        names = [\n",
        "            \"Louis\",\n",
        "            \"Randolph\",\n",
        "            \"Mortimer\",\n",
        "            \"Billy Ray\",\n",
        "            \"Penelope\",\n",
        "        ]\n",
        "        friend_pairs = [\n",
        "            (0, 1),\n",
        "            (0, 2),\n",
        "            (1, 2),\n",
        "            (3, 0),\n",
        "            (4, 0),\n",
        "            (1, 3),\n",
        "            (1, 2),\n",
        "        ]\n",
        "        names_string = \"\\\\\\\\\".join(names + [\"$\\\\vdots$\"])\n",
        "        friends_string = \"\\\\\\\\\".join([\n",
        "            \"\\\\text{%s}&\\\\leftrightarrow\\\\text{%s}\"%(names[i],names[j])\n",
        "            for i, j in friend_pairs\n",
        "        ] + [\"\\\\vdots\"])\n",
        "        names_mob = OldTexText(names_string).shift(3*LEFT)\n",
        "        friends_mob = OldTex(\n",
        "            friends_string, size = \"\\\\Large\"\n",
        "        ).shift(3*RIGHT)\n",
        "        accounts = OldTexText(\"\\\\textbf{Accounts}\")\n",
        "        accounts.shift(3*LEFT).to_edge(UP)\n",
        "        friendships = OldTexText(\"\\\\textbf{Friendships}\")\n",
        "        friendships.shift(3*RIGHT).to_edge(UP)\n",
        "        lines = Mobject(\n",
        "            Line(UP*FRAME_Y_RADIUS, DOWN*FRAME_Y_RADIUS),\n",
        "            Line(LEFT*FRAME_X_RADIUS + 3*UP, RIGHT*FRAME_X_RADIUS + 3*UP)\n",
        "        ).set_color(\"white\")\n",
        "\n",
        "        self.add(accounts, friendships, lines)\n",
        "        self.wait()\n",
        "        for mob in names_mob, friends_mob:\n",
        "            self.play(ShowCreation(\n",
        "                mob, run_time = 1.0\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExamplesOfGraphs(GraphScene):\n",
        "    def construct(self):\n",
        "        buff = 0.5\n",
        "        self.graph.vertices = [v + DOWN + RIGHT for v in self.graph.vertices]\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_regions()\n",
        "        objects, notions = Mobject(*TexText(\n",
        "            [\"Objects \\\\quad\\\\quad \", \"Thing that connects objects\"]\n",
        "        )).to_corner().shift(0.5*RIGHT).split()\n",
        "        horizontal_line = Line(\n",
        "            (-FRAME_X_RADIUS, FRAME_Y_RADIUS-1, 0),\n",
        "            (max(notions.get_points()[:,0]), FRAME_Y_RADIUS-1, 0)\n",
        "        )\n",
        "        vert_line_x_val = min(notions.get_points()[:,0]) - buff\n",
        "        vertical_line = Line(\n",
        "            (vert_line_x_val, FRAME_Y_RADIUS, 0),\n",
        "            (vert_line_x_val,-FRAME_Y_RADIUS, 0)\n",
        "        )\n",
        "        objects_and_notions = [\n",
        "            (\"Facebook accounts\", \"Friendship\"),\n",
        "            (\"English Words\", \"Differ by One Letter\"),\n",
        "            (\"Mathematicians\", \"Coauthorship\"),\n",
        "            (\"Neurons\", \"Synapses\"),\n",
        "            (\n",
        "                \"Regions our graph \\\\\\\\ cuts the plane into\",\n",
        "                \"Shared edges\"\n",
        "            )\n",
        "        ]\n",
        "\n",
        "\n",
        "        self.clear()\n",
        "        self.add(objects, notions, horizontal_line, vertical_line)\n",
        "        for (obj, notion), height in zip(objects_and_notions, it.count(2, -1)):\n",
        "            obj_mob = OldTexText(obj, size = \"\\\\small\").to_edge(LEFT)\n",
        "            not_mob = OldTexText(notion, size = \"\\\\small\").to_edge(LEFT)\n",
        "            not_mob.shift((vert_line_x_val + FRAME_X_RADIUS)*RIGHT)\n",
        "            obj_mob.shift(height*UP)\n",
        "            not_mob.shift(height*UP)\n",
        "\n",
        "            if obj.startswith(\"Regions\"):\n",
        "                self.handle_dual_graph(obj_mob, not_mob)\n",
        "            elif obj.startswith(\"English\"):\n",
        "                self.handle_english_words(obj_mob, not_mob)\n",
        "            else:\n",
        "                self.add(obj_mob)\n",
        "                self.wait()\n",
        "                self.add(not_mob)\n",
        "                self.wait()\n",
        "\n",
        "    def handle_english_words(self, words1, words2):\n",
        "        words = list(map(TexText, [\"graph\", \"grape\", \"gape\", \"gripe\"]))\n",
        "        words[0].shift(RIGHT)\n",
        "        words[1].shift(3*RIGHT)\n",
        "        words[2].shift(3*RIGHT + 2*UP)\n",
        "        words[3].shift(3*RIGHT + 2*DOWN)\n",
        "        lines = [\n",
        "            Line(*pair)\n",
        "            for pair in [\n",
        "                (\n",
        "                    words[0].get_center() + RIGHT*words[0].get_width()/2,\n",
        "                    words[1].get_center() + LEFT*words[1].get_width()/2\n",
        "                ),(\n",
        "                    words[1].get_center() + UP*words[1].get_height()/2,\n",
        "                    words[2].get_center() + DOWN*words[2].get_height()/2\n",
        "                ),(\n",
        "                    words[1].get_center() + DOWN*words[1].get_height()/2,\n",
        "                    words[3].get_center() + UP*words[3].get_height()/2\n",
        "                )\n",
        "            ]\n",
        "        ]\n",
        "\n",
        "        comp_words = Mobject(*words)\n",
        "        comp_lines = Mobject(*lines)\n",
        "        self.add(words1)\n",
        "        self.play(ShowCreation(comp_words, run_time = 1.0))\n",
        "        self.wait()\n",
        "        self.add(words2)\n",
        "        self.play(ShowCreation(comp_lines, run_time = 1.0))\n",
        "        self.wait()\n",
        "        self.remove(comp_words, comp_lines)\n",
        "\n",
        "\n",
        "    def handle_dual_graph(self, words1, words2):\n",
        "        words1.set_color(\"yellow\")\n",
        "        words2.set_color(\"yellow\")\n",
        "        connected = OldTexText(\"Connected\")\n",
        "        connected.set_color(\"lightgreen\")\n",
        "        not_connected = OldTexText(\"Not Connected\")\n",
        "        not_connected.set_color(\"red\")\n",
        "        for mob in connected, not_connected:\n",
        "            mob.shift(self.get_points()[3] + UP)\n",
        "\n",
        "        self.play(*[\n",
        "            ShowCreation(mob, run_time = 1.0)\n",
        "            for mob in self.edges + self.vertices\n",
        "        ])\n",
        "        self.wait()\n",
        "        for region in self.regions:\n",
        "            self.set_color_region(region)\n",
        "        self.add(words1)\n",
        "        self.wait()\n",
        "        self.reset_background()\n",
        "        self.add(words2)\n",
        "\n",
        "        region_pairs = it.combinations(self.graph.region_cycles, 2)\n",
        "        for x in range(6):\n",
        "            want_matching = (x%2 == 0)\n",
        "            found = False\n",
        "            while True:\n",
        "                try:\n",
        "                    cycle1, cycle2 = next(region_pairs)\n",
        "                except:\n",
        "                    return\n",
        "                shared = set(cycle1).intersection(cycle2)\n",
        "                if len(shared) == 2 and want_matching:\n",
        "                    break\n",
        "                if len(shared) != 2 and not want_matching:\n",
        "                    break\n",
        "            for cycle in cycle1, cycle2:\n",
        "                index = self.graph.region_cycles.index(cycle)\n",
        "                self.set_color_region(self.regions[index])\n",
        "            if want_matching:\n",
        "                self.remove(not_connected)\n",
        "                self.add(connected)\n",
        "                tup = tuple(shared)\n",
        "                if tup not in self.graph.edges:\n",
        "                    tup = tuple(reversed(tup))\n",
        "                edge = deepcopy(self.edges[self.graph.edges.index(tup)])\n",
        "                edge.set_color(\"red\")\n",
        "                self.play(ShowCreation(edge), run_time = 1.0)\n",
        "                self.wait()\n",
        "                self.remove(edge)\n",
        "            else:\n",
        "                self.remove(connected)\n",
        "                self.add(not_connected)\n",
        "                self.wait(2)\n",
        "            self.reset_background()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class DrawDualGraph(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_regions()\n",
        "        self.generate_dual_graph()\n",
        "        region_mobs = [\n",
        "            ImageMobject(disp.paint_region(reg, self.background), invert = False)\n",
        "            for reg in self.regions\n",
        "        ]\n",
        "        for region, mob in zip(self.regions, region_mobs):\n",
        "            self.set_color_region(region, mob.get_color())\n",
        "        outer_region      = self.regions.pop()\n",
        "        outer_region_mob  = region_mobs.pop()\n",
        "        outer_dual_vertex = self.dual_vertices.pop()\n",
        "        internal_edges = [e for e in self.dual_edges if abs(e.start[0]) < FRAME_X_RADIUS and \\\n",
        "                       abs(e.end[0]) < FRAME_X_RADIUS and \\\n",
        "                       abs(e.start[1]) < FRAME_Y_RADIUS and \\\n",
        "                       abs(e.end[1]) < FRAME_Y_RADIUS]\n",
        "        external_edges = [e for e in self.dual_edges if e not in internal_edges]\n",
        "\n",
        "        self.wait()\n",
        "        self.reset_background()\n",
        "        self.set_color_region(outer_region, outer_region_mob.get_color())\n",
        "        self.play(*[\n",
        "            Transform(reg_mob, dot)\n",
        "            for reg_mob, dot in zip(region_mobs, self.dual_vertices)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.reset_background()\n",
        "        self.play(ApplyFunction(\n",
        "            lambda p : (FRAME_X_RADIUS + FRAME_Y_RADIUS)*p/get_norm(p),\n",
        "            outer_region_mob\n",
        "        ))\n",
        "        self.wait()\n",
        "        for edges in internal_edges, external_edges:\n",
        "            self.play(*[\n",
        "                ShowCreation(edge, run_time = 2.0)\n",
        "                for edge in edges\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "class EdgesAreTheSame(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "        self.remove(*self.vertices)\n",
        "        self.add(*self.dual_edges)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair, run_time = 2.0)\n",
        "            for pair in zip(self.dual_edges, self.edges)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.add(\n",
        "            OldTexText(\"\"\"\n",
        "                (Or at least I would argue they should \\\\\\\\\n",
        "                be thought of as the same thing.)\n",
        "            \"\"\", size = \"\\\\small\").to_edge(UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ListOfCorrespondances(Scene):\n",
        "    def construct(self):\n",
        "        buff = 0.5\n",
        "        correspondances = [\n",
        "            [\"Regions cut out by\", \"Vertices of\"],\n",
        "            [\"Edges of\", \"Edges of\"],\n",
        "            [\"Cycles of\", \"Connected components of\"],\n",
        "            [\"Connected components of\", \"Cycles of\"],\n",
        "            [\"Spanning tree in\", \"Complement of spanning tree in\"],\n",
        "            [\"\", \"Dual of\"],\n",
        "        ]\n",
        "        for corr in correspondances:\n",
        "            corr[0] += \" original graph\"\n",
        "            corr[1] += \" dual graph\"\n",
        "        arrow = OldTex(\"\\\\leftrightarrow\", size = \"\\\\large\")\n",
        "        lines = []\n",
        "        for corr, height in zip(correspondances, it.count(3, -1)):\n",
        "            left  = OldTexText(corr[0], size = \"\\\\small\")\n",
        "            right = OldTexText(corr[1], size = \"\\\\small\")\n",
        "            this_arrow = deepcopy(arrow)\n",
        "            for mob in left, right, this_arrow:\n",
        "                mob.shift(height*UP)\n",
        "            arrow_xs = this_arrow.get_points()[:,0]\n",
        "            left.to_edge(RIGHT)\n",
        "            left.shift((min(arrow_xs) - FRAME_X_RADIUS, 0, 0))\n",
        "            right.to_edge(LEFT)\n",
        "            right.shift((max(arrow_xs) + FRAME_X_RADIUS, 0, 0))\n",
        "            lines.append(Mobject(left, right, this_arrow))\n",
        "        last = None\n",
        "        for line in lines:\n",
        "            self.add(line.set_color(\"yellow\"))\n",
        "            if last:\n",
        "                last.set_color(\"white\")\n",
        "            last = line\n",
        "            self.wait(1)\n",
        "\n",
        "\n",
        "class CyclesCorrespondWithConnectedComponents(GraphScene):\n",
        "    args_list = [(SampleGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_regions()\n",
        "        self.generate_dual_graph()\n",
        "        cycle = [4, 2, 1, 5, 4]\n",
        "        enclosed_regions = [0, 2, 3, 4]\n",
        "        dual_cycle = DUAL_CYCLE\n",
        "        enclosed_vertices = [0, 1]\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDOLPH_SCALE_FACTOR)\n",
        "        randy.move_to(self.get_points()[cycle[0]])\n",
        "\n",
        "        lines_to_remove = []\n",
        "        for last, next in zip(cycle, cycle[1:]):\n",
        "            line = Line(self.get_points()[last], self.get_points()[next])\n",
        "            line.set_color(\"yellow\")\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                WalkPiCreature(randy, self.get_points()[next]),\n",
        "                run_time = 1.0\n",
        "            )\n",
        "            lines_to_remove.append(line)\n",
        "        self.wait()\n",
        "        self.remove(randy, *lines_to_remove)\n",
        "        for region in np.array(self.regions)[enclosed_regions]:\n",
        "            self.set_color_region(region)\n",
        "        self.wait(2)\n",
        "        self.reset_background()\n",
        "        lines = Mobject(*[\n",
        "            Line(self.dual_points[last], self.dual_points[next])\n",
        "            for last, next in zip(dual_cycle, dual_cycle[1:])\n",
        "        ]).set_color(\"red\")\n",
        "        self.play(ShowCreation(lines))\n",
        "        self.play(*[\n",
        "            Transform(v, Dot(\n",
        "                v.get_center(), \n",
        "                radius = 3*Dot.DEFAULT_RADIUS\n",
        "            ).set_color(\"green\"))\n",
        "            for v in np.array(self.vertices)[enclosed_vertices]\n",
        "        ] + [\n",
        "            ApplyMethod(self.edges[0].set_color, \"green\")\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        \n",
        "class IntroduceMortimer(GraphScene):\n",
        "    args_list = [(SampleGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "        self.generate_regions()\n",
        "        randy = Randolph().shift(LEFT)\n",
        "        morty = Mortimer().shift(RIGHT)\n",
        "        name = OldTexText(\"Mortimer\")\n",
        "        name.shift(morty.get_center() + 1.2*UP)\n",
        "        randy_path = (0, 1, 3)\n",
        "        morty_path = (-2, -3, -4)\n",
        "        morty_crossed_lines = [\n",
        "            Line(self.get_points()[i], self.get_points()[j]).set_color(\"red\")\n",
        "            for i, j in [(7, 1), (1, 5)]\n",
        "        ]\n",
        "        kwargs = {\"run_time\" : 1.0}\n",
        "\n",
        "        self.clear()\n",
        "        self.add(randy)\n",
        "        self.wait()\n",
        "        self.add(morty, name)\n",
        "        self.wait()\n",
        "        self.remove(name)\n",
        "        small_randy = deepcopy(randy).scale(RANDOLPH_SCALE_FACTOR)\n",
        "        small_morty = deepcopy(morty).scale(RANDOLPH_SCALE_FACTOR)\n",
        "        small_randy.move_to(self.get_points()[randy_path[0]])\n",
        "        small_morty.move_to(self.dual_points[morty_path[0]])\n",
        "        self.play(*[\n",
        "            FadeIn(mob)\n",
        "            for mob in self.vertices + self.edges\n",
        "        ] + [\n",
        "            Transform(randy, small_randy),\n",
        "            Transform(morty, small_morty),\n",
        "        ], **kwargs)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        self.set_color_region(self.regions[morty_path[0]])\n",
        "        for last, next in zip(morty_path, morty_path[1:]):\n",
        "            self.play(WalkPiCreature(morty, self.dual_points[next]),**kwargs)\n",
        "            self.set_color_region(self.regions[next])\n",
        "        self.wait()\n",
        "        for last, next in zip(randy_path, randy_path[1:]):\n",
        "            line = Line(self.get_points()[last], self.get_points()[next])\n",
        "            line.set_color(\"yellow\")\n",
        "            self.play(\n",
        "                WalkPiCreature(randy, self.get_points()[next]),\n",
        "                ShowCreation(line),\n",
        "                **kwargs\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                line.rotate, \n",
        "                np.pi/10, \n",
        "                rate_func = wiggle) \n",
        "            for line in morty_crossed_lines\n",
        "        ], **kwargs)\n",
        "        \n",
        "        self.wait()\n",
        "\n",
        "class RandolphMortimerSpanningTreeGame(GraphScene):\n",
        "    args_list = [(SampleGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_spanning_tree()\n",
        "        self.generate_dual_graph()\n",
        "        self.generate_regions()\n",
        "        randy = Randolph().scale(RANDOLPH_SCALE_FACTOR)\n",
        "        morty = Mortimer().scale(RANDOLPH_SCALE_FACTOR)\n",
        "        randy.move_to(self.get_points()[0])\n",
        "        morty.move_to(self.dual_points[0])\n",
        "        attempted_dual_point_index = 2\n",
        "        region_ordering = [0, 1, 7, 2, 3, 5, 4, 6]\n",
        "        dual_edges = [1, 3, 4, 7, 11, 9, 13]\n",
        "        time_per_dual_edge = 0.5\n",
        "\n",
        "        self.add(randy, morty)\n",
        "        self.play(ShowCreation(self.spanning_tree))\n",
        "        self.wait()\n",
        "        self.play(WalkPiCreature(\n",
        "            morty, self.dual_points[attempted_dual_point_index],\n",
        "            rate_func = lambda t : 0.3 * there_and_back(t),\n",
        "            run_time = 2.0,\n",
        "        ))\n",
        "        self.wait()\n",
        "        for index in range(len(self.regions)):\n",
        "            # if index > 0:\n",
        "            #     edge = self.edges[dual_edges[index-1]]\n",
        "            #     midpoint = edge.get_center()\n",
        "            #     self.play(*[\n",
        "            #         ShowCreation(Line(\n",
        "            #             midpoint,\n",
        "            #             tip\n",
        "            #         ).set_color(\"red\"))\n",
        "            #         for tip in edge.start, edge.end\n",
        "            #     ], run_time = time_per_dual_edge)\n",
        "            self.set_color_region(self.regions[region_ordering[index]])\n",
        "            self.wait(time_per_dual_edge)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        cycle_index = region_ordering[-1]\n",
        "        cycle = self.graph.region_cycles[cycle_index]\n",
        "        self.set_color_region(self.regions[cycle_index], \"black\")\n",
        "        self.play(ShowCreation(Mobject(*[\n",
        "            Line(self.get_points()[last], self.get_points()[next]).set_color(\"green\")\n",
        "            for last, next in zip(cycle, list(cycle)[1:] + [cycle[0]])\n",
        "        ])))\n",
        "        self.wait()\n",
        "\n",
        "class MortimerCannotTraverseCycle(GraphScene):\n",
        "    args_list = [(SampleGraph(),)]\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "        dual_cycle = DUAL_CYCLE\n",
        "        trapped_points = [0, 1]\n",
        "        morty = Mortimer().scale(RANDOLPH_SCALE_FACTOR)\n",
        "        morty.move_to(self.dual_points[dual_cycle[0]])\n",
        "        time_per_edge = 0.5\n",
        "        text = OldTexText(\"\"\"\n",
        "            One of these lines must be included\n",
        "            in the spanning tree if those two inner\n",
        "            vertices are to be reached.\n",
        "        \"\"\").scale(0.7).to_edge(UP)\n",
        "\n",
        "        all_lines = []\n",
        "        matching_edges = []\n",
        "        kwargs = {\"run_time\" : time_per_edge, \"rate_func\" : None}\n",
        "        for last, next in zip(dual_cycle, dual_cycle[1:]):\n",
        "            line = Line(self.dual_points[last], self.dual_points[next])\n",
        "            line.set_color(\"red\")\n",
        "            self.play(\n",
        "                WalkPiCreature(morty, self.dual_points[next], **kwargs),\n",
        "                ShowCreation(line, **kwargs),\n",
        "            )\n",
        "            all_lines.append(line)\n",
        "            center = line.get_center()\n",
        "            distances = [get_norm(center - e.get_center()) for e in self.edges]\n",
        "            matching_edges.append(\n",
        "                self.edges[distances.index(min(distances))]\n",
        "            )\n",
        "        self.play(*[\n",
        "            Transform(v, Dot(\n",
        "                v.get_center(), \n",
        "                radius = 3*Dot.DEFAULT_RADIUS,\n",
        "                color = \"green\"\n",
        "            ))\n",
        "            for v in np.array(self.vertices)[trapped_points]\n",
        "        ])\n",
        "        self.add(text)\n",
        "        self.play(*[\n",
        "            Transform(line, deepcopy(edge).set_color(line.get_color()))\n",
        "            for line, edge in zip(all_lines, matching_edges)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class TwoPropertiesOfSpanningTree(Scene):\n",
        "    def construct(self):\n",
        "        spanning, tree = OldTexText(\n",
        "            [\"Spanning \", \"Tree\"], \n",
        "            size = \"\\\\Huge\"\n",
        "        ).split()\n",
        "        spanning_explanation = OldTexText(\"\"\"\n",
        "            Touches every vertex\n",
        "        \"\"\").shift(spanning.get_center() + 2*DOWN)\n",
        "        tree_explanation = OldTexText(\"\"\"\n",
        "            No Cycles\n",
        "        \"\"\").shift(tree.get_center() + 2*UP)\n",
        "\n",
        "        self.add(spanning, tree)\n",
        "        self.wait()\n",
        "        for word, explanation, vect in [\n",
        "            (spanning, spanning_explanation, 0.5*UP),\n",
        "            (tree, tree_explanation, 0.5*DOWN)\n",
        "            ]:\n",
        "            self.add(explanation)\n",
        "            self.add(Arrow(\n",
        "                explanation.get_center() + vect,\n",
        "                tail = word.get_center() - vect,\n",
        "            ))\n",
        "            self.play(ApplyMethod(word.set_color, \"yellow\"))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class DualSpanningTree(GraphScene):\n",
        "    def construct(self):\n",
        "        GraphScene.construct(self)\n",
        "        self.generate_dual_graph()\n",
        "        self.generate_spanning_tree()\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDOLPH_SCALE_FACTOR)\n",
        "        randy.move_to(self.get_points()[0])\n",
        "        morty = Mortimer()\n",
        "        morty.scale(RANDOLPH_SCALE_FACTOR)\n",
        "        morty.move_to(self.dual_points[0])\n",
        "        dual_edges = [1, 3, 4, 7, 11, 9, 13]\n",
        "        words = OldTexText(\"\"\"\n",
        "            The red edges form a spanning tree of the dual graph!\n",
        "        \"\"\").to_edge(UP)\n",
        "\n",
        "        self.add(self.spanning_tree, randy, morty)\n",
        "        self.play(ShowCreation(Mobject(\n",
        "            *np.array(self.edges)[dual_edges]\n",
        "        ).set_color(\"red\")))\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "\n",
        "class TreeCountFormula(Scene):\n",
        "    def construct(self):\n",
        "        time_per_branch = 0.5\n",
        "        text = OldTexText(\"\"\"\n",
        "            In any tree:\n",
        "            $$E + 1 = V$$\n",
        "        \"\"\")\n",
        "        gs = GraphScene(SampleGraph())\n",
        "        gs.generate_treeified_spanning_tree()\n",
        "        branches = gs.treeified_spanning_tree.to_edge(LEFT).split()\n",
        "\n",
        "        all_dots = [Dot(branches[0].get_points()[0])]\n",
        "        self.add(text, all_dots[0])\n",
        "        for branch in branches:\n",
        "            self.play(\n",
        "                ShowCreation(branch), \n",
        "                run_time = time_per_branch\n",
        "            )\n",
        "            dot = Dot(branch.get_points()[-1])\n",
        "            self.add(dot)\n",
        "            all_dots.append(dot)\n",
        "        self.wait()\n",
        "        self.remove(*all_dots)\n",
        "        self.play(\n",
        "            FadeOut(text), \n",
        "            FadeIn(Mobject(*gs.edges + gs.vertices)),\n",
        "            *[\n",
        "                Transform(*pair)\n",
        "                for pair in zip(branches,gs.spanning_tree.split())\n",
        "            ]\n",
        "        )\n",
        "\n",
        "\n",
        "class FinalSum(Scene):\n",
        "    def construct(self):\n",
        "        lines = OldTex([\n",
        "            \"(\\\\text{Number of Randolph's Edges}) + 1 &= V \\\\\\\\ \\n\",\n",
        "            \"(\\\\text{Number of Mortimer's Edges}) + 1 &= F \\\\\\\\ \\n\",\n",
        "            \" \\\\Downarrow \\\\\\\\\", \"E\",\"+\",\"2\",\"&=\",\"V\",\"+\",\"F\",\n",
        "        ], size = \"\\\\large\").split()\n",
        "        for line in lines[:2] + [Mobject(*lines[2:])]:\n",
        "            self.add(line)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        symbols = V, minus, E, plus, F, equals, two = OldTex(\n",
        "            \"V - E + F = 2\".split(\" \")\n",
        "        )\n",
        "        plus = OldTex(\"+\")\n",
        "        anims = []\n",
        "        for mob, index in zip(symbols, [-3, -2, -7, -6, -1, -4, -5]):\n",
        "            copy = plus if index == -2 else deepcopy(mob)\n",
        "            copy.center().shift(lines[index].get_center())\n",
        "            copy.scale(lines[index].get_width()/mob.get_width())\n",
        "            anims.append(CounterclockwiseTransform(copy, mob))\n",
        "        self.clear()\n",
        "        self.play(*anims, run_time = 2.0)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    command_line_create_scene(MOVIE_PREFIX)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}