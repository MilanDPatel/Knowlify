{
    "topic": "demonstrates the concept of word wrapping.",
    "code": [
        "from __future__ import annotations\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from typing import TYPE_CHECKING\n",
        "import warnings\n",
        "# import datasets\n",
        "\n",
        "DATA_DIR = Path(get_output_dir(), \"2024/transformers/data/\")\n",
        "WORD_FILE = Path(DATA_DIR, \"OWL3_Dictionary.txt\")\n",
        "\n",
        "\n",
        "if TYPE_CHECKING:\n",
        "    from typing import Optional\n",
        "    from manimlib.typing import Vect3, ManimColor\n",
        "\n",
        "\n",
        "def get_paragraph(words, line_len=40, font_size=48):\n",
        "    \"\"\"\n",
        "    Handle word wrapping\n",
        "    \"\"\"\n",
        "    words = list(map(str.strip, words))\n",
        "    word_lens = list(map(len, words))\n",
        "    lines = []\n",
        "    lh, rh = 0, 0\n",
        "    while rh < len(words):\n",
        "        rh += 1\n",
        "        if sum(word_lens[lh:rh]) > line_len:\n",
        "            rh -= 1\n",
        "            lines.append(words[lh:rh])\n",
        "            lh = rh\n",
        "    lines.append(words[lh:])\n",
        "    text = \"\\n\".join([\" \".join(line).strip() for line in lines])\n",
        "    return Text(text, alignment=\"LEFT\", font_size=font_size)\n",
        "\n",
        "\n",
        "def softmax(logits, temperature=1.0):\n",
        "    logits = np.array(logits)\n",
        "    with warnings.catch_warnings():\n",
        "        warnings.filterwarnings('ignore')  # Ignore all warnings within this block\n",
        "        logits = logits - np.max(logits)  # For numerical stability\n",
        "        exps = np.exp(np.divide(logits, temperature, where=temperature != 0))\n",
        "    \n",
        "    if np.isinf(exps).any() or np.isnan(exps).any() or temperature == 0:\n",
        "        result = np.zeros_like(logits)\n",
        "        result[np.argmax(logits)] = 1\n",
        "        return result\n",
        "    return exps / np.sum(exps)\n",
        "\n",
        "\n",
        "def value_to_color(\n",
        "    value,\n",
        "    low_positive_color=BLUE_E,\n",
        "    high_positive_color=BLUE_B,\n",
        "    low_negative_color=RED_E,\n",
        "    high_negative_color=RED_B,\n",
        "    min_value=0.0,\n",
        "    max_value=10.0\n",
        "):\n",
        "    alpha = clip(float(inverse_interpolate(min_value, max_value, abs(value))), 0, 1)\n",
        "    if value >= 0:\n",
        "        colors = (low_positive_color, high_positive_color)\n",
        "    else:\n",
        "        colors = (low_negative_color, high_negative_color)\n",
        "    return interpolate_color_by_hsl(*colors, alpha)\n",
        "\n",
        "\n",
        "def read_in_book(name=\"tale_of_two_cities\"):\n",
        "    return Path(DATA_DIR, name).with_suffix(\".txt\").read_text()\n",
        "\n",
        "\n",
        "def load_image_net_data(dataset_name=\"image_net_1k\"):\n",
        "    data_path = Path(Path.home(), \"Documents\", dataset_name)\n",
        "    image_dir = Path(data_path, \"images\")\n",
        "    label_category_path = Path(DATA_DIR, \"image_categories.txt\")\n",
        "    image_label_path = Path(data_path, \"image_labels.txt\")\n",
        "\n",
        "    if not os.path.exists(image_dir):\n",
        "        os.makedirs(image_dir)\n",
        "        image_data = datasets.load_from_disk(str(data_path))\n",
        "        indices = range(len(image_data))\n",
        "        categories = label_category_path.read_text().split(\"\\n\")\n",
        "        labels = [categories[image_data[index]['label']] for index in indices]\n",
        "        image_label_path.write_text(\"\\n\".join(labels))\n",
        "        for index in ProgressDisplay(indices):\n",
        "            image = image_data[index]['image']\n",
        "            image.save(str(Path(image_dir, f\"{index}.jpeg\")))\n",
        "\n",
        "\n",
        "    labels = image_label_path.read_text().split(\"\\n\")\n",
        "    return [\n",
        "        (Path(image_dir, f\"{index}.jpeg\"), label)\n",
        "        for index, label in enumerate(labels)\n",
        "    ]\n",
        "\n",
        "\n",
        "def show_matrix_vector_product(scene, matrix, vector, buff=0.25, x_max=999, fix_in_frame=False):\n",
        "    # Show product\n",
        "    eq = Tex(\"=\")\n",
        "    eq.set_width(0.5 * vector.get_width())\n",
        "    shape = (matrix.shape[0], 1)\n",
        "    rhs = NumericEmbedding(\n",
        "        values=x_max * np.ones(shape),\n",
        "        value_range=(-x_max, x_max),\n",
        "        decimal_config=dict(include_sign=True, edge_to_fix=ORIGIN),\n",
        "        ellipses_row=matrix.ellipses_row,\n",
        "    )\n",
        "    rhs.scale(vector.elements[0].get_height() / rhs.elements[0].get_height())\n",
        "    eq.next_to(vector, RIGHT, buff=buff)\n",
        "    rhs.next_to(eq, RIGHT, buff=buff)\n",
        "    if fix_in_frame:\n",
        "        eq.fix_in_frame()\n",
        "        rhs.fix_in_frame()\n",
        "\n",
        "    scene.play(FadeIn(eq), FadeIn(rhs.get_brackets()))\n",
        "\n",
        "    last_rects = VGroup()\n",
        "    n_rows = len(matrix.rows)\n",
        "    for n, row, entry in zip(it.count(), matrix.get_rows(), rhs[:-2]):\n",
        "        if matrix.ellipses_row is not None and n == (matrix.ellipses_row % n_rows):\n",
        "            scene.add(entry)\n",
        "        else:\n",
        "            last_rects = matrix_row_vector_product(\n",
        "                scene, row, vector, entry, last_rects,\n",
        "                fix_in_frame=fix_in_frame\n",
        "            )\n",
        "    scene.play(FadeOut(last_rects))\n",
        "\n",
        "    return eq, rhs\n",
        "\n",
        "\n",
        "def matrix_row_vector_product(scene, row, vector, entry, to_fade, fix_in_frame=False):\n",
        "    def get_rect(elem):\n",
        "        return SurroundingRectangle(elem, buff=0.1, is_fixed_in_frame=fix_in_frame).set_stroke(YELLOW, 2)\n",
        "\n",
        "    row_rects = VGroup(*map(get_rect, row))\n",
        "    vect_rects = VGroup(*map(get_rect, vector[:-2]))\n",
        "    partial_values = [0]\n",
        "    for e1, e2 in zip(row, vector[:-2]):\n",
        "        if not isinstance(e1, DecimalNumber) and isinstance(e2, DecimalNumber):\n",
        "            increment = 0\n",
        "        else:\n",
        "            val1 = round(e1.get_value(), e1.num_decimal_places)\n",
        "            val2 = round(e2.get_value(), e2.num_decimal_places)\n",
        "            increment = val1 * val2\n",
        "        partial_values.append(partial_values[-1] + increment)\n",
        "    n_values = len(partial_values)\n",
        "\n",
        "    scene.play(\n",
        "        ShowIncreasingSubsets(row_rects),\n",
        "        ShowIncreasingSubsets(vect_rects),\n",
        "        UpdateFromAlphaFunc(entry, lambda m, a: m.set_value(\n",
        "            partial_values[min(int(np.round(a * n_values)), n_values - 1)]\n",
        "        )),\n",
        "        FadeOut(to_fade),\n",
        "        rate_func=linear,\n",
        "    )\n",
        "\n",
        "    return VGroup(row_rects, vect_rects)\n",
        "\n",
        "\n",
        "def get_full_matrix_vector_product(\n",
        "    mat_sym=\"w\",\n",
        "    vect_sym=\"x\",\n",
        "    n_rows=5,\n",
        "    n_cols=5,\n",
        "    mat_sym_color=BLUE,\n",
        "    height=3.0,\n",
        "    ellipses_row=-2,\n",
        "    ellipses_col=-2,\n",
        "):\n",
        "    m_indices = list(map(str, [*range(1, n_cols), \"m\"]))\n",
        "    n_indices = list(map(str, [*range(1, n_rows), \"n\"]))\n",
        "    matrix = TexMatrix(\n",
        "        [\n",
        "            [Rf\"{mat_sym}_{{{m}, {n}}}\" for n in n_indices]\n",
        "            for m in m_indices\n",
        "        ],\n",
        "        ellipses_row=ellipses_row,\n",
        "        ellipses_col=ellipses_col,\n",
        "    )\n",
        "    matrix.set_height(height)\n",
        "    matrix.get_entries().set_color(mat_sym_color)\n",
        "    vector = TexMatrix(\n",
        "        [[Rf\"x_{{{n}}}\"] for n in n_indices],\n",
        "        ellipses_row=ellipses_row,\n",
        "    )\n",
        "    vector.match_height(matrix)\n",
        "    vector.next_to(matrix, RIGHT)\n",
        "    equals = Tex(\"=\", font_size=72)\n",
        "    equals.next_to(vector, RIGHT)\n",
        "\n",
        "    result_terms = [\n",
        "        [Rf\"w_{{{m}, {n}}} x_{n}\" for n in n_indices]\n",
        "        for m in m_indices\n",
        "    ]\n",
        "    rhs = TexMatrix(\n",
        "        result_terms,\n",
        "        ellipses_row=ellipses_row,\n",
        "        ellipses_col=ellipses_col,\n",
        "    )\n",
        "    rhs.match_height(matrix)\n",
        "    rhs.next_to(equals, RIGHT)\n",
        "    for m, row in enumerate(rhs.get_rows()):\n",
        "        if m == (ellipses_row % len(m_indices)):\n",
        "            continue\n",
        "        for n, entry in enumerate(row):\n",
        "            if n != (ellipses_col % len(n_indices)):\n",
        "                entry[:4].set_color(mat_sym_color)\n",
        "        for e1, e2 in zip(row, row[1:]):\n",
        "            plus = Tex(\"+\")\n",
        "            plus.match_height(e1)\n",
        "            points = [e1.get_right(), e2.get_left()]\n",
        "            plus.move_to(midpoint(*points))\n",
        "            plus.align_to(e1, UP)\n",
        "            e2.add(plus)\n",
        "\n",
        "    return matrix, vector, equals, rhs\n",
        "\n",
        "\n",
        "def show_symbolic_matrix_vector_product(scene, matrix, vector, rhs, run_time_per_row=0.75):\n",
        "    last_rects = VGroup()\n",
        "    for mat_row, rhs_row in zip(matrix.get_rows(), rhs.get_rows()):\n",
        "        mat_rects = VGroup(*map(SurroundingRectangle, mat_row))\n",
        "        vect_rects = VGroup(*map(SurroundingRectangle, vector.get_columns()[0]))\n",
        "        rect_group = VGroup(mat_rects, vect_rects)\n",
        "        rect_group.set_stroke(YELLOW, 2)\n",
        "        scene.play(\n",
        "            FadeOut(last_rects),\n",
        "            *(\n",
        "                ShowIncreasingSubsets(group, rate_func=linear)\n",
        "                for group in [mat_rects, vect_rects, rhs_row]\n",
        "            ),\n",
        "            run_time=run_time_per_row,\n",
        "        )\n",
        "        last_rects = rect_group\n",
        "    scene.play(FadeOut(last_rects))\n",
        "\n",
        "\n",
        "def data_flying_animation(\n",
        "    point,\n",
        "    vect=2 * DOWN + RIGHT,\n",
        "    color=GREY_C,\n",
        "    max_opacity=0.75,\n",
        "    font_size=48,\n",
        "    fix_in_frame=False\n",
        "    ):\n",
        "    word = Text(\"Data\", color=color, font_size=font_size)\n",
        "    if fix_in_frame:\n",
        "        word.fix_in_frame()\n",
        "    return UpdateFromAlphaFunc(\n",
        "        word, lambda m, a: m.move_to(\n",
        "            interpolate(point, point + vect, a)\n",
        "        ).set_opacity(there_and_back(a) * max_opacity)\n",
        "    )\n",
        "\n",
        "\n",
        "def get_data_modifying_matrix_anims(\n",
        "    matrix,\n",
        "    word_shape=(5, 10),\n",
        "    alpha_maxes=(0.7, 0.9),\n",
        "    shift_vect=2 * DOWN + RIGHT,\n",
        "    run_time=3,\n",
        "    fix_in_frame=False,\n",
        "    font_size=48,\n",
        "):\n",
        "    x_min, x_max = [matrix.get_x(LEFT), matrix.get_x(RIGHT)]\n",
        "    y_min, y_max = [matrix.get_y(UP), matrix.get_y(DOWN)]\n",
        "    z = matrix.get_z()\n",
        "    points = np.array([\n",
        "        [\n",
        "            interpolate(x_min, x_max, a1),\n",
        "            interpolate(y_min, y_max, a2),\n",
        "            z,\n",
        "        ]\n",
        "        for a1 in np.linspace(0, alpha_maxes[1], word_shape[1])\n",
        "        for a2 in np.linspace(0, alpha_maxes[0], word_shape[0])\n",
        "    ])\n",
        "    return [\n",
        "        LaggedStart(\n",
        "            (data_flying_animation(p, vect=shift_vect, fix_in_frame=fix_in_frame, font_size=font_size)\n",
        "            for p in points),\n",
        "            lag_ratio=1 / len(points),\n",
        "            run_time=run_time\n",
        "        ),\n",
        "        RandomizeMatrixEntries(matrix, run_time=run_time),\n",
        "    ]\n",
        "\n",
        "\n",
        "def data_modifying_matrix(scene, matrix, *args, **kwargs):\n",
        "    anims = get_data_modifying_matrix_anims(matrix, *args, **kwargs)\n",
        "    scene.play(*anims)\n",
        "\n",
        "\n",
        "def create_pixels(image_mob, pixel_width=0.1):\n",
        "    x0, y0, z0 = image_mob.get_corner(UL)\n",
        "    x1, y1, z1 = image_mob.get_corner(DR)\n",
        "    points = np.array([\n",
        "        [x, y, 0]\n",
        "        for y in np.arange(y0, y1, -pixel_width)\n",
        "        for x in np.arange(x0, x1, pixel_width)\n",
        "    ])\n",
        "    square = Square(pixel_width).set_fill(WHITE, 1).set_stroke(width=0)\n",
        "    pixels = VGroup(\n",
        "        square.copy().move_to(point, UL).set_color(\n",
        "            Color(rgb=image_mob.point_to_rgb(point))\n",
        "        )\n",
        "        for point in points\n",
        "    )\n",
        "    return pixels\n",
        "\n",
        "\n",
        "def get_network_connections(layer1, layer2, max_width=2.0, opacity_exp=1.0):\n",
        "    radius = layer1[0].get_width() / 2\n",
        "    return VGroup(\n",
        "        Line(n1.get_center(), n2.get_center(), buff=radius).set_stroke(\n",
        "            color=value_to_color(random.uniform(-10, 10)),\n",
        "            width=max_width * random.random(),\n",
        "            opacity=random.random()**opacity_exp,\n",
        "        )\n",
        "        for n1 in layer1\n",
        "        for n2 in layer2\n",
        "    )\n",
        "\n",
        "\n",
        "def get_vector_pair(angle_in_degrees=90, length=1.0, colors=(BLUE, BLUE)):\n",
        "    angle = angle_in_degrees * DEGREES\n",
        "    v1 = Vector(length * RIGHT)\n",
        "    v2 = v1.copy().rotate(angle, about_point=ORIGIN)\n",
        "    v1.set_color(colors[0])\n",
        "    v2.set_color(colors[1])\n",
        "    arc = Arc(radius=0.2, angle=angle)\n",
        "    arc.set_stroke(WHITE, 2)\n",
        "    label = Tex(Rf\"180^\\circ\", font_size=24)\n",
        "    num = label.make_number_changeable(\"180\")\n",
        "    num.set_value(angle_in_degrees)\n",
        "    label.next_to(arc.pfp(0.5), normalize(arc.pfp(0.5)), buff=SMALL_BUFF)\n",
        "\n",
        "    return VGroup(v1, v2, arc, label)\n",
        "\n",
        "\n",
        "class NeuralNetwork(VGroup):\n",
        "    def __init__(\n",
        "        self,\n",
        "        layer_sizes=[6, 12, 6],\n",
        "        neuron_radius=0.1,\n",
        "        v_buff_ratio=1.0,\n",
        "        h_buff_ratio=7.0,\n",
        "        max_stroke_width=2.0,\n",
        "        stroke_decay=2.0,\n",
        "    ):\n",
        "        self.max_stroke_width = max_stroke_width\n",
        "        self.stroke_decay = stroke_decay\n",
        "        layers = VGroup(*(\n",
        "            Dot(radius=neuron_radius).get_grid(n, 1, v_buff_ratio=v_buff_ratio)\n",
        "            for n in layer_sizes\n",
        "        ))\n",
        "        layers.arrange(RIGHT, buff=h_buff_ratio * layers[0].get_width())\n",
        "\n",
        "        lines = VGroup(*(\n",
        "            VGroup(*(\n",
        "                Line(\n",
        "                    n1.get_center(),\n",
        "                    n2.get_center(),\n",
        "                    buff=n1.get_width() / 2,\n",
        "                )\n",
        "                for n1, n2 in it.product(l1, l2)\n",
        "            ))\n",
        "            for l1, l2 in zip(layers, layers[1:])\n",
        "        ))\n",
        "\n",
        "        super().__init__(layers, lines)\n",
        "        self.layers = layers\n",
        "        self.lines = lines\n",
        "\n",
        "        self.randomize_layer_values()\n",
        "        self.randomize_line_style()\n",
        "\n",
        "    def randomize_layer_values(self):\n",
        "        for group in self.lines:\n",
        "            for line in group:\n",
        "                line.set_stroke(\n",
        "                    value_to_color(random.uniform(-10, 10)),\n",
        "                    self.max_stroke_width * random.random()**self.stroke_decay,\n",
        "                )\n",
        "        return self\n",
        "\n",
        "    def randomize_line_style(self):\n",
        "        for layer in self.layers:\n",
        "            for dot in layer:\n",
        "                dot.set_stroke(WHITE, 1)\n",
        "                dot.set_fill(WHITE, random.random())\n",
        "        return self\n",
        "\n",
        "\n",
        "class ContextAnimation(LaggedStart):\n",
        "    def __init__(\n",
        "        self,\n",
        "        target,\n",
        "        sources,\n",
        "        direction=UP,\n",
        "        hue_range=(0.1, 0.3),\n",
        "        time_width=2,\n",
        "        min_stroke_width=0,\n",
        "        max_stroke_width=5,\n",
        "        lag_ratio=None,\n",
        "        strengths=None,\n",
        "        run_time=3,\n",
        "        fix_in_frame=False,\n",
        "        path_arc=PI / 2,\n",
        "        **kwargs,\n",
        "    ):\n",
        "        arcs = VGroup()\n",
        "        if strengths is None:\n",
        "            strengths = np.random.random(len(sources))**2\n",
        "        for source, strength in zip(sources, strengths):\n",
        "            sign = direction[1] * (-1)**int(source.get_x() < target.get_x())\n",
        "            arcs.add(Line(\n",
        "                source.get_edge_center(direction),\n",
        "                target.get_edge_center(direction),\n",
        "                path_arc=sign * path_arc,\n",
        "                stroke_color=random_bright_color(hue_range=hue_range),\n",
        "                stroke_width=interpolate(\n",
        "                    min_stroke_width,\n",
        "                    max_stroke_width,\n",
        "                    strength,\n",
        "                )\n",
        "            ))\n",
        "        if fix_in_frame:\n",
        "            arcs.fix_in_frame()\n",
        "        arcs.shuffle()\n",
        "        lag_ratio = 0.5 / len(arcs) if lag_ratio is None else lag_ratio\n",
        "\n",
        "        super().__init__(\n",
        "            *(\n",
        "                VShowPassingFlash(arc, time_width=time_width)\n",
        "                for arc in arcs\n",
        "            ),\n",
        "            lag_ratio=lag_ratio,\n",
        "            run_time=run_time,\n",
        "            **kwargs,\n",
        "        )\n",
        "\n",
        "\n",
        "class LabeledArrow(Arrow):\n",
        "    def __init__(\n",
        "        self,\n",
        "        *args,\n",
        "        label_text: Optional[str] = None,\n",
        "        font_size: float = 24,\n",
        "        label_buff: float = 0.1,\n",
        "        direction: Optional[Vect3] = None,\n",
        "        label_rotation: float = PI / 2,\n",
        "        **kwargs\n",
        "    ):\n",
        "        super().__init__(*args, **kwargs)\n",
        "        if label_text is not None:\n",
        "            start, end = self.get_start_and_end()\n",
        "            label = Text(label_text, font_size=font_size)\n",
        "            label.set_fill(self.get_color())\n",
        "            label.set_backstroke()\n",
        "            label.rotate(label_rotation, RIGHT)\n",
        "            if direction is None:\n",
        "                direction = normalize(end - start)\n",
        "            label.next_to(end, direction, buff=label_buff)\n",
        "            self.label = label\n",
        "        else:\n",
        "            self.label = None\n",
        "\n",
        "\n",
        "class WeightMatrix(DecimalMatrix):\n",
        "    def __init__(\n",
        "        self,\n",
        "        values: Optional[np.ndarray] = None,\n",
        "        shape: tuple[int, int] = (6, 8),\n",
        "        value_range: tuple[float, float] = (-9.9, 9.9),\n",
        "        ellipses_row: Optional[int] = -2,\n",
        "        ellipses_col: Optional[int] = -2,\n",
        "        num_decimal_places: int = 1,\n",
        "        bracket_h_buff: float = 0.1,\n",
        "        decimal_config=dict(include_sign=True),\n",
        "        low_positive_color: ManimColor = BLUE_E,\n",
        "        high_positive_color: ManimColor = BLUE_B,\n",
        "        low_negative_color: ManimColor = RED_E,\n",
        "        high_negative_color: ManimColor = RED_B,\n",
        "    ):\n",
        "        if values is not None:\n",
        "            shape = values.shape\n",
        "        self.shape = shape\n",
        "        self.value_range = value_range\n",
        "        self.low_positive_color = low_positive_color\n",
        "        self.high_positive_color = high_positive_color\n",
        "        self.low_negative_color = low_negative_color\n",
        "        self.high_negative_color = high_negative_color\n",
        "        self.ellipses_row = ellipses_row\n",
        "        self.ellipses_col = ellipses_col\n",
        "\n",
        "        if values is None:\n",
        "            values = np.random.uniform(*self.value_range, size=shape)\n",
        "\n",
        "        super().__init__(\n",
        "            values,\n",
        "            num_decimal_places=num_decimal_places,\n",
        "            bracket_h_buff=bracket_h_buff,\n",
        "            decimal_config=decimal_config,\n",
        "            ellipses_row=ellipses_row,\n",
        "            ellipses_col=ellipses_col,\n",
        "        )\n",
        "        self.reset_entry_colors()\n",
        "\n",
        "    def reset_entry_colors(self):\n",
        "        for entry in self.get_entries():\n",
        "            entry.set_fill(color=value_to_color(\n",
        "                entry.get_value(),\n",
        "                self.low_positive_color,\n",
        "                self.high_positive_color,\n",
        "                self.low_negative_color,\n",
        "                self.high_negative_color,\n",
        "                0, max(self.value_range),\n",
        "            ))\n",
        "        return self\n",
        "\n",
        "\n",
        "class NumericEmbedding(WeightMatrix):\n",
        "    def __init__(\n",
        "        self,\n",
        "        values: Optional[np.ndarray] = None,\n",
        "        shape: Optional[Tuple[int, int]] = None,\n",
        "        length: int = 7,\n",
        "        num_decimal_places: int = 1,\n",
        "        ellipses_row: int = -2,\n",
        "        ellipses_col: int = -2,\n",
        "        value_range: tuple[float, float] = (-9.9, 9.9),\n",
        "        bracket_h_buff: float = 0.1,\n",
        "        decimal_config=dict(include_sign=True),\n",
        "        dark_color: ManimColor = GREY_C,\n",
        "        light_color: ManimColor = WHITE,\n",
        "        **kwargs,\n",
        "    ):\n",
        "        if values is not None:\n",
        "            if len(values.shape) == 1:\n",
        "                values = values.reshape((values.shape[0], 1))\n",
        "            shape = values.shape\n",
        "        if shape is None:\n",
        "            shape = (length, 1)\n",
        "        super().__init__(\n",
        "            values,\n",
        "            shape=shape,\n",
        "            value_range=value_range,\n",
        "            num_decimal_places=num_decimal_places,\n",
        "            bracket_h_buff=bracket_h_buff,\n",
        "            decimal_config=decimal_config,\n",
        "            low_positive_color=dark_color,\n",
        "            high_positive_color=light_color,\n",
        "            low_negative_color=dark_color,\n",
        "            high_negative_color=light_color,\n",
        "            ellipses_row=ellipses_row,\n",
        "            ellipses_col=ellipses_col,\n",
        "            **kwargs,\n",
        "        )\n",
        "\n",
        "        # No sign on zeros\n",
        "        for entry in self.get_entries():\n",
        "            if entry.get_value() == 0:\n",
        "                entry[0].set_opacity(0)\n",
        "\n",
        "\n",
        "class EmbeddingArray(VGroup):\n",
        "    def __init__(\n",
        "        self,\n",
        "        shape=(10, 9),\n",
        "        height=4,\n",
        "        dots_index=-4,\n",
        "        buff_ratio=0.4,\n",
        "        bracket_color=GREY_B,\n",
        "        backstroke_width=3,\n",
        "        add_background_rectangle=False,\n",
        "    ):\n",
        "        super().__init__()\n",
        "\n",
        "        # Embeddings\n",
        "        embeddings = VGroup(\n",
        "            NumericEmbedding(length=shape[0])\n",
        "            for n in range(shape[1])\n",
        "        )\n",
        "        embeddings.set_height(height)\n",
        "        buff = buff_ratio * embeddings[0].get_width()\n",
        "        embeddings.arrange(RIGHT, buff=buff)\n",
        "\n",
        "        # Background rectangle\n",
        "        if add_background_rectangle:\n",
        "            for embedding in embeddings:\n",
        "                embedding.add_background_rectangle()\n",
        "\n",
        "        # Add brackets\n",
        "        brackets = Tex(\"\".join((\n",
        "            R\"\\left[\\begin{array}{c}\",\n",
        "            *(shape[1] // 3) * [R\"\\quad \\\\\"],\n",
        "            R\"\\end{array}\\right]\",\n",
        "        )))\n",
        "        brackets.set_height(1.1 * embeddings.get_height())\n",
        "        lb = brackets[:len(brackets) // 2]\n",
        "        rb = brackets[len(brackets) // 2:]\n",
        "        lb.next_to(embeddings, LEFT, buff=0)\n",
        "        rb.next_to(embeddings, RIGHT, buff=0)\n",
        "        brackets.set_fill(bracket_color)\n",
        "\n",
        "        # Assemble result\n",
        "        dots = VGroup()\n",
        "        self.add(embeddings, dots, brackets)\n",
        "        self.embeddings = embeddings\n",
        "        self.dots = dots\n",
        "        self.brackets = brackets\n",
        "        self.set_backstroke(BLACK, backstroke_width)\n",
        "\n",
        "        if dots_index is not None:\n",
        "            self.swap_embedding_for_dots(dots_index)\n",
        "\n",
        "\n",
        "    def swap_embedding_for_dots(self, dots_index=-4):\n",
        "        to_replace = self.embeddings[dots_index]\n",
        "        dots = Tex(R\"\\dots\", font_size=60)\n",
        "        dots.set_width(0.75 * to_replace.get_width())\n",
        "        dots.move_to(to_replace)\n",
        "        self.embeddings.remove(to_replace)\n",
        "        self.dots.add(dots)\n",
        "        return self\n",
        "\n",
        "\n",
        "class RandomizeMatrixEntries(Animation):\n",
        "    def __init__(self, matrix, **kwargs):\n",
        "        self.matrix = matrix\n",
        "        self.entries = matrix.get_entries()\n",
        "        self.start_values = [entry.get_value() for entry in self.entries]\n",
        "        self.target_values = np.random.uniform(\n",
        "            matrix.value_range[0],\n",
        "            matrix.value_range[1],\n",
        "            len(self.entries)\n",
        "        )\n",
        "        super().__init__(matrix, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha: float) -> None:\n",
        "        for index, entry in enumerate(self.entries):\n",
        "            start = self.start_values[index]\n",
        "            target = self.target_values[index]\n",
        "            sub_alpha = self.get_sub_alpha(alpha, index, len(self.entries))\n",
        "            entry.set_value(interpolate(start, target, sub_alpha))\n",
        "        self.matrix.reset_entry_colors()\n",
        "\n",
        "\n",
        "class AbstractEmbeddingSequence(MobjectMatrix):\n",
        "    pass\n",
        "\n",
        "\n",
        "class Dial(VGroup):\n",
        "    def __init__(\n",
        "        self,\n",
        "        radius=0.5,\n",
        "        relative_tick_size=0.2,\n",
        "        value_range=(0, 1, 0.1),\n",
        "        initial_value=0,\n",
        "        arc_angle=270 * DEGREES,\n",
        "        stroke_width=2,\n",
        "        stroke_color=WHITE,\n",
        "        needle_color=BLUE,\n",
        "        needle_stroke_width=5.0,\n",
        "        value_to_color_config=dict(),\n",
        "        set_anim_streak_color=TEAL,\n",
        "        set_anim_streak_width=4,\n",
        "        set_value_anim_streak_density=6,\n",
        "        **kwargs\n",
        "    ):\n",
        "        super().__init__(**kwargs)\n",
        "        self.value_range = value_range\n",
        "        self.value_to_color_config = value_to_color_config\n",
        "        self.set_anim_streak_color = set_anim_streak_color\n",
        "        self.set_anim_streak_width = set_anim_streak_width\n",
        "        self.set_value_anim_streak_density = set_value_anim_streak_density\n",
        "\n",
        "        # Main dial\n",
        "        self.arc = Arc(arc_angle / 2, -arc_angle, radius=radius)\n",
        "        self.arc.rotate(90 * DEGREES, about_point=ORIGIN)\n",
        "\n",
        "        low, high, step = value_range\n",
        "        n_values = int(1 + (high - low) / step)\n",
        "        tick_points = map(self.arc.pfp, np.linspace(0, 1, n_values))\n",
        "        self.ticks = VGroup(*(\n",
        "            Line((1.0 - relative_tick_size) * point, point)\n",
        "            for point in tick_points\n",
        "        ))\n",
        "        self.bottom_point = VectorizedPoint(radius * DOWN)\n",
        "        for mob in self.arc, self.ticks:\n",
        "            mob.set_stroke(stroke_color, stroke_width)\n",
        "\n",
        "        self.add(self.arc, self.ticks, self.bottom_point)\n",
        "\n",
        "        # Needle\n",
        "        self.needle = Line()\n",
        "        self.needle.set_stroke(\n",
        "            color=needle_color,\n",
        "            width=[needle_stroke_width, 0]\n",
        "        )\n",
        "        self.add(self.needle)\n",
        "\n",
        "        # Initialize\n",
        "        self.set_value(initial_value)\n",
        "\n",
        "    def value_to_point(self, value):\n",
        "        low, high, step = self.value_range\n",
        "        alpha = inverse_interpolate(low, high, value)\n",
        "        return self.arc.pfp(alpha)\n",
        "\n",
        "    def set_value(self, value):\n",
        "        self.needle.put_start_and_end_on(\n",
        "            self.get_center(),\n",
        "            self.value_to_point(value)\n",
        "        )\n",
        "        self.needle.set_color(value_to_color(\n",
        "            value,\n",
        "            min_value=self.value_range[0],\n",
        "            max_value=self.value_range[1],\n",
        "            **self.value_to_color_config\n",
        "        ))\n",
        "\n",
        "    def animate_set_value(self, value, **kwargs):\n",
        "        kwargs.pop(\"path_arc\", None)\n",
        "        center = self.get_center()\n",
        "        points = [self.needle.get_end(), self.value_to_point(value)]\n",
        "        vects = [point - center for point in points]\n",
        "        angle1, angle2 = [\n",
        "            (angle_of_vector(vect) + TAU / 4) % TAU - TAU / 4\n",
        "            for vect in vects\n",
        "        ]\n",
        "        path_arc = angle2 - angle1\n",
        "\n",
        "        density = self.set_value_anim_streak_density\n",
        "        radii = np.linspace(0, 0.5 * self.get_width(), density + 1)[1:]\n",
        "        diff_arcs = VGroup(*(\n",
        "            Arc(\n",
        "                angle1, angle2 - angle1,\n",
        "                radius=radius,\n",
        "                arc_center=center,\n",
        "            )\n",
        "            for radius in radii\n",
        "        ))\n",
        "        diff_arcs.set_stroke(self.set_anim_streak_color, self.set_anim_streak_width)\n",
        "\n",
        "        return AnimationGroup(\n",
        "            self.animate.set_value(value).set_anim_args(path_arc=path_arc, **kwargs),\n",
        "            *(\n",
        "                VShowPassingFlash(diff_arc, time_width=1.5, **kwargs)\n",
        "                for diff_arc in diff_arcs\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def get_random_value(self):\n",
        "        low, high, step = self.value_range\n",
        "        return interpolate(low, high, random.random())\n",
        "\n",
        "\n",
        "class MachineWithDials(VGroup):\n",
        "    default_dial_config = dict(\n",
        "        stroke_width=1.0,\n",
        "        needle_stroke_width=5.0,\n",
        "        relative_tick_size=0.25,\n",
        "        set_anim_streak_width=2,\n",
        "    )\n",
        "\n",
        "    def __init__(\n",
        "        self,\n",
        "        width=5.0,\n",
        "        height=4.0,\n",
        "        n_rows=6,\n",
        "        n_cols=8,\n",
        "        dial_buff_ratio=0.5,\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=1,\n",
        "        fill_color=GREY_D,\n",
        "        fill_opacity=1.0,\n",
        "        dial_config=dict(),\n",
        "    ):\n",
        "        super().__init__()\n",
        "        box = Rectangle(width, height)\n",
        "        box.set_stroke(stroke_color, stroke_width)\n",
        "        box.set_fill(fill_color, fill_opacity)\n",
        "        self.box = box\n",
        "\n",
        "        dial_config = dict(**self.default_dial_config, **dial_config)\n",
        "        dials = Dial(**dial_config).get_grid(n_rows, n_cols, buff_ratio=dial_buff_ratio)\n",
        "        buff = dials[0].get_width() * dial_buff_ratio\n",
        "        dials.set_width(box.get_width() - buff)\n",
        "        dials.set_max_height(box.get_width() - buff)\n",
        "        dials.move_to(box)\n",
        "        for dial in dials:\n",
        "            dial.set_value(dial.get_random_value())\n",
        "        self.dials = dials\n",
        "\n",
        "        self.add(box, dials)\n",
        "\n",
        "    def random_change_animation(self, lag_factor=0.5, run_time=3.0, **kwargs):\n",
        "        return LaggedStart(\n",
        "            *(\n",
        "                dial.animate_set_value(dial.get_random_value())\n",
        "                for dial in self.dials\n",
        "            ), lag_ratio=lag_factor / len(self.dials),\n",
        "            run_time=run_time,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def rotate_all_dials(self, run_time=2, lag_factor=1.0):\n",
        "        shuffled_dials = list(self.dials)\n",
        "        random.shuffle(shuffled_dials)\n",
        "        return LaggedStart(\n",
        "            *(\n",
        "                Rotate(dial.needle, TAU, about_point=dial.get_center())\n",
        "                for dial in shuffled_dials\n",
        "            ),\n",
        "            lag_ratio=lag_factor / len(self.dials)\n",
        "        )\n"
    ]
}