{
    "topic": "demonstrates the concept of a cycloid, which is a curve that is created by",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "RANDY_SCALE_FACTOR = 0.3\n",
        "\n",
        "\n",
        "\n",
        "class Cycloid(ParametricCurve):\n",
        "    CONFIG = {\n",
        "        \"point_a\"       : 6*LEFT+3*UP,\n",
        "        \"radius\"        : 2,\n",
        "        \"end_theta\"     : 3*np.pi/2,\n",
        "        \"density\"       : 5*DEFAULT_POINT_DENSITY_1D,\n",
        "        \"color\"         : YELLOW\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        ParametricCurve.__init__(self, self.pos_func, **kwargs)\n",
        "\n",
        "    def pos_func(self, t):\n",
        "        T = t*self.end_theta\n",
        "        return self.point_a + self.radius * np.array([\n",
        "            T - np.sin(T),\n",
        "            np.cos(T) - 1,\n",
        "            0\n",
        "        ])\n",
        "\n",
        "class LoopTheLoop(ParametricCurve):\n",
        "    CONFIG = {\n",
        "        \"color\" : YELLOW_D,\n",
        "        \"density\" : 10*DEFAULT_POINT_DENSITY_1D\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        def func(t):\n",
        "            t = (6*np.pi/2)*(t-0.5)\n",
        "            return (t/2-np.sin(t))*RIGHT + \\\n",
        "                   (np.cos(t)+(t**2)/10)*UP\n",
        "        ParametricCurve.__init__(self, func, **kwargs)\n",
        "\n",
        "\n",
        "class SlideWordDownCycloid(Animation):\n",
        "    CONFIG = { \n",
        "        \"rate_func\" : None,\n",
        "        \"run_time\"  : 8\n",
        "    }\n",
        "    def __init__(self, word, **kwargs):\n",
        "        self.path = Cycloid(end_theta = np.pi)        \n",
        "        word_mob = OldTexText(list(word))\n",
        "        end_word = word_mob.copy()\n",
        "        end_word.shift(-end_word.get_bottom())\n",
        "        end_word.shift(self.path.get_corner(DOWN+RIGHT))\n",
        "        end_word.shift(3*RIGHT)\n",
        "        self.end_letters = end_word.split()\n",
        "        for letter in word_mob.split():\n",
        "            letter.center()\n",
        "            letter.angle = 0\n",
        "        unit_interval = np.arange(0, 1, 1./len(word))\n",
        "        self.start_times = 0.5*(1-(unit_interval))\n",
        "        Animation.__init__(self, word_mob, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        virtual_times = 2*(alpha - self.start_times)\n",
        "        cut_offs = [\n",
        "            0.1,\n",
        "            0.3,\n",
        "            0.7,\n",
        "        ]\n",
        "        for letter, time, end_letter in zip(\n",
        "            self.mobject.split(), virtual_times, self.end_letters\n",
        "            ):\n",
        "            time = max(time, 0)\n",
        "            time = min(time, 1)\n",
        "            if time < cut_offs[0]:\n",
        "                brightness = time/cut_offs[0]\n",
        "                letter.rgbas = brightness*np.ones(letter.rgbas.shape)\n",
        "                position = self.path.get_points()[0]\n",
        "                angle = 0\n",
        "            elif time < cut_offs[1]:\n",
        "                alpha = (time-cut_offs[0])/(cut_offs[1]-cut_offs[0])\n",
        "                angle = -rush_into(alpha)*np.pi/2\n",
        "                position = self.path.get_points()[0]\n",
        "            elif time < cut_offs[2]:\n",
        "                alpha = (time-cut_offs[1])/(cut_offs[2]-cut_offs[1])\n",
        "                index = int(alpha*self.path.get_num_points())\n",
        "                position = self.path.get_points()[index]\n",
        "                try:\n",
        "                    angle = angle_of_vector(\n",
        "                        self.path.get_points()[index+1] - \\\n",
        "                        self.path.get_points()[index]\n",
        "                    )\n",
        "                except:\n",
        "                    angle = letter.angle\n",
        "            else:\n",
        "                alpha = (time-cut_offs[2])/(1-cut_offs[2])\n",
        "                start = self.path.get_points()[-1]\n",
        "                end = end_letter.get_bottom()\n",
        "                position = interpolate(start, end, rush_from(alpha))\n",
        "                angle = 0\n",
        "\n",
        "            letter.shift(position-letter.get_bottom())\n",
        "            letter.rotate(angle-letter.angle)\n",
        "            letter.angle = angle\n",
        "\n",
        "\n",
        "class BrachistochroneWordSliding(Scene):\n",
        "    def construct(self):\n",
        "        anim = SlideWordDownCycloid(\"Brachistochrone\")\n",
        "        anim.path.set_color_by_gradient(WHITE, BLUE_E)\n",
        "        self.play(ShowCreation(anim.path))\n",
        "        self.play(anim)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(anim.path),\n",
        "            ApplyMethod(anim.mobject.center)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "class PathSlidingScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"gravity\" : 3,\n",
        "        \"delta_t\" : 0.05,\n",
        "        \"wait_and_add\" : True,\n",
        "        \"show_time\" : True,\n",
        "    }\n",
        "    def slide(self, mobject, path, roll = False, ceiling = None):\n",
        "        points = path.points\n",
        "        time_slices = self.get_time_slices(points, ceiling = ceiling)\n",
        "        curr_t = 0\n",
        "        last_index = 0\n",
        "        curr_index = 1\n",
        "        if self.show_time:\n",
        "            self.t_equals = OldTex(\"t = \")\n",
        "            self.t_equals.shift(3.5*UP+4*RIGHT)\n",
        "            self.add(self.t_equals)\n",
        "        while curr_index < len(points):\n",
        "            self.slider = mobject.copy()\n",
        "            self.adjust_mobject_to_index(\n",
        "                self.slider, curr_index, points\n",
        "            )\n",
        "            if roll:\n",
        "                distance = get_norm(\n",
        "                    points[curr_index] - points[last_index]\n",
        "                )\n",
        "                self.roll(mobject, distance)\n",
        "            self.add(self.slider)\n",
        "            if self.show_time:\n",
        "                self.write_time(curr_t)\n",
        "            self.wait(self.frame_duration)\n",
        "            self.remove(self.slider)\n",
        "            curr_t += self.delta_t\n",
        "            last_index = curr_index\n",
        "            while time_slices[curr_index] < curr_t:\n",
        "                curr_index += 1\n",
        "                if curr_index == len(points):\n",
        "                    break\n",
        "        if self.wait_and_add:\n",
        "            self.add(self.slider)\n",
        "            self.wait()\n",
        "        else:\n",
        "            return self.slider\n",
        "\n",
        "    def get_time_slices(self, points, ceiling = None):\n",
        "        dt_list = np.zeros(len(points))\n",
        "        ds_list = np.apply_along_axis(\n",
        "            get_norm,\n",
        "            1,\n",
        "            points[1:]-points[:-1]\n",
        "        )\n",
        "        if ceiling is None:\n",
        "            ceiling = points[0, 1]\n",
        "        delta_y_list = np.abs(ceiling - points[1:,1])\n",
        "        delta_y_list += 0.001*(delta_y_list == 0)\n",
        "        v_list = self.gravity*np.sqrt(delta_y_list)\n",
        "        dt_list[1:] = ds_list / v_list\n",
        "        return np.cumsum(dt_list)\n",
        "\n",
        "    def adjust_mobject_to_index(self, mobject, index, points):\n",
        "        point_a, point_b = points[index-1], points[index]\n",
        "        while np.all(point_a == point_b):\n",
        "            index += 1\n",
        "            point_b = points[index]\n",
        "        theta = angle_of_vector(point_b - point_a)\n",
        "        mobject.rotate(theta)\n",
        "        mobject.shift(points[index])\n",
        "        self.midslide_action(point_a, theta)\n",
        "        return mobject\n",
        "\n",
        "    def midslide_action(self, point, angle):\n",
        "        pass\n",
        "\n",
        "    def write_time(self, time):\n",
        "        if hasattr(self, \"time_mob\"):\n",
        "            self.remove(self.time_mob)\n",
        "        digits = list(map(Tex, \"%.2f\"%time))\n",
        "        digits[0].next_to(self.t_equals, buff = 0.1)\n",
        "        for left, right in zip(digits, digits[1:]):\n",
        "            right.next_to(left, buff = 0.1, aligned_edge = DOWN)\n",
        "        self.time_mob = Mobject(*digits)\n",
        "        self.add(self.time_mob)\n",
        "\n",
        "    def roll(self, mobject, arc_length):\n",
        "        radius = mobject.get_width()/2\n",
        "        theta = arc_length / radius\n",
        "        mobject.rotate(-theta)\n",
        "\n",
        "    def add_cycloid_end_points(self):\n",
        "        cycloid = Cycloid()\n",
        "        point_a = Dot(cycloid.get_points()[0])\n",
        "        point_b = Dot(cycloid.get_points()[-1])\n",
        "        A = OldTex(\"A\").next_to(point_a, LEFT)\n",
        "        B = OldTex(\"B\").next_to(point_b, RIGHT)\n",
        "        self.add(point_a, point_b, A, B)\n",
        "        digest_locals(self)\n",
        "\n",
        "\n",
        "class TryManyPaths(PathSlidingScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        self.slider = randy.copy()  \n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        paths = self.get_paths()\n",
        "        point_a = Dot(paths[0].get_points()[0])\n",
        "        point_b = Dot(paths[0].get_points()[-1])\n",
        "        A = OldTex(\"A\").next_to(point_a, LEFT)\n",
        "        B = OldTex(\"B\").next_to(point_b, RIGHT)\n",
        "        for point, tex in [(point_a, A), (point_b, B)]:\n",
        "            self.play(ShowCreation(point))\n",
        "            self.play(ShimmerIn(tex))\n",
        "            self.wait()\n",
        "        curr_path = None        \n",
        "        for path in paths:\n",
        "            new_slider = self.adjust_mobject_to_index(\n",
        "                randy.copy(), 1, path.points\n",
        "            )\n",
        "            if curr_path is None:\n",
        "                curr_path = path\n",
        "                self.play(ShowCreation(curr_path))\n",
        "            else:\n",
        "                self.play(Transform(curr_path, path))\n",
        "            self.play(Transform(self.slider, new_slider))\n",
        "            self.wait()\n",
        "            self.remove(self.slider)\n",
        "            self.slide(randy, curr_path)\n",
        "        self.clear()\n",
        "        self.add(point_a, point_b, A, B, curr_path)\n",
        "        text = self.get_text()\n",
        "        text.to_edge(UP)\n",
        "        self.play(ShimmerIn(text))\n",
        "        for path in paths:\n",
        "            self.play(Transform(\n",
        "                curr_path, path,\n",
        "                path_func = path_along_arc(np.pi/2),\n",
        "                run_time = 3\n",
        "            ))\n",
        "\n",
        "    def get_text(self):\n",
        "        return OldTexText(\"Which path is fastest?\")\n",
        "\n",
        "    def get_paths(self):\n",
        "        sharp_corner = Mobject(\n",
        "            Line(3*UP+LEFT, LEFT),\n",
        "            Arc(angle = np.pi/2, start_angle = np.pi),\n",
        "            Line(DOWN, DOWN+3*RIGHT)\n",
        "        ).ingest_submobjects().set_color(GREEN)\n",
        "        paths = [\n",
        "            Arc(\n",
        "                angle = np.pi/2, \n",
        "                radius = 3, \n",
        "                start_angle = 4\n",
        "            ),\n",
        "            LoopTheLoop(),            \n",
        "            Line(7*LEFT, 7*RIGHT, color = RED_D),\n",
        "            sharp_corner,\n",
        "            FunctionGraph(\n",
        "                lambda x : 0.05*(x**2)+0.1*np.sin(2*x)\n",
        "            ),\n",
        "            FunctionGraph(\n",
        "                lambda x : x**2, \n",
        "                x_min = -3, \n",
        "                x_max = 2,\n",
        "                density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "            )\n",
        "        ]\n",
        "        cycloid = Cycloid()\n",
        "        self.align_paths(paths, cycloid)\n",
        "        return paths + [cycloid]\n",
        "\n",
        "    def align_paths(self, paths, target_path):\n",
        "        start = target_path.get_points()[0]\n",
        "        end = target_path.get_points()[-1]\n",
        "        for path in paths:\n",
        "            path.put_start_and_end_on(start, end)\n",
        "\n",
        "\n",
        "class RollingRandolph(PathSlidingScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        self.add_cycloid_end_points()        \n",
        "        self.slide(randy, self.cycloid, roll = True)\n",
        "\n",
        "\n",
        "\n",
        "class NotTheCircle(PathSlidingScene):\n",
        "    def construct(self):\n",
        "        self.add_cycloid_end_points()\n",
        "        start = self.point_a.get_center()\n",
        "        end   = self.point_b.get_center()\n",
        "        angle = 2*np.pi/3\n",
        "        path = Arc(angle, radius = 3)\n",
        "        path.set_color_by_gradient(RED_D, WHITE)\n",
        "        radius = Line(ORIGIN, path.get_points()[0])\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        randy_copy = randy.copy()\n",
        "        words = OldTexText(\"Circular paths are good, \\\\\\\\ but still not the best\")\n",
        "        words.shift(UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(path),\n",
        "            ApplyMethod(\n",
        "                radius.rotate, \n",
        "                angle,\n",
        "                path_func = path_along_arc(angle)\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeOut(radius))\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                path.put_start_and_end_on, start, end,\n",
        "                path_func = path_along_arc(-angle)\n",
        "            ),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.adjust_mobject_to_index(randy_copy, 1, path.points)\n",
        "        self.play(FadeIn(randy_copy))\n",
        "        self.remove(randy_copy)\n",
        "        self.slide(randy, path)\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TransitionAwayFromSlide(PathSlidingScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        self.add_cycloid_end_points()\n",
        "        arrow = Arrow(ORIGIN, 2*RIGHT)\n",
        "        arrows = Mobject(*[\n",
        "            arrow.copy().shift(vect)\n",
        "            for vect in (3*LEFT, ORIGIN, 3*RIGHT)\n",
        "        ])\n",
        "        arrows.shift(FRAME_WIDTH*RIGHT)\n",
        "        self.add(arrows)\n",
        "\n",
        "        self.add(self.cycloid)\n",
        "        self.slide(randy, self.cycloid)\n",
        "        everything = Mobject(*self.mobjects)\n",
        "        self.play(ApplyMethod(\n",
        "            everything.shift, 4*FRAME_X_RADIUS*LEFT,\n",
        "            run_time = 2,\n",
        "            rate_func = rush_into\n",
        "        ))\n",
        "        \n",
        "\n",
        "class MinimalPotentialEnergy(Scene):\n",
        "    def construct(self):\n",
        "        horiz_radius = 5\n",
        "        vert_radius = 3\n",
        "\n",
        "        vert_axis = NumberLine(numerical_radius = vert_radius)\n",
        "        vert_axis.rotate(np.pi/2)\n",
        "        vert_axis.shift(horiz_radius*LEFT)\n",
        "        horiz_axis = NumberLine(\n",
        "            numerical_radius = 5,\n",
        "            big_tick_numbers = []\n",
        "        )\n",
        "        axes = Mobject(horiz_axis, vert_axis)\n",
        "        graph = FunctionGraph(\n",
        "            lambda x : 0.4*(x-2)*(x+2)+3,\n",
        "            x_min = -2,\n",
        "            x_max = 2,\n",
        "            density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        graph.stretch_to_fit_width(2*horiz_radius)\n",
        "        graph.set_color(YELLOW)\n",
        "        min_point = Dot(graph.get_bottom())\n",
        "        nature_finds = OldTexText(\"Nature finds this point\")\n",
        "        nature_finds.scale(0.5)\n",
        "        nature_finds.set_color(GREEN)\n",
        "        nature_finds.shift(2*RIGHT+3*UP)\n",
        "        arrow = Arrow(\n",
        "            nature_finds.get_bottom(), min_point, \n",
        "            color = GREEN\n",
        "        )\n",
        "\n",
        "        side_words_start = OldTexText(\"Parameter describing\")\n",
        "        top_words, last_side_words = [\n",
        "            list(map(TexText, pair))\n",
        "            for pair in [\n",
        "                (\"Light's travel time\", \"Potential energy\"),\n",
        "                (\"path\", \"mechanical state\")\n",
        "            ]\n",
        "        ]\n",
        "        for word in top_words + last_side_words + [side_words_start]:\n",
        "            word.scale(0.7)\n",
        "        side_words_start.next_to(horiz_axis, DOWN)\n",
        "        side_words_start.to_edge(RIGHT)\n",
        "        for words in top_words:\n",
        "            words.next_to(vert_axis, UP)\n",
        "            words.to_edge(LEFT)\n",
        "        for words in last_side_words:\n",
        "            words.next_to(side_words_start, DOWN)\n",
        "        for words in top_words[1], last_side_words[1]:\n",
        "            words.set_color(RED)\n",
        "\n",
        "        self.add(\n",
        "            axes, top_words[0], side_words_start, \n",
        "            last_side_words[0]\n",
        "        )\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(\n",
        "            ShimmerIn(nature_finds),\n",
        "            ShowCreation(arrow),\n",
        "            ShowCreation(min_point)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(top_words[0]), \n",
        "            FadeOut(last_side_words[0]),\n",
        "            GrowFromCenter(top_words[1]), \n",
        "            GrowFromCenter(last_side_words[1])\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class WhatGovernsSpeed(PathSlidingScene):\n",
        "    CONFIG = {\n",
        "        \"num_pieces\" : 6,\n",
        "        \"wait_and_add\" : False,\n",
        "        \"show_time\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        self.add_cycloid_end_points()\n",
        "        points = self.cycloid.points\n",
        "        ceiling = points[0, 1]\n",
        "        n = len(points)\n",
        "        broken_points = [\n",
        "            points[k*n/self.num_pieces:(k+1)*n/self.num_pieces]\n",
        "            for k in range(self.num_pieces)\n",
        "        ]\n",
        "        words = OldTexText(\"\"\"\n",
        "            What determines the speed\\\\\\\\\n",
        "            at each point?\n",
        "        \"\"\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(self.cycloid)\n",
        "        sliders, vectors = [], []\n",
        "        for points in broken_points:\n",
        "            path = Mobject().add_points(points)\n",
        "            vect = points[-1] - points[-2]\n",
        "            magnitude = np.sqrt(ceiling - points[-1, 1])\n",
        "            vect = magnitude*vect/get_norm(vect)\n",
        "            slider = self.slide(randy, path, ceiling = ceiling)\n",
        "            vector = Vector(slider.get_center(), vect)\n",
        "            self.add(slider, vector)\n",
        "            sliders.append(slider)\n",
        "            vectors.append(vector)\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait(3)\n",
        "        slider = sliders.pop(1)\n",
        "        vector = vectors.pop(1)\n",
        "        faders = sliders+vectors+[words]\n",
        "        self.play(*list(map(FadeOut, faders)))\n",
        "        self.remove(*faders)\n",
        "        self.show_geometry(slider, vector)\n",
        "\n",
        "    def show_geometry(self, slider, vector):\n",
        "        point_a = self.point_a.get_center()\n",
        "        horiz_line = Line(point_a, point_a + 6*RIGHT)\n",
        "        ceil_point = point_a\n",
        "        ceil_point[0] = slider.get_center()[0]\n",
        "        vert_brace = Brace(\n",
        "            Mobject(Point(ceil_point), Point(slider.get_center())),\n",
        "            RIGHT,\n",
        "            buff = 0.5\n",
        "        )\n",
        "        vect_brace = Brace(slider)\n",
        "        vect_brace.stretch_to_fit_width(vector.get_length())\n",
        "        vect_brace.rotate(np.arctan(vector.get_slope()))\n",
        "        vect_brace.center().shift(vector.get_center())\n",
        "        nudge = 0.2*(DOWN+LEFT)\n",
        "        vect_brace.shift(nudge)\n",
        "        y_mob = OldTex(\"y\")\n",
        "        y_mob.next_to(vert_brace)\n",
        "        sqrt_y = OldTex(\"k\\\\sqrt{y}\")\n",
        "        sqrt_y.scale(0.5)\n",
        "        sqrt_y.shift(vect_brace.get_center())\n",
        "        sqrt_y.shift(3*nudge)\n",
        "\n",
        "        self.play(ShowCreation(horiz_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(vert_brace),\n",
        "            ShimmerIn(y_mob)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(vect_brace),\n",
        "            ShimmerIn(sqrt_y)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.solve_energy()\n",
        "\n",
        "    def solve_energy(self):\n",
        "        loss_in_potential = OldTexText(\"Loss in potential: \")\n",
        "        loss_in_potential.shift(2*UP)\n",
        "        potential = OldTex(\"m g y\".split())\n",
        "        potential.next_to(loss_in_potential)\n",
        "        kinetic = OldTex([\n",
        "            \"\\\\dfrac{1}{2}\",\"m\",\"v\",\"^2\",\"=\"\n",
        "        ])\n",
        "        kinetic.next_to(potential, LEFT)\n",
        "        nudge = 0.1*UP\n",
        "        kinetic.shift(nudge)\n",
        "        loss_in_potential.shift(nudge)\n",
        "        ms = Mobject(kinetic.split()[1], potential.split()[0])\n",
        "        two = OldTex(\"2\")\n",
        "        two.shift(ms.split()[1].get_center())\n",
        "        half = kinetic.split()[0]\n",
        "        sqrt = OldTex(\"\\\\sqrt{\\\\phantom{2mg}}\")\n",
        "        sqrt.shift(potential.get_center())\n",
        "        nudge = 0.2*LEFT\n",
        "        sqrt.shift(nudge)\n",
        "        squared = kinetic.split()[3]\n",
        "        equals = kinetic.split()[-1]\n",
        "        new_eq = equals.copy().next_to(kinetic.split()[2])\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                Point(loss_in_potential.get_left()),\n",
        "                loss_in_potential\n",
        "            ),\n",
        "            *list(map(GrowFromCenter, potential.split()))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(loss_in_potential),\n",
        "            GrowFromCenter(kinetic)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ApplyMethod(ms.shift, 5*UP))\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            half, two, \n",
        "            path_func = counterclockwise_path()\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(\n",
        "                squared, sqrt, \n",
        "                path_func = clockwise_path()\n",
        "            ),\n",
        "            Transform(equals, new_eq)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ThetaTInsteadOfXY(Scene):\n",
        "    def construct(self):\n",
        "        cycloid = Cycloid()\n",
        "        index = cycloid.get_num_points()/3\n",
        "        point = cycloid.get_points()[index]\n",
        "        vect = cycloid.get_points()[index+1]-point\n",
        "        vect /= get_norm(vect)\n",
        "        vect *= 3\n",
        "        vect_mob = Vector(point, vect)\n",
        "        dot = Dot(point)\n",
        "        xy = OldTex(\"\\\\big( x(t), y(t) \\\\big)\")\n",
        "        xy.next_to(dot, UP+RIGHT, buff = 0.1)\n",
        "        vert_line = Line(2*DOWN, 2*UP)\n",
        "        vert_line.shift(point)\n",
        "        angle = vect_mob.get_angle() + np.pi/2\n",
        "        arc = Arc(angle, radius = 1, start_angle = -np.pi/2)\n",
        "        arc.shift(point)\n",
        "        theta = OldTex(\"\\\\theta(t)\")\n",
        "        theta.next_to(arc, DOWN, buff = 0.1, aligned_edge = LEFT)\n",
        "        theta.shift(0.2*RIGHT)\n",
        "\n",
        "        self.play(ShowCreation(cycloid))\n",
        "        self.play(ShowCreation(dot))\n",
        "        self.play(ShimmerIn(xy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(xy),\n",
        "            ShowCreation(vect_mob)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            ShowCreation(vert_line),\n",
        "            ShimmerIn(theta)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DefineCurveWithKnob(PathSlidingScene):\n",
        "    def construct(self):\n",
        "        self.knob = Circle(color = BLUE_D)\n",
        "        self.knob.add_line(UP, DOWN)\n",
        "        self.knob.to_corner(UP+RIGHT)\n",
        "        self.knob.shift(0.5*DOWN)\n",
        "        self.last_angle = np.pi/2\n",
        "        arrow = Vector(ORIGIN, RIGHT)\n",
        "        arrow.next_to(self.knob, LEFT)\n",
        "        words = OldTexText(\"Turn this knob over time to define the curve\")\n",
        "        words.next_to(arrow, LEFT)\n",
        "        self.path = self.get_path()\n",
        "        self.path.shift(1.5*DOWN)\n",
        "        self.path.show()\n",
        "        self.path.set_color(BLACK)        \n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(ShowCreation(self.knob))\n",
        "        self.wait()\n",
        "        self.add(self.path)\n",
        "\n",
        "        self.slide(randy, self.path)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def get_path(self):\n",
        "        return Cycloid(end_theta = 2*np.pi)\n",
        "\n",
        "    def midslide_action(self, point, angle):\n",
        "        d_angle = angle-self.last_angle\n",
        "        self.knob.rotate(d_angle)\n",
        "        self.last_angle = angle\n",
        "        self.path.set_color(BLUE_D, lambda p : p[0] < point[0])\n",
        "\n",
        "\n",
        "\n",
        "class WonkyDefineCurveWithKnob(DefineCurveWithKnob):\n",
        "    def get_path(self):\n",
        "        return ParametricCurve(\n",
        "            lambda t : t*RIGHT + (-0.2*t-np.sin(2*np.pi*t/6))*UP,\n",
        "            start = -7, \n",
        "            end = 10\n",
        "        )\n",
        "\n",
        "\n",
        "class SlowDefineCurveWithKnob(DefineCurveWithKnob):\n",
        "    def get_path(self):\n",
        "        return ParametricCurve(\n",
        "            lambda t : t*RIGHT + (np.exp(-(t+2)**2)-0.2*np.exp(t-2)),\n",
        "            start = -4, \n",
        "            end = 4\n",
        "        )\n",
        "\n",
        "\n",
        "class BumpyDefineCurveWithKnob(DefineCurveWithKnob):\n",
        "    def get_path(self):\n",
        "\n",
        "        result = FunctionGraph(\n",
        "            lambda x : 0.05*(x**2)+0.1*np.sin(2*x)\n",
        "        )\n",
        "        result.rotate(-np.pi/20)\n",
        "        result.scale(0.7)\n",
        "        result.shift(DOWN)\n",
        "        return result\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}