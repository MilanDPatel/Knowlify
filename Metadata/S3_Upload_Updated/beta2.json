{
    "topic": "The mathematical concept being demonstrated is the probability of a coin being heads or tails, given that",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2020.beta.helpers import *\n",
        "from _2020.beta.beta1 import *\n",
        "from _2019.hyperdarts import Dartboard\n",
        "\n",
        "import scipy.stats\n",
        "\n",
        "OUTPUT_DIRECTORY = \"bayes/beta2\"\n",
        "\n",
        "\n",
        "class WeightedCoin(Scene):\n",
        "    def construct(self):\n",
        "        # Coin grid\n",
        "        bools = 50 * [True] + 50 * [False]\n",
        "        random.shuffle(bools)\n",
        "        grid = get_coin_grid(bools)\n",
        "\n",
        "        sorted_grid = VGroup(*grid)\n",
        "        sorted_grid.submobjects.sort(key=lambda m: m.symbol)\n",
        "\n",
        "        # Prob label\n",
        "        p_label = get_prob_coin_label()\n",
        "        p_label.set_height(0.7)\n",
        "        p_label.to_edge(UP)\n",
        "\n",
        "        rhs = p_label[-1]\n",
        "        rhs_box = SurroundingRectangle(rhs, color=RED)\n",
        "        rhs_label = OldTexText(\"Not necessarily\")\n",
        "        rhs_label.next_to(rhs_box, DOWN, LARGE_BUFF)\n",
        "        rhs_label.to_edge(RIGHT)\n",
        "        rhs_label.match_color(rhs_box)\n",
        "\n",
        "        rhs_arrow = Arrow(\n",
        "            rhs_label.get_top(),\n",
        "            rhs_box.get_right(),\n",
        "            buff=SMALL_BUFF,\n",
        "            path_arc=60 * DEGREES,\n",
        "            color=rhs_box.get_color()\n",
        "        )\n",
        "\n",
        "        # Introduce coin\n",
        "        self.play(FadeIn(\n",
        "            grid,\n",
        "            run_time=2,\n",
        "            rate_func=linear,\n",
        "            lag_ratio=3 / len(grid),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            grid.set_height, 5,\n",
        "            grid.to_edge, DOWN,\n",
        "            FadeInFromDown(p_label)\n",
        "        )\n",
        "\n",
        "        for coin in grid:\n",
        "            coin.generate_target()\n",
        "        sorted_coins = list(grid)\n",
        "        sorted_coins.sort(key=lambda m: m.symbol)\n",
        "        for c1, c2 in zip(sorted_coins, grid):\n",
        "            c1.target.move_to(c2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rhs_label, lag_ratio=0.1),\n",
        "            ShowCreation(rhs_arrow),\n",
        "            ShowCreation(rhs_box),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, grid,\n",
        "                path_arc=30 * DEGREES,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Alternate weightings\n",
        "        old_grid = VGroup(*sorted_coins)\n",
        "        rhs_junk_on_screen = True\n",
        "        for value in [0.2, 0.9, 0.0, 0.31]:\n",
        "            n = int(100 * value)\n",
        "            new_grid = get_coin_grid([True] * n + [False] * (100 - n))\n",
        "            new_grid.replace(grid)\n",
        "\n",
        "            anims = []\n",
        "            if rhs_junk_on_screen:\n",
        "                anims += [\n",
        "                    FadeOut(rhs_box),\n",
        "                    FadeOut(rhs_label),\n",
        "                    FadeOut(rhs_arrow),\n",
        "                ]\n",
        "                rhs_junk_on_screen = False\n",
        "\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(\n",
        "                    old_grid,\n",
        "                    0.1 * DOWN,\n",
        "                    lag_ratio=0.01,\n",
        "                    run_time=1.5\n",
        "                ),\n",
        "                FadeIn(new_grid, lag_ratio=0.01, run_time=1.5),\n",
        "                ChangeDecimalToValue(rhs, value),\n",
        "                *anims,\n",
        "            )\n",
        "            old_grid = new_grid\n",
        "\n",
        "        long_rhs = DecimalNumber(\n",
        "            0.31415926,\n",
        "            num_decimal_places=8,\n",
        "            show_ellipsis=True,\n",
        "        )\n",
        "        long_rhs.match_height(rhs)\n",
        "        long_rhs.move_to(rhs, DL)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(long_rhs, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "        # You just don't know\n",
        "        box = get_q_box(rhs)\n",
        "\n",
        "        self.remove(rhs)\n",
        "        self.play(\n",
        "            FadeOut(old_grid, lag_ratio=0.1),\n",
        "            FadeOut(long_rhs, 0.1 * RIGHT, lag_ratio=0.1),\n",
        "            Write(box),\n",
        "        )\n",
        "        p_label.add(box)\n",
        "        self.wait()\n",
        "\n",
        "        # 7/10 heads\n",
        "        bools = [True] * 7 + [False] * 3\n",
        "        random.shuffle(bools)\n",
        "        coins = VGroup(*[\n",
        "            get_coin(\"H\" if heads else \"T\")\n",
        "            for heads in bools\n",
        "        ])\n",
        "        coins.arrange(RIGHT)\n",
        "        coins.set_height(0.7)\n",
        "        coins.next_to(p_label, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        heads_arrows = VGroup(*[\n",
        "            Vector(\n",
        "                0.5 * UP,\n",
        "                max_stroke_width_to_length_ratio=15,\n",
        "                max_tip_length_to_length_ratio=0.4,\n",
        "            ).next_to(coin, DOWN)\n",
        "            for coin in coins\n",
        "            if coin.symbol == \"H\"\n",
        "        ])\n",
        "        numbers = VGroup(*[\n",
        "            Integer(i + 1).next_to(arrow, DOWN, SMALL_BUFF)\n",
        "            for i, arrow in enumerate(heads_arrows)\n",
        "        ])\n",
        "\n",
        "        for coin in coins:\n",
        "            coin.save_state()\n",
        "            coin.stretch(0, 0)\n",
        "            coin.set_opacity(0)\n",
        "\n",
        "        self.play(LaggedStartMap(Restore, coins), run_time=1)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(heads_arrows),\n",
        "            ShowIncreasingSubsets(numbers),\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Plot\n",
        "        axes = scaled_pdf_axes()\n",
        "        axes.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        axes.y_axis.numbers.set_opacity(0)\n",
        "        axes.y_axis_label.set_opacity(0)\n",
        "\n",
        "        x_axis_label = p_label[:4].copy()\n",
        "        x_axis_label.set_height(0.4)\n",
        "        x_axis_label.next_to(axes.c2p(1, 0), UR, buff=SMALL_BUFF)\n",
        "        axes.x_axis.add(x_axis_label)\n",
        "\n",
        "        n_heads = 7\n",
        "        n_tails = 3\n",
        "        graph = get_beta_graph(axes, n_heads, n_tails)\n",
        "        dist = scipy.stats.beta(n_heads + 1, n_tails + 1)\n",
        "        true_graph = axes.get_graph(dist.pdf)\n",
        "\n",
        "        v_line = Line(\n",
        "            axes.c2p(0.7, 0),\n",
        "            axes.input_to_graph_point(0.7, true_graph),\n",
        "        )\n",
        "        v_line.set_stroke(YELLOW, 4)\n",
        "\n",
        "        region = get_region_under_curve(axes, true_graph, 0.6, 0.8)\n",
        "        region.set_fill(GREY, 0.85)\n",
        "        region.set_stroke(YELLOW, 1)\n",
        "\n",
        "        eq_label = VGroup(\n",
        "            p_label[:4].copy(),\n",
        "            OldTex(\"= 0.7\"),\n",
        "        )\n",
        "        for mob in eq_label:\n",
        "            mob.set_height(0.4)\n",
        "        eq_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        pp_label = VGroup(\n",
        "            OldTex(\"P(\"),\n",
        "            eq_label,\n",
        "            OldTex(\")\"),\n",
        "        )\n",
        "        for mob in pp_label[::2]:\n",
        "            mob.set_height(0.7)\n",
        "            mob.set_color(YELLOW)\n",
        "        pp_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        pp_label.move_to(axes.c2p(0.3, 3))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(heads_arrows),\n",
        "            FadeOut(numbers),\n",
        "            Write(axes),\n",
        "            DrawBorderThenFill(graph),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(pp_label[::2]),\n",
        "            ShowCreation(v_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(p_label[:4], eq_label[0]))\n",
        "        self.play(\n",
        "            GrowFromPoint(eq_label[1], v_line.get_center())\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Look confused\n",
        "        randy = Randolph()\n",
        "        randy.set_height(1.5)\n",
        "        randy.next_to(axes.c2p(0, 0), UR, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", pp_label.get_top())\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        # Remind what the title is\n",
        "        title = OldTexText(\n",
        "            \"Probabilities\", \"of\", \"Probabilities\"\n",
        "        )\n",
        "        title.arrange(DOWN, aligned_edge=LEFT)\n",
        "        title.next_to(axes.c2p(0, 0), UR, buff=MED_LARGE_BUFF)\n",
        "        title.align_to(pp_label, LEFT)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(title, rate_func=linear))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(title))\n",
        "\n",
        "        # Continuous values\n",
        "        v_line.tracker = ValueTracker(0.7)\n",
        "        v_line.axes = axes\n",
        "        v_line.graph = true_graph\n",
        "        v_line.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                m.axes.c2p(m.tracker.get_value(), 0),\n",
        "                m.axes.input_to_graph_point(m.tracker.get_value(), m.graph),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        for value in [0.4, 0.9, 0.7]:\n",
        "            self.play(\n",
        "                v_line.tracker.set_value, value,\n",
        "                run_time=3,\n",
        "            )\n",
        "\n",
        "        # Label h\n",
        "        brace = Brace(rhs_box, DOWN, buff=SMALL_BUFF)\n",
        "        h_label = OldTex(\"h\", buff=SMALL_BUFF)\n",
        "        h_label.set_color(YELLOW)\n",
        "        h_label.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOutAndShift, coins, lambda m: (m, DOWN)),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(h_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # End\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class Eq70(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTex(\"=\", \"70\", \"\\\\%\", \"?\")\n",
        "        fix_percent(label.get_part_by_tex(\"\\\\%\")[0])\n",
        "        self.play(FadeIn(label))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowInfiniteContinuum(Scene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = scaled_pdf_axes()\n",
        "        axes.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        axes.y_axis.numbers.set_opacity(0)\n",
        "        axes.y_axis_label.set_opacity(0)\n",
        "        self.add(axes)\n",
        "\n",
        "        # Label\n",
        "        p_label = get_prob_coin_label()\n",
        "        p_label.set_height(0.7)\n",
        "        p_label.to_edge(UP)\n",
        "        box = get_q_box(p_label[-1])\n",
        "        p_label.add(box)\n",
        "\n",
        "        brace = Brace(box, DOWN, buff=SMALL_BUFF)\n",
        "        h_label = OldTex(\"h\")\n",
        "        h_label.next_to(brace, DOWN)\n",
        "        h_label.set_color(YELLOW)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(h_label, RIGHT)\n",
        "        value = DecimalNumber(0, num_decimal_places=4)\n",
        "        value.match_height(h_label)\n",
        "        value.next_to(eq, RIGHT)\n",
        "        value.set_color(YELLOW)\n",
        "\n",
        "        self.add(p_label)\n",
        "        self.add(brace)\n",
        "        self.add(h_label)\n",
        "\n",
        "        # Moving h\n",
        "        h_part = h_label.copy()\n",
        "        x_line = Line(axes.c2p(0, 0), axes.c2p(1, 0))\n",
        "        x_line.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.play(\n",
        "            h_part.next_to, x_line.get_start(), UR, SMALL_BUFF,\n",
        "            Write(eq),\n",
        "            FadeInFromPoint(value, h_part.get_center()),\n",
        "        )\n",
        "\n",
        "        # Scan continuum\n",
        "        h_part.tracked = x_line\n",
        "        value.tracked = x_line\n",
        "        value.x_axis = axes.x_axis\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            UpdateFromFunc(\n",
        "                h_part,\n",
        "                lambda m: m.next_to(m.tracked.get_end(), UR, SMALL_BUFF)\n",
        "            ),\n",
        "            UpdateFromFunc(\n",
        "                value,\n",
        "                lambda m: m.set_value(\n",
        "                    m.x_axis.p2n(m.tracked.get_end())\n",
        "                )\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(eq),\n",
        "            FadeOut(value),\n",
        "        )\n",
        "\n",
        "        # Arrows\n",
        "        arrows = VGroup()\n",
        "        arrow_template = Vector(DOWN)\n",
        "\n",
        "        def get_arrow(s, denom, arrow_template=arrow_template, axes=axes):\n",
        "            arrow = arrow_template.copy()\n",
        "            arrow.set_height(4 / denom)\n",
        "            arrow.move_to(axes.c2p(s, 0), DOWN)\n",
        "            arrow.set_color(interpolate_color(\n",
        "                GREY_A, GREY_C, random.random()\n",
        "            ))\n",
        "            return arrow\n",
        "\n",
        "        for k in range(2, 50):\n",
        "            for n in range(1, k):\n",
        "                if np.gcd(n, k) != 1:\n",
        "                    continue\n",
        "                s = n / k\n",
        "                arrows.add(get_arrow(s, k))\n",
        "        for k in range(50, 1000):\n",
        "            arrows.add(get_arrow(1 / k, k))\n",
        "            arrows.add(get_arrow(1 - 1 / k, k))\n",
        "\n",
        "        kw = {\n",
        "            \"lag_ratio\": 0.05,\n",
        "            \"run_time\": 5,\n",
        "            \"rate_func\": lambda t: t**5,\n",
        "        }\n",
        "        arrows.save_state()\n",
        "        for arrow in arrows:\n",
        "            arrow.stretch(0, 0)\n",
        "            arrow.set_stroke(width=0)\n",
        "            arrow.set_opacity(0)\n",
        "        self.play(Restore(arrows, **kw))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, arrows,\n",
        "            lambda m: (m.scale, 0, {\"about_edge\": DOWN}),\n",
        "            lag_ratio=10 / len(arrows),\n",
        "            rate_func=smooth,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.remove(arrows)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TitleCard(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"A beginner's guide to\\\\\\\\probability density\")\n",
        "        text.scale(2)\n",
        "        text.to_edge(UP, buff=1.5)\n",
        "\n",
        "        subtext = OldTexText(\"Probabilities of probabilities, \", \"part 2\")\n",
        "        subtext.set_width(FRAME_WIDTH - 3)\n",
        "        subtext[0].set_color(BLUE)\n",
        "        subtext.next_to(text, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(text)\n",
        "        self.play(FadeIn(subtext, lag_ratio=0.1, run_time=2))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class NamePdfs(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTexText(\"Probability density\\\\\\\\function\")\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LabelH(Scene):\n",
        "    def construct(self):\n",
        "        p_label = get_prob_coin_label()\n",
        "        p_label.scale(1.5)\n",
        "        brace = Brace(p_label, DOWN)\n",
        "        h = OldTex(\"h\")\n",
        "        h.scale(2)\n",
        "        h.next_to(brace, DOWN)\n",
        "\n",
        "        self.add(p_label)\n",
        "        self.play(ShowCreationThenFadeAround(p_label))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(h, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DrawUnderline(Scene):\n",
        "    def construct(self):\n",
        "        line = Line(2 * LEFT, 2 * RIGHT)\n",
        "        line.set_stroke(PINK, 5)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        line.reverse_points()\n",
        "        self.play(Uncreate(line))\n",
        "\n",
        "\n",
        "class TryAssigningProbabilitiesToSpecificValues(Scene):\n",
        "    def construct(self):\n",
        "        # To get \"P(s = .7000001) = ???\" type labels\n",
        "        def get_p_label(value):\n",
        "            result = OldTex(\n",
        "                # \"P(\", \"{s}\", \"=\", value, \"\\\\%\", \")\",\n",
        "                \"P(\", \"{h}\", \"=\", value, \")\",\n",
        "            )\n",
        "            # fix_percent(result.get_part_by_tex(\"\\\\%\")[0])\n",
        "            result.set_color_by_tex(\"{h}\", YELLOW)\n",
        "            return result\n",
        "\n",
        "        labels = VGroup(\n",
        "            get_p_label(\"0.70000000\"),\n",
        "            get_p_label(\"0.70000001\"),\n",
        "            get_p_label(\"0.70314159\"),\n",
        "            get_p_label(\"0.70271828\"),\n",
        "            get_p_label(\"0.70466920\"),\n",
        "            get_p_label(\"0.70161803\"),\n",
        "        )\n",
        "        labels.arrange(DOWN, buff=0.35, aligned_edge=LEFT)\n",
        "        labels.set_height(4.5)\n",
        "        labels.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        q_marks = VGroup()\n",
        "        gt_zero = VGroup()\n",
        "        eq_zero = VGroup()\n",
        "        for label in labels:\n",
        "            qm = OldTex(\"=\", \"\\\\,???\")\n",
        "            qm.next_to(label, RIGHT)\n",
        "            qm[1].set_color(TEAL)\n",
        "            q_marks.add(qm)\n",
        "\n",
        "            gt = OldTex(\"> 0\")\n",
        "            gt.next_to(label, RIGHT)\n",
        "            gt_zero.add(gt)\n",
        "\n",
        "            eqz = OldTex(\"= 0\")\n",
        "            eqz.next_to(label, RIGHT)\n",
        "            eq_zero.add(eqz)\n",
        "\n",
        "        v_dots = OldTex(\"\\\\vdots\")\n",
        "        v_dots.next_to(q_marks[-1][0], DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        # Animations\n",
        "        self.play(FadeInFromDown(labels[0]))\n",
        "        self.play(FadeIn(q_marks[0], LEFT))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            TransformFromCopy(m1, m2)\n",
        "            for m1, m2 in [\n",
        "                (q_marks[0], q_marks[1]),\n",
        "                (labels[0][:3], labels[1][:3]),\n",
        "                (labels[0][-1], labels[1][-1]),\n",
        "            ]\n",
        "        ])\n",
        "        self.play(ShowIncreasingSubsets(\n",
        "            labels[1][3],\n",
        "            run_time=3,\n",
        "            int_func=np.ceil,\n",
        "            rate_func=linear,\n",
        "        ))\n",
        "        self.add(labels[1])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, labels[2:],\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, q_marks[2:],\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            Write(v_dots, rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "        self.add(labels, q_marks)\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(q_marks, gt_zero, lag_ratio=0.05),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum\n",
        "        group = VGroup(labels, gt_zero, v_dots)\n",
        "        sum_label = OldTex(\n",
        "            \"\\\\sum_{0 \\\\le {h} \\\\le 1}\", \"P(\", \"{h}\", \")\", \"=\",\n",
        "            tex_to_color_map={\"{h}\": YELLOW},\n",
        "        )\n",
        "        # sum_label.set_color_by_tex(\"{s}\", YELLOW)\n",
        "        sum_label[0].set_color(WHITE)\n",
        "        sum_label.scale(1.75)\n",
        "        sum_label.next_to(ORIGIN, RIGHT, buff=1)\n",
        "        sum_label.shift(LEFT)\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.set_height(2)\n",
        "        morty.to_corner(DR)\n",
        "\n",
        "        self.play(group.to_corner, DL)\n",
        "        self.play(\n",
        "            Write(sum_label),\n",
        "            VFadeIn(morty),\n",
        "            morty.change, \"confused\", sum_label,\n",
        "        )\n",
        "\n",
        "        infty = OldTex(\"\\\\infty\")\n",
        "        zero = OldTex(\"0\")\n",
        "        for mob in [infty, zero]:\n",
        "            mob.scale(2)\n",
        "            mob.next_to(sum_label[-1], RIGHT)\n",
        "        zero.set_color(RED)\n",
        "        zero.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(infty),\n",
        "            morty.change, \"horrified\", infty,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        # If equal to zero\n",
        "        eq_zero.move_to(gt_zero)\n",
        "        eq_zero.set_color(RED)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                gt_zero, eq_zero,\n",
        "                lag_ratio=0.05,\n",
        "                run_time=2,\n",
        "                path_arc=30 * DEGREES,\n",
        "            ),\n",
        "            morty.change, \"pondering\", eq_zero,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(zero, DOWN),\n",
        "            FadeOut(infty, UP),\n",
        "            morty.change, \"sad\", zero\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WanderingArrow(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Vector(0.8 * DOWN)\n",
        "        arrow.move_to(4 * LEFT, DOWN)\n",
        "        for u in [1, -1, 1, -1, 1]:\n",
        "            self.play(\n",
        "                arrow.shift, u * 8 * RIGHT,\n",
        "                run_time=3\n",
        "            )\n",
        "\n",
        "\n",
        "class ProbabilityToContinuousValuesSupplement(Scene):\n",
        "    def construct(self):\n",
        "        nl = UnitInterval()\n",
        "        nl.set_width(10)\n",
        "        nl.add_numbers(\n",
        "            *np.arange(0, 1.1, 0.1),\n",
        "            buff=0.3,\n",
        "        )\n",
        "        nl.to_edge(LEFT)\n",
        "        self.add(nl)\n",
        "\n",
        "        def f(x):\n",
        "            return -100 * (x - 0.6) * (x - 0.8)\n",
        "\n",
        "        values = np.linspace(0.65, 0.75, 100)\n",
        "        lines = VGroup()\n",
        "        for x, color in zip(values, it.cycle([BLUE_E, BLUE_C])):\n",
        "            line = Line(ORIGIN, UP)\n",
        "            line.set_height(f(x))\n",
        "            line.set_stroke(color, 1)\n",
        "            line.move_to(nl.n2p(x), DOWN)\n",
        "            lines.add(line)\n",
        "\n",
        "        self.play(ShowCreation(lines, lag_ratio=0.9, run_time=5))\n",
        "\n",
        "        lines_row = lines.copy()\n",
        "        lines_row.generate_target()\n",
        "        for lt in lines_row.target:\n",
        "            lt.rotate(90 * DEGREES)\n",
        "        lines_row.target.arrange(RIGHT, buff=0)\n",
        "        lines_row.target.set_stroke(width=4)\n",
        "        lines_row.target.next_to(nl, UP, LARGE_BUFF)\n",
        "        lines_row.target.align_to(nl.n2p(0), LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                lines_row,\n",
        "                lag_ratio=0.1,\n",
        "                rate_func=rush_into,\n",
        "                run_time=4,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lines.set_height, 0.01, {\"about_edge\": DOWN, \"stretch\": True},\n",
        "            ApplyMethod(\n",
        "                lines_row.set_width, 0.01, {\"about_edge\": LEFT},\n",
        "                rate_func=rush_into,\n",
        "            ),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CarFactoryNumbers(Scene):\n",
        "    def construct(self):\n",
        "        # Test words\n",
        "        denom_words = OldTexText(\n",
        "            \"in a test of 100 cars\",\n",
        "            tex_to_color_map={\"100\": BLUE},\n",
        "        )\n",
        "        denom_words.to_corner(UR)\n",
        "\n",
        "        numer_words = OldTexText(\n",
        "            \"2 defects found\",\n",
        "            tex_to_color_map={\"2\": RED}\n",
        "        )\n",
        "        numer_words.move_to(denom_words, LEFT)\n",
        "\n",
        "        self.play(Write(denom_words, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            denom_words.next_to, numer_words, DOWN, {\"aligned_edge\": LEFT},\n",
        "            FadeIn(numer_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Question words\n",
        "        question = VGroup(\n",
        "            OldTexText(\"What can you say\"),\n",
        "            OldTex(\n",
        "                \"\\\\text{about } P(\\\\text{defect})?\",\n",
        "                tex_to_color_map={\"\\\\text{defect}\": RED}\n",
        "            )\n",
        "        )\n",
        "\n",
        "        question.arrange(DOWN, aligned_edge=LEFT)\n",
        "        question.next_to(denom_words, DOWN, buff=1.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(FadeIn(question))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TeacherHoldingValue(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(self.teacher.change, \"raise_right_hand\", self.screen)\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class ShowLimitToPdf(Scene):\n",
        "    def construct(self):\n",
        "        # Init\n",
        "        axes = self.get_axes()\n",
        "        alpha = 4\n",
        "        beta = 2\n",
        "        dist = scipy.stats.beta(alpha, beta)\n",
        "        bars = self.get_bars(axes, dist, 0.05)\n",
        "\n",
        "        axis_prob_label = OldTexText(\"Probability\")\n",
        "        axis_prob_label.next_to(axes.y_axis, UP)\n",
        "        axis_prob_label.to_edge(LEFT)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(axis_prob_label)\n",
        "\n",
        "        # From individual to ranges\n",
        "        kw = {\"tex_to_color_map\": {\"h\": YELLOW}}\n",
        "        eq_label = OldTex(\"P(h = 0.8)\", **kw)\n",
        "        ineq_label = OldTex(\"P(0.8 < h < 0.85)\", **kw)\n",
        "\n",
        "        arrows = VGroup(Vector(DOWN), Vector(DOWN))\n",
        "        for arrow, x in zip(arrows, [0.8, 0.85]):\n",
        "            arrow.move_to(axes.c2p(x, 0), DOWN)\n",
        "        brace = Brace(\n",
        "            Line(arrows[0].get_start(), arrows[1].get_start()),\n",
        "            UP, buff=SMALL_BUFF\n",
        "        )\n",
        "        eq_label.next_to(arrows[0], UP)\n",
        "        ineq_label.next_to(brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(eq_label, 0.2 * DOWN),\n",
        "            GrowArrow(arrows[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        vect = eq_label.get_center() - ineq_label.get_center()\n",
        "        self.play(\n",
        "            FadeOut(eq_label, -vect),\n",
        "            FadeIn(ineq_label, vect),\n",
        "            TransformFromCopy(*arrows),\n",
        "            GrowFromPoint(brace, brace.get_left()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bars\n",
        "        arrow = arrows[0]\n",
        "        arrow.generate_target()\n",
        "        arrow.target.next_to(bars[16], UP, SMALL_BUFF)\n",
        "        highlighted_bar_color = RED_E\n",
        "        bars[16].set_color(highlighted_bar_color)\n",
        "\n",
        "        for bar in bars:\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 1, about_edge=DOWN)\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 2,\n",
        "            \"rate_func\": squish_rate_func(smooth, 0.3, 0.9),\n",
        "        }\n",
        "        self.play(\n",
        "            MoveToTarget(arrow, **kw),\n",
        "            ApplyMethod(ineq_label.next_to, arrows[0].target, UP, **kw),\n",
        "            FadeOut(arrows[1]),\n",
        "            FadeOut(brace),\n",
        "            LaggedStartMap(Restore, bars, run_time=2, lag_ratio=0.025),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Focus on area, not height\n",
        "        lines = VGroup()\n",
        "        new_bars = VGroup()\n",
        "        for bar in bars:\n",
        "            line = Line(\n",
        "                bar.get_corner(DL),\n",
        "                bar.get_corner(DR),\n",
        "            )\n",
        "            line.set_stroke(YELLOW, 0)\n",
        "            line.generate_target()\n",
        "            line.target.set_stroke(YELLOW, 3)\n",
        "            line.target.move_to(bar.get_top())\n",
        "            lines.add(line)\n",
        "\n",
        "            new_bar = bar.copy()\n",
        "            new_bar.match_style(line)\n",
        "            new_bar.set_fill(YELLOW, 0.5)\n",
        "            new_bar.generate_target()\n",
        "            new_bar.stretch(0, 1, about_edge=UP)\n",
        "            new_bars.add(new_bar)\n",
        "\n",
        "        prob_label = OldTexText(\n",
        "            \"Height\",\n",
        "            \"$\\\\rightarrow$\",\n",
        "            \"Probability\",\n",
        "        )\n",
        "        prob_label.space_out_submobjects(1.1)\n",
        "        prob_label.next_to(bars[10], UL, LARGE_BUFF)\n",
        "        height_word = prob_label[0]\n",
        "        height_cross = Cross(height_word)\n",
        "        area_word = OldTexText(\"Area\")\n",
        "        area_word.move_to(height_word, UR)\n",
        "        area_word.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, lines,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            FadeInFromDown(prob_label),\n",
        "        )\n",
        "        self.add(height_word)\n",
        "        self.play(\n",
        "            ShowCreation(height_cross),\n",
        "            FadeOut(axis_prob_label, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(height_word, UP),\n",
        "            FadeOut(height_cross, UP),\n",
        "            FadeInFromDown(area_word),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, new_bars,\n",
        "                lag_ratio=0.01,\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(new_bars),\n",
        "            area_word.set_color, BLUE,\n",
        "        )\n",
        "\n",
        "        prob_label = VGroup(area_word, *prob_label[1:])\n",
        "        self.add(prob_label)\n",
        "\n",
        "        # Ask about where values come from\n",
        "        randy = Randolph(height=1)\n",
        "        randy.next_to(prob_label, UP, aligned_edge=LEFT)\n",
        "\n",
        "        bubble = SpeechBubble(\n",
        "            height=2,\n",
        "            width=4,\n",
        "        )\n",
        "        bubble.move_to(randy.get_corner(UR), DL)\n",
        "        bubble.write(\"Where do these\\\\\\\\probabilities come from?\")\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            ShowCreation(bubble),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change, \"confused\",\n",
        "            FadeIn(bubble.content, lag_ratio=0.1)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        bars.generate_target()\n",
        "        bars.save_state()\n",
        "        bars.target.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "        bars.target.next_to(bars.get_bottom(), UP)\n",
        "\n",
        "        self.play(MoveToTarget(bars))\n",
        "        self.play(LaggedStartMap(Indicate, bars, scale_factor=1.05), run_time=1)\n",
        "        self.play(Restore(bars))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "        )\n",
        "\n",
        "        # Refine\n",
        "        last_ineq_label = ineq_label\n",
        "        last_bars = bars\n",
        "        all_ineq_labels = VGroup(ineq_label)\n",
        "        for step_size in [0.025, 0.01, 0.005, 0.001]:\n",
        "            new_bars = self.get_bars(axes, dist, step_size)\n",
        "            new_ineq_label = OldTex(\n",
        "                \"P(0.8 < h < {:.3})\".format(0.8 + step_size),\n",
        "                tex_to_color_map={\"h\": YELLOW},\n",
        "            )\n",
        "\n",
        "            if step_size <= 0.005:\n",
        "                new_bars.set_stroke(width=0)\n",
        "\n",
        "            arrow.generate_target()\n",
        "            bar = new_bars[int(0.8 * len(new_bars))]\n",
        "            bar.set_color(highlighted_bar_color)\n",
        "            arrow.target.next_to(bar, UP, SMALL_BUFF)\n",
        "            new_ineq_label.next_to(arrow.target, UP)\n",
        "\n",
        "            vect = new_ineq_label.get_center() - last_ineq_label.get_center()\n",
        "\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    last_bars, new_bars,\n",
        "                    lag_ratio=step_size,\n",
        "                ),\n",
        "                MoveToTarget(arrow),\n",
        "                FadeOut(last_ineq_label, vect),\n",
        "                FadeIn(new_ineq_label, -vect),\n",
        "                run_time=2,\n",
        "            )\n",
        "            last_ineq_label = new_ineq_label\n",
        "            last_bars = new_bars\n",
        "            all_ineq_labels.add(new_ineq_label)\n",
        "\n",
        "        # Show continuous graph\n",
        "        graph = get_beta_graph(axes, alpha - 1, beta - 1)\n",
        "        graph_curve = axes.get_graph(dist.pdf)\n",
        "        graph_curve.set_stroke([YELLOW, GREEN])\n",
        "\n",
        "        limit_words = OldTexText(\"In the limit...\")\n",
        "        limit_words.next_to(\n",
        "            axes.input_to_graph_point(0.75, graph_curve),\n",
        "            UP, MED_LARGE_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(graph),\n",
        "            FadeOut(last_ineq_label),\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(last_bars),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(graph_curve),\n",
        "            Write(limit_words, run_time=1)\n",
        "        )\n",
        "        self.play(FadeOut(graph_curve))\n",
        "        self.wait()\n",
        "\n",
        "        # Show individual probabilities goes to zero\n",
        "        all_ineq_labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        all_ineq_labels.move_to(prob_label, LEFT)\n",
        "        all_ineq_labels.to_edge(UP)\n",
        "\n",
        "        prob_label.generate_target()\n",
        "        prob_label.target.next_to(\n",
        "            all_ineq_labels, DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "\n",
        "        rhss = VGroup()\n",
        "        step_sizes = [0.05, 0.025, 0.01, 0.005, 0.001]\n",
        "        for label, step in zip(all_ineq_labels, step_sizes):\n",
        "            eq = OldTex(\"=\")\n",
        "            decimal = DecimalNumber(\n",
        "                dist.cdf(0.8 + step) - dist.cdf(0.8),\n",
        "                num_decimal_places=3,\n",
        "            )\n",
        "            eq.next_to(label, RIGHT)\n",
        "            decimal.next_to(eq, RIGHT)\n",
        "            decimal.set_stroke(BLACK, 3, background=True)\n",
        "            rhss.add(VGroup(eq, decimal))\n",
        "\n",
        "        for rhs in rhss:\n",
        "            rhs.align_to(rhss[1], LEFT)\n",
        "\n",
        "        VGroup(all_ineq_labels, rhss).set_height(3, about_edge=UL)\n",
        "\n",
        "        arrow = Arrow(rhss.get_top(), rhss.get_bottom(), buff=0)\n",
        "        arrow.next_to(rhss, RIGHT)\n",
        "        arrow.set_color(YELLOW)\n",
        "        to_zero_words = OldTexText(\"Individual probabilites\\\\\\\\\", \"go to zero\")\n",
        "        to_zero_words[1].align_to(to_zero_words[0], LEFT)\n",
        "        to_zero_words.next_to(arrow, RIGHT, aligned_edge=UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, all_ineq_labels,\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, rhss,\n",
        "                lambda m: (m, UP),\n",
        "            ),\n",
        "            MoveToTarget(prob_label)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(to_zero_words),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Indicate, rhss,\n",
        "                scale_factor=1.05,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # What if it was heights\n",
        "        bars.restore()\n",
        "        height_word.move_to(area_word, RIGHT)\n",
        "        height_word.set_color(PINK)\n",
        "        step = 0.05\n",
        "        new_y_numbers = VGroup(*[\n",
        "            DecimalNumber(x) for x in np.arange(step, 5 * step, step)\n",
        "        ])\n",
        "        for n1, n2 in zip(axes.y_axis.numbers, new_y_numbers):\n",
        "            n2.match_height(n1)\n",
        "            n2.add_background_rectangle(\n",
        "                opacity=1,\n",
        "                buff=SMALL_BUFF,\n",
        "            )\n",
        "            n2.move_to(n1, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(limit_words),\n",
        "            FadeOut(graph),\n",
        "            FadeIn(bars),\n",
        "            FadeOut(area_word, UP),\n",
        "            FadeIn(height_word, DOWN),\n",
        "            FadeIn(new_y_numbers, 0.5 * RIGHT),\n",
        "        )\n",
        "\n",
        "        # Height refine\n",
        "        rect = SurroundingRectangle(rhss[0][1])\n",
        "        rect.set_stroke(RED, 3)\n",
        "        self.play(FadeIn(rect))\n",
        "\n",
        "        last_bars = bars\n",
        "        for step_size, rhs in zip(step_sizes[1:], rhss[1:]):\n",
        "            new_bars = self.get_bars(axes, dist, step_size)\n",
        "            bar = new_bars[int(0.8 * len(new_bars))]\n",
        "            bar.set_color(highlighted_bar_color)\n",
        "            new_bars.stretch(\n",
        "                step_size / 0.05, 1,\n",
        "                about_edge=DOWN,\n",
        "            )\n",
        "            if step_size <= 0.05:\n",
        "                new_bars.set_stroke(width=0)\n",
        "            self.remove(last_bars)\n",
        "            self.play(\n",
        "                TransformFromCopy(last_bars, new_bars, lag_ratio=step_size),\n",
        "                rect.move_to, rhs[1],\n",
        "            )\n",
        "            last_bars = new_bars\n",
        "        self.play(\n",
        "            FadeOut(last_bars),\n",
        "            FadeOutAndShiftDown(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Back to area\n",
        "        self.play(\n",
        "            FadeIn(graph),\n",
        "            FadeIn(area_word, 0.5 * DOWN),\n",
        "            FadeOut(height_word, 0.5 * UP),\n",
        "            FadeOut(new_y_numbers, lag_ratio=0.2),\n",
        "        )\n",
        "        self.play(\n",
        "            arrow.scale, 0, {\"about_edge\": DOWN},\n",
        "            FadeOut(to_zero_words, DOWN),\n",
        "            LaggedStartMap(FadeOutAndShiftDown, all_ineq_labels),\n",
        "            LaggedStartMap(FadeOutAndShiftDown, rhss),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about y_axis units\n",
        "        arrow = Arrow(\n",
        "            axes.y_axis.get_top() + 3 * RIGHT,\n",
        "            axes.y_axis.get_top(),\n",
        "            path_arc=90 * DEGREES,\n",
        "        )\n",
        "        question = OldTexText(\"What are the\\\\\\\\units here?\")\n",
        "        question.next_to(arrow.get_start(), DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question, lag_ratio=0.1),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Bring back bars\n",
        "        bars = self.get_bars(axes, dist, 0.05)\n",
        "        self.play(\n",
        "            FadeOut(graph),\n",
        "            FadeIn(bars),\n",
        "        )\n",
        "        bars.generate_target()\n",
        "        bars.save_state()\n",
        "        bars.target.set_opacity(0.2)\n",
        "        bar_index = int(0.8 * len(bars))\n",
        "        bars.target[bar_index].set_opacity(0.8)\n",
        "        bar = bars[bar_index]\n",
        "\n",
        "        prob_word = OldTexText(\"Probability\")\n",
        "        prob_word.rotate(90 * DEGREES)\n",
        "        prob_word.set_height(0.8 * bar.get_height())\n",
        "        prob_word.move_to(bar)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(bars),\n",
        "            Write(prob_word, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show dimensions of bar\n",
        "        top_brace = Brace(bar, UP)\n",
        "        side_brace = Brace(bar, LEFT)\n",
        "        top_label = top_brace.get_tex(\"\\\\Delta x\")\n",
        "        side_label = side_brace.get_tex(\n",
        "            \"{\\\\text{Prob.} \\\\over \\\\Delta x}\"\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(top_brace),\n",
        "            FadeIn(top_label),\n",
        "        )\n",
        "        self.play(GrowFromCenter(side_brace))\n",
        "        self.wait()\n",
        "        self.play(Write(side_label))\n",
        "        self.wait()\n",
        "\n",
        "        y_label = OldTexText(\"Probability density\")\n",
        "        y_label.next_to(axes.y_axis, UP, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Uncreate(arrow),\n",
        "            FadeOutAndShiftDown(question),\n",
        "            Write(y_label),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Restore(bars),\n",
        "            FadeOut(top_brace),\n",
        "            FadeOut(side_brace),\n",
        "            FadeOut(top_label),\n",
        "            FadeOut(side_label),\n",
        "            FadeOut(prob_word),\n",
        "        )\n",
        "\n",
        "        # Point out total area is 1\n",
        "        total_label = OldTexText(\"Total area = 1\")\n",
        "        total_label.set_height(0.5)\n",
        "        total_label.next_to(bars, UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(total_label, DOWN))\n",
        "        bars.save_state()\n",
        "        self.play(\n",
        "            bars.arrange, RIGHT, {\"aligned_edge\": DOWN, \"buff\": SMALL_BUFF},\n",
        "            bars.move_to, bars.get_bottom() + 0.5 * UP, DOWN,\n",
        "        )\n",
        "        self.play(LaggedStartMap(Indicate, bars, scale_factor=1.05))\n",
        "        self.play(Restore(bars))\n",
        "\n",
        "        # Refine again\n",
        "        for step_size in step_sizes[1:]:\n",
        "            new_bars = self.get_bars(axes, dist, step_size)\n",
        "            if step_size <= 0.05:\n",
        "                new_bars.set_stroke(width=0)\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    bars, new_bars, lag_ratio=step_size\n",
        "                ),\n",
        "                run_time=3,\n",
        "            )\n",
        "            self.wait()\n",
        "            bars = new_bars\n",
        "        self.add(graph, total_label)\n",
        "        self.play(\n",
        "            FadeIn(graph),\n",
        "            FadeOut(bars),\n",
        "            total_label.move_to, axes.c2p(0.7, 0.8)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name pdf\n",
        "        func_name = OldTexText(\"Probability \", \"Density \", \"Function\")\n",
        "        initials = OldTexText(\"P\", \"D\", \"F\")\n",
        "        for mob in func_name, initials:\n",
        "            mob.set_color(YELLOW)\n",
        "            mob.next_to(axes.input_to_graph_point(0.75, graph_curve), UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph_curve),\n",
        "            Write(func_name, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        func_name_copy = func_name.copy()\n",
        "        self.play(\n",
        "            func_name.next_to, initials, UP,\n",
        "            *[\n",
        "                ReplacementTransform(np[0], ip[0])\n",
        "                for np, ip in zip(func_name_copy, initials)\n",
        "            ],\n",
        "            *[\n",
        "                FadeOut(np[1:])\n",
        "                for np in func_name_copy\n",
        "            ]\n",
        "        )\n",
        "        self.add(initials)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(func_name),\n",
        "            FadeOut(total_label),\n",
        "            FadeOut(graph_curve),\n",
        "            initials.next_to, axes.input_to_graph_point(0.95, graph_curve), UR,\n",
        "        )\n",
        "\n",
        "        # Look at bounded area\n",
        "        min_x = 0.6\n",
        "        max_x = 0.8\n",
        "        region = get_region_under_curve(axes, graph_curve, min_x, max_x)\n",
        "        area_label = DecimalNumber(\n",
        "            dist.cdf(max_x) - dist.cdf(min_x),\n",
        "            num_decimal_places=3,\n",
        "        )\n",
        "        area_label.move_to(region)\n",
        "\n",
        "        v_lines = VGroup()\n",
        "        for x in [min_x, max_x]:\n",
        "            v_lines.add(\n",
        "                DashedLine(\n",
        "                    axes.c2p(x, 0),\n",
        "                    axes.c2p(x, 2.5),\n",
        "                )\n",
        "            )\n",
        "        v_lines.set_stroke(YELLOW, 2)\n",
        "\n",
        "        p_label = VGroup(\n",
        "            OldTex(\"P(\"),\n",
        "            DecimalNumber(min_x),\n",
        "            OldTex(\"\\\\le\"),\n",
        "            OldTex(\"h\", color=YELLOW),\n",
        "            OldTex(\"\\\\le\"),\n",
        "            DecimalNumber(max_x),\n",
        "            OldTex(\")\")\n",
        "        )\n",
        "        p_label.arrange(RIGHT, buff=0.25)\n",
        "        VGroup(p_label[0], p_label[-1]).space_out_submobjects(0.92)\n",
        "        p_label.next_to(v_lines, UP)\n",
        "\n",
        "        rhs = VGroup(\n",
        "            OldTex(\"=\"),\n",
        "            area_label.copy()\n",
        "        )\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.next_to(p_label, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(p_label, 2 * DOWN),\n",
        "            *map(ShowCreation, v_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "        region.func = get_region_under_curve\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                region,\n",
        "                lambda m, a: m.become(\n",
        "                    m.func(\n",
        "                        m.axes, m.graph,\n",
        "                        m.min_x,\n",
        "                        interpolate(m.min_x, m.max_x, a)\n",
        "                    )\n",
        "                )\n",
        "            ),\n",
        "            CountInFrom(area_label),\n",
        "            UpdateFromAlphaFunc(\n",
        "                area_label,\n",
        "                lambda m, a: m.set_opacity(a),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(area_label, rhs[1]),\n",
        "            Write(rhs[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change range\n",
        "        new_x = np.mean([min_x, max_x])\n",
        "        area_label.original_width = area_label.get_width()\n",
        "        region.new_x = new_x\n",
        "        # Squish to area 1\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(p_label[1], new_x),\n",
        "            ChangeDecimalToValue(p_label[5], new_x),\n",
        "            ChangeDecimalToValue(area_label, 0),\n",
        "            UpdateFromAlphaFunc(\n",
        "                area_label,\n",
        "                lambda m, a: m.set_width(\n",
        "                    interpolate(m.original_width, 1e-6, a)\n",
        "                )\n",
        "            ),\n",
        "            ChangeDecimalToValue(rhs[1], 0),\n",
        "            v_lines[0].move_to, axes.c2p(new_x, 0), DOWN,\n",
        "            v_lines[1].move_to, axes.c2p(new_x, 0), DOWN,\n",
        "            UpdateFromAlphaFunc(\n",
        "                region,\n",
        "                lambda m, a: m.become(m.func(\n",
        "                    m.axes, m.graph,\n",
        "                    interpolate(m.min_x, m.new_x, a),\n",
        "                    interpolate(m.max_x, m.new_x, a),\n",
        "                ))\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Stretch to area 1\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(p_label[1], 0),\n",
        "            ChangeDecimalToValue(p_label[5], 1),\n",
        "            ChangeDecimalToValue(area_label, 1),\n",
        "            UpdateFromAlphaFunc(\n",
        "                area_label,\n",
        "                lambda m, a: m.set_width(\n",
        "                    interpolate(1e-6, m.original_width, clip(5 * a, 0, 1))\n",
        "                )\n",
        "            ),\n",
        "            ChangeDecimalToValue(rhs[1], 1),\n",
        "            v_lines[0].move_to, axes.c2p(0, 0), DOWN,\n",
        "            v_lines[1].move_to, axes.c2p(1, 0), DOWN,\n",
        "            UpdateFromAlphaFunc(\n",
        "                region,\n",
        "                lambda m, a: m.become(m.func(\n",
        "                    m.axes, m.graph,\n",
        "                    interpolate(m.new_x, 0, a),\n",
        "                    interpolate(m.new_x, 1, a),\n",
        "                ))\n",
        "            ),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=1,\n",
        "            x_axis_config={\n",
        "                \"tick_frequency\": 0.05,\n",
        "                \"unit_size\": 12,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "            y_min=0,\n",
        "            y_max=4,\n",
        "            y_axis_config={\n",
        "                \"tick_frequency\": 1,\n",
        "                \"unit_size\": 1.25,\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        )\n",
        "        axes.center()\n",
        "\n",
        "        h_label = OldTex(\"h\")\n",
        "        h_label.set_color(YELLOW)\n",
        "        h_label.next_to(axes.x_axis.n2p(1), UR, buff=0.2)\n",
        "        axes.x_axis.add(h_label)\n",
        "        axes.x_axis.label = h_label\n",
        "\n",
        "        axes.x_axis.add_numbers(\n",
        "            *np.arange(0.2, 1.2, 0.2),\n",
        "            num_decimal_places=1\n",
        "        )\n",
        "        axes.y_axis.add_numbers(*range(1, 5))\n",
        "        return axes\n",
        "\n",
        "    def get_bars(self, axes, dist, step_size):\n",
        "        bars = VGroup()\n",
        "        for x in np.arange(0, 1, step_size):\n",
        "            bar = Rectangle()\n",
        "            bar.set_stroke(BLUE, 2)\n",
        "            bar.set_fill(BLUE, 0.5)\n",
        "            h_line = Line(\n",
        "                axes.c2p(x, 0),\n",
        "                axes.c2p(x + step_size, 0),\n",
        "            )\n",
        "            v_line = Line(\n",
        "                axes.c2p(0, 0),\n",
        "                axes.c2p(0, dist.pdf(x)),\n",
        "            )\n",
        "            bar.match_width(h_line, stretch=True)\n",
        "            bar.match_height(v_line, stretch=True)\n",
        "            bar.move_to(h_line, DOWN)\n",
        "            bars.add(bar)\n",
        "        return bars\n",
        "\n",
        "\n",
        "class FiniteVsContinuum(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        f_title = OldTexText(\"Discrete context\")\n",
        "        f_title.set_height(0.5)\n",
        "        f_title.to_edge(UP)\n",
        "        f_underline = Underline(f_title)\n",
        "        f_underline.scale(1.3)\n",
        "        f_title.add(f_underline)\n",
        "        self.add(f_title)\n",
        "\n",
        "        # Equations\n",
        "        dice = get_die_faces()[::2]\n",
        "        cards = [PlayingCard(letter + \"H\") for letter in \"A35\"]\n",
        "\n",
        "        eqs = VGroup(\n",
        "            self.get_union_equation(dice),\n",
        "            self.get_union_equation(cards),\n",
        "        )\n",
        "        for eq in eqs:\n",
        "            eq.set_width(FRAME_WIDTH - 1)\n",
        "        eqs.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        eqs.next_to(f_underline, DOWN, LARGE_BUFF)\n",
        "\n",
        "        anims = []\n",
        "        for eq in eqs:\n",
        "            movers = eq.mob_copies1.copy()\n",
        "            for m1, m2 in zip(movers, eq.mob_copies2):\n",
        "                m1.generate_target()\n",
        "                m1.target.replace(m2)\n",
        "            eq.mob_copies2.set_opacity(0)\n",
        "            eq.add(movers)\n",
        "\n",
        "            self.play(FadeIn(eq[0]))\n",
        "\n",
        "            anims.append(FadeIn(eq[1:]))\n",
        "            anims.append(LaggedStartMap(\n",
        "                MoveToTarget, movers,\n",
        "                path_arc=30 * DEGREES,\n",
        "                lag_ratio=0.1,\n",
        "            ))\n",
        "        self.wait()\n",
        "        for anim in anims:\n",
        "            self.play(anim)\n",
        "\n",
        "        # Continuum label\n",
        "        c_title = OldTexText(\"Continuous context\")\n",
        "        c_title.match_height(f_title)\n",
        "        c_underline = Underline(c_title)\n",
        "        c_underline.scale(1.25)\n",
        "\n",
        "        self.play(\n",
        "            Write(c_title, run_time=1),\n",
        "            ShowCreation(c_underline),\n",
        "            eqs[0].shift, 0.5 * UP,\n",
        "            eqs[1].shift, UP,\n",
        "        )\n",
        "\n",
        "        # Range sum\n",
        "        c_eq = OldTex(\n",
        "            \"P\\\\big(\", \"x \\\\in [0.65, 0.75]\", \"\\\\big)\",\n",
        "            \"=\",\n",
        "            \"\\\\sum_{x \\\\in [0.65, 0.75]}\",\n",
        "            \"P(\", \"x\", \")\",\n",
        "        )\n",
        "        c_eq.set_color_by_tex(\"P\", YELLOW)\n",
        "        c_eq.set_color_by_tex(\")\", YELLOW)\n",
        "        c_eq.next_to(c_underline, DOWN, LARGE_BUFF)\n",
        "        c_eq.to_edge(LEFT)\n",
        "\n",
        "        equals = c_eq.get_part_by_tex(\"=\")\n",
        "        equals.shift(SMALL_BUFF * RIGHT)\n",
        "        e_cross = Line(DL, UR)\n",
        "        e_cross.replace(equals, dim_to_match=0)\n",
        "        e_cross.set_stroke(RED, 5)\n",
        "\n",
        "        self.play(FadeIn(c_eq))\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(e_cross))\n",
        "        self.wait()\n",
        "\n",
        "    def get_union_equation(self, mobs):\n",
        "        mob_copies1 = VGroup()\n",
        "        mob_copies2 = VGroup()\n",
        "        p_color = YELLOW\n",
        "\n",
        "        # Create mob_set\n",
        "        brackets = OldTex(\"\\\\big\\\\{\\\\big\\\\}\")[0]\n",
        "        mob_set = VGroup(brackets[0])\n",
        "        commas = VGroup()\n",
        "        for mob in mobs:\n",
        "            mc = mob.copy()\n",
        "            mc.match_height(mob_set[0])\n",
        "            mob_copies1.add(mc)\n",
        "            comma = OldTex(\",\")\n",
        "            commas.add(comma)\n",
        "            mob_set.add(mc)\n",
        "            mob_set.add(comma)\n",
        "\n",
        "        mob_set.remove(commas[-1])\n",
        "        commas.remove(commas[-1])\n",
        "        mob_set.add(brackets[1])\n",
        "        mob_set.arrange(RIGHT, buff=0.15)\n",
        "        commas.set_y(mob_set[1].get_bottom()[1])\n",
        "\n",
        "        mob_set.scale(0.8)\n",
        "\n",
        "        # Create individual probabilities\n",
        "        probs = VGroup()\n",
        "        for mob in mobs:\n",
        "            prob = OldTex(\"P(\", \"x = \", \"00\", \")\")\n",
        "            index = prob.index_of_part_by_tex(\"00\")\n",
        "            mc = mob.copy()\n",
        "            mc.replace(prob[index])\n",
        "            mc.scale(0.8, about_edge=LEFT)\n",
        "            mc.match_y(prob[-1])\n",
        "            mob_copies2.add(mc)\n",
        "            prob.replace_submobject(index, mc)\n",
        "            prob[0].set_color(p_color)\n",
        "            prob[1].match_y(mc)\n",
        "            prob[-1].set_color(p_color)\n",
        "            probs.add(prob)\n",
        "\n",
        "        # Result\n",
        "        lhs = VGroup(\n",
        "            OldTex(\"P\\\\big(\", color=p_color),\n",
        "            OldTex(\"x \\\\in\"),\n",
        "            mob_set,\n",
        "            OldTex(\"\\\\big)\", color=p_color),\n",
        "        )\n",
        "        lhs.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        group = VGroup(lhs, OldTex(\"=\"))\n",
        "        for prob in probs:\n",
        "            group.add(prob)\n",
        "            group.add(OldTex(\"+\"))\n",
        "        group.remove(group[-1])\n",
        "\n",
        "        group.arrange(RIGHT, buff=0.2)\n",
        "        group.mob_copies1 = mob_copies1\n",
        "        group.mob_copies2 = mob_copies2\n",
        "\n",
        "        return group\n",
        "\n",
        "\n",
        "class ComplainAboutRuleChange(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait, the rules\\\\\\\\changed?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.play_student_changes(\"erm\", \"confused\")\n",
        "        self.wait(4)\n",
        "        self.teacher_says(\"You may enjoy\\\\\\\\``Measure theory''\")\n",
        "        self.play_all_student_changes(\n",
        "            \"pondering\",\n",
        "            look_at=self.teacher.bubble\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class HalfFiniteHalfContinuous(Scene):\n",
        "    def construct(self):\n",
        "        # Basic symbols\n",
        "        box = Rectangle(width=3, height=1.2)\n",
        "        box.set_stroke(WHITE, 2)\n",
        "        box.set_fill(GREY_E, 1)\n",
        "        box.move_to(2.5 * LEFT, RIGHT)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        arrow_labels = VGroup()\n",
        "        for vect in [UP, DOWN]:\n",
        "            arrow = Arrow(\n",
        "                box.get_corner(vect + RIGHT),\n",
        "                box.get_corner(vect + RIGHT) + 3 * RIGHT + 1.5 * vect,\n",
        "                buff=MED_SMALL_BUFF,\n",
        "            )\n",
        "            label = OldTex(\"50\\\\%\")\n",
        "            fix_percent(label[0][-1])\n",
        "            label.set_color(YELLOW)\n",
        "            label.next_to(\n",
        "                arrow.get_center(),\n",
        "                vect + LEFT,\n",
        "                buff=SMALL_BUFF,\n",
        "            )\n",
        "\n",
        "            arrow_labels.add(label)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        zero = Integer(0)\n",
        "        zero.set_height(0.5)\n",
        "        zero.next_to(arrows[0].get_end(), RIGHT)\n",
        "\n",
        "        # Half Gaussian\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=6.5,\n",
        "            y_min=0,\n",
        "            y_max=0.25,\n",
        "            y_axis_config={\n",
        "                \"tick_frequency\": 1 / 16,\n",
        "                \"unit_size\": 10,\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        )\n",
        "        axes.next_to(arrows[1].get_end(), RIGHT)\n",
        "\n",
        "        dist = scipy.stats.norm(0, 2)\n",
        "        graph = axes.get_graph(dist.pdf)\n",
        "        graph_fill = graph.copy()\n",
        "        close_off_graph(axes, graph_fill)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        graph_fill.set_fill(BLUE_E, 1)\n",
        "        graph_fill.set_stroke(BLUE_E, 0)\n",
        "\n",
        "        half_gauss = Group(\n",
        "            graph, graph_fill, axes,\n",
        "        )\n",
        "\n",
        "        # Random Decimal\n",
        "        number = DecimalNumber(num_decimal_places=4)\n",
        "        number.set_height(0.6)\n",
        "        number.move_to(box)\n",
        "\n",
        "        number.time = 0\n",
        "        number.last_change = 0\n",
        "        number.change_freq = 0.2\n",
        "\n",
        "        def update_number(number, dt, dist=dist):\n",
        "            number.time += dt\n",
        "\n",
        "            if (number.time - number.last_change) < number.change_freq:\n",
        "                return\n",
        "\n",
        "            number.last_change = number.time\n",
        "            rand_val = random.random()\n",
        "            if rand_val < 0.5:\n",
        "                number.set_value(0)\n",
        "            else:\n",
        "                number.set_value(dist.ppf(rand_val))\n",
        "\n",
        "        number.add_updater(update_number)\n",
        "\n",
        "        v_line = SurroundingRectangle(zero)\n",
        "        v_line.save_state()\n",
        "        v_line.set_stroke(YELLOW, 3)\n",
        "\n",
        "        def update_v_line(v_line, number=number, axes=axes, graph=graph):\n",
        "            x = number.get_value()\n",
        "            if x < 0.5:\n",
        "                v_line.restore()\n",
        "            else:\n",
        "                v_line.set_width(1e-6)\n",
        "                p1 = axes.c2p(x, 0)\n",
        "                p2 = axes.input_to_graph_point(x, graph)\n",
        "                v_line.set_height(get_norm(p2 - p1), stretch=True)\n",
        "                v_line.move_to(p1, DOWN)\n",
        "\n",
        "        v_line.add_updater(update_v_line)\n",
        "\n",
        "        # Add everything\n",
        "        self.add(box)\n",
        "        self.add(number)\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            GrowArrow(arrows[0]),\n",
        "            FadeIn(arrow_labels[0]),\n",
        "            GrowFromPoint(zero, box.get_corner(UR))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowArrow(arrows[1]),\n",
        "            FadeIn(arrow_labels[1]),\n",
        "            FadeIn(half_gauss),\n",
        "        )\n",
        "        self.add(v_line)\n",
        "\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class SumToIntegral(Scene):\n",
        "    def construct(self):\n",
        "        # Titles\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Discrete context\"),\n",
        "            OldTexText(\"Continuous context\"),\n",
        "        )\n",
        "        titles.set_height(0.5)\n",
        "        for title, vect in zip(titles, [LEFT, RIGHT]):\n",
        "            title.move_to(vect * FRAME_WIDTH / 4)\n",
        "            title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(titles, DOWN)\n",
        "        h_line.set_x(0)\n",
        "        v_line.center()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(VGroup(h_line, v_line)),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, titles,\n",
        "                lambda m: (m, -0.2 * m.get_center()[0] * RIGHT),\n",
        "                run_time=1,\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Sum and int\n",
        "        kw = {\"tex_to_color_map\": {\"S\": BLUE}}\n",
        "        s_sym = OldTex(\"\\\\sum\", \"_{x \\\\in S} P(x)\", **kw)\n",
        "        i_sym = OldTex(\"\\\\int_{S} p(x)\", \"\\\\text{d}x\", **kw)\n",
        "        syms = VGroup(s_sym, i_sym)\n",
        "        syms.scale(2)\n",
        "        for sym, title in zip(syms, titles):\n",
        "            sym.shift(-sym[-1].get_center())\n",
        "            sym.match_x(title)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            s_sym[0].get_corner(UP),\n",
        "            i_sym[0].get_corner(UP),\n",
        "            path_arc=-90 * DEGREES,\n",
        "        )\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(s_sym, run_time=1))\n",
        "        anims = [ShowCreation(arrow)]\n",
        "        for i, j in [(0, 0), (2, 1), (3, 2)]:\n",
        "            source = s_sym[i].deepcopy()\n",
        "            target = i_sym[j]\n",
        "            target.save_state()\n",
        "            source.generate_target()\n",
        "            target.replace(source, stretch=True)\n",
        "            source.target.replace(target, stretch=True)\n",
        "            target.set_opacity(0)\n",
        "            source.target.set_opacity(0)\n",
        "            anims += [\n",
        "                Restore(target, path_arc=-60 * DEGREES),\n",
        "                MoveToTarget(source, path_arc=-60 * DEGREES),\n",
        "            ]\n",
        "        self.play(LaggedStart(*anims))\n",
        "        self.play(FadeInFromDown(i_sym[3]))\n",
        "        self.add(i_sym)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arrow, UP),\n",
        "            syms.next_to, h_line, DOWN, {\"buff\": MED_LARGE_BUFF},\n",
        "            syms.match_x, syms,\n",
        "        )\n",
        "\n",
        "        # Add curve area in editing\n",
        "        # Add bar chart\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=10,\n",
        "            y_min=0,\n",
        "            y_max=7,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.75,\n",
        "            }\n",
        "        )\n",
        "        axes.set_width(0.5 * FRAME_WIDTH - 1)\n",
        "        axes.next_to(s_sym, DOWN)\n",
        "        axes.y_axis.add_numbers(2, 4, 6)\n",
        "\n",
        "        bars = VGroup()\n",
        "        for x, y in [(1, 1), (4, 3), (7, 2)]:\n",
        "            bar = Rectangle()\n",
        "            bar.set_stroke(WHITE, 1)\n",
        "            bar.set_fill(BLUE_D, 1)\n",
        "            line = Line(axes.c2p(x, 0), axes.c2p(x + 2, y))\n",
        "            bar.replace(line, stretch=True)\n",
        "            bars.add(bar)\n",
        "\n",
        "        addition_formula = OldTex(*\"1+3+2\")\n",
        "        addition_formula.space_out_submobjects(2.1)\n",
        "        addition_formula.next_to(bars, UP)\n",
        "\n",
        "        for bar in bars:\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 1, about_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(axes),\n",
        "            LaggedStartMap(Restore, bars),\n",
        "            LaggedStartMap(FadeInFromDown, addition_formula),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Confusion\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        morty.look_at(i_sym)\n",
        "        self.play(\n",
        "            *map(FadeOut, [axes, bars, addition_formula]),\n",
        "            FadeIn(morty)\n",
        "        )\n",
        "        self.play(morty.change, \"maybe\")\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"confused\", i_sym.get_right())\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        # Focus on integral\n",
        "        self.play(\n",
        "            Uncreate(VGroup(v_line, h_line)),\n",
        "            FadeOut(titles, UP),\n",
        "            FadeOut(morty, RIGHT),\n",
        "            FadeOut(s_sym, LEFT),\n",
        "            i_sym.center,\n",
        "            i_sym.to_edge, LEFT\n",
        "        )\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for vect in [UP, DOWN]:\n",
        "            corner = i_sym[-1].get_corner(RIGHT + vect)\n",
        "            arrows.add(Arrow(\n",
        "                corner,\n",
        "                corner + 2 * RIGHT + 2 * vect,\n",
        "                path_arc=-np.sign(vect[1]) * 60 * DEGREES,\n",
        "            ))\n",
        "\n",
        "        self.play(*map(ShowCreation, arrows))\n",
        "\n",
        "        # Types of integration\n",
        "        dist = scipy.stats.beta(7 + 1, 3 + 1)\n",
        "        axes_pair = VGroup()\n",
        "        graph_pair = VGroup()\n",
        "        for arrow in arrows:\n",
        "            axes = get_beta_dist_axes(y_max=5, y_unit=1)\n",
        "            axes.set_width(4)\n",
        "            axes.next_to(arrow.get_end(), RIGHT)\n",
        "            graph = axes.get_graph(dist.pdf)\n",
        "            graph.set_stroke(BLUE, 2)\n",
        "            graph.set_fill(BLUE_E, 0)\n",
        "            graph.make_smooth()\n",
        "            axes_pair.add(axes)\n",
        "            graph_pair.add(graph)\n",
        "\n",
        "        r_axes, l_axes = axes_pair\n",
        "        r_graph, l_graph = graph_pair\n",
        "        r_name = OldTexText(\"Riemann\\\\\\\\Integration\")\n",
        "        r_name.next_to(r_axes, RIGHT)\n",
        "        l_name = OldTexText(\"Lebesgue\\\\\\\\Integration$^*$\")\n",
        "        l_name.next_to(l_axes, RIGHT)\n",
        "        footnote = OldTexText(\"*a bit more complicated than\\\\\\\\these bars make it look\")\n",
        "        footnote.match_width(l_name)\n",
        "        footnote.next_to(l_name, DOWN)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(r_axes),\n",
        "            FadeIn(r_graph),\n",
        "            FadeIn(r_name),\n",
        "            FadeIn(l_axes),\n",
        "            FadeIn(l_graph),\n",
        "            FadeIn(l_name),\n",
        "            run_time=1,\n",
        "        ))\n",
        "\n",
        "        # Approximation bars\n",
        "        def get_riemann_rects(dx, axes=r_axes, func=dist.pdf):\n",
        "            bars = VGroup()\n",
        "            for x in np.arange(0, 1, dx):\n",
        "                bar = Rectangle()\n",
        "                line = Line(\n",
        "                    axes.c2p(x, 0),\n",
        "                    axes.c2p(x + dx, func(x)),\n",
        "                )\n",
        "                bar.replace(line, stretch=True)\n",
        "                bar.set_stroke(BLUE_E, width=10 * dx, opacity=1)\n",
        "                bar.set_fill(BLUE, 0.5)\n",
        "                bars.add(bar)\n",
        "            return bars\n",
        "\n",
        "        def get_lebesgue_bars(dy, axes=l_axes, func=dist.pdf, mx=0.7, y_max=dist.pdf(0.7)):\n",
        "            bars = VGroup()\n",
        "            for y in np.arange(dy, y_max + dy, dy):\n",
        "                x0 = binary_search(func, y, 0, mx) or mx\n",
        "                x1 = binary_search(func, y, mx, 1) or mx\n",
        "                line = Line(axes.c2p(x0, y - dy), axes.c2p(x1, y))\n",
        "                bar = Rectangle()\n",
        "                bar.set_stroke(RED_E, 0)\n",
        "                bar.set_fill(RED_E, 0.5)\n",
        "                bar.replace(line, stretch=True)\n",
        "                bars.add(bar)\n",
        "            return bars\n",
        "\n",
        "        r_bar_groups = []\n",
        "        l_bar_groups = []\n",
        "        Ns = [10, 20, 40, 80, 160]\n",
        "        Ms = [2, 4, 8, 16, 32]\n",
        "        for N, M in zip(Ns, Ms):\n",
        "            r_bar_groups.append(get_riemann_rects(dx=1 / N))\n",
        "            l_bar_groups.append(get_lebesgue_bars(dy=1 / M))\n",
        "        self.play(\n",
        "            FadeIn(r_bar_groups[0], lag_ratio=0.1),\n",
        "            FadeIn(l_bar_groups[0], lag_ratio=0.1),\n",
        "            FadeIn(footnote),\n",
        "        )\n",
        "        self.wait()\n",
        "        for rbg0, rbg1, lbg0, lbg1 in zip(r_bar_groups, r_bar_groups[1:], l_bar_groups, l_bar_groups[1:]):\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    rbg0, rbg1,\n",
        "                    lag_ratio=1 / len(rbg0),\n",
        "                    run_time=2,\n",
        "                ),\n",
        "                ReplacementTransform(\n",
        "                    lbg0, lbg1,\n",
        "                    lag_ratio=1 / len(lbg0),\n",
        "                    run_time=2,\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeOut(r_bar_groups[-1]),\n",
        "            FadeOut(l_bar_groups[-1]),\n",
        "            r_graph.set_fill, BLUE_E, 1,\n",
        "            l_graph.set_fill, RED_E, 1,\n",
        "        )\n",
        "\n",
        "\n",
        "class MeasureTheoryLeadsTo(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Measure Theory\")\n",
        "        words.set_color(RED)\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(words, DOWN, buff=SMALL_BUFF)\n",
        "        arrow.set_stroke(width=7)\n",
        "        arrow.rotate(45 * DEGREES, about_point=arrow.get_start())\n",
        "        self.play(\n",
        "            FadeIn(words, DOWN),\n",
        "            GrowArrow(arrow),\n",
        "            UpdateFromAlphaFunc(arrow, lambda m, a: m.set_opacity(a)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhenIWasFirstLearning(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher.change_mode(\"raise_right_hand\")\n",
        "        self.play(\n",
        "            self.change_students(\"pondering\", \"thinking\", \"tease\"),\n",
        "            self.teacher.change, \"thinking\",\n",
        "        )\n",
        "\n",
        "        younger = BabyPiCreature(color=GREY_BROWN)\n",
        "        younger.set_height(2)\n",
        "        younger.move_to(self.students, DL)\n",
        "\n",
        "        self.look_at(self.screen)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(self.teacher, younger),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShift, self.students,\n",
        "                lambda m: (m, DOWN),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Bubble\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble[-1].set_fill(GREEN_SCREEN, 1)\n",
        "        bubble.move_to(younger.get_corner(UR), DL)\n",
        "\n",
        "        self.play(\n",
        "            Write(bubble),\n",
        "            younger.change, \"maybe\", bubble.get_bubble_center(),\n",
        "        )\n",
        "        self.play(Blink(younger))\n",
        "        for mode in [\"confused\", \"angry\", \"pondering\", \"maybe\"]:\n",
        "            self.play(younger.change, mode)\n",
        "            for x in range(2):\n",
        "                self.wait()\n",
        "                if random.random() < 0.5:\n",
        "                    self.play(Blink(younger))\n",
        "\n",
        "\n",
        "class PossibleYetProbabilityZero(Scene):\n",
        "    def construct(self):\n",
        "        poss = OldTexText(\"Possible\")\n",
        "        prob = OldTexText(\"Probability = 0\")\n",
        "        total = OldTexText(\"P(dart hits somewhere) = 1\")\n",
        "        # total[1].next_to(total[0][0], RIGHT)\n",
        "        words = VGroup(poss, prob, total)\n",
        "        words.scale(1.5)\n",
        "        words.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(poss, run_time=0.5))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(prob, UP))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(total, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TiePossibleToDensity(Scene):\n",
        "    def construct(self):\n",
        "        poss = OldTexText(\"Possibility\")\n",
        "        prob = OldTexText(\"Probability\", \" $>$ 0\")\n",
        "        dens = OldTexText(\"Probability \\\\emph{density}\", \" $>$ 0\")\n",
        "        dens[0].set_color(BLUE)\n",
        "        implies = OldTex(\"\\\\Rightarrow\")\n",
        "        implies2 = implies.copy()\n",
        "\n",
        "        poss.next_to(implies, LEFT)\n",
        "        prob.next_to(implies, RIGHT)\n",
        "        dens.next_to(implies, RIGHT)\n",
        "        cross = Cross(implies)\n",
        "\n",
        "        self.camera.frame.scale(0.7, about_point=dens.get_center())\n",
        "\n",
        "        self.add(poss)\n",
        "        self.play(\n",
        "            FadeIn(prob, LEFT),\n",
        "            Write(implies, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            VGroup(implies, cross, prob).shift, UP,\n",
        "            FadeIn(implies2),\n",
        "            FadeIn(dens),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class DrawBigRect(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(width=7, height=2.5)\n",
        "        rect.set_stroke(RED, 5)\n",
        "        rect.to_edge(RIGHT)\n",
        "\n",
        "        words = OldTexText(\"Not how to\\\\\\\\think about it\")\n",
        "        words.set_color(RED)\n",
        "        words.align_to(rect, LEFT)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            words.get_bottom(),\n",
        "            rect.get_top(),\n",
        "            buff=0.25,\n",
        "            color=RED,\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            FadeInFromDown(words),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        dartboard = Dartboard()\n",
        "        axes = NumberPlane(\n",
        "            x_min=-1.25,\n",
        "            x_max=1.25,\n",
        "            y_min=-1.25,\n",
        "            y_max=1.25,\n",
        "            axis_config={\n",
        "                \"unit_size\": 0.5 * dartboard.get_width(),\n",
        "                \"tick_frequency\": 0.25,\n",
        "            },\n",
        "            x_line_frequency=1.0,\n",
        "            y_line_frequency=1.0,\n",
        "        )\n",
        "        group = VGroup(dartboard, axes)\n",
        "        group.to_edge(LEFT, buff=0)\n",
        "\n",
        "        # Arrow\n",
        "        arrow = Vector(DR, max_stroke_width_to_length_ratio=np.inf)\n",
        "        arrow.move_to(axes.c2p(PI / 10, np.exp(1) / 10), DR)\n",
        "        arrow.scale(1.5, about_edge=DR)\n",
        "        arrow.set_stroke(WHITE, 10)\n",
        "\n",
        "        black_arrow = arrow.copy()\n",
        "        black_arrow.set_color(BLACK)\n",
        "        black_arrow.set_stroke(width=20)\n",
        "\n",
        "        arrow.get_points()[0] += 0.025 * DR\n",
        "\n",
        "        # Coords\n",
        "        coords = OldTex(\"(x, y) = (0.31415\\\\dots, 0.27182\\\\dots)\")\n",
        "        coords.set_width(5.5)\n",
        "        coords.set_stroke(BLACK, 10, background=True)\n",
        "        coords.next_to(axes.get_bottom(), UP, buff=0)\n",
        "\n",
        "        # Words\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Probability = 0\"),\n",
        "            OldTexText(\"$\\\\dots$but still possible\"),\n",
        "        )\n",
        "        for word in words:\n",
        "            word.set_width(6)\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        words.next_to(axes, RIGHT)\n",
        "        words.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        # Pi\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        morty.change(\"confused\", words)\n",
        "\n",
        "        self.add(group)\n",
        "        self.add(black_arrow)\n",
        "        self.add(arrow)\n",
        "        self.add(coords)\n",
        "        self.add(words)\n",
        "        self.add(morty)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class Part2EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"scroll_time\": 30,\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adam D\u0159\u00ednek\",\n",
        "            \"Aidan Shenkman\",\n",
        "            \"Alan Stein\",\n",
        "            \"Albin Egasse\",\n",
        "            \"Alex Mijalis\",\n",
        "            \"Alexander Mai\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Andrew Cary\",\n",
        "            \"Andrew R. Whalley\",\n",
        "            \"Anthony Losego\",\n",
        "            \"Aravind C V\",\n",
        "            \"Arjun Chakroborty\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Ashwin Siddarth\",\n",
        "            \"Augustine Lim\",\n",
        "            \"Austin Goodman\",\n",
        "            \"Avi Finkel\",\n",
        "            \"Awoo\",\n",
        "            \"Axel Ericsson\",\n",
        "            \"Ayan Doss\",\n",
        "            \"AZsorcerer\",\n",
        "            \"Barry Fam\",\n",
        "            \"Ben Delo\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Bill Gatliff\",\n",
        "            \"Bob Sanderson\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Bradley Pirtle\",\n",
        "            \"Brandon Huang\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Britton Finley\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Calvin Lin\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Charlie N\",\n",
        "            \"Chenna Kautilya\",\n",
        "            \"Chris Connett\",\n",
        "            \"Chris Druta\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"cinterloper\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Colwyn Fritze-Moor\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Corey Ogburn\",\n",
        "            \"D. Sivakumar\",\n",
        "            \"Dan Herbatschek\",\n",
        "            \"Daniel Brown\",\n",
        "            \"Daniel Herrera C\",\n",
        "            \"Darrell Thomas\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"dave nicponski\",\n",
        "            \"David B. Hill\",\n",
        "            \"David Clark\",\n",
        "            \"David Gow\",\n",
        "            \"Delton Ding\",\n",
        "            \"Dominik Wagner\",\n",
        "            \"Eddie Landesberg\",\n",
        "            \"Eduardo Rodriguez\",\n",
        "            \"emptymachine\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Fernando Via Canel\",\n",
        "            \"Frank R. Brown, Jr.\",\n",
        "            \"Gavin\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Goodwine\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Hitoshi Yamauchi\",\n",
        "            \"Ivan Sorokin\",\n",
        "            \"Jacob Baxter\",\n",
        "            \"Jacob Harmon\",\n",
        "            \"Jacob Hartmann\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jalex Stark\",\n",
        "            \"Jameel Syed\",\n",
        "            \"James Beall\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jayne Gabriele\",\n",
        "            \"Jean-Manuel Izaret\",\n",
        "            \"Jeff Dodds\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Jimmy Yang\",\n",
        "            \"John C. Vesey\",\n",
        "            \"John Camp\",\n",
        "            \"John Haley\",\n",
        "            \"John Le\",\n",
        "            \"John Luttig\",\n",
        "            \"John Rizzo\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Heckerman\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Josh Kinnear\",\n",
        "            \"Joshua Claeys\",\n",
        "            \"Joshua Ouellette\",\n",
        "            \"Juan Benet\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Karl Niu\",\n",
        "            \"Kartik Cating-Subramanian\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Killian McGuinness\",\n",
        "            \"Klaas Moerman\",\n",
        "            \"Kros Dai\",\n",
        "            \"L0j1k\",\n",
        "            \"Lael S Costa\",\n",
        "            \"LAI Oscar\",\n",
        "            \"Lambda GPU Workstations\",\n",
        "            \"Laura Gast\",\n",
        "            \"Lee Redden\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Lukas Zenick\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Magnus Hiie\",\n",
        "            \"Manoj Rewatkar - RITEK SOLUTIONS\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Mark Heising\",\n",
        "            \"Mark Mann\",\n",
        "            \"Martin Price\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Godbolt\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matt Russell\",\n",
        "            \"Matteo Delabre\",\n",
        "            \"Matthew Bouchard\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Maxim Nitsche\",\n",
        "            \"Michael Bos\",\n",
        "            \"Michael Day\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Michael W White\",\n",
        "            \"Mihran Vardanyan\",\n",
        "            \"Mirik Gogri\",\n",
        "            \"Molly Mackinlay\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nate Heckmann\",\n",
        "            \"Nicholas Cahill\",\n",
        "            \"Nikita Lesnikov\",\n",
        "            \"Oleg Leonov\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "            \"Patrick Lucas\",\n",
        "            \"Pavel Dubov\",\n",
        "            \"Pesho Ivanov\",\n",
        "            \"Petar Veli\u010dkovi\u0107\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Peter Francis\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Pierre Lancien\",\n",
        "            \"Pradeep Gollakota\",\n",
        "            \"Rafael Bove Barrios\",\n",
        "            \"Randy C. Will\",\n",
        "            \"rehmi post\",\n",
        "            \"Rex Godby\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Roman Sergeychik\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Ryan Prayogo\",\n",
        "            \"Samuel Judge\",\n",
        "            \"SansWord Huang\",\n",
        "            \"Scott Gray\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"soekul\",\n",
        "            \"Solara570\",\n",
        "            \"Steve Huynh\",\n",
        "            \"Steve Muench\",\n",
        "            \"Steve Sperandeo\",\n",
        "            \"Steven Siddals\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Sunil Nagaraj\",\n",
        "            \"supershabam\",\n",
        "            \"Susanne Fenja Mehr-Koks\",\n",
        "            \"Suteerth Vishnu\",\n",
        "            \"Suthen Thomas\",\n",
        "            \"Tal Einav\",\n",
        "            \"Taras Bobrovytsky\",\n",
        "            \"Tauba Auerbach\",\n",
        "            \"Ted Suzman\",\n",
        "            \"THIS IS THE point OF NO RE tUUurRrhghgGHhhnnn\",\n",
        "            \"Thomas J Sargent\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Tihan Seale\",\n",
        "            \"Tyler Herrmann\",\n",
        "            \"Tyler McAtee\",\n",
        "            \"Tyler VanValkenburg\",\n",
        "            \"Tyler Veness\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Vasu Dubey\",\n",
        "            \"Veritasium\",\n",
        "            \"Vignesh Ganapathi Subramanian\",\n",
        "            \"Vinicius Reis\",\n",
        "            \"Vladimir Solomatin\",\n",
        "            \"Wooyong Ee\",\n",
        "            \"Xuanji Li\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Yorick Lesecque\",\n",
        "            \"Yu Jun\",\n",
        "            \"Yurii Monastyrshyn\",\n",
        "        ],\n",
        "    }\n"
    ]
}