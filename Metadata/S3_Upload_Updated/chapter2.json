{
    "topic": "The mathematical concept being demonstrated is the derivative of a function.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "DISTANCE_COLOR = BLUE\n",
        "TIME_COLOR = YELLOW\n",
        "VELOCITY_COLOR = GREEN\n",
        "\n",
        "\n",
        "#### Warning, scenes here not updated based on most recent GraphScene changes #######\n",
        "\n",
        "\n",
        "class IncrementNumber(Succession):\n",
        "    CONFIG = {\n",
        "        \"start_num\" : 0,\n",
        "        \"changes_per_second\" : 1,\n",
        "        \"run_time\" : 11,\n",
        "    }\n",
        "    def __init__(self, num_mob, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        n_iterations = int(self.run_time * self.changes_per_second)\n",
        "        new_num_mobs = [\n",
        "            OldTex(str(num)).move_to(num_mob, LEFT)\n",
        "            for num in range(self.start_num, self.start_num+n_iterations)\n",
        "        ]\n",
        "        transforms = [\n",
        "            Transform(\n",
        "                num_mob, new_num_mob, \n",
        "                run_time = 1.0/self.changes_per_second,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "            )\n",
        "            for new_num_mob in new_num_mobs\n",
        "        ]\n",
        "        Succession.__init__(\n",
        "            self, *transforms, **{\n",
        "                \"rate_func\" : None,\n",
        "                \"run_time\" : self.run_time,\n",
        "            }\n",
        "        )\n",
        "\n",
        "class IncrementTest(Scene):\n",
        "    def construct(self):\n",
        "        num = OldTex(\"0\")\n",
        "        num.shift(UP)\n",
        "        self.play(IncrementNumber(num))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "############################\n",
        "\n",
        "class Chapter2OpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"So far as the theories of mathematics are about\",\n",
        "            \"reality,\", \n",
        "            \"they are not\",\n",
        "            \"certain;\", \n",
        "            \"so far as they are\",\n",
        "            \"certain,\", \n",
        "            \"they are not about\",\n",
        "            \"reality.\",\n",
        "        ],\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"reality,\" : BLUE,\n",
        "            \"certain;\" : GREEN,\n",
        "            \"certain,\" : GREEN,\n",
        "            \"reality.\" : BLUE,\n",
        "        },\n",
        "        \"author\" : \"Albert Einstein\"\n",
        "    }\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        goals = OldTexText(\n",
        "            \"Goals: \",\n",
        "            \"1) Learn derivatives\", \n",
        "            \", 2) Avoid paradoxes.\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        goals[1].set_color(MAROON_B)\n",
        "        goals[2].set_color(RED)\n",
        "        goals[2][0].set_color(WHITE)\n",
        "        goals.to_edge(UP)\n",
        "        self.add(*goals[:2])\n",
        "\n",
        "        self.student_says(\n",
        "            \"What is a derivative?\",\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"It's actually a \\\\\\\\\",\n",
        "            \"very subtle idea\",\n",
        "            target_mode = \"well\"\n",
        "        )\n",
        "        self.play_student_changes(None, \"pondering\", \"thinking\")\n",
        "        self.play(Write(goals[2], run_time = 2))\n",
        "        self.play_student_changes(\"erm\")\n",
        "        self.student_says(\n",
        "            \"Instantaneous rate of change\", \"?\",\n",
        "            index = 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        bubble = self.get_students()[0].bubble\n",
        "        phrase = bubble.content[0]\n",
        "        bubble.content.remove(phrase)\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "            FadeOut(goals),\n",
        "            phrase.center,\n",
        "            phrase.scale, 1.5,\n",
        "            phrase.to_edge, UP,\n",
        "            *it.chain(*[\n",
        "                [\n",
        "                    pi.change_mode, mode,\n",
        "                    pi.look_at, FRAME_Y_RADIUS*UP\n",
        "                ]\n",
        "                for pi, mode in zip(self.get_pi_creatures(), [\n",
        "                    \"speaking\", \"pondering\", \"confused\", \"confused\",\n",
        "                ])\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "        change = VGroup(*phrase[-len(\"change\"):])\n",
        "        instantaneous = VGroup(*phrase[:len(\"instantaneous\")])\n",
        "        change_brace = Brace(change)\n",
        "        change_description = change_brace.get_text(\n",
        "            \"Requires multiple \\\\\\\\ points in time\"\n",
        "        )\n",
        "        instantaneous_brace = Brace(instantaneous)\n",
        "        instantaneous_description = instantaneous_brace.get_text(\n",
        "            \"One point \\\\\\\\ in time\"\n",
        "        )\n",
        "        clock = Clock()\n",
        "        clock.next_to(change_description, DOWN)\n",
        "        def get_clock_anim(run_time = 3):\n",
        "            return ClockPassesTime(\n",
        "                clock,\n",
        "                hours_passed = 0.4*run_time,\n",
        "                run_time = run_time,\n",
        "            )\n",
        "        self.play(FadeIn(clock))\n",
        "        self.play(\n",
        "            change.set_color_by_gradient, BLUE, YELLOW,\n",
        "            GrowFromCenter(change_brace),\n",
        "            Write(change_description),\n",
        "            get_clock_anim()\n",
        "        )\n",
        "        self.play(get_clock_anim(1))\n",
        "        stopped_clock = clock.copy()\n",
        "        stopped_clock.next_to(instantaneous_description, DOWN)\n",
        "        self.play(\n",
        "            instantaneous.set_color, BLUE,\n",
        "            GrowFromCenter(instantaneous_brace),\n",
        "            Transform(change_description.copy(), instantaneous_description),\n",
        "            clock.copy().next_to, instantaneous_description, DOWN,\n",
        "            get_clock_anim(3)\n",
        "        )\n",
        "        self.play(get_clock_anim(12))\n",
        "\n",
        "class FathersOfCalculus(Scene):\n",
        "    CONFIG = {\n",
        "        \"names\" : [\n",
        "            \"Barrow\",\n",
        "            \"Newton\", \n",
        "            \"Leibniz\",\n",
        "            \"Cauchy\",\n",
        "            \"Weierstrass\",\n",
        "        ],\n",
        "        \"picture_height\" : 2.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"(A few) Fathers of Calculus\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        men = Mobject()\n",
        "        for name in self.names:\n",
        "            image = ImageMobject(name, invert = False)\n",
        "            image.set_height(self.picture_height)\n",
        "            title = OldTexText(name)\n",
        "            title.scale(0.8)\n",
        "            title.next_to(image, DOWN)\n",
        "            image.add(title)\n",
        "            men.add(image)\n",
        "        men.arrange(RIGHT, aligned_edge = UP)\n",
        "        men.shift(DOWN)\n",
        "\n",
        "        discover_brace = Brace(Mobject(*men[:3]), UP)\n",
        "        discover = discover_brace.get_text(\"Discovered it\")\n",
        "        VGroup(discover_brace, discover).set_color(BLUE)\n",
        "        rigor_brace = Brace(Mobject(*men[3:]), UP)\n",
        "        rigor = rigor_brace.get_text(\"Made it rigorous\")\n",
        "        rigor.shift(0.1*DOWN)\n",
        "        VGroup(rigor_brace, rigor).set_color(YELLOW)\n",
        "\n",
        "\n",
        "        for man in men:\n",
        "            self.play(FadeIn(man))\n",
        "        self.play(\n",
        "            GrowFromCenter(discover_brace),\n",
        "            Write(discover, run_time = 1)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(rigor_brace),\n",
        "            Write(rigor, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceCar(Scene):\n",
        "    CONFIG = {\n",
        "        \"should_transition_to_graph\" : True,\n",
        "        \"show_distance\" : True,\n",
        "        \"point_A\" : DOWN+4*LEFT,\n",
        "        \"point_B\" : DOWN+5*RIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        point_A, point_B = self.point_A, self.point_B\n",
        "        A = Dot(point_A)\n",
        "        B = Dot(point_B)\n",
        "        line = Line(point_A, point_B)\n",
        "        VGroup(A, B, line).set_color(WHITE)        \n",
        "        for dot, tex in (A, \"A\"), (B, \"B\"):\n",
        "            label = OldTex(tex).next_to(dot, DOWN)\n",
        "            dot.add(label)\n",
        "\n",
        "        car = Car()\n",
        "        self.car = car #For introduce_added_mobjects use in subclasses\n",
        "        car.move_to(point_A)\n",
        "        front_line = car.get_front_line()\n",
        "\n",
        "        time_label = OldTexText(\"Time (in seconds):\", \"0\")\n",
        "        time_label.shift(2*UP)\n",
        "\n",
        "        distance_brace = Brace(line, UP)\n",
        "        # distance_brace.set_fill(opacity = 0.5)\n",
        "        distance = distance_brace.get_text(\"100m\")\n",
        "\n",
        "        self.add(A, B, line, car, time_label)\n",
        "        self.play(ShowCreation(front_line))\n",
        "        self.play(FadeOut(front_line))\n",
        "        self.introduce_added_mobjects()\n",
        "        self.play(\n",
        "            MoveCar(car, point_B, run_time = 10),\n",
        "            IncrementNumber(time_label[1], run_time = 11),\n",
        "            *self.get_added_movement_anims()\n",
        "        )\n",
        "        front_line = car.get_front_line()\n",
        "        self.play(ShowCreation(front_line))\n",
        "        self.play(FadeOut(front_line))\n",
        "\n",
        "        if self.show_distance:\n",
        "            self.play(\n",
        "                GrowFromCenter(distance_brace),\n",
        "                Write(distance)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        if self.should_transition_to_graph:\n",
        "            self.play(\n",
        "                car.move_to, point_A,\n",
        "                FadeOut(time_label),\n",
        "                FadeOut(distance_brace),\n",
        "                FadeOut(distance),\n",
        "            )\n",
        "            graph_scene = GraphCarTrajectory(skip_animations = True)\n",
        "            origin = graph_scene.graph_origin\n",
        "            top = graph_scene.coords_to_point(0, 100)\n",
        "            new_length = get_norm(top-origin)\n",
        "            new_point_B = point_A + new_length*RIGHT\n",
        "            car_line_group = VGroup(car, A, B, line)\n",
        "            for mob in car_line_group:\n",
        "                mob.generate_target()\n",
        "            car_line_group.target = VGroup(*[\n",
        "                m.target for m in car_line_group\n",
        "            ])\n",
        "            B = car_line_group[2]\n",
        "            B.target.shift(new_point_B - point_B)\n",
        "            line.target.put_start_and_end_on(\n",
        "                point_A, new_point_B\n",
        "            )\n",
        "\n",
        "            car_line_group.target.rotate(np.pi/2, about_point = point_A)\n",
        "            car_line_group.target.shift(graph_scene.graph_origin - point_A)\n",
        "            self.play(MoveToTarget(car_line_group, path_arc = np.pi/2))\n",
        "            self.wait()\n",
        "\n",
        "    def introduce_added_mobjects(self):\n",
        "        pass\n",
        "\n",
        "    def get_added_movement_anims(self):\n",
        "        return []\n",
        "\n",
        "class GraphCarTrajectory(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 10,\n",
        "        \"x_labeled_nums\" : list(range(1, 11)),\n",
        "        \"x_axis_label\" : \"Time (seconds)\",\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 110,\n",
        "        \"y_tick_frequency\" : 10,\n",
        "        \"y_labeled_nums\" : list(range(10, 110, 10)),\n",
        "        \"y_axis_label\" : \"Distance traveled \\\\\\\\ (meters)\",\n",
        "        \"graph_origin\" : 2.5*DOWN + 5*LEFT,\n",
        "        \"default_graph_colors\" : [DISTANCE_COLOR, VELOCITY_COLOR],\n",
        "        \"default_derivative_color\" : VELOCITY_COLOR,\n",
        "        \"time_of_journey\" : 10,\n",
        "        \"care_movement_rate_func\" : smooth,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        graph = self.graph_sigmoid_trajectory_function()\n",
        "        origin = self.coords_to_point(0, 0)\n",
        "\n",
        "        self.introduce_graph(graph, origin)\n",
        "        self.comment_on_slope(graph, origin)\n",
        "        self.show_velocity_graph()\n",
        "        self.ask_critically_about_velocity()\n",
        "\n",
        "    def graph_sigmoid_trajectory_function(self, **kwargs):\n",
        "        graph = self.get_graph(\n",
        "            lambda t : 100*smooth(t/10.),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.s_graph = graph\n",
        "        return graph\n",
        "\n",
        "    def introduce_graph(self, graph, origin):\n",
        "        h_line, v_line = [\n",
        "            Line(origin, origin, color = color, stroke_width = 2)\n",
        "            for color in (TIME_COLOR, DISTANCE_COLOR)\n",
        "        ]\n",
        "        def h_update(h_line, proportion = 1):\n",
        "            end = graph.point_from_proportion(proportion)\n",
        "            t_axis_point = end[0]*RIGHT + origin[1]*UP\n",
        "            h_line.put_start_and_end_on(t_axis_point, end)\n",
        "        def v_update(v_line, proportion = 1):\n",
        "            end = graph.point_from_proportion(proportion)\n",
        "            d_axis_point = origin[0]*RIGHT + end[1]*UP\n",
        "            v_line.put_start_and_end_on(d_axis_point, end)\n",
        "\n",
        "        car = Car()\n",
        "        car.rotate(np.pi/2)\n",
        "        car.move_to(origin)\n",
        "        car_target = origin*RIGHT + graph.point_from_proportion(1)*UP\n",
        "\n",
        "\n",
        "        self.add(car)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                graph,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            MoveCar(\n",
        "                car, car_target,\n",
        "                rate_func = self.care_movement_rate_func\n",
        "            ),\n",
        "            UpdateFromFunc(h_line, h_update),\n",
        "            UpdateFromFunc(v_line, v_update),\n",
        "            run_time = self.time_of_journey,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [h_line, v_line, car])))\n",
        "\n",
        "        #Show example vertical distance\n",
        "        h_update(h_line, 0.6)\n",
        "        t_dot = Dot(h_line.get_start(), color = h_line.get_color())\n",
        "        t_dot.save_state()\n",
        "        t_dot.move_to(self.x_axis_label_mob)\n",
        "        t_dot.set_fill(opacity = 0)\n",
        "        dashed_h = DashedLine(*h_line.get_start_and_end())\n",
        "        dashed_h.set_color(h_line.get_color())\n",
        "        brace = Brace(dashed_h, RIGHT)\n",
        "        brace_text = brace.get_text(\"Distance traveled\")\n",
        "        self.play(t_dot.restore)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(dashed_h))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [t_dot, dashed_h, brace, brace_text])))\n",
        "\n",
        "        #Name graph\n",
        "        s_of_t = OldTex(\"s(t)\")\n",
        "        s_of_t.next_to(\n",
        "            graph.point_from_proportion(1), \n",
        "            DOWN+RIGHT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        s = s_of_t[0]\n",
        "        d = OldTex(\"d\")\n",
        "        d.move_to(s, DOWN)\n",
        "        d.set_color(DISTANCE_COLOR)\n",
        "\n",
        "        self.play(Write(s_of_t))\n",
        "        self.wait()\n",
        "        s.save_state()\n",
        "        self.play(Transform(s, d))\n",
        "        self.wait()\n",
        "        self.play(s.restore)\n",
        "\n",
        "    def comment_on_slope(self, graph, origin):\n",
        "        delta_t = 1\n",
        "        curr_time = 0\n",
        "        ghost_line = Line(\n",
        "            origin, \n",
        "            self.coords_to_point(delta_t, self.y_max)\n",
        "        )\n",
        "        rect = Rectangle().replace(ghost_line, stretch = True)\n",
        "        rect.set_stroke(width = 0)\n",
        "        rect.set_fill(TIME_COLOR, opacity = 0.3)\n",
        "\n",
        "        change_lines = self.get_change_lines(curr_time, delta_t)\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "        self.play(Write(change_lines))\n",
        "        self.wait()\n",
        "        for x in range(1, 10):\n",
        "            curr_time = x\n",
        "            new_change_lines = self.get_change_lines(curr_time, delta_t)\n",
        "            self.play(\n",
        "                rect.move_to, self.coords_to_point(curr_time, 0), DOWN+LEFT,\n",
        "                Transform(change_lines, new_change_lines)\n",
        "            )\n",
        "            if curr_time == 5:\n",
        "                text = change_lines[-1].get_text(\n",
        "                    \"$\\\\frac{\\\\text{meters}}{\\\\text{second}}$\"\n",
        "                )\n",
        "                self.play(Write(text))\n",
        "                self.wait()\n",
        "                self.play(FadeOut(text))\n",
        "            else:\n",
        "                self.wait()\n",
        "        self.play(*list(map(FadeOut, [rect, change_lines])))\n",
        "        self.rect = rect\n",
        "\n",
        "    def get_change_lines(self, curr_time, delta_t = 1):\n",
        "        p1 = self.input_to_graph_point(\n",
        "            curr_time, self.s_graph\n",
        "        )\n",
        "        p2 = self.input_to_graph_point(\n",
        "            curr_time+delta_t, self.s_graph\n",
        "        )\n",
        "        interim_point = p2[0]*RIGHT + p1[1]*UP\n",
        "        delta_t_line = Line(p1, interim_point, color = TIME_COLOR)\n",
        "        delta_s_line = Line(interim_point, p2, color = DISTANCE_COLOR)\n",
        "        brace = Brace(delta_s_line, RIGHT, buff = SMALL_BUFF)\n",
        "        return VGroup(delta_t_line, delta_s_line, brace)\n",
        "\n",
        "    def show_velocity_graph(self):\n",
        "        velocity_graph = self.get_derivative_graph(self.s_graph)\n",
        "\n",
        "        self.play(ShowCreation(velocity_graph))\n",
        "        def get_velocity_label(v_graph):\n",
        "            result = self.get_graph_label(\n",
        "                v_graph,\n",
        "                label = \"v(t)\",\n",
        "                direction = UP+RIGHT,\n",
        "                x_val = 5,\n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "            self.remove(result)\n",
        "            return result\n",
        "        label = get_velocity_label(velocity_graph)\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "        self.rect.move_to(self.coords_to_point(0, 0), DOWN+LEFT)\n",
        "        self.play(FadeIn(self.rect))\n",
        "        self.wait()\n",
        "        for time, show_slope in (4.5, True), (9, False):\n",
        "            self.play(\n",
        "                self.rect.move_to, self.coords_to_point(time, 0), DOWN+LEFT\n",
        "            )\n",
        "            if show_slope:\n",
        "                change_lines = self.get_change_lines(time)\n",
        "                self.play(FadeIn(change_lines))\n",
        "                self.wait()\n",
        "                self.play(FadeOut(change_lines))\n",
        "            else:\n",
        "                self.wait()\n",
        "        self.play(FadeOut(self.rect))\n",
        "\n",
        "        #Change distance and velocity graphs\n",
        "        self.s_graph.save_state()\n",
        "        velocity_graph.save_state()\n",
        "        label.save_state()\n",
        "        def shallow_slope(t):\n",
        "            return 100*smooth(t/10., inflection = 4)\n",
        "        def steep_slope(t):\n",
        "            return 100*smooth(t/10., inflection = 25)\n",
        "        def double_smooth_graph_function(t):\n",
        "            if t < 5:\n",
        "                return 50*smooth(t/5.)\n",
        "            else:\n",
        "                return 50*(1+smooth((t-5)/5.))\n",
        "        graph_funcs = [\n",
        "            shallow_slope,\n",
        "            steep_slope,\n",
        "            double_smooth_graph_function,\n",
        "        ]\n",
        "        for graph_func in graph_funcs:\n",
        "            new_graph = self.get_graph(\n",
        "                graph_func,\n",
        "                color = DISTANCE_COLOR,\n",
        "            )\n",
        "            self.remove(new_graph)\n",
        "            new_velocity_graph = self.get_derivative_graph(\n",
        "                graph = new_graph,\n",
        "            )\n",
        "            new_velocity_label = get_velocity_label(new_velocity_graph)\n",
        "\n",
        "            self.play(Transform(self.s_graph, new_graph))\n",
        "            self.play(\n",
        "                Transform(velocity_graph, new_velocity_graph),\n",
        "                Transform(label, new_velocity_label),\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play(self.s_graph.restore)\n",
        "        self.play(\n",
        "            velocity_graph.restore,\n",
        "            label.restore,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def ask_critically_about_velocity(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        self.play(PiCreatureSays(morty,\n",
        "            \"Think critically about \\\\\\\\\",\n",
        "            \"what velocity means.\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class ShowSpeedometer(IntroduceCar):\n",
        "    CONFIG = {\n",
        "        \"num_ticks\" : 8,\n",
        "        \"tick_length\" : 0.2,\n",
        "        \"needle_width\" : 0.1,\n",
        "        \"needle_height\" : 0.8,\n",
        "        \"should_transition_to_graph\" : False,\n",
        "        \"show_distance\" : False,\n",
        "        \"speedometer_title_text\" : \"Speedometer\",\n",
        "    }\n",
        "    def setup(self):\n",
        "        start_angle = -np.pi/6\n",
        "        end_angle = 7*np.pi/6\n",
        "        speedometer = Arc(\n",
        "            start_angle = start_angle,\n",
        "            angle = end_angle-start_angle\n",
        "        )\n",
        "        tick_angle_range = np.linspace(end_angle, start_angle, self.num_ticks)\n",
        "        for index, angle in enumerate(tick_angle_range):\n",
        "            vect = rotate_vector(RIGHT, angle)\n",
        "            tick = Line((1-self.tick_length)*vect, vect)\n",
        "            label = OldTex(str(10*index))\n",
        "            label.set_height(self.tick_length)\n",
        "            label.shift((1+self.tick_length)*vect)\n",
        "            speedometer.add(tick, label)\n",
        "\n",
        "        needle = Polygon(\n",
        "            LEFT, UP, RIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = 1,\n",
        "            fill_color = YELLOW\n",
        "        )\n",
        "        needle.stretch_to_fit_width(self.needle_width)\n",
        "        needle.stretch_to_fit_height(self.needle_height)\n",
        "        needle.rotate(end_angle-np.pi/2)\n",
        "        speedometer.add(needle)\n",
        "        speedometer.needle = needle\n",
        "\n",
        "        speedometer.center_offset = speedometer.get_center()\n",
        "\n",
        "        speedometer_title = OldTexText(self.speedometer_title_text)\n",
        "        speedometer_title.to_corner(UP+LEFT)\n",
        "        speedometer.next_to(speedometer_title, DOWN)\n",
        "\n",
        "        self.speedometer = speedometer\n",
        "        self.speedometer_title = speedometer_title\n",
        "\n",
        "    def introduce_added_mobjects(self):\n",
        "        speedometer = self.speedometer\n",
        "        speedometer_title = self.speedometer_title\n",
        "\n",
        "        speedometer.save_state()\n",
        "        speedometer.rotate(-np.pi/2, UP)\n",
        "        speedometer.set_height(self.car.get_height()/4)\n",
        "        speedometer.move_to(self.car)\n",
        "        speedometer.shift((self.car.get_width()/4)*RIGHT)\n",
        "\n",
        "        self.play(speedometer.restore, run_time = 2)\n",
        "        self.play(Write(speedometer_title, run_time = 1))\n",
        "\n",
        "    def get_added_movement_anims(self, **kwargs):\n",
        "        needle = self.speedometer.needle\n",
        "        center = self.speedometer.get_center() - self.speedometer.center_offset\n",
        "        default_kwargs = {\n",
        "            \"about_point\" : center,\n",
        "            \"radians\" : -np.pi/2,\n",
        "            \"run_time\" : 10,\n",
        "            \"rate_func\" : there_and_back,\n",
        "        }\n",
        "        default_kwargs.update(kwargs)\n",
        "        return [Rotating(needle, **default_kwargs)]\n",
        "\n",
        "    # def construct(self):\n",
        "    #     self.add(self.speedometer)\n",
        "    #     self.play(*self.get_added_movement_anims())\n",
        "\n",
        "class VelocityInAMomentMakesNoSense(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.next_to(ORIGIN, DOWN+LEFT)\n",
        "        words = OldTexText(\"Velocity in \\\\\\\\ a moment\")\n",
        "        words.next_to(randy, UP+RIGHT)\n",
        "        randy.look_at(words)\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.next_to(randy, UP)\n",
        "\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            Write(words)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(Write(q_marks))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class SnapshotOfACar(Scene):\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        car.scale(1.5)\n",
        "        car.move_to(3*LEFT+DOWN)\n",
        "        flash_box = Rectangle(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = FRAME_HEIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        speed_lines = VGroup(*[\n",
        "            Line(point, point+0.5*LEFT)\n",
        "            for point in [\n",
        "                0.5*UP+0.25*RIGHT,\n",
        "                ORIGIN, \n",
        "                0.5*DOWN+0.25*RIGHT\n",
        "            ]\n",
        "        ])\n",
        "        question = OldTexText(\"\"\"\n",
        "            How fast is\n",
        "            this car going?\n",
        "        \"\"\")\n",
        "\n",
        "        self.play(MoveCar(\n",
        "            car, RIGHT+DOWN, \n",
        "            run_time = 2,\n",
        "            rate_func = rush_into\n",
        "        ))\n",
        "        car.get_tires().set_color(GREY)\n",
        "        speed_lines.next_to(car, LEFT)\n",
        "        self.add(speed_lines)\n",
        "        self.play(\n",
        "            flash_box.set_fill, None, 0,\n",
        "            rate_func = rush_from\n",
        "        )\n",
        "        question.next_to(car, UP, buff = LARGE_BUFF)\n",
        "        self.play(Write(question, run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "class CompareTwoTimes(Scene):\n",
        "    CONFIG = {\n",
        "        \"start_distance\" : 30,\n",
        "        \"start_time\" : 4,\n",
        "        \"end_distance\" : 50,\n",
        "        \"end_time\" : 5,\n",
        "        \"fade_at_the_end\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_states()\n",
        "        self.show_equation()\n",
        "        if self.fade_at_the_end:\n",
        "            self.fade_all_but_one_moment()\n",
        "\n",
        "    def introduce_states(self):\n",
        "        state1 = self.get_car_state(self.start_distance, self.start_time)\n",
        "        state2 = self.get_car_state(self.end_distance, self.end_time)\n",
        "\n",
        "        state1.to_corner(UP+LEFT)\n",
        "        state2.to_corner(DOWN+LEFT)\n",
        "\n",
        "        dividers = VGroup(\n",
        "            Line(FRAME_X_RADIUS*LEFT, RIGHT),\n",
        "            Line(RIGHT+FRAME_Y_RADIUS*UP, RIGHT+FRAME_Y_RADIUS*DOWN),\n",
        "        )\n",
        "        dividers.set_color(GREY)\n",
        "\n",
        "        self.add(dividers, state1)\n",
        "        self.wait()\n",
        "        copied_state = state1.copy()\n",
        "        self.play(copied_state.move_to, state2)\n",
        "        self.play(Transform(copied_state, state2))\n",
        "        self.wait(2)\n",
        "        self.keeper = state1\n",
        "\n",
        "    def show_equation(self):\n",
        "        velocity = OldTexText(\"Velocity\")\n",
        "        change_over_change = OldTex(\n",
        "            \"\\\\frac{\\\\text{Change in distance}}{\\\\text{Change in time}}\"\n",
        "        )\n",
        "        formula = OldTex(\n",
        "            \"\\\\frac{(%s - %s) \\\\text{ meters}}{(%s - %s) \\\\text{ seconds}}\"%(\n",
        "                str(self.end_distance), str(self.start_distance),\n",
        "                str(self.end_time), str(self.start_time),\n",
        "            )\n",
        "        )\n",
        "        ed_len = len(str(self.end_distance))\n",
        "        sd_len = len(str(self.start_distance))\n",
        "        et_len = len(str(self.end_time))\n",
        "        st_len = len(str(self.start_time))\n",
        "        seconds_len = len(\"seconds\")\n",
        "        VGroup(\n",
        "            VGroup(*formula[1:1+ed_len]),\n",
        "            VGroup(*formula[2+ed_len:2+ed_len+sd_len])\n",
        "        ).set_color(DISTANCE_COLOR)\n",
        "        VGroup(\n",
        "            VGroup(*formula[-2-seconds_len-et_len-st_len:-2-seconds_len-st_len]),\n",
        "            VGroup(*formula[-1-seconds_len-st_len:-1-seconds_len]),\n",
        "        ).set_color(TIME_COLOR)\n",
        "\n",
        "        down_arrow1 = OldTex(\"\\\\Downarrow\")\n",
        "        down_arrow2 = OldTex(\"\\\\Downarrow\")\n",
        "        group = VGroup(\n",
        "            velocity, down_arrow1, \n",
        "            change_over_change, down_arrow2,\n",
        "            formula,\n",
        "        )\n",
        "        group.arrange(DOWN)\n",
        "        group.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            group, lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait(3)\n",
        "        self.formula = formula\n",
        "\n",
        "    def fade_all_but_one_moment(self):\n",
        "        anims = [\n",
        "            ApplyMethod(mob.fade, 0.5)\n",
        "            for mob in self.get_mobjects()\n",
        "        ]\n",
        "        anims.append(Animation(self.keeper.copy()))\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def get_car_state(self, distance, time):\n",
        "        line = Line(3*LEFT, 3*RIGHT)\n",
        "        dots = list(map(Dot, line.get_start_and_end()))\n",
        "        line.add(*dots)\n",
        "        car = Car()\n",
        "        car.move_to(line.get_start())\n",
        "        car.shift((distance/10)*RIGHT)\n",
        "        front_line = car.get_front_line()\n",
        "\n",
        "        brace = Brace(VGroup(dots[0], front_line), DOWN)\n",
        "        distance_label = brace.get_text(\n",
        "            str(distance), \" meters\"\n",
        "        )\n",
        "        distance_label.set_color_by_tex(str(distance), DISTANCE_COLOR)\n",
        "        brace.add(distance_label)\n",
        "        time_label = OldTexText(\n",
        "            \"Time:\", str(time), \"seconds\"\n",
        "        )\n",
        "        time_label.set_color_by_tex(str(time), TIME_COLOR)\n",
        "        time_label.next_to(\n",
        "            VGroup(line, car), UP,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        return VGroup(line, car, front_line, brace, time_label)\n",
        "\n",
        "class VelocityAtIndividualPointsVsPairs(GraphCarTrajectory):\n",
        "    CONFIG = {\n",
        "        \"start_time\" : 6.5,\n",
        "        \"end_time\" : 3,\n",
        "        \"dt\" : 1.0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        distance_graph = self.graph_function(lambda t : 100*smooth(t/10.))\n",
        "        distance_label = self.label_graph(\n",
        "            distance_graph,\n",
        "            label = \"s(t)\",\n",
        "            proportion = 1,\n",
        "            direction = RIGHT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        velocity_graph = self.get_derivative_graph()\n",
        "        self.play(ShowCreation(velocity_graph))\n",
        "        velocity_label = self.label_graph(\n",
        "            velocity_graph, \n",
        "            label = \"v(t)\",\n",
        "            proportion = self.start_time/10.0, \n",
        "            direction = UP,\n",
        "            buff = MED_SMALL_BUFF\n",
        "        )\n",
        "        velocity_graph.add(velocity_label)\n",
        "\n",
        "        self.show_individual_times_to_velocity(velocity_graph)\n",
        "        self.play(velocity_graph.fade, 0.4)\n",
        "        self.show_two_times_on_distance()\n",
        "        self.show_confused_pi_creature()\n",
        "\n",
        "    def show_individual_times_to_velocity(self, velocity_graph):\n",
        "        start_time = self.start_time\n",
        "        end_time = self.end_time\n",
        "        line = self.get_vertical_line_to_graph(start_time, velocity_graph)\n",
        "        def line_update(line, alpha):\n",
        "            time = interpolate(start_time, end_time, alpha)\n",
        "            line.put_start_and_end_on(\n",
        "                self.coords_to_point(time, 0),\n",
        "                self.input_to_graph_point(time, graph = velocity_graph)\n",
        "            )\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            line, line_update,\n",
        "            run_time = 4,\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.wait()\n",
        "        velocity_graph.add(line)\n",
        "\n",
        "    def show_two_times_on_distance(self):\n",
        "        line1 = self.get_vertical_line_to_graph(self.start_time-self.dt/2.0)\n",
        "        line2 = self.get_vertical_line_to_graph(self.start_time+self.dt/2.0)\n",
        "        p1 = line1.get_end()\n",
        "        p2 = line2.get_end()\n",
        "        interim_point = p2[0]*RIGHT+p1[1]*UP\n",
        "        dt_line = Line(p1, interim_point, color = TIME_COLOR)\n",
        "        ds_line = Line(interim_point, p2, color = DISTANCE_COLOR)\n",
        "        dt_brace = Brace(dt_line, DOWN, buff = SMALL_BUFF)\n",
        "        ds_brace = Brace(ds_line, RIGHT, buff = SMALL_BUFF)\n",
        "        dt_text = dt_brace.get_text(\"Change in time\", buff = SMALL_BUFF)\n",
        "        ds_text = ds_brace.get_text(\"Change in distance\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(VGroup(line1, line2)))\n",
        "        for line, brace, text in (dt_line, dt_brace, dt_text), (ds_line, ds_brace, ds_text):\n",
        "            brace.set_color(line.get_color())\n",
        "            text.set_color(line.get_color())\n",
        "            text.add_background_rectangle()\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def show_confused_pi_creature(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.shift(2*RIGHT)\n",
        "\n",
        "        self.play(randy.change_mode, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"erm\")\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "class FirstRealWorld(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"First, the real world.\")\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"hooray\", \"happy\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class SidestepParadox(Scene):\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        car.shift(DOWN)\n",
        "        show_speedometer = ShowSpeedometer(skip_animations = True)\n",
        "        speedometer = show_speedometer.speedometer\n",
        "        speedometer.next_to(car, UP)\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"Instantaneous\", \"rate of change\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.replace(title[0], stretch = True)\n",
        "        cross.set_fill(RED, opacity = 0.8)\n",
        "\n",
        "        new_words = OldTexText(\"over a small time\")\n",
        "        new_words.next_to(title[1], DOWN)\n",
        "        new_words.set_color(TIME_COLOR)\n",
        "\n",
        "        self.add(title, car)\n",
        "        self.play(Write(speedometer))\n",
        "        self.wait()\n",
        "        self.play(Write(cross))\n",
        "        self.wait()\n",
        "        self.play(Write(new_words))\n",
        "        self.wait()\n",
        "\n",
        "class CompareTwoVerySimilarTimes(CompareTwoTimes):\n",
        "    CONFIG = {\n",
        "        \"start_distance\" : 20,\n",
        "        \"start_time\" : 3,\n",
        "        \"end_distance\" : 20.21,\n",
        "        \"end_time\" : 3.01,\n",
        "        \"fade_at_the_end\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        CompareTwoTimes.construct(self)\n",
        "\n",
        "        formula = self.formula\n",
        "        ds_symbols, dt_symbols = [\n",
        "            VGroup(*[\n",
        "                mob\n",
        "                for mob in formula\n",
        "                if mob.get_color() == Color(color)\n",
        "            ])\n",
        "            for color in (DISTANCE_COLOR, TIME_COLOR)\n",
        "        ]\n",
        "        ds_brace = Brace(ds_symbols, UP)\n",
        "        ds_text = ds_brace.get_text(\"$ds$\", buff = SMALL_BUFF)\n",
        "        ds_text.set_color(DISTANCE_COLOR)\n",
        "        dt_brace = Brace(dt_symbols, DOWN)\n",
        "        dt_text = dt_brace.get_text(\"$dt$\", buff = SMALL_BUFF)\n",
        "        dt_text.set_color(TIME_COLOR)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(dt_brace),\n",
        "            Write(dt_text)\n",
        "        )\n",
        "        formula.add(dt_brace, dt_text)\n",
        "        self.wait(2)\n",
        "\n",
        "        formula.generate_target()\n",
        "        VGroup(\n",
        "            ds_brace, ds_text, formula.target\n",
        "        ).move_to(formula, UP).shift(0.5*UP)\n",
        "        self.play(\n",
        "            MoveToTarget(formula),\n",
        "            GrowFromCenter(ds_brace),\n",
        "            Write(ds_text)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class DsOverDtGraphically(GraphCarTrajectory, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"dt\" : 0.1,\n",
        "        \"zoom_factor\" : 4,#Before being shrunk by dt\n",
        "        \"start_time\" : 3,\n",
        "        \"end_time\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        distance_graph = self.graph_function(\n",
        "            lambda t : 100*smooth(t/10.),\n",
        "            animate = False,\n",
        "        )\n",
        "        distance_label = self.label_graph(\n",
        "            distance_graph,\n",
        "            label = \"s(t)\",\n",
        "            proportion = 0.9,\n",
        "            direction = UP+LEFT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        input_point_line = self.get_vertical_line_to_graph(\n",
        "            self.start_time,\n",
        "            line_kwargs = {\n",
        "                \"dash_length\" : 0.02,\n",
        "                \"stroke_width\" : 4,\n",
        "                \"color\" : WHITE,\n",
        "            },\n",
        "        )\n",
        "        def get_ds_dt_group(time):\n",
        "            point1 = self.input_to_graph_point(time)\n",
        "            point2 = self.input_to_graph_point(time+self.dt)\n",
        "            interim_point = point2[0]*RIGHT+point1[1]*UP\n",
        "            dt_line = Line(point1, interim_point, color = TIME_COLOR)\n",
        "            ds_line = Line(interim_point, point2, color = DISTANCE_COLOR)\n",
        "            result = VGroup()\n",
        "            for line, char, vect in (dt_line, \"t\", DOWN), (ds_line, \"s\", RIGHT):\n",
        "                line.scale(1./self.dt)\n",
        "                brace = Brace(line, vect)\n",
        "                text = brace.get_text(\"$d%s$\"%char)\n",
        "                text.next_to(brace, vect)\n",
        "                text.set_color(line.get_color())\n",
        "                subgroup = VGroup(line, brace, text)\n",
        "                subgroup.scale(self.dt)\n",
        "                result.add(subgroup)\n",
        "            return result\n",
        "        def align_little_rectangle_on_ds_dt_group(rect):\n",
        "            rect.move_to(ds_dt_group, DOWN+RIGHT)\n",
        "            rect.shift(self.dt*(DOWN+RIGHT)/4)\n",
        "            return rect\n",
        "        ds_dt_group = get_ds_dt_group(self.start_time)\n",
        "\n",
        "        #Initially zoom in\n",
        "        self.play(ShowCreation(input_point_line))\n",
        "        self.activate_zooming()\n",
        "        self.play(*list(map(FadeIn, [self.big_rectangle, self.little_rectangle])))\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                align_little_rectangle_on_ds_dt_group,\n",
        "                self.little_rectangle\n",
        "            )\n",
        "        )\n",
        "        self.little_rectangle.generate_target()\n",
        "        self.little_rectangle.target.scale(self.zoom_factor*self.dt)\n",
        "        align_little_rectangle_on_ds_dt_group(\n",
        "            self.little_rectangle.target\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(self.little_rectangle),\n",
        "            run_time = 3\n",
        "        )\n",
        "        for subgroup in ds_dt_group:\n",
        "            line, brace, text= subgroup\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        #Show as function\n",
        "        frac = OldTex(\"\\\\frac{ds}{dt}\")\n",
        "        VGroup(*frac[:2]).set_color(DISTANCE_COLOR)\n",
        "        VGroup(*frac[-2:]).set_color(TIME_COLOR)\n",
        "        frac.next_to(self.input_to_graph_point(5.25), DOWN+RIGHT)\n",
        "        rise_over_run = OldTex(\n",
        "            \"=\\\\frac{\\\\text{rise}}{\\\\text{run}}\"\n",
        "        )\n",
        "        rise_over_run.next_to(frac, RIGHT)\n",
        "        of_t = OldTex(\"(t)\")\n",
        "        of_t.next_to(frac, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        dt_choice = OldTex(\"dt = 0.01\")\n",
        "        dt_choice.set_color(TIME_COLOR)\n",
        "        dt_choice.next_to(of_t, UP, aligned_edge = LEFT, buff = LARGE_BUFF)\n",
        "\n",
        "\n",
        "        full_formula = OldTex(\n",
        "            \"=\\\\frac{s(t+dt) - s(t)}{dt}\"\n",
        "        )\n",
        "        full_formula.next_to(of_t)\n",
        "        s_t_plus_dt = VGroup(*full_formula[1:8])\n",
        "        s_t = VGroup(*full_formula[9:13])\n",
        "        numerator = VGroup(*full_formula[1:13])\n",
        "        lower_dt =  VGroup(*full_formula[-2:])\n",
        "        upper_dt = VGroup(*full_formula[5:7])\n",
        "        equals = full_formula[0]\n",
        "        frac_line = full_formula[-3]\n",
        "        s_t_plus_dt.set_color(DISTANCE_COLOR)\n",
        "        s_t.set_color(DISTANCE_COLOR)\n",
        "        lower_dt.set_color(TIME_COLOR)\n",
        "        upper_dt.set_color(TIME_COLOR)\n",
        "\n",
        "        velocity_graph = self.get_derivative_graph()\n",
        "        t_tick_marks = VGroup(*[\n",
        "            Line(\n",
        "                UP, DOWN,\n",
        "                color = TIME_COLOR,\n",
        "                stroke_width = 3,\n",
        "            ).scale(0.1).move_to(self.coords_to_point(t, 0))\n",
        "            for t in np.linspace(0, 10, 75)\n",
        "        ])\n",
        "\n",
        "        v_line_at_t, v_line_at_t_plus_dt = [\n",
        "            self.get_vertical_line_to_graph(\n",
        "                time,\n",
        "                line_class = Line,\n",
        "                line_kwargs = {\"color\" : MAROON_B}\n",
        "            )\n",
        "            for time in (self.end_time, self.end_time + self.dt)\n",
        "        ]\n",
        "\n",
        "\n",
        "        self.play(Write(frac))\n",
        "        self.play(Write(rise_over_run))\n",
        "        self.wait()\n",
        "        def input_point_line_update(line, alpha):\n",
        "            time = interpolate(self.start_time, self.end_time, alpha)\n",
        "            line.put_start_and_end_on(\n",
        "                self.coords_to_point(time, 0),\n",
        "                self.input_to_graph_point(time),\n",
        "            )\n",
        "        def ds_dt_group_update(group, alpha):\n",
        "            time = interpolate(self.start_time, self.end_time, alpha)\n",
        "            new_group = get_ds_dt_group(time)\n",
        "            Transform(group, new_group).update(1)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(input_point_line, input_point_line_update),\n",
        "            UpdateFromAlphaFunc(ds_dt_group, ds_dt_group_update),\n",
        "            UpdateFromFunc(self.little_rectangle, align_little_rectangle_on_ds_dt_group),\n",
        "            run_time = 6,\n",
        "        )\n",
        "        self.play(FadeOut(input_point_line))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rise_over_run))\n",
        "        self.play(Write(of_t))\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(velocity_graph))\n",
        "        velocity_label = self.label_graph(\n",
        "            velocity_graph, \n",
        "            label = \"v(t)\",\n",
        "            proportion = 0.6,\n",
        "            direction = DOWN+LEFT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(dt_choice))\n",
        "        self.wait()\n",
        "        for anim_class in FadeIn, FadeOut:\n",
        "            self.play(anim_class(\n",
        "                t_tick_marks, lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            ))\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(numerator)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(v_line_at_t))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_line_at_t_plus_dt))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [v_line_at_t, v_line_at_t_plus_dt])))\n",
        "        self.play(\n",
        "            Write(frac_line),\n",
        "            Write(lower_dt)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Show different curves\n",
        "        self.disactivate_zooming()\n",
        "        self.remove(ds_dt_group)\n",
        "\n",
        "        self.graph.save_state()\n",
        "        velocity_graph.save_state()\n",
        "        velocity_label.save_state()\n",
        "        def steep_slope(t):\n",
        "            return 100*smooth(t/10., inflection = 25)\n",
        "        def sin_wiggle(t):\n",
        "            return (10/(2*np.pi/10.))*(np.sin(2*np.pi*t/10.) + 2*np.pi*t/10.)\n",
        "        def double_smooth_graph_function(t):\n",
        "            if t < 5:\n",
        "                return 50*smooth(t/5.)\n",
        "            else:\n",
        "                return 50*(1+smooth((t-5)/5.))\n",
        "        graph_funcs = [\n",
        "            steep_slope,\n",
        "            sin_wiggle,            \n",
        "            double_smooth_graph_function,\n",
        "        ]\n",
        "        for graph_func in graph_funcs:\n",
        "            new_graph = self.graph_function(\n",
        "                graph_func,\n",
        "                color = DISTANCE_COLOR,\n",
        "                is_main_graph = False\n",
        "            )\n",
        "            self.remove(new_graph)\n",
        "            new_velocity_graph = self.get_derivative_graph(\n",
        "                graph = new_graph,\n",
        "            )\n",
        "\n",
        "            self.play(Transform(self.graph, new_graph))\n",
        "            self.play(Transform(velocity_graph, new_velocity_graph))\n",
        "            self.wait(2)\n",
        "        self.play(self.graph.restore)\n",
        "        self.play(\n",
        "            velocity_graph.restore,\n",
        "            velocity_label.restore,\n",
        "        )\n",
        "\n",
        "        #Pause and reflect\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT).shift(2*RIGHT)\n",
        "        randy.look_at(frac_line)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"thinking\")\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class DefineTrueDerivative(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"The true derivative\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        lhs = OldTex(\"\\\\frac{ds}{dt}(t) = \")\n",
        "        VGroup(*lhs[:2]).set_color(DISTANCE_COLOR)\n",
        "        VGroup(*lhs[3:5]).set_color(TIME_COLOR)\n",
        "        lhs.shift(3*LEFT+UP)\n",
        "\n",
        "        dt_rhs = self.get_fraction(\"dt\")\n",
        "        numerical_rhs_list = [\n",
        "            self.get_fraction(\"0.%s1\"%(\"0\"*x))\n",
        "            for x in range(7)\n",
        "        ]\n",
        "        for rhs in [dt_rhs] + numerical_rhs_list:\n",
        "            rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        brace, dt_to_zero = self.get_brace_and_text(dt_rhs)\n",
        "\n",
        "        self.add(lhs, dt_rhs)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        dt_rhs.save_state()\n",
        "        for num_rhs in numerical_rhs_list:\n",
        "            self.play(Transform(dt_rhs, num_rhs))\n",
        "        self.wait()\n",
        "        self.play(dt_rhs.restore)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(dt_to_zero)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_fraction(self, dt_string):\n",
        "        tex_mob = OldTex(\n",
        "            \"\\\\frac{s(t + %s) - s(t)}{%s}\"%(dt_string, dt_string)\n",
        "        )\n",
        "        part_lengths = [\n",
        "            0,\n",
        "            len(\"s(t+\"),\n",
        "            1,#1 and -1 below are purely for transformation quirks\n",
        "            len(dt_string)-1,\n",
        "            len(\")-s(t)_\"),#Underscore represents frac_line\n",
        "            1,\n",
        "            len(dt_string)-1,\n",
        "        ]\n",
        "        pl_cumsum = np.cumsum(part_lengths)\n",
        "        result = VGroup(*[\n",
        "            VGroup(*tex_mob[i1:i2])\n",
        "            for i1, i2 in zip(pl_cumsum, pl_cumsum[1:])\n",
        "        ])\n",
        "        VGroup(*result[1:3]+result[4:6]).set_color(TIME_COLOR)\n",
        "        return result\n",
        "\n",
        "    def get_brace_and_text(self, deriv_frac):\n",
        "        brace = Brace(VGroup(deriv_frac), DOWN)\n",
        "        dt_to_zero = brace.get_text(\"$dt \\\\to 0$\")\n",
        "        VGroup(*dt_to_zero[:2]).set_color(TIME_COLOR)\n",
        "        return brace, dt_to_zero\n",
        "\n",
        "class SecantLineToTangentLine(GraphCarTrajectory, DefineTrueDerivative):\n",
        "    CONFIG = {\n",
        "        \"start_time\" : 6,\n",
        "        \"end_time\" : 2,\n",
        "        \"alt_end_time\" : 10,\n",
        "        \"start_dt\" : 2,\n",
        "        \"end_dt\" : 0.01,\n",
        "        \"secant_line_length\" : 10,\n",
        "\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.remove(self.y_axis_label_mob, self.x_axis_label_mob)\n",
        "        self.add_derivative_definition(self.y_axis_label_mob)\n",
        "        self.add_graph()\n",
        "        self.draw_axes()\n",
        "        self.show_tangent_line()\n",
        "        self.best_constant_approximation_around_a_point()\n",
        "\n",
        "    def get_ds_dt_group(self, dt, animate = False):\n",
        "        points = [\n",
        "            self.input_to_graph_point(time, self.graph)\n",
        "            for time in (self.curr_time, self.curr_time+dt)\n",
        "        ]\n",
        "        dots = list(map(Dot, points))\n",
        "        for dot in dots:\n",
        "            dot.scale(0.5)\n",
        "        secant_line = Line(*points)\n",
        "        secant_line.set_color(VELOCITY_COLOR)\n",
        "        secant_line.scale(\n",
        "            self.secant_line_length/secant_line.get_length()\n",
        "        )\n",
        "\n",
        "        interim_point = points[1][0]*RIGHT + points[0][1]*UP\n",
        "        dt_line = Line(points[0], interim_point, color = TIME_COLOR)\n",
        "        ds_line = Line(interim_point, points[1], color = DISTANCE_COLOR)\n",
        "        dt = OldTex(\"dt\")\n",
        "        dt.set_color(TIME_COLOR)\n",
        "        if dt.get_width() > dt_line.get_width():\n",
        "            dt.scale(\n",
        "                dt_line.get_width()/dt.get_width(),\n",
        "                about_point = dt.get_top()\n",
        "            )\n",
        "        dt.next_to(dt_line, DOWN, buff = SMALL_BUFF)\n",
        "        ds = OldTex(\"ds\")\n",
        "        ds.set_color(DISTANCE_COLOR)\n",
        "        if ds.get_height() > ds_line.get_height():\n",
        "            ds.scale(\n",
        "                ds_line.get_height()/ds.get_height(),\n",
        "                about_point = ds.get_left()\n",
        "            )\n",
        "        ds.next_to(ds_line, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(\n",
        "            secant_line, \n",
        "            ds_line, dt_line,\n",
        "            ds, dt,\n",
        "            *dots\n",
        "        )\n",
        "        if animate:\n",
        "            self.play(\n",
        "                ShowCreation(dt_line),\n",
        "                Write(dt),\n",
        "                ShowCreation(dots[0]),                \n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(ds_line),\n",
        "                Write(ds),\n",
        "                ShowCreation(dots[1]),                \n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(secant_line),\n",
        "                Animation(VGroup(*dots))\n",
        "            )\n",
        "        return group\n",
        "\n",
        "    def add_graph(self):\n",
        "        def double_smooth_graph_function(t):\n",
        "            if t < 5:\n",
        "                return 50*smooth(t/5.)\n",
        "            else:\n",
        "                return 50*(1+smooth((t-5)/5.))\n",
        "        self.graph = self.get_graph(double_smooth_graph_function)\n",
        "        self.graph_label = self.get_graph_label(\n",
        "            self.graph, \"s(t)\", \n",
        "            x_val = self.x_max, \n",
        "            direction = DOWN+RIGHT, \n",
        "            buff = SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "    def add_derivative_definition(self, target_upper_left):\n",
        "        deriv_frac = self.get_fraction(\"dt\")\n",
        "        lhs = OldTex(\"\\\\frac{ds}{dt}(t)=\")\n",
        "        VGroup(*lhs[:2]).set_color(DISTANCE_COLOR)\n",
        "        VGroup(*lhs[3:5]).set_color(TIME_COLOR)\n",
        "        lhs.next_to(deriv_frac, LEFT)\n",
        "        brace, text = self.get_brace_and_text(deriv_frac)\n",
        "        deriv_def = VGroup(lhs, deriv_frac, brace, text)\n",
        "        deriv_word = OldTexText(\"Derivative\")        \n",
        "        deriv_word.next_to(deriv_def, UP, buff = MED_LARGE_BUFF)\n",
        "        deriv_def.add(deriv_word)\n",
        "        rect = Rectangle(color = WHITE)\n",
        "        rect.replace(deriv_def, stretch = True)\n",
        "        rect.scale(1.2)\n",
        "        deriv_def.add(rect)\n",
        "        deriv_def.scale(0.7)\n",
        "        deriv_def.move_to(target_upper_left, UP+LEFT)\n",
        "        self.add(deriv_def)\n",
        "        return deriv_def\n",
        "\n",
        "    def draw_axes(self):\n",
        "        self.x_axis.remove(self.x_axis_label_mob)\n",
        "        self.y_axis.remove(self.y_axis_label_mob)\n",
        "        self.play(Write(\n",
        "            VGroup(\n",
        "                self.x_axis, self.y_axis,\n",
        "                self.graph, self.graph_label\n",
        "            ),\n",
        "            run_time = 4\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_tangent_line(self):\n",
        "        self.curr_time = self.start_time\n",
        "\n",
        "        ds_dt_group = self.get_ds_dt_group(2, animate = True)\n",
        "        self.wait()\n",
        "        def update_ds_dt_group(ds_dt_group, alpha):\n",
        "            new_dt = interpolate(self.start_dt, self.end_dt, alpha)\n",
        "            new_group = self.get_ds_dt_group(new_dt)\n",
        "            Transform(ds_dt_group, new_group).update(1)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(ds_dt_group, update_ds_dt_group),\n",
        "            run_time = 15\n",
        "        )\n",
        "        self.wait()\n",
        "        def update_as_tangent_line(ds_dt_group, alpha):\n",
        "            self.curr_time = interpolate(self.start_time, self.end_time, alpha)\n",
        "            new_group = self.get_ds_dt_group(self.end_dt)\n",
        "            Transform(ds_dt_group, new_group).update(1)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(ds_dt_group, update_as_tangent_line),\n",
        "            run_time = 8,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        what_dt_is_not_text = self.what_this_is_not_saying()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(ds_dt_group, update_ds_dt_group),\n",
        "            run_time = 8,\n",
        "            rate_func = lambda t : 1-there_and_back(t)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(what_dt_is_not_text))\n",
        "\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            self.curr_time,\n",
        "            self.graph,\n",
        "            line_class = Line,\n",
        "            line_kwargs = {\n",
        "                \"color\" : MAROON_B,\n",
        "                \"stroke_width\" : 3\n",
        "            }\n",
        "        )\n",
        "        def v_line_update(v_line):\n",
        "            v_line.put_start_and_end_on(\n",
        "                self.coords_to_point(self.curr_time, 0),\n",
        "                self.input_to_graph_point(self.curr_time, self.graph),\n",
        "            )\n",
        "            return v_line\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "\n",
        "        original_end_time = self.end_time\n",
        "        for end_time in self.alt_end_time, original_end_time, self.start_time:\n",
        "            self.end_time = end_time\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(ds_dt_group, update_as_tangent_line),\n",
        "                UpdateFromFunc(v_line, v_line_update),\n",
        "                run_time = abs(self.curr_time-self.end_time),\n",
        "            )\n",
        "            self.start_time = end_time\n",
        "        self.play(FadeOut(v_line))\n",
        "\n",
        "    def what_this_is_not_saying(self):\n",
        "        phrases = [\n",
        "            OldTexText(\n",
        "                \"$dt$\", \"is\", \"not\", s\n",
        "            )\n",
        "            for s in (\"``infinitely small''\", \"0\")\n",
        "        ]\n",
        "        for phrase in phrases:\n",
        "            phrase[0].set_color(TIME_COLOR)\n",
        "            phrase[2].set_color(RED)\n",
        "        phrases[0].shift(DOWN+2*RIGHT)\n",
        "        phrases[1].next_to(phrases[0], DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        for phrase in phrases:\n",
        "            self.play(Write(phrase))\n",
        "        return VGroup(*phrases)\n",
        "\n",
        "    def best_constant_approximation_around_a_point(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            Best constant \n",
        "            approximation\n",
        "            around a point\n",
        "        \"\"\")\n",
        "        words.next_to(self.x_axis, UP, aligned_edge = RIGHT)\n",
        "        circle = Circle(\n",
        "            radius = 0.25,\n",
        "            color = WHITE\n",
        "        ).shift(self.input_to_graph_point(self.curr_time))\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.play(ShowCreation(circle))        \n",
        "        self.wait()\n",
        "\n",
        "class UseOfDImpliesApproaching(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        statement = OldTexText(\"\"\"\n",
        "            Using ``$d$''\n",
        "            announces that\n",
        "            $dt \\\\to 0$\n",
        "        \"\"\")\n",
        "        VGroup(*statement[-4:-2]).set_color(TIME_COLOR)\n",
        "        self.teacher_says(statement)\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(4)\n",
        "\n",
        "class LeadIntoASpecificExample(TeacherStudentsScene, SecantLineToTangentLine):\n",
        "    def setup(self):\n",
        "        TeacherStudentsScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        dot = Dot() #Just to coordinate derivative definition\n",
        "        dot.to_corner(UP+LEFT, buff = SMALL_BUFF)\n",
        "        deriv_def = self.add_derivative_definition(dot)\n",
        "        self.remove(deriv_def)\n",
        "\n",
        "        self.teacher_says(\"An example \\\\\\\\ should help.\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(deriv_def),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"thinking\", pi.look_at, dot]\n",
        "                for pi in self.get_students()\n",
        "            ])\n",
        "        )\n",
        "        self.random_blink(3)\n",
        "        # self.teacher_says(\n",
        "        #     \"\"\"\n",
        "        #     The idea of \n",
        "        #     ``approaching''\n",
        "        #     actually makes \n",
        "        #     things easier\n",
        "        #     \"\"\",\n",
        "        #     height = 3,\n",
        "        #     target_mode = \"hooray\"\n",
        "        # )\n",
        "        # self.wait(2)\n",
        "\n",
        "class TCubedExample(SecantLineToTangentLine):\n",
        "    CONFIG = {\n",
        "        \"y_axis_label\" : \"Distance\",\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 16,\n",
        "        \"y_tick_frequency\" : 1,\n",
        "        \"y_labeled_nums\" : list(range(0, 17, 2)),\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 4,\n",
        "        \"x_labeled_nums\" : list(range(1, 5)),\n",
        "        \"graph_origin\" : 2.5*DOWN + 6*LEFT,\n",
        "        \"start_time\" : 2,\n",
        "        \"end_time\" : 0.5,\n",
        "        \"start_dt\" : 0.25,\n",
        "        \"end_dt\" : 0.001,\n",
        "        \"secant_line_length\" : 0.01,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_graph()\n",
        "        self.show_vertical_lines()\n",
        "        self.bear_with_me()\n",
        "        self.add_ds_dt_group()\n",
        "        self.brace_for_details()\n",
        "        self.show_expansion()\n",
        "        self.react_to_simplicity()\n",
        "\n",
        "    def draw_graph(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.x_axis_label_mob.shift(0.5*DOWN)\n",
        "        # self.y_axis_label_mob.next_to(self.y_axis, UP)\n",
        "        graph = self.graph_function(lambda t : t**3, animate = True)\n",
        "        self.label_graph(\n",
        "            graph,\n",
        "            label = \"s(t) = t^3\",\n",
        "            proportion = 0.62,\n",
        "            direction = LEFT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_vertical_lines(self):\n",
        "        for t in 1, 2:\n",
        "            v_line = self.get_vertical_line_to_graph(\n",
        "                t, line_kwargs = {\"color\" : WHITE}\n",
        "            )\n",
        "            brace = Brace(v_line, RIGHT)\n",
        "            text = OldTex(\"%d^3 = %d\"%(t, t**3))\n",
        "            text.next_to(brace, RIGHT)\n",
        "            text.shift(0.2*UP)\n",
        "            group = VGroup(v_line, brace, text)\n",
        "            if t == 1:\n",
        "                self.play(ShowCreation(v_line))\n",
        "                self.play(\n",
        "                    GrowFromCenter(brace),\n",
        "                    Write(text)\n",
        "                )\n",
        "                last_group = group\n",
        "            else:\n",
        "                self.play(Transform(last_group, group))\n",
        "            self.wait()\n",
        "        self.play(FadeOut(last_group))\n",
        "\n",
        "    def bear_with_me(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Bear with \\\\\\\\ me here\",\n",
        "            target_mode = \"sassy\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(*list(map(\n",
        "            FadeOut, \n",
        "            [morty, morty.bubble, morty.bubble.content]\n",
        "        )))\n",
        "\n",
        "    def add_ds_dt_group(self):\n",
        "        self.curr_time = self.start_time\n",
        "        self.curr_dt = self.start_dt\n",
        "        ds_dt_group = self.get_ds_dt_group(dt = self.start_dt)\n",
        "        v_lines = self.get_vertical_lines()\n",
        "\n",
        "        lhs = OldTex(\"\\\\frac{ds}{dt}(2) = \")\n",
        "        lhs.next_to(ds_dt_group, UP+RIGHT, buff = MED_LARGE_BUFF)\n",
        "        ds = VGroup(*lhs[:2])\n",
        "        dt = VGroup(*lhs[3:5])\n",
        "        ds.set_color(DISTANCE_COLOR)\n",
        "        dt.set_color(TIME_COLOR)\n",
        "        ds.target, dt.target = ds_dt_group[3:5]\n",
        "        for mob in ds, dt:\n",
        "            mob.save_state()\n",
        "            mob.move_to(mob.target)\n",
        "\n",
        "        nonzero_size = OldTexText(\"Nonzero size...for now\")\n",
        "        nonzero_size.set_color(TIME_COLOR)\n",
        "        nonzero_size.next_to(dt, DOWN+2*RIGHT, buff = LARGE_BUFF)\n",
        "        arrow = Arrow(nonzero_size, dt)\n",
        "\n",
        "        rhs = OldTex(\n",
        "            \"\\\\frac{s(2+dt) - s(2)}{dt}\"\n",
        "        )\n",
        "        rhs.next_to(lhs[-1])\n",
        "        VGroup(*rhs[4:6]).set_color(TIME_COLOR)\n",
        "        VGroup(*rhs[-2:]).set_color(TIME_COLOR)\n",
        "        numerator = VGroup(*rhs[:-3])\n",
        "        non_numerator = VGroup(*rhs[-3:])\n",
        "        numerator_non_minus = VGroup(*numerator)\n",
        "        numerator_non_minus.remove(rhs[7])\n",
        "        s_pair = rhs[0], rhs[8]\n",
        "        lp_pair = rhs[6], rhs[11]\n",
        "        for s, lp in zip(s_pair, lp_pair):\n",
        "            s.target = OldTex(\"3\").scale(0.7)\n",
        "            s.target.move_to(lp.get_corner(UP+RIGHT), LEFT)\n",
        "\n",
        "\n",
        "\n",
        "        self.play(Write(ds_dt_group, run_time = 2))\n",
        "        self.play(\n",
        "            FadeIn(lhs),\n",
        "            *[mob.restore for mob in (ds, dt)]\n",
        "        )\n",
        "        self.play(ShowCreation(v_lines[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(nonzero_size),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [arrow, nonzero_size])))\n",
        "        self.play(Write(numerator))\n",
        "        self.play(ShowCreation(v_lines[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            v_lines[0].set_color, YELLOW,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(non_numerator))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            *list(map(MoveToTarget, s_pair)),\n",
        "            **{\n",
        "                \"path_arc\" : -np.pi/2\n",
        "            }\n",
        "        )\n",
        "        self.play(numerator_non_minus.shift, 0.2*LEFT)\n",
        "        self.wait()\n",
        "\n",
        "        self.vertical_lines = v_lines\n",
        "        self.ds_dt_group = ds_dt_group\n",
        "        self.lhs = lhs\n",
        "        self.rhs = rhs\n",
        "\n",
        "    def get_vertical_lines(self):\n",
        "        return VGroup(*[\n",
        "            self.get_vertical_line_to_graph(\n",
        "                time,\n",
        "                line_class = DashedLine,\n",
        "                line_kwargs = {\n",
        "                    \"color\" : WHITE,\n",
        "                    \"dash_length\" : 0.05,\n",
        "                }\n",
        "            )\n",
        "            for time in (self.start_time, self.start_time+self.start_dt)\n",
        "        ])\n",
        "\n",
        "    def brace_for_details(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(self.rhs, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            morty.look_at, self.rhs\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"sassy\",\n",
        "            morty.look, OUT\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change_mode, \"pondering\")\n",
        "        self.wait()\n",
        "        self.play(FadeOut(morty))\n",
        "\n",
        "    def show_expansion(self):\n",
        "        expression = OldTex(\"\"\"\n",
        "            \\\\frac{\n",
        "                2^3 + \n",
        "                3 (2)^2 dt\n",
        "                + 3 (2)(dt)^2 + \n",
        "                (dt)^3\n",
        "                - 2^3\n",
        "            }{dt}\n",
        "        \"\"\")\n",
        "        expression.set_width(\n",
        "            VGroup(self.lhs, self.rhs).get_width()\n",
        "        )\n",
        "        expression.next_to(\n",
        "            self.lhs, DOWN, \n",
        "            aligned_edge = LEFT,\n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "        term_lens = [\n",
        "            len(\"23+\"),\n",
        "            len(\"3(2)2dt\"),\n",
        "            len(\"+3(2)(dt)2+\"),\n",
        "            len(\"(dt)3\"),\n",
        "            len(\"-23\"),\n",
        "            len(\"_\"),#frac bar\n",
        "            len(\"dt\"),\n",
        "        ]\n",
        "        terms = [\n",
        "            VGroup(*expression[i1:i2])\n",
        "            for i1, i2 in zip(\n",
        "                [0]+list(np.cumsum(term_lens)),\n",
        "                np.cumsum(term_lens)\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        dts = [\n",
        "            VGroup(*terms[1][-2:]),\n",
        "            VGroup(*terms[2][6:8]),\n",
        "            VGroup(*terms[3][1:3]),\n",
        "            terms[-1]\n",
        "        ]\n",
        "        VGroup(*dts).set_color(TIME_COLOR)\n",
        "\n",
        "        two_cubed_terms = terms[0], terms[4]\n",
        "\n",
        "        for term in terms:\n",
        "            self.play(FadeIn(term))\n",
        "            self.wait()\n",
        "\n",
        "        #Cancel out two_cubed terms\n",
        "        self.play(*it.chain(*[\n",
        "            [\n",
        "                tc.scale, 1.3, tc.get_corner(vect),\n",
        "                tc.set_color, RED\n",
        "            ]\n",
        "            for tc, vect in zip(\n",
        "                two_cubed_terms, \n",
        "                [DOWN+RIGHT, DOWN+LEFT]\n",
        "            )\n",
        "        ]))\n",
        "        self.play(*list(map(FadeOut, two_cubed_terms)))\n",
        "        numerator = VGroup(*terms[1:4])\n",
        "        self.play(\n",
        "            numerator.scale, 1.4, numerator.get_bottom(),\n",
        "            terms[-1].scale, 1.4, terms[-1].get_top()\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Cancel out dt\n",
        "        #This is all way too hacky...\n",
        "        faders = VGroup(\n",
        "            terms[-1],            \n",
        "            VGroup(*terms[1][-2:]), #\"3(2)^2 dt\"\n",
        "            terms[2][-2], # \"+3(2)(dt)2+\"\n",
        "            terms[3][-1], # \"(dt)3\"\n",
        "        )\n",
        "        new_exp = OldTex(\"2\").replace(faders[-1], dim_to_match = 1)\n",
        "        self.play(\n",
        "            faders.set_color, BLACK,\n",
        "            FadeIn(new_exp),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        terms[3].add(new_exp)\n",
        "        shift_val = 0.4*DOWN\n",
        "        self.play(\n",
        "            FadeOut(terms[-2]),#frac_line\n",
        "            terms[1].shift, shift_val + 0.45*RIGHT,\n",
        "            terms[2].shift, shift_val,\n",
        "            terms[3].shift, shift_val,\n",
        "        )\n",
        "\n",
        "        #Isolate dominant term\n",
        "        arrow = Arrow(\n",
        "            self.lhs[4].get_bottom(), terms[1][2].get_top(),\n",
        "            color = WHITE,\n",
        "            buff = MED_SMALL_BUFF\n",
        "        )\n",
        "        brace = Brace(VGroup(terms[2][0], terms[3][-1]), DOWN)\n",
        "        brace_text = brace.get_text(\"Contains $dt$\")\n",
        "        VGroup(*brace_text[-2:]).set_color(TIME_COLOR)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace), \n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Shink dt\n",
        "        faders = VGroup(*terms[2:4] + [brace, brace_text])        \n",
        "        def ds_dt_group_update(group, alpha):\n",
        "            new_dt = interpolate(self.start_dt, self.end_dt, alpha)\n",
        "            new_group = self.get_ds_dt_group(new_dt)\n",
        "            Transform(group, new_group).update(1)\n",
        "        self.play(FadeOut(self.vertical_lines))\n",
        "        self.secant_line_length = 10\n",
        "        self.play(Transform(\n",
        "            self.ds_dt_group,\n",
        "            self.get_ds_dt_group(self.start_dt)\n",
        "        ))\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(self.ds_dt_group, ds_dt_group_update),\n",
        "            faders.fade, 0.7,\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Show as derivative\n",
        "        deriv_term = VGroup(*terms[1][:5])\n",
        "        deriv_term.generate_target()\n",
        "        lhs_copy = self.lhs.copy()\n",
        "        lhs_copy.generate_target()\n",
        "        lhs_copy.target.shift(3*DOWN)\n",
        "        #hack a little, hack a lot\n",
        "        deriv_term.target.scale(1.1)\n",
        "        deriv_term.target.next_to(lhs_copy.target)\n",
        "        deriv_term.target.shift(0.07*DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(faders),            \n",
        "            MoveToTarget(deriv_term),\n",
        "            MoveToTarget(lhs_copy),\n",
        "        )\n",
        "        arrow = Arrow(\n",
        "            self.rhs.get_bottom(), deriv_term.target.get_top(),\n",
        "            buff = MED_SMALL_BUFF,\n",
        "            color = WHITE\n",
        "        )\n",
        "        approach_text = OldTexText(\"As $dt \\\\to 0$\")\n",
        "        approach_text.next_to(arrow.get_center(), RIGHT)\n",
        "        VGroup(*approach_text[2:4]).set_color(TIME_COLOR)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(approach_text)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.wait()\n",
        "\n",
        "        #Ephasize slope\n",
        "        v_line = self.vertical_lines[0]\n",
        "        slope_text = OldTexText(\"Slope = $12$\")\n",
        "        slope_text.set_color(VELOCITY_COLOR)\n",
        "        slope_text.next_to(v_line.get_end(), LEFT)\n",
        "        self.play(Write(slope_text))\n",
        "        self.play(\n",
        "            self.ds_dt_group.rotate, np.pi/24,\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(v_line))\n",
        "        self.play(FadeOut(slope_text))\n",
        "\n",
        "        #Generalize to more t\n",
        "        twos = [\n",
        "            self.lhs[6],\n",
        "            self.rhs[2],\n",
        "            self.rhs[10],\n",
        "            lhs_copy[6],\n",
        "            deriv_term[2]\n",
        "        ]\n",
        "        for two in twos:\n",
        "            two.target = OldTex(\"t\")\n",
        "            two.target.replace(two, dim_to_match = 1)\n",
        "        self.play(*list(map(MoveToTarget, twos)))\n",
        "        def update_as_tangent_line(group, alpha):\n",
        "            self.curr_time = interpolate(self.start_time, self.end_time, alpha)\n",
        "            new_group = self.get_ds_dt_group(self.end_dt)\n",
        "            Transform(group, new_group).update(1)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(self.ds_dt_group, update_as_tangent_line),\n",
        "            run_time = 5,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.lhs_copy = lhs_copy\n",
        "        self.deriv_term = deriv_term\n",
        "        self.approach_text = approach_text\n",
        "\n",
        "    def react_to_simplicity(self):\n",
        "        morty = Mortimer().flip().to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"That's \\\\\\\\ beautiful!\",\n",
        "            target_mode = \"hooray\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, 'happy',\n",
        "            *list(map(FadeOut, [morty.bubble, morty.bubble.content]))\n",
        "        )\n",
        "\n",
        "        numerator = VGroup(*self.rhs[:12])\n",
        "        denominator = VGroup(*self.rhs[-2:])\n",
        "        for mob in numerator, denominator, self.approach_text, self.deriv_term:\n",
        "            mob.generate_target()\n",
        "            mob.target.scale(1.2)\n",
        "            mob.target.set_color(MAROON_B)\n",
        "            self.play(\n",
        "                MoveToTarget(\n",
        "                    mob, rate_func = there_and_back,\n",
        "                    run_time = 1.5,\n",
        "                ),\n",
        "                morty.look_at, mob\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class YouWouldntDoThisEveryTime(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_student_changes(\n",
        "            \"pleading\", \"guilty\", \"hesitant\",\n",
        "            run_time = 0\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"You wouldn't do this \\\\\\\\ every time\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(2)\n",
        "        self.student_thinks(\n",
        "            \"$\\\\frac{d(t^3)}{dt} = 3t^2$\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        series = VideoSeries()\n",
        "        series.set_width(FRAME_WIDTH-1)\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[1]\n",
        "        next_video = series[2]\n",
        "        this_video.save_state()\n",
        "        this_video.set_color(YELLOW)\n",
        "        self.play(FadeIn(series, lag_ratio = 0.5))\n",
        "        self.play(\n",
        "            this_video.restore,\n",
        "            next_video.set_color, YELLOW,\n",
        "            next_video.shift, 0.5*DOWN\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ContrastConcreteDtWithLimit(Scene):\n",
        "    def construct(self):\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        self.add(v_line)\n",
        "\n",
        "        l_title = OldTexText(\"\"\"\n",
        "            If $dt$ has a\n",
        "            specific size.\n",
        "        \"\"\")\n",
        "        VGroup(*l_title[2:4]).set_color(TIME_COLOR)\n",
        "        r_title = OldTex(\"dt \\\\to 0\")\n",
        "        VGroup(*r_title[:2]).set_color(TIME_COLOR)\n",
        "        for title, vect in (l_title, LEFT), (r_title, RIGHT):\n",
        "            title.to_edge(UP)\n",
        "            title.shift(FRAME_X_RADIUS*vect/2)\n",
        "            self.add(title)\n",
        "\n",
        "        l_formula = OldTex(\"\"\"\n",
        "            \\\\frac{d(t^3)}{dt} = \n",
        "            \\\\frac{\n",
        "                t^3+\n",
        "                3t^2 \\\\, dt + \n",
        "                3t \\\\, (dt)^2 + \n",
        "                (dt)^3\n",
        "                - t^3\n",
        "            }{dt}\n",
        "        \"\"\")\n",
        "        VGroup(*it.chain(\n",
        "            l_formula[6:8],\n",
        "            l_formula[15:17],\n",
        "            l_formula[21:23],\n",
        "            l_formula[27:29],\n",
        "            l_formula[35:37],\n",
        "        )).set_color(TIME_COLOR)\n",
        "        l_formula.set_width(FRAME_X_RADIUS-MED_LARGE_BUFF)\n",
        "        l_formula.to_edge(LEFT)\n",
        "\n",
        "        l_brace = Brace(l_formula, DOWN)\n",
        "        l_text = l_brace.get_text(\"Messy\")\n",
        "        l_text.set_color(RED)\n",
        "\n",
        "        r_formula = OldTex(\n",
        "            \"\\\\frac{d(t^3)}{dt} = 3t^2\"\n",
        "        )\n",
        "        VGroup(*r_formula[6:8]).set_color(TIME_COLOR)\n",
        "        r_formula.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        r_brace = Brace(r_formula, DOWN)\n",
        "        r_text = r_brace.get_text(\"Simple\")\n",
        "        r_text.set_color(GREEN)\n",
        "\n",
        "        triplets = [\n",
        "            (l_formula, l_brace, l_text),\n",
        "            (r_formula, r_brace, r_text),\n",
        "        ]\n",
        "        for formula, brace, text in triplets:\n",
        "            self.play(Write(formula, run_time = 1))\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "class TimeForAnActualParadox(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"``Instantaneous rate of change''\")\n",
        "        paradoxes = OldTexText(\"Paradoxes\")\n",
        "        arrow = Arrow(ORIGIN, DOWN, buff = 0)\n",
        "        group = VGroup(words, arrow, paradoxes)\n",
        "        group.arrange(DOWN)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        teacher = self.get_teacher()\n",
        "        self.play(\n",
        "            teacher.change_mode, \"raise_right_hand\",\n",
        "            teacher.look_at, words,\n",
        "            Write(words)\n",
        "        )\n",
        "        self.play(*list(map(Write, [arrow, paradoxes])))\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, mode, pi.look_at, words]\n",
        "            for pi, mode in zip(\n",
        "                self.get_students(),\n",
        "                [\"pondering\", \"happy\", \"hesitant\"]\n",
        "            )\n",
        "        ]))\n",
        "        self.wait(4)\n",
        "\n",
        "class ParadoxAtTEquals0(TCubedExample):\n",
        "    CONFIG = {\n",
        "        \"tangent_line_length\" : 20,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_graph()\n",
        "        self.ask_question()\n",
        "        self.show_derivative_text()\n",
        "        self.show_tangent_line()\n",
        "        self.if_not_then_when()\n",
        "        self.single_out_question()\n",
        "\n",
        "    def draw_graph(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.x_axis_label_mob.set_fill(opacity = 0)\n",
        "        graph = self.graph_function(lambda t : t**3, animate = False)\n",
        "        graph_x_max = 3.0\n",
        "        graph.pointwise_become_partial(graph, 0, graph_x_max/self.x_max)\n",
        "\n",
        "        origin = self.coords_to_point(0, 0)\n",
        "        h_line = Line(LEFT, RIGHT, color = TIME_COLOR)\n",
        "        v_line = Line(UP, DOWN, color = DISTANCE_COLOR)\n",
        "        VGroup(h_line, v_line).set_stroke(width = 2)\n",
        "\n",
        "        def h_line_update(h_line):\n",
        "            point = graph.point_from_proportion(1)\n",
        "            y_axis_point = origin[0]*RIGHT + point[1]*UP\n",
        "            h_line.put_start_and_end_on(y_axis_point, point)\n",
        "            return h_line\n",
        "\n",
        "        def v_line_update(v_line):\n",
        "            point = graph.point_from_proportion(1)\n",
        "            x_axis_point =  point[0]*RIGHT + origin[1]*UP\n",
        "            v_line.put_start_and_end_on(x_axis_point, point)\n",
        "            return v_line\n",
        "\n",
        "        car = Car()\n",
        "        car.rotate(np.pi/2)\n",
        "        car.move_to(origin)\n",
        "        self.add(car)\n",
        "        #Should be 0, 1, but for some reason I don't know\n",
        "        #the car was lagging the graph.\n",
        "        car_target_point = self.coords_to_point(0, 1.15)\n",
        "\n",
        "        self.play(\n",
        "            MoveCar(\n",
        "                car, car_target_point,\n",
        "                rate_func = lambda t : (t*graph_x_max)**3\n",
        "            ),\n",
        "            ShowCreation(graph, rate_func=linear),\n",
        "            UpdateFromFunc(h_line, h_line_update),\n",
        "            UpdateFromFunc(v_line, v_line_update),\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [h_line, v_line])))\n",
        "\n",
        "        self.label_graph(\n",
        "            graph,\n",
        "            label = \"s(t) = t^3\",\n",
        "            proportion = 0.8,\n",
        "            direction = RIGHT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.car = car\n",
        "\n",
        "    def ask_question(self):\n",
        "        question = OldTexText(\n",
        "            \"At time $t=0$,\", \n",
        "            \"is \\\\\\\\ the car moving?\"\n",
        "        )\n",
        "        VGroup(*question[0][-4:-1]).set_color(RED)\n",
        "        question.next_to(\n",
        "            self.coords_to_point(0, 10),\n",
        "            RIGHT\n",
        "        )\n",
        "        origin = self.coords_to_point(0, 0)\n",
        "        arrow = Arrow(question.get_bottom(), origin)\n",
        "\n",
        "        self.play(Write(question[0], run_time = 1))\n",
        "        self.play(MoveCar(self.car, origin))\n",
        "        self.wait()\n",
        "        self.play(Write(question[1]))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.question = question\n",
        "\n",
        "    def show_derivative_text(self):\n",
        "        derivative = OldTex(\n",
        "            \"\\\\frac{ds}{dt}(t) = 3t^2\",\n",
        "            \"= 3(0)^2\",\n",
        "            \"= 0\",\n",
        "            \"\\\\frac{\\\\text{m}}{\\\\text{s}}\",\n",
        "        )\n",
        "        VGroup(*derivative[0][:2]).set_color(DISTANCE_COLOR)\n",
        "        VGroup(*derivative[0][3:5]).set_color(TIME_COLOR)\n",
        "        derivative[1][3].set_color(RED)\n",
        "        derivative[-1].scale(0.7)\n",
        "        derivative.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        derivative.shift(2*UP)\n",
        "\n",
        "        self.play(Write(derivative[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(derivative[1]))\n",
        "        self.play(*list(map(FadeIn, derivative[2:])))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.derivative = derivative\n",
        "\n",
        "    def show_tangent_line(self):\n",
        "        dot = Dot()\n",
        "        line = Line(ORIGIN, RIGHT, color = VELOCITY_COLOR)\n",
        "        line.scale(self.tangent_line_length)\n",
        "\n",
        "        start_time = 2\n",
        "        end_time = 0\n",
        "\n",
        "        def get_time_and_point(alpha):\n",
        "            time = interpolate(start_time, end_time, alpha)\n",
        "            point = self.input_to_graph_point(time)\n",
        "            return time, point\n",
        "\n",
        "        def dot_update(dot, alpha):\n",
        "            dot.move_to(get_time_and_point(alpha)[1])\n",
        "\n",
        "        def line_update(line, alpha):\n",
        "            time, point = get_time_and_point(alpha)\n",
        "            line.rotate(\n",
        "                self.angle_of_tangent(time)-line.get_angle()\n",
        "            )\n",
        "            line.move_to(point)\n",
        "\n",
        "        dot_update(dot, 0)\n",
        "        line_update(line, 0)\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            ShowCreation(dot)\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(line, line_update),\n",
        "            UpdateFromAlphaFunc(dot, dot_update),            \n",
        "            run_time = 4\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.tangent_line = line\n",
        "\n",
        "    def if_not_then_when(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"If not at $t=0$, when?\",\n",
        "            target_mode = \"maybe\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(MoveCar(\n",
        "            self.car, self.coords_to_point(0, 1),\n",
        "            rate_func = lambda t : (3*t)**3,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            FadeOut(morty.bubble),\n",
        "            FadeOut(morty.bubble.content),\n",
        "        )\n",
        "        self.play(MoveCar(self.car, self.coords_to_point(0, 0)))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.morty = morty\n",
        "\n",
        "    def single_out_question(self):\n",
        "        morty, question = self.morty, self.question\n",
        "\n",
        "        #Shouldn't need this\n",
        "        morty.bubble.content.set_fill(opacity = 0)\n",
        "        morty.bubble.set_fill(opacity = 0)\n",
        "        morty.bubble.set_stroke(width = 0)\n",
        "\n",
        "        change_word = VGroup(*question[1][-7:-1])\n",
        "        moment_word = question[0]\n",
        "\n",
        "        brace = Brace(VGroup(*self.derivative[1:]))\n",
        "        brace_text = brace.get_text(\"Best constant \\\\\\\\ approximation\")\n",
        "\n",
        "        self.remove(question, morty)\n",
        "        pre_everything = Mobject(*self.get_mobjects())\n",
        "        everything = Mobject(*pre_everything.family_members_with_points())\n",
        "        everything.save_state()\n",
        "\n",
        "        self.play(\n",
        "            everything.fade, 0.8,\n",
        "            question.center,\n",
        "            morty.change_mode, \"confused\",\n",
        "            morty.look_at, ORIGIN\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        for word in change_word, moment_word:\n",
        "            self.play(\n",
        "                word.scale, 1.2,\n",
        "                word.set_color, YELLOW,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1.5\n",
        "            )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            everything.restore,\n",
        "            FadeOut(question),\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, self.derivative\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.tangent_line.rotate, np.pi/24,\n",
        "            rate_func = wiggle,\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class TinyMovement(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"distance\" : 0.05,\n",
        "        \"distance_label\" : \"(0.1)^3 = 0.001\",\n",
        "        \"time_label\" : \"0.1\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.activate_zooming()\n",
        "        self.show_initial_motion()\n",
        "        self.show_ratios()\n",
        "\n",
        "    def show_initial_motion(self):\n",
        "        car = Car()\n",
        "        car.move_to(ORIGIN)\n",
        "        car_points = car.get_all_points()\n",
        "        lowest_to_highest_indices = np.argsort(car_points[:,1])\n",
        "        wheel_point = car_points[lowest_to_highest_indices[2]]\n",
        "        target_wheel_point = wheel_point+self.distance*RIGHT\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(point, radius = self.distance/10)\n",
        "            for point in (wheel_point, target_wheel_point)\n",
        "        ])\n",
        "        brace = Brace(Line(ORIGIN, RIGHT))\n",
        "        distance_label = OldTex(self.distance_label)\n",
        "        distance_label.next_to(brace, DOWN)\n",
        "        distance_label.set_color(DISTANCE_COLOR)\n",
        "        brace.add(distance_label)\n",
        "        brace.scale(self.distance)\n",
        "        brace.next_to(dots, DOWN, buff = self.distance/5)\n",
        "\n",
        "        zoom_rect = self.little_rectangle\n",
        "        zoom_rect.scale(2)\n",
        "        zoom_rect.move_to(wheel_point)\n",
        "\n",
        "        time_label = OldTexText(\"Time $t = $\")\n",
        "        time_label.next_to(car, UP, buff = LARGE_BUFF)\n",
        "        start_time = OldTex(\"0\")\n",
        "        end_time = OldTex(self.time_label)\n",
        "        for time in start_time, end_time:\n",
        "            time.set_color(TIME_COLOR)\n",
        "            time.next_to(time_label, RIGHT)\n",
        "\n",
        "        self.add(car, time_label, start_time)\n",
        "        self.play(\n",
        "            zoom_rect.scale,\n",
        "            10*self.distance / zoom_rect.get_width()\n",
        "        )\n",
        "        self.play(ShowCreation(dots[0]))\n",
        "        self.play(Transform(start_time, end_time))\n",
        "        self.play(MoveCar(car, self.distance*RIGHT))\n",
        "        self.play(ShowCreation(dots[1]))\n",
        "        self.play(Write(brace, run_time = 1))\n",
        "        self.play(\n",
        "            zoom_rect.scale, 0.5,\n",
        "            zoom_rect.move_to, brace\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_ratios(self):\n",
        "        ratios = [\n",
        "            self.get_ratio(n)\n",
        "            for n in range(1, 5)\n",
        "        ]\n",
        "        ratio = ratios[0]\n",
        "        self.play(FadeIn(ratio))\n",
        "        self.wait(2)\n",
        "        for new_ratio in ratios[1:]:\n",
        "            self.play(Transform(ratio, new_ratio))\n",
        "            self.wait()\n",
        "\n",
        "    def get_ratio(self, power = 1):\n",
        "        dt = \"0.%s1\"%(\"0\"*(power-1))\n",
        "        ds_dt = \"0.%s1\"%(\"0\"*(2*power-1))\n",
        "        expression = OldTex(\"\"\"\n",
        "            \\\\frac{(%s)^3 \\\\text{ meters}}{%s \\\\text{ seconds}}\n",
        "            = %s \\\\frac{\\\\text{meters}}{\\\\text{second}}\n",
        "        \"\"\"%(dt, dt, ds_dt))\n",
        "        expression.next_to(ORIGIN, DOWN, buff = LARGE_BUFF)\n",
        "        lengths = [\n",
        "            0,\n",
        "            len(\"(\"),\n",
        "            len(dt),\n",
        "            len(\")3meters_\"),\n",
        "            len(dt),\n",
        "            len(\"seconds=\"),\n",
        "            len(ds_dt),\n",
        "            len(\"meters_second\")\n",
        "        ]\n",
        "        result = VGroup(*[\n",
        "            VGroup(*expression[i1:i2])\n",
        "            for i1, i2 in zip(\n",
        "                np.cumsum(lengths),\n",
        "                np.cumsum(lengths)[1:],\n",
        "            )\n",
        "        ])\n",
        "        result[1].set_color(DISTANCE_COLOR)\n",
        "        result[3].set_color(TIME_COLOR)\n",
        "        result[5].set_color(VELOCITY_COLOR)\n",
        "\n",
        "        return result\n",
        "\n",
        "class NextVideos(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.set_width(FRAME_WIDTH - 1)\n",
        "        series.to_edge(UP)\n",
        "        series[1].set_color(YELLOW)\n",
        "        self.add(series)\n",
        "\n",
        "        brace = Brace(VGroup(*series[2:6]))\n",
        "        brace_text = brace.get_text(\"More derivative stuffs\")\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(\n",
        "            Write(brace_text),\n",
        "            *it.chain(*[\n",
        "                [pi.look_at, brace]\n",
        "                for pi in self.get_students()\n",
        "            ])\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class Chapter2PatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"Ali Yahya\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Vecht\",\n",
        "            \"Jonathan    Eppele\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        aops_logo = AoPSLogo()\n",
        "        aops_logo.next_to(self.pi_creature, UP+LEFT)\n",
        "        url = OldTexText(\n",
        "            \"AoPS.com/\", \"3blue1brown\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        url.to_corner(UP+LEFT)\n",
        "        url_rect = Rectangle(color = BLUE)\n",
        "        url_rect.replace(\n",
        "            url.get_part_by_tex(\"3blue1brown\"),\n",
        "            stretch = True\n",
        "        )\n",
        "\n",
        "        url_rect.stretch_in_place(1.1, dim = 1)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(4.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "        mathy = Mathematician()\n",
        "        mathy.flip()\n",
        "        mathy.to_corner(DOWN+RIGHT)\n",
        "        morty = self.pi_creature\n",
        "        morty.save_state()\n",
        "        book_spot = mathy.get_corner(UP+LEFT) + UP+LEFT\n",
        "        mathy.get_center = mathy.get_top\n",
        "\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\",\n",
        "            *[\n",
        "                DrawBorderThenFill(\n",
        "                    submob,\n",
        "                    run_time = 3,\n",
        "                    rate_func = squish_rate_func(double_smooth, a, a+0.5)\n",
        "                )\n",
        "                for submob, a in zip(aops_logo, np.linspace(0, 0.5, len(aops_logo)))\n",
        "            ]\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.play(\n",
        "            morty.change_mode, \"plain\",\n",
        "            morty.flip,\n",
        "            morty.scale, 0.7,\n",
        "            morty.next_to, mathy, LEFT, LARGE_BUFF,\n",
        "            morty.to_edge, DOWN,\n",
        "            FadeIn(mathy),\n",
        "        )\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                mathy, \"\",\n",
        "                bubble_config = {\"width\" : 5},\n",
        "                look_at = morty.eyes,\n",
        "            ),\n",
        "            aops_logo.shift, 1.5*UP + 0.5*RIGHT\n",
        "        )\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                mathy, target_mode = \"happy\"\n",
        "            ),\n",
        "            aops_logo.to_corner, UP+RIGHT,\n",
        "            aops_logo.shift, MED_SMALL_BUFF*DOWN,\n",
        "        )\n",
        "        self.play(\n",
        "            mathy.look_at, morty.eyes,\n",
        "            morty.look_at, mathy.eyes,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(book_spot)),\n",
        "            mathy.change, \"raise_right_hand\", book_spot,\n",
        "            morty.change, \"pondering\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait(7)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            morty.restore,\n",
        "            morty.change, \"happy\", rect,\n",
        "            FadeOut(mathy),\n",
        "        )\n",
        "        self.wait(10)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(\n",
        "            FadeOut(url_rect),\n",
        "            url.get_part_by_tex(\"3blue1brown\").set_color, BLUE,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class Thumbnail(SecantLineToTangentLine):\n",
        "    def construct(self):\n",
        "        self.setup_axes(animate = False)\n",
        "        self.add_graph()\n",
        "        self.curr_time = 6\n",
        "        ds_dt_group = self.get_ds_dt_group(1)\n",
        "        self.add(ds_dt_group)\n",
        "        self.remove(self.x_axis_label_mob)\n",
        "        self.remove(self.y_axis_label_mob)\n",
        "        VGroup(*self.get_mobjects()).fade(0.4)\n",
        "\n",
        "        title = OldTexText(\"Derivative paradox\")\n",
        "        title.set_width(FRAME_WIDTH-1)\n",
        "        title.to_edge(UP)\n",
        "        title.add_background_rectangle()\n",
        "        title.set_color_by_gradient(GREEN, YELLOW)\n",
        "\n",
        "        randy = Randolph(mode = \"confused\")\n",
        "        randy.scale(1.7)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        randy.shift(RIGHT)\n",
        "\n",
        "        deriv = OldTex(\"\\\\frac{ds}{dt}(t)\")\n",
        "        VGroup(*deriv[:2]).set_color(DISTANCE_COLOR)\n",
        "        VGroup(*deriv[3:5]).set_color(TIME_COLOR)\n",
        "        deriv.scale(3)\n",
        "        # deriv.next_to(randy, RIGHT, buff = 2)\n",
        "        deriv.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        randy.look_at(deriv)\n",
        "\n",
        "        self.add(title, randy, deriv)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}