{
    "topic": "is demonstrating the concept of a pendulum, specifically the motion of a weight",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part1.shared_constructs import *\n",
        "\n",
        "\n",
        "class Pendulum(VGroup):\n",
        "    CONFIG = {\n",
        "        \"length\": 3,\n",
        "        \"gravity\": 9.8,\n",
        "        \"weight_diameter\": 0.5,\n",
        "        \"initial_theta\": 0.3,\n",
        "        \"omega\": 0,\n",
        "        \"damping\": 0.1,\n",
        "        \"top_point\": 2 * UP,\n",
        "        \"rod_style\": {\n",
        "            \"stroke_width\": 3,\n",
        "            \"stroke_color\": GREY_B,\n",
        "            \"sheen_direction\": UP,\n",
        "            \"sheen_factor\": 1,\n",
        "        },\n",
        "        \"weight_style\": {\n",
        "            \"stroke_width\": 0,\n",
        "            \"fill_opacity\": 1,\n",
        "            \"fill_color\": GREY_BROWN,\n",
        "            \"sheen_direction\": UL,\n",
        "            \"sheen_factor\": 0.5,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "            \"background_stroke_width\": 3,\n",
        "            \"background_stroke_opacity\": 0.5,\n",
        "        },\n",
        "        \"dashed_line_config\": {\n",
        "            \"num_dashes\": 25,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"angle_arc_config\": {\n",
        "            \"radius\": 1,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"velocity_vector_config\": {\n",
        "            \"color\": RED,\n",
        "        },\n",
        "        \"theta_label_height\": 0.25,\n",
        "        \"set_theta_label_height_cap\": False,\n",
        "        \"n_steps_per_frame\": 100,\n",
        "        \"include_theta_label\": True,\n",
        "        \"include_velocity_vector\": False,\n",
        "        \"velocity_vector_multiple\": 0.5,\n",
        "        \"max_velocity_vector_length_to_length_ratio\": 0.5,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        self.create_fixed_point()\n",
        "        self.create_rod()\n",
        "        self.create_weight()\n",
        "        self.rotating_group = VGroup(self.rod, self.weight)\n",
        "        self.create_dashed_line()\n",
        "        self.create_angle_arc()\n",
        "        if self.include_theta_label:\n",
        "            self.add_theta_label()\n",
        "        if self.include_velocity_vector:\n",
        "            self.add_velocity_vector()\n",
        "\n",
        "        self.set_theta(self.initial_theta)\n",
        "        self.update()\n",
        "\n",
        "    def create_fixed_point(self):\n",
        "        self.fixed_point_tracker = VectorizedPoint(self.top_point)\n",
        "        self.add(self.fixed_point_tracker)\n",
        "        return self\n",
        "\n",
        "    def create_rod(self):\n",
        "        rod = self.rod = Line(UP, DOWN)\n",
        "        rod.set_height(self.length)\n",
        "        rod.set_style(**self.rod_style)\n",
        "        rod.move_to(self.get_fixed_point(), UP)\n",
        "        self.add(rod)\n",
        "\n",
        "    def create_weight(self):\n",
        "        weight = self.weight = Circle()\n",
        "        weight.set_width(self.weight_diameter)\n",
        "        weight.set_style(**self.weight_style)\n",
        "        weight.move_to(self.rod.get_end())\n",
        "        self.add(weight)\n",
        "\n",
        "    def create_dashed_line(self):\n",
        "        line = self.dashed_line = DashedLine(\n",
        "            self.get_fixed_point(),\n",
        "            self.get_fixed_point() + self.length * DOWN,\n",
        "            **self.dashed_line_config\n",
        "        )\n",
        "        line.add_updater(\n",
        "            lambda l: l.move_to(self.get_fixed_point(), UP)\n",
        "        )\n",
        "        self.add_to_back(line)\n",
        "\n",
        "    def create_angle_arc(self):\n",
        "        self.angle_arc = always_redraw(lambda: Arc(\n",
        "            arc_center=self.get_fixed_point(),\n",
        "            start_angle=-90 * DEGREES,\n",
        "            angle=self.get_arc_angle_theta(),\n",
        "            **self.angle_arc_config,\n",
        "        ))\n",
        "        self.add(self.angle_arc)\n",
        "\n",
        "    def get_arc_angle_theta(self):\n",
        "        # Might be changed in certain scenes\n",
        "        return self.get_theta()\n",
        "\n",
        "    def add_velocity_vector(self):\n",
        "        def make_vector():\n",
        "            omega = self.get_omega()\n",
        "            theta = self.get_theta()\n",
        "            mvlr = self.max_velocity_vector_length_to_length_ratio\n",
        "            max_len = mvlr * self.rod.get_length()\n",
        "            vvm = self.velocity_vector_multiple\n",
        "            multiple = np.clip(\n",
        "                vvm * omega, -max_len, max_len\n",
        "            )\n",
        "            vector = Vector(\n",
        "                multiple * RIGHT,\n",
        "                **self.velocity_vector_config,\n",
        "            )\n",
        "            vector.rotate(theta, about_point=ORIGIN)\n",
        "            vector.shift(self.rod.get_end())\n",
        "            return vector\n",
        "\n",
        "        self.velocity_vector = always_redraw(make_vector)\n",
        "        self.add(self.velocity_vector)\n",
        "        return self\n",
        "\n",
        "    def add_theta_label(self):\n",
        "        self.theta_label = always_redraw(self.get_label)\n",
        "        self.add(self.theta_label)\n",
        "\n",
        "    def get_label(self):\n",
        "        label = OldTex(\"\\\\theta\")\n",
        "        label.set_height(self.theta_label_height)\n",
        "        if self.set_theta_label_height_cap:\n",
        "            max_height = self.angle_arc.get_width()\n",
        "            if label.get_height() > max_height:\n",
        "                label.set_height(max_height)\n",
        "        top = self.get_fixed_point()\n",
        "        arc_center = self.angle_arc.point_from_proportion(0.5)\n",
        "        vect = arc_center - top\n",
        "        norm = get_norm(vect)\n",
        "        vect = normalize(vect) * (norm + self.theta_label_height)\n",
        "        label.move_to(top + vect)\n",
        "        return label\n",
        "\n",
        "    #\n",
        "    def get_theta(self):\n",
        "        theta = self.rod.get_angle() - self.dashed_line.get_angle()\n",
        "        theta = (theta + PI) % TAU - PI\n",
        "        return theta\n",
        "\n",
        "    def set_theta(self, theta):\n",
        "        self.rotating_group.rotate(\n",
        "            theta - self.get_theta()\n",
        "        )\n",
        "        self.rotating_group.shift(\n",
        "            self.get_fixed_point() - self.rod.get_start(),\n",
        "        )\n",
        "        return self\n",
        "\n",
        "    def get_omega(self):\n",
        "        return self.omega\n",
        "\n",
        "    def set_omega(self, omega):\n",
        "        self.omega = omega\n",
        "        return self\n",
        "\n",
        "    def get_fixed_point(self):\n",
        "        return self.fixed_point_tracker.get_location()\n",
        "\n",
        "    #\n",
        "    def start_swinging(self):\n",
        "        self.add_updater(Pendulum.update_by_gravity)\n",
        "\n",
        "    def end_swinging(self):\n",
        "        self.remove_updater(Pendulum.update_by_gravity)\n",
        "\n",
        "    def update_by_gravity(self, dt):\n",
        "        theta = self.get_theta()\n",
        "        omega = self.get_omega()\n",
        "        nspf = self.n_steps_per_frame\n",
        "        for x in range(nspf):\n",
        "            d_theta = omega * dt / nspf\n",
        "            d_omega = op.add(\n",
        "                -self.damping * omega,\n",
        "                -(self.gravity / self.length) * np.sin(theta),\n",
        "            ) * dt / nspf\n",
        "            theta += d_theta\n",
        "            omega += d_omega\n",
        "        self.set_theta(theta)\n",
        "        self.set_omega(omega)\n",
        "        return self\n",
        "\n",
        "\n",
        "class GravityVector(Vector):\n",
        "    CONFIG = {\n",
        "        \"color\": YELLOW,\n",
        "        \"length_multiple\": 1 / 9.8,\n",
        "        # TODO, continually update the length based\n",
        "        # on the pendulum's gravity?\n",
        "    }\n",
        "\n",
        "    def __init__(self, pendulum, **kwargs):\n",
        "        super().__init__(DOWN, **kwargs)\n",
        "        self.pendulum = pendulum\n",
        "        self.scale(self.length_multiple * pendulum.gravity)\n",
        "        self.attach_to_pendulum(pendulum)\n",
        "\n",
        "    def attach_to_pendulum(self, pendulum):\n",
        "        self.add_updater(lambda m: m.shift(\n",
        "            pendulum.weight.get_center() - self.get_start(),\n",
        "        ))\n",
        "\n",
        "    def add_component_lines(self):\n",
        "        self.component_lines = always_redraw(self.create_component_lines)\n",
        "        self.add(self.component_lines)\n",
        "\n",
        "    def create_component_lines(self):\n",
        "        theta = self.pendulum.get_theta()\n",
        "        x_new = rotate(RIGHT, theta)\n",
        "        base = self.get_start()\n",
        "        tip = self.get_end()\n",
        "        vect = tip - base\n",
        "        corner = base + x_new * np.dot(vect, x_new)\n",
        "        kw = {\"dash_length\": 0.025}\n",
        "        return VGroup(\n",
        "            DashedLine(base, corner, **kw),\n",
        "            DashedLine(corner, tip, **kw),\n",
        "        )\n",
        "\n",
        "\n",
        "class ThetaValueDisplay(VGroup):\n",
        "    CONFIG = {\n",
        "\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "\n",
        "\n",
        "class ThetaVsTAxes(Axes):\n",
        "    CONFIG = {\n",
        "        \"x_min\": 0,\n",
        "        \"x_max\": 8,\n",
        "        \"y_min\": -PI / 2,\n",
        "        \"y_max\": PI / 2,\n",
        "        \"y_axis_config\": {\n",
        "            \"tick_frequency\": PI / 8,\n",
        "            \"unit_size\": 1.5,\n",
        "        },\n",
        "        \"axis_config\": {\n",
        "            \"color\": \"#EEEEEE\",\n",
        "            \"stroke_width\": 2,\n",
        "            \"include_tip\": False,\n",
        "        },\n",
        "        \"graph_style\": {\n",
        "            \"stroke_color\": GREEN,\n",
        "            \"stroke_width\": 3,\n",
        "            \"fill_opacity\": 0,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        super().__init__(**kwargs)\n",
        "        self.add_labels()\n",
        "\n",
        "    def add_axes(self):\n",
        "        self.axes = Axes(**self.axes_config)\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def add_labels(self):\n",
        "        x_axis = self.get_x_axis()\n",
        "        y_axis = self.get_y_axis()\n",
        "\n",
        "        t_label = self.t_label = OldTex(\"t\")\n",
        "        t_label.next_to(x_axis.get_right(), UP, MED_SMALL_BUFF)\n",
        "        x_axis.label = t_label\n",
        "        x_axis.add(t_label)\n",
        "        theta_label = self.theta_label = OldTex(\"\\\\theta(t)\")\n",
        "        theta_label.next_to(y_axis.get_top(), UP, SMALL_BUFF)\n",
        "        y_axis.label = theta_label\n",
        "        y_axis.add(theta_label)\n",
        "\n",
        "        self.y_axis_label = theta_label\n",
        "        self.x_axis_label = t_label\n",
        "\n",
        "        x_axis.add_numbers()\n",
        "        y_axis.add(self.get_y_axis_coordinates(y_axis))\n",
        "\n",
        "    def get_y_axis_coordinates(self, y_axis):\n",
        "        texs = [\n",
        "            # \"\\\\pi \\\\over 4\",\n",
        "            # \"\\\\pi \\\\over 2\",\n",
        "            # \"3 \\\\pi \\\\over 4\",\n",
        "            # \"\\\\pi\",\n",
        "            \"\\\\pi / 4\",\n",
        "            \"\\\\pi / 2\",\n",
        "            \"3 \\\\pi / 4\",\n",
        "            \"\\\\pi\",\n",
        "        ]\n",
        "        values = np.arange(1, 5) * PI / 4\n",
        "        labels = VGroup()\n",
        "        for pos_tex, pos_value in zip(texs, values):\n",
        "            neg_tex = \"-\" + pos_tex\n",
        "            neg_value = -1 * pos_value\n",
        "            for tex, value in (pos_tex, pos_value), (neg_tex, neg_value):\n",
        "                if value > self.y_max or value < self.y_min:\n",
        "                    continue\n",
        "                symbol = OldTex(tex)\n",
        "                symbol.scale(0.5)\n",
        "                point = y_axis.number_to_point(value)\n",
        "                symbol.next_to(point, LEFT, MED_SMALL_BUFF)\n",
        "                labels.add(symbol)\n",
        "        return labels\n",
        "\n",
        "    def get_live_drawn_graph(self, pendulum,\n",
        "                             t_max=None,\n",
        "                             t_step=1.0 / 60,\n",
        "                             **style):\n",
        "        style = merge_dicts_recursively(self.graph_style, style)\n",
        "        if t_max is None:\n",
        "            t_max = self.x_max\n",
        "\n",
        "        graph = VMobject()\n",
        "        graph.set_style(**style)\n",
        "\n",
        "        graph.all_coords = [(0, pendulum.get_theta())]\n",
        "        graph.time = 0\n",
        "        graph.time_of_last_addition = 0\n",
        "\n",
        "        def update_graph(graph, dt):\n",
        "            graph.time += dt\n",
        "            if graph.time > t_max:\n",
        "                graph.remove_updater(update_graph)\n",
        "                return\n",
        "            new_coords = (graph.time, pendulum.get_theta())\n",
        "            if graph.time - graph.time_of_last_addition >= t_step:\n",
        "                graph.all_coords.append(new_coords)\n",
        "                graph.time_of_last_addition = graph.time\n",
        "            points = [\n",
        "                self.coords_to_point(*coords)\n",
        "                for coords in [*graph.all_coords, new_coords]\n",
        "            ]\n",
        "            graph.set_points_smoothly(points)\n",
        "\n",
        "        graph.add_updater(update_graph)\n",
        "        return graph\n",
        "\n",
        "\n",
        "# Scenes\n",
        "class IntroducePendulum(PiCreatureScene, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"length\": 3,\n",
        "            \"top_point\": 4 * RIGHT,\n",
        "            \"weight_diameter\": 0.35,\n",
        "            \"gravity\": 20,\n",
        "        },\n",
        "        \"theta_vs_t_axes_config\": {\n",
        "            \"y_max\": PI / 4,\n",
        "            \"y_min\": -PI / 4,\n",
        "            \"y_axis_config\": {\n",
        "                \"tick_frequency\": PI / 16,\n",
        "                \"unit_size\": 2,\n",
        "                \"tip_length\": 0.3,\n",
        "            },\n",
        "            \"x_max\": 12,\n",
        "            \"axis_config\": {\n",
        "                \"stroke_width\": 2,\n",
        "            }\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_pendulum()\n",
        "        # self.label_pi_creatures()\n",
        "        self.label_pendulum()\n",
        "        self.add_graph()\n",
        "        self.label_function()\n",
        "        self.show_graph_period()\n",
        "        self.show_length_and_gravity()\n",
        "        # self.tweak_length_and_gravity()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        morty = Mortimer(color=MAROON_E)\n",
        "        creatures = VGroup(randy, morty)\n",
        "        creatures.scale(0.5)\n",
        "        creatures.arrange(RIGHT, buff=2.5)\n",
        "        creatures.to_corner(DR)\n",
        "        return creatures\n",
        "\n",
        "    def add_pendulum(self):\n",
        "        pendulum = self.pendulum = Pendulum(**self.pendulum_config)\n",
        "        pendulum.start_swinging()\n",
        "        frame = self.camera_frame\n",
        "        frame.save_state()\n",
        "        frame.scale(0.5)\n",
        "        frame.move_to(pendulum.dashed_line)\n",
        "\n",
        "        self.add(pendulum, frame)\n",
        "\n",
        "    def label_pi_creatures(self):\n",
        "        randy, morty = self.pi_creatures\n",
        "        randy_label = OldTexText(\"Physics\\\\\\\\\", \"student\")\n",
        "        morty_label = OldTexText(\"Physics\\\\\\\\\", \"teacher\")\n",
        "        labels = VGroup(randy_label, morty_label)\n",
        "        labels.scale(0.5)\n",
        "        randy_label.next_to(randy, UP, LARGE_BUFF)\n",
        "        morty_label.next_to(morty, UP, LARGE_BUFF)\n",
        "\n",
        "        for label, pi in zip(labels, self.pi_creatures):\n",
        "            label.arrow = Arrow(\n",
        "                label.get_bottom(), pi.eyes.get_top()\n",
        "            )\n",
        "            label.arrow.set_color(WHITE)\n",
        "            label.arrow.set_stroke(width=5)\n",
        "\n",
        "        morty.labels = VGroup(\n",
        "            morty_label,\n",
        "            morty_label.arrow,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(randy_label),\n",
        "            GrowArrow(randy_label.arrow),\n",
        "            randy.change, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            Animation(self.pendulum.fixed_point_tracker),\n",
        "            TransformFromCopy(randy_label[0], morty_label[0]),\n",
        "            FadeIn(morty_label[1]),\n",
        "            GrowArrow(morty_label.arrow),\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def label_pendulum(self):\n",
        "        pendulum = self.pendulum\n",
        "        randy, morty = self.pi_creatures\n",
        "        label = pendulum.theta_label\n",
        "        rect = SurroundingRectangle(label, buff=0.5 * SMALL_BUFF)\n",
        "        rect.add_updater(lambda r: r.move_to(label))\n",
        "\n",
        "        for pi in randy, morty:\n",
        "            pi.add_updater(\n",
        "                lambda m: m.look_at(pendulum.weight)\n",
        "            )\n",
        "\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.play(morty.change, \"pondering\")\n",
        "        self.wait(3)\n",
        "        randy.clear_updaters()\n",
        "        morty.clear_updaters()\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_graph(self):\n",
        "        axes = self.axes = ThetaVsTAxes(**self.theta_vs_t_axes_config)\n",
        "        axes.y_axis.label.next_to(axes.y_axis, UP, buff=0)\n",
        "        axes.to_corner(UL)\n",
        "\n",
        "        self.play(\n",
        "            Restore(\n",
        "                self.camera_frame,\n",
        "                rate_func=squish_rate_func(smooth, 0, 0.9),\n",
        "            ),\n",
        "            DrawBorderThenFill(\n",
        "                axes,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "                lag_ratio=0.9,\n",
        "            ),\n",
        "            Transform(\n",
        "                self.pendulum.theta_label.copy().clear_updaters(),\n",
        "                axes.y_axis.label.copy(),\n",
        "                remover=True,\n",
        "                rate_func=squish_rate_func(smooth, 0, 0.8),\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        self.wait(1.5)\n",
        "        self.graph = axes.get_live_drawn_graph(self.pendulum)\n",
        "        self.add(self.graph)\n",
        "\n",
        "    def label_function(self):\n",
        "        hm_word = OldTexText(\"Simple harmonic motion\")\n",
        "        hm_word.scale(1.25)\n",
        "        hm_word.to_edge(UP)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"=\\\\theta_0 \\\\cos(\\\\sqrt{g / L} t)\"\n",
        "        )\n",
        "        formula.next_to(\n",
        "            self.axes.y_axis_label, RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        formula.set_stroke(width=0, background=True)\n",
        "\n",
        "        self.play(FadeIn(hm_word, DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(formula),\n",
        "            hm_word.to_corner, UR\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def show_graph_period(self):\n",
        "        pendulum = self.pendulum\n",
        "        axes = self.axes\n",
        "\n",
        "        period = self.period = TAU * np.sqrt(\n",
        "            pendulum.length / pendulum.gravity\n",
        "        )\n",
        "        amplitude = pendulum.initial_theta\n",
        "\n",
        "        line = Line(\n",
        "            axes.coords_to_point(0, amplitude),\n",
        "            axes.coords_to_point(period, amplitude),\n",
        "        )\n",
        "        line.shift(SMALL_BUFF * RIGHT)\n",
        "        brace = Brace(line, UP, buff=SMALL_BUFF)\n",
        "        brace.add_to_back(brace.copy().set_style(BLACK, 10))\n",
        "        formula = get_period_formula()\n",
        "        formula.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        self.period_formula = formula\n",
        "        self.period_brace = brace\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeInFromDown(formula),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_length_and_gravity(self):\n",
        "        formula = self.period_formula\n",
        "        L = formula.get_part_by_tex(\"L\")\n",
        "        g = formula.get_part_by_tex(\"g\")\n",
        "\n",
        "        rod = self.pendulum.rod\n",
        "        new_rod = rod.copy()\n",
        "        new_rod.set_stroke(BLUE, 7)\n",
        "        new_rod.add_updater(lambda r: r.put_start_and_end_on(\n",
        "            *rod.get_start_and_end()\n",
        "        ))\n",
        "\n",
        "        g_vect = GravityVector(\n",
        "            self.pendulum,\n",
        "            length_multiple=0.5 / 9.8,\n",
        "        )\n",
        "        down_vectors = self.get_down_vectors()\n",
        "        down_vectors.set_color(YELLOW)\n",
        "        down_vectors.set_opacity(0.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenDestructionAround(L),\n",
        "            ShowCreation(new_rod),\n",
        "        )\n",
        "        self.play(FadeOut(new_rod))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenDestructionAround(g),\n",
        "            GrowArrow(g_vect),\n",
        "        )\n",
        "        self.play(self.get_down_vectors_animation(down_vectors))\n",
        "        self.wait(6)\n",
        "\n",
        "        self.gravity_vector = g_vect\n",
        "\n",
        "    def tweak_length_and_gravity(self):\n",
        "        pendulum = self.pendulum\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        brace = self.period_brace\n",
        "        formula = self.period_formula\n",
        "        g_vect = self.gravity_vector\n",
        "        randy, morty = self.pi_creatures\n",
        "\n",
        "        graph.clear_updaters()\n",
        "        period2 = self.period * np.sqrt(2)\n",
        "        period3 = self.period / np.sqrt(2)\n",
        "        amplitude = pendulum.initial_theta\n",
        "        graph2, graph3 = [\n",
        "            axes.get_graph(\n",
        "                lambda t: amplitude * np.cos(TAU * t / p),\n",
        "                color=RED,\n",
        "            )\n",
        "            for p in (period2, period3)\n",
        "        ]\n",
        "        formula.add_updater(lambda m: m.next_to(\n",
        "            brace, UP, SMALL_BUFF\n",
        "        ))\n",
        "\n",
        "        new_pendulum_config = dict(self.pendulum_config)\n",
        "        new_pendulum_config[\"length\"] *= 2\n",
        "        new_pendulum_config[\"top_point\"] += 3.5 * UP\n",
        "        # new_pendulum_config[\"initial_theta\"] = pendulum.get_theta()\n",
        "        new_pendulum = Pendulum(**new_pendulum_config)\n",
        "\n",
        "        down_vectors = self.get_down_vectors()\n",
        "\n",
        "        self.play(randy.change, \"happy\")\n",
        "        self.play(\n",
        "            ReplacementTransform(pendulum, new_pendulum),\n",
        "            morty.change, \"horrified\",\n",
        "            morty.shift, 3 * RIGHT,\n",
        "            morty.labels.shift, 3 * RIGHT,\n",
        "        )\n",
        "        self.remove(morty, morty.labels)\n",
        "        g_vect.attach_to_pendulum(new_pendulum)\n",
        "        new_pendulum.start_swinging()\n",
        "        self.play(\n",
        "            ReplacementTransform(graph, graph2),\n",
        "            brace.stretch, np.sqrt(2), 0, {\"about_edge\": LEFT},\n",
        "        )\n",
        "        self.add(g_vect)\n",
        "        self.wait(3)\n",
        "\n",
        "        new_pendulum.gravity *= 4\n",
        "        g_vect.scale(2)\n",
        "        self.play(\n",
        "            FadeOut(graph2),\n",
        "            self.get_down_vectors_animation(down_vectors)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(graph3),\n",
        "            brace.stretch, 0.5, 0, {\"about_edge\": LEFT},\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "    #\n",
        "    def get_down_vectors(self):\n",
        "        down_vectors = VGroup(*[\n",
        "            Vector(0.5 * DOWN)\n",
        "            for x in range(10 * 150)\n",
        "        ])\n",
        "        down_vectors.arrange_in_grid(10, 150, buff=MED_SMALL_BUFF)\n",
        "        down_vectors.set_color_by_gradient(BLUE, RED)\n",
        "        # for vect in down_vectors:\n",
        "        #     vect.shift(0.1 * np.random.random(3))\n",
        "        down_vectors.to_edge(RIGHT)\n",
        "        return down_vectors\n",
        "\n",
        "    def get_down_vectors_animation(self, down_vectors):\n",
        "        return LaggedStart(\n",
        "            *[\n",
        "                GrowArrow(v, rate_func=there_and_back)\n",
        "                for v in down_vectors\n",
        "            ],\n",
        "            lag_ratio=0.0005,\n",
        "            run_time=2,\n",
        "            remover=True\n",
        "        )\n",
        "\n",
        "\n",
        "class MultiplePendulumsOverlayed(Scene):\n",
        "    CONFIG = {\n",
        "        \"initial_thetas\": [\n",
        "            150 * DEGREES,\n",
        "            90 * DEGREES,\n",
        "            60 * DEGREES,\n",
        "            30 * DEGREES,\n",
        "            10 * DEGREES,\n",
        "        ],\n",
        "        \"weight_colors\": [\n",
        "            PINK, RED, GREEN, BLUE, GREY,\n",
        "        ],\n",
        "        \"pendulum_config\": {\n",
        "            \"top_point\": ORIGIN,\n",
        "            \"length\": 3,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        pendulums = VGroup(*[\n",
        "            Pendulum(\n",
        "                initial_theta=theta,\n",
        "                weight_style={\n",
        "                    \"fill_color\": wc,\n",
        "                    \"fill_opacity\": 0.5,\n",
        "                },\n",
        "                **self.pendulum_config,\n",
        "            )\n",
        "            for theta, wc in zip(\n",
        "                self.initial_thetas,\n",
        "                self.weight_colors,\n",
        "            )\n",
        "        ])\n",
        "        for pendulum in pendulums:\n",
        "            pendulum.start_swinging()\n",
        "            pendulum.remove(pendulum.theta_label)\n",
        "\n",
        "        randy = Randolph(color=BLUE_C)\n",
        "        randy.to_corner(DL)\n",
        "        randy.add_updater(lambda r: r.look_at(pendulums[0].weight))\n",
        "\n",
        "        axes = ThetaVsTAxes(\n",
        "            x_max=20,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.5,\n",
        "                \"tip_length\": 0.3,\n",
        "            },\n",
        "        )\n",
        "        axes.to_corner(UL)\n",
        "        graphs = VGroup(*[\n",
        "            axes.get_live_drawn_graph(\n",
        "                pendulum,\n",
        "                stroke_color=pendulum.weight.get_color(),\n",
        "                stroke_width=1,\n",
        "            )\n",
        "            for pendulum in pendulums\n",
        "        ])\n",
        "\n",
        "        self.add(pendulums)\n",
        "        self.add(axes, *graphs)\n",
        "        self.play(randy.change, \"sassy\")\n",
        "        self.wait(2)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(5)\n",
        "        self.play(randy.change, \"angry\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class LowAnglePendulum(Scene):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"initial_theta\": 20 * DEGREES,\n",
        "            \"length\": 2.0,\n",
        "            \"damping\": 0,\n",
        "            \"top_point\": ORIGIN,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_axis_config\": {\"unit_size\": 0.75},\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 0.5,\n",
        "                \"numbers_to_show\": range(2, 25, 2),\n",
        "                \"number_scale_val\": 0.5,\n",
        "            },\n",
        "            \"x_max\": 25,\n",
        "            \"axis_config\": {\n",
        "                \"tip_length\": 0.3,\n",
        "                \"stroke_width\": 2,\n",
        "            }\n",
        "        },\n",
        "        \"axes_corner\": UL,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        pendulum = Pendulum(**self.pendulum_config)\n",
        "        axes = ThetaVsTAxes(**self.axes_config)\n",
        "        axes.center()\n",
        "        axes.to_corner(self.axes_corner, buff=LARGE_BUFF)\n",
        "        graph = axes.get_live_drawn_graph(pendulum)\n",
        "\n",
        "        L = pendulum.length\n",
        "        g = pendulum.gravity\n",
        "        theta0 = pendulum.initial_theta\n",
        "        prediction = axes.get_graph(\n",
        "            lambda t: theta0 * np.cos(t * np.sqrt(g / L))\n",
        "        )\n",
        "        dashed_prediction = DashedVMobject(prediction, num_dashes=300)\n",
        "        dashed_prediction.set_stroke(WHITE, 1)\n",
        "        prediction_formula = OldTex(\n",
        "            \"\\\\theta_0\", \"\\\\cos(\\\\sqrt{g / L} \\\\cdot t)\"\n",
        "        )\n",
        "        prediction_formula.scale(0.75)\n",
        "        prediction_formula.next_to(\n",
        "            dashed_prediction, UP, SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        theta0 = prediction_formula.get_part_by_tex(\"\\\\theta_0\")\n",
        "        theta0_brace = Brace(theta0, UP, buff=SMALL_BUFF)\n",
        "        theta0_brace.stretch(0.5, 1, about_edge=DOWN)\n",
        "        theta0_label = Integer(\n",
        "            pendulum.initial_theta * 180 / PI,\n",
        "            unit=\"^\\\\circ\"\n",
        "        )\n",
        "        theta0_label.scale(0.75)\n",
        "        theta0_label.next_to(theta0_brace, UP, SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(theta0_brace, theta0_label, prediction_formula)\n",
        "        group.shift_onto_screen(buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(axes, dashed_prediction, pendulum)\n",
        "        self.play(\n",
        "            ShowCreation(dashed_prediction, run_time=2),\n",
        "            FadeInFromDown(prediction_formula),\n",
        "            FadeInFromDown(theta0_brace),\n",
        "            FadeInFromDown(theta0_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(theta0_label),\n",
        "            ShowCreationThenFadeAround(pendulum.theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pendulum.start_swinging()\n",
        "        self.add(graph)\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class ApproxWordsLowAnglePendulum(Scene):\n",
        "    def construct(self):\n",
        "        period = OldTex(\n",
        "            \"\\\\text{Period}\", \"\\\\approx\",\n",
        "            \"2\\\\pi \\\\sqrt{\\\\,{L} / {g}}\",\n",
        "            **Lg_formula_config\n",
        "        )\n",
        "        checkmark = OldTex(\"\\\\checkmark\")\n",
        "        checkmark.set_color(GREEN)\n",
        "        checkmark.scale(2)\n",
        "        checkmark.next_to(period, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(period, checkmark)\n",
        "\n",
        "\n",
        "class MediumAnglePendulum(LowAnglePendulum):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"initial_theta\": 50 * DEGREES,\n",
        "            \"n_steps_per_frame\": 1000,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_axis_config\": {\"unit_size\": 0.75},\n",
        "            \"y_max\": PI / 2,\n",
        "            \"y_min\": -PI / 2,\n",
        "            \"axis_config\": {\n",
        "                \"tip_length\": 0.3,\n",
        "                \"stroke_width\": 2,\n",
        "            }\n",
        "        },\n",
        "        \"pendulum_shift_vect\": 1 * RIGHT,\n",
        "    }\n",
        "\n",
        "\n",
        "class MediumHighAnglePendulum(MediumAnglePendulum):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"initial_theta\": 90 * DEGREES,\n",
        "            \"n_steps_per_frame\": 1000,\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class HighAnglePendulum(LowAnglePendulum):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"initial_theta\": 175 * DEGREES,\n",
        "            \"n_steps_per_frame\": 1000,\n",
        "            \"top_point\": 1.5 * DOWN,\n",
        "            \"length\": 2,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_axis_config\": {\"unit_size\": 0.5},\n",
        "            \"y_max\": PI,\n",
        "            \"y_min\": -PI,\n",
        "            \"axis_config\": {\n",
        "                \"tip_length\": 0.3,\n",
        "                \"stroke_width\": 2,\n",
        "            }\n",
        "        },\n",
        "        \"pendulum_shift_vect\": 1 * RIGHT,\n",
        "    }\n",
        "\n",
        "\n",
        "class VeryLowAnglePendulum(LowAnglePendulum):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"initial_theta\": 10 * DEGREES,\n",
        "            \"n_steps_per_frame\": 1000,\n",
        "            \"top_point\": ORIGIN,\n",
        "            \"length\": 3,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"y_axis_config\": {\"unit_size\": 2},\n",
        "            \"y_max\": PI / 4,\n",
        "            \"y_min\": -PI / 4,\n",
        "            \"axis_config\": {\n",
        "                \"tip_length\": 0.3,\n",
        "                \"stroke_width\": 2,\n",
        "            }\n",
        "        },\n",
        "        \"pendulum_shift_vect\": 1 * RIGHT,\n",
        "    }\n",
        "\n",
        "\n",
        "class WherePendulumLeads(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        pendulum = Pendulum(\n",
        "            top_point=UP,\n",
        "            length=3,\n",
        "            gravity=20,\n",
        "        )\n",
        "        pendulum.start_swinging()\n",
        "\n",
        "        l_title = OldTexText(\"Linearization\")\n",
        "        l_title.scale(1.5)\n",
        "        l_title.to_corner(UL)\n",
        "        c_title = OldTexText(\"Chaos\")\n",
        "        c_title.scale(1.5)\n",
        "        c_title.move_to(l_title)\n",
        "        c_title.move_to(\n",
        "            c_title.get_center() * np.array([-1, 1, 1])\n",
        "        )\n",
        "\n",
        "        get_theta = pendulum.get_theta\n",
        "        spring = always_redraw(\n",
        "            lambda: ParametricCurve(\n",
        "                lambda t: np.array([\n",
        "                    np.cos(TAU * t) + (1.4 + get_theta()) * t,\n",
        "                    np.sin(TAU * t) - 0.5,\n",
        "                    0,\n",
        "                ]),\n",
        "                t_min=-0.5,\n",
        "                t_max=7,\n",
        "                color=GREY,\n",
        "                sheen_factor=1,\n",
        "                sheen_direction=UL,\n",
        "            ).scale(0.2).to_edge(LEFT, buff=0)\n",
        "        )\n",
        "        spring_rect = SurroundingRectangle(\n",
        "            spring, buff=MED_LARGE_BUFF,\n",
        "            stroke_width=0,\n",
        "            fill_color=BLACK,\n",
        "            fill_opacity=0,\n",
        "        )\n",
        "\n",
        "        weight = Dot(radius=0.25)\n",
        "        weight.add_updater(lambda m: m.move_to(\n",
        "            spring.get_points()[-1]\n",
        "        ))\n",
        "        weight.set_color(BLUE)\n",
        "        weight.set_sheen(1, UL)\n",
        "        spring_system = VGroup(spring, weight)\n",
        "\n",
        "        linear_formula = OldTex(\n",
        "            \"\\\\frac{d \\\\vec{\\\\textbf{x}}}{dt}=\"\n",
        "            \"A\\\\vec{\\\\textbf{x}}\"\n",
        "        )\n",
        "        linear_formula.next_to(spring, UP, LARGE_BUFF)\n",
        "        linear_formula.match_x(l_title)\n",
        "\n",
        "        randy = self.pi_creature\n",
        "        randy.set_height(2)\n",
        "        randy.center()\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(3 * LEFT)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(randy, UP)\n",
        "\n",
        "        self.add(pendulum, randy)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\", pendulum,\n",
        "            FadeInFromDown(q_marks, lag_ratio=0.3)\n",
        "        )\n",
        "        self.play(randy.look_at, pendulum)\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(pendulum.get_top())),\n",
        "            FadeOut(q_marks, UP, lag_ratio=0.3),\n",
        "        )\n",
        "        self.add(spring_system)\n",
        "        self.play(\n",
        "            FadeOut(spring_rect),\n",
        "            FadeIn(linear_formula, UP),\n",
        "            FadeInFromDown(l_title),\n",
        "        )\n",
        "        self.play(FadeInFromDown(c_title))\n",
        "        self.wait(8)\n",
        "\n",
        "\n",
        "class LongDoublePendulum(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AnalyzePendulumForce(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"pendulum_config\": {\n",
        "            \"length\": 5,\n",
        "            \"top_point\": 3.5 * UP,\n",
        "            \"initial_theta\": 60 * DEGREES,\n",
        "            \"set_theta_label_height_cap\": True,\n",
        "        },\n",
        "        \"g_vect_config\": {\n",
        "            \"length_multiple\": 0.25,\n",
        "        },\n",
        "        \"tan_line_color\": BLUE,\n",
        "        \"perp_line_color\": PINK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_pendulum()\n",
        "        self.show_arc_length()\n",
        "        self.add_g_vect()\n",
        "        self.show_constraint()\n",
        "        self.break_g_vect_into_components()\n",
        "        self.show_angle_geometry()\n",
        "        self.show_gsin_formula()\n",
        "        self.show_sign()\n",
        "        self.show_acceleration_formula()\n",
        "        # self.ask_about_what_to_do()\n",
        "\n",
        "        # self.emphasize_theta()\n",
        "        # self.show_angular_velocity()\n",
        "        # self.show_angular_acceleration()\n",
        "        # self.circle_g_sin_formula()\n",
        "\n",
        "    def add_pendulum(self):\n",
        "        pendulum = Pendulum(**self.pendulum_config)\n",
        "        theta_tracker = ValueTracker(pendulum.get_theta())\n",
        "        pendulum.add_updater(lambda p: p.set_theta(\n",
        "            theta_tracker.get_value()\n",
        "        ))\n",
        "\n",
        "        self.add(pendulum)\n",
        "        self.pendulum = pendulum\n",
        "        self.theta_tracker = theta_tracker\n",
        "\n",
        "    def show_arc_length(self):\n",
        "        pendulum = self.pendulum\n",
        "        angle = pendulum.get_theta()\n",
        "        height = pendulum.length\n",
        "        top = pendulum.get_fixed_point()\n",
        "\n",
        "        line = Line(UP, DOWN)\n",
        "        line.set_height(height)\n",
        "        line.move_to(top, UP)\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            start_angle=-90 * DEGREES,\n",
        "            angle=pendulum.get_theta(),\n",
        "            arc_center=pendulum.get_fixed_point(),\n",
        "            radius=pendulum.length,\n",
        "            stroke_color=GREEN,\n",
        "        ))\n",
        "\n",
        "        brace = Brace(Line(ORIGIN, 5 * UP), RIGHT)\n",
        "        brace.point = VectorizedPoint(brace.get_right())\n",
        "        brace.add(brace.point)\n",
        "        brace.set_height(angle)\n",
        "        brace.move_to(ORIGIN, DL)\n",
        "        brace.apply_complex_function(np.exp)\n",
        "        brace.scale(height)\n",
        "        brace.rotate(-90 * DEGREES)\n",
        "        brace.move_to(arc)\n",
        "        brace.shift(MED_SMALL_BUFF * normalize(\n",
        "            arc.point_from_proportion(0.5) - top\n",
        "        ))\n",
        "        x_sym = OldTex(\"x\")\n",
        "        x_sym.set_color(GREEN)\n",
        "        x_sym.next_to(brace.point, DR, buff=SMALL_BUFF)\n",
        "\n",
        "        rhs = OldTex(\"=\", \"L\", \"\\\\theta\")\n",
        "        rhs.set_color_by_tex(\"\\\\theta\", BLUE)\n",
        "        rhs.next_to(x_sym, RIGHT)\n",
        "        rhs.shift(0.7 * SMALL_BUFF * UP)\n",
        "        line_L = OldTex(\"L\")\n",
        "        line_L.next_to(\n",
        "            pendulum.rod.get_center(), UR, SMALL_BUFF,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Rotate(line, angle, about_point=top),\n",
        "            UpdateFromAlphaFunc(\n",
        "                line, lambda m, a: m.set_stroke(\n",
        "                    width=2 * there_and_back(a)\n",
        "                )\n",
        "            ),\n",
        "            GrowFromPoint(\n",
        "                brace, line.get_bottom(),\n",
        "                path_arc=angle\n",
        "            ),\n",
        "        )\n",
        "        self.play(FadeIn(x_sym, UP))\n",
        "        self.wait()\n",
        "\n",
        "        # Show equation\n",
        "        line.set_stroke(BLUE, 5)\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(line),\n",
        "            FadeInFromDown(line_L)\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                line_L, rhs.get_part_by_tex(\"L\")\n",
        "            ),\n",
        "            Write(rhs.get_part_by_tex(\"=\"))\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                pendulum.theta_label,\n",
        "                rhs.get_parts_by_tex(\"\\\\theta\"),\n",
        "            )\n",
        "        )\n",
        "        self.add(rhs)\n",
        "\n",
        "        x_eq = VGroup(x_sym, rhs)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            x_eq.rotate, angle / 2,\n",
        "            x_eq.next_to, arc.point_from_proportion(0.5),\n",
        "            UL, {\"buff\": -MED_SMALL_BUFF}\n",
        "        )\n",
        "\n",
        "        self.x_eq = x_eq\n",
        "        self.arc = arc\n",
        "        self.line_L = line_L\n",
        "\n",
        "    def add_g_vect(self):\n",
        "        pendulum = self.pendulum\n",
        "\n",
        "        g_vect = self.g_vect = GravityVector(\n",
        "            pendulum, **self.g_vect_config,\n",
        "        )\n",
        "        g_word = self.g_word = OldTexText(\"Gravity\")\n",
        "        g_word.rotate(-90 * DEGREES)\n",
        "        g_word.scale(0.75)\n",
        "        g_word.add_updater(lambda m: m.next_to(\n",
        "            g_vect, RIGHT, buff=-SMALL_BUFF,\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(g_vect),\n",
        "            FadeIn(g_word, UP, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_constraint(self):\n",
        "        pendulum = self.pendulum\n",
        "\n",
        "        arcs = VGroup()\n",
        "        for u in [-1, 2, -1]:\n",
        "            d_theta = 40 * DEGREES * u\n",
        "            arc = Arc(\n",
        "                start_angle=pendulum.get_theta() - 90 * DEGREES,\n",
        "                angle=d_theta,\n",
        "                radius=pendulum.length,\n",
        "                arc_center=pendulum.get_fixed_point(),\n",
        "                stroke_width=2,\n",
        "                stroke_color=YELLOW,\n",
        "                stroke_opacity=0.5,\n",
        "            )\n",
        "            self.play(\n",
        "                self.theta_tracker.increment_value, d_theta,\n",
        "                ShowCreation(arc)\n",
        "            )\n",
        "            arcs.add(arc)\n",
        "        self.play(FadeOut(arcs))\n",
        "\n",
        "    def break_g_vect_into_components(self):\n",
        "        g_vect = self.g_vect\n",
        "        g_vect.component_lines = always_redraw(\n",
        "            g_vect.create_component_lines\n",
        "        )\n",
        "        tan_line, perp_line = g_vect.component_lines\n",
        "        g_vect.tangent = always_redraw(lambda: Arrow(\n",
        "            tan_line.get_start(),\n",
        "            tan_line.get_end(),\n",
        "            buff=0,\n",
        "            color=self.tan_line_color,\n",
        "        ))\n",
        "        g_vect.perp = always_redraw(lambda: Arrow(\n",
        "            perp_line.get_start(),\n",
        "            perp_line.get_end(),\n",
        "            buff=0,\n",
        "            color=self.perp_line_color,\n",
        "        ))\n",
        "\n",
        "        self.play(ShowCreation(g_vect.component_lines))\n",
        "        self.play(GrowArrow(g_vect.tangent))\n",
        "        self.wait()\n",
        "        self.play(GrowArrow(g_vect.perp))\n",
        "        self.wait()\n",
        "\n",
        "    def show_angle_geometry(self):\n",
        "        g_vect = self.g_vect\n",
        "\n",
        "        arc = Arc(\n",
        "            start_angle=90 * DEGREES,\n",
        "            angle=self.pendulum.get_theta(),\n",
        "            radius=0.5,\n",
        "            arc_center=g_vect.get_end(),\n",
        "        )\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.next_to(arc.get_center(), UL, SMALL_BUFF)\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.move_to(q_mark)\n",
        "\n",
        "        self.add(g_vect)\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(q_mark)\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(q_mark))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            self.pendulum.theta_label\n",
        "        ))\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                self.pendulum.theta_label,\n",
        "                theta_label,\n",
        "            ),\n",
        "            FadeOut(q_mark)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(WiggleOutThenIn(g_vect.tangent))\n",
        "        self.play(WiggleOutThenIn(\n",
        "            Line(\n",
        "                *g_vect.get_start_and_end(),\n",
        "                buff=0,\n",
        "            ).add_tip().match_style(g_vect),\n",
        "            remover=True\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arc),\n",
        "            FadeOut(theta_label),\n",
        "        )\n",
        "\n",
        "    def show_gsin_formula(self):\n",
        "        g_vect = self.g_vect\n",
        "        g_word = self.g_word\n",
        "        g_word.clear_updaters()\n",
        "\n",
        "        g_term = self.g_term = OldTex(\"-g\")\n",
        "        g_term.add_updater(lambda m: m.next_to(\n",
        "            g_vect,\n",
        "            RIGHT if self.pendulum.get_theta() >= 0 else LEFT,\n",
        "            SMALL_BUFF\n",
        "        ))\n",
        "\n",
        "        def create_vect_label(vect, tex, direction):\n",
        "            label = OldTex(tex)\n",
        "            label.set_stroke(width=0, background=True)\n",
        "            label.add_background_rectangle()\n",
        "            label.scale(0.7)\n",
        "            max_width = 0.9 * vect.get_length()\n",
        "            if label.get_width() > max_width:\n",
        "                label.set_width(max_width)\n",
        "            angle = vect.get_angle()\n",
        "            angle = (angle + PI / 2) % PI - PI / 2\n",
        "            label.next_to(ORIGIN, direction, SMALL_BUFF)\n",
        "            label.rotate(angle, about_point=ORIGIN)\n",
        "            label.shift(vect.get_center())\n",
        "            return label\n",
        "\n",
        "        g_sin_label = always_redraw(lambda: create_vect_label(\n",
        "            g_vect.tangent, \"-g\\\\sin(\\\\theta)\", UP,\n",
        "        ))\n",
        "        g_cos_label = always_redraw(lambda: create_vect_label(\n",
        "            g_vect.perp, \"-g\\\\cos(\\\\theta)\", DOWN,\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(g_word[0][0], g_term[0][1]),\n",
        "            FadeOut(g_word[0][1:]),\n",
        "            Write(g_term[0][0]),\n",
        "        )\n",
        "        self.add(g_term)\n",
        "        self.wait()\n",
        "        for label in g_sin_label, g_cos_label:\n",
        "            self.play(\n",
        "                GrowFromPoint(label[0], g_term.get_center()),\n",
        "                TransformFromCopy(g_term, label[1][:2]),\n",
        "                GrowFromPoint(label[1][2:], g_term.get_center()),\n",
        "                remover=True\n",
        "            )\n",
        "            self.add(label)\n",
        "            self.wait()\n",
        "\n",
        "        self.g_sin_label = g_sin_label\n",
        "        self.g_cos_label = g_cos_label\n",
        "\n",
        "    def show_sign(self):\n",
        "        get_theta = self.pendulum.get_theta\n",
        "        theta_decimal = DecimalNumber(include_sign=True)\n",
        "        theta_decimal.add_updater(lambda d: d.set_value(\n",
        "            get_theta()\n",
        "        ))\n",
        "        theta_decimal.add_updater(lambda m: m.next_to(\n",
        "            self.pendulum.theta_label, DOWN\n",
        "        ))\n",
        "        theta_decimal.add_updater(lambda m: m.set_color(\n",
        "            GREEN if get_theta() > 0 else RED\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(theta_decimal, UP),\n",
        "            FadeOut(self.x_eq),\n",
        "            FadeOut(self.line_L),\n",
        "        )\n",
        "        self.set_theta(-60 * DEGREES, run_time=4)\n",
        "        self.set_theta(60 * DEGREES, run_time=4)\n",
        "        self.play(\n",
        "            FadeOut(theta_decimal),\n",
        "            FadeIn(self.x_eq),\n",
        "        )\n",
        "\n",
        "    def show_acceleration_formula(self):\n",
        "        x_eq = self.x_eq\n",
        "        g_sin_theta = self.g_sin_label\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"a\", \"=\",\n",
        "            \"\\\\ddot\", \"x\",\n",
        "            \"=\",\n",
        "            \"-\", \"g\", \"\\\\sin\\\\big(\", \"\\\\theta\", \"\\\\big)\",\n",
        "        )\n",
        "        equation.to_edge(LEFT)\n",
        "\n",
        "        second_deriv = equation[2:4]\n",
        "        x_part = equation.get_part_by_tex(\"x\")\n",
        "        x_part.set_color(GREEN)\n",
        "        a_eq = equation[:2]\n",
        "        eq2 = equation.get_parts_by_tex(\"=\")[1]\n",
        "        rhs = equation[5:]\n",
        "\n",
        "        second_deriv_L_form = OldTex(\n",
        "            \"L\", \"\\\\ddot\", \"\\\\theta\"\n",
        "        )\n",
        "        second_deriv_L_form.move_to(second_deriv, DOWN)\n",
        "        eq3 = OldTex(\"=\")\n",
        "        eq3.rotate(90 * DEGREES)\n",
        "        eq3.next_to(second_deriv_L_form, UP)\n",
        "\n",
        "        g_L_frac = OldTex(\n",
        "            \"-\", \"{g\", \"\\\\over\", \"L}\"\n",
        "        )\n",
        "        g_L_frac.move_to(rhs[:2], LEFT)\n",
        "        g_L_frac.shift(SMALL_BUFF * UP / 2)\n",
        "\n",
        "        mu_term = OldTex(\n",
        "            \"-\\\\mu\", \"\\\\dot\", \"\\\\theta\",\n",
        "        )\n",
        "        mu_term.next_to(g_L_frac, LEFT)\n",
        "        mu_term.shift(SMALL_BUFF * UP / 2)\n",
        "\n",
        "        mu_brace = Brace(mu_term, UP)\n",
        "        mu_word = mu_brace.get_text(\"Air resistance\")\n",
        "\n",
        "        for mob in equation, second_deriv_L_form, mu_term:\n",
        "            mob.set_color_by_tex(\"\\\\theta\", BLUE)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(x_eq[0], x_part),\n",
        "            Write(equation[:3]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(eq2),\n",
        "            TransformFromCopy(g_sin_theta, rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "        #\n",
        "        self.show_acceleration_at_different_angles()\n",
        "        #\n",
        "        self.play(\n",
        "            FadeInFromDown(second_deriv_L_form),\n",
        "            Write(eq3),\n",
        "            second_deriv.next_to, eq3, UP,\n",
        "            a_eq.shift, SMALL_BUFF * LEFT,\n",
        "            eq2.shift, SMALL_BUFF * RIGHT,\n",
        "            rhs.shift, SMALL_BUFF * RIGHT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(a_eq),\n",
        "            FadeOut(second_deriv),\n",
        "            FadeOut(eq3),\n",
        "            ReplacementTransform(\n",
        "                second_deriv_L_form.get_part_by_tex(\"L\"),\n",
        "                g_L_frac.get_part_by_tex(\"L\"),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                equation.get_part_by_tex(\"-\"),\n",
        "                g_L_frac.get_part_by_tex(\"-\"),\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                equation.get_part_by_tex(\"g\"),\n",
        "                g_L_frac.get_part_by_tex(\"g\"),\n",
        "            ),\n",
        "            Write(g_L_frac.get_part_by_tex(\"\\\\over\")),\n",
        "            rhs[2:].next_to, g_L_frac, RIGHT, {\"buff\": SMALL_BUFF},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(mu_term),\n",
        "            VGroup(eq2, second_deriv_L_form[1:]).next_to,\n",
        "            mu_term, LEFT,\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(mu_brace),\n",
        "            FadeInFromDown(mu_word),\n",
        "        )\n",
        "\n",
        "    def show_acceleration_at_different_angles(self):\n",
        "        to_fade = VGroup(\n",
        "            self.g_cos_label,\n",
        "            self.g_vect.perp,\n",
        "        )\n",
        "        new_comp_line_sytle = {\n",
        "            \"stroke_width\": 0.5,\n",
        "            \"stroke_opacity\": 0.25,\n",
        "        }\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.x_eq),\n",
        "            to_fade.set_opacity, 0.25,\n",
        "            self.g_vect.component_lines.set_style,\n",
        "            new_comp_line_sytle\n",
        "        )\n",
        "        self.g_vect.component_lines.add_updater(\n",
        "            lambda m: m.set_style(**new_comp_line_sytle)\n",
        "        )\n",
        "        for mob in to_fade:\n",
        "            mob.add_updater(lambda m: m.set_opacity(0.25))\n",
        "\n",
        "        self.set_theta(0)\n",
        "        self.wait(2)\n",
        "        self.set_theta(89.9 * DEGREES, run_time=3)\n",
        "        self.wait(2)\n",
        "        self.set_theta(\n",
        "            60 * DEGREES,\n",
        "            FadeIn(self.x_eq),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_what_to_do(self):\n",
        "        g_vect = self.g_vect\n",
        "        g_sin_label = self.g_sin_label\n",
        "        angle = g_vect.tangent.get_angle()\n",
        "        angle = (angle - PI) % TAU\n",
        "\n",
        "        randy = You()\n",
        "        randy.to_corner(DL)\n",
        "        bubble = randy.get_bubble(\n",
        "            height=2,\n",
        "            width=3.5,\n",
        "        )\n",
        "        g_sin_copy = g_sin_label.copy()\n",
        "        g_sin_copy.remove(g_sin_copy[0])\n",
        "        g_sin_copy.generate_target()\n",
        "        g_sin_copy.target.scale(1 / 0.75)\n",
        "        g_sin_copy.target.rotate(-angle)\n",
        "        a_eq = OldTex(\"a=\")\n",
        "        thought_term = VGroup(a_eq, g_sin_copy.target)\n",
        "        thought_term.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        thought_term.move_to(bubble.get_bubble_center())\n",
        "\n",
        "        rect = SurroundingRectangle(g_sin_copy.target)\n",
        "        rect.rotate(angle)\n",
        "        rect.move_to(g_sin_label)\n",
        "\n",
        "        randy.save_state()\n",
        "        randy.fade(1)\n",
        "        self.play(randy.restore, randy.change, \"pondering\")\n",
        "        self.play(ShowCreationThenFadeOut(rect))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(a_eq),\n",
        "            MoveToTarget(g_sin_copy),\n",
        "            randy.look_at, bubble,\n",
        "        )\n",
        "        thought_term.remove(g_sin_copy.target)\n",
        "        thought_term.add(g_sin_copy)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(\n",
        "                thought_term.copy().set_style(\n",
        "                    stroke_color=YELLOW,\n",
        "                    stroke_width=2,\n",
        "                    fill_opacity=0,\n",
        "                ),\n",
        "                run_time=2,\n",
        "                lag_ratio=0.2,\n",
        "            ),\n",
        "            randy.change, \"confused\", thought_term,\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(bubble),\n",
        "            thought_term.next_to, self.pendulum, DOWN, LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        self.accleration_equation = thought_term\n",
        "\n",
        "    def emphasize_theta(self):\n",
        "        pendulum = self.pendulum\n",
        "\n",
        "        self.play(FocusOn(pendulum.theta_label))\n",
        "        self.play(Indicate(pendulum.theta_label))\n",
        "\n",
        "        pendulum_copy = pendulum.deepcopy()\n",
        "        pendulum_copy.clear_updaters()\n",
        "        pendulum_copy.fade(1)\n",
        "        pendulum_copy.start_swinging()\n",
        "\n",
        "        def new_updater(p):\n",
        "            p.set_theta(pendulum_copy.get_theta())\n",
        "        pendulum.add_updater(new_updater)\n",
        "\n",
        "        self.add(pendulum_copy)\n",
        "        self.wait(5)\n",
        "        pendulum_copy.end_swinging()\n",
        "        self.remove(pendulum_copy)\n",
        "        pendulum.remove_updater(new_updater)\n",
        "        self.update_mobjects(0)\n",
        "\n",
        "    def show_angular_velocity(self):\n",
        "        pass\n",
        "\n",
        "    def show_angular_acceleration(self):\n",
        "        pass\n",
        "\n",
        "    def circle_g_sin_formula(self):\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(\n",
        "                self.accleration_equation\n",
        "            )\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def set_theta(self, value, *added_anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 2)\n",
        "        self.play(\n",
        "            self.theta_tracker.set_value, value,\n",
        "            *added_anims,\n",
        "            **kwargs,\n",
        "        )\n",
        "\n",
        "\n",
        "class BuildUpEquation(Scene):\n",
        "    CONFIG = {\n",
        "        \"tex_config\": {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{a}\": YELLOW,\n",
        "                \"{v}\": RED,\n",
        "                \"{x}\": GREEN,\n",
        "                \"\\\\theta\": BLUE,\n",
        "                \"{L}\": WHITE,\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # self.add_center_line()\n",
        "        self.show_derivatives()\n",
        "        self.show_theta_double_dot_equation()\n",
        "        self.talk_about_sine_component()\n",
        "        self.add_air_resistance()\n",
        "\n",
        "    def add_center_line(self):\n",
        "        line = Line(UP, DOWN)\n",
        "        line.set_height(FRAME_HEIGHT)\n",
        "        line.set_stroke(WHITE, 1)\n",
        "        self.add(line)\n",
        "\n",
        "    def show_derivatives(self):\n",
        "        a_eq = OldTex(\n",
        "            \"{a}\", \"=\", \"{d{v} \\\\over dt}\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "        v_eq = OldTex(\n",
        "            \"{v}\", \"=\", \"{d{x} \\\\over dt}\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "        x_eq = OldTex(\n",
        "            \"{x} = {L} \\\\theta\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "        eqs = VGroup(a_eq, v_eq, x_eq)\n",
        "        eqs.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        eqs.to_corner(UL)\n",
        "\n",
        "        v_rhs = OldTex(\n",
        "            \"={L}{d\\\\theta \\\\over dt}\",\n",
        "            \"=\", \"{L}\\\\dot{\\\\theta}\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "\n",
        "        v_rhs.next_to(v_eq, RIGHT, SMALL_BUFF)\n",
        "        v_rhs.shift(\n",
        "            UP * (v_eq[1].get_bottom()[1] - v_rhs[0].get_bottom()[1])\n",
        "        )\n",
        "        a_rhs = OldTex(\n",
        "            \"={L}{d\", \"\\\\dot{\\\\theta}\", \"\\\\over dt}\",\n",
        "            \"=\", \"{L}\\\\ddot{\\\\theta}\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "        a_rhs.next_to(a_eq, RIGHT, SMALL_BUFF)\n",
        "        a_rhs.shift(\n",
        "            UP * (a_eq[1].get_bottom()[1] - a_rhs[0].get_bottom()[1])\n",
        "        )\n",
        "\n",
        "        # a_eq\n",
        "        self.play(Write(a_eq))\n",
        "        self.wait()\n",
        "\n",
        "        # v_eq\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                a_eq.get_part_by_tex(\"{v}\"),\n",
        "                v_eq.get_part_by_tex(\"{v}\"),\n",
        "            )\n",
        "        )\n",
        "        self.play(TransformFromCopy(v_eq[:1], v_eq[1:]))\n",
        "        self.wait()\n",
        "\n",
        "        # x_eq\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                v_eq.get_part_by_tex(\"{x}\"),\n",
        "                x_eq.get_part_by_tex(\"{x}\"),\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(x_eq[1:]))\n",
        "        self.wait()\n",
        "        for tex in \"L\", \"\\\\theta\":\n",
        "            self.play(ShowCreationThenFadeAround(\n",
        "                x_eq.get_part_by_tex(tex)\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        # v_rhs\n",
        "        self.play(*[\n",
        "            TransformFromCopy(\n",
        "                x_eq.get_part_by_tex(tex),\n",
        "                v_rhs.get_part_by_tex(tex),\n",
        "            )\n",
        "            for tex in (\"=\", \"{L}\", \"\\\\theta\")\n",
        "        ])\n",
        "        self.play(\n",
        "            TransformFromCopy(v_eq[-3], v_rhs[2]),\n",
        "            TransformFromCopy(v_eq[-1], v_rhs[4]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(v_rhs[-5]),\n",
        "            TransformFromCopy(*v_rhs.get_parts_by_tex(\"{L}\")),\n",
        "            TransformFromCopy(v_rhs[3:4], v_rhs[-3:])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(v_rhs[2:4]))\n",
        "        self.play(ShowCreationThenFadeAround(v_rhs[4]))\n",
        "        self.wait()\n",
        "\n",
        "        # a_rhs\n",
        "        self.play(*[\n",
        "            TransformFromCopy(\n",
        "                v_rhs.get_parts_by_tex(tex)[-1],\n",
        "                a_rhs.get_part_by_tex(tex),\n",
        "            )\n",
        "            for tex in (\"=\", \"{L}\", \"\\\\theta\", \"\\\\dot\")\n",
        "        ])\n",
        "        self.play(\n",
        "            TransformFromCopy(a_eq[-3], a_rhs[2]),\n",
        "            TransformFromCopy(a_eq[-1], a_rhs[6]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(a_rhs[-5]),\n",
        "            TransformFromCopy(*a_rhs.get_parts_by_tex(\"{L}\")),\n",
        "            TransformFromCopy(a_rhs[3:4], a_rhs[-3:]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equations = VGroup(\n",
        "            a_eq, v_eq, x_eq,\n",
        "            v_rhs, a_rhs,\n",
        "        )\n",
        "\n",
        "    def show_theta_double_dot_equation(self):\n",
        "        equations = self.equations\n",
        "        a_deriv = equations[0]\n",
        "        a_rhs = equations[-1][-5:].copy()\n",
        "\n",
        "        shift_vect = 1.5 * DOWN\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.rotate(90 * DEGREES)\n",
        "        equals.next_to(a_deriv[0], UP, MED_LARGE_BUFF)\n",
        "        g_sin_eq = OldTex(\n",
        "            \"-\", \"g\", \"\\\\sin\", \"(\", \"\\\\theta\", \")\",\n",
        "            **self.tex_config,\n",
        "        )\n",
        "        g_sin_eq.next_to(\n",
        "            equals, UP,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        g_sin_eq.to_edge(LEFT)\n",
        "        g_sin_eq.shift(shift_vect)\n",
        "\n",
        "        shift_vect += (\n",
        "            g_sin_eq[1].get_center() -\n",
        "            a_deriv[0].get_center()\n",
        "        )[0] * RIGHT\n",
        "\n",
        "        equals.shift(shift_vect)\n",
        "        a_rhs.shift(shift_vect)\n",
        "\n",
        "        self.play(\n",
        "            equations.shift, shift_vect,\n",
        "            Write(equals),\n",
        "            GrowFromPoint(\n",
        "                g_sin_eq, 2 * RIGHT + 3 * DOWN\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            a_rhs.next_to, g_sin_eq, RIGHT,\n",
        "            a_rhs.shift, SMALL_BUFF * UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fade equations\n",
        "        self.play(\n",
        "            FadeOut(equals),\n",
        "            equations.shift, DOWN,\n",
        "            equations.fade, 0.5,\n",
        "        )\n",
        "\n",
        "        # Rotate sides\n",
        "        equals, L, ddot, theta, junk = a_rhs\n",
        "        L_dd_theta = VGroup(L, ddot, theta)\n",
        "        minus, g, sin, lp, theta2, rp = g_sin_eq\n",
        "        m2, g2, over, L2 = frac = OldTex(\"-\", \"{g\", \"\\\\over\", \"L}\")\n",
        "        frac.next_to(equals, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            L_dd_theta.next_to, equals, LEFT,\n",
        "            L_dd_theta.shift, SMALL_BUFF * UP,\n",
        "            g_sin_eq.next_to, equals, RIGHT,\n",
        "            path_arc=PI / 2,\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(g, g2),\n",
        "            ReplacementTransform(minus, m2),\n",
        "            ReplacementTransform(L, L2),\n",
        "            Write(over),\n",
        "            g_sin_eq[2:].next_to, over, RIGHT, SMALL_BUFF,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Surround\n",
        "        rect = SurroundingRectangle(VGroup(g_sin_eq, frac, ddot))\n",
        "        rect.stretch(1.1, 0)\n",
        "        dashed_rect = DashedVMobject(\n",
        "            rect, num_dashes=50, positive_space_ratio=1,\n",
        "        )\n",
        "        dashed_rect.shuffle()\n",
        "        dashed_rect.save_state()\n",
        "        dashed_rect.space_out_submobjects(1.1)\n",
        "        for piece in dashed_rect:\n",
        "            piece.rotate(90 * DEGREES)\n",
        "        dashed_rect.fade(1)\n",
        "        self.play(Restore(dashed_rect, lag_ratio=0.05))\n",
        "        dashed_rect.generate_target()\n",
        "        dashed_rect.target.space_out_submobjects(0.9)\n",
        "        dashed_rect.target.fade(1)\n",
        "        for piece in dashed_rect.target:\n",
        "            piece.rotate(90 * DEGREES)\n",
        "        self.play(MoveToTarget(\n",
        "            dashed_rect,\n",
        "            lag_ratio=0.05,\n",
        "            remover=True\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.main_equation = VGroup(\n",
        "            ddot, theta, equals,\n",
        "            m2, L2, over, g2,\n",
        "            sin, lp, theta2, rp,\n",
        "        )\n",
        "\n",
        "    def talk_about_sine_component(self):\n",
        "        main_equation = self.main_equation\n",
        "        gL_part = main_equation[4:7]\n",
        "        sin_part = main_equation[7:]\n",
        "        sin = sin_part[0]\n",
        "\n",
        "        morty = Mortimer(height=1.5)\n",
        "        morty.next_to(sin, DR, buff=LARGE_BUFF)\n",
        "        morty.add_updater(lambda m: m.look_at(sin))\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(gL_part))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(sin_part))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        sin.save_state()\n",
        "        self.play(\n",
        "            morty.change, \"angry\",\n",
        "            sin.next_to, morty, LEFT, {\"aligned_edge\": UP},\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        morty.clear_updaters()\n",
        "        self.play(\n",
        "            morty.change, \"concerned_musician\",\n",
        "            morty.look, DR,\n",
        "        )\n",
        "        self.play(Restore(sin))\n",
        "        self.play(FadeOut(morty))\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize theta as input\n",
        "        theta = sin_part[2]\n",
        "        arrow = Vector(0.5 * UP, color=WHITE)\n",
        "        arrow.next_to(theta, DOWN, SMALL_BUFF)\n",
        "        word = OldTexText(\"Input\")\n",
        "        word.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(word, UP),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(\n",
        "                theta.copy().set_style(\n",
        "                    fill_opacity=0,\n",
        "                    stroke_width=2,\n",
        "                    stroke_color=YELLOW,\n",
        "                ),\n",
        "                lag_ratio=0.1,\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeOut(arrow), FadeOut(word))\n",
        "\n",
        "    def add_air_resistance(self):\n",
        "        main_equation = self.main_equation\n",
        "        tdd_eq = main_equation[:3]\n",
        "        rhs = main_equation[3:]\n",
        "\n",
        "        new_term = OldTex(\n",
        "            \"-\", \"\\\\mu\", \"\\\\dot{\", \"\\\\theta}\",\n",
        "        )\n",
        "        new_term.set_color_by_tex(\"\\\\theta\", BLUE)\n",
        "        new_term.move_to(main_equation)\n",
        "        new_term.shift(0.5 * SMALL_BUFF * UP)\n",
        "        new_term[0].align_to(rhs[0], UP)\n",
        "\n",
        "        brace = Brace(new_term, DOWN)\n",
        "        words = brace.get_text(\"Air resistance\")\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(new_term),\n",
        "            tdd_eq.next_to, new_term, LEFT,\n",
        "            tdd_eq.align_to, tdd_eq, UP,\n",
        "            rhs.next_to, new_term, RIGHT,\n",
        "            rhs.align_to, rhs, UP,\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleDampenedPendulum(Scene):\n",
        "    def construct(self):\n",
        "        pendulum = Pendulum(\n",
        "            top_point=ORIGIN,\n",
        "            initial_theta=150 * DEGREES,\n",
        "            mu=0.5,\n",
        "        )\n",
        "        self.add(pendulum)\n",
        "        pendulum.start_swinging()\n",
        "        self.wait(20)\n",
        "\n",
        "\n",
        "class NewSceneName(Scene):\n",
        "    def construct(self):\n",
        "        pass\n"
    ]
}