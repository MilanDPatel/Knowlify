{
    "topic": "The mathematical concept being demonstrated is the graph of a function f(x) and g(y)",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.convolutions2.continuous import *\n",
        "\n",
        "\n",
        "class Introduce3DGraph(InteractiveScene):\n",
        "    plane_config = dict(\n",
        "        x_range=(-2, 2),\n",
        "        y_range=(-2, 2),\n",
        "        width=6.0,\n",
        "        height=6.0,\n",
        "    )\n",
        "    plane_width = 6.0\n",
        "    z_axis_height = 2.0\n",
        "    plane_line_style = dict(\n",
        "        stroke_color=GREY_C,\n",
        "        stroke_width=1,\n",
        "        stroke_opacity=1,\n",
        "    )\n",
        "    graph_resolution = (101, 101)\n",
        "\n",
        "    def construct(self):\n",
        "        # Initial axes and graphs\n",
        "        f_axes, g_axes = all_axes = VGroup(*(\n",
        "            Axes((-2, 2), (0, 1, 0.5), width=5, height=2)\n",
        "            for n in range(2)\n",
        "        ))\n",
        "        all_axes.arrange(DOWN, buff=1.5)\n",
        "        all_axes.to_edge(LEFT)\n",
        "        self.frame.move_to(all_axes)\n",
        "\n",
        "        for char, axes in zip(\"xy\", all_axes):\n",
        "            axis_label = Tex(char, font_size=24)\n",
        "            axis_label.next_to(axes.x_axis.get_right(), UP)\n",
        "            axes.add(axis_label)\n",
        "\n",
        "        f_graph = f_axes.get_graph(self.f, use_smoothing=False)\n",
        "        f_graph.set_stroke(BLUE, 3)\n",
        "        g_graph = g_axes.get_graph(self.g)\n",
        "        g_graph.set_stroke(YELLOW, 3)\n",
        "\n",
        "        f_label, g_label = func_labels = VGroup(\n",
        "            Tex(\"f(x)\", font_size=36),\n",
        "            Tex(\"g(y)\", font_size=36)\n",
        "        )\n",
        "        for label, axes in zip(func_labels, all_axes):\n",
        "            label.move_to(axes, UL)\n",
        "\n",
        "        self.add(f_axes, f_graph, f_label)\n",
        "        self.add(g_axes, g_graph, g_label)\n",
        "\n",
        "        # Hook up trackers\n",
        "        x_tracker = ValueTracker()\n",
        "        y_tracker = ValueTracker()\n",
        "\n",
        "        get_x = x_tracker.get_value\n",
        "        get_y = y_tracker.get_value\n",
        "\n",
        "        x_indicator, y_indicator = indicators = ArrowTip(90 * DEGREES).replicate(2)\n",
        "        indicators.scale(0.5)\n",
        "        indicators.set_fill(GREY_B)\n",
        "        x_indicator.add_updater(lambda m: m.move_to(f_axes.c2p(get_x(), 0), UP))\n",
        "        y_indicator.add_updater(lambda m: m.move_to(g_axes.c2p(get_y(), 0), UP))\n",
        "\n",
        "        x_label, y_label = DecimalNumber(font_size=24).replicate(2)\n",
        "        x_label.add_updater(lambda m: m.set_value(get_x()).next_to(x_indicator, DOWN, SMALL_BUFF).fix_in_frame())\n",
        "        y_label.add_updater(lambda m: m.set_value(get_y()).next_to(y_indicator, DOWN, SMALL_BUFF).fix_in_frame())\n",
        "\n",
        "        Axes.get_v_line_to_graph\n",
        "        x_line = Line().set_stroke(WHITE, 1)\n",
        "        y_line = Line().set_stroke(WHITE, 1)\n",
        "        x_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            f_axes.c2p(get_x(), 0), f_axes.i2gp(get_x(), f_graph)\n",
        "        ))\n",
        "        y_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            g_axes.c2p(get_y(), 0), g_axes.i2gp(get_y(), g_graph)\n",
        "        ))\n",
        "\n",
        "        x_dot = GlowDot(color=BLUE)\n",
        "        y_dot = GlowDot(color=YELLOW)\n",
        "        x_dot.add_updater(lambda m: m.move_to(f_axes.i2gp(get_x(), f_graph)))\n",
        "        y_dot.add_updater(lambda m: m.move_to(g_axes.i2gp(get_y(), g_graph)))\n",
        "\n",
        "        # Ask about analog\n",
        "        question = Text(\"What is analgous to this?\")\n",
        "        question.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        question.to_edge(UP)\n",
        "        arrow = Vector(DOWN).next_to(question, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            GrowArrow(arrow),\n",
        "            self.frame.animate.center().set_anim_args(run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Scan over inputs\n",
        "        x_tracker.set_value(-2)\n",
        "        y_tracker.set_value(-2)\n",
        "        self.add(x_indicator, x_label, x_line, x_dot)\n",
        "        self.add(y_indicator, y_label, y_line, y_dot)\n",
        "        self.play(LaggedStart(\n",
        "            x_tracker.animate.set_value(0.31),\n",
        "            y_tracker.animate.set_value(0.41),\n",
        "            run_time=5,\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the xy-plane\n",
        "        plane = self.get_plane()\n",
        "        plane.to_edge(RIGHT)\n",
        "\n",
        "        x_indicator2 = x_indicator.copy().clear_updaters()\n",
        "        y_indicator2 = y_indicator.copy().clear_updaters()\n",
        "        y_indicator2.rotate(-90 * DEGREES)\n",
        "        VGroup(x_indicator2, y_indicator2).scale(0.8)\n",
        "\n",
        "        x_indicator2.add_updater(lambda m: m.move_to(plane.c2p(get_x()), UP))\n",
        "        y_indicator2.add_updater(lambda m: m.move_to(plane.c2p(0, get_y()), RIGHT))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question, UP),\n",
        "            Uncreate(arrow),\n",
        "            TransformFromCopy(f_axes.x_axis, plane.x_axis),\n",
        "            TransformFromCopy(g_axes.x_axis, plane.y_axis),\n",
        "            TransformFromCopy(x_indicator, x_indicator2),\n",
        "            TransformFromCopy(y_indicator, y_indicator2),\n",
        "            TransformFromCopy(f_axes[-1], plane.axis_labels[0]),\n",
        "            TransformFromCopy(g_axes[-1], plane.axis_labels[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(plane.background_lines, stroke_width=0.5, lag_ratio=0.01),\n",
        "            Write(plane.faded_lines, stroke_width=0.5, lag_ratio=0.01),\n",
        "        )\n",
        "        self.add(plane, x_indicator2, y_indicator2)\n",
        "\n",
        "        # Add plane lines\n",
        "        h_line = Line().set_stroke(BLUE, 1)\n",
        "        v_line = Line().set_stroke(YELLOW, 1)\n",
        "        h_line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            plane.c2p(0, get_y()), plane.c2p(get_x(), get_y())\n",
        "        ))\n",
        "        v_line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            plane.c2p(get_x(), 0), plane.c2p(get_x(), get_y())\n",
        "        ))\n",
        "\n",
        "        dot = GlowDot(color=GREEN)\n",
        "        dot.add_updater(lambda m: m.move_to(plane.c2p(get_x(), get_y())))\n",
        "        xy_label = Tex(\"(x, y)\", font_size=30)\n",
        "        xy_label.add_updater(lambda m: m.next_to(dot, UR, buff=-SMALL_BUFF))\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            VFadeIn(h_line),\n",
        "            VFadeIn(v_line),\n",
        "            FadeIn(dot),\n",
        "            VFadeIn(xy_label),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(x_tracker.animate.set_value(1), run_time=2)\n",
        "        self.play(y_tracker.animate.set_value(0.9), run_time=2)\n",
        "        self.play(x_tracker.animate.set_value(0.2), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Note probability density at a single point\n",
        "        rect = SurroundingRectangle(xy_label, buff=0.05)\n",
        "        rect.set_stroke(TEAL, 1)\n",
        "        label = TexText(\"Probability density = $f(x)g(y)$\", font_size=36)\n",
        "        label.next_to(rect, UP)\n",
        "        label.set_backstroke()\n",
        "\n",
        "        prob_word = label[\"Probability\"]\n",
        "        equals = label[\"=\"]\n",
        "        prob_word.save_state()\n",
        "        prob_word.next_to(equals, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(prob_word, lag_ratio=0.1),\n",
        "            FadeIn(equals),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            prob_word.animate.restore(),\n",
        "            FadeIn(label[\"density\"])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(f_label.copy(), label[\"f(x)\"][0]),\n",
        "            FadeTransform(g_label.copy(), label[\"g(y)\"][0]),\n",
        "            lag_ratio=0.3,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.add(label)\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Draw 3d graph\n",
        "        to_fix = [\n",
        "            f_axes, f_graph, f_label, x_indicator, x_label, x_line, x_dot,\n",
        "            g_axes, g_graph, g_label, y_indicator, y_label, y_line, y_dot,\n",
        "            label,\n",
        "        ]\n",
        "        for mobject in to_fix:\n",
        "            mobject.fix_in_frame()\n",
        "        plane.set_flat_stroke(False)\n",
        "\n",
        "        three_d_axes = self.get_three_d_axes(plane)\n",
        "        surface = three_d_axes.get_graph(\n",
        "            lambda x, y: self.f(x) * self.g(y),\n",
        "            resolution=self.graph_resolution,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(surface),\n",
        "            label.animate.set_x(FRAME_WIDTH / 4).to_edge(UP),\n",
        "            self.frame.animate.reorient(-27, 78, 0).move_to([0.36, -0.62, 0.71]).set_height(5.66).set_anim_args(run_time=4),\n",
        "        )\n",
        "        surface.always_sort_to_camera(self.camera)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(68, 77, 0).move_to([-0.13, -1.12, -0.27]).set_height(9.37),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Show two perspectives\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(3, 83, 0).move_to([1.09, -0.82, -0.54]).set_height(6.91),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(89, 95, 0).move_to([0.63, -2.19, 2.56]).set_height(9.41),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(69, 75, 0).move_to([1.07, -1.37, -0.19]).set_height(7.64),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "    def get_plane(self):\n",
        "        plane = NumberPlane(\n",
        "            **self.plane_config,\n",
        "            background_line_style=self.plane_line_style,\n",
        "        )\n",
        "        axis_labels = VGroup(\n",
        "            Tex(\"x\", font_size=24).next_to(plane.x_axis, RIGHT, SMALL_BUFF),\n",
        "            Tex(\"y\", font_size=24).next_to(plane.y_axis, UP, SMALL_BUFF),\n",
        "        )\n",
        "        axis_labels.insert_n_curves(100)\n",
        "        axis_labels.make_jagged()\n",
        "        plane.axis_labels = axis_labels\n",
        "        plane.add(*axis_labels)\n",
        "        return plane\n",
        "\n",
        "    def get_three_d_axes(self, plane):\n",
        "        axes = ThreeDAxes(\n",
        "            plane.x_range,\n",
        "            plane.y_range,\n",
        "            (0, 1),\n",
        "            width=plane.x_axis.get_width(),\n",
        "            height=plane.y_axis.get_height(),\n",
        "            depth=self.z_axis_height\n",
        "        )\n",
        "        axes.shift(plane.c2p(0, 0) - axes.c2p(0, 0, 0))\n",
        "        axes.z_axis.apply_depth_test()\n",
        "        return axes\n",
        "\n",
        "    def f(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "    def g(self, y):\n",
        "        return double_lump(y)\n",
        "\n",
        "\n",
        "class DiagonalSlices(Introduce3DGraph):\n",
        "    mesh_resolution = (21, 21)\n",
        "    shadow_opacity = 0.25\n",
        "    add_shadow = True\n",
        "    shadow_bump = 0.01\n",
        "    clip_plane_unit_coord = 0.45\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        plane, axes = self.add_plane_and_axes()\n",
        "        self.s_tracker = ValueTracker(-2 * plane.x_range[1])\n",
        "        get_s = self.s_tracker.get_value\n",
        "        self.add_surface_group(axes, get_s)\n",
        "        self.add_slice_graph(get_s)\n",
        "\n",
        "        self.init_func_name()\n",
        "        self.init_line_labels(get_s)\n",
        "\n",
        "        self.add(self.func_name)\n",
        "\n",
        "    def construct(self):\n",
        "        # Get some nice local variables\n",
        "        frame = self.camera.frame\n",
        "        plane = self.plane\n",
        "        axes = self.axes\n",
        "        s_tracker = self.s_tracker\n",
        "        slice_graph = self.slice_graph\n",
        "\n",
        "        # Insert\n",
        "        self.remove(self.equation)\n",
        "        axes.z_axis.set_opacity(1)\n",
        "        axes.z_axis.set_flat_stroke(True)\n",
        "        frame.reorient(80, 70).move_to(ORIGIN),\n",
        "        s_tracker.set_value(-5)\n",
        "        self.play(\n",
        "            frame.animate.reorient(40, 70).move_to(ORIGIN),\n",
        "            run_time=20,\n",
        "        )\n",
        "\n",
        "        # Initial orientation\n",
        "        self.frame.reorient(88, 90, 0).move_to([-0.31, -2.14, 2.16])\n",
        "        self.play(frame.animate.reorient(40, 70).move_to(ORIGIN), run_time=10)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(0.5),\n",
        "            frame.animate.reorient(0, 0),\n",
        "            VFadeIn(self.equation),\n",
        "            FadeOut(axes.z_axis),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show x + y = s slice\n",
        "        self.play(\n",
        "            FadeIn(self.ses_label, 0.5 * DOWN),\n",
        "            MoveAlongPath(GlowDot(), slice_graph, run_time=5, remover=True)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-22, 74, 0).move_to([-0.12, -0.16, 0.04]).set_height(5.45),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change s\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.5),\n",
        "            self.frame.animate.reorient(-45, 75, 0).move_to([0.18, -0.14, 0.49]).set_height(3.0),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-2.0),\n",
        "            self.frame.animate.reorient(-5, 66, 0).move_to([-0.03, -0.18, 0.14]).set_height(6.35),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(2.0),\n",
        "            self.frame.animate.reorient(16, 73, 0).move_to([-0.03, -0.18, 0.14]).set_height(6.35),\n",
        "            run_time=15,\n",
        "        )\n",
        "\n",
        "    def add_plane_and_axes(self):\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(20, 70)\n",
        "        plane = self.plane = self.get_plane()\n",
        "        plane.axes.set_stroke(GREY_B)\n",
        "        plane.set_flat_stroke(False)\n",
        "        plane.remove(plane.faded_lines)\n",
        "        axes = self.axes = self.get_three_d_axes(plane)\n",
        "\n",
        "        self.add(axes, axes.z_axis)\n",
        "        self.add(plane)\n",
        "\n",
        "        self.plane = plane\n",
        "        self.axes = axes\n",
        "\n",
        "        return plane, axes\n",
        "\n",
        "    def add_surface_group(self, axes, get_s):\n",
        "        # Surface\n",
        "        surface = axes.get_graph(\n",
        "            lambda x, y: self.f(x) * self.g(y),\n",
        "            resolution=self.graph_resolution\n",
        "        )\n",
        "        vect = axes.c2p(*2 * [self.clip_plane_unit_coord], 0)  # Why?\n",
        "        surface.add_updater(lambda m: m.set_clip_plane(vect, -get_s()))\n",
        "        surface.always_sort_to_camera(self.camera)\n",
        "\n",
        "        surface_mesh = SurfaceMesh(surface, resolution=self.mesh_resolution)\n",
        "        surface_mesh.set_stroke(WHITE, width=1, opacity=0.1)\n",
        "\n",
        "        surface_group = Group(surface, surface_mesh)\n",
        "\n",
        "        # Add shadow\n",
        "        if self.add_shadow:\n",
        "            surface_shadow = surface.copy()\n",
        "            surface_shadow.set_opacity(self.shadow_opacity)\n",
        "            surface_shadow.shift(self.shadow_bump * IN)\n",
        "            self.add(surface_shadow)\n",
        "\n",
        "            surface_group.add(surface_shadow)\n",
        "\n",
        "        self.surface_group = surface_group\n",
        "        self.add(surface_group)\n",
        "        return surface_group\n",
        "\n",
        "    def add_slice_graph(\n",
        "        self, get_s,\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=2,\n",
        "        fill_color=TEAL_D,\n",
        "        fill_opacity=0.5,\n",
        "        dx=0.01\n",
        "    ):\n",
        "        axes = self.axes\n",
        "\n",
        "        def get_points(s):\n",
        "            x_min, x_max = axes.x_range[:2]\n",
        "            y_min, y_max = axes.y_range[:2]\n",
        "\n",
        "            if s > 0:\n",
        "                xs = np.arange(s - y_max, x_max, dx)\n",
        "            else:\n",
        "                xs = np.arange(x_min, s - y_min, dx)\n",
        "\n",
        "            return axes.c2p(xs, s - xs, self.f(xs) * self.g(s - xs))\n",
        "\n",
        "        graph = VMobject()\n",
        "        graph.set_flat_stroke(False)\n",
        "        graph.set_stroke(stroke_color, stroke_width)\n",
        "        graph.set_fill(fill_color, fill_opacity)\n",
        "        graph.add_updater(lambda m: m.set_points_as_corners(get_points(get_s())))\n",
        "\n",
        "        self.add(graph)\n",
        "        self.slice_graph = graph\n",
        "\n",
        "    def init_func_name(self):\n",
        "        self.func_name = Tex(\n",
        "            R\"f(x) \\cdot g(y)\",\n",
        "            font_size=42,\n",
        "        )\n",
        "        self.func_name.to_corner(UL, buff=0.25)\n",
        "        self.func_name.fix_in_frame()\n",
        "        return self.func_name\n",
        "\n",
        "    def init_line_labels(self, get_s):\n",
        "        equation = Tex(\"x + y = 0.00\")\n",
        "        s_label = equation.make_number_changeable(\"0.00\")\n",
        "        s_label.add_updater(lambda m: m.set_value(get_s()))\n",
        "        equation.to_corner(UR)\n",
        "        equation.fix_in_frame()\n",
        "\n",
        "        ses_label = Tex(R\"\\{(x, s - x): x \\in \\mathds{R}\\}\", tex_to_color_map={\"s\": YELLOW}, font_size=30)\n",
        "        ses_label.next_to(equation, DOWN, MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        ses_label.fix_in_frame()\n",
        "\n",
        "        self.equation = equation\n",
        "        self.ses_label = ses_label\n",
        "\n",
        "        return equation, ses_label\n",
        "\n",
        "\n",
        "class SyncedSlices(DiagonalSlices):\n",
        "    initial_s = 2\n",
        "    add_shadow = False\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.func_name.set_x(-3)\n",
        "        self.func_name.align_to(self.equation, UP)\n",
        "        self.s_tracker.set_value(self.initial_s)\n",
        "        self.equation.set_x(2)\n",
        "        self.add(self.equation)\n",
        "\n",
        "    def construct(self):\n",
        "        s_tracker = self.s_tracker\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-1.5),\n",
        "            self.frame.animate.reorient(-28, 77, 0).move_to([0.17, -0.28, 0.25]).set_height(5.29),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.5),\n",
        "            self.frame.animate.reorient(-10, 73, 0).move_to([0.15, -0.28, 0.22]).set_height(5.04),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-0.5),\n",
        "            self.frame.animate.reorient(-39, 79, 0).move_to([0.15, -0.28, 0.21]).set_height(5.04),\n",
        "            run_time=20,\n",
        "        )\n",
        "\n",
        "\n",
        "class SyncedSlicesExpAndRect(SyncedSlices):\n",
        "    initial_s = -3.0\n",
        "    graph_resolution = (201, 201)\n",
        "    add_shadow = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        s_tracker = self.s_tracker\n",
        "        self.frame.reorient(-31, 68, 0).move_to([-1.51, 0.77, 0.22]).set_height(6.35)\n",
        "\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.0),\n",
        "            self.frame.animate.reorient(-38, 72, 0).move_to([0.53, -0.5, 0.34]).set_height(6.75),\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-1.5),\n",
        "            self.frame.animate.reorient(-45, 80, 0).move_to([-1.75, 0.32, 0.2]).set_height(5.04),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-3.0),\n",
        "            self.frame.animate.reorient(-28, 73, 0).move_to([-1.75, 0.32, 0.2]).set_height(5.04),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.0),\n",
        "            self.frame.animate.reorient(-39, 65, 0).move_to([0.35, -0.53, 0.06]).set_height(6.38),\n",
        "            run_time=20,\n",
        "        )\n",
        "\n",
        "    def f(self, x):\n",
        "        return (x > -2) * np.exp(-2 - x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "\n",
        "class CleanExpAndRect(SyncedSlicesExpAndRect):\n",
        "    def construct(self):\n",
        "        self.remove(self.equation, self.func_name)\n",
        "\n",
        "        s_tracker = self.s_tracker\n",
        "        s_tracker.set_value(-1.5)\n",
        "\n",
        "        surface, mesh, surface_shadow = self.surface_group\n",
        "        mesh.make_jagged()\n",
        "        surface_shadow.set_opacity(0.5)\n",
        "        self.remove(self.surface_group)\n",
        "        self.add(surface, surface_shadow, mesh, self.slice_graph)\n",
        "\n",
        "\n",
        "class SyncedSlicesUniformAndWedge(SyncedSlices):\n",
        "    initial_s = -2.0\n",
        "    graph_resolution = (201, 201)\n",
        "    add_shadow = True\n",
        "\n",
        "    def f(self, x):\n",
        "        return uniform(x)\n",
        "\n",
        "    def g(self, x):\n",
        "        return wedge_func(x)\n",
        "\n",
        "\n",
        "class SyncedSlicesGaussian(SyncedSlices):\n",
        "    add_shadow = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.func_name.set_x(0)\n",
        "        self.equation.to_edge(RIGHT)\n",
        "\n",
        "        s_tracker = self.s_tracker\n",
        "        s_tracker.set_value(0)\n",
        "        self.frame.reorient(0, 53, 0).move_to([0.05, 0.28, -0.23]).set_height(6.70)\n",
        "\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-2.0),\n",
        "            self.frame.animate.reorient(-38, 72, 0).move_to([0.53, -0.5, 0.34]).set_height(6.75),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1.5),\n",
        "            self.frame.animate.reorient(-7, 61, 0).move_to([0.5, -0.06, 0.4]).set_height(3.85),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(-1.5),\n",
        "            self.frame.animate.reorient(-28, 73, 0).move_to([-0.06, -0.56, 0.26]).set_height(5.04),\n",
        "            run_time=20,\n",
        "        )\n",
        "\n",
        "    def f(self, x):\n",
        "        return gauss_func(x, 0, 0.5)\n",
        "\n",
        "    def g(self, x):\n",
        "        return gauss_func(x, 0, 0.5)\n",
        "\n",
        "\n",
        "class AnalyzeStepAlongDiagonalLine(DiagonalSlices):\n",
        "    initial_s = 0.5\n",
        "    dx = 1 / 8\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        s_tracker = self.s_tracker\n",
        "        frame = self.frame\n",
        "        surface, mesh, shadow = self.surface_group\n",
        "\n",
        "        s_tracker.set_value(self.initial_s)\n",
        "        frame.reorient(-27, 73, 0)\n",
        "\n",
        "        self.slice_graph.update()\n",
        "        self.slice_graph.clear_updaters()\n",
        "\n",
        "        # Focus on line\n",
        "        line = self.plane.get_graph(lambda x: self.initial_s - x)\n",
        "        line.set_stroke(WHITE, 3)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0).center().set_height(7),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(surface),\n",
        "            FadeOut(mesh),\n",
        "            FadeOut(shadow),\n",
        "            FadeOut(self.slice_graph),\n",
        "            FadeIn(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show small step\n",
        "        segment = line.copy()\n",
        "        segment.pointwise_become_partial(line, 12 * self.dx / 4, 13 * self.dx / 4)\n",
        "        segment.set_stroke(YELLOW, 3)\n",
        "\n",
        "        segment.rotate(45 * DEGREES).scale(3)\n",
        "        brace = Brace(segment, DOWN, buff=SMALL_BUFF)\n",
        "        center = segment.get_center()\n",
        "        VGroup(brace, segment).scale(1 / 3, about_point=center).rotate(-45 * DEGREES, about_point=center)\n",
        "\n",
        "        tex_kw = dict(font_size=12)\n",
        "        step_word = Text(\"Step\", **tex_kw)\n",
        "        step_word.next_to(brace.get_center(), DL, SMALL_BUFF)\n",
        "        step_word.shift(0.05 * UP)\n",
        "        step_word.set_backstroke()\n",
        "\n",
        "        dx_line = DashedLine(segment.get_corner(UL), segment.get_corner(UR), dash_length=0.01)\n",
        "        dy_line = DashedLine(segment.get_corner(UR), segment.get_corner(DR), dash_length=0.01)\n",
        "        dx_line.set_stroke(RED)\n",
        "        dy_line.set_stroke(GREEN)\n",
        "\n",
        "        dx_label = Tex(R\"\\Delta x\", **tex_kw)\n",
        "        dx_label.match_color(dx_line)\n",
        "        dx_label.next_to(dx_line, UP, buff=0.05)\n",
        "\n",
        "        dy_label = Tex(R\"\\Delta y\", **tex_kw)\n",
        "        dy_label.next_to(dy_line, RIGHT, buff=0.05)\n",
        "        dy_label.match_color(dy_line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(segment),\n",
        "            line.animate.set_stroke(width=1),\n",
        "            GrowFromCenter(brace),\n",
        "            Write(step_word),\n",
        "            frame.animate.scale(0.3, about_point=1.5 * UL).set_anim_args(run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dx_line),\n",
        "            ShowCreation(dy_line),\n",
        "            FadeIn(dx_label),\n",
        "            FadeIn(dy_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show equation\n",
        "        rhs = Tex(R\"= \\sqrt{2} \\cdot \\Delta x\", **tex_kw)\n",
        "        rhs.move_to(step_word, RIGHT)\n",
        "        rhs.set_backstroke()\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(dx_label.copy(), rhs[R\"\\Delta x\"][0]),\n",
        "            Write(rhs[R\"= \\sqrt{2} \\cdot \"]),\n",
        "            step_word.animate.next_to(rhs, LEFT, buff=0.05).shift(0.025 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show graph again\n",
        "        segment.set_flat_stroke(False)\n",
        "        line.set_flat_stroke(False)\n",
        "        self.add(surface, mesh)\n",
        "        self.play(\n",
        "            FadeIn(surface),\n",
        "            FadeIn(mesh),\n",
        "            FadeIn(self.slice_graph),\n",
        "            FadeOut(self.equation),\n",
        "            FadeOut(self.ses_label),\n",
        "            FadeOut(self.func_name),\n",
        "            self.frame.animate.reorient(-42, 79, 0).move_to([-0.15, 0.73, 1.18]).set_height(3.50),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Show riemann rectangles\n",
        "        rects = VGroup()\n",
        "        x_unit = self.plane.x_axis.get_unit_size()\n",
        "        z_unit = self.axes.z_axis.get_unit_size()\n",
        "        dx = self.dx\n",
        "        for x in np.arange(-2, 2, dx):\n",
        "            y = self.initial_s - x\n",
        "            if not (-2 <= y <= 2):\n",
        "                continue\n",
        "            rect = Rectangle(\n",
        "                width=math.sqrt(2) * x_unit * dx,\n",
        "                height=self.f(x) * self.g(y) * z_unit\n",
        "            )\n",
        "            rect.rotate(90 * DEGREES, RIGHT)\n",
        "            rect.rotate(-45 * DEGREES, OUT)\n",
        "            rect.shift(self.plane.c2p(x, y) - rect.get_corner([-1, 1, -1]))\n",
        "            rects.add(rect)\n",
        "\n",
        "        rects.set_fill(TEAL, 0.5)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        rects.set_flat_stroke(False)\n",
        "\n",
        "        self.play(\n",
        "            Write(rects),\n",
        "            self.slice_graph.animate.set_fill(opacity=0.1)\n",
        "        )\n",
        "        self.add(rects)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotationalSymmetryOfGaussian(DiagonalSlices):\n",
        "    plane_config = dict(\n",
        "        x_range=(-3, 3),\n",
        "        y_range=(-3, 3),\n",
        "        width=8.0,\n",
        "        height=8.0,\n",
        "    )\n",
        "    mesh_resolution = (25, 25)\n",
        "    clip_plane_unit_coord = 0.565\n",
        "\n",
        "    def construct(self):\n",
        "        # Variables\n",
        "        frame = self.frame\n",
        "        axes = self.axes\n",
        "        s_tracker = self.s_tracker\n",
        "        surface_group = self.surface_group\n",
        "        slice_graph = self.slice_graph\n",
        "\n",
        "        # Add functions\n",
        "        self.add_function_labels()\n",
        "\n",
        "        # Show slices\n",
        "        s_tracker.set_value(1)\n",
        "        frame.reorient(-20, 69, 0).move_to(0.5 * OUT)\n",
        "        self.play(\n",
        "            frame.animate.reorient(20, 69, 0),\n",
        "            s_tracker.animate.set_value(-6),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        # Emphasize rotational symmetry\n",
        "        curve = VMobject()\n",
        "        curve.set_stroke(TEAL, 3)\n",
        "        dx = 0.05\n",
        "        xs = np.arange(*axes.x_range, dx)\n",
        "        curve.set_points_smoothly(axes.c2p(xs, np.zeros(xs.size), self.f(xs)))\n",
        "        curve.set_flat_stroke(False)\n",
        "        curve.make_jagged()\n",
        "        curve.apply_depth_test()\n",
        "        curve.shift(0.025 * OUT)\n",
        "        curves = VGroup(*(\n",
        "            curve.copy().rotate(a, about_point=axes.c2p(0, 0, 0))\n",
        "            for a in np.linspace(0, PI, 25)\n",
        "        ))\n",
        "        curves.set_stroke(width=1, opacity=0.5)\n",
        "\n",
        "        self.play(ShowCreation(curve))\n",
        "        self.play(\n",
        "            Rotate(curve, PI, about_point=ORIGIN),\n",
        "            ShowIncreasingSubsets(curves, rate_func=smooth),\n",
        "            self.frame.animate.reorient(-20, 69, 0).center(),\n",
        "            Rotate(surface_group, PI),\n",
        "            run_time=7\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(curve, time_span=(0, 2)),\n",
        "            FadeOut(curves, time_span=(0, 2)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show r\n",
        "        surface, mesh, ghost_surface = surface_group\n",
        "        surface_group.generate_target()\n",
        "        surface_group.target[0].set_opacity(0.25)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(surface_group),\n",
        "            frame.animate.reorient(0, 0).set_height(10).move_to(1.5 * LEFT).set_field_of_view(1 * DEGREES),\n",
        "            FadeOut(self.func_names),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Explain meaning of r\n",
        "        x, y = (1.5, 0.75)\n",
        "        dot = Dot(axes.c2p(x, y), fill_color=RED)\n",
        "        dot.set_stroke(WHITE, 0.5)\n",
        "        coords = Tex(\"(x, y)\", font_size=36)\n",
        "        coords.set_backstroke(width=5)\n",
        "        coords.next_to(dot, UR, SMALL_BUFF)\n",
        "        coords.shift(0.1 * DOWN)\n",
        "\n",
        "        x_line = Line(axes.get_origin(), axes.c2p(x, 0, 0))\n",
        "        y_line = Line(axes.c2p(x, 0, 0), axes.c2p(x, y, 0))\n",
        "        r_line = Line(axes.c2p(x, y, 0), axes.get_origin())\n",
        "        x_line.set_stroke(BLUE, 3)\n",
        "        y_line.set_stroke(YELLOW, 3)\n",
        "        r_line.set_stroke(RED, 3)\n",
        "        lines = VGroup(x_line, y_line, r_line)\n",
        "        labels = VGroup(*map(Tex, \"xyr\"))\n",
        "        for label, line in zip(labels, lines):\n",
        "            label.match_color(line)\n",
        "            label.scale(0.85)\n",
        "            label.next_to(line.get_center(), rotate_vector(line.get_vector(), -90 * DEGREES), SMALL_BUFF)\n",
        "\n",
        "        self.add(dot, coords)\n",
        "        self.play(\n",
        "            FadeIn(dot, scale=0.5),\n",
        "            FadeIn(coords),\n",
        "        )\n",
        "        for line, label in zip(lines, labels):\n",
        "            self.add(line, label, dot)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Write(label),\n",
        "            )\n",
        "\n",
        "    def add_function_labels(self):\n",
        "        kw = dict(t2c={\"x\": BLUE, \"y\": YELLOW})\n",
        "        func_names = VGroup(\n",
        "            Tex(\"f(x) = e^{-x^2}\", **kw),\n",
        "            Tex(\"g(y) = e^{-y^2}\", **kw),\n",
        "        )\n",
        "        func_names.scale(0.75)\n",
        "        func_names.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        func_names.to_corner(UL)\n",
        "        func_names.fix_in_frame()\n",
        "        self.func_names = func_names\n",
        "\n",
        "        self.remove(self.func_name)\n",
        "        self.add(func_names)\n",
        "\n",
        "    def f(self, x):\n",
        "        return np.exp(-x**2)\n",
        "\n",
        "    def g(self, x):\n",
        "        return np.exp(-x**2)\n",
        "\n",
        "\n",
        "class RotateGaussianSlice(RotationalSymmetryOfGaussian):\n",
        "    def construct(self):\n",
        "        # Variables\n",
        "        frame = self.frame\n",
        "        axes = self.axes\n",
        "        s_tracker = self.s_tracker\n",
        "        surface_group = self.surface_group\n",
        "        slice_graph = self.slice_graph\n",
        "        self.add_function_labels()\n",
        "        self.add(s_tracker)\n",
        "\n",
        "        # Focus on one slice\n",
        "        self.play(\n",
        "            frame.animate.reorient(-20, 69, 0), run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(1),\n",
        "            frame.animate.reorient(0, 55, 0),\n",
        "            axes.z_axis.animate.set_opacity(0),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.remove(axes.z_axis)\n",
        "        self.wait()\n",
        "        for s in [1.5, 0.5, 1.0]:\n",
        "            self.play(s_tracker.animate.set_value(s), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        # Label two points\n",
        "        s_tracker.set_value(1)\n",
        "        s_color = RED\n",
        "        s: float = s_tracker.get_value()\n",
        "        dots = Group(\n",
        "            GlowDot(axes.c2p(s, 0, 0), color=s_color),\n",
        "            GlowDot(axes.c2p(0, s, 0), color=s_color),\n",
        "        )\n",
        "        labels = VGroup()\n",
        "        lines = VGroup()\n",
        "        for dot, tex in zip(dots, [\"(s, 0)\", \"(0, s)\"]):\n",
        "            label = Tex(tex, font_size=24)\n",
        "            label.next_to(dot, DL, buff=-0.1)\n",
        "            label.set_backstroke()\n",
        "            labels.add(label)\n",
        "            line = Line(axes.get_origin(), dot.get_center())\n",
        "            line.set_stroke(s_color, 2)\n",
        "            lines.add(line)\n",
        "\n",
        "        self.play(frame.animate.reorient(0, 25, 0).set_height(6).move_to(UP))\n",
        "        for dot, label, line in zip(dots, labels, lines):\n",
        "            self.play(\n",
        "                FadeInFromPoint(dot, line.get_start()),\n",
        "                Write(label),\n",
        "                ShowCreation(line),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Straight line distance\n",
        "        s_tracker.set_value(1)\n",
        "        dist_line = Line(axes.get_origin(), axes.c2p(s / 2, s / 2, 0))\n",
        "        dist_line.set_stroke(s_color, 2)\n",
        "        dist_label = Tex(R\"s / \\sqrt{2}\", font_size=20)\n",
        "        dist_label.next_to(dist_line.get_center(), RIGHT, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(5).set_anim_args(run_time=4),\n",
        "            LaggedStart(\n",
        "                ShowCreation(dist_line),\n",
        "                Write(dist_label),\n",
        "            ),\n",
        "            FadeOut(self.func_names, time_span=(2, 3)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, Group(*dots, *lines, *labels)))\n",
        "        self.wait()\n",
        "\n",
        "        # Rotate\n",
        "        surface, mesh, shadow = surface_group\n",
        "        shadow.set_opacity(0)\n",
        "        surface.clear_updaters()\n",
        "        slice_graph.clear_updaters()\n",
        "\n",
        "        clip_vect = VectorizedPoint(surface.uniforms[\"clip_plane\"][:3])\n",
        "        surface.add_updater(lambda m: m.set_clip_plane(\n",
        "            clip_vect.get_center(), -s_tracker.get_value()\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            Rotate(clip_vect, -45 * DEGREES, about_point=ORIGIN),\n",
        "            Rotate(slice_graph, -45 * DEGREES, about_point=ORIGIN),\n",
        "            Rotate(dist_line, -45 * DEGREES, about_point=ORIGIN),\n",
        "            dist_label.animate.next_to(\n",
        "                axes.c2p(s / 2 / math.sqrt(2), 0, 0), DOWN, SMALL_BUFF,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Ambient rotation\n",
        "        self.play(\n",
        "            frame.animate.reorient(-35, 59, 0).move_to([-0.0, 0.22, 0.4]).set_height(5.94),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-8, 62, 0),\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(-31, 54, 0),\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OscillatingGaussianSlice(RotationalSymmetryOfGaussian):\n",
        "    def construct(self):\n",
        "        # Variables\n",
        "        frame = self.frame\n",
        "        axes = self.axes\n",
        "        s_tracker = self.s_tracker\n",
        "        surface_group = self.surface_group\n",
        "        slice_graph = self.slice_graph\n",
        "        self.add(s_tracker)\n",
        "        self.remove(self.func_name)\n",
        "        self.add(self.equation)\n",
        "\n",
        "        # Change value\n",
        "        s_tracker.set_value(-3)\n",
        "        frame.reorient(-20, 55, 0)\n",
        "        frame.set_height(6)\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(3).set_anim_args(rate_func=there_and_back),\n",
        "            frame.animate.reorient(20, 60, 0),\n",
        "            run_time=24,\n",
        "        )\n",
        "        self.play(\n",
        "            s_tracker.animate.set_value(3).set_anim_args(rate_func=there_and_back),\n",
        "            frame.animate.reorient(-20, 55, 0),\n",
        "            run_time=24,\n",
        "        )\n",
        "\n",
        "\n",
        "class Thumbnail(RotationalSymmetryOfGaussian):\n",
        "    def construct(self):\n",
        "        # Variables\n",
        "        frame = self.frame\n",
        "        axes = self.axes\n",
        "        s_tracker = self.s_tracker\n",
        "        surface_group = self.surface_group\n",
        "        slice_graph = self.slice_graph\n",
        "        self.add(s_tracker)\n",
        "        self.remove(self.func_name)\n",
        "        self.remove(self.equation)\n",
        "        s_tracker.set_value(0)\n",
        "        frame.reorient(0, 47, 0)\n",
        "\n",
        "        # Better surface\n",
        "        surface, mesh, shadow = surface_group\n",
        "        shadow.clear_updaters()\n",
        "        shadow.set_clip_plane(ORIGIN, 00)\n",
        "        shadow.set_opacity(0.5)\n",
        "\n",
        "        self.add(shadow, surface, mesh, slice_graph)\n",
        "\n",
        "        # Title\n",
        "        title = TexText(\"It's about symmetry\", font_size=90)\n",
        "        title.to_edge(UP)\n",
        "        title.fix_in_frame()\n",
        "        self.add(title)\n",
        "\n"
    ]
}