{
    "topic": "The mathematical concept being demonstrated is the visualization of a celestial sphere, which represents the Earth",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "EARTH_TILT_ANGLE = 23.3 * DEG\n",
        "\n",
        "# All in Kilometers\n",
        "EARTH_RADIUS = 6_371\n",
        "MOON_RADIUS = 1_737.4\n",
        "MOON_ORBIT_RADIUS = 384_400\n",
        "SUN_RADIUS = 695_700\n",
        "\n",
        "MERCURY_ORBIT_RADIUS = 6.805e7\n",
        "VENUS_ORBIT_RADIUS = 1.082e8\n",
        "EARTH_ORBIT_RADIUS = 1.473e8\n",
        "MARS_ORBIT_RADIUS = 2.280e8\n",
        "CERES_ORBIT_RADIUS = 4.130e8\n",
        "JUPITER_ORBIT_RADIUS = 7.613e8\n",
        "SATURN_ORBIT_RADIUS = 1.439e9\n",
        "\n",
        "# In days\n",
        "MERCURY_ORBIT_PERIOD = 87.97\n",
        "VENUS_ORBIT_PERIOD = 224.7\n",
        "EARTH_ORBIT_PERIOD = 365.25\n",
        "MARS_ORBIT_PERIOD = 686.98\n",
        "JUPITER_ORBIT_PERIOD = 4332.82\n",
        "SATURN_ORBIT_PERIOD = 10755.7\n",
        "\n",
        "# In km / s\n",
        "SPEED_OF_LIGHT = 299792\n",
        "\n",
        "\n",
        "def get_earth(radius=1.0, day_texture=\"EarthTextureMap\", night_texture=\"NightEarthTextureMap\"):\n",
        "    sphere = Sphere(radius=radius)\n",
        "    earth = TexturedSurface(sphere, day_texture, night_texture)\n",
        "    return earth\n",
        "\n",
        "\n",
        "def get_sphere_mesh(radius=1.0):\n",
        "    sphere = Sphere(radius=radius)\n",
        "    mesh = SurfaceMesh(sphere)\n",
        "    mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "    return mesh\n",
        "\n",
        "\n",
        "def get_moon(radius=1.0, resolution=(101, 51)):\n",
        "    moon = TexturedSurface(Sphere(radius=radius, resolution=resolution), \"MoonTexture\", \"DarkMoonTexture\")\n",
        "    moon.set_shading(0.25, 0.25, 1)\n",
        "    return moon\n",
        "\n",
        "\n",
        "def get_sun(\n",
        "    radius=1.0,\n",
        "    near_glow_ratio=2.0,\n",
        "    near_glow_factor=2,\n",
        "    big_glow_ratio=4,\n",
        "    big_glow_factor=1,\n",
        "    big_glow_opacity=0.35,\n",
        "):\n",
        "    sun = TexturedSurface(Sphere(radius=radius), \"SunTexture\")\n",
        "    sun.set_shading(0, 0, 0)\n",
        "    sun.to_edge(LEFT)\n",
        "\n",
        "    # Glows\n",
        "    near_glow = GlowDot(radius=near_glow_ratio * radius, glow_factor=near_glow_factor)\n",
        "    near_glow.move_to(sun)\n",
        "\n",
        "    big_glow = GlowDot(radius=big_glow_ratio * radius, glow_factor=big_glow_factor, opacity=big_glow_opacity)\n",
        "    big_glow.move_to(sun)\n",
        "\n",
        "    return Group(sun, near_glow, big_glow)\n",
        "\n",
        "\n",
        "def get_planet(name, radius=1.0):\n",
        "    planet = TexturedSurface(Sphere(radius=radius), f\"{name}Texture\", f\"Dark{name}Texture\")\n",
        "    planet.set_shading(0.25, 0.25, 1)\n",
        "    return planet\n",
        "\n",
        "\n",
        "def get_celestial_sphere(radius=1000, constellation_opacity=0.1):\n",
        "    sphere = Group(\n",
        "        TexturedSurface(Sphere(radius=radius, clockwise=True), \"hiptyc_2020_8k\"),\n",
        "        TexturedSurface(Sphere(radius=0.99 * radius, clockwise=True), \"constellation_figures\"),\n",
        "    )\n",
        "    sphere.set_shading(0, 0, 0)\n",
        "    sphere[1].set_opacity(constellation_opacity)\n",
        "\n",
        "    sphere.rotate(EARTH_TILT_ANGLE, RIGHT)\n",
        "\n",
        "    return sphere\n",
        "\n",
        "\n",
        "def get_planet_symbols(text, font_size=48):\n",
        "    return Tex(\n",
        "        Rf\"\\{text}\",\n",
        "        additional_preamble=R\"\\usepackage{wasysym}\",\n",
        "        font_size=font_size,\n",
        "    )\n",
        "\n",
        "\n",
        "class PerspectivesOnEarth(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Ask about size\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(50 * LEFT)\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(25 * DEG)\n",
        "\n",
        "        conversion_factor = 1.0 / EARTH_RADIUS\n",
        "\n",
        "        earth = get_earth(radius=EARTH_RADIUS * conversion_factor)\n",
        "        earth.rotate(-EARTH_TILT_ANGLE, UP)\n",
        "        earth_axis = rotate_vector(OUT, -EARTH_TILT_ANGLE, UP)\n",
        "\n",
        "        earth.add_updater(lambda m, dt: m.rotate(dt * 10 * DEG, axis=earth_axis))\n",
        "\n",
        "        self.add(earth)\n",
        "\n",
        "        # Clearly show the size of the earth\n",
        "        brace = Brace(earth, LEFT)\n",
        "        brace.stretch(0.5, 1, about_edge=UP)\n",
        "        label = brace.get_tex(Rf\"R_E\", font_size=24)\n",
        "        VGroup(brace, label).rotate(90 * DEG, RIGHT, about_point=brace.get_bottom())\n",
        "\n",
        "        dashed_lines = VGroup(\n",
        "            DashedLine(brace.get_corner(OUT + RIGHT), earth.get_zenith(), dash_length=0.02),\n",
        "            DashedLine(brace.get_corner(IN + RIGHT), earth.get_center(), dash_length=0.02),\n",
        "        )\n",
        "        dashed_lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        frame.reorient(0, 90, 0, ORIGIN, 3.42)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(label),\n",
        "            *map(ShowCreation, dashed_lines),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(label, brace, *dashed_lines), shift=IN))\n",
        "\n",
        "        # Make it wobble a bit\n",
        "        earth.suspend_updating()\n",
        "\n",
        "        def wave(x):\n",
        "            return math.sin(2 * x) * np.exp(-x * x)\n",
        "\n",
        "        def homotopy(x, y, z, t):\n",
        "            t = 3 * (2 * t - 1)\n",
        "            return (x + 0.1 * wave(t - z), y, z + 0.1 * wave(t - x))\n",
        "\n",
        "        self.play(Homotopy(homotopy, earth, run_time=5))\n",
        "\n",
        "        # Turn it into a disk\n",
        "        earth.save_state()\n",
        "        flat_earth = TexturedSurface(\n",
        "            ParametricSurface(\n",
        "                lambda u, v: ((1 - v) * math.cos(u), (1 - v) * math.sin(u), 0),\n",
        "                u_range=(0, TAU),\n",
        "                v_range=(0, 1),\n",
        "                resolution=earth.resolution\n",
        "            ),\n",
        "            \"EarthTextureMap\",\n",
        "            \"NightEarthTextureMap\",\n",
        "        )\n",
        "\n",
        "        rot = rotation_matrix_transpose(40 * DEG, (-1, 0, -0.5)).T\n",
        "        flat_earth = earth.copy().apply_matrix(rot).stretch(1e-2, 2)\n",
        "        flat_earth.data[\"d_normal_point\"] = flat_earth.get_points() + 1e-3 * OUT\n",
        "\n",
        "        self.play(\n",
        "            Transform(earth, flat_earth, run_time=4),\n",
        "            frame.animate.reorient(0, 74, 0, (-0.03, -0.14, 0.04), 3.42),\n",
        "            light.animate.shift(10 * OUT + 10 * LEFT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(Rotate(earth, PI / 3, axis=RIGHT, run_time=3, rate_func=wiggle))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom out to the moon\n",
        "        orbit = Circle(radius=MOON_ORBIT_RADIUS * conversion_factor)\n",
        "        orbit.set_stroke(GREY_C, width=(0, 3))\n",
        "        orbit.rotate(-45 * DEG)\n",
        "        orbit.add_updater(lambda m, dt: m.rotate(5 * dt * DEG))\n",
        "\n",
        "        moon = get_moon(radius=MOON_RADIUS * conversion_factor)\n",
        "        moon.to_edge(RIGHT)\n",
        "        moon.add_updater(lambda m: m.move_to(orbit.get_start()))\n",
        "\n",
        "        self.add(orbit, moon)\n",
        "        self.play(\n",
        "            Restore(earth, time_span=(0, 3)),\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, 1.1 * orbit.get_height()),\n",
        "            run_time=4,\n",
        "        )\n",
        "\n",
        "        interp_factor = ValueTracker(0)\n",
        "        frame.add_updater(lambda m: m.move_to(interpolate(m.get_center(), moon.get_center(), interp_factor.get_value())))\n",
        "        self.play(\n",
        "            frame.animate.reorient(-67, 60, 0,).set_height(3),\n",
        "            interp_factor.animate.set_value(0.2),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SphericalEarthVsFlat(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(50 * LEFT)\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(25 * DEG)\n",
        "        earth = get_earth(radius=3)\n",
        "        earth.rotate(-EARTH_TILT_ANGLE, UP)\n",
        "        earth_axis = rotate_vector(OUT, -EARTH_TILT_ANGLE, UP)\n",
        "        self.add(earth)\n",
        "\n",
        "        frame.reorient(160, 75, 0, (-0.53, -0.33, 1.91), 1.84)\n",
        "        self.play(\n",
        "            frame.animate.reorient(166, 63, 0, ORIGIN, FRAME_HEIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(frame.animate.to_default_state(), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Look around\n",
        "        self.look_from_various_angles()\n",
        "\n",
        "        # Squish\n",
        "        day_earth = get_earth(radius=earth.get_height() / 2, night_texture=\"EarthTextureMap\")\n",
        "        flat_earth = day_earth.copy().set_depth(1e-2, stretch=True)\n",
        "        flat_earth.data[\"d_normal_point\"] = flat_earth.data[\"point\"] + 1e-3 * OUT\n",
        "        self.play(FadeOut(earth, scale=0.99), FadeIn(day_earth, scale=0.99))\n",
        "        self.play(\n",
        "            Transform(day_earth, flat_earth),\n",
        "            light.animate.set_z(10),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Ellipse\n",
        "        circle = Circle(radius=3)\n",
        "        circle.set_stroke(TEAL, 3)\n",
        "        self.play(frame.animate.reorient(10, 80, 0), run_time=2)\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "\n",
        "    def look_from_various_angles(self, run_time=1.5):\n",
        "        frame = self.frame\n",
        "        orientations = [\n",
        "            (10, 80, 0),\n",
        "            (-150, 129, 0),\n",
        "            (97, 55, 0),\n",
        "            (0, 0, 0)\n",
        "        ]\n",
        "        for orientation in orientations:\n",
        "            self.play(frame.animate.reorient(*orientation), run_time=run_time)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class SizeOfEarthRenewed(InteractiveScene):\n",
        "    radius = 3.0\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        self.set_floor_plane(\"xz\")\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(15 * DEG)\n",
        "\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(20 * RIGHT)\n",
        "\n",
        "        # Add earth\n",
        "        sphere = Sphere(radius=self.radius)\n",
        "        earth = get_earth(radius=self.radius)\n",
        "        mesh = get_sphere_mesh(radius=self.radius)\n",
        "        mesh.rotate(-2 * DEG)\n",
        "        transparent_earth = earth.copy()\n",
        "        transparent_earth.set_opacity(0.25)\n",
        "\n",
        "        inner_shell = sphere.copy()\n",
        "        inner_shell.set_color(GREY_E)\n",
        "        inner_shell.set_height(0.99 * 2 * self.radius)\n",
        "\n",
        "        earth_group = Group(inner_shell, earth, mesh, transparent_earth)\n",
        "        earth_group.rotate(90 * DEG, LEFT)\n",
        "\n",
        "        slice_tracker = ValueTracker(self.radius + SMALL_BUFF)\n",
        "        earth.add_updater(lambda m: m.set_clip_plane(OUT, slice_tracker.get_value()))\n",
        "        inner_shell.add_updater(lambda m: m.set_clip_plane(OUT, slice_tracker.get_value()))\n",
        "        mesh.add_updater(lambda m: m.set_clip_plane(IN, -slice_tracker.get_value()))\n",
        "        transparent_earth.add_updater(lambda m: m.set_clip_plane(IN, -slice_tracker.get_value()))\n",
        "\n",
        "        circle = Circle(radius=self.radius)\n",
        "\n",
        "        earth_axis = rotate_vector(UP, -EARTH_TILT_ANGLE)\n",
        "\n",
        "        axis_line = Line(DOWN, UP).set_height(8)\n",
        "        axis_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        earth_group.rotate(147 * DEG, UP)\n",
        "        earth_group.rotate(-EARTH_TILT_ANGLE, OUT)\n",
        "\n",
        "        self.add(earth)\n",
        "\n",
        "        # Unflatten earth\n",
        "        earth.save_state()\n",
        "        earth.stretch(1e-3, 0)\n",
        "        earth.data[\"d_normal_point\"] = earth.get_points() + 1e-3 * RIGHT\n",
        "        earth.note_changed_data()\n",
        "\n",
        "        frame.reorient(5, 0, -90, 2 * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, -90, RIGHT),\n",
        "            Restore(earth),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Add rays from the sun\n",
        "        sun = GlowDot(100 * RIGHT, radius=1)\n",
        "        n_rays = 25\n",
        "        rays = Line(LEFT, RIGHT).replicate(n_rays)\n",
        "        rays.set_stroke(YELLOW, 1)\n",
        "\n",
        "        def update_rays(rays):\n",
        "            ys = np.linspace(earth.get_y(UP), earth.get_y(DOWN), len(rays))\n",
        "            for ray, y in zip(rays, ys):\n",
        "                ray.put_start_and_end_on(\n",
        "                    sun.get_center(),\n",
        "                    [math.sqrt(abs(self.radius**2 - y**2)), y, 0],\n",
        "                )\n",
        "\n",
        "        rays.add_updater(update_rays)\n",
        "        rays.set_z_index(-1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rays, shift=0.5 * LEFT, lag_ratio=0.02),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-67, -7, 0, (0.92, 2.13, 3.94), 20.25),\n",
        "            sun.animate.move_to(50 * RIGHT),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            sun.animate.move_to(1000 * RIGHT).set_anim_args(time_span=(0, 3)),\n",
        "            frame.animate.reorient(-130, -14, 0, (2.66, 0.14, -0.69), 8.18).set_anim_args(time_span=(2, 7)),\n",
        "            run_time=7,\n",
        "        )\n",
        "\n",
        "        # Show line through Syene\n",
        "        center_dot = GlowDot(color=RED)\n",
        "        slice_tracker.set_value(self.radius + SMALL_BUFF)\n",
        "        angle = 7 * DEG\n",
        "\n",
        "        h_line = Line(ORIGIN, 20 * RIGHT)\n",
        "        h_line.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.add(earth_group)\n",
        "        self.play(\n",
        "            slice_tracker.animate.set_value(0),\n",
        "            FadeIn(center_dot, scale=0.25),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(h_line, rate_func=rush_into, run_time=2),\n",
        "            FadeOut(rays, run_time=2),\n",
        "            frame.animate.reorient(-205, -11, 0, (3.0, -0.0, 0.0), 6.50).set_anim_args(run_time=10),\n",
        "        )\n",
        "\n",
        "        # Rotate the earth about a bit\n",
        "        earth_group.save_state()\n",
        "        self.play(Rotate(earth_group, 40 * DEG, axis=OUT, run_time=3))\n",
        "        self.play(Rotate(earth_group, 40 * DEG, axis=UP, run_time=3, rate_func=there_and_back))\n",
        "        self.play(Rotate(earth_group, -40 * DEG, axis=OUT, run_time=3))\n",
        "\n",
        "        # Emphasize the tilt of the earth's axis\n",
        "        axis_line = Line(-1.25 * self.radius * earth_axis, 1.25 * self.radius * earth_axis)\n",
        "        axis_line.set_stroke(WHITE, 2)\n",
        "        self.play(\n",
        "            Rotate(earth_group, 2 * TAU, axis=earth_axis),\n",
        "            FadeIn(axis_line, time_span=(0, 1)),\n",
        "            FadeIn(rays, remover=True, time_span=(4, 15), rate_func=lambda t: there_and_back_with_pause(t, 9 / 11)),\n",
        "            frame.animate.reorient(-91, -36, 0, (4.91, -1.44, 0.39), 11.01).set_anim_args(time_span=(4, 15), rate_func=lambda t: there_and_back_with_pause(t, 0.2)),\n",
        "            run_time=15,\n",
        "        )\n",
        "\n",
        "        # Show tropic of cancer\n",
        "        def get_lat_line(angle):\n",
        "            result = Circle(radius=self.radius)\n",
        "            result.rotate(90 * DEG, LEFT).rotate(EARTH_TILT_ANGLE, axis=IN)\n",
        "            result.set_stroke(TEAL, 2)\n",
        "            result.apply_depth_test()\n",
        "            result.scale(math.cos(angle))\n",
        "            result.shift(math.sin(angle) * earth_axis * self.radius)\n",
        "            return result\n",
        "\n",
        "        equator_label = Text(\"Equator\")\n",
        "        equator_label.flip().rotate(EARTH_TILT_ANGLE, IN)\n",
        "        equator_label.move_to(self.radius * IN + 0.15 * earth_axis)\n",
        "        equator_label.set_backstroke()\n",
        "\n",
        "        cancer_label = Text(\"Tropic of Cancer\")\n",
        "        cancer_label.flip().rotate(EARTH_TILT_ANGLE, IN)\n",
        "        cancer_label.move_to(op.add(\n",
        "            math.cos(EARTH_TILT_ANGLE) * self.radius * IN,\n",
        "            (math.sin(EARTH_TILT_ANGLE) * self.radius + 0.15) * earth_axis,\n",
        "        ))\n",
        "\n",
        "        tropic_of_cancer = get_lat_line(EARTH_TILT_ANGLE)\n",
        "\n",
        "        d_line = h_line.copy().rotate(angle, about_point=ORIGIN)\n",
        "        d_line.set_stroke(PINK)\n",
        "\n",
        "        alex_point = earth.get_center() + self.radius * normalize(d_line.get_vector())\n",
        "        alex_name = Text(\"Alexandria\", font_size=36).flip()\n",
        "        alex_name.next_to(alex_point, UR, buff=SMALL_BUFF).shift(0.45 * UP)\n",
        "        alex_arrow = Arrow(alex_name.get_bottom() + 0.35 * LEFT, alex_point, buff=SMALL_BUFF, thickness=2)\n",
        "\n",
        "        syene_point = earth.get_right()\n",
        "        syene_name = Text(\"Syene\", font_size=36).flip()\n",
        "        syene_name.next_to(syene_point, DR, buff=MED_SMALL_BUFF).shift(0.25 * DOWN)\n",
        "        syene_arrow = Arrow(syene_name.get_top(), syene_point, buff=SMALL_BUFF, thickness=2)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(earth_group, TAU, axis=earth_axis),\n",
        "            ShowCreation(tropic_of_cancer),\n",
        "            axis_line.animate.set_stroke(opacity=0.5).set_anim_args(time_span=(0, 1)),\n",
        "            run_time=12,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-172, 0, 0, (3.05, -0.01, -0.01), 6.69),\n",
        "            Write(cancer_label, time_span=(1, 3)),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(syene_name),\n",
        "            GrowArrow(syene_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-225, -8, 0, (3.05, -0.01, -0.01), 6.69),\n",
        "            FadeOut(cancer_label, time_span=(0, 2)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show line through Alexandria\n",
        "        self.play(\n",
        "            ShowCreation(d_line),\n",
        "            frame.animate.reorient(-189, 6, 0, (3.05, -0.01, -0.01), 6.69),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(alex_name),\n",
        "            GrowArrow(alex_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the angle\n",
        "        earth_point = circle.pfp(angle / TAU)\n",
        "        upper_ray = Line(earth_point, earth_point + 20 * RIGHT)\n",
        "        upper_ray.match_style(h_line)\n",
        "\n",
        "        arc = Arc(0, 2 * angle, radius=3, arc_center=earth_point)\n",
        "        arc.scale(1 / 2, about_edge=DOWN)\n",
        "        arc_labels = VGroup()\n",
        "        for tex in [R\"\\theta\", R\"7^{\\circ}\"]:\n",
        "            arc_label = Tex(tex, font_size=36)\n",
        "            arc_label.flip()\n",
        "            arc_label.next_to(arc, RIGHT, SMALL_BUFF)\n",
        "            arc_labels.add(arc_label)\n",
        "\n",
        "        arc_label = arc_labels[0]\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(upper_ray),\n",
        "            ShowCreation(arc),\n",
        "            FadeIn(arc_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(arc_label, arc_labels[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            arc.animate.shift(earth_point - arc.get_end()).shift(0.01 * LEFT).set_stroke(RED),\n",
        "            arc_label.animate.next_to(earth_point, DR, buff=0.05),\n",
        "            upper_ray.animate.set_stroke(width=1, opacity=0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(alex_name, alex_arrow, syene_name, syene_arrow)))\n",
        "\n",
        "        # Show full circumference\n",
        "        self.play(\n",
        "            frame.animate.reorient(-173, 0, 0, (2.91, 0.1, -0.01), 7.20),\n",
        "            ShowCreation(circle),\n",
        "            run_time=4,\n",
        "        )\n",
        "\n",
        "        # Ambient panning\n",
        "        circle.apply_depth_test()\n",
        "        self.play(\n",
        "            FadeOut(arc_label, time_span=(3, 5)),\n",
        "            frame.animate.reorient(110 - 360, -10, 0, (-0.41, -0.16, 3.6), 7.86),\n",
        "            run_time=24,\n",
        "        )\n",
        "\n",
        "    def old_material(self):\n",
        "        # Tilt earth\n",
        "        v_line = axis_line.copy()\n",
        "        d_line = axis_line.copy()\n",
        "\n",
        "        arc = Arc(90 * DEG, -EARTH_TILT_ANGLE, radius=1.75)\n",
        "        arc.set_stroke(WHITE, 2)\n",
        "        arc_label = Tex(R\"23.5^\\circ\", font_size=36)\n",
        "        arc_label.next_to(arc.pfp(0.65), UP, buff=0.15)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(earth_group, -EARTH_TILT_ANGLE, axis=OUT),\n",
        "            Rotate(axis_line, -EARTH_TILT_ANGLE, axis=OUT),\n",
        "            Rotate(d_line, -EARTH_TILT_ANGLE, axis=OUT),\n",
        "            FadeIn(v_line),\n",
        "            VFadeIn(d_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(arc_label),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(rays, axis_line, earth_group)\n",
        "        self.play(\n",
        "            FadeOut(VGroup(v_line, d_line, arc, arc_label), time_span=(0, 1)),\n",
        "            frame.animate.reorient(-138, -25, 0, (4.72, -0.66, -0.11), 10.77),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "\n",
        "class AlBiruniEarthMeasurement(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth and mountain\n",
        "        radius = 2\n",
        "        height = 0.3\n",
        "\n",
        "        earth = Circle(radius=radius)\n",
        "        earth.set_fill(BLUE_B, 0.5)\n",
        "        earth.set_stroke(WHITE, 3)\n",
        "        earth.rotate(90 * DEG)\n",
        "\n",
        "        earth_pattern = SVGMobject(\"earth\")\n",
        "        earth_pattern.rotate(90 * DEG)\n",
        "        earth_pattern.replace(earth)\n",
        "        earth_pattern.set_fill(Color(hsl=(0.23, 0.5, 0.2)), 1)\n",
        "\n",
        "        mountain_tip = earth.get_top() + height * UP\n",
        "        mountain = Polyline(\n",
        "            earth.pfp(0.02), mountain_tip, earth.pfp(0.98)\n",
        "        )\n",
        "        mountain.set_stroke(GREY_B, 4)\n",
        "\n",
        "        self.add(earth)\n",
        "        self.add(earth_pattern)\n",
        "        self.add(mountain)\n",
        "\n",
        "        # Show line of sight\n",
        "        theta = math.acos(radius / (radius + height))\n",
        "        line_length = 3\n",
        "\n",
        "        line_of_sight = DashedLine(ORIGIN, line_length * RIGHT, dash_length=DEFAULT_DASH_LENGTH / 2)\n",
        "        line_of_sight.set_stroke(WHITE, 2)\n",
        "        line_of_sight.rotate(-theta, about_point=ORIGIN)\n",
        "        line_of_sight.shift(mountain_tip)\n",
        "\n",
        "        horizontal = Line(mountain_tip, mountain_tip + line_length * RIGHT)\n",
        "        horizontal.set_stroke(WHITE, 2)\n",
        "        horizontal_copy = horizontal.copy()\n",
        "\n",
        "        arc = Arc(0, -theta, arc_center=mountain_tip, radius=0.5)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=24)\n",
        "        theta_label.next_to(arc, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(line_of_sight))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(horizontal))\n",
        "        self.play(\n",
        "            Rotate(horizontal_copy, -theta, about_point=mountain_tip),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta_label)\n",
        "        )\n",
        "        self.play(FadeOut(horizontal_copy))\n",
        "        self.wait()\n",
        "\n",
        "        # Show radius of the earth\n",
        "        radius_line = Line(earth.get_center(), earth.get_top())\n",
        "        radius_line.rotate(-theta, about_point=earth.get_center())\n",
        "        radius_line.set_stroke(WHITE, 4)\n",
        "        R_label = Tex(R\"R\", font_size=36)\n",
        "        R_label.next_to(radius_line.get_center(), DR, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            earth_pattern.animate.set_fill(opacity=0.5),\n",
        "            earth.animate.set_fill(opacity=0.2),\n",
        "            ShowCreation(radius_line),\n",
        "            Write(R_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show triangle\n",
        "        elbow = Elbow(angle=180 * DEG - theta)\n",
        "        elbow.shift(radius_line.get_end())\n",
        "        hyp = Line(earth.get_center(), mountain_tip)\n",
        "        hyp.set_stroke(RED, 3)\n",
        "        hyp_brace = Brace(hyp, LEFT, buff=0.1)\n",
        "        hyp_label = hyp_brace.get_tex(\"R + h\", font_size=36)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(elbow),\n",
        "            ShowCreation(hyp),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(hyp_brace),\n",
        "            Write(hyp_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show angle\n",
        "        low_arc = Arc(90 * DEG, -theta, arc_center=earth.get_center(), radius=0.5)\n",
        "        low_theta_label = theta_label.copy()\n",
        "        low_theta_label.next_to(low_arc.pfp(0.6), UP, buff=0.075)\n",
        "\n",
        "        self.play(FlashAround(theta_label))\n",
        "        self.play(\n",
        "            TransformFromCopy(arc, low_arc),\n",
        "            TransformFromCopy(theta_label, low_theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the equation\n",
        "        frame = self.frame\n",
        "        equation = Tex(R\"R = (R + h)\\cos(\\theta)\", font_size=36)\n",
        "        equation.to_edge(UP, buff=0)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.shift(UP),\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(R_label, equation[\"R\"][0]),\n",
        "                Write(equation[\"= (\"][0]),\n",
        "                TransformFromCopy(hyp_label, equation[\"R + h\"][0]),\n",
        "                Write(equation[R\")\\cos(\"][0]),\n",
        "                TransformFromCopy(low_theta_label, equation[R\"\\theta\"][0]),\n",
        "                Write(equation[\")\"][-1]),\n",
        "                lag_ratio=0.25\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Simplify\n",
        "        eq2 = Tex(R\"R - R \\cos(\\theta) = h \\cos(\\theta)\", font_size=36)\n",
        "        eq3 = Tex(R\"R = {h\\cos(\\theta) \\over 1 - \\cos(\\theta)}\", font_size=36)\n",
        "        eq2.move_to(equation).shift(0.5 * UP)\n",
        "        eq3.next_to(eq2, DOWN)\n",
        "        rect = SurroundingRectangle(eq3)\n",
        "        rect.set_fill(BLACK, 0.8)\n",
        "\n",
        "        self.play(equation.animate.next_to(eq2, UP), frame.animate.shift(0.5 * UP))\n",
        "        self.play(TransformMatchingTex(equation.copy(), eq2, path_arc=45 * DEG, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(eq2.copy(), eq3, path_arc=45 * DEG, lag_ratio=0.01))\n",
        "        self.add(rect, eq3)\n",
        "        self.play(DrawBorderThenFill(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LuarEclipse(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup earth and moon\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(50 * LEFT)\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(25 * DEG)\n",
        "\n",
        "        conversion_factor = 1.0 / EARTH_RADIUS\n",
        "\n",
        "        earth = get_earth(radius=EARTH_RADIUS * conversion_factor)\n",
        "        earth.rotate(-EARTH_TILT_ANGLE, UP)\n",
        "        earth_axis = rotate_vector(OUT, -EARTH_TILT_ANGLE, UP)\n",
        "\n",
        "        earth.add_updater(lambda m, dt: m.rotate(dt * 10 * DEG, axis=earth_axis))\n",
        "\n",
        "        self.add(earth)\n",
        "\n",
        "        # Clearly show the size of the earth\n",
        "        brace = Brace(earth, LEFT)\n",
        "        label = brace.get_tex(Rf\"2 R_E\")\n",
        "        re_label = Integer(2 * EARTH_RADIUS, unit=\" km\", font_size=36)\n",
        "        re_label.next_to(label, DOWN, aligned_edge=RIGHT)\n",
        "        dashed_lines = VGroup(\n",
        "            DashedLine(brace.get_corner(UR), earth.get_top() + RIGHT, dash_length=0.03),\n",
        "            DashedLine(brace.get_corner(DR), earth.get_bottom() + RIGHT, dash_length=0.03),\n",
        "        )\n",
        "        dashed_lines.set_stroke(GREY, 2)\n",
        "\n",
        "        frame.reorient(-2, 59, 0, (-0.08, 0.07, -0.08), 2.76)\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            LaggedStart(\n",
        "                Animation(Mobject(), remover=True),\n",
        "                Animation(Mobject(), remover=True),\n",
        "                Animation(Mobject(), remover=True),\n",
        "                FadeIn(brace, scale=100),\n",
        "                FadeIn(label),\n",
        "                FadeIn(dashed_lines),\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(re_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom out from earth to moon\n",
        "        orbit = Circle(radius=MOON_ORBIT_RADIUS * conversion_factor)\n",
        "        orbit.set_stroke(GREY_C, width=(0, 3))\n",
        "        # orbit.rotate(-45 * DEG)\n",
        "        orbit.rotate(-135 * DEG)\n",
        "        orbit.add_updater(lambda m, dt: m.rotate(3 * dt * DEG))\n",
        "\n",
        "        moon = get_moon(radius=MOON_RADIUS * conversion_factor)\n",
        "        moon.to_edge(RIGHT)\n",
        "        moon.add_updater(lambda m: m.move_to(orbit.get_start()))\n",
        "\n",
        "        radial_line = Line()\n",
        "        radial_line.set_stroke(WHITE, 0.5)\n",
        "        radial_line.add_updater(lambda m: m.put_start_and_end_on(earth.get_center(), moon.get_center()))\n",
        "\n",
        "        # dist_question = Text(\"Distance to the moon?\", font_size=400)\n",
        "        # dist_question.add_updater(lambda m: m.next_to(radial_line.get_center(), UR, buff=1))\n",
        "        dist_question = TexText(R\"Distance to the moon \\\\ $\\approx$ 385,000km $\\pm$ 21,000km\", font_size=600)\n",
        "        dist_question.add_updater(lambda m: m.next_to(radial_line.get_center(), DR, buff=1))\n",
        "\n",
        "        trg_height = 1.2 * orbit.get_height()\n",
        "        self.add(orbit, moon)\n",
        "        self.play(\n",
        "            frame.animate.set_height(trg_height),\n",
        "            FadeIn(radial_line, time_span=(2, 3)),\n",
        "            FadeIn(dist_question, time_span=(2, 3)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait(20)\n",
        "\n",
        "        # Show earth's shadow\n",
        "        sunlight = GlowDot(radius=3 * FRAME_WIDTH, glow_factor=1, opacity=0.5)\n",
        "        sunlight.move_to(1.5 * FRAME_WIDTH * LEFT)\n",
        "        sunlight.fix_in_frame()\n",
        "\n",
        "        shadow = Rectangle(\n",
        "            width=3 * MOON_ORBIT_RADIUS * conversion_factor,\n",
        "            height=2 * EARTH_RADIUS * conversion_factor,\n",
        "        )\n",
        "        shadow.set_stroke(width=0)\n",
        "        shadow.set_fill(BLACK, 1)\n",
        "        shadow.move_to(ORIGIN, LEFT)\n",
        "\n",
        "        sunlight.set_z_index(-1)\n",
        "        shadow.set_z_index(-1)\n",
        "\n",
        "        self.add(sunlight, shadow)\n",
        "        self.play(GrowFromCenter(sunlight, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in to the moon\n",
        "        orbit.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            Rotate(orbit, -angle_of_vector(orbit.get_start()) - 1.25 * DEG),\n",
        "            frame.animate.set_height(6 * EARTH_RADIUS * conversion_factor).move_to(MOON_ORBIT_RADIUS * conversion_factor * RIGHT),\n",
        "            FadeOut(radial_line, time_span=(0, 2)),\n",
        "            FadeOut(dist_question, time_span=(0, 2)),\n",
        "            sunlight.animate.set_opacity(0.35),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Show the moon passing through\n",
        "        self.play(\n",
        "            Rotate(orbit, 2.5 * DEG, about_point=ORIGIN),\n",
        "            Rotate(moon, 2.5 * DEG, about_point=ORIGIN),\n",
        "            run_time=12,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the width\n",
        "        brace_copy = brace.copy().flip()\n",
        "        brace_copy.next_to(orbit, RIGHT, LARGE_BUFF)\n",
        "        label_copy = VGroup(label, re_label).copy()\n",
        "        label_copy.arrange(DOWN, aligned_edge=LEFT)\n",
        "        label_copy.next_to(brace_copy, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace_copy),\n",
        "            FadeIn(label_copy, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the time\n",
        "        time_label = Tex(R\"~4 \\text{ hours}\", font_size=60)\n",
        "        time_label.next_to(brace_copy, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(label_copy, lag_ratio=0.1),\n",
        "            FadeIn(time_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the full lunar month\n",
        "        orbit_rate = ValueTracker(0)\n",
        "        orbit.clear_updaters()\n",
        "        orbit.add_updater(lambda m, dt: m.rotate(orbit_rate.get_value() * dt * DEG))\n",
        "\n",
        "        large_text_height = 2 * earth.get_height()\n",
        "\n",
        "        month_arrow = Arc(\n",
        "            5 * DEG,\n",
        "            350 * DEG,\n",
        "            arc_center=2.0 * earth.get_right(),\n",
        "            radius=0.9 * MOON_ORBIT_RADIUS * conversion_factor\n",
        "        )\n",
        "        month_arrow.set_stroke(TEAL, 3)\n",
        "        month_arrow.add_tip()\n",
        "        month_arrow.tip.set_height(4 * EARTH_RADIUS * conversion_factor, about_point=month_arrow.get_end())\n",
        "\n",
        "        month_label = Text(\"28 days\")\n",
        "        month_label.set_height(2 * large_text_height)\n",
        "        month_label.match_color(month_arrow)\n",
        "        month_label.next_to(month_arrow.pfp(3 / 8), DR, buff=earth.get_height())\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.move_to(MOON_ORBIT_RADIUS * conversion_factor * LEFT).set_height(1.35 * orbit.get_height()).set_anim_args(run_time=4),\n",
        "            orbit_rate.animate.set_value(15).set_anim_args(run_time=4),\n",
        "            time_label.animate.set_height(large_text_height, about_point=brace_copy.get_right()).set_anim_args(run_time=4),\n",
        "            ShowCreation(month_arrow, time_span=(1, 5)),\n",
        "            Write(month_label, time_span=(2, 3)),\n",
        "        )\n",
        "        self.wait(32)\n",
        "\n",
        "    def show_circles(self):\n",
        "        radii = [1e4, 1e5]\n",
        "        circles = VGroup()\n",
        "        for n, radius in enumerate(radii):\n",
        "            circle = Circle(radius=radius * conversion_factor)\n",
        "            circle.set_stroke(WHITE, 2)\n",
        "            radial_line = Line(ORIGIN, circle.get_right())\n",
        "            radial_line.set_stroke(GREY, 1)\n",
        "            label = Integer(radius, unit=\" km\")\n",
        "            label.set_width(0.25 * radial_line.get_width())\n",
        "            label.move_to(radial_line.pfp(0.6), DOWN).shift(0.001 * radius * UP)\n",
        "            group = VGroup(radial_line, label, circle)\n",
        "            circles.add(group)\n",
        "\n",
        "    def get_red_moon(self):\n",
        "        red_moon = TexturedSurface(\n",
        "            Sphere(radius=MOON_RADIUS * conversion_factor),\n",
        "            \"RedMoonTexture\", \"DarkMoonTexture\",\n",
        "        ).set_opacity(0.8)\n",
        "        return red_moon\n",
        "\n",
        "\n",
        "class PenumbraAndUmbra(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth and sun\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(10 * DEG)\n",
        "        light_source = self.camera.light_source\n",
        "\n",
        "        sun = get_sun(radius=2, big_glow_ratio=10, big_glow_factor=2)\n",
        "        sun.move_to(7 * LEFT)\n",
        "\n",
        "        earth = get_earth(radius=0.7)\n",
        "        earth.rotate(90 * DEG, LEFT).rotate(EARTH_TILT_ANGLE, OUT)\n",
        "        earth.move_to(2 * RIGHT)\n",
        "\n",
        "        light_source.move_to(sun)\n",
        "        self.add(sun, earth)\n",
        "\n",
        "        # Add shadows\n",
        "        umbra, penumbra, umbral_lines, penumbral_lines = shadow_group = self.get_umbral_lines(sun[0], earth)\n",
        "\n",
        "        umbrum_word = Text(\"Umbra\", font_size=24)\n",
        "        umbrum_word.move_to(umbra)\n",
        "        penumbrum_word = Text(\"Penumbra\", font_size=24)\n",
        "        penumbrum_word.move_to(umbrum_word)\n",
        "        penumbrum_word.shift(0.55 * earth.get_height() * UP)\n",
        "\n",
        "        self.add(penumbra, penumbral_lines, earth, penumbrum_word)\n",
        "        self.play(\n",
        "            FadeIn(penumbra),\n",
        "            FadeIn(penumbral_lines),\n",
        "            FadeIn(penumbrum_word),\n",
        "        )\n",
        "        self.add(*shadow_group, earth, umbrum_word, penumbrum_word)\n",
        "        self.play(\n",
        "            FadeIn(umbral_lines, lag_ratio=0),\n",
        "            FadeIn(umbra, time_span=(0.5, 1)),\n",
        "            FadeIn(umbrum_word, time_span=(0.5, 1)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pull away\n",
        "        self.add(shadow_group, earth, umbrum_word, penumbrum_word)\n",
        "\n",
        "        shift_vect = 100 * LEFT\n",
        "        self.play(\n",
        "            sun[:2].animate.shift(shift_vect),\n",
        "            sun[2].animate.shift(5 * LEFT).scale(2),\n",
        "            frame.animate.reorient(0, 0, 0, (4.21, 0.56, 0.0), 13.04),\n",
        "            umbrum_word.animate.shift(2 * RIGHT),\n",
        "            penumbrum_word.animate.scale(0.5, about_edge=DOWN).shift(2 * RIGHT),\n",
        "            UpdateFromFunc(shadow_group, lambda m: m.become(self.get_umbral_lines(sun[0], earth))),\n",
        "            run_time=8,\n",
        "        )\n",
        "\n",
        "    def get_umbral_lines(self, circle1, circle2):\n",
        "        r1 = circle1.get_width() / 2\n",
        "        r2 = circle2.get_width() / 2\n",
        "        c1 = circle1.get_center()\n",
        "        c2 = circle2.get_center()\n",
        "\n",
        "        vect = c2 - c1\n",
        "        dist = get_norm(vect)\n",
        "\n",
        "        cs1 = c1 + vect / (1.0 - r2 / r1)\n",
        "        cs2 = c1 + vect / (1.0 + r2 / r1)\n",
        "\n",
        "        angle = math.asin(r1 / get_norm(cs1 - c1))\n",
        "\n",
        "        v1 = rotate_vector(UP, -angle)\n",
        "        v2 = rotate_vector(DOWN, angle)\n",
        "        v3 = rotate_vector(UP, angle)\n",
        "        v4 = rotate_vector(DOWN, -angle)\n",
        "\n",
        "        umbral_lines = VGroup(\n",
        "            Line(c1 + r1 * v1, cs1),\n",
        "            Line(c1 + r1 * v2, cs1),\n",
        "        )\n",
        "        umbral_lines.set_stroke(WHITE, 0.5)\n",
        "        umbra = Polygon(cs1, c2 + r2 * v1, c2, c2 + r2 * v2)\n",
        "        umbra.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "\n",
        "        penumbral_lines = VGroup(\n",
        "            Line(cs2, c2 + r2 * v3).scale(10),\n",
        "            Line(cs2, c2 + r2 * v4).scale(10),\n",
        "        )\n",
        "        penumbral_lines.set_stroke(WHITE, 0.5)\n",
        "        penumbra = Polygon(\n",
        "            c2 + r2 * v3, penumbral_lines[0].get_end(),\n",
        "            penumbral_lines[1].get_end(), c2 + r2 * v4,\n",
        "        )\n",
        "        penumbra.set_fill(BLACK, 0.5)\n",
        "        penumbra.set_stroke(width=0)\n",
        "\n",
        "        return VGroup(umbra, penumbra, umbral_lines, penumbral_lines)\n",
        "\n",
        "\n",
        "class LineOfSight(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(20 * RIGHT)\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(25 * DEG)\n",
        "\n",
        "        conversion_factor = 1 / EARTH_RADIUS\n",
        "\n",
        "        earth = get_earth(radius=EARTH_RADIUS * conversion_factor)\n",
        "        earth.rotate(90 * DEG)\n",
        "        earth.rotate(-EARTH_TILT_ANGLE, UP)\n",
        "        earth_axis = rotate_vector(OUT, -EARTH_TILT_ANGLE, UP)\n",
        "\n",
        "        frame.set_height(2.25)\n",
        "        self.add(earth)\n",
        "\n",
        "        # Add moon\n",
        "        orbit = Circle(radius=MOON_ORBIT_RADIUS * conversion_factor)\n",
        "        orbit.set_stroke(GREY_C, width=(0, 3))\n",
        "        orbit.rotate(PI)\n",
        "\n",
        "        moon = get_moon(radius=MOON_RADIUS * conversion_factor)\n",
        "        moon.rotate(PI)\n",
        "        moon.move_to(orbit.get_start())\n",
        "\n",
        "        self.add(orbit, moon)\n",
        "\n",
        "        # Show a line of sight\n",
        "        line = Line(earth.get_center() + 0.75 * UP, moon.get_center())\n",
        "        line.set_stroke(BLUE, 1)\n",
        "\n",
        "        words = Text(\"Line of sight\")\n",
        "        words.set_width(line.get_width() * 0.5)\n",
        "        words.set_color(BLUE)\n",
        "        words.next_to(line, UP, buff=-0.5 * earth.get_height())\n",
        "\n",
        "        angle = (MOON_RADIUS / (TAU * MOON_ORBIT_RADIUS)) * TAU\n",
        "        line.rotate(angle, about_point=line.get_start())\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(MOON_ORBIT_RADIUS * conversion_factor * 2.25),\n",
        "            ShowCreation(line),\n",
        "            FadeIn(words, lag_ratio=0.1, time_span=(2, 4)),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Zoom into the moon\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-59.4, 0.01, 0.0), 2.83),\n",
        "            line.animate.set_stroke(width=2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(line, -2 * angle, about_point=line.get_start()),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_height(MOON_ORBIT_RADIUS * conversion_factor * 2.25).center(),\n",
        "            line.animate.set_stroke(width=1),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Rotate over 24 hours\n",
        "        timer = DecimalNumber(0.0, num_decimal_places=1, edge_to_fix=RIGHT)\n",
        "        units = Text(\"hours\")\n",
        "        timer[-1].shift(SMALL_BUFF * RIGHT)\n",
        "        timer.fix_in_frame()\n",
        "        timer.move_to(UR)\n",
        "        timer.add_updater(lambda m: m.set_stroke(width=0).set_fill(border_width=0))\n",
        "        units.next_to(timer, RIGHT, buff=0.2, aligned_edge=DOWN)\n",
        "        units.fix_in_frame()\n",
        "        units.set_stroke(width=0).set_fill(border_width=0)\n",
        "        self.play(\n",
        "            VFadeIn(timer, time_span=(0, 1)),\n",
        "            VFadeIn(units, time_span=(0, 1)),\n",
        "            ChangeDecimalToValue(timer, 24),\n",
        "            Rotate(earth, -TAU, about_point=ORIGIN),\n",
        "            Rotate(line, -TAU, about_point=ORIGIN),\n",
        "            Rotate(words, -TAU, about_point=ORIGIN),\n",
        "            Rotate(moon, TAU / 28, about_point=ORIGIN),\n",
        "            Rotate(orbit, TAU / 28, about_point=ORIGIN),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*map(FadeOut, [timer, units, words, line]))\n",
        "\n",
        "        # Ambient rotation\n",
        "        self.play(\n",
        "            Rotate(orbit, 90 * DEG, about_point=ORIGIN, rate_func=linear),\n",
        "            Rotate(moon, 90 * DEG, about_point=ORIGIN, rate_func=linear),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Show elliptical orbit\n",
        "        moon.f_always.move_to(orbit.get_end)\n",
        "\n",
        "        orbit_ghost = orbit.copy().set_stroke(opacity=0.5)\n",
        "\n",
        "        self.add(orbit_ghost)\n",
        "        self.play(\n",
        "            orbit.animate.stretch(0.9, 1).stretch(1.1, 0).shift(3 * earth.get_width() * LEFT),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Zoom in then out\n",
        "        self.play(\n",
        "            frame.animate.reorient(80, 82, 0, moon.get_center(), 0.80),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, MOON_ORBIT_RADIUS * conversion_factor * 2.25),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show many moons\n",
        "        ratio = int(2 * PI * MOON_ORBIT_RADIUS / MOON_RADIUS / 2)\n",
        "        moons = Group()\n",
        "        for a in np.arange(0, 1, 1 / ratio):\n",
        "            lil_moon = get_moon(resolution=(21, 11))\n",
        "            lil_moon.match_height(moon)\n",
        "            lil_moon.move_to(orbit.pfp(a))\n",
        "            moons.add(lil_moon)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(orbit, run_time=3),\n",
        "            FadeIn(moons, lag_ratio=0.05, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shrink down its orbit\n",
        "        n_moons = 32\n",
        "        small_orbit = orbit.copy()\n",
        "        small_orbit.set_height(4.5 * n_moons * MOON_RADIUS * conversion_factor / TAU)\n",
        "        small_orbit.set_stroke(WHITE, 1)\n",
        "\n",
        "        inner_moons = Group()\n",
        "        for a in np.arange(0, 1, 1.0 / n_moons):\n",
        "            lil_moon = get_moon(resolution=(51, 25))\n",
        "            lil_moon.match_height(moon)\n",
        "            lil_moon.move_to(small_orbit.pfp(a))\n",
        "            lil_moon.save_state()\n",
        "            lil_moon.move_to(orbit.pfp(a))\n",
        "            inner_moons.add(lil_moon)\n",
        "\n",
        "        self.remove(moon)\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, inner_moons, lag_ratio=0),\n",
        "            FadeOut(moons),\n",
        "            frame.animate.set_height(1.5 * small_orbit.get_height()).center().set_anim_args(time_span=(1, 5)),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "\n",
        "class DistanceToSun(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show sun and the earth\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(15 * DEG)\n",
        "        light_source = self.camera.light_source\n",
        "\n",
        "        earth = get_earth(radius=0.1)\n",
        "        earth.rotate(90 * DEG)\n",
        "        earth.rotate(-EARTH_TILT_ANGLE, UP)\n",
        "        earth.to_edge(LEFT, buff=1.0)\n",
        "\n",
        "        sun = get_sun(radius=1.0)\n",
        "        sun.move_to((0.5 * FRAME_WIDTH - 2) * RIGHT)\n",
        "        sun.rotate(90 * DEG, LEFT)\n",
        "\n",
        "        light_source.f_always.move_to(sun[0].get_center)\n",
        "        self.add(light_source)\n",
        "\n",
        "        self.add(earth, sun)\n",
        "        frame.reorient(0, 0, 0, earth.get_center(), 2 * earth.get_height())\n",
        "        self.play(frame.animate.to_default_state(), run_time=5)\n",
        "\n",
        "        # Show distance and radius\n",
        "        sun_brace = Brace(sun[0], RIGHT)\n",
        "        sun_brace.stretch(0.5, 1, about_edge=UP)\n",
        "        sun_brace.move_to(sun.get_center(), DL).shift(SMALL_BUFF * RIGHT)\n",
        "        sun_radius_label = sun_brace.get_tex(\"R_S\", buff=0.05)\n",
        "        VGroup(sun_brace, sun_radius_label).set_color(BLACK)\n",
        "\n",
        "        dist_line = Line(earth.get_center(), sun.get_center())\n",
        "        dist_line.insert_n_curves(10)\n",
        "        dist_line.set_stroke(WHITE, width=(0, *5 * [2], 0))\n",
        "        dist_label = Tex(R\"D_S\")\n",
        "        dist_label.next_to(dist_line, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(sun_brace),\n",
        "            Write(sun_radius_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dist_line),\n",
        "            Write(dist_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show ratio\n",
        "        ratio = Tex(R\"{R_S \\over D_S}\")\n",
        "        ratio.to_corner(UL)\n",
        "        ratio.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(sun_radius_label, ratio[\"R_S\"][0]),\n",
        "            TransformFromCopy(dist_label, ratio[\"D_S\"][0]),\n",
        "            Write(ratio[R\"\\over\"][0])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom into the moon\n",
        "        orbit_radius = 2\n",
        "        orbit = Circle(radius=orbit_radius, n_components=100)\n",
        "        orbit.move_to(earth)\n",
        "        orbit.set_stroke(GREY, (0, 2))\n",
        "\n",
        "        scaled_moon_radius = 0.5 * (sun[0].get_height() / get_dist(earth.get_center(), sun.get_center())) * orbit_radius\n",
        "        small_moon_radius = (1.0 / 4) * earth.get_height()\n",
        "        moon = get_moon(radius=small_moon_radius)\n",
        "        moon.move_to(orbit.get_end())\n",
        "\n",
        "        self.add(orbit, moon)\n",
        "        self.play(\n",
        "            FadeIn(orbit),\n",
        "            FadeIn(moon),\n",
        "            dist_line.animate.set_stroke(opacity=0),\n",
        "            frame.animate.reorient(0, 0, 0, (-4.94, 0.05, 0.0), 1.83),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the moon sizes and ratio\n",
        "        moon_brace = sun_brace.copy().set_color(WHITE)\n",
        "        moon_brace.set_height(moon.get_height())\n",
        "        moon_brace.next_to(moon, RIGHT, buff=0, aligned_edge=UP)\n",
        "        moon_brace.stretch(0.5, 1, about_edge=UP)\n",
        "        moon_radius_label = moon_brace.get_tex(\"R_M\", font_size=8, buff=0.01)\n",
        "        moon_radius_label.align_to(moon_brace, DOWN)\n",
        "\n",
        "        moon_dist_line = Line(earth.get_center(), moon.get_center())\n",
        "        moon_dist_line.insert_n_curves(20)\n",
        "        moon_dist_line.set_stroke(TEAL_A, (0, 2, 2, 2, 0))\n",
        "        moon_dist_label = Tex(\"D_M\", font_size=8)\n",
        "        moon_dist_label.next_to(moon_dist_line, UP, buff=0.01)\n",
        "\n",
        "        moon_ratio = Tex(R\"{R_M \\over D_M}\", font_size=10)\n",
        "        moon_ratio.set_color(GREY_B)\n",
        "        moon_ratio.next_to(frame.get_corner(UL), DR, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(moon_ratio))\n",
        "        self.play(\n",
        "            GrowFromCenter(moon_brace),\n",
        "            TransformFromCopy(moon_ratio[\"R_M\"][0], moon_radius_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(moon_dist_line),\n",
        "            TransformFromCopy(moon_ratio[\"D_M\"][0], moon_dist_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Compare ratios\n",
        "        equals = Tex(\"=\")\n",
        "        equals.next_to(ratio, RIGHT, 2 * SMALL_BUFF)\n",
        "\n",
        "        sun_point = Point(sun.get_center())\n",
        "        size_ratio = moon.get_height() / get_dist(moon.get_center(), earth.get_center())\n",
        "        sun[0].add_updater(lambda m: m.move_to(sun_point).set_height(size_ratio * get_dist(sun_point.get_center(), earth.get_center())))\n",
        "        sun[1].add_updater(lambda m: m.move_to(sun[0]).set_height(1.2 * sun[0].get_height()))\n",
        "        sun[2].add_updater(lambda m: m.move_to(sun[0]))\n",
        "\n",
        "        VGroup(sun_brace, sun_radius_label).set_color(WHITE)\n",
        "        sun_brace.f_always.set_height(lambda: 0.5 * sun[0].get_height(), stretch=lambda: True)\n",
        "        sun_brace.always.next_to(sun[0], RIGHT, buff=0, aligned_edge=UP)\n",
        "        sun_radius_label.always.next_to(sun_brace, buff=0.05)\n",
        "\n",
        "        self.remove(sun_brace, sun_radius_label, dist_line, dist_label, ratio)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(-87.85, 89.126, 0, [-5.6279674 ,-0.0808167, 0.00590339], 0.03),\n",
        "            sun[2].animate.set_opacity(0.15),\n",
        "            *map(FadeOut, [moon_ratio, moon_dist_line, moon_dist_label, moon_brace, moon_radius_label, orbit]),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            FadeIn(orbit),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        VGroup(sun_radius_label, dist_label).set_color(YELLOW)\n",
        "        self.play(\n",
        "            GrowFromCenter(sun_brace),\n",
        "            GrowFromCenter(sun_radius_label),\n",
        "        )\n",
        "        dist_line.set_stroke(opacity=1),\n",
        "        self.play(\n",
        "            FadeIn(dist_line),\n",
        "            FadeIn(dist_label, shift=0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Wiggle the orbit\n",
        "        self.play(\n",
        "            orbit.animate.stretch(0.8, 0).stretch(1.2, 1),\n",
        "            UpdateFromFunc(Group(moon), lambda m: m.move_to(orbit.get_end())),\n",
        "            rate_func=wiggle,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fade Out labels\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut,\n",
        "                VGroup(dist_line, dist_label, sun_brace, sun_radius_label),\n",
        "                scale=0.5,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Shift sun scale around\n",
        "        sun.clear_updaters()\n",
        "        to_moon = moon.get_center() - earth.get_center()\n",
        "        true_sun_center = earth.get_center() + to_moon * (EARTH_ORBIT_RADIUS / MOON_ORBIT_RADIUS)\n",
        "        true_sun_height = earth.get_height() * (SUN_RADIUS / EARTH_RADIUS)\n",
        "        sun.save_state()\n",
        "        sun.target = sun.generate_target()\n",
        "        sun.target.scale(true_sun_height / sun[0].get_height())\n",
        "        sun.target.move_to(true_sun_center)\n",
        "        sun.target[1].set_radius(1.2 * true_sun_height)\n",
        "        sun.target[2].set_radius(10 * true_sun_height)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(sun),\n",
        "            frame.animate.reorient(0, 0, 0, (365.67, 14.24, 0.0), 485.35),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        sun.target[0].set_height(2 * moon.get_height())\n",
        "        sun.target[1].set_height(1.2 * 2 * moon.get_height())\n",
        "        sun.target[2].set_height(50 * 2 * moon.get_height())\n",
        "        sun.target[2].set_opacity(0.35)\n",
        "        sun.target.move_to(earth.get_center() + 2 * to_moon)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(sun, time_span=(0, 2)),\n",
        "            frame.animate.reorient(0, 0, 0, (-3.89, 0.03, 0.0), 4.73),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Show being twice as big\n",
        "        dist_brace = Brace(Line(earth.get_top(), moon.get_top()), UP, buff=0.1)\n",
        "        dist_brace2 = dist_brace.copy().shift(dist_brace.get_width() * RIGHT)\n",
        "\n",
        "        side_brace = Brace(moon, RIGHT, buff=0)\n",
        "        side_brace.stretch(0.25, 0, about_edge=LEFT)\n",
        "        side_brace_pair = side_brace.get_grid(2, 1, buff=0)\n",
        "        side_brace_pair.next_to(sun[0], RIGHT, buff=0)\n",
        "\n",
        "        self.play(GrowFromPoint(dist_brace, dist_brace.get_left()))\n",
        "        self.play(TransformFromCopy(dist_brace, dist_brace2))\n",
        "\n",
        "        self.play(GrowFromCenter(side_brace))\n",
        "        self.play(TransformFromCopy(VGroup(side_brace), side_brace_pair))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(dist_brace, dist_brace2, side_brace, side_brace_pair)))\n",
        "        self.wait()\n",
        "\n",
        "        # Show one moon orbit (with the intention of showing phases in the corner)\n",
        "        orbit_group = Group(orbit, moon)\n",
        "\n",
        "        self.play(Rotate(orbit_group, TAU, about_point=earth.get_center(), rate_func=linear, run_time=10))\n",
        "        self.play(Rotate(orbit_group, TAU / 8, about_point=earth.get_center(), rate_func=linear, run_time=1.25))\n",
        "\n",
        "        # Sun highlights half, we see half\n",
        "        words1 = Text(\"Sun illuminates half\")\n",
        "        words2 = Text(\"We see half\")\n",
        "        sub_words = Text(\"(a different half)\", font_size=36)\n",
        "\n",
        "        words1.move_to(4 * RIGHT + 2 * UP)\n",
        "        words2.move_to(4 * LEFT + 2 * DOWN)\n",
        "        sub_words.next_to(words2, DOWN)\n",
        "\n",
        "        arrow1 = Arrow(words1.get_bottom(), 0.75 * RIGHT, path_arc=-60 * DEG)\n",
        "        arrow2 = Arrow(words2.get_top(), 0.75 * LEFT, path_arc=-60 * DEG)\n",
        "\n",
        "        VGroup(words1, words2, sub_words, arrow1, arrow2).scale(0.6 / FRAME_HEIGHT, about_point=ORIGIN).shift(moon.get_center())\n",
        "        VGroup(words2, sub_words, arrow2).set_color(BLUE_D)\n",
        "\n",
        "        our_half = Sphere(radius=0.51 * moon.get_height())\n",
        "        our_half.set_color(BLUE, 0.35)\n",
        "        our_half.always_sort_to_camera(self.camera)\n",
        "        our_half.rotate(90 * DEG, UP)\n",
        "        our_half.rotate(45 * DEG)\n",
        "        our_half.move_to(moon)\n",
        "        our_half.pointwise_become_partial(our_half, 0, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, moon.get_center(), 0.6),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(words1, lag_ratio=0.1),\n",
        "            Write(arrow1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(words2, lag_ratio=0.1),\n",
        "            Write(arrow2),\n",
        "            ShowCreation(our_half)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(sub_words, 0.03 * DOWN))\n",
        "        self.play(\n",
        "            FadeOut(VGroup(words1, arrow1, words2, arrow2, sub_words)),\n",
        "            frame.animate.reorient(0, 0, 0, (-6.23, 0.02, 0.0), 4.73).set_anim_args(run_time=2),\n",
        "        )\n",
        "\n",
        "        # Transition to a different phase\n",
        "        orbit_group.add(our_half)\n",
        "        self.play(Rotate(orbit_group, TAU / 4, about_point=earth.get_center(), run_time=5))\n",
        "        self.play(our_half.animate.set_opacity(0))\n",
        "\n",
        "        # Flat moon\n",
        "        moon.save_state()\n",
        "        moon.target = moon.generate_target()\n",
        "        moon.target.rotate(45 * DEG)\n",
        "        moon.target.stretch(0.01, 0)\n",
        "        moon.target.rotate(-45 * DEG)\n",
        "        moon.target.data[\"d_normal_point\"] = moon.target.data[\"point\"] + 1e-3 * DR\n",
        "\n",
        "        self.play(MoveToTarget(moon))\n",
        "        self.play(\n",
        "            frame.animate.reorient(3, 63, 0, (-6.08, 1.44, -0.78), 2.88),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(orbit_group, -TAU / 4, about_point=earth.get_center(), run_time=8, rate_func=there_and_back),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(moon, time_span=(0, 1)),\n",
        "            frame.animate.reorient(0, 0, 0, (-4.8, 0, 0.0), 4.22),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Show full and new moons\n",
        "        self.play(Rotate(orbit_group, TAU / 8, about_point=earth.get_center(), run_time=2))\n",
        "        full_moon = moon.copy()\n",
        "        full_moon_label = Text(\"Full moon\", font_size=15)\n",
        "        full_moon_label.next_to(full_moon, UR, buff=0.025)\n",
        "        self.play(Write(full_moon_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(full_moon)\n",
        "        self.play(Rotate(orbit_group, TAU / 2, about_point=earth.get_center(), run_time=2))\n",
        "\n",
        "        new_moon = moon.copy()\n",
        "        new_moon_label = Text(\"New moon\", font_size=15)\n",
        "        new_moon_label.next_to(new_moon, UL, buff=0.025)\n",
        "        self.play(Write(new_moon_label))\n",
        "        self.wait()\n",
        "        self.add(new_moon)\n",
        "\n",
        "        # Ask about half moon\n",
        "        question = Text(\"When is the\\nhalf moon?\", font_size=15)\n",
        "        question.set_color(RED)\n",
        "        question.always.next_to(moon, DL, buff=0.025)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(orbit_group, 3 * TAU / 8, about_point=earth.get_center(), run_time=8),\n",
        "            VFadeIn(question, time_span=(1, 3))\n",
        "        )\n",
        "        self.play(Rotate(orbit_group, -TAU / 8, about_point=earth.get_center(), run_time=8))\n",
        "        self.wait()\n",
        "\n",
        "        # Show incorrect right angle\n",
        "        not_here = Text(\"Not here!\", font_size=15)\n",
        "        not_here.next_to(moon, DL, buff=0.05)\n",
        "        not_here.set_color(RED)\n",
        "        half_moon_label = Text(\"Half moon\", font_size=15)\n",
        "\n",
        "        def get_half_moon_angle():\n",
        "            orbit_radius = orbit.get_width() / 2\n",
        "            sun_dist = get_dist(sun[0].get_center(), earth.get_center())\n",
        "            return math.acos(orbit_radius / sun_dist)\n",
        "\n",
        "        def get_half_moon_point():\n",
        "            theta = get_half_moon_angle()\n",
        "            return earth.get_center() + rotate_vector(RIGHT, theta) * orbit.get_width() / 2\n",
        "\n",
        "        half_moon_point = get_half_moon_point()\n",
        "\n",
        "        lines1 = VGroup(\n",
        "            Line(sun[0].get_center(), earth.get_center()),\n",
        "            Line(earth.get_center(), orbit.get_top()),\n",
        "        )\n",
        "        lines2 = VGroup(\n",
        "            Line(sun[0].get_center(), half_moon_point),\n",
        "            Line(half_moon_point, earth.get_center())\n",
        "        )\n",
        "        VGroup(lines1, lines2).set_stroke(WHITE, 2)\n",
        "\n",
        "        elbow1 = Elbow(width=0.15).shift(earth.get_center())\n",
        "        elbow2 = Elbow(width=0.15, angle=get_half_moon_angle() - PI).shift(half_moon_point)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(question),\n",
        "            FadeIn(not_here, scale=0.75),\n",
        "            FadeIn(lines1),\n",
        "            FadeIn(elbow1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(lines1, lines2, time_span=(2, 3)),\n",
        "            ReplacementTransform(elbow1, elbow2, time_span=(2, 3)),\n",
        "            Rotate(orbit_group, get_half_moon_angle() - 90 * DEG, about_point=earth.get_center()),\n",
        "            FadeOut(not_here, time_span=(0, 1)),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        half_moon_label.always.next_to(moon, UR, buff=0.025)\n",
        "        self.play(FadeIn(half_moon_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in\n",
        "        self.play(\n",
        "            frame.animate.reorient(-30, 87, 0, (-5.02, 1.67, 0.0), 0.35),\n",
        "            # elbow2.animate.scale(0.1, about_point=half_moon_point),\n",
        "            FadeOut(lines2),\n",
        "            FadeOut(elbow2),\n",
        "            FadeOut(half_moon_label),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(3, 0, 0, (-5.02, 1.71, 0.01), 0.36),\n",
        "            our_half.animate.set_opacity(0.35),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        lit_half = our_half.copy().set_opacity(0)\n",
        "        lit_half.shift(1e-2 * OUT)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                lit_half,\n",
        "                lit_half.copy().rotate(90 * DEG, about_point=half_moon_point).set_color(YELLOW, 0.35),\n",
        "                path_arc=90 * DEG,\n",
        "            ),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(lit_half),\n",
        "            our_half.animate.set_opacity(0),\n",
        "            FadeIn(half_moon_label),\n",
        "            frame.animate.reorient(0, 0, 0, (-2.89, 0.13, 0.0), 6.83),\n",
        "            FadeIn(elbow2),\n",
        "            FadeIn(lines2),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Move sun away\n",
        "        def get_lunar_angle():\n",
        "            return angle_of_vector(moon.get_center() - earth.get_center())\n",
        "\n",
        "        def get_implied_sun_location():\n",
        "            return earth.get_center() + RIGHT * (orbit.get_width() / 2) / math.cos(get_lunar_angle())\n",
        "\n",
        "        sun.f_always.move_to(get_implied_sun_location)\n",
        "\n",
        "        sun_line, moon_line = lines2\n",
        "        orbit_group.add(moon_line, elbow2)\n",
        "\n",
        "        sun_line.add_updater(lambda m: m.put_start_and_end_on(moon.get_center(), sun.get_center()))\n",
        "\n",
        "        self.remove(lines2)\n",
        "        self.add(orbit_group, sun_line)\n",
        "        self.play(Rotate(orbit_group, 25 * DEG, about_point=earth.get_center()), run_time=5)\n",
        "        self.play(Rotate(orbit_group, -35 * DEG, about_point=earth.get_center()), run_time=5)\n",
        "        self.play(Rotate(orbit_group, 25 * DEG, about_point=earth.get_center()), run_time=10)\n",
        "\n",
        "        # Add angle label\n",
        "        v_line = DashedLine(earth.get_center(), earth.get_center() + orbit.get_width() * UP)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        def get_diff_arc(radius=0.75, color=WHITE, stroke_width=3):\n",
        "            return Arc(\n",
        "                90 * DEG,\n",
        "                get_half_moon_angle() - 90 * DEG,\n",
        "                radius=radius,\n",
        "                arc_center=earth.get_center()\n",
        "            ).set_stroke(color, stroke_width)\n",
        "\n",
        "        arc = always_redraw(get_diff_arc)\n",
        "        theta_label = Tex(R\"\\theta\", font_size=24)\n",
        "        theta_label.add_updater(lambda m: m.set_width(min(0.15, 0.5 * arc.get_width())))\n",
        "        theta_label.add_updater(lambda m: m.next_to(arc.pfp(0.6), UP, SMALL_BUFF))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            FadeIn(arc),\n",
        "            FadeIn(theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(orbit_group, 10 * DEG, about_point=earth.get_center()),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        # Equation\n",
        "        dist_eq = Tex(R\"D_S = {D_M \\over \\sin(\\theta)}\", t2c={\"D_S\": YELLOW, \"D_M\": GREY_B})\n",
        "        dist_eq.to_edge(UP)\n",
        "        dist_eq.fix_in_frame()\n",
        "\n",
        "        dist_line = Line(earth.get_center(), sun[0].get_center())\n",
        "        dist_line.set_stroke(YELLOW, 2)\n",
        "        dist_label = Tex(R\"D_S\", font_size=72)\n",
        "        dist_label.next_to(dist_line, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (4.7, 0.17, 0.0), 14.93),\n",
        "            ShowCreation(dist_line, time_span=(3, 5)),\n",
        "            FadeIn(dist_label, RIGHT, time_span=(3, 5)),\n",
        "            FadeIn(dist_eq, time_span=(3, 5)),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in on discrpency\n",
        "        self.play(\n",
        "            FadeOut(dist_eq, time_span=(0, 2)),\n",
        "            frame.animate.reorient(0, 0, 0, (-6.0, 1.05, 0.0), 2.52),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Comment on discrepency\n",
        "        disc_arc = get_diff_arc(radius=orbit_radius, color=BLUE, stroke_width=5)\n",
        "        est_words = Text(\"Aristarchus estimated\\n6 hours\", font_size=15)\n",
        "        est_words.next_to(frame.get_corner(UL), DR, SMALL_BUFF)\n",
        "        est_words.set_color(BLUE)\n",
        "\n",
        "        question = Text(\"How much time\\nis this?\", font_size=15)\n",
        "        question.move_to(est_words, UP)\n",
        "        question.set_color(BLUE)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            est_words[\"6 hours\"].get_bottom() + 0.05 * DOWN,\n",
        "            disc_arc.get_center(),\n",
        "            buff=0.025,\n",
        "            path_arc=90 * DEG,\n",
        "            thickness=1.5\n",
        "        )\n",
        "        arrow.set_fill(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question),\n",
        "            FadeIn(arrow),\n",
        "            ShowCreation(disc_arc)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(question, 0.25 * UP),\n",
        "            FadeIn(est_words, 0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show true answer\n",
        "        true_answer = TexText(R\"True answer: $\\sim30$ minutes\", font_size=15)\n",
        "        true_answer.set_color(TEAL)\n",
        "        true_answer.move_to(est_words, DL)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(est_words, 0.25 * LEFT, time_span=(1, 2)),\n",
        "            FadeIn(true_answer, 0.25 * LEFT, time_span=(1.25, 2.25)),\n",
        "            Rotate(orbit_group, 4 * DEG, about_point=earth.get_center()),\n",
        "            UpdateFromAlphaFunc(disc_arc, lambda m, a: m.become(\n",
        "                get_diff_arc(\n",
        "                    radius=orbit_radius,\n",
        "                    color=interpolate_color(BLUE, TEAL, a),\n",
        "                    stroke_width=5\n",
        "                )\n",
        "            )),\n",
        "            arrow.animate.set_color(TEAL).shift(0.05 * LEFT),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show false distance to the Sun\n",
        "        brace = Brace(Line(earth.get_bottom(), new_moon.get_bottom()), buff=0)\n",
        "        brace_copies = brace.get_grid(1, 20, buff=0)\n",
        "        brace_copies.move_to(brace, LEFT)\n",
        "\n",
        "        v_line_copies = VGroup(\n",
        "            v_line.copy().align_to(brace_copy, RIGHT)\n",
        "            for brace_copy in brace_copies\n",
        "        )\n",
        "        v_line_copies.stretch(0.5, 1, about_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(true_answer),\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(disc_arc),\n",
        "            FadeOut(dist_line),\n",
        "            FadeOut(dist_label),\n",
        "            Rotate(orbit_group, 1 * DEG - math.asin(1 / 20), about_point=earth.get_center())\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (13.31, -0.69, 0.0), 26.92),\n",
        "            FadeIn(brace, time_span=(0, 1)),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(brace, brace2, path_arc=45 * DEG)\n",
        "                for brace2 in brace_copies),\n",
        "                lag_ratio=0.1,\n",
        "                time_span=(1, 5)\n",
        "            ),\n",
        "            LaggedStartMap(FadeIn, v_line_copies, lag_ratio=0.1, time_span=(1.5, 5)),\n",
        "            sun[2].animate.set_radius(50).set_glow_factor(2),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # True distance\n",
        "        self.play(\n",
        "            Rotate(orbit_group, math.asin(1 / 20) - math.asin(1 / 383), about_point=earth.get_center()),\n",
        "            frame.animate.reorient(0, 0, 0, (364.45, -1.75, 0.0), 480.47),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PhasesOfTheMoon(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Position ourselves\n",
        "        moon = get_moon(radius=2)\n",
        "        moon.set_shading(0, 0, 2)\n",
        "\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(10 * DEG)\n",
        "        light_source = self.camera.light_source\n",
        "        light_source.move_to(10 * LEFT)\n",
        "\n",
        "        self.add(moon)\n",
        "\n",
        "        frame.reorient(-90, 90, 0)\n",
        "\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        dist_to_earth = 20 * moon.get_width()\n",
        "        earth_point = 10 * moon.get_width() * LEFT\n",
        "\n",
        "        def get_sun_location():\n",
        "            theta = theta_tracker.get_value()\n",
        "            return earth_point + 2 * dist_to_earth * rotate_vector(RIGHT, -theta)\n",
        "\n",
        "        light_source.f_always.move_to(get_sun_location)\n",
        "\n",
        "        dot = GlowDot()\n",
        "        dot.set_radius(5)\n",
        "        dot.always.move_to(light_source)\n",
        "\n",
        "        self.add(moon, light_source)\n",
        "        self.play(\n",
        "            theta_tracker.animate.set_value(TAU),\n",
        "            run_time=10,\n",
        "            rate_func=linear\n",
        "        )\n",
        "\n",
        "\n",
        "class HowManyEarthsInsideSun(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth and sun\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(10 * DEG)\n",
        "\n",
        "        earth_radius = 0.25\n",
        "        earth = get_earth(radius=earth_radius)\n",
        "        earth.move_to(0.25 * FRAME_WIDTH * LEFT)\n",
        "\n",
        "        sun = get_sun(radius=7 * earth_radius)\n",
        "        sun.move_to(0.25 * FRAME_WIDTH * RIGHT)\n",
        "\n",
        "        self.add(earth)\n",
        "        self.add(sun)\n",
        "\n",
        "        # Show seven circles\n",
        "        circle = Circle(radius=earth_radius)\n",
        "        circle.move_to(earth)\n",
        "        circle.set_stroke(BLUE, 5)\n",
        "\n",
        "        stack = circle.get_grid(7, 1, buff=0)\n",
        "        stack.move_to(sun)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(LaggedStart(\n",
        "            (TransformFromCopy(circle, circle2)\n",
        "            for circle2 in stack),\n",
        "            lag_ratio=0.05,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show large sun\n",
        "        big_sun = get_sun(radius=109 * earth_radius)\n",
        "        big_sun.move_to(200 * earth_radius * RIGHT)\n",
        "\n",
        "        big_stack = circle.get_grid(109, 1, buff=0)\n",
        "        big_stack.move_to(big_sun[0])\n",
        "        big_stack.set_stroke(width=1)\n",
        "\n",
        "        self.play(\n",
        "            Transform(sun, big_sun),\n",
        "            frame.animate.reorient(0, 0, 0, (8.71, 0.01, 0.0), 89.70),\n",
        "            circle.animate.set_stroke(width=1),\n",
        "            # FadeOut(stack),\n",
        "            Transform(stack, big_stack, lag_ratio=0.001),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "\n",
        "class EarthAroundSun(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth and sun\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(10 * DEG)\n",
        "        frame.set_height(10)\n",
        "\n",
        "        earth_radius = 0.1\n",
        "        orbit_radius = 6.0\n",
        "\n",
        "        earth = get_earth(radius=earth_radius)\n",
        "        earth.move_to(3 * LEFT)\n",
        "\n",
        "        sun = get_sun(radius=7 * earth_radius)\n",
        "        sun.move_to(3 * RIGHT)\n",
        "\n",
        "        # Orbits\n",
        "        sun_orbit = TracingTail(sun, stroke_color=YELLOW, stroke_width=(0, 10), time_traced=5)\n",
        "        earth_orbit = TracingTail(earth, stroke_color=BLUE, stroke_width=(0, 5), time_traced=5)\n",
        "\n",
        "        self.add(sun_orbit, sun, earth_orbit, earth)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Rotate(sun, TAU, about_point=earth.get_center()),\n",
        "            # ShowCreation(sun_orbit),\n",
        "            frame.animate.move_to(earth).set_height(16).set_anim_args(time_span=(0, 4)),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(FadeOut(sun_orbit))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.move_to(sun).set_anim_args(time_span=(0, 4)),\n",
        "            Rotate(earth, TAU, about_point=sun.get_center()),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(sun.animate.scale(109 / 7, about_edge=LEFT).move_to(10 * RIGHT), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NearestPlanets(InteractiveScene):\n",
        "    random_seed = 2\n",
        "    highlighted_orbit = None\n",
        "    linger = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Frame\n",
        "        frame = self.frame\n",
        "\n",
        "        # Add sun\n",
        "        sun = get_sun(radius=0.01, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "\n",
        "        # Add celestial sphere\n",
        "        celestial_sphere = TexturedSurface(Sphere(radius=200), \"hiptyc_2020_8k\")\n",
        "        celestial_sphere.set_shading(0, 0, 0)\n",
        "        celestial_sphere.set_opacity(0.75)\n",
        "        self.add(celestial_sphere)\n",
        "        self.add(sun)\n",
        "\n",
        "        # Add orbits\n",
        "        radius_conversion = 1.0 / EARTH_ORBIT_RADIUS\n",
        "        seconds_per_day = MERCURY_ORBIT_PERIOD\n",
        "\n",
        "        radii = radius_conversion * np.array([\n",
        "            MERCURY_ORBIT_RADIUS,\n",
        "            VENUS_ORBIT_RADIUS,\n",
        "            EARTH_ORBIT_RADIUS,\n",
        "            MARS_ORBIT_RADIUS,\n",
        "            JUPITER_ORBIT_RADIUS,\n",
        "            SATURN_ORBIT_RADIUS,\n",
        "        ])\n",
        "        periods = [\n",
        "            MERCURY_ORBIT_PERIOD,\n",
        "            VENUS_ORBIT_PERIOD,\n",
        "            EARTH_ORBIT_PERIOD,\n",
        "            MARS_ORBIT_PERIOD,\n",
        "            JUPITER_ORBIT_PERIOD,\n",
        "            SATURN_ORBIT_PERIOD,\n",
        "        ]\n",
        "        colors = [GREY_C, TEAL, BLUE, RED, ORANGE, GREY_BROWN]\n",
        "\n",
        "        orbits = VGroup()\n",
        "        for radius, period, color in zip(radii, periods, colors):\n",
        "            orbit = Circle(radius=radius)\n",
        "            orbit.set_stroke(color, width=(0, 3 * radius**0.25))\n",
        "            orbit.rotate(random.random() * TAU, about_point=ORIGIN)\n",
        "            orbit.set_anti_alias_width(5)\n",
        "            orbit.period = period\n",
        "            orbit.add_updater(lambda m, dt: m.rotate(0.5 * (seconds_per_day / m.period) * TAU * dt))\n",
        "            orbits.add(orbit)\n",
        "\n",
        "        self.add(*orbits)\n",
        "\n",
        "        # Add symbols\n",
        "        symbol_texs = [R\"\\mercury\", R\"\\venus\", R\"\\earth\", R\"\\mars\", R\"\\jupiter\", R\"\\saturn\"]\n",
        "        symbols = Tex(\n",
        "            \"\".join(symbol_texs),\n",
        "            additional_preamble=R\"\\usepackage{wasysym}\",\n",
        "            font_size=16\n",
        "        )\n",
        "        for symbol, orbit in zip(symbols, orbits):\n",
        "            radius = orbit.get_width() / 2\n",
        "            symbol.orbit = orbit\n",
        "            symbol.scale(radius**0.5)\n",
        "            buff = symbol.get_height()\n",
        "            symbol.factor = (radius - buff) / radius\n",
        "            symbol.add_updater(lambda m: m.move_to(m.orbit.get_start() * m.factor))\n",
        "\n",
        "        symbols.update()\n",
        "        self.add(*symbols)\n",
        "\n",
        "        # Highlight\n",
        "        if self.highlighted_orbit is not None:\n",
        "            orbits.set_stroke(opacity=0.25)\n",
        "            symbols.set_fill(opacity=0.25)\n",
        "            orbits[self.highlighted_orbit].set_stroke(opacity=1)\n",
        "            symbols[self.highlighted_orbit].set_fill(opacity=1)\n",
        "\n",
        "        # Zoom out\n",
        "        frame = self.frame\n",
        "\n",
        "        frame.reorient(0, 56, 0, (-0.11, 0.08, -0.37), 2.76)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, 15),\n",
        "            run_time=30,\n",
        "        )\n",
        "\n",
        "        if self.linger:\n",
        "            self.wait(30)\n",
        "\n",
        "        # Ask about relative sizes\n",
        "        braces = VGroup()\n",
        "        for orbit, symbol_tex, angle in zip(orbits, symbol_texs, np.linspace(90 * DEG, 0, len(symbol_texs))):\n",
        "            brace = Brace(Line(ORIGIN, orbit.get_width()**0.5 * RIGHT), UP, buff=0)\n",
        "            brace.set_width(orbit.get_width() / 2, about_edge=LEFT)\n",
        "            sym = Tex(Rf\"R{symbol_tex}\", additional_preamble=R\"\\usepackage{wasysym}\", font_size=24)\n",
        "            sym[1].scale(0.5)\n",
        "            sym[1].next_to(sym[0].get_corner(DR), RIGHT, buff=0)\n",
        "            sym.match_height(brace)\n",
        "            sym.set_backstroke(BLACK, 5)\n",
        "            sym.next_to(brace, UP, buff=0.05)\n",
        "            brace.add(sym)\n",
        "            brace.rotate(angle, RIGHT, about_edge=DOWN)\n",
        "            braces.add(brace)\n",
        "        braces.reverse_submobjects()\n",
        "\n",
        "        main_brace = braces[0].copy()\n",
        "        self.play(\n",
        "            Succession(\n",
        "                GrowFromCenter(main_brace),\n",
        "                *(Transform(main_brace, b, rate_func=lambda t: smooth(clip(1.5 * t, 0, 1))) for b in braces[1:]),\n",
        "            ),\n",
        "            frame.animate.reorient(0, 61, 0, ORIGIN, 2.5).set_field_of_view(20 * DEG),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(main_brace))\n",
        "\n",
        "        # Prepare nested spheres\n",
        "        spheres = Group(\n",
        "            self.get_open_sphere(orbit.get_radius())\n",
        "            for orbit in orbits\n",
        "        )\n",
        "        for sphere in spheres:\n",
        "            sphere.clip_tracker.set_value(1.3)\n",
        "            sphere[0].set_opacity(0.25)\n",
        "\n",
        "        # Show platonic solids\n",
        "        solids = self.get_platonic_solids()\n",
        "        for solid in solids:\n",
        "            solid.add_updater(lambda m, dt: m.rotate(10 * DEG * dt * math.cos(self.time), axis=OUT))\n",
        "\n",
        "        box = SurroundingRectangle(solids)\n",
        "        solids.next_to(\n",
        "            rotate_vector(frame.get_corner(UL), frame.get_phi(), RIGHT),\n",
        "            IN + RIGHT,\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, solids, shift=0.25 * OUT, run_time=2, lag_ratio=0.25),\n",
        "            FadeOut(symbols),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show the nesting\n",
        "        orbits.apply_depth_test()\n",
        "        spheres.set_color(GREY_D, 1)\n",
        "        spheres.set_shading(0.25, 0.25, 0.2)\n",
        "        self.camera.light_source.move_to(20 * LEFT)\n",
        "\n",
        "        octo, icos, dodec, tetra, cube = solids\n",
        "        target_solids = self.get_platonic_solids()\n",
        "        factors = [1.5, 1.15, 1.2, 2.0, 1.0]\n",
        "        for target_solid, sphere, factor in zip(target_solids, spheres, factors):\n",
        "            target_solid.set_width(factor * sphere.get_width())\n",
        "            target_solid.shift(-target_solid.get_all_points().mean(0))\n",
        "        target_solids[4].center()\n",
        "\n",
        "        def drop_sphere(index, run_time=1.5):\n",
        "            self.add(spheres[index])\n",
        "            self.play(\n",
        "                FadeIn(spheres[index], scale=0.7),\n",
        "                run_time=run_time\n",
        "            )\n",
        "            self.add(solids[index:])\n",
        "\n",
        "        self.add(spheres[0], solids[0])\n",
        "        self.play(  # Octohedron\n",
        "            FadeIn(spheres[0]),\n",
        "            ReplacementTransform(solids[0], target_solids[0]),\n",
        "            frame.animate.reorient(-8, 72, 0, (0.0, 0.0, 0.0), 2.50),\n",
        "            run_time=2\n",
        "        )\n",
        "        drop_sphere(1, run_time=2)\n",
        "        self.wait(2)\n",
        "        self.play(  # Dodecahedron\n",
        "            target_solids[0].animate.set_stroke(opacity=0.25),\n",
        "            ReplacementTransform(solids[1], target_solids[1]),\n",
        "            frame.animate.reorient(-2, 69, 0, ORIGIN, 2.92),\n",
        "            solids[2:].animate.shift(LEFT + 0.1 * OUT),\n",
        "            run_time=2\n",
        "        )\n",
        "        drop_sphere(2)\n",
        "        self.play(  # Dodec\n",
        "            target_solids[1].animate.set_stroke(opacity=0.25),\n",
        "            ReplacementTransform(solids[2], target_solids[2]),\n",
        "            frame.animate.reorient(-16, 69, 0, ORIGIN, 4),\n",
        "            solids[3:].animate.shift(LEFT + 0.5 * OUT),\n",
        "            run_time=2\n",
        "        )\n",
        "        drop_sphere(3)\n",
        "        self.play(  # Tetra\n",
        "            target_solids[2].animate.set_stroke(opacity=0.25),\n",
        "            ReplacementTransform(solids[3], target_solids[3]),\n",
        "            frame.animate.reorient(-31, 68, 0, ORIGIN, 9),\n",
        "            solids[4:].animate.scale(5).shift(3 * LEFT + 2 * OUT),\n",
        "            run_time=2\n",
        "        )\n",
        "        drop_sphere(4)\n",
        "        self.play(  # Cube\n",
        "            target_solids[3].animate.set_stroke(opacity=0.25),\n",
        "            ReplacementTransform(solids[4], target_solids[4]),\n",
        "            frame.animate.reorient(-9, 69, 0, ORIGIN, 15),\n",
        "            run_time=2\n",
        "        )\n",
        "        drop_sphere(5)\n",
        "        self.play(frame.animate.reorient(-19, 72, 0, ORIGIN, 20), run_time=3)\n",
        "\n",
        "        # Ambient panning\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation(3 * DEG)\n",
        "        self.play(\n",
        "            LaggedStart(*(sphere.clip_tracker.animate.set_value(0) for sphere in spheres[::-1]), lag_ratio=0.25, run_time=6)\n",
        "        )\n",
        "        last_solid = target_solids[-1]\n",
        "        for solid in (*target_solids, *target_solids, *target_solids):\n",
        "            self.play(\n",
        "                solid.animate.set_stroke(WHITE, 2, 1),\n",
        "                last_solid.animate.set_stroke(WHITE, 1, 0.25),\n",
        "            )\n",
        "            last_solid = solid\n",
        "\n",
        "        # Show difficulty in making the theory fit\n",
        "        frame.clear_updaters()\n",
        "        orbits.suspend_updating()\n",
        "\n",
        "        self.add(*spheres)\n",
        "        self.play(*(\n",
        "            mob.animate.scale(1.1).set_anim_args(rate_func=lambda t: wiggle(t, 5), time_span=(random.random(), 4 + random.random()))\n",
        "            for mob in (*spheres, *orbits, *target_solids)\n",
        "        ))\n",
        "\n",
        "        # Trouble with orbits\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, 12),\n",
        "            target_solids.animate.set_stroke(opacity=0.2),\n",
        "            FadeOut(spheres),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        factors = np.random.uniform(0.8, 1.2, len(orbits))\n",
        "        angles = np.random.uniform(0, TAU, len(orbits))\n",
        "        self.play(\n",
        "            *(\n",
        "                orbit.animate.rotate(angle).stretch(factor, 0).stretch(1 / factor, 1).rotate(-angle).set_anim_args(\n",
        "                    rate_func=lambda t: wiggle(t, 7),\n",
        "                    time_span=(random.random(), 6 + random.random())\n",
        "                )\n",
        "                for orbit, factor, angle in zip(orbits, factors, angles)\n",
        "            ),\n",
        "            FadeOut(target_solids),\n",
        "        )\n",
        "\n",
        "        # Get rid of circles, add planets\n",
        "        self.camera.light_source.move_to(ORIGIN)\n",
        "\n",
        "        small_radius = 0.01\n",
        "        planets = Group(\n",
        "            Sphere(radius=small_radius * math.sqrt(orbit.get_radius()), color=orbit.get_color()).set_shading(0.25, 0.25, 1)\n",
        "            for orbit in orbits\n",
        "        )\n",
        "        planets.replace_submobject(2, get_earth(radius=small_radius))\n",
        "        for planet, orbit, symbol in zip(planets, orbits, symbols):\n",
        "            planet.f_always.move_to(orbit.get_start)\n",
        "            symbol.clear_updaters()\n",
        "            symbol.always.next_to(planet, UR, buff=0.025)\n",
        "\n",
        "        fading_orbits = orbits.copy()\n",
        "        orbits.set_stroke(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(fading_orbits, shift=2 * LEFT, lag_ratio=0.2),\n",
        "            FadeIn(planets),\n",
        "            FadeIn(symbols),\n",
        "            celestial_sphere.animate.set_opacity(0.25),\n",
        "            frame.animate.set_height(4),\n",
        "            run_time=3,\n",
        "        )\n",
        "        orbits.resume_updating()\n",
        "\n",
        "        # Add observation lines\n",
        "        lines = VGroup()\n",
        "        non_earth_planets = [*planets[:2], *planets[3:]]\n",
        "        for planet in non_earth_planets:\n",
        "            # line = Line().set_stroke(colors[list(planets).index(planet)], 1)\n",
        "            line = Line().set_stroke(planet.get_color(), 2, opacity=0.75)\n",
        "            line.f_always.put_start_and_end_on(planets[2].get_center, planet.get_center)\n",
        "            lines.add(line)\n",
        "        lines.apply_depth_test()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(6).move_to(DOWN),\n",
        "            FadeIn(lines, time_span=(0, 1)),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Change perspective\n",
        "        orbits.suspend_updating()\n",
        "        earth = planets[2]\n",
        "        self.play(\n",
        "            frame.animate.reorient(82, 87, 0, earth.get_center(), 0.05),\n",
        "            FadeOut(symbols),\n",
        "            *(planet.animate.scale(0.1) for planet in non_earth_planets),\n",
        "            celestial_sphere.animate.set_opacity(1),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_open_sphere(self, radius, color=GREY_C, opacity=0.5):\n",
        "        sphere = Sphere(radius=radius)\n",
        "        sphere.set_color(color, opacity)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "\n",
        "        mesh = SurfaceMesh(sphere, normal_nudge=0, resolution=(51, 25))\n",
        "        mesh.set_stroke(WHITE, 0.5, 0.1)\n",
        "        mesh.set_anti_alias_width(1)\n",
        "        mesh.deactivate_depth_test()\n",
        "\n",
        "        result = Group(sphere, mesh)\n",
        "        result.clip_tracker = ValueTracker(0)\n",
        "\n",
        "        sphere.add_updater(lambda m: m.set_clip_plane(IN, result.clip_tracker.get_value() * radius))\n",
        "        mesh.add_updater(lambda m: m.set_clip_plane(OUT, result.clip_tracker.get_value() * radius))\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_platonic_solids(self):\n",
        "        # Platonic solid test\n",
        "        dodec = Dodecahedron()\n",
        "        cube = VCube()\n",
        "\n",
        "        icos_verts = np.array([pent.get_vertices().mean(0) for pent in dodec])\n",
        "        octo_verts = np.array([square.get_vertices().mean(0) for square in cube])\n",
        "        tetra_verts = vertices = np.array([\n",
        "            [0, 0, 1],\n",
        "            [np.sqrt(8 / 9), 0, -1 / 3],\n",
        "            [-np.sqrt(2 / 9), np.sqrt(2 / 3), -1 / 3],\n",
        "            [-np.sqrt(2 / 9), -np.sqrt(2 / 3), -1 / 3],\n",
        "        ])\n",
        "\n",
        "        octo = self.wireframe_from_points(octo_verts, 4)\n",
        "        icos = self.wireframe_from_points(icos_verts, 5)\n",
        "        tetra = self.wireframe_from_points(tetra_verts, 3)\n",
        "\n",
        "        solids = VGroup(octo, icos, dodec, tetra, cube)\n",
        "        for solid in solids:\n",
        "            solid.set_height(0.25)\n",
        "            solid.set_stroke(WHITE, 1)\n",
        "            solid.set_fill(opacity=0)\n",
        "            solid.set_stroke(flat=False)\n",
        "            solid.apply_depth_test()\n",
        "        solids.arrange(RIGHT, buff=0.25)\n",
        "\n",
        "        return solids\n",
        "\n",
        "    def wireframe_from_points(self, points, n_neighbors):\n",
        "        lines = VGroup()\n",
        "        for point in points:\n",
        "            norms = np.linalg.norm(points - point, axis=1)\n",
        "            indices = np.argsort(norms)\n",
        "            lines.add(*(\n",
        "                Line(point, points[index])\n",
        "                for index in indices[1:1 + n_neighbors]\n",
        "            ))\n",
        "\n",
        "        return lines\n",
        "\n",
        "\n",
        "class HighlightEarthOrbit(NearestPlanets):\n",
        "    highlighted_orbit = 2\n",
        "\n",
        "\n",
        "class HighlightMarsOrbit(NearestPlanets):\n",
        "    highlighted_orbit = 3\n",
        "\n",
        "\n",
        "class HighlightJupiterOrbit(NearestPlanets):\n",
        "    highlighted_orbit = 4\n",
        "\n",
        "\n",
        "class KeplersMethod(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth, mars\n",
        "        frame = self.frame\n",
        "        frame.set_field_of_view(45 * DEG)\n",
        "        light_source = self.camera.light_source\n",
        "        light_source.move_to(ORIGIN)\n",
        "\n",
        "        orbit_scale_factor = 2.5 / EARTH_ORBIT_RADIUS\n",
        "\n",
        "        sun = get_sun(radius=0.025, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "        earth_orbit = Circle(radius=EARTH_ORBIT_RADIUS * orbit_scale_factor)\n",
        "        earth_orbit.set_stroke(BLUE, 1)\n",
        "        earth_orbit.stretch(1.03, 0)\n",
        "\n",
        "        mars_orbit = Circle(radius=MARS_ORBIT_RADIUS * orbit_scale_factor)\n",
        "        mars_orbit.set_stroke(RED, 1)\n",
        "        mars_orbit.stretch(1.03, 0).rotate(50 * DEG)\n",
        "\n",
        "        earth = get_earth(radius=0.01)\n",
        "        earth.move_to(earth_orbit.get_start())\n",
        "        earth_glow = GlowDot(color=BLUE, radius=0.25)\n",
        "        earth_glow.always.move_to(earth)\n",
        "\n",
        "        mars = get_planet(\"Mars\", radius=0.01)\n",
        "        mars_glow = GlowDot(color=RED, radius=0.1)\n",
        "        mars_glow.always.move_to(mars)\n",
        "        mars.move_to(mars_orbit.get_start())\n",
        "\n",
        "        self.add(sun)\n",
        "        self.add(earth)\n",
        "        self.add(mars)\n",
        "        self.add(mars_glow)\n",
        "\n",
        "        # Add celestial sphere\n",
        "        celestial_sphere = get_celestial_sphere()\n",
        "        celestial_sphere.set_z_index(-2)\n",
        "        celestial_sphere.rotate(170 * DEG)\n",
        "        self.add(celestial_sphere)\n",
        "\n",
        "        # Zoom out from earth observing mars, adding an arrow to it\n",
        "        frame.move_to(earth)\n",
        "        frame.set_height(6 * earth.get_height())\n",
        "        frame.reorient(-9, 86, 0)\n",
        "\n",
        "        line_to_mars = self.get_line_between_bodies(earth, mars, RED)\n",
        "        line_to_mars.set_z_index(-1)\n",
        "\n",
        "        symbols = Tex(R\"\\earth \\mars\", additional_preamble=R\"\\usepackage{wasysym}\",)\n",
        "        symbols.scale(0.75)\n",
        "        earth_symbol, mars_symbol = symbols\n",
        "        earth_symbol.always.next_to(earth, RIGHT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "        mars_symbol.always.next_to(mars, UR, buff=0.05)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.to_default_state().set_anim_args(time_span=(1.5, 6)),\n",
        "            ShowCreation(line_to_mars, suspend_mobject_updating=True),\n",
        "            mars.animate.scale(5),\n",
        "            mars_glow.animate.scale(3),\n",
        "            earth.animate.scale(5).set_anim_args(time_span=(4, 6)),\n",
        "            FadeIn(earth_glow, time_span=(4, 5)),\n",
        "            FadeIn(symbols, time_span=(4, 5)),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move around the earth and mars\n",
        "        self.play(\n",
        "            Rotate(earth, TAU, about_point=earth.get_center() + 0.4 * DOWN),\n",
        "            MaintainPositionRelativeTo(mars, earth),\n",
        "            frame.animate.set_height(9),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            mars.animate.move_to(interpolate(mars.get_center(), earth.get_center(), 0.5)),\n",
        "            run_time=4,\n",
        "            rate_func=wiggle,\n",
        "        )\n",
        "\n",
        "        # Show the direction the sun\n",
        "        line_to_sun = self.get_line_between_bodies(earth, sun, YELLOW)\n",
        "        line_to_sun.set_stroke(width=1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_to_sun, suspend_mobject_updating=True, run_time=2),\n",
        "            line_to_mars.animate.set_stroke(width=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(earth, TAU, about_point=sun.get_center()),\n",
        "            Rotate(mars, (EARTH_ORBIT_PERIOD / MARS_ORBIT_PERIOD) * TAU, about_point=sun.get_center()),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "        # Unsure of the distance to the sun\n",
        "        sun_earth_group = Group(sun[0], earth)\n",
        "        brace = Brace(Line(sun.get_center(), earth.get_center()), UP)\n",
        "        q_marks = brace.get_tex(\"???\", buff=SMALL_BUFF)\n",
        "\n",
        "        brace.f_always.set_width(lambda: get_dist(sun.get_center(), earth.get_center()))\n",
        "        brace.always.next_to(sun.get_center(), UP, SMALL_BUFF, aligned_edge=LEFT)\n",
        "        q_marks.always.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            GrowFromPoint(brace, sun.get_center(), suspend_mobject_updating=True),\n",
        "            FadeIn(q_marks, shift=0.25 * DOWN, suspend_mobject_updating=True),\n",
        "        ))\n",
        "        self.play(\n",
        "            earth.animate.shift(0.5 * LEFT),\n",
        "            MaintainPositionRelativeTo(mars, earth),\n",
        "            rate_func=lambda t: wiggle(t, 6),\n",
        "            run_time=8\n",
        "        )\n",
        "        brace.set_fill(border_width=0)\n",
        "        self.play(FadeOut(brace, suspend_mobject_updating=True), FadeOut(q_marks))\n",
        "\n",
        "        # Reference both orbits we want to know\n",
        "        angle = 1.6 * TAU\n",
        "\n",
        "        earth_annulus = self.get_mystery_orbit(earth_orbit)\n",
        "        mars_annulus = self.get_mystery_orbit(mars_orbit)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(earth, angle, about_point=sun.get_center()),\n",
        "            Rotate(mars, (EARTH_ORBIT_PERIOD / MARS_ORBIT_PERIOD) * angle, about_point=sun.get_center()),\n",
        "            FadeIn(earth_annulus, time_span=(3, 5)),\n",
        "            FadeIn(mars_annulus, time_span=(4, 6)),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "        # Clear the board\n",
        "        self.play(\n",
        "            FadeOut(earth_annulus),\n",
        "            FadeOut(mars_annulus),\n",
        "            celestial_sphere[0].animate.set_opacity(0.5),\n",
        "            celestial_sphere[1].animate.set_opacity(0),\n",
        "        )\n",
        "\n",
        "        # Fix mars in space\n",
        "        pin = SVGMobject(\"push_pin\")\n",
        "        pin.set_height(0.75)\n",
        "        pin.rotate(40 * DEG, UP)\n",
        "        pin.set_fill(GREY_E, 1)\n",
        "        pin.set_shading(0.5, 0.25, 0)\n",
        "        pin.rotate(10 * DEG)\n",
        "        pin.move_to(mars.get_center(), DR)\n",
        "\n",
        "        earth_orbit.set_shape(5.2, 5.0)\n",
        "        earth_orbit.move_to(0.5 * math.sqrt(earth_orbit.get_width()**2 - earth_orbit.get_height()**2) * LEFT)\n",
        "        earth_orbit.rotate(angle_of_vector(earth.get_center()) - angle_of_vector(earth_orbit.get_start()), about_point=ORIGIN)\n",
        "        dens_func = bezier([0, 0.2, 0.8, 1])\n",
        "        n_samples = 24\n",
        "        sample_points = [earth_orbit.pfp(dens_func(a)) for a in np.arange(0, 1, 1 / n_samples)]\n",
        "        earth.move_to(sample_points[0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pin, shift=0.5 * DR, rate_func=rush_into),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show several lines deducing where earth is\n",
        "        self.remove(line_to_sun, line_to_mars)\n",
        "\n",
        "        ghost_lines = VGroup()\n",
        "        ghost_earths = Group()\n",
        "        self.add(ghost_earths)\n",
        "        for sample_point in sample_points:\n",
        "            self.play(\n",
        "                earth.animate.move_to(sample_point),\n",
        "                ghost_lines.animate.set_stroke(opacity=0.2),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            new_lines = self.show_earth_location_with_intersection(earth, mars, sun)\n",
        "            ghost_lines.add(new_lines)\n",
        "            ghost_earths.add(earth_glow.copy().clear_updaters())\n",
        "\n",
        "        # Move around fixed mars, see implied ghost locations\n",
        "        self.play(ghost_lines.animate.set_stroke(opacity=0.2))\n",
        "        earth.add_updater(lambda m: m.move_to(ghost_earths[-1]))\n",
        "        pin.add_updater(lambda m: m.move_to(mars.get_center(), DR))\n",
        "        self.bind_ghost_lines_to_mars(ghost_lines, ghost_earths, mars)\n",
        "\n",
        "        self.play(\n",
        "            # Rotate(mars, TAU, about_point=mars.get_center() + 0.2 * LEFT, run_time=5),\n",
        "            mars.animate.scale(1.2, about_point=ORIGIN),\n",
        "            rate_func=wiggle,\n",
        "            run_time=5\n",
        "        )\n",
        "        earth.clear_updaters()\n",
        "\n",
        "        # Unfix mars\n",
        "        ghost_earths.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(pin, UL),\n",
        "            FadeOut(ghost_earths, lag_ratio=0.1, run_time=1),\n",
        "            FadeOut(ghost_lines, lag_ratio=0.1, run_time=1),\n",
        "            Rotate(mars, TAU, about_point=sun.get_center(), run_time=8)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show samples after 5 martian years\n",
        "        ghost_lines, ghost_earths = self.show_time_series_measurments(earth, mars, sun, earth_glow, 5, 4)\n",
        "        self.bind_ghost_lines_to_mars(ghost_lines, ghost_earths, mars)\n",
        "\n",
        "        self.play(*map(FadeOut, [earth, earth_glow, earth_symbol]))\n",
        "        self.play(Rotate(mars, 5 * DEG, about_point=ORIGIN, run_time=5, rate_func=wiggle))\n",
        "        self.play(mars.animate.shift(LEFT), run_time=5, rate_func=wiggle)\n",
        "\n",
        "        earth.move_to(ghost_earths[0])\n",
        "        mars_copy = mars_glow.copy()\n",
        "        mars_copy.clear_updaters()\n",
        "        mars_copy.set_color(PINK)\n",
        "        self.play(\n",
        "            FadeOut(ghost_lines),\n",
        "            ghost_earths.animate.set_color(GREEN),\n",
        "            FadeIn(mars_copy)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Rotate(mars, 5 * DEG, about_point=sun.get_center()),\n",
        "            Rotate(earth, (MARS_ORBIT_PERIOD / EARTH_ORBIT_PERIOD) * 5 * DEG, about_point=sun.get_center()),\n",
        "            FadeIn(earth_glow),\n",
        "        )\n",
        "        self.wait()\n",
        "        og_ghost_earths = ghost_earths\n",
        "\n",
        "        # Find a new sample\n",
        "        ghost_lines, ghost_earths = self.show_time_series_measurments(earth, mars, sun, earth_glow, 5, 2)\n",
        "        self.bind_ghost_lines_to_mars(ghost_lines, ghost_earths, mars)\n",
        "        self.play(FadeOut(earth), FadeOut(earth_glow))\n",
        "\n",
        "        self.play(Rotate(mars, 5 * DEG, about_point=ORIGIN, run_time=5, rate_func=wiggle))\n",
        "        self.play(mars.animate.shift(LEFT), run_time=5, rate_func=wiggle)\n",
        "\n",
        "        self.play(*map(FadeOut, [\n",
        "            ghost_lines, ghost_earths, og_ghost_earths,\n",
        "            earth_glow, mars_copy,\n",
        "        ]))\n",
        "\n",
        "        # Show clusters of five\n",
        "        step = (MARS_ORBIT_PERIOD / EARTH_ORBIT_PERIOD)\n",
        "        clusters = Group()\n",
        "        mars_line_groups = Group()\n",
        "\n",
        "        last_cluster = Group()\n",
        "        last_mars_lines = VGroup()\n",
        "        for n in range(30):\n",
        "            initial_mars_spot = mars.get_center().copy()\n",
        "            mars.rotate(5 * DEG, about_point=ORIGIN)\n",
        "\n",
        "            start = n * (5 / 360)\n",
        "            alphas = (start + np.arange(5) * step) % 1\n",
        "            points = [earth_orbit.pfp(dens_func(a)) for a in alphas]\n",
        "            cluster = Group(GlowDot(point).set_color(BLUE) for point in points)\n",
        "            mars_lines = VGroup(Line(mars.get_center(), dot.get_center(), buff=0) for dot in cluster)\n",
        "            mars_lines.set_stroke(RED, 1)\n",
        "            clusters.add(cluster)\n",
        "\n",
        "            # Animation\n",
        "            cluster.set_color(WHITE)\n",
        "            rigid_group = Group(mars, mars_glow, mars_lines, cluster)\n",
        "            rigid_group.save_state()\n",
        "            rigid_group.scale(np.random.uniform(0.9, 1.1), about_point=ORIGIN)\n",
        "            rigid_group.rotate(np.random.uniform(0, 2 * DEG), about_point=ORIGIN)\n",
        "\n",
        "            new_mars_spot = mars.get_center().copy()\n",
        "            mars.move_to(initial_mars_spot)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(last_mars_lines),\n",
        "                mars.animate.move_to(new_mars_spot)\n",
        "            )\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(cluster),\n",
        "                ShowIncreasingSubsets(mars_lines),\n",
        "                *(dot.animate.set_color(BLUE).set_radius(0.15) for dot in last_cluster)\n",
        "            )\n",
        "            self.play(Restore(rigid_group))\n",
        "            last_cluster = cluster\n",
        "            last_mars_lines = mars_lines\n",
        "\n",
        "        earth.move_to(earth_orbit.get_start())\n",
        "        self.play(\n",
        "            FadeOut(last_mars_lines),\n",
        "            FadeOut(last_cluster),\n",
        "            FadeOut(clusters),\n",
        "            FadeIn(earth),\n",
        "            FadeIn(earth_glow),\n",
        "            FadeIn(earth_symbol),\n",
        "            ShowCreation(earth_orbit),\n",
        "        )\n",
        "\n",
        "        # Show the deduction of Mars' orbit\n",
        "        mars.set_x(4.8)\n",
        "        earth_location_tracker = ValueTracker(0)\n",
        "        earth.add_updater(lambda m: m.move_to(earth_orbit.pfp(dens_func(earth_location_tracker.get_value() % 1))))\n",
        "        earth_glow.update()\n",
        "        mars_lines = VGroup()\n",
        "        earth_copies = Group()\n",
        "        self.add(mars_lines, earth_copies)\n",
        "        for n in range(5):\n",
        "            earth_copy = earth_glow.copy()\n",
        "            earth_copy.clear_updaters()\n",
        "            earth_copy.orbit_offset = earth_location_tracker.get_value()\n",
        "            mars_line = self.get_line_between_bodies(earth_copy, mars, RED, 1, 2)\n",
        "            mars_line.set_stroke(opacity=0.7)\n",
        "            mars_line.suspend_updating()\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(mars_line),\n",
        "                FadeIn(earth_copy)\n",
        "            )\n",
        "            mars_lines.add(mars_line)\n",
        "            earth_copies.add(earth_copy)\n",
        "            if n == 0:\n",
        "                self.play(\n",
        "                    mars.animate.move_to(mars_line.pfp(0.75)).set_anim_args(rate_func=wiggle),\n",
        "                    frame.animate.set_height(10),\n",
        "                    run_time=4,\n",
        "                )\n",
        "                self.play(\n",
        "                    mars.animate.set_opacity(0),\n",
        "                    mars_glow.animate.set_opacity(0),\n",
        "                    mars_symbol.animate.set_opacity(0),\n",
        "                )\n",
        "            if n < 4:\n",
        "                self.play(\n",
        "                    Rotate(mars, TAU, about_point=sun.get_center()),\n",
        "                    earth_location_tracker.animate.increment_value(MARS_ORBIT_PERIOD / EARTH_ORBIT_PERIOD),\n",
        "                    run_time=2,\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    mars.animate.set_opacity(1),\n",
        "                    mars_glow.animate.set_opacity(1),\n",
        "                    mars_symbol.animate.set_opacity(1),\n",
        "                )\n",
        "\n",
        "        # Shift forward a bunch\n",
        "        self.play(*map(FadeOut, [earth, earth_symbol, earth_glow]))\n",
        "        earth_location_tracker.set_value(0)\n",
        "        for dot, mars_line in zip(earth_copies, mars_lines):\n",
        "            dot.add_updater(lambda m: m.move_to(earth_orbit.pfp(dens_func((earth_location_tracker.get_value() + m.orbit_offset) % 1))))\n",
        "            mars_line.resume_updating()\n",
        "\n",
        "        mars_copies = Group()\n",
        "        self.add(earth_copies, mars_copies)\n",
        "        for n in range(100):\n",
        "            d_alpha = 0.01\n",
        "            mars_copy = mars_glow.copy()\n",
        "            mars_copy.clear_updaters()\n",
        "            mars_copy.scale(0.25)\n",
        "            mars_copies.add(mars_copy)\n",
        "            mars.rotate(d_alpha * (EARTH_ORBIT_PERIOD / MARS_ORBIT_PERIOD) * TAU, about_point=0.5 * UR)\n",
        "            earth_location_tracker.increment_value(d_alpha)\n",
        "            self.wait(0.2)\n",
        "\n",
        "    def get_line_between_bodies(self, body1, body2, color, stroke_width=2, scale_factor=10):\n",
        "        line = Line()\n",
        "        line.set_stroke(color, stroke_width)\n",
        "        line.f_always.put_start_and_end_on(body1.get_center, body2.get_center)\n",
        "        line.add_updater(lambda m: m.scale(scale_factor, about_point=m.get_start()))\n",
        "        return line\n",
        "\n",
        "    def get_mystery_orbit(self, orbit, opacity=0.25, n_q_marks=12):\n",
        "        annulus = Annulus(0.9 * orbit.get_radius(), 1.1 * orbit.get_radius())\n",
        "        annulus.set_fill(orbit.get_color(), opacity=opacity)\n",
        "        q_marks = VGroup(Tex(\"?\").move_to(orbit.pfp(a)) for a in np.arange(0, 1, 1 / n_q_marks))\n",
        "        q_marks.set_fill(opacity=0.25)\n",
        "        return VGroup(annulus, q_marks)\n",
        "\n",
        "    def show_time_series_measurments(self, earth, mars, sun, earth_glow, n_measurements=5, rotation_time=2):\n",
        "        ghost_lines = VGroup()\n",
        "        ghost_earths = Group()\n",
        "        corner_counter = VGroup(\n",
        "            Integer(687, include_sign=True, edge_to_fix=RIGHT),\n",
        "            Text(\"Days\")\n",
        "        )\n",
        "        corner_counter.arrange(RIGHT, aligned_edge=UP)\n",
        "        corner_counter.to_corner(UL, buff=0)\n",
        "\n",
        "        self.add(ghost_lines)\n",
        "        self.add(ghost_earths)\n",
        "        for n in range(n_measurements):\n",
        "            new_lines = self.show_earth_location_with_intersection(earth, mars, sun)\n",
        "            ghost_lines.add(new_lines)\n",
        "            ghost_earths.add(earth_glow.copy().clear_updaters())\n",
        "            if n < n_measurements - 1:\n",
        "                corner_counter[0].set_value(0)\n",
        "                self.add(corner_counter)\n",
        "                self.play(\n",
        "                    Rotate(mars, TAU, about_point=sun.get_center()),\n",
        "                    Rotate(earth, (MARS_ORBIT_PERIOD / EARTH_ORBIT_PERIOD) * TAU, about_point=sun.get_center()),\n",
        "                    ChangeDecimalToValue(corner_counter[0], 687),\n",
        "                    ghost_lines.animate.set_stroke(opacity=0.2).set_anim_args(time_span=(0, 1)),\n",
        "                    run_time=rotation_time\n",
        "                )\n",
        "            else:\n",
        "                self.play(\n",
        "                    ghost_lines.animate.set_stroke(opacity=0.2),\n",
        "                    FadeOut(corner_counter)\n",
        "                )\n",
        "\n",
        "        return ghost_lines, ghost_earths\n",
        "\n",
        "    def show_earth_location_with_intersection(self, earth, mars, sun):\n",
        "        lines = VGroup(\n",
        "            self.get_line_between_bodies(mars, earth, RED, 1, 2),\n",
        "            self.get_line_between_bodies(sun, earth, YELLOW, 1, 2),\n",
        "        )\n",
        "        lines.clear_updaters()\n",
        "        lines.set_stroke(width=1)\n",
        "        self.play(ShowCreation(lines, lag_ratio=0))\n",
        "        return lines\n",
        "\n",
        "    def bind_ghost_lines_to_mars(self, ghost_lines, ghost_earths, mars):\n",
        "        sun_point = ghost_lines[0][1].get_start()\n",
        "        for pair, dot in zip(ghost_lines, ghost_earths):\n",
        "            mars_line, sun_line = pair\n",
        "            mars_line.add_updater(lambda m: m.shift(mars.get_center() - m.get_start()))\n",
        "\n",
        "            dot.sun_line = sun_line\n",
        "            dot.mars_line = mars_line\n",
        "            dot.add_updater(lambda m: m.move_to(find_intersection(\n",
        "                m.sun_line.get_start(), m.sun_line.get_vector(),\n",
        "                m.mars_line.get_start(), m.mars_line.get_vector(),\n",
        "            )))\n",
        "\n",
        "    def get_rigid_lines_from_mars(self, mars, ghost_earths):\n",
        "        mars_lines = VGroup(\n",
        "            self.get_line_between_bodies(mars, dot, RED, 1, 1)\n",
        "            for dot in ghost_earths\n",
        "        )\n",
        "        mars_lines.clear_updaters()\n",
        "        mars_lines.set_stroke(opacity=0.5)\n",
        "        return mars_lines\n",
        "\n",
        "\n",
        "class ShowCreationOfAllOrbits(KeplersMethod):\n",
        "    def construct(self):\n",
        "        # Add all orbits (Copied largely from NearestPlanets)\n",
        "        frame = self.frame\n",
        "        sun = get_sun(radius=0.02, big_glow_ratio=20).center()\n",
        "        celestial_sphere = get_celestial_sphere(constellation_opacity=0.01)\n",
        "\n",
        "        self.add(celestial_sphere)\n",
        "        self.add(sun)\n",
        "\n",
        "        # Add orbits\n",
        "        radius_conversion = 2.0 / EARTH_ORBIT_RADIUS\n",
        "        seconds_per_day = MERCURY_ORBIT_PERIOD\n",
        "\n",
        "        radii = radius_conversion * np.array([\n",
        "            MERCURY_ORBIT_RADIUS,\n",
        "            VENUS_ORBIT_RADIUS,\n",
        "            EARTH_ORBIT_RADIUS,\n",
        "            MARS_ORBIT_RADIUS,\n",
        "            JUPITER_ORBIT_RADIUS,\n",
        "            SATURN_ORBIT_RADIUS,\n",
        "        ])\n",
        "        periods = [\n",
        "            MERCURY_ORBIT_PERIOD,\n",
        "            VENUS_ORBIT_PERIOD,\n",
        "            EARTH_ORBIT_PERIOD,\n",
        "            MARS_ORBIT_PERIOD,\n",
        "            JUPITER_ORBIT_PERIOD,\n",
        "            SATURN_ORBIT_PERIOD,\n",
        "        ]\n",
        "        eccentricities = [\n",
        "            0.206,\n",
        "            0,\n",
        "            0.017,\n",
        "            0.093,\n",
        "            0.048,\n",
        "            0.056\n",
        "        ]\n",
        "        colors = [GREY_C, TEAL, BLUE, RED, ORANGE, GREY_BROWN]\n",
        "\n",
        "        orbits = VGroup()\n",
        "        for radius, period, color, ecc in zip(radii, periods, colors, eccentricities):\n",
        "            orbit = Circle(radius=radius)\n",
        "            orbit.set_stroke(color, width=2)\n",
        "            orbit.stretch(math.sqrt(1 - ecc**2), 1)\n",
        "            orbit.shift(0.5 * radius * ecc * RIGHT)\n",
        "            orbit.rotate(random.random() * TAU, about_point=ORIGIN)\n",
        "            orbit.set_anti_alias_width(5)\n",
        "            orbit.period = period\n",
        "            orbits.add(orbit)\n",
        "\n",
        "        # Add planet dots\n",
        "        symbol_texs = [R\"\\mercury\", R\"\\venus\", R\"\\earth\", R\"\\mars\", R\"\\jupiter\", R\"\\saturn\"]\n",
        "        symbols = Tex(\n",
        "            \"\".join(symbol_texs),\n",
        "            additional_preamble=R\"\\usepackage{wasysym}\",\n",
        "            font_size=32\n",
        "        )\n",
        "        planet_dots = Group()\n",
        "        symbols[-2:].scale(3)\n",
        "        for orbit, symbol in zip(orbits, symbols):\n",
        "            dot = GlowDot(color=orbit.get_color())\n",
        "            dot.move_to(orbit.get_start())\n",
        "            orbit.dot = dot\n",
        "            orbit.symbol = symbol\n",
        "            symbol.buff_factor = (orbit.get_radius() + 0.6 * symbol.get_height()) / orbit.get_radius()\n",
        "            symbol.dot = dot\n",
        "            symbol.add_updater(lambda m: m.move_to(m.buff_factor * m.dot.get_center()))\n",
        "            planet_dots.add(dot)\n",
        "\n",
        "        # Draw the orbits\n",
        "        earth_orbit = orbits[2]\n",
        "        earth_orbit.set_stroke(width=1)\n",
        "\n",
        "        frame.set_phi(70 * DEG)\n",
        "        frame.add_updater(lambda m, dt: m.set_phi(m.get_phi() * (1 - 0.03 * dt)))\n",
        "        frame.set_height(3)\n",
        "        growth_rate_tracker = ValueTracker(0.1)\n",
        "        frame.add_updater(lambda m, dt: m.set_height(m.get_height() + growth_rate_tracker.get_value() * dt))\n",
        "\n",
        "        self.add(earth_orbit)\n",
        "        self.draw_orbit(earth_orbit, orbits[3], MARS_ORBIT_PERIOD, 5)\n",
        "        self.draw_orbit(earth_orbit, orbits[0], MERCURY_ORBIT_PERIOD, 7)\n",
        "        self.draw_orbit(earth_orbit, orbits[1], VENUS_ORBIT_PERIOD, 6)\n",
        "        self.draw_orbit(\n",
        "            earth_orbit, orbits[4], JUPITER_ORBIT_PERIOD, 2, run_time=10,\n",
        "            added_anims=[frame.animate.set_height(18)],\n",
        "        )\n",
        "        growth_rate_tracker.set_value(0.4)\n",
        "        self.play(FadeIn(orbits[5]))\n",
        "\n",
        "        # Just linger\n",
        "        self.wait(9)\n",
        "\n",
        "    def draw_orbit(self, earth_orbit, orbit, period, n_samples=3, run_time=4, added_anims=[]):\n",
        "        orbit.set_stroke(width=2)\n",
        "        earth_year_tracker = ValueTracker()\n",
        "        get_earth_time = earth_year_tracker.get_value\n",
        "\n",
        "        def get_earth_orbit_point(offset):\n",
        "            return earth_orbit.pfp((offset + earth_year_tracker.get_value()) % 1)\n",
        "\n",
        "        earth_dots = Group()\n",
        "        lines = VGroup()\n",
        "        for n in range(n_samples):\n",
        "            dot = GlowDot(color=earth_orbit.get_color(), radius=0.1)\n",
        "            dot.offset = n * (period / EARTH_ORBIT_PERIOD)\n",
        "            dot.add_updater(lambda m: m.move_to(get_earth_orbit_point(m.offset)))\n",
        "            earth_dots.add(dot)\n",
        "\n",
        "            line = self.get_line_between_bodies(dot, orbit.dot, orbit.get_color(), 1, 1.1)\n",
        "            lines.add(line),\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(earth_dots),\n",
        "            ShowCreation(lines, lag_ratio=0.1, suspend_mobject_updating=True),\n",
        "            FadeIn(orbit.dot),\n",
        "            FadeIn(orbit.symbol),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(orbit),\n",
        "            UpdateFromFunc(orbit.dot, lambda m: m.move_to(orbit.get_end())),\n",
        "            earth_year_tracker.animate.set_value(period / EARTH_ORBIT_PERIOD),\n",
        "            *added_anims,\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(earth_dots),\n",
        "            FadeOut(orbit.dot),\n",
        "            FadeOut(orbit.symbol),\n",
        "            orbit.animate.set_stroke(width=1)\n",
        "        )\n",
        "\n",
        "\n",
        "class LightFromEarthToMoon(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Earth and moon\n",
        "        self.camera.light_source.move_to(20 * LEFT)\n",
        "        self.frame.set_field_of_view(15 * DEG)\n",
        "\n",
        "        conversion_factor = 12 / MOON_ORBIT_RADIUS\n",
        "        earth = get_earth(radius=conversion_factor * EARTH_RADIUS)\n",
        "        earth.rotate(EARTH_TILT_ANGLE, axis=DOWN)\n",
        "        moon = get_moon(radius=conversion_factor * MOON_RADIUS)\n",
        "        earth.to_edge(LEFT, buff=0.75)\n",
        "        moon.move_to(earth.get_center() + conversion_factor * MOON_ORBIT_RADIUS * RIGHT)\n",
        "\n",
        "        labels = VGroup(Text(\"Earth\"), Text(\"Moon\"))\n",
        "        for label, body in zip(labels, [earth, moon]):\n",
        "            label.scale(0.75).next_to(body, UP, buff=0.25)\n",
        "\n",
        "        self.add(earth, moon)\n",
        "        self.add(labels)\n",
        "\n",
        "        # Light beam\n",
        "        low_x = earth.get_x(RIGHT)\n",
        "        high_x = moon.get_left()[0] - 0.1\n",
        "        pulse = self.get_pulse(SPEED_OF_LIGHT * conversion_factor * LEFT, low_x, high_x)\n",
        "        pulse.next_to(moon, LEFT, buff=0)\n",
        "\n",
        "        self.add(pulse)\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_pulse(\n",
        "        self,\n",
        "        velocity,\n",
        "        low_x=-np.inf,\n",
        "        high_x=np.inf,\n",
        "        radius=0.2,\n",
        "        max_stroke_width=6,\n",
        "        tail_time=0.25,\n",
        "        label_text=\"\"\n",
        "    ):\n",
        "        pulse = GlowDot(radius=radius).set_color(WHITE)\n",
        "\n",
        "        pulse.velocities = np.zeros_like(pulse.get_points())\n",
        "        pulse.velocities[:] = velocity\n",
        "\n",
        "        def update_pulse(pulse, dt):\n",
        "            points = pulse.get_points()\n",
        "            new_points = points.copy()\n",
        "            too_low = points[:, 0] < low_x\n",
        "            too_high = points[:, 0] > high_x\n",
        "\n",
        "            new_points[too_low][:, 0] = low_x\n",
        "            new_points[too_high][:, 0] = high_x\n",
        "\n",
        "            pulse.velocities[too_low] *= -1\n",
        "            pulse.velocities[too_high] *= -1\n",
        "            new_points += pulse.velocities * dt\n",
        "            pulse.set_points(new_points)\n",
        "\n",
        "        pulse.add_updater(update_pulse)\n",
        "        tail = TracingTail(pulse, stroke_width=(0, max_stroke_width), time_traced=tail_time)\n",
        "\n",
        "        result = Group(pulse, tail)\n",
        "\n",
        "        if label_text:\n",
        "            label = Text(label_text, font_size=24)\n",
        "            label.always.next_to(pulse, DOWN, buff=0)\n",
        "            result.add(label)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class LightFromSunToEarth(LightFromEarthToMoon):\n",
        "    def construct(self):\n",
        "        # Sun and earth\n",
        "        self.frame.set_field_of_view(15 * DEG)\n",
        "\n",
        "        conversion_factor = 12 / EARTH_ORBIT_RADIUS\n",
        "        earth = get_earth(radius=conversion_factor * EARTH_RADIUS)\n",
        "        earth.rotate(EARTH_TILT_ANGLE, axis=DOWN)\n",
        "\n",
        "        sun = get_sun(radius=SUN_RADIUS * conversion_factor, big_glow_ratio=20)\n",
        "        sun.move_to(6.5 * LEFT)\n",
        "        earth.move_to(sun.get_center() + conversion_factor * EARTH_ORBIT_RADIUS * RIGHT)\n",
        "        earth_glow = GlowDot(earth.get_center(), color=BLUE)\n",
        "\n",
        "        colors = [GREY_C, TEAL, BLUE]\n",
        "        radii = [MERCURY_ORBIT_RADIUS, VENUS_ORBIT_RADIUS, EARTH_ORBIT_RADIUS]\n",
        "        orbits = VGroup(\n",
        "            Circle(radius=radius * conversion_factor)\n",
        "            for radius, color in zip(radii, colors)\n",
        "        )\n",
        "        glows = Group()\n",
        "        np.random.seed(1)\n",
        "        angles = [-7 * DEG, 8 * DEG, 0]\n",
        "        for orbit, angle, color in zip(orbits, angles, colors):\n",
        "            orbit.rotate(angle)\n",
        "            orbit.move_to(sun)\n",
        "            orbit.set_stroke(color, (0, 3))\n",
        "            glow = GlowDot(color=orbit.get_color())\n",
        "            glow.move_to(orbit.get_start())\n",
        "            glows.add(glow)\n",
        "\n",
        "        symbol_texs = [R\"\\sun\", R\"\\mercury\", R\"\\venus\", R\"\\earth\"]\n",
        "        labels = Tex(\n",
        "            \"\".join(symbol_texs),\n",
        "            additional_preamble=R\"\\usepackage{wasysym}\",\n",
        "            font_size=40\n",
        "        )\n",
        "        labels[0].set_opacity(0)\n",
        "        for label, body in zip(labels, [sun[0], *glows]):\n",
        "            label.next_to(body.get_center(), UR, buff=0.15)\n",
        "\n",
        "        self.camera.light_source.move_to(sun)\n",
        "\n",
        "        self.add(sun, earth, glows, orbits, labels)\n",
        "\n",
        "        # Add pulse\n",
        "        pulse = self.get_pulse(\n",
        "            SPEED_OF_LIGHT * conversion_factor * RIGHT,\n",
        "            low_x=sun.get_x(RIGHT),\n",
        "            high_x=earth.get_x(LEFT),\n",
        "            tail_time=20,\n",
        "            label_text=\"Light\"\n",
        "        )\n",
        "        pulse.next_to(sun, RIGHT)\n",
        "\n",
        "        self.add(pulse)\n",
        "        self.wait(40)\n",
        "\n",
        "\n",
        "class LightAcrossEarth(LightFromEarthToMoon):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.frame.set_field_of_view(10 * DEG)\n",
        "        self.camera.light_source.move_to([-5, 0, 2])\n",
        "        radius = 2.5\n",
        "        earth = get_earth(radius=radius)\n",
        "        earth.rotate(90 * DEG - EARTH_TILT_ANGLE, LEFT)\n",
        "        conversion_factor = radius / EARTH_RADIUS\n",
        "        pulse = self.get_pulse(\n",
        "            0.1 * SPEED_OF_LIGHT * conversion_factor * RIGHT,\n",
        "            low_x=earth.get_x(LEFT) + 0.025,\n",
        "            high_x=earth.get_x(RIGHT),\n",
        "            tail_time=0.4,\n",
        "        )\n",
        "        pulse.move_to(earth.get_corner(DL) + 0.5 * DOWN)\n",
        "\n",
        "        v_lines = Group(\n",
        "            DashedLine(\n",
        "                earth.get_corner(UP + vect) + UP,\n",
        "                earth.get_corner(DOWN + vect) + DOWN,\n",
        "            ).set_stroke(WHITE, 1)\n",
        "            for vect in [LEFT, RIGHT]\n",
        "        )\n",
        "        v_lines[1].shift(0.1 * RIGHT)\n",
        "\n",
        "        self.add(earth)\n",
        "        self.add(v_lines)\n",
        "        self.add(pulse)\n",
        "        self.wait(50)\n",
        "\n",
        "\n",
        "class LightAcrossEarthsOrbit(LightFromEarthToMoon):\n",
        "    def construct(self):\n",
        "        # Add orbit\n",
        "        orbit = Circle(radius=3)\n",
        "        orbit.set_stroke(BLUE, width=(0, 3))\n",
        "        orbit.rotate(190 * DEG)\n",
        "\n",
        "        sun = get_sun(radius=0.05, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "\n",
        "        self.add(sun, orbit)\n",
        "\n",
        "        # Show light\n",
        "        pulse = self.get_pulse(velocity=0.25 * LEFT, tail_time=5)\n",
        "        pulse.next_to(orbit.get_right(), RIGHT, buff=LARGE_BUFF)\n",
        "        pulse.match_y(orbit.get_start())\n",
        "        label = Text(\"Light from Io\", font_size=24)\n",
        "        label.always.next_to(pulse, DOWN, buff=-0.05)\n",
        "\n",
        "        self.add(pulse)\n",
        "        self.wait(4)\n",
        "        self.play(FadeIn(label))\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_light_pulse(self, width=2, n_points=25, dropoff=2):\n",
        "        pulse = GlowDots(np.linspace(ORIGIN, width * RIGHT, n_points), radius=0.1)\n",
        "        pulse.set_opacity(np.linspace(1, 0, pulse.get_num_points())**dropoff)\n",
        "        pulse.set_color(WHITE)\n",
        "        return pulse\n",
        "\n",
        "\n",
        "class EarthAndVenus(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add sun, stars, and orbits (copied from below)\n",
        "        frame = self.frame\n",
        "        conversion_factor = 3.5 / EARTH_ORBIT_RADIUS\n",
        "        celestial_sphere = get_celestial_sphere(radius=100, constellation_opacity=0.05)\n",
        "\n",
        "        sun = get_sun(radius=SUN_RADIUS * conversion_factor, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "\n",
        "        colors = [TEAL, BLUE]\n",
        "        radii = np.array([VENUS_ORBIT_RADIUS, EARTH_ORBIT_RADIUS]) * conversion_factor\n",
        "        orbits = VGroup(\n",
        "            Circle(radius=radius).set_stroke(color, (0, 5))\n",
        "            for radius, color in zip(radii, colors)\n",
        "        )\n",
        "        glows = Group(GlowDot(color=orbit.get_color()) for orbit in orbits)\n",
        "        symbols = VGroup(*map(get_planet_symbols, [\"venus\", \"earth\"]))\n",
        "\n",
        "        for symbol, glow, orbit in zip(symbols, glows, orbits):\n",
        "            orbit.rotate(PI)\n",
        "            glow.f_always.move_to(orbit.get_start)\n",
        "            symbol.scale(0.5)\n",
        "            symbol.glow = glow\n",
        "            # symbol.add_updater(lambda m: m.move_to(1.075 * m.glow.get_center()))\n",
        "            symbol.always.next_to(glow, UL, buff=-SMALL_BUFF)\n",
        "\n",
        "        self.add(celestial_sphere, sun, orbits, glows, symbols)\n",
        "\n",
        "        # Add line\n",
        "        venus, earth = glows\n",
        "        angles = [(180 / period) * TAU for period in [VENUS_ORBIT_PERIOD, EARTH_ORBIT_PERIOD]]\n",
        "        for orbit, angle in zip(orbits, angles):\n",
        "            orbit.rotate(-angle)\n",
        "\n",
        "        line_of_sight = Line()\n",
        "        line_of_sight.set_stroke(WHITE, 1)\n",
        "        line_of_sight.f_always.put_start_and_end_on(earth.get_center, venus.get_center)\n",
        "        line_of_sight.add_updater(lambda m: m.scale(5, about_point=m.get_start())),\n",
        "\n",
        "        self.play(\n",
        "            *(Rotate(orbit, angle) for orbit, angle in zip(orbits, angles)),\n",
        "            VFadeIn(line_of_sight, time_span=(8, 10)),\n",
        "            run_time=20,\n",
        "            # rate_func=lambda t: 0.999 * bezier([0, 1, 1])(t),\n",
        "            rate_func=lambda t: 0.999 * t,\n",
        "        )\n",
        "        line_of_sight.clear_updaters()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-89, 82, 0, (-0.0, 0.01, -0.01), 0.49),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            line_of_sight.animate.rotate(-0.6 * DEG, about_point=earth.get_center()),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RadarToVenus(LightFromEarthToMoon):\n",
        "    def construct(self):\n",
        "        # Add sun, stars, and orbits\n",
        "        frame = self.frame\n",
        "        conversion_factor = 7 / EARTH_ORBIT_RADIUS\n",
        "        celestial_sphere = get_celestial_sphere(radius=100, constellation_opacity=0.05)\n",
        "\n",
        "        sun = get_sun(radius=SUN_RADIUS * conversion_factor, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "\n",
        "        colors = [TEAL, BLUE]\n",
        "        radii = np.array([VENUS_ORBIT_RADIUS, EARTH_ORBIT_RADIUS]) * conversion_factor\n",
        "        angles = [160 * DEG, 180 * DEG]\n",
        "        orbits = VGroup(\n",
        "            Circle(radius=radius).rotate(angle).set_stroke(color, (0, 5))\n",
        "            for radius, color, angle in zip(radii, colors, angles)\n",
        "        )\n",
        "        glows = Group(\n",
        "            GlowDot(orbit.get_start(), color=orbit.get_color())\n",
        "            for orbit in orbits\n",
        "        )\n",
        "        symbols = VGroup(*map(get_planet_symbols, [\"venus\", \"earth\"]))\n",
        "        for symbol, glow in zip(symbols, glows):\n",
        "            symbol.scale(0.5)\n",
        "            symbol.rotate(110 * DEG, LEFT)\n",
        "            symbol.rotate(-54 * DEG, OUT)\n",
        "            symbol.next_to(glow, IN, buff=0)\n",
        "\n",
        "        frame.reorient(-51, 60, 0, (-2.11, 1.24, -2.0), 7.66)\n",
        "        frame.add_ambient_rotation(-1 * DEG)\n",
        "        self.add(celestial_sphere, sun, orbits, glows, symbols)\n",
        "\n",
        "        # Show pulses\n",
        "        venus_point = orbits[0].get_start()\n",
        "        earth_point = orbits[1].get_start()\n",
        "\n",
        "        for _ in range(4):\n",
        "            pulse = self.get_pulse(\n",
        "                velocity=0.15 * (venus_point - earth_point),\n",
        "                radius=0.05,\n",
        "                max_stroke_width=2,\n",
        "                low_x=earth_point[0],\n",
        "                high_x=venus_point[0],\n",
        "                tail_time=0.5,\n",
        "            )\n",
        "            pulse.move_to(earth_point)\n",
        "            self.add(pulse)\n",
        "            self.wait(0.2)\n",
        "        self.wait(20)\n"
    ]
}