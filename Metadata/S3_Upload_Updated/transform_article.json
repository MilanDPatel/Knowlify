{
    "topic": "demonstrates the concept of a single variable function, specifically the graph of a quadratic equation",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "def half_plane():\n",
        "    plane = NumberPlane(\n",
        "        x_radius = FRAME_X_RADIUS/2,\n",
        "        x_unit_to_spatial_width  = 0.5,\n",
        "        y_unit_to_spatial_height = 0.5,\n",
        "        x_faded_line_frequency = 0,\n",
        "        y_faded_line_frequency = 0,\n",
        "        density = 4*DEFAULT_POINT_DENSITY_1D,\n",
        "    )\n",
        "    plane.add_coordinates(\n",
        "        x_vals = list(range(-6, 7, 2)),\n",
        "        y_vals = list(range(-6, 7, 2))\n",
        "    )\n",
        "    return plane\n",
        "\n",
        "class SingleVariableFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x : x**2 - 3, \"ShiftedSquare\", True),\n",
        "        (lambda x : x**2 - 3, \"ShiftedSquare\", False),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name, separate_lines):\n",
        "        return name + (\"SeparateLines\" if separate_lines else \"\")\n",
        "\n",
        "    def construct(self, func, name, separate_lines):\n",
        "        base_line = NumberLine(color = \"grey\")\n",
        "        moving_line = NumberLine(\n",
        "            tick_frequency = 1, \n",
        "            density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        base_line.add_numbers()\n",
        "        def point_function(xxx_todo_changeme):\n",
        "            (x, y, z) = xxx_todo_changeme\n",
        "            return (func(x), y, z)\n",
        "        target = moving_line.copy().apply_function(point_function)\n",
        "\n",
        "        transform_config = {\n",
        "            \"run_time\" : 3,\n",
        "            \"path_func\" : path_along_arc(np.pi/4)\n",
        "        }\n",
        "\n",
        "        if separate_lines:\n",
        "            numbers = moving_line.get_number_mobjects(*list(range(-7, 7)))\n",
        "            negative_numbers = []\n",
        "            for number in numbers:\n",
        "                number.set_color(GREEN_E)\n",
        "                number.shift(-2*moving_line.get_vertical_number_offset())\n",
        "                center = number.get_center()\n",
        "                target_num = number.copy()\n",
        "                target_num.shift(point_function(center) - center)\n",
        "                target.add(target_num)\n",
        "                if center[0] < -0.5:\n",
        "                    negative_numbers.append(number)\n",
        "            moving_line.add(*numbers)\n",
        "            base_line.shift(DOWN)\n",
        "            target.shift(DOWN)\n",
        "            moving_line.shift(UP)\n",
        "\n",
        "        self.add(base_line, moving_line)\n",
        "        self.wait(3)\n",
        "        self.play(Transform(moving_line, target, **transform_config))\n",
        "        if separate_lines:\n",
        "            self.play(*[\n",
        "                ApplyMethod(mob.shift, 0.4*UP)\n",
        "                for mob in negative_numbers\n",
        "            ])\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class LineToPlaneFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x : (np.cos(x), 0.5*x*np.sin(x)), \"Swirl\", []),\n",
        "        (lambda x : (np.cos(x), 0.5*x*np.sin(x)), \"Swirl\", [\n",
        "            (\"0\", \"(1, 0)\", 0),\n",
        "            (\"\\\\frac{\\\\pi}{2}\",  \"(0, \\\\pi / 4)\", np.pi/2),\n",
        "            (\"\\\\pi\", \"(-1, 0)\", np.pi),\n",
        "        ])        \n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name, numbers_to_follow):\n",
        "        return name + (\"FollowingNumbers\" if numbers_to_follow else \"\")\n",
        "\n",
        "    def construct(self, func, name, numbers_to_follow):\n",
        "        line = NumberLine(\n",
        "            unit_length_to_spatial_width = 0.5,\n",
        "            tick_frequency = 1,\n",
        "            number_at_center = 6,\n",
        "            numerical_radius = 6,\n",
        "            big_tick_numbers = [0, 12],\n",
        "            density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        line.to_edge(LEFT)\n",
        "        line_copy = line.copy()\n",
        "        line.add_numbers(*list(range(0, 14, 2)))\n",
        "        divider = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        plane = half_plane()\n",
        "        plane.submobjects = []\n",
        "        plane.filter_out(\n",
        "            lambda x_y_z2 : abs(x_y_z2[0]) > 0.1 and abs(x_y_z2[1]) > 0.1\n",
        "        )\n",
        "        plane.shift(0.5*FRAME_X_RADIUS*RIGHT)\n",
        "        self.add(line, divider, plane)\n",
        "\n",
        "        def point_function(point):\n",
        "            x, y = func(line.point_to_number(point))\n",
        "            return plane.num_pair_to_point((x, y))\n",
        "\n",
        "        target = line_copy.copy().apply_function(point_function)\n",
        "        target.set_color()\n",
        "        anim_config = {\"run_time\" : 3}\n",
        "        anims = [Transform(line_copy, target, **anim_config)]\n",
        "\n",
        "        colors = iter([BLUE_B, GREEN_D, RED_D])\n",
        "        for input_tex, output_tex, number in numbers_to_follow:\n",
        "            center = line.number_to_point(number)\n",
        "            dot = Dot(center, color = next(colors))\n",
        "            anims.append(ApplyMethod(\n",
        "                dot.shift, \n",
        "                point_function(center) - center, \n",
        "                **anim_config \n",
        "            ))\n",
        "            label = OldTex(input_tex)\n",
        "            label.shift(center + 2*UP)\n",
        "            arrow = Arrow(label, dot)\n",
        "            self.add(label)\n",
        "            self.play(ShowCreation(arrow), ShowCreation(dot))\n",
        "            self.wait()\n",
        "            self.remove(arrow, label)\n",
        "\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "        for input_tex, output_tex, number in numbers_to_follow:\n",
        "            point = plane.num_pair_to_point(func(number))\n",
        "            label = OldTex(output_tex)\n",
        "            side_shift = LEFT if number == np.pi else RIGHT\n",
        "            label.shift(point, 2*UP, side_shift)\n",
        "            arrow = Arrow(label, point)\n",
        "            self.add(label)\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.wait(2)\n",
        "            self.remove(arrow, label)\n",
        "\n",
        "class PlaneToPlaneFunctionSeparatePlanes(Scene):\n",
        "    args_list = [\n",
        "        (lambda x_y3 : (x_y3[0]**2+x_y3[1]**2, x_y3[0]**2-x_y3[1]**2), \"Quadratic\")\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name):\n",
        "        return name\n",
        "\n",
        "    def construct(self, func, name):\n",
        "        shift_factor = 0.55\n",
        "        in_plane  = half_plane().shift(shift_factor*FRAME_X_RADIUS*LEFT)\n",
        "        out_plane = half_plane().shift(shift_factor*FRAME_X_RADIUS*RIGHT)\n",
        "        divider = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        self.add(in_plane, out_plane, divider)\n",
        "\n",
        "        plane_copy = in_plane.copy()\n",
        "        plane_copy.submobjects = []\n",
        "\n",
        "        def point_function(point):\n",
        "            result = np.array(func((point*2 + 2*shift_factor*FRAME_X_RADIUS*RIGHT)[:2]))\n",
        "            result = np.append(result/2, [0])\n",
        "            return result + shift_factor*FRAME_X_RADIUS*RIGHT\n",
        "\n",
        "        target = plane_copy.copy().apply_function(point_function)\n",
        "        target.set_color(GREEN_B)\n",
        "\n",
        "        anim_config = {\"run_time\" : 5}\n",
        "\n",
        "        self.wait()\n",
        "        self.play(Transform(plane_copy, target, **anim_config))\n",
        "        self.wait()\n",
        "\n",
        "class PlaneToPlaneFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x_y4 : (x_y4[0]**2+x_y4[1]**2, x_y4[0]**2-x_y4[1]**2), \"Quadratic\")\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name):\n",
        "        return name\n",
        "\n",
        "    def construct(self, func, name):\n",
        "        plane = NumberPlane()\n",
        "        plane.prepare_for_nonlinear_transform()\n",
        "        background = NumberPlane(color = \"grey\")\n",
        "        background.add_coordinates()\n",
        "        anim_config = {\"run_time\" : 3}\n",
        "\n",
        "        def point_function(point):\n",
        "            return np.append(func(point[:2]), [0])\n",
        "\n",
        "        self.add(background, plane)\n",
        "        self.wait(2)\n",
        "        self.play(ApplyPointwiseFunction(point_function, plane, **anim_config))\n",
        "        self.wait(3)\n",
        "\n",
        "class PlaneToLineFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x_y : x_y[0]**2 + x_y[1]**2, \"Bowl\"),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name):\n",
        "        return name\n",
        "\n",
        "    def construct(self, func, name):\n",
        "        line = NumberLine(\n",
        "            color = GREEN,\n",
        "            unit_length_to_spatial_width = 0.5,\n",
        "            tick_frequency = 1,\n",
        "            number_at_center = 6,\n",
        "            numerical_radius = 6,\n",
        "            big_tick_numbers = [0, 12],\n",
        "        ).to_edge(RIGHT)\n",
        "        line.add_numbers()\n",
        "        plane = half_plane().to_edge(LEFT, buff = 0)\n",
        "\n",
        "        divider = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        line_left = line.number_to_point(0)\n",
        "        def point_function(point):\n",
        "            shifter = 0.5*FRAME_X_RADIUS*RIGHT\n",
        "            return func((point+shifter)[:2])*RIGHT + line_left\n",
        "\n",
        "        self.add(line, plane, divider)\n",
        "        self.wait()\n",
        "        plane.submobjects = []\n",
        "        self.play(ApplyPointwiseFunction(point_function, plane))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class PlaneToSpaceFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x_y1 : (x_y1[0]*x_y1[0], x_y1[0]*x_y1[1], x_y1[1]*x_y1[1]), \"Quadratic\"),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name):\n",
        "        return name\n",
        "\n",
        "    def construct(self, func, name):\n",
        "        plane = half_plane().shift(0.5*FRAME_X_RADIUS*LEFT)\n",
        "        divider = Line(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        axes = XYZAxes()\n",
        "        axes.filter_out(lambda p : get_norm(p) > 3)\n",
        "        rot_kwargs = {\n",
        "            \"run_time\" : 3,\n",
        "            \"radians\"  : 0.3*np.pi,\n",
        "            \"axis\"     : [0.1, 1, 0.1],\n",
        "        }\n",
        "        axes.to_edge(RIGHT).shift(DOWN)        \n",
        "        dampening_factor = 0.1\n",
        "        def point_function(xxx_todo_changeme5):\n",
        "            (x, y, z) = xxx_todo_changeme5\n",
        "            return dampening_factor*np.array(func((x, y)))\n",
        "        target = NumberPlane().apply_function(point_function)\n",
        "        target.set_color(\"yellow\")\n",
        "        target.shift(axes.get_center())\n",
        "\n",
        "        self.add(plane, divider, axes)\n",
        "        self.play(Rotating(axes, **rot_kwargs))\n",
        "\n",
        "        target.rotate(rot_kwargs[\"radians\"])\n",
        "        self.play(\n",
        "            TransformAnimations(\n",
        "                Animation(plane.copy()),\n",
        "                Rotating(target, **rot_kwargs),\n",
        "                rate_func = smooth\n",
        "            ),\n",
        "            Rotating(axes, **rot_kwargs)\n",
        "        )\n",
        "        axes.add(target)\n",
        "        self.clear()\n",
        "        self.add(plane, divider, axes)\n",
        "        self.play(Rotating(axes, **rot_kwargs))\n",
        "        self.clear()\n",
        "        for i in range(5):\n",
        "            self.play(Rotating(axes, **rot_kwargs))\n",
        "\n",
        "\n",
        "class SpaceToSpaceFunction(Scene):\n",
        "    args_list = [\n",
        "        (lambda x_y_z : (x_y_z[1]*x_y_z[2], x_y_z[0]*x_y_z[2], x_y_z[0]*x_y_z[1]), \"Quadratic\"),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(func, name):\n",
        "        return name\n",
        "\n",
        "    def construct(self, func, name):\n",
        "        space = SpaceGrid()\n",
        "        rot_kwargs = {\n",
        "            \"run_time\" : 10,\n",
        "            \"radians\"  : 2*np.pi/5,\n",
        "            \"axis\"     : [0.1, 1, 0.1],\n",
        "            \"in_place\" : False,\n",
        "        }\n",
        "        axes = XYZAxes()\n",
        "        target = space.copy().apply_function(func)\n",
        "\n",
        "        self.play(\n",
        "            TransformAnimations(\n",
        "                Rotating(space, **rot_kwargs),\n",
        "                Rotating(target, **rot_kwargs),\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.7)\n",
        "            ),\n",
        "            Rotating(axes, **rot_kwargs)\n",
        "        )\n",
        "        axes.add(space)\n",
        "        self.play(Rotating(axes, **rot_kwargs))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}