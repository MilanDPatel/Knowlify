{
    "topic": "demonstrates the concept of the Laplace transform, which is a mathematical tool used to convert",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class IntroduceTrilogy(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add definition\n",
        "        frame = self.frame\n",
        "        laplace = Tex(R\"F(s) = \\int_0^\\infty f({t}) e^{-s{t}} dt\", font_size=72, t2c={\"s\": YELLOW, R\"{t}\": WHITE})\n",
        "        name = Text(\"Laplace Transform\", font_size=72)\n",
        "        name.next_to(laplace, UP, LARGE_BUFF)\n",
        "\n",
        "        frame.move_to(laplace[\"f({t})\"])\n",
        "        self.play(\n",
        "            Write(laplace[\"f({t})\"]),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(laplace[\"e^{-s\"]),\n",
        "            TransformFromCopy(*laplace[R\"{t}\"][0:2]),\n",
        "            frame.animate.move_to(laplace[R\"f({t}) e^{-s{t}}\"])\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(laplace[R\"\\int_0^\\infty\"], shift=0.25 * RIGHT, scale=1.5),\n",
        "            FadeIn(laplace[R\"dt\"], shift=0.25 * LEFT, scale=1.5),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(laplace[\"f(\"].copy(), laplace[\"F(\"], path_arc=-PI / 2),\n",
        "            TransformFromCopy(laplace[\")\"][1], laplace[\")\"][0], path_arc=-PI / 2),\n",
        "            TransformFromCopy(laplace[\"s\"][1], laplace[\"s\"][0], path_arc=-PI / 4),\n",
        "            Write(laplace[\"=\"]),\n",
        "            frame.animate.center(),\n",
        "        )\n",
        "        self.play(Write(name))\n",
        "        self.wait()\n",
        "\n",
        "        # Show trilogy\n",
        "        background = FullScreenRectangle().set_fill(GREY_E, 1)\n",
        "        screens = ScreenRectangle().replicate(3)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.set_stroke(WHITE, 2)\n",
        "        screens.set_width(0.3 * FRAME_WIDTH)\n",
        "        screens.arrange(RIGHT, buff=0.25 * (FRAME_WIDTH - 3 * screens[0].get_width()))\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.to_edge(UP)\n",
        "\n",
        "        screens[1].save_state()\n",
        "        screens[1].replace(background)\n",
        "        screens[1].set_stroke(width=0)\n",
        "        screens.set_stroke(behind=True)\n",
        "\n",
        "        terms = VGroup(name, laplace)\n",
        "\n",
        "        self.add(background, screens, terms)\n",
        "        self.play(\n",
        "            FadeIn(background),\n",
        "            Restore(screens[1]),\n",
        "            terms.animate.scale(0.4).move_to(screens[1].saved_state),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Inverse\n",
        "        ilp = VGroup(\n",
        "            Text(\"Inverse Laplace Transform\"),\n",
        "            Tex(R\"f({t}) = \\frac{1}{2\\pi i} \\int_{a - i \\infty}^{a + i \\infty} F(s) e^{s{t}} ds\", t2c={\"s\": YELLOW})\n",
        "        )\n",
        "        for mob1, mob2 in zip(ilp, terms):\n",
        "            mob1.replace(mob2, dim_to_match=1)\n",
        "\n",
        "        ilp.move_to(screens[2])\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingStrings(name.copy(), ilp[0], lag_ratio=1e-2, path_arc=-20 * DEG),\n",
        "            TransformMatchingTex(\n",
        "                laplace.copy(),\n",
        "                ilp[1],\n",
        "                lag_ratio=1e-2,\n",
        "                path_arc=-20 * DEG,\n",
        "                matched_keys=[\"f({t})\", \"F(s)\", \"e^{s{t}}\", R\"\\int\"],\n",
        "                key_map={\"dt\": \"ds\"},\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DiscussTrilogy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.background)\n",
        "        screens = ScreenRectangle().replicate(3)\n",
        "        screens.set_width(0.3 * FRAME_WIDTH)\n",
        "        screens.arrange(RIGHT, buff=0.25 * (FRAME_WIDTH - 3 * screens[0].get_width()))\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.to_edge(UP)\n",
        "\n",
        "        # Reference last two\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.body.insert_n_curves(200)\n",
        "        morty = self.teacher\n",
        "        morty.change_mode(\"tease\")\n",
        "        brace1 = Brace(screens[0], DOWN)\n",
        "        brace2 = Brace(screens[1:3], DOWN)\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.change(\"raise_left_hand\", look_at=brace2),\n",
        "            self.change_students(\"pondering\", \"erm\", \"sassy\", look_at=brace2),\n",
        "            GrowFromCenter(brace2),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            self.change_students(\"thinking\", \"pondering\", \"pondering\", look_at=brace1),\n",
        "            ReplacementTransform(brace2, brace1, path_arc=-30 * DEG),\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class WhoCares(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.remove(self.background)\n",
        "        stds = self.students\n",
        "        morty = self.teacher\n",
        "\n",
        "        self.play(\n",
        "            stds[2].says(\"Who cares?\", mode=\"angry\", look_at=3 * UP),\n",
        "            morty.change(\"guilty\", stds[2].eyes),\n",
        "            stds[1].change(\"hesitant\", 3 * UP),\n",
        "            stds[0].change(\"erm\", stds[2].eyes),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class MiniLessonTitle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        title = Text(\"Visualizing complex exponents\", font_size=72)\n",
        "        title.to_edge(UP)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WeGotThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        self.play(\n",
        "            self.change_students(\"coin_flip_2\", \"tease\", \"hooray\", look_at=3 * UP),\n",
        "            morty.change(\"tease\")\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.change_students(\"tease\", \"happy\", \"well\", look_at=morty.eyes)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ConfusionAndWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.body.insert_n_curves(200)\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "\n",
        "        q_marks = Tex(R\"???\").replicate(3)\n",
        "        q_marks.space_out_submobjects(1.5)\n",
        "        for mark, student in zip(q_marks, stds):\n",
        "            mark.next_to(student, UP, MED_SMALL_BUFF)\n",
        "        self.play(\n",
        "            self.change_students(\"confused\", \"pondering\", \"pleading\", look_at=self.screen),\n",
        "            FadeIn(q_marks, 0.2 * UP, lag_ratio=0.05),\n",
        "            morty.change(\"raise_right_hand\")\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(morty.change(\"raise_left_hand\", look_at=3 * UR))\n",
        "        self.play(\n",
        "            self.change_students(\"erm\", \"thinking\", \"hesitant\", look_at=morty.get_top() + 2 * UP),\n",
        "            FadeOut(q_marks)\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(self.change_students(\"pondering\"))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ArrowBetweenScreens(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        screens = ScreenRectangle().replicate(2)\n",
        "        screens.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        screens.set_width(FRAME_WIDTH - 2)\n",
        "        screens.move_to(DOWN)\n",
        "        arrow = Arrow(screens[0].get_top(), screens[1].get_top(), path_arc=-120 * DEG, thickness=6, buff=0.25)\n",
        "        line = Line(screens[0].get_top(), screens[1].get_top(), path_arc=-120 * DEG, stroke_width=8, buff=0.25)\n",
        "        VGroup(arrow, line).set_color(TEAL)\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeIn(arrow, time_span=(0.75, 1))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class WhatAndWhy(InteractiveScene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            Tex(R\"\\text{1) Understanding } e^{i {t}} \\\\ \\text{ intuitively}\", t2c={R\"{t}\": GREY_B}),\n",
        "            TexText(R\"2) How they \\\\ \\quad \\quad naturally arise\"),\n",
        "        )\n",
        "        words[0][R\"intuitively\"].align_to(words[0][\"Understanding\"], LEFT)\n",
        "        words[1][R\"naturally arise\"].align_to(words[1][\"How\"], LEFT)\n",
        "        words.refresh_bounding_box()\n",
        "        words.scale(1.25)\n",
        "        self.add(words)\n",
        "        words.arrange(DOWN, aligned_edge=LEFT, buff=2.5)\n",
        "        words.next_to(ORIGIN, RIGHT)\n",
        "        words.set_opacity(0)\n",
        "        for word, u in zip(words, [1, -1]):\n",
        "            word.set_opacity(1)\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "        # Test\n",
        "\n",
        "\n",
        "class PrequelToLaplace(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # False goal of motivating the i\n",
        "        pass\n",
        "\n",
        "        # Swap out i and \u03c0 for s and t\n",
        "\n",
        "\n",
        "class OtherExponentialDerivatives(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        kw = dict(t2c={\"t\": GREY_B})\n",
        "        derivs = VGroup(\n",
        "            Tex(R\"\\frac{d}{dt} 2^t = (0.693...)2^t\", **kw),\n",
        "            Tex(R\"\\frac{d}{dt} 3^t = (1.098...)3^t\", **kw),\n",
        "            Tex(R\"\\frac{d}{dt} 4^t = (1.386...)4^t\", **kw),\n",
        "            Tex(R\"\\frac{d}{dt} 5^t = (1.609...)5^t\", **kw),\n",
        "            Tex(R\"\\frac{d}{dt} 6^t = (1.791...)6^t\", **kw),\n",
        "        )\n",
        "        derivs.scale(0.75)\n",
        "        derivs.arrange(DOWN, buff=0.7)\n",
        "        derivs.to_corner(UL)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, derivs, shift=UP, lag_ratio=0.5, run_time=5))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VariousExponentials(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        exp_st = Tex(R\"e^{st}\", t2c={\"s\": YELLOW, \"t\": BLUE}, font_size=90)\n",
        "        gen_exp = Tex(R\"e^{+0.50 t}\", t2c={\"+0.50\": YELLOW, \"t\": BLUE}, font_size=90)\n",
        "        exp_st.to_edge(UP, buff=MED_LARGE_BUFF)\n",
        "        gen_exp.move_to(exp_st)\n",
        "\n",
        "        num = gen_exp[\"+0.50\"]\n",
        "        num.set_opacity(0)\n",
        "        gen_exp[\"t\"].scale(1.25, about_edge=UL)\n",
        "\n",
        "        s_num = DecimalNumber(-1.00, edge_to_fix=ORIGIN, include_sign=True)\n",
        "        s_num.set_color(YELLOW)\n",
        "        s_num.replace(num, dim_to_match=1)\n",
        "\n",
        "        self.add(gen_exp, s_num)\n",
        "        self.play(ChangeDecimalToValue(s_num, 0.5, run_time=4))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            ReplacementTransform(gen_exp[\"e\"][0], exp_st[\"e\"][0]),\n",
        "            ReplacementTransform(s_num, exp_st[\"s\"]),\n",
        "            ReplacementTransform(gen_exp[\"t\"][0], exp_st[\"t\"][0]),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhyToWhat(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title text\n",
        "        why = Text(\"Why\", font_size=90)\n",
        "        what = Text(\"Wait, what does this even mean?\", font_size=72)\n",
        "        VGroup(why, what).to_edge(UP)\n",
        "\n",
        "        what_word = what[\"what\"][0].copy()\n",
        "        what[\"what\"][0].set_opacity(0)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            what[\"this\"].get_bottom(),\n",
        "            (2.5, 2, 0),\n",
        "            thickness=5,\n",
        "            fill_color=YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(why, UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            # FadeOut(why, UP),\n",
        "            ReplacementTransform(why, what_word),\n",
        "            FadeIn(what, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            what[\"this\"].animate.set_color(YELLOW)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DerivativeOfExp(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        frame = self.frame\n",
        "        tex_kw = dict(t2c={\"t\": GREY_B, \"s\": YELLOW})\n",
        "        equation = Tex(R\"\\frac{d}{dt} e^{st} = s \\cdot e^{st}\", font_size=90, **tex_kw)\n",
        "        deriv_part = equation[R\"\\frac{d}{dt}\"][0]\n",
        "        exp_parts = equation[R\"e^{st}\"]\n",
        "        equals = equation[R\"=\"][0]\n",
        "        s_dot = equation[R\"s \\cdot\"][0]\n",
        "\n",
        "        v_box = SurroundingRectangle(VGroup(deriv_part, exp_parts[0]))\n",
        "        p_box = SurroundingRectangle(exp_parts[1])\n",
        "        s_box = SurroundingRectangle(s_dot)\n",
        "        s_box.match_height(p_box, stretch=True).match_y(p_box)\n",
        "        boxes = VGroup(v_box, p_box, s_box)\n",
        "        boxes.set_stroke(width=2)\n",
        "        boxes.set_submobject_colors_by_gradient(GREEN, BLUE, YELLOW)\n",
        "\n",
        "        v_label = Text(\"Velocity\", font_size=48).match_color(v_box)\n",
        "        p_label = Text(\"Position\", font_size=48).match_color(p_box)\n",
        "        s_label = Text(\"Modifier\", font_size=48).match_color(s_box)\n",
        "        v_label.next_to(v_box, UP, MED_SMALL_BUFF)\n",
        "        p_label.next_to(p_box, UP, MED_SMALL_BUFF, aligned_edge=LEFT)\n",
        "        s_label.next_to(s_box, DOWN, MED_SMALL_BUFF)\n",
        "        labels = VGroup(v_label, p_label, s_label)\n",
        "\n",
        "        frame.move_to(exp_parts[0])\n",
        "\n",
        "        self.add(exp_parts[0])\n",
        "        self.wait()\n",
        "        self.play(Write(deriv_part))\n",
        "        self.play(\n",
        "            TransformFromCopy(*exp_parts, path_arc=90 * DEG),\n",
        "            Write(equals),\n",
        "            frame.animate.center(),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(exp_parts[1][1], s_dot[0], path_arc=90 * DEG),\n",
        "            Write(s_dot[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show labels\n",
        "        for box, label in zip(boxes, labels):\n",
        "            self.play(ShowCreation(box), FadeIn(label))\n",
        "\n",
        "        self.wait()\n",
        "        full_group = VGroup(equation, boxes, labels)\n",
        "\n",
        "        # Set s equal to 1\n",
        "        s_eq_1 = Tex(R\"s = 1\", font_size=72, **tex_kw)\n",
        "        simple_equation = Tex(R\"\\frac{d}{dt} e^{t} = e^{t}\", font_size=72, **tex_kw)\n",
        "        simple_equation.to_edge(UP).shift(2 * LEFT)\n",
        "        s_eq_1.next_to(simple_equation, RIGHT, buff=2.5)\n",
        "        arrow = Arrow(s_eq_1, simple_equation, thickness=5, buff=0.35).shift(0.05 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(s_eq_1),\n",
        "            GrowArrow(arrow),\n",
        "            TransformMatchingTex(equation.copy(), simple_equation, run_time=1.5, lag_ratio=0.02),\n",
        "            full_group.animate.shift(DOWN).scale(0.75).fade(0.15)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HighlightRect(InteractiveScene):\n",
        "    def construct(self):\n",
        "        img = ImageMobject('/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/laplace/exponentials/DynamicExpIntuitionStill.png')\n",
        "        img.set_height(FRAME_HEIGHT)\n",
        "        self.add(img)\n",
        "\n",
        "        # Rects\n",
        "        rects = VGroup(\n",
        "            Rectangle(2.25, 1).move_to((2.18, 2.74, 0)),\n",
        "            Rectangle(2, 0.85).move_to((-5.88, -2.2, 0.0)),\n",
        "        )\n",
        "        rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(rects[0]))\n",
        "        self.play(TransformFromCopy(*rects))\n",
        "        self.play(FadeOut(rects))\n",
        "\n",
        "\n",
        "class DefineI(InteractiveScene):\n",
        "    def construct(self):\n",
        "        eq = Tex(R\"i = \\sqrt{-1}\", t2c={\"i\": YELLOW}, font_size=90)\n",
        "        self.play(Write(eq))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WaitWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(\n",
        "            self.students[0].change(\"erm\", self.screen),\n",
        "            self.students[1].change(\"tease\", self.screen),\n",
        "            self.students[2].says(\"Wait, why?\", \"confused\", look_at=self.screen, bubble_direction=LEFT),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class MultiplicationByI(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Example number\n",
        "        plane = ComplexPlane(\n",
        "            background_line_style=dict(stroke_color=BLUE, stroke_width=1),\n",
        "            # faded_line_style=dict(stroke_color=BLUE, stroke_width=0.5, stroke_opacity=0.5),\n",
        "        )\n",
        "        plane.add_coordinate_labels(font_size=24)\n",
        "\n",
        "        z = 3 + 2j\n",
        "        tex_kw = dict(t2c={\"a\": YELLOW, \"b\": PINK})\n",
        "\n",
        "        vect = Vector(plane.n2p(z), fill_color=WHITE, thickness=4)\n",
        "        vect_label = Tex(R\"a + bi\", **tex_kw)\n",
        "        vect_label.next_to(vect.get_end(), UR, SMALL_BUFF)\n",
        "        vect_label.set_backstroke(BLACK, 5)\n",
        "\n",
        "        lines = VGroup(\n",
        "            Line(ORIGIN, plane.n2p(z.real)).set_color(YELLOW),\n",
        "            Line(plane.n2p(z.real), plane.n2p(z)).set_color(PINK),\n",
        "        )\n",
        "        a_label, b_label = line_labels = VGroup(\n",
        "            Tex(R\"a\", font_size=36, **tex_kw).next_to(lines[0], UP, SMALL_BUFF),\n",
        "            Tex(R\"bi\", font_size=36, **tex_kw).next_to(lines[1], RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        line_labels.set_backstroke(BLACK, 5)\n",
        "\n",
        "        self.add(plane, Point(), plane.coordinate_labels)\n",
        "        self.add(vect)\n",
        "        self.add(vect_label)\n",
        "        for line, label in zip(lines, line_labels):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeIn(label, 0.25 * line.get_vector())\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Multiply components by i\n",
        "        new_lines = lines.copy()\n",
        "        new_lines.rotate(90 * DEG, about_point=ORIGIN)\n",
        "        new_lines[1].move_to(ORIGIN, RIGHT)\n",
        "\n",
        "        new_a_label = Tex(R\"ai\", font_size=36, **tex_kw).next_to(new_lines[0], RIGHT, SMALL_BUFF)\n",
        "        new_b_label = Tex(R\"bi \\cdot i\", font_size=36, **tex_kw).next_to(new_lines[1], UP, SMALL_BUFF)\n",
        "        neg_b_label = Tex(R\"=-b\", font_size=36, **tex_kw)\n",
        "        neg_b_label.move_to(new_b_label.get_right())\n",
        "\n",
        "        mult_i_label = Tex(R\"\\times i\", font_size=90)\n",
        "        mult_i_label.set_backstroke(BLACK, 5)\n",
        "        mult_i_label.to_corner(UR, buff=MED_LARGE_BUFF).shift(0.2 * UP)\n",
        "\n",
        "        self.play(Write(mult_i_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[0], new_lines[0], path_arc=90 * DEG),\n",
        "            TransformFromCopy(a_label[0], new_a_label[0], path_arc=90 * DEG),\n",
        "            TransformFromCopy(mult_i_label[1], new_a_label[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[1], new_lines[1], path_arc=90 * DEG),\n",
        "            TransformFromCopy(b_label[0], new_b_label[:-1], path_arc=90 * DEG),\n",
        "            TransformFromCopy(mult_i_label[1], new_b_label[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FlashAround(VGroup(new_b_label, new_lines[1]), color=PINK, time_width=1.5, run_time=2),\n",
        "            new_b_label.animate.next_to(neg_b_label, LEFT, SMALL_BUFF),\n",
        "            FadeIn(neg_b_label, SMALL_BUFF * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(VGroup(new_lines[1], new_b_label, neg_b_label).animate.shift(new_lines[0].get_vector()))\n",
        "\n",
        "        # New vector\n",
        "        vect_copy = vect.copy()\n",
        "        elbow = Elbow().rotate(vect.get_angle(), about_point=ORIGIN)\n",
        "        self.play(\n",
        "            Rotate(vect_copy, 90 * DEG, run_time=2, about_point=ORIGIN),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(elbow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def old_material(self):\n",
        "        # Show the algebra\n",
        "        algebra = VGroup(\n",
        "            Tex(R\"i \\cdot (a + bi)\", **tex_kw),\n",
        "            Tex(R\"ai + bi^2\", **tex_kw),\n",
        "            Tex(R\"-b + ai\", **tex_kw),\n",
        "        )\n",
        "        algebra.set_backstroke(BLACK, 8)\n",
        "        algebra.arrange(DOWN, buff=0.35)\n",
        "        algebra.to_corner(UL)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(vect_label, algebra[0][\"a + bi\"][0]),\n",
        "            FadeIn(algebra[0]),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(algebra[0][\"a\"], algebra[1][\"a\"]),\n",
        "            TransformFromCopy(algebra[0][\"+ bi\"], algebra[1][\"+ bi\"]),\n",
        "            TransformFromCopy(algebra[0][\"i\"][0], algebra[1][\"i\"][0]),\n",
        "            TransformFromCopy(algebra[0][\"i\"][0], algebra[1][\"2\"]),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(algebra[1][\"bi^2\"], algebra[2][\"-b\"]),\n",
        "            TransformFromCopy(algebra[1][\"ai\"], algebra[2][\"ai\"]),\n",
        "            TransformFromCopy(algebra[1][\"+\"], algebra[2][\"+\"]),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # New lines\n",
        "        new_lines = lines.copy()\n",
        "        new_lines.rotate(90 * DEG)\n",
        "        new_lines.refresh_bounding_box()\n",
        "        new_lines[1].move_to(ORIGIN, RIGHT)\n",
        "        new_lines[0].move_to(new_lines[1].get_left(), DOWN)\n",
        "\n",
        "        neg_b_label = Tex(R\"-b\", fill_color=PINK, font_size=36).next_to(new_lines[1], UP, SMALL_BUFF)\n",
        "        new_a_label = Tex(R\"a\", fill_color=YELLOW, font_size=36).next_to(new_lines[0], LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[1], new_lines[1]),\n",
        "            FadeTransform(algebra[2][\"-b\"].copy(), neg_b_label),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[0], new_lines[0]),\n",
        "            FadeTransform(algebra[2][\"a\"].copy(), new_a_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UnitArcLengthsOnCircle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Moving sectors\n",
        "        arc = Arc(0, 1, radius=2.5, stroke_color=GREEN, stroke_width=8)\n",
        "        sector = Sector(angle=1, radius=2.5).set_fill(GREEN, 0.25)\n",
        "        v_line = Line(ORIGIN, 2.5 * UP)\n",
        "        v_line.match_style(arc)\n",
        "        v_line.move_to(arc.get_start(), DOWN)\n",
        "\n",
        "        self.add(v_line)\n",
        "        self.play(\n",
        "            FadeIn(sector),\n",
        "            ReplacementTransform(v_line, arc),\n",
        "        )\n",
        "\n",
        "        group = VGroup(sector, arc)\n",
        "        self.add(group)\n",
        "\n",
        "        for n in range(5):\n",
        "            self.wait(2)\n",
        "            group.rotate(1, about_point=ORIGIN)\n",
        "\n",
        "        return\n",
        "\n",
        "        # Previous\n",
        "        colors = [RED, BLUE]\n",
        "        arcs = VGroup(\n",
        "            Arc(n, 1, radius=2.5, stroke_color=colors[n % 2], stroke_width=8)\n",
        "            for n in range(6)\n",
        "        )\n",
        "        for arc in arcs:\n",
        "            one = Integer(1, font_size=24).move_to(1.0 * arc.get_center())\n",
        "            self.play(ShowCreation(arc, rate_func=linear, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleIndicationRect(InteractiveScene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(3, 2)\n",
        "        # Test\n",
        "        self.play(FlashAround(rect, time_width=2.0, run_time=2, color=WHITE))\n",
        "\n",
        "\n",
        "class WriteSPlane(InteractiveScene):\n",
        "    def construct(self):\n",
        "        title = Text(\"S-plane\", font_size=72)\n",
        "        title.set_color(YELLOW)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ODEStoExp(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        odes, exp = words = VGroup(\n",
        "            Text(\"Differential\\nEquations\"),\n",
        "            Tex(\"e^{st}\", t2c={\"s\": YELLOW}, font_size=72),\n",
        "        )\n",
        "        exp.match_height(odes)\n",
        "        words.arrange(RIGHT, buff=3.0)\n",
        "        words.to_edge(UP, buff=1.25)\n",
        "\n",
        "        top_arrow, low_arrow = arrows = VGroup(\n",
        "            Arrow(odes.get_corner(UR), exp.get_corner(UL), path_arc=-60 * DEG, thickness=5),\n",
        "            Arrow(exp.get_corner(DL), odes.get_corner(DR), path_arc=-60 * DEG, thickness=5),\n",
        "        )\n",
        "        arrows.set_fill(TEAL)\n",
        "\n",
        "        top_words = Tex(R\"Explain\", font_size=36).next_to(top_arrow, UP, SMALL_BUFF)\n",
        "        low_words = Tex(R\"Solves\", font_size=36).next_to(low_arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        exp.shift(0.25 * UP + 0.05 * LEFT)\n",
        "\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(top_arrow),\n",
        "            Write(top_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            # Write(low_arrow),\n",
        "            TransformFromCopy(top_arrow, low_arrow, path_arc=-PI),\n",
        "            Write(low_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GenLinearEquationToOscillator(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # General equation\n",
        "        a_texs = [\"a_n\", \"a_2\", \"a_1\", \"a_0\"]\n",
        "        x_texs = [\"x^{n}(t)\", \"x''(t)\", \"x'(t)\", \"x(t)\"]\n",
        "        x_colors = color_gradient([BLUE, TEAL], len(x_texs), interp_by_hsl=True)\n",
        "        t2c = dict()\n",
        "        t2c.update({a: WHITE for a in a_texs})\n",
        "        t2c.update({x: color for x, color in zip(x_texs, x_colors)})\n",
        "        ode = Tex(R\"a_n x^{n}(t) + \\cdots + a_2 x''(t) + a_1 x'(t) + a_0 x(t) = 0\", t2c=t2c, font_size=60)\n",
        "        ode.move_to(DOWN)\n",
        "        ode_2nd = ode[\"a_2 x''(t) + a_1 x'(t) + a_0 x(t) = 0\"]\n",
        "\n",
        "        self.play(Write(ode))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(ode[R\"a_n x^{n}(t) + \\cdots + \"]),\n",
        "            ode_2nd.animate.move_to(UP),\n",
        "            self.frame.animate.set_height(7)\n",
        "        )\n",
        "\n",
        "        # Transition\n",
        "        alt_consts = VGroup(Tex(R\"m\"), Tex(R\"\\mu\"), Tex(R\"k\"))\n",
        "        alt_consts.scale(60 / 48)\n",
        "        a_parts = VGroup(ode[tex][0] for tex in a_texs[1:])\n",
        "        for const, a_part in zip(alt_consts, a_parts):\n",
        "            const.move_to(a_part, RIGHT)\n",
        "            const.align_to(ode[-1], DOWN)\n",
        "            if const is alt_consts[1]:\n",
        "                const.shift(0.1 * DOWN)\n",
        "            self.play(\n",
        "                FadeOut(a_part, 0.25 * UP),\n",
        "                FadeIn(const, 0.25 * UP),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VLineOverZero(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        rect = Square(0.25)\n",
        "        rect.move_to(2.5 * DOWN)\n",
        "        v_line = Line(rect.get_top(), 4 * UP, buff=0.1)\n",
        "        v_line.set_stroke(YELLOW, 2)\n",
        "        rect.match_style(v_line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeOut(rect),\n",
        "            ShowCreationThenFadeOut(v_line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KIsSomeConstant(InteractiveScene):\n",
        "    def construct(self):\n",
        "        rect = SurroundingRectangle(Text(\"k\"), buff=0.05)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        words = Text(\"Some constant\", font_size=24)\n",
        "        words.next_to(rect, UP, SMALL_BUFF)\n",
        "        words.match_color(rect)\n",
        "\n",
        "        self.play(ShowCreation(rect), FadeIn(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WriteMu(InteractiveScene):\n",
        "    def construct(self):\n",
        "        sym = Tex(R\"\\mu\")\n",
        "        rect = SurroundingRectangle(sym, buff=0.05)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        mu = TexText(\"``Mu''\")\n",
        "        mu.set_color(YELLOW)\n",
        "        mu.next_to(rect, DOWN)\n",
        "        self.play(\n",
        "            Write(mu),\n",
        "            ShowCreation(rect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReferenceGuessingExp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.remove(self.background)\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.body.insert_n_curves(100)\n",
        "\n",
        "        # Student asks\n",
        "        question = Tex(R\"x(t) = ???\")\n",
        "        lhs = question[\"x(t)\"][0]\n",
        "        rhs = question[\"= ???\"][0]\n",
        "        bubble = stds[2].get_bubble(question, bubble_type=SpeechBubble, direction=LEFT)\n",
        "        lhs.save_state()\n",
        "        lhs.scale(0.25).move_to([-6.24, 2.38, 0])\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"hesitant\", look_at=stds[2].eyes),\n",
        "            self.change_students(\"erm\", \"confused\", \"maybe\", look_at=self.screen)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            stds[2].change(\"raise_left_hand\", morty.eyes),\n",
        "            Write(bubble[0]),\n",
        "            Write(rhs, time_span=(0.5, 1.0)),\n",
        "            Restore(lhs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(Point())\n",
        "        self.play(\n",
        "            morty.says(\"Here's a trick:\", mode=\"tease\", bubble_creation_class=FadeIn),\n",
        "            self.change_students(\"pondering\", \"thinking\", \"hesitant\", look_at=UL),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Teacher gestures to upper right, students look confused and hesitant\n",
        "        eq_point = 5 * RIGHT + 3 * UP\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\", look_at=eq_point),\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(morty.bubble),\n",
        "            self.change_students(\"confused\", \"thinking\", \"hesitant\", look_at=eq_point),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.change_students(\"confused\", \"hesitant\", \"confused\", look_at=eq_point, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"shruggie\", look_at=eq_point),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.change_students(\"angry\", \"hesitant\", \"erm\", look_at=morty.eyes),\n",
        "            morty.animate.look_at(stds)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Transition: flip and reposition morty to where stds are\n",
        "        new_teacher_pos = stds[2].get_bottom()\n",
        "        new_teacher = morty.copy()\n",
        "        new_teacher.change_mode(\"raise_left_hand\")\n",
        "        new_teacher.look_at(3 * UR)\n",
        "        new_teacher.body.set_color(GREY_C)\n",
        "\n",
        "        self.play(\n",
        "            morty.animate.scale(0.8).flip().change_mode(\"confused\").look_at(5 * UR).move_to(new_teacher_pos, DOWN),\n",
        "            LaggedStartMap(FadeOut, stds, shift=DOWN, lag_ratio=0.2, run_time=1),\n",
        "            FadeIn(new_teacher, time_span=(0.5, 1.5)),\n",
        "        )\n",
        "        self.play(morty.change(\"pleading\", 3 * UR))\n",
        "        self.play(Blink(new_teacher))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(\n",
        "            morty.change(\"erm\", new_teacher.eyes),\n",
        "            new_teacher.change(\"guilty\", look_at=morty.eyes),\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Reference a graph\n",
        "        self.play(\n",
        "            morty.change(\"angry\", 2 * UR),\n",
        "            new_teacher.change(\"tease\", 2 * UR)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Blink(new_teacher))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FromGuessToLaplace(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Words\n",
        "        strategy = VGroup(\n",
        "            Text(\"\u201cStrategy\u201d\", fill_color=GREY_A, font_size=72),\n",
        "            TexText(\"Guess $x(t) = e^{{s}t}$\", t2c={\"{s}\": YELLOW}, fill_color=WHITE, font_size=72),\n",
        "        )\n",
        "        strategy.arrange(DOWN)\n",
        "        self.add(strategy)\n",
        "        return\n",
        "\n",
        "        # Comment on it\n",
        "        exp_rect = SurroundingRectangle(strategy[1][\"x(t) = e^{{s}t}\"], buff=SMALL_BUFF)\n",
        "        exp_words = Text(\"Why?\", font_size=42)\n",
        "        exp_words.next_to(exp_rect, RIGHT, SMALL_BUFF)\n",
        "        VGroup(exp_rect, exp_words).set_color(PINK)\n",
        "\n",
        "        guess_rect = SurroundingRectangle(strategy[1][\"Guess\"], buff=SMALL_BUFF)\n",
        "        guess_rect.match_height(exp_rect, stretch=True).match_y(exp_rect)\n",
        "        guess_words = Text(\"Seems dumb\", font_size=36)\n",
        "        guess_words.next_to(guess_rect, DOWN, SMALL_BUFF)\n",
        "        VGroup(guess_rect, guess_words).set_color(RED)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(guess_rect),\n",
        "            FadeIn(guess_words, lag_ratio=0.1),\n",
        "            ShowCreation(exp_rect),\n",
        "            FadeIn(exp_words, lag_ratio=0.1),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to Laplace\n",
        "        laplace = Tex(R\"\\int_0^\\infty x(t) e^{-{s}t} dt\", t2c={\"{s}\": YELLOW}, font_size=72)\n",
        "        laplace.move_to(strategy[1])\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            LaggedStartMap(FadeOut, VGroup(strategy[1][\"Guess\"], guess_rect, guess_words), shift=DOWN, lag_ratio=0.1),\n",
        "            TransformFromCopy(strategy[0][\"S\"][0], laplace[R\"\\int\"][0]),\n",
        "            TransformFromCopy(strategy[0][\"e\"][0], laplace[R\"0\"][0]),\n",
        "            TransformFromCopy(strategy[0][\"g\"][0], laplace[R\"\\infty\"][0]),\n",
        "            FadeOut(strategy[0], lag_ratio=0.1),\n",
        "            # Break\n",
        "            FadeOut(VGroup(exp_rect, exp_words), 0.5 * LEFT, lag_ratio=0.1),\n",
        "            FadeTransform(strategy[1][\"x(t)\"][0], laplace[\"x(t)\"][0]),\n",
        "            FadeTransform(strategy[1][\"=\"][0], laplace[\"-\"][0]),\n",
        "            FadeTransform(strategy[1][\"e\"][-1], laplace[\"e\"][0]),\n",
        "            FadeTransform(strategy[1][\"{s}t\"][0], laplace[\"{s}t\"][0]),\n",
        "            Write(laplace[\"dt\"][0]),\n",
        "            lag_ratio=0.15,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Label laplace\n",
        "        laplace_rect = SurroundingRectangle(laplace)\n",
        "        laplace_rect.set_color(BLUE)\n",
        "        laplace_label = Text(\"Laplace Transform\", font_size=72)\n",
        "        laplace_label.next_to(laplace_rect, UP)\n",
        "        laplace_label.match_color(laplace_rect)\n",
        "\n",
        "        self.play(\n",
        "            Write(laplace_label),\n",
        "            ShowCreation(laplace_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class JustAlgebra(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = Mortimer(mode=\"tease\")\n",
        "        morty.body.insert_n_curves(100)\n",
        "        self.play(morty.says(\"Just algebra!\", mode=\"hooray\", look_at=2 * UL))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(morty.bubble),\n",
        "            morty.change(\"tease\", look_at=2 * UL + UP)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BothPositiveNumbers(InteractiveScene):\n",
        "    def construct(self):\n",
        "        tex = Tex(\"k / m\")\n",
        "        self.add(tex)\n",
        "\n",
        "        # Test\n",
        "        rects = VGroup(SurroundingRectangle(tex[c], buff=0.05) for c in \"km\")\n",
        "        rects.set_stroke(GREEN, 3)\n",
        "        plusses = VGroup(Tex(R\"+\").next_to(rect, DOWN, SMALL_BUFF) for rect in rects)\n",
        "        plusses.set_fill(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, rects, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, plusses, shift=0.25 * DOWN, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ButSpringsAreReal(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.play(\n",
        "            stds[0].change(\"maybe\", self.screen),\n",
        "            stds[1].says(\"But...springs are real\", mode=\"confused\", look_at=self.screen),\n",
        "            stds[2].change(\"erm\", self.screen),\n",
        "            morty.change(\"tease\", stds[2].eyes)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class ShowIncreaseToK(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        k = Tex(R\"k\")\n",
        "\n",
        "        box = SurroundingRectangle(k)\n",
        "        box.set_stroke(GREEN, 5)\n",
        "        arrow = Vector(UP, thickness=6)\n",
        "        arrow.set_fill(GREEN)\n",
        "        center = box.get_center()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(box),\n",
        "            UpdateFromAlphaFunc(\n",
        "                arrow, lambda m, a: m.move_to(\n",
        "                    center + interpolate(-1, 1, a) * UP\n",
        "                ).set_fill(\n",
        "                    opacity=there_and_back(a) * 0.7\n",
        "                ),\n",
        "                run_time=4\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PureMathEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        t2c = {\"x''(t)\": RED, \"x(t)\": TEAL, R\"\\omega\": PINK}\n",
        "        physics_eq = Tex(R\"m x''(t) + k x(t) = 0\", t2c=t2c, font_size=72)\n",
        "        math_eq = Tex(R\"a_2 x''(t) + a_0 x(t) = 0\", t2c=t2c, font_size=72)\n",
        "\n",
        "        self.add(physics_eq)\n",
        "        self.play(LaggedStart(\n",
        "            *(\n",
        "                ReplacementTransform(physics_eq[tex][0], math_eq[tex][0])\n",
        "                for tex in [\"x''(t) +\", \"x(t) = 0\"]\n",
        "            ),\n",
        "            FadeOut(physics_eq[\"m\"], 0.5 * UP),\n",
        "            FadeIn(math_eq[\"a_2\"], 0.5 * UP),\n",
        "            FadeOut(physics_eq[\"k\"], 0.5 * UP),\n",
        "            FadeIn(math_eq[\"a_0\"], 0.5 * UP),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.15\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show solution\n",
        "        implies = Tex(R\"\\Downarrow\", font_size=72)\n",
        "        answer = Tex(R\"e^{\\pm i\\omega t}\", font_size=90, t2c=t2c)\n",
        "        answer.next_to(implies, DOWN, MED_LARGE_BUFF)\n",
        "        omega_eq = Tex(R\"\\text{Where } \\omega = \\sqrt{a_2 / a_0}\", t2c=t2c)\n",
        "        omega_eq.next_to(answer, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            math_eq.animate.next_to(implies, UP, MED_LARGE_BUFF),\n",
        "            Write(implies),\n",
        "            FadeIn(answer, DOWN),\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "        self.play(FadeIn(omega_eq))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LinearityDefinition(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Base differential equation string\n",
        "        eq_str = R\"m x''(t) + k x(t) = 0\"\n",
        "        t2c = {\"x_1\": TEAL, \"x_2\": RED, \"0.0\": YELLOW, \"2.0\": YELLOW}\n",
        "\n",
        "        base_eq = Tex(eq_str)\n",
        "        base_eq.to_edge(UP)\n",
        "\n",
        "        eq1, eq2, eq3, eq4 = equations = VGroup(\n",
        "            Tex(eq_str.replace(\"x\", \"x_1\"), t2c=t2c),\n",
        "            Tex(eq_str.replace(\"x\", \"x_2\"), t2c=t2c),\n",
        "            Tex(R\"m\\Big(x_1''(t) + x_2''(t) \\Big) + k \\Big(x_1(t) + x_2(t)\\Big) = 0\", t2c=t2c),\n",
        "            Tex(R\"m\\Big(0.0 x_1''(t) + 2.0 x_2''(t) \\Big) + k \\Big(0.0 x_1(t) + 2.0 x_2(t)\\Big) = 0\", t2c=t2c),\n",
        "        )\n",
        "        for eq in equations:\n",
        "            eq.set_max_width(7)\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        equations.to_edge(RIGHT)\n",
        "        equations.shift(DOWN)\n",
        "\n",
        "        phrase1, phrase2, phrase3, phrase4 = phrases = VGroup(\n",
        "            TexText(\"If $x_1$ solves it:\", t2c=t2c),\n",
        "            TexText(\"and $x_2$ solves it:\", t2c=t2c),\n",
        "            TexText(\"Then $(x_1 + x_2)$ solves it:\", t2c=t2c),\n",
        "            TexText(\"Then $(0.0 x_1 + 2.0 x_2)$ solves it:\", t2c=t2c),\n",
        "        )\n",
        "\n",
        "        for phrase, eq in zip(phrases, equations):\n",
        "            phrase.set_max_width(5)\n",
        "            phrase.next_to(eq, LEFT, LARGE_BUFF)\n",
        "\n",
        "        eq4.move_to(eq3)\n",
        "        phrase4.move_to(phrase3)\n",
        "\n",
        "        kw = dict(edge_to_fix=RIGHT)\n",
        "        c1_terms = VGroup(phrase4.make_number_changeable(\"0.0\", **kw), *eq4.make_number_changeable(\"0.0\", replace_all=True, **kw))\n",
        "        c2_terms = VGroup(phrase4.make_number_changeable(\"2.0\", **kw), *eq4.make_number_changeable(\"2.0\", replace_all=True, **kw))\n",
        "\n",
        "        # Show base equation\n",
        "        self.play(Write(phrase1), FadeIn(eq1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(eq1.copy(), eq2, key_map={\"x_1\": \"x_2\"}, run_time=1, lag_ratio=0.01),\n",
        "            FadeTransform(phrase1.copy(), phrase2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(phrase3, DOWN),\n",
        "            FadeIn(eq3, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(eq3, 0.5 * DOWN),\n",
        "            FadeOut(phrase3, 0.5 * DOWN),\n",
        "            FadeIn(eq4, 0.5 * DOWN),\n",
        "            FadeIn(phrase4, 0.5 * DOWN),\n",
        "        )\n",
        "        for _ in range(8):\n",
        "            new_c1 = random.random() * 10\n",
        "            new_c2 = random.random() * 10\n",
        "            self.play(*(\n",
        "                ChangeDecimalToValue(c1, new_c1, run_time=1)\n",
        "                for c1 in c1_terms\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "            self.play(*(\n",
        "                ChangeDecimalToValue(c2, new_c2, run_time=1)\n",
        "                for c2 in c2_terms\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class ComplainAboutNeelessComplexity(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "\n",
        "        # Complain\n",
        "        self.play(\n",
        "            stds[0].change(\"confused\", self.screen),\n",
        "            stds[1].says(\"That\u2019s needlessly\\ncomplicated!\", mode=\"angry\", look_at=self.screen),\n",
        "            stds[2].change(\"maybe\", self.screen),\n",
        "            morty.change(\"guilty\"),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            stds[0].change(\"erm\", self.screen),\n",
        "            stds[1].debubble(mode=\"raise_left_hand\", look_at=self.screen),\n",
        "            stds[2].change(\"sassy\", self.screen),\n",
        "            morty.change(\"tease\"),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            stds[1].change(\"raise_right_hand\", ORIGIN),\n",
        "            stds[0].change(\"pondering\", ORIGIN),\n",
        "            stds[2].change(\"pondering\", ORIGIN),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class LetsGeneralize(InteractiveScene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        self.play(\n",
        "            morty.says(\"Let\u2019s\\n  generalize!\", mode=\"hooray\")\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class EquationRect(InteractiveScene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(5.25, 1)\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "\n",
        "        # Test\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.stretch(0.5, 0).shift(4 * RIGHT).set_opacity(0))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GeneralLinearEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up equations\n",
        "        a_texs = [\"a_n\", \"a_2\", \"a_1\", \"a_0\"]\n",
        "        x_texs = [\"x^{n}(t)\", \"x''(t)\", \"x'(t)\", \"x(t)\"]\n",
        "        x_colors = color_gradient([BLUE, TEAL], len(x_texs), interp_by_hsl=True)\n",
        "        t2c = {\"{s}\": YELLOW}\n",
        "        t2c.update({a: WHITE for a in a_texs})\n",
        "        t2c.update({x: color for x, color in zip(x_texs, x_colors)})\n",
        "        ode = Tex(R\"a_n x^{n}(t) + \\cdots + a_2 x''(t) + a_1 x'(t) + a_0 x(t) = 0\", t2c=t2c)\n",
        "        exp_version = Tex(\n",
        "            R\"a_n \\left({s}^n e^{{s}t}\\right) \"\n",
        "            R\"+ \\cdots \"\n",
        "            R\"+ a_2 \\left({s}^2 e^{{s}t}\\right) \"\n",
        "            R\"+ a_1 \\left({s}e^{{s}t}\\right) \"\n",
        "            R\"+ a_0 e^{{s}t} = 0\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        factored = Tex(R\"e^{{s}t} \\left(a_n {s}^n + \\cdots + a_2 {s}^2 + a_1 {s} + a_0 \\right) = 0\", t2c=t2c)\n",
        "\n",
        "        ode.to_edge(UP)\n",
        "        exp_version.next_to(ode, DOWN, MED_LARGE_BUFF)\n",
        "        factored.move_to(exp_version)\n",
        "\n",
        "        # Introduce ode\n",
        "        index = ode.submobjects.index(ode[\"a_2\"][0][0])\n",
        "\n",
        "        right_part = ode[index:]\n",
        "        left_part = ode[:index]\n",
        "        right_part.save_state()\n",
        "        right_part.set_x(0)\n",
        "\n",
        "        self.play(FadeIn(right_part, UP))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            Restore(right_part),\n",
        "            Write(left_part)\n",
        "        ))\n",
        "        self.add(ode)\n",
        "\n",
        "        # Highlight equation parts\n",
        "        x_arrows = VGroup(\n",
        "            Arrow(UP, ode[x_tex].get_bottom(), fill_color=color)\n",
        "            for x_tex, color in zip(x_texs, x_colors)\n",
        "        )\n",
        "        x_arrows.reverse_submobjects()\n",
        "\n",
        "        x_rects = VGroup(SurroundingRectangle(ode[x_tex], buff=SMALL_BUFF) for x_tex in x_texs)\n",
        "        a_rects = VGroup(SurroundingRectangle(ode[a_tex]) for a_tex in a_texs)\n",
        "        full_rect = SurroundingRectangle(ode[:-2])\n",
        "        zero_rect = SurroundingRectangle(ode[-2:])\n",
        "        VGroup(x_rects, a_rects, full_rect, zero_rect).set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, x_rects))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(x_rects, a_rects, lag_ratio=0.2))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(a_rects, VGroup(full_rect)))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(full_rect, zero_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(zero_rect))\n",
        "\n",
        "        # Plug in e^{st}\n",
        "        key_map = {\n",
        "            R\"+ a_0 x(t) = 0\": R\"+ a_0 e^{{s}t} = 0\",\n",
        "            R\"+ a_1 x'(t)\": R\"+ a_1 \\left({s}e^{{s}t}\\right)\",\n",
        "            R\"+ a_2 x''(t)\": R\"+ a_2 \\left({s}^2 e^{{s}t}\\right)\",\n",
        "            R\"+ \\cdots\": R\"+ \\cdots\",\n",
        "            R\"a_n x^{n}(t)\": R\"a_n \\left({s}^n e^{{s}t}\\right)\",\n",
        "        }\n",
        "\n",
        "        self.play(LaggedStart(*(\n",
        "            FadeTransform(ode[k1].copy(), exp_version[k2])\n",
        "            for k1, k2 in key_map.items()\n",
        "        ), lag_ratio=0.6, run_time=4))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                exp_version,\n",
        "                factored,\n",
        "                matched_keys=[R\"e^{{s}t}\", \"{s}^n\", \"{s}^2\", \"{s}\", \"a_n\", \"a_2\", \"a_1\", \"a_0\"],\n",
        "                path_arc=45 * DEG\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight the polynomail\n",
        "        poly_rect = SurroundingRectangle(factored[R\"a_n {s}^n + \\cdots + a_2 {s}^2 + a_1 {s} + a_0\"])\n",
        "        poly_rect.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(poly_rect),\n",
        "            FadeOut(factored[\"e^{{s}t}\"]),\n",
        "            FadeOut(factored[R\"\\left(\"]),\n",
        "            FadeOut(factored[R\"\\right)\"]),\n",
        "        )\n",
        "\n",
        "        # Show factored expression\n",
        "        linear_term_texs = [\n",
        "            R\"({s} - s_1)\",\n",
        "            R\"({s} - s_2)\",\n",
        "            R\"({s} - s_3)\",\n",
        "            R\"\\cdots\",\n",
        "            R\"({s} - s_n)\",\n",
        "        ]\n",
        "        fully_factored = Tex(\n",
        "            R\"a_n\" + \" \".join(linear_term_texs),\n",
        "            t2c=t2c,\n",
        "            font_size=42,\n",
        "            isolate=linear_term_texs\n",
        "        )\n",
        "        fully_factored.next_to(poly_rect, DOWN)\n",
        "        linear_terms = VGroup(\n",
        "            fully_factored[tex][0]\n",
        "            for tex in linear_term_texs\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(factored[\"{s}\"][1].copy().replicate(4), fully_factored[\"{s}\"].copy(), remover=True),\n",
        "            FadeIn(fully_factored, time_span=(0.25, 1)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Plane\n",
        "        plane = ComplexPlane((-3, 3), (-3, 3), width=6, height=6)\n",
        "        plane.set_height(4.5)\n",
        "        plane.next_to(poly_rect, DOWN, LARGE_BUFF)\n",
        "        plane.set_x(0)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "        c_label = Tex(R\"\\mathds{C}\", font_size=90, fill_color=BLUE)\n",
        "        c_label.next_to(plane, LEFT, aligned_edge=UP).shift(0.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(plane, run_time=1, lag_ratio=2e-2),\n",
        "            Write(c_label),\n",
        "        )\n",
        "\n",
        "        # Show some random root collections\n",
        "        for n in range(4):\n",
        "            roots = []\n",
        "            n_roots = random.randint(3, 7)\n",
        "            for _ in range(n_roots):\n",
        "                root = complex(random.uniform(-3, 3), random.uniform(-3, 3))\n",
        "                if random.random() < 0.25:\n",
        "                    roots.append(root.real)\n",
        "                else:\n",
        "                    roots.extend([root, root.conjugate()])\n",
        "            dots = Group(GlowDot(plane.n2p(z)) for z in roots)\n",
        "\n",
        "            self.play(ShowIncreasingSubsets(dots))\n",
        "            self.play(FadeOut(dots))\n",
        "\n",
        "        # Turn linear terms into\n",
        "        roots = [0.2 + 1j, 0.2 - 1j, -0.5 + 3j, -0.5 - 3j, -2]\n",
        "        root_dots = Group(GlowDot(plane.n2p(root)) for root in roots)\n",
        "\n",
        "        root_labels = VGroup(\n",
        "            Tex(Rf\"s_{{{n + 1}}}\", font_size=36).next_to(dot.get_center(), UR, SMALL_BUFF)\n",
        "            for n, dot in enumerate(root_dots)\n",
        "        )\n",
        "        root_labels.set_color(YELLOW)\n",
        "\n",
        "        root_intro_kw = dict(lag_ratio=0.3, run_time=4)\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(term, dot)\n",
        "                for term, dot in zip(linear_terms, root_dots)\n",
        "            ), **root_intro_kw),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(term[3:5], label)\n",
        "                for term, label in zip(linear_terms, root_labels)\n",
        "            ), **root_intro_kw),\n",
        "            FadeOut(fully_factored[\"a_n\"][0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the solutions\n",
        "        frame = self.frame\n",
        "        axes = VGroup(\n",
        "            Axes((0, 10), (-y_max, y_max), width=5, height=1.25)\n",
        "            for root in roots\n",
        "            for y_max in [3 if root.real > 0 else 1]\n",
        "        )\n",
        "        axes.arrange(DOWN, buff=0.75)\n",
        "        axes.next_to(plane, RIGHT, buff=6)\n",
        "\n",
        "        c_trackers = Group(ComplexValueTracker(1) for root in roots)\n",
        "        graphs = VGroup(\n",
        "            self.get_graph(axes, root, c_tracker.get_value)\n",
        "            for axes, root, c_tracker in zip(axes, roots, c_trackers)\n",
        "        )\n",
        "\n",
        "        axes_labels = VGroup(\n",
        "            Tex(Rf\"e^{{s_{{{n + 1}}} t}}\", font_size=60)\n",
        "            for n in range(len(axes))\n",
        "        )\n",
        "        for label, ax in zip(axes_labels, axes):\n",
        "            label.next_to(ax, LEFT, aligned_edge=UP)\n",
        "            label[1:3].set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes, lag_ratio=0.2),\n",
        "            frame.animate.reorient(0, 0, 0, (4.67, -0.94, 0.0), 10.96),\n",
        "            LaggedStart(\n",
        "                (FadeTransform(m1.copy(), m2) for m1, m2 in zip(root_labels, axes_labels)),\n",
        "                lag_ratio=0.05,\n",
        "                group_type=Group\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        rect = Square(side_length=1e-3).move_to(plane.n2p(0))\n",
        "        rect.set_stroke(TEAL, 3)\n",
        "        for root_label, graph in zip(root_labels, graphs):\n",
        "            self.play(\n",
        "                ShowCreation(graph, time_span=(0.5, 2.0), suspend_mobject_updating=True),\n",
        "                rect.animate.surround(root_label, buff=0.1),\n",
        "            )\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Add on constants\n",
        "        constant_labels = VGroup(\n",
        "            Tex(Rf\"c_{{{n + 1}}}\", font_size=60).next_to(label[0], LEFT, SMALL_BUFF, aligned_edge=UP)\n",
        "            for n, label in enumerate(axes_labels)\n",
        "        )\n",
        "        constant_labels.set_color(BLUE_B)\n",
        "        target_values = [0.5, 0.25, 1.5, -1.5, -1]\n",
        "\n",
        "        solution_rect = SurroundingRectangle(VGroup(axes_labels, axes, constant_labels), buff=MED_SMALL_BUFF)\n",
        "        solution_rect.set_stroke(WHITE, 1)\n",
        "        solution_words = Text(\"All Solutions\", font_size=60)\n",
        "        solution_words.next_to(solution_rect, UP)\n",
        "        solution_word = solution_words[\"Solutions\"][0]\n",
        "        solution_word.save_state(0)\n",
        "        solution_word.match_x(solution_rect)\n",
        "\n",
        "        const_rects = VGroup(SurroundingRectangle(c_label) for c_label in constant_labels)\n",
        "        const_rects.set_stroke(BLUE, 3)\n",
        "\n",
        "        plusses = Tex(\"+\").replicate(4)\n",
        "        for l1, l2, plus in zip(axes_labels, axes_labels[1:], plusses):\n",
        "            plus.move_to(VGroup(l1, l2)).shift(SMALL_BUFF * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(solution_rect),\n",
        "            Write(solution_word),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, constant_labels, lag_ratio=0.5),\n",
        "            LaggedStart(*(\n",
        "                c_tracker.animate.set_value(value)\n",
        "                for c_tracker, value in zip(c_trackers, target_values)\n",
        "            ), lag_ratio=0.5),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, plusses),\n",
        "            Write(solution_words[\"All\"]),\n",
        "            Restore(solution_word),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Play with constants\n",
        "        self.play(LaggedStartMap(ShowCreation, const_rects, lag_ratio=0.15))\n",
        "        value_sets = [\n",
        "            [1, 1, 1, 1, 1],\n",
        "            [1j, -1j, 1 + 1j, -1 + 1j, -0.5],\n",
        "            [-0.5, 1j, 1j, 1 + 1j, -1],\n",
        "        ]\n",
        "        for values in value_sets:\n",
        "            self.play(\n",
        "                LaggedStart(*(\n",
        "                    c_tracker.animate.set_value(value)\n",
        "                    for c_tracker, value in zip(c_trackers, values)\n",
        "                ), lag_ratio=0.25, run_time=3)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, const_rects, lag_ratio=0.25))\n",
        "        self.wait()\n",
        "\n",
        "    def get_graph(self, axes, s, get_const):\n",
        "        def func(t):\n",
        "            return (get_const() * np.exp(s * t)).real\n",
        "\n",
        "        graph = axes.get_graph(func, bind=True, stroke_color=TEAL, stroke_width=2)\n",
        "        return graph\n",
        "\n",
        "\n",
        "class HoldUpGeneralLinear(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.body.insert_n_curves(500)\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            self.change_students(\"pondering\", \"thinking\", \"tease\", look_at=3 * UR)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"sassy\", look_at=3 * UR),\n",
        "            self.change_students(\"hesitant\", \"erm\", \"maybe\")\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class BigCross(InteractiveScene):\n",
        "    def construct(self):\n",
        "        cross = Cross(Rectangle(4, 1.5))\n",
        "        cross.set_stroke(RED, width=(0, 8, 8, 8, 0))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DifferentialEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # ode to x\n",
        "        x_term = Tex(R\"x(t)\", font_size=90)\n",
        "        arrow = Vector(DOWN, thickness=5)\n",
        "        arrow.move_to(ORIGIN, DOWN)\n",
        "        words = Text(\"Differential Equation\", font_size=72)\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.play(Write(x_term))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(words),\n",
        "            x_term.animate.next_to(arrow, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DumbTrickAlgebra(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class LaplaceTransformAlgebra(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add equation\n",
        "        colors = color_gradient([TEAL, RED], 3, interp_by_hsl=True)\n",
        "        t2c = {\n",
        "            R\"x(t)\": colors[0],\n",
        "            R\"x'(t)\": colors[1],\n",
        "            R\"x''(t)\": colors[2],\n",
        "            \"{s}\": YELLOW,\n",
        "        }\n",
        "        equation = Tex(\n",
        "            R\"{m} x''(t) + \\mu x'(t) + k x(t) = F_0 \\cos(\\omega_l t)\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        equation.to_edge(UP, buff=1.5)\n",
        "\n",
        "        arrow = Vector(1.25 * DOWN, thickness=6)\n",
        "        arrow.next_to(equation, DOWN)\n",
        "        arrow_label = Tex(R\"\\mathcal{L}\", font_size=72)\n",
        "        arrow_label.next_to(arrow, RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(arrow_label, shift=0.5 * DOWN)\n",
        "        )\n",
        "\n",
        "        # Make transformed\n",
        "        transformed_eq = Tex(\n",
        "            R\"{m} {s}^2 X({s}) + \\mu {s} X({s}) + k X({s}) = \\frac{F_0 {s}}{{s}^2 + \\omega_l^2}\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        transformed_eq.next_to(arrow, DOWN)\n",
        "\n",
        "        xt_texs = [\"x(t)\", \"x'(t)\", \"x''(t)\"]\n",
        "        Xs_texs = [\"X({s})\", \"{s} X({s})\", \"{s}^2 X({s})\"]\n",
        "\n",
        "        rects = VGroup()\n",
        "        srcs = VGroup()\n",
        "        trgs = VGroup()\n",
        "        for t1, t2, color in zip(xt_texs, Xs_texs, colors):\n",
        "            src = equation[t1][0]\n",
        "            trg = transformed_eq[t2][-1]\n",
        "            rect = SurroundingRectangle(src, buff=0.05)\n",
        "            rect.set_stroke(color, 2)\n",
        "            rect.target = rect.generate_target()\n",
        "            rect.target.surround(trg, buff=0.05)\n",
        "\n",
        "            rects.add(rect)\n",
        "            srcs.add(src.copy())\n",
        "            trgs.add(trg)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, rects, lag_ratio=0.25, run_time=1.5))\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *(FadeTransform(src, trg)\n",
        "                for src, trg in zip(srcs, trgs)),\n",
        "                lag_ratio=0.25,\n",
        "                group_type=Group,\n",
        "                run_time=1.5\n",
        "            ),\n",
        "            LaggedStartMap(MoveToTarget, rects, lag_ratio=0.25, run_time=1.5)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(equation[tex], transformed_eq[tex][:2])\n",
        "                for tex in [\"{m}\", \"+\", R\"\\mu\", \"k\", \"=\"]\n",
        "            )),\n",
        "            TransformMatchingParts(\n",
        "                equation[R\"F_0 \\cos(\\omega_l t)\"].copy(),\n",
        "                transformed_eq[R\"\\frac{F_0 {s}}{{s}^2 + \\omega_l^2}\"]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Factor it\n",
        "        factored = Tex(\n",
        "            R\"X({s}) \\left({m} {s}^2+ \\mu {s} + k\\right) = \\frac{F_0 {s}}{{s}^2 + \\omega_l^2}\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        factored.move_to(transformed_eq)\n",
        "        left_rect = SurroundingRectangle(factored[\"X({s})\"], buff=0.05)\n",
        "        left_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                transformed_eq,\n",
        "                factored,\n",
        "                matched_keys=[\"X({s})\"],\n",
        "                path_arc=30 * DEG\n",
        "            ),\n",
        "            ReplacementTransform(rects, VGroup(left_rect), path_arc=30 * DEG),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeOut(left_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Rearrange\n",
        "        rearranged = Tex(\n",
        "            R\"X({s}) = \\frac{F_0 {s}}{{s}^2 + \\omega_l^2} \\frac{1}{{m} {s}^2+ \\mu {s} + k}\",\n",
        "            t2c=t2c\n",
        "        )\n",
        "        rearranged.next_to(factored, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                factored.copy(),\n",
        "                rearranged,\n",
        "                matched_keys=[\"X({s})\"],\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "class ContrastDumbTrickAndLT(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        kw = dict(font_size=60)\n",
        "        titles = VGroup(\n",
        "            Text(\"Dumb trick\", **kw),\n",
        "            Text(\"Laplace Transform\", **kw),\n",
        "        )\n",
        "        underlines = VGroup()\n",
        "        for x, title in zip([-1, 1], titles):\n",
        "            title.set_x(x * FRAME_WIDTH / 4)\n",
        "            title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "            underlines.add(Underline(title))\n",
        "        underlines[0].scale(1.25)\n",
        "        underlines[1].shift(SMALL_BUFF * UP)\n",
        "\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, titles[::-1], lag_ratio=0.5),\n",
        "            LaggedStartMap(ShowCreation, underlines[::-1], lag_ratio=0.5),\n",
        "            ShowCreation(v_line, time_span=(0.5, 2.0)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DifferentialEquationToAlgebra(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Associations\n",
        "        t2c = {\"{s}\": YELLOW}\n",
        "        arrow = Vector(1.5 * RIGHT, thickness=5)\n",
        "        words = VGroup(Text(\"ODE\"), Text(\"Algebra\"))\n",
        "        symbols = VGroup(Tex(R\"d / dt\"), Tex(R\"\\times {s}\", t2c=t2c))\n",
        "        for group in words, symbols:\n",
        "            for mob, vect in zip(group, [LEFT, RIGHT]):\n",
        "                mob.next_to(arrow, vect)\n",
        "\n",
        "        deriv_eq = Tex(R\"\\frac{d}{dt} e^{{s}t} = {s} e^{{s} t}\", t2c=t2c, font_size=36)\n",
        "        deriv_eq.next_to(arrow, UP, buff=0.25)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(words[0], lag_ratio=0.1),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(words[1], 0.25 * RIGHT),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words[0], 0.5 * UP),\n",
        "            FadeIn(symbols[0], 0.5 * UP),\n",
        "            FadeIn(deriv_eq)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(words[1], 0.5 * UP),\n",
        "            FadeIn(symbols[1], 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleExp(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(Tex(R\"e^{st}\", t2c={\"s\": YELLOW}, font_size=60))\n",
        "\n",
        "\n",
        "class AtomsOfCalculus(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        expr = Tex(R\"e^{s_n t}\", font_size=72)\n",
        "        expr.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        rect = SurroundingRectangle(expr, buff=SMALL_BUFF)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "        words = Text(\"Atoms of\\nCalculus\", font_size=60)\n",
        "        words.set_x(FRAME_WIDTH / 5)\n",
        "        words.set_y(3)\n",
        "        arrow = Arrow(words.get_right(), rect.get_top(), path_arc=-90 * DEG, thickness=4)\n",
        "        arrow.set_fill(YELLOW)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            Write(words),\n",
        "            Write(arrow),\n",
        "            ShowCreation(rect)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(SideScrollEndScreen):\n",
        "    pass"
    ]
}