{
    "topic": "is demonstrating the concept of a discrete boundary value problem for the heat equation.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part2.heat_equation import *\n",
        "\n",
        "\n",
        "class ShowNewRuleAtDiscreteBoundary(DiscreteSetup):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": 0,\n",
        "            \"stroke_width\": 1,\n",
        "            \"x_axis_config\": {\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "        },\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "        ],\n",
        "        \"v_line_class\": DashedLine,\n",
        "        \"v_line_config\": {\n",
        "\n",
        "        },\n",
        "        \"step_size\": 1,\n",
        "        \"wait_time\": 15,\n",
        "        \"alpha\": 0.25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.set_points()\n",
        "        self.show_boundary_point_influenced_by_neighbor()\n",
        "        self.add_clock()\n",
        "        self.let_evolve()\n",
        "\n",
        "    def set_points(self):\n",
        "        axes = self.axes\n",
        "        for mob in axes.family_members_with_points():\n",
        "            if isinstance(mob, Line):\n",
        "                mob.set_stroke(width=1)\n",
        "\n",
        "        step_size = self.step_size\n",
        "        xs = np.arange(\n",
        "            axes.x_min,\n",
        "            axes.x_max + step_size,\n",
        "            step_size\n",
        "        )\n",
        "\n",
        "        dots = self.dots = self.get_dots(axes, xs)\n",
        "        self.v_lines = self.get_v_lines(dots)\n",
        "        self.rod_pieces = self.get_rod_pieces(dots)\n",
        "\n",
        "        # rod_pieces\n",
        "\n",
        "        self.add(self.dots)\n",
        "        self.add(self.v_lines)\n",
        "        self.add(self.rod_pieces)\n",
        "\n",
        "    def show_boundary_point_influenced_by_neighbor(self):\n",
        "        dots = self.dots\n",
        "        ld = dots[0]\n",
        "        ld_in = dots[1]\n",
        "        rd = dots[-1]\n",
        "        rd_in = dots[-2]\n",
        "        v_len = 0.75\n",
        "        l_arrow = Vector(v_len * LEFT)\n",
        "        l_arrow.move_to(ld.get_left(), RIGHT)\n",
        "        r_arrow = Vector(v_len * RIGHT)\n",
        "        r_arrow.move_to(rd.get_right(), LEFT)\n",
        "        arrows = VGroup(l_arrow, r_arrow)\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"?\").scale(1.5).next_to(\n",
        "                arrow, arrow.get_vector()\n",
        "            )\n",
        "            for arrow in arrows\n",
        "        ])\n",
        "\n",
        "        arrows.set_color(YELLOW)\n",
        "        q_marks.set_color(YELLOW)\n",
        "\n",
        "        blocking_rects = VGroup(*[\n",
        "            BackgroundRectangle(VGroup(\n",
        "                *dots[i:-i],\n",
        "                *self.rod_pieces[i:-i]\n",
        "            ))\n",
        "            for i in [1, 2]\n",
        "        ])\n",
        "        for rect in blocking_rects:\n",
        "            rect.stretch(1.1, dim=1, about_edge=UP)\n",
        "\n",
        "        self.play(FadeIn(blocking_rects[0]))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, arrows),\n",
        "            LaggedStart(*[\n",
        "                FadeIn(q_mark, -arrow.get_vector())\n",
        "                for q_mark, arrow in zip(q_marks, arrows)\n",
        "            ]),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Point to inward neighbor\n",
        "        new_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                d1.get_center(),\n",
        "                VGroup(d1, d2).get_center(),\n",
        "                buff=0,\n",
        "            ).match_style(l_arrow)\n",
        "            for d1, d2 in [(ld, ld_in), (rd, rd_in)]\n",
        "        ])\n",
        "        new_arrows.match_style(arrows)\n",
        "\n",
        "        l_brace = Brace(VGroup(ld, ld_in), DOWN)\n",
        "        r_brace = Brace(VGroup(rd, rd_in), DOWN)\n",
        "        braces = VGroup(l_brace, r_brace)\n",
        "        for brace in braces:\n",
        "            brace.align_to(\n",
        "                self.axes.x_axis.get_center(), UP\n",
        "            )\n",
        "            brace.shift(SMALL_BUFF * DOWN)\n",
        "            brace.add(brace.get_tex(\"\\\\Delta x\"))\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(arrows, new_arrows),\n",
        "            FadeOut(q_marks),\n",
        "            ReplacementTransform(*blocking_rects)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(braces, UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(new_arrows),\n",
        "            FadeOut(blocking_rects[1]),\n",
        "            FadeOut(braces),\n",
        "        )\n",
        "\n",
        "    def add_clock(self):\n",
        "        super().add_clock()\n",
        "        self.time_label.add_updater(\n",
        "            lambda d, dt: d.increment_value(dt)\n",
        "        )\n",
        "        VGroup(\n",
        "            self.clock,\n",
        "            self.time_label\n",
        "        ).shift(2 * LEFT)\n",
        "\n",
        "    def let_evolve(self):\n",
        "        dots = self.dots\n",
        "        dots.add_updater(self.update_dots)\n",
        "\n",
        "        wait_time = self.wait_time\n",
        "        self.play(\n",
        "            ClockPassesTime(\n",
        "                self.clock,\n",
        "                run_time=wait_time,\n",
        "                hours_passed=wait_time,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    #\n",
        "\n",
        "    def get_dots(self, axes, xs):\n",
        "        dots = VGroup(*[\n",
        "            Dot(axes.c2p(x, self.temp_func(x, 0)))\n",
        "            for x in xs\n",
        "        ])\n",
        "\n",
        "        max_width = 0.8 * self.step_size\n",
        "        for dot in dots:\n",
        "            dot.add_updater(self.update_dot_color)\n",
        "            if dot.get_width() > max_width:\n",
        "                dot.set_width(max_width)\n",
        "\n",
        "        return dots\n",
        "\n",
        "    def get_v_lines(self, dots):\n",
        "        return always_redraw(lambda: VGroup(*[\n",
        "            self.get_v_line(dot)\n",
        "            for dot in dots\n",
        "        ]))\n",
        "\n",
        "    def get_v_line(self, dot):\n",
        "        x_axis = self.axes.x_axis\n",
        "        bottom = dot.get_bottom()\n",
        "        x = x_axis.p2n(bottom)\n",
        "        proj_point = x_axis.n2p(x)\n",
        "        return self.v_line_class(\n",
        "            proj_point, bottom,\n",
        "            **self.v_line_config,\n",
        "        )\n",
        "\n",
        "    def get_rod_pieces(self, dots):\n",
        "        axis = self.axes.x_axis\n",
        "        factor = 1 - np.exp(-(0.8 / self.step_size)**2)\n",
        "        width = factor * self.step_size\n",
        "\n",
        "        pieces = VGroup()\n",
        "        for dot in dots:\n",
        "            piece = Line(ORIGIN, width * RIGHT)\n",
        "            piece.set_stroke(width=5)\n",
        "            piece.move_to(dot)\n",
        "            piece.set_y(axis.get_center()[1])\n",
        "            piece.dot = dot\n",
        "            piece.add_updater(\n",
        "                lambda p: p.match_color(p.dot)\n",
        "            )\n",
        "            pieces.add(piece)\n",
        "        return pieces\n",
        "\n",
        "    def update_dot_color(self, dot):\n",
        "        y = self.axes.y_axis.p2n(dot.get_center())\n",
        "        dot.set_color(self.y_to_color(y))\n",
        "\n",
        "    def update_dots(self, dots, dt):\n",
        "        for ds in zip(dots, dots[1:], dots[2:]):\n",
        "            points = [d.get_center() for d in ds]\n",
        "            x0, x1, x2 = [p[0] for p in points]\n",
        "            dx = x1 - x0\n",
        "            y0, y1, y2 = [p[1] for p in points]\n",
        "            \n",
        "            self.update_dot(\n",
        "                dot=ds[1],\n",
        "                dt=dt,\n",
        "                mean_diff=0.5 * (y2 - 2 * y1 + y0) / dx\n",
        "            )\n",
        "            if ds[0] is dots[0]:\n",
        "                self.update_dot(\n",
        "                    dot=ds[0],\n",
        "                    dt=dt,\n",
        "                    mean_diff=(y1 - y0) / dx\n",
        "                )\n",
        "            elif ds[-1] is dots[-1]:\n",
        "                self.update_dot(\n",
        "                    dot=ds[-1],\n",
        "                    dt=dt,\n",
        "                    mean_diff=(y1 - y2) / dx\n",
        "                )\n",
        "\n",
        "    def update_dot(self, dot, dt, mean_diff):\n",
        "        dot.shift(mean_diff * self.alpha * dt * UP)\n",
        "\n",
        "\n",
        "class DiscreteEvolutionPoint25(ShowNewRuleAtDiscreteBoundary):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.25,\n",
        "        \"alpha\": 0.5,\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.set_points()\n",
        "        self.add_clock()\n",
        "        self.let_evolve()\n",
        "\n",
        "\n",
        "class DiscreteEvolutionPoint1(DiscreteEvolutionPoint25):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.1,\n",
        "        \"v_line_config\": {\n",
        "            \"stroke_width\": 1,\n",
        "        },\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "\n",
        "class FlatEdgesForDiscreteEvolution(DiscreteEvolutionPoint1):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 20,\n",
        "        \"step_size\": 0.1,\n",
        "    }\n",
        "\n",
        "    def let_evolve(self):\n",
        "        lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        lines.set_width(1.5)\n",
        "        lines.set_stroke(WHITE, 5, opacity=0.5)\n",
        "        lines.add_updater(self.update_lines)\n",
        "\n",
        "        turn_animation_into_updater(\n",
        "            ShowCreation(lines, run_time=2)\n",
        "        )\n",
        "        self.add(lines)\n",
        "\n",
        "        super().let_evolve()\n",
        "\n",
        "    def update_lines(self, lines):\n",
        "        dots = self.dots\n",
        "        for line, dot in zip(lines, [dots[0], dots[-1]]):\n",
        "            line.move_to(dot)\n",
        "\n",
        "\n",
        "class FlatEdgesForDiscreteEvolutionTinySteps(FlatEdgesForDiscreteEvolution):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.025,\n",
        "        \"wait_time\": 10,\n",
        "        \"v_line_class\": Line,\n",
        "        \"v_line_config\": {\n",
        "            \"stroke_opacity\": 0.5,\n",
        "        }\n",
        "    }\n"
    ]
}