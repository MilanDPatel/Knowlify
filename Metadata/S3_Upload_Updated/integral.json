{
    "topic": "The mathematical concept being demonstrated is the area under a curve using rectangles.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.convolutions2.continuous import *\n",
        "from _2023.clt.main import *\n",
        "\n",
        "\n",
        "class LastTime(VideoWrapper):\n",
        "    wait_time = 8\n",
        "    title = \"Normal Distribution\"\n",
        "\n",
        "\n",
        "class AltBuildUpGaussian(BuildUpGaussian):\n",
        "    pass\n",
        "\n",
        "\n",
        "class BellCurveArea(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        axes = NumberPlane(\n",
        "            (-4, 4), (0, 1.5, 0.5),\n",
        "            width=14, height=5,\n",
        "            background_line_style=dict(\n",
        "                stroke_color=GREY_C,\n",
        "                stroke_width=2,\n",
        "                stroke_opacity=0.5\n",
        "            )\n",
        "        )\n",
        "        axes.x_axis.add_numbers(font_size=24)\n",
        "        axes.y_axis.add_numbers(num_decimal_places=1, excluding=[0])\n",
        "        axes.to_edge(DOWN)\n",
        "        graph = axes.get_graph(lambda x: np.exp(-x**2))\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        t2c = {\"x\": BLUE}\n",
        "        graph_label = Tex(\"e^{-x^2}\", font_size=72, t2c=t2c)\n",
        "        graph_label.next_to(graph.pfp(0.6), UR)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Show integral\n",
        "        integral = Tex(R\"\\int_{-\\infty}^\\infty e^{-x^2} dx\", t2c=t2c)\n",
        "        integral.to_edge(UP)\n",
        "\n",
        "        self.play(graph.animate.set_fill(BLUE, 0.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(integral[R\"\\int_{-\\infty}^\\infty\"]),\n",
        "            FadeTransform(graph_label.copy(), integral[\"e^{-x^2}\"])\n",
        "        )\n",
        "        self.play(TransformFromCopy(integral[\"x\"][0], integral[\"dx\"]))\n",
        "        self.wait()\n",
        "\n",
        "        # Show rectangles\n",
        "        colors = (BLUE_E, BLUE_D, TEAL_D, TEAL_E)\n",
        "        rects = axes.get_riemann_rectangles(graph, dx=0.2, colors=colors)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        rects.set_fill(opacity=0.75)\n",
        "        rect = rects[len(rects) // 2 - 2].copy()\n",
        "        rect.set_opacity(1)\n",
        "        graph_label.set_backstroke(width=5)\n",
        "\n",
        "        brace = Brace(rect, UP, SMALL_BUFF)\n",
        "        brace.set_backstroke(width=3)\n",
        "        dx_label = brace.get_tex(\"dx\", buff=SMALL_BUFF)\n",
        "        dx_label[\"x\"].set_color(BLUE)\n",
        "\n",
        "        axes.generate_target()\n",
        "        axes.target.y_axis.numbers.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rects, lag_ratio=0.1, run_time=3),\n",
        "            graph.animate.set_fill(opacity=0).set_anim_args(time_span=(1, 2)),\n",
        "            graph_label.animate.shift(SMALL_BUFF * UR).set_anim_args(time_span=(1, 2)),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rects.animate.set_opacity(0.1),\n",
        "            MoveToTarget(axes),\n",
        "            FadeIn(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(graph_label.animate.set_height(0.5).next_to(rect, LEFT, SMALL_BUFF))\n",
        "        self.play(FlashAround(integral[\"e^{-x^2}\"], time_width=1, run_time=1.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(dx_label, 0.5 * UP),\n",
        "        )\n",
        "        self.play(FlashAround(integral[\"dx\"], time_width=1, run_time=1.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Show addition\n",
        "        rects.set_fill(opacity=0.8)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        self.play(\n",
        "            graph_label.animate.set_height(0.7).next_to(graph.pfp(0.4), UL),\n",
        "            rects.animate.set_opacity(0.75),\n",
        "            FadeOut(rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                r.animate.shift(0.25 * UP).set_color(YELLOW).set_anim_args(rate_func=there_and_back)\n",
        "                for r in rects\n",
        "            ), run_time=5, lag_ratio=0.1),\n",
        "            LaggedStart(\n",
        "                FlashAround(integral[2:4], time_width=1),\n",
        "                FlashAround(integral[1], time_width=1),\n",
        "                lag_ratio=0.25,\n",
        "                run_time=5,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Thinner rectangles\n",
        "        for dx in [0.1, 0.075, 0.05, 0.03, 0.02, 0.01, 0.005]:\n",
        "            new_rects = axes.get_riemann_rectangles(graph, dx=dx, colors=colors)\n",
        "            new_rects.set_stroke(WHITE, 1)\n",
        "            new_rects.set_fill(opacity=0.7)\n",
        "            self.play(\n",
        "                Transform(rects, new_rects),\n",
        "                brace.animate.set_width(dx * axes.x_axis.get_unit_size(), about_edge=LEFT),\n",
        "                MaintainPositionRelativeTo(dx_label, brace),\n",
        "            )\n",
        "        self.add(graph)\n",
        "        self.play(\n",
        "            FadeOut(brace), FadeOut(dx_label),\n",
        "            ShowCreation(graph),\n",
        "        )\n",
        "\n",
        "        # Indefinite integral\n",
        "        frame = self.frame\n",
        "        equals = Tex(\"=\")\n",
        "        equals.move_to(integral)\n",
        "        equals.shift(0.5 * UP)\n",
        "        answer_box = SurroundingRectangle(integral[\"e^{-x^2} dx\"])\n",
        "        answer_box.next_to(equals, RIGHT)\n",
        "        answer_box.set_stroke(TEAL, 2)\n",
        "        answer_box.set_fill(GREY_E, 1)\n",
        "        q_marks = Tex(\"???\")\n",
        "        q_marks.set_height(0.6 * answer_box.get_height())\n",
        "        q_marks.move_to(answer_box)\n",
        "        answer_box.add(q_marks)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(9, about_edge=DOWN),\n",
        "            integral.animate.next_to(equals, LEFT),\n",
        "            FadeIn(equals),\n",
        "            Write(answer_box),\n",
        "        )\n",
        "\n",
        "        integral.save_state()\n",
        "        integral.generate_target()\n",
        "        integral.target[1:4].stretch(0, 0, about_edge=RIGHT).set_opacity(0)\n",
        "        integral.target[0].move_to(integral[:4], RIGHT)\n",
        "        self.play(MoveToTarget(integral))\n",
        "\n",
        "        # Arrows\n",
        "        int_box = SurroundingRectangle(integral[\"e^{-x^2} dx\"])\n",
        "        int_box.set_stroke(BLUE, 2)\n",
        "        arc = -0.5 * PI\n",
        "        low_arrow = Arrow(answer_box.get_bottom(), int_box.get_bottom(), path_arc=arc)\n",
        "        top_arrow = Arrow(int_box.get_top(), answer_box.get_top(), path_arc=arc)\n",
        "\n",
        "        low_words = Text(\"Derivative\", font_size=30)\n",
        "        low_words.next_to(low_arrow, DOWN, MED_SMALL_BUFF)\n",
        "        top_words = Text(\"Antiderivative\", font_size=30)\n",
        "        top_words.next_to(top_arrow, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(low_arrow),\n",
        "            FadeIn(low_words, 0.5 * LEFT),\n",
        "            FadeTransform(answer_box.copy(), int_box, path_arc=arc)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(top_arrow),\n",
        "            FadeIn(top_words, 0.5 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Impossible\n",
        "        impossible = Text(\"Impossible!\", font_size=72, color=RED)\n",
        "        impossible.next_to(answer_box, RIGHT)\n",
        "\n",
        "        functions = VGroup(\n",
        "            Tex(R\"a_n x^n + \\cdots a_1 x + a_0\", t2c=t2c),\n",
        "            Tex(R\"\\sin(x), \\cos(x), \\tan(x)\", t2c=t2c),\n",
        "            Tex(R\"b^x\", t2c=t2c),\n",
        "            Tex(R\"\\vdots\")\n",
        "        )\n",
        "        functions.arrange(DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        functions.set_height(2.5)\n",
        "        functions.next_to(impossible, RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(impossible, scale=0.5, rate_func=rush_into))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, functions, shift=DOWN, lag_ratio=0.5),\n",
        "            frame.animate.shift(4 * RIGHT),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AntiDerivative(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add both planes\n",
        "        x_min, x_max = (-3, 3)\n",
        "        planes = VGroup(*(\n",
        "            NumberPlane(\n",
        "                (x_min, x_max), (0, 2),\n",
        "                width=5.5, height=2.75,\n",
        "                background_line_style=dict(stroke_color=GREY, stroke_width=1, stroke_opacity=1.0),\n",
        "                faded_line_ratio=3,\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ))\n",
        "        planes.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        planes.to_corner(UL)\n",
        "        self.add(planes)\n",
        "\n",
        "        # Titles\n",
        "        titles = VGroup(\n",
        "            Tex(\"f(x) = e^{-x^2}\", font_size=66),\n",
        "            Tex(R\"F(x) = \\int_0^x e^{-t^2} dt\"),\n",
        "        )\n",
        "        for title, plane in zip(titles, planes):\n",
        "            title.next_to(plane, RIGHT)\n",
        "\n",
        "        ad_word = Text(\"Antiderivative\")\n",
        "        ad_word.next_to(titles[1], UP, MED_LARGE_BUFF)\n",
        "        VGroup(ad_word, titles[1]).match_y(planes[1])\n",
        "\n",
        "        self.add(titles)\n",
        "        self.add(ad_word)\n",
        "\n",
        "        # High graph\n",
        "        x_tracker = ValueTracker(0)\n",
        "        get_x = x_tracker.get_value\n",
        "        high_graph = planes[0].get_graph(lambda x: np.exp(-x**2))\n",
        "        high_graph.set_stroke(BLUE, 3)\n",
        "\n",
        "        high_area = high_graph.copy()\n",
        "\n",
        "        def update_area(area: VMobject):\n",
        "            x = get_x()\n",
        "            area.become(high_graph)\n",
        "            area.set_stroke(width=0)\n",
        "            area.set_fill(BLUE, 0.5)\n",
        "            area.pointwise_become_partial(\n",
        "                high_graph, 0, inverse_interpolate(x_min, x_max, x)\n",
        "            )\n",
        "            area.add_line_to(planes[0].c2p(x, 0))\n",
        "            area.add_line_to(planes[0].c2p(x_min, 0))\n",
        "            return area\n",
        "\n",
        "        high_area.add_updater(update_area)\n",
        "\n",
        "        self.add(high_graph, high_area)\n",
        "\n",
        "        # Low graph\n",
        "        dist = scipy.stats.norm(0, 1)\n",
        "        low_graph = planes[1].get_graph(lambda x: math.sqrt(PI) * dist.cdf(x))\n",
        "        low_graph.set_stroke(YELLOW, 2)\n",
        "        low_dot = GlowDot()\n",
        "        low_dot.add_updater(lambda m: m.move_to(planes[1].i2gp(get_x(), low_graph)))\n",
        "\n",
        "        low_line = always_redraw(lambda: DashedLine(\n",
        "            planes[1].c2p(get_x(), 0), planes[1].i2gp(get_x(), low_graph),\n",
        "        ).set_stroke(WHITE, 2))\n",
        "\n",
        "        self.add(low_graph, low_dot, low_line)\n",
        "\n",
        "        # Animations\n",
        "        for value in [1.5, -2, -1, 1, -0.5, 0.5, 3.0, -1.5]:\n",
        "            self.play(x_tracker.animate.set_value(value), run_time=3)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class UsualFunctionTypes(InteractiveScene):\n",
        "    def construct(self):\n",
        "        t2c = {\"x\": YELLOW}\n",
        "        functions = VGroup(\n",
        "            Tex(R\"a_n x^n + \\cdots a_1 x + a_0\", t2c=t2c),\n",
        "            Tex(R\"\\sin(x), \\cos(x), \\arctan(x)\", t2c=t2c),\n",
        "            Tex(R\"b^x, \\log(x), \\cosh(x)\", t2c=t2c),\n",
        "            Tex(R\"\\vdots\")\n",
        "        )\n",
        "        functions.arrange(DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        functions.set_height(2.5)\n",
        "        functions.to_edge(RIGHT, buff=0.6)\n",
        "\n",
        "        box = SurroundingRectangle(functions, buff=MED_LARGE_BUFF)\n",
        "        box.set_stroke(RED, 2)\n",
        "\n",
        "        words = Text(\"Cannot be expressed \\n in terms of these:\")\n",
        "        words.next_to(box, UP)\n",
        "        words.set_fill(RED)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words, lag_ratio=0.1),\n",
        "            FadeIn(box),\n",
        "            LaggedStartMap(FadeIn, functions, shift=DOWN, lag_ratio=0.5, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GaussianIntegral(ThreeDScene, InteractiveScene):\n",
        "    def func(self, x, y):\n",
        "        return np.exp(-x**2 - y**2)\n",
        "\n",
        "    def get_axes(\n",
        "        self,\n",
        "        x_range=(-3, 3),\n",
        "        y_range=(-3, 3),\n",
        "        z_range=(0, 1.5, 0.5),\n",
        "        width=8,\n",
        "        height=8,\n",
        "        depth=3,\n",
        "        center=0.5 * IN,\n",
        "        include_plane=False\n",
        "    ):\n",
        "        axes = ThreeDAxes(\n",
        "            x_range, y_range, z_range,\n",
        "            width=width, height=height, depth=depth\n",
        "        )\n",
        "        axes.set_stroke(GREY_C)\n",
        "        if include_plane:\n",
        "            plane = NumberPlane(\n",
        "                x_range, y_range,\n",
        "                width=width, height=height,\n",
        "                background_line_style=dict(\n",
        "                    stroke_color=GREY_C,\n",
        "                    stroke_width=1,\n",
        "                ),\n",
        "            )\n",
        "            plane.faded_lines.set_stroke(opacity=0.5)\n",
        "            plane.shift(0.01 * IN)\n",
        "            axes.plane = plane\n",
        "            axes.add(plane)\n",
        "\n",
        "        x, y, z = axis_labels = VGroup(*map(Tex, \"xyz\"))\n",
        "        axis_labels.use_winding_fill(False)\n",
        "        x.next_to(axes.x_axis, RIGHT)\n",
        "        y.next_to(axes.y_axis, UP)\n",
        "        z.rotate(90 * DEGREES, RIGHT)\n",
        "        z.next_to(axes.z_axis, OUT)\n",
        "        axes.labels = axis_labels\n",
        "        axes.add(axis_labels)\n",
        "\n",
        "        axes.shift(center - axes.c2p(0, 0, 0))\n",
        "        axes.set_flat_stroke(False)\n",
        "        return axes\n",
        "\n",
        "    def get_gaussian_graph(\n",
        "        self,\n",
        "        axes,\n",
        "        color=interpolate_color(BLUE_E, BLACK, 0.6),\n",
        "        opacity=1.0,\n",
        "        shading=(0.2, 0.2, 0.4),\n",
        "    ):\n",
        "        graph = axes.get_graph(self.func)\n",
        "        graph.set_color(color)\n",
        "        graph.set_opacity(opacity)\n",
        "        graph.set_shading(*shading)\n",
        "        return graph\n",
        "\n",
        "    def get_dynamic_cylinder(self, axes, r_init=1):\n",
        "        cylinder = self.get_cylinder(axes, r_init)\n",
        "        r_tracker = ValueTracker(r_init)\n",
        "        cylinder.add_updater(lambda m: self.set_cylinder_r(\n",
        "            m, axes, r_tracker.get_value()\n",
        "        ))\n",
        "        return cylinder, r_tracker\n",
        "\n",
        "    def get_cylinder(\n",
        "        self, axes, r,\n",
        "        color=BLUE_E,\n",
        "        opacity=1\n",
        "    ):\n",
        "        cylinder = Cylinder(color=color, opacity=opacity)\n",
        "        self.set_cylinder_r(cylinder, axes, r)\n",
        "        return cylinder\n",
        "\n",
        "    def set_cylinder_r(self, cylinder, axes, r):\n",
        "        r = max(r, 1e-5)\n",
        "        cylinder.set_width(2 * r * axes.x_axis.get_unit_size())\n",
        "        cylinder.set_depth(\n",
        "            self.func(r, 0) * axes.z_axis.get_unit_size(),\n",
        "            stretch=True\n",
        "        )\n",
        "        cylinder.move_to(axes.c2p(0, 0, 0), IN)\n",
        "        return cylinder\n",
        "\n",
        "    def get_thick_cylinder(self, cylinder, delta_r):\n",
        "        radius = 0.5 * cylinder.get_width()\n",
        "        outer_cylinder = cylinder.copy()\n",
        "        factor = (radius + delta_r) / radius\n",
        "        outer_cylinder.stretch(factor, 0)\n",
        "        outer_cylinder.stretch(factor, 1)\n",
        "\n",
        "        annulus = ParametricSurface(\n",
        "            lambda u, v: (radius + u * delta_r) * np.array([math.cos(v), math.sin(v), 0]),\n",
        "            u_range=(0, 1),\n",
        "            v_range=(0, TAU),\n",
        "        )\n",
        "        annulus.match_color(cylinder)\n",
        "        annulus.move_to(cylinder, OUT)\n",
        "\n",
        "        result = Group(cylinder.copy(), annulus, outer_cylinder)\n",
        "        result.clear_updaters()\n",
        "        return result\n",
        "\n",
        "    def get_x_slice(self, axes, y, x_range=(-3, 3.1, 0.1)):\n",
        "        xs = np.arange(*x_range)\n",
        "        ys = np.ones(len(xs)) * y\n",
        "        points = axes.c2p(xs, ys, self.func(xs, y))\n",
        "        graph = VMobject().set_points_smoothly(points)\n",
        "        graph.use_winding_fill(False)\n",
        "        return graph\n",
        "\n",
        "    def get_dynamic_slice(\n",
        "        self,\n",
        "        axes,\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=2,\n",
        "        fill_color=BLUE_E,\n",
        "        fill_opacity=0.5,\n",
        "    ):\n",
        "        y_tracker = ValueTracker(0)\n",
        "        get_y = y_tracker.get_value\n",
        "\n",
        "        z_unit = axes.z_axis.get_unit_size()\n",
        "        x_slice = self.get_x_slice(axes, 0)\n",
        "        x_slice.set_stroke(stroke_color, stroke_width)\n",
        "        x_slice.set_fill(fill_color, fill_opacity)\n",
        "        x_slice.add_updater(\n",
        "            lambda m: m.set_depth(self.func(0, get_y()) * z_unit, stretch=True)\n",
        "        )\n",
        "        x_slice.add_updater(lambda m: m.move_to(axes.c2p(0, get_y(), 0), IN))\n",
        "\n",
        "        return x_slice, y_tracker\n",
        "\n",
        "\n",
        "class CylinderSlices(GaussianIntegral):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        axes = self.get_axes()\n",
        "\n",
        "        graph = self.get_gaussian_graph(axes)\n",
        "        graph.set_opacity(0.8)\n",
        "        graph.always_sort_to_camera(self.camera)\n",
        "\n",
        "        graph_mesh = SurfaceMesh(graph, resolution=(21, 21))\n",
        "        graph_mesh.set_stroke(WHITE, 0.5, opacity=0.25)\n",
        "        graph_mesh.set_flat_stroke(False)\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Animate in by rotating e^{-x^2}\n",
        "        bell_halves = Group(*(\n",
        "            axes.get_parametric_surface(\n",
        "                lambda r, theta: np.array(\n",
        "                    [r * np.cos(theta), r * np.sin(theta), np.exp(-r**2)\n",
        "                ]),\n",
        "                u_range=(0, 3),\n",
        "                v_range=v_range,\n",
        "            )\n",
        "            for v_range in [(0, PI), (PI, TAU)]\n",
        "        ))\n",
        "        for half in bell_halves:\n",
        "            half.match_style(graph)\n",
        "            half.set_opacity(0.5)\n",
        "\n",
        "        bell2d = self.get_x_slice(axes, 0)\n",
        "        bell2d.set_stroke(TEAL, 3)\n",
        "        kw = dict(t2c={\"x\": BLUE, \"y\": YELLOW})\n",
        "        label2d, label3d = func_labels = VGroup(\n",
        "            Tex(\"f_1(x) = e^{-x^2}\", **kw),\n",
        "            Tex(\"f_2(x, y) = e^{-(x^2 + y^2)}\", **kw),\n",
        "        )\n",
        "        for label in func_labels:\n",
        "            label.fix_in_frame()\n",
        "            label.move_to(4 * LEFT + 2 * UP)\n",
        "\n",
        "        axes.save_state()\n",
        "        frame.reorient(0, 90)\n",
        "        frame.move_to(OUT + 2 * UP)\n",
        "        axes.y_axis.set_opacity(0)\n",
        "        axes.labels.set_opacity(0)\n",
        "        self.play(\n",
        "            ShowCreation(bell2d),\n",
        "            Write(label2d)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(bell_halves[0]),\n",
        "            ShowCreation(bell_halves[1]),\n",
        "            Rotate(bell2d, PI, axis=OUT, about_point=axes.c2p(0, 0, 0)),\n",
        "            frame.animate.move_to(ORIGIN).reorient(-20, 70),\n",
        "            Restore(axes),\n",
        "            TransformMatchingTex(label2d.copy(), label3d, time_span=(0, 2)),\n",
        "            label2d.animate.next_to(label3d, UP, MED_LARGE_BUFF, LEFT),\n",
        "            run_time=6\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(bell_halves, 0.01 * IN),\n",
        "            FadeOut(bell2d, 0.1 * IN),\n",
        "            FadeIn(graph, 0.01 * IN),\n",
        "        )\n",
        "        self.play(Write(graph_mesh, stroke_width=1, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "\n",
        "        # Rotate the frame\n",
        "        self.play(\n",
        "            frame.animate.set_theta(20 * DEGREES),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=30,\n",
        "        )\n",
        "\n",
        "        # Reposition to 2d view\n",
        "        frame.save_state()\n",
        "        graph_mesh.save_state()\n",
        "        func_labels.use_winding_fill(False)\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0).set_height(10).move_to(1.5 * LEFT).set_field_of_view(1 * DEGREES),\n",
        "            graph.animate.set_opacity(0.25),\n",
        "            func_labels.animate.scale(0.75).to_corner(UL),\n",
        "            graph_mesh.animate.set_stroke(width=1),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Explain meaning of r\n",
        "        x, y = (1.5, 0.75)\n",
        "        dot = Dot(axes.c2p(x, y), fill_color=RED)\n",
        "        dot.set_stroke(WHITE, 0.5)\n",
        "        coords = Tex(\"(x, y)\", font_size=36)\n",
        "        coords.next_to(dot, UR, SMALL_BUFF)\n",
        "\n",
        "        x_line = Line(axes.get_origin(), axes.c2p(x, 0, 0))\n",
        "        y_line = Line(axes.c2p(x, 0, 0), axes.c2p(x, y, 0))\n",
        "        r_line = Line(axes.c2p(x, y, 0), axes.get_origin())\n",
        "        x_line.set_stroke(BLUE, 3)\n",
        "        y_line.set_stroke(YELLOW, 3)\n",
        "        r_line.set_stroke(RED, 3)\n",
        "        lines = VGroup(x_line, y_line, r_line)\n",
        "        labels = VGroup(*map(Tex, \"xyr\"))\n",
        "        for label, line in zip(labels, lines):\n",
        "            label.match_color(line)\n",
        "            label.scale(0.85)\n",
        "            label.next_to(line.get_center(), rotate_vector(line.get_vector(), -90 * DEGREES), SMALL_BUFF)\n",
        "\n",
        "        self.add(dot, coords, set_depth_test=False)\n",
        "        self.play(\n",
        "            FadeIn(dot, scale=0.5),\n",
        "            FadeIn(coords),\n",
        "        )\n",
        "        for line, label in zip(lines, labels):\n",
        "            self.add(line, label, dot, set_depth_test=False)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Write(label),\n",
        "            )\n",
        "\n",
        "        # Plug in r\n",
        "        r_label_rect = SurroundingRectangle(labels[2], buff=SMALL_BUFF)\n",
        "        r_label_rect.set_stroke(RED, 2)\n",
        "        arrow = Arrow(r_label_rect, axes.c2p(-3, 3, 0) + 3.2 * LEFT + 0.25 * UP, path_arc=45 * DEGREES)\n",
        "        arrow.set_stroke(RED)\n",
        "\n",
        "        self.always_depth_test = False\n",
        "        self.play(ShowCreation(r_label_rect))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Show Pythagorean equations\n",
        "        r_func = Tex(\"= e^{-r^2}\", t2c={\"r\": RED})\n",
        "        r_func.match_height(label2d[\"= e^{-x^2}\"])\n",
        "        r_func.next_to(label3d, RIGHT, MED_SMALL_BUFF, UP)\n",
        "        r_func.fix_in_frame()\n",
        "\n",
        "        r_rect = SurroundingRectangle(r_func[\"r^2\"], buff=0.025)\n",
        "        xy_rect = SurroundingRectangle(label3d[\"x^2 + y^2\"], buff=0.025)\n",
        "        VGroup(r_rect, xy_rect).set_stroke(TEAL, 1)\n",
        "        VGroup(r_rect, xy_rect).fix_in_frame()\n",
        "\n",
        "        pythag = Tex(\"x^2 + y^2 = r^2\", t2c={\"x\": BLUE, \"y\": YELLOW, \"r\": RED})\n",
        "        pythag.next_to(label3d, DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        pythag.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(label2d[\"= e^{-x^2}\"].copy(), r_func),\n",
        "            FadeOut(arrow, scale=0.8, shift=DR + RIGHT),\n",
        "            FadeOut(r_label_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "        line_copies = lines.copy()\n",
        "        self.add(*line_copies, set_depth_test=False)\n",
        "        self.play(\n",
        "            *(\n",
        "                VShowPassingFlash(line.insert_n_curves(20).set_stroke(width=8), time_width=1.5)\n",
        "                for line in line_copies\n",
        "            ),\n",
        "            *map(ShowCreation, lines)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(r_func[\"r^2\"][0].copy(), pythag[\"r^2\"]),\n",
        "            FadeTransform(label3d[\"x^2 + y^2\"][0].copy(), pythag[\"x^2 + y^2\"]),\n",
        "            Write(pythag[\"=\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(xy_rect))\n",
        "        self.wait()\n",
        "        self.play(Transform(xy_rect, r_rect))\n",
        "        self.play(FadeOut(xy_rect))\n",
        "\n",
        "        functions = VGroup(label2d, label3d, r_func)\n",
        "        functions.fix_in_frame()\n",
        "\n",
        "        # Emphasize rotational symmetry\n",
        "        self.always_depth_test = True\n",
        "        x_label, y_label, r_label = labels\n",
        "        self.play(\n",
        "            *map(FadeOut, [x_line, y_line, x_label, y_label, pythag])\n",
        "        )\n",
        "\n",
        "        def get_circle(point, z_shift=0.02):\n",
        "            origin = axes.c2p(0, 0, 0)\n",
        "            point[2] = origin[2]\n",
        "            radius = get_norm(point - origin)\n",
        "            circle = Circle(radius=radius, n_components=96)\n",
        "            x = axes.x_axis.p2n(point)\n",
        "            y = axes.y_axis.p2n(point)\n",
        "            circle.move_to(axes.c2p(0, 0, self.func(x, y) + z_shift))\n",
        "            circle.set_stroke(RED, 2)\n",
        "            circle.rotate(np.arctan2(y, x))\n",
        "            circle.set_flat_stroke(False)\n",
        "            return circle\n",
        "\n",
        "        r_label.add_updater(lambda m: m.next_to(r_line.get_center(), UL, SMALL_BUFF))\n",
        "        dot.add_updater(lambda m: m.move_to(r_line.get_start()))\n",
        "        coords.add_updater(lambda m: m.next_to(dot, UR, SMALL_BUFF))\n",
        "        circle = get_circle(r_line.get_start())\n",
        "\n",
        "        self.play(\n",
        "            Rotate(r_line, TAU, about_point=axes.get_origin()),\n",
        "            ShowCreation(circle),\n",
        "            frame.animate.reorient(30, 60).move_to(ORIGIN).set_height(8).set_field_of_view(45 * DEGREES),\n",
        "            Restore(graph_mesh),\n",
        "            run_time=7,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            r_line.animate.scale(0.1, about_point=axes.get_origin()),\n",
        "            UpdateFromFunc(circle, lambda c: c.replace(get_circle(r_line.get_start()))),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [r_line, dot, r_label, coords, circle]))\n",
        "\n",
        "        # Dynamic cylinder\n",
        "        cylinder, r_tracker = self.get_dynamic_cylinder(axes)\n",
        "        delta_r = 0.1\n",
        "        cylinders = Group(*(\n",
        "            self.get_cylinder(axes, r, opacity=0.5)\n",
        "            for r in np.arange(0, 3, delta_r)\n",
        "        ))\n",
        "\n",
        "        r_tracker.set_value(0)\n",
        "        self.add(cylinder, cylinders, graph, graph_mesh)\n",
        "        self.play(\n",
        "            graph.animate.set_opacity(0.1).set_anim_args(time_span=(0, 2)),\n",
        "            FadeIn(cylinders, lag_ratio=0.9),\n",
        "            r_tracker.animate.set_value(3).set_anim_args(\n",
        "                rate_func=linear,\n",
        "                time_span=(0.5, 10),\n",
        "            ),\n",
        "            frame.animate.reorient(-15, 75).set_height(5.5),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate one particular cylinder\n",
        "        self.play(\n",
        "            r_tracker.animate.set_value(0.7),\n",
        "            cylinders.animate.set_opacity(0.1),\n",
        "            frame.animate.reorient(-27, 71),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Unwrap cylinder\n",
        "        axes.labels[2].set_opacity(0)\n",
        "        R = cylinder.get_width() / 2\n",
        "        rect = Square3D(resolution=cylinder.resolution)\n",
        "        rect.set_width(TAU * R)\n",
        "        rect.set_height(cylinder.get_depth(), stretch=True)\n",
        "        rect.match_color(cylinder)\n",
        "        rect_top = Line(rect.get_corner(UL), rect.get_corner(UR))\n",
        "        rect_top.set_stroke(RED, 3)\n",
        "        rect_side = Line(rect.get_corner(DL), rect.get_corner(UL))\n",
        "        rect_side.set_stroke(PINK, 3)\n",
        "        VGroup(rect_top, rect_side).set_flat_stroke(False)\n",
        "        rect_group = Group(rect, rect_top, rect_side)\n",
        "        rect_group.apply_matrix(frame.get_orientation().as_matrix())\n",
        "        rect_group.next_to(cylinder, [1, 0, 1], LARGE_BUFF)\n",
        "\n",
        "        eq_kw = dict(\n",
        "            font_size=35,\n",
        "            t2c={\"{r}\": RED},\n",
        "        )\n",
        "        area_eq1 = TexText(\"Area = (Circumference)(Height)\", **eq_kw)\n",
        "        area_eq2 = TexText(R\"Area = $2 \\pi {r} \\cdot e^{-{r}^2}$\", **eq_kw)\n",
        "        for eq in area_eq1, area_eq2:\n",
        "            eq.fix_in_frame()\n",
        "            eq.to_corner(UL)\n",
        "        area_eq1.shift(area_eq2[0].get_center() - area_eq1[0].get_center())\n",
        "\n",
        "        self.add(functions)\n",
        "        functions.fix_in_frame()\n",
        "        functions.deactivate_depth_test()\n",
        "        functions.use_winding_fill(False)\n",
        "        self.play(\n",
        "            FadeIn(area_eq1, DOWN),\n",
        "            functions.animate.shift(1.5 * DOWN).scale(0.7, about_edge=DL).set_fill(opacity=0.75)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pre_rect = cylinder.copy()\n",
        "        pre_rect.clear_updaters()\n",
        "        self.add(pre_rect, graph)\n",
        "        self.play(\n",
        "            pre_rect.animate.scale(0.95).next_to(cylinder, OUT, buff=1.0),\n",
        "            frame.animate.set_height(7).move_to([1.0, 0.15, 1.0]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(ReplacementTransform(pre_rect, rect), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Show cylinder area\n",
        "        circle = get_circle(cylinder.get_points()[0], z_shift=0)\n",
        "        height_line = Line(cylinder.get_corner(IN + DOWN), cylinder.get_corner(OUT + DOWN))\n",
        "        height_line.set_stroke(PINK, 3)\n",
        "        height_line.set_flat_stroke(False)\n",
        "\n",
        "        circ_brace = Brace(area_eq2[R\"2 \\pi {r}\"], DOWN, SMALL_BUFF)\n",
        "        height_brace = Brace(area_eq2[R\"e^{-{r}^2}\"], DOWN, SMALL_BUFF)\n",
        "        VGroup(circ_brace, height_brace).fix_in_frame()\n",
        "\n",
        "        circ_word = area_eq1[\"(Circumference)\"]\n",
        "        height_word = area_eq1[\"(Height)\"]\n",
        "\n",
        "        self.add(circle, set_depth_test=False)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            ShowCreation(rect_top),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(circ_brace),\n",
        "            circ_word.animate.scale(0.75).next_to(circ_brace, DOWN, SMALL_BUFF),\n",
        "            Write(area_eq2[R\"2 \\pi {r}\"]),\n",
        "            height_word.animate.next_to(area_eq2[R\"2 \\pi {r}\"], RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(height_line, set_depth_test=False)\n",
        "        self.play(\n",
        "            FadeOut(circle),\n",
        "            FadeOut(rect_top),\n",
        "            ShowCreation(rect_side),\n",
        "            ShowCreation(height_line),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(height_brace),\n",
        "            height_word.animate.scale(0.75).next_to(height_brace, DOWN, SMALL_BUFF, aligned_edge=LEFT),\n",
        "            circ_word.animate.align_to(circ_brace, RIGHT),\n",
        "            FadeInFromPoint(area_eq2[R\"\\cdot e^{-{r}^2}\"], r_func[1:].get_center()),\n",
        "        )\n",
        "        self.remove(area_eq1)\n",
        "        self.add(area_eq2, circ_word, height_word)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.center().reorient(-15, 66).set_height(4).set_anim_args(run_time=15),\n",
        "            *map(FadeOut, [rect, rect_side, height_line]),\n",
        "        )\n",
        "\n",
        "        # Show thickness\n",
        "        volume_word = Text(\"Volume\", **eq_kw)\n",
        "        volume_word.fix_in_frame()\n",
        "        volume_word.move_to(area_eq2, DL)\n",
        "        area_part = area_eq2[R\"= $2 \\pi {r} \\cdot e^{-{r}^2}$\"]\n",
        "        annotations = VGroup(circ_brace, height_brace, circ_word, height_word)\n",
        "        dr_tex = Tex(\"d{r}\", **eq_kw)\n",
        "        dr_tex.fix_in_frame()\n",
        "\n",
        "        thick_cylinder = self.get_thick_cylinder(cylinder, delta_r * axes.x_axis.get_unit_size())\n",
        "        thin_cylinder = self.get_thick_cylinder(cylinder, 0.1 * delta_r * axes.x_axis.get_unit_size())\n",
        "        _, annulus, outer_cylinder = thick_cylinder\n",
        "\n",
        "        dr_brace = Brace(\n",
        "            Line(axes.get_origin(), axes.c2p(delta_r, 0, 0)), UP\n",
        "        )\n",
        "        dr_brace.stretch(0.5, 1)\n",
        "        brace_label = dr_brace.get_tex(\"d{r}\", buff=SMALL_BUFF)\n",
        "        brace_label[\"r\"].set_color(RED)\n",
        "        brace_label.scale(0.35, about_edge=DOWN)\n",
        "        dr_brace.add(brace_label)\n",
        "        dr_brace.rotate(90 * DEGREES, RIGHT)\n",
        "        dr_brace.move_to(thick_cylinder.get_corner(OUT + LEFT), IN + LEFT)\n",
        "\n",
        "        self.remove(cylinder)\n",
        "        self.add(thin_cylinder, cylinders, graph, graph_mesh)\n",
        "        self.play(Transform(thin_cylinder, thick_cylinder))\n",
        "        self.add(dr_brace, set_depth_test=False)\n",
        "        self.play(Write(dr_brace))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, annotations, shift=DOWN, run_time=1),\n",
        "            FadeOut(area_eq2[\"Area\"], DOWN),\n",
        "            FadeIn(volume_word, DOWN),\n",
        "            area_part.animate.next_to(volume_word, RIGHT, SMALL_BUFF, DOWN),\n",
        "        )\n",
        "        dr_tex.next_to(area_part, RIGHT, SMALL_BUFF, DOWN)\n",
        "        self.play(FadeIn(dr_tex))\n",
        "        self.wait()\n",
        "\n",
        "        # Show all cylinders\n",
        "        integrand = VGroup(*area_part[0][1:], *dr_tex)\n",
        "        integrand.fix_in_frame()\n",
        "        integral = Tex(R\"\\int_0^\\infty\", **eq_kw)\n",
        "        integral.fix_in_frame()\n",
        "        integral.move_to(volume_word, LEFT)\n",
        "\n",
        "        thick_cylinders = Group(*(\n",
        "            self.get_thick_cylinder(cyl, delta_r * axes.x_axis.get_unit_size())\n",
        "            for cyl in cylinders\n",
        "        ))\n",
        "        thick_cylinders.set_opacity(0.8)\n",
        "        thick_cylinders.set_shading(0.25, 0.25, 0.25)\n",
        "        small_dr = 0.02\n",
        "        thin_cylinders = Group(*(\n",
        "            self.get_thick_cylinder(self.get_cylinder(axes, r), small_dr)\n",
        "            for r in np.arange(0, 5, small_dr)\n",
        "        ))\n",
        "        thin_cylinders.set_opacity(0.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(volume_word, LEFT),\n",
        "            FadeOut(area_part[0][0], LEFT),\n",
        "            FadeIn(integral, LEFT),\n",
        "            integrand.animate.next_to(integral, RIGHT, buff=0),\n",
        "        )\n",
        "\n",
        "        self.add(thick_cylinders, cylinders, graph, graph_mesh)\n",
        "        self.play(ShowIncreasingSubsets(thick_cylinders, run_time=8))\n",
        "        self.play(FadeOut(thick_cylinders, 0.1 * IN))\n",
        "        self.wait()\n",
        "\n",
        "        self.add(dr_brace[:-1], dr_brace[-1], set_depth_test=False)\n",
        "        self.play(\n",
        "            Transform(thin_cylinder, thin_cylinders[int(np.round(r_tracker.get_value() / small_dr))]),\n",
        "            dr_brace[:-1].animate.stretch(small_dr / delta_r, 0, about_edge=RIGHT),\n",
        "            UpdateFromFunc(dr_brace[-1], lambda m: m.next_to(dr_brace[:-1], OUT, SMALL_BUFF)),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.add(thin_cylinders, cylinders, graph, graph_mesh)\n",
        "        self.add(dr_brace)\n",
        "        dr_brace.deactivate_depth_test()\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(thin_cylinders),\n",
        "            frame.animate.reorient(20, 70).set_height(8).move_to(OUT),\n",
        "            FadeOut(dr_brace, time_span=(0, 2)),\n",
        "            FadeOut(thin_cylinder, 2 * IN, time_span=(0, 2)),\n",
        "            FadeOut(functions, time_span=(0, 2)),\n",
        "            FadeOut(integral, time_span=(0, 2)),\n",
        "            FadeOut(integrand, time_span=(0, 2)),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ambient rotation\n",
        "        t0 = self.time\n",
        "        frame.add_updater(lambda m: m.reorient(20 * math.cos(0.1 * (self.time - t0))))\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class CylinderIntegral(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up equations\n",
        "        kw = dict(\n",
        "            font_size=48,\n",
        "            t2c={\n",
        "                \"{r}\": RED,\n",
        "                \"{0}\": RED,\n",
        "                R\"{\\infty}\": RED,\n",
        "            }\n",
        "        )\n",
        "        exprs = VGroup(\n",
        "            Tex(R\"\\int_0^\\infty 2\\pi {r} \\cdot e^{-{r}^2} \\, d{r}\", **kw),\n",
        "            Tex(R\"\\pi \\int_0^\\infty 2 {r} \\cdot e^{-{r}^2}\\,  d{r}\", **kw),\n",
        "            Tex(R\"= \\pi \\left[ -e^{-{\\infty}^2} - \\left(-e^{-{0}^2} \\right) \\right]\", **kw),\n",
        "            Tex(R\"= \\pi\", **kw),\n",
        "        )\n",
        "        exprs[1:].arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        exprs[1:].to_corner(UL)\n",
        "        exprs[0].move_to(exprs[1], LEFT)\n",
        "\n",
        "        # Factor out\n",
        "        self.add(exprs[0])\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(*exprs[:2], run_time=1, path_arc=30 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        # Show antiderivative\n",
        "        integrand = exprs[1][R\"2 {r} \\cdot e^{-{r}^2}\"]\n",
        "        integrand_rect = SurroundingRectangle(integrand, buff=SMALL_BUFF)\n",
        "        integrand_rect.set_stroke(YELLOW, 2)\n",
        "        anti_derivative = Tex(R\"-e^{-{r}^2}\", **kw)\n",
        "        anti_derivative.next_to(integrand_rect, DOWN, buff=1.5)\n",
        "        arrow = Arrow(anti_derivative, integrand_rect)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow_label = Tex(R\"d \\over d{r}\", **kw)\n",
        "        arrow_label.scale(0.75)\n",
        "        arrow_label.next_to(arrow, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(integrand_rect),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(arrow_label, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingShapes(integrand.copy(), anti_derivative))\n",
        "        self.wait()\n",
        "\n",
        "        # Evaluate\n",
        "        self.play(\n",
        "            Write(exprs[2][\"=\"]),\n",
        "            TransformFromCopy(exprs[1][R\"\\pi\"], exprs[2][R\"\\pi\"]),\n",
        "            TransformFromCopy(exprs[1][R\"\\int\"], exprs[2][R\"[\"]),\n",
        "            TransformFromCopy(exprs[1][R\"\\int\"], exprs[2][R\"]\"]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(anti_derivative.copy(), exprs[2][R\"-e^{-{\\infty}^2}\"]),\n",
        "            FadeIn(VGroup(*exprs[2][R\"- \\left(\"], exprs[2][R\"\\right)\"])),\n",
        "            FadeTransform(anti_derivative.copy(), exprs[2][R\"-e^{-{0}^2}\"]),\n",
        "            lag_ratio=0.7\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(\n",
        "                    *exprs[1][R\"\\pi \\int_0^\\infty\"],\n",
        "                    *anti_derivative\n",
        "                ).copy(),\n",
        "                exprs[2]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(exprs[2].copy(), exprs[3]))\n",
        "        self.wait()\n",
        "\n",
        "        # Simplify\n",
        "        rects = VGroup(\n",
        "            SurroundingRectangle(exprs[2][R\"-e^{-{\\infty}^2}\"]),\n",
        "            SurroundingRectangle(exprs[2][R\"-e^{-{0}^2}\"]),\n",
        "        )\n",
        "        rects.set_stroke(TEAL, 1)\n",
        "        values = VGroup(*map(Integer, [0, -1]))\n",
        "        for value, rect in zip(values, rects):\n",
        "            value.next_to(rect, DOWN)\n",
        "            value.match_color(rect)\n",
        "\n",
        "        zero, one = values\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(integrand_rect, rects[0]),\n",
        "            integrand_rect.animate.set_stroke(YELLOW, 1, 0.5)\n",
        "        )\n",
        "        self.play(FadeIn(zero, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(*rects))\n",
        "        self.play(FadeIn(one, 0.5 * DOWN))\n",
        "        self.wait()\n",
        "        self.play(Write(exprs[3]))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight answer\n",
        "        answer = exprs[3][R\"\\pi\"]\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                integrand_rect, arrow, arrow_label, anti_derivative,\n",
        "                *rects, *values\n",
        "            )),\n",
        "            answer.animate.scale(2, about_edge=LEFT)\n",
        "        )\n",
        "        self.play(FlashAround(answer, run_time=2, time_width=1.5, color=TEAL))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CartesianSlices(GaussianIntegral):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.frame\n",
        "        axes = self.get_axes()\n",
        "\n",
        "        graph = self.get_gaussian_graph(axes)\n",
        "        graph_mesh = SurfaceMesh(graph, resolution=(21, 21))\n",
        "        graph_mesh.set_stroke(WHITE, 0.5, opacity=0.25)\n",
        "        graph_mesh.set_flat_stroke(False)\n",
        "\n",
        "        self.add(axes, graph, graph_mesh)\n",
        "\n",
        "        # Dynamic slice\n",
        "        x_slice, y_tracker = self.get_dynamic_slice(axes)\n",
        "        y_unit = axes.y_axis.get_unit_size()\n",
        "        graph.add_updater(lambda m: m.set_clip_plane(UP, -y_tracker.get_value() * y_unit))\n",
        "\n",
        "        x_max = axes.x_range[1]\n",
        "        y_tracker.set_value(x_max)\n",
        "        self.add(x_slice)\n",
        "        self.play(\n",
        "            y_tracker.animate.set_value(-x_max),\n",
        "            run_time=5,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show many slices\n",
        "        def get_x_slices(dx=0.25):\n",
        "            original_y_value = y_tracker.get_value()\n",
        "            x_slices = VGroup()\n",
        "            x_min, x_max = axes.x_range[:2]\n",
        "            for y in np.arange(x_max, x_min, -dx):\n",
        "                y_tracker.set_value(y)\n",
        "                x_slice.update()\n",
        "                x_slices.add(x_slice.copy().clear_updaters())\n",
        "            x_slices.use_winding_fill(False)\n",
        "            x_slices.deactivate_depth_test()\n",
        "            x_slices.set_stroke(BLUE, 2, 0.5)\n",
        "            x_slices.set_flat_stroke(False)\n",
        "            y_tracker.set_value(original_y_value)\n",
        "            return x_slices\n",
        "\n",
        "        x_slices = get_x_slices(dx=0.25)\n",
        "        self.add(x_slice, x_slices, graph, graph_mesh)\n",
        "        self.play(\n",
        "            FadeOut(graph, time_span=(0, 1)),\n",
        "            FadeOut(x_slice, time_span=(0, 1)),\n",
        "            FadeIn(x_slices, 0.1 * OUT, lag_ratio=0.1),\n",
        "            axes.labels[2].animate.set_opacity(0),\n",
        "            frame.animate.reorient(-80),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-100),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "        y_tracker.set_value(-x_max)\n",
        "        self.add(x_slice, x_slices, graph, graph_mesh)\n",
        "        self.play(\n",
        "            FadeOut(x_slices, 0.1 * IN, time_span=(0, 2.5)),\n",
        "            FadeIn(graph, time_span=(0, 2.5)),\n",
        "            VFadeIn(x_slice),\n",
        "            frame.animate.reorient(-15).set_height(6),\n",
        "            y_tracker.animate.set_value(0),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Discuss area of each slice\n",
        "        tex_kw = dict(\n",
        "            font_size=42,\n",
        "            t2c={\"x\": BLUE, \"y\": YELLOW}\n",
        "        )\n",
        "        get_y = y_tracker.get_value\n",
        "        x_slice_label = Tex(\"0.00 e^{-x^2}\", **tex_kw)\n",
        "        coef = x_slice_label.make_number_changeable(\"0.00\")\n",
        "        coef.set_color(YELLOW)\n",
        "        coef.add_updater(lambda m: m.set_value(math.exp(-get_y()**2)).rotate(90 * DEGREES, RIGHT))\n",
        "\n",
        "        x_term = x_slice_label[1:]\n",
        "        brace = Brace(coef, UP, MED_SMALL_BUFF)\n",
        "        y_term = Tex(\"e^{-y^2}\", **tex_kw)\n",
        "        y_term.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        y0_label = Tex(\"y = 0\", **tex_kw)\n",
        "        y0_label.rotate(90 * DEGREES, RIGHT)\n",
        "        y0_label.next_to(x_slice.pfp(0.35), OUT + LEFT)\n",
        "\n",
        "        x_slice_label.add(brace, y_term)\n",
        "        x_slice_label.rotate(90 * DEGREES, RIGHT)\n",
        "        x_slice_label.add_updater(lambda m: m.next_to(x_slice.pfp(0.6), OUT + RIGHT))\n",
        "\n",
        "        x_slice_label.save_state()\n",
        "        y_term.next_to(x_term, LEFT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "        brace.scale(0, about_edge=IN)\n",
        "        coef.scale(0, about_edge=IN)\n",
        "        swap = Swap(x_term, y_term)\n",
        "        swap.begin()\n",
        "        swap.update(1)\n",
        "\n",
        "        func_label = Tex(R\"e^{-(x^2 + y^2)}\", **tex_kw)\n",
        "        func_label.rotate(90 * DEGREES, RIGHT)\n",
        "        func_label.next_to(x_slice_label, OUT, MED_LARGE_BUFF)\n",
        "\n",
        "        fx0 = Tex(R\"e^{-(x^2 + 0^2)} = e^{-x^2}\", **tex_kw)\n",
        "        fx0.rotate(90 * DEGREES, RIGHT)\n",
        "        fx0.next_to(func_label, IN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        fx0[\"0\"].set_color(YELLOW)\n",
        "\n",
        "        self.always_depth_test = False\n",
        "        self.play(\n",
        "            *(\n",
        "                VShowPassingFlash(mob, time_width=1.5, run_time=3)\n",
        "                for mob in [\n",
        "                    x_slice.copy().set_stroke(YELLOW, 8).set_fill(opacity=0).shift(0.02 * OUT),\n",
        "                    Line(*axes.x_axis.get_start_and_end()).set_stroke(YELLOW, 8).insert_n_curves(40),\n",
        "                ]\n",
        "            ),\n",
        "            Write(y0_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(func_label))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(func_label.copy(), fx0, lag_ratio=0.025))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(fx0, RIGHT, rate_func=running_start))\n",
        "\n",
        "        self.play(TransformMatchingShapes(func_label.copy(), x_slice_label))\n",
        "        self.wait()\n",
        "        self.play(Swap(x_term, y_term, path_arc=0.5 * PI))\n",
        "        self.play(\n",
        "            Restore(x_slice_label),\n",
        "            FadeOut(func_label, OUT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Note the area\n",
        "        def get_area_label():\n",
        "            area_label = TexText(R\"Area = $0.00 \\cdot C$\", font_size=30)\n",
        "            area_label[\"C\"].set_color(RED)\n",
        "            num = area_label.make_number_changeable(\"0.00\")\n",
        "            num.set_value(coef.get_value())\n",
        "            area_label.rotate(90 * DEGREES, RIGHT)\n",
        "            area_label.move_to(interpolate(x_slice.get_zenith(), x_slice.get_nadir(), 0.66))\n",
        "            area_label.shift(0.1 * DOWN)\n",
        "            return area_label\n",
        "\n",
        "        self.play(FadeIn(get_area_label(), run_time=3, rate_func=there_and_back_with_pause))\n",
        "\n",
        "        # Move the slice\n",
        "        y0_slice_copy = x_slice.copy()\n",
        "        y0_slice_copy.clear_updaters()\n",
        "        y0_slice_copy.set_fill(opacity=0)\n",
        "        self.play(FadeOut(y0_label))\n",
        "        for value in [-0.5, -0.75, -1]:\n",
        "            self.play(y_tracker.animate.set_value(value), run_time=3)\n",
        "            slice_copy = y0_slice_copy.copy().set_opacity(0)\n",
        "            area_label = get_area_label()\n",
        "            self.play(FadeIn(area_label))\n",
        "            self.play(slice_copy.animate.match_y(x_slice).set_stroke(YELLOW, 3, 1))\n",
        "            self.wait(0.25)\n",
        "            self.play(slice_copy.animate.match_depth(x_slice, stretch=True, about_edge=IN).set_opacity(0))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(area_label))\n",
        "\n",
        "        # Go back to finer slices\n",
        "        x_slices = get_x_slices(dx=0.1)\n",
        "        y_tracker.set_value(-1)\n",
        "\n",
        "        self.add(x_slices, graph, graph_mesh)\n",
        "        self.play(\n",
        "            FadeIn(x_slices, 0.1 * OUT, lag_ratio=0.1, run_time=4),\n",
        "            FadeOut(graph),\n",
        "            FadeOut(x_slice, time_span=(3, 4)),\n",
        "            FadeOut(x_slice_label, time_span=(3, 4)),\n",
        "            frame.animate.reorient(-83, 72, 0).set_height(8).center().set_anim_args(run_time=5)\n",
        "        )\n",
        "\n",
        "        # Ambient rotation\n",
        "        t0 = self.time\n",
        "        theta0 = frame.get_theta()\n",
        "        frame.clear_updaters()\n",
        "        frame.add_updater(lambda m: m.set_theta(\n",
        "            theta0 + -0.2 * math.sin(0.1 * (self.time - t0))\n",
        "        ))\n",
        "        self.wait(10)\n",
        "\n",
        "        # Show slice width\n",
        "        mid_index = len(x_slices) // 2 - 3\n",
        "        line = Line(x_slices[mid_index].get_zenith(), x_slices[mid_index + 1].get_zenith())\n",
        "        brace = Brace(Line().set_width(line.get_length()), UP)\n",
        "        brace.stretch(0.5, 1)\n",
        "        brace.add(brace.get_tex(\"dy\", buff=SMALL_BUFF).scale(0.75, about_edge=DOWN))\n",
        "        brace.rotate(90 * DEGREES, RIGHT)\n",
        "        brace.rotate(90 * DEGREES, IN)\n",
        "        brace.next_to(line, OUT, buff=0)\n",
        "        brace.use_winding_fill(False)\n",
        "        self.play(FadeIn(brace))\n",
        "        self.wait(60)\n",
        "\n",
        "\n",
        "class CartesianSliceOverlay(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show integral\n",
        "        kw = dict(\n",
        "            t2c={\"{x}\": BLUE, \"{y}\": YELLOW, \"C\": RED},\n",
        "            font_size=48,\n",
        "        )\n",
        "        integral1 = Tex(R\"\\int_{-\\infty}^\\infty C \\cdot e^{-{y}^2} d{y}\", **kw)\n",
        "        integral2 = Tex(R\"= C \\int_{-\\infty}^\\infty e^{-{y}^2}d{y}\", **kw)\n",
        "        rhs = Tex(R\"= C^2\", **kw)\n",
        "        top_eq = VGroup(integral1, integral2, rhs)\n",
        "        top_eq.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        top_eq.to_corner(UL)\n",
        "        for part in top_eq:\n",
        "            part.shift((integral1[0].get_y() - part[0].get_y()) * UP)\n",
        "\n",
        "        self.play(FadeIn(integral1))\n",
        "        self.wait()\n",
        "\n",
        "        # Spell out meanings of each part\n",
        "        area_part = integral1[R\"C \\cdot e^{-{y}^2}\"]\n",
        "        volume_part = integral1[R\"C \\cdot e^{-{y}^2} d{y}\"]\n",
        "        area_rect = SurroundingRectangle(area_part, buff=0.05)\n",
        "        volume_rect = SurroundingRectangle(volume_part, buff=0.05)\n",
        "        rects = VGroup(area_rect, volume_rect)\n",
        "        rects.set_stroke(TEAL, 1)\n",
        "        rects.set_fill(TEAL, 0.25)\n",
        "\n",
        "        area_word = Text(\"Area of a slice\")\n",
        "        volume_word = Text(\"Volume of a slice\")\n",
        "        words = VGroup(area_word, volume_word)\n",
        "        arrows = VGroup()\n",
        "        for word, rect in zip(words, rects):\n",
        "            word.next_to(rect, DOWN, LARGE_BUFF, LEFT)\n",
        "            arrows.add(Arrow(rect, word))\n",
        "\n",
        "        self.add(area_rect, integral1)\n",
        "        self.play(\n",
        "            FadeIn(area_rect),\n",
        "            GrowArrow(arrows[0]),\n",
        "            FadeIn(area_word)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(*rects),\n",
        "            Transform(*arrows),\n",
        "            TransformMatchingStrings(area_word, volume_word, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [area_rect, arrows[0], volume_word]))\n",
        "        self.wait()\n",
        "\n",
        "        # Show meaning of C\n",
        "        sub_int = Tex(R\"C = \\int_{-\\infty}^\\infty e^{-{x}^2} d{x}\", **kw)\n",
        "        sub_int.next_to(top_eq, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        box = SurroundingRectangle(sub_int)\n",
        "        box.set_stroke(RED, 2)\n",
        "\n",
        "        arrow = Arrow(integral1[\"C\"], box, stroke_color=RED)\n",
        "\n",
        "        for mob in box, sub_int:\n",
        "            mob.save_state()\n",
        "            mob.replace(integral1[\"C\"], stretch=True)\n",
        "            mob.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Restore(box),\n",
        "            Restore(sub_int),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(integral1.copy(), integral2, path_arc=30 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        # Expand\n",
        "        box2 = SurroundingRectangle(integral2[2:], buff=SMALL_BUFF)\n",
        "        box2.set_stroke(RED, 1)\n",
        "        self.play(TransformFromCopy(box, box2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(box2),\n",
        "            Write(rhs)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize C^2\n",
        "        C2 = rhs[\"C^2\"]\n",
        "        everything = VGroup(integral1, integral2, sub_int)\n",
        "        self.play(C2.animate.scale(2, about_point=C2.get_left() + 0.1 * LEFT))\n",
        "        self.play(\n",
        "            FlashAround(C2, time_width=1.5, run_time=3),\n",
        "            everything.animate.set_opacity(0.7),\n",
        "        )\n",
        "        self.wait()"
    ]
}