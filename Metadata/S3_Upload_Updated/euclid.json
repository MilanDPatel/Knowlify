{
    "topic": "demonstrates the concept of a cone and its projection onto a flat surface.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class FlattenCone(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add surfaces\n",
        "        frame = self.frame\n",
        "        radius = 3.0\n",
        "        axes = ThreeDAxes()\n",
        "        axes.set_stroke(WHITE, width=2, opacity=0.5)\n",
        "        axes.set_anti_alias_width(5)\n",
        "        axes.apply_depth_test()\n",
        "        axes.set_z_index(1)\n",
        "        self.add(axes)\n",
        "\n",
        "        kw = dict(radius=0.1)\n",
        "        tracking_dots = Group(\n",
        "            TrueDot(2 * RIGHT, color=RED, **kw),\n",
        "            TrueDot(2 * LEFT, color=RED, **kw),\n",
        "            TrueDot(2 * UP, color=GREEN, **kw),\n",
        "            TrueDot(2 * DOWN, color=GREEN, **kw),\n",
        "            TrueDot(2 * IN, color=BLUE, **kw),\n",
        "            TrueDot(2 * OUT, color=BLUE, **kw),\n",
        "        )\n",
        "        for dot in tracking_dots:\n",
        "            dot.make_3d()\n",
        "        tracking_dots.set_z_index(2)\n",
        "        tracking_dots.deactivate_depth_test()\n",
        "        self.add(tracking_dots)\n",
        "\n",
        "        theta = TAU * math.sin(TAU / 8)  # Angle off slice of paper\n",
        "\n",
        "        def cone_func(u, v):\n",
        "            return np.array([\n",
        "                u * math.cos(TAU * v),\n",
        "                u * math.sin(TAU * v),\n",
        "                0.5 * radius - u\n",
        "            ])\n",
        "\n",
        "        def flat_cone_func(u, v):\n",
        "            return np.array([\n",
        "                u * math.cos(theta * v + 0.5 * (TAU - theta)),\n",
        "                u * math.sin(theta * v + 0.5 * (TAU - theta)),\n",
        "                0,\n",
        "            ])\n",
        "\n",
        "        range_kw = dict(\n",
        "            u_range=(0, radius),\n",
        "            v_range=(0, 1)\n",
        "        )\n",
        "        cone = ParametricSurface(cone_func, **range_kw)\n",
        "        flat_cone = ParametricSurface(flat_cone_func, **range_kw)\n",
        "\n",
        "        for surface in [cone, flat_cone]:\n",
        "            surface.set_color(GREY_D)\n",
        "            surface.set_shading(0.5, 0.25, 0.5)\n",
        "\n",
        "        frame.reorient(-25, 69, 0)\n",
        "        frame.set_x(1e-1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(50, 80, 0),\n",
        "            ShowCreation(cone, time_span=(0, 2)),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        # Add line\n",
        "        def get_line(uv_func):\n",
        "            line = Line().set_stroke(RED, 5)\n",
        "            line.set_points_as_corners([\n",
        "                uv_func(radius, 0.75),\n",
        "                uv_func(0, 0.75),\n",
        "                uv_func(radius, 0.25),\n",
        "            ])\n",
        "            line.apply_depth_test()\n",
        "            line.shift(1e-2 * OUT)\n",
        "            return line\n",
        "\n",
        "        def get_div_line(uv_func):\n",
        "            line = DashedLine(uv_func(radius, 0.5), uv_func(0, 0)).set_stroke(YELLOW, 4)\n",
        "            line.apply_depth_test()\n",
        "            line.shift(1e-2 * OUT)\n",
        "            return line\n",
        "\n",
        "        cone_line = get_line(cone_func)\n",
        "        flat_line = get_line(flat_cone_func)\n",
        "\n",
        "        cone_div_line = get_div_line(cone_func)\n",
        "        flat_div_line = get_div_line(flat_cone_func)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(cone_line, time_span=(0, 3)),\n",
        "            frame.animate.reorient(0, 2, 0),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(ShowCreation(cone_div_line))\n",
        "        self.wait()\n",
        "\n",
        "        # Flatten\n",
        "        kw = dict(time_span=(1.5, 3))\n",
        "        self.play(\n",
        "            Transform(cone, flat_cone, **kw),\n",
        "            Transform(cone_line, flat_line, **kw),\n",
        "            Transform(cone_div_line, flat_div_line, **kw),\n",
        "            frame.animate.reorient(21, 74, 0),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(frame.animate.reorient(0, 0, 0), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SquareOnASphere(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add sphere\n",
        "        frame = self.frame\n",
        "        self.camera.light_source.set_y(5)\n",
        "        sphere = Sphere()\n",
        "        sphere.set_color(GREY_D)\n",
        "        sphere.set_shading(0.5, 0.25, 0.25)\n",
        "        mesh = SurfaceMesh(sphere, resolution=(41, 21), normal_nudge=1e-3)\n",
        "        mesh.set_stroke(WHITE, 1, 0.25)\n",
        "\n",
        "        frame.reorient(0, 84, 0, ORIGIN, 2.50)\n",
        "        self.add(sphere, mesh)\n",
        "\n",
        "        # Show \"square\" lines\n",
        "        arc_len = 40 * DEG\n",
        "        u0 = 270 * DEG\n",
        "        v0 = 100 * DEG\n",
        "\n",
        "        line1 = ParametricCurve(lambda t: sphere.uv_func(u0, v0 + arc_len * t))\n",
        "        line1.set_stroke(RED_D, 3)\n",
        "        all_lines = VGroup(line1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line1, time_span=(0, 2)),\n",
        "            frame.animate.reorient(5, 57, 0),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        orientations = [\n",
        "            (32, 65, 0),\n",
        "            (23, 85, 0),\n",
        "            (6, 84, 0),\n",
        "        ]\n",
        "\n",
        "        for orientation in orientations:\n",
        "            last_line = all_lines[-1]\n",
        "            elbow = self.get_elbow(last_line)\n",
        "            new_line = last_line.copy()\n",
        "            new_line = self.get_rotated_arc(last_line, 90 * DEG)\n",
        "            new_line.reverse_points()\n",
        "            self.play(\n",
        "                ShowCreation(new_line, time_span=(0, 2)),\n",
        "                ShowCreation(elbow, time_span=(0, 1)),\n",
        "                frame.animate.reorient(*orientation),\n",
        "                run_time=3\n",
        "            )\n",
        "            all_lines.add(new_line)\n",
        "\n",
        "        # Show transitions\n",
        "        for line in all_lines[:3]:\n",
        "            anim = UpdateFromAlphaFunc(\n",
        "                line.copy(),\n",
        "                lambda m, a: m.match_points(self.get_rotated_arc(line, a * 90 * DEG)),\n",
        "                run_time=3,\n",
        "                time_span=(0, 2)\n",
        "            )\n",
        "            if line is all_lines[0]:\n",
        "                self.play(\n",
        "                    anim,\n",
        "                    frame.animate.reorient(7, 61, 0, (-0.02, -0.01, -0.01), 2.68).set_anim_args(run_time=3)\n",
        "                )\n",
        "                frame.add_ambient_rotation(2 * DEG)\n",
        "            else:\n",
        "                self.play(anim)\n",
        "        self.wait(5)\n",
        "\n",
        "    def get_rotated_arc(self, arc, angle):\n",
        "        return arc.copy().rotate(angle, about_point=arc.get_end(), axis=arc.get_end())\n",
        "\n",
        "    def get_elbow(self, arc, prop=0.1):\n",
        "        corner = arc.get_end()\n",
        "        rot_arc = self.get_rotated_arc(arc, 90 * DEG)\n",
        "        v1 = arc.get_points()[-2] - corner\n",
        "        v2 = rot_arc.get_points()[-2] - corner\n",
        "        elbow = VMobject()\n",
        "        elbow.set_points_as_corners([corner + v1, corner + v1 + v2, corner + v2])\n",
        "        elbow.set_stroke(WHITE, 2)\n",
        "        return elbow\n"
    ]
}