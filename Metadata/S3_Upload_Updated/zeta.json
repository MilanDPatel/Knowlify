{
    "topic": "demonstrates the transformation of a complex function, specifically the zeta function, using Man",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "import mpmath\n",
        "mpmath.mp.dps = 7\n",
        "\n",
        "\n",
        "def zeta(z):\n",
        "    max_norm = FRAME_X_RADIUS\n",
        "    try:\n",
        "        return np.complex(mpmath.zeta(z))\n",
        "    except:\n",
        "        return np.complex(max_norm, 0)\n",
        "\n",
        "\n",
        "def d_zeta(z):\n",
        "    epsilon = 0.01\n",
        "    return (zeta(z + epsilon) - zeta(z))/epsilon\n",
        "\n",
        "\n",
        "class ComplexTransformationScene(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ZetaTransformationScene(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 35,\n",
        "        \"min_added_anchors\" : 10,\n",
        "        \"max_added_anchors\" : 300,\n",
        "        \"num_anchors_to_add_per_line\" : 75,\n",
        "        \"post_transformation_stroke_width\" : 2,\n",
        "        \"default_apply_complex_function_kwargs\" : {\n",
        "            \"run_time\" : 5,\n",
        "        },\n",
        "        \"x_min\" : 1,\n",
        "        \"x_max\" : int(FRAME_X_RADIUS+2),\n",
        "        \"extra_lines_x_min\" : -2,\n",
        "        \"extra_lines_x_max\" : 4,\n",
        "        \"extra_lines_y_min\" : -2,\n",
        "        \"extra_lines_y_max\" : 2,\n",
        "    }\n",
        "    def prepare_for_transformation(self, mob):\n",
        "        for line in mob.family_members_with_points():\n",
        "            #Find point of line cloest to 1 on C\n",
        "            if not isinstance(line, Line):\n",
        "                line.insert_n_curves(self.min_added_anchors)\n",
        "                continue\n",
        "            p1 = line.get_start()+LEFT\n",
        "            p2 = line.get_end()+LEFT\n",
        "            t = (-np.dot(p1, p2-p1))/(get_norm(p2-p1)**2)\n",
        "            closest_to_one = interpolate(\n",
        "                line.get_start(), line.get_end(), t\n",
        "            )\n",
        "            #See how big this line will become\n",
        "            diameter = abs(zeta(complex(*closest_to_one[:2])))\n",
        "            target_num_curves = np.clip(\n",
        "                int(self.anchor_density*np.pi*diameter),\n",
        "                self.min_added_anchors,\n",
        "                self.max_added_anchors,\n",
        "            )\n",
        "            num_curves = line.get_num_curves()\n",
        "            if num_curves < target_num_curves:\n",
        "                line.insert_n_curves(target_num_curves-num_curves)\n",
        "            line.make_smooth()\n",
        "\n",
        "    def add_extra_plane_lines_for_zeta(self, animate = False, **kwargs):\n",
        "        dense_grid = self.get_dense_grid(**kwargs)\n",
        "        if animate:\n",
        "            self.play(ShowCreation(dense_grid))\n",
        "        self.plane.add(dense_grid)\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def get_dense_grid(self, step_size = 1./16):\n",
        "        epsilon = 0.1\n",
        "        x_range = np.arange(\n",
        "            max(self.x_min, self.extra_lines_x_min),\n",
        "            min(self.x_max, self.extra_lines_x_max),\n",
        "            step_size\n",
        "        )\n",
        "        y_range = np.arange(\n",
        "            max(self.y_min, self.extra_lines_y_min),\n",
        "            min(self.y_max, self.extra_lines_y_max),\n",
        "            step_size\n",
        "        )\n",
        "        vert_lines = VGroup(*[\n",
        "            Line(\n",
        "                self.y_min*UP,\n",
        "                self.y_max*UP,\n",
        "            ).shift(x*RIGHT)\n",
        "            for x in x_range\n",
        "            if abs(x-1) > epsilon\n",
        "        ])\n",
        "        vert_lines.set_color_by_gradient(\n",
        "            self.vert_start_color, self.vert_end_color\n",
        "        )\n",
        "        horiz_lines = VGroup(*[\n",
        "            Line(\n",
        "                self.x_min*RIGHT,\n",
        "                self.x_max*RIGHT,\n",
        "            ).shift(y*UP)\n",
        "            for y in y_range\n",
        "            if abs(y) > epsilon\n",
        "        ])\n",
        "        horiz_lines.set_color_by_gradient(\n",
        "            self.horiz_start_color, self.horiz_end_color\n",
        "        )\n",
        "        dense_grid = VGroup(horiz_lines, vert_lines)\n",
        "        dense_grid.set_stroke(width = 1)\n",
        "        return dense_grid\n",
        "\n",
        "    def add_reflected_plane(self, animate = False):\n",
        "        reflected_plane = self.get_reflected_plane()\n",
        "        if animate:\n",
        "            self.play(ShowCreation(reflected_plane, run_time = 5))\n",
        "        self.plane.add(reflected_plane)\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def get_reflected_plane(self):\n",
        "        reflected_plane = self.plane.copy()\n",
        "        reflected_plane.rotate(np.pi, UP, about_point = RIGHT)\n",
        "        for mob in reflected_plane.family_members_with_points():\n",
        "            mob.set_color(\n",
        "                Color(rgb = 1-0.5*color_to_rgb(mob.get_color()))\n",
        "            )\n",
        "        self.prepare_for_transformation(reflected_plane)\n",
        "        reflected_plane.submobjects = list(reversed(\n",
        "            reflected_plane.family_members_with_points()\n",
        "        ))\n",
        "        return reflected_plane\n",
        "\n",
        "    def apply_zeta_function(self, **kwargs):\n",
        "        transform_kwargs = dict(self.default_apply_complex_function_kwargs)\n",
        "        transform_kwargs.update(kwargs)\n",
        "        self.apply_complex_function(zeta, **kwargs)\n",
        "\n",
        "class TestZetaOnHalfPlane(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.prepare_for_transformation(self.plane)\n",
        "        print(sum([\n",
        "            mob.get_num_points()\n",
        "            for mob in self.plane.family_members_with_points()\n",
        "        ]))\n",
        "        print(len(self.plane.family_members_with_points()))\n",
        "        self.apply_zeta_function()\n",
        "        self.wait()\n",
        "\n",
        "class TestZetaOnFullPlane(ZetaTransformationScene):\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane(animate = True)\n",
        "        self.add_extra_plane_lines_for_zeta(animate = True)\n",
        "        self.add_reflected_plane(animate = True)\n",
        "        self.apply_zeta_function()\n",
        "\n",
        "\n",
        "class TestZetaOnLine(ZetaTransformationScene):\n",
        "    def construct(self):\n",
        "        line = Line(UP+20*LEFT, UP+20*RIGHT)\n",
        "        self.add_transformable_plane()\n",
        "        self.plane.submobjects = [line]\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(line, run_time = 10))\n",
        "        self.wait(3)\n",
        "\n",
        "######################\n",
        "\n",
        "class IntroduceZeta(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"default_apply_complex_function_kwargs\" : {\n",
        "            \"run_time\" : 8,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Riemann zeta function\")\n",
        "        title.add_background_rectangle()\n",
        "        title.to_corner(UP+LEFT)\n",
        "        func_mob = VGroup(\n",
        "            OldTex(\"\\\\zeta(s) = \"),\n",
        "            OldTex(\"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\")\n",
        "        )\n",
        "        func_mob.arrange(RIGHT, buff = 0)\n",
        "        for submob in func_mob:\n",
        "            submob.add_background_rectangle()\n",
        "        func_mob.next_to(title, DOWN)\n",
        "\n",
        "        randy = Randolph().flip()\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.add_foreground_mobjects(title, func_mob)\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.play(ShowCreation(self.plane, run_time = 2))\n",
        "        reflected_plane = self.get_reflected_plane()\n",
        "        self.play(ShowCreation(reflected_plane, run_time = 2))\n",
        "        self.plane.add(reflected_plane)\n",
        "        self.wait()\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, func_mob,\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class WhyPeopleMayKnowIt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Riemann zeta function\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        func_mob = OldTex(\n",
        "            \"\\\\zeta(s) = \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\"\n",
        "        )\n",
        "        func_mob.next_to(title, DOWN, aligned_edge = LEFT)\n",
        "        self.add(title, func_mob)\n",
        "\n",
        "        mercenary_thought = VGroup(\n",
        "            OldTex(\"\\\\$1{,}000{,}000\").set_color_by_gradient(GREEN_B, GREEN_D),\n",
        "            OldTex(\"\\\\zeta(s) = 0\")\n",
        "        )\n",
        "        mercenary_thought.arrange(DOWN)\n",
        "        divergent_sum = VGroup(\n",
        "            OldTex(\"1+2+3+4+\\\\cdots = -\\\\frac{1}{12}\"),\n",
        "            OldTex(\"\\\\zeta(-1) = -\\\\frac{1}{12}\")\n",
        "        )\n",
        "        divergent_sum.arrange(DOWN)\n",
        "        divergent_sum[0].set_color_by_gradient(YELLOW, MAROON_B)\n",
        "        divergent_sum[1].set_color(BLACK)\n",
        "\n",
        "        #Thoughts\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, \"pondering\", pi.look_at, func_mob]\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ]))\n",
        "        self.random_blink()\n",
        "        self.student_thinks(\n",
        "            mercenary_thought, index = 2,\n",
        "            target_mode = \"surprised\",\n",
        "        )\n",
        "        student = self.get_students()[2]\n",
        "        self.random_blink()\n",
        "        self.wait(2)\n",
        "        self.student_thinks(\n",
        "            divergent_sum, index = 1,\n",
        "            added_anims = [student.change_mode, \"plain\"]\n",
        "        )\n",
        "        student = self.get_students()[1]\n",
        "        self.play(\n",
        "            student.change_mode, \"confused\",\n",
        "            student.look_at, divergent_sum,\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, \"confused\", pi.look_at, divergent_sum]\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ]))\n",
        "        self.wait()\n",
        "        self.random_blink()\n",
        "        divergent_sum[1].set_color(WHITE)\n",
        "        self.play(Write(divergent_sum[1]))\n",
        "        self.random_blink()\n",
        "        self.wait()\n",
        "\n",
        "        #Ask about continuation\n",
        "        self.student_says(\n",
        "            OldTexText(\"Can you explain \\\\\\\\\" , \"``analytic continuation''?\"),\n",
        "            index = 1,\n",
        "            target_mode = \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"raise_left_hand\",\n",
        "            \"raise_right_hand\",\n",
        "            \"raise_left_hand\",\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_teacher().change_mode, \"happy\",\n",
        "            self.get_teacher().look_at, student.eyes,\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.wait(2)\n",
        "        self.random_blink()\n",
        "        self.wait()\n",
        "\n",
        "class ComplexValuedFunctions(ComplexTransformationScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Complex-valued function\")\n",
        "        title.scale(1.5)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        z_in = Dot(UP+RIGHT, color = YELLOW)\n",
        "        z_out = Dot(4*RIGHT + 2*UP, color = MAROON_B)\n",
        "        arrow = Arrow(z_in, z_out, buff = 0.1)\n",
        "        arrow.set_color(WHITE)\n",
        "        z = OldTex(\"z\").next_to(z_in, DOWN+LEFT, buff = SMALL_BUFF)\n",
        "        z.set_color(z_in.get_color())\n",
        "        f_z = OldTex(\"f(z)\").next_to(z_out, UP+RIGHT, buff = SMALL_BUFF)\n",
        "        f_z.set_color(z_out.get_color())\n",
        "\n",
        "        self.add(z_in, z)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(\n",
        "            ShowCreation(z_out),\n",
        "            Write(f_z)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class PreviewZetaAndContinuation(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"default_apply_complex_function_kwargs\" : {\n",
        "            \"run_time\" : 4,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        reflected_plane = self.get_reflected_plane()\n",
        "\n",
        "        titles = [\n",
        "            OldTexText(\n",
        "                \"What does\", \"%s\"%s,\n",
        "                \"look like?\",\n",
        "                alignment = \"\",\n",
        "            )\n",
        "            for s in [\n",
        "                \"$\\\\displaystyle \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}$\",\n",
        "                \"analytic continuation\"\n",
        "            ]\n",
        "        ]\n",
        "        for mob in titles:\n",
        "            mob[1].set_color(YELLOW)\n",
        "            mob.to_corner(UP+LEFT, buff = 0.7)\n",
        "            mob.add_background_rectangle()\n",
        "\n",
        "        self.remove(self.plane)\n",
        "        self.play(Write(titles[0], run_time = 2))\n",
        "        self.add_foreground_mobjects(titles[0])\n",
        "        self.play(FadeIn(self.plane))\n",
        "        self.apply_zeta_function()\n",
        "        reflected_plane.apply_complex_function(zeta)\n",
        "        reflected_plane.make_smooth()\n",
        "        reflected_plane.set_stroke(width = 2)\n",
        "        self.wait()\n",
        "        self.play(Transform(*titles))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            reflected_plane,\n",
        "            lag_ratio = 0,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class AssumeKnowledgeOfComplexNumbers(ComplexTransformationScene):\n",
        "    def construct(self):\n",
        "        z = complex(5, 2)\n",
        "        dot = Dot(z.real*RIGHT + z.imag*UP, color = YELLOW)\n",
        "        line = Line(ORIGIN, dot.get_center(), color = dot.get_color())\n",
        "        x_line = Line(ORIGIN, z.real*RIGHT, color = GREEN_B)\n",
        "        y_line = Line(ORIGIN, z.imag*UP, color = RED)\n",
        "        y_line.shift(z.real*RIGHT)\n",
        "        complex_number_label = OldTex(\n",
        "            \"%d+%di\"%(int(z.real), int(z.imag))\n",
        "        )\n",
        "        complex_number_label[0].set_color(x_line.get_color())\n",
        "        complex_number_label[2].set_color(y_line.get_color())\n",
        "        complex_number_label.next_to(dot, UP)\n",
        "\n",
        "        text = VGroup(\n",
        "            OldTexText(\"Assumed knowledge:\"),\n",
        "            OldTexText(\"1) What complex numbers are.\"),\n",
        "            OldTexText(\"2) How to work with them.\"),\n",
        "            OldTexText(\"3) Maybe derivatives?\"),\n",
        "        )\n",
        "        text.arrange(DOWN, aligned_edge = LEFT)\n",
        "        for words in text:\n",
        "            words.add_background_rectangle()\n",
        "        text[0].shift(LEFT)\n",
        "        text[-1].set_color(PINK)\n",
        "        text.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(Write(text[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(text[1]))\n",
        "        self.play(\n",
        "            ShowCreation(x_line),\n",
        "            ShowCreation(y_line),\n",
        "            ShowCreation(VGroup(line, dot)),\n",
        "            Write(complex_number_label),\n",
        "        )\n",
        "        self.play(Write(text[2]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(text[3]))\n",
        "        self.wait()\n",
        "        self.play(text[3].fade)\n",
        "\n",
        "class DefineForRealS(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        zeta_def, s_group = self.get_definition(\"s\")\n",
        "\n",
        "        self.initial_definition(zeta_def)\n",
        "        self.plug_in_two(zeta_def)\n",
        "        self.plug_in_three_and_four(zeta_def)\n",
        "        self.plug_in_negative_values(zeta_def)\n",
        "\n",
        "    def initial_definition(self, zeta_def):\n",
        "        zeta_s, sum_terms, brace, sigma = zeta_def\n",
        "\n",
        "        self.say(\"Let's define $\\\\zeta(s)$\")\n",
        "        self.blink()\n",
        "        pre_zeta_s = VGroup(\n",
        "            *self.pi_creature.bubble.content.copy()[-4:]\n",
        "        )\n",
        "        pre_zeta_s.add(VectorizedPoint(pre_zeta_s.get_right()))\n",
        "        self.play(\n",
        "            Transform(pre_zeta_s, zeta_s),\n",
        "            *self.get_bubble_fade_anims()\n",
        "        )\n",
        "        self.remove(pre_zeta_s)\n",
        "        self.add(zeta_s)\n",
        "        self.wait()\n",
        "\n",
        "        for count, term in enumerate(sum_terms):\n",
        "            self.play(FadeIn(term), run_time = 0.5)\n",
        "            if count%2 == 0:\n",
        "                self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(sigma),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def plug_in_two(self, zeta_def):\n",
        "        two_def = self.get_definition(\"2\")[0]\n",
        "        number_line = NumberLine(\n",
        "            x_min = 0,\n",
        "            x_max = 3,\n",
        "            tick_frequency = 0.25,\n",
        "            big_tick_numbers = list(range(4)),\n",
        "            unit_size = 3,\n",
        "        )\n",
        "        number_line.add_numbers()\n",
        "        number_line.next_to(self.pi_creature, LEFT)\n",
        "        number_line.to_edge(LEFT)\n",
        "        self.number_line = number_line\n",
        "\n",
        "        lines, braces, dots, pi_dot = self.get_sum_lines(2)\n",
        "        fracs = VGroup(*[\n",
        "            OldTex(\"\\\\frac{1}{%d}\"%((d+1)**2)).scale(0.7)\n",
        "            for d, brace in enumerate(braces)\n",
        "        ])\n",
        "        for frac, brace, line in zip(fracs, braces, lines):\n",
        "            frac.set_color(line.get_color())\n",
        "            frac.next_to(brace, UP, buff = SMALL_BUFF)\n",
        "            if frac is fracs[-1]:\n",
        "                frac.shift(0.5*RIGHT + 0.2*UP)\n",
        "                arrow = Arrow(\n",
        "                    frac.get_bottom(), brace.get_top(),\n",
        "                    tip_length = 0.1,\n",
        "                    buff = 0.1\n",
        "                )\n",
        "                arrow.set_color(line.get_color())\n",
        "                frac.add(arrow)\n",
        "\n",
        "        pi_term = OldTex(\"= \\\\frac{\\\\pi^2}{6}\")\n",
        "        pi_term.next_to(zeta_def[1], RIGHT)\n",
        "        pi_arrow = Arrow(\n",
        "            pi_term[-1].get_bottom(), pi_dot,\n",
        "            color = pi_dot.get_color()\n",
        "        )\n",
        "        approx = OldTex(\"\\\\approx 1.645\")\n",
        "        approx.next_to(pi_term)\n",
        "\n",
        "        self.play(Transform(zeta_def, two_def))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(number_line))\n",
        "\n",
        "        for frac, brace, line in zip(fracs, braces, lines):\n",
        "            self.play(\n",
        "                Write(frac),\n",
        "                GrowFromCenter(brace),\n",
        "                ShowCreation(line),\n",
        "                run_time = 0.7\n",
        "            )\n",
        "            self.wait(0.7)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(VGroup(*lines[4:])),\n",
        "            Write(dots)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(pi_term),\n",
        "            ShowCreation(VGroup(pi_arrow, pi_dot)),\n",
        "            self.pi_creature.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(approx),\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            fracs, pi_arrow, pi_dot, approx,\n",
        "        ])))\n",
        "        self.lines = lines\n",
        "        self.braces = braces\n",
        "        self.dots = dots\n",
        "        self.final_dot = pi_dot\n",
        "        self.final_sum = pi_term\n",
        "\n",
        "    def plug_in_three_and_four(self, zeta_def):\n",
        "        final_sums = [\"1.202\\\\dots\", \"\\\\frac{\\\\pi^4}{90}\"]\n",
        "        sum_terms, brace, sigma = zeta_def[1:]\n",
        "        for exponent, final_sum in zip([3, 4], final_sums):\n",
        "            self.transition_to_new_input(zeta_def, exponent, final_sum)\n",
        "            self.wait()\n",
        "\n",
        "        arrow = Arrow(sum_terms.get_left(), sum_terms.get_right())\n",
        "        arrow.next_to(sum_terms, DOWN)\n",
        "        smaller_words = OldTexText(\"Getting smaller\")\n",
        "        smaller_words.next_to(arrow, DOWN)\n",
        "        self.arrow, self.smaller_words = arrow, smaller_words\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(smaller_words)\n",
        "        )\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def plug_in_negative_values(self, zeta_def):\n",
        "        zeta_s, sum_terms, brace, sigma = zeta_def\n",
        "        arrow = self.arrow\n",
        "        smaller_words = self.smaller_words\n",
        "        bigger_words = OldTexText(\"Getting \\\\emph{bigger}?\")\n",
        "        bigger_words.move_to(self.smaller_words)\n",
        "\n",
        "        #plug in -1\n",
        "        self.transition_to_new_input(zeta_def, -1, \"-\\\\frac{1}{12}\")\n",
        "        self.play(\n",
        "            Transform(self.smaller_words, bigger_words),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        new_sum_terms = OldTex(\n",
        "            list(\"1+2+3+4+\") + [\"\\\\cdots\"]\n",
        "        )\n",
        "        new_sum_terms.move_to(sum_terms, LEFT)\n",
        "        arrow.target = arrow.copy().next_to(new_sum_terms, DOWN)\n",
        "        arrow.target.stretch_to_fit_width(new_sum_terms.get_width())\n",
        "        bigger_words.next_to(arrow.target, DOWN)\n",
        "        new_brace = Brace(new_sum_terms, UP)\n",
        "        self.play(\n",
        "            Transform(sum_terms, new_sum_terms),\n",
        "            Transform(brace, new_brace),\n",
        "            sigma.next_to, new_brace, UP,\n",
        "            MoveToTarget(arrow),\n",
        "            Transform(smaller_words, bigger_words),\n",
        "            self.final_sum.next_to, new_sum_terms, RIGHT\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        #plug in -2\n",
        "        new_sum_terms = OldTex(\n",
        "            list(\"1+4+9+16+\") + [\"\\\\cdots\"]\n",
        "        )\n",
        "        new_sum_terms.move_to(sum_terms, LEFT)\n",
        "        new_zeta_def, ignore = self.get_definition(\"-2\")\n",
        "        zeta_minus_two, ignore, ignore, new_sigma = new_zeta_def\n",
        "        new_sigma.next_to(brace, UP)\n",
        "        new_final_sum = OldTex(\"=0\")\n",
        "        new_final_sum.next_to(new_sum_terms)\n",
        "        lines, braces, dots, final_dot = self.get_sum_lines(-2)\n",
        "\n",
        "        self.play(\n",
        "            Transform(zeta_s, zeta_minus_two),\n",
        "            Transform(sum_terms, new_sum_terms),\n",
        "            Transform(sigma, new_sigma),\n",
        "            Transform(self.final_sum, new_final_sum),\n",
        "            Transform(self.lines, lines),\n",
        "            Transform(self.braces, braces),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_mode(\"pleading\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_definition(self, input_string, input_color = YELLOW):\n",
        "        inputs = VGroup()\n",
        "        num_shown_terms = 4\n",
        "        n_input_chars = len(input_string)\n",
        "\n",
        "        zeta_s_eq = OldTex(\"\\\\zeta(%s) = \"%input_string)\n",
        "        zeta_s_eq.to_edge(LEFT, buff = LARGE_BUFF)\n",
        "        zeta_s_eq.shift(0.5*UP)\n",
        "        inputs.add(*zeta_s_eq[2:2+n_input_chars])\n",
        "\n",
        "        sum_terms = OldTex(*it.chain(*list(zip(\n",
        "            [\n",
        "                \"\\\\frac{1}{%d^{%s}}\"%(d, input_string)\n",
        "                for d in range(1, 1+num_shown_terms)\n",
        "            ],\n",
        "            it.cycle([\"+\"])\n",
        "        ))))\n",
        "        sum_terms.add(OldTex(\"\\\\cdots\").next_to(sum_terms))\n",
        "        sum_terms.next_to(zeta_s_eq, RIGHT)\n",
        "        for x in range(num_shown_terms):\n",
        "            inputs.add(*sum_terms[2*x][-n_input_chars:])\n",
        "\n",
        "\n",
        "        brace = Brace(sum_terms, UP)\n",
        "        sigma = OldTex(\n",
        "            \"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^{%s}}\"%input_string\n",
        "        )\n",
        "        sigma.next_to(brace, UP)\n",
        "        inputs.add(*sigma[-n_input_chars:])\n",
        "\n",
        "        inputs.set_color(input_color)\n",
        "        group = VGroup(zeta_s_eq, sum_terms, brace, sigma)\n",
        "        return group, inputs\n",
        "\n",
        "    def get_sum_lines(self, exponent, line_thickness = 6):\n",
        "        num_lines = 100 if exponent > 0 else 6\n",
        "        powers = [0] + [x**(-exponent) for x in range(1, num_lines)]\n",
        "        power_sums = np.cumsum(powers)\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                self.number_line.number_to_point(s1),\n",
        "                self.number_line.number_to_point(s2),\n",
        "            )\n",
        "            for s1, s2 in zip(power_sums, power_sums[1:])\n",
        "        ])\n",
        "        lines.set_stroke(width = line_thickness)\n",
        "        # VGroup(*lines[:4]).set_color_by_gradient(RED, GREEN_B)\n",
        "        # VGroup(*lines[4:]).set_color_by_gradient(GREEN_B, MAROON_B)\n",
        "        VGroup(*lines[::2]).set_color(MAROON_B)\n",
        "        VGroup(*lines[1::2]).set_color(RED)\n",
        "\n",
        "        braces = VGroup(*[\n",
        "            Brace(line, UP)\n",
        "            for line in lines[:4]\n",
        "        ])\n",
        "        dots = OldTex(\"...\")\n",
        "        dots.stretch_to_fit_width(\n",
        "            0.8 * VGroup(*lines[4:]).get_width()\n",
        "        )\n",
        "        dots.next_to(braces, RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        final_dot = Dot(\n",
        "            self.number_line.number_to_point(power_sums[-1]),\n",
        "            color = GREEN_B\n",
        "        )\n",
        "\n",
        "        return lines, braces, dots, final_dot\n",
        "\n",
        "    def transition_to_new_input(self, zeta_def, exponent, final_sum):\n",
        "        new_zeta_def = self.get_definition(str(exponent))[0]\n",
        "        lines, braces, dots, final_dot = self.get_sum_lines(exponent)\n",
        "        final_sum = OldTex(\"=\" + final_sum)\n",
        "        final_sum.next_to(new_zeta_def[1][-1])\n",
        "        final_sum.shift(SMALL_BUFF*UP)\n",
        "        self.play(\n",
        "            Transform(zeta_def, new_zeta_def),\n",
        "            Transform(self.lines, lines),\n",
        "            Transform(self.braces, braces),\n",
        "            Transform(self.dots, dots),\n",
        "            Transform(self.final_dot, final_dot),\n",
        "            Transform(self.final_sum, final_sum),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "\n",
        "class ReadIntoZetaFunction(Scene):\n",
        "    CONFIG = {\n",
        "        \"statement\" : \"$\\\\zeta(-1) = -\\\\frac{1}{12}$\",\n",
        "        \"target_mode\" : \"frustrated\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        randy = Randolph(mode = \"pondering\")\n",
        "        randy.shift(3*LEFT+DOWN)\n",
        "        paper = Rectangle(width = 4, height = 5)\n",
        "        paper.next_to(randy, RIGHT, aligned_edge = DOWN)\n",
        "        paper.set_color(WHITE)\n",
        "        max_width = 0.8*paper.get_width()\n",
        "\n",
        "        title = OldTexText(\"$\\\\zeta(s)$ manual\")\n",
        "        title.next_to(paper.get_top(), DOWN)\n",
        "        title.set_color(YELLOW)\n",
        "        paper.add(title)\n",
        "        paragraph_lines = VGroup(\n",
        "            Line(LEFT, RIGHT),\n",
        "            Line(LEFT, RIGHT).shift(0.2*DOWN),\n",
        "            Line(LEFT, ORIGIN).shift(0.4*DOWN)\n",
        "        )\n",
        "        paragraph_lines.set_width(max_width)\n",
        "        paragraph_lines.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        paper.add(paragraph_lines)\n",
        "        max_height = 1.5*paragraph_lines.get_height()\n",
        "\n",
        "        statement = OldTexText(self.statement)\n",
        "        if statement.get_width() > max_width:\n",
        "            statement.set_width(max_width)\n",
        "        if statement.get_height() > max_height:\n",
        "            statement.set_height(max_height)\n",
        "\n",
        "        statement.next_to(paragraph_lines, DOWN)\n",
        "        statement.set_color(GREEN_B)\n",
        "        paper.add(paragraph_lines.copy().next_to(statement, DOWN, MED_LARGE_BUFF))\n",
        "\n",
        "        randy.look_at(statement)\n",
        "        self.add(randy, paper)\n",
        "        self.play(Write(statement))\n",
        "        self.play(\n",
        "            randy.change_mode, self.target_mode,\n",
        "            randy.look_at, title\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look_at, statement)\n",
        "        self.wait()\n",
        "\n",
        "class ReadIntoZetaFunctionTrivialZero(ReadIntoZetaFunction):\n",
        "    CONFIG = {\n",
        "        \"statement\" : \"$\\\\zeta(-2n) = 0$\"\n",
        "    }\n",
        "\n",
        "class ReadIntoZetaFunctionAnalyticContinuation(ReadIntoZetaFunction):\n",
        "    CONFIG = {\n",
        "        \"statement\" : \"...analytic \\\\\\\\ continuation...\",\n",
        "        \"target_mode\" : \"confused\",\n",
        "    }\n",
        "\n",
        "class IgnoreNegatives(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        definition = OldTex(\"\"\"\n",
        "            \\\\zeta(s) = \\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{n^s}\n",
        "        \"\"\")\n",
        "        VGroup(definition[2], definition[-1]).set_color(YELLOW)\n",
        "        definition.to_corner(UP+LEFT)\n",
        "        self.add(definition)\n",
        "        brace = Brace(definition, DOWN)\n",
        "        only_s_gt_1 = brace.get_text(\"\"\"\n",
        "            Only defined\n",
        "            for $s > 1$\n",
        "        \"\"\")\n",
        "        only_s_gt_1[-3].set_color(YELLOW)\n",
        "\n",
        "\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        words = OldTexText(\n",
        "            \"Ignore $s \\\\le 1$ \\\\dots \\\\\\\\\",\n",
        "            \"For now.\"\n",
        "        )\n",
        "        words[0][6].set_color(YELLOW)\n",
        "        words[1].set_color(BLACK)\n",
        "        self.teacher_says(words)\n",
        "        self.play(words[1].set_color, WHITE)\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(only_s_gt_1),\n",
        "            *it.chain(*[\n",
        "                [pi.look_at, definition]\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ])\n",
        "        )\n",
        "        self.random_blink(3)\n",
        "\n",
        "class RiemannFatherOfComplex(ComplexTransformationScene):\n",
        "    def construct(self):\n",
        "        name = OldTexText(\n",
        "            \"Bernhard Riemann $\\\\rightarrow$ Complex analysis\"\n",
        "        )\n",
        "        name.to_corner(UP+LEFT)\n",
        "        name.shift(0.25*DOWN)\n",
        "        name.add_background_rectangle()\n",
        "        # photo = Square()\n",
        "        photo = ImageMobject(\"Riemann\", invert = False)\n",
        "        photo.set_width(5)\n",
        "        photo.next_to(name, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "\n",
        "        self.add(photo)\n",
        "        self.play(Write(name))\n",
        "        self.wait()\n",
        "\n",
        "        input_dot = Dot(2*RIGHT+UP, color = YELLOW)\n",
        "        arc = Arc(-2*np.pi/3)\n",
        "        arc.rotate(-np.pi)\n",
        "        arc.add_tip()\n",
        "        arc.shift(input_dot.get_top()-arc.get_points()[0]+SMALL_BUFF*UP)\n",
        "        output_dot = Dot(\n",
        "            arc.get_points()[-1] + SMALL_BUFF*(2*RIGHT+DOWN),\n",
        "            color = MAROON_B\n",
        "        )\n",
        "        for dot, tex in (input_dot, \"z\"), (output_dot, \"f(z)\"):\n",
        "            dot.label = OldTex(tex)\n",
        "            dot.label.add_background_rectangle()\n",
        "            dot.label.next_to(dot, DOWN+RIGHT, buff = SMALL_BUFF)\n",
        "            dot.label.set_color(dot.get_color())\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(input_dot),\n",
        "            Write(input_dot.label)\n",
        "        )\n",
        "        self.play(ShowCreation(arc))\n",
        "        self.play(\n",
        "            ShowCreation(output_dot),\n",
        "            Write(output_dot.label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class FromRealToComplex(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"plane_config\" : {\n",
        "            \"space_unit_to_x_unit\" : 2,\n",
        "            \"space_unit_to_y_unit\" : 2,\n",
        "        },\n",
        "        \"background_label_scale_val\" : 0.7,\n",
        "        \"output_color\" : GREEN_B,\n",
        "        \"num_lines_in_spiril_sum\" : 1000,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.handle_background()\n",
        "        self.show_real_to_real()\n",
        "        self.transition_to_complex()\n",
        "        self.single_out_complex_exponent()\n",
        "        ##Fade to several scenes defined below\n",
        "        self.show_s_equals_two_lines()\n",
        "        self.transition_to_spiril_sum()\n",
        "        self.vary_complex_input()\n",
        "        self.show_domain_of_convergence()\n",
        "        self.ask_about_visualizing_all()\n",
        "\n",
        "    def handle_background(self):\n",
        "        self.remove(self.background)\n",
        "        #Oh yeah, this is great practice...\n",
        "        self.background[-1].remove(*self.background[-1][-3:])\n",
        "\n",
        "    def show_real_to_real(self):\n",
        "        zeta = self.get_zeta_definition(\"2\",  \"\\\\frac{\\\\pi^2}{6}\")\n",
        "        number_line = NumberLine(\n",
        "            unit_size = 2,\n",
        "            tick_frequency = 0.5,\n",
        "            big_tick_numbers = list(range(-2, 3))\n",
        "        )\n",
        "        number_line.add_numbers()\n",
        "        input_dot = Dot(number_line.number_to_point(2))\n",
        "        input_dot.set_color(YELLOW)\n",
        "\n",
        "        output_dot = Dot(number_line.number_to_point(np.pi**2/6))\n",
        "        output_dot.set_color(self.output_color)\n",
        "\n",
        "        arc = Arc(\n",
        "            2*np.pi/3, start_angle = np.pi/6,\n",
        "        )\n",
        "        arc.stretch_to_fit_width(\n",
        "            (input_dot.get_center()-output_dot.get_center())[0]\n",
        "        )\n",
        "        arc.stretch_to_fit_height(0.5)\n",
        "        arc.next_to(input_dot.get_center(), UP, aligned_edge = RIGHT)\n",
        "        arc.add_tip()\n",
        "\n",
        "        two = zeta[1][2].copy()\n",
        "        sum_term = zeta[-1]\n",
        "        self.add(number_line, *zeta[:-1])\n",
        "        self.wait()\n",
        "        self.play(Transform(two, input_dot))\n",
        "        self.remove(two)\n",
        "        self.add(input_dot)\n",
        "        self.play(ShowCreation(arc))\n",
        "        self.play(ShowCreation(output_dot))\n",
        "        self.play(Transform(output_dot.copy(), sum_term))\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(sum_term)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                self.background,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            FadeOut(VGroup(arc, output_dot, number_line)),\n",
        "            Animation(zeta),\n",
        "            Animation(input_dot)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.zeta = zeta\n",
        "        self.input_dot = input_dot\n",
        "\n",
        "    def transition_to_complex(self):\n",
        "        complex_zeta = self.get_zeta_definition(\"2+i\", \"???\")\n",
        "        input_dot = self.input_dot\n",
        "        input_dot.generate_target()\n",
        "        input_dot.target.move_to(\n",
        "            self.background.num_pair_to_point((2, 1))\n",
        "        )\n",
        "        input_label = OldTex(\"2+i\")\n",
        "        input_label.set_color(YELLOW)\n",
        "        input_label.next_to(input_dot.target, DOWN+RIGHT, buff = SMALL_BUFF)\n",
        "        input_label.add_background_rectangle()\n",
        "        input_label.save_state()\n",
        "        input_label.replace(VGroup(*complex_zeta[1][2:5]))\n",
        "        input_label.background_rectangle.scale(0.01)\n",
        "        self.input_label = input_label\n",
        "\n",
        "        self.play(Transform(self.zeta, complex_zeta))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            input_label.restore,\n",
        "            MoveToTarget(input_dot)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def single_out_complex_exponent(self):\n",
        "        frac_scale_factor = 1.2\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.to_corner()\n",
        "        bubble = randy.get_bubble(height = 4)\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "\n",
        "        frac = VGroup(\n",
        "            VectorizedPoint(self.zeta[2][3].get_left()),\n",
        "            self.zeta[2][3],\n",
        "            VectorizedPoint(self.zeta[2][3].get_right()),\n",
        "            self.zeta[2][4],\n",
        "        ).copy()\n",
        "        frac.generate_target()\n",
        "        frac.target.scale(frac_scale_factor)\n",
        "        bubble.add_content(frac.target)\n",
        "        new_frac = OldTex(\n",
        "            \"\\\\Big(\", \"\\\\frac{1}{2}\", \"\\\\Big)\", \"^{2+i}\"\n",
        "        )\n",
        "        new_frac[-1].set_color(YELLOW)\n",
        "        new_frac.scale(frac_scale_factor)\n",
        "        new_frac.move_to(frac.target)\n",
        "        new_frac.shift(LEFT+0.2*UP)\n",
        "\n",
        "        words = OldTexText(\"Not repeated \\\\\\\\\", \" multiplication\")\n",
        "        words.scale(0.8)\n",
        "        words.set_color(RED)\n",
        "        words.next_to(new_frac, RIGHT)\n",
        "\n",
        "        new_words = OldTexText(\"Not \\\\emph{super} \\\\\\\\\", \"crucial to know...\")\n",
        "        new_words.replace(words)\n",
        "        new_words.scale(1.3)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            randy.look_at, bubble,\n",
        "            ShowCreation(bubble),\n",
        "            MoveToTarget(frac)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(Transform(frac, new_frac))\n",
        "        self.play(Write(words))\n",
        "        for x in range(2):\n",
        "            self.wait(2)\n",
        "            self.play(Blink(randy))\n",
        "        self.play(\n",
        "            Transform(words, new_words),\n",
        "            randy.change_mode, \"maybe\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change_mode, \"happy\")\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [randy, bubble, frac, words])))\n",
        "\n",
        "    def show_s_equals_two_lines(self):\n",
        "        self.input_label.save_state()\n",
        "        zeta = self.get_zeta_definition(\"2\", \"\\\\frac{\\\\pi^2}{6}\")\n",
        "        lines, output_dot = self.get_sum_lines(2)\n",
        "        sum_terms = self.zeta[2][:-1:3]\n",
        "        dots_copy = zeta[2][-1].copy()\n",
        "        pi_copy = zeta[3].copy()\n",
        "        def transform_and_replace(m1, m2):\n",
        "            self.play(Transform(m1, m2))\n",
        "            self.remove(m1)\n",
        "            self.add(m2)\n",
        "\n",
        "        self.play(\n",
        "            self.input_dot.shift, 2*DOWN,\n",
        "            self.input_label.fade, 0.7,\n",
        "        )\n",
        "        self.play(Transform(self.zeta, zeta))\n",
        "\n",
        "        for term, line in zip(sum_terms, lines):\n",
        "            line.save_state()\n",
        "            line.next_to(term, DOWN)\n",
        "            term_copy = term.copy()\n",
        "            transform_and_replace(term_copy, line)\n",
        "            self.play(line.restore)\n",
        "        later_lines = VGroup(*lines[4:])\n",
        "        transform_and_replace(dots_copy, later_lines)\n",
        "        self.wait()\n",
        "        transform_and_replace(pi_copy, output_dot)\n",
        "        self.wait()\n",
        "\n",
        "        self.lines = lines\n",
        "        self.output_dot = output_dot\n",
        "\n",
        "    def transition_to_spiril_sum(self):\n",
        "        zeta = self.get_zeta_definition(\"2+i\", \"1.15 - 0.44i\")\n",
        "        zeta.set_width(FRAME_WIDTH-1)\n",
        "        zeta.to_corner(UP+LEFT)\n",
        "        lines, output_dot = self.get_sum_lines(complex(2, 1))\n",
        "\n",
        "        self.play(\n",
        "            self.input_dot.shift, 2*UP,\n",
        "            self.input_label.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(self.zeta, zeta))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(self.lines, lines),\n",
        "            Transform(self.output_dot, output_dot),\n",
        "            run_time = 2,\n",
        "            path_arc = -np.pi/6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def vary_complex_input(self):\n",
        "        zeta = self.get_zeta_definition(\"s\", \"\")\n",
        "        zeta[3].set_color(BLACK)\n",
        "        self.play(Transform(self.zeta, zeta))\n",
        "        self.play(FadeOut(self.input_label))\n",
        "        self.wait(2)\n",
        "        inputs = [\n",
        "            complex(1.5, 1.8),\n",
        "            complex(1.5, -1),\n",
        "            complex(3, -1),\n",
        "            complex(1.5, 1.8),\n",
        "            complex(1.5, -1.8),\n",
        "            complex(1.4, -1.8),\n",
        "            complex(1.5, 0),\n",
        "            complex(2, 1),\n",
        "        ]\n",
        "        for s in inputs:\n",
        "            input_point = self.z_to_point(s)\n",
        "            lines, output_dot = self.get_sum_lines(s)\n",
        "            self.play(\n",
        "                self.input_dot.move_to, input_point,\n",
        "                Transform(self.lines, lines),\n",
        "                Transform(self.output_dot, output_dot),\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "    def show_domain_of_convergence(self, opacity = 0.2):\n",
        "        domain = Rectangle(\n",
        "            width = FRAME_X_RADIUS-2,\n",
        "            height = FRAME_HEIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = opacity,\n",
        "        )\n",
        "        domain.to_edge(RIGHT, buff = 0)\n",
        "        anti_domain = Rectangle(\n",
        "            width = FRAME_X_RADIUS+2,\n",
        "            height = FRAME_HEIGHT,\n",
        "            stroke_width = 0,\n",
        "            fill_color = RED,\n",
        "            fill_opacity = opacity,\n",
        "        )\n",
        "        anti_domain.to_edge(LEFT, buff = 0)\n",
        "\n",
        "        domain_words = OldTexText(\"\"\"\n",
        "            $\\\\zeta(s)$ happily\n",
        "            converges and\n",
        "            makes sense\n",
        "        \"\"\")\n",
        "        domain_words.to_corner(UP+RIGHT, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        anti_domain_words = OldTexText(\"\"\"\n",
        "            Not so much...\n",
        "        \"\"\")\n",
        "        anti_domain_words.next_to(ORIGIN, LEFT, buff = LARGE_BUFF)\n",
        "        anti_domain_words.shift(1.5*DOWN)\n",
        "\n",
        "        self.play(FadeIn(domain))\n",
        "        self.play(Write(domain_words))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(anti_domain))\n",
        "        self.play(Write(anti_domain_words))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            anti_domain, anti_domain_words,\n",
        "        ])))\n",
        "        self.domain_words = domain_words\n",
        "\n",
        "    def ask_about_visualizing_all(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        bubble = morty.get_bubble(SpeechBubble, height = 4)\n",
        "        bubble.set_fill(BLACK, opacity = 0.5)\n",
        "        bubble.write(\"\"\"\n",
        "            How can we visualize\n",
        "            this for all inputs?\n",
        "        \"\"\")\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, self.input_dot,\n",
        "            *list(map(FadeOut, [\n",
        "                bubble, bubble.content, self.domain_words\n",
        "            ]))\n",
        "        )\n",
        "        arrow = Arrow(self.input_dot, self.output_dot, buff = SMALL_BUFF)\n",
        "        arrow.set_color(WHITE)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "    def get_zeta_definition(self, input_string, output_string, input_color = YELLOW):\n",
        "        inputs = VGroup()\n",
        "        num_shown_terms = 4\n",
        "        n_input_chars = len(input_string)\n",
        "\n",
        "        zeta_s_eq = OldTex(\"\\\\zeta(%s) = \"%input_string)\n",
        "        zeta_s_eq.to_edge(LEFT, buff = LARGE_BUFF)\n",
        "        zeta_s_eq.shift(0.5*UP)\n",
        "        inputs.add(*zeta_s_eq[2:2+n_input_chars])\n",
        "\n",
        "\n",
        "        raw_sum_terms = OldTex(*[\n",
        "            \"\\\\frac{1}{%d^{%s}} + \"%(d, input_string)\n",
        "            for d in range(1, 1+num_shown_terms)\n",
        "        ])\n",
        "        sum_terms = VGroup(*it.chain(*[\n",
        "            [\n",
        "                VGroup(*term[:3]),\n",
        "                VGroup(*term[3:-1]),\n",
        "                term[-1],\n",
        "            ]\n",
        "            for term in raw_sum_terms\n",
        "        ]))\n",
        "        sum_terms.add(OldTex(\"\\\\cdots\").next_to(sum_terms[-1]))\n",
        "        sum_terms.next_to(zeta_s_eq, RIGHT)\n",
        "        for x in range(num_shown_terms):\n",
        "            inputs.add(*sum_terms[3*x+1])\n",
        "\n",
        "        output = OldTex(\"= \\\\,\" + output_string)\n",
        "        output.next_to(sum_terms, RIGHT)\n",
        "        output.set_color(self.output_color)\n",
        "\n",
        "        inputs.set_color(input_color)\n",
        "        group = VGroup(zeta_s_eq, sum_terms, output)\n",
        "        group.to_edge(UP)\n",
        "        group.add_to_back(BackgroundRectangle(group))\n",
        "        return group\n",
        "\n",
        "    def get_sum_lines(self, exponent, line_thickness = 6):\n",
        "        powers = [0] + [\n",
        "            x**(-exponent)\n",
        "            for x in range(1, self.num_lines_in_spiril_sum)\n",
        "        ]\n",
        "        power_sums = np.cumsum(powers)\n",
        "        lines = VGroup(*[\n",
        "            Line(*list(map(self.z_to_point, z_pair)))\n",
        "            for z_pair in zip(power_sums, power_sums[1:])\n",
        "        ])\n",
        "        widths = np.linspace(line_thickness, 0, len(list(lines)))\n",
        "        for line, width in zip(lines, widths):\n",
        "            line.set_stroke(width = width)\n",
        "        VGroup(*lines[::2]).set_color(MAROON_B)\n",
        "        VGroup(*lines[1::2]).set_color(RED)\n",
        "\n",
        "        final_dot = Dot(\n",
        "            # self.z_to_point(power_sums[-1]),\n",
        "            self.z_to_point(zeta(exponent)),\n",
        "            color = self.output_color\n",
        "        )\n",
        "\n",
        "        return lines, final_dot\n",
        "\n",
        "class TerritoryOfExponents(ComplexTransformationScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        familiar_territory = OldTexText(\"Familiar territory\")\n",
        "        familiar_territory.set_color(YELLOW)\n",
        "        familiar_territory.next_to(ORIGIN, UP+RIGHT)\n",
        "        familiar_territory.shift(2*UP)\n",
        "        real_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        real_line.set_color(YELLOW)\n",
        "        arrow1 = Arrow(familiar_territory.get_bottom(), real_line.get_left())\n",
        "        arrow2 = Arrow(familiar_territory.get_bottom(), real_line.get_right())\n",
        "        VGroup(arrow1, arrow2).set_color(WHITE)\n",
        "\n",
        "        extended_realm = OldTexText(\"Extended realm\")\n",
        "        extended_realm.move_to(familiar_territory)\n",
        "        full_plane = Rectangle(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = FRAME_HEIGHT,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.3\n",
        "        )\n",
        "\n",
        "        self.add(familiar_territory)\n",
        "        self.play(ShowCreation(arrow1))\n",
        "        self.play(\n",
        "            Transform(arrow1, arrow2),\n",
        "            ShowCreation(real_line)\n",
        "        )\n",
        "        self.play(FadeOut(arrow1))\n",
        "        self.play(\n",
        "            FadeIn(full_plane),\n",
        "            Transform(familiar_territory, extended_realm),\n",
        "            Animation(real_line)\n",
        "        )\n",
        "\n",
        "    def add_title(self):\n",
        "        exponent = OldTex(\n",
        "            \"\\\\left(\\\\frac{1}{2}\\\\right)^s\"\n",
        "        )\n",
        "        exponent[-1].set_color(YELLOW)\n",
        "        exponent.next_to(ORIGIN, LEFT, MED_LARGE_BUFF).to_edge(UP)\n",
        "        self.add_foreground_mobjects(exponent)\n",
        "\n",
        "class ComplexExponentiation(Scene):\n",
        "    def construct(self):\n",
        "        self.extract_pure_imaginary_part()\n",
        "        self.add_on_planes()\n",
        "        self.show_imaginary_powers()\n",
        "\n",
        "    def extract_pure_imaginary_part(self):\n",
        "        original = OldTex(\n",
        "            \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2+i}\"\n",
        "        )\n",
        "        split = OldTex(\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2}\",\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{i}\",\n",
        "        )\n",
        "        VGroup(original[-1], split[1], split[3]).set_color(YELLOW)\n",
        "        VGroup(original, split).shift(UP)\n",
        "        real_part = VGroup(*split[:2])\n",
        "        imag_part = VGroup(*split[2:])\n",
        "\n",
        "        brace = Brace(real_part)\n",
        "        we_understand = brace.get_text(\n",
        "            \"We understand this\"\n",
        "        )\n",
        "        VGroup(brace, we_understand).set_color(GREEN_B)\n",
        "\n",
        "        self.add(original)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in [\n",
        "                (original[0], split[0]),\n",
        "                (original[1][0], split[1]),\n",
        "                (original[0].copy(), split[2]),\n",
        "                (VGroup(*original[1][1:]), split[3]),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(real_part, imag_part)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(we_understand),\n",
        "            real_part.set_color, GREEN_B\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            imag_part.move_to, imag_part.get_left(),\n",
        "            *list(map(FadeOut, [brace, we_understand, real_part]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.imag_exponent = imag_part\n",
        "\n",
        "    def add_on_planes(self):\n",
        "        left_plane = NumberPlane(x_radius = (FRAME_X_RADIUS-1)/2)\n",
        "        left_plane.to_edge(LEFT, buff = 0)\n",
        "        imag_line = Line(DOWN, UP).scale(FRAME_Y_RADIUS)\n",
        "        imag_line.set_color(YELLOW).fade(0.3)\n",
        "        imag_line.move_to(left_plane.get_center())\n",
        "        left_plane.add(imag_line)\n",
        "        left_title = OldTexText(\"Input space\")\n",
        "        left_title.add_background_rectangle()\n",
        "        left_title.set_color(YELLOW)\n",
        "        left_title.next_to(left_plane.get_top(), DOWN)\n",
        "\n",
        "        right_plane = NumberPlane(x_radius = (FRAME_X_RADIUS-1)/2)\n",
        "        right_plane.to_edge(RIGHT, buff = 0)\n",
        "        unit_circle = Circle()\n",
        "        unit_circle.set_color(MAROON_B).fade(0.3)\n",
        "        unit_circle.shift(right_plane.get_center())\n",
        "        right_plane.add(unit_circle)\n",
        "        right_title = OldTexText(\"Output space\")\n",
        "        right_title.add_background_rectangle()\n",
        "        right_title.set_color(MAROON_B)\n",
        "        right_title.next_to(right_plane.get_top(), DOWN)\n",
        "\n",
        "        for plane in left_plane, right_plane:\n",
        "            labels = VGroup()\n",
        "            for x in range(-2, 3):\n",
        "                label = OldTex(str(x))\n",
        "                label.move_to(plane.num_pair_to_point((x, 0)))\n",
        "                labels.add(label)\n",
        "            for y in range(-3, 4):\n",
        "                if y == 0:\n",
        "                    continue\n",
        "                label = OldTex(str(y) + \"i\")\n",
        "                label.move_to(plane.num_pair_to_point((0, y)))\n",
        "                labels.add(label)\n",
        "            for label in labels:\n",
        "                label.scale(0.5)\n",
        "                label.next_to(\n",
        "                    label.get_center(), DOWN+RIGHT,\n",
        "                    buff = SMALL_BUFF\n",
        "                )\n",
        "            plane.add(labels)\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(left_plane),\n",
        "            Write(left_title),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(right_plane),\n",
        "            Write(right_title),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.left_plane = left_plane\n",
        "        self.right_plane = right_plane\n",
        "\n",
        "    def show_imaginary_powers(self):\n",
        "        i = complex(0, 1)\n",
        "        input_dot = Dot(self.z_to_point(i))\n",
        "        input_dot.set_color(YELLOW)\n",
        "        output_dot = Dot(self.z_to_point(0.5**(i), is_input = False))\n",
        "        output_dot.set_color(MAROON_B)\n",
        "\n",
        "        output_dot.save_state()\n",
        "        output_dot.move_to(input_dot)\n",
        "        output_dot.set_color(input_dot.get_color())\n",
        "\n",
        "        curr_base = 0.5\n",
        "        def output_dot_update(ouput_dot):\n",
        "            y = input_dot.get_center()[1]\n",
        "            output_dot.move_to(self.z_to_point(\n",
        "                curr_base**complex(0, y), is_input = False\n",
        "            ))\n",
        "            return output_dot\n",
        "\n",
        "        def walk_up_and_down():\n",
        "            for vect in 3*DOWN, 5*UP, 5*DOWN, 2*UP:\n",
        "                self.play(\n",
        "                    input_dot.shift, vect,\n",
        "                    UpdateFromFunc(output_dot, output_dot_update),\n",
        "                    run_time = 3\n",
        "                )\n",
        "\n",
        "        exp = self.imag_exponent[-1]\n",
        "        new_exp = OldTex(\"ti\")\n",
        "        new_exp.set_color(exp.get_color())\n",
        "        new_exp.set_height(exp.get_height())\n",
        "        new_exp.move_to(exp, LEFT)\n",
        "\n",
        "        nine = OldTex(\"9\")\n",
        "        nine.set_color(BLUE)\n",
        "        denom = self.imag_exponent[0][3]\n",
        "        denom.save_state()\n",
        "        nine.replace(denom)\n",
        "\n",
        "        self.play(Transform(exp, new_exp))\n",
        "        self.play(input_dot.shift, 2*UP)\n",
        "        self.play(input_dot.shift, 2*DOWN)\n",
        "        self.wait()\n",
        "        self.play(output_dot.restore)\n",
        "        self.wait()\n",
        "        walk_up_and_down()\n",
        "        self.wait()\n",
        "        curr_base = 1./9\n",
        "        self.play(Transform(denom, nine))\n",
        "        walk_up_and_down()\n",
        "        self.wait()\n",
        "\n",
        "    def z_to_point(self, z, is_input = True):\n",
        "        if is_input:\n",
        "            plane = self.left_plane\n",
        "        else:\n",
        "            plane = self.right_plane\n",
        "        return plane.num_pair_to_point((z.real, z.imag))\n",
        "\n",
        "class SizeAndRotationBreakdown(Scene):\n",
        "    def construct(self):\n",
        "        original = OldTex(\n",
        "            \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2+i}\"\n",
        "        )\n",
        "        split = OldTex(\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2}\",\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{i}\",\n",
        "        )\n",
        "        VGroup(original[-1], split[1], split[3]).set_color(YELLOW)\n",
        "        VGroup(original, split).shift(UP)\n",
        "        real_part = VGroup(*split[:2])\n",
        "        imag_part = VGroup(*split[2:])\n",
        "\n",
        "        size_brace = Brace(real_part)\n",
        "        size = size_brace.get_text(\"Size\")\n",
        "        rotation_brace = Brace(imag_part, UP)\n",
        "        rotation = rotation_brace.get_text(\"Rotation\")\n",
        "\n",
        "        self.add(original)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in [\n",
        "                (original[0], split[0]),\n",
        "                (original[1][0], split[1]),\n",
        "                (original[0].copy(), split[2]),\n",
        "                (VGroup(*original[1][1:]), split[3]),\n",
        "            ]\n",
        "        ])\n",
        "        self.play(\n",
        "            GrowFromCenter(size_brace),\n",
        "            Write(size)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(rotation_brace),\n",
        "            Write(rotation)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SeeLinksInDescription(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            See links in the\n",
        "            description for more.\n",
        "        \"\"\")\n",
        "        self.play(*it.chain(*[\n",
        "            [pi.change_mode, \"hooray\", pi.look, DOWN]\n",
        "            for pi in self.get_students()\n",
        "        ]))\n",
        "        self.random_blink(3)\n",
        "\n",
        "class ShowMultiplicationOfRealAndImaginaryExponentialParts(FromRealToComplex):\n",
        "    def construct(self):\n",
        "        self.break_up_exponent()\n",
        "        self.show_multiplication()\n",
        "\n",
        "    def break_up_exponent(self):\n",
        "        original = OldTex(\n",
        "            \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2+i}\"\n",
        "        )\n",
        "        split = OldTex(\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2}\",\n",
        "             \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{i}\",\n",
        "        )\n",
        "        VGroup(original[-1], split[1], split[3]).set_color(YELLOW)\n",
        "        VGroup(original, split).to_corner(UP+LEFT)\n",
        "        rect = BackgroundRectangle(split)\n",
        "        real_part = VGroup(*split[:2])\n",
        "        imag_part = VGroup(*split[2:])\n",
        "\n",
        "        self.add(rect, original)\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in [\n",
        "                (original[0], split[0]),\n",
        "                (original[1][0], split[1]),\n",
        "                (original[0].copy(), split[2]),\n",
        "                (VGroup(*original[1][1:]), split[3]),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(real_part, imag_part)\n",
        "        self.wait()\n",
        "        self.real_part = real_part\n",
        "        self.imag_part = imag_part\n",
        "\n",
        "    def show_multiplication(self):\n",
        "        real_part = self.real_part.copy()\n",
        "        imag_part = self.imag_part.copy()\n",
        "        for part in real_part, imag_part:\n",
        "            part.add_to_back(BackgroundRectangle(part))\n",
        "\n",
        "        fourth_point = self.z_to_point(0.25)\n",
        "        fourth_line = Line(ORIGIN, fourth_point)\n",
        "        brace = Brace(fourth_line, UP, buff = SMALL_BUFF)\n",
        "        fourth_dot = Dot(fourth_point)\n",
        "        fourth_group = VGroup(fourth_line, brace, fourth_dot)\n",
        "        fourth_group.set_color(RED)\n",
        "\n",
        "        circle = Circle(radius = 2, color = MAROON_B)\n",
        "        circle.fade(0.3)\n",
        "        imag_power_point = self.z_to_point(0.5**complex(0, 1))\n",
        "        imag_power_dot = Dot(imag_power_point)\n",
        "        imag_power_line = Line(ORIGIN, imag_power_point)\n",
        "        VGroup(imag_power_dot, imag_power_line).set_color(MAROON_B)\n",
        "\n",
        "        full_power_tex = OldTex(\n",
        "            \"\\\\left(\\\\frac{1}{2}\\\\right)\", \"^{2+i}\"\n",
        "        )\n",
        "        full_power_tex[-1].set_color(YELLOW)\n",
        "        full_power_tex.add_background_rectangle()\n",
        "        full_power_tex.scale(0.7)\n",
        "        full_power_tex.next_to(\n",
        "            0.5*self.z_to_point(0.5**complex(2, 1)),\n",
        "            UP+RIGHT\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            real_part.scale, 0.7,\n",
        "            real_part.next_to, brace, UP, SMALL_BUFF, LEFT,\n",
        "            ShowCreation(fourth_dot)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShowCreation(fourth_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            imag_part.scale, 0.7,\n",
        "            imag_part.next_to, imag_power_dot, DOWN+RIGHT, SMALL_BUFF,\n",
        "            ShowCreation(imag_power_dot)\n",
        "        )\n",
        "        self.play(ShowCreation(circle), Animation(imag_power_dot))\n",
        "        self.play(ShowCreation(imag_power_line))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            fourth_group.rotate, imag_power_line.get_angle()\n",
        "        )\n",
        "        real_part.generate_target()\n",
        "        imag_part.generate_target()\n",
        "        real_part.target.next_to(brace, UP+RIGHT, buff = 0)\n",
        "        imag_part.target.next_to(real_part.target, buff = 0)\n",
        "        self.play(*list(map(MoveToTarget, [real_part, imag_part])))\n",
        "        self.wait()\n",
        "\n",
        "class ComplexFunctionsAsTransformations(ComplexTransformationScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        input_dots, output_dots, arrows = self.get_dots()\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            input_dots,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        for in_dot, out_dot, arrow in zip(input_dots, output_dots, arrows):\n",
        "            self.play(\n",
        "                Transform(in_dot.copy(), out_dot),\n",
        "                ShowCreation(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Complex functions as transformations\")\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "    def get_dots(self):\n",
        "        input_points = [\n",
        "            RIGHT+2*UP,\n",
        "            4*RIGHT+DOWN,\n",
        "            2*LEFT+2*UP,\n",
        "            LEFT+DOWN,\n",
        "            6*LEFT+DOWN,\n",
        "        ]\n",
        "        output_nudges = [\n",
        "            DOWN+RIGHT,\n",
        "            2*UP+RIGHT,\n",
        "            2*RIGHT+2*DOWN,\n",
        "            2*RIGHT+DOWN,\n",
        "            RIGHT+2*UP,\n",
        "        ]\n",
        "        input_dots = VGroup(*list(map(Dot, input_points)))\n",
        "        input_dots.set_color(YELLOW)\n",
        "        output_dots = VGroup(*[\n",
        "            Dot(ip + on)\n",
        "            for ip, on in zip(input_points, output_nudges)\n",
        "        ])\n",
        "        output_dots.set_color(MAROON_B)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(in_dot, out_dot, buff = 0.1, color = WHITE)\n",
        "            for in_dot, out_dot, in zip(input_dots, output_dots)\n",
        "        ])\n",
        "        for i, dot in enumerate(input_dots):\n",
        "            label = OldTex(\"s_%d\"%i)\n",
        "            label.set_color(dot.get_color())\n",
        "            label.next_to(dot, DOWN+LEFT, buff = SMALL_BUFF)\n",
        "            dot.add(label)\n",
        "        for i, dot in enumerate(output_dots):\n",
        "            label = OldTex(\"f(s_%d)\"%i)\n",
        "            label.set_color(dot.get_color())\n",
        "            label.next_to(dot, UP+RIGHT, buff = SMALL_BUFF)\n",
        "            dot.add(label)\n",
        "        return input_dots, output_dots, arrows\n",
        "\n",
        "class VisualizingSSquared(ComplexTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"num_anchors_to_add_per_line\" : 100,\n",
        "        \"horiz_end_color\" : GOLD,\n",
        "        \"y_min\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.plug_in_specific_values()\n",
        "        self.show_transformation()\n",
        "        self.comment_on_two_dimensions()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(\", \"s\", \") = \", \"s\", \"^2\")\n",
        "        title.set_color_by_tex(\"s\", YELLOW)\n",
        "        title.add_background_rectangle()\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.play(Write(title))\n",
        "        self.add_foreground_mobject(title)\n",
        "        self.wait()\n",
        "        self.title = title\n",
        "\n",
        "    def plug_in_specific_values(self):\n",
        "        inputs = list(map(complex, [2, -1, complex(0, 1)]))\n",
        "        input_dots  = VGroup(*[\n",
        "            Dot(self.z_to_point(z), color = YELLOW)\n",
        "            for z in inputs\n",
        "        ])\n",
        "        output_dots = VGroup(*[\n",
        "            Dot(self.z_to_point(z**2), color = BLUE)\n",
        "            for z in inputs\n",
        "        ])\n",
        "        arrows = VGroup()\n",
        "        VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t : self.z_to_point(z**(1.1+0.8*t))\n",
        "            )\n",
        "            for z in inputs\n",
        "        ])\n",
        "        for z, dot in zip(inputs, input_dots):\n",
        "            path = ParametricCurve(\n",
        "                lambda t : self.z_to_point(z**(1+t))\n",
        "            )\n",
        "            dot.path = path\n",
        "            arrow = ParametricCurve(\n",
        "                lambda t : self.z_to_point(z**(1.1+0.8*t))\n",
        "            )\n",
        "            stand_in_arrow = Arrow(\n",
        "                arrow.get_points()[-2], arrow.get_points()[-1],\n",
        "                tip_length = 0.2\n",
        "            )\n",
        "            arrow.add(stand_in_arrow.tip)\n",
        "            arrows.add(arrow)\n",
        "        arrows.set_color(WHITE)\n",
        "\n",
        "        for input_dot, output_dot, arrow in zip(input_dots, output_dots, arrows):\n",
        "            input_dot.save_state()\n",
        "            input_dot.move_to(self.title[1][1])\n",
        "            input_dot.set_fill(opacity = 0)\n",
        "\n",
        "            self.play(input_dot.restore)\n",
        "            self.wait()\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.play(ShowCreation(output_dot))\n",
        "            self.wait()\n",
        "        self.add_foreground_mobjects(arrows, output_dots, input_dots)\n",
        "        self.input_dots = input_dots\n",
        "        self.output_dots = output_dots\n",
        "\n",
        "    def add_transformable_plane(self, **kwargs):\n",
        "        ComplexTransformationScene.add_transformable_plane(self, **kwargs)\n",
        "        self.plane.next_to(ORIGIN, UP, buff = 0.01)\n",
        "        self.plane.add(self.plane.copy().rotate(np.pi, RIGHT))\n",
        "        self.plane.add(\n",
        "            Line(ORIGIN, FRAME_X_RADIUS*RIGHT, color = self.horiz_end_color),\n",
        "            Line(ORIGIN, FRAME_X_RADIUS*LEFT, color = self.horiz_end_color),\n",
        "        )\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def show_transformation(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.play(ShowCreation(self.plane, run_time = 3))\n",
        "\n",
        "        self.wait()\n",
        "        self.apply_complex_homotopy(\n",
        "            lambda z, t : z**(1+t),\n",
        "            added_anims = [\n",
        "                MoveAlongPath(dot, dot.path, run_time = 5)\n",
        "                for dot in self.input_dots\n",
        "            ],\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    def comment_on_two_dimensions(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        bubble = morty.get_bubble(SpeechBubble, height = 2, width = 4)\n",
        "        bubble.set_fill(BLACK, opacity = 0.9)\n",
        "        bubble.write(\"\"\"\n",
        "            It all happens\n",
        "            in two dimensions!\n",
        "        \"\"\")\n",
        "        self.foreground_mobjects = []\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class ShowZetaOnHalfPlane(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 1,\n",
        "        \"x_max\" : int(FRAME_X_RADIUS+2),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.initial_transformation()\n",
        "        self.react_to_transformation()\n",
        "        self.show_cutoff()\n",
        "        self.set_color_i_line()\n",
        "        self.show_continuation()\n",
        "        self.emphsize_sum_doesnt_make_sense()\n",
        "\n",
        "\n",
        "    def add_title(self):\n",
        "        zeta = OldTex(\n",
        "            \"\\\\zeta(\", \"s\", \")=\",\n",
        "            *[\n",
        "                \"\\\\frac{1}{%d^s} + \"%d\n",
        "                for d in range(1, 5)\n",
        "            ] + [\"\\\\cdots\"]\n",
        "        )\n",
        "        zeta[1].set_color(YELLOW)\n",
        "        for mob in zeta[3:3+4]:\n",
        "            mob[-2].set_color(YELLOW)\n",
        "        zeta.add_background_rectangle()\n",
        "        zeta.scale(0.8)\n",
        "        zeta.to_corner(UP+LEFT)\n",
        "        self.add_foreground_mobjects(zeta)\n",
        "        self.zeta = zeta\n",
        "\n",
        "    def initial_transformation(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.wait()\n",
        "        self.add_extra_plane_lines_for_zeta(animate = True)\n",
        "        self.wait(2)\n",
        "        self.plane.save_state()\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "\n",
        "    def react_to_transformation(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        bubble = morty.get_bubble(SpeechBubble)\n",
        "        bubble.set_fill(BLACK, 0.5)\n",
        "        bubble.write(\"\\\\emph{Damn}!\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.pin_to(morty)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"surprised\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.look_at, self.plane.get_top())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.look_at, self.plane.get_bottom(),\n",
        "            *list(map(FadeOut, [bubble, bubble.content]))\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(FadeOut(morty))\n",
        "\n",
        "    def show_cutoff(self):\n",
        "        words = OldTexText(\"Such an abrupt stop...\")\n",
        "        words.add_background_rectangle()\n",
        "        words.next_to(ORIGIN, UP+LEFT)\n",
        "        words.shift(LEFT+UP)\n",
        "\n",
        "        line = Line(*list(map(self.z_to_point, [\n",
        "            complex(np.euler_gamma, u*FRAME_Y_RADIUS)\n",
        "            for u in (1, -1)\n",
        "        ])))\n",
        "        line.set_color(YELLOW)\n",
        "        arrows = [\n",
        "            Arrow(words.get_right(), point)\n",
        "            for point in line.get_start_and_end()\n",
        "        ]\n",
        "\n",
        "        self.play(Write(words, run_time = 2))\n",
        "        self.play(ShowCreation(arrows[0]))\n",
        "        self.play(\n",
        "            Transform(*arrows),\n",
        "            ShowCreation(line),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeOut(arrows[0]))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [words, line])))\n",
        "\n",
        "    def set_color_i_line(self):\n",
        "        right_i_lines, left_i_lines = [\n",
        "            VGroup(*[\n",
        "                Line(\n",
        "                    vert_vect+RIGHT,\n",
        "                    vert_vect+(FRAME_X_RADIUS+1)*horiz_vect\n",
        "                )\n",
        "                for vert_vect in (UP, DOWN)\n",
        "            ])\n",
        "            for horiz_vect in (RIGHT, LEFT)\n",
        "        ]\n",
        "        right_i_lines.set_color(YELLOW)\n",
        "        left_i_lines.set_color(BLUE)\n",
        "        for lines in right_i_lines, left_i_lines:\n",
        "            self.prepare_for_transformation(lines)\n",
        "\n",
        "        self.restore_mobjects(self.plane)\n",
        "        self.plane.add(*right_i_lines)\n",
        "        colored_plane = self.plane.copy()\n",
        "        right_i_lines.set_stroke(width = 0)\n",
        "        self.play(\n",
        "            self.plane.set_stroke, GREY, 1,\n",
        "        )\n",
        "        right_i_lines.set_stroke(YELLOW, width = 3)\n",
        "        self.play(ShowCreation(right_i_lines))\n",
        "        self.plane.save_state()\n",
        "        self.wait(2)\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "\n",
        "        left_i_lines.save_state()\n",
        "        left_i_lines.apply_complex_function(zeta)\n",
        "        self.play(ShowCreation(left_i_lines, run_time = 5))\n",
        "        self.wait()\n",
        "        self.restore_mobjects(self.plane, left_i_lines)\n",
        "        self.play(Transform(self.plane, colored_plane))\n",
        "        self.wait()\n",
        "        self.left_i_lines = left_i_lines\n",
        "\n",
        "    def show_continuation(self):\n",
        "        reflected_plane = self.get_reflected_plane()\n",
        "        self.play(ShowCreation(reflected_plane, run_time = 2))\n",
        "        self.plane.add(reflected_plane)\n",
        "        self.remove(self.left_i_lines)\n",
        "        self.wait()\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(\n",
        "            reflected_plane,\n",
        "            run_time = 6,\n",
        "            rate_func = lambda t : 1-there_and_back(t)\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def emphsize_sum_doesnt_make_sense(self):\n",
        "        brace = Brace(VGroup(*self.zeta[1][3:]))\n",
        "        words = brace.get_text(\"\"\"\n",
        "            Still fails to converge\n",
        "            when Re$(s) < 1$\n",
        "        \"\"\", buff = SMALL_BUFF)\n",
        "        words.add_background_rectangle()\n",
        "        words.scale(0.8)\n",
        "        divergent_sum = OldTex(\"1+2+3+4+\\\\cdots\")\n",
        "        divergent_sum.next_to(ORIGIN, UP)\n",
        "        divergent_sum.to_edge(LEFT)\n",
        "        divergent_sum.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(divergent_sum))\n",
        "        self.wait(2)\n",
        "\n",
        "    def restore_mobjects(self, *mobjects):\n",
        "        self.play(*it.chain(*[\n",
        "            [m.restore, m.make_smooth]\n",
        "            for m in  mobjects\n",
        "        ]), run_time = 2)\n",
        "        for m in mobjects:\n",
        "            self.remove(m)\n",
        "            m.restore()\n",
        "            self.add(m)\n",
        "\n",
        "class ShowConditionalDefinition(Scene):\n",
        "    def construct(self):\n",
        "        zeta = OldTex(\"\\\\zeta(s)=\")\n",
        "        zeta[2].set_color(YELLOW)\n",
        "        sigma = OldTex(\"\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\")\n",
        "        sigma[-1].set_color(YELLOW)\n",
        "        something_else = OldTexText(\"Something else...\")\n",
        "        conditions = VGroup(*[\n",
        "            OldTexText(\"if Re$(s) %s 1$\"%s)\n",
        "            for s in (\">\", \"\\\\le\")\n",
        "        ])\n",
        "        definitions = VGroup(sigma, something_else)\n",
        "        definitions.arrange(DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT)\n",
        "        conditions.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        definitions.shift(2*LEFT+2*UP)\n",
        "        conditions.next_to(definitions, RIGHT, buff = LARGE_BUFF, aligned_edge = DOWN)\n",
        "        brace = Brace(definitions, LEFT)\n",
        "        zeta.next_to(brace, LEFT)\n",
        "\n",
        "        sigma.save_state()\n",
        "        sigma.next_to(zeta)\n",
        "        self.add(zeta, sigma)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            sigma.restore,\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(something_else)\n",
        "        )\n",
        "        self.play(Write(conditions))\n",
        "        self.wait()\n",
        "\n",
        "        underbrace = Brace(something_else)\n",
        "        question = underbrace.get_text(\"\"\"\n",
        "            What to put here?\n",
        "        \"\"\")\n",
        "        VGroup(underbrace, question).set_color(GREEN_B)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(underbrace),\n",
        "            Write(question),\n",
        "            something_else.set_color, GREEN_B\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class SquiggleOnExtensions(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 1,\n",
        "        \"x_max\" : int(FRAME_X_RADIUS+2),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_negative_one()\n",
        "        self.cycle_through_options()\n",
        "        self.lock_into_place()\n",
        "\n",
        "    def show_negative_one(self):\n",
        "        self.add_transformable_plane()\n",
        "        thin_plane = self.plane.copy()\n",
        "        thin_plane.add(self.get_reflected_plane())\n",
        "        self.remove(self.plane)\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        reflected_plane = self.get_reflected_plane()\n",
        "        self.plane.add(reflected_plane)\n",
        "        self.remove(self.plane)\n",
        "        self.add(thin_plane)\n",
        "\n",
        "        dot = self.note_point(-1, \"-1\")\n",
        "        self.play(\n",
        "            ShowCreation(self.plane, run_time = 2),\n",
        "            Animation(dot),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.remove(thin_plane)\n",
        "        self.apply_zeta_function(added_anims = [\n",
        "            ApplyMethod(\n",
        "                dot.move_to, self.z_to_point(-1./12),\n",
        "                run_time = 5\n",
        "            )\n",
        "        ])\n",
        "        dot_to_remove = self.note_point(-1./12, \"-\\\\frac{1}{12}\")\n",
        "        self.remove(dot_to_remove)\n",
        "        self.left_plane = reflected_plane\n",
        "        self.dot = dot\n",
        "\n",
        "    def note_point(self, z, label_tex):\n",
        "        dot = Dot(self.z_to_point(z))\n",
        "        dot.set_color(YELLOW)\n",
        "        label = OldTex(label_tex)\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, UP+LEFT, buff = SMALL_BUFF)\n",
        "        label.shift(LEFT)\n",
        "        arrow = Arrow(label.get_right(), dot, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(label, run_time = 1))\n",
        "        self.play(*list(map(ShowCreation, [arrow, dot])))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [arrow, label])))\n",
        "        return dot\n",
        "\n",
        "    def cycle_through_options(self):\n",
        "        gamma = np.euler_gamma\n",
        "        def shear(point):\n",
        "            x, y, z = point\n",
        "            return np.array([\n",
        "                x,\n",
        "                y+0.25*(1-x)**2,\n",
        "                0\n",
        "            ])\n",
        "        def mixed_scalar_func(point):\n",
        "            x, y, z = point\n",
        "            scalar = 1 + (gamma-x)/(gamma+FRAME_X_RADIUS)\n",
        "            return np.array([\n",
        "                (scalar**2)*x,\n",
        "                (scalar**3)*y,\n",
        "                0\n",
        "            ])\n",
        "        def alt_mixed_scalar_func(point):\n",
        "            x, y, z = point\n",
        "            scalar = 1 + (gamma-x)/(gamma+FRAME_X_RADIUS)\n",
        "            return np.array([\n",
        "                (scalar**5)*x,\n",
        "                (scalar**2)*y,\n",
        "                0\n",
        "            ])\n",
        "        def sinusoidal_func(point):\n",
        "            x, y, z = point\n",
        "            freq = np.pi/gamma\n",
        "            return np.array([\n",
        "                x-0.2*np.sin(x*freq)*np.sin(y),\n",
        "                y-0.2*np.sin(x*freq)*np.sin(y),\n",
        "                0\n",
        "            ])\n",
        "        funcs = [\n",
        "            shear,\n",
        "            mixed_scalar_func,\n",
        "            alt_mixed_scalar_func,\n",
        "            sinusoidal_func,\n",
        "        ]\n",
        "        for mob in self.left_plane.family_members_with_points():\n",
        "            if np.all(np.abs(mob.get_points()[:,1]) < 0.1):\n",
        "                self.left_plane.remove(mob)\n",
        "\n",
        "        new_left_planes = [\n",
        "            self.left_plane.copy().apply_function(func)\n",
        "            for func in funcs\n",
        "        ]\n",
        "        new_dots = [\n",
        "            self.dot.copy().move_to(func(self.dot.get_center()))\n",
        "            for func in funcs\n",
        "        ]\n",
        "        self.left_plane.save_state()\n",
        "        for plane, dot in zip(new_left_planes, new_dots):\n",
        "            self.play(\n",
        "                Transform(self.left_plane, plane),\n",
        "                Transform(self.dot, dot),\n",
        "                run_time = 3\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(self.dot))\n",
        "\n",
        "        #Squiggle on example\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.left_plane))\n",
        "        self.play(ShowCreation(\n",
        "            self.left_plane,\n",
        "            run_time = 5,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def lock_into_place(self):\n",
        "        words = OldTexText(\n",
        "            \"\"\"Only one extension\n",
        "            has a \"\"\",\n",
        "            \"\\\\emph{derivative}\",\n",
        "            \"everywhere\",\n",
        "            alignment = \"\"\n",
        "        )\n",
        "        words.to_corner(UP+LEFT)\n",
        "        words.set_color_by_tex(\"\\\\emph{derivative}\", YELLOW)\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.add_foreground_mobjects(words)\n",
        "        self.play(self.left_plane.restore)\n",
        "        self.wait()\n",
        "\n",
        "class DontKnowDerivatives(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            You said we don't\n",
        "            need derivatives!\n",
        "            \"\"\",\n",
        "            target_mode = \"pleading\"\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            I get $\\\\frac{df}{dx}$, just not\n",
        "            for complex functions\n",
        "            \"\"\",\n",
        "            target_mode = \"confused\",\n",
        "            index = 2\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            Luckily, there's a purely\n",
        "            geometric intuition here.\n",
        "            \"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "class IntroduceAnglePreservation(VisualizingSSquared):\n",
        "    CONFIG = {\n",
        "        \"num_anchors_to_add_per_line\" : 50,\n",
        "        \"use_homotopy\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_initial_transformation()\n",
        "        self.talk_about_derivative()\n",
        "        self.cycle_through_line_pairs()\n",
        "        self.note_grid_lines()\n",
        "        self.name_analytic()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(\", \"s\", \")=\", \"s\", \"^2\")\n",
        "        title.set_color_by_tex(\"s\", YELLOW)\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UP+LEFT)\n",
        "        title.add_background_rectangle()\n",
        "        self.title = title\n",
        "\n",
        "        self.add_transformable_plane()\n",
        "        self.play(Write(title))\n",
        "        self.add_foreground_mobjects(title)\n",
        "        self.wait()\n",
        "\n",
        "    def show_initial_transformation(self):\n",
        "        self.apply_function()\n",
        "        self.wait(2)\n",
        "        self.reset()\n",
        "\n",
        "    def talk_about_derivative(self):\n",
        "        randy = Randolph().scale(0.8)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        randy.make_eye_contact(morty)\n",
        "        for pi, words in (randy, \"$f'(s) = 2s$\"), (morty, \"Here's some \\\\\\\\ related geometry...\"):\n",
        "            pi.bubble = pi.get_bubble(SpeechBubble)\n",
        "            pi.bubble.set_fill(BLACK, opacity = 0.7)\n",
        "            pi.bubble.write(words)\n",
        "            pi.bubble.resize_to_content()\n",
        "            pi.bubble.pin_to(pi)\n",
        "        for index in 3, 7:\n",
        "            randy.bubble.content[index].set_color(YELLOW)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [randy, morty])))\n",
        "        self.play(\n",
        "            randy.change_mode, \"speaking\",\n",
        "            ShowCreation(randy.bubble),\n",
        "            Write(randy.bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change_mode, \"speaking\",\n",
        "            randy.change_mode, \"pondering\",\n",
        "            ShowCreation(morty.bubble),\n",
        "            Write(morty.bubble.content),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            randy, morty,\n",
        "            randy.bubble, randy.bubble.content,\n",
        "            morty.bubble, morty.bubble.content,\n",
        "        ])))\n",
        "\n",
        "\n",
        "    def cycle_through_line_pairs(self):\n",
        "        line_pairs = [\n",
        "            (\n",
        "                Line(3*DOWN+3*RIGHT, 2*UP),\n",
        "                Line(DOWN+RIGHT, 3*UP+4*RIGHT)\n",
        "            ),\n",
        "            (\n",
        "                Line(RIGHT+3.5*DOWN, RIGHT+2.5*UP),\n",
        "                Line(3*LEFT+0.5*UP, 3*RIGHT+0.5*UP),\n",
        "            ),\n",
        "            (\n",
        "                Line(4*RIGHT+4*DOWN, RIGHT+2*UP),\n",
        "                Line(4*DOWN+RIGHT, 2*UP+2*RIGHT)\n",
        "            ),\n",
        "        ]\n",
        "        for lines in line_pairs:\n",
        "            self.show_angle_preservation_between_lines(*lines)\n",
        "            self.reset()\n",
        "\n",
        "    def note_grid_lines(self):\n",
        "        intersection_inputs = [\n",
        "            complex(x, y)\n",
        "            for x in np.arange(-5, 5, 0.5)\n",
        "            for y in np.arange(0, 3, 0.5)\n",
        "            if not (x <= 0 and y == 0)\n",
        "        ]\n",
        "        brackets = VGroup(*list(map(\n",
        "            self.get_right_angle_bracket,\n",
        "            intersection_inputs\n",
        "        )))\n",
        "        self.apply_function()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(brackets, run_time = 5),\n",
        "            Animation(self.plane)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def name_analytic(self):\n",
        "        equiv = OldTexText(\"``Analytic'' $\\\\Leftrightarrow$ Angle-preserving\")\n",
        "        kind_of = OldTexText(\"...kind of\")\n",
        "        for text in equiv, kind_of:\n",
        "            text.scale(1.2)\n",
        "            text.add_background_rectangle()\n",
        "        equiv.set_color(YELLOW)\n",
        "        kind_of.set_color(RED)\n",
        "        kind_of.next_to(equiv, RIGHT)\n",
        "        VGroup(equiv, kind_of).next_to(ORIGIN, UP, buff = 1)\n",
        "\n",
        "        self.play(Write(equiv))\n",
        "        self.wait(2)\n",
        "        self.play(Write(kind_of, run_time = 1))\n",
        "        self.wait(2)\n",
        "\n",
        "    def reset(self, faded = True):\n",
        "        self.play(FadeOut(self.plane))\n",
        "        self.add_transformable_plane()\n",
        "        if faded:\n",
        "            self.plane.fade()\n",
        "        self.play(FadeIn(self.plane))\n",
        "\n",
        "    def apply_function(self, **kwargs):\n",
        "        if self.use_homotopy:\n",
        "            self.apply_complex_homotopy(\n",
        "                lambda z, t : z**(1+t),\n",
        "                run_time = 5,\n",
        "                **kwargs\n",
        "            )\n",
        "        else:\n",
        "            self.apply_complex_function(\n",
        "                lambda z : z**2,\n",
        "                **kwargs\n",
        "            )\n",
        "\n",
        "    def show_angle_preservation_between_lines(self, *lines):\n",
        "        R2_endpoints = [\n",
        "            [l.get_start()[:2], l.get_end()[:2]]\n",
        "            for l in lines\n",
        "        ]\n",
        "        R2_intersection_point = intersection(*R2_endpoints)\n",
        "        intersection_point = np.array(list(R2_intersection_point) + [0])\n",
        "\n",
        "        angle1, angle2 = [l.get_angle() for l in lines]\n",
        "        arc = Arc(\n",
        "            start_angle = angle1,\n",
        "            angle = angle2-angle1,\n",
        "            radius = 0.4,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        arc.shift(intersection_point)\n",
        "        arc.insert_n_curves(10)\n",
        "        arc.generate_target()\n",
        "        input_z = complex(*arc.get_center()[:2])\n",
        "        scale_factor = abs(2*input_z)\n",
        "        arc.target.scale_about_point(1./scale_factor, intersection_point)\n",
        "        arc.target.apply_complex_function(lambda z : z**2)\n",
        "\n",
        "        angle_tex = OldTex(\n",
        "            \"%d^\\\\circ\"%abs(int((angle2-angle1)*180/np.pi))\n",
        "        )\n",
        "        angle_tex.set_color(arc.get_color())\n",
        "        angle_tex.add_background_rectangle()\n",
        "        self.put_angle_tex_next_to_arc(angle_tex, arc)\n",
        "        angle_arrow = Arrow(\n",
        "            angle_tex, arc,\n",
        "            color = arc.get_color(),\n",
        "            buff = 0.1,\n",
        "        )\n",
        "        angle_group = VGroup(angle_tex, angle_arrow)\n",
        "\n",
        "\n",
        "        self.play(*list(map(ShowCreation, lines)))\n",
        "        self.play(\n",
        "            Write(angle_tex),\n",
        "            ShowCreation(angle_arrow),\n",
        "            ShowCreation(arc)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(angle_group))\n",
        "        self.plane.add(*lines)\n",
        "        self.apply_function(added_anims = [\n",
        "            MoveToTarget(arc, run_time = 5)\n",
        "        ])\n",
        "        self.put_angle_tex_next_to_arc(angle_tex, arc)\n",
        "        arrow = Arrow(angle_tex, arc, buff = 0.1)\n",
        "        arrow.set_color(arc.get_color())\n",
        "        self.play(\n",
        "            Write(angle_tex),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [arc, angle_tex, arrow])))\n",
        "\n",
        "    def put_angle_tex_next_to_arc(self, angle_tex, arc):\n",
        "        vect = arc.point_from_proportion(0.5)-interpolate(\n",
        "            arc.get_points()[0], arc.get_points()[-1], 0.5\n",
        "        )\n",
        "        unit_vect = vect/get_norm(vect)\n",
        "        angle_tex.move_to(arc.get_center() + 1.7*unit_vect)\n",
        "\n",
        "    def get_right_angle_bracket(self, input_z):\n",
        "        output_z = input_z**2\n",
        "        derivative = 2*input_z\n",
        "        rotation = np.log(derivative).imag\n",
        "\n",
        "        brackets = VGroup(\n",
        "            Line(RIGHT, RIGHT+UP),\n",
        "            Line(RIGHT+UP, UP)\n",
        "        )\n",
        "        brackets.scale(0.15)\n",
        "        brackets.set_stroke(width = 2)\n",
        "        brackets.set_color(YELLOW)\n",
        "        brackets.shift(0.02*UP) ##Why???\n",
        "        brackets.rotate(rotation, about_point = ORIGIN)\n",
        "        brackets.shift(self.z_to_point(output_z))\n",
        "        return brackets\n",
        "\n",
        "class AngleAtZeroDerivativePoints(IntroduceAnglePreservation):\n",
        "    CONFIG = {\n",
        "        \"use_homotopy\" : True\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.is_before_transformation = True\n",
        "        self.add_transformable_plane()\n",
        "        self.plane.fade()\n",
        "        line = Line(3*LEFT+0.5*UP, 3*RIGHT+0.5*DOWN)\n",
        "        self.show_angle_preservation_between_lines(\n",
        "            line, line.copy().rotate(np.pi/5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"f(\", \"s\", \")=\", \"s\", \"^2\")\n",
        "        title.set_color_by_tex(\"s\", YELLOW)\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UP+LEFT)\n",
        "        title.add_background_rectangle()\n",
        "        derivative = OldTex(\"f'(0) = 0\")\n",
        "        derivative.set_color(RED)\n",
        "        derivative.scale(1.2)\n",
        "        derivative.add_background_rectangle()\n",
        "        derivative.next_to(title, DOWN)\n",
        "\n",
        "        self.add_foreground_mobjects(title, derivative)\n",
        "\n",
        "\n",
        "    def put_angle_tex_next_to_arc(self, angle_tex, arc):\n",
        "        IntroduceAnglePreservation.put_angle_tex_next_to_arc(\n",
        "            self, angle_tex, arc\n",
        "        )\n",
        "        if not self.is_before_transformation:\n",
        "            two_dot = OldTex(\"2 \\\\times \")\n",
        "            two_dot.set_color(angle_tex.get_color())\n",
        "            two_dot.next_to(angle_tex, LEFT, buff = SMALL_BUFF)\n",
        "            two_dot.add_background_rectangle()\n",
        "            center = angle_tex.get_center()\n",
        "            angle_tex.add_to_back(two_dot)\n",
        "            angle_tex.move_to(center)\n",
        "        else:\n",
        "            self.is_before_transformation = False\n",
        "\n",
        "class AnglePreservationAtAnyPairOfPoints(IntroduceAnglePreservation):\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.plane.fade()\n",
        "        line_pairs = self.get_line_pairs()\n",
        "        line_pair = line_pairs[0]\n",
        "        for target_pair in line_pairs[1:]:\n",
        "            self.play(Transform(\n",
        "                line_pair, target_pair,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.show_angle_preservation_between_lines(*line_pair)\n",
        "        self.show_example_analytic_functions()\n",
        "\n",
        "    def get_line_pairs(self):\n",
        "        return list(it.starmap(VGroup, [\n",
        "            (\n",
        "                Line(3*DOWN, 3*LEFT+2*UP),\n",
        "                Line(2*LEFT+DOWN, 3*UP+RIGHT)\n",
        "            ),\n",
        "            (\n",
        "                Line(2*RIGHT+DOWN, 3*LEFT+2*UP),\n",
        "                Line(LEFT+3*DOWN, 4*RIGHT+3*UP),\n",
        "            ),\n",
        "            (\n",
        "                Line(LEFT+3*DOWN, LEFT+3*UP),\n",
        "                Line(5*LEFT+UP, 3*RIGHT+UP)\n",
        "            ),\n",
        "            (\n",
        "                Line(4*RIGHT+3*DOWN, RIGHT+2*UP),\n",
        "                Line(3*DOWN+RIGHT, 2*UP+2*RIGHT)\n",
        "            ),\n",
        "        ]))\n",
        "\n",
        "    def show_example_analytic_functions(self):\n",
        "        words = OldTexText(\"Examples of analytic functions:\")\n",
        "        words.shift(2*UP)\n",
        "        words.set_color(YELLOW)\n",
        "        words.add_background_rectangle()\n",
        "        words.next_to(UP, UP).to_edge(LEFT)\n",
        "        functions = OldTexText(\n",
        "            \"$e^x$, \",\n",
        "            \"$\\\\sin(x)$, \",\n",
        "            \"any polynomial, \"\n",
        "            \"$\\\\log(x)$, \",\n",
        "            \"\\\\dots\",\n",
        "        )\n",
        "        functions.next_to(ORIGIN, UP).to_edge(LEFT)\n",
        "        for function in functions:\n",
        "            function.add_to_back(BackgroundRectangle(function))\n",
        "\n",
        "        self.play(Write(words))\n",
        "        for function in functions:\n",
        "            self.play(FadeIn(function))\n",
        "        self.wait()\n",
        "\n",
        "class NoteZetaFunctionAnalyticOnRightHalf(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 35,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_transformable_plane(animate = False)\n",
        "        self.add_extra_plane_lines_for_zeta(animate = True)\n",
        "        self.apply_zeta_function()\n",
        "        self.note_right_angles()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\n",
        "            \"\\\\zeta(s) = \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\"\n",
        "        )\n",
        "        title[2].set_color(YELLOW)\n",
        "        title[-1].set_color(YELLOW)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def note_right_angles(self):\n",
        "        intersection_inputs = [\n",
        "            complex(x, y)\n",
        "            for x in np.arange(1+2./16, 1.4, 1./16)\n",
        "            for y in np.arange(-0.5, 0.5, 1./16)\n",
        "            if abs(y) > 1./16\n",
        "        ]\n",
        "        brackets = VGroup(*list(map(\n",
        "            self.get_right_angle_bracket,\n",
        "            intersection_inputs\n",
        "        )))\n",
        "        self.play(ShowCreation(brackets, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "    def get_right_angle_bracket(self, input_z):\n",
        "        output_z = zeta(input_z)\n",
        "        derivative = d_zeta(input_z)\n",
        "        rotation = np.log(derivative).imag\n",
        "\n",
        "        brackets = VGroup(\n",
        "            Line(RIGHT, RIGHT+UP),\n",
        "            Line(RIGHT+UP, UP)\n",
        "        )\n",
        "        brackets.scale(0.1)\n",
        "        brackets.set_stroke(width = 2)\n",
        "        brackets.set_color(YELLOW)\n",
        "        brackets.rotate(rotation, about_point = ORIGIN)\n",
        "        brackets.shift(self.z_to_point(output_z))\n",
        "        return brackets\n",
        "\n",
        "class InfiniteContinuousJigsawPuzzle(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 35,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.set_stage()\n",
        "        self.add_title()\n",
        "        self.show_jigsaw()\n",
        "        self.name_analytic_continuation()\n",
        "\n",
        "    def set_stage(self):\n",
        "        self.plane = self.get_dense_grid()\n",
        "        left_plane = self.get_reflected_plane()\n",
        "        self.plane.add(left_plane)\n",
        "        self.apply_zeta_function(run_time = 0)\n",
        "        self.remove(left_plane)\n",
        "        lines_per_piece = 5\n",
        "        pieces = [\n",
        "            VGroup(*left_plane[lines_per_piece*i:lines_per_piece*(i+1)])\n",
        "            for i in range(len(list(left_plane))/lines_per_piece)\n",
        "        ]\n",
        "        random.shuffle(pieces)\n",
        "        self.pieces = pieces\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Infinite \", \"continuous \", \"jigsaw puzzle\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        for word in title:\n",
        "            word.add_to_back(BackgroundRectangle(word))\n",
        "            self.play(FadeIn(word))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_jigsaw(self):\n",
        "        for piece in self.pieces:\n",
        "            self.play(FadeIn(piece, run_time = 0.5))\n",
        "        self.wait()\n",
        "\n",
        "    def name_analytic_continuation(self):\n",
        "        words = OldTexText(\"``Analytic continuation''\")\n",
        "        words.set_color(YELLOW)\n",
        "        words.scale(1.5)\n",
        "        words.next_to(self.title, DOWN, buff = LARGE_BUFF)\n",
        "        words.add_background_rectangle()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class ThatsHowZetaIsDefined(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_zeta_definition()\n",
        "        self.teacher_says(\"\"\"\n",
        "            So that's how\n",
        "            $\\\\zeta(s)$ is defined\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.random_blink(2)\n",
        "\n",
        "    def add_zeta_definition(self):\n",
        "        zeta = OldTex(\n",
        "            \"\\\\zeta(s) = \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\"\n",
        "        )\n",
        "        VGroup(zeta[2], zeta[-1]).set_color(YELLOW)\n",
        "        zeta.to_corner(UP+LEFT)\n",
        "        self.add(zeta)\n",
        "\n",
        "class ManyIntersectingLinesPreZeta(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"apply_zeta\" : False,\n",
        "        \"lines_center\" : RIGHT,\n",
        "        \"nudge_size\" : 0.9,\n",
        "        \"function\" : zeta,\n",
        "        \"angle\" : np.pi/5,\n",
        "        \"arc_scale_factor\" : 0.3,\n",
        "        \"shift_directions\" : [LEFT, RIGHT],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.establish_plane()\n",
        "        self.add_title()\n",
        "\n",
        "        line = Line(DOWN+2*LEFT, UP+2*RIGHT)\n",
        "        lines = VGroup(line, line.copy().rotate(self.angle))\n",
        "        arc = Arc(start_angle = line.get_angle(), angle = self.angle)\n",
        "        arc.scale(self.arc_scale_factor)\n",
        "        arc.set_color(YELLOW)\n",
        "        lines.add(arc)\n",
        "        # lines.set_stroke(WHITE, width = 5)\n",
        "        lines.shift(self.lines_center + self.nudge_size*RIGHT)\n",
        "\n",
        "        if self.apply_zeta:\n",
        "            self.apply_zeta_function(run_time = 0)\n",
        "            lines.set_stroke(width = 0)\n",
        "\n",
        "        added_anims = self.get_modified_line_anims(lines)\n",
        "        for vect in self.shift_directions:\n",
        "            self.play(\n",
        "                ApplyMethod(lines.shift, 2*self.nudge_size*vect, path_arc = np.pi),\n",
        "                *added_anims,\n",
        "                run_time = 3\n",
        "            )\n",
        "\n",
        "    def establish_plane(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.add_reflected_plane()\n",
        "        self.plane.fade()\n",
        "\n",
        "\n",
        "    def add_title(self):\n",
        "        if self.apply_zeta:\n",
        "            title = OldTexText(\"After \\\\\\\\ transformation\")\n",
        "        else:\n",
        "            title = OldTexText(\"Before \\\\\\\\ transformation\")\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP)\n",
        "        self.add_foreground_mobjects(title)\n",
        "\n",
        "    def get_modified_line_anims(self, lines):\n",
        "        return []\n",
        "\n",
        "class ManyIntersectingLinesPostZeta(ManyIntersectingLinesPreZeta):\n",
        "    CONFIG = {\n",
        "        \"apply_zeta\" : True,\n",
        "        # \"anchor_density\" : 5\n",
        "    }\n",
        "    def get_modified_line_anims(self, lines):\n",
        "        n_inserted_points = 30\n",
        "        new_lines = lines.copy()\n",
        "        new_lines.set_stroke(width = 5)\n",
        "        def update_new_lines(lines_to_update):\n",
        "            transformed = lines.copy()\n",
        "            self.prepare_for_transformation(transformed)\n",
        "            transformed.apply_complex_function(self.function)\n",
        "            transformed.make_smooth()\n",
        "            transformed.set_stroke(width = 5)\n",
        "            for start, end in zip(lines_to_update, transformed):\n",
        "                if start.get_num_points() > 0:\n",
        "                    start.points = np.array(end.points)\n",
        "        return [UpdateFromFunc(new_lines, update_new_lines)]\n",
        "\n",
        "class ManyIntersectingLinesPreSSquared(ManyIntersectingLinesPreZeta):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -int(FRAME_X_RADIUS),\n",
        "        \"apply_zeta\" : False,\n",
        "        \"lines_center\" : ORIGIN,\n",
        "        \"nudge_size\" : 0.9,\n",
        "        \"function\" : lambda z : z**2,\n",
        "        \"shift_directions\" : [LEFT, RIGHT, UP, DOWN, DOWN+LEFT, UP+RIGHT],\n",
        "    }\n",
        "    def establish_plane(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.plane.fade()\n",
        "\n",
        "    def apply_zeta_function(self, **kwargs):\n",
        "        self.apply_complex_function(self.function, **kwargs)\n",
        "\n",
        "class ManyIntersectingLinesPostSSquared(ManyIntersectingLinesPreSSquared):\n",
        "    CONFIG = {\n",
        "        \"apply_zeta\" : True,\n",
        "    }\n",
        "    def get_modified_line_anims(self, lines):\n",
        "        n_inserted_points = 30\n",
        "        new_lines = lines.copy()\n",
        "        new_lines.set_stroke(width = 5)\n",
        "        def update_new_lines(lines_to_update):\n",
        "            transformed = lines.copy()\n",
        "            self.prepare_for_transformation(transformed)\n",
        "            transformed.apply_complex_function(self.function)\n",
        "            transformed.make_smooth()\n",
        "            transformed.set_stroke(width = 5)\n",
        "            for start, end in zip(lines_to_update, transformed):\n",
        "                if start.get_num_points() > 0:\n",
        "                    start.points = np.array(end.points)\n",
        "        return [UpdateFromFunc(new_lines, update_new_lines)]\n",
        "\n",
        "class ButWhatIsTheExensions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            But what exactly \\\\emph{is}\n",
        "            that continuation?\n",
        "            \"\"\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"confused\")\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\"\"\"\n",
        "            You're $\\\\$1{,}000{,}000$ richer\n",
        "            if you can answer\n",
        "            that fully\n",
        "        \"\"\", target_mode = \"shruggie\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "class MathematiciansLookingAtFunctionEquation(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"\\\\zeta(s)\",\n",
        "            \"= 2^s \\\\pi ^{s-1}\",\n",
        "            \"\\\\sin\\\\left(\\\\frac{\\\\pi s}{2}\\\\right)\",\n",
        "            \"\\\\Gamma(1-s)\",\n",
        "            \"\\\\zeta(1-s)\",\n",
        "        )\n",
        "        equation.shift(UP)\n",
        "\n",
        "        mathy = Mathematician().to_corner(DOWN+LEFT)\n",
        "        mathys = VGroup(mathy)\n",
        "        for x in range(2):\n",
        "            mathys.add(Mathematician().next_to(mathys))\n",
        "        for mathy in mathys:\n",
        "            mathy.change_mode(\"pondering\")\n",
        "            mathy.look_at(equation)\n",
        "\n",
        "        self.add(mathys)\n",
        "        self.play(Write(VGroup(*equation[:-1])))\n",
        "        self.play(Transform(\n",
        "            equation[0].copy(),\n",
        "            equation[-1],\n",
        "            path_arc = -np.pi/3,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        for mathy in mathys:\n",
        "            self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "class DiscussZeros(ZetaTransformationScene):\n",
        "    def construct(self):\n",
        "        self.establish_plane()\n",
        "        self.ask_about_zeros()\n",
        "        self.show_trivial_zeros()\n",
        "        self.show_critical_strip()\n",
        "        self.transform_bit_of_critical_line()\n",
        "        self.extend_transformed_critical_line()\n",
        "\n",
        "    def establish_plane(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.add_reflected_plane()\n",
        "        self.plane.fade()\n",
        "\n",
        "    def ask_about_zeros(self):\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                (2+np.sin(12*alpha))*\\\n",
        "                rotate_vector(RIGHT, alpha+nudge)\n",
        "            )\n",
        "            for alpha in np.arange(3*np.pi/20, 2*np.pi, 2*np.pi/5)\n",
        "            for nudge in [random.random()*np.pi/6]\n",
        "        ])\n",
        "        dots.set_color(YELLOW)\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"?\").next_to(dot, UP)\n",
        "            for dot in dots\n",
        "        ])\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(dot, ORIGIN, buff = 0.2, tip_length = 0.1)\n",
        "            for dot in dots\n",
        "        ])\n",
        "        question = OldTexText(\"Which numbers go to $0$?\")\n",
        "        question.add_background_rectangle()\n",
        "        question.to_edge(UP)\n",
        "\n",
        "        for mob in dots, arrows, q_marks:\n",
        "            self.play(ShowCreation(mob))\n",
        "        self.play(Write(question))\n",
        "        self.wait(2)\n",
        "        dots.generate_target()\n",
        "        for i, dot in enumerate(dots.target):\n",
        "            dot.move_to(2*(i+1)*LEFT)\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(q_marks),\n",
        "            FadeOut(question),\n",
        "            MoveToTarget(dots),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.dots = dots\n",
        "\n",
        "    def show_trivial_zeros(self):\n",
        "        trivial_zero_words = OldTexText(\"``Trivial'' zeros\")\n",
        "        trivial_zero_words.next_to(ORIGIN, UP)\n",
        "        trivial_zero_words.to_edge(LEFT)\n",
        "\n",
        "        randy = Randolph().flip()\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "        bubble = randy.get_bubble()\n",
        "        bubble.set_fill(BLACK, opacity = 0.8)\n",
        "        bubble.write(\"$1^1 + 2^2 + 3^2 + \\\\cdots = 0$\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.pin_to(randy)\n",
        "\n",
        "        self.plane.save_state()\n",
        "        self.dots.save_state()\n",
        "        for dot in self.dots.target:\n",
        "            dot.move_to(ORIGIN)\n",
        "        self.apply_zeta_function(\n",
        "            added_anims = [MoveToTarget(self.dots, run_time = 3)],\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            self.plane.restore,\n",
        "            self.plane.make_smooth,\n",
        "            self.dots.restore,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.plane.restore()\n",
        "        self.dots.restore()\n",
        "        self.add(self.plane, self.dots)\n",
        "\n",
        "        self.play(Write(trivial_zero_words))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"confused\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            randy, bubble, bubble.content, trivial_zero_words\n",
        "        ])))\n",
        "\n",
        "    def show_critical_strip(self):\n",
        "        strip = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = 1\n",
        "        )\n",
        "        strip.next_to(ORIGIN, RIGHT, buff = 0)\n",
        "        strip.set_stroke(width = 0)\n",
        "        strip.set_fill(YELLOW, opacity = 0.3)\n",
        "        name = OldTexText(\"Critical strip\")\n",
        "        name.add_background_rectangle()\n",
        "        name.next_to(ORIGIN, LEFT)\n",
        "        name.to_edge(UP)\n",
        "        arrow = Arrow(name.get_bottom(), 0.5*RIGHT+UP)\n",
        "        primes = OldTex(\"2, 3, 5, 7, 11, 13, 17, \\\\dots\")\n",
        "        primes.to_corner(UP+RIGHT)\n",
        "        # photo = Square()\n",
        "        photo = ImageMobject(\"Riemann\", invert = False)\n",
        "        photo.set_width(5)\n",
        "        photo.to_corner(UP+LEFT)\n",
        "        new_dots = VGroup(*[\n",
        "            Dot(0.5*RIGHT + y*UP)\n",
        "            for y in np.linspace(-2.5, 3.2, 5)\n",
        "        ])\n",
        "        new_dots.set_color(YELLOW)\n",
        "        critical_line = Line(\n",
        "            0.5*RIGHT+FRAME_Y_RADIUS*DOWN,\n",
        "            0.5*RIGHT+FRAME_Y_RADIUS*UP,\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.give_dots_wandering_anims()\n",
        "\n",
        "        self.play(FadeIn(strip), *self.get_dot_wandering_anims())\n",
        "        self.play(\n",
        "            Write(name, run_time = 1),\n",
        "            ShowCreation(arrow),\n",
        "            *self.get_dot_wandering_anims()\n",
        "        )\n",
        "        self.play(*self.get_dot_wandering_anims())\n",
        "        self.play(\n",
        "            FadeIn(primes),\n",
        "            *self.get_dot_wandering_anims()\n",
        "        )\n",
        "        for x in range(7):\n",
        "            self.play(*self.get_dot_wandering_anims())\n",
        "        self.play(\n",
        "            GrowFromCenter(photo),\n",
        "            FadeOut(name),\n",
        "            FadeOut(arrow),\n",
        "            *self.get_dot_wandering_anims()\n",
        "        )\n",
        "        self.play(Transform(self.dots, new_dots))\n",
        "        self.play(ShowCreation(critical_line))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            photo.shift, 7*LEFT,\n",
        "            *list(map(FadeOut, [\n",
        "            primes, self.dots, strip\n",
        "            ]))\n",
        "        )\n",
        "        self.remove(photo)\n",
        "        self.critical_line = critical_line\n",
        "\n",
        "    def give_dots_wandering_anims(self):\n",
        "        def func(t):\n",
        "            result = (np.sin(6*2*np.pi*t) + 1)*RIGHT/2\n",
        "            result += 3*np.cos(2*2*np.pi*t)*UP\n",
        "            return result\n",
        "\n",
        "        self.wandering_path = ParametricCurve(func)\n",
        "        for i, dot in enumerate(self.dots):\n",
        "            dot.target = dot.copy()\n",
        "            q_mark = OldTex(\"?\")\n",
        "            q_mark.next_to(dot.target, UP)\n",
        "            dot.target.add(q_mark)\n",
        "            dot.target.move_to(self.wandering_path.point_from_proportion(\n",
        "                (float(2+2*i)/(4*len(list(self.dots))))%1\n",
        "            ))\n",
        "        self.dot_anim_count = 0\n",
        "\n",
        "    def get_dot_wandering_anims(self):\n",
        "        self.dot_anim_count += 1\n",
        "        if self.dot_anim_count == 1:\n",
        "            return list(map(MoveToTarget, self.dots))\n",
        "        denom = 4*(len(list(self.dots)))\n",
        "        def get_rate_func(index):\n",
        "            return lambda t : (float(self.dot_anim_count + 2*index + t)/denom)%1\n",
        "        return [\n",
        "            MoveAlongPath(\n",
        "                dot, self.wandering_path,\n",
        "                rate_func = get_rate_func(i)\n",
        "            )\n",
        "            for i, dot in enumerate(self.dots)\n",
        "        ]\n",
        "\n",
        "    def transform_bit_of_critical_line(self):\n",
        "        self.play(\n",
        "            self.plane.scale, 0.8,\n",
        "            self.critical_line.scale, 0.8,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.plane.set_stroke, GREY, 1,\n",
        "            Animation(self.critical_line)\n",
        "        )\n",
        "        self.plane.add(self.critical_line)\n",
        "        self.apply_zeta_function()\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.plane.fade,\n",
        "            Animation(self.critical_line)\n",
        "        )\n",
        "\n",
        "    def extend_transformed_critical_line(self):\n",
        "        def func(t):\n",
        "            z = zeta(complex(0.5, t))\n",
        "            return z.real*RIGHT + z.imag*UP\n",
        "        full_line = VGroup(*[\n",
        "            ParametricCurve(func, t_min = t0, t_max = t0+1)\n",
        "            for t0 in range(100)\n",
        "        ])\n",
        "        full_line.set_color_by_gradient(\n",
        "            YELLOW, BLUE, GREEN, RED, YELLOW, BLUE, GREEN, RED,\n",
        "        )\n",
        "        self.play(ShowCreation(full_line, run_time = 20, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutRelationToPrimes(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            Whoa!  Where the heck\n",
        "            do primes come in here?\n",
        "        \"\"\", target_mode = \"confused\")\n",
        "        self.random_blink(3)\n",
        "        self.teacher_says(\"\"\"\n",
        "            Perhaps in a\n",
        "            different video.\n",
        "        \"\"\", target_mode = \"hesitant\")\n",
        "        self.random_blink(3)\n",
        "\n",
        "class HighlightCriticalLineAgain(DiscussZeros):\n",
        "    def construct(self):\n",
        "        self.establish_plane()\n",
        "        title = OldTex(\"\\\\zeta(\", \"s\", \") = 0\")\n",
        "        title.set_color_by_tex(\"s\", YELLOW)\n",
        "        title.add_background_rectangle()\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.add(title)\n",
        "\n",
        "        strip = Rectangle(\n",
        "            height = FRAME_HEIGHT,\n",
        "            width = 1\n",
        "        )\n",
        "        strip.next_to(ORIGIN, RIGHT, buff = 0)\n",
        "        strip.set_stroke(width = 0)\n",
        "        strip.set_fill(YELLOW, opacity = 0.3)\n",
        "        line = Line(\n",
        "            0.5*RIGHT+FRAME_Y_RADIUS*UP,\n",
        "            0.5*RIGHT+FRAME_Y_RADIUS*DOWN,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        randy = Randolph().to_corner(DOWN+LEFT)\n",
        "        million = OldTex(\"\\\\$1{,}000{,}000\")\n",
        "        million.set_color(GREEN_B)\n",
        "        million.next_to(ORIGIN, UP+LEFT)\n",
        "        million.shift(2*LEFT)\n",
        "        arrow1 = Arrow(million.get_right(), line.get_top())\n",
        "        arrow2 = Arrow(million.get_right(), line.get_bottom())\n",
        "\n",
        "        self.add(randy, strip)\n",
        "        self.play(Write(million))\n",
        "        self.play(\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, line.get_top(),\n",
        "            ShowCreation(arrow1),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.play(\n",
        "            randy.look_at, line.get_bottom(),\n",
        "            ShowCreation(line),\n",
        "            Transform(arrow1, arrow2)\n",
        "        )\n",
        "        self.play(FadeOut(arrow1))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.look_at, line.get_center())\n",
        "        self.play(randy.change_mode, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"pondering\")\n",
        "        self.wait()\n",
        "\n",
        "class DiscussSumOfNaturals(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTex(\n",
        "            \"\\\\zeta(s) = \\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^s}\"\n",
        "        )\n",
        "        VGroup(title[2], title[-1]).set_color(YELLOW)\n",
        "        title.to_corner(UP+LEFT)\n",
        "\n",
        "        neg_twelfth, eq, zeta_neg_1, sum_naturals = equation = OldTex(\n",
        "            \"-\\\\frac{1}{12}\",\n",
        "            \"=\",\n",
        "            \"\\\\zeta(-1)\",\n",
        "            \"= 1 + 2 + 3 + 4 + \\\\cdots\"\n",
        "        )\n",
        "        neg_twelfth.set_color(GREEN_B)\n",
        "        VGroup(*zeta_neg_1[2:4]).set_color(YELLOW)\n",
        "        q_mark = OldTex(\"?\").next_to(sum_naturals[0], UP)\n",
        "        q_mark.set_color(RED)\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        analytic_continuation = OldTexText(\"Analytic continuation\")\n",
        "        analytic_continuation.next_to(title, RIGHT, 3*LARGE_BUFF)\n",
        "\n",
        "        sum_to_zeta = Arrow(title.get_corner(DOWN+RIGHT), zeta_neg_1)\n",
        "        sum_to_ac = Arrow(title.get_right(), analytic_continuation)\n",
        "        ac_to_zeta = Arrow(analytic_continuation.get_bottom(), zeta_neg_1.get_top())\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.scale(2)\n",
        "        cross.set_color(RED)\n",
        "        cross.rotate(np.pi/6)\n",
        "        cross.move_to(sum_to_zeta.get_center())\n",
        "\n",
        "        brace = Brace(VGroup(zeta_neg_1, sum_naturals))\n",
        "        words = OldTexText(\n",
        "            \"If not equal, at least connected\",\n",
        "            \"\\\\\\\\(see links in description)\"\n",
        "        )\n",
        "        words.next_to(brace, DOWN)\n",
        "\n",
        "        self.add(neg_twelfth, eq, zeta_neg_1, randy, title)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(sum_naturals),\n",
        "            Write(q_mark),\n",
        "            randy.change_mode, \"confused\"\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change_mode, \"angry\")\n",
        "        self.play(\n",
        "            ShowCreation(sum_to_zeta),\n",
        "            Write(cross)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(sum_to_zeta, sum_to_ac),\n",
        "            FadeOut(cross),\n",
        "            Write(analytic_continuation),\n",
        "            randy.change_mode, \"pondering\",\n",
        "            randy.look_at, analytic_continuation,\n",
        "        )\n",
        "        self.play(ShowCreation(ac_to_zeta))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words[0]),\n",
        "            randy.look_at, words[0],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(words[1]))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class InventingMathPreview(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(4)\n",
        "        title = OldTexText(\"What does it feel like to invent math?\")\n",
        "        title.next_to(rect, UP)\n",
        "        sum_tex = OldTex(\"1+2+4+8+\\\\cdots = -1\")\n",
        "        sum_tex.set_width(rect.get_width()-1)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(title)\n",
        "        )\n",
        "        self.play(Write(sum_tex))\n",
        "        self.wait()\n",
        "\n",
        "class FinalAnimationTease(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer().shift(2*(DOWN+RIGHT))\n",
        "        bubble = morty.get_bubble(SpeechBubble)\n",
        "        bubble.write(\"\"\"\n",
        "            Want to know what\n",
        "            $\\\\zeta'(s)$ looks like?\n",
        "        \"\"\")\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            morty.change_mode, \"hooray\",\n",
        "            morty.look_at, bubble.content,\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class PatreonThanks(Scene):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"CrypticSwarm\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Batiz-Benet\",\n",
        "            \"Yu Jun\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Einar Johansen\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk Werklund\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Felipe Diniz\",\n",
        "        ]\n",
        "    }\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "\n",
        "        n_patrons = len(self.specific_patrons)\n",
        "        special_thanks = OldTexText(\"Special thanks to:\")\n",
        "        special_thanks.set_color(YELLOW)\n",
        "        special_thanks.shift(3*UP)\n",
        "        patreon_logo = ImageMobject(\"patreon\", invert = False)\n",
        "        patreon_logo.set_height(1.5)\n",
        "        patreon_logo.next_to(special_thanks, DOWN)\n",
        "\n",
        "        left_patrons = VGroup(*list(map(TexText,\n",
        "            self.specific_patrons[:n_patrons/2]\n",
        "        )))\n",
        "        right_patrons = VGroup(*list(map(TexText,\n",
        "            self.specific_patrons[n_patrons/2:]\n",
        "        )))\n",
        "        for patrons, vect in (left_patrons, LEFT), (right_patrons, RIGHT):\n",
        "            patrons.arrange(DOWN, aligned_edge = LEFT)\n",
        "            patrons.next_to(special_thanks, DOWN)\n",
        "            patrons.to_edge(vect, buff = LARGE_BUFF)\n",
        "\n",
        "        self.add(patreon_logo)\n",
        "        self.play(morty.change_mode, \"gracious\")\n",
        "        self.play(Write(special_thanks, run_time = 1))\n",
        "        self.play(\n",
        "            Write(left_patrons),\n",
        "            morty.look_at, left_patrons\n",
        "        )\n",
        "        self.play(\n",
        "            Write(right_patrons),\n",
        "            morty.look_at, right_patrons\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        for patrons in left_patrons, right_patrons:\n",
        "            for index in 0, -1:\n",
        "                self.play(morty.look_at, patrons[index])\n",
        "                self.wait()\n",
        "\n",
        "class CreditTwo(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(ORIGIN, DOWN)\n",
        "        morty.to_edge(RIGHT)\n",
        "\n",
        "        brother = PiCreature(color = GOLD_E)\n",
        "        brother.next_to(morty, LEFT)\n",
        "        brother.look_at(morty.eyes)\n",
        "\n",
        "        headphones = Headphones(height = 1)\n",
        "        headphones.move_to(morty.eyes, aligned_edge = DOWN)\n",
        "        headphones.shift(0.1*DOWN)\n",
        "\n",
        "        url = OldTexText(\"www.audible.com/3blue1brown\")\n",
        "        url.to_corner(UP+RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeIn(headphones),\n",
        "            Write(url),\n",
        "            Animation(morty)\n",
        "        )\n",
        "        self.play(morty.change_mode, \"happy\")\n",
        "        for x in range(4):\n",
        "            self.wait()\n",
        "            self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(brother),\n",
        "            morty.look_at, brother.eyes\n",
        "        )\n",
        "        self.play(brother.change_mode, \"surprised\")\n",
        "        self.play(Blink(brother))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.look, LEFT,\n",
        "            brother.change_mode, \"happy\",\n",
        "            brother.look, LEFT\n",
        "        )\n",
        "        for x in range(10):\n",
        "            self.play(Blink(morty))\n",
        "            self.wait()\n",
        "            self.play(Blink(brother))\n",
        "            self.wait()\n",
        "\n",
        "class FinalAnimation(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"min_added_anchors\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.add_reflected_plane()\n",
        "        title = OldTex(\"s\", \"\\\\to \\\\frac{d\\\\zeta}{ds}(\", \"s\", \")\")\n",
        "        title.set_color_by_tex(\"s\", YELLOW)\n",
        "        title.add_background_rectangle()\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.add_foreground_mobjects(title)\n",
        "        self.wait()\n",
        "        self.apply_complex_function(d_zeta, run_time = 8)\n",
        "        self.wait()\n",
        "\n",
        "class Thumbnail(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 35\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.y_min = -4\n",
        "        self.y_max = 4\n",
        "        self.x_min = 1\n",
        "        self.x_max = int(FRAME_X_RADIUS+2)\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.add_reflected_plane()\n",
        "        # self.apply_zeta_function()\n",
        "        self.plane.set_stroke(width = 4)\n",
        "\n",
        "        div_sum = OldTex(\"-\\\\frac{1}{12} = \", \"1+2+3+4+\\\\cdots\")\n",
        "        div_sum.set_width(FRAME_WIDTH-1)\n",
        "        div_sum.to_edge(DOWN)\n",
        "        div_sum.set_color(YELLOW)\n",
        "        div_sum.set_background_stroke(width=8)\n",
        "        # for mob in div_sum.submobjects:\n",
        "        #     mob.add_to_back(BackgroundRectangle(mob))\n",
        "\n",
        "        zeta = OldTex(\"\\\\zeta(s)\")\n",
        "        zeta.set_height(FRAME_Y_RADIUS-1)\n",
        "        zeta.to_corner(UP+LEFT)\n",
        "\n",
        "        million = OldTex(\"\\\\$1{,}000{,}000\")\n",
        "        million.set_width(FRAME_X_RADIUS+1)\n",
        "        million.to_edge(UP+RIGHT)\n",
        "        million.set_color(GREEN_B)\n",
        "        million.set_background_stroke(width=8)\n",
        "\n",
        "        self.add(div_sum, million, zeta)\n",
        "\n",
        "class ZetaThumbnail(Scene):\n",
        "    def construct(self):\n",
        "        plane = ComplexPlane(\n",
        "            x_range=(-5, 5), y_range=(-3, 3),\n",
        "            background_line_style={\n",
        "                \"stroke_width\": 2,\n",
        "                \"stroke_opacity\": 0.75,\n",
        "            }\n",
        "        )\n",
        "        plane.set_height(FRAME_HEIGHT)\n",
        "        plane.scale(3 / 2.5)\n",
        "        plane.add_coordinate_labels(font_size=12)\n",
        "        # self.add(plane)\n",
        "\n",
        "        lines = VGroup(\n",
        "            *(\n",
        "                Line(plane.c2p(-7, y), plane.c2p(7, y))\n",
        "                for y in np.arange(-2, 2, 0.1)\n",
        "                if y != 0\n",
        "            ),\n",
        "            *(\n",
        "                Line(plane.c2p(x, -4), plane.c2p(x, 4))\n",
        "                for x in np.arange(-2, 2, 0.1)\n",
        "                if x != 0\n",
        "            ),\n",
        "        )\n",
        "        lines.insert_n_curves(200)\n",
        "        lines.apply_function(lambda p: plane.n2p(zeta(plane.p2n(p))))\n",
        "        lines.make_smooth()\n",
        "        lines.set_stroke(GREY_B, 1, opacity=0.5)\n",
        "        # self.add(lines)\n",
        "\n",
        "        c_line = Line(plane.c2p(0.5, 0), plane.c2p(0.5, 35))\n",
        "        c_line.insert_n_curves(1000)\n",
        "        c_line.apply_function(lambda p: plane.n2p(zeta(plane.p2n(p))))\n",
        "        c_line.make_smooth()\n",
        "        c_line.set_stroke([TEAL, YELLOW], width=[7, 3])\n",
        "\n",
        "        shadow = VGroup()\n",
        "        for w in np.linspace(25, 0, 50):\n",
        "            cc = c_line.copy()\n",
        "            cc.set_stroke(BLACK, width=w, opacity=0.025)\n",
        "            shadow.add(cc)\n",
        "\n",
        "        self.add(shadow)\n",
        "        self.add(c_line)\n",
        "\n",
        "        sym = OldTex(\"\\\\zeta\\\\left(s\\\\right)\")\n",
        "        sym.set_height(1.5)\n",
        "        sym.move_to(FRAME_WIDTH * LEFT / 4 + FRAME_HEIGHT * UP / 4)\n",
        "        shadow = VGroup()\n",
        "        for w in np.linspace(50, 0, 50):\n",
        "            sc = sym.copy()\n",
        "            sc.set_fill(opacity=0)\n",
        "            sc.set_stroke(BLACK, width=w, opacity=0.05)\n",
        "            shadow.add(sc)\n",
        "        # self.add(shadow)\n",
        "        # self.add(sym)\n",
        "\n",
        "class ZetaPartialSums(ZetaTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"anchor_density\" : 35,\n",
        "        \"num_partial_sums\" : 12,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_transformable_plane()\n",
        "        self.add_extra_plane_lines_for_zeta()\n",
        "        self.prepare_for_transformation(self.plane)\n",
        "\n",
        "        N_list = [2**k for k in range(self.num_partial_sums)]\n",
        "        sigma = OldTex(\n",
        "            \"\\\\sum_{n = 1}^N \\\\frac{1}{n^s}\"\n",
        "        )\n",
        "        sigmas = []\n",
        "        for N in N_list + [\"\\\\infty\"]:\n",
        "            tex = OldTex(str(N))\n",
        "            tex.set_color(YELLOW)\n",
        "            new_sigma = sigma.copy()\n",
        "            top = new_sigma[0]\n",
        "            tex.move_to(top, DOWN)\n",
        "            new_sigma.remove(top)\n",
        "            new_sigma.add(tex)\n",
        "            new_sigma.to_corner(UP+LEFT)\n",
        "            sigmas.append(new_sigma)\n",
        "\n",
        "        def get_partial_sum_func(n_terms):\n",
        "            return lambda s : sum([1./(n**s) for n in range(1, n_terms+1)])\n",
        "        interim_planes = [\n",
        "            self.plane.copy().apply_complex_function(\n",
        "                get_partial_sum_func(N)\n",
        "            )\n",
        "            for N in N_list\n",
        "        ]\n",
        "        interim_planes.append(self.plane.copy().apply_complex_function(zeta))\n",
        "        symbol = VGroup(OldTex(\"s\"))\n",
        "        symbol.scale(2)\n",
        "        symbol.set_color(YELLOW)\n",
        "        symbol.to_corner(UP+LEFT)\n",
        "        for plane, sigma in zip(interim_planes, sigmas):\n",
        "            self.play(\n",
        "                Transform(self.plane, plane),\n",
        "                Transform(symbol, sigma)\n",
        "            )\n",
        "            self.wait()\n"
    ]
}