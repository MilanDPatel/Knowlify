{
    "topic": "The mathematical concept being demonstrated is the projection of a 3D point onto a 2D plane",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.shadows import *\n",
        "\n",
        "\n",
        "# Abstract scenes\n",
        "\n",
        "class Cylinder(Sphere):\n",
        "    \"\"\"\n",
        "    Inherits from sphere so as to be as aligned as possible\n",
        "    for transformations\n",
        "    \"\"\"\n",
        "\n",
        "    def func(self, u, v):\n",
        "        return np.array([\n",
        "            np.cos(v),\n",
        "            np.sin(v),\n",
        "            np.cos(u)\n",
        "        ])\n",
        "\n",
        "\n",
        "class UnwrappedCylinder(Cylinder):\n",
        "    def func(self, u, v):\n",
        "        return np.array([\n",
        "            v - PI,\n",
        "            -self.radius,\n",
        "            np.cos(u)\n",
        "        ])\n",
        "\n",
        "\n",
        "class ParametricDisc(Sphere):\n",
        "    CONFIG = {\n",
        "        \"u_min\": 0,\n",
        "        \"u_max\": 1,\n",
        "        \"stroke_width\": 0,\n",
        "        \"checkerboard_colors\": [BLUE_D],\n",
        "    }\n",
        "\n",
        "    def func(self, u, v):\n",
        "        return np.array([\n",
        "            u * np.cos(v),\n",
        "            u * np.sin(v),\n",
        "            0,\n",
        "        ])\n",
        "\n",
        "\n",
        "class SphereCylinderScene(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"cap_config\": {\n",
        "            \"stroke_width\": 1,\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"fill_color\": BLUE_D,\n",
        "            \"fill_opacity\": 1,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def get_cylinder(self, **kwargs):\n",
        "        config = merge_dicts_recursively(self.sphere_config, kwargs)\n",
        "        return Cylinder(**config)\n",
        "\n",
        "    def get_cylinder_caps(self):\n",
        "        R = self.sphere_config[\"radius\"]\n",
        "        caps = VGroup(*[\n",
        "            Circle(\n",
        "                radius=R,\n",
        "                **self.cap_config,\n",
        "            ).shift(R * vect)\n",
        "            for vect in [IN, OUT]\n",
        "        ])\n",
        "        caps.set_shade_in_3d(True)\n",
        "        return caps\n",
        "\n",
        "    def get_unwrapped_cylinder(self):\n",
        "        return UnwrappedCylinder(**self.sphere_config)\n",
        "\n",
        "    def get_xy_plane(self):\n",
        "        pass\n",
        "\n",
        "    def get_ghost_surface(self, surface):\n",
        "        result = surface.copy()\n",
        "        result.set_fill(BLUE_E, opacity=0.5)\n",
        "        result.set_stroke(WHITE, width=0.5, opacity=0.5)\n",
        "        return result\n",
        "\n",
        "    def project_point(self, point):\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        result = np.array(point)\n",
        "        result[:2] = normalize(result[:2]) * radius\n",
        "        return result\n",
        "\n",
        "    def project_mobject(self, mobject):\n",
        "        return mobject.apply_function(self.project_point)\n",
        "\n",
        "\n",
        "# Scenes for video\n",
        "\n",
        "class AskAboutShadowRelation(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"R_color\": YELLOW,\n",
        "        \"space_out_factor\": 1.15,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_surface_area()\n",
        "        self.show_four_circles()\n",
        "        self.ask_why()\n",
        "        self.show_all_pieces()\n",
        "\n",
        "    def show_surface_area(self):\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.set_fill(BLUE_E, opacity=0.5)\n",
        "        sphere.add_updater(\n",
        "            lambda s, dt: s.rotate(0.1 * dt, axis=OUT)\n",
        "        )\n",
        "        pieces = sphere.deepcopy()\n",
        "        pieces.space_out_submobjects(1.5)\n",
        "        pieces.shift(IN)\n",
        "        pieces.set_color(GREEN)\n",
        "\n",
        "        # radial_line = Line(ORIGIN, sphere.get_right())\n",
        "        # R_label = OldTex(\"R\")\n",
        "        # R_label.set_color(BLUE)\n",
        "        # R_label.rotate(90 * DEGREES, RIGHT)\n",
        "        # R_label.next_to(radial_line, OUT, SMALL_BUFF)\n",
        "\n",
        "        sa_equation = OldTex(\n",
        "            \"\\\\text{Surface area} = 4\\\\pi R^2\",\n",
        "            tex_to_color_map={\"R\": BLUE}\n",
        "        )\n",
        "        sa_equation.scale(1.5)\n",
        "        sa_equation.to_edge(UP)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "        self.add_fixed_in_frame_mobjects(sa_equation)\n",
        "        self.play(\n",
        "            Write(sphere, stroke_width=1),\n",
        "            FadeInFromDown(sa_equation),\n",
        "            # ShowCreation(radial_line),\n",
        "            # FadeIn(R_label, IN),\n",
        "        )\n",
        "        # self.play(\n",
        "        #     Transform(\n",
        "        #         sphere, pieces,\n",
        "        #         rate_func=there_and_back_with_pause,\n",
        "        #         run_time=2\n",
        "        #     )\n",
        "        # )\n",
        "        self.play(LaggedStartMap(\n",
        "            UpdateFromAlphaFunc, sphere,\n",
        "            lambda mob: (mob, lambda m, a: m.set_fill(\n",
        "                color=interpolate_color(BLUE_E, YELLOW, a),\n",
        "                opacity=interpolate(0.5, 1, a)\n",
        "            )),\n",
        "            rate_func=there_and_back,\n",
        "            lag_ratio=0.1,\n",
        "            run_time=4\n",
        "        ))\n",
        "        self.play(\n",
        "            sphere.scale, 0.75,\n",
        "            sphere.shift, 3 * LEFT,\n",
        "            sa_equation.shift, 3 * LEFT,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.sphere = sphere\n",
        "        self.sa_equation = sa_equation\n",
        "\n",
        "    def show_four_circles(self):\n",
        "        sphere = self.sphere\n",
        "        shadow = Circle(\n",
        "            radius=sphere.get_width() / 2,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "            fill_color=BLUE_E,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        radial_line = Line(\n",
        "            shadow.get_center(),\n",
        "            shadow.get_right(),\n",
        "            color=YELLOW\n",
        "        )\n",
        "        R_label = OldTex(\"R\").set_color(self.R_color)\n",
        "        R_label.scale(0.8)\n",
        "        R_label.next_to(radial_line, DOWN, SMALL_BUFF)\n",
        "        shadow.add(radial_line, R_label)\n",
        "        shadow.move_to(\n",
        "            self.camera.transform_points_pre_display(sphere, [sphere.get_center()])[0]\n",
        "        )\n",
        "\n",
        "        shadows = VGroup(*[shadow.copy() for x in range(4)])\n",
        "        shadows.arrange_in_grid(buff=MED_LARGE_BUFF)\n",
        "        shadows.to_edge(RIGHT)\n",
        "\n",
        "        area_label = OldTex(\n",
        "            \"\\\\pi R^2\",\n",
        "            tex_to_color_map={\"R\": self.R_color}\n",
        "        )\n",
        "        area_label.scale(1.2)\n",
        "        area_labels = VGroup(*[\n",
        "            area_label.copy().move_to(interpolate(\n",
        "                mob.get_center(), mob.get_top(), 0.5\n",
        "            ))\n",
        "            for mob in shadows\n",
        "        ])\n",
        "\n",
        "        # shadow.move_to(sphere)\n",
        "        self.add_fixed_in_frame_mobjects(shadow)\n",
        "        self.play(DrawBorderThenFill(shadow))\n",
        "        anims = []\n",
        "        for new_shadow in shadows:\n",
        "            old_shadow = shadow.copy()\n",
        "            self.add_fixed_in_frame_mobjects(old_shadow)\n",
        "            anims.append(Transform(\n",
        "                old_shadow, new_shadow, remover=True\n",
        "            ))\n",
        "        self.remove(shadow)\n",
        "        self.play(*anims)\n",
        "        self.add_fixed_in_frame_mobjects(shadows, area_labels)\n",
        "        self.play(LaggedStartMap(FadeInFromLarge, area_labels))\n",
        "        self.wait()\n",
        "\n",
        "        self.shadows = shadows\n",
        "        self.shadow_area_labels = area_labels\n",
        "\n",
        "    def ask_why(self):\n",
        "        pass\n",
        "\n",
        "    def show_all_pieces(self):\n",
        "        shadows = self.shadows\n",
        "        area_labels = self.shadow_area_labels\n",
        "        sphere = self.sphere\n",
        "\n",
        "        shadow_pieces_group = VGroup()\n",
        "        for shadow in shadows:\n",
        "            pieces = ParametricSurface(\n",
        "                func=lambda u, v: np.array([\n",
        "                    u * np.cos(TAU * v),\n",
        "                    u * np.sin(TAU * v),\n",
        "                    0,\n",
        "                ]),\n",
        "                resolution=(12, 24)\n",
        "            )\n",
        "            pieces.replace(shadow)\n",
        "            pieces.match_style(sphere)\n",
        "            shadow_pieces_group.add(pieces)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(shadow_pieces_group)\n",
        "        self.play(\n",
        "            FadeOut(shadows),\n",
        "            FadeOut(area_labels),\n",
        "            FadeIn(shadow_pieces_group)\n",
        "        )\n",
        "        self.show_area_pieces(sphere)\n",
        "        self.wait()\n",
        "        self.show_area_pieces(*shadow_pieces_group)\n",
        "        self.wait(2)\n",
        "        self.unshow_area_pieces(sphere, *shadow_pieces_group)\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_area_pieces(self, *mobjects):\n",
        "        for mob in mobjects:\n",
        "            mob.generate_target()\n",
        "            mob.target.space_out_submobjects(self.space_out_factor)\n",
        "        self.play(*map(MoveToTarget, mobjects))\n",
        "        self.play(*[\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, mob,\n",
        "                lambda m: (m.set_fill, YELLOW, 1),\n",
        "                rate_func=there_and_back,\n",
        "                lag_ratio=0.25,\n",
        "                run_time=1.5\n",
        "            )\n",
        "            for mob in mobjects\n",
        "        ])\n",
        "\n",
        "    def unshow_area_pieces(self, *mobjects):\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                mob.space_out_submobjects,\n",
        "                1.0 / self.space_out_factor\n",
        "            )\n",
        "            for mob in mobjects\n",
        "        ])\n",
        "\n",
        "\n",
        "class ButWhy(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"student_mode\": \"raise_right_hand\",\n",
        "        \"question\": \"But why?\",\n",
        "        \"teacher_mode\": \"guilty\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        for student in self.students:\n",
        "            student.change(\"pondering\", self.screen)\n",
        "        self.student_says(\n",
        "            \"But why?\",\n",
        "            index=2,\n",
        "            target_mode=self.student_mode,\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, self.teacher_mode, self.students[2]\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ButWhyHappy(ButWhy):\n",
        "    CONFIG = {\n",
        "        \"teacher_mode\": \"happy\"\n",
        "    }\n",
        "\n",
        "\n",
        "class ButWhySassy(ButWhy):\n",
        "    CONFIG = {\n",
        "        \"teacher_mode\": \"sassy\"\n",
        "    }\n",
        "\n",
        "\n",
        "class ButWhyHesitant(ButWhy):\n",
        "    CONFIG = {\n",
        "        \"teacher_mode\": \"hesitant\"\n",
        "    }\n",
        "\n",
        "\n",
        "class ButWhyAngry(ButWhy):\n",
        "    CONFIG = {\n",
        "        \"teacher_mode\": \"angry\"\n",
        "    }\n",
        "\n",
        "\n",
        "class TryFittingCirclesDirectly(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class PreviewTwoMethods(MovingCameraScene):\n",
        "    def construct(self):\n",
        "        thumbnails = Group(\n",
        "            ImageMobject(\"SphereSurfaceProof1\"),\n",
        "            ImageMobject(\"SphereSurfaceProof2\"),\n",
        "        )\n",
        "        for thumbnail in thumbnails:\n",
        "            thumbnail.set_width(FRAME_WIDTH / 2 - 1)\n",
        "            thumbnail.add_to_back(SurroundingRectangle(\n",
        "                thumbnail, buff=0,\n",
        "                stroke_color=WHITE,\n",
        "                stroke_width=5\n",
        "            ))\n",
        "        thumbnails.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        title = OldTexText(\"Two proofs\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.add(title)\n",
        "        for thumbnail in thumbnails:\n",
        "            self.play(FadeInFromDown(thumbnail))\n",
        "        self.wait()\n",
        "        for thumbnail in thumbnails:\n",
        "            frame.save_state()\n",
        "            self.play(\n",
        "                frame.replace, thumbnail,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(Restore(frame, run_time=2))\n",
        "\n",
        "\n",
        "class MapSphereOntoCylinder(SphereCylinderScene):\n",
        "    def construct(self):\n",
        "        sphere = self.get_sphere()\n",
        "        sphere_ghost = self.get_ghost_surface(sphere)\n",
        "        sphere_ghost.set_stroke(width=0)\n",
        "        axes = self.get_axes()\n",
        "        cylinder = self.get_cylinder()\n",
        "        cylinder.set_fill(opacity=0.75)\n",
        "        radius = cylinder.get_width() / 2\n",
        "\n",
        "        self.add(axes, sphere_ghost, sphere)\n",
        "        self.wait()\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            **self.default_angled_camera_position,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ReplacementTransform(sphere, cylinder),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Get rid of caps\n",
        "        caps = self.get_cylinder_caps()\n",
        "        caps[1].set_shade_in_3d(False)\n",
        "        label = OldTexText(\"Label\")\n",
        "        label.scale(1.5)\n",
        "        label.stretch(0.8, 0)\n",
        "        label.rotate(90 * DEGREES, RIGHT)\n",
        "        label.rotate(90 * DEGREES, OUT)\n",
        "        label.shift(np.log(radius + SMALL_BUFF) * RIGHT)\n",
        "        label.apply_complex_function(np.exp)\n",
        "        label.rotate(90 * DEGREES, IN, about_point=ORIGIN)\n",
        "        label.shift(OUT)\n",
        "        label.set_background_stroke(width=0)\n",
        "\n",
        "        self.play(FadeIn(caps))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            caps.space_out_submobjects, 2,\n",
        "            caps.fade, 1,\n",
        "            remover=True\n",
        "        )\n",
        "        self.play(Write(label))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(label))\n",
        "\n",
        "        # Unwrap\n",
        "        unwrapped_cylinder = self.get_unwrapped_cylinder()\n",
        "        unwrapped_cylinder.set_fill(opacity=0.75)\n",
        "        self.play(\n",
        "            ReplacementTransform(cylinder, unwrapped_cylinder),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            phi=90 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "\n",
        "        # Show dimensions\n",
        "        stroke_width = 5\n",
        "        top_line = Line(\n",
        "            PI * radius * LEFT + radius * OUT,\n",
        "            PI * radius * RIGHT + radius * OUT,\n",
        "            color=YELLOW,\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "        side_line = Line(\n",
        "            PI * radius * LEFT + radius * OUT,\n",
        "            PI * radius * LEFT + radius * IN,\n",
        "            color=RED,\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "        lines = VGroup(top_line, side_line)\n",
        "        lines.shift(radius * DOWN)\n",
        "        two_pi_R = OldTex(\"2\\\\pi R\")\n",
        "        two_R = OldTex(\"2R\")\n",
        "        texs = VGroup(two_pi_R, two_R)\n",
        "        for tex in texs:\n",
        "            tex.scale(1.5)\n",
        "            tex.rotate(90 * DEGREES, RIGHT)\n",
        "        two_pi_R.next_to(top_line, OUT)\n",
        "        two_R.next_to(side_line, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(top_line),\n",
        "            FadeIn(two_pi_R, IN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(side_line),\n",
        "            FadeIn(two_R, RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CircumferenceOfCylinder(SphereCylinderScene):\n",
        "    def construct(self):\n",
        "        sphere = self.get_sphere()\n",
        "        sphere_ghost = self.get_ghost_surface(sphere)\n",
        "        cylinder = self.get_cylinder()\n",
        "        cylinder_ghost = self.get_ghost_surface(cylinder)\n",
        "        cylinder_ghost.set_stroke(width=0)\n",
        "\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(YELLOW, 5)\n",
        "        circle.shift(radius * OUT)\n",
        "\n",
        "        height = Line(radius * IN, radius * OUT)\n",
        "        height.shift(radius * LEFT)\n",
        "        height.set_stroke(RED, 5)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-95 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(0.01)\n",
        "        self.add(sphere_ghost, cylinder_ghost)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(height))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class UnfoldCircles(Scene):\n",
        "    CONFIG = {\n",
        "        \"circle_style\": {\n",
        "            \"fill_color\": GREY_BROWN,\n",
        "            \"fill_opacity\": 0,\n",
        "            \"stroke_color\": GREY_BROWN,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"radius\": 1.0,\n",
        "        \"dr\": 0.01,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_rectangle_with_formula()\n",
        "        self.add_four_circles()\n",
        "\n",
        "    def show_rectangle_with_formula(self):\n",
        "        Tex.CONFIG[\"background_stroke_width\"] = 1\n",
        "        R = self.radius\n",
        "        rect = Rectangle(width=TAU * R, height=2 * R)\n",
        "        rect.set_fill(BLUE_E, 1)\n",
        "        rect.set_stroke(width=0)\n",
        "        p0, p1, p2 = [rect.get_corner(v) for v in (DL, UL, UR)]\n",
        "        h_line = Line(p0, p1)\n",
        "        h_line.set_stroke(RED, 3)\n",
        "        w_line = Line(p1, p2)\n",
        "        w_line.set_stroke(YELLOW, 3)\n",
        "        two_R = OldTex(\"2\", \"R\")\n",
        "        two_R.next_to(h_line, LEFT)\n",
        "        two_pi_R = OldTex(\"2\", \"\\\\pi\", \"R\")\n",
        "        two_pi_R.next_to(w_line, UP)\n",
        "\n",
        "        pre_area_label = OldTex(\n",
        "            \"2\\\\cdot\", \"2\", \"\\\\pi\", \"R\", \"\\\\cdot R\"\n",
        "        )\n",
        "        area_label = OldTex(\"4\", \"\\\\pi\", \"R^2\")\n",
        "        for label in [area_label, pre_area_label]:\n",
        "            label.next_to(rect.get_center(), UP, SMALL_BUFF)\n",
        "\n",
        "        self.rect_group = VGroup(\n",
        "            rect, h_line, w_line,\n",
        "            two_R, two_pi_R, area_label\n",
        "        )\n",
        "        self.area_label = area_label\n",
        "        self.rect = rect\n",
        "\n",
        "        self.add(rect, h_line, w_line, two_R, two_pi_R)\n",
        "        self.play(\n",
        "            TransformFromCopy(two_R[0], pre_area_label[0]),\n",
        "            TransformFromCopy(two_R[1], pre_area_label[-1]),\n",
        "            TransformFromCopy(two_pi_R, pre_area_label[1:-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_area_label[:2], area_label[:1]),\n",
        "            ReplacementTransform(pre_area_label[2], area_label[1]),\n",
        "            ReplacementTransform(pre_area_label[3:], area_label[2:]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.rect_group.to_corner, UL,\n",
        "            {\"buff\": MED_SMALL_BUFF}\n",
        "        )\n",
        "\n",
        "    def add_four_circles(self):\n",
        "        rect_group = self.rect_group\n",
        "        radius = self.radius\n",
        "\n",
        "        radii_lines = VGroup(*[\n",
        "            Line(radius * UP, ORIGIN).set_stroke(WHITE, 2)\n",
        "            for x in range(4)\n",
        "        ])\n",
        "        radii_lines.arrange_in_grid(buff=1.3)\n",
        "        radii_lines[2:].shift(RIGHT)\n",
        "        radii_lines.next_to(rect_group, DOWN, buff=1.3)\n",
        "        R_labels = VGroup(*[\n",
        "            OldTex(\"R\").next_to(line, LEFT, SMALL_BUFF)\n",
        "            for line in radii_lines\n",
        "        ])\n",
        "\n",
        "        unwrap_factor_tracker = ValueTracker(0)\n",
        "\n",
        "        def get_circle(line):\n",
        "            return always_redraw(\n",
        "                lambda: self.get_unwrapped_circle(\n",
        "                    radius=radius, dr=self.dr,\n",
        "                    unwrap_factor=unwrap_factor_tracker.get_value(),\n",
        "                    center=line.get_top()\n",
        "                )\n",
        "            )\n",
        "\n",
        "        circles = VGroup(*[get_circle(line) for line in radii_lines])\n",
        "        circle_copies = circles.copy()\n",
        "        for mob in circle_copies:\n",
        "            mob.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, circle_copies, lag_ratio=0.7),\n",
        "            LaggedStartMap(Write, R_labels),\n",
        "            LaggedStartMap(ShowCreation, radii_lines),\n",
        "        )\n",
        "        self.remove(circle_copies)\n",
        "        self.add(circles, radii_lines, R_labels)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            radii_lines[2:].shift, 2.9 * RIGHT,\n",
        "            R_labels[2:].shift, 2.9 * RIGHT,\n",
        "            VGroup(\n",
        "                radii_lines[:2], R_labels[:2]\n",
        "            ).to_edge, LEFT, {\"buff\": 1.0}\n",
        "        )\n",
        "        self.play(\n",
        "            unwrap_factor_tracker.set_value, 1,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move triangles\n",
        "        triangles = circles.copy()\n",
        "        for triangle in triangles:\n",
        "            triangle.clear_updaters()\n",
        "            border = Polygon(*[\n",
        "                triangle.get_corner(vect)\n",
        "                for vect in (DL, UL, DR)\n",
        "            ])\n",
        "            border.set_stroke(WHITE, 1)\n",
        "            triangle.add(border)\n",
        "            triangle.generate_target()\n",
        "        rect = self.rect\n",
        "        for i, triangle in enumerate(triangles):\n",
        "            if i % 2 == 1:\n",
        "                triangle.target.rotate(PI)\n",
        "            vect = UP if i < 2 else DOWN\n",
        "            triangle.target.move_to(rect, vect)\n",
        "\n",
        "        self.play(FadeIn(triangles))\n",
        "        self.add(triangles, triangles.copy(), self.area_label)\n",
        "        self.play(MoveToTarget(triangles[0]))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(MoveToTarget, triangles))\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_unwrapped_circle(self, radius, dr, unwrap_factor=0, center=ORIGIN):\n",
        "        radii = np.arange(0, radius + dr, dr)\n",
        "        rings = VGroup()\n",
        "        for r in radii:\n",
        "            r_factor = 1 + 3 * (r / radius)\n",
        "            alpha = unwrap_factor**r_factor\n",
        "            alpha = np.clip(alpha, 0, 0.9999)\n",
        "            angle = interpolate(TAU, 0, alpha)\n",
        "            length = TAU * r\n",
        "            arc_radius = length / angle\n",
        "            ring = Arc(\n",
        "                start_angle=-90 * DEGREES,\n",
        "                angle=angle,\n",
        "                radius=arc_radius,\n",
        "                **self.circle_style\n",
        "            )\n",
        "            ring.shift(center + (r - arc_radius) * DOWN)\n",
        "            # ring = AnnularSector(\n",
        "            #     inner_radius=r1,\n",
        "            #     outer_radius=r2,\n",
        "            #     angle=TAU,\n",
        "            #     start_angle=-TAU / 4,\n",
        "            #     **self.circle_style\n",
        "            # )\n",
        "            rings.add(ring)\n",
        "        return rings\n",
        "\n",
        "\n",
        "class ShowProjection(SphereCylinderScene):\n",
        "    CONFIG = {\n",
        "        # \"default_angled_camera_position\": {\n",
        "        #     \"theta\": -155 * DEGREES,\n",
        "        # }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_shapes()\n",
        "        self.show_many_tiny_rectangles()\n",
        "        self.project_all_rectangles()\n",
        "        self.focus_on_one()\n",
        "        self.label_sides()\n",
        "        self.show_length_scaled_up()\n",
        "        self.show_height_scaled_down()\n",
        "\n",
        "    def setup_shapes(self):\n",
        "        self.sphere = self.get_sphere()\n",
        "        self.cylinder = self.get_cylinder()\n",
        "        self.ghost_sphere = self.get_ghost_surface(self.sphere)\n",
        "        self.ghost_sphere.scale(0.99)\n",
        "        self.ghost_cylinder = self.get_ghost_surface(self.cylinder)\n",
        "        self.ghost_cylinder.set_stroke(width=0)\n",
        "\n",
        "        self.add(self.get_axes())\n",
        "        self.set_camera_to_default_position()\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "    def show_many_tiny_rectangles(self):\n",
        "        ghost_sphere = self.ghost_sphere\n",
        "        pieces = self.sphere.copy()\n",
        "        random.shuffle(pieces.submobjects)\n",
        "        for piece in pieces:\n",
        "            piece.save_state()\n",
        "        pieces.space_out_submobjects(2)\n",
        "        pieces.fade(1)\n",
        "\n",
        "        self.add(ghost_sphere)\n",
        "        self.play(LaggedStartMap(Restore, pieces))\n",
        "        self.wait()\n",
        "\n",
        "        self.pieces = pieces\n",
        "\n",
        "    def project_all_rectangles(self):\n",
        "        pieces = self.pieces\n",
        "        for piece in pieces:\n",
        "            piece.save_state()\n",
        "            piece.generate_target()\n",
        "            self.project_mobject(piece.target)\n",
        "            piece.target.set_fill(opacity=0.5)\n",
        "\n",
        "        example_group = self.get_example_group([1, -1, 2])\n",
        "        proj_lines = example_group[1]\n",
        "        self.example_group = example_group\n",
        "\n",
        "        self.play(*map(ShowCreation, proj_lines))\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, pieces),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def focus_on_one(self):\n",
        "        ghost_cylinder = self.ghost_cylinder\n",
        "        pieces = self.pieces\n",
        "\n",
        "        example_group = self.example_group\n",
        "        original_rect, rect_proj_lines, rect = example_group\n",
        "\n",
        "        equation = self.get_equation(rect)\n",
        "        lhs, equals, rhs = equation[:3]\n",
        "        lhs.save_state()\n",
        "        rhs.save_state()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ghost_cylinder),\n",
        "            FadeOut(pieces),\n",
        "            FadeIn(original_rect),\n",
        "        )\n",
        "        self.play(TransformFromCopy(original_rect, rect))\n",
        "        self.wait()\n",
        "        self.add_fixed_in_frame_mobjects(lhs, equals, rhs)\n",
        "        self.move_fixed_in_frame_mob_to_unfixed_mob(lhs, original_rect)\n",
        "        self.move_fixed_in_frame_mob_to_unfixed_mob(rhs, rect)\n",
        "        self.play(\n",
        "            Restore(lhs),\n",
        "            Restore(rhs),\n",
        "            FadeInFromDown(equals),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.equation = equation\n",
        "        self.example_group = example_group\n",
        "\n",
        "    def label_sides(self):\n",
        "        sphere = self.sphere\n",
        "        equation = self.equation\n",
        "        w_brace, h_brace = equation.braces\n",
        "        width_label, height_label = equation.labels\n",
        "\n",
        "        u_values, v_values = sphere.get_u_values_and_v_values()\n",
        "        radius = sphere.radius\n",
        "        lat_lines = VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t: radius * sphere.func(u, t),\n",
        "                t_min=sphere.v_min,\n",
        "                t_max=sphere.v_max,\n",
        "            )\n",
        "            for u in u_values\n",
        "        ])\n",
        "        lon_lines = VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t: radius * sphere.func(t, v),\n",
        "                t_min=sphere.u_min,\n",
        "                t_max=sphere.u_max,\n",
        "            )\n",
        "            for v in v_values\n",
        "        ])\n",
        "        for lines in lat_lines, lon_lines:\n",
        "            for line in lines:\n",
        "                line.add(DashedVMobject(line, spacing=-1))\n",
        "                line.set_points([])\n",
        "                line.set_stroke(width=2)\n",
        "            lines.set_shade_in_3d(True)\n",
        "        lat_lines.set_color(RED)\n",
        "        lon_lines.set_color(PINK)\n",
        "\n",
        "        self.play(\n",
        "            *map(ShowCreationThenDestruction, lat_lines),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add_fixed_in_frame_mobjects(w_brace, width_label)\n",
        "        self.play(\n",
        "            GrowFromCenter(w_brace),\n",
        "            Write(width_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *map(ShowCreationThenDestruction, lon_lines),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add_fixed_in_frame_mobjects(h_brace, height_label)\n",
        "        self.play(\n",
        "            GrowFromCenter(h_brace),\n",
        "            Write(height_label),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_length_scaled_up(self):\n",
        "        ghost_sphere = self.ghost_sphere\n",
        "        example_group = self.example_group\n",
        "        equation = self.equation\n",
        "        equation.save_state()\n",
        "        new_example_groups = [\n",
        "            self.get_example_group([1, -1, z])\n",
        "            for z in [6, 0.25]\n",
        "        ]\n",
        "        r1, lines, r2 = example_group\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            phi=65 * DEGREES,\n",
        "            theta=-80 * DEGREES,\n",
        "            added_anims=[\n",
        "                ghost_sphere.set_stroke, {\"opacity\": 0.1},\n",
        "                lines.set_stroke, {\"width\": 3},\n",
        "            ]\n",
        "        )\n",
        "        for eg in new_example_groups:\n",
        "            eg[1].set_stroke(width=3)\n",
        "        self.show_length_stretch_of_rect(example_group)\n",
        "        all_example_groups = [example_group, *new_example_groups]\n",
        "        for eg1, eg2 in zip(all_example_groups, all_example_groups[1:]):\n",
        "            if eg1 is new_example_groups[0]:\n",
        "                self.move_camera(\n",
        "                    phi=70 * DEGREES,\n",
        "                    theta=-110 * DEGREES\n",
        "                )\n",
        "            self.remove(eg1)\n",
        "            self.play(\n",
        "                ReplacementTransform(eg1.deepcopy(), eg2),\n",
        "                Transform(\n",
        "                    equation,\n",
        "                    self.get_equation(eg2[2])\n",
        "                )\n",
        "            )\n",
        "            if eg1 is example_group:\n",
        "                self.move_camera(\n",
        "                    phi=0,\n",
        "                    theta=-90 * DEGREES,\n",
        "                )\n",
        "            self.show_length_stretch_of_rect(eg2)\n",
        "        self.play(\n",
        "            ReplacementTransform(all_example_groups[-1], example_group),\n",
        "            Restore(equation)\n",
        "        )\n",
        "\n",
        "    def show_length_stretch_of_rect(self, example_group):\n",
        "        s_rect, proj_lines, c_rect = example_group\n",
        "        rects = VGroup(s_rect, c_rect)\n",
        "        line1, line2 = lines = VGroup(*[\n",
        "            Line(m.get_anchors()[1], m.get_anchors()[2])\n",
        "            for m in rects\n",
        "        ])\n",
        "        lines.set_stroke(YELLOW, 5)\n",
        "        lines.set_shade_in_3d(True)\n",
        "        proj_lines_to_fade = VGroup(\n",
        "            proj_lines[0],\n",
        "            proj_lines[3],\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(lines[0]),\n",
        "            FadeOut(rects),\n",
        "            FadeOut(proj_lines_to_fade)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            anims = []\n",
        "            if lines[1] in self.mobjects:\n",
        "                anims.append(FadeOut(lines[1]))\n",
        "            self.play(\n",
        "                TransformFromCopy(lines[0], lines[1]),\n",
        "                *anims\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeIn(rects),\n",
        "            FadeIn(proj_lines_to_fade),\n",
        "        )\n",
        "        self.remove(rects, proj_lines_to_fade)\n",
        "        self.add(example_group)\n",
        "\n",
        "    def show_height_scaled_down(self):\n",
        "        ghost_sphere = self.ghost_sphere\n",
        "        ghost_cylinder = self.ghost_cylinder\n",
        "        example_group = self.example_group\n",
        "        equation = self.equation\n",
        "        r1, lines, r2 = example_group\n",
        "        to_fade = VGroup(*[\n",
        "            mob\n",
        "            for mob in it.chain(ghost_sphere, ghost_cylinder)\n",
        "            if np.dot(mob.get_center(), [1, 1, 0]) < 0\n",
        "        ])\n",
        "        to_fade.save_state()\n",
        "\n",
        "        new_example_groups = [\n",
        "            self.get_example_group([1, -1, z])\n",
        "            for z in [6, 0.25]\n",
        "        ]\n",
        "        for eg in new_example_groups:\n",
        "            eg[::2].set_stroke(YELLOW, 2)\n",
        "            eg.set_stroke(width=1)\n",
        "        all_example_groups = VGroup(example_group, *new_example_groups)\n",
        "\n",
        "        self.play(\n",
        "            to_fade.shift, IN,\n",
        "            to_fade.fade, 1,\n",
        "            remover=True\n",
        "        )\n",
        "        self.move_camera(\n",
        "            phi=85 * DEGREES,\n",
        "            theta=-135 * DEGREES,\n",
        "            added_anims=[\n",
        "                lines.set_stroke, {\"width\": 1},\n",
        "                r1.set_stroke, YELLOW, 2, 1,\n",
        "                r2.set_stroke, YELLOW, 2, 1,\n",
        "            ]\n",
        "        )\n",
        "        self.show_shadow(example_group)\n",
        "        for eg1, eg2 in zip(all_example_groups, all_example_groups[1:]):\n",
        "            self.remove(*eg1.get_family())\n",
        "            self.play(\n",
        "                ReplacementTransform(eg1.deepcopy(), eg2),\n",
        "                Transform(\n",
        "                    equation,\n",
        "                    self.get_equation(eg2[2])\n",
        "                )\n",
        "            )\n",
        "            self.show_shadow(eg2)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-115 * DEGREES,\n",
        "            added_anims=[\n",
        "                ReplacementTransform(\n",
        "                    all_example_groups[-1],\n",
        "                    example_group,\n",
        "                ),\n",
        "                Restore(equation),\n",
        "            ]\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.play(Restore(to_fade))\n",
        "        self.wait(5)\n",
        "\n",
        "    def show_shadow(self, example_group):\n",
        "        s_rect, lines, c_rect = example_group\n",
        "        for x in range(3):\n",
        "            self.play(TransformFromCopy(s_rect, c_rect))\n",
        "\n",
        "    #\n",
        "    def get_projection_lines(self, piece):\n",
        "        result = VGroup()\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        for corner in piece.get_anchors()[:-1]:\n",
        "            start = np.array(corner)\n",
        "            end = np.array(corner)\n",
        "            start[:2] = np.zeros(2)\n",
        "            end[:2] = (radius + 0.03) * normalize(end[:2])\n",
        "            kwargs = {\n",
        "                \"color\": YELLOW,\n",
        "                \"stroke_width\": 0.5,\n",
        "            }\n",
        "            result.add(VGroup(*[\n",
        "                Line(p1, p2, **kwargs)\n",
        "                for p1, p2 in [(start, corner), (corner, end)]\n",
        "            ]))\n",
        "        result.set_shade_in_3d(True)\n",
        "        return result\n",
        "\n",
        "    def get_equation(self, rect):\n",
        "        length = get_norm(rect.get_anchors()[1] - rect.get_anchors()[0])\n",
        "        height = get_norm(rect.get_anchors()[2] - rect.get_anchors()[1])\n",
        "        lhs = Rectangle(width=length, height=height)\n",
        "        rhs = Rectangle(width=height, height=length)\n",
        "        eq_rects = VGroup(lhs, rhs)\n",
        "        eq_rects.set_stroke(width=0)\n",
        "        eq_rects.set_fill(YELLOW, 1)\n",
        "        eq_rects.scale(2)\n",
        "        equals = OldTex(\"=\")\n",
        "        equation = VGroup(lhs, equals, rhs)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_corner(UR)\n",
        "\n",
        "        brace = Brace(Line(ORIGIN, 0.5 * RIGHT), DOWN)\n",
        "        w_brace = brace.copy().match_width(lhs, stretch=True)\n",
        "        h_brace = brace.copy().rotate(-90 * DEGREES)\n",
        "        h_brace.match_height(lhs, stretch=True)\n",
        "        w_brace.next_to(lhs, DOWN, buff=SMALL_BUFF)\n",
        "        h_brace.next_to(lhs, LEFT, buff=SMALL_BUFF)\n",
        "        braces = VGroup(w_brace, h_brace)\n",
        "\n",
        "        width_label = OldTexText(\"Width\")\n",
        "        height_label = OldTexText(\"Height\")\n",
        "        labels = VGroup(width_label, height_label)\n",
        "        labels.scale(0.75)\n",
        "        width_label.next_to(w_brace, DOWN, SMALL_BUFF)\n",
        "        height_label.next_to(h_brace, LEFT, SMALL_BUFF)\n",
        "\n",
        "        equation.braces = braces\n",
        "        equation.labels = labels\n",
        "        equation.add(braces, labels)\n",
        "\n",
        "        return equation\n",
        "\n",
        "    def move_fixed_in_frame_mob_to_unfixed_mob(self, m1, m2):\n",
        "        phi = self.camera.phi_tracker.get_value()\n",
        "        theta = self.camera.theta_tracker.get_value()\n",
        "        target = m2.get_center()\n",
        "        target = rotate_vector(target, -theta - 90 * DEGREES, OUT)\n",
        "        target = rotate_vector(target, -phi, RIGHT)\n",
        "\n",
        "        m1.move_to(target)\n",
        "        m1.scale(0.1)\n",
        "        m1.shift(SMALL_BUFF * UR)\n",
        "        return m1\n",
        "\n",
        "    def get_example_group(self, vect):\n",
        "        pieces = self.pieces\n",
        "        rect = pieces[np.argmax([\n",
        "            np.dot(r.saved_state.get_center(), vect)\n",
        "            for r in pieces\n",
        "        ])].saved_state.copy()\n",
        "        rect_proj_lines = self.get_projection_lines(rect)\n",
        "        rect.set_fill(YELLOW, 1)\n",
        "        original_rect = rect.copy()\n",
        "        self.project_mobject(rect)\n",
        "        rect.shift(\n",
        "            0.001 * np.array([*rect.get_center()[:2], 0])\n",
        "        )\n",
        "        result = VGroup(original_rect, rect_proj_lines, rect)\n",
        "        result.set_shade_in_3d(True)\n",
        "        return result\n",
        "\n",
        "\n",
        "class SlantedShadowSquishing(ShowShadows):\n",
        "    CONFIG = {\n",
        "        \"num_reorientations\": 4,\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        ShowShadows.setup(self)\n",
        "        self.surface_area_label.fade(1)\n",
        "        self.shadow_area_label.fade(1)\n",
        "        self.shadow_area_decimal.fade(1)\n",
        "\n",
        "    def construct(self):\n",
        "        # Show creation\n",
        "        self.set_camera_orientation(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-150 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(0.01)\n",
        "        square = self.obj3d.deepcopy()\n",
        "        square.clear_updaters()\n",
        "        shadow = always_redraw(lambda: get_shadow(square))\n",
        "\n",
        "        # Reorient\n",
        "        self.add(square, shadow)\n",
        "        for n in range(self.num_reorientations):\n",
        "            angle = 40 * DEGREES\n",
        "            self.play(\n",
        "                Rotate(square, angle, axis=RIGHT),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "    def get_object(self):\n",
        "        square = Square()\n",
        "        square.set_shade_in_3d(True)\n",
        "        square.set_height(2)\n",
        "        square.set_stroke(WHITE, 0.5)\n",
        "        square.set_fill(BLUE_C, 1)\n",
        "        return square\n",
        "\n",
        "\n",
        "class JustifyLengthStretch(ShowProjection):\n",
        "    CONFIG = {\n",
        "        \"R_color\": RED,\n",
        "        \"d_color\": WHITE,\n",
        "        \"d_ambiguity_iterations\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_shapes()\n",
        "        self.add_ghosts()\n",
        "        self.add_example_group()\n",
        "        self.cut_cross_section()\n",
        "        self.label_R()\n",
        "        self.label_d()\n",
        "        self.show_similar_triangles()\n",
        "\n",
        "    def add_ghosts(self):\n",
        "        self.add(self.ghost_sphere, self.ghost_cylinder)\n",
        "\n",
        "    def add_example_group(self):\n",
        "        self.pieces = self.sphere\n",
        "        for piece in self.pieces:\n",
        "            piece.save_state()\n",
        "        self.example_group = self.get_example_group([1, 0.1, 1.5])\n",
        "        self.add(self.example_group)\n",
        "        self.set_camera_orientation(theta=-45 * DEGREES)\n",
        "\n",
        "    def cut_cross_section(self):\n",
        "        sphere = self.ghost_sphere\n",
        "        cylinder = self.ghost_cylinder\n",
        "        to_fade = VGroup(*[\n",
        "            mob\n",
        "            for mob in it.chain(sphere, cylinder)\n",
        "            if np.dot(mob.get_center(), DOWN) > 0\n",
        "        ])\n",
        "        self.lost_hemisphere = to_fade\n",
        "        to_fade.save_state()\n",
        "\n",
        "        circle = Circle(\n",
        "            stroke_width=2,\n",
        "            stroke_color=PINK,\n",
        "            radius=self.sphere.radius\n",
        "        )\n",
        "        circle.rotate(90 * DEGREES, RIGHT)\n",
        "        self.circle = circle\n",
        "\n",
        "        self.example_group.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                to_fade, -PI,\n",
        "                axis=OUT,\n",
        "                about_point=sphere.get_left(),\n",
        "                run_time=2\n",
        "            ),\n",
        "            VFadeOut(to_fade, run_time=2),\n",
        "            FadeIn(circle),\n",
        "        )\n",
        "        # self.move_camera(\n",
        "        #     phi=80 * DEGREES,\n",
        "        #     theta=-85 * DEGREES,\n",
        "        # )\n",
        "\n",
        "    def label_R(self):\n",
        "        circle = self.circle\n",
        "        R_line = Line(ORIGIN, circle.get_right())\n",
        "        R_line.set_color(self.R_color)\n",
        "        R_label = OldTex(\"R\")\n",
        "        R_label.next_to(R_line, IN)\n",
        "\n",
        "        self.add_fixed_orientation_mobjects(R_label)\n",
        "        self.play(\n",
        "            ShowCreation(R_line),\n",
        "            FadeIn(R_label, IN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.R_line = R_line\n",
        "        self.R_label = R_label\n",
        "\n",
        "    def label_d(self):\n",
        "        example_group = self.example_group\n",
        "        s_rect = example_group[0]\n",
        "        d_line = self.get_d_line(\n",
        "            s_rect.get_corner(IN + RIGHT + DOWN)\n",
        "        )\n",
        "        alt_d_line = self.get_d_line(\n",
        "            s_rect.get_corner(OUT + LEFT + DOWN)\n",
        "        )\n",
        "        d_label = OldTex(\"d\")\n",
        "        d_label.next_to(d_line, IN)\n",
        "\n",
        "        self.add_fixed_orientation_mobjects(d_label)\n",
        "        self.play(\n",
        "            ShowCreation(d_line),\n",
        "            FadeIn(d_label, IN),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(self.d_ambiguity_iterations):\n",
        "            to_fade_out = [d_line, alt_d_line][x % 2]\n",
        "            to_fade_in = [d_line, alt_d_line][(x + 1) % 2]\n",
        "            self.play(\n",
        "                FadeIn(to_fade_in),\n",
        "                FadeOut(to_fade_out),\n",
        "                d_label.next_to, to_fade_in, IN,\n",
        "            )\n",
        "\n",
        "        self.d_line = d_line\n",
        "        self.d_label = d_label\n",
        "\n",
        "    def show_similar_triangles(self):\n",
        "        d_line = self.d_line\n",
        "        d_label = self.d_label\n",
        "        R_line = self.R_line\n",
        "        R_label = self.R_label\n",
        "        example_group = self.example_group\n",
        "        s_rect, proj_lines, c_rect = example_group\n",
        "\n",
        "        p1 = s_rect.get_anchors()[1]\n",
        "        p2 = s_rect.get_anchors()[2]\n",
        "        p0 = np.array(p1)\n",
        "        p0[:2] = np.zeros(2)\n",
        "        triangle = Polygon(p0, p1, p2)\n",
        "        triangle.set_stroke(width=0)\n",
        "        triangle.set_fill(GREEN, opacity=1)\n",
        "        base = Line(p1, p2)\n",
        "        base.set_stroke(PINK, 3)\n",
        "\n",
        "        big_triangle = Polygon(\n",
        "            p0, self.project_point(p1), self.project_point(p2)\n",
        "        )\n",
        "        big_triangle.set_stroke(width=0)\n",
        "        big_triangle.set_fill(RED, opacity=1)\n",
        "\n",
        "        equation = VGroup(\n",
        "            triangle.copy().rotate(-3 * DEGREES),\n",
        "            OldTex(\"\\\\sim\"),\n",
        "            big_triangle.copy().rotate(-3 * DEGREES)\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.to_corner(UL)\n",
        "        eq_d = OldTex(\"d\").next_to(equation[0], DOWN, SMALL_BUFF)\n",
        "        eq_R = OldTex(\"R\").next_to(equation[2], DOWN, SMALL_BUFF)\n",
        "        VGroup(equation, eq_d, eq_R).rotate(20 * DEGREES, axis=RIGHT)\n",
        "\n",
        "        for mob in [triangle, big_triangle]:\n",
        "            mob.set_shade_in_3d(True)\n",
        "            mob.set_fill(opacity=0.8)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=40 * DEGREES,\n",
        "            theta=-85 * DEGREES,\n",
        "            added_anims=[\n",
        "                d_label.next_to, d_line, DOWN, SMALL_BUFF,\n",
        "                d_line.set_stroke, {\"width\": 1},\n",
        "                FadeOut(proj_lines[0]),\n",
        "                FadeOut(proj_lines[3]),\n",
        "                FadeOut(R_label)\n",
        "            ],\n",
        "            run_time=2,\n",
        "        )\n",
        "        point = VectorizedPoint(p0)\n",
        "        point.set_shade_in_3d(True)\n",
        "        self.play(\n",
        "            ReplacementTransform(point, triangle),\n",
        "            Animation(self.camera.phi_tracker)\n",
        "        )\n",
        "        self.add_fixed_in_frame_mobjects(equation, eq_d, eq_R)\n",
        "        self.play(\n",
        "            FadeIn(equation[0], 7 * RIGHT + 2.5 * DOWN),\n",
        "            FadeIn(equation[1:]),\n",
        "            FadeInFromDown(eq_d),\n",
        "            FadeInFromDown(eq_R),\n",
        "            Animation(self.camera.phi_tracker)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(2):\n",
        "            self.play(ShowCreationThenDestruction(base))\n",
        "        self.wait()\n",
        "        d_line_copy = d_line.copy().set_stroke(WHITE, 3)\n",
        "        self.play(ShowCreation(d_line_copy))\n",
        "        self.play(FadeOut(d_line_copy))\n",
        "        self.wait(2)\n",
        "        R_label.next_to(R_line, DOWN, SMALL_BUFF)\n",
        "        R_label.shift(0.25 * IN)\n",
        "        self.play(\n",
        "            ReplacementTransform(triangle, big_triangle),\n",
        "            FadeIn(R_label),\n",
        "            Animation(self.camera.phi_tracker)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-70 * DEGREES,\n",
        "            added_anims=[\n",
        "                big_triangle.set_fill, {\"opacity\": 0.25},\n",
        "                d_label.next_to, d_line, IN, {\"buff\": 0.3},\n",
        "            ]\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        lost_hemisphere = self.lost_hemisphere\n",
        "        lost_hemisphere.restore()\n",
        "        left_point = self.sphere.get_left()\n",
        "        lost_hemisphere.rotate(-PI, axis=OUT, about_point=left_point)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                lost_hemisphere, PI,\n",
        "                axis=OUT,\n",
        "                about_point=left_point,\n",
        "                run_time=2,\n",
        "            ),\n",
        "            VFadeIn(lost_hemisphere),\n",
        "            FadeOut(self.circle),\n",
        "            R_line.set_color, self.R_color,\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "    #\n",
        "    def get_d_line(self, sphere_point):\n",
        "        end = sphere_point\n",
        "        start = np.array(end)\n",
        "        start[:2] = np.zeros(2)\n",
        "\n",
        "        d_line = Line(start, end)\n",
        "        d_line.set_color(self.d_color)\n",
        "        return d_line\n",
        "\n",
        "\n",
        "class JustifyLengthStretchHigherRes(JustifyLengthStretch):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (2 * 24, 2 * 48)\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class JustifyLengthStretchHighestRes(JustifyLengthStretch):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (4 * 24, 4 * 48)\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class ProTipNameThings(Scene):\n",
        "    CONFIG = {\n",
        "        \"tip_descriptor\": \"(Deceptively simple) problem solving tip:\",\n",
        "        \"tip\": \"Start with names\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            self.tip_descriptor,\n",
        "            self.tip,\n",
        "        )\n",
        "        words[1].set_color(YELLOW)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(FadeIn(words[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(words[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WidthScaleLabel(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTex(\n",
        "            \"\\\\text{Width scale factor} =\",\n",
        "            \"\\\\frac{R}{d}\"\n",
        "        )\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HeightSquishLabel(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTex(\n",
        "            \"\\\\text{Height squish factor} =\",\n",
        "            \"\\\\frac{R}{d}\"\n",
        "        )\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TinierAndTinerRectangles(SphereCylinderScene):\n",
        "    CONFIG = {\n",
        "        \"n_iterations\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        spheres = [\n",
        "            self.get_sphere(\n",
        "                resolution=(12 * (2**n), 24 * (2**n)),\n",
        "                stroke_width=0,\n",
        "            )\n",
        "            for n in range(self.n_iterations)\n",
        "        ]\n",
        "\n",
        "        self.set_camera_to_default_position()\n",
        "        self.add(self.get_axes())\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.add(spheres[0])\n",
        "        for s1, s2 in zip(spheres, spheres[1:]):\n",
        "            self.wait()\n",
        "            random.shuffle(s2.submobjects)\n",
        "            for piece in s2:\n",
        "                piece.save_state()\n",
        "            s2.space_out_submobjects(1.2)\n",
        "            s2.fade(1)\n",
        "            for piece in s1:\n",
        "                piece.add(VectorizedPoint(piece.get_center() / 2))\n",
        "            self.play(\n",
        "                LaggedStartMap(Restore, s2)\n",
        "            )\n",
        "            self.remove(s1)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class LimitViewToCrossSection(JustifyLengthStretch):\n",
        "    CONFIG = {\n",
        "        \"d_ambiguity_iterations\": 0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_shapes()\n",
        "        self.add_ghosts()\n",
        "        self.add_example_group()\n",
        "        self.cut_cross_section()\n",
        "        self.label_R()\n",
        "        self.label_d()\n",
        "        self.move_camera(\n",
        "            phi=90 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.ghost_sphere),\n",
        "            FadeOut(self.ghost_cylinder),\n",
        "        )\n",
        "\n",
        "\n",
        "class JustifyHeightSquish(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        # As measured from previous scene\n",
        "        \"top_phi\": 0.5242654422649652,\n",
        "        \"low_phi\": 0.655081802831207,\n",
        "        \"radius\": 2,\n",
        "        \"R_color\": RED,\n",
        "        \"d_color\": WHITE,\n",
        "        \"little_triangle_color\": BLUE,\n",
        "        \"big_triangle_color\": GREY_BROWN,\n",
        "        \"alpha_color\": WHITE,\n",
        "        \"beta_color\": WHITE,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.recreate_cross_section()\n",
        "        self.show_little_triangle()\n",
        "        self.show_tangent_to_radius()\n",
        "        self.tweak_parameter()\n",
        "        self.label_angles()\n",
        "\n",
        "    def recreate_cross_section(self):\n",
        "        axes = Axes(\n",
        "            axis_config={\n",
        "                \"unit_size\": 2,\n",
        "            }\n",
        "        )\n",
        "        circle = Circle(\n",
        "            radius=self.radius,\n",
        "            stroke_color=PINK,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        R_line = self.get_R_line(90 * DEGREES)\n",
        "        R_line.set_color(self.R_color)\n",
        "        R_label = OldTex(\"R\")\n",
        "        R_label.next_to(R_line, DOWN, SMALL_BUFF)\n",
        "        d_lines = VGroup(*[\n",
        "            self.get_d_line(phi)\n",
        "            for phi in [self.low_phi, self.top_phi]\n",
        "        ])\n",
        "        d_line = d_lines[0]\n",
        "        d_line.set_color(self.d_color)\n",
        "        d_label = OldTex(\"d\")\n",
        "        d_label.next_to(d_line, DOWN, SMALL_BUFF)\n",
        "\n",
        "        proj_lines = VGroup(*[\n",
        "            self.get_R_line(phi)\n",
        "            for phi in [self.top_phi, self.low_phi]\n",
        "        ])\n",
        "        proj_lines.set_stroke(YELLOW, 1)\n",
        "\n",
        "        s_rect_line, c_rect_line = [\n",
        "            Line(\n",
        "                *[l.get_end() for l in lines],\n",
        "                stroke_color=YELLOW,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "            for lines in [d_lines, proj_lines]\n",
        "        ]\n",
        "\n",
        "        mobjects = [\n",
        "            axes, circle,\n",
        "            R_line, d_line,\n",
        "            R_label, d_label,\n",
        "            proj_lines,\n",
        "            s_rect_line, c_rect_line,\n",
        "        ]\n",
        "        self.add(*mobjects)\n",
        "        self.set_variables_as_attrs(*mobjects)\n",
        "\n",
        "    def show_little_triangle(self):\n",
        "        phi = self.low_phi\n",
        "        d_phi = abs(self.low_phi - self.top_phi)\n",
        "        tri_group = self.get_double_triangle_group(phi, d_phi)\n",
        "        lil_tri, big_tri = tri_group\n",
        "        frame = self.camera_frame\n",
        "        frame.save_state()\n",
        "        scale_factor = 0.1\n",
        "        sw_sf = 0.2  # stroke_width scale factor\n",
        "        d_sf = 0.3  # d_label scale factor\n",
        "\n",
        "        hyp = lil_tri.hyp\n",
        "        leg = lil_tri.leg2\n",
        "        leg.rotate(PI)\n",
        "        VGroup(hyp, leg).set_stroke(YELLOW, 1)\n",
        "        hyp_word = OldTexText(\"Rectangle height $\\\\rightarrow$\")\n",
        "        leg_word = OldTexText(\"$\\\\leftarrow$ Projection\")\n",
        "        words = VGroup(hyp_word, leg_word)\n",
        "        words.set_height(0.4 * lil_tri.get_height())\n",
        "        words.set_background_stroke(width=0)\n",
        "        hyp_word.next_to(hyp.get_center(), LEFT, buff=0.05)\n",
        "        leg_word.next_to(leg, RIGHT, buff=0.02)\n",
        "\n",
        "        stroke_width_changers = VGroup()\n",
        "        for mob in self.mobjects:\n",
        "            if mob in [self.d_label, frame]:\n",
        "                continue\n",
        "            mob.generate_target()\n",
        "            mob.save_state()\n",
        "            mob.target.set_stroke(\n",
        "                width=sw_sf * mob.get_stroke_width()\n",
        "            )\n",
        "            stroke_width_changers.add(mob)\n",
        "\n",
        "        self.play(\n",
        "            frame.scale, scale_factor,\n",
        "            frame.move_to, lil_tri,\n",
        "            self.d_label.scale, d_sf, {\"about_edge\": UP},\n",
        "            *map(MoveToTarget, stroke_width_changers)\n",
        "        )\n",
        "        self.play(DrawBorderThenFill(lil_tri, stroke_width=0.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(hyp),\n",
        "            LaggedStartMap(\n",
        "                DrawBorderThenFill, hyp_word,\n",
        "                stroke_width=0.5,\n",
        "                run_time=1,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(hyp, leg))\n",
        "        self.play(TransformFromCopy(\n",
        "            hyp_word, leg_word,\n",
        "            path_arc=-PI / 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.restore,\n",
        "            self.d_label.scale, 1 / d_sf, {\"about_edge\": UP},\n",
        "            *map(Restore, stroke_width_changers),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            hyp_word, leg_word, tri_group\n",
        "        )\n",
        "\n",
        "    def show_tangent_to_radius(self):\n",
        "        tri_group = self.tri_group\n",
        "        lil_tri, big_tri = tri_group\n",
        "        lil_hyp = lil_tri.hyp\n",
        "        phi = self.low_phi\n",
        "        circle_point = self.get_circle_point(phi)\n",
        "\n",
        "        tangent = lil_hyp.copy()\n",
        "        tangent.set_stroke(WHITE, 2)\n",
        "        tangent.scale(5 / tangent.get_length())\n",
        "        tangent.move_to(circle_point)\n",
        "\n",
        "        R_line = self.R_line\n",
        "        R_label = self.R_label\n",
        "        d_label = self.d_label\n",
        "        elbow = Elbow(angle=(-phi - PI / 2), width=0.15)\n",
        "        elbow.shift(circle_point)\n",
        "        elbow.set_stroke(WHITE, 1)\n",
        "        self.tangent_elbow = elbow\n",
        "\n",
        "        self.play(GrowFromPoint(tangent, circle_point))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                R_line, 90 * DEGREES - phi,\n",
        "                about_point=ORIGIN,\n",
        "            ),\n",
        "            R_label.next_to, 0.5 * circle_point, DR, {\"buff\": 0},\n",
        "            d_label.shift, SMALL_BUFF * UL,\n",
        "        )\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.wait()\n",
        "        self.add(big_tri, d_label, R_line, elbow)\n",
        "        d_label.set_background_stroke(width=0)\n",
        "        self.play(DrawBorderThenFill(big_tri))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(tangent, elbow)\n",
        "\n",
        "    def tweak_parameter(self):\n",
        "        tri_group = self.tri_group\n",
        "        lil_tri = tri_group[0]\n",
        "        d_label = self.d_label\n",
        "        d_line = self.d_line\n",
        "        R_label = self.R_label\n",
        "        R_line = self.R_line\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        to_fade = VGroup(\n",
        "            self.proj_lines,\n",
        "            self.s_rect_line, self.c_rect_line,\n",
        "            self.hyp_word, self.leg_word,\n",
        "            lil_tri.hyp, lil_tri.leg2,\n",
        "        )\n",
        "        rad_tangent = VGroup(\n",
        "            R_line,\n",
        "            self.tangent,\n",
        "            self.elbow,\n",
        "        )\n",
        "\n",
        "        phi_tracker = ValueTracker(self.low_phi)\n",
        "\n",
        "        self.play(\n",
        "            frame.scale, 0.6,\n",
        "            frame.shift, UR,\n",
        "            R_label.scale, 0.6, {\"about_edge\": UL},\n",
        "            d_label.scale, 0.6,\n",
        "            {\"about_point\": d_label.get_top() + SMALL_BUFF * DOWN},\n",
        "            *map(FadeOut, to_fade),\n",
        "        )\n",
        "\n",
        "        curr_phi = self.low_phi\n",
        "        d_phi = abs(self.top_phi - self.low_phi)\n",
        "        alt_phis = [\n",
        "            80 * DEGREES,\n",
        "            20 * DEGREES,\n",
        "            50 * DEGREES,\n",
        "            curr_phi\n",
        "        ]\n",
        "        for new_phi in alt_phis:\n",
        "            self.add(tri_group, d_label)\n",
        "            self.play(\n",
        "                phi_tracker.set_value, new_phi,\n",
        "                UpdateFromFunc(\n",
        "                    tri_group,\n",
        "                    lambda tg: tg.become(\n",
        "                        self.get_double_triangle_group(\n",
        "                            phi_tracker.get_value(),\n",
        "                            d_phi\n",
        "                        )\n",
        "                    )\n",
        "                ),\n",
        "                Rotate(\n",
        "                    rad_tangent,\n",
        "                    -(new_phi - curr_phi),\n",
        "                    about_point=ORIGIN,\n",
        "                ),\n",
        "                MaintainPositionRelativeTo(R_label, R_line),\n",
        "                UpdateFromFunc(\n",
        "                    d_line,\n",
        "                    lambda dl: dl.become(\n",
        "                        self.get_d_line(phi_tracker.get_value())\n",
        "                    ),\n",
        "                ),\n",
        "                MaintainPositionRelativeTo(d_label, d_line),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "            curr_phi = new_phi\n",
        "        for tri in tri_group:\n",
        "            self.play(Indicate(tri))\n",
        "        self.wait()\n",
        "        self.play(*map(FadeIn, to_fade))\n",
        "        self.remove(phi_tracker)\n",
        "\n",
        "    def label_angles(self):\n",
        "        # Getting pretty hacky here...\n",
        "        tri_group = self.tri_group\n",
        "        lil_tri, big_tri = tri_group\n",
        "        d_label = self.d_label\n",
        "        R_label = self.R_label\n",
        "        frame = self.camera_frame\n",
        "\n",
        "        alpha = self.low_phi\n",
        "        beta = 90 * DEGREES - alpha\n",
        "        circle_point = self.get_circle_point(alpha)\n",
        "        alpha_arc = Arc(\n",
        "            start_angle=90 * DEGREES,\n",
        "            angle=-alpha,\n",
        "            radius=0.2,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        beta_arc = Arc(\n",
        "            start_angle=PI,\n",
        "            angle=beta,\n",
        "            radius=0.2,\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        beta_arc.shift(circle_point)\n",
        "        alpha_label = OldTex(\"\\\\alpha\")\n",
        "        alpha_label.scale(0.5)\n",
        "        alpha_label.set_color(self.alpha_color)\n",
        "        alpha_label.next_to(alpha_arc, UP, buff=SMALL_BUFF)\n",
        "        alpha_label.shift(0.05 * DR)\n",
        "        beta_label = OldTex(\"\\\\beta\")\n",
        "        beta_label.scale(0.5)\n",
        "        beta_label.set_color(self.beta_color)\n",
        "        beta_label.next_to(beta_arc, LEFT, buff=SMALL_BUFF)\n",
        "        beta_label.shift(0.07 * DR)\n",
        "        VGroup(alpha_label, beta_label).set_background_stroke(width=0)\n",
        "\n",
        "        elbow = Elbow(width=0.15, angle=-90 * DEGREES)\n",
        "        elbow.shift(big_tri.get_corner(UL))\n",
        "        elbow.set_stroke(width=2)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"\\\\alpha\", \"+\", \"\\\\beta\", \"+\",\n",
        "            \"90^\\\\circ\", \"=\", \"180^\\\\circ\"\n",
        "        )\n",
        "        equation.scale(0.6)\n",
        "        equation.next_to(frame.get_corner(UR), DL)\n",
        "\n",
        "        movers = VGroup(\n",
        "            alpha_label.deepcopy(), beta_label.deepcopy(),\n",
        "            elbow.copy()\n",
        "        )\n",
        "        indices = [0, 2, 4]\n",
        "        for mover, index in zip(movers, indices):\n",
        "            mover.target = VGroup(equation[index])\n",
        "\n",
        "        # Show equation\n",
        "        self.play(\n",
        "            FadeOut(d_label),\n",
        "            FadeOut(R_label),\n",
        "            ShowCreation(alpha_arc),\n",
        "            ShowCreation(beta_arc),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(alpha_label, UP))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(beta_label, LEFT))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, movers),\n",
        "            LaggedStartMap(FadeInFromDown, equation[1:4:2])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(equation[-2:], LEFT))\n",
        "        self.remove(equation, movers)\n",
        "        self.add(equation)\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in\n",
        "        self.remove(self.tangent_elbow)\n",
        "        stroke_width_changers = VGroup(*[\n",
        "            mob for mob in self.mobjects\n",
        "            if mob not in [\n",
        "                beta_arc, beta_label, frame, equation,\n",
        "            ]\n",
        "        ])\n",
        "        for mob in stroke_width_changers:\n",
        "            mob.generate_target()\n",
        "            mob.save_state()\n",
        "            mob.target.set_stroke(\n",
        "                width=0.3 * mob.get_stroke_width()\n",
        "            )\n",
        "        equation.set_background_stroke(width=0)\n",
        "        scaled_arcs = VGroup(beta_arc, self.tangent_elbow)\n",
        "        beta_label.set_background_stroke(color=BLACK, width=0.3)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                VGroup(frame, equation).scale, 0.15,\n",
        "                {\"about_point\": circle_point + 0.1 * LEFT},\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                beta_label.scale, 0.3,\n",
        "                {\"about_point\": circle_point},\n",
        "            ),\n",
        "            scaled_arcs.set_stroke, {\"width\": 0.3},\n",
        "            scaled_arcs.scale, 0.3, {\"about_point\": circle_point},\n",
        "            *map(MoveToTarget, stroke_width_changers)\n",
        "        )\n",
        "\n",
        "        # Show small triangle angles\n",
        "        Tex.CONFIG[\"background_stroke_width\"] = 0\n",
        "        words = VGroup(self.hyp_word, self.leg_word)\n",
        "        alpha_arc1 = Arc(\n",
        "            start_angle=90 * DEGREES + beta,\n",
        "            angle=0.95 * alpha,\n",
        "            radius=0.3 * 0.2,\n",
        "            stroke_width=beta_arc.get_stroke_width(),\n",
        "        ).shift(circle_point)\n",
        "        alpha_arc2 = Arc(\n",
        "            start_angle=0,\n",
        "            angle=-0.95 * alpha,\n",
        "            radius=0.3 * 0.2,\n",
        "            stroke_width=beta_arc.get_stroke_width(),\n",
        "        ).shift(lil_tri.hyp.get_end())\n",
        "        beta_arc1 = Arc(\n",
        "            start_angle=90 * DEGREES,\n",
        "            angle=beta,\n",
        "            radius=0.3 * 0.2,\n",
        "            stroke_width=beta_arc.get_stroke_width(),\n",
        "        ).shift(circle_point)\n",
        "        deg90 = OldTex(\"90^\\\\circ\")\n",
        "        deg90.set_height(0.8 * beta_label.get_height())\n",
        "        deg90.next_to(self.tangent_elbow, DOWN, buff=0.025)\n",
        "        # deg90.set_background_stroke(width=0)\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.set_height(0.5 * beta_label.get_height())\n",
        "        q_mark.next_to(alpha_arc1, LEFT, buff=0.025)\n",
        "        q_mark.shift(0.01 * UP)\n",
        "        alpha_label1 = OldTex(\"\\\\alpha\")\n",
        "        alpha_label1.set_height(0.7 * q_mark.get_height())\n",
        "        alpha_label1.move_to(q_mark)\n",
        "\n",
        "        alpha_label2 = alpha_label1.copy()\n",
        "        alpha_label2.next_to(\n",
        "            alpha_arc2, RIGHT, buff=0.01\n",
        "        )\n",
        "        alpha_label2.set_background_stroke(color=BLACK, width=0.3)\n",
        "\n",
        "        beta_label1 = beta_label.copy()\n",
        "        beta_label1.scale(0.7)\n",
        "        beta_label1.set_background_stroke(color=BLACK, width=0.3)\n",
        "        beta_label1.next_to(\n",
        "            beta_arc1, UP, buff=0.01\n",
        "        )\n",
        "        beta_label1.shift(0.01 * LEFT)\n",
        "\n",
        "        self.play(FadeOut(words))\n",
        "        self.play(FadeIn(deg90, 0.1 * UP))\n",
        "        self.wait(0.25)\n",
        "        self.play(WiggleOutThenIn(beta_label))\n",
        "        self.wait(0.25)\n",
        "        self.play(\n",
        "            ShowCreation(alpha_arc1),\n",
        "            FadeIn(q_mark, 0.1 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowPassingFlash(\n",
        "            self.tangent.copy().scale(0.1).set_stroke(PINK, 0.5)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(q_mark, alpha_label1))\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            equation,\n",
        "            surrounding_rectangle_config={\n",
        "                \"buff\": 0.015,\n",
        "                \"stroke_width\": 0.5,\n",
        "            },\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(alpha_arc2),\n",
        "            FadeIn(alpha_label2),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(beta_arc1),\n",
        "            FadeIn(beta_label1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_double_triangle_group(self, phi, d_phi):\n",
        "        p0 = self.get_circle_point(phi)\n",
        "        p1 = self.get_circle_point(phi - d_phi)\n",
        "        p2 = np.array(p1)\n",
        "        p2[0] = p0[0]\n",
        "\n",
        "        little_triangle = Polygon(\n",
        "            p0, p1, p2,\n",
        "            stroke_width=0,\n",
        "            fill_color=self.little_triangle_color,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        big_triangle = Polygon(\n",
        "            p0, ORIGIN, p0 - p0[0] * RIGHT,\n",
        "            stroke_width=0,\n",
        "            fill_color=self.big_triangle_color,\n",
        "            fill_opacity=1\n",
        "        )\n",
        "        result = VGroup(little_triangle, big_triangle)\n",
        "        for tri in result:\n",
        "            p0, p1, p2 = tri.get_anchors()[:3]\n",
        "            tri.hyp = Line(p0, p1)\n",
        "            tri.leg1 = Line(p1, p2)\n",
        "            tri.leg2 = Line(p2, p0)\n",
        "            tri.side_lines = VGroup(\n",
        "                tri.hyp, tri.leg1, tri.leg2\n",
        "            )\n",
        "            tri.side_lines.set_stroke(WHITE, 1)\n",
        "        result.set_stroke(width=0)\n",
        "        return result\n",
        "\n",
        "    def get_R_line(self, phi):\n",
        "        y = self.radius * np.cos(phi)\n",
        "        x = self.radius\n",
        "        return Line(ORIGIN, x * RIGHT).shift(y * UP)\n",
        "\n",
        "    def get_d_line(self, phi):\n",
        "        end = self.get_circle_point(phi)\n",
        "        start = np.array(end)\n",
        "        start[0] = 0\n",
        "        return Line(start, end)\n",
        "\n",
        "    def get_circle_point(self, phi):\n",
        "        return rotate_vector(self.radius * UP, -phi)\n",
        "\n",
        "\n",
        "class ProTipTangentRadii(ProTipNameThings):\n",
        "    CONFIG = {\n",
        "        \"tip_descriptor\": \"Pro tip:\",\n",
        "        \"tip\": \"A circle's tangent is perpendicular to its radius\",\n",
        "    }\n",
        "\n",
        "\n",
        "class ProTipTweakParameters(ProTipNameThings):\n",
        "    CONFIG = {\n",
        "        \"tip_descriptor\": \"Pro tip:\",\n",
        "        \"tip\": \"Tweak parameters $\\\\rightarrow$ make\",\n",
        "    }\n",
        "\n",
        "\n",
        "class DrawSquareThenFade(Scene):\n",
        "    def construct(self):\n",
        "        square = Square(color=YELLOW, stroke_width=5)\n",
        "        self.play(ShowCreation(square))\n",
        "        self.play(FadeOut(square))\n",
        "\n",
        "\n",
        "class WhyAreWeDoingThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Hang on, what \\\\\\\\ are we doing?\",\n",
        "            index=2,\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "            target_mode=\"hesitant\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"maybe\", \"pondering\", \"hesitant\",\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.students[2]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.play_student_changes(*2 * [\"pondering\"])\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SameEffectAsRotating(Scene):\n",
        "    CONFIG = {\n",
        "        \"rectangle_config\": {\n",
        "            \"height\": 2,\n",
        "            \"width\": 1,\n",
        "            \"stroke_width\": 0,\n",
        "            \"fill_color\": YELLOW,\n",
        "            \"fill_opacity\": 1,\n",
        "            \"background_stroke_width\": 2,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "        },\n",
        "        \"x_stretch\": 2,\n",
        "        \"y_stretch\": 0.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        rect1 = Rectangle(**self.rectangle_config)\n",
        "        rect2 = rect1.copy()\n",
        "        rect2.stretch(self.x_stretch, 0)\n",
        "        rect2.stretch(self.y_stretch, 1)\n",
        "        rotated_rect1 = rect1.copy()\n",
        "        rotated_rect1.rotate(-90 * DEGREES)\n",
        "\n",
        "        arrow = Arrow(ORIGIN, RIGHT, buff=0, color=WHITE)\n",
        "        group = VGroup(rect1, arrow, rect2)\n",
        "        group.arrange(RIGHT)\n",
        "        group.center()\n",
        "        moving_rect = rect1.copy()\n",
        "\n",
        "        low_brace = always_redraw(\n",
        "            lambda: Brace(\n",
        "                moving_rect, DOWN, buff=SMALL_BUFF,\n",
        "                min_num_quads=2,\n",
        "            )\n",
        "        )\n",
        "        right_brace = always_redraw(\n",
        "            lambda: Brace(\n",
        "                moving_rect, RIGHT, buff=SMALL_BUFF,\n",
        "                min_num_quads=2,\n",
        "            )\n",
        "        )\n",
        "        times_R_over_d = OldTex(\"\\\\times \\\\frac{R}{d}\")\n",
        "        times_d_over_R = OldTex(\"\\\\times \\\\frac{d}{R}\")\n",
        "        times_R_over_d.add_updater(\n",
        "            lambda m: m.next_to(low_brace, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "        times_d_over_R.add_updater(\n",
        "            lambda m: m.next_to(right_brace, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.add(rect1, arrow)\n",
        "        self.play(moving_rect.move_to, rect2)\n",
        "        self.add(low_brace)\n",
        "        self.play(\n",
        "            moving_rect.match_width, rect2, {\"stretch\": True},\n",
        "            FadeIn(times_R_over_d),\n",
        "        )\n",
        "        self.add(right_brace)\n",
        "        self.play(\n",
        "            moving_rect.match_height, rect2, {\"stretch\": True},\n",
        "            FadeIn(times_d_over_R),\n",
        "        )\n",
        "        self.wait()\n",
        "        rotated_rect1.move_to(moving_rect)\n",
        "        self.play(TransformFromCopy(\n",
        "            rect1, rotated_rect1,\n",
        "            path_arc=-90 * DEGREES,\n",
        "            run_time=2\n",
        "        ))\n",
        "\n",
        "\n",
        "class NotSameEffectAsRotating(SameEffectAsRotating):\n",
        "    CONFIG = {\n",
        "        \"rectangle_config\": {\n",
        "            \"width\": 1.5,\n",
        "            \"height\": 1.5,\n",
        "        }\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowParameterization(Scene):\n",
        "    def construct(self):\n",
        "        u_color = PINK\n",
        "        v_color = GREEN\n",
        "        tex_kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"u\": u_color,\n",
        "                \"v\": v_color,\n",
        "            }\n",
        "        }\n",
        "        vector = Matrix(\n",
        "            [\n",
        "                [\"\\\\text{cos}(u)\\\\text{sin}(v)\"],\n",
        "                [\"\\\\text{sin}(u)\\\\text{sin}(v)\"],\n",
        "                [\"\\\\text{cos}(v)\"]\n",
        "            ],\n",
        "            element_to_mobject_config=tex_kwargs,\n",
        "            element_alignment_corner=DOWN,\n",
        "        )\n",
        "        vector.to_edge(UP)\n",
        "\n",
        "        ranges = VGroup(\n",
        "            OldTex(\"0 \\\\le u \\\\le 2\\\\pi\", **tex_kwargs),\n",
        "            OldTex(\"0 \\\\le v \\\\le \\\\pi\", **tex_kwargs),\n",
        "            OldTexText(\n",
        "                \"Sample $u$ and $v$ with \\\\\\\\ the same density\",\n",
        "                tex_to_color_map={\n",
        "                    \"$u$\": u_color,\n",
        "                    \"$v$\": v_color,\n",
        "                }\n",
        "            )\n",
        "        )\n",
        "        ranges.arrange(DOWN)\n",
        "        ranges.next_to(vector, DOWN)\n",
        "\n",
        "        self.add(vector)\n",
        "        self.add(ranges)\n",
        "\n",
        "\n",
        "class RdLabels(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height=1, width=0.5)\n",
        "        cR = OldTex(\"cR\")\n",
        "        cR.next_to(rect, LEFT, SMALL_BUFF)\n",
        "        cd = OldTex(\"cd\")\n",
        "        cd.next_to(rect, DOWN, SMALL_BUFF)\n",
        "\n",
        "        labels = VGroup(cd, cR)\n",
        "        for label in labels:\n",
        "            label[1].set_color(BLUE)\n",
        "            self.play(FadeInFromDown(label))\n",
        "\n",
        "\n",
        "class RotateAllPiecesWithExpansion(ShowProjection):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"radius\": 1.5,\n",
        "        },\n",
        "        \"with_expansion\": True\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_shapes()\n",
        "        self.rotate_all_pieces()\n",
        "\n",
        "    def rotate_all_pieces(self):\n",
        "        sphere = self.sphere\n",
        "        cylinder = self.cylinder\n",
        "        ghost_sphere = self.ghost_sphere\n",
        "        ghost_sphere.scale(0.99)\n",
        "\n",
        "        # Shuffle sphere and cylinder same way\n",
        "        random.seed(0)\n",
        "        random.shuffle(sphere.submobjects)\n",
        "        random.seed(0)\n",
        "        random.shuffle(cylinder.submobjects)\n",
        "\n",
        "        sphere_target = VGroup()\n",
        "        for piece in sphere:\n",
        "            p0, p1, p2, p3 = piece.get_anchors()[:4]\n",
        "            piece.set_points_as_corners([\n",
        "                p3, p0, p1, p2, p3\n",
        "            ])\n",
        "            piece.generate_target()\n",
        "            sphere_target.add(piece.target)\n",
        "            piece.target.move_to(\n",
        "                (1 + random.random()) * piece.get_center()\n",
        "            )\n",
        "\n",
        "        self.add(ghost_sphere, sphere)\n",
        "        self.wait()\n",
        "        if self.with_expansion:\n",
        "            self.play(LaggedStartMap(\n",
        "                MoveToTarget, sphere\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Rotate(piece, 90 * DEGREES, axis=piece.get_center())\n",
        "            for piece in sphere\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Transform(sphere, cylinder, run_time=2))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class RotateAllPiecesWithoutExpansion(RotateAllPiecesWithExpansion):\n",
        "    CONFIG = {\n",
        "        \"with_expansion\": False,\n",
        "    }\n",
        "\n",
        "\n",
        "class ThinkingCritically(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change, \"hesitant\", 2 * UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"sassy\")\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"angry\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class WriteNotEquals(Scene):\n",
        "    def construct(self):\n",
        "        symbol = OldTex(\"\\\\ne\")\n",
        "        symbol.scale(2)\n",
        "        symbol.set_background_stroke(width=0)\n",
        "        self.play(Write(symbol))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RectangulatedSphere(SphereCylinderScene):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (10, 20)\n",
        "        },\n",
        "        \"uniform_color\": False,\n",
        "        \"wait_time\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        sphere = self.get_sphere()\n",
        "        if self.uniform_color:\n",
        "            sphere.set_stroke(BLUE_E, width=0.5)\n",
        "            sphere.set_fill(BLUE_E)\n",
        "        self.set_camera_to_default_position()\n",
        "        self.begin_ambient_camera_rotation(0.05)\n",
        "        self.add(sphere)\n",
        "        self.wait(self.wait_time)\n",
        "\n",
        "\n",
        "class SmoothSphere(RectangulatedSphere):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (200, 400),\n",
        "        },\n",
        "        \"uniform_color\": True,\n",
        "        \"wait_time\": 0,\n",
        "    }\n",
        "\n",
        "\n",
        "class SequenceOfSpheres(SphereCylinderScene):\n",
        "    def construct(self):\n",
        "        n_shapes = 4\n",
        "        spheres, cylinders = groups = VGroup(*[\n",
        "            VGroup(*[\n",
        "                func(resolution=(n, 2 * n))\n",
        "                for k in range(1, n_shapes + 1)\n",
        "                for n in [3 * (2**k)]\n",
        "            ])\n",
        "            for func in [self.get_sphere, self.get_cylinder]\n",
        "        ])\n",
        "        groups.scale(0.5)\n",
        "        for group in groups:\n",
        "            for shape in group:\n",
        "                for piece in shape:\n",
        "                    piece.make_jagged()\n",
        "                shape.set_stroke(width=0)\n",
        "\n",
        "        for group in groups:\n",
        "            group.add(self.get_oriented_tex(\"?\").scale(2))\n",
        "            group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        groups.arrange(IN, buff=1.5)\n",
        "\n",
        "        all_equals = VGroup()\n",
        "        for sphere, cylinder in zip(spheres, cylinders):\n",
        "            equals = self.get_oriented_tex(\"=\")\n",
        "            equals.scale(1.5)\n",
        "            equals.rotate(90 * DEGREES, UP)\n",
        "            equals.move_to(interpolate(\n",
        "                sphere.get_nadir(), cylinder.get_zenith(), 0.5\n",
        "            ))\n",
        "            all_equals.add(equals)\n",
        "        all_equals.remove(all_equals[-1])\n",
        "\n",
        "        arrow_groups = VGroup()\n",
        "        for group in groups:\n",
        "            arrow_group = VGroup()\n",
        "            for m1, m2 in zip(group, group[1:]):\n",
        "                arrow = self.get_oriented_tex(\"\\\\rightarrow\")\n",
        "                arrow.move_to(interpolate(\n",
        "                    m1.get_right(), m2.get_left(), 0.5\n",
        "                ))\n",
        "                arrow_group.add(arrow)\n",
        "            arrow_groups.add(arrow_group)\n",
        "\n",
        "        q_marks = VGroup(*[\n",
        "            group[-1]\n",
        "            for group in groups\n",
        "        ])\n",
        "        final_arrows = VGroup(\n",
        "            arrow_groups[0][-1],\n",
        "            arrow_groups[1][-1],\n",
        "        )\n",
        "        for arrow in final_arrows:\n",
        "            dots = self.get_oriented_tex(\"\\\\dots\")\n",
        "            dots.next_to(arrow, RIGHT, SMALL_BUFF)\n",
        "            arrow.add(dots)\n",
        "        q_marks.shift(MED_LARGE_BUFF * RIGHT)\n",
        "        tilted_final_arrows = VGroup(\n",
        "            final_arrows[0].copy().rotate(\n",
        "                -45 * DEGREES, axis=DOWN\n",
        "            ).shift(0.75 * IN),\n",
        "            final_arrows[1].copy().rotate(\n",
        "                45 * DEGREES, axis=DOWN\n",
        "            ).shift(0.75 * OUT),\n",
        "        )\n",
        "        final_q_mark = q_marks[0].copy()\n",
        "        final_q_mark.move_to(q_marks)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "\n",
        "        for i in range(n_shapes):\n",
        "            anims = [\n",
        "                FadeIn(spheres[i], LEFT),\n",
        "                FadeIn(cylinders[i], LEFT),\n",
        "            ]\n",
        "            if i > 0:\n",
        "                anims += [\n",
        "                    Write(arrow_group[i - 1])\n",
        "                    for arrow_group in arrow_groups\n",
        "                ]\n",
        "            self.play(*anims, run_time=1)\n",
        "            self.play(GrowFromCenter(all_equals[i]))\n",
        "        self.play(\n",
        "            FadeIn(q_marks, LEFT),\n",
        "            Write(final_arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(final_arrows, tilted_final_arrows),\n",
        "            Transform(q_marks, VGroup(final_q_mark)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_oriented_tex(self, tex):\n",
        "        result = OldTex(tex)\n",
        "        result.rotate(90 * DEGREES, RIGHT)\n",
        "        return result\n",
        "\n",
        "\n",
        "class WhatIsSurfaceArea(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"change_power\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"What is surface area?\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.shift(0.035 * RIGHT)\n",
        "        self.add_fixed_in_frame_mobjects(title)\n",
        "\n",
        "        power_tracker = ValueTracker(1)\n",
        "        surface = always_redraw(\n",
        "            lambda: self.get_surface(\n",
        "                radius=3,\n",
        "                amplitude=1,\n",
        "                power=power_tracker.get_value()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        pieces = surface.copy()\n",
        "        pieces.clear_updaters()\n",
        "        random.shuffle(pieces.submobjects)\n",
        "\n",
        "        self.set_camera_to_default_position()\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        # self.add(self.get_axes())\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, pieces,\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.remove(pieces)\n",
        "        self.add(surface)\n",
        "        if self.change_power:\n",
        "            self.play(\n",
        "                power_tracker.set_value, 5,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.play(\n",
        "                power_tracker.set_value, 1,\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_surface(self, radius, amplitude, power):\n",
        "        def alt_pow(x, y):\n",
        "            return np.sign(x) * (np.abs(x) ** y)\n",
        "        return ParametricSurface(\n",
        "            lambda u, v: radius * np.array([\n",
        "                v * np.cos(TAU * u),\n",
        "                v * np.sin(TAU * u),\n",
        "                0,\n",
        "            ]) + amplitude * np.array([\n",
        "                0,\n",
        "                0,\n",
        "                (v**2) * alt_pow(np.sin(5 * TAU * u), power),\n",
        "            ]),\n",
        "            resolution=(100, 20),\n",
        "            v_min=0.01\n",
        "        )\n",
        "\n",
        "\n",
        "class AltWhatIsSurfaceArea(WhatIsSurfaceArea):\n",
        "    CONFIG = {\n",
        "        \"change_power\": False,\n",
        "    }\n",
        "\n",
        "    def get_surface(self, radius, amplitude, power):\n",
        "        return ParametricSurface(\n",
        "            lambda u, v: radius * (1 - 0.8 * (v**2) ** power) * np.array([\n",
        "                np.cos(TAU * u) * (1 + 0.5 * v * np.sin(5 * TAU * u)),\n",
        "                np.sin(TAU * u) * (1 + 0.5 * v * np.sin(5 * TAU * u)),\n",
        "                v,\n",
        "            ]),\n",
        "            v_min=-1,\n",
        "            v_max=1,\n",
        "            resolution=(100, 25),\n",
        "        )\n",
        "\n",
        "\n",
        "class EoCWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Essence of calculus\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RoleOfCalculus(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"light_source_start_point\": [-4, 5, 7],\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        calc = OldTex(\"\\\\int\", \"\\\\int\")\n",
        "        calc.space_out_submobjects(0.4)\n",
        "        calc.scale(2)\n",
        "        arrow = Vector(2 * RIGHT, color=WHITE)\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.rotate(70 * DEGREES, axis=LEFT)\n",
        "\n",
        "        group = VGroup(calc, arrow, sphere)\n",
        "        group.arrange(RIGHT)\n",
        "        group.shift(0.5 * RIGHT)\n",
        "        cross = Cross(group[:2], stroke_width=10)\n",
        "\n",
        "        # arrow2 = arrow.copy()\n",
        "\n",
        "        self.add(calc, arrow)\n",
        "        self.play(Write(sphere))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            sphere.next_to, ORIGIN, LEFT, 1.0,\n",
        "            arrow.move_to, ORIGIN, LEFT,\n",
        "            calc.next_to, ORIGIN, RIGHT, 2.25,\n",
        "            FadeOut(cross),\n",
        "            path_arc=PI,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UnwrappedCircleLogic(UnfoldCircles):\n",
        "    CONFIG = {\n",
        "        \"radius\": 1.25,\n",
        "        \"dr\": 0.01,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        radius = self.radius\n",
        "        dr = self.dr\n",
        "\n",
        "        Tex.CONFIG[\"background_stroke_width\"] = 2\n",
        "        unwrap_factor_tracker = ValueTracker(0)\n",
        "        center_tracker = VectorizedPoint()\n",
        "        highligt_prop_tracker = ValueTracker(0.5)\n",
        "\n",
        "        def get_highlight_prop():\n",
        "            return highligt_prop_tracker.get_value()\n",
        "\n",
        "        def get_r():\n",
        "            return radius * get_highlight_prop()\n",
        "\n",
        "        center_tracker.move_to(4.5 * LEFT)\n",
        "\n",
        "        def get_unwrapped_circle():\n",
        "            result = self.get_unwrapped_circle(\n",
        "                radius=radius, dr=dr,\n",
        "                unwrap_factor=unwrap_factor_tracker.get_value(),\n",
        "                center=center_tracker.get_center()\n",
        "            )\n",
        "            self.get_submob_from_prop(\n",
        "                result, get_highlight_prop()\n",
        "            ).set_stroke(YELLOW, 2)\n",
        "            return result\n",
        "\n",
        "        unwrapped_circle = always_redraw(get_unwrapped_circle)\n",
        "        circle = unwrapped_circle.copy()\n",
        "        circle.clear_updaters()\n",
        "        R_line = Line(circle.get_center(), circle.get_bottom())\n",
        "        R_line.set_stroke(WHITE, 2)\n",
        "        R_label = OldTex(\"R\")\n",
        "        R_label.next_to(R_line, LEFT)\n",
        "        circle_group = VGroup(circle, R_line, R_label)\n",
        "\n",
        "        tri_R_line = always_redraw(\n",
        "            lambda: Line(\n",
        "                ORIGIN, radius * DOWN\n",
        "            ).shift(center_tracker.get_center())\n",
        "        )\n",
        "\n",
        "        # Unwrap\n",
        "        self.play(FadeInFromDown(circle_group))\n",
        "        self.add(circle_group, unwrapped_circle, tri_R_line, R_label)\n",
        "        circle_group.set_stroke(opacity=0.5)\n",
        "        self.play(\n",
        "            unwrap_factor_tracker.set_value, 1,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            center_tracker.move_to,\n",
        "            circle.get_right() + (radius + MED_SMALL_BUFF) * RIGHT,\n",
        "            circle_group.set_stroke, {\"opacity\": 1},\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Change radius\n",
        "        r_line = always_redraw(\n",
        "            lambda: Line(\n",
        "                ORIGIN, get_r() * DOWN,\n",
        "                stroke_width=2,\n",
        "                stroke_color=WHITE,\n",
        "            ).shift(circle.get_center())\n",
        "        )\n",
        "        r_label = OldTex(\"r\")\n",
        "        r_label.add_updater(\n",
        "            lambda m: m.next_to(r_line, LEFT, SMALL_BUFF)\n",
        "        )\n",
        "        two_pi_r_label = OldTex(\"2\\\\pi r\")\n",
        "        two_pi_r_label.add_updater(\n",
        "            lambda m: m.next_to(\n",
        "                self.get_submob_from_prop(\n",
        "                    unwrapped_circle,\n",
        "                    get_highlight_prop(),\n",
        "                ), DOWN, SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "        circle.add_updater(\n",
        "            lambda m: m.match_style(unwrapped_circle)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(R_line, r_line),\n",
        "            ReplacementTransform(R_label, r_label),\n",
        "            FadeInFromDown(\n",
        "                two_pi_r_label.copy().clear_updaters(),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        self.add(two_pi_r_label)\n",
        "        for prop in [0.2, 0.8, 0.5]:\n",
        "            self.play(\n",
        "                highligt_prop_tracker.set_value, prop,\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        # Show line\n",
        "        line = Line(*[\n",
        "            unwrapped_circle.get_corner(vect)\n",
        "            for vect in (UL, DR)\n",
        "        ])\n",
        "        line.set_color(PINK)\n",
        "        line.set_fill(BLACK, 1)\n",
        "        line_word = OldTexText(\"Line\")\n",
        "        line_word.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "        line_word.rotate(line.get_angle(), about_point=ORIGIN)\n",
        "        line_word.shift(line.get_center())\n",
        "\n",
        "        curve = line.copy()\n",
        "        curve.get_points()[1] = unwrapped_circle.get_corner(DL)\n",
        "        not_line = OldTexText(\"Not line\")\n",
        "        not_line.rotate(line.get_angle() / 2)\n",
        "        not_line.move_to(line_word)\n",
        "        not_line.shift(0.3 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(line_word),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(highligt_prop_tracker.set_value, 1)\n",
        "        self.wait()\n",
        "\n",
        "        # Bend\n",
        "        line.save_state()\n",
        "        line_word.save_state()\n",
        "        self.play(\n",
        "            Transform(line, curve),\n",
        "            Transform(line_word, not_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(line),\n",
        "            Restore(line_word),\n",
        "            # FadeIn(two_pi_r_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_submob_from_prop(self, mob, prop):\n",
        "        n = len(mob.submobjects)\n",
        "        return mob[min(int(prop * n), n - 1)]\n",
        "\n",
        "\n",
        "class AskAboutDirectConnection(TeacherStudentsScene, SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"light_source_start_point\": [-4, 5, 7],\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        sphere = Sphere()\n",
        "        cylinder = Cylinder()\n",
        "        for mob in sphere, cylinder:\n",
        "            mob.rotate(70 * DEGREES, LEFT)\n",
        "        formula = OldTex(\"4\\\\pi R^2\")\n",
        "        formula.set_color(BLUE)\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(width=0)\n",
        "        circle.set_fill(GREY_BROWN, 1)\n",
        "        area_label = OldTex(\"\\\\pi R^2\", background_stroke_width=0)\n",
        "        area_label.scale(1.5)\n",
        "        circle.add(area_label)\n",
        "        group = VGroup(\n",
        "            sphere, cylinder, formula, circle\n",
        "        )\n",
        "        for mob in group:\n",
        "            mob.set_height(1.5)\n",
        "        formula.scale(0.5)\n",
        "        group.arrange(RIGHT, buff=1.5)\n",
        "        group.to_edge(UP, buff=2)\n",
        "        group[1:3].to_edge(UP)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for m1, m2 in zip(group, group[1:]):\n",
        "            arrow = Arrow(\n",
        "                m1.get_center(), m2.get_center(),\n",
        "                buff=1,\n",
        "                color=WHITE\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "        direct_arrow = Arrow(\n",
        "            sphere, circle, color=WHITE\n",
        "        )\n",
        "        q_marks = OldTex(*\"???\")\n",
        "        q_marks.space_out_submobjects(1.5)\n",
        "        q_marks.scale(1.5)\n",
        "        q_marks.next_to(direct_arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=group,\n",
        "            ),\n",
        "            LaggedStartMap(FadeInFromDown, group),\n",
        "            LaggedStartMap(GrowArrow, arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change, \"pondering\",\n",
        "            self.students[2].change, \"raise_right_hand\",\n",
        "            GrowArrow(direct_arrow),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, q_marks,\n",
        "                lambda m: (m, UP),\n",
        "                lag_ratio=0.8,\n",
        "                run_time=1.5,\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"sassy\", \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.look_at(group)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ExercisesGiveLearning(MovingCameraScene):\n",
        "    def construct(self):\n",
        "        bulb = Lightbulb()\n",
        "        arrow1 = Arrow(ORIGIN, RIGHT, buff=0)\n",
        "        lectures = OldTexText(\"Lectures\")\n",
        "        exercises = OldTexText(\"Exercises\")\n",
        "        frame = self.camera_frame\n",
        "        frame.scale(0.7)\n",
        "\n",
        "        bulb.next_to(arrow1, RIGHT)\n",
        "        for word in lectures, exercises:\n",
        "            word.next_to(arrow1, LEFT)\n",
        "\n",
        "        cross = Cross(lectures)\n",
        "\n",
        "        # Knock down lectures\n",
        "        self.add(lectures)\n",
        "        self.play(GrowArrow(arrow1))\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, bulb))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(\n",
        "            VGroup(lectures, cross).shift, DOWN,\n",
        "            FadeIn(exercises, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show self\n",
        "        arrow2 = arrow1.copy()\n",
        "        arrow2.next_to(lectures, LEFT)\n",
        "        logo = Logo()\n",
        "        logo.set_height(1)\n",
        "        logo.next_to(arrow2, LEFT)\n",
        "        pupil_copy = logo.pupil.copy()\n",
        "\n",
        "        self.add(logo, pupil_copy)\n",
        "        self.play(\n",
        "            frame.shift, 1.5 * LEFT,\n",
        "            Write(logo, run_time=1.5)\n",
        "        )\n",
        "        self.remove(pupil_copy)\n",
        "        self.play(\n",
        "            GrowArrow(arrow2),\n",
        "            FadeOut(cross)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(logo, arrow2).next_to,\n",
        "            exercises, LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NobodyLikesHomework(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_student_changes(\n",
        "            \"angry\", \"pleading\", \"angry\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play_all_student_changes(\n",
        "            \"tired\", look_at=8 * RIGHT + 4 * DOWN,\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ChallengeMode(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Challenge mode: Predict the proof\")\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SecondProof(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (30, 30),\n",
        "        },\n",
        "        \"n_random_subsets\": 12,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_shapes()\n",
        "        self.divide_into_rings()\n",
        "        self.show_shadows()\n",
        "        self.correspond_to_every_other_ring()\n",
        "        self.cut_cross_section()\n",
        "        self.show_theta()\n",
        "        self.enumerate_rings()\n",
        "        self.ask_about_ring_circumference()\n",
        "        self.ask_about_shadow_area()\n",
        "        self.ask_about_2_to_1_correspondance()\n",
        "        self.show_all_shadow_rings()\n",
        "        self.ask_about_global_correspondance()\n",
        "\n",
        "    def setup_shapes(self):\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.set_stroke(WHITE, width=0.25)\n",
        "        self.add(sphere)\n",
        "        self.sphere = sphere\n",
        "\n",
        "        u_values, v_values = sphere.get_u_values_and_v_values()\n",
        "        rings = VGroup(*[VGroup() for u in u_values])\n",
        "        for piece in sphere:\n",
        "            rings[piece.u_index].add(piece.copy())\n",
        "        self.set_ring_colors(rings)\n",
        "        self.rings = rings\n",
        "\n",
        "        self.axes = self.get_axes()\n",
        "        self.add(self.axes)\n",
        "\n",
        "        self.set_camera_to_default_position()\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "    def divide_into_rings(self):\n",
        "        rings = self.rings\n",
        "\n",
        "        self.play(FadeIn(rings), FadeOut(self.sphere))\n",
        "        self.play(\n",
        "            rings.space_out_submobjects, 1.5,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        rings.save_state()\n",
        "\n",
        "    def show_shadows(self):\n",
        "        rings = self.rings\n",
        "        north_rings = rings[:len(rings) // 2]\n",
        "        ghost_rings = rings.copy()\n",
        "        ghost_rings.set_fill(opacity=0.0)\n",
        "        ghost_rings.set_stroke(WHITE, width=0.5, opacity=0.2)\n",
        "\n",
        "        north_rings.submobjects.reverse()\n",
        "        shadows = self.get_shadow(north_rings)\n",
        "        for piece in shadows.family_members_with_points():\n",
        "            piece.set_stroke(\n",
        "                piece.get_fill_color(),\n",
        "                width=0.5,\n",
        "            )\n",
        "        for shadow in shadows:\n",
        "            shadow.save_state()\n",
        "        shadows.become(north_rings)\n",
        "\n",
        "        self.add(ghost_rings)\n",
        "        self.play(FadeOut(rings), Animation(shadows))\n",
        "        self.play(LaggedStartMap(Restore, shadows))\n",
        "        self.wait()\n",
        "        self.move_camera(phi=40 * DEGREES)\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show circle\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        radial_line = Line(ORIGIN, radius * RIGHT)\n",
        "        radial_line.set_stroke(RED)\n",
        "        R_label = OldTex(\"R\")\n",
        "        R_label.set_background_stroke(width=1)\n",
        "        R_label.next_to(radial_line, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(R_label),\n",
        "            ShowCreation(radial_line)\n",
        "        )\n",
        "        self.play(Rotating(\n",
        "            radial_line, angle=TAU,\n",
        "            about_point=ORIGIN,\n",
        "            rate_func=smooth,\n",
        "            run_time=3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            shadows, ghost_rings,\n",
        "            radial_line, R_label\n",
        "        )\n",
        "\n",
        "    def correspond_to_every_other_ring(self):\n",
        "        rings = self.rings\n",
        "        shadows = self.shadows\n",
        "        shadows.submobjects.reverse()\n",
        "\n",
        "        rings.restore()\n",
        "        self.set_ring_colors(rings)\n",
        "        every_other_ring = rings[1::2]\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-135 * DEGREES,\n",
        "            added_anims=[\n",
        "                FadeOut(self.R_label),\n",
        "                FadeOut(self.radial_line),\n",
        "            ],\n",
        "            run_time=2,\n",
        "        )\n",
        "        shadows_copy = shadows.copy()\n",
        "        shadows.fade(1)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                shadows_copy, every_other_ring\n",
        "            ),\n",
        "            FadeOut(self.ghost_rings),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.every_other_ring = every_other_ring\n",
        "\n",
        "    def cut_cross_section(self):\n",
        "        shadows = self.shadows\n",
        "        every_other_ring = self.every_other_ring\n",
        "        rings = self.rings\n",
        "\n",
        "        back_half = self.get_hemisphere(rings, UP)\n",
        "        front_half = self.get_hemisphere(rings, DOWN)\n",
        "        front_half_ghost = front_half.copy()\n",
        "        front_half_ghost.set_fill(opacity=0.2)\n",
        "        front_half_ghost.set_stroke(opacity=0)\n",
        "\n",
        "        # shaded_back_half = back_half.copy()\n",
        "        # for piece in shaded_back_half.family_members_with_points():\n",
        "        #     piece.set_points(piece.get_points()[::-1])\n",
        "        # shaded_back_half.scale(0.999)\n",
        "        # shaded_back_half.set_fill(opacity=0.5)\n",
        "\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(PINK, 2)\n",
        "        circle.rotate(90 * DEGREES, RIGHT)\n",
        "\n",
        "        every_other_ring_copy = every_other_ring.copy()\n",
        "        self.add(every_other_ring_copy)\n",
        "        self.remove(every_other_ring)\n",
        "        rings.set_fill(opacity=0.8)\n",
        "        rings.set_stroke(opacity=0.6)\n",
        "        self.play(\n",
        "            FadeIn(back_half),\n",
        "            FadeIn(front_half_ghost),\n",
        "            FadeIn(circle),\n",
        "            FadeOut(shadows),\n",
        "            FadeOut(every_other_ring_copy),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            back_half, front_half,\n",
        "            front_half_ghost,\n",
        "            slice_circle=circle\n",
        "        )\n",
        "\n",
        "    def show_theta(self):\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        get_theta = theta_tracker.get_value\n",
        "        theta_group = always_redraw(\n",
        "            lambda: self.get_theta_group(get_theta())\n",
        "        )\n",
        "        theta_mob_opacity_tracker = ValueTracker(0)\n",
        "        get_theta_mob_opacity = theta_mob_opacity_tracker.get_value\n",
        "        theta_mob = theta_group[-1]\n",
        "        theta_mob.add_updater(\n",
        "            lambda m: m.set_fill(opacity=get_theta_mob_opacity())\n",
        "        )\n",
        "        theta_mob.add_updater(\n",
        "            lambda m: m.set_background_stroke(\n",
        "                width=get_theta_mob_opacity()\n",
        "            )\n",
        "        )\n",
        "\n",
        "        lit_ring = always_redraw(\n",
        "            lambda: self.get_ring_from_theta(\n",
        "                self.rings, get_theta()\n",
        "            ).copy().set_color(YELLOW)\n",
        "        )\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(theta=-60 * DEGREES)\n",
        "\n",
        "        self.add(theta_group, lit_ring)\n",
        "        n_rings = len(self.rings) - 1\n",
        "        lit_ring_index = int((30 / 180) * n_rings)\n",
        "        angle = PI * lit_ring_index / n_rings\n",
        "        for alpha in [angle, 0, PI, angle]:\n",
        "            self.play(\n",
        "                theta_tracker.set_value, alpha,\n",
        "                theta_mob_opacity_tracker.set_value, 1,\n",
        "                Animation(self.camera.phi_tracker),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Label d-theta\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        d_theta = PI / len(self.rings)\n",
        "        alt_theta = get_theta() + d_theta\n",
        "        alt_theta_group = self.get_theta_group(alt_theta)\n",
        "        alt_R_line = alt_theta_group[1]\n",
        "        # d_theta_arc = Arc(\n",
        "        #     start_angle=get_theta(),\n",
        "        #     angle=d_theta,\n",
        "        #     radius=theta_group[0].radius,\n",
        "        #     stroke_color=PINK,\n",
        "        #     stroke_width=3,\n",
        "        # )\n",
        "        # d_theta_arc.rotate(90 * DEGREES, axis=RIGHT, about_point=ORIGIN)\n",
        "        brace = Brace(Line(ORIGIN, radius * d_theta * RIGHT), UP)\n",
        "        brace.rotate(90 * DEGREES, RIGHT)\n",
        "        brace.next_to(self.sphere, OUT, buff=0)\n",
        "        brace.add_to_back(brace.copy().set_stroke(BLACK, 3))\n",
        "        brace.rotate(\n",
        "            get_theta() + d_theta / 2,\n",
        "            axis=UP,\n",
        "            about_point=ORIGIN,\n",
        "        )\n",
        "        brace_label = OldTex(\"R\\\\,d\\\\theta\")\n",
        "        brace_label.rotate(90 * DEGREES, RIGHT)\n",
        "        brace_label.next_to(brace, OUT + RIGHT, buff=0)\n",
        "        radial_line = self.radial_line\n",
        "        R_label = self.R_label\n",
        "        R_label.rotate(90 * DEGREES, RIGHT)\n",
        "        R_label.next_to(radial_line, IN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(theta_group[1], alt_R_line),\n",
        "            GrowFromCenter(brace),\n",
        "            Animation(self.camera.phi_tracker),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_camera(\n",
        "            phi=90 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(brace_label, IN),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            FadeIn(R_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-70 * DEGREES,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            theta_tracker, lit_ring, theta_group,\n",
        "            brace, brace_label, d_theta,\n",
        "            alt_R_line, theta_mob_opacity_tracker,\n",
        "        )\n",
        "\n",
        "    def enumerate_rings(self):\n",
        "        pass  # Skip, for now...\n",
        "\n",
        "    def ask_about_ring_circumference(self):\n",
        "        theta = self.theta_tracker.get_value()\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        circle = Circle(\n",
        "            radius=radius * np.sin(theta)\n",
        "        )\n",
        "        circle.shift(radius * np.cos(theta) * OUT)\n",
        "        circle.set_stroke(Color(\"red\"), 5)\n",
        "\n",
        "        to_fade = VGroup(\n",
        "            self.R_label, self.radial_line,\n",
        "            self.brace, self.brace_label\n",
        "        )\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=0 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "            added_anims=[FadeOut(to_fade)]\n",
        "        )\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-70 * DEGREES,\n",
        "            added_anims=[\n",
        "                FadeIn(to_fade),\n",
        "                FadeOut(circle),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_shadow_area(self):\n",
        "        lit_ring = self.lit_ring\n",
        "        lit_ring_copy = lit_ring.copy()\n",
        "        lit_ring_copy.clear_updaters()\n",
        "\n",
        "        all_shadows = self.shadows\n",
        "        all_shadows.set_fill(BLUE_E, 0.5)\n",
        "        for piece in all_shadows.family_members_with_points():\n",
        "            piece.set_stroke(width=0)\n",
        "\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        shadow = self.get_shadow(lit_ring)\n",
        "        theta = self.theta_tracker.get_value()\n",
        "        d_theta = self.d_theta\n",
        "\n",
        "        def get_dashed_line(angle):\n",
        "            p0 = np.cos(angle) * OUT + np.sin(angle) * RIGHT\n",
        "            p0 *= radius\n",
        "            p1 = np.array([*p0[:2], 0])\n",
        "            result = DashedLine(p0, p1)\n",
        "            result.set_stroke(WHITE, 1)\n",
        "            result.add_to_back(\n",
        "                result.copy().set_stroke(BLACK, 2)\n",
        "            )\n",
        "            result.set_shade_in_3d(True)\n",
        "            return result\n",
        "\n",
        "        dashed_lines = VGroup(*[\n",
        "            get_dashed_line(t)\n",
        "            for t in [theta, theta + d_theta]\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(lit_ring_copy, shadow),\n",
        "            FadeOut(self.R_label),\n",
        "            FadeOut(self.radial_line),\n",
        "            Animation(self.camera.phi_tracker),\n",
        "            *map(ShowCreation, dashed_lines),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            dashed_lines,\n",
        "            lit_shadow=shadow,\n",
        "        )\n",
        "\n",
        "    def ask_about_2_to_1_correspondance(self):\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        get_theta = theta_tracker.get_value\n",
        "        new_lit_ring = always_redraw(\n",
        "            lambda: self.get_ring_from_theta(\n",
        "                self.rings, get_theta()\n",
        "            ).copy().set_color(PINK)\n",
        "        )\n",
        "\n",
        "        self.add(new_lit_ring)\n",
        "        for angle in [PI, 0, PI]:\n",
        "            self.play(\n",
        "                theta_tracker.set_value, angle,\n",
        "                Animation(self.camera.phi_tracker),\n",
        "                run_time=3\n",
        "            )\n",
        "        self.remove(new_lit_ring)\n",
        "        self.remove(theta_tracker)\n",
        "\n",
        "    def show_all_shadow_rings(self):\n",
        "        lit_ring_copy = self.lit_ring.copy()\n",
        "        lit_ring_copy.clear_updaters()\n",
        "        self.remove(self.lit_ring)\n",
        "        theta_group_copy = self.theta_group.copy()\n",
        "        theta_group_copy.clear_updaters()\n",
        "        self.remove(self.theta_group, *self.theta_group)\n",
        "        to_fade = VGroup(\n",
        "            theta_group_copy, self.alt_R_line,\n",
        "            self.brace, self.brace_label,\n",
        "            lit_ring_copy, self.lit_shadow,\n",
        "            self.slice_circle,\n",
        "            self.dashed_lines,\n",
        "        )\n",
        "\n",
        "        R_label = self.R_label\n",
        "        radial_line = self.radial_line\n",
        "        R_label.rotate(\n",
        "            -90 * DEGREES,\n",
        "            axis=RIGHT, about_point=radial_line.get_center()\n",
        "        )\n",
        "        shadows = self.shadows\n",
        "        self.set_ring_colors(shadows, [GREY_BROWN, GREY_D])\n",
        "        for submob in shadows:\n",
        "            submob.save_state()\n",
        "        shadows.become(self.rings.saved_state[:len(shadows)])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            LaggedStartMap(FadeIn, shadows),\n",
        "            self.theta_mob_opacity_tracker.set_value, 0,\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, shadows),\n",
        "            ApplyMethod(\n",
        "                self.camera.phi_tracker.set_value, 60 * DEGREES,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                self.camera.theta_tracker.set_value, -130 * DEGREES,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(radial_line),\n",
        "            FadeIn(R_label),\n",
        "            Animation(self.camera.phi_tracker),\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.wait()\n",
        "\n",
        "        rings = self.rings\n",
        "        rings_copy = rings.saved_state.copy()\n",
        "        self.set_ring_colors(rings_copy)\n",
        "        self.play(\n",
        "            FadeOut(R_label),\n",
        "            FadeOut(radial_line),\n",
        "            FadeIn(rings_copy)\n",
        "        )\n",
        "        self.remove(rings_copy)\n",
        "        rings.become(rings_copy)\n",
        "        self.add(rings)\n",
        "\n",
        "    def ask_about_global_correspondance(self):\n",
        "        rings = self.rings\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(rings[::2])\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "    #\n",
        "    def set_ring_colors(self, rings, colors=[BLUE_E, BLUE_D]):\n",
        "        for i, ring in enumerate(rings):\n",
        "            color = colors[i % len(colors)]\n",
        "            ring.set_fill(color, opacity=1)\n",
        "            ring.set_stroke(color, width=0.5, opacity=1)\n",
        "            for piece in ring:\n",
        "                piece.insert_n_curves(4)\n",
        "                piece.on_sphere = True\n",
        "                piece.set_points([\n",
        "                    *piece.get_points()[3:-1],\n",
        "                    *piece.get_points()[:3],\n",
        "                    piece.get_points()[3]\n",
        "                ])\n",
        "        return rings\n",
        "\n",
        "    def get_shadow(self, mobject):\n",
        "        result = mobject.copy()\n",
        "        result.apply_function(\n",
        "            lambda p: np.array([*p[:2], 0])\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def get_hemisphere(self, group, vect):\n",
        "        if len(group.submobjects) == 0:\n",
        "            if np.dot(group.get_center(), vect) > 0:\n",
        "                return group\n",
        "            else:\n",
        "                return VMobject()\n",
        "        else:\n",
        "            return VGroup(*[\n",
        "                self.get_hemisphere(submob, vect)\n",
        "                for submob in group\n",
        "            ])\n",
        "\n",
        "    def get_northern_hemisphere(self, group):\n",
        "        return self.get_hemisphere(group, OUT)\n",
        "\n",
        "    def get_theta(self, ring):\n",
        "        piece = ring[0]\n",
        "        point = piece.get_points()[3]\n",
        "        return np.arccos(point[2] / get_norm(point))\n",
        "\n",
        "    def get_theta_group(self, theta):\n",
        "        arc = Arc(\n",
        "            start_angle=90 * DEGREES,\n",
        "            angle=-theta,\n",
        "            radius=0.5,\n",
        "        )\n",
        "        arc.rotate(90 * DEGREES, RIGHT, about_point=ORIGIN)\n",
        "        arc.set_stroke(YELLOW, 2)\n",
        "        theta_mob = OldTex(\"\\\\theta\")\n",
        "        theta_mob.rotate(90 * DEGREES, RIGHT)\n",
        "        vect = np.cos(theta / 2) * OUT + np.sin(theta / 2) * RIGHT\n",
        "        theta_mob.move_to(\n",
        "            (arc.radius + 0.25) * normalize(vect),\n",
        "        )\n",
        "        theta_mob.set_background_stroke(width=1)\n",
        "\n",
        "        radius = self.sphere_config[\"radius\"]\n",
        "        point = arc.point_from_proportion(1)\n",
        "        radial_line = Line(\n",
        "            ORIGIN, radius * normalize(point)\n",
        "        )\n",
        "        radial_line.set_stroke(WHITE, 2)\n",
        "\n",
        "        return VGroup(arc, radial_line, theta_mob)\n",
        "\n",
        "    def get_ring_from_theta(self, rings, theta):\n",
        "        n_rings = len(rings)\n",
        "        index = min(int((theta / PI) * n_rings), n_rings - 1)\n",
        "        return rings[index]\n",
        "\n",
        "\n",
        "class SecondProofHigherRes(SecondProof):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (60, 60),\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class SecondProofHighestRes(SecondProof):\n",
        "    CONFIG = {\n",
        "        \"sphere_config\": {\n",
        "            \"resolution\": (120, 120),\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class RangeFrom0To180(Scene):\n",
        "    def construct(self):\n",
        "        angle = Integer(0, unit=\"^\\\\circ\")\n",
        "        angle.scale(2)\n",
        "\n",
        "        self.add(angle)\n",
        "        self.wait()\n",
        "        self.play(ChangeDecimalToValue(\n",
        "            angle, 180,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Question1(Scene):\n",
        "    def construct(self):\n",
        "        kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"circumference\": RED,\n",
        "            }\n",
        "        }\n",
        "        question = OldTexText(\n",
        "            \"\"\"\n",
        "            \\\\small\n",
        "            Question \\\\#1: What is the circumference of\\\\\\\\\n",
        "            one of these rings (in terms of $R$ and $\\\\theta$)?\\\\\\\\\n",
        "            \"\"\",\n",
        "            **kwargs\n",
        "        )\n",
        "        prompt = OldTexText(\n",
        "            \"\"\"\n",
        "            Multiply this circumference by $R\\\\,d\\\\theta$ to \\\\\\\\\n",
        "            get an approximation of the ring's area.\n",
        "            \"\"\",\n",
        "            **kwargs\n",
        "\n",
        "        )\n",
        "        for words in question, prompt:\n",
        "            words.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        self.play(FadeInFromDown(question))\n",
        "        self.wait(2)\n",
        "        for word in question, prompt:\n",
        "            word.circum = word.get_part_by_tex(\"circumference\")\n",
        "            word.remove(word.circum)\n",
        "        self.play(\n",
        "            FadeOut(question, UP),\n",
        "            FadeInFromDown(prompt),\n",
        "            question.circum.replace, prompt.circum,\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class YouCouldIntegrate(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Integrate?\",\n",
        "            index=2,\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "        )\n",
        "        self.play(self.teacher.change, \"hesitant\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"We'll be a bit \\\\\\\\ more Archimedean\",\n",
        "            target_mode=\"speaking\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"confused\")\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Question2(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\n",
        "            \"\"\"\n",
        "            Question \\\\#2: What is the area of the shadow of\\\\\\\\\n",
        "            one of these rings?  (In terms of $R$, $\\\\theta$, and $d\\\\theta$).\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"shadow\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        question.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        self.play(FadeInFromDown(question))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Question3(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\"Question \\\\#3:\")\n",
        "        question.to_edge(LEFT)\n",
        "        equation = OldTexText(\n",
        "            \"(Shadow area)\", \"=\", \"$\\\\frac{1}{2}$\",\n",
        "            \"(Area of one of the rings)\"\n",
        "        )\n",
        "        equation[0][1:-1].set_color(YELLOW)\n",
        "        equation[3][1:-1].set_color(PINK)\n",
        "        equation.next_to(question, RIGHT)\n",
        "        which_one = OldTexText(\"Which one?\")\n",
        "        # which_one.set_color(YELLOW)\n",
        "        brace = Brace(equation[-1], DOWN, buff=SMALL_BUFF)\n",
        "        which_one.next_to(brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(question)\n",
        "        self.play(FadeIn(equation))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(which_one)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExtraHint(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Extra hint\")\n",
        "        title.scale(2.5)\n",
        "        title.shift(UP)\n",
        "        equation = OldTex(\n",
        "            \"\\\\sin(2\\\\theta) = 2\\\\sin(\\\\theta)\\\\cos(\\\\theta)\"\n",
        "        )\n",
        "        equation.next_to(title, DOWN)\n",
        "        self.add(title, equation)\n",
        "\n",
        "\n",
        "class Question4(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\n",
        "            \"Question \\\\#4:\",\n",
        "            \"Explain how the shadows relate to\\\\\\\\\"\n",
        "            \"every other ring on the sphere.\",\n",
        "            tex_to_color_map={\n",
        "                \"shadows\": YELLOW,\n",
        "                \"every other ring\": BLUE,\n",
        "            }\n",
        "        )\n",
        "\n",
        "        self.add(question[0])\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(question[1:]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Question5(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\n",
        "            \"\"\"\n",
        "            Question \\\\#5: Why does this imply that the \\\\\\\\\n",
        "            shadow is $\\\\frac{1}{4}$ the surface area?\n",
        "            \"\"\"\n",
        "        )\n",
        "        self.play(FadeInFromDown(question))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SpherePatronThanks(Scene):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Ankalagon\",\n",
        "            \"Antonio Juarez\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Awoo\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"brian tiger chow\",\n",
        "            \"Brice Gower\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Carla Kirby\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Danger Dai\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"dave nicponski\",\n",
        "            \"David Clark\",\n",
        "            \"David Gow\",\n",
        "            \"Delton Ding\",\n",
        "            \"Devarsh Desai\",\n",
        "            \"Devin Scott\",\n",
        "            \"eaglle\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Evan Phillips\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Florian Chudigiewitsch\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Graham\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"J\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"James Hughes\",\n",
        "            \"Jan Pijpers\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Jerry Ling\",\n",
        "            \"John Griffith\",\n",
        "            \"John Haley\",\n",
        "            \"John Shaughnessy\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Juan Benet\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"L0j1k\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Magnus Lysfjord\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Markus Persson\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matt Russell\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Maur\u00edcio Collares\",\n",
        "            \"Mehdi Razavi\",\n",
        "            \"Michael Faust\",\n",
        "            \"Michael Hardel\",\n",
        "            \"MrSneaky\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nathan Jessurun\",\n",
        "            \"Nero Li\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Quantopian\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Robert Teed\",\n",
        "            \"Roobie\",\n",
        "            \"Roy Larson\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"soekul\",\n",
        "            \"Solara570\",\n",
        "            \"Song Gao\",\n",
        "            \"Steven Soloway\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Xavier Bernard\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Yaw Etse\",\n",
        "            \"YinYangBalance Asia\",\n",
        "            \"Zach Cardwell\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_columns()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Funded by the community, with special thanks to:\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.to_edge(UP)\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.set_width(title.get_width() + MED_SMALL_BUFF)\n",
        "        underline.next_to(title, DOWN, SMALL_BUFF)\n",
        "        title.add(underline)\n",
        "\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_columns(self):\n",
        "        random.seed(1)\n",
        "        random.shuffle(self.specific_patrons)\n",
        "        patrons = VGroup(*[\n",
        "            OldTexText(name)\n",
        "            for name in self.specific_patrons\n",
        "        ])\n",
        "        columns = VGroup()\n",
        "        column_size = 15\n",
        "        for n in range(0, len(patrons), column_size):\n",
        "            column = patrons[n:n + column_size]\n",
        "            column.arrange(\n",
        "                DOWN,\n",
        "                aligned_edge=LEFT\n",
        "            )\n",
        "            columns.add(column)\n",
        "        columns.set_height(6)\n",
        "        for group in columns[:4], columns[4:]:\n",
        "            for k, column in enumerate(group):\n",
        "                column.move_to(\n",
        "                    6.5 * LEFT + 3.75 * k * RIGHT + 2.5 * UP,\n",
        "                    UL\n",
        "                )\n",
        "\n",
        "        self.add(columns[:4])\n",
        "        self.wait()\n",
        "        for k in range(4):\n",
        "            self.play(\n",
        "                FadeOut(columns[k]),\n",
        "                FadeIn(columns[k + 4]),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"thanks_words\": \"\",\n",
        "    }\n",
        "\n",
        "\n",
        "class ForThoseStillAround(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Still here?\")\n",
        "        words.scale(1.5)\n",
        "        url = OldTexText(\"3blue1brown.com/store\")\n",
        "        # url.scale(1.5)\n",
        "        url.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(words, url))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PatronWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\\\\$2+ Patrons get \\\\\\\\ 50\\\\% off\")\n",
        "        words.to_corner(UL)\n",
        "        words.set_color(RED)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class PlushMe(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Plushie me?\")\n",
        "        self.play_student_changes(\"happy\", None, \"happy\")\n",
        "        self.play(self.teacher.change, \"confused\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\"...why?\", target_mode=\"maybe\")\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class Thumbnail(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\n",
        "            \"light_source_start_point\": [-10, 5, 7],\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        radius = 1.75\n",
        "        sphere = self.get_sphere(radius=radius)\n",
        "        sphere.rotate(70 * DEGREES, LEFT)\n",
        "        sphere.set_fill(BLUE_E)\n",
        "        sphere.set_stroke(WHITE, 0.5)\n",
        "\n",
        "        circles = VGroup(*[\n",
        "            Circle(radius=radius)\n",
        "            for x in range(4)\n",
        "        ])\n",
        "        circles.set_stroke(WHITE, 2)\n",
        "        circles.set_fill(BLUE_E, 1)\n",
        "        circles[0].set_fill(GREY_BROWN)\n",
        "        circles.arrange_in_grid()\n",
        "        for circle in circles:\n",
        "            formula = OldTex(\"\\\\pi\", \"R\", \"^2\")\n",
        "            formula.set_color_by_tex(\"R\", YELLOW)\n",
        "            formula.scale(2)\n",
        "            formula.move_to(circle)\n",
        "            circle.add(formula)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.scale(3)\n",
        "\n",
        "        group = VGroup(sphere, equals, circles)\n",
        "        group.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        equals.shift(3 * SMALL_BUFF * RIGHT)\n",
        "\n",
        "        why = OldTexText(\"Why?!\")\n",
        "        why.set_color(YELLOW)\n",
        "        why.scale(2.5)\n",
        "        why.next_to(sphere, UP)\n",
        "\n",
        "        sa_formula = OldTex(\"4\\\\pi\", \"R\", \"^2\")\n",
        "        sa_formula.set_color_by_tex(\"R\", YELLOW)\n",
        "        sa_formula.scale(2)\n",
        "        sa_formula.next_to(sphere, DOWN)\n",
        "\n",
        "        self.camera.distance_tracker.set_value(100)\n",
        "\n",
        "        self.add(sphere, equals, circles, why, sa_formula)\n"
    ]
}