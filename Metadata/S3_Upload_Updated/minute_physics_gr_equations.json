{
    "topic": "demonstrates the concept of a system of equations, specifically the first-order linear differential equation",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class GREquations(Scene):\n",
        "    CONFIG = {\n",
        "        \"mu_color\": BLUE_E,\n",
        "        \"nu_color\": RED_E,\n",
        "        \"camera_config\": {\n",
        "            \"background_color\": WHITE,\n",
        "        },\n",
        "        \"tex_config\": {\n",
        "            \"color\": BLACK,\n",
        "            \"background_stroke_width\": 0,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        eq1 = self.get_field_eq(\"\\\\mu\", \"\\\\nu\")\n",
        "        indices = list(filter(\n",
        "            lambda t: t[0] <= t[1],\n",
        "            it.product(range(4), range(4))\n",
        "        ))\n",
        "        sys1, sys2 = [\n",
        "            VGroup(*[\n",
        "                self.get_field_eq(i, j, simple=simple)\n",
        "                for i, j in indices\n",
        "            ])\n",
        "            for simple in (True, False)\n",
        "        ]\n",
        "        for sys in sys1, sys2:\n",
        "            sys.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "            sys.set_height(FRAME_HEIGHT - 0.5)\n",
        "            sys2.center()\n",
        "\n",
        "        sys1.next_to(ORIGIN, RIGHT)\n",
        "\n",
        "        eq1.generate_target()\n",
        "        group = VGroup(eq1.target, sys1)\n",
        "        group.arrange(RIGHT, buff=2)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                eq1.target.get_right(), eq.get_left(),\n",
        "                buff=0.2,\n",
        "                color=BLACK,\n",
        "                stroke_width=2,\n",
        "                tip_length=0.2,\n",
        "            )\n",
        "            for eq in sys1\n",
        "        ])\n",
        "\n",
        "        self.play(FadeIn(eq1, DOWN))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(eq1),\n",
        "            LaggedStart(*[\n",
        "                GrowArrow(arrow)\n",
        "                for arrow in arrows\n",
        "            ]),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(eq1, eq)\n",
        "                for eq in sys1\n",
        "            ], lag_ratio=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #\n",
        "        sys1.generate_target()\n",
        "        sys1.target.to_edge(LEFT)\n",
        "        sys2.to_edge(RIGHT)\n",
        "        new_arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                e1.get_right(), e2.get_left(),\n",
        "                buff=SMALL_BUFF,\n",
        "                color=BLACK,\n",
        "                stroke_width=2,\n",
        "                tip_length=0.2,\n",
        "            )\n",
        "            for e1, e2 in zip(sys1.target, sys2)\n",
        "        ])\n",
        "        self.play(\n",
        "            MoveToTarget(sys1),\n",
        "            MaintainPositionRelativeTo(arrows, sys1),\n",
        "            MaintainPositionRelativeTo(eq1, sys1),\n",
        "            VFadeOut(arrows),\n",
        "            VFadeOut(eq1),\n",
        "        )\n",
        "\n",
        "        #\n",
        "        sys1_rects, sys2_rects = [\n",
        "            VGroup(*map(self.get_rects, sys))\n",
        "            for sys in [sys1, sys2]\n",
        "        ]\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, sys1_rects),\n",
        "            LaggedStartMap(GrowArrow, new_arrows),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(sys1_rects, sys2_rects),\n",
        "            TransformFromCopy(sys1, sys2),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(sys1_rects),\n",
        "            FadeOut(sys2_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_field_eq(self, mu, nu, simple=True):\n",
        "        mu = \"{\" + str(mu) + \" }\"  # Deliberate space\n",
        "        nu = \"{\" + str(nu) + \"}\"\n",
        "        config = dict(self.tex_config)\n",
        "        config[\"tex_to_color_map\"] = {\n",
        "            mu: self.mu_color,\n",
        "            nu: self.nu_color,\n",
        "        }\n",
        "        if simple:\n",
        "            tex_args = [\n",
        "                (\"R_{%s%s}\" % (mu, nu),),\n",
        "                (\"-{1 \\\\over 2}\",),\n",
        "                (\"g_{%s%s}\" % (mu, nu),),\n",
        "                (\"R\",),\n",
        "                (\"=\",),\n",
        "                (\"8\\\\pi T_{%s%s}\" % (mu, nu),),\n",
        "            ]\n",
        "        else:\n",
        "            tex_args = [\n",
        "                (\n",
        "                    \"\\\\left(\",\n",
        "                    \"\\\\partial_\\\\rho \\\\Gamma^{\\\\rho}_{%s%s} -\" % (mu, nu),\n",
        "                    \"\\\\partial_%s \\\\Gamma^{\\\\rho}_{\\\\rho%s} +\" % (nu, mu),\n",
        "                    \"\\\\Gamma^{\\\\rho}_{\\\\rho\\\\lambda}\",\n",
        "                    \"\\\\Gamma^{\\\\lambda}_{%s%s} -\" % (nu, mu),\n",
        "                    \"\\\\Gamma^{\\\\rho}_{%s \\\\lambda}\" % nu,\n",
        "                    \"\\\\Gamma^{\\\\lambda}_{\\\\rho %s}\" % mu,\n",
        "                    \"\\\\right)\",\n",
        "                ),\n",
        "                (\"-{1 \\\\over 2}\",),\n",
        "                (\"g_{%s%s}\" % (mu, nu),),\n",
        "                (\n",
        "                    \"g^{\\\\alpha \\\\beta}\",\n",
        "                    \"\\\\left(\",\n",
        "                    \"\\\\partial_\\\\rho \\\\Gamma^{\\\\rho}_{\\\\beta \\\\alpha} -\"\n",
        "                    \"\\\\partial_\\\\beta \\\\Gamma^{\\\\rho}_{\\\\rho\\\\alpha} +\",\n",
        "                    \"\\\\Gamma^{\\\\rho}_{\\\\rho\\\\lambda}\",\n",
        "                    \"\\\\Gamma^{\\\\lambda}_{\\\\beta\\\\alpha} -\"\n",
        "                    \"\\\\Gamma^{\\\\rho}_{\\\\beta \\\\lambda}\",\n",
        "                    \"\\\\Gamma^{\\\\lambda}_{\\\\rho \\\\alpha}\",\n",
        "                    \"\\\\right)\",\n",
        "                ),\n",
        "                (\"=\",),\n",
        "                (\"8\\\\pi T_{%s%s}\" % (mu, nu),),\n",
        "            ]\n",
        "\n",
        "        result = VGroup(*[\n",
        "            OldTex(*args, **config)\n",
        "            for args in tex_args\n",
        "        ])\n",
        "        result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        return result\n",
        "\n",
        "    def get_rects(self, equation):\n",
        "        return VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                equation[i],\n",
        "                buff=0.025,\n",
        "                color=color,\n",
        "                stroke_width=1,\n",
        "            )\n",
        "            for i, color in zip(\n",
        "                [0, 3],\n",
        "                [GREY, GREY]\n",
        "            )\n",
        "        ])\n"
    ]
}