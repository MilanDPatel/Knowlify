{
    "topic": "The mathematical concept being demonstrated is the computation of the Riemann zeta function's zeros using the complex",
    "code": [
        "from manim_imports_ext import *\n",
        "from sympy import primerange\n",
        "from sympy import factorint\n",
        "import mpmath\n",
        "\n",
        "\n",
        "def get_first_n_primes(n=100_000):\n",
        "    pass\n",
        "    \"\"\"Generate the first n prime numbers.\"\"\"\n",
        "    primes = []\n",
        "    prime_gen = primerange(1, float('inf'))\n",
        "    for _ in range(n):\n",
        "        primes.append(next(prime_gen))\n",
        "    return primes\n",
        "\n",
        "\n",
        "def get_zeta_zeros(n_zeros=10):\n",
        "    return [complex(mpmath.zetazero(k + 1)) for k in range(n_zeros)]\n",
        "\n",
        "\n",
        "class ZetaSum(InteractiveScene):\n",
        "    n_vects = 100\n",
        "    max_N = 100_000\n",
        "    show_c = True\n",
        "    sum_tex = R\"\\sum_{n=1}^\\infty \\frac{1}{n^{s}}\"\n",
        "    exp_tex = R\"\\cdot e^{\\minus {c} n}\"\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.exp_const_tracker = ValueTracker(0)\n",
        "        self.s_plane, self.out_plane = self.add_planes()\n",
        "        self.s_group = self.add_s_group(self.s_plane)\n",
        "        self.s_tracker = self.s_group[0]\n",
        "        self.sum_label = self.add_sum_label()\n",
        "\n",
        "        self.generate_sample_ns()\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        s_tracker, s_dot, s_label = self.s_group\n",
        "        exp_const_tracker = self.exp_const_tracker\n",
        "        zeta_zeros = get_zeta_zeros()\n",
        "\n",
        "        # Add sum\n",
        "        self.add_partial_sum_path()\n",
        "\n",
        "        # Move to various values\n",
        "        self.play(s_tracker.animate.set_value(zeta_zeros[0]), run_time=3)\n",
        "\n",
        "        # Change exponential constant\n",
        "        self.play(exp_const_tracker.animate.set_value(0.01), run_time=3)\n",
        "\n",
        "    def add_planes(self):\n",
        "        planes = VGroup(\n",
        "            ComplexPlane((-1, 3), (-40, 40)),\n",
        "            ComplexPlane((-3, 3), (-3, 3)),\n",
        "        )\n",
        "        planes[0].set_width(4)\n",
        "        planes[1].set_width(6)\n",
        "        planes.arrange(RIGHT, buff=2.0)\n",
        "        planes.set_y(-0.5).to_edge(LEFT)\n",
        "        for plane in planes:\n",
        "            plane.add_coordinate_labels(font_size=16)\n",
        "        self.add(planes)\n",
        "        return planes\n",
        "\n",
        "    def add_s_group(self, s_plane):\n",
        "        s_tracker = ComplexValueTracker(1)\n",
        "        get_s = s_tracker.get_value\n",
        "        s_dot = Group(TrueDot(), GlowDot())\n",
        "        s_dot.set_color(YELLOW)\n",
        "        s_dot.add_updater(lambda m: m.move_to(s_plane.n2p(get_s())))\n",
        "        s_label = Tex(R\"s\").set_color(YELLOW)\n",
        "        s_label.always.next_to(s_dot[0], UR, SMALL_BUFF)\n",
        "\n",
        "        s_group = Group(s_tracker, s_dot, s_label)\n",
        "        self.add(s_group)\n",
        "        return s_group\n",
        "\n",
        "    def add_sum_label(self):\n",
        "        out_plane = self.out_plane\n",
        "        get_exp_const = self.exp_const_tracker.get_value\n",
        "\n",
        "        sum_label = Tex(\n",
        "            self.sum_tex + (self.exp_tex if self.show_c else \"\"),\n",
        "            t2c={\"{s}\": YELLOW, \"{c}\": RED},\n",
        "            font_size=42\n",
        "        )\n",
        "        sum_label.next_to(out_plane, UP, aligned_edge=LEFT)\n",
        "        self.add(sum_label)\n",
        "\n",
        "        if self.show_c:\n",
        "            exp_const_label = Tex(R\"c = 0.0000\", t2c={\"c\": RED})\n",
        "            exp_const_label.next_to(sum_label, RIGHT, LARGE_BUFF)\n",
        "            c_dec = exp_const_label.make_number_changeable(\"0.0000\")\n",
        "            c_dec.add_updater(lambda m: m.set_value(get_exp_const()))\n",
        "            sum_label.add(exp_const_label)\n",
        "\n",
        "        return sum_label\n",
        "\n",
        "    def add_partial_sum_path(self):\n",
        "        self.partial_sum_path = self.get_partial_sum_path()\n",
        "        self.vect_sum = self.get_vect_sum(self.partial_sum_path)\n",
        "\n",
        "        self.add(self.partial_sum_path)\n",
        "        self.add(self.vect_sum)\n",
        "\n",
        "    def generate_sample_ns(self):\n",
        "        self.sample_ns = np.arange(1, self.max_N + 1)\n",
        "\n",
        "    def get_summands(self, s):\n",
        "        exp_const = self.exp_const_tracker.get_value()\n",
        "        weights = np.exp(-exp_const * self.sample_ns)\n",
        "        return weights * (self.sample_ns**(-s))\n",
        "\n",
        "    def get_partial_sum_path(self, stroke_color=TEAL, stroke_width=1):\n",
        "        out_plane = self.out_plane\n",
        "\n",
        "        path = VMobject()\n",
        "\n",
        "        def update_path(path):\n",
        "            summands = self.get_summands(self.s_tracker.get_value())\n",
        "            partial_sums = np.hstack([[0], np.cumsum(summands)])\n",
        "            points = out_plane.n2p(partial_sums)\n",
        "            path.set_points_as_corners(points)\n",
        "\n",
        "        path.add_updater(update_path)\n",
        "        path.set_stroke(TEAL, 1)\n",
        "        return path\n",
        "\n",
        "    def get_vect_sum(self, path, vect_colors=[TEAL, GREEN], thickness=3):\n",
        "        vects = VGroup(\n",
        "            Vector(RIGHT, thickness=thickness, fill_color=color)\n",
        "            for n, color in zip(range(self.n_vects), it.cycle(vect_colors))\n",
        "        )\n",
        "        vects.set_fill(border_width=1)\n",
        "\n",
        "        def update_vects(vects):\n",
        "            points = path.get_anchors()\n",
        "            for vect, p0, p1 in zip(vects, points, points[1:]):\n",
        "                vect.put_start_and_end_on(p0, p1)\n",
        "\n",
        "        vects.add_updater(update_vects)\n",
        "        return vects\n",
        "\n",
        "\n",
        "class ZetaLogDerivSum(ZetaSum):\n",
        "    sum_tex = R\"-\\frac{\\zeta'(s)}{\\zeta(s)} = \\sum_{\\substack{p \\, \\text{prime} \\\\ k \\in \\mathds{N}}} \\log(p) \\left(\\frac{1}{p^{k}} \\right)^s\"\n",
        "    exp_tex = R\"\\cdot e^{\\minus {c} p^k}\"\n",
        "    show_c = False\n",
        "    max_N = 1_000_000\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        self.frame.reorient(0, 0, 0, RIGHT, 10)\n",
        "        s_tracker = self.s_tracker\n",
        "        exp_const_tracker = self.exp_const_tracker\n",
        "        zeta_zeros = get_zeta_zeros()\n",
        "\n",
        "        # Add sum\n",
        "        partial_sum_path = self.get_partial_sum_path()\n",
        "        vect_sum = self.get_vect_sum(partial_sum_path)\n",
        "\n",
        "        self.add(partial_sum_path)\n",
        "        self.add(vect_sum)\n",
        "\n",
        "        # Move to various values\n",
        "        self.play(s_tracker.animate.set_value(-1 + 5j))\n",
        "        self.play(s_tracker.animate.set_value(0.5 + 5j), run_time=3)\n",
        "        self.play(s_tracker.animate.set_value(zeta_zeros[5]), run_time=5)\n",
        "        self.play(s_tracker.animate.increment_value(-0.25), run_time=3)\n",
        "\n",
        "        self.play(exp_const_tracker.animate.set_value(0.1), run_time=3)\n",
        "\n",
        "    def generate_sample_ns(self):\n",
        "        base_weights = []\n",
        "        sample_ns = []\n",
        "        for n in range(1, self.max_N + 1):\n",
        "            factors = factorint(n)\n",
        "            if len(factors) == 1:\n",
        "                sample_ns.append(n)\n",
        "                p, k = list(factors.items())[0]\n",
        "                base_weights.append(np.log(p))\n",
        "        self.base_weights = np.array(base_weights)\n",
        "        self.sample_ns = np.array(sample_ns)\n",
        "\n",
        "    def get_summands(self, s):\n",
        "        exp_const = self.exp_const_tracker.get_value()\n",
        "        weights = self.base_weights * np.exp(-exp_const * self.sample_ns)\n",
        "        return weights * (self.sample_ns**(-s))\n",
        "\n"
    ]
}