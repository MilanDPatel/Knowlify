{
    "topic": "The mathematical concept being demonstrated is the visualization of a sum of waves with different frequencies and amplitudes",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from _2022.piano.wav_to_midi import DATA_DIR\n",
        "from scipy.io import wavfile\n",
        "\n",
        "\n",
        "def get_wave_sum(axes, freqs, amplitudes=None, phases=None):\n",
        "    if amplitudes is None:\n",
        "        amplitudes = np.ones(len(freqs))\n",
        "    if phases is None:\n",
        "        phases = np.zeros(len(freqs))\n",
        "    return axes.get_graph(lambda t: sum(\n",
        "        amp * math.sin(TAU * freq * (t - phase))\n",
        "        for freq, amp, phase in zip(freqs, amplitudes, phases)\n",
        "    ))\n",
        "\n",
        "\n",
        "def get_ellipsis_vector(values, n_top_shown=3, n_bottom_shown=2, height=2):\n",
        "    values = list(map(str, (*values[:n_top_shown], *values[-n_bottom_shown:])))\n",
        "    values.insert(n_top_shown, \"\\\\vdots\")\n",
        "    vector = Matrix(np.transpose([values]))\n",
        "    vector.set_height(3)\n",
        "    return vector\n",
        "\n",
        "\n",
        "class SumOfWaves(Scene):\n",
        "    def construct(self):\n",
        "        # Show single pure wave\n",
        "        axes = Axes(\n",
        "            (0, 12), (-1, 1),\n",
        "            height=2,\n",
        "        )\n",
        "        base_freq = 0.5\n",
        "        wave = get_wave_sum(axes, [base_freq])\n",
        "        wave.set_stroke(BLUE, 2)\n",
        "\n",
        "        x = 4.5\n",
        "        brace = Brace(\n",
        "            Line(axes.i2gp(x, wave), axes.i2gp(x + 1 / base_freq, wave)),\n",
        "            UP, buff=SMALL_BUFF\n",
        "        )\n",
        "        brace_label = brace.get_text(\n",
        "            \"220 cycles / sec.\",\n",
        "            buff=SMALL_BUFF,\n",
        "            font_size=36,\n",
        "        )\n",
        "\n",
        "        axes_labels = VGroup(*(\n",
        "            Text(word, font_size=30)\n",
        "            for word in [\"Air pressure\", \"Time\"]\n",
        "        ))\n",
        "        axes_labels[0].next_to(axes.y_axis, UP).to_edge(LEFT)\n",
        "        axes_labels[1].next_to(axes.x_axis, UP).to_edge(RIGHT)\n",
        "\n",
        "        self.add(axes)\n",
        "        brace_rf = squish_rate_func(smooth, 0.25, 0.5)\n",
        "        label_rf = squish_rate_func(smooth, 0.25, 1)\n",
        "        self.play(\n",
        "            ShowCreation(wave, rate_func=linear),\n",
        "            GrowFromCenter(brace, rate_func=brace_rf),\n",
        "            Write(brace_label, rate_func=label_rf),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            Write, axes_labels,\n",
        "            lag_ratio=0.8\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show multiple waves\n",
        "        freq_multiples = [1, 6 / 5, 3 / 2, 21 / 12]\n",
        "        freqs = [base_freq * r for r in freq_multiples]\n",
        "\n",
        "        low_axes_group = VGroup(*(\n",
        "            Axes((0, 12), (-1, 1), height=0.65)\n",
        "            for freq in freqs\n",
        "        ))\n",
        "        low_axes_group.arrange(UP, buff=0.4)\n",
        "        low_axes_group.to_edge(DOWN)\n",
        "        low_axes_group.to_edge(RIGHT)\n",
        "\n",
        "        waves = VGroup(*(\n",
        "            get_wave_sum(la, [freq])\n",
        "            for la, freq in zip(low_axes_group, freqs)\n",
        "        ))\n",
        "        waves.set_submobject_colors_by_gradient(BLUE, YELLOW)\n",
        "        waves.set_stroke(width=2)\n",
        "\n",
        "        axes_labels = VGroup(*(\n",
        "            Text(f\"{int(mult * 220)} Hz\", font_size=24)\n",
        "            for mult in freq_multiples\n",
        "        ))\n",
        "        for low_axes, label in zip(low_axes_group, axes_labels):\n",
        "            label.next_to(low_axes, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(VGroup(axes_labels[1], brace), DOWN),\n",
        "            ReplacementTransform(brace_label, axes_labels[0]),\n",
        "            ReplacementTransform(axes, low_axes_group[0]),\n",
        "            ReplacementTransform(wave, waves[0]),\n",
        "            *(\n",
        "                TransformFromCopy(axes, low_axes)\n",
        "                for low_axes in low_axes_group[1:]\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, waves[1:],\n",
        "                lag_ratio=0.5,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, axes_labels[1:],\n",
        "                lag_ratio=0.5,\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum\n",
        "        top_axes = Axes((0, 12), (-4, 4), height=2.25)\n",
        "        top_axes.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        top_axes.align_to(low_axes_group, RIGHT)\n",
        "        top_rect = Rectangle(FRAME_WIDTH, top_axes.get_height() + 0.5)\n",
        "        top_rect.move_to(top_axes)\n",
        "        top_rect.set_x(0)\n",
        "        top_rect.set_stroke(WHITE, 0)\n",
        "        top_rect.set_fill(GREY_E, 1.0)\n",
        "        sum_label = Text(\"Sum\")\n",
        "        sum_label.to_edge(UP, buff=0.25)\n",
        "\n",
        "        amp_tracker = ValueTracker(np.ones(len(freqs)))\n",
        "        comp_wave = always_redraw(lambda: get_wave_sum(\n",
        "            top_axes, freqs, amplitudes=amp_tracker.get_value(),\n",
        "        ).set_stroke(TEAL, 2))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(top_rect),\n",
        "            FadeIn(top_axes),\n",
        "            FadeIn(sum_label),\n",
        "            *(\n",
        "                Transform(wave.deepcopy(), comp_wave, remover=True)\n",
        "                for wave in waves\n",
        "            )\n",
        "        )\n",
        "        self.add(comp_wave)\n",
        "        self.wait()\n",
        "\n",
        "        # Tweak magnitudes\n",
        "        for index in range(len(waves)):\n",
        "            wave = waves[index]\n",
        "            wave.index = index\n",
        "            wave.max_height = wave.get_height()\n",
        "            wave.add_updater(lambda w: w.set_height(\n",
        "                amp_tracker.get_value()[w.index] * w.max_height,\n",
        "                stretch=True\n",
        "            ))\n",
        "\n",
        "        self.add(*waves)\n",
        "\n",
        "        changes = [\n",
        "            # (index, d_value)\n",
        "            (3, -0.8),\n",
        "            (2, -0.9),\n",
        "            (1, 0.6),\n",
        "            (0, 0.5),\n",
        "            (3, 0.8),\n",
        "            (0, -1.1),\n",
        "            (1, 0.5),\n",
        "        ]\n",
        "        for index, d_value in changes:\n",
        "            values = amp_tracker.get_value().copy()\n",
        "            values[index] += d_value\n",
        "            arrows = VGroup(\n",
        "                Vector(0.5 * UP),\n",
        "                Vector(0.5 * DOWN),\n",
        "            )\n",
        "            arrows.arrange(DOWN if d_value > 0 else UP)\n",
        "            axes = low_axes_group[index]\n",
        "            arrows.match_height(axes)\n",
        "            arrows.next_to(axes, LEFT)\n",
        "\n",
        "            self.play(\n",
        "                amp_tracker.animate.set_value(values),\n",
        "                FadeIn(arrows[0], 0.25 * UP),\n",
        "                FadeIn(arrows[1], 0.25 * DOWN),\n",
        "            )\n",
        "            self.play(FadeOut(arrows, run_time=0.75))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DecomposeAudioSegment(Scene):\n",
        "    audio_file = os.path.join(DATA_DIR, \"audio_clips\", \"SignalFromSpeech.wav\")\n",
        "    sample_density = 1 / 5\n",
        "    n_sine_waves = 5\n",
        "    signal_graph_style = dict(\n",
        "        stroke_color=BLUE,\n",
        "        stroke_width=1,\n",
        "    )\n",
        "    graph_point = 0.428\n",
        "    zoom_rect_dims = (0.4, 4.0)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_full_waveform()\n",
        "        self.zoom_in_on_segment(\n",
        "            self.axes, self.graph,\n",
        "            self.graph_point, self.zoom_rect_dims\n",
        "        )\n",
        "        self.prepare_for_3d()\n",
        "        self.break_down_into_fourier_components()\n",
        "        self.back_to_full_signal()\n",
        "\n",
        "    def add_full_waveform(self, run_time=5):\n",
        "        axes, graph = self.get_signal_graph()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                graph,\n",
        "                rate_func=squish_rate_func(linear, 0.05, 1),\n",
        "            ),\n",
        "            VShowPassingFlash(\n",
        "                graph.copy().set_stroke(BLUE_B, 3),\n",
        "                time_width=0.1,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            run_time=run_time,\n",
        "        )\n",
        "\n",
        "        self.axes = axes\n",
        "        self.graph = graph\n",
        "\n",
        "    def zoom_in_on_segment(self, axes, graph, graph_point, zoom_rect_dims, run_time=4, fade_in_new_axes=True):\n",
        "        point = graph.pfp(graph_point)[0] * RIGHT\n",
        "        zoom_rect = Rectangle(*zoom_rect_dims)\n",
        "        zoom_rect.move_to(point)\n",
        "        zoom_rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        graph_snippet = VMobject()\n",
        "        graph_points = graph.get_anchors()\n",
        "        lx = zoom_rect.get_left()[0]\n",
        "        rx = zoom_rect.get_right()[0]\n",
        "        xs = graph_points[:, 0]\n",
        "        snippet_points = graph_points[(xs > lx) * (xs < rx)]\n",
        "        graph_snippet.set_points_as_corners(snippet_points)\n",
        "        graph_snippet.match_style(graph)\n",
        "        point = graph_snippet.get_center().copy()\n",
        "        point[1] = axes.get_origin()[1]\n",
        "        zoom_rect.move_to(point)\n",
        "\n",
        "        movers = [axes, graph, graph_snippet, zoom_rect]\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        for mover in movers:\n",
        "            mover.save_state()\n",
        "            mover.generate_target()\n",
        "            mover.target.stretch(frame.get_width() / zoom_rect.get_width(), 0, about_point=point)\n",
        "            mover.target.stretch(frame.get_height() / zoom_rect.get_height(), 1, about_point=point)\n",
        "            mover.target.shift(-point)\n",
        "        graph_snippet.target.set_stroke(width=3)\n",
        "        zoom_rect.target.set_stroke(width=0)\n",
        "        axes.target.set_stroke(opacity=0)\n",
        "\n",
        "        new_axes = Axes((-2, 12), (-1, 1, 0.25), width=FRAME_WIDTH + 1)\n",
        "        new_axes.shift(LEFT_SIDE + RIGHT - new_axes.get_origin())\n",
        "\n",
        "        self.play(Write(zoom_rect))\n",
        "        self.play(\n",
        "            *map(MoveToTarget, movers),\n",
        "            FadeIn(new_axes),\n",
        "            run_time=run_time,\n",
        "        )\n",
        "        self.remove(graph, axes)\n",
        "\n",
        "        # Swap axes\n",
        "\n",
        "        # if fade_in_new_axes:\n",
        "        #     self.play(FadeIn(new_axes))\n",
        "\n",
        "        self.original_graph = graph\n",
        "        self.original_axes = axes\n",
        "        self.axes = new_axes\n",
        "        self.graph = graph_snippet\n",
        "\n",
        "        return new_axes, graph_snippet\n",
        "\n",
        "    def prepare_for_3d(self):\n",
        "        frame = self.camera.frame\n",
        "        for mob in self.mobjects:\n",
        "            mob.rotate(PI / 2, RIGHT)\n",
        "        frame.reorient(0, 90)\n",
        "        self.add(frame)\n",
        "\n",
        "    def break_down_into_fourier_components(self):\n",
        "        t_axes = self.axes\n",
        "        graph = self.graph\n",
        "\n",
        "        # Take the fourier transform\n",
        "        t_max = t_axes.x_range[1]\n",
        "        ts, values = t_axes.p2c(graph.get_points()[::6])\n",
        "        signal = values[(ts > 0) * (ts < t_max)]\n",
        "        signal_fft = np.fft.fft(signal)\n",
        "        signal_fft /= len(signal)\n",
        "        signal_fft_abs = np.abs(signal_fft)\n",
        "        signal_fft_phase = np.log(signal_fft).imag\n",
        "\n",
        "        # Prepare the graph\n",
        "        max_freq = signal.size / t_max\n",
        "        f_axes = Axes(\n",
        "            (0, max_freq / 2, max_freq / len(signal) / 2),\n",
        "            (0, 1, 1 / 8),\n",
        "            height=t_axes.get_depth(),\n",
        "            width=150,\n",
        "        )\n",
        "        f_axes.rotate(PI / 2, RIGHT)\n",
        "        f_axes.rotate(PI / 2, OUT)\n",
        "        f_axes.shift(t_axes.get_origin() - f_axes.get_origin())\n",
        "        freqs = np.fft.fftfreq(signal.size, 1 / max_freq) % max_freq\n",
        "\n",
        "        fft_graph = VMobject()\n",
        "        fft_graph.set_points_as_corners([\n",
        "            f_axes.c2p(freq, 2 * value)\n",
        "            for freq, value in zip(freqs, signal_fft_abs)\n",
        "        ])\n",
        "        fft_graph.set_stroke(GREEN, 3)\n",
        "        freq_label = Text(\"Frequency\", font_size=60)\n",
        "        freq_label.rotate(PI / 2, RIGHT)\n",
        "        freq_label.rotate(PI / 2, OUT)\n",
        "        freq_label.next_to(f_axes.c2p(1.3, 0), OUT + UP)\n",
        "\n",
        "        # Express the most dominant signals as sine waves\n",
        "        sine_waves = VGroup()\n",
        "        amps = []\n",
        "        for index in range(1, 50):\n",
        "            freq = freqs[index]\n",
        "            amp = signal_fft_abs[index]\n",
        "            phase = signal_fft_phase[index]\n",
        "            wave = t_axes.get_graph(\n",
        "                lambda t: 2 * amp * np.cos(TAU * freq * (t + phase)),\n",
        "                x_range=(0, t_max),\n",
        "            )\n",
        "            wave.match_y(f_axes.c2p(freq, 0))\n",
        "            wave.set_stroke(opacity=clip(15 * amp, 0.35, 1))\n",
        "            wave.amp = amp\n",
        "            wave.freq = freq\n",
        "            wave.phase = phase\n",
        "            amps.append(amp)\n",
        "            sine_waves.add(wave)\n",
        "\n",
        "        sine_waves.set_submobject_colors_by_gradient(YELLOW, GREEN, RED, ORANGE)\n",
        "        sine_waves.set_stroke(width=3)\n",
        "        top_waves = VGroup(*[sine_waves[i] for i in [4, 9, 13, 14]]).copy()\n",
        "\n",
        "        # Break down\n",
        "        frame = self.camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.set_euler_angles(1.2, 1.35)\n",
        "        frame.target.set_height(10.5)\n",
        "        frame.target.move_to([1.5, 5.0, 0.7])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(f_axes),\n",
        "            MoveToTarget(frame, run_time=8),\n",
        "            LaggedStart(\n",
        "                *(TransformFromCopy(graph, wave) for wave in top_waves),\n",
        "                lag_ratio=0.8,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.25 * dt * DEGREES))\n",
        "        self.play(Write(freq_label))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeIn(sine_waves, lag_ratio=0.1, run_time=3),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Collapse into FFT graph\n",
        "        lines = VGroup(*(\n",
        "            Line(f_axes.c2p(freqs[i], 0), f_axes.i2gp(freqs[i], fft_graph))\n",
        "            for i in range(1, len(sine_waves))\n",
        "        ))\n",
        "        lines.set_stroke(GREEN, 2)\n",
        "        lines.set_flat_stroke(False)\n",
        "\n",
        "        frame.clear_updaters()\n",
        "        frame.generate_target()\n",
        "        frame.target.set_euler_angles(1.22, 1.54)\n",
        "        frame.target.move_to([1.92, 7.29, 1.05])\n",
        "\n",
        "        fft_label = OldTexText(\"|Fourier Transform|\", font_size=60)\n",
        "        fft_label.rotate(PI / 2, RIGHT).rotate(PI / 2, OUT)\n",
        "        fft_label.next_to(f_axes.i2gp(freqs[5], fft_graph), OUT)\n",
        "        fft_label.set_color(GREEN)\n",
        "\n",
        "        piano = Piano()\n",
        "        f_step = f_axes.x_range[2]\n",
        "        piano.set_width(get_norm(f_axes.c2p(88 * f_step) - f_axes.get_origin()))\n",
        "        piano.rotate(PI / 2, OUT)\n",
        "        piano.move_to(f_axes.get_origin(), DR)\n",
        "        piano.set_opacity(0.5)\n",
        "\n",
        "        wave_shadows = sine_waves.copy().set_stroke(opacity=0.1)\n",
        "        self.remove(top_waves, sine_waves)\n",
        "        self.add(wave_shadows)\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    TransformFromCopy(wave, line)\n",
        "                    for wave, line in zip(sine_waves, lines)\n",
        "                ),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=8,\n",
        "            ),\n",
        "            graph.animate.set_stroke(width=1, opacity=0.5),\n",
        "            ShowCreation(fft_graph, run_time=5),\n",
        "            Write(fft_label),\n",
        "            MoveToTarget(frame, run_time=5),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.add(piano, freq_label, fft_graph, lines)\n",
        "        self.play(\n",
        "            Write(piano),\n",
        "            frame.animate.set_phi(1.25),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pull out dominant signals\n",
        "        glow_keys = VGroup(*(\n",
        "            piano[np.argmin([\n",
        "                get_norm(k.get_center() - wave.get_left())\n",
        "                for k in piano\n",
        "            ])]\n",
        "            for wave in top_waves\n",
        "        ))\n",
        "        peak_dots = GlowDots([\n",
        "            lines[np.argmin([\n",
        "                get_norm(line.get_start() - wave.get_left())\n",
        "                for line in lines\n",
        "            ])].get_end()\n",
        "            for wave in top_waves\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(peak_dots),\n",
        "            LaggedStartMap(ShowCreation, top_waves),\n",
        "            frame.animate.set_euler_angles(0.72, 1.15).move_to([2., 4., 1.]),\n",
        "            ApplyMethod(glow_keys.set_fill, RED, 1, rate_func=squish_rate_func(smooth, 0, 0.2)),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reconstruct\n",
        "        approx_wave = graph.copy()  # Cheating\n",
        "        approx_wave.set_points_smoothly(graph.get_points()[::150])\n",
        "        approx_wave.set_stroke(TEAL, 3, 1.0)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 90).move_to(ORIGIN).set_height(10),\n",
        "            graph.animate.set_stroke(width=2, opacity=0.5),\n",
        "            *(ReplacementTransform(wave, approx_wave) for wave in top_waves),\n",
        "            LaggedStartMap(FadeOut, VGroup(fft_graph, lines, fft_label, freq_label, f_axes)),\n",
        "            FadeOut(peak_dots),\n",
        "            FadeOut(wave_shadows),\n",
        "            FadeOut(piano),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.approx_wave = approx_wave\n",
        "\n",
        "    def back_to_full_signal(self):\n",
        "        # Back to original graph\n",
        "        self.play(\n",
        "            FadeOut(self.axes),\n",
        "            FadeOut(self.approx_wave),\n",
        "            self.graph.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "        self.camera.frame.reorient(0, 0)\n",
        "        self.graph.rotate(-PI / 2, RIGHT)\n",
        "        self.play(\n",
        "            Restore(self.original_axes),\n",
        "            Restore(self.original_graph),\n",
        "            Restore(self.graph),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Show windows\n",
        "        axes = self.original_axes\n",
        "        graph = self.original_graph\n",
        "\n",
        "        windows = Rectangle().get_grid(1, 75, buff=0)\n",
        "        windows.replace(graph, stretch=True)\n",
        "        windows.stretch(1.1, 1)\n",
        "        windows.set_stroke(WHITE, 1)\n",
        "\n",
        "        piano = Piano()\n",
        "        piano.set_width(12)\n",
        "        piano.next_to(axes, UP).set_x(0)\n",
        "        piano.save_state()\n",
        "        self.add(piano)\n",
        "\n",
        "        for window in windows[:40]:\n",
        "            fade_rect = BackgroundRectangle(axes)\n",
        "            fade_rect.scale(1.01)\n",
        "            fade_rect = Difference(fade_rect, window)\n",
        "            fade_rect.set_fill(BLACK, 0.6)\n",
        "            fade_rect.set_stroke(width=0)\n",
        "\n",
        "            piano.restore()\n",
        "            VGroup(*random.sample(list(piano), random.randint(1, 4))).set_color(RED)\n",
        "\n",
        "            self.add(fade_rect, window)\n",
        "            self.wait(0.25)\n",
        "            self.remove(fade_rect, window)\n",
        "\n",
        "    def get_signal_graph(self):\n",
        "        sample_rate, signal = wavfile.read(self.audio_file)\n",
        "        signal = signal[:, 0] / np.abs(signal).max()\n",
        "        signal = signal[::int(1 / self.sample_density)]\n",
        "\n",
        "        axes = Axes(\n",
        "            (0, len(signal), sample_rate * self.sample_density), (-1, 1, 0.25),\n",
        "            height=6,\n",
        "            width=15,\n",
        "        )\n",
        "        axes.to_edge(LEFT)\n",
        "\n",
        "        xs = np.arange(len(signal))\n",
        "        points = axes.c2p(xs, signal)\n",
        "        graph = VMobject()\n",
        "        graph.set_points_as_corners(points)\n",
        "        graph.set_style(**self.signal_graph_style)\n",
        "\n",
        "        return axes, graph\n",
        "\n",
        "\n",
        "class WaveformDescription(DecomposeAudioSegment):\n",
        "    def construct(self):\n",
        "        self.add_full_waveform()\n",
        "\n",
        "        # Line passing over waveform\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "\n",
        "        line = Line(DOWN, UP)\n",
        "        line.set_stroke(WHITE, 1)\n",
        "        line.match_height(axes)\n",
        "        line.move_to(axes.get_origin())\n",
        "        line.add_updater(lambda l, dt: l.shift(0.1 * dt * RIGHT))\n",
        "\n",
        "        dot = GlowDot()\n",
        "        dot.add_updater(lambda d: d.move_to(axes.i2gp(\n",
        "            axes.x_axis.p2n(line.get_x()),\n",
        "            graph\n",
        "        )))\n",
        "        self.add(line, dot)\n",
        "\n",
        "        # Words\n",
        "        waveform = Text(\"Waveform\", font_size=72)\n",
        "        waveform.to_edge(UP)\n",
        "\n",
        "        y_label = Text(\"Intensity\", font_size=36)\n",
        "        y_label.next_to(axes.y_axis, UP).shift_onto_screen()\n",
        "        x_label = Text(\"Time\", font_size=36)\n",
        "        x_label.next_to(axes.x_axis, UP).to_edge(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.wait(4)\n",
        "        self.play(Write(waveform))\n",
        "        self.wait(2)\n",
        "        self.play(Write(y_label), run_time=1)\n",
        "        self.play(Write(x_label), run_time=1)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SignalsAsVectors(DecomposeAudioSegment):\n",
        "    audio_file = os.path.join(DATA_DIR, \"audio_clips\", \"SignalFromSpeech.wav\")  # Change?\n",
        "    sample_density = 1.0\n",
        "\n",
        "    def construct(self):\n",
        "        self.zoom_in_on_waveform()\n",
        "        self.describe_fourier_basis()\n",
        "\n",
        "    def zoom_in_on_waveform(self):\n",
        "        # Two sets of zooming\n",
        "        axes, graph = self.get_signal_graph()\n",
        "        self.add(axes, graph)\n",
        "        axes, graph = self.zoom_in_on_segment(\n",
        "            axes, graph, 0.35, (0.2, 4.0), run_time=3, fade_in_new_axes=False\n",
        "        )\n",
        "        axes.set_stroke(opacity=0)\n",
        "        axes, graph = self.zoom_in_on_segment(\n",
        "            axes, graph, 0.5, (0.15, 6.0), run_time=3, fade_in_new_axes=False\n",
        "        )\n",
        "\n",
        "        # Pull out true points from graph\n",
        "        points = []\n",
        "        for point in graph.get_anchors():\n",
        "            if not any((point == p).all() for p in points):\n",
        "                points.append(point)\n",
        "\n",
        "        # Create axes with alternate line representation of values\n",
        "        axes = Axes(\n",
        "            (0, len(points) - 1), (-1, 1, 0.25),\n",
        "            width=graph.get_width(),\n",
        "            height=graph.get_height(),\n",
        "        )\n",
        "        axes.shift(graph.get_left() - axes.get_origin())\n",
        "        self.play(FadeIn(axes))\n",
        "\n",
        "        # Lines and dots\n",
        "        new_graph, lines, dots = self.get_graph_with_lines_and_dots(axes, points)\n",
        "        new_graph.match_style(graph)\n",
        "        self.remove(graph)\n",
        "        graph = new_graph\n",
        "        self.add(graph)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(lines, lag_ratio=0.5),\n",
        "            FadeIn(dots),\n",
        "            graph.animate.set_stroke(width=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.signal_graph_group = Group(axes, graph, lines, dots)\n",
        "\n",
        "    def describe_fourier_basis(self):\n",
        "        # Vars\n",
        "        frame = self.camera.frame\n",
        "        graph_group = self.signal_graph_group\n",
        "        axes, graph, lines, dots = graph_group\n",
        "\n",
        "        # Show as a list of numbers\n",
        "        values = axes.y_axis.p2n(dots.get_points())\n",
        "        vector = get_ellipsis_vector((100 * values).astype(int))\n",
        "        vector.next_to(graph, UP, buff=MED_LARGE_BUFF)\n",
        "        vector.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.move_to(axes.get_bottom() + MED_LARGE_BUFF * DOWN, DOWN),\n",
        "            LaggedStart(\n",
        "                Write(vector.get_brackets()),\n",
        "                *(\n",
        "                    GrowFromPoint(mob, point)\n",
        "                    for point, mob in zip(dots.get_points()[:3], vector.get_entries()[:3])\n",
        "                ),\n",
        "                Write(vector.get_entries()[3]),\n",
        "                *(\n",
        "                    GrowFromPoint(mob, point)\n",
        "                    for point, mob in zip(dots.get_points()[-2:], vector.get_entries()[-2:])\n",
        "                ),\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show fourier basis as graphs\n",
        "        signal_fft = np.fft.fft(values)\n",
        "        fourier_basis = np.array([\n",
        "            np.fft.ifft(basis)\n",
        "            for basis in np.identity(values.size)\n",
        "        ])\n",
        "        component_values = np.array([\n",
        "            part * len(signal_fft)\n",
        "            for coef, fb in zip(signal_fft, fourier_basis)\n",
        "            for part in (fb.real, fb.imag)\n",
        "        ])\n",
        "        xs = list(range(len(signal_fft)))\n",
        "        component_graphs = VGroup(*(\n",
        "            self.get_graph_with_lines_and_dots(axes, axes.c2p(xs, vals))[0]\n",
        "            for vals in component_values\n",
        "        ))\n",
        "\n",
        "        component_graphs.make_smooth()\n",
        "        component_graphs.set_submobject_colors_by_gradient(YELLOW, RED, GREEN)\n",
        "\n",
        "        n_parts_shown = 6\n",
        "        comp_groups = VGroup(*(\n",
        "            VGroup(axes.deepcopy(), cg)\n",
        "            for cg in component_graphs[2:2 + n_parts_shown]\n",
        "        ))\n",
        "        comp_groups.add(OldTex(\"\\\\vdots\").set_height(comp_groups.get_height() / 2))\n",
        "        comp_groups.arrange(DOWN, buff=0.75 * comp_groups.get_height())\n",
        "        comp_groups.set_height(7.5)\n",
        "        comp_groups.move_to(frame).to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            graph_group.animate.set_width(\n",
        "                graph_group.get_width() - comp_groups.get_width() - LARGE_BUFF,\n",
        "                about_edge=DL\n",
        "            ),\n",
        "            vector.animate.to_edge(LEFT, buff=MED_LARGE_BUFF),\n",
        "            LaggedStartMap(FadeIn, comp_groups),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show fourier basis as vectors\n",
        "        c_dots_group = Group()\n",
        "        c_lines_group = VGroup()\n",
        "        c_vectors = VGroup()\n",
        "\n",
        "        for c_axes, c_graph in comp_groups[:-1]:\n",
        "            g, c_lines, c_dots = self.get_graph_with_lines_and_dots(\n",
        "                c_axes,\n",
        "                c_graph.get_points()[::6]\n",
        "            )\n",
        "            c_dots.set_color(c_graph.get_color())\n",
        "            c_dots.set_radius(0.1)\n",
        "            c_lines.set_stroke(width=0.5)\n",
        "\n",
        "            c_dots_group.add(c_dots)\n",
        "            c_lines_group.add(c_lines)\n",
        "\n",
        "            c_values = c_axes.y_axis.p2n(c_dots.get_points())\n",
        "            c_vector = get_ellipsis_vector((100 * c_values).astype(int))\n",
        "            c_vector.set_color(c_graph.get_color())\n",
        "            c_vectors.add(c_vector)\n",
        "\n",
        "        syms = VGroup(OldTex(\"=\"), *(OldTex(\"+\") for v in c_vectors[1:]))\n",
        "        coef_syms = VGroup(*(OldTex(f\"c_{i}\") for i in range(1, 4)))\n",
        "        coef_syms.add(OldTex(\"\\\\cdots\"))\n",
        "        last_vect = vector\n",
        "        buff = 0.15\n",
        "        for sym, coef_sym, c_vect in zip(syms, coef_syms, c_vectors):\n",
        "            sym.next_to(last_vect, RIGHT, buff=buff)\n",
        "            coef_sym.next_to(sym, RIGHT, buff=buff)\n",
        "            c_vect.next_to(coef_sym, RIGHT, buff=buff)\n",
        "            last_vect = c_vect\n",
        "\n",
        "        for i in range(3):\n",
        "            self.play(\n",
        "                ShowCreation(c_dots_group[i]),\n",
        "                ShowCreation(c_lines_group[i]),\n",
        "            )\n",
        "            self.play(\n",
        "                FadeIn(syms[i]),\n",
        "                Write(coef_syms[i]),\n",
        "                FadeTransform(c_dots_group[i].copy(), c_vectors[i])\n",
        "            )\n",
        "        self.play(\n",
        "            *map(ShowCreation, c_dots_group[3:]),\n",
        "            *map(ShowCreation, c_lines_group[3:]),\n",
        "            Write(syms[3]),\n",
        "            Write(coef_syms[3]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for comp, dots, lines in zip(comp_groups, c_dots_group, c_lines_group):\n",
        "            c_axes, c_graph = comp\n",
        "            stretcher = Group(c_graph, dots, lines)\n",
        "            self.play(\n",
        "                stretcher.animate.stretch(\n",
        "                    random.uniform(-1, 1),\n",
        "                    dim=1,\n",
        "                    about_point=c_axes.get_center(),\n",
        "                ),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def get_graph_with_lines_and_dots(self, axes, points, color=BLUE):\n",
        "        graph = VMobject()\n",
        "        graph.set_points_as_corners(points)\n",
        "        graph.set_stroke(color, 1)\n",
        "\n",
        "        # Alternate representation of values with lines\n",
        "        lines = VGroup(*(\n",
        "            axes.get_v_line(point, line_func=Line)\n",
        "            for point in points\n",
        "        ))\n",
        "        lines.set_stroke(WHITE, 1)\n",
        "        dots = GlowDots(points)\n",
        "        dots.set_color(color)\n",
        "\n",
        "        return graph, lines, dots\n",
        "\n",
        "\n",
        "class SampleRateOverlay(Scene):\n",
        "    def construct(self):\n",
        "        text = VGroup(\n",
        "            OldTexText(\"48,000 samples / sec\"),\n",
        "            OldTex(\"\\\\Downarrow\"),\n",
        "            OldTexText(\"20 ms window\", \" = 960-dimensional vector\")\n",
        "        )\n",
        "        text.arrange(DOWN)\n",
        "        text.to_edge(UP)\n",
        "\n",
        "        text[2][1].set_color(YELLOW)\n",
        "        text[2][0].save_state()\n",
        "        text[2][0].match_x(text)\n",
        "        self.play(Write(text[0]), run_time=1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromPoint(text[1], text[0].get_bottom()),\n",
        "            FadeIn(text[2][0], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(text[2][0]), FadeIn(text[2][1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThreeDChangeOfBasisExample(Scene):\n",
        "    def construct(self):\n",
        "        # Add axes and standard basis\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-20, 75)\n",
        "        frame.shift(OUT)\n",
        "        frame.add_updater(lambda m: m.set_theta(\n",
        "            -20 * math.cos(TAU * self.time / 60) * DEGREES,\n",
        "        ))\n",
        "\n",
        "        axes = ThreeDAxes(axis_config=dict(tick_size=0.05))\n",
        "        axes.set_stroke(width=1)\n",
        "        plane = NumberPlane(faded_line_ratio=0)\n",
        "        plane.set_stroke(GREY, 1, 0.5)\n",
        "        basis_mobs = VGroup(\n",
        "            Vector(RIGHT, color=RED),\n",
        "            Vector(UP, color=GREEN),\n",
        "            Vector(OUT, color=BLUE),\n",
        "        )\n",
        "\n",
        "        signal = Vector([-3, 1, 2], color=YELLOW)\n",
        "        signal.set_opacity(0.75)\n",
        "        signal_label = Text(\"Signal\")\n",
        "        signal_label.rotate(90 * DEGREES, RIGHT)\n",
        "        signal_label.match_color(signal)\n",
        "        signal_label.add_updater(lambda m: m.next_to(signal.get_end(), OUT))\n",
        "        coef_label = self.get_coef_label(signal, basis_mobs)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(plane)\n",
        "        self.add(basis_mobs)\n",
        "        self.add(signal)\n",
        "        self.add(signal_label)\n",
        "        self.add(coef_label)\n",
        "        for mob in self.mobjects:\n",
        "            mob.apply_depth_test()\n",
        "\n",
        "        # Show components\n",
        "        components = always_redraw(\n",
        "            self.get_linear_combination, signal, basis_mobs\n",
        "        )\n",
        "        components.suspend_updating()\n",
        "        self.animate_linear_combination(basis_mobs, components)\n",
        "        self.wait(2)\n",
        "        components.resume_updating()\n",
        "        self.add(components)\n",
        "        for v in [[-1, 1, 0.5], [1, 1, 0.25], [2, 1, 2]]:\n",
        "            self.play(\n",
        "                signal.animate.put_start_and_end_on(ORIGIN, v),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(5)\n",
        "\n",
        "        # Change of basis\n",
        "        rot_matrix = rotation_between_vectors([1, 1, 1], OUT)\n",
        "        new_basis = rot_matrix.T\n",
        "\n",
        "        basis_mobs.generate_target()\n",
        "        for basis_mob, new_vector in zip(basis_mobs.target, new_basis):\n",
        "            basis_mob.put_start_and_end_on(ORIGIN, new_vector)\n",
        "\n",
        "        self.play(FadeOut(components))\n",
        "        self.play(MoveToTarget(basis_mobs, run_time=2))\n",
        "        self.wait()\n",
        "        components.update()\n",
        "        for comp in components:\n",
        "            self.play(GrowArrow(comp))\n",
        "        self.add(components)\n",
        "        for vect in [[1, 0, 2]]:\n",
        "            self.play(signal.animate.put_start_and_end_on(ORIGIN, vect), run_time=3)\n",
        "            self.wait()\n",
        "\n",
        "        frame.suspend_updating()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "    def get_coefficients(self, vect_mob, basis_mobs):\n",
        "        cob_inv = np.array([\n",
        "            b.get_vector()\n",
        "            for b in basis_mobs\n",
        "        ]).T\n",
        "        cob = np.linalg.inv(cob_inv)\n",
        "        return np.dot(cob, vect_mob.get_vector())\n",
        "\n",
        "    def get_linear_combination(self, vect_mob, basis_mobs):\n",
        "        coefs = self.get_coefficients(vect_mob, basis_mobs)\n",
        "        components = VGroup()\n",
        "        last_point = vect_mob.get_start()\n",
        "        for coef, basis in zip(coefs, basis_mobs):\n",
        "            comp = Vector(coef * basis.get_vector())\n",
        "            comp.match_style(basis)\n",
        "            comp.set_stroke(opacity=0.5)\n",
        "            comp.shift(last_point - comp.get_start())\n",
        "            last_point = comp.get_end()\n",
        "            components.add(comp)\n",
        "        return components\n",
        "\n",
        "    def animate_linear_combination(self, basis_mobs, components):\n",
        "        for basis, part in zip(basis_mobs, components):\n",
        "            self.play(TransformFromCopy(basis, part))\n",
        "\n",
        "    def get_coef_label(self, vect_mob, basis_mobs, lhs_tex=\"\\\\vec{\\\\textbf{s}}\"):\n",
        "        label = VGroup()\n",
        "        lhs = OldTex(lhs_tex + \"=\")\n",
        "        label.numbers = VGroup(*(\n",
        "            DecimalNumber(include_sign=True)\n",
        "            for b in basis_mobs\n",
        "        ))\n",
        "        label.basis_labels = VGroup(*(\n",
        "            OldTex(\"\\\\vec{\\\\textbf{v}}_1\", color=RED),\n",
        "            OldTex(\"\\\\vec{\\\\textbf{v}}_2\", color=GREEN),\n",
        "            OldTex(\"\\\\vec{\\\\textbf{v}}_3\", color=BLUE),\n",
        "        ))\n",
        "\n",
        "        label.add(lhs)\n",
        "        label.add(*it.chain(*zip(\n",
        "            label.numbers, label.basis_labels\n",
        "        )))\n",
        "        label.fix_in_frame()\n",
        "        label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        label.to_corner(UL)\n",
        "\n",
        "        def update_label(label):\n",
        "            coefs = self.get_coefficients(vect_mob, basis_mobs)\n",
        "            for coef, number in zip(coefs, label.numbers):\n",
        "                number.set_value(coef)\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "        return label\n",
        "\n",
        "\n",
        "class ContrastPureToneToPianoKey(Scene):\n",
        "    def construct(self):\n",
        "        pass\n"
    ]
}