{
    "topic": "demonstrates the concept of twin primes, which are prime numbers that differ by",
    "code": [
        "from manim_imports_ext import *\n",
        "import sympy\n",
        "from _2023.clt.main import ChartBars\n",
        "\n",
        "\n",
        "class TwinPrimScrolling(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Create list of primes\n",
        "        n_max = 1000\n",
        "        primes = list(sympy.primerange(2, n_max))\n",
        "        prime_mobs = VGroup(*map(Integer, primes))\n",
        "        prime_mobs.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        prime_mobs.move_to(1 * RIGHT, LEFT)\n",
        "        prime_mobs.shift(2.5 * DOWN)\n",
        "        prime_mobs.set_fill(border_width=1)\n",
        "\n",
        "        twin_prime_color = BLUE\n",
        "        tp_groups = VGroup()\n",
        "        twin_primes = set()\n",
        "        for i in range(len(primes) - 1):\n",
        "            if primes[i] + 2 == primes[i + 1]:\n",
        "                twin_primes.add(primes[i])\n",
        "                twin_primes.add(primes[i + 1])\n",
        "                arc = Line(\n",
        "                    prime_mobs[i].get_top(),\n",
        "                    prime_mobs[i + 1].get_top(),\n",
        "                    path_arc=-PI,\n",
        "                    stroke_color=twin_prime_color,\n",
        "                    stroke_width=2,\n",
        "                )\n",
        "                arc.scale(0.9, about_edge=UP)\n",
        "                plus_2 = Tex(\"+2\", font_size=24)\n",
        "                plus_2.next_to(arc, UP, SMALL_BUFF)\n",
        "                plus_2.set_color(twin_prime_color)\n",
        "                tp_groups.add(VGroup(\n",
        "                    *prime_mobs[i:i + 2].copy(),\n",
        "                    arc, plus_2\n",
        "                ))\n",
        "\n",
        "        non_twin_primes = VGroup(*(\n",
        "            pm\n",
        "            for pm, prime in zip(prime_mobs, primes)\n",
        "            if prime not in twin_primes\n",
        "        ))\n",
        "\n",
        "        highlight_point = 5\n",
        "\n",
        "        def update_tp_groups(tp_groups):\n",
        "            for tp_group in tp_groups:\n",
        "                for mob in tp_group[2:]:\n",
        "                    mob.match_x(tp_group[:2])\n",
        "                x_coord = tp_group.get_x()\n",
        "                if x_coord < -10:\n",
        "                    tp_groups.remove(tp_group)\n",
        "                    continue\n",
        "                pre_alpha = inverse_interpolate(\n",
        "                    highlight_point + 0.25,\n",
        "                    highlight_point - 0.25,\n",
        "                    x_coord\n",
        "                )\n",
        "                alpha = clip(pre_alpha, 0, 1)\n",
        "                color = interpolate_color(WHITE, twin_prime_color, alpha)\n",
        "                tp_group[:2].set_color(color)\n",
        "                tp_group[2].set_stroke(width=2 * alpha)\n",
        "                tp_group[3].set_opacity(alpha)\n",
        "\n",
        "        tp_groups.add_updater(update_tp_groups)\n",
        "\n",
        "        self.add(non_twin_primes)\n",
        "        self.add(tp_groups)\n",
        "\n",
        "        # Animation\n",
        "        velocity = 1.5\n",
        "        run_time = non_twin_primes.get_width()\n",
        "\n",
        "        def shift_updater(mobject, dt):\n",
        "            mobject.shift(velocity * dt * LEFT)\n",
        "\n",
        "        tp_groups.add_updater(shift_updater)\n",
        "        non_twin_primes.add_updater(shift_updater)\n",
        "\n",
        "        self.wait(run_time)\n",
        "\n",
        "\n",
        "class Timeline(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Timeline\n",
        "        timeline = NumberLine(\n",
        "            (-500, 2050, 100),\n",
        "            width=FRAME_WIDTH - 1\n",
        "        )\n",
        "        timeline.move_to(2.5 * DOWN)\n",
        "        timeline.add_numbers(\n",
        "            list(range(0, 2050, 500)),\n",
        "            direction=DOWN,\n",
        "            group_with_commas=False,\n",
        "            font_size=36,\n",
        "        )\n",
        "        label = Tex(R\"\\sim 300 BC\", font_size=36)\n",
        "        v_line = Line(DOWN, UP)\n",
        "        v_line.move_to(timeline.n2p(-300), DOWN)\n",
        "        v_line.shift(SMALL_BUFF * DOWN)\n",
        "        v_line.set_stroke(WHITE, 1)\n",
        "        label.next_to(v_line, DOWN, buff=0.15)\n",
        "\n",
        "        self.add(timeline)\n",
        "        self.add(v_line)\n",
        "        self.add(label)\n",
        "\n",
        "        # Label\n",
        "        question = TexText(\n",
        "            R\"``Are there infinitely many twin primes?''\\\\ \\quad -Euclid\",\n",
        "            font_size=48,\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        question[-7:].shift(RIGHT + 0.1 * DOWN)\n",
        "        question.next_to(v_line, UP)\n",
        "        question.shift_onto_screen(buff=0.2)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Vector(3 * LEFT),\n",
        "            Text(\"No one can\\nanswer\", font_size=60).set_color(YELLOW),\n",
        "            Vector(3 * RIGHT)\n",
        "        )\n",
        "        arrows.arrange(RIGHT)\n",
        "        arrows.set_width(get_norm(timeline.n2p(2000) - timeline.n2p(-300)))\n",
        "        arrows.next_to(v_line, RIGHT)\n",
        "        arrows.shift(0.5 * UP)\n",
        "\n",
        "        # self.add(question)\n",
        "        self.add(arrows)\n",
        "\n",
        "\n",
        "class InfinitePrimes(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        n_max = 150\n",
        "        primes = list(sympy.primerange(2, n_max))\n",
        "        prime_mobs = VGroup(*map(Integer, primes))\n",
        "        prime_mobs.set_height(1.5)\n",
        "        prime_mobs.use_winding_fill(False)\n",
        "\n",
        "        def update_opacity(prime):\n",
        "            # alpha = inverse_interpolate(10, 0, prime.get_y())\n",
        "            alpha = inverse_interpolate(-20, 0, prime.get_z())\n",
        "            prime.set_fill(opacity=alpha)\n",
        "\n",
        "        for n, prime in enumerate(prime_mobs):\n",
        "            # prime.rotate(88 * DEGREES, RIGHT)\n",
        "            prime.set_height(1.5 * 0.95**n)\n",
        "            prime.move_to(3 * n * IN)\n",
        "            prime.add_updater(update_opacity)\n",
        "\n",
        "        rect = FullScreenRectangle()\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.fix_in_frame()\n",
        "\n",
        "        self.frame.reorient(-70, -30, 70)\n",
        "        self.frame.set_focal_distance(5)\n",
        "\n",
        "        self.add(prime_mobs)\n",
        "        self.play(\n",
        "            prime_mobs.animate.shift(70 * OUT),\n",
        "            FadeIn(rect, time_span=(10, 12)),\n",
        "            run_time=12,\n",
        "            rate_func=rush_into,\n",
        "        )\n",
        "\n",
        "    def old_attempt(self):\n",
        "        # Old attempt\n",
        "        point = UL\n",
        "        height = 2\n",
        "        shift = 0.75 * np.array([1, -1.2, 0])\n",
        "        scale = 1.0\n",
        "        opacity = 1.0\n",
        "\n",
        "        scale_factor = 0.65\n",
        "        shift_scale_factor = 0.7\n",
        "        opacity_scale_factor = 0.9\n",
        "\n",
        "        for n, mob in enumerate(prime_mobs):\n",
        "            mob.set_height(height * scale_factor**n)\n",
        "            mob.move_to(point + sum(\n",
        "                shift * shift_scale_factor**k\n",
        "                for k in range(n)\n",
        "            ))\n",
        "            mob.set_fill(opacity=opacity * opacity_scale_factor**n)\n",
        "\n",
        "        prime_mobs.submobjects.reverse()\n",
        "        self.add(prime_mobs)\n",
        "\n",
        "\n",
        "class ThoughtBubble(InteractiveScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(LEFT)\n",
        "        bubble = randy.get_bubble(\"Suppose\\nnot...\")\n",
        "        self.add(bubble, bubble.content)\n",
        "\n",
        "\n",
        "class SimpleBubble(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(OldThoughtBubble())\n",
        "\n",
        "\n",
        "class EuclidProof(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Suppose finite\n",
        "        prime_sequence = Tex(R\"2, 3, 5, \\dots , p_n\", font_size=72)\n",
        "        prime_sequence.move_to(UP + LEFT)\n",
        "        last = prime_sequence[\"p_n\"]\n",
        "        finite_words = Text(\"All primes (suppose finite)\", font_size=60)\n",
        "        finite_words.next_to(last, UR).shift(0.2 * UP)\n",
        "        sequence_rect = SurroundingRectangle(prime_sequence)\n",
        "        sequence_rect.set_stroke(YELLOW, 2)\n",
        "        sequence_rect.set_stroke(YELLOW, 2)\n",
        "        finite_words.next_to(sequence_rect, UP)\n",
        "        finite_words.shift(RIGHT * (sequence_rect.get_x() - finite_words[\"All primes\"].get_x()))\n",
        "\n",
        "        last_arrow = Arrow(\n",
        "            finite_words[\"prime\"].get_corner(DL),\n",
        "            last,\n",
        "            path_arc=-PI / 3,\n",
        "            buff=0.1\n",
        "        )\n",
        "        VGroup(finite_words, sequence_rect).set_color(YELLOW)\n",
        "\n",
        "        self.add(prime_sequence)\n",
        "        self.add(finite_words)\n",
        "        self.add(sequence_rect)\n",
        "\n",
        "        # Multiply, add 1, factor\n",
        "        product = Tex(R\"N = 2 \\cdot 3 \\cdot 5 \\cdots p_n\", font_size=72)\n",
        "        product.next_to(prime_sequence, DOWN, LARGE_BUFF)\n",
        "\n",
        "        plus_one = Tex(\"+1\", font_size=72)\n",
        "        plus_one.next_to(product, RIGHT, 0.2)\n",
        "        plus_one.shift(0.05 * UP)\n",
        "        N_mob = VGroup(product, plus_one)\n",
        "        N_mob.match_x(prime_sequence)\n",
        "\n",
        "        psc = prime_sequence.copy()\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                psc,\n",
        "                product,\n",
        "                matched_pairs=[\n",
        "                    (psc[\",\"], product[R\"\\cdot\"]),\n",
        "                    (psc[R\"\\dots\"], product[R\"\\cdots\"]),\n",
        "                ],\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(plus_one))\n",
        "        self.wait()\n",
        "\n",
        "        # Factor\n",
        "        N_rect = SurroundingRectangle(\n",
        "            VGroup(product[2:], plus_one)\n",
        "        )\n",
        "        factor_arrow = Vector(DL)\n",
        "        factor_arrow.next_to(N_rect, DOWN)\n",
        "        factor_word = Text(\"Prime factors\", font_size=60)\n",
        "        factor_word.next_to(factor_arrow, RIGHT, buff=0)\n",
        "\n",
        "        VGroup(N_rect, factor_arrow, factor_word).set_color(TEAL)\n",
        "\n",
        "        factor_eq = Tex(R\"N = q_1 \\cdots q_k\", font_size=72)\n",
        "        factor_eq[R\"q_1 \\cdots q_k\"].set_color(RED)\n",
        "        factor_eq.next_to(product, DOWN, buff=1.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransformPieces(product.copy(), factor_eq),\n",
        "            FadeIn(N_rect),\n",
        "            GrowArrow(factor_arrow),\n",
        "            FadeIn(factor_word, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Contradiction\n",
        "        q_rect = SurroundingRectangle(factor_eq[\"q_1\"], buff=0.1)\n",
        "        q_rect.set_stroke(WHITE, 3)\n",
        "        q_words = TexText(R\"Cannot be in $\\{2, 3, 5, \\dots, p_n\\}$\", font_size=60)\n",
        "        q_words.next_to(q_rect, UP, aligned_edge=LEFT)\n",
        "        q_words.match_color(factor_eq[2])\n",
        "        rect = SurroundingRectangle(Group(*(\n",
        "            mob\n",
        "            for mob in self.mobjects\n",
        "            if isinstance(mob, StringMobject)\n",
        "        )), buff=0.5)\n",
        "        rect.set_stroke(WHITE, 3)\n",
        "        rect.shift(0.35 * DOWN)\n",
        "        rect.set_fill(RED, 0.1)\n",
        "        cont_word = Text(\"Contradiction!\", font_size=90)\n",
        "        cont_word.next_to(rect, UP, buff=0.5, aligned_edge=RIGHT)\n",
        "        cont_word.set_color(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            Transform(N_rect, q_rect),\n",
        "            FadeTransformPieces(factor_word, q_words),\n",
        "            FadeOut(factor_arrow),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeIn(cont_word, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def infinite(self):\n",
        "        # Interlude to show infinite\n",
        "        inf_sequence = Tex(R\"2, 3, 5, 7, 11, \\dots\", font_size=72)\n",
        "        inf_sequence.move_to(prime_sequence, LEFT)\n",
        "        inf_arrow = Vector(RIGHT)\n",
        "        inf_arrow.next_to(inf_sequence, RIGHT, SMALL_BUFF)\n",
        "        inf_words = Text(\"Infinite\", font_size=60)\n",
        "        inf_words.next_to(inf_arrow, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(inf_sequence, inf_arrow, inf_words)\n",
        "\n",
        "\n",
        "class PrimeDensityHistogram(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        max_x = 10000\n",
        "        step = 100\n",
        "        labeled_xs = list(range(1000, max_x + 1000, 1000))\n",
        "        axes = Axes(\n",
        "            (0, max_x, step),\n",
        "            (0, 0.5, 0.1),\n",
        "            width=FRAME_WIDTH - 2,\n",
        "            height=6,\n",
        "            x_axis_config=dict(\n",
        "                tick_size=0.03,\n",
        "                big_tick_numbers=labeled_xs,\n",
        "                longer_tick_multiple=3,\n",
        "            )\n",
        "        )\n",
        "        axes.x_axis.add_numbers(\n",
        "            labeled_xs,\n",
        "            font_size=16,\n",
        "            buff=0.25,\n",
        "        )\n",
        "        axes.y_axis.add_numbers(\n",
        "            np.arange(0, 0.6, 0.1),\n",
        "            num_decimal_places=2,\n",
        "        )\n",
        "\n",
        "        y_label = Text(\"\"\"\n",
        "            Proportion of primes\n",
        "            in ranges of length 1,000\n",
        "        \"\"\", font_size=36)\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, buff=0.5)\n",
        "        y_label.to_edge(UP)\n",
        "        axes.add(y_label)\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Bars\n",
        "        proportions = []\n",
        "        for n in range(0, max_x, step):\n",
        "            n_primes = len(list(sympy.primerange(n, n + step)))\n",
        "            proportions.append(n_primes / step)\n",
        "\n",
        "        bars = ChartBars(axes, proportions)\n",
        "\n",
        "        self.add(bars)\n",
        "\n",
        "\n",
        "class PrimesNearMillion(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add line\n",
        "        T = int(1e6)\n",
        "        radius = 800\n",
        "        spacing = 50\n",
        "        labeled_numbers = list(range(T - radius, T + radius, spacing))\n",
        "        number_line = NumberLine(\n",
        "            (T - radius, T + radius),\n",
        "            width=250,\n",
        "            tick_size=0.075,\n",
        "        )\n",
        "        number_line.ticks[::spacing // 5].stretch(2, 1)\n",
        "        # number_line.stretch(0.2, 0)\n",
        "        number_line.add_numbers(labeled_numbers, font_size=48, buff=0.5)\n",
        "        self.add(number_line)\n",
        "\n",
        "        # Primes\n",
        "        primes = np.array(list(sympy.primerange(T - radius, T + radius)))\n",
        "        dots = GlowDots(number_line.n2p(primes))\n",
        "        dots.set_glow_factor(2)\n",
        "        dots.set_radius(0.35)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Highlight twins\n",
        "        arcs = VGroup()\n",
        "        for p1, p2 in zip(primes, primes[1:]):\n",
        "            if p1 + 2 == p2:\n",
        "                arc = Line(\n",
        "                    number_line.n2p(p1),\n",
        "                    number_line.n2p(p2),\n",
        "                    path_arc=-PI\n",
        "                )\n",
        "                arc.set_stroke(YELLOW, 3)\n",
        "                plus_2 = Tex(\"+2\", font_size=24)\n",
        "                plus_2.set_fill(YELLOW)\n",
        "                plus_2.next_to(arc, UP, SMALL_BUFF)\n",
        "                arcs.add(arc, plus_2)\n",
        "\n",
        "        # Pan\n",
        "        line_group = Group(number_line, dots, arcs)\n",
        "        line_group.shift(1.5 * DOWN + -number_line.n2p(1e6))\n",
        "        line_group.add_updater(lambda m, dt: m.shift(2 * dt * LEFT))\n",
        "        self.add(line_group)\n",
        "\n",
        "        # Words\n",
        "        t2c = {\"T\": BLUE}\n",
        "        kw = dict(font_size=90, t2c=t2c)\n",
        "        words = TexText(\"How dense are primes?\", **kw)\n",
        "        lhs = TexText(\"Prime density near $T$\", **kw)\n",
        "        approx = Tex(R\"\\approx\", **kw)\n",
        "        approx.rotate(PI / 2)\n",
        "        rhs = Tex(R\"1 / \\ln(T)\", **kw)\n",
        "        group = VGroup(lhs, approx, rhs)\n",
        "        group.arrange(DOWN, buff=0.5)\n",
        "        group.to_edge(UP)\n",
        "        words.move_to(lhs)\n",
        "\n",
        "        example = TexText(\"(e.g. $T = 1{,}000{,}000$)\", font_size=60, t2c=t2c)\n",
        "        example.next_to(lhs, DOWN, LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            lhs[\"T\"].get_bottom(),\n",
        "            example.get_right(),\n",
        "            stroke_width=8,\n",
        "            stroke_color=BLUE,\n",
        "            path_arc=-PI / 2,\n",
        "            buff=0.2,\n",
        "        )\n",
        "\n",
        "        self.add(words)\n",
        "        self.wait(13)\n",
        "        self.play(\n",
        "            FadeTransform(words, lhs, run_time=1),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(example, time_span=(1, 2)),\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(example),\n",
        "            Write(approx),\n",
        "            FadeIn(rhs[:-2], DOWN),\n",
        "            FadeIn(rhs[-1], DOWN),\n",
        "            TransformFromCopy(lhs[\"T\"], rhs[\"T\"]),\n",
        "        )\n",
        "        self.wait(45)\n",
        "\n",
        "    def old_zooming(self):\n",
        "        sf = 0.1\n",
        "        self.play(\n",
        "            number_line.animate.scale(sf, about_point=ORIGIN),\n",
        "            dots.animate.scale(sf, about_point=ORIGIN).set_radius(0.1),\n",
        "            rate_func=rush_from,\n",
        "            run_time=17\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom in to twin prime\n",
        "        zoom_point = number_line.n2p(1000210)\n",
        "        frame = self.frame\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.move_to(zoom_point).set_height(0.60),\n",
        "            dots.animate.set_radius(0.03),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "\n",
        "class PrimePanning(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # (A bit too much copy paste from above)\n",
        "        N_max = 500\n",
        "        number_line = NumberLine(\n",
        "            (0, N_max),\n",
        "            unit_size=0.5,\n",
        "            tick_size=0.075,\n",
        "        )\n",
        "        number_line.ticks[::10].stretch(2, 1)\n",
        "        number_line.add_numbers(range(0, N_max), font_size=20, buff=0.2)\n",
        "        number_line.move_to(2 * LEFT, LEFT)\n",
        "        self.add(number_line)\n",
        "\n",
        "        # Primes\n",
        "        primes = np.array(list(sympy.primerange(0, N_max)))\n",
        "        dots = GlowDots(number_line.n2p(primes))\n",
        "        dots.set_glow_factor(2)\n",
        "        dots.set_radius(0.35)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Pan\n",
        "        frame = self.frame\n",
        "        frame.set_height(4)\n",
        "        frame.add_updater(lambda m, dt: m.shift(1.5 * dt * RIGHT))\n",
        "        self.wait(90)\n",
        "\n",
        "\n",
        "class SieveWithMod(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup prime list title\n",
        "        prime_title = Text(\"Primes: \", font_size=72)\n",
        "        prime_title.to_edge(UP)\n",
        "        prime_title.set_x(-5)\n",
        "\n",
        "        self.add(prime_title)\n",
        "\n",
        "        # Setup grid\n",
        "        row_size = 12\n",
        "        grid = Square().get_grid(20, row_size, buff=0)\n",
        "        grid.set_stroke(GREY_B, 1)\n",
        "        grid.set_width(FRAME_WIDTH - 5)\n",
        "        grid.move_to(1.65 * UP, UP)\n",
        "        labels = VGroup()\n",
        "        labeled_boxes = VGroup()\n",
        "        for n, square in enumerate(grid, start=1):\n",
        "            label = Integer(n)\n",
        "            label.set_max_width(0.5 * square.get_width())\n",
        "            label.move_to(square)\n",
        "            square.label = label\n",
        "            labels.add(label)\n",
        "            labeled_boxes.add(VGroup(square, label))\n",
        "\n",
        "        self.add(grid)\n",
        "        self.add(labels)\n",
        "\n",
        "        # Do the initial sift\n",
        "        non_primes = VGroup(\n",
        "            label for label in labels\n",
        "            if not sympy.isprime(label.get_value())\n",
        "        )\n",
        "        primes = VGroup(\n",
        "            label for label in labels\n",
        "            if sympy.isprime(label.get_value())\n",
        "        )\n",
        "        prime_list = primes.copy()\n",
        "        prime_list.scale(72 / 48)\n",
        "        prime_list.arrange(RIGHT, buff=MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "        prime_list.next_to(prime_title, RIGHT, MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "        self.play(\n",
        "            non_primes.animate.set_fill(opacity=0.25),\n",
        "            lag_ratio=0.025,\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(primes, prime_list)\n",
        "        )\n",
        "        self.play(\n",
        "            labels.animate.set_fill(opacity=1),\n",
        "            FadeOut(prime_list)\n",
        "        )\n",
        "\n",
        "        # Reduction title\n",
        "        reduction_label = Text(\"Reduce all mod\")\n",
        "        reduction_label.next_to(grid, UP, buff=MED_SMALL_BUFF, aligned_edge=LEFT)\n",
        "        reduction_label.set_fill(GREY_A)\n",
        "        reduction_label.set_fill(opacity=0)\n",
        "\n",
        "        self.add(reduction_label)\n",
        "\n",
        "        # Reduction game (this will be looped)\n",
        "        arrows = VGroup()\n",
        "        reductions = VGroup()\n",
        "        colors = color_gradient([BLUE_E, BLUE_A, RED_E], 8)\n",
        "\n",
        "        for _ in range(5):\n",
        "            # Pull out the next prime\n",
        "            prime_label = labels[1]\n",
        "            prime_value = int(prime_label.get_value())\n",
        "            highlight = SurroundingRectangle(prime_label)\n",
        "            list_prime = prime_label.copy()\n",
        "            list_prime.scale(72 / 48)\n",
        "            list_prime.next_to(prime_title, RIGHT, buff=0.35, aligned_edge=DOWN)\n",
        "            list_prime_highlight = SurroundingRectangle(list_prime)\n",
        "            comma = Text(\",\")\n",
        "            comma.next_to(list_prime.get_corner(DR), RIGHT, SMALL_BUFF)\n",
        "            reduction_prime = prime_label.copy()\n",
        "            reduction_prime.next_to(reduction_label, RIGHT, MED_SMALL_BUFF, DOWN)\n",
        "\n",
        "            rows = VGroup(\n",
        "                labeled_boxes[n:n + row_size]\n",
        "                for n in range(0, len(grid), row_size)\n",
        "            )\n",
        "            rows.target = rows.generate_target()\n",
        "            for row in rows.target:\n",
        "                row.arrange(RIGHT, buff=0)\n",
        "                row.set_width(grid.get_width())\n",
        "                row.set_max_height(rows.target[0].get_height())\n",
        "                row.align_to(rows.target[0], LEFT)\n",
        "            rows.target.arrange(DOWN, buff=1.2)\n",
        "            rows.target.move_to(grid, UP)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(highlight),\n",
        "                FadeOut(arrows),\n",
        "                FadeOut(reductions),\n",
        "            )\n",
        "            self.play(\n",
        "                TransformFromCopy(prime_label, list_prime),\n",
        "                FadeIn(comma, UP),\n",
        "                TransformFromCopy(highlight, list_prime_highlight),\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(list_prime_highlight),\n",
        "                FadeOut(highlight),\n",
        "                TransformFromCopy(list_prime, reduction_prime),\n",
        "                reduction_label.animate.set_opacity(1),\n",
        "                MoveToTarget(rows),\n",
        "            )\n",
        "            prime_title.add(list_prime)\n",
        "\n",
        "            # Add reductions\n",
        "            arrows = VGroup()\n",
        "            reductions = VGroup()\n",
        "            for label, box in zip(labels, grid):\n",
        "                reduction = Integer(label.get_value() % prime_value)\n",
        "                reduction.next_to(box, DOWN, buff=MED_LARGE_BUFF)\n",
        "                reductions.add(reduction)\n",
        "                color = YELLOW if label.get_value() % prime_value == 0 else BLUE\n",
        "                arrow = Arrow(\n",
        "                    label, reduction,\n",
        "                    buff=0.15,\n",
        "                    max_tip_length_to_length_ratio=0.4,\n",
        "                    stroke_width=3,\n",
        "                    stroke_color=GREY_A,\n",
        "                )\n",
        "                arrows.add(arrow)\n",
        "                rect = SurroundingRectangle(reduction)\n",
        "                rect.set_stroke(color, width=1)\n",
        "                reduction.add(rect)\n",
        "\n",
        "            for n, arrow, reduction in zip(it.count(), arrows, reductions):\n",
        "                self.add(arrow, reduction)\n",
        "                if n < 36:\n",
        "                    self.wait(0.2 * (1 + (n % 2)))\n",
        "\n",
        "            # Kill the zeros\n",
        "            killed_indices = [\n",
        "                n\n",
        "                for n, label in enumerate(labels)\n",
        "                if label.get_value() % prime_value == 0\n",
        "            ]\n",
        "            self.play(\n",
        "                *(\n",
        "                    LaggedStartMap(FadeOut, VGroup(group[n] for n in killed_indices), shift=0.1 * DOWN, lag_ratio=0.1)\n",
        "                    for group in [labeled_boxes, arrows, reductions]\n",
        "                ),\n",
        "                FadeOut(reduction_prime)\n",
        "            )\n",
        "\n",
        "            for group in [labeled_boxes, grid, labels, arrows, reductions]:\n",
        "                to_remove = [group[n] for n in killed_indices]\n",
        "                group.remove(*to_remove)\n",
        "\n",
        "\n",
        "class DensityFormula(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Formula\n",
        "        t2c = {\n",
        "            \"T\": BLUE,\n",
        "        }\n",
        "        kw = dict(t2c=t2c, font_size=90)\n",
        "        lhs = TexText(\"Prime density near $T$\", **kw)\n",
        "        approx = Tex(R\"\\approx\", **kw)\n",
        "        approx.rotate(PI / 2)\n",
        "        rhs = Tex(R\"1 / \\ln(T)\", **kw)\n",
        "        group = VGroup(lhs, approx, rhs)\n",
        "        group.arrange(DOWN, buff=0.5)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        example = TexText(\"(e.g. $T = 1{,}000{,}000$)\", font_size=60, t2c=t2c)\n",
        "        example.next_to(lhs, DOWN, LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            lhs[\"T\"].get_bottom(),\n",
        "            example.get_right(),\n",
        "            stroke_width=8,\n",
        "            stroke_color=BLUE,\n",
        "            path_arc=-PI / 2,\n",
        "            buff=0.2,\n",
        "        )\n",
        "\n",
        "        self.add(lhs, example, arrow)\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(example, arrow)\n",
        "        self.add(approx, rhs)\n",
        "\n",
        "    def old_mess(self):\n",
        "        # Formula\n",
        "        kw = dict(t2c={\n",
        "            \"T\": BLUE,\n",
        "            \"1{,}000{,}000\": BLUE,\n",
        "        })\n",
        "        lhs = TexText(\"What's the density of primes near $T$\", **kw)\n",
        "        rhs = Tex(R\"\\approx \\frac{1}{\\ln(T)}\", **kw)\n",
        "        group = VGroup(lhs, rhs)\n",
        "        group.arrange(RIGHT)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        q_mark = Text(\"?\")\n",
        "        q_mark.next_to(lhs, RIGHT, buff=0.1)\n",
        "        q_mark.align_to(lhs[0], DOWN)\n",
        "        lhs_note = TexText(\n",
        "            \"(Some big number, e.g. $T = 1{,}000{,}000$)\",\n",
        "            font_size=36,\n",
        "            **kw\n",
        "        )\n",
        "        lhs_note.next_to(lhs, DR, buff=LARGE_BUFF)\n",
        "        lhs_note.shift_onto_screen()\n",
        "        arrow = Arrow(lhs_note.get_top(), lhs[\"T\"], buff=0.1)\n",
        "        arrow.set_color(BLUE)\n",
        "\n",
        "        self.add(lhs)\n",
        "        self.add(q_mark, lhs_note, arrow)\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(q_mark, lhs_note, arrow)\n",
        "        self.remove(lhs[\"What's the\"])\n",
        "        self.add(rhs)\n",
        "\n",
        "\n",
        "class OldGapsInPrimes(InteractiveScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class NewGapsInPrimes(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show number line\n",
        "        x_min = 99980\n",
        "        x_max = 100100\n",
        "        line = NumberLine(\n",
        "            x_range=(x_min, x_max),\n",
        "            width=0.5 * (x_max - x_min)\n",
        "        )\n",
        "        line.to_edge(LEFT).shift(2 * LEFT)\n",
        "        line.set_y(1)\n",
        "        \n",
        "        primes = [n for n in range(x_min, x_max) if sympy.isprime(n)]\n",
        "        labels = line.add_numbers(primes, font_size=48)\n",
        "        lc = labels[:2].get_center()\n",
        "        labels[:2].arrange(RIGHT, buff=0.5).move_to(lc)\n",
        "        dots = GlowDots([line.n2p(p) for p in primes])\n",
        "\n",
        "        self.add(line)\n",
        "        self.add(dots)\n",
        "\n",
        "        # Pan over\n",
        "        center_label = labels[-2]\n",
        "        self.play(\n",
        "            self.frame.animate.match_x(center_label).set_height(11),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        # Label it\n",
        "        prime_label = TexText(R\"Big prime, $p$\", font_size=96)\n",
        "        prime_label.set_color(YELLOW)\n",
        "        prime_label.next_to(center_label.get_corner(DL), DOWN, 1.5, aligned_edge=RIGHT)\n",
        "        arrow = Arrow(\n",
        "            prime_label[-1].get_top(), center_label.get_bottom(),\n",
        "            buff=0.25,\n",
        "        )\n",
        "        arrow.set_stroke(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(prime_label),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the gap\n",
        "        brace = Brace(Line(*dots.get_points()[-2:]), UP)\n",
        "        gap_label = Text(\"gap\", font_size=72)\n",
        "        gap_label.next_to(brace, UP)\n",
        "        self.play(\n",
        "            GrowFromPoint(brace, brace.get_left()),\n",
        "            FadeIn(gap_label, 2 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Expected gap size\n",
        "        eq = TexText(R\"E[gap] = $\\ln(p)$\", font_size=96)\n",
        "        eq[\"p\"][-1].set_color(YELLOW)\n",
        "        eq.next_to(self.frame.get_top(), DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(eq[\"E[\"]),\n",
        "            FadeIn(eq[\"] = \"]),\n",
        "            FadeIn(eq[R\"\\ln(\"]),\n",
        "            FadeIn(eq[R\")\"]),\n",
        "            FadeTransform(gap_label.copy(), eq[\"gap\"][0]),\n",
        "            FadeTransform(prime_label[-1].copy(), eq[\"p\"][-1]),\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CrankEmail(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        rect = FullScreenRectangle(fill_color=WHITE, fill_opacity=1)\n",
        "        rect.scale(2)\n",
        "        rect.stretch(10, 1, about_edge=UP)\n",
        "        self.add(rect)\n",
        "\n",
        "        frame = self.frame\n",
        "        frame.set_height(9)\n",
        "        frame.to_edge(UP, buff=0)\n",
        "\n",
        "        # Rows of numbers\n",
        "        numbers1 = list(range(1, 100))\n",
        "        numbers2 = list(filter(lambda m: m % 2 != 0, numbers1))\n",
        "        numbers3 = list(filter(lambda m: m % 3 != 0, numbers2))\n",
        "\n",
        "        arrays = VGroup(\n",
        "            self.create_array(numbers1[:30], 2, BLUE_D),\n",
        "            self.create_array(numbers2[:30], 3, GREEN_D),\n",
        "            self.create_array(numbers3[:20], 5, RED_D),\n",
        "        )\n",
        "\n",
        "        arrays.arrange(DOWN, buff=1.0, aligned_edge=LEFT)\n",
        "        arrays.to_corner(UL)\n",
        "\n",
        "        # Paragraphs\n",
        "        kw = dict(alignment=\"LEFT\", font_size=48, fill_color=BLACK, font=\"Roboto\")\n",
        "        paragraphs = VGroup(\n",
        "            Text(\"\"\"\n",
        "                Dear sir,\n",
        "\n",
        "                I have proven the twin prime conjecture.\n",
        "\n",
        "                I study an elegant proof of prime generation:\n",
        "                List all natural numbers, and start by\n",
        "                reducing each of them modulo 2:\n",
        "            \"\"\", **kw),\n",
        "            arrays[0],\n",
        "            Text(\"\"\"\n",
        "                Remove numbers which have reduced\n",
        "                to 0, reduce what remains modulo 3:\n",
        "            \"\"\", **kw),\n",
        "            arrays[1],\n",
        "            Text(\"\"\"\n",
        "                Again, remove numbers which have reduced\n",
        "                to 0, reduce what remains modulo 5:\n",
        "            \"\"\", **kw),\n",
        "            arrays[2],\n",
        "        )\n",
        "\n",
        "        paragraphs.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        paragraphs.shift(paragraphs[0].get_x() * LEFT)\n",
        "        paragraphs.to_edge(UP, buff=0.2)\n",
        "\n",
        "        self.add(paragraphs)\n",
        "        for array in arrays:\n",
        "            for grid in array:\n",
        "                self.remove(grid[1])\n",
        "\n",
        "        # Fill in grid, slide frame\n",
        "        self.anticipate_frame_to_y(-5, run_time=3)\n",
        "        for grid in arrays[0]:\n",
        "            self.animate_reduction(grid)\n",
        "\n",
        "        self.cross_out_the_zeros(arrays[0])\n",
        "        self.wait(0.5)\n",
        "        self.play(frame.animate.set_y(-11))\n",
        "\n",
        "        for n, grid in enumerate(arrays[1]):\n",
        "            self.animate_reduction(grid)\n",
        "            if n == 0:\n",
        "                self.anticipate_frame_to_y(-15, run_time=2)\n",
        "\n",
        "        self.anticipate_frame_to_y(-22, run_time=2)\n",
        "        self.cross_out_the_zeros(arrays[1])\n",
        "        self.wait(2)\n",
        "\n",
        "        for grid in arrays[2]:\n",
        "            self.animate_reduction(grid)\n",
        "        self.cross_out_the_zeros(arrays[2])\n",
        "\n",
        "    def create_array(\n",
        "        self,\n",
        "        numbers,\n",
        "        modulus,\n",
        "        color=BLUE,\n",
        "        height=0.85,\n",
        "        spacing=10,\n",
        "        buff=0.75,\n",
        "        width=10,\n",
        "    ):\n",
        "        result = VGroup()\n",
        "        row1_content = numbers\n",
        "        row2_content = [n % modulus for n in numbers]\n",
        "        row1_title = \"Numbers: \"\n",
        "        row2_title = f\"Mod {modulus}:\"\n",
        "        n = 0\n",
        "        while n < len(row1_content):\n",
        "            result.add(self.create_table(\n",
        "                row1_title, row2_title,\n",
        "                row1_content[n:n + spacing],\n",
        "                row2_content[n:n + spacing],\n",
        "                color=color,\n",
        "                height=height,\n",
        "            ))\n",
        "            n += spacing\n",
        "            row1_title = \"\"\n",
        "            row2_title = \"\"\n",
        "        result.arrange(DOWN, buff=buff, aligned_edge=RIGHT)\n",
        "        result.set_width(width)\n",
        "        return result\n",
        "\n",
        "    def create_table(\n",
        "        self,\n",
        "        row1_title,\n",
        "        row2_title,\n",
        "        row1_content,\n",
        "        row2_content,\n",
        "        x_spacing=0.6,\n",
        "        font_size=36,\n",
        "        color=BLUE,\n",
        "        height=0.85\n",
        "    ):\n",
        "        # Numbers\n",
        "        row1_mobs, row2_mobs = (\n",
        "            VGroup(*(\n",
        "                Integer(n, font_size=font_size)\n",
        "                for n in content\n",
        "            ))\n",
        "            for content in [row1_content, row2_content]\n",
        "        )\n",
        "        for x, mob in enumerate(row1_mobs):\n",
        "            mob.set_x(x_spacing * x)\n",
        "        row1_mobs.to_edge(LEFT)\n",
        "        row1_mobs.set_fill(BLACK)\n",
        "\n",
        "        row2_mobs.set_color(color)\n",
        "        for m1, m2 in zip(row1_mobs, row2_mobs):\n",
        "            m2.set_max_width(0.5 * x_spacing)\n",
        "            m2.next_to(m1, DOWN, 0.5)\n",
        "\n",
        "        grid = VGroup(row1_mobs, row2_mobs)\n",
        "\n",
        "        # Titles\n",
        "        row1_label = Text(row1_title, font_size=font_size)\n",
        "        row2_label = Text(row2_title, font_size=font_size)\n",
        "        row1_label.set_color(BLACK)\n",
        "        row1_label.next_to(row1_mobs, LEFT, buff=0.5)\n",
        "        row2_label.next_to(row2_mobs, LEFT, buff=0.5)\n",
        "        row2_label.set_color(color)\n",
        "        grid.add(row1_label, row2_label)\n",
        "\n",
        "        # Grid lines\n",
        "        h_line = Line(ORIGIN, grid.get_width() * RIGHT)\n",
        "        h_line.move_to(grid, LEFT)\n",
        "        v_lines = VGroup(*(\n",
        "            Line(grid.get_height() * UP, ORIGIN).set_x(\n",
        "                0.5 * (row1_mobs[i].get_right()[0] + row1_mobs[i + 1].get_left()[0])\n",
        "            ).align_to(grid, UP)\n",
        "            for i in range(len(row1_mobs) - 1)\n",
        "        ))\n",
        "        v_lines.set_stroke(BLACK, width=1)\n",
        "        h_line.set_stroke(BLACK, width=1)\n",
        "\n",
        "        grid.add(h_line, v_lines)\n",
        "        grid.set_height(height, about_edge=LEFT)\n",
        "\n",
        "        return grid\n",
        "\n",
        "    def animate_reduction(self, array, beat_time=0.17):\n",
        "        reductions = array[1]\n",
        "        self.remove(reductions)\n",
        "        self.wait(0.1)\n",
        "        for i, term in enumerate(reductions):\n",
        "            self.add(term)\n",
        "            self.wait(beat_time)\n",
        "            m10 = i % 10\n",
        "            if m10 % 2 == 1:\n",
        "                self.wait(beat_time)\n",
        "            if m10 == 9:\n",
        "                self.wait(beat_time)\n",
        "        self.add(array)\n",
        "\n",
        "    def cross_out_the_zeros(self, array):\n",
        "        crosses = VGroup()\n",
        "        rects = VGroup()\n",
        "        for grid in array:\n",
        "            for m1, m2 in zip(grid[0], grid[1]):\n",
        "                if m2.get_value() == 0:\n",
        "                    crosses.add(Cross(m1).scale(1.5))\n",
        "                    rect = SurroundingRectangle(VGroup(m1, m2))\n",
        "                    rect.set_fill(RED, 0.2)\n",
        "                    rect.set_stroke(width=0)\n",
        "                    rects.add(rect)\n",
        "        self.play(\n",
        "            ShowCreation(crosses, lag_ratio=0),\n",
        "            FadeIn(rects, lag_ratio=0.1)\n",
        "        )\n",
        "\n",
        "    def anticipate_frame_to_y(self, y, run_time=3):\n",
        "        turn_animation_into_updater(\n",
        "            ApplyMethod(self.frame.set_y, y, run_time=run_time)\n",
        "        )\n",
        "\n",
        "\n",
        "class SieveOfEratosthenes(InteractiveScene):\n",
        "    grid_shape = (10, 10)\n",
        "    n_iterations = 10\n",
        "    rect_buff = 0.1\n",
        "\n",
        "    def construct(self):\n",
        "        # Initialize grid\n",
        "        grid = Square().get_grid(*self.grid_shape, buff=0)\n",
        "        grid.set_height(FRAME_HEIGHT - 1)\n",
        "        grid.set_stroke(width=1)\n",
        "        number_mobs = self.get_number_mobs(grid)\n",
        "        number_mobs[0].set_opacity(0)\n",
        "\n",
        "        self.add(grid, number_mobs)\n",
        "\n",
        "        # Run the sieve\n",
        "        modulus = 2\n",
        "        numbers = list(range(2, len(grid) + 1))\n",
        "        for n in range(self.n_iterations):\n",
        "            numbers = list(filter(lambda n: n % modulus != 0, numbers))\n",
        "            to_remove = VGroup(*(\n",
        "                mob\n",
        "                for mob in number_mobs\n",
        "                if mob.get_value() % modulus == 0\n",
        "            ))\n",
        "            rects = VGroup(*(\n",
        "                SurroundingRectangle(tr, buff=self.rect_buff)\n",
        "                for tr in to_remove\n",
        "                if tr.get_fill_opacity() > 0.5\n",
        "            ))\n",
        "            rects.set_stroke(RED, 1)\n",
        "\n",
        "            self.play(\n",
        "                to_remove.animate.set_color(RED),\n",
        "                Write(rects, stroke_color=RED, stroke_width=2),\n",
        "                lag_ratio=0.1,\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                to_remove[0].animate.set_color(WHITE),\n",
        "                to_remove[1:].animate.set_opacity(0),\n",
        "                number_mobs[0].animate.set_opacity(0),\n",
        "                FadeOut(rects)\n",
        "            )\n",
        "            modulus = numbers[0]\n",
        "\n",
        "    def get_number_mobs(self, grid):\n",
        "        return VGroup(*(\n",
        "            Integer(i).set_height(0.3 * box.get_height()).move_to(box)\n",
        "            for i, box in zip(it.count(1), grid)\n",
        "        ))\n",
        "\n",
        "\n",
        "class GiantSieve(SieveOfEratosthenes):\n",
        "    grid_shape = (25, 25)\n",
        "    n_iterations = 30\n",
        "    rect_buff = 0.02\n",
        "\n",
        "    # def get_number_mobs(self, grid):\n",
        "    #     radius = grid[0].get_width() / 4\n",
        "    #     return VGroup(*(\n",
        "    #         Dot(radius=radius).move_to(box)\n",
        "    #         for box in grid\n",
        "    #     ))\n",
        "\n",
        "\n",
        "class WannaProve(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        randy = Randolph()\n",
        "        morty = Mortimer()\n",
        "        VGroup(randy, morty).to_edge(DOWN)\n",
        "        randy.set_x(-3)\n",
        "        morty.set_x(3)\n",
        "        morty.make_eye_contact(randy)\n",
        "\n",
        "        self.play(\n",
        "            randy.says(\"Twin primes\\nare infinite!\", mode=\"hooray\"),\n",
        "            morty.change(\"concentrating\")\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(randy.bubble),\n",
        "            randy.change(\"pondering\", look_at=3 * UP),\n",
        "            morty.change(\"raise_right_hand\", look_at=3 * UP)\n",
        "        )\n",
        "\n",
        "        # Hold up picture\n"
    ]
}