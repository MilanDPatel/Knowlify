{
    "topic": "The mathematical concept being demonstrated is the SHA-256 hash function and its output in",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from hashlib import sha256\n",
        "import binascii\n",
        "\n",
        "#force_skipping\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "BITCOIN_COLOR = \"#f7931a\"\n",
        "\n",
        "def get_cursive_name(name):\n",
        "    result = OldTexText(\"\\\\normalfont\\\\calligra %s\"%name)\n",
        "    result.set_stroke(width = 0.5)\n",
        "    return result\n",
        "\n",
        "def sha256_bit_string(message):\n",
        "    hexdigest = sha256(message.encode('utf-8')).hexdigest()\n",
        "    return bin(int(hexdigest, 16))[2:]\n",
        "\n",
        "def bit_string_to_mobject(bit_string):\n",
        "    line = OldTex(\"0\"*32)\n",
        "    pre_result = VGroup(*[\n",
        "        line.copy() for row in range(8)\n",
        "    ])\n",
        "    pre_result.arrange(DOWN, buff = SMALL_BUFF)\n",
        "    result = VGroup(*it.chain(*pre_result))\n",
        "    result.scale(0.7)\n",
        "    bit_string = (256 - len(bit_string))*\"0\" + bit_string\n",
        "\n",
        "    for i, (bit, part) in enumerate(zip(bit_string, result)):\n",
        "        if bit == \"1\":\n",
        "            one = OldTex(\"1\")[0]\n",
        "            one.replace(part, dim_to_match = 1)\n",
        "            result.submobjects[i] = one\n",
        "\n",
        "    return result\n",
        "\n",
        "def sha256_tex_mob(message, n_forced_start_zeros = 0):\n",
        "    true_bit_string = sha256_bit_string(message)\n",
        "    n = n_forced_start_zeros\n",
        "    bit_string = \"0\"*n + true_bit_string[n:]\n",
        "    return bit_string_to_mobject(bit_string)\n",
        "\n",
        "class EthereumLogo(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"ethereum_logo\",\n",
        "        \"stroke_width\" : 0,\n",
        "        \"fill_opacity\" : 1,\n",
        "        \"color_chars\" : \"8B8B48\",\n",
        "        \"height\" : 0.5,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        SVGMobject.__init__(self, **kwargs)\n",
        "        for part, char in zip(self.submobjects, self.color_chars):\n",
        "            part.set_color(\"#\" + 6*char)\n",
        "\n",
        "class LitecoinLogo(SVGMobject):\n",
        "    CONFIG = {\n",
        "        \"file_name\" : \"litecoin_logo\",\n",
        "        \"stroke_width\" : 0,\n",
        "        \"fill_opacity\" : 1,\n",
        "        \"fill_color\" : GREY_B,\n",
        "        \"height\" : 0.5,\n",
        "    }\n",
        "\n",
        "class TenDollarBill(VGroup):\n",
        "    CONFIG = {\n",
        "        \"color\" : GREEN,\n",
        "        \"height\" : 0.5,\n",
        "        \"mark_paths_closed\" : False,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        rect = Rectangle(\n",
        "            height = 2.61,\n",
        "            width = 6.14,\n",
        "            color = self.color,\n",
        "            mark_paths_closed = False,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        rect.set_height(self.height)\n",
        "        oval = Circle()\n",
        "        oval.stretch_to_fit_height(0.7*self.height)\n",
        "        oval.stretch_to_fit_width(0.4*self.height)\n",
        "        rect.add_subpath(oval.get_points())\n",
        "\n",
        "        pi = Randolph(\n",
        "            mode = \"pondering\",\n",
        "            color = GREEN_B\n",
        "        )\n",
        "        pi.set_width(oval.get_width())\n",
        "        pi.move_to(oval)\n",
        "        pi.shift(0.1*pi.get_height()*DOWN)\n",
        "\n",
        "        self.add(pi, rect)\n",
        "        for vect in UP+LEFT, DOWN+RIGHT:\n",
        "            ten = OldTex(\"\\\\$10\")\n",
        "            ten.set_height(0.25*self.height)\n",
        "            ten.next_to(self.get_corner(vect), -vect, SMALL_BUFF)\n",
        "            ten.set_color(GREEN_C)\n",
        "            self.add(ten)\n",
        "\n",
        "\n",
        "##################\n",
        "\n",
        "class AskQuestion(Scene):\n",
        "    CONFIG = {\n",
        "        \"time_per_char\" : 0.06,\n",
        "    }\n",
        "    def construct(self):\n",
        "        strings = [\n",
        "            \"What\", \"does\", \"it\", \"mean   \", \"to\", \n",
        "            \"have    \", \"a\", \"Bitcoin?\"\n",
        "        ]\n",
        "        question = OldTexText(*strings)\n",
        "        question.set_color_by_tex(\"have\", YELLOW)\n",
        "        self.wait()\n",
        "        for word, part in zip(strings, question):\n",
        "            n_chars = len(word.strip())\n",
        "            n_spaces = len(word) - n_chars\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeIn, part),\n",
        "                run_time = self.time_per_char * len(word),\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "            )\n",
        "            self.wait(self.time_per_char*n_spaces)\n",
        "        self.wait(2)\n",
        "\n",
        "class ListOfAttributes(Scene):\n",
        "    def construct(self):\n",
        "        logo = BitcoinLogo()\n",
        "\n",
        "        digital = OldTexText(\"Digital\")\n",
        "        government, bank = buildings = [\n",
        "            SVGMobject(\n",
        "                file_name = \"%s_building\"%word,\n",
        "                height = 2,\n",
        "                fill_color = GREY_B,\n",
        "                fill_opacity = 1,\n",
        "                stroke_width = 0,\n",
        "            )\n",
        "            for word in (\"government\", \"bank\")\n",
        "        ]\n",
        "        attributes = VGroup(digital, *buildings)\n",
        "        attributes.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        for building in buildings:\n",
        "            building.cross = Cross(building)\n",
        "            building.cross.set_stroke(width = 12)\n",
        "\n",
        "        self.play(DrawBorderThenFill(logo))\n",
        "        self.play(\n",
        "            logo.to_corner, UP+LEFT,\n",
        "            Write(digital, run_time = 2)\n",
        "        )\n",
        "        for building in buildings:\n",
        "            self.play(FadeIn(building))\n",
        "            self.play(ShowCreation(building.cross))\n",
        "        self.wait()\n",
        "\n",
        "class UnknownAuthor(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\" : {\n",
        "            \"background_image\" : \"bitcoin_paper\"\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 0.4, width = 2.5)\n",
        "        rect.shift(2.45*UP)\n",
        "        question = OldTexText(\"Who is this?\")\n",
        "        question.next_to(rect, RIGHT, buff = 1.5)\n",
        "        arrow = Arrow(question, rect, buff = SMALL_BUFF)\n",
        "        VGroup(question, arrow, rect).set_color(RED_D)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class DisectQuestion(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.hold_up_question()\n",
        "        self.list_topics()\n",
        "        self.isolate_you()\n",
        "\n",
        "    def hold_up_question(self):\n",
        "        question = OldTexText(\n",
        "            \"What does it mean to\", \"have\", \"a\", \"Bitcoin?\"\n",
        "        )\n",
        "        question.set_color_by_tex(\"have\", YELLOW)\n",
        "        question.next_to(self.teacher, UP)\n",
        "        question.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        question.save_state()\n",
        "        question.shift(DOWN)\n",
        "        question.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            question.restore\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "        self.bitcoin_word = question.get_part_by_tex(\"Bitcoin\")\n",
        "\n",
        "    def list_topics(self):\n",
        "        topics = OldTexText(\n",
        "            \"Digital signatures, \",\n",
        "            \"Proof of work, \",\n",
        "            \"Cryptographic hash functions, \\\\dots\"\n",
        "        )\n",
        "        topics.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        topics.to_edge(UP)\n",
        "        topics.set_color_by_tex(\"Digital\", BLUE)\n",
        "        topics.set_color_by_tex(\"Proof\", GREEN)\n",
        "        topics.set_color_by_tex(\"hash\", YELLOW)\n",
        "\n",
        "        for word in topics:\n",
        "            anims = [Write(word, run_time = 1)]\n",
        "            self.play_student_changes(\n",
        "                *[\"confused\"]*3,\n",
        "                added_anims = anims,\n",
        "                look_at = word\n",
        "            )\n",
        "\n",
        "    def isolate_you(self):\n",
        "        self.pi_creatures = VGroup()\n",
        "        you = self.students[1]\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        words = OldTexText(\"Invent your own\")\n",
        "        arrow = Arrow(UP, DOWN)\n",
        "        arrow.next_to(you, UP)\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(FadeIn(rect), Animation(you))\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow),\n",
        "            you.change, \"erm\", words\n",
        "        )\n",
        "        self.play(Blink(you))\n",
        "        self.wait()\n",
        "\n",
        "class CryptocurrencyEquation(Scene):\n",
        "    def construct(self):\n",
        "        parts = OldTexText(\n",
        "            \"Ledger\", \n",
        "            \"- Trust\",\n",
        "            \"+ Cryptography\",\n",
        "            \"= Cryptocurrency\"\n",
        "        )\n",
        "        VGroup(*parts[-1][1:]).set_color(YELLOW)\n",
        "        parts.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "\n",
        "        for part in parts:\n",
        "            self.play(FadeIn(part))\n",
        "            self.wait(2)\n",
        "\n",
        "class CryptocurrencyMarketCaps(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ListRecentCurrencies(Scene):\n",
        "    def construct(self):\n",
        "        footnote = OldTexText(\"$^*$Listed by market cap\")\n",
        "        footnote.scale(0.5)\n",
        "        footnote.to_corner(DOWN+RIGHT)\n",
        "        self.add(footnote)\n",
        "\n",
        "        logos = VGroup(\n",
        "            BitcoinLogo(),\n",
        "            EthereumLogo(),\n",
        "            ImageMobject(\"ripple_logo\"),\n",
        "            LitecoinLogo(),\n",
        "            EthereumLogo().set_color_by_gradient(GREEN_B, GREEN_D),\n",
        "        )\n",
        "        for logo in logos:\n",
        "            logo.set_height(0.75)\n",
        "        logos.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        logos.shift(LEFT)\n",
        "        logos.to_edge(UP)\n",
        "        names = list(map(\n",
        "            TexText, \n",
        "            [\n",
        "                \"Bitcoin\", \"Ethereum\", \"Ripple\", \n",
        "                \"Litecoin\", \"Ethereum Classic\"\n",
        "            ],\n",
        "        ))\n",
        "        for logo, name in zip(logos, names):\n",
        "            name.next_to(logo, RIGHT)\n",
        "            anims = []\n",
        "            if isinstance(logo, SVGMobject):\n",
        "                anims.append(DrawBorderThenFill(logo, run_time = 1))\n",
        "            else:\n",
        "                anims.append(FadeIn(logo))\n",
        "            anims.append(Write(name, run_time = 2))\n",
        "            self.play(*anims)\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(logos, DOWN)\n",
        "        self.play(LaggedStartMap(FadeIn, dots, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "class Hype(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher.change_mode(\"guilty\")\n",
        "        phrases = list(map(TexText, [\n",
        "            \"I want some!\",\n",
        "            \"I'll get rich, right?\",\n",
        "            \"Buy them all!\"\n",
        "        ]))\n",
        "        modes = [\"hooray\", \"conniving\", \"surprised\"]\n",
        "        for student, phrase, mode in zip(self.students, phrases, modes):\n",
        "            bubble = SpeechBubble()\n",
        "            bubble.set_fill(BLACK, 1)\n",
        "            bubble.add_content(phrase)\n",
        "            bubble.resize_to_content()\n",
        "            bubble.pin_to(student)\n",
        "            bubble.add(phrase)\n",
        "            self.play(\n",
        "                student.change_mode, mode,\n",
        "                FadeIn(bubble),\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "class NoCommentOnSpeculation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        axes = VGroup(\n",
        "            Line(0.25*LEFT, 4*RIGHT),\n",
        "            Line(0.25*DOWN, 3*UP),\n",
        "        )\n",
        "        times = np.arange(0, 4.25, 0.25)\n",
        "        prices = [\n",
        "            0.1, 0.5, 1.75, 1.5,\n",
        "            2.75, 2.2, 1.3, 0.8,\n",
        "            1.1, 1.3, 1.2, 1.4,\n",
        "            1.5, 1.7, 1.2, 1.3,\n",
        "        ]\n",
        "        graph = VMobject()\n",
        "        graph.set_points_as_corners([\n",
        "            time*RIGHT + price*UP\n",
        "            for time, price in zip(times, prices)\n",
        "        ])\n",
        "        graph.set_stroke(BLUE)\n",
        "        group = VGroup(axes, graph)\n",
        "        group.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        cross = Cross(group)\n",
        "\n",
        "        mining_graphic = ImageMobject(\"bitcoin_mining_graphic\")\n",
        "        mining_graphic.set_height(2)\n",
        "        mining_graphic.next_to(self.teacher, UP+LEFT)\n",
        "        mining_cross = Cross(mining_graphic)\n",
        "        mining_cross.set_stroke(RED, 8)\n",
        "\n",
        "        axes.save_state()\n",
        "        axes.shift(DOWN)\n",
        "        axes.fade(1)\n",
        "        self.play(\n",
        "            self.teacher.change, \"sassy\",\n",
        "            axes.restore,\n",
        "        )\n",
        "        self.play(ShowCreation(\n",
        "            graph, run_time = 2,\n",
        "            rate_func=linear\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        group.add(cross)\n",
        "        self.play(\n",
        "            group.shift, FRAME_WIDTH*RIGHT,\n",
        "            self.teacher.change, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.student_says(\n",
        "            \"But...what are they?\",\n",
        "            index = 0,\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeIn(mining_graphic),\n",
        "            RemovePiCreatureBubble(self.students[0]),\n",
        "            self.teacher.change, \"sassy\",\n",
        "        )\n",
        "        self.play(ShowCreation(mining_cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(mining_graphic, mining_cross).shift,\n",
        "            FRAME_WIDTH*RIGHT\n",
        "        )\n",
        "        black_words = OldTexText(\"Random words\\\\\\\\Blah blah\")\n",
        "        black_words.set_color(BLACK)\n",
        "        self.teacher_thinks(black_words)\n",
        "        self.zoom_in_on_thought_bubble()\n",
        "\n",
        "class MiningIsALotteryCopy(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class LedgerScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"ledger_width\" : 6,\n",
        "        \"ledger_height\" : 7,\n",
        "        \"denomination\" : \"USD\",\n",
        "        \"ledger_line_height\" : 0.4,\n",
        "        \"sign_transactions\" : False,\n",
        "        \"enumerate_lines\" : False,\n",
        "        \"line_number_color\" : YELLOW,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.remove(self.pi_creatures)\n",
        "\n",
        "    def add_ledger_and_network(self):\n",
        "        self.add(self.get_ledger(), self.get_network())\n",
        "\n",
        "    def get_ledger(self):\n",
        "        title = OldTexText(\"Ledger\")\n",
        "        rect = Rectangle(\n",
        "            width = self.ledger_width, \n",
        "            height = self.ledger_height\n",
        "        )\n",
        "        title.next_to(rect.get_top(), DOWN)\n",
        "        h_line = Line(rect.get_left(), rect.get_right())\n",
        "        h_line.scale(0.8)\n",
        "        h_line.set_stroke(width = 2)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        content = VGroup(h_line)\n",
        "\n",
        "        self.ledger = VGroup(rect, title, content)\n",
        "        self.ledger.content = content\n",
        "        self.ledger.to_corner(UP+LEFT)\n",
        "        return self.ledger\n",
        "\n",
        "    def add_line_to_ledger(self, string_or_mob):\n",
        "        if isinstance(string_or_mob, str):\n",
        "            mob = OldTexText(string_or_mob)\n",
        "        elif isinstance(string_or_mob, Mobject):\n",
        "            mob = string_or_mob\n",
        "        else:\n",
        "            raise Exception(\"Invalid input\")\n",
        "\n",
        "        items = self.ledger.content\n",
        "\n",
        "        mob.set_height(self.ledger_line_height)\n",
        "        if self.enumerate_lines:\n",
        "            num = OldTex(str(len(items)) + \".\")\n",
        "            num.scale(0.8)\n",
        "            num.set_color(self.line_number_color)\n",
        "            num.next_to(mob, LEFT, MED_SMALL_BUFF)\n",
        "            mob.add_to_back(num)\n",
        "        mob.next_to(\n",
        "            items[-1], DOWN, \n",
        "            buff = MED_SMALL_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        if self.enumerate_lines and len(items) == 1:\n",
        "            mob.shift(MED_LARGE_BUFF * LEFT)\n",
        "        items.add(mob)\n",
        "        return mob\n",
        "\n",
        "    def add_payment_line_to_ledger(self, from_name, to_name, amount):\n",
        "        amount_str = str(amount)\n",
        "        if self.denomination == \"USD\":\n",
        "            amount_str = \"\\\\$\" + amount_str\n",
        "        else:\n",
        "            amount_str += \" \" + self.denomination\n",
        "        line_tex_parts = [\n",
        "            from_name.capitalize(), \n",
        "            \"pays\" if from_name.lower() != \"you\" else \"pay\",\n",
        "            to_name.capitalize(),\n",
        "            amount_str,\n",
        "        ]\n",
        "        if self.sign_transactions:\n",
        "            line_tex_parts.append(self.get_signature_tex())\n",
        "        line = OldTexText(*line_tex_parts)\n",
        "        for name in from_name, to_name:\n",
        "            color = self.get_color_from_name(name)\n",
        "            line.set_color_by_tex(name.capitalize(), color)\n",
        "        if self.sign_transactions:\n",
        "            from_part = line.get_part_by_tex(from_name.capitalize())\n",
        "            line[-1].set_color(from_part.get_color())\n",
        "\n",
        "        amount_color = {\n",
        "            \"USD\" : GREEN,\n",
        "            \"BTC\" : YELLOW,\n",
        "            \"LD\" : YELLOW,\n",
        "        }.get(self.denomination, WHITE)\n",
        "        line.set_color_by_tex(amount_str, amount_color)\n",
        "\n",
        "        return self.add_line_to_ledger(line)\n",
        "\n",
        "    def get_color_from_name(self, name):\n",
        "        if hasattr(self, name.lower()):\n",
        "            creature = getattr(self, name.lower())\n",
        "            color = creature.get_color()\n",
        "            if np.mean(color.get_rgb()) < 0.5:\n",
        "                color = average_color(color, color, WHITE)\n",
        "            return color\n",
        "        return WHITE\n",
        "\n",
        "    def animate_payment_addition(self, *args, **kwargs):\n",
        "        line = self.add_payment_line_to_ledger(*args, **kwargs)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, \n",
        "            VGroup(*it.chain(*line)),\n",
        "            run_time = 1\n",
        "        ))\n",
        "\n",
        "    def get_network(self):\n",
        "        creatures = self.pi_creatures\n",
        "        lines = VGroup(*[\n",
        "            Line(\n",
        "                VGroup(pi1, pi1.label), VGroup(pi2, pi2.label),\n",
        "                buff = MED_SMALL_BUFF,\n",
        "                stroke_width = 2,\n",
        "            )\n",
        "            for pi1, pi2 in it.combinations(creatures, 2)\n",
        "        ])\n",
        "        labels = VGroup(*[pi.label for pi in creatures])\n",
        "        self.network = VGroup(creatures, labels, lines)\n",
        "        self.network.lines = lines\n",
        "        return self.network\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        creatures = VGroup(*[\n",
        "            PiCreature(color = color, height = 1).shift(2*vect)\n",
        "            for color, vect in zip(\n",
        "                [BLUE_C, MAROON_D, GREY_BROWN, BLUE_E],\n",
        "                [UP+LEFT, UP+RIGHT, DOWN+LEFT, DOWN+RIGHT],\n",
        "            )\n",
        "        ])\n",
        "        creatures.to_edge(RIGHT)\n",
        "        names = self.get_names()\n",
        "        for name, creature in zip(names, creatures):\n",
        "            setattr(self, name, creature)\n",
        "            label = OldTexText(name.capitalize())\n",
        "            label.scale(0.75)\n",
        "            label.next_to(creature, DOWN, SMALL_BUFF)\n",
        "            creature.label = label\n",
        "            if (creature.get_center() - creatures.get_center())[0] > 0:\n",
        "                creature.flip()\n",
        "            creature.look_at(creatures.get_center())\n",
        "\n",
        "        return creatures\n",
        "\n",
        "    def get_names(self):\n",
        "        return [\"alice\", \"bob\", \"charlie\", \"you\"]\n",
        "\n",
        "    def get_signature_tex(self):\n",
        "        if not hasattr(self, \"nonce\"):\n",
        "            self.nonce = 0\n",
        "        binary = bin(hash(str(self.nonce)))[-8:]\n",
        "        self.nonce += 1\n",
        "        return binary + \"\\\\dots\"\n",
        "\n",
        "    def get_signature(self, color = BLUE_C):\n",
        "        result = OldTex(self.get_signature_tex())\n",
        "        result.set_color(color)\n",
        "        return result\n",
        "\n",
        "    def add_ellipsis(self):\n",
        "        last_item = self.ledger.content[-1]\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(last_item.get_left(), DOWN)\n",
        "        last_item.add(dots)\n",
        "        self.add(last_item)\n",
        "\n",
        "class LayOutPlan(LedgerScene):\n",
        "    def construct(self):\n",
        "        self.ask_question()\n",
        "        self.show_ledger()\n",
        "        self.become_skeptical()\n",
        "\n",
        "    def ask_question(self):\n",
        "        btc = BitcoinLogo()\n",
        "        group = VGroup(btc, OldTex(\"= ???\"))\n",
        "        group.arrange(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(btc),\n",
        "            Write(group[1], run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            group.scale, 0.7,\n",
        "            group.next_to, ORIGIN, RIGHT,\n",
        "            group.to_edge, UP\n",
        "        )\n",
        "\n",
        "    def show_ledger(self):\n",
        "        network = self.get_network()\n",
        "        ledger = self.get_ledger()\n",
        "        payments = [\n",
        "            (\"Alice\", \"Bob\", 20),\n",
        "            (\"Bob\", \"Charlie\", 40),\n",
        "            (\"Alice\", \"You\", 50),\n",
        "        ]\n",
        "\n",
        "        self.play(*list(map(FadeIn, [network, ledger])))\n",
        "        for payment in payments:\n",
        "            new_line = self.add_payment_line_to_ledger(*payment)\n",
        "            from_name, to_name, amount = payment\n",
        "            from_pi = getattr(self, from_name.lower())\n",
        "            to_pi = getattr(self, to_name.lower())\n",
        "            cash = OldTex(\"\\\\$\"*(amount/10))\n",
        "            cash.scale(0.5)\n",
        "            cash.move_to(from_pi)\n",
        "            cash.set_color(GREEN)\n",
        "\n",
        "            self.play(\n",
        "                cash.move_to, to_pi,\n",
        "                to_pi.change_mode, \"hooray\"\n",
        "            )\n",
        "            self.play(\n",
        "                FadeOut(cash),\n",
        "                Write(new_line, run_time = 1)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    def become_skeptical(self):\n",
        "        creatures = self.pi_creatures\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change_mode, \"sassy\")\n",
        "            for pi in creatures\n",
        "        ])\n",
        "        for k in range(3):\n",
        "            self.play(*[\n",
        "                ApplyMethod(\n",
        "                    creatures[i].look_at,\n",
        "                    creatures[k*(i+1)%4]\n",
        "                )\n",
        "                for i in range(4)\n",
        "            ])\n",
        "        self.wait(2)\n",
        "\n",
        "class UnderlyingSystemVsUserFacing(Scene):\n",
        "    def construct(self):\n",
        "        underlying = OldTexText(\"Underlying \\\\\\\\ system\")\n",
        "        underlying.shift(DOWN).to_edge(LEFT)\n",
        "        user_facing = OldTexText(\"User-facing\")\n",
        "        user_facing.next_to(underlying, UP, LARGE_BUFF, LEFT)\n",
        "\n",
        "        protocol = OldTexText(\"Bitcoin protocol\")\n",
        "        protocol.next_to(underlying, RIGHT, MED_LARGE_BUFF)\n",
        "        protocol.set_color(BITCOIN_COLOR)\n",
        "        banking = OldTexText(\"Banking system\")\n",
        "        banking.next_to(protocol, RIGHT, MED_LARGE_BUFF)\n",
        "        banking.set_color(GREEN)\n",
        "\n",
        "        phone = SVGMobject(\n",
        "            file_name = \"phone\",\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 1,\n",
        "            height = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        phone.next_to(protocol, UP, LARGE_BUFF)\n",
        "        card = SVGMobject(\n",
        "            file_name = \"credit_card\",\n",
        "            fill_color = GREY_B,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "            height = 1\n",
        "        )\n",
        "        card.next_to(banking, UP, LARGE_BUFF)\n",
        "\n",
        "        btc = BitcoinLogo()\n",
        "        btc.next_to(phone, UP, MED_LARGE_BUFF)\n",
        "        dollar = OldTex(\"\\\\$\")\n",
        "        dollar.set_height(1)\n",
        "        dollar.set_color(GREEN)\n",
        "        dollar.next_to(card, UP, MED_LARGE_BUFF)\n",
        "        card.save_state()\n",
        "        card.shift(2*RIGHT)\n",
        "        card.set_fill(opacity = 0)\n",
        "\n",
        "\n",
        "        h_line = Line(underlying.get_left(), banking.get_right())\n",
        "        h_line.next_to(underlying, DOWN, MED_SMALL_BUFF, LEFT)\n",
        "        h_line2 = h_line.copy()\n",
        "        h_line2.next_to(user_facing, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "        h_line3 = h_line.copy()\n",
        "        h_line3.next_to(user_facing, UP, MED_LARGE_BUFF, LEFT)\n",
        "        v_line = Line(5*UP, ORIGIN)\n",
        "        v_line.next_to(underlying, RIGHT, MED_SMALL_BUFF)\n",
        "        v_line.shift(1.7*UP)\n",
        "        v_line2 = v_line.copy()\n",
        "        v_line2.next_to(protocol, RIGHT, MED_SMALL_BUFF)\n",
        "        v_line2.shift(1.7*UP)\n",
        "\n",
        "        self.add(h_line, h_line2, h_line3, v_line, v_line2)\n",
        "        self.add(underlying, user_facing, btc)\n",
        "        self.play(Write(protocol))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            card.restore,\n",
        "            Write(dollar)\n",
        "        )\n",
        "        self.play(Write(banking))\n",
        "        self.wait(2)\n",
        "        self.play(DrawBorderThenFill(phone))\n",
        "        self.wait(2)\n",
        "        \n",
        "class FromBankToDecentralizedSystemCopy(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class IntroduceLedgerSystem(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"payments\" : [\n",
        "            (\"Alice\", \"Bob\", 20),\n",
        "            (\"Bob\", \"Charlie\", 40),\n",
        "            (\"Charlie\", \"You\", 30),\n",
        "            (\"You\", \"Alice\", 10),\n",
        "        ]\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add(self.get_network())\n",
        "        self.exchange_money()\n",
        "        self.add_ledger()\n",
        "        self.tally_it_all_up()\n",
        "\n",
        "\n",
        "    def exchange_money(self):\n",
        "        for from_name, to_name, num in self.payments:\n",
        "            from_pi = getattr(self, from_name.lower())\n",
        "            to_pi = getattr(self, to_name.lower())\n",
        "            cash = OldTex(\"\\\\$\"*(num/10)).set_color(GREEN)\n",
        "            cash.set_height(0.5)\n",
        "            cash.move_to(from_pi)\n",
        "            self.play(\n",
        "                cash.move_to, to_pi,\n",
        "                to_pi.change_mode, \"hooray\"\n",
        "            )\n",
        "            self.play(FadeOut(cash))\n",
        "        self.wait()\n",
        "\n",
        "    def add_ledger(self):\n",
        "        ledger = self.get_ledger()\n",
        "\n",
        "        self.play(\n",
        "            Write(ledger),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"pondering\", ledger)\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        )\n",
        "        for payment in self.payments:\n",
        "            self.animate_payment_addition(*payment)\n",
        "        self.wait(3)\n",
        "\n",
        "    def tally_it_all_up(self):\n",
        "        accounts = dict()\n",
        "        names = \"alice\", \"bob\", \"charlie\", \"you\"\n",
        "        for name in names:\n",
        "            accounts[name] = 0\n",
        "        for from_name, to_name, amount in self.payments:\n",
        "            accounts[from_name.lower()] -= amount\n",
        "            accounts[to_name.lower()] += amount\n",
        "\n",
        "        results = VGroup()\n",
        "        debtors = VGroup()\n",
        "        creditors = VGroup()\n",
        "        for name in names:\n",
        "            amount = accounts[name]\n",
        "            creature = getattr(self, name)\n",
        "            creature.cash = OldTex(\"\\\\$\"*abs(amount/10))\n",
        "            creature.cash.next_to(creature, UP+LEFT, SMALL_BUFF)\n",
        "            creature.cash.set_color(GREEN)\n",
        "            if amount < 0:\n",
        "                verb = \"Owes\"\n",
        "                debtors.add(creature)\n",
        "            else:\n",
        "                verb = \"Gets\"\n",
        "                creditors.add(creature)\n",
        "            if name == \"you\":\n",
        "                verb = verb[:-1]\n",
        "            result = OldTexText(\n",
        "                verb, \"\\\\$%d\"%abs(amount)\n",
        "            )\n",
        "            result.set_color_by_tex(\"Owe\", RED)\n",
        "            result.set_color_by_tex(\"Get\", GREEN)\n",
        "            result.add_background_rectangle()\n",
        "            result.scale(0.7)\n",
        "            result.next_to(creature.label, DOWN)\n",
        "            results.add(result)\n",
        "\n",
        "        brace = Brace(VGroup(*self.ledger.content[1:]), RIGHT)\n",
        "        tally_up = brace.get_text(\"Tally up\")\n",
        "        tally_up.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace), \n",
        "            FadeIn(tally_up)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, results),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"happy\")\n",
        "                for pi in creditors\n",
        "            ] + [\n",
        "                ApplyMethod(pi.change, \"plain\")\n",
        "                for pi in debtors\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        debtor_cash, creditor_cash = [\n",
        "            VGroup(*it.chain(*[pi.cash for pi in group]))\n",
        "            for group in (debtors, creditors)\n",
        "        ]\n",
        "        self.play(FadeIn(debtor_cash))\n",
        "        self.play(\n",
        "            debtor_cash.arrange, RIGHT, SMALL_BUFF,\n",
        "            debtor_cash.move_to, self.pi_creatures,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            debtor_cash, creditor_cash\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class InitialProtocol(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_first_two_items()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Protocol\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(4)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.h_line = h_line\n",
        "        self.title = title\n",
        "        self.add(title, h_line)\n",
        "\n",
        "    def show_first_two_items(self):\n",
        "        items = VGroup(*list(map(self.get_new_item, [\n",
        "            \"Anyone can add lines to the Ledger\",\n",
        "            \"Settle up with real money each month\"\n",
        "        ])))\n",
        "\n",
        "        for item in items:\n",
        "            self.wait()\n",
        "            self.play(LaggedStartMap(FadeIn, item))\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_new_item(self, item_string):\n",
        "        item = OldTexText(\"$\\\\cdot$ %s\"%item_string)\n",
        "        if not hasattr(self, \"items\"):\n",
        "            self.items = VGroup(item)\n",
        "            self.items.next_to(self.h_line, DOWN, MED_LARGE_BUFF)\n",
        "        else:\n",
        "            item.next_to(self.items, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "            self.items.add(item)\n",
        "        return item\n",
        "\n",
        "class AddFraudulentLine(LedgerScene):\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.anyone_can_add_a_line()\n",
        "        self.bob_adds_lines()\n",
        "        self.alice_reacts()\n",
        "\n",
        "    def anyone_can_add_a_line(self):\n",
        "        words = OldTexText(\"Anyone can add a line\")\n",
        "        words.to_corner(UP+RIGHT)\n",
        "        words.set_color(YELLOW)\n",
        "        arrow = Arrow(\n",
        "            words.get_left(), \n",
        "            self.ledger.content.get_center() + DOWN,\n",
        "        )\n",
        "\n",
        "        self.play(Write(words, run_time = 1))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(arrow),\n",
        "            FocusOn(self.bob),\n",
        "        )\n",
        "\n",
        "    def bob_adds_lines(self):\n",
        "        line = self.add_payment_line_to_ledger(\"Alice\", \"Bob\", 100)\n",
        "        line.save_state()\n",
        "        line.scale(0.001)\n",
        "        line.move_to(self.bob)\n",
        "\n",
        "        self.play(self.bob.change, \"conniving\")\n",
        "        self.play(line.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def alice_reacts(self):\n",
        "        bubble = SpeechBubble(\n",
        "            height = 1.5, width = 2, direction = LEFT,\n",
        "        )\n",
        "        bubble.next_to(self.alice, UP+RIGHT, buff = 0)\n",
        "        bubble.write(\"Hey!\")\n",
        "        self.play(\n",
        "            Animation(self.bob.pupils),\n",
        "            self.alice.change, \"angry\",\n",
        "            FadeIn(bubble),\n",
        "            Write(bubble.content, run_time = 1)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "            self.alice.change_mode, \"pondering\"\n",
        "        )\n",
        "\n",
        "class AnnounceDigitalSignatures(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Digital \\\\\\\\ signatures!\")\n",
        "        words.scale(1.5)\n",
        "        self.teacher_says(\n",
        "            words,\n",
        "            target_mode = \"hooray\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceSignatures(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"payments\" : [\n",
        "            (\"Alice\", \"Bob\", 100),\n",
        "            (\"Charlie\", \"You\", 20),\n",
        "            (\"Bob\", \"You\", 30),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.add_transactions()\n",
        "        self.add_signatures()\n",
        "\n",
        "    def add_transactions(self):\n",
        "        transactions = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in self.payments\n",
        "        ])\n",
        "        self.play(LaggedStartMap(FadeIn, transactions))\n",
        "        self.wait()\n",
        "\n",
        "    def add_signatures(self):\n",
        "        signatures = VGroup(*[\n",
        "            get_cursive_name(payments[0].capitalize())\n",
        "            for payments in self.payments\n",
        "        ])\n",
        "        for signature, transaction in zip(signatures, self.ledger.content[1:]):\n",
        "            signature.next_to(transaction, RIGHT)\n",
        "            signature.set_color(transaction[0].get_color())\n",
        "            self.play(Write(signature, run_time = 2))\n",
        "            transaction.add(signature)\n",
        "        self.wait(2)\n",
        "\n",
        "        rect = SurroundingRectangle(self.ledger.content[1])\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "        self.play(Indicate(signatures[0]))\n",
        "        self.wait()\n",
        "\n",
        "class AskHowDigitalSignaturesArePossible(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        signature = get_cursive_name(\"Alice\")\n",
        "        signature.scale(1.5)\n",
        "        signature.set_color(BLUE_C)\n",
        "        signature.to_corner(UP+LEFT)\n",
        "        signature_copy = signature.copy()\n",
        "        signature_copy.shift(3*RIGHT)\n",
        "\n",
        "        bits = OldTex(\"01100001\")\n",
        "        bits.next_to(signature, DOWN)\n",
        "        bits.shift_onto_screen()\n",
        "        bits_copy = bits.copy()\n",
        "        bits_copy.next_to(signature_copy, DOWN)\n",
        "\n",
        "\n",
        "        self.student_says(\n",
        "            \"Couldn't you just \\\\\\\\ copy the signature?\",\n",
        "            target_mode = \"confused\",\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.play(Write(signature))\n",
        "        self.play(LaggedStartMap(FadeIn, bits, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            bits.copy(), bits_copy,\n",
        "            path_arc = np.pi/2\n",
        "        ))\n",
        "        self.play(Write(signature_copy))\n",
        "        self.wait(3)\n",
        "\n",
        "class DescribeDigitalSignatures(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"public_color\" : GREEN,\n",
        "        \"private_color\" : RED,\n",
        "        \"signature_color\" : BLUE_C,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.reorganize_pi_creatures()\n",
        "        self.generate_key_pairs()\n",
        "        self.keep_secret_key_secret()\n",
        "        self.show_handwritten_signatures()\n",
        "        self.show_digital_signatures()\n",
        "        self.show_signing_functions()\n",
        "\n",
        "    def reorganize_pi_creatures(self):\n",
        "        self.pi_creatures.remove(self.you)\n",
        "        creature_groups = VGroup(*[\n",
        "            VGroup(pi, pi.label).scale(1.7)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        creature_groups.arrange(RIGHT, buff = 2)\n",
        "        creature_groups.to_edge(DOWN)\n",
        "        self.add(creature_groups)\n",
        "        for pi in self.pi_creatures:\n",
        "            if pi.is_flipped():\n",
        "                pi.flip()\n",
        "\n",
        "    def generate_key_pairs(self):\n",
        "        title = OldTexText(\"Private\", \"key /\", \"Public\", \"key\")\n",
        "        title.to_edge(UP)\n",
        "        private, public = list(map(title.get_part_by_tex, [\"Private\", \"Public\"]))\n",
        "        private.set_color(self.private_color)\n",
        "        public.set_color(self.public_color)\n",
        "        secret = OldTexText(\"Secret\")\n",
        "        secret.move_to(private, RIGHT)\n",
        "        secret.set_color(self.private_color)\n",
        "\n",
        "        names = self.get_names()[:-1]\n",
        "        public_key_strings = [\n",
        "            bin(256+ord(name[0].capitalize()))[3:]\n",
        "            for name in names\n",
        "        ]\n",
        "        private_key_strings = [\n",
        "            bin(hash(name))[2:10]\n",
        "            for name in names\n",
        "        ]\n",
        "        public_keys, private_keys = [\n",
        "            VGroup(*[\n",
        "                OldTexText(key_name+\":\",\" $%s\\\\dots$\"%key)\n",
        "                for key in keys\n",
        "            ])\n",
        "            for key_name, keys in [\n",
        "                (\"pk\", public_key_strings),\n",
        "                (\"sk\", private_key_strings)\n",
        "            ]\n",
        "        ]\n",
        "        key_pairs = [\n",
        "            VGroup(*pair).arrange(DOWN, aligned_edge = LEFT)\n",
        "            for pair in zip(public_keys, private_keys)\n",
        "        ]\n",
        "        for key_pair, pi in zip(key_pairs, self.pi_creatures):\n",
        "            key_pair.next_to(pi, UP, MED_LARGE_BUFF)\n",
        "            for key in key_pair:\n",
        "                key.set_color_by_tex(\"sk\", self.private_color)\n",
        "                key.set_color_by_tex(\"pk\", self.public_color)\n",
        "\n",
        "        self.play(Write(title, run_time = 2))\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(VGroup(public.copy())),\n",
        "            public_keys\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(VGroup(private.copy())),\n",
        "            private_keys\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(private.shift, DOWN)\n",
        "        self.play(FadeIn(secret))\n",
        "        self.play(FadeOut(private))\n",
        "        self.wait()\n",
        "\n",
        "        title.remove(private)\n",
        "        title.add(secret)\n",
        "        self.title = title\n",
        "        self.private_keys = private_keys\n",
        "        self.public_keys = public_keys\n",
        "\n",
        "    def keep_secret_key_secret(self):\n",
        "        keys = self.private_keys\n",
        "        rects = VGroup(*list(map(SurroundingRectangle, keys)))\n",
        "        rects.set_color(self.private_color)\n",
        "        lock = SVGMobject(\n",
        "            file_name = \"lock\",\n",
        "            height = rects.get_height(),\n",
        "            fill_color = GREY_B,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        locks = VGroup(*[\n",
        "            lock.copy().next_to(rect, LEFT, SMALL_BUFF)\n",
        "            for rect in rects\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(rects))\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, locks))\n",
        "        self.wait()\n",
        "\n",
        "        self.private_key_rects = rects\n",
        "        self.locks = locks\n",
        "\n",
        "    def show_handwritten_signatures(self):\n",
        "        lines = VGroup(*[Line(LEFT, RIGHT) for x in range(5)])\n",
        "        lines.arrange(DOWN)\n",
        "        last_line = lines[-1]\n",
        "        last_line.scale(0.7, about_point = last_line.get_left())\n",
        "\n",
        "        signature_line = lines[0].copy()\n",
        "        signature_line.set_stroke(width = 2)\n",
        "        signature_line.next_to(lines, DOWN, LARGE_BUFF)\n",
        "        ex = OldTex(\"\\\\times\")\n",
        "        ex.scale(0.7)\n",
        "        ex.next_to(signature_line, UP, SMALL_BUFF, LEFT)\n",
        "        lines.add(ex, signature_line)\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            lines, \n",
        "            color = GREY_B, \n",
        "            buff = MED_SMALL_BUFF\n",
        "        )\n",
        "        document = VGroup(rect, lines)\n",
        "        documents = VGroup(*[\n",
        "            document.copy()\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        documents.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        documents.to_corner(UP+LEFT)\n",
        "\n",
        "        signatures = VGroup()\n",
        "        for document in documents:\n",
        "            signature = get_cursive_name(\"Alice\")\n",
        "            signature.set_color(self.signature_color)\n",
        "            line = document[1][-1]\n",
        "            signature.next_to(line, UP, SMALL_BUFF)\n",
        "            signatures.add(signature)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.title),\n",
        "            LaggedStartMap(FadeIn, documents, run_time = 1)\n",
        "        )\n",
        "        self.play(Write(signatures))\n",
        "        self.wait()\n",
        "\n",
        "        self.signatures = signatures\n",
        "        self.documents = documents\n",
        "\n",
        "    def show_digital_signatures(self):\n",
        "        rect = SurroundingRectangle(VGroup(\n",
        "            self.public_keys[0],\n",
        "            self.private_key_rects[0],\n",
        "            self.locks[0]\n",
        "        ))\n",
        "        digital_signatures = VGroup()\n",
        "        for i, signature in enumerate(self.signatures):\n",
        "            bits = bin(hash(str(i)))[-8:]\n",
        "            digital_signature = OldTex(bits + \"\\\\dots\")\n",
        "            digital_signature.scale(0.7)\n",
        "            digital_signature.set_color(signature.get_color())\n",
        "            digital_signature.move_to(signature, DOWN)\n",
        "            digital_signatures.add(digital_signature)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                rect.get_corner(UP), sig.get_bottom(),\n",
        "                tip_length = 0.15,\n",
        "                color = WHITE\n",
        "            )\n",
        "            for sig in digital_signatures\n",
        "        ])\n",
        "\n",
        "        words = VGroup(*list(map(\n",
        "            TexText,\n",
        "            [\"Different messages\", \"Completely different signatures\"]\n",
        "        )))\n",
        "        words.arrange(DOWN, aligned_edge = LEFT)\n",
        "        words.scale(1.3)\n",
        "        words.next_to(self.documents, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        self.play(*list(map(ShowCreation, arrows)))\n",
        "        self.play(Transform(self.signatures, digital_signatures))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"pondering\", digital_signatures)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(words))\n",
        "\n",
        "    def show_signing_functions(self):\n",
        "        sign = OldTexText(\n",
        "            \"Sign(\", \"Message\", \", \", \"sk\", \") = \", \"Signature\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        sign.to_corner(UP+RIGHT)\n",
        "        verify = OldTexText(\n",
        "            \"Verify(\", \"Message\", \", \", \"Signature\", \", \", \"pk\", \") = \", \"T/F\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        for mob in sign, verify:\n",
        "            mob.set_color_by_tex(\"sk\", self.private_color)\n",
        "            mob.set_color_by_tex(\"pk\", self.public_color)\n",
        "            mob.set_color_by_tex(\n",
        "                \"Signature\", self.signature_color,\n",
        "            )\n",
        "            for name in \"Message\", \"sk\", \"Signature\", \"pk\":\n",
        "                part = mob.get_part_by_tex(name)\n",
        "                if part is not None:\n",
        "                    setattr(mob, name.lower(), part)\n",
        "        verify.next_to(sign, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "        VGroup(sign, verify).to_corner(UP+RIGHT)\n",
        "\n",
        "        private_key = self.private_key_rects[0]\n",
        "        public_key = self.public_keys[0]\n",
        "        message = self.documents[0]\n",
        "        signature = self.signatures[0]\n",
        "\n",
        "        self.play(*[\n",
        "            FadeIn(part)\n",
        "            for part in sign\n",
        "            if part not in [sign.message, sign.sk, sign.signature]\n",
        "        ])\n",
        "        self.play(ReplacementTransform(\n",
        "            message.copy(), VGroup(sign.message)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            private_key.copy(), sign.sk\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(sign.sk, sign.message).copy(),\n",
        "            VGroup(sign.signature)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Indicate(sign.sk))\n",
        "        self.wait()\n",
        "        self.play(Indicate(sign.message))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            FadeIn(part)\n",
        "            for part in verify\n",
        "            if part not in [\n",
        "                verify.message, verify.signature, \n",
        "                verify.pk, verify[-1]\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                sign.message.copy(), verify.message\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                sign.signature.copy(), verify.signature\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            public_key.copy(), VGroup(verify.pk)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(verify[-1]))\n",
        "        self.wait()\n",
        "\n",
        "class TryGuessingDigitalSignature(Scene):\n",
        "    def construct(self):\n",
        "        verify = OldTexText(\n",
        "            \"Verify(\", \"Message\", \", \", \n",
        "            \"256 bit Signature\", \", \", \"pk\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        verify.scale(1.5)\n",
        "        verify.shift(DOWN)\n",
        "        signature = verify.get_part_by_tex(\"Signature\")\n",
        "        verify.set_color_by_tex(\"Signature\", BLUE)\n",
        "        verify.set_color_by_tex(\"pk\", GREEN)\n",
        "        brace = Brace(signature, UP)\n",
        "\n",
        "        zeros_row = OldTex(\"0\"*32)\n",
        "        zeros = VGroup(*[zeros_row.copy() for x in range(8)])\n",
        "        zeros.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        zeros.next_to(brace, UP)\n",
        "\n",
        "        self.add(verify)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(\n",
        "                zeros,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(2**10):\n",
        "            last_row = zeros[-1]\n",
        "            binary = bin(n)[2:]\n",
        "            for i, bit_str in enumerate(reversed(binary)):\n",
        "                curr_bit = last_row.submobjects[-i-1]\n",
        "                new_bit = OldTex(bit_str)\n",
        "                new_bit.replace(curr_bit, dim_to_match = 1)\n",
        "                last_row.submobjects[-i-1] = new_bit\n",
        "                self.remove(curr_bit)\n",
        "            self.add(last_row)\n",
        "            self.wait(1./30)\n",
        "\n",
        "class WriteTwoTo256PossibleSignatures(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"$2^{256}$\", \"possible\\\\\\\\\", \"signatures\"\n",
        "        )\n",
        "        words.scale(2)\n",
        "        words.set_color_by_tex(\"256\", BLUE)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class SupplementVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"How secure is 256 bit security?\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height = 6)\n",
        "        rect.next_to(title, DOWN)\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "class FeelConfidentWithVerification(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.show_verification()\n",
        "        self.show_secret_key()\n",
        "\n",
        "    def show_verification(self):\n",
        "        verify = OldTexText(\n",
        "            \"Verify(\", \"Message\", \", \", \n",
        "            \"256 bit Signature\", \", \", \"pk\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        signature_word = verify.get_part_by_tex(\"Signature\")\n",
        "        verify.set_color_by_tex(\"Signature\", BLUE)\n",
        "        verify.set_color_by_tex(\"pk\", GREEN)\n",
        "        brace = Brace(signature_word, UP)\n",
        "        signature = sha256_tex_mob(\"Signature\")\n",
        "        signature.next_to(brace, UP)\n",
        "        signature.set_color(BLUE_C)\n",
        "\n",
        "        rhs = OldTexText(\"=\", \"True\")\n",
        "        rhs.set_color_by_tex(\"True\", YELLOW)\n",
        "        rhs.next_to(verify, RIGHT)\n",
        "\n",
        "        pk = verify.get_part_by_tex(\"pk\")\n",
        "        sk = OldTexText(\"sk\")\n",
        "        sk.set_color(RED)\n",
        "        arrow = OldTex(\"\\\\Updownarrow\")\n",
        "        arrow.next_to(pk, DOWN)\n",
        "        sk.next_to(arrow, DOWN)\n",
        "        sk_group = VGroup(arrow, sk)\n",
        "        lock_box = SurroundingRectangle(sk_group, buff = SMALL_BUFF)\n",
        "        lock_box.set_color(RED)\n",
        "        lock = SVGMobject(\n",
        "            file_name = \"lock\", \n",
        "            fill_color = GREY_B,\n",
        "            height = 0.5,\n",
        "        )\n",
        "        lock.next_to(lock_box, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.add(verify)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(signature),\n",
        "            self.pi_creature.change, \"pondering\"\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            verify.copy(), rhs\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(self.pi_creature.change, \"happy\")\n",
        "        self.play(Write(sk_group))\n",
        "        self.play(\n",
        "            ShowCreation(lock_box),\n",
        "            DrawBorderThenFill(lock, run_time = 1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    def show_secret_key(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().to_corner(DOWN+LEFT)\n",
        "\n",
        "class IncludeTransactionNumber(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"ledger_width\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.add_signed_payment()\n",
        "        self.fail_to_sign_new_transaction()\n",
        "        self.copy_payment_many_times()\n",
        "        self.add_ids()\n",
        "\n",
        "    def add_signed_payment(self):\n",
        "        line = self.add_payment_line_to_ledger(\n",
        "            \"Alice\", \"Bob\", 100\n",
        "        )\n",
        "        signature = self.get_signature()\n",
        "        signature.scale(0.7)\n",
        "        signature.next_to(line, RIGHT)\n",
        "        signature.save_state()\n",
        "        signature.scale(0.1)\n",
        "        signature.move_to(self.alice)\n",
        "\n",
        "        self.play(Write(line, run_time = 1))\n",
        "        self.play(\n",
        "            signature.restore,\n",
        "            self.alice.change, \"raise_left_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.alice.change, \"happy\")\n",
        "        self.wait()\n",
        "\n",
        "        line.add(signature)\n",
        "\n",
        "    def fail_to_sign_new_transaction(self):\n",
        "        payment = self.add_payment_line_to_ledger(\"Alice\", \"Bob\", 3000)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(payment, RIGHT)\n",
        "        cross = Cross(payment)\n",
        "        payment.save_state()\n",
        "        payment.move_to(self.bob.get_corner(UP+LEFT))\n",
        "        payment.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            self.bob.change, \"raise_right_hand\",\n",
        "            payment.restore,\n",
        "        )\n",
        "        self.play(\n",
        "            self.bob.change, \"confused\",\n",
        "            Write(q_marks)\n",
        "        )\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [payment, cross, q_marks])))\n",
        "        self.ledger.content.remove(payment)\n",
        "\n",
        "    def copy_payment_many_times(self):\n",
        "        line = self.ledger.content[-1]\n",
        "        copies = VGroup(*[line.copy() for x in range(4)])\n",
        "        copies.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        copies.next_to(line, DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, copies, run_time = 3),\n",
        "            self.bob.change, \"conniving\",\n",
        "        )\n",
        "        self.play(self.alice.change, \"angry\")\n",
        "        self.wait()\n",
        "\n",
        "        self.copies = copies\n",
        "\n",
        "    def add_ids(self):\n",
        "        top_line = self.ledger.content[-1]\n",
        "        lines = VGroup(top_line, *self.copies)\n",
        "        numbers = VGroup()\n",
        "        old_signatures = VGroup()\n",
        "        new_signatures = VGroup()\n",
        "        colors = list(Color(BLUE_B).range_to(GREEN_B, len(lines)))\n",
        "        for i, line in enumerate(lines):\n",
        "            number = OldTex(str(i))\n",
        "            number.scale(0.7)\n",
        "            number.set_color(YELLOW)\n",
        "            number.next_to(line, LEFT)\n",
        "            numbers.add(number)\n",
        "            line.add_to_back(number)\n",
        "            old_signature = line[-1]\n",
        "            new_signature = self.get_signature()\n",
        "            new_signature.replace(old_signature)\n",
        "            new_signature.set_color(colors[i])\n",
        "            old_signatures.add(old_signature)\n",
        "            new_signatures.add(VGroup(new_signature))\n",
        "            line.remove(old_signature)\n",
        "\n",
        "        self.play(\n",
        "            Write(numbers),\n",
        "            self.alice.change, \"thinking\"\n",
        "        )\n",
        "        self.play(FadeOut(old_signatures))\n",
        "        self.play(ReplacementTransform(\n",
        "            lines.copy(), new_signatures,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.play(self.bob.change, \"erm\")\n",
        "        self.wait(2)\n",
        "\n",
        "class ProtocolWithDigitalSignatures(InitialProtocol):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        InitialProtocol.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        rect = SurroundingRectangle(self.items[-1])\n",
        "        rect.set_color(RED)\n",
        "\n",
        "        new_item = self.get_new_item(\n",
        "            \"Only signed transactions are valid\"\n",
        "        )\n",
        "        new_item.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(new_item))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "class SignedLedgerScene(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"sign_transactions\" : True,\n",
        "        \"enumerate_lines\" : True,\n",
        "        \"ledger_width\" : 7.5,\n",
        "    }\n",
        "\n",
        "class CharlieRacksUpDebt(SignedLedgerScene):\n",
        "    CONFIG = {\n",
        "        \"payments\" : [\n",
        "            (\"Charlie\", \"Alice\", 100),\n",
        "            (\"Charlie\", \"Bob\", 200),\n",
        "            (\"Charlie\", \"You\", 800),\n",
        "            (\"Charlie\", \"Bob\", 600),\n",
        "            (\"Charlie\", \"Alice\", 900),\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        lines = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in self.payments\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, lines, \n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.25\n",
        "        ))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"sassy\", self.charlie)\n",
        "            for pi in self.pi_creatures\n",
        "            if pi is not self.charlie\n",
        "        ])\n",
        "        self.play(\n",
        "            self.charlie.shift, FRAME_X_RADIUS*RIGHT,\n",
        "            rate_func = running_start\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"angry\", self.charlie)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "class CharlieFeelsGuilty(Scene):\n",
        "    def construct(self):\n",
        "        charlie = PiCreature(color = GREY_BROWN)\n",
        "        charlie.scale(2)\n",
        "\n",
        "        self.play(FadeIn(charlie))\n",
        "        self.play(charlie.change, \"sad\")\n",
        "        for x in range(2):\n",
        "            self.play(Blink(charlie))\n",
        "            self.wait(2)\n",
        "\n",
        "class ThinkAboutSettlingUp(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            randy, \n",
        "            \"You don't \\\\emph{actually} \\\\\\\\\" + \\\n",
        "            \"need to settle up $\\\\dots$\",\n",
        "            bubble_type = ThoughtBubble,\n",
        "            target_mode = \"thinking\"\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class DontAllowOverdrawing(InitialProtocol):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        lines = list(map(self.get_new_item, [\n",
        "            \"Anyone can add lines to the Ledger \\\\,\",\n",
        "            \"Only signed transactions are valid \\\\,\",\n",
        "            \"No overspending\"\n",
        "        ]))\n",
        "        lines[2].set_color(YELLOW)\n",
        "\n",
        "        self.add(*lines[:2])\n",
        "        self.wait()\n",
        "        self.play(Write(lines[2]))\n",
        "        self.wait()\n",
        "\n",
        "class LedgerWithInitialBuyIn(SignedLedgerScene):\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.everyone_buys_in()\n",
        "        self.add_initial_lines()\n",
        "        self.add_charlie_payments()\n",
        "        self.point_out_charlie_is_broke()\n",
        "        self.running_balance()\n",
        "\n",
        "    def everyone_buys_in(self):\n",
        "        center = self.network.get_center()\n",
        "        moneys = VGroup(*[\n",
        "            OldTex(\"\\\\$100\")\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        moneys.set_color(GREEN)\n",
        "        for pi, money in zip(reversed(self.pi_creatures), moneys):\n",
        "            vect = pi.get_center() - center\n",
        "            money.next_to(center, vect, SMALL_BUFF)\n",
        "            money.add_background_rectangle()\n",
        "            money.save_state()\n",
        "            money.scale(0.01)\n",
        "            corner = pi.get_corner(UP + np.sign(vect[0])*LEFT)\n",
        "            money.move_to(corner)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, moneys,\n",
        "                lambda m : (m.restore,)\n",
        "            ),\n",
        "            self.charlie.change, \"raise_right_hand\",\n",
        "            self.you.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.network.add(moneys)\n",
        "\n",
        "    def add_initial_lines(self):\n",
        "        lines = VGroup()\n",
        "        for name in self.get_names():\n",
        "            new_line = OldTexText(\n",
        "                name.capitalize(), \n",
        "                \"get\" if name == \"you\" else \"gets\",\n",
        "                \"\\\\$100\"\n",
        "            )\n",
        "            new_line.set_color_by_tex(\n",
        "                name.capitalize(),\n",
        "                self.get_color_from_name(name)\n",
        "            )\n",
        "            new_line.set_color_by_tex(\"100\", GREEN)\n",
        "            self.add_line_to_ledger(new_line)\n",
        "            lines.add(new_line)\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_width(self.ledger.get_width())\n",
        "        line.scale(0.9)\n",
        "        line.next_to(lines[-1], DOWN, SMALL_BUFF, LEFT)\n",
        "        line.set_stroke(width = 1)\n",
        "        lines[-1].add(line)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, lines),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"thinking\", self.ledger)\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_charlie_payments(self):\n",
        "        payments = [\n",
        "            (\"Charlie\", \"Alice\", 50),\n",
        "            (\"Charlie\", \"Bob\", 50),\n",
        "            (\"Charlie\", \"You\", 20),\n",
        "        ]\n",
        "        new_lines = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in payments\n",
        "        ])\n",
        "\n",
        "        for line in new_lines:\n",
        "            self.play(Write(line, run_time = 1))\n",
        "            self.wait()\n",
        "\n",
        "    def point_out_charlie_is_broke(self):\n",
        "        charlie_lines = VGroup(*[\n",
        "            VGroup(*self.ledger.content[i][1:5])\n",
        "            for i in (3, 5, 6, 7)\n",
        "        ])\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(line)\n",
        "            for line in charlie_lines\n",
        "        ])\n",
        "        rects.set_color(YELLOW)\n",
        "        rects.set_stroke(width = 2)\n",
        "        last_rect = rects[-1]\n",
        "        last_rect.set_stroke(RED, 4)\n",
        "        rects.remove(last_rect)\n",
        "        invalid = OldTexText(\"Invalid\")\n",
        "        invalid.set_color(RED)\n",
        "        invalid.next_to(last_rect, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(rects))\n",
        "        self.play(self.charlie.change_mode, \"guilty\")\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(last_rect))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"sassy\", self.charlie)\n",
        "            for pi in self.pi_creatures\n",
        "            if pi is not self.charlie\n",
        "        ])\n",
        "        self.play(Write(invalid))\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [rects, last_rect, invalid])))\n",
        "\n",
        "    def running_balance(self):\n",
        "        charlie_lines = VGroup(*[\n",
        "            VGroup(*self.ledger.content[i][1:5])\n",
        "            for i in (3, 5, 6, 7)\n",
        "        ])\n",
        "        signatures = VGroup(*[\n",
        "            self.ledger.content[i][5]\n",
        "            for i in (5, 6, 7)\n",
        "        ])\n",
        "        rect = Rectangle(color = WHITE)\n",
        "        rect.set_fill(BLACK, 0.8)\n",
        "        rect.stretch_to_fit_height(self.ledger.get_height() - 2*MED_SMALL_BUFF)\n",
        "        title = OldTexText(\"Charlie's running \\\\\\\\ balance\")\n",
        "        rect.stretch_to_fit_width(title.get_width() + 2*MED_SMALL_BUFF)\n",
        "        rect.move_to(self.ledger.get_right())\n",
        "        title.next_to(rect.get_top(), DOWN)\n",
        "        balance = VGroup(rect, title)\n",
        "\n",
        "        lines = VGroup(*list(map(TexText, [\n",
        "            \"\\\\$100\", \"\\\\$50\", \"\\\\$0\", \"Overdrawn\"\n",
        "        ])))\n",
        "        lines.set_color(GREEN)\n",
        "        lines[-1].set_color(RED)\n",
        "        arrows = VGroup()\n",
        "        for line, c_line in zip(lines, charlie_lines):\n",
        "            line.next_to(rect.get_left(), RIGHT, LARGE_BUFF)\n",
        "            line.shift(\n",
        "                (c_line.get_center() - line.get_center())[1]*UP\n",
        "            )\n",
        "            arrow = Arrow(c_line, line)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        self.pi_creatures.remove(self.alice, self.charlie)\n",
        "        self.play(\n",
        "            FadeOut(signatures),\n",
        "            FadeIn(balance)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, lines, run_time = 3),\n",
        "            LaggedStartMap(ShowCreation, arrows, run_time = 3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class RemovedConnectionBetweenLedgerAndCash(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        ledger = Rectangle(\n",
        "            height = 2, width = 1.5,\n",
        "            color = WHITE\n",
        "        )\n",
        "        ledger_name = OldTexText(\"Ledger\")\n",
        "        ledger_name.set_width(ledger.get_width() - MED_SMALL_BUFF)\n",
        "        ledger_name.next_to(ledger.get_top(), DOWN)\n",
        "        ledger.add(ledger_name)\n",
        "\n",
        "        arrow = OldTex(\"\\\\leftrightarrow\")\n",
        "        cash = OldTex(\"\\\\$\\\\$\\\\$\")\n",
        "        cash.set_color(GREEN)\n",
        "        arrow.next_to(ledger, RIGHT)\n",
        "        cash.next_to(arrow, RIGHT)\n",
        "        group = VGroup(ledger, arrow, cash)\n",
        "        group.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        self.add(group)\n",
        "        self.play(\n",
        "            Animation(group),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(\n",
        "            arrow.shift, 2*UP,\n",
        "            arrow.set_fill, None, 0\n",
        "        )\n",
        "        self.play(\n",
        "            ledger.shift, LEFT, \n",
        "            cash.shift, RIGHT\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = ledger,\n",
        "            added_anims = [self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class RenameToLedgerDollars(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"payments\" : [\n",
        "            (\"Alice\", \"Bob\", 20),\n",
        "            (\"Charlie\", \"You\", 80),\n",
        "            (\"Bob\", \"Charlie\", 60),\n",
        "            (\"Bob\", \"Alice\", 30),\n",
        "            (\"Alice\", \"You\", 100),\n",
        "        ],\n",
        "        \"enumerate_lines\" : True,\n",
        "        \"line_number_color\" : WHITE,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add(self.get_ledger())\n",
        "        self.add_bubble()\n",
        "        self.jump_in_to_middle()\n",
        "        self.add_payments_in_dollars()\n",
        "        self.rewrite_as_ledger_dollars()\n",
        "\n",
        "    def add_bubble(self):\n",
        "        randy = self.pi_creature\n",
        "        bubble = SpeechBubble(direction = RIGHT)\n",
        "        bubble.write(\"Who needs \\\\\\\\ cash?\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.add(bubble.content)\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        self.bubble = bubble\n",
        "\n",
        "        self.add(randy, bubble)\n",
        "        self.add_foreground_mobject(bubble)\n",
        "\n",
        "    def jump_in_to_middle(self):\n",
        "        h_line = self.ledger.content[0]\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(h_line.get_left(), DOWN)\n",
        "        h_line.add(dots)\n",
        "        self.add(h_line)\n",
        "        point = VectorizedPoint(h_line.get_corner(DOWN+LEFT))\n",
        "        point.shift(MED_SMALL_BUFF*LEFT)\n",
        "        self.ledger.content.add(*[\n",
        "            point.copy()\n",
        "            for x in range(103)\n",
        "        ])\n",
        "\n",
        "    def add_payments_in_dollars(self):\n",
        "        lines = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in self.payments\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, lines,\n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.payment_lines = lines\n",
        "\n",
        "    def rewrite_as_ledger_dollars(self):\n",
        "        curr_lines = self.payment_lines\n",
        "        amounts = VGroup(*[line[4] for line in curr_lines])\n",
        "        amounts.target = VGroup()\n",
        "        for amount in amounts:\n",
        "            dollar_sign = amount[0]\n",
        "            amount.remove(dollar_sign)\n",
        "            amount.add(dollar_sign)\n",
        "            tex_string = amount.get_tex()\n",
        "            ld = OldTexText(tex_string[2:] + \" LD\")\n",
        "            ld.set_color(YELLOW)\n",
        "            ld.scale(0.8)\n",
        "            ld.move_to(amount, LEFT)\n",
        "            amounts.target.add(ld)\n",
        "\n",
        "        ledger_dollars = OldTexText(\"Ledger Dollars \\\\\\\\ ``LD'' \")\n",
        "        ledger_dollars.set_color(YELLOW)\n",
        "        ledger_dollars.next_to(self.ledger, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(ledger_dollars),\n",
        "            FadeOut(self.bubble),\n",
        "            self.pi_creature.change, \"thinking\", ledger_dollars\n",
        "        )\n",
        "        self.play(MoveToTarget(amounts))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        LedgerScene.create_pi_creatures(self)\n",
        "        randy = Randolph(mode = \"shruggie\").flip()\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "        return VGroup(randy)\n",
        "\n",
        "class ExchangeCashForLedgerDollars(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"sign_transactions\" : True,\n",
        "        \"denomination\" : \"LD\",\n",
        "        \"ledger_width\" : 7.5,\n",
        "        \"ledger_height\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.add_ellipsis()\n",
        "        self.add_title()\n",
        "        self.give_ten_dollar_bill()\n",
        "        self.add_bob_pays_alice_line()\n",
        "        self.everyone_thinks()\n",
        "\n",
        "    def add_title(self):\n",
        "        self.ledger.shift(DOWN)\n",
        "        title = OldTexText(\n",
        "            \"Exchange\", \"LD\", \"for\", \"\\\\$\\\\$\\\\$\"\n",
        "        )\n",
        "        title.set_color_by_tex(\"LD\", YELLOW)\n",
        "        title.set_color_by_tex(\"\\\\$\", GREEN)\n",
        "        title.scale(1.3)\n",
        "        title.to_edge(UP).shift(LEFT)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "    def give_ten_dollar_bill(self):\n",
        "        bill = TenDollarBill()\n",
        "        bill.next_to(self.alice.get_corner(UP+RIGHT), UP)\n",
        "        bill.generate_target()\n",
        "        bill.target.next_to(self.bob.get_corner(UP+LEFT), UP)\n",
        "\n",
        "        arrow = Arrow(bill, bill.target, color = GREEN)\n",
        "\n",
        "        small_bill = bill.copy()\n",
        "        small_bill.scale(0.01, about_point = bill.get_bottom())\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(small_bill, bill),\n",
        "            self.alice.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(MoveToTarget(bill))\n",
        "        self.play(self.bob.change, \"happy\", bill)\n",
        "        self.wait()\n",
        "\n",
        "    def add_bob_pays_alice_line(self):\n",
        "        line = self.add_payment_line_to_ledger(\n",
        "            \"Bob\", \"Alice\", 10\n",
        "        )\n",
        "        line.save_state()\n",
        "        line.scale(0.01)\n",
        "        line.move_to(self.bob.get_corner(UP+LEFT))\n",
        "        self.play(self.bob.change, \"raise_right_hand\", line)\n",
        "        self.play(line.restore, run_time = 2)\n",
        "        self.wait()\n",
        "\n",
        "    def everyone_thinks(self):\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"thinking\", self.ledger)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.wait(4)\n",
        "\n",
        "class BitcoinIsALedger(Scene):\n",
        "    def construct(self):\n",
        "        self.add_btc_to_ledger()\n",
        "        self.add_currency_to_tx_history()\n",
        "\n",
        "    def add_btc_to_ledger(self):\n",
        "        logo = BitcoinLogo()\n",
        "        ledger = self.get_ledger()\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        group = VGroup(logo, arrow, ledger)\n",
        "        group.arrange(RIGHT)\n",
        "\n",
        "        self.play(DrawBorderThenFill(logo))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(arrow),\n",
        "            Write(ledger)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.btc_to_ledger = group\n",
        "\n",
        "    def add_currency_to_tx_history(self):\n",
        "        equation = OldTexText(\n",
        "            \"Currency\", \"=\", \"Transaction history\"\n",
        "        )\n",
        "        equation.set_color_by_tex(\"Currency\", BITCOIN_COLOR)\n",
        "        equation.shift(\n",
        "            self.btc_to_ledger[1].get_center() - \\\n",
        "            equation[1].get_center() + 2*UP\n",
        "        )\n",
        "\n",
        "        for part in reversed(equation):\n",
        "            self.play(FadeIn(part))\n",
        "        self.wait()\n",
        "\n",
        "    def get_ledger(self):\n",
        "        rect = Rectangle(height = 2, width = 1.5)\n",
        "        title = OldTexText(\"Ledger\")\n",
        "        title.set_width(0.8*rect.get_width())\n",
        "        title.next_to(rect.get_top(), DOWN, SMALL_BUFF)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT)\n",
        "            for x in range(8)\n",
        "        ])\n",
        "        lines.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        lines.stretch_to_fit_width(title.get_width())\n",
        "        lines.next_to(title, DOWN)\n",
        "        return VGroup(rect, title, lines)\n",
        "\n",
        "class BigDifferenceBetweenLDAndCryptocurrencies(Scene):\n",
        "    def construct(self):\n",
        "        ld = OldTexText(\"LD\").scale(1.5).set_color(YELLOW)\n",
        "        btc = BitcoinLogo()\n",
        "        eth = EthereumLogo()\n",
        "        ltc = LitecoinLogo()\n",
        "        logos = VGroup(ltc, eth, ld, btc)\n",
        "        cryptos = VGroup(btc, eth, ltc)\n",
        "        for logo in cryptos:\n",
        "            logo.set_height(1)\n",
        "        vects = compass_directions(4, DOWN+LEFT)\n",
        "        for logo, vect in zip(logos, vects):\n",
        "            logo.move_to(0.75*vect)\n",
        "\n",
        "        centralized = OldTexText(\"Centralized\")\n",
        "        decentralized = OldTexText(\"Decentralized\")\n",
        "        words = VGroup(centralized, decentralized)\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "        for word, vect in zip(words, [RIGHT, LEFT]):\n",
        "            word.shift(FRAME_X_RADIUS*vect/2)\n",
        "\n",
        "        self.add(logos)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            cryptos.next_to, decentralized, DOWN, LARGE_BUFF,\n",
        "            ld.next_to, centralized, DOWN, LARGE_BUFF,\n",
        "        )\n",
        "        self.play(*list(map(Write, words)))\n",
        "        self.wait(2)\n",
        "\n",
        "class DistributedLedgerScene(LedgerScene):\n",
        "    def get_large_network(self):\n",
        "        network = self.get_network()\n",
        "        network.set_height(FRAME_HEIGHT - LARGE_BUFF)\n",
        "        network.center()\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.label.scale(0.8, about_point = pi.get_bottom())\n",
        "        return network\n",
        "\n",
        "    def get_distributed_ledgers(self):\n",
        "        ledger = self.get_ledger()\n",
        "        title = ledger[1]\n",
        "        h_line = ledger.content\n",
        "        title.set_width(0.7*ledger.get_width())\n",
        "        title.next_to(ledger.get_top(), DOWN, MED_LARGE_BUFF)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        added_lines = VGroup(*[h_line.copy() for x in range(5)])\n",
        "        added_lines.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        added_lines.next_to(h_line, DOWN, MED_LARGE_BUFF)\n",
        "        ledger.content.add(added_lines)\n",
        "\n",
        "        ledgers = VGroup()\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.ledger = ledger.copy()\n",
        "            pi.ledger.set_height(pi.get_height())\n",
        "            pi.ledger[0].set_color(pi.get_color())\n",
        "            vect = pi.get_center()-self.pi_creatures.get_center()\n",
        "            x_vect = vect[0]*RIGHT\n",
        "            pi.ledger.next_to(pi, x_vect, SMALL_BUFF)\n",
        "            ledgers.add(pi.ledger)\n",
        "        return ledgers\n",
        "\n",
        "    def add_large_network_and_distributed_ledger(self):\n",
        "        self.add(self.get_large_network())\n",
        "        self.add(self.get_distributed_ledgers())        \n",
        "\n",
        "class TransitionToDistributedLedger(DistributedLedgerScene):\n",
        "    CONFIG = {\n",
        "        \"sign_transactions\" : True,\n",
        "        \"ledger_width\" : 7.5,\n",
        "        \"ledger_height\" : 6,\n",
        "        \"enumerate_lines\" : True,\n",
        "        \"denomination\" : \"LD\",\n",
        "        \"line_number_color\" : WHITE,\n",
        "        \"ledger_line_height\" : 0.35,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_ledger_and_network()\n",
        "        self.ledger.shift(DOWN)\n",
        "        self.add_ellipsis()\n",
        "\n",
        "        self.ask_where_is_ledger()\n",
        "        self.add_various_payements()\n",
        "        self.ask_who_controls_ledger()\n",
        "        self.distribute_ledger()\n",
        "        self.broadcast_transaction()\n",
        "        self.ask_about_ledger_consistency()\n",
        "\n",
        "    def ask_where_is_ledger(self):\n",
        "        question = OldTexText(\"Where\", \"is\", \"this?!\")\n",
        "        question.set_color(RED)\n",
        "        question.scale(1.5)\n",
        "        question.next_to(self.ledger, UP)\n",
        "\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "        self.question = question\n",
        "\n",
        "    def add_various_payements(self):\n",
        "        payments = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in [\n",
        "                (\"Alice\", \"Bob\", 20),\n",
        "                (\"Charlie\", \"You\", 100),\n",
        "                (\"You\", \"Alice\", 50),\n",
        "                (\"Bob\", \"You\", 30),\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        for payment in payments:\n",
        "            self.play(LaggedStartMap(FadeIn, payment, run_time = 1))\n",
        "            self.wait()\n",
        "\n",
        "    def ask_who_controls_ledger(self):\n",
        "        new_question = OldTexText(\"Who\", \"controls\", \"this?!\")\n",
        "        new_question.scale(1.3)\n",
        "        new_question.move_to(self.question)\n",
        "        new_question.set_color(RED)\n",
        "\n",
        "        self.play(Transform(self.question, new_question))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"confused\", new_question)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "    def distribute_ledger(self):\n",
        "        ledger = self.ledger\n",
        "        self.ledger_width = 6\n",
        "        self.ledger_height = 7\n",
        "        distribute_ledgers = self.get_distributed_ledgers()\n",
        "        group = VGroup(self.network, distribute_ledgers)\n",
        "\n",
        "        self.play(FadeOut(self.question))\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(ledger), distribute_ledgers\n",
        "        ))\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"pondering\", pi.ledger)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.play(\n",
        "            group.set_height, FRAME_HEIGHT - 2,\n",
        "            group.center\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def broadcast_transaction(self):\n",
        "        payment = OldTexText(\n",
        "            \"Alice\", \"pays\", \"Bob\", \"100 LD\"\n",
        "        )\n",
        "        payment.set_color_by_tex(\"Alice\", self.alice.get_color())\n",
        "        payment.set_color_by_tex(\"Bob\", self.bob.get_color())\n",
        "        payment.set_color_by_tex(\"LD\", YELLOW)\n",
        "        payment.scale(0.75)\n",
        "        payment.add_background_rectangle()\n",
        "        payment_copies = VGroup(*[\n",
        "            payment.copy().next_to(pi, UP)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        payment = payment_copies[0]\n",
        "\n",
        "        self.play(\n",
        "            self.alice.change, \"raise_right_hand\", payment,\n",
        "            Write(payment, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(payment), payment_copies, \n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            Broadcast(self.alice.get_corner(UP+RIGHT)),\n",
        "            self.alice.change, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        pairs = list(zip(payment_copies, self.pi_creatures))\n",
        "        Scene.play(self, *it.chain(*[\n",
        "            [\n",
        "                pi.look_at, pi.ledger[-1],\n",
        "                line.scale, 0.2,\n",
        "                line.next_to, pi.ledger[-1], DOWN, SMALL_BUFF,\n",
        "            ]\n",
        "            for line, pi in pairs\n",
        "        ]))\n",
        "        self.wait(3)\n",
        "\n",
        "        for line, pi in pairs:\n",
        "            pi.ledger.add(line)\n",
        "\n",
        "    def ask_about_ledger_consistency(self):\n",
        "        ledgers = VGroup(*[\n",
        "            pi.ledger\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.network),\n",
        "            ledgers.scale, 2,\n",
        "            ledgers.arrange, RIGHT,\n",
        "            ledgers.space_out_submobjects,\n",
        "        )\n",
        "\n",
        "        question = OldTexText(\"Are these the same?\")\n",
        "        question.scale(1.5)\n",
        "        question.to_edge(UP)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(question.get_bottom(), ledger.get_top())\n",
        "            for ledger in ledgers\n",
        "        ])\n",
        "\n",
        "        self.play(*list(map(ShowCreation, arrows)))\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "class BobDoubtsBroadcastTransaction(DistributedLedgerScene):\n",
        "    def construct(self):\n",
        "        self.setup_bob_and_charlie()\n",
        "        self.bob_receives_transaction()\n",
        "        self.bob_tries_to_pay_charlie()\n",
        "\n",
        "    def setup_bob_and_charlie(self):\n",
        "        bob, charlie = self.bob, self.charlie\n",
        "        self.pi_creatures = VGroup(bob, charlie)\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.flip()\n",
        "        self.pi_creatures.scale(2)\n",
        "        self.pi_creatures.arrange(RIGHT, buff = 5)\n",
        "\n",
        "        for name in \"bob\", \"charlie\":\n",
        "            label = OldTexText(name.capitalize())\n",
        "            pi = getattr(self, name)\n",
        "            label.next_to(pi, DOWN)\n",
        "            pi.label = label\n",
        "        bob.make_eye_contact(charlie)\n",
        "\n",
        "        self.get_distributed_ledgers()\n",
        "\n",
        "        self.add(bob, bob.label, bob.ledger)\n",
        "\n",
        "    def bob_receives_transaction(self):\n",
        "        bob, charlie = self.bob, self.charlie\n",
        "        corner = FRAME_Y_RADIUS*UP + FRAME_X_RADIUS*LEFT\n",
        "\n",
        "        payment = OldTexText(\n",
        "            \"Alice\", \"pays\", \"Bob\", \"10 LD\"\n",
        "        )\n",
        "        payment.set_color_by_tex(\"Alice\", self.alice.get_color())\n",
        "        payment.set_color_by_tex(\"Bob\", self.bob.get_color())\n",
        "        payment.set_color_by_tex(\"LD\", YELLOW)\n",
        "        payment.next_to(corner, UP+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Broadcast(corner),\n",
        "            ApplyMethod(\n",
        "                payment.next_to, bob, UP,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 1)\n",
        "            ),\n",
        "        )\n",
        "        self.play(bob.look_at, payment)\n",
        "        self.play(\n",
        "            payment.scale, 0.3,\n",
        "            payment.next_to, bob.ledger[-1], DOWN, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "    def bob_tries_to_pay_charlie(self):\n",
        "        bob, charlie = self.bob, self.charlie\n",
        "        chralie_group = VGroup(\n",
        "            charlie, charlie.label, charlie.ledger\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                bob, \"Did you hear that?\",\n",
        "                target_mode = \"sassy\"\n",
        "            ),\n",
        "            FadeIn(chralie_group)\n",
        "        )\n",
        "        self.play(charlie.change, \"maybe\", bob.eyes)\n",
        "        self.wait(2)\n",
        "\n",
        "class YouListeningToBroadcasts(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"denomination\" : \"LD\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        ledger = self.get_ledger()\n",
        "        payments = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in [\n",
        "                (\"Alice\", \"You\", 20),\n",
        "                (\"Bob\", \"You\", 50),\n",
        "                (\"Charlie\", \"You\", 30),\n",
        "            ]\n",
        "        ])\n",
        "        self.remove(self.ledger)\n",
        "        corners = [\n",
        "            FRAME_X_RADIUS*RIGHT*u1 + FRAME_Y_RADIUS*UP*u2\n",
        "            for u1, u2 in [(-1, 1), (1, 1), (-1, -1)]\n",
        "        ]\n",
        "        you = self.you\n",
        "        you.scale(2)\n",
        "        you.center()\n",
        "\n",
        "        self.add(you)\n",
        "        for payment, corner in zip(payments, corners):\n",
        "            vect = corner/get_norm(corner)\n",
        "            payment.next_to(corner, vect)\n",
        "            self.play(\n",
        "                Broadcast(corner),\n",
        "                ApplyMethod(\n",
        "                    payment.next_to, you, vect,\n",
        "                    run_time = 3,\n",
        "                    rate_func = squish_rate_func(smooth, 0.3, 1)\n",
        "                ),\n",
        "                you.change_mode, \"pondering\"\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "class AskWhatToAddToProtocol(InitialProtocol):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        items = VGroup(*list(map(self.get_new_item, [\n",
        "            \"Broadcast transactions\",\n",
        "            \"Only accept signed transactions\",\n",
        "            \"No overspending\",\n",
        "        ] + [\"\"]*6)))\n",
        "        brace = Brace(VGroup(*items[3:]), LEFT)\n",
        "        question = OldTexText(\"What to \\\\\\\\ add here?\")\n",
        "        question.set_color(RED)\n",
        "        question.scale(1.5)\n",
        "        brace.set_color(RED)\n",
        "        question.next_to(brace, LEFT)\n",
        "\n",
        "        self.add(*items[:3])\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "class TrustComputationalWork(DistributedLedgerScene):\n",
        "    def construct(self):\n",
        "        self.add_ledger()\n",
        "        self.show_work()\n",
        "\n",
        "    def add_ledger(self):\n",
        "        ledgers = self.get_distributed_ledgers()\n",
        "        ledger = ledgers[0]\n",
        "        ledger.scale(3)\n",
        "        ledger[1].scale(2./3)\n",
        "        ledger.center().to_edge(UP).shift(4*LEFT)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.next_to(ledger, RIGHT)\n",
        "\n",
        "        self.add(ledger, plus)\n",
        "        self.ledger = ledger\n",
        "        self.plus = plus\n",
        "\n",
        "    def show_work(self):\n",
        "        zeros = OldTex(\"0\"*32)\n",
        "        zeros.next_to(self.plus, RIGHT)\n",
        "        brace = Brace(zeros, DOWN)\n",
        "        words = brace.get_text(\"Computational work\")\n",
        "        self.add(brace, words)\n",
        "\n",
        "        for n in range(2**12):\n",
        "            binary = bin(n)[2:]\n",
        "            for i, bit_str in enumerate(reversed(binary)):\n",
        "                curr_bit = zeros.submobjects[-i-1]\n",
        "                new_bit = OldTex(bit_str)\n",
        "                new_bit.replace(curr_bit, dim_to_match = 1)\n",
        "                if bit_str == \"1\":\n",
        "                    new_bit.set_color(YELLOW)\n",
        "                zeros.submobjects[-i-1] = new_bit\n",
        "                self.remove(curr_bit)\n",
        "            self.add(zeros)\n",
        "            self.wait(1./30)\n",
        "\n",
        "class TrustComputationalWorkSupplement(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Main tool: \", \"Cryptographic hash functions\"\n",
        "        )\n",
        "        words[1].set_color(YELLOW)\n",
        "        self.add(words[0])\n",
        "        self.play(Write(words[1]))\n",
        "        self.wait()\n",
        "\n",
        "class FraudIsInfeasible(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Fraud\", \"$\\\\Leftrightarrow$\",\n",
        "            \"Computationally infeasible\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Fraud\", RED)\n",
        "        words.to_edge(UP)\n",
        "        self.play(FadeIn(words[0]))\n",
        "        self.play(FadeIn(words[2]))\n",
        "        self.play(Write(words[1]))\n",
        "        self.wait()\n",
        "\n",
        "class ThisIsWellIntoTheWeeds(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        idea = OldTexText(\"Proof of work\")\n",
        "        idea.move_to(self.teacher.get_corner(UP+LEFT))\n",
        "        idea.shift(MED_LARGE_BUFF*UP)\n",
        "        idea.save_state()\n",
        "        lightbulb = Lightbulb()\n",
        "        lightbulb.next_to(idea, UP)\n",
        "        idea.shift(DOWN)\n",
        "        idea.set_fill(opacity = 0)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"We're well into \\\\\\\\ the weeds now\",\n",
        "            target_mode = \"sassy\",\n",
        "            added_anims = [\n",
        "                ApplyMethod(pi.change, mode)\n",
        "                for pi, mode in zip(self.students, [\n",
        "                    \"hooray\", \"sad\", \"erm\"\n",
        "                ])\n",
        "            ],\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            idea.restore,\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode = \"hooray\",\n",
        "                look_at = lightbulb\n",
        "            ),\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            added_anims = [LaggedStartMap(FadeIn, lightbulb)]\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, lightbulb,\n",
        "            lambda b : (b.set_color, YELLOW_A),\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceSHA256(Scene):\n",
        "    def construct(self):\n",
        "        self.introduce_evaluation()\n",
        "        self.inverse_function_question()\n",
        "        self.issue_challenge()\n",
        "        self.shift_everything_down()\n",
        "        self.guess_and_check()\n",
        "\n",
        "    def introduce_evaluation(self):\n",
        "        messages = [\n",
        "            \"3Blue1Brown\",\n",
        "            \"3Blue1Crown\",\n",
        "            \"Mathologer\",\n",
        "            \"Infinite Series\",\n",
        "            \"Numberphile\",\n",
        "            \"Welch Labs\",\n",
        "            \"3Blue1Brown\",\n",
        "        ]\n",
        "        groups = VGroup()\n",
        "        for message in messages:\n",
        "            lhs = OldTexText(\n",
        "                \"SHA256\", \"(``\", message, \"'') =\",\n",
        "                arg_separator = \"\"\n",
        "            )\n",
        "            lhs.set_color_by_tex(message, BLUE)\n",
        "            digest = sha256_tex_mob(message)\n",
        "            digest.next_to(lhs, RIGHT)\n",
        "            group = VGroup(lhs, digest)\n",
        "            group.to_corner(UP+RIGHT)\n",
        "            group.shift(MED_LARGE_BUFF*DOWN)\n",
        "            groups.add(group)\n",
        "\n",
        "        group = groups[0]\n",
        "        lhs, digest = group\n",
        "        sha, lp, message, lp = lhs\n",
        "        sha_brace = Brace(sha, UP)\n",
        "        message_brace = Brace(message, DOWN)\n",
        "        digest_brace = Brace(digest, DOWN)\n",
        "        sha_text = sha_brace.get_text(\"\", \"Hash function\")\n",
        "        sha_text.set_color(YELLOW)\n",
        "        message_text = message_brace.get_text(\"Message/file\")\n",
        "        message_text.set_color(BLUE)\n",
        "        digest_text = digest_brace.get_text(\"``Hash'' or ``Digest''\")\n",
        "        brace_text_pairs = [\n",
        "            (sha_brace, sha_text),\n",
        "            (message_brace, message_text),\n",
        "            (digest_brace, digest_text),\n",
        "        ]\n",
        "\n",
        "        looks_random = OldTexText(\"Looks random\")\n",
        "        looks_random.set_color(MAROON_B)\n",
        "        looks_random.next_to(digest_text, DOWN)\n",
        "\n",
        "        self.add(group)\n",
        "        self.remove(digest)\n",
        "        for brace, text in brace_text_pairs:\n",
        "            if brace is digest_brace:\n",
        "                self.play(LaggedStartMap(\n",
        "                    FadeIn, digest,\n",
        "                    run_time = 4,\n",
        "                    lag_ratio = 0.05\n",
        "                ))\n",
        "                self.wait()\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text, run_time = 2)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Write(looks_random))\n",
        "        self.wait(2)\n",
        "        for mob in digest, message:\n",
        "            self.play(LaggedStartMap(\n",
        "                ApplyMethod, mob,\n",
        "                lambda m : (m.set_color, YELLOW),\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 1\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(looks_random))\n",
        "\n",
        "        new_lhs, new_digest = groups[1]\n",
        "        char = new_lhs[2][-5]\n",
        "        arrow = Arrow(UP, ORIGIN, buff = 0)\n",
        "        arrow.next_to(char, UP)\n",
        "        arrow.set_color(RED)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        for new_group in groups[1:]:\n",
        "            new_lhs, new_digest = new_group\n",
        "            new_message = new_lhs[2]\n",
        "            self.play(\n",
        "                Transform(lhs, new_lhs),\n",
        "                message_brace.stretch_to_fit_width, new_message.get_width(),\n",
        "                message_brace.next_to, new_message, DOWN,\n",
        "                MaintainPositionRelativeTo(message_text, message_brace),\n",
        "                MaintainPositionRelativeTo(sha_brace, lhs[0]),\n",
        "                MaintainPositionRelativeTo(sha_text, sha_brace)\n",
        "            )\n",
        "            self.play(Transform(\n",
        "                digest, new_digest,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = np.pi/2\n",
        "            ))\n",
        "            if arrow in self.get_mobjects():\n",
        "                self.wait()\n",
        "                self.play(FadeOut(arrow))\n",
        "        self.wait()\n",
        "\n",
        "        new_sha_text = OldTexText(\n",
        "            \"Cryptographic\", \"hash function\"\n",
        "        )\n",
        "        new_sha_text.next_to(sha_brace, UP)\n",
        "        new_sha_text.shift_onto_screen()\n",
        "        new_sha_text.set_color(YELLOW)\n",
        "        new_sha_text[0].set_color(GREEN)\n",
        "        self.play(Transform(sha_text, new_sha_text))\n",
        "        self.wait()\n",
        "\n",
        "        self.lhs = lhs\n",
        "        self.message = message\n",
        "        self.digest = digest\n",
        "        self.digest_text = digest_text\n",
        "        self.message_text = message_text\n",
        "\n",
        "    def inverse_function_question(self):\n",
        "        arrow = Arrow(3*RIGHT, 3*LEFT, buff = 0)\n",
        "        arrow.set_stroke(width = 8)\n",
        "        arrow.set_color(RED)\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        arrow.next_to(everything, DOWN)\n",
        "        words = OldTexText(\"Inverse is infeasible\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "    def issue_challenge(self):\n",
        "        desired_output_text = OldTexText(\"Desired output\")\n",
        "        desired_output_text.move_to(self.digest_text)\n",
        "        desired_output_text.set_color(YELLOW)\n",
        "        new_digest = sha256_tex_mob(\"Challenge\")\n",
        "        new_digest.replace(self.digest)\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.move_to(self.message_text)\n",
        "        q_marks.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            Transform(\n",
        "                self.digest, new_digest,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = np.pi/2\n",
        "            ),\n",
        "            Transform(self.digest_text, desired_output_text)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.message),\n",
        "            Transform(self.message_text, q_marks)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def shift_everything_down(self):\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        self.play(\n",
        "            everything.scale, 0.85,\n",
        "            everything.to_edge, DOWN\n",
        "        )\n",
        "\n",
        "    def guess_and_check(self):\n",
        "        groups = VGroup()\n",
        "        for x in range(32):\n",
        "            message = \"Guess \\\\#%d\"%x\n",
        "            lhs = OldTexText(\n",
        "                \"SHA256(``\", message, \"'') = \",\n",
        "                arg_separator = \"\"\n",
        "            )\n",
        "            lhs.set_color_by_tex(\"Guess\", BLUE)\n",
        "            digest = sha256_tex_mob(message)\n",
        "            digest.next_to(lhs, RIGHT)\n",
        "            group = VGroup(lhs, digest)\n",
        "            group.scale(0.85)\n",
        "            group.next_to(self.digest, UP, aligned_edge = RIGHT)\n",
        "            group.to_edge(UP)\n",
        "            groups.add(group)\n",
        "\n",
        "        group = groups[0]\n",
        "        self.play(FadeIn(group))\n",
        "        for new_group in groups[1:]:\n",
        "            self.play(Transform(\n",
        "                group[0], new_group[0],\n",
        "                run_time = 0.5,\n",
        "            ))\n",
        "            self.play(Transform(\n",
        "                group[1], new_group[1],\n",
        "                run_time = 1,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "\n",
        "class PonderScematic(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        self.play(randy.change, \"confused\", ORIGIN)\n",
        "        for x in range(3):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait(2)\n",
        "\n",
        "class ViewingSLLCertificate(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class SHA256ToProofOfWork(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        sha = OldTexText(\"SHA256\")\n",
        "        proof = OldTexText(\"Proof of work\")\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        group = VGroup(sha, arrow, proof)\n",
        "        group.arrange(RIGHT)\n",
        "        group.next_to(self.teacher, UP, buff = LARGE_BUFF)\n",
        "        group.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(sha, run_time = 1),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(proof, run_time = 1))\n",
        "        self.wait(3)\n",
        "\n",
        "class IntroduceNonceOnTrasactions(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"denomination\" : \"LD\",\n",
        "        \"ledger_width\" : 5,\n",
        "        \"ledger_line_height\" : 0.3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add(self.get_ledger())\n",
        "        self.hash_with_nonce()\n",
        "        self.write_probability()\n",
        "        self.guess_and_check()\n",
        "        self.name_proof_of_work()\n",
        "        self.change_ledger()\n",
        "        self.guess_and_check()\n",
        "\n",
        "    def hash_with_nonce(self):\n",
        "        ledger = self.ledger\n",
        "        self.add(*[\n",
        "            self.add_payment_line_to_ledger(*payment)\n",
        "            for payment in [\n",
        "                (\"Alice\", \"Bob\", 20),\n",
        "                (\"Alice\", \"You\", 30),\n",
        "                (\"Charlie\", \"You\", 100),\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        nonce = OldTex(str(2**30 + hash(\"Hey there\")%(2**15)))\n",
        "        nonce.next_to(ledger, RIGHT, LARGE_BUFF)\n",
        "        nonce.set_color(GREEN_C)\n",
        "        nonce_brace = Brace(nonce, DOWN)\n",
        "        special_word = nonce_brace.get_text(\"Special number\")\n",
        "        arrow = Arrow(LEFT, RIGHT, buff = 0)\n",
        "        arrow.next_to(ledger, RIGHT)\n",
        "        arrow.shift(MED_LARGE_BUFF*DOWN)\n",
        "        sha = OldTexText(\"SHA256\")\n",
        "        sha.next_to(arrow, UP)\n",
        "        digest = sha256_tex_mob(\n",
        "            \"\"\"Man, you're reading this deeply into\n",
        "            the code behind videos?  I'm touched,\n",
        "            really touched.  Keeping loving math, my\n",
        "            friend. \"\"\",\n",
        "            n_forced_start_zeros = 30,\n",
        "        )\n",
        "        digest.next_to(arrow, RIGHT)\n",
        "        zeros = VGroup(*digest[:30])\n",
        "        zeros_brace = Brace(zeros, UP)\n",
        "        zeros_words = zeros_brace.get_text(\"30 zeros\")\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(special_word, nonce_brace, nonce)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            nonce.next_to, ledger.content, DOWN, MED_SMALL_BUFF, LEFT,\n",
        "            FadeOut(special_word),\n",
        "            FadeOut(nonce_brace)\n",
        "        )\n",
        "        ledger.content.add(nonce)\n",
        "        decomposed_ledger = VGroup(*[m for m in ledger.family_members_with_points() if not m.is_subpath])\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(sha)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, decomposed_ledger,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        point = VectorizedPoint(sha.get_center())\n",
        "        point.set_fill(opacity = 1)\n",
        "        self.play(LaggedStartMap(\n",
        "            Transform, decomposed_ledger.copy(),\n",
        "            lambda m : (m, point),\n",
        "            run_time = 1\n",
        "        ))\n",
        "        bit_iter = iter(digest)\n",
        "        self.play(LaggedStartMap(\n",
        "            ReplacementTransform, \n",
        "            VGroup(*[point.copy() for x in range(256)]),\n",
        "            lambda m : (m, next(bit_iter)),\n",
        "        ))\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(digest)\n",
        "        self.play(\n",
        "            GrowFromCenter(zeros_brace),\n",
        "            Write(zeros_words, run_time = 1)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, zeros,\n",
        "            lambda m : (m.set_color, YELLOW)\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.nonce = nonce\n",
        "        self.digest = digest\n",
        "        self.zeros_brace = zeros_brace\n",
        "        self.zeros_words = zeros_words\n",
        "\n",
        "    def write_probability(self):\n",
        "        probability = OldTexText(\n",
        "            \"Probability: $\\\\frac{1}{2^{30}}$\",\n",
        "            \"$\\\\approx \\\\frac{1}{1{,}000{,}000{,}000}$\",\n",
        "        )\n",
        "        probability.next_to(self.zeros_words, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(probability[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(probability[1], run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "    def guess_and_check(self):\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.set_color(RED)\n",
        "        q_mark.next_to(self.zeros_words, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.digest.save_state()\n",
        "        self.nonce.save_state()\n",
        "\n",
        "        self.play(FadeIn(q_mark))\n",
        "        for x in range(1, 13):\n",
        "            nonce = OldTex(str(x))\n",
        "            nonce.move_to(self.nonce)\n",
        "            nonce.set_color(GREEN_C)\n",
        "            digest = sha256_tex_mob(str(x))\n",
        "            digest.replace(self.digest)\n",
        "\n",
        "            self.play(Transform(\n",
        "                self.nonce, nonce,\n",
        "                run_time = 1 if x == 1 else 0.3\n",
        "            ))\n",
        "            self.play(Transform(\n",
        "                self.digest, digest,\n",
        "                run_time = 1,\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(self.nonce.restore)\n",
        "        self.play(\n",
        "            self.digest.restore, \n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeOut(q_mark))\n",
        "        self.wait()\n",
        "\n",
        "    def name_proof_of_work(self):\n",
        "        words = OldTexText(\"``Proof of work''\")\n",
        "        words.next_to(self.nonce, DOWN, LARGE_BUFF)\n",
        "        words.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        words.set_color(GREEN)\n",
        "        arrow = Arrow(\n",
        "            words.get_top(), self.nonce.get_bottom(),\n",
        "            color = WHITE,\n",
        "            tip_length = 0.15\n",
        "        )\n",
        "        self.play(Write(words, run_time = 2))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def change_ledger(self):\n",
        "        amount = self.ledger.content[2][-1]\n",
        "        new_amount = OldTexText(\"300 LD\")\n",
        "        new_amount.set_height(amount.get_height())\n",
        "        new_amount.set_color(amount.get_color())\n",
        "        new_amount.move_to(amount, LEFT)\n",
        "\n",
        "        new_digest = sha256_tex_mob(\"Ah shucks\")\n",
        "        new_digest.replace(self.digest)\n",
        "\n",
        "        dot = Dot(amount.get_center())\n",
        "        dot.set_fill(opacity = 0.5)\n",
        "\n",
        "        self.play(FocusOn(amount))\n",
        "        self.play(Transform(amount, new_amount))\n",
        "        self.play(\n",
        "            dot.move_to, new_digest,\n",
        "            dot.set_fill, None, 0\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            self.digest, new_digest,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "\n",
        "class ShowSomeBroadcasting(DistributedLedgerScene):\n",
        "    def construct(self):\n",
        "        self.add_large_network_and_distributed_ledger()\n",
        "        lines = self.network.lines.copy()\n",
        "        lines.add(*[\n",
        "            line.copy().rotate(np.pi)\n",
        "            for line in lines\n",
        "        ])\n",
        "\n",
        "        point = VectorizedPoint(self.pi_creatures.get_center())\n",
        "        last_pi = None\n",
        "        for pi in self.pi_creatures:\n",
        "            outgoing_lines = []\n",
        "            for line in lines:\n",
        "                vect = line.get_start() - pi.get_center()\n",
        "                dist = get_norm(vect)\n",
        "                if dist < 2:\n",
        "                    outgoing_lines.append(line)\n",
        "            dots = VGroup()\n",
        "            for line in outgoing_lines:\n",
        "                dot = Dot(line.get_start())\n",
        "                dot.set_color(YELLOW)\n",
        "                dot.generate_target()\n",
        "                dot.target.move_to(line.get_end())\n",
        "                for alt_pi in self.pi_creatures:\n",
        "                    vect = line.get_end() - alt_pi.get_center()\n",
        "                    dist = get_norm(vect)\n",
        "                    if dist < 2:\n",
        "                        dot.ledger = alt_pi.ledger\n",
        "                dots.add(dot)\n",
        "            self.play(\n",
        "                Animation(point),\n",
        "                Broadcast(pi),\n",
        "                *[\n",
        "                    Succession(\n",
        "                        FadeIn(dot),\n",
        "                        MoveToTarget(dot, run_time = 2),\n",
        "                    )\n",
        "                    for dot in dots\n",
        "                ]\n",
        "            )\n",
        "            self.play(*it.chain(*[\n",
        "                [dot.move_to, dot.ledger, dot.set_fill, None, 0]\n",
        "                for dot in dots\n",
        "            ]))\n",
        "\n",
        "class IntroduceBlockChain(Scene):\n",
        "    CONFIG = {\n",
        "        \"transaction_color\" : YELLOW,\n",
        "        \"proof_of_work_color\" : GREEN,\n",
        "        \"prev_hash_color\" : BLUE,\n",
        "        \"block_width\" : 3,\n",
        "        \"block_height\" : 3.5,\n",
        "        \"n_transaction_lines\" : 8,\n",
        "        \"payment_height_to_block_height\" : 0.15,\n",
        "    }\n",
        "    def setup(self):\n",
        "        ls = LedgerScene()\n",
        "        self.names = [\n",
        "            name.capitalize()\n",
        "            for name in ls.get_names()\n",
        "        ]\n",
        "        self.name_colors = [\n",
        "            ls.get_color_from_name(name)\n",
        "            for name in self.names\n",
        "        ]\n",
        "\n",
        "    def construct(self):\n",
        "        self.divide_ledger_into_blocks()\n",
        "        self.show_proofs_of_work()\n",
        "        self.chain_blocks_together()\n",
        "        self.mess_with_early_block()\n",
        "        self.propagate_hash_change()\n",
        "        self.redo_proof_of_work()\n",
        "        self.write_block_chain()\n",
        "\n",
        "\n",
        "    def divide_ledger_into_blocks(self):\n",
        "        blocks = VGroup(*[\n",
        "            self.get_block() for x in range(3)\n",
        "        ])\n",
        "        blocks.arrange(RIGHT, buff = 1.5)\n",
        "        blocks.to_edge(UP)\n",
        "\n",
        "        all_payments = VGroup()\n",
        "        all_proofs_of_work = VGroup()\n",
        "        for block in blocks:\n",
        "            block.remove(block.prev_hash)\n",
        "            all_payments.add(*block.payments)\n",
        "            all_proofs_of_work.add(block.proof_of_work)\n",
        "\n",
        "        blocks_word = OldTexText(\"Blocks\")\n",
        "        blocks_word.scale(1.5)\n",
        "        blocks_word.shift(2*DOWN)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                blocks_word.get_top(), block.get_bottom(),\n",
        "                buff = MED_LARGE_BUFF,\n",
        "                color = WHITE\n",
        "            )\n",
        "            for block in blocks\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, blocks))\n",
        "        self.play(\n",
        "            Write(blocks_word),\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, arrows, \n",
        "                run_time = 1,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for group in all_payments, all_proofs_of_work:\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, group,\n",
        "                rate_func = there_and_back,\n",
        "                scale_factor = 1.1,\n",
        "            ))\n",
        "        self.play(*list(map(FadeOut, [blocks_word, arrows])))\n",
        "\n",
        "        self.blocks = blocks\n",
        "\n",
        "    def show_proofs_of_work(self):\n",
        "        random.seed(0)\n",
        "        blocks = self.blocks\n",
        "\n",
        "        proofs_of_work = VGroup()\n",
        "        new_proofs_of_work = VGroup()\n",
        "        digests = VGroup()\n",
        "        arrows = VGroup()\n",
        "        sha_words = VGroup()\n",
        "        signatures = VGroup()\n",
        "\n",
        "        for block in blocks:\n",
        "            proofs_of_work.add(block.proof_of_work)\n",
        "            num_str = str(random.randint(0, 10**12))\n",
        "            number = OldTex(num_str)\n",
        "            number.set_color(self.proof_of_work_color)\n",
        "            number.replace(block.proof_of_work, dim_to_match = 1)\n",
        "            new_proofs_of_work.add(number)\n",
        "\n",
        "            digest = sha256_tex_mob(num_str, 60)\n",
        "            digest.scale(0.7)\n",
        "            digest.move_to(block).to_edge(DOWN)\n",
        "            VGroup(*digest[:60]).set_color(YELLOW)\n",
        "            arrow = Arrow(block, digest)\n",
        "            sha = OldTexText(\"SHA256\")\n",
        "            sha.scale(0.7)\n",
        "            point = arrow.get_center()\n",
        "            sha.next_to(point, UP, SMALL_BUFF)\n",
        "            sha.rotate(-np.pi/2, about_point = point)\n",
        "            sha.shift(SMALL_BUFF*(UP+RIGHT))\n",
        "            digests.add(digest)\n",
        "            arrows.add(arrow)\n",
        "            sha_words.add(sha)\n",
        "\n",
        "            for payment in block.payments[:2]:\n",
        "                signatures.add(payment[-1])\n",
        "\n",
        "        proofs_of_work.save_state()\n",
        "\n",
        "        self.play(Transform(\n",
        "            proofs_of_work, new_proofs_of_work,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(arrows),\n",
        "            Write(sha_words),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Write(digests))\n",
        "        self.wait()\n",
        "        for group in signatures, proofs_of_work:\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, group,\n",
        "                run_time = 2,\n",
        "                rate_func = there_and_back,\n",
        "            ))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            proofs_of_work.restore,\n",
        "            FadeOut(sha_words)\n",
        "        )\n",
        "\n",
        "        self.digests = digests\n",
        "        self.sha_arrows = arrows\n",
        "\n",
        "    def chain_blocks_together(self):\n",
        "        blocks = self.blocks\n",
        "        digests = self.digests\n",
        "        sha_arrows = self.sha_arrows\n",
        "        block_spacing = blocks[1].get_center() - blocks[0].get_center()\n",
        "        prev_hashes = VGroup(*[\n",
        "            block.prev_hash for block in blocks\n",
        "        ])\n",
        "\n",
        "        prev_hashes.add(\n",
        "            prev_hashes[-1].copy().shift(block_spacing).fade(1)\n",
        "        )\n",
        "\n",
        "        new_arrows = VGroup()\n",
        "        for block in blocks:\n",
        "            end = np.array([\n",
        "                block.get_left()[0] + block_spacing[0],\n",
        "                block.prev_hash.get_center()[1],\n",
        "                0\n",
        "            ])\n",
        "            arrow = Arrow(end+LEFT, end, buff = SMALL_BUFF)\n",
        "            arrow.get_points()[0] = block.get_right()\n",
        "            arrow.get_points()[1] = block.get_right() + RIGHT\n",
        "            arrow.get_points()[2] = end + LEFT + SMALL_BUFF*UP\n",
        "            new_arrows.add(arrow)\n",
        "\n",
        "        for i in range(3):\n",
        "            self.play(\n",
        "                ReplacementTransform(digests[i], prev_hashes[i+1]),\n",
        "                Transform(sha_arrows[i], new_arrows[i])\n",
        "            )\n",
        "        arrow = new_arrows[0].copy().shift(-block_spacing)\n",
        "        sha_arrows.add_to_back(arrow)\n",
        "        self.play(*list(map(FadeIn, [arrow, prev_hashes[0]])))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.prev_hashes = prev_hashes\n",
        "\n",
        "    def mess_with_early_block(self):\n",
        "        blocks = self.blocks\n",
        "        amount = blocks[0].payments[1][3]\n",
        "        new_amount = OldTexText(\"400 LD\")\n",
        "        new_amount.set_height(amount.get_height())\n",
        "        new_amount.set_color(RED)\n",
        "        new_amount.move_to(amount, LEFT)\n",
        "\n",
        "        self.play(FocusOn(amount))\n",
        "        self.play(Transform(amount, new_amount))\n",
        "        self.wait()\n",
        "        self.play(Swap(*blocks[:2]))\n",
        "        self.wait()\n",
        "\n",
        "        blocks.submobjects[:2] = blocks.submobjects[1::-1]\n",
        "\n",
        "    def propagate_hash_change(self):\n",
        "        prev_hashes = self.prev_hashes\n",
        "\n",
        "        for block, prev_hash in zip(self.blocks, prev_hashes[1:]):\n",
        "            rect = block.rect.copy()\n",
        "            rect.set_stroke(RED, 8)\n",
        "            rect.target = SurroundingRectangle(prev_hash)\n",
        "            rect.target.set_stroke(rect.get_color(), 0)\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.play(\n",
        "                MoveToTarget(rect),\n",
        "                prev_hash.set_color, RED\n",
        "            )\n",
        "\n",
        "    def redo_proof_of_work(self):\n",
        "        proofs_of_work = VGroup(*[\n",
        "            block.proof_of_work for block in self.blocks\n",
        "        ])\n",
        "        hashes = self.prev_hashes[1:]\n",
        "\n",
        "        self.play(FadeOut(proofs_of_work))\n",
        "        for proof_of_work, prev_hash in zip(proofs_of_work, hashes):\n",
        "            num_pow_group = VGroup(*[\n",
        "                Integer(random.randint(10**9, 10**10))\n",
        "                for x in range(50)\n",
        "            ])\n",
        "            num_pow_group.set_color(proof_of_work.get_color())\n",
        "            num_pow_group.set_width(proof_of_work.get_width())\n",
        "            num_pow_group.move_to(proof_of_work)\n",
        "            for num_pow in num_pow_group:\n",
        "                self.add(num_pow)\n",
        "                self.wait(1./20)\n",
        "                prev_hash.set_color(random_bright_color())\n",
        "                self.remove(num_pow)\n",
        "            self.add(num_pow)\n",
        "            prev_hash.set_color(BLUE)\n",
        "\n",
        "    def write_block_chain(self):\n",
        "        ledger = OldTexText(\"Ledger\")\n",
        "        ledger.next_to(self.blocks, DOWN, LARGE_BUFF)\n",
        "        cross = Cross(ledger)\n",
        "        block_chain = OldTexText(\"``Block Chain''\")\n",
        "        block_chain.next_to(ledger, DOWN)\n",
        "\n",
        "        self.play(FadeIn(ledger))\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            Write(block_chain)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_block(self):\n",
        "        block = VGroup()\n",
        "        rect = Rectangle(\n",
        "            color = WHITE,\n",
        "            height = self.block_height,\n",
        "            width = self.block_width,\n",
        "        )\n",
        "        h_line1, h_line2 = [\n",
        "            Line(\n",
        "                rect.get_left(), rect.get_right()\n",
        "            ).shift(0.3*rect.get_height()*vect)\n",
        "            for vect in (UP, DOWN)\n",
        "        ]\n",
        "\n",
        "        payments = VGroup()\n",
        "        if not hasattr(self, \"transaction_counter\"):\n",
        "            self.transaction_counter = 0\n",
        "        for x in range(2):\n",
        "            hashes = [\n",
        "                hash(\"%d %d\"%(seed, self.transaction_counter))\n",
        "                for seed in range(3)\n",
        "            ]\n",
        "            payment = OldTexText(\n",
        "                self.names[hashes[0]%3],\n",
        "                \"pays\",\n",
        "                self.names[hashes[1]%4],\n",
        "                \"%d0 LD\"%(hashes[2]%9 + 1),\n",
        "            )\n",
        "            payment.set_color_by_tex(\"LD\", YELLOW)\n",
        "            for name, color in zip(self.names, self.name_colors):\n",
        "                payment.set_color_by_tex(name, color)\n",
        "            signature = OldTexText(\"$\\\\langle$ Signature $\\\\rangle$\")\n",
        "            signature.set_color(payment[0].get_color())\n",
        "            signature.next_to(payment, DOWN, SMALL_BUFF)\n",
        "            payment.add(signature)\n",
        "\n",
        "            factor = self.payment_height_to_block_height\n",
        "            payment.set_height(factor*rect.get_height())\n",
        "            payments.add(payment)\n",
        "            self.transaction_counter += 1\n",
        "        payments.add(OldTex(\"\\\\dots\").scale(0.5))\n",
        "        payments.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        payments.next_to(h_line1, DOWN)\n",
        "\n",
        "        proof_of_work = OldTexText(\"Proof of work\")\n",
        "        proof_of_work.set_color(self.proof_of_work_color)\n",
        "        proof_of_work.scale(0.8)\n",
        "        proof_of_work.move_to(\n",
        "            VGroup(h_line2, VectorizedPoint(rect.get_bottom()))\n",
        "        )\n",
        "\n",
        "        prev_hash = OldTexText(\"Prev hash\")\n",
        "        prev_hash.scale(0.8)\n",
        "        prev_hash.set_color(self.prev_hash_color)\n",
        "        prev_hash.move_to(\n",
        "            VGroup(h_line1, VectorizedPoint(rect.get_top()))\n",
        "        )\n",
        "\n",
        "        block.rect = rect\n",
        "        block.h_lines = VGroup(h_line1, h_line2)\n",
        "        block.payments = payments\n",
        "        block.proof_of_work = proof_of_work\n",
        "        block.prev_hash = prev_hash\n",
        "        block.digest_mobject_attrs()\n",
        "        return block\n",
        "\n",
        "class DistributedBlockChainScene(DistributedLedgerScene):\n",
        "    CONFIG = {\n",
        "        \"block_height\" : 0.5,\n",
        "        \"block_width\" : 0.5,\n",
        "        \"n_blocks\" : 3,\n",
        "    }\n",
        "    def get_distributed_ledgers(self):\n",
        "        ledgers = VGroup()\n",
        "        point = self.pi_creatures.get_center()\n",
        "        for pi in self.pi_creatures:\n",
        "            vect = pi.get_center() - point\n",
        "            vect[0] = 0\n",
        "            block_chain = self.get_block_chain()\n",
        "            block_chain.next_to(\n",
        "                VGroup(pi, pi.label), vect, SMALL_BUFF\n",
        "            )\n",
        "            pi.block_chain = pi.ledger = block_chain\n",
        "            ledgers.add(block_chain)\n",
        "        self.ledgers = self.block_chains = ledgers\n",
        "        return ledgers\n",
        "\n",
        "    def get_block_chain(self):\n",
        "        blocks = VGroup(*[\n",
        "            self.get_block() \n",
        "            for x in range(self.n_blocks)\n",
        "        ])\n",
        "        blocks.arrange(RIGHT, buff = MED_SMALL_BUFF)\n",
        "        arrows = VGroup()\n",
        "\n",
        "        for b1, b2 in zip(blocks, blocks[1:]):\n",
        "            arrow = Arrow(\n",
        "                LEFT, RIGHT,\n",
        "                preserve_tip_size_when_scaling = False,\n",
        "                tip_length = 0.15,\n",
        "            )\n",
        "            arrow.set_width(b1.get_width())\n",
        "            target_point = interpolate(\n",
        "                b2.get_left(), b2.get_corner(UP+LEFT), 0.8\n",
        "            )\n",
        "            arrow.next_to(target_point, LEFT, 0.5*SMALL_BUFF)\n",
        "            arrow.get_points()[0] = b1.get_right()\n",
        "            arrow.get_points()[1] = b2.get_left()\n",
        "            arrow.get_points()[2] = b1.get_corner(UP+RIGHT)\n",
        "            arrow.get_points()[2] += SMALL_BUFF*LEFT\n",
        "            arrows.add(arrow)\n",
        "        block_chain = VGroup(blocks, arrows)\n",
        "        block_chain.blocks = blocks\n",
        "        block_chain.arrows = arrows\n",
        "        return block_chain\n",
        "\n",
        "    def get_block(self):\n",
        "        block = Rectangle(\n",
        "            color = WHITE,\n",
        "            height = self.block_height,\n",
        "            width = self.block_width,\n",
        "        )\n",
        "        for vect in UP, DOWN:\n",
        "            line = Line(block.get_left(), block.get_right())\n",
        "            line.shift(0.3*block.get_height()*vect)\n",
        "            block.add(line)\n",
        "        return block\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        creatures = DistributedLedgerScene.create_pi_creatures(self)\n",
        "        VGroup(\n",
        "            self.alice, self.alice.label,\n",
        "            self.charlie, self.charlie.label,\n",
        "        ).shift(LEFT)\n",
        "        return creatures\n",
        "\n",
        "#Out of order\n",
        "class FromBankToDecentralizedSystem(DistributedBlockChainScene):\n",
        "    CONFIG = {\n",
        "        \"n_blocks\" : 5,\n",
        "        \"ledger_height\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove_bank()\n",
        "        self.show_block_chains()\n",
        "        self.add_crypto_terms()\n",
        "        self.set_aside_everything()\n",
        "\n",
        "    def remove_bank(self):\n",
        "        bank = SVGMobject(\n",
        "            file_name = \"bank_building\",\n",
        "            color = GREY_B,\n",
        "            height = 3,\n",
        "        )\n",
        "        cross = Cross(bank)\n",
        "        cross.set_stroke(width = 10)\n",
        "        group = VGroup(bank, cross)\n",
        "\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, bank))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            group.next_to, FRAME_X_RADIUS*RIGHT, RIGHT,\n",
        "            rate_func = running_start,\n",
        "            path_arc = -np.pi/6,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(group)\n",
        "\n",
        "    def show_block_chains(self):\n",
        "        creatures = self.pi_creatures\n",
        "        creatures.center()\n",
        "        VGroup(self.charlie, self.you).to_edge(DOWN)\n",
        "        chains = self.get_distributed_ledgers()\n",
        "        for pi, chain in zip(creatures, chains):\n",
        "            pi.scale(1.5)\n",
        "            pi.shift(0.5*pi.get_center()[0]*RIGHT)\n",
        "            chain.next_to(pi, UP)\n",
        "        center_chain = self.get_block_chain()\n",
        "        center_chain.scale(2)\n",
        "        center_chain.center()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, creatures, run_time = 1))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, center_chain.blocks, run_time = 1),\n",
        "            ShowCreation(center_chain.arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(VGroup(center_chain), chains),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"pondering\", pi.ledger)\n",
        "                for pi in creatures\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_crypto_terms(self):\n",
        "        terms = OldTexText(\n",
        "            \"Digital signatures \\\\\\\\\",\n",
        "            \"Cryptographic hash functions\",\n",
        "        )\n",
        "        terms.set_color_by_tex(\"signature\", BLUE)\n",
        "        terms.set_color_by_tex(\"hash\", YELLOW)\n",
        "        for term in terms:\n",
        "            self.play(Write(term, run_time = 1))\n",
        "            self.wait()\n",
        "        self.digital_signature = terms[0]\n",
        "\n",
        "    def set_aside_everything(self):\n",
        "        digital_signature = self.digital_signature\n",
        "        ledger = LedgerScene.get_ledger(self)\n",
        "        LedgerScene.add_payment_line_to_ledger(self, \n",
        "            \"Alice\", \"Bob\", \"40\",\n",
        "        )\n",
        "        LedgerScene.add_payment_line_to_ledger(self,\n",
        "            \"Charlie\", \"Alice\", \"60\",\n",
        "        )\n",
        "        ledger.next_to(ORIGIN, LEFT)\n",
        "\n",
        "        self.remove(digital_signature)\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "\n",
        "        self.play(\n",
        "            Animation(digital_signature),\n",
        "            everything.scale, 0.1,\n",
        "            everything.to_corner, DOWN+LEFT,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(ledger),\n",
        "            digital_signature.next_to, ORIGIN, RIGHT\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceBlockCreator(DistributedBlockChainScene):\n",
        "    CONFIG = {\n",
        "        \"n_block_creators\" : 3,\n",
        "        \"n_pow_guesses\" : 60,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_network()\n",
        "        self.add_block_creators()\n",
        "        self.broadcast_transactions()\n",
        "        self.collect_transactions()\n",
        "        self.find_proof_of_work()\n",
        "        self.add_block_reward()\n",
        "        self.comment_on_block_reward()\n",
        "        self.write_miners()\n",
        "        self.broadcast_block()\n",
        "\n",
        "    def add_network(self):\n",
        "        network = self.get_large_network()\n",
        "        network.remove(network.lines)\n",
        "        network.scale(0.7)\n",
        "        ledgers = self.get_distributed_ledgers()\n",
        "        self.add(network, ledgers)\n",
        "        VGroup(network, ledgers).to_edge(RIGHT)\n",
        "\n",
        "    def add_block_creators(self):\n",
        "        block_creators = VGroup()\n",
        "        labels = VGroup()\n",
        "        everything = VGroup()\n",
        "        for x in range(self.n_block_creators):\n",
        "            block_creator = PiCreature(color = GREY)\n",
        "            block_creator.set_height(self.alice.get_height())\n",
        "            label = OldTexText(\"Block creator %d\"%(x+1))\n",
        "            label.scale(0.7)\n",
        "            label.next_to(block_creator, DOWN, SMALL_BUFF)\n",
        "            block_creator.label = label\n",
        "            block_creators.add(block_creator)\n",
        "            labels.add(label)\n",
        "            everything.add(VGroup(block_creator, label))\n",
        "        everything.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        everything.to_edge(LEFT)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, everything))\n",
        "        self.pi_creatures.add(*block_creators)\n",
        "        self.wait()\n",
        "\n",
        "        self.block_creators = block_creators\n",
        "        self.block_creator_labels = labels\n",
        "\n",
        "    def broadcast_transactions(self):\n",
        "        payment_parts = [\n",
        "            (\"Alice\", \"Bob\", 20),\n",
        "            (\"Bob\", \"Charlie\", 10),\n",
        "            (\"Charlie\", \"You\", 50),\n",
        "            (\"You\", \"Alice\", 30),\n",
        "        ]\n",
        "        payments = VGroup()\n",
        "        payment_targets = VGroup()\n",
        "        for from_name, to_name, amount in payment_parts:\n",
        "            verb = \"pay\" if from_name == \"You\" else \"pays\"\n",
        "            payment = OldTexText(\n",
        "                from_name, verb, to_name, \"%d LD\"%amount\n",
        "            )\n",
        "            payment.set_color_by_tex(\"LD\", YELLOW)\n",
        "            for name in self.get_names():\n",
        "                payment.set_color_by_tex(\n",
        "                    name.capitalize(),\n",
        "                    self.get_color_from_name(name)\n",
        "                )\n",
        "            payment.scale(0.7)\n",
        "            payment.generate_target()\n",
        "            payment_targets.add(payment.target)\n",
        "\n",
        "            pi = getattr(self, from_name.lower())\n",
        "            payment.scale(0.1)\n",
        "            payment.set_fill(opacity = 0)\n",
        "            payment.move_to(pi)\n",
        "            payments.add(payment)\n",
        "        payment_targets.arrange(DOWN, aligned_edge = LEFT)\n",
        "        payment_targets.next_to(\n",
        "            self.block_creator_labels, RIGHT,\n",
        "            MED_LARGE_BUFF\n",
        "        )\n",
        "        payment_targets.shift(UP)\n",
        "\n",
        "        anims = []\n",
        "        alpha_range = np.linspace(0, 0.5, len(payments))\n",
        "        for pi, payment, alpha in zip(self.pi_creatures, payments, alpha_range):\n",
        "            rf1 = squish_rate_func(smooth, alpha, alpha+0.5)\n",
        "            rf2 = squish_rate_func(smooth, alpha, alpha+0.5)\n",
        "            anims.append(Broadcast(\n",
        "                pi, rate_func = rf1,\n",
        "                big_radius = 3,\n",
        "            ))\n",
        "            anims.append(MoveToTarget(payment, rate_func = rf2))\n",
        "\n",
        "        self.play(*anims, run_time = 5)\n",
        "        self.payments = payments\n",
        "\n",
        "    def collect_transactions(self):\n",
        "        creator = self.block_creators[0]\n",
        "        block = self.get_block()\n",
        "        block.stretch_to_fit_height(4)\n",
        "        block.stretch_to_fit_width(3.5)\n",
        "        block.next_to(creator.label, RIGHT, MED_LARGE_BUFF)\n",
        "        block.to_edge(UP)\n",
        "\n",
        "        payments = self.payments\n",
        "        payments.generate_target()\n",
        "        payments.target.set_height(1.5)\n",
        "        payments.target.move_to(block)\n",
        "\n",
        "        prev_hash = OldTexText(\"Prev hash\")\n",
        "        prev_hash.set_color(BLUE)\n",
        "        prev_hash.set_height(0.3)\n",
        "        prev_hash.next_to(block.get_top(), DOWN, MED_SMALL_BUFF)\n",
        "        block.add(prev_hash)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(block),\n",
        "            MoveToTarget(payments),\n",
        "            creator.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        block.add(payments)\n",
        "\n",
        "        self.block = block\n",
        "\n",
        "    def find_proof_of_work(self):\n",
        "        block = self.block\n",
        "\n",
        "        arrow = Arrow(UP, ORIGIN, buff = 0)\n",
        "        arrow.next_to(block, DOWN)\n",
        "        sha = OldTexText(\"SHA256\")\n",
        "        sha.scale(0.7)\n",
        "        sha.next_to(arrow, RIGHT)\n",
        "        arrow.add(sha)\n",
        "\n",
        "        self.add(arrow)\n",
        "        for x in range(self.n_pow_guesses):\n",
        "            guess = Integer(random.randint(10**11, 10**12))\n",
        "            guess.set_color(GREEN)\n",
        "            guess.set_height(0.3)\n",
        "            guess.next_to(block.get_bottom(), UP, MED_SMALL_BUFF)\n",
        "\n",
        "            if x == self.n_pow_guesses - 1:\n",
        "                digest = sha256_tex_mob(str(x), 60)\n",
        "                VGroup(*digest[:60]).set_color(YELLOW)\n",
        "            else:\n",
        "                digest = sha256_tex_mob(str(x))\n",
        "            digest.set_width(block.get_width())\n",
        "            digest.next_to(arrow.get_end(), DOWN)\n",
        "\n",
        "            self.add(guess, digest)\n",
        "            self.wait(1./20)\n",
        "            self.remove(guess, digest)\n",
        "        proof_of_work = guess\n",
        "        self.add(proof_of_work, digest)\n",
        "        block.add(proof_of_work)\n",
        "        self.wait()\n",
        "\n",
        "        self.hash_group = VGroup(arrow, digest)\n",
        "\n",
        "    def add_block_reward(self):\n",
        "        payments = self.payments\n",
        "        new_transaction = OldTexText(\n",
        "            self.block_creator_labels[0].get_tex(),\n",
        "            \"gets\", \"10 LD\"\n",
        "        )\n",
        "        new_transaction[0].set_color(GREY_B)\n",
        "        new_transaction.set_color_by_tex(\"LD\", YELLOW)\n",
        "        new_transaction.set_height(payments[0].get_height())\n",
        "        new_transaction.move_to(payments.get_top())\n",
        "        payments.generate_target()\n",
        "        payments.target.next_to(new_transaction, DOWN, SMALL_BUFF, LEFT)\n",
        "        new_transaction.shift(SMALL_BUFF*UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(payments),\n",
        "            Write(new_transaction)\n",
        "        )\n",
        "        payments.add_to_back(new_transaction)\n",
        "        self.wait()\n",
        "\n",
        "    def comment_on_block_reward(self):\n",
        "        reward = self.payments[0]\n",
        "        reward_rect = SurroundingRectangle(reward)\n",
        "        big_rect = SurroundingRectangle(self.ledgers)\n",
        "        big_rect.set_stroke(width = 0)\n",
        "        big_rect.set_fill(BLACK, opacity = 1)\n",
        "\n",
        "        comments = VGroup(*list(map(TexText, [\n",
        "            \"- ``Block reward''\",\n",
        "            \"- No sender/signature\",\n",
        "            \"- Adds to total money supply\",\n",
        "        ])))\n",
        "        comments.arrange(DOWN, aligned_edge = LEFT)\n",
        "        comments.move_to(big_rect, UP+LEFT)\n",
        "\n",
        "        pi_creatures = self.pi_creatures\n",
        "        self.pi_creatures = VGroup()\n",
        "\n",
        "        self.play(ShowCreation(reward_rect))\n",
        "        self.play(FadeIn(big_rect))\n",
        "        for comment in comments:\n",
        "            self.play(FadeIn(comment))\n",
        "            self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [big_rect, comments, reward_rect])))\n",
        "\n",
        "        self.pi_creatures = pi_creatures\n",
        "\n",
        "    def write_miners(self):\n",
        "        for label in self.block_creator_labels:\n",
        "            tex = label.get_tex()\n",
        "            new_label = OldTexText(\"Miner \" + tex[-1])\n",
        "            new_label.set_color(label.get_color())\n",
        "            new_label.replace(label, dim_to_match = 1)\n",
        "            self.play(Transform(label, new_label))\n",
        "        top_payment = self.payments[0]\n",
        "        new_top_payment = OldTexText(\"Miner 1\", \"gets\", \"10 LD\")\n",
        "        new_top_payment[0].set_color(GREY_B)\n",
        "        new_top_payment[-1].set_color(YELLOW)\n",
        "        new_top_payment.set_height(top_payment.get_height())\n",
        "        new_top_payment.move_to(top_payment, LEFT)\n",
        "        self.play(Transform(top_payment, new_top_payment))\n",
        "        self.wait()\n",
        "\n",
        "    def broadcast_block(self):\n",
        "        old_chains = self.block_chains\n",
        "        self.n_blocks = 4\n",
        "        new_chains = self.get_distributed_ledgers()\n",
        "        block_target_group = VGroup()\n",
        "        anims = []\n",
        "        arrow_creations = []\n",
        "        for old_chain, new_chain  in zip(old_chains, new_chains):\n",
        "            for attr in \"blocks\", \"arrows\":\n",
        "                pairs = list(zip(\n",
        "                    getattr(old_chain, attr), \n",
        "                    getattr(new_chain, attr), \n",
        "                ))\n",
        "                for m1, m2 in pairs:\n",
        "                    anims.append(Transform(m1, m2))\n",
        "            arrow_creations.append(ShowCreation(new_chain.arrows[-1]))\n",
        "            block_target = self.block.copy()\n",
        "            block_target.replace(new_chain.blocks[-1], stretch = True)\n",
        "            block_target_group.add(block_target)\n",
        "        anims.append(Transform(\n",
        "            VGroup(self.block),\n",
        "            block_target_group\n",
        "        ))\n",
        "        anims.append(Broadcast(self.block, n_circles = 4))\n",
        "        anims.append(FadeOut(self.hash_group))\n",
        "        anims.append(ApplyMethod(\n",
        "            self.block_creators[0].change, \"happy\"\n",
        "        ))\n",
        "\n",
        "        self.play(*anims, run_time = 2)\n",
        "        self.play(*it.chain(\n",
        "            arrow_creations,\n",
        "            [\n",
        "                ApplyMethod(\n",
        "                    pi.change, \"hooray\", \n",
        "                    pi.block_chain.get_right()\n",
        "                )\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        ))\n",
        "        self.wait(3)\n",
        "\n",
        "class MiningIsALottery(IntroduceBlockCreator):\n",
        "    CONFIG = {\n",
        "        \"n_miners\" : 3,\n",
        "        \"denomination\" : \"LD\",\n",
        "        \"n_guesses\" : 90,\n",
        "        \"n_nonce_digits\" : 15,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_blocks()\n",
        "        self.add_arrows()\n",
        "        self.make_guesses()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        IntroduceBlockCreator.create_pi_creatures(self)\n",
        "        miners = VGroup(*[\n",
        "            PiCreature(color = GREY)\n",
        "            for n in range(self.n_miners)\n",
        "        ])\n",
        "        miners.scale(0.5)\n",
        "        miners.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        miners.to_edge(LEFT)\n",
        "        for x, miner in enumerate(miners):\n",
        "            label = OldTexText(\"Miner %d\"%(x+1))\n",
        "            label.scale(0.7)\n",
        "            label.next_to(miner, DOWN, SMALL_BUFF)\n",
        "            miner.label = label\n",
        "            self.add(label)\n",
        "        self.miners = miners\n",
        "        return miners\n",
        "\n",
        "    def add_blocks(self):\n",
        "        self.add(self.miners)\n",
        "\n",
        "        blocks = VGroup()\n",
        "        for miner in self.miners:\n",
        "            block = self.get_block()\n",
        "            block.stretch_to_fit_height(2)\n",
        "            block.stretch_to_fit_width(3)\n",
        "            block.next_to(miner, RIGHT)\n",
        "\n",
        "            payments = self.get_payments(miner)\n",
        "            payments.set_height(1)\n",
        "            payments.move_to(block)\n",
        "            block.add(payments)\n",
        "\n",
        "            prev_hash = OldTexText(\"Prev hash\")\n",
        "            prev_hash.set_color(BLUE)\n",
        "            prev_hash.set_height(0.2)\n",
        "            prev_hash.next_to(block.get_top(), DOWN, SMALL_BUFF)\n",
        "            block.add(prev_hash)\n",
        "\n",
        "            miner.block = block\n",
        "            miner.change(\"pondering\", block)\n",
        "            blocks.add(block)\n",
        "\n",
        "        self.blocks = blocks\n",
        "        self.add(blocks)\n",
        "\n",
        "    def add_arrows(self):\n",
        "        self.arrows = VGroup()\n",
        "        for block in self.blocks:\n",
        "            arrow = Arrow(LEFT, RIGHT)\n",
        "            arrow.next_to(block)\n",
        "            label = OldTexText(\"SHA256\")\n",
        "            label.scale(0.7)\n",
        "            label.next_to(arrow, UP, buff = SMALL_BUFF)\n",
        "            self.add(arrow, label)\n",
        "            block.arrow = arrow\n",
        "            self.arrows.add(VGroup(arrow, label))\n",
        "\n",
        "    def make_guesses(self):\n",
        "        for x in range(self.n_guesses):\n",
        "            e = self.n_nonce_digits\n",
        "            nonces = VGroup()\n",
        "            digests = VGroup()\n",
        "            for block in self.blocks:\n",
        "                nonce = Integer(random.randint(10**e, 10**(e+1)))\n",
        "                nonce.set_height(0.2)\n",
        "                nonce.next_to(block.get_bottom(), UP, SMALL_BUFF)\n",
        "                nonces.add(nonce)\n",
        "                digest = sha256_tex_mob(str(x) + str(block))\n",
        "                digest.set_height(block.get_height())\n",
        "                digest.next_to(block.arrow, RIGHT)\n",
        "                digests.add(digest)\n",
        "            self.add(nonces, digests)\n",
        "            self.wait(1./20)\n",
        "            self.remove(nonces, digests)\n",
        "        self.add(nonces, digests)\n",
        "\n",
        "        winner_index = 1\n",
        "        winner = self.miners[winner_index]\n",
        "        losers = VGroup(*[m for m in self.miners if m is not winner])\n",
        "\n",
        "        nonces[winner_index].set_color(GREEN)\n",
        "        new_digest = sha256_tex_mob(\"Winner\", 60)\n",
        "        VGroup(*new_digest[:60]).set_color(YELLOW)\n",
        "        old_digest = digests[winner_index]\n",
        "        new_digest.replace(old_digest)\n",
        "        Transform(old_digest, new_digest).update(1)\n",
        "\n",
        "        self.play(\n",
        "            winner.change, \"hooray\",\n",
        "            *[\n",
        "                ApplyMethod(VGroup(\n",
        "                    self.blocks[i], self.arrows[i], \n",
        "                    nonces[i], digests[i]\n",
        "                ).fade, 0.7)\n",
        "                for i in range(len(self.blocks))\n",
        "                if i is not winner_index\n",
        "            ]\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(loser.change, \"angry\", winner)\n",
        "            for loser in losers\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_payments(self, miner):\n",
        "        if not hasattr(self, \"ledger\"):\n",
        "            self.get_ledger() ##Unused\n",
        "        self.ledger.content.remove(*self.ledger.content[1:])\n",
        "\n",
        "        lines = VGroup()\n",
        "\n",
        "        miner_name = miner.label.get_tex()\n",
        "        top_line = OldTexText(miner_name, \"gets\", \"10 LD\")\n",
        "        top_line.set_color_by_tex(miner_name, GREY_B)\n",
        "        top_line.set_color_by_tex(\"LD\", YELLOW)\n",
        "        lines.add(top_line)\n",
        "        payments = [\n",
        "            (\"Alice\", \"Bob\", 20),\n",
        "            (\"Charlie\", \"You\", 50),\n",
        "        ]\n",
        "        for payment in payments:\n",
        "            lines.add(self.add_payment_line_to_ledger(*payment))\n",
        "        lines.add(OldTex(\"\\\\vdots\"))\n",
        "        for line in lines:\n",
        "            line.set_height(0.5)\n",
        "        lines.arrange(\n",
        "            DOWN, buff = SMALL_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        lines[-1].next_to(lines[-2], DOWN, buff = SMALL_BUFF)\n",
        "        return lines\n",
        "\n",
        "class TwoBlockChains(DistributedBlockChainScene):\n",
        "    CONFIG = {\n",
        "        \"n_blocks\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.listen_for_new_blocks()\n",
        "        self.defer_to_longer()\n",
        "        self.break_tie()\n",
        "\n",
        "    def listen_for_new_blocks(self):\n",
        "        randy = self.randy\n",
        "        chain = self.get_block_chain()\n",
        "        chain.scale(1.5)\n",
        "        chain.next_to(randy, UP+RIGHT)\n",
        "        chain.shift_onto_screen()\n",
        "        randy.change(\"raise_right_hand\", chain)\n",
        "\n",
        "        corners = [\n",
        "            u1 * FRAME_X_RADIUS*RIGHT + u2 * FRAME_Y_RADIUS*UP\n",
        "            for u1, u2 in it.product(*[[-1, 1]]*2)\n",
        "        ]\n",
        "        moving_blocks = chain.blocks[1:]\n",
        "\n",
        "        self.add(randy, chain.blocks[0])\n",
        "        for corner, block, arrow in zip(corners, moving_blocks, chain.arrows):\n",
        "            block.save_state()\n",
        "            block.next_to(corner, corner)\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    block.restore,\n",
        "                    rate_func = squish_rate_func(smooth, 0.3, 0.8),\n",
        "                    run_time = 3,\n",
        "                ),\n",
        "                Broadcast(corner, run_time = 3),\n",
        "                ShowCreation(\n",
        "                    arrow, \n",
        "                    rate_func = squish_rate_func(smooth, 0.8, 1),\n",
        "                    run_time = 3,\n",
        "                ),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.block_chain = chain\n",
        "\n",
        "    def defer_to_longer(self):\n",
        "        randy = self.randy\n",
        "        self.n_blocks -= 1\n",
        "        block_chains = VGroup(\n",
        "            self.block_chain,\n",
        "            self.get_block_chain().scale(1.5)\n",
        "        )\n",
        "        block_chains[1].next_to(randy, UP+LEFT)\n",
        "        block_chains[1].shift_onto_screen()\n",
        "\n",
        "        conflicting = OldTexText(\"Conflicting\")\n",
        "        conflicting.to_edge(UP)\n",
        "        conflicting.set_color(RED)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                conflicting.get_bottom(), block_chain.get_top(),\n",
        "                color = RED,\n",
        "                buff = MED_LARGE_BUFF\n",
        "            )\n",
        "            for block_chain in block_chains\n",
        "        ])\n",
        "\n",
        "        longer_chain_rect = SurroundingRectangle(block_chains[0])\n",
        "        longer_chain_rect.set_stroke(GREEN, 8)\n",
        "        checkmark = OldTex(\"\\\\checkmark\")\n",
        "        checkmark.set_color(GREEN)\n",
        "        checkmark.next_to(longer_chain_rect, UP)\n",
        "        checkmark.shift(RIGHT)\n",
        "\n",
        "        chain = block_chains[1]\n",
        "        chain.save_state()\n",
        "        corner = FRAME_X_RADIUS*LEFT + FRAME_Y_RADIUS*UP\n",
        "        chain.next_to(corner, UP+LEFT)\n",
        "        self.play(\n",
        "            randy.change, \"confused\", chain,\n",
        "            Broadcast(corner),\n",
        "            ApplyMethod(\n",
        "                chain.restore,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.7),\n",
        "                run_time = 3\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            Write(conflicting),\n",
        "            *list(map(ShowCreation, arrows))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(longer_chain_rect))\n",
        "        self.play(Write(checkmark, run_time = 1))\n",
        "        self.play(randy.change, \"thinking\", checkmark)\n",
        "        self.wait()\n",
        "\n",
        "        self.to_fade = VGroup(\n",
        "            conflicting, arrows, \n",
        "            longer_chain_rect, checkmark\n",
        "        )\n",
        "        self.block_chains = block_chains\n",
        "\n",
        "    def break_tie(self):\n",
        "        to_fade = self.to_fade\n",
        "        block_chains = self.block_chains\n",
        "        randy = self.randy\n",
        "\n",
        "        arrow = block_chains[1].arrows[-1]\n",
        "        block = block_chains[1].blocks[-1]\n",
        "        arrow_block = VGroup(arrow, block).copy()\n",
        "\n",
        "        block_chains.generate_target()\n",
        "        block_chains.target.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        block_chains.target.next_to(randy, UP)\n",
        "        block_chains.target.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(block_chains),\n",
        "            FadeOut(to_fade),\n",
        "            run_time = 1\n",
        "        )\n",
        "        arrow_block.next_to(block_chains[1], RIGHT, buff = 0)\n",
        "        block_chains[1].add(arrow_block)\n",
        "        self.play(\n",
        "            randy.change, \"confused\", block_chains,\n",
        "            FadeIn(arrow_block),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow_block = arrow_block.copy()\n",
        "        arrow_block.next_to(FRAME_X_RADIUS*RIGHT, RIGHT)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                arrow_block.next_to, block_chains[0], RIGHT, 0,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.8)\n",
        "            ),\n",
        "            Broadcast(arrow_block),\n",
        "        )\n",
        "        block_chains[0].add(arrow_block)\n",
        "        rect = SurroundingRectangle(block_chains[0])\n",
        "        rect.set_stroke(GREEN, 8)\n",
        "        checkmark = OldTex(\"\\\\checkmark\")\n",
        "        checkmark.next_to(rect, UP)\n",
        "        checkmark.set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(checkmark),\n",
        "            randy.change, \"happy\", arrow_block\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        self.randy = randy\n",
        "        return VGroup(randy)\n",
        "\n",
        "class ReplaceCentralAuthorityWithWork(Scene):\n",
        "    def construct(self):\n",
        "        trust, central = words = OldTexText(\"Trust\", \"central authority\")\n",
        "        words.scale(1.5)\n",
        "        cross = Cross(central)\n",
        "        work = OldTexText(\"computational work\")\n",
        "        work.scale(1.5)\n",
        "        work.move_to(central, LEFT)\n",
        "        work.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.play(ShowCreation(cross))\n",
        "        central.add(cross)\n",
        "        self.play(\n",
        "            central.shift, DOWN,\n",
        "            Write(work)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutTrustingWork(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        mode = \"raise_left_hand\"\n",
        "        self.student_says(\n",
        "            \"Is trusting work \\\\\\\\ really enough?\",\n",
        "            target_mode = mode,\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", mode, \"erm\")\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"Well, let's try\\\\\\\\ fooling someone\",\n",
        "            target_mode = \"speaking\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class DoubleSpendingAttack(DistributedBlockChainScene):\n",
        "    CONFIG = {\n",
        "        \"fraud_block_height\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_characters()\n",
        "        self.show_fraudulent_block()\n",
        "        self.send_to_bob()\n",
        "        self.dont_send_to_rest_of_network()\n",
        "\n",
        "    def initialize_characters(self):\n",
        "        network = self.get_large_network()\n",
        "        network.scale(0.7)\n",
        "        block_chains = self.get_distributed_ledgers()\n",
        "        self.add(network, block_chains)\n",
        "        self.play(self.alice.change, \"conniving\")\n",
        "        self.wait()\n",
        "\n",
        "    def show_fraudulent_block(self):\n",
        "        block = self.get_fraud_block()\n",
        "        block.next_to(self.alice, LEFT, LARGE_BUFF)\n",
        "        block.remove(block.content)\n",
        "        self.play(\n",
        "            ShowCreation(block),\n",
        "            Write(block.content),\n",
        "            self.alice.change, \"raise_left_hand\"\n",
        "        )\n",
        "        block.add(block.content)\n",
        "        self.wait()\n",
        "\n",
        "        self.block = block\n",
        "\n",
        "    def send_to_bob(self):\n",
        "        block = self.block.copy()\n",
        "        block.generate_target()\n",
        "        block.target.replace(\n",
        "            self.bob.block_chain.blocks[-1],\n",
        "            stretch = True\n",
        "        )\n",
        "        arrow = self.bob.block_chain.arrows[-1].copy()\n",
        "        VGroup(arrow, block.target).next_to(\n",
        "            self.bob.block_chain.blocks[-1], RIGHT, buff = 0\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(block),\n",
        "            self.alice.change, \"happy\"\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def dont_send_to_rest_of_network(self):\n",
        "        bubble = ThoughtBubble()\n",
        "        words = OldTexText(\"Alice\", \"never \\\\\\\\ paid\", \"Bob\")\n",
        "        for name in \"Alice\", \"Bob\":\n",
        "            words.set_color_by_tex(name, self.get_color_from_name(name))\n",
        "        bubble.add_content(words)\n",
        "        bubble.resize_to_content()\n",
        "        bubble.add(*bubble.content)\n",
        "        bubble.move_to(self.you.get_corner(UP+RIGHT), DOWN+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.charlie.change, \"shruggie\",\n",
        "            self.you.change, \"shruggie\",\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, bubble))\n",
        "        self.play(self.bob.change, \"confused\", words)\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_fraud_block(self):\n",
        "        block = self.get_block()\n",
        "        block.set_height(self.fraud_block_height)\n",
        "        content = VGroup()\n",
        "\n",
        "        tuples = [\n",
        "            (\"Prev hash\", UP, BLUE), \n",
        "            (\"Proof of work\", DOWN, GREEN),\n",
        "        ]\n",
        "        for word, vect, color in tuples:\n",
        "            mob = OldTexText(word)\n",
        "            mob.set_color(color)\n",
        "            mob.set_height(0.07*block.get_height())\n",
        "            mob.next_to(\n",
        "                block.get_edge_center(vect), -vect,\n",
        "                buff = 0.06*block.get_height()\n",
        "            )\n",
        "            content.add(mob)\n",
        "            attr = word.lower().replace(\" \", \"_\")\n",
        "            setattr(block, attr, mob)\n",
        "\n",
        "        payment = OldTexText(\"Alice\", \"pays\", \"Bob\", \"100 LD\")\n",
        "        for name in \"Alice\", \"Bob\":\n",
        "            payment.set_color_by_tex(name, self.get_color_from_name(name))\n",
        "        payment.set_color_by_tex(\"LD\", YELLOW)\n",
        "        payments = VGroup(\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            payment,\n",
        "            OldTex(\"\\\\vdots\")\n",
        "        )\n",
        "        payments.arrange(DOWN)\n",
        "        payments.set_width(0.9*block.get_width())\n",
        "        payments.move_to(block)\n",
        "        content.add(payments)\n",
        "\n",
        "        block.content = content\n",
        "        block.add(content)\n",
        "        return block\n",
        "\n",
        "class AliceRacesOtherMiners(DoubleSpendingAttack):\n",
        "    CONFIG = {\n",
        "        \"n_frames_per_pow\" : 3,\n",
        "        \"fraud_block_height\" : 2,\n",
        "        \"n_miners\" : 3,\n",
        "        \"n_proof_of_work_digits\" : 11,\n",
        "        \"proof_of_work_update_counter\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_characters()\n",
        "        self.find_proof_of_work()\n",
        "        self.receive_broadcast_from_other_miners()\n",
        "        self.race_between_alice_and_miners()\n",
        "\n",
        "    def initialize_characters(self):\n",
        "        alice = self.alice\n",
        "        bob = self.bob\n",
        "        alice_l = VGroup(alice, alice.label)\n",
        "        bob_l = VGroup(bob, bob.label)\n",
        "        bob_l.move_to(ORIGIN)\n",
        "        alice_l.to_corner(UP+LEFT)\n",
        "        alice_l.shift(DOWN)\n",
        "        self.add(bob_l, alice_l)\n",
        "\n",
        "        chain = self.get_block_chain()\n",
        "        chain.next_to(bob, UP)\n",
        "        self.block_chain = chain\n",
        "        self.add(chain)\n",
        "\n",
        "        fraud_block = self.get_fraud_block()\n",
        "        fraud_block.next_to(alice, RIGHT)\n",
        "        fraud_block.to_edge(UP)\n",
        "        proof_of_work = self.get_rand_int_mob()\n",
        "        proof_of_work.replace(fraud_block.proof_of_work, dim_to_match = 1)\n",
        "        fraud_block.content.remove(fraud_block.proof_of_work)\n",
        "        fraud_block.content.add(proof_of_work)\n",
        "        fraud_block.proof_of_work = proof_of_work\n",
        "        self.fraud_block = fraud_block\n",
        "        self.add(fraud_block)\n",
        "\n",
        "        miners = VGroup(*[\n",
        "            PiCreature(color = GREY)\n",
        "            for x in range(self.n_miners)\n",
        "        ])\n",
        "        miners.set_height(alice.get_height())\n",
        "        miners.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        miners.to_edge(DOWN+LEFT)\n",
        "        miners.shift(0.5*UP)\n",
        "        miners_word = OldTexText(\"Miners\")\n",
        "        miners_word.next_to(miners, DOWN)\n",
        "        self.miners = miners\n",
        "        self.add(miners_word, miners)\n",
        "\n",
        "        miner_blocks = VGroup()\n",
        "        self.proofs_of_work = VGroup()\n",
        "        self.add_foreground_mobject(self.proofs_of_work)\n",
        "        for miner in miners:\n",
        "            block = self.get_block()\n",
        "            block.set_width(1.5*miner.get_width())\n",
        "            block.next_to(miner, UP)\n",
        "\n",
        "            transactions = self.get_block_filler(block)\n",
        "            block.add(transactions)\n",
        "\n",
        "            proof_of_work = self.get_rand_int_mob()\n",
        "            prev_hash = OldTexText(\"Prev hash\").set_color(BLUE)\n",
        "            for mob, vect in (proof_of_work, DOWN), (prev_hash, UP):\n",
        "                mob.set_height(0.1*block.get_height())\n",
        "                mob.next_to(\n",
        "                    block.get_edge_center(vect), -vect, \n",
        "                    buff = 0.05*block.get_height()\n",
        "                )\n",
        "                block.add(mob)\n",
        "            block.proof_of_work = proof_of_work\n",
        "            block.prev_hash = prev_hash\n",
        "            self.proofs_of_work.add(proof_of_work)\n",
        "\n",
        "            miner.block = block\n",
        "            miner_blocks.add(block)\n",
        "        self.add(miner_blocks)\n",
        "\n",
        "    def find_proof_of_work(self):\n",
        "        fraud_block = self.fraud_block\n",
        "        chain = self.block_chain\n",
        "\n",
        "        self.proofs_of_work.add(self.fraud_block.proof_of_work)\n",
        "        self.wait(3)\n",
        "        self.proofs_of_work.remove(self.fraud_block.proof_of_work)\n",
        "        fraud_block.proof_of_work.set_color(GREEN)\n",
        "        self.play(\n",
        "            Indicate(fraud_block.proof_of_work),\n",
        "            self.alice.change, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "    \n",
        "        block = fraud_block.copy()        \n",
        "        block.generate_target()\n",
        "        block.target.replace(chain.blocks[-1], stretch = True)\n",
        "        arrow = chain.arrows[-1].copy()\n",
        "        VGroup(arrow, block.target).next_to(\n",
        "            chain.blocks[-1], RIGHT, buff = 0\n",
        "        )\n",
        "        self.remove(fraud_block)\n",
        "        self.clean_fraud_block_content()\n",
        "        self.fraud_fork_head = block\n",
        "        self.fraud_fork_arrow = arrow\n",
        "\n",
        "        self.play(MoveToTarget(block))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(self.alice.change, \"happy\")\n",
        "        self.wait()\n",
        "\n",
        "    def receive_broadcast_from_other_miners(self):\n",
        "        winner = self.miners[-1]\n",
        "        proof_of_work = winner.block.proof_of_work\n",
        "        self.proofs_of_work.remove(proof_of_work)\n",
        "        proof_of_work.set_color(GREEN)\n",
        "        self.play(\n",
        "            Indicate(proof_of_work),\n",
        "            winner.change, \"hooray\"\n",
        "        )\n",
        "        block = winner.block.copy()\n",
        "        proof_of_work.set_color(WHITE)\n",
        "        self.remove(winner.block)\n",
        "\n",
        "        ff_head = self.fraud_fork_head\n",
        "        ff_arrow = self.fraud_fork_arrow\n",
        "        arrow = ff_arrow.copy()\n",
        "        movers = [ff_head, ff_arrow, block, arrow]\n",
        "        for mover in movers:\n",
        "            mover.generate_target()\n",
        "        block.target.replace(ff_head, stretch = True)\n",
        "\n",
        "        dist = 0.5*ff_head.get_height() + MED_SMALL_BUFF\n",
        "        block.target.shift(dist*DOWN)\n",
        "        ff_head.target.shift(dist*UP)\n",
        "        arrow.target[1].shift(dist*DOWN)\n",
        "        arrow.target.get_points()[-2:] += dist*DOWN\n",
        "        ff_arrow.target[1].shift(dist*UP)\n",
        "        ff_arrow.target.get_points()[-2:] += dist*UP\n",
        "\n",
        "        self.play(\n",
        "            Broadcast(block),\n",
        "            *[\n",
        "                MoveToTarget(\n",
        "                    mover, run_time = 3, \n",
        "                    rate_func = squish_rate_func(smooth, 0.3, 0.8)\n",
        "                )\n",
        "                for mover in movers\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(winner.block),\n",
        "            winner.change_mode, \"plain\",\n",
        "            self.alice.change, \"sassy\",\n",
        "        )\n",
        "        self.proofs_of_work.add(winner.block.proof_of_work)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.alice.change, \"pondering\",\n",
        "            FadeIn(self.fraud_block)\n",
        "        )\n",
        "        self.proofs_of_work.add(self.fraud_block.proof_of_work)\n",
        "\n",
        "        self.valid_fork_head = block\n",
        "\n",
        "    def race_between_alice_and_miners(self):\n",
        "        last_fraud_block = self.fraud_fork_head\n",
        "        last_valid_block = self.valid_fork_head\n",
        "        chain = self.block_chain\n",
        "        winners = [\n",
        "            \"Alice\", \"Alice\",\n",
        "            \"Miners\", \"Miners\", \"Miners\",\n",
        "            \"Alice\", \"Miners\", \"Miners\", \"Miners\",\n",
        "            \"Alice\", \"Miners\", \"Miners\"\n",
        "        ]\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        for winner in winners:\n",
        "            self.wait()\n",
        "            if winner == \"Alice\":\n",
        "                block = self.fraud_block\n",
        "                prev_block = last_fraud_block\n",
        "            else:\n",
        "                block = random.choice(self.miners).block\n",
        "                prev_block = last_valid_block\n",
        "            block_copy = block.deepcopy()\n",
        "            block_copy.proof_of_work.set_color(GREEN)\n",
        "            block_copy.generate_target()\n",
        "            block_copy.target.replace(chain.blocks[1], stretch = True)\n",
        "            arrow = chain.arrows[0].copy()\n",
        "            VGroup(arrow, block_copy.target).next_to(\n",
        "                prev_block, RIGHT, buff = 0\n",
        "            )\n",
        "            anims = [\n",
        "                MoveToTarget(block_copy, run_time = 2),\n",
        "                ShowCreation(\n",
        "                    arrow,\n",
        "                    run_time = 2,\n",
        "                    rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "                ),\n",
        "                FadeIn(block),\n",
        "            ]\n",
        "            if winner == \"Alice\":\n",
        "                last_fraud_block = block_copy\n",
        "            else:\n",
        "                last_valid_block = block_copy\n",
        "                anims.append(Broadcast(block, run_time = 2))\n",
        "            self.proofs_of_work.remove(block.proof_of_work)\n",
        "            self.play(*anims)\n",
        "            self.proofs_of_work.add(block.proof_of_work)\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def wait(self, time = 1):\n",
        "        self.play(\n",
        "            Animation(VGroup(*self.foreground_mobjects)),\n",
        "            run_time = time\n",
        "        )\n",
        "\n",
        "    def update_frame(self, *args, **kwargs):\n",
        "        self.update_proofs_of_work()\n",
        "        Scene.update_frame(self, *args, **kwargs)\n",
        "\n",
        "    def update_proofs_of_work(self):\n",
        "        self.proof_of_work_update_counter += 1\n",
        "        if self.proof_of_work_update_counter%self.n_frames_per_pow != 0:\n",
        "            return\n",
        "        for proof_of_work in self.proofs_of_work:\n",
        "            new_pow = self.get_rand_int_mob()\n",
        "            new_pow.replace(proof_of_work, dim_to_match = 1)\n",
        "            Transform(proof_of_work, new_pow).update(1)\n",
        "\n",
        "    def get_rand_int_mob(self):\n",
        "        e = self.n_proof_of_work_digits\n",
        "        return Integer(random.randint(10**e, 10**(e+1)))\n",
        "\n",
        "    def clean_fraud_block_content(self):\n",
        "        content = self.fraud_block.content\n",
        "        payments = content[1]\n",
        "        content.remove(payments)\n",
        "        transactions = self.get_block_filler(self.fraud_block)\n",
        "        content.add(transactions)\n",
        "\n",
        "    def get_block_filler(self, block):\n",
        "        result = OldTexText(\"$\\\\langle$Transactions$\\\\rangle$\")\n",
        "        result.set_width(0.8*block.get_width())\n",
        "        result.move_to(block)\n",
        "        return result\n",
        "\n",
        "class WhenToTrustANewBlock(DistributedBlockChainScene):\n",
        "    def construct(self):\n",
        "        chain = self.block_chain = self.get_block_chain()\n",
        "        chain.scale(2)\n",
        "        chain.to_edge(LEFT)\n",
        "        self.add(chain)\n",
        "\n",
        "        words = list(map(TexText, [\n",
        "            \"Don't trust yet\",\n",
        "            \"Still don't trust\",\n",
        "            \"...a little more...\",\n",
        "            \"Maybe trust\",\n",
        "            \"Probably safe\",\n",
        "            \"Alright, you're good.\"\n",
        "        ]))\n",
        "        colors = [RED, RED, YELLOW, YELLOW, GREEN, GREEN]\n",
        "        self.add_new_block()\n",
        "        arrow = Arrow(UP, DOWN, color = RED)\n",
        "        arrow.next_to(chain.blocks[-1], UP)\n",
        "        for word, color in zip(words, colors):\n",
        "            word.set_color(color)\n",
        "            word.next_to(arrow, UP)\n",
        "        word = words[0]\n",
        "        self.play(\n",
        "            FadeIn(word),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        for new_word in words[1:]:\n",
        "            kwargs = {\n",
        "                \"run_time\" : 3,\n",
        "                \"rate_func\" : squish_rate_func(smooth, 0.7, 1)\n",
        "            }\n",
        "            self.add_new_block(\n",
        "                Transform(word, new_word, **kwargs),\n",
        "                ApplyMethod(\n",
        "                    arrow.set_color, new_word.get_color(),\n",
        "                    **kwargs\n",
        "                )\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_block(self):\n",
        "        block = DistributedBlockChainScene.get_block(self)\n",
        "        tuples = [\n",
        "            (\"Prev hash\", UP, BLUE), \n",
        "            (\"Proof of work\", DOWN, GREEN),\n",
        "        ]\n",
        "        for word, vect, color in tuples:\n",
        "            mob = OldTexText(word)\n",
        "            mob.set_color(color)\n",
        "            mob.set_height(0.07*block.get_height())\n",
        "            mob.next_to(\n",
        "                block.get_edge_center(vect), -vect,\n",
        "                buff = 0.06*block.get_height()\n",
        "            )\n",
        "            block.add(mob)\n",
        "            attr = word.lower().replace(\" \", \"_\")\n",
        "            setattr(block, attr, mob)\n",
        "        transactions = OldTexText(\"$\\\\langle$Transactions$\\\\rangle$\")\n",
        "        transactions.set_width(0.8*block.get_width())\n",
        "        transactions.move_to(block)\n",
        "        block.add(transactions)\n",
        "        return block\n",
        "\n",
        "    def add_new_block(self, *added_anims):\n",
        "        blocks = self.block_chain.blocks\n",
        "        arrows = self.block_chain.arrows\n",
        "        block = blocks[-1].copy()\n",
        "        arrow = arrows[-1].copy()\n",
        "        VGroup(block, arrow).next_to(blocks[-1], RIGHT, buff = 0)\n",
        "        corner = FRAME_X_RADIUS*RIGHT + FRAME_Y_RADIUS*UP\n",
        "        block.save_state()\n",
        "        block.next_to(corner, UP+RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Broadcast(block),\n",
        "            ApplyMethod(\n",
        "                block.restore,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 0.8),\n",
        "            ),\n",
        "            ShowCreation(\n",
        "                arrow,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, 0.7, 1),\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "        arrows.add(arrow)\n",
        "        blocks.add(block)\n",
        "\n",
        "class MainIdeas(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Main ideas\")\n",
        "        title.scale(1.5)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        VGroup(title, h_line).to_corner(UP+LEFT)\n",
        "\n",
        "        ideas = VGroup(*[\n",
        "            OldTexText(\"$\\\\cdot$ \" + words)\n",
        "            for words in [\n",
        "                \"Digital signatures\",\n",
        "                \"The ledger is the currency\",\n",
        "                \"Decentralize\",\n",
        "                \"Proof of work\",\n",
        "                \"Block chain\",\n",
        "            ]\n",
        "        ])\n",
        "        colors = BLUE, WHITE, RED, GREEN, YELLOW\n",
        "        for idea, color in zip(ideas, colors):\n",
        "            idea.set_color(color)\n",
        "        ideas.arrange(\n",
        "            DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        ideas.next_to(h_line, DOWN)\n",
        "\n",
        "        self.add(title, h_line)\n",
        "        for idea in ideas:\n",
        "            self.play(LaggedStartMap(FadeIn, idea))\n",
        "        self.wait()\n",
        "\n",
        "class VariableProofOfWork(WhenToTrustANewBlock):\n",
        "    CONFIG = {\n",
        "        \"block_height\" : 3,\n",
        "        \"block_width\" : 3,\n",
        "        \"n_guesses\" : 60,\n",
        "        \"n_proof_of_work_digits\" : 11,\n",
        "        \"n_miners\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_miner_and_hash()\n",
        "        self.change_requirement()\n",
        "        self.add_more_miners()\n",
        "\n",
        "    def add_miner_and_hash(self):\n",
        "        miner = PiCreature(color = GREY)\n",
        "        miner.scale(0.7)\n",
        "        miner.to_edge(LEFT)\n",
        "\n",
        "        block = self.get_block()\n",
        "        block.next_to(miner, RIGHT)\n",
        "        old_proof_of_work = block.proof_of_work\n",
        "        proof_of_work = self.get_rand_int_mob()\n",
        "        proof_of_work.replace(old_proof_of_work, dim_to_match = 1)\n",
        "        block.remove(old_proof_of_work)\n",
        "        block.add(proof_of_work)\n",
        "        block.proof_of_work = proof_of_work\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        arrow.next_to(block)\n",
        "        sha_tex = OldTexText(\"SHA256\")\n",
        "        sha_tex.scale(0.7)\n",
        "        sha_tex.next_to(arrow, UP, SMALL_BUFF)\n",
        "        sha_tex.set_color(YELLOW)\n",
        "        arrow.add(sha_tex)\n",
        "\n",
        "        digest = sha256_tex_mob(\"Random\")\n",
        "        digest.next_to(arrow.get_end(), RIGHT)\n",
        "\n",
        "        miner.change(\"pondering\", digest)\n",
        "\n",
        "        self.add(miner, block, arrow, digest)\n",
        "        for x in range(self.n_guesses):\n",
        "            new_pow = self.get_rand_int_mob()\n",
        "            new_pow.replace(proof_of_work, dim_to_match = 1)\n",
        "            Transform(proof_of_work, new_pow).update(1)\n",
        "            if x == self.n_guesses-1:\n",
        "                n_zeros = 60\n",
        "            else:\n",
        "                n_zeros = 0\n",
        "            new_digest = sha256_tex_mob(str(x+1), n_zeros)\n",
        "            new_digest.replace(digest)\n",
        "            Transform(digest, new_digest).update(1)\n",
        "            self.wait(1./20)\n",
        "        proof_of_work.set_color(GREEN)\n",
        "        VGroup(*digest[:60]).set_color(YELLOW)\n",
        "\n",
        "        self.miner = miner\n",
        "        self.block = block\n",
        "        self.arrow = arrow\n",
        "        self.digest = digest\n",
        "\n",
        "    def change_requirement(self):\n",
        "        digest = self.digest\n",
        "        requirement = OldTexText(\n",
        "            \"Must start with \\\\\\\\\",\n",
        "            \"60\", \"zeros\"\n",
        "        )\n",
        "        requirement.next_to(digest, UP, MED_LARGE_BUFF)\n",
        "        self.n_zeros_mob = requirement.get_part_by_tex(\"60\")\n",
        "        self.n_zeros_mob.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(requirement, run_time = 2))\n",
        "        self.wait(2)\n",
        "        for n_zeros in 30, 32, 35, 37, 42:\n",
        "            self.change_challenge(n_zeros)\n",
        "            self.wait()\n",
        "\n",
        "    def add_more_miners(self):\n",
        "        miner = self.miner\n",
        "        block = self.block\n",
        "        miner_block = VGroup(miner, block)\n",
        "        target = miner_block.copy()\n",
        "        target[1].scale(\n",
        "            0.5, about_point = miner.get_right()\n",
        "        )\n",
        "        copies = VGroup(*[\n",
        "            target.copy() \n",
        "            for x in range(self.n_miners - 1)\n",
        "        ])\n",
        "        everyone = VGroup(target, *copies)\n",
        "        everyone.arrange(DOWN)\n",
        "        everyone.set_height(FRAME_HEIGHT - LARGE_BUFF)\n",
        "        everyone.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(Transform(miner_block, target))\n",
        "        self.play(LaggedStartMap(FadeIn, copies))\n",
        "        self.change_challenge(72)\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "    def change_challenge(self, n_zeros):\n",
        "        digest = self.digest\n",
        "        proof_of_work = self.block.proof_of_work\n",
        "        n_zeros_mob = self.n_zeros_mob\n",
        "\n",
        "        new_digest = sha256_tex_mob(str(n_zeros), n_zeros)\n",
        "        new_digest.move_to(digest)\n",
        "        VGroup(*new_digest[:n_zeros]).set_color(YELLOW)\n",
        "        new_n_zeros_mob = OldTex(str(n_zeros))\n",
        "        new_n_zeros_mob.move_to(n_zeros_mob)\n",
        "        new_n_zeros_mob.set_color(n_zeros_mob.get_color())\n",
        "        new_pow = self.get_rand_int_mob()\n",
        "        new_pow.replace(proof_of_work, dim_to_match = 1)\n",
        "        new_pow.set_color(proof_of_work.get_color())\n",
        "\n",
        "        self.play(\n",
        "            Transform(n_zeros_mob, new_n_zeros_mob),\n",
        "            Transform(\n",
        "                digest, new_digest,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            Transform(proof_of_work, new_pow),\n",
        "        )\n",
        "\n",
        "    def get_rand_int_mob(self):\n",
        "        e = self.n_proof_of_work_digits\n",
        "        return Integer(random.randint(10**e, 10**(e+1)))\n",
        "\n",
        "class CompareBlockTimes(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Average block time\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN, SMALL_BUFF)\n",
        "\n",
        "        examples = VGroup(\n",
        "            OldTexText(\"BTC: \", \"10 minutes\"),\n",
        "            OldTexText(\"ETH: \", \"15 Seconds\"),\n",
        "            OldTexText(\"XRP: \", \"3.5 Seconds\"),\n",
        "            OldTexText(\"LTC: \", \"2.5 Minutes\"),\n",
        "        )\n",
        "        examples.arrange(\n",
        "            DOWN, \n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        examples.next_to(h_line, DOWN)\n",
        "        logos = VGroup(\n",
        "            BitcoinLogo(),\n",
        "            EthereumLogo(),\n",
        "            ImageMobject(\"ripple_logo\"),\n",
        "            LitecoinLogo(),\n",
        "        )\n",
        "        colors = [BITCOIN_COLOR, GREEN, BLUE_B, GREY_B]\n",
        "        for logo, example, color in zip(logos, examples, colors):\n",
        "            logo.set_height(0.5)\n",
        "            logo.next_to(example, LEFT)\n",
        "            example[0].set_color(color)\n",
        "\n",
        "        self.add(title, h_line)\n",
        "        self.play(\n",
        "            FadeIn(examples[0]),\n",
        "            DrawBorderThenFill(logos[0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            LaggedStartMap(FadeIn, VGroup(*group[1:]))\n",
        "            for group in (examples, logos)\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "    # def get_ethereum_logo(self):\n",
        "    #     logo = SVGMobject(\n",
        "    #         file_name = \"ethereum_logo\",\n",
        "    #         height = 1,\n",
        "    #     )\n",
        "    #     logo.set_fill(GREEN, 1)\n",
        "    #     logo.set_stroke(WHITE, 3)\n",
        "    #     logo.set_color_by_gradient(GREEN_B, GREEN_D)\n",
        "    #     logo.set_width(1)\n",
        "    #     logo.center()\n",
        "    #     self.add(SurroundingRectangle(logo))\n",
        "    #     return logo\n",
        "\n",
        "class BlockRewards(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Block rewards\")\n",
        "        title.scale(1.5)\n",
        "        logo = BitcoinLogo()\n",
        "        logo.set_height(0.75)\n",
        "        logo.next_to(title, LEFT)\n",
        "        title.add(logo)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, logo, h_line)\n",
        "\n",
        "        rewards = VGroup(\n",
        "            OldTexText(\"Jan 2009 - Nov 2012:\", \"50\", \"BTC\"),\n",
        "            OldTexText(\"Nov 2012 - Jul 2016:\", \"25\", \"BTC\"),\n",
        "            OldTexText(\"Jul 2016 - Feb 2020$^*$:\", \"12.5\", \"BTC\"),\n",
        "            OldTexText(\"Feb 2020$^*$ - Sep 2023$^*$:\", \"6.25\", \"BTC\"),\n",
        "        )\n",
        "        rewards.arrange(\n",
        "            DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        rewards.next_to(h_line, DOWN)\n",
        "        for reward in rewards:\n",
        "            reward[1].set_color(YELLOW)\n",
        "\n",
        "        footnote = OldTexText(\n",
        "            \"$^*$ Extrapolating from the 25 BTC reward period\"\n",
        "        )\n",
        "        footnote.scale(0.5)\n",
        "        footnote.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, rewards,\n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.play(FadeIn(footnote))\n",
        "        self.wait(3)\n",
        "\n",
        "class ShowFirstFewBlocks(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ShowGeometricSum(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"210{,}000\", \"(\", \n",
        "            \"50\", \"+\", \"25\", \"+\", \"12.5\", \"+\", \n",
        "            \"6.25\", \"+\\\\cdots\", \")\", \"=\", \"21{,}000{,}000\"\n",
        "        )\n",
        "        numbers = [\"50\", \"25\", \"12.5\", \"6.25\"]\n",
        "        colors = color_gradient([BLUE_D, BLUE_B], 4)\n",
        "        for tex, color in zip(numbers, colors):\n",
        "            equation.set_color_by_tex(tex, color)\n",
        "        equation[-1].set_color(YELLOW)\n",
        "\n",
        "        self.add(*equation[:2] + equation[-3:-1])\n",
        "        for i in range(2, 9, 2):\n",
        "            self.play(FadeIn(VGroup(*equation[i:i+2])))\n",
        "        self.wait()\n",
        "        self.play(Write(equation[-1]))\n",
        "        self.wait(2)\n",
        "\n",
        "class TransactionFeeExample(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        alice = self.pi_creature\n",
        "        payment = OldTexText(\n",
        "            \"Alice\", \"pays\", \"Bob\", \"0.42 BTC\",\n",
        "        )\n",
        "        payment.set_color_by_tex(\"Alice\", BLUE_C)\n",
        "        payment.set_color_by_tex(\"Bob\", MAROON)\n",
        "        payment.set_color_by_tex(\"BTC\", YELLOW)\n",
        "        payment.move_to(2.5*UP)\n",
        "\n",
        "        fee = OldTexText(\"And leaves\", \"0.001 BTC\", \"to the miner\")\n",
        "        fee.set_color_by_tex(\"BTC\", YELLOW)\n",
        "        fee.next_to(payment, DOWN)\n",
        "\n",
        "        signature = OldTexText(\n",
        "            \"$\\\\langle$Alice's digital signature$\\\\rangle$\"\n",
        "        )\n",
        "        signature.set_color(BLUE_C)\n",
        "        signature.next_to(fee, DOWN)\n",
        "\n",
        "        group = VGroup(payment, fee, signature)\n",
        "        rect = SurroundingRectangle(group, color = BLUE_B)\n",
        "\n",
        "        incentive_words = OldTexText(\n",
        "            \"Incentivizes miner \\\\\\\\ to include\"\n",
        "        )\n",
        "        incentive_words.next_to(rect, DOWN, buff = 1.5)\n",
        "        incentive_words.shift(2*RIGHT)\n",
        "        arrow = Arrow(\n",
        "            incentive_words.get_top(),\n",
        "            rect.get_bottom(),\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        fee.save_state()\n",
        "        fee.shift(DOWN)\n",
        "        fee.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(Write(payment))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            alice.change, \"raise_right_hand\", payment,\n",
        "            fee.restore,\n",
        "        )\n",
        "        self.play(Write(signature))\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            alice.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(incentive_words),\n",
        "            ShowCreation(arrow),\n",
        "            alice.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        alice = PiCreature(color = BLUE_C)\n",
        "        alice.to_edge(DOWN)\n",
        "        alice.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        return alice\n",
        "\n",
        "class ShowBitcoinBlockSize(LedgerScene):\n",
        "    CONFIG = {\n",
        "        \"denomination\" : \"BTC\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        block = VGroup()\n",
        "        ledger = self.get_ledger()\n",
        "\n",
        "        payments = VGroup(*[\n",
        "            self.add_payment_line_to_ledger(*args)\n",
        "            for args in [\n",
        "                (\"Alice\", \"Bob\", \"0.42\"),\n",
        "                (\"You\", \"Charlie\", \"3.14\"),\n",
        "                (\"Bob\", \"You\", \"2.72\"),\n",
        "                (\"Alice\", \"Charlie\", \"4.67\"),\n",
        "            ]\n",
        "        ])\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(payments, DOWN)\n",
        "        payments.add(dots)\n",
        "        payments.to_edge(LEFT)\n",
        "        payments.shift(DOWN+0.5*RIGHT)\n",
        "        payments_rect = SurroundingRectangle(\n",
        "            payments, color = WHITE, buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        block.add(payments_rect, payments)\n",
        "\n",
        "        tuples = [\n",
        "            (\"Prev hash\", UP, BLUE_C), \n",
        "            (\"Proof of work\", DOWN, GREEN),\n",
        "        ]\n",
        "        for word, vect, color in tuples:\n",
        "            mob = OldTexText(word)\n",
        "            mob.set_color(color)\n",
        "            rect = SurroundingRectangle(\n",
        "                mob, color = WHITE, buff = MED_SMALL_BUFF\n",
        "            )\n",
        "            VGroup(mob, rect).next_to(payments_rect, vect, 0)\n",
        "            rect.stretch_to_fit_width(payments_rect.get_width())\n",
        "            block.add(mob, rect)\n",
        "\n",
        "        title = VGroup(\n",
        "            BitcoinLogo(height = 0.75), \n",
        "            OldTexText(\"Block\").scale(1.5)\n",
        "        )\n",
        "        title.arrange(RIGHT, SMALL_BUFF)\n",
        "        title.next_to(block, UP)\n",
        "\n",
        "        brace = Brace(payments_rect, RIGHT)\n",
        "        limit = brace.get_text(\n",
        "            \"Limited to\\\\\\\\\", \n",
        "            \"$\\\\sim 2{,}400$\", \"transactions\"\n",
        "        )\n",
        "        limit.set_color_by_tex(\"2{,}400\", RED)\n",
        "\n",
        "        self.add(title, block)\n",
        "        self.remove(payments)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(limit)\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, payments))\n",
        "        self.wait()\n",
        "\n",
        "        ####Visa\n",
        "\n",
        "        visa_logo = SVGMobject(\n",
        "            file_name = \"visa_logo\",\n",
        "            height = 0.5,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLUE_D,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        visa_logo[-1].set_color(\"#faa61a\")\n",
        "        visa_logo.sort()\n",
        "        avg_rate = OldTexText(\"Avg: $1{,}700$/second\")\n",
        "        max_rate = OldTexText(\"Max: $>24{,}000$/second\")\n",
        "        rates = VGroup(avg_rate, max_rate)\n",
        "        rates.scale(0.8)\n",
        "        rates.arrange(DOWN, aligned_edge = LEFT)\n",
        "        rates.next_to(visa_logo, RIGHT, buff = MED_SMALL_BUFF)\n",
        "        visa = VGroup(visa_logo, rates)\n",
        "        visa.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, visa_logo))\n",
        "        self.play(LaggedStartMap(FadeIn, avg_rate))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, max_rate))\n",
        "        self.wait(2)\n",
        "\n",
        "class CurrentAverageFees(Scene):\n",
        "    def construct(self):\n",
        "        fees = OldTexText(\n",
        "            \"Current average fees: \",\n",
        "            \"$\\\\sim 0.0013$ BTC\", \n",
        "            \"$\\\\approx$\", \"\\\\$3.39\"\n",
        "        )\n",
        "        fees.set_color_by_tex(\"BTC\", YELLOW)\n",
        "        fees.set_color_by_tex(\"\\\\$\", GREEN)\n",
        "        fees.to_edge(UP)\n",
        "\n",
        "        self.play(Write(fees))\n",
        "        self.wait()\n",
        "\n",
        "class HighlightingAFewFees(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class TopicsNotCovered(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Topics not covered:\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        title.set_color(YELLOW)\n",
        "        title.save_state()\n",
        "        title.shift(DOWN)\n",
        "        title.set_fill(opacity = 0)\n",
        "\n",
        "        topics = VGroup(*list(map(TexText, [\n",
        "            \"Merkle trees\",\n",
        "            \"Alternatives to proof of work\",\n",
        "            \"Scripting\",\n",
        "            \"$\\\\vdots$\",\n",
        "            \"(See links in description)\",\n",
        "        ])))\n",
        "        topics.arrange(DOWN, aligned_edge = LEFT)\n",
        "        topics[-2].next_to(topics[-3], DOWN)\n",
        "        topics.next_to(title, RIGHT)\n",
        "        topics.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            title.restore,\n",
        "            self.teacher.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        for topic in topics:\n",
        "            self.play_student_changes(\n",
        "                \"confused\", \"thinking\",\"pondering\",\n",
        "                look_at = topic,\n",
        "                added_anims = [LaggedStartMap(FadeIn, topic)]\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class Exchange(Animation):\n",
        "    CONFIG = {\n",
        "        \"rate_func\" : None,\n",
        "    }\n",
        "    def __init__(self, exchange, **kwargs):\n",
        "        self.swap = Swap(\n",
        "            exchange.left,\n",
        "            exchange.right,\n",
        "        )\n",
        "        self.changed_symbols_yet = False\n",
        "        Animation.__init__(self, exchange, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        exchange = self.mobject\n",
        "        if alpha < 1./3:\n",
        "            self.swap.update(3*alpha)\n",
        "        elif alpha < 2./3:\n",
        "            sub_alpha = alpha*3 - 1\n",
        "            group = VGroup(exchange.left, exchange.right)\n",
        "            group.set_fill(opacity = 1-smooth(sub_alpha))\n",
        "        else:\n",
        "            if not self.changed_symbols_yet:\n",
        "                new_left = random.choice(\n",
        "                    exchange.cryptocurrencies\n",
        "                ).copy()\n",
        "                new_left.move_to(exchange.right)\n",
        "                new_right = random.choice(\n",
        "                    exchange.currencies\n",
        "                ).copy()\n",
        "                new_right.move_to(exchange.left)\n",
        "                Transform(exchange.left, new_left).update(1)\n",
        "                Transform(exchange.right, new_right).update(1)\n",
        "                self.changed_symbols_yet = True\n",
        "            sub_alpha = 3*alpha - 2\n",
        "            group = VGroup(exchange.left, exchange.right)\n",
        "            group.set_fill(opacity = smooth(sub_alpha))\n",
        "\n",
        "class ShowManyExchanges(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_rows\" : 2,\n",
        "        \"n_cols\" : 8,\n",
        "        \"shift_radius\" : 0.5,\n",
        "        \"run_time\" : 30,\n",
        "    }\n",
        "    def construct(self):\n",
        "        cryptocurrencies = self.get_cryptocurrencies()\n",
        "        currencies = self.get_currencies()\n",
        "        for currency in it.chain(currencies, cryptocurrencies):\n",
        "            currency.set_height(0.5)\n",
        "            currency.align_data_and_family(EthereumLogo())\n",
        "        exchange = VGroup(*[\n",
        "            Arrow(\n",
        "                p1, p2,\n",
        "                path_arc = np.pi,\n",
        "                buff = MED_LARGE_BUFF\n",
        "            )\n",
        "            for p1, p2 in [(LEFT, RIGHT), (RIGHT, LEFT)]\n",
        "        ]).set_color(WHITE)\n",
        "        exchanges = VGroup(*[\n",
        "            VGroup(*[\n",
        "                exchange.copy()\n",
        "                for x in range(3)\n",
        "            ]).arrange(RIGHT, buff = 2*LARGE_BUFF)\n",
        "            for y in range(3)\n",
        "        ]).arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        exchanges = VGroup(*it.chain(*exchanges))\n",
        "        self.add(exchanges)\n",
        "        start_times = list(np.linspace(0, 2, len(exchanges)))\n",
        "        random.shuffle(start_times)\n",
        "        for exchange, start_time in zip(exchanges, start_times):\n",
        "            left = random.choice(cryptocurrencies).copy()\n",
        "            right = random.choice(currencies).copy()\n",
        "            left.move_to(exchange.get_left())\n",
        "            right.move_to(exchange.get_right())\n",
        "\n",
        "            exchange.left = left\n",
        "            exchange.right = right\n",
        "            exchange.start_time = start_time\n",
        "            exchange.add(left, right)\n",
        "            exchange.currencies = currencies\n",
        "            exchange.cryptocurrencies = cryptocurrencies\n",
        "            exchange.animation = Exchange(exchange)\n",
        "\n",
        "        times = np.arange(0, self.run_time, self.frame_duration)\n",
        "        from scene.scene import ProgressDisplay\n",
        "        for t in ProgressDisplay(times):\n",
        "            for exchange in exchanges:\n",
        "                sub_t = t - exchange.start_time\n",
        "                if sub_t < 0:\n",
        "                    continue\n",
        "                elif sub_t > 3:\n",
        "                    exchange.start_time = t\n",
        "                    sub_t = 0\n",
        "                    exchange.animation = Exchange(exchange)\n",
        "                exchange.animation.update(sub_t/3.0)\n",
        "            self.update_frame(\n",
        "                self.extract_mobject_family_members(exchanges)\n",
        "            )\n",
        "            self.add_frames(self.get_frame())\n",
        "\n",
        "    def get_cryptocurrencies(self):\n",
        "        return [\n",
        "            BitcoinLogo(),\n",
        "            BitcoinLogo(),\n",
        "            BitcoinLogo(),\n",
        "            EthereumLogo(),\n",
        "            LitecoinLogo()\n",
        "        ]\n",
        "\n",
        "    def get_currencies(self):\n",
        "        return [\n",
        "            OldTex(\"\\\\$\").set_color(GREEN),\n",
        "            OldTex(\"\\\\$\").set_color(GREEN),\n",
        "            OldTex(\"\\\\$\").set_color(GREEN),\n",
        "            SVGMobject(\n",
        "                file_name = \"euro_symbol\",\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 1,\n",
        "                fill_color = BLUE,\n",
        "            ),\n",
        "            SVGMobject(\n",
        "                file_name = \"yen_symbol\",\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 1,\n",
        "                fill_color = RED,\n",
        "            )\n",
        "        ]\n",
        "\n",
        "class ShowLDAndOtherCurrencyExchanges(ShowManyExchanges):\n",
        "    CONFIG = {\n",
        "        \"run_time\" : 15,\n",
        "    }\n",
        "    def get_cryptocurrencies(self):\n",
        "        euro = SVGMobject(\n",
        "            file_name = \"euro_symbol\",\n",
        "            stroke_width = 0,\n",
        "            fill_opacity = 1,\n",
        "            fill_color = BLUE,\n",
        "        )\n",
        "        return [\n",
        "            OldTexText(\"LD\").set_color(YELLOW),\n",
        "            OldTexText(\"LD\").set_color(YELLOW),\n",
        "            euro, euro.copy(),\n",
        "            SVGMobject(\n",
        "                file_name = \"yen_symbol\",\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 1,\n",
        "                fill_color = RED,\n",
        "            ),\n",
        "            BitcoinLogo(),\n",
        "        ]\n",
        "\n",
        "    def get_currencies(self):\n",
        "        return [Tex(\"\\\\$\").set_color(GREEN)]\n",
        "\n",
        "class CryptoPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"James Park\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Michael McGuffin\",\n",
        "            \"John Haley\",\n",
        "            \"Mourits de Beer\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Tomohiro Furusawa\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class ProtocolLabs(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        logo = self.get_logo()\n",
        "        logo.next_to(morty, UP)\n",
        "        logo.shift_onto_screen()\n",
        "        screen_rect = ScreenRectangle()\n",
        "        screen_rect.set_height(5)\n",
        "        screen_rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(logo[0]),\n",
        "            LaggedStartMap(FadeIn, logo[1]),\n",
        "            morty.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            logo.scale, 0.5,\n",
        "            logo.to_corner, UP+LEFT,\n",
        "            ShowCreation(screen_rect)\n",
        "        )\n",
        "        modes = [\"pondering\", \"happy\", \"happy\"]\n",
        "        for mode in modes:\n",
        "            for x in range(2):\n",
        "                self.play(Blink(morty))\n",
        "                self.wait(3)\n",
        "            self.play(morty.change, mode, screen_rect)\n",
        "\n",
        "    def get_logo(self):\n",
        "        logo = SVGMobject(\n",
        "            file_name = \"protocol_labs_logo\",\n",
        "            height = 1.5,\n",
        "            fill_color = WHITE,\n",
        "        )\n",
        "        name = SVGMobject(\n",
        "            file_name = \"protocol_labs_name\",\n",
        "            height = 0.5*logo.get_height(),\n",
        "            fill_color = GREY_B,\n",
        "        )\n",
        "        for mob in logo, name:\n",
        "            for submob in mob:\n",
        "                submob.is_subpath = False\n",
        "        name.next_to(logo, RIGHT)\n",
        "        return VGroup(logo, name)\n",
        "\n",
        "class Thumbnail(DistributedBlockChainScene):\n",
        "    CONFIG = {\n",
        "        \"n_blocks\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Crypto\", \"currencies\", arg_separator = \"\")\n",
        "        title.scale(2.5)\n",
        "        title.to_edge(UP)\n",
        "        title[0].set_color(YELLOW)\n",
        "        title[0].set_stroke(RED, 2)\n",
        "        self.add(title)\n",
        "\n",
        "        # logos = VGroup(\n",
        "        #     BitcoinLogo(), EthereumLogo(), LitecoinLogo()\n",
        "        # )\n",
        "        # for logo in logos:\n",
        "        #     logo.set_height(1)\n",
        "        # logos.add(OldTex(\"\\\\dots\").scale(2))\n",
        "        # logos.arrange(RIGHT)\n",
        "        # logos.next_to(title, RIGHT, LARGE_BUFF)\n",
        "        # self.add(logos)\n",
        "\n",
        "        block_chain = self.get_block_chain()\n",
        "        block_chain.arrows.set_color(RED)\n",
        "        block_chain.blocks.set_color_by_gradient(BLUE, GREEN)\n",
        "        block_chain.set_width(FRAME_WIDTH-1)\n",
        "        block_chain.set_stroke(width = 12)\n",
        "        self.add(block_chain)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}