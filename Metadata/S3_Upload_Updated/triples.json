{
    "topic": "demonstrates the Pythagorean theorem, which states that in a right triangle,",
    "code": [
        "import fractions\n",
        "from manim_imports_ext import *\n",
        "\n",
        "A_COLOR = BLUE\n",
        "B_COLOR = GREEN\n",
        "C_COLOR = YELLOW\n",
        "SIDE_COLORS = [A_COLOR, B_COLOR, C_COLOR]\n",
        "U_COLOR = GREEN\n",
        "V_COLOR = RED\n",
        "\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "def complex_string_with_i(z):\n",
        "    if z.real == 0:\n",
        "        return str(int(z.imag)) + \"i\"\n",
        "    elif z.imag == 0:\n",
        "        return str(int(z.real))\n",
        "    return complex_string(z).replace(\"j\", \"i\")\n",
        "\n",
        "class IntroduceTriples(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTex(\"a\", \"^2\", \"+\", \"b\", \"^2\", \"=\", \"c\", \"^2\")\n",
        "        for color, char in zip(SIDE_COLORS, \"abc\"):\n",
        "            title.set_color_by_tex(char, color)\n",
        "        title.to_corner(UP + RIGHT)\n",
        "\n",
        "        triples = [\n",
        "            (3, 4, 5), \n",
        "            (5, 12, 13),\n",
        "            (8, 15, 17),\n",
        "            (7, 24, 25),\n",
        "        ]\n",
        "\n",
        "        self.add(title)\n",
        "        for a, b, c in triples:\n",
        "            triangle = Polygon(\n",
        "                ORIGIN, a*RIGHT, a*RIGHT+b*UP,\n",
        "                stroke_width = 0,\n",
        "                fill_color = WHITE,\n",
        "                fill_opacity = 0.5\n",
        "            )\n",
        "            hyp_line = Line(ORIGIN, a*RIGHT+b*UP)\n",
        "            elbow = VMobject()\n",
        "            elbow.set_points_as_corners([LEFT, LEFT+UP, UP])\n",
        "            elbow.set_width(0.2*triangle.get_width())\n",
        "            elbow.move_to(triangle, DOWN+RIGHT)\n",
        "            triangle.add(elbow)\n",
        "\n",
        "            square = Square(side_length = 1)\n",
        "            square_groups = VGroup()\n",
        "            for n, color in zip([a, b, c], SIDE_COLORS):\n",
        "                square_group = VGroup(*[\n",
        "                    square.copy().shift(x*RIGHT + y*UP)\n",
        "                    for x in range(n)\n",
        "                    for y in range(n)\n",
        "                ])\n",
        "                square_group.set_stroke(color, width = 3)\n",
        "                square_group.set_fill(color, opacity = 0.5)\n",
        "                square_groups.add(square_group)\n",
        "            a_square, b_square, c_square = square_groups\n",
        "            a_square.move_to(triangle.get_bottom(), UP)\n",
        "            b_square.move_to(triangle.get_right(), LEFT)\n",
        "            c_square.move_to(hyp_line.get_center(), DOWN)\n",
        "            c_square.rotate(\n",
        "                hyp_line.get_angle(),\n",
        "                about_point = hyp_line.get_center()\n",
        "            )\n",
        "            if c in [5, 13, 25]:\n",
        "                if c == 5:\n",
        "                    keys = list(range(0, 5, 2))\n",
        "                elif c == 13:\n",
        "                    keys = list(range(0, 13, 3))\n",
        "                elif c == 25:\n",
        "                    keys = list(range(0, 25, 4))\n",
        "                i_list = [i for i in range(c**2) if (i%c) in keys and (i//c) in keys]\n",
        "            else:\n",
        "                i_list = list(range(a**2))\n",
        "            not_i_list = list(filter(\n",
        "                lambda i : i not in i_list,\n",
        "                list(range(c**2)),\n",
        "            ))\n",
        "            c_square_parts = [\n",
        "                VGroup(*[c_square[i] for i in i_list]),\n",
        "                VGroup(*[c_square[i] for i in not_i_list]),\n",
        "            ]\n",
        "            full_group = VGroup(triangle, square_groups)\n",
        "            full_group.set_height(4)\n",
        "            full_group.center()\n",
        "            full_group.to_edge(UP)\n",
        "\n",
        "            equation = OldTex(\n",
        "                str(a), \"^2\", \"+\", str(b), \"^2\", \"=\", str(c), \"^2\"\n",
        "            )\n",
        "            for num, color in zip([a, b, c], SIDE_COLORS):\n",
        "                equation.set_color_by_tex(str(num), color)\n",
        "            equation.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "            equation.shift_onto_screen()\n",
        "            \n",
        "            self.play(\n",
        "                FadeIn(triangle),\n",
        "                self.teacher.change_mode, \"raise_right_hand\"\n",
        "            )\n",
        "            self.play(LaggedStartMap(FadeIn, a_square))\n",
        "            self.play_student_changes(\n",
        "                *[\"pondering\"]*3,\n",
        "                look_at = triangle,\n",
        "                added_anims = [LaggedStartMap(FadeIn, b_square)]\n",
        "            )\n",
        "            self.play(self.teacher.change_mode, \"happy\")\n",
        "            for start, target in zip([a_square, b_square], c_square_parts):\n",
        "                mover = start.copy().set_fill(opacity = 0)\n",
        "                target.set_color(start.get_color())\n",
        "                self.play(ReplacementTransform(\n",
        "                    mover, target,\n",
        "                    run_time = 2,\n",
        "                    path_arc = np.pi/2\n",
        "                ))\n",
        "            self.play(Write(equation))\n",
        "            self.play(c_square.set_color, C_COLOR)\n",
        "            self.wait()\n",
        "            self.play(*list(map(FadeOut, [full_group, equation])))\n",
        "\n",
        "class CompareToFermatsLastTheorem(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        expressions = [\n",
        "            OldTex(\n",
        "                \"a\", \"^%d\"%d, \"+\", \"b\", \"^%d\"%d, \n",
        "                \"=\", \"c\", \"^%d\"%d\n",
        "            )\n",
        "            for d in range(2, 9)\n",
        "        ]\n",
        "        for expression in expressions:\n",
        "            for char, color in zip(\"abc\", SIDE_COLORS):\n",
        "                expression.set_color_by_tex(char, color)\n",
        "            expression.next_to(self.get_pi_creatures(), UP, buff = 1.3)\n",
        "        square_expression = expressions[0]\n",
        "        low_expression = expressions[1]\n",
        "        square_expression.to_edge(UP, buff = 1.3)\n",
        "        top_brace = Brace(square_expression, UP, buff = SMALL_BUFF)\n",
        "        top_text = top_brace.get_text(\n",
        "            \"Abundant integer solutions\", buff = SMALL_BUFF\n",
        "        )\n",
        "        low_brace = Brace(low_expression, DOWN, buff = SMALL_BUFF)\n",
        "        low_text = low_brace.get_text(\n",
        "            \"No integer solutions\", buff = SMALL_BUFF\n",
        "        )\n",
        "        low_text.set_color(RED)\n",
        "\n",
        "        self.add(square_expression, top_brace, top_text)\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.play(self.teacher.change, \"happy\", run_time = 0)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                square_expression.copy(),\n",
        "                low_expression\n",
        "            ),\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"confused\", expressions[1])\n",
        "                for pi in self.get_students()\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(low_expression, expressions[2]))\n",
        "        self.play(\n",
        "            GrowFromCenter(low_brace),\n",
        "            FadeIn(low_text),\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"sassy\", \"angry\", \"erm\",\n",
        "            look_at = low_expression,\n",
        "            added_anims = [Transform(low_expression, expressions[3])]\n",
        "        )\n",
        "        for expression in expressions[4:]:\n",
        "            self.play(Transform(low_expression, expression))\n",
        "            self.wait()\n",
        "\n",
        "class WritePythagoreanTriple(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"``Pythagorean triple''\")\n",
        "        words.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        words.to_corner(DOWN+LEFT)\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class ShowManyTriples(Scene):\n",
        "    def construct(self):\n",
        "        triples = [\n",
        "            (u**2 - v**2, 2*u*v, u**2 + v**2)\n",
        "            for u in range(1, 15)\n",
        "            for v in range(1, u)\n",
        "            if fractions.gcd(u, v) == 1 and not (u%2 == v%2)\n",
        "        ][:40]\n",
        "        triangles = VGroup()\n",
        "        titles = VGroup()\n",
        "        for i, (a, b, c) in enumerate(triples):\n",
        "            triangle = Polygon(ORIGIN, a*RIGHT, a*RIGHT+b*UP)\n",
        "            triangle.set_color(WHITE)\n",
        "            max_width = max_height = 4\n",
        "            triangle.set_height(max_height)\n",
        "            if triangle.get_width() > max_width:\n",
        "                triangle.set_width(max_width)\n",
        "            triangle.move_to(2*RIGHT)\n",
        "            num_strings = list(map(str, (a, b, c)))\n",
        "            labels = list(map(Tex, num_strings))\n",
        "            for label, color in zip(labels, SIDE_COLORS):\n",
        "                label.set_color(color)\n",
        "            labels[0].next_to(triangle, DOWN)\n",
        "            labels[1].next_to(triangle, RIGHT)\n",
        "            labels[2].next_to(triangle.get_center(), UP+LEFT)\n",
        "            triangle.add(*labels)\n",
        "\n",
        "            title = OldTex(\n",
        "                str(a), \"^2\", \"+\", str(b), \"^2\", \"=\", str(c), \"^2\"\n",
        "            )\n",
        "            for num, color in zip([a, b, c], SIDE_COLORS):\n",
        "                title.set_color_by_tex(str(num), color)\n",
        "            title.next_to(triangle, UP, LARGE_BUFF)\n",
        "            title.generate_target()\n",
        "            title.target.scale(0.5)\n",
        "\n",
        "            title.target.move_to(\n",
        "                (-FRAME_X_RADIUS + MED_LARGE_BUFF + 2.7*(i//8))*RIGHT + \\\n",
        "                (FRAME_Y_RADIUS - MED_LARGE_BUFF - (i%8))*UP,\n",
        "                UP+LEFT\n",
        "            )\n",
        "\n",
        "            triangles.add(triangle)\n",
        "            titles.add(title)\n",
        "\n",
        "        triangle = triangles[0]\n",
        "        title = titles[0]\n",
        "        self.play(\n",
        "            Write(triangle),\n",
        "            Write(title),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(title))\n",
        "        for i in range(1, 17):\n",
        "            new_triangle = triangles[i]\n",
        "            new_title = titles[i]\n",
        "            if i < 4:\n",
        "                self.play(\n",
        "                    Transform(triangle, new_triangle),\n",
        "                    FadeIn(new_title)\n",
        "                )\n",
        "                self.wait()\n",
        "                self.play(MoveToTarget(new_title))\n",
        "            else:\n",
        "                self.play(\n",
        "                    Transform(triangle, new_triangle),\n",
        "                    FadeIn(new_title.target)\n",
        "                )\n",
        "                self.wait()\n",
        "        self.play(FadeOut(triangle))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, \n",
        "            VGroup(*[\n",
        "                title.target \n",
        "                for title in titles[17:]\n",
        "            ]),\n",
        "            run_time = 5\n",
        "        ))\n",
        "\n",
        "        self.wait(2)\n",
        "\n",
        "class BabylonianTablets(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Plimpton 322 Tablets \\\\\\\\ (1800 BC)\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        ac_pairs = [\n",
        "            (119, 169),\n",
        "            (3367, 4825),\n",
        "            (4601, 6649),\n",
        "            (12709, 18541),\n",
        "            (65, 97),\n",
        "            (319, 481),\n",
        "            (2291, 3541),\n",
        "            (799, 1249),\n",
        "            (481, 769),\n",
        "            (4961, 8161),\n",
        "            (45, 75),\n",
        "            (1679, 2929),\n",
        "            (161, 289),\n",
        "            (1771, 3229),\n",
        "            (56, 106),\n",
        "        ]\n",
        "        triples = VGroup()\n",
        "        for a, c in ac_pairs:\n",
        "            b = int(np.sqrt(c**2 - a**2))\n",
        "            tex = \"%s^2 + %s^2 = %s^2\"%tuple(\n",
        "                map(\"{:,}\".format, [a, b, c])\n",
        "            )\n",
        "            tex = tex.replace(\",\", \"{,}\")\n",
        "            triple = OldTex(tex)\n",
        "            triples.add(triple)\n",
        "        triples.arrange(DOWN, aligned_edge = LEFT)\n",
        "        triples.set_height(FRAME_HEIGHT - LARGE_BUFF)\n",
        "        triples.to_edge(RIGHT)\n",
        "\n",
        "        self.add(title)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, triples, run_time = 5))\n",
        "        self.wait()\n",
        "\n",
        "class AskAboutFavoriteProof(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What's you're \\\\\\\\ favorite proof?\",\n",
        "            target_mode = \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"raise_right_hand\", \"happy\")\n",
        "        self.teacher_thinks(\"\", target_mode = \"thinking\")\n",
        "        self.wait()\n",
        "        self.zoom_in_on_thought_bubble()\n",
        "\n",
        "class PythagoreanProof(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_proof()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"a^2\", \"+\", \"b^2\", \"=\", \"c^2\")\n",
        "        for color, char in zip(SIDE_COLORS, \"abc\"):\n",
        "            title.set_color_by_tex(char, color)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_proof(self):\n",
        "        triangle = Polygon(\n",
        "            ORIGIN, 5*RIGHT, 5*RIGHT+12*UP,\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 2,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 0.5\n",
        "        )\n",
        "        triangle.set_height(3)\n",
        "        triangle.center()\n",
        "        side_labels = self.get_triangle_side_labels(triangle)\n",
        "        triangle_copy = triangle.copy()\n",
        "        squares = self.get_abc_squares(triangle)\n",
        "        a_square, b_square, c_square = squares\n",
        "\n",
        "\n",
        "        self.add(triangle, triangle_copy)\n",
        "        self.play(Write(side_labels))\n",
        "        self.wait()\n",
        "        self.play(*list(map(DrawBorderThenFill, squares)))\n",
        "        self.add_labels_to_squares(squares, side_labels)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(triangle_copy, a_square, b_square).move_to, \n",
        "                4*LEFT+2*DOWN, DOWN,\n",
        "            VGroup(triangle, c_square).move_to, \n",
        "                4*RIGHT+2*DOWN, DOWN,\n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_new_triangles(\n",
        "            triangle, \n",
        "            self.get_added_triangles_to_c_square(triangle, c_square)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_new_triangles(\n",
        "            triangle_copy,\n",
        "            self.get_added_triangles_to_ab_squares(triangle_copy, a_square)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        big_squares = VGroup(*list(map(\n",
        "            self.get_big_square,\n",
        "            [triangle, triangle_copy]\n",
        "        )))\n",
        "        negative_space_words = OldTexText(\n",
        "            \"Same negative \\\\\\\\ space\"\n",
        "        )\n",
        "        negative_space_words.scale(0.75)\n",
        "        negative_space_words.shift(UP)\n",
        "        double_arrow = DoubleArrow(LEFT, RIGHT)\n",
        "        double_arrow.next_to(negative_space_words, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(big_squares), \n",
        "            Write(negative_space_words), \n",
        "            ShowCreation(double_arrow),\n",
        "            *list(map(FadeOut, squares))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeIn, squares)),\n",
        "            list(map(Animation, big_squares)),\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def add_labels_to_squares(self, squares, side_labels):\n",
        "        for label, square in zip(side_labels, squares):\n",
        "            label.target = OldTex(label.get_tex() + \"^2\")\n",
        "            label.target.set_color(label.get_color())\n",
        "            # label.target.scale(0.7)\n",
        "            label.target.move_to(square)\n",
        "            square.add(label)\n",
        "\n",
        "        self.play(LaggedStartMap(MoveToTarget, side_labels))\n",
        "\n",
        "    def add_new_triangles(self, triangle, added_triangles):\n",
        "        brace = Brace(added_triangles, DOWN)\n",
        "        label = OldTex(\"a\", \"+\", \"b\")\n",
        "        label.set_color_by_tex(\"a\", A_COLOR)\n",
        "        label.set_color_by_tex(\"b\", B_COLOR)\n",
        "        label.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(triangle.copy().set_fill(opacity = 0)),\n",
        "            added_triangles,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(label))\n",
        "        triangle.added_triangles = added_triangles\n",
        "\n",
        "    def get_big_square(self, triangle):\n",
        "        square = Square(stroke_color = RED)\n",
        "        square.replace(\n",
        "            VGroup(triangle, triangle.added_triangles),\n",
        "            stretch = True\n",
        "        )\n",
        "        square.scale(1.01)\n",
        "        return square\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_triangle_side_labels(self, triangle):\n",
        "        a, b, c = list(map(Tex, \"abc\"))\n",
        "        for mob, color in zip([a, b, c], SIDE_COLORS):\n",
        "            mob.set_color(color)\n",
        "        a.next_to(triangle, DOWN)\n",
        "        b.next_to(triangle, RIGHT)\n",
        "        c.next_to(triangle.get_center(), LEFT)\n",
        "        return VGroup(a, b, c)\n",
        "\n",
        "    def get_abc_squares(self, triangle):\n",
        "        a_square, b_square, c_square = squares = [\n",
        "            Square(\n",
        "                stroke_color = color,\n",
        "                fill_color = color,\n",
        "                fill_opacity = 0.5,\n",
        "            )\n",
        "            for color in SIDE_COLORS\n",
        "        ]\n",
        "        a_square.set_width(triangle.get_width())\n",
        "        a_square.move_to(triangle.get_bottom(), UP)\n",
        "        b_square.set_height(triangle.get_height())\n",
        "        b_square.move_to(triangle.get_right(), LEFT)\n",
        "        hyp_line = Line(\n",
        "            triangle.get_corner(UP+RIGHT),\n",
        "            triangle.get_corner(DOWN+LEFT),\n",
        "        )\n",
        "        c_square.set_width(hyp_line.get_length())\n",
        "        c_square.move_to(hyp_line.get_center(), UP)\n",
        "        c_square.rotate(\n",
        "            hyp_line.get_angle(), \n",
        "            about_point = hyp_line.get_center()\n",
        "        )\n",
        "\n",
        "        return a_square, b_square, c_square\n",
        "\n",
        "    def get_added_triangles_to_c_square(self, triangle, c_square):\n",
        "        return VGroup(*[\n",
        "            triangle.copy().rotate(i*np.pi/2, about_point = c_square.get_center())\n",
        "            for i in range(1, 4)\n",
        "        ])\n",
        "\n",
        "    def get_added_triangles_to_ab_squares(self, triangle, a_square):\n",
        "        t1 = triangle.copy()\n",
        "        t1.rotate(np.pi)\n",
        "        group = VGroup(triangle, t1).copy()\n",
        "        group.rotate(-np.pi/2)\n",
        "        group.move_to(a_square.get_right(), LEFT)\n",
        "        t2, t3 = group\n",
        "        return VGroup(t1, t2, t3)\n",
        "\n",
        "class ReframeOnLattice(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"initial_plane_center\" : 3*LEFT + DOWN,\n",
        "        \"new_plane_center\" : ORIGIN,\n",
        "        \"initial_unit_size\" : 0.5,\n",
        "        \"new_unit_size\" : 0.8,\n",
        "        \"dot_radius\" : 0.075,\n",
        "        \"dot_color\" : YELLOW,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.add_plane()\n",
        "        self.wander_over_lattice_points()\n",
        "        self.show_whole_distance_examples()\n",
        "        self.resize_plane()\n",
        "        self.show_root_example()\n",
        "        self.view_as_complex_number()\n",
        "        self.mention_squaring_it()\n",
        "        self.work_out_square_algebraically()\n",
        "        self.walk_through_square_geometrically()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = ComplexPlane(\n",
        "            center_point = self.initial_plane_center,\n",
        "            unit_size = self.initial_unit_size,\n",
        "            stroke_width = 2,\n",
        "            secondary_line_ratio = 0,\n",
        "        )\n",
        "        plane.axes.set_stroke(width = 4)\n",
        "        plane.coordinate_labels = VGroup()\n",
        "        for x in range(-8, 20, 2):\n",
        "            if x == 0:\n",
        "                continue\n",
        "            label = OldTex(str(x))\n",
        "            label.scale(0.5)\n",
        "            label.add_background_rectangle(opacity = 1)\n",
        "            label.next_to(plane.coords_to_point(x, 0), DOWN, SMALL_BUFF)\n",
        "            plane.coordinate_labels.add(label)\n",
        "\n",
        "        self.add(plane, plane.coordinate_labels)\n",
        "        self.plane = plane\n",
        "\n",
        "    def wander_over_lattice_points(self):\n",
        "        initial_examples = [(5, 3), (6, 8), (2, 7)]\n",
        "        integer_distance_examples = [(3, 4), (12, 5), (15, 8)]\n",
        "        dot_tuple_groups = VGroup()\n",
        "        for x, y in initial_examples + integer_distance_examples:\n",
        "            dot = Dot(\n",
        "                self.plane.coords_to_point(x, y),\n",
        "                color = self.dot_color,\n",
        "                radius = self.dot_radius,\n",
        "            )\n",
        "            tuple_mob = OldTex(\"(\", str(x), \",\", str(y), \")\")\n",
        "            tuple_mob.add_background_rectangle()\n",
        "            tuple_mob.next_to(dot, UP+RIGHT, buff = 0)\n",
        "            dot_tuple_groups.add(VGroup(dot, tuple_mob))\n",
        "        dot_tuple_group = dot_tuple_groups[0]\n",
        "        final_group = dot_tuple_groups[-len(integer_distance_examples)]\n",
        "\n",
        "        all_dots = self.get_all_plane_dots()\n",
        "\n",
        "        self.play(Write(dot_tuple_group, run_time = 2))\n",
        "        self.wait()\n",
        "        for new_group in dot_tuple_groups[1:len(initial_examples)]:\n",
        "            self.play(Transform(dot_tuple_group, new_group))\n",
        "            self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, all_dots,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            dot_tuple_group, final_group\n",
        "        ))\n",
        "\n",
        "        self.integer_distance_dot_tuple_groups = VGroup(\n",
        "            *dot_tuple_groups[len(initial_examples):]\n",
        "        )\n",
        "\n",
        "    def show_whole_distance_examples(self):\n",
        "        dot_tuple_groups = self.integer_distance_dot_tuple_groups\n",
        "        for dot_tuple_group in dot_tuple_groups:\n",
        "            dot, tuple_mob = dot_tuple_group\n",
        "            p0 = self.plane.get_center_point()\n",
        "            p1 = dot.get_center()\n",
        "            triangle = Polygon(\n",
        "                p0, p1[0]*RIGHT + p0[1]*UP, p1,\n",
        "                stroke_width = 0,\n",
        "                fill_color = BLUE,\n",
        "                fill_opacity = 0.75,\n",
        "            )\n",
        "            line = Line(p0, p1, color = dot.get_color())\n",
        "            a, b = self.plane.point_to_coords(p1)\n",
        "            c = int(np.sqrt(a**2 + b**2))\n",
        "            hyp_label = OldTex(str(c))\n",
        "            hyp_label.add_background_rectangle()\n",
        "            hyp_label.next_to(\n",
        "                triangle.get_center(), UP+LEFT, buff = SMALL_BUFF\n",
        "            )\n",
        "            line.add(hyp_label)\n",
        "\n",
        "            dot_tuple_group.triangle = triangle\n",
        "            dot_tuple_group.line = line\n",
        "\n",
        "        group = dot_tuple_groups[0]\n",
        "\n",
        "        self.play(Write(group.line))\n",
        "        self.play(FadeIn(group.triangle), Animation(group.line))\n",
        "        self.wait(2)\n",
        "        for new_group in dot_tuple_groups[1:]:\n",
        "            self.play(\n",
        "                Transform(group, new_group),\n",
        "                Transform(group.triangle, new_group.triangle),\n",
        "                Transform(group.line, new_group.line),\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [group, group.triangle, group.line])))\n",
        "\n",
        "    def resize_plane(self):\n",
        "        new_plane = ComplexPlane(\n",
        "            plane_center = self.new_plane_center,\n",
        "            unit_size = self.new_unit_size,\n",
        "            y_radius = 8,\n",
        "            x_radius = 11,\n",
        "            stroke_width = 2,\n",
        "            secondary_line_ratio = 0,\n",
        "        )\n",
        "        new_plane.axes.set_stroke(width = 4)\n",
        "        self.plane.generate_target()\n",
        "        self.plane.target.unit_size = self.new_unit_size\n",
        "        self.plane.target.plane_center = self.new_plane_center\n",
        "        self.plane.target.shift(\n",
        "            new_plane.coords_to_point(0, 0) - \\\n",
        "            self.plane.target.coords_to_point(0, 0)\n",
        "        )\n",
        "        self.plane.target.scale(\n",
        "            self.new_unit_size / self.initial_unit_size\n",
        "        )\n",
        "        coordinate_labels = self.plane.coordinate_labels\n",
        "        for coord in coordinate_labels:\n",
        "            x = int(coord.get_tex())\n",
        "            coord.generate_target()\n",
        "            coord.target.scale(1.5)\n",
        "            coord.target.next_to(\n",
        "                new_plane.coords_to_point(x, 0),\n",
        "                DOWN, buff = SMALL_BUFF\n",
        "            )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(self.plane),\n",
        "            *list(map(MoveToTarget, self.plane.coordinate_labels)),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.remove(self.plane)\n",
        "        self.plane = new_plane\n",
        "        self.plane.coordinate_labels = coordinate_labels \n",
        "        self.add(self.plane, coordinate_labels)\n",
        "        self.wait()\n",
        "\n",
        "    def show_root_example(self):\n",
        "        x, y = (2, 1)\n",
        "        point = self.plane.coords_to_point(x, y)\n",
        "        dot = Dot(\n",
        "            point,\n",
        "            color = self.dot_color,\n",
        "            radius = self.dot_radius\n",
        "        )\n",
        "        tuple_label = OldTex(str((x, y)))\n",
        "        tuple_label.add_background_rectangle()\n",
        "        tuple_label.next_to(dot, RIGHT, SMALL_BUFF)\n",
        "        line = Line(self.plane.get_center_point(), point)\n",
        "        line.set_color(dot.get_color())\n",
        "        distance_labels = VGroup()\n",
        "        for tex in \"2^2 + 1^2\", \"5\":\n",
        "            pre_label = OldTex(\"\\\\sqrt{%s}\"%tex)\n",
        "            rect = BackgroundRectangle(pre_label)\n",
        "            label = VGroup(\n",
        "                rect,\n",
        "                VGroup(*pre_label[:2]),\n",
        "                VGroup(*pre_label[2:]),\n",
        "            )\n",
        "            label.scale(0.8)\n",
        "            label.next_to(line.get_center(), UP, SMALL_BUFF)\n",
        "            label.rotate(\n",
        "                line.get_angle(),\n",
        "                about_point = line.get_center()\n",
        "            )\n",
        "            distance_labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            DrawBorderThenFill(\n",
        "                dot,\n",
        "                stroke_width = 3,\n",
        "                stroke_color = PINK\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(tuple_label))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(distance_labels[0]))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(*distance_labels))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.distance_label = distance_labels[0]\n",
        "        self.example_dot = dot\n",
        "        self.example_line = line\n",
        "        self.example_tuple_label = tuple_label\n",
        "\n",
        "    def view_as_complex_number(self):\n",
        "        imag_coords = VGroup()\n",
        "        for y in range(-4, 5, 2):\n",
        "            if y == 0:\n",
        "                continue\n",
        "            label = OldTex(\"%di\"%y)\n",
        "            label.add_background_rectangle()\n",
        "            label.scale(0.75)\n",
        "            label.next_to(\n",
        "                self.plane.coords_to_point(0, y),\n",
        "                LEFT, SMALL_BUFF\n",
        "            )\n",
        "            imag_coords.add(label)\n",
        "        tuple_label = self.example_tuple_label\n",
        "        new_label = OldTex(\"2+i\")\n",
        "        new_label.add_background_rectangle()\n",
        "        new_label.next_to(\n",
        "            self.example_dot,\n",
        "            DOWN+RIGHT, buff = 0,\n",
        "        )\n",
        "\n",
        "        self.play(Write(imag_coords))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(tuple_label))\n",
        "        self.play(FadeIn(new_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.example_label = new_label\n",
        "        self.plane.coordinate_labels.add(*imag_coords)\n",
        "\n",
        "    def mention_squaring_it(self):\n",
        "        morty = self.pi_creature\n",
        "        arrow = Arrow(\n",
        "            self.plane.coords_to_point(2, 1),\n",
        "            self.plane.coords_to_point(3, 4),\n",
        "            path_arc = np.pi/3,\n",
        "            color = MAROON_B\n",
        "        )\n",
        "        square_label = OldTex(\"z \\\\to z^2\")\n",
        "        square_label.set_color(arrow.get_color())\n",
        "        square_label.add_background_rectangle()\n",
        "        square_label.next_to(\n",
        "            arrow.point_from_proportion(0.5), \n",
        "            RIGHT, buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                morty, \"Try squaring \\\\\\\\ it!\",\n",
        "                target_mode = \"hooray\",\n",
        "                bubble_config = {\"width\" : 4, \"height\" : 3},\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(square_label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            morty, target_mode = \"pondering\",\n",
        "            look_at = self.example_label\n",
        "        ))\n",
        "\n",
        "    def work_out_square_algebraically(self):\n",
        "        rect = Rectangle(\n",
        "            height = 3.5, width = 6.5,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8\n",
        "        )\n",
        "        rect.to_corner(UP+LEFT, buff = 0)\n",
        "        top_line = OldTex(\"(2+i)\", \"(2+i)\")\n",
        "        top_line.next_to(rect.get_top(), DOWN)\n",
        "        second_line = OldTex(\n",
        "            \"2^2 + 2i + 2i + i^2\"\n",
        "        )\n",
        "        second_line.next_to(top_line, DOWN, MED_LARGE_BUFF)\n",
        "        final_line = OldTex(\"3 + 4i\")\n",
        "        final_line.next_to(second_line, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        result_dot = Dot(\n",
        "            self.plane.coords_to_point(3, 4),\n",
        "            color = MAROON_B,\n",
        "            radius = self.dot_radius\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            ReplacementTransform(\n",
        "                VGroup(self.example_label[1].copy()),\n",
        "                top_line\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #From top line to second line\n",
        "        index_alignment_lists = [\n",
        "            [(0, 1, 0), (1, 1, 1)],\n",
        "            [(0, 2, 2), (0, 1, 3), (1, 3, 4)],\n",
        "            [(0, 2, 5), (1, 1, 6), (0, 3, 7)],\n",
        "            [(0, 2, 8), (0, 3, 9), (1, 3, 10)],\n",
        "        ]\n",
        "        for index_alignment in index_alignment_lists:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    top_line[i][j].copy(), second_line[k],\n",
        "                )\n",
        "                for i, j, k in index_alignment\n",
        "            ])\n",
        "        self.wait(2)\n",
        "\n",
        "        #From second line to final line\n",
        "        index_alignment_lists = [\n",
        "            [(0, 0), (1, 0), (9, 0), (10, 0)],\n",
        "            [(2, 1), (3, 2), (4, 3), (6, 2), (7, 3)],\n",
        "        ]\n",
        "        for index_alignment in index_alignment_lists:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    second_line[i].copy(), final_line[j],\n",
        "                    run_time = 1.5\n",
        "                )\n",
        "                for i, j in index_alignment\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "        #Move result to appropriate place\n",
        "        result_label = final_line.copy()\n",
        "        result_label.add_background_rectangle()\n",
        "        self.play(\n",
        "            result_label.next_to, result_dot, UP+RIGHT, SMALL_BUFF,\n",
        "            Animation(final_line),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play(DrawBorderThenFill(\n",
        "            result_dot,\n",
        "            stroke_width = 4,\n",
        "            stroke_color = PINK\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    def walk_through_square_geometrically(self):\n",
        "        line = self.example_line\n",
        "        dot = self.example_dot\n",
        "        example_label = self.example_label\n",
        "        distance_label = self.distance_label\n",
        "\n",
        "        alt_line = line.copy().set_color(RED)\n",
        "        arc = Arc(\n",
        "            angle = line.get_angle(),\n",
        "            radius = 0.7,\n",
        "            color = WHITE\n",
        "        )\n",
        "        double_arc = Arc(\n",
        "            angle = 2*line.get_angle(),\n",
        "            radius = 0.8,\n",
        "            color = RED,\n",
        "        )\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        two_theta = OldTex(\"2\\\\theta\")\n",
        "        for tex_mob, arc_mob in (theta, arc), (two_theta, double_arc):\n",
        "            tex_mob.scale(0.75)\n",
        "            tex_mob.add_background_rectangle()\n",
        "            point = arc_mob.point_from_proportion(0.5)\n",
        "            tex_mob.move_to(point)\n",
        "            tex_mob.shift(tex_mob.get_width()*point/get_norm(point))\n",
        "\n",
        "\n",
        "        self.play(self.pi_creature.change, \"happy\", arc)\n",
        "        self.play(ShowCreation(alt_line))\n",
        "        self.play(ShowCreation(line))\n",
        "        self.remove(alt_line)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(theta)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Indicate(distance_label))\n",
        "        self.wait()\n",
        "\n",
        "        #Multiply full plane under everything\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        everything.remove(self.plane)\n",
        "        self.plane.save_state()\n",
        "        ghost_plane = self.plane.copy().fade()\n",
        "        method_args_list = [\n",
        "            (self.plane.rotate, (line.get_angle(),)),\n",
        "            (self.plane.scale, (np.sqrt(5),)),\n",
        "            (self.plane.restore, ()),\n",
        "        ]\n",
        "        for method, args in method_args_list:\n",
        "            self.play(\n",
        "                Animation(ghost_plane),\n",
        "                ApplyMethod(method, *args),\n",
        "                Animation(everything),\n",
        "                run_time = 1.5\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        #Multiply number by itself\n",
        "        ghost_arc = arc.copy().fade()\n",
        "        ghost_line = line.copy().fade()\n",
        "        ghots_dot = dot.copy().fade()\n",
        "        self.add(ghost_arc, ghost_line, ghots_dot)\n",
        "\n",
        "        self.play(\n",
        "            VGroup(\n",
        "                line, dot, distance_label,\n",
        "            ).rotate, line.get_angle(),\n",
        "            Transform(arc, double_arc),\n",
        "            Transform(theta, two_theta),\n",
        "        )\n",
        "        self.wait()\n",
        "        five = distance_label[2]\n",
        "        distance_label.remove(five)\n",
        "        for mob in five, line, dot:\n",
        "            mob.generate_target()\n",
        "        line.target.scale(np.sqrt(5))\n",
        "        five.target.shift(line.target.get_center()-line.get_center())\n",
        "        dot.target.move_to(line.target.get_end())\n",
        "        self.play(\n",
        "            FadeOut(distance_label),\n",
        "            *list(map(MoveToTarget, [five, line, dot])),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_all_plane_dots(self):\n",
        "        x_min, y_min = list(map(int, self.plane.point_to_coords(\n",
        "            FRAME_X_RADIUS*LEFT + FRAME_Y_RADIUS*DOWN\n",
        "        )))\n",
        "        x_max, y_max = list(map(int, self.plane.point_to_coords(\n",
        "            FRAME_X_RADIUS*RIGHT + FRAME_Y_RADIUS*UP\n",
        "        )))\n",
        "        result = VGroup(*[\n",
        "            Dot(\n",
        "                self.plane.coords_to_point(x, y),\n",
        "                radius = self.dot_radius,\n",
        "                color = self.dot_color,\n",
        "            )\n",
        "            for x in range(int(x_min), int(x_max)+1)\n",
        "            for y in range(int(y_min), int(y_max)+1)\n",
        "        ])\n",
        "        result.sort(lambda p : np.dot(p, UP+RIGHT))\n",
        "        return result\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT, buff = MED_SMALL_BUFF)\n",
        "        return morty\n",
        "\n",
        "class TimeToGetComplex(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Time to \\\\\\\\ get complex\")\n",
        "        self.play_student_changes(\"angry\", \"sassy\", \"pleading\")\n",
        "        self.wait(2)\n",
        "\n",
        "class OneMoreExample(Scene):\n",
        "    CONFIG = {\n",
        "        \"unit_size\" : 0.5,\n",
        "        \"plane_center\" : 3*LEFT + 3*DOWN,\n",
        "        \"dot_color\" : YELLOW,\n",
        "        \"x_label_range\" : list(range(-6, 25, 3)),\n",
        "        \"y_label_range\" : list(range(3, 13, 3)),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_point()\n",
        "        self.square_algebraically()\n",
        "        self.plot_result()\n",
        "        self.show_triangle()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = ComplexPlane(\n",
        "            unit_size = self.unit_size,\n",
        "            center_point = self.plane_center,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "        plane.axes.set_stroke(width = 4)\n",
        "        coordinate_labels = VGroup()\n",
        "        for x in self.x_label_range:\n",
        "            if x == 0:\n",
        "                continue\n",
        "            coord = OldTex(str(x))\n",
        "            coord.scale(0.75)\n",
        "            coord.next_to(plane.coords_to_point(x, 0), DOWN, SMALL_BUFF)\n",
        "            coord.add_background_rectangle()\n",
        "            coordinate_labels.add(coord)\n",
        "        for y in self.y_label_range:\n",
        "            if y == 0:\n",
        "                continue\n",
        "            coord = OldTex(\"%di\"%y)\n",
        "            coord.scale(0.75)\n",
        "            coord.next_to(plane.coords_to_point(0, y), LEFT, SMALL_BUFF)\n",
        "            coord.add_background_rectangle()\n",
        "            coordinate_labels.add(coord)\n",
        "        self.add(plane, coordinate_labels)\n",
        "\n",
        "        self.plane = plane\n",
        "        self.plane.coordinate_labels = coordinate_labels\n",
        "\n",
        "    def add_point(self):\n",
        "        point = self.plane.coords_to_point(3, 2)\n",
        "        dot = Dot(point, color = self.dot_color)\n",
        "        line = Line(self.plane.get_center_point(), point)\n",
        "        line.set_color(dot.get_color())\n",
        "        number_label = OldTex(\"3+2i\")\n",
        "        number_label.add_background_rectangle()\n",
        "        number_label.next_to(dot, RIGHT, SMALL_BUFF)\n",
        "        distance_labels = VGroup() \n",
        "        for tex in \"3^2 + 2^2\", \"13\":\n",
        "            pre_label = OldTex(\"\\\\sqrt{%s}\"%tex)\n",
        "            label = VGroup(\n",
        "                BackgroundRectangle(pre_label),\n",
        "                VGroup(*pre_label[:2]),\n",
        "                VGroup(*pre_label[2:]),\n",
        "            )\n",
        "            label.scale(0.75)\n",
        "            label.next_to(line.get_center(), UP, SMALL_BUFF)\n",
        "            label.rotate(\n",
        "                line.get_angle(),\n",
        "                about_point = line.get_center()\n",
        "            )\n",
        "            distance_labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(number_label), \n",
        "            ShowCreation(line),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.play(Write(distance_labels[0]))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(*distance_labels))\n",
        "        self.wait()\n",
        "\n",
        "        self.distance_label = distance_labels[1]\n",
        "        self.line = line\n",
        "        self.dot = dot\n",
        "        self.number_label = number_label\n",
        "\n",
        "    def square_algebraically(self):\n",
        "        #Crazy hacky.  To anyone looking at this, for God's\n",
        "        #sake, don't mimic this.\n",
        "        rect = Rectangle(\n",
        "            height = 3.5, width = 7,\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 2,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8\n",
        "        )\n",
        "        rect.to_corner(UP+RIGHT, buff = 0)\n",
        "        number = self.number_label[1].copy()\n",
        "\n",
        "        top_line = OldTex(\"(3+2i)\", \"(3+2i)\")\n",
        "        for part in top_line:\n",
        "            for i, color in zip([1, 3], [BLUE, YELLOW]):\n",
        "                part[i].set_color(color)\n",
        "        second_line = OldTex(\n",
        "            \"\\\\big( 3^2 + (2i)^2 \\\\big) + \" + \\\n",
        "            \"\\\\big(3 \\\\cdot 2 + 2 \\\\cdot 3 \\\\big)i\"\n",
        "        )\n",
        "        for i in 1, 12, 18:\n",
        "            second_line[i].set_color(BLUE)\n",
        "        for i in 5, 14, 16:\n",
        "            second_line[i].set_color(YELLOW)\n",
        "        second_line.scale(0.9)\n",
        "        final_line = OldTex(\"5 + 12i\")\n",
        "        for i in 0, 2, 3:\n",
        "            final_line[i].set_color(GREEN)\n",
        "        lines = VGroup(top_line, second_line, final_line)\n",
        "        lines.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        lines.next_to(rect.get_top(), DOWN)\n",
        "        minus = OldTex(\"-\").scale(0.9)\n",
        "        minus.move_to(second_line[3])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Transform(VGroup(number), top_line),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        index_alignment_lists = [\n",
        "            [(0, 0, 0), (0, 1, 1), (1, 1, 2), (1, 5, 9)],\n",
        "            [\n",
        "                (0, 2, 3), (1, 3, 4), (0, 3, 5), \n",
        "                (0, 4, 6), (1, 4, 7), (1, 3, 8)\n",
        "            ],\n",
        "            [\n",
        "                (0, 2, 10), (0, 0, 11), (0, 1, 12), \n",
        "                (1, 3, 13), (1, 3, 14), (1, 5, 19), \n",
        "                (0, 4, 20), (1, 4, 20),\n",
        "            ],\n",
        "            [\n",
        "                (0, 2, 15), (0, 3, 16), \n",
        "                (1, 1, 17), (1, 1, 18),\n",
        "            ],\n",
        "        ]\n",
        "        for index_alignment in index_alignment_lists[:2]:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    top_line[i][j].copy(), second_line[k],\n",
        "                    run_time = 1.5\n",
        "                )\n",
        "                for i, j, k in index_alignment\n",
        "            ])\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            Transform(second_line[3], minus),\n",
        "            FadeOut(VGroup(*[\n",
        "                second_line[i]\n",
        "                for i in (4, 6, 7)\n",
        "            ])),\n",
        "            second_line[5].shift, 0.35*RIGHT,\n",
        "        )\n",
        "        self.play(VGroup(*second_line[:4]).shift, 0.55*RIGHT)\n",
        "        self.wait()\n",
        "        for index_alignment in index_alignment_lists[2:]:\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    top_line[i][j].copy(), second_line[k],\n",
        "                    run_time = 1.5\n",
        "                )\n",
        "                for i, j, k in index_alignment\n",
        "            ])\n",
        "            self.wait()\n",
        "        self.play(FadeIn(final_line))\n",
        "        self.wait()\n",
        "\n",
        "        self.final_line = final_line\n",
        "\n",
        "    def plot_result(self):\n",
        "        result_label = self.final_line.copy()\n",
        "        result_label.add_background_rectangle()\n",
        "\n",
        "        point = self.plane.coords_to_point(5, 12)\n",
        "        dot = Dot(point, color = GREEN)\n",
        "        line = Line(self.plane.get_center_point(), point)\n",
        "        line.set_color(dot.get_color())\n",
        "        distance_label = OldTex(\"13\")\n",
        "        distance_label.add_background_rectangle()\n",
        "        distance_label.next_to(line.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            result_label.next_to, dot, UP+LEFT, SMALL_BUFF,\n",
        "            Animation(self.final_line),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(m1.copy(), m2)\n",
        "            for m1, m2 in [\n",
        "                (self.line, line), \n",
        "                (self.distance_label, distance_label)\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    def show_triangle(self):\n",
        "        triangle = Polygon(*[\n",
        "            self.plane.coords_to_point(x, y)\n",
        "            for x, y in [(0, 0), (5, 0), (5, 12)]\n",
        "        ])\n",
        "        triangle.set_stroke(WHITE, 1)\n",
        "        triangle.set_fill(BLUE, opacity = 0.75)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(triangle),\n",
        "            Animation(VGroup(\n",
        "                self.line, self.dot, \n",
        "                self.number_label[1], *self.distance_label[1:]\n",
        "            )),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ThisIsMagic(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"This is magic\", target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class GeneralExample(OneMoreExample):\n",
        "    CONFIG = {\n",
        "        \"number\" : complex(4, 1),\n",
        "        \"square_color\" : MAROON_B,\n",
        "        \"result_label_vect\" : UP+LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.square_point()\n",
        "\n",
        "    def square_point(self):\n",
        "        z = self.number\n",
        "        z_point = self.plane.number_to_point(z)\n",
        "        zero_point = self.plane.number_to_point(0)\n",
        "        dot = Dot(z_point, color = self.dot_color)\n",
        "        line = Line(zero_point, z_point)\n",
        "        line.set_color(dot.get_color())\n",
        "        label = OldTex(complex_string_with_i(z))\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        square_point = self.plane.number_to_point(z**2)\n",
        "        square_dot = Dot(square_point, color = self.square_color)\n",
        "        square_line = Line(zero_point, square_point)\n",
        "        square_line.set_color(square_dot.get_color())\n",
        "        square_label = OldTex(complex_string_with_i(z**2))\n",
        "        square_label.add_background_rectangle()\n",
        "        square_label.next_to(square_dot, UP+RIGHT, SMALL_BUFF)\n",
        "        result_length_label = OldTex(str(int(abs(z**2))))\n",
        "        result_length_label.next_to(\n",
        "            square_line.get_center(), self.result_label_vect\n",
        "        )\n",
        "        result_length_label.add_background_rectangle()\n",
        "\n",
        "        arrow = Arrow(\n",
        "            z_point, square_point, \n",
        "            # buff = SMALL_BUFF,\n",
        "            path_arc = np.pi/2\n",
        "        )\n",
        "        arrow.set_color(WHITE)\n",
        "        z_to_z_squared = OldTex(\"z\", \"\\\\to\", \"z^2\")\n",
        "        z_to_z_squared.set_color_by_tex(\"z\", dot.get_color())\n",
        "        z_to_z_squared.set_color_by_tex(\"z^2\", square_dot.get_color())\n",
        "        z_to_z_squared.next_to(\n",
        "            arrow.point_from_proportion(0.5), \n",
        "            RIGHT, MED_SMALL_BUFF\n",
        "        )\n",
        "        z_to_z_squared.add_to_back(\n",
        "            BackgroundRectangle(VGroup(\n",
        "                z_to_z_squared[2][0],\n",
        "                *z_to_z_squared[:-1]\n",
        "            )),\n",
        "            BackgroundRectangle(z_to_z_squared[2][1])\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Write(label), \n",
        "            ShowCreation(line),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(z_to_z_squared),\n",
        "            Animation(label),\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                start.copy(), target,\n",
        "                path_arc = np.pi/2,\n",
        "                run_time = 1.5\n",
        "            )\n",
        "            for start, target in [\n",
        "                (dot, square_dot),\n",
        "                (line, square_line),\n",
        "                (label, square_label),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Write(result_length_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.example_dot = dot\n",
        "        self.example_label = label\n",
        "        self.example_line = line\n",
        "        self.square_dot = square_dot\n",
        "        self.square_label = square_label\n",
        "        self.square_line = square_line\n",
        "        self.z_to_z_squared = z_to_z_squared\n",
        "        self.z_to_z_squared_arrow = arrow\n",
        "        self.result_length_label = result_length_label\n",
        "\n",
        "class BoringExample(GeneralExample):\n",
        "    CONFIG = {\n",
        "        \"number\" : complex(2, 2),\n",
        "        \"result_label_vect\" : RIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.square_point()\n",
        "        self.show_associated_triplet()\n",
        "\n",
        "    def show_associated_triplet(self):\n",
        "        arrow = Arrow(LEFT, RIGHT, color = GREEN)\n",
        "        arrow.next_to(self.square_label, RIGHT)\n",
        "        triple = OldTex(\"0^2 + 8^2 = 8^2\")\n",
        "        for part, color in zip(triple[::3], SIDE_COLORS):\n",
        "            part.set_color(color)\n",
        "        triple.add_background_rectangle()\n",
        "        triple.next_to(arrow, RIGHT)\n",
        "\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(self.plane.coords_to_point(12, 0), UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(morty)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(triple),\n",
        "            morty.change, \"raise_right_hand\", triple\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"tired\")\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class FiveTwoExample(GeneralExample):\n",
        "    CONFIG = {\n",
        "        \"number\" : complex(5, 2),\n",
        "        \"unit_size\" : 0.25,\n",
        "        \"x_label_range\" : list(range(-10, 40, 5)),\n",
        "        \"y_label_range\" : list(range(0, 30, 5)),\n",
        "    }\n",
        "\n",
        "class WriteGeneralFormula(GeneralExample):\n",
        "    CONFIG = {\n",
        "        \"plane_center\" : 2*RIGHT,\n",
        "        \"x_label_range\" : [],\n",
        "        \"y_label_range\" : [],\n",
        "        \"unit_size\" : 0.7,\n",
        "        \"number\" : complex(2, 1),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.show_squaring()\n",
        "        self.expand_square()\n",
        "        self.draw_triangle()\n",
        "        self.show_uv_to_triples()\n",
        "\n",
        "    def show_squaring(self):\n",
        "        self.force_skipping()\n",
        "        self.square_point()\n",
        "        dot = self.example_dot\n",
        "        old_label = self.example_label\n",
        "        line = self.example_line\n",
        "        square_dot = self.square_dot\n",
        "        old_square_label = self.square_label\n",
        "        square_line = self.square_line\n",
        "        z_to_z_squared = self.z_to_z_squared\n",
        "        arrow = self.z_to_z_squared_arrow\n",
        "        result_length_label = self.result_length_label\n",
        "        self.clear()\n",
        "        self.add(self.plane, self.plane.coordinate_labels)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        label = OldTex(\"u+vi\")\n",
        "        label.move_to(old_label, LEFT)\n",
        "        label.add_background_rectangle()\n",
        "        square_label = OldTex(\"(u+vi)^2\")\n",
        "        square_label.move_to(old_square_label, LEFT)\n",
        "        square_label.add_background_rectangle()\n",
        "\n",
        "        self.add(label, dot, line)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(z_to_z_squared)\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                start.copy(), target,\n",
        "                run_time = 1.5,\n",
        "                path_arc = np.pi/2\n",
        "            )\n",
        "            for start, target in [\n",
        "                (dot, square_dot),\n",
        "                (line, square_line),\n",
        "                (label, square_label),\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        self.example_label = label\n",
        "        self.square_label = square_label\n",
        "\n",
        "    def expand_square(self):\n",
        "        rect = Rectangle(\n",
        "            height = 2.5, width = 7,\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 0.8,\n",
        "        )\n",
        "        rect.to_corner(UP+LEFT, buff = 0)\n",
        "        top_line = OldTex(\"(u+vi)(u+vi)\")\n",
        "        for i in 1, 7:\n",
        "            top_line[i].set_color(U_COLOR)\n",
        "            top_line[i+2].set_color(V_COLOR)\n",
        "        top_line.next_to(rect.get_top(), DOWN)\n",
        "        second_line = OldTex(\n",
        "            \"\\\\big(\", \"u^2 - v^2\", \"\\\\big)\", \"+\",\n",
        "            \"\\\\big(\", \"2uv\", \"\\\\big)\", \"i\"\n",
        "        )\n",
        "        for i, j in (1, 0), (5, 1):\n",
        "            second_line[i][j].set_color(U_COLOR)\n",
        "        for i, j in (1, 3), (5, 2):\n",
        "            second_line[i][j].set_color(V_COLOR)\n",
        "        second_line.next_to(top_line, DOWN, MED_LARGE_BUFF)\n",
        "        real_part = second_line[1]\n",
        "        imag_part = second_line[5]\n",
        "        for part in real_part, imag_part:\n",
        "            part.add_to_back(BackgroundRectangle(part))\n",
        "\n",
        "        z = self.number**2\n",
        "        square_point = self.plane.number_to_point(z)\n",
        "        zero_point = self.plane.number_to_point(0)\n",
        "        real_part_point = self.plane.number_to_point(z.real)\n",
        "        real_part_line = Line(zero_point, real_part_point)\n",
        "        imag_part_line = Line(real_part_point, square_point)\n",
        "        for line in real_part_line, imag_part_line:\n",
        "            line.set_color(self.square_color)\n",
        "\n",
        "\n",
        "        self.play(*list(map(FadeIn, [rect, top_line, second_line])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            real_part.copy().next_to, real_part_line.copy(), \n",
        "                DOWN, SMALL_BUFF,\n",
        "            ShowCreation(real_part_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(\n",
        "                self.example_label, self.example_dot, self.example_line,\n",
        "                self.z_to_z_squared, self.z_to_z_squared_arrow\n",
        "            )),\n",
        "            imag_part.copy().next_to, imag_part_line.copy(), \n",
        "                RIGHT, SMALL_BUFF,\n",
        "            ShowCreation(imag_part_line)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.corner_rect = rect\n",
        "\n",
        "    def draw_triangle(self):\n",
        "        hyp_length = OldTex(\"u\", \"^2\", \"+\", \"v\", \"^2\")\n",
        "        hyp_length.set_color_by_tex(\"u\", U_COLOR)\n",
        "        hyp_length.set_color_by_tex(\"v\", V_COLOR)\n",
        "        hyp_length.add_background_rectangle()\n",
        "        line = self.square_line\n",
        "        hyp_length.next_to(line.get_center(), UP, SMALL_BUFF)\n",
        "        hyp_length.rotate(\n",
        "            line.get_angle(),\n",
        "            about_point = line.get_center()\n",
        "        )\n",
        "        triangle = Polygon(\n",
        "            ORIGIN, RIGHT, RIGHT+UP,\n",
        "            stroke_width = 0,\n",
        "            fill_color = MAROON_B,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        triangle.replace(line, stretch = True)\n",
        "\n",
        "        self.play(Write(hyp_length))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(triangle))\n",
        "        self.wait()\n",
        "\n",
        "    def show_uv_to_triples(self):\n",
        "        rect = self.corner_rect.copy()\n",
        "        rect.stretch_to_fit_height(FRAME_HEIGHT)\n",
        "        rect.move_to(self.corner_rect.get_bottom(), UP)\n",
        "\n",
        "        h_line = Line(rect.get_left(), rect.get_right())\n",
        "        h_line.next_to(rect.get_top(), DOWN, LARGE_BUFF)\n",
        "        v_line = Line(rect.get_top(), rect.get_bottom())\n",
        "        v_line.shift(1.3*LEFT)\n",
        "        uv_title = OldTex(\"(u, v)\")\n",
        "        triple_title = OldTex(\"(u^2 - v^2, 2uv, u^2 + v^2)\")\n",
        "        uv_title.scale(0.75)\n",
        "        triple_title.scale(0.75)\n",
        "        uv_title.next_to(\n",
        "            h_line.point_from_proportion(1./6), \n",
        "            UP, SMALL_BUFF\n",
        "        )\n",
        "        triple_title.next_to(\n",
        "            h_line.point_from_proportion(2./3),\n",
        "            UP, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        pairs = [(2, 1), (3, 2), (4, 1), (4, 3), (5, 2), (5, 4)]\n",
        "        pair_mobs = VGroup()\n",
        "        triple_mobs = VGroup()\n",
        "        for u, v in pairs:\n",
        "            a, b, c = u**2 - v**2, 2*u*v, u**2 + v**2\n",
        "            pair_mob = OldTex(\"(\", str(u), \",\", str(v), \")\")\n",
        "            pair_mob.set_color_by_tex(str(u), U_COLOR)\n",
        "            pair_mob.set_color_by_tex(str(v), V_COLOR)\n",
        "            triple_mob = OldTex(\"(%d, %d, %d)\"%(a, b, c))\n",
        "            pair_mobs.add(pair_mob)\n",
        "            triple_mobs.add(triple_mob)\n",
        "            pair_mob.scale(0.75)\n",
        "            triple_mob.scale(0.75)\n",
        "        pair_mobs.arrange(DOWN)\n",
        "        pair_mobs.next_to(uv_title, DOWN, MED_LARGE_BUFF)\n",
        "        triple_mobs.arrange(DOWN)\n",
        "        triple_mobs.next_to(triple_title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            rect, h_line, v_line, \n",
        "            uv_title, triple_title\n",
        "        ])))\n",
        "        self.play(*[\n",
        "            LaggedStartMap(\n",
        "                FadeIn, mob, \n",
        "                run_time = 5,\n",
        "                lag_ratio = 0.2\n",
        "            )\n",
        "            for mob in (pair_mobs, triple_mobs)\n",
        "        ])\n",
        "\n",
        "class VisualizeZSquared(Scene):\n",
        "    CONFIG = {\n",
        "        \"initial_unit_size\" : 0.4,\n",
        "        \"final_unit_size\" : 0.1,\n",
        "        \"plane_center\" : 3*LEFT + 2*DOWN,\n",
        "        \"x_label_range\" : list(range(-12, 24, 4)),\n",
        "        \"y_label_range\" : list(range(-4, 24, 4)),\n",
        "        \"dot_color\" : YELLOW,\n",
        "        \"square_color\" : MAROON_B,\n",
        "        \"big_dot_radius\" : 0.075,\n",
        "        \"dot_radius\" : 0.05,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_plane()\n",
        "        self.write_z_to_z_squared()\n",
        "        self.draw_arrows()\n",
        "        self.draw_dots()\n",
        "        self.add_colored_grid()\n",
        "        self.apply_transformation()\n",
        "        self.show_triangles()\n",
        "        self.zoom_out()\n",
        "        self.show_more_triangles()\n",
        "\n",
        "    def add_plane(self):\n",
        "        width = (FRAME_X_RADIUS+abs(self.plane_center[0]))/self.final_unit_size\n",
        "        height = (FRAME_Y_RADIUS+abs(self.plane_center[1]))/self.final_unit_size\n",
        "        background_plane = ComplexPlane(\n",
        "            x_radius = width,\n",
        "            y_radius = height,\n",
        "            stroke_width = 2,\n",
        "            stroke_color = BLUE_E,\n",
        "            secondary_line_ratio = 0,\n",
        "        )\n",
        "        background_plane.axes.set_stroke(width = 4)\n",
        "\n",
        "        background_plane.scale(self.initial_unit_size)\n",
        "        background_plane.shift(self.plane_center)\n",
        "\n",
        "        coordinate_labels = VGroup()\n",
        "        z_list = np.append(\n",
        "            self.x_label_range,\n",
        "            complex(0, 1)*np.array(self.y_label_range)\n",
        "        )\n",
        "        for z in z_list:\n",
        "            if z == 0:\n",
        "                continue\n",
        "            if z.imag == 0:\n",
        "                tex = str(int(z.real))\n",
        "            else:\n",
        "                tex = str(int(z.imag)) + \"i\"\n",
        "            label = OldTex(tex)\n",
        "            label.scale(0.75)\n",
        "            label.add_background_rectangle()\n",
        "            point = background_plane.number_to_point(z)\n",
        "            if z.imag == 0:\n",
        "                label.next_to(point, DOWN, SMALL_BUFF)\n",
        "            else:\n",
        "                label.next_to(point, LEFT, SMALL_BUFF)\n",
        "            coordinate_labels.add(label)\n",
        "\n",
        "        self.add(background_plane, coordinate_labels)\n",
        "        self.background_plane = background_plane\n",
        "        self.coordinate_labels = coordinate_labels\n",
        "\n",
        "    def write_z_to_z_squared(self):\n",
        "        z_to_z_squared = OldTex(\"z\", \"\\\\to\", \"z^2\")\n",
        "        z_to_z_squared.set_color_by_tex(\"z\", YELLOW)\n",
        "        z_to_z_squared.set_color_by_tex(\"z^2\", MAROON_B)\n",
        "        z_to_z_squared.add_background_rectangle()\n",
        "        z_to_z_squared.to_edge(UP)\n",
        "        z_to_z_squared.shift(2*RIGHT)\n",
        "\n",
        "        self.play(Write(z_to_z_squared))\n",
        "        self.wait()\n",
        "        self.z_to_z_squared = z_to_z_squared\n",
        "\n",
        "    def draw_arrows(self):\n",
        "        z_list = [\n",
        "            complex(2, 1),\n",
        "            complex(3, 2),\n",
        "            complex(0, 1),\n",
        "            complex(-1, 0),\n",
        "        ]\n",
        "\n",
        "        arrows = VGroup()\n",
        "        dots = VGroup()\n",
        "        for z in z_list:\n",
        "            z_point, square_point, mid_point = [\n",
        "                self.background_plane.number_to_point(z**p)\n",
        "                for p in (1, 2, 1.5)\n",
        "            ]\n",
        "            angle = Line(mid_point, square_point).get_angle()\n",
        "            angle -= Line(z_point, mid_point).get_angle()\n",
        "            angle *= 2\n",
        "            arrow = Arrow(\n",
        "                z_point, square_point, \n",
        "                path_arc = angle,\n",
        "                color = WHITE,\n",
        "                tip_length = 0.15,\n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "\n",
        "            z_dot, square_dot = [\n",
        "                Dot(\n",
        "                    point, color = color,\n",
        "                    radius = self.big_dot_radius,\n",
        "                )\n",
        "                for point, color in [\n",
        "                    (z_point, self.dot_color),\n",
        "                    (square_point, self.square_color),\n",
        "                ]\n",
        "            ]\n",
        "            z_label = OldTex(complex_string_with_i(z))\n",
        "            square_label = OldTex(complex_string_with_i(z**2))\n",
        "            for label, point in (z_label, z_point), (square_label, square_point):\n",
        "                if abs(z) > 2:\n",
        "                    vect = RIGHT\n",
        "                else:\n",
        "                    vect = point - self.plane_center\n",
        "                    vect /= get_norm(vect)\n",
        "                    if abs(vect[1]) < 0.1:\n",
        "                        vect[1] = -1\n",
        "                label.next_to(point, vect)\n",
        "                label.add_background_rectangle()\n",
        "\n",
        "            self.play(*list(map(FadeIn, [z_label, z_dot])))\n",
        "            self.wait()\n",
        "            self.play(ShowCreation(arrow))\n",
        "            self.play(ReplacementTransform(\n",
        "                z_dot.copy(), square_dot,\n",
        "                path_arc = angle\n",
        "            ))\n",
        "            self.play(FadeIn(square_label))\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(z_label),\n",
        "                FadeOut(square_label),\n",
        "                Animation(arrow)\n",
        "            )\n",
        "\n",
        "            arrows.add(arrow)\n",
        "            dots.add(z_dot, square_dot)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            dots, arrows, self.z_to_z_squared\n",
        "        ])))\n",
        "\n",
        "    def draw_dots(self):\n",
        "        min_corner, max_corner = [\n",
        "            self.background_plane.point_to_coords(\n",
        "                u*FRAME_X_RADIUS*RIGHT + u*FRAME_Y_RADIUS*UP\n",
        "            )\n",
        "            for u in (-1, 1)\n",
        "        ]\n",
        "        x_min, y_min = list(map(int, min_corner[:2]))\n",
        "        x_max, y_max = list(map(int, max_corner[:2]))\n",
        "\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                self.background_plane.coords_to_point(x, y),\n",
        "                color = self.dot_color,\n",
        "                radius = self.dot_radius,\n",
        "            )\n",
        "            for x in range(x_min, x_max+1)\n",
        "            for y in range(y_min, y_max+1)\n",
        "        ])\n",
        "        dots.sort(lambda p : np.dot(p, UP+RIGHT))\n",
        "\n",
        "        self.add_foreground_mobject(self.coordinate_labels)\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, dots,\n",
        "            stroke_width = 3,\n",
        "            stroke_color = PINK,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.dots = dots\n",
        "\n",
        "    def add_colored_grid(self):\n",
        "        color_grid = self.get_color_grid()\n",
        "\n",
        "        self.play(\n",
        "            self.background_planes.set_stroke, None, 1,\n",
        "            LaggedStartMap(\n",
        "                FadeIn, color_grid, \n",
        "                run_time = 2\n",
        "            ),\n",
        "            Animation(self.dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.color_grid = color_grid\n",
        "\n",
        "    def apply_transformation(self):\n",
        "        for dot in self.dots:\n",
        "            dot.start_point = dot.get_center()\n",
        "        def update_dot(dot, alpha):\n",
        "            event = list(dot.start_point) + [alpha]\n",
        "            dot.move_to(self.homotopy(*event))\n",
        "            return dot\n",
        "        self.play(\n",
        "            Homotopy(self.homotopy, self.color_grid),\n",
        "            *[\n",
        "                UpdateFromAlphaFunc(dot, update_dot)\n",
        "                for dot in self.dots\n",
        "            ],\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(self.color_grid.set_stroke, None, 3)\n",
        "        self.wait()\n",
        "        scale_factor = self.big_dot_radius/self.dot_radius\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, self.dots,\n",
        "            lambda d : (d.scale, scale_factor),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_triangles(self):\n",
        "        z_list = [\n",
        "            complex(u, v)**2\n",
        "            for u, v in [(2, 1), (3, 2), (4, 1)]\n",
        "        ]\n",
        "        triangles = self.get_triangles(z_list)\n",
        "        triangle = triangles[0]\n",
        "        triangle.save_state()\n",
        "        triangle.scale(0.01, about_point = triangle.tip)\n",
        "\n",
        "        self.play(triangle.restore, run_time = 2)\n",
        "        self.wait(2)\n",
        "        for new_triangle in triangles[1:]:\n",
        "            self.play(Transform(triangle, new_triangle))\n",
        "            self.wait(2)\n",
        "        self.play(FadeOut(triangle))\n",
        "\n",
        "    def zoom_out(self):\n",
        "        self.remove_foreground_mobject(self.coordinate_labels)\n",
        "        movers = [\n",
        "            self.background_plane,\n",
        "            self.color_grid,\n",
        "            self.dots,\n",
        "            self.coordinate_labels,\n",
        "        ]\n",
        "        scale_factor = self.final_unit_size/self.initial_unit_size\n",
        "        for mover in movers:\n",
        "            mover.generate_target()\n",
        "            mover.target.scale(\n",
        "                scale_factor,\n",
        "                about_point = self.plane_center\n",
        "            )\n",
        "        for dot in self.dots.target:\n",
        "            dot.scale(1./scale_factor)\n",
        "        self.background_plane.target.fade()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(\n",
        "            *list(map(MoveToTarget, movers)),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_more_triangles(self):\n",
        "        z_list = [\n",
        "            complex(u, v)**2\n",
        "            for u in range(4, 7)\n",
        "            for v in range(1, u)\n",
        "        ]\n",
        "        triangles = self.get_triangles(z_list)\n",
        "        triangle = triangles[0]\n",
        "\n",
        "        self.play(FadeOut(triangle))\n",
        "        self.wait(2)\n",
        "        for new_triangle in triangles[1:]:\n",
        "            self.play(Transform(triangle, new_triangle))\n",
        "            self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_color_grid(self):\n",
        "        width = (FRAME_X_RADIUS+abs(self.plane_center[0]))/self.initial_unit_size\n",
        "        height = (FRAME_Y_RADIUS+abs(self.plane_center[1]))/self.initial_unit_size\n",
        "        color_grid = ComplexPlane(\n",
        "            x_radius = width,\n",
        "            y_radius = int(height),\n",
        "            secondary_line_ratio = 0,\n",
        "            stroke_width = 2,\n",
        "        )\n",
        "        color_grids.set_color_by_gradient(\n",
        "            *[GREEN, RED, MAROON_B, TEAL]*2\n",
        "        )\n",
        "        color_grid.remove(color_grid.axes[0])\n",
        "        for line in color_grid.family_members_with_points():\n",
        "            center = line.get_center()\n",
        "            if center[0] <= 0 and abs(center[1]) < 0.01:\n",
        "                line_copy = line.copy()\n",
        "                line.scale(0.499, about_point = line.get_start())\n",
        "                line_copy.scale(0.499, about_point = line_copy.get_end())\n",
        "                color_grid.add(line_copy)\n",
        "        color_grid.scale(self.initial_unit_size)\n",
        "        color_grid.shift(self.plane_center)\n",
        "        color_grid.prepare_for_nonlinear_transform()\n",
        "        return color_grid\n",
        "\n",
        "    def get_triangles(self, z_list):\n",
        "        triangles = VGroup()\n",
        "        for z in z_list:\n",
        "            point = self.background_plane.number_to_point(z)\n",
        "            line = Line(self.plane_center, point)\n",
        "            triangle = Polygon(\n",
        "                ORIGIN, RIGHT, RIGHT+UP,\n",
        "                stroke_color = BLUE,\n",
        "                stroke_width = 2,\n",
        "                fill_color = BLUE,\n",
        "                fill_opacity = 0.5,\n",
        "            )\n",
        "            triangle.replace(line, stretch = True)\n",
        "            a = int(z.real)\n",
        "            b = int(z.imag)\n",
        "            c = int(abs(z))\n",
        "            a_label, b_label, c_label = labels = [\n",
        "                OldTex(str(num))\n",
        "                for num in (a, b, c)\n",
        "            ]\n",
        "            for label in b_label, c_label:\n",
        "                label.add_background_rectangle()\n",
        "            a_label.next_to(triangle.get_bottom(), UP, SMALL_BUFF)\n",
        "            b_label.next_to(triangle, RIGHT, SMALL_BUFF)\n",
        "            c_label.next_to(line.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "            triangle.add(*labels)\n",
        "            triangle.tip = point\n",
        "            triangles.add(triangle)\n",
        "        return triangles\n",
        "\n",
        "    def homotopy(self, x, y, z, t):\n",
        "        z_complex = self.background_plane.point_to_number(np.array([x, y, z]))\n",
        "        result = z_complex**(1+t)\n",
        "        return self.background_plane.number_to_point(result)\n",
        "\n",
        "class AskAboutHittingAllPoints(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Does this hit \\\\\\\\ all pythagorean triples?\",\n",
        "            target_mode = \"raise_left_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\"No\", target_mode = \"sad\")\n",
        "        self.play_student_changes(*[\"hesitant\"]*3)\n",
        "        self.wait()\n",
        "\n",
        "class PointsWeMiss(VisualizeZSquared):\n",
        "    CONFIG = {\n",
        "        \"final_unit_size\" : 0.4,\n",
        "        \"plane_center\" : 2*LEFT + 2*DOWN,\n",
        "        \"dot_x_range\" : list(range(-5, 6)),\n",
        "        \"dot_y_range\" : list(range(-4, 4)),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_transformed_color_grid()\n",
        "        self.add_dots()\n",
        "        self.show_missing_point()\n",
        "        self.show_second_missing_point()\n",
        "        self.mention_one_half_rule()\n",
        "\n",
        "    def add_transformed_color_grid(self):\n",
        "        color_grid = self.get_color_grid()\n",
        "        func = lambda p : self.homotopy(p[0], p[1], p[1], 1)\n",
        "        color_grid.apply_function(func)\n",
        "        color_grid.set_stroke(width = 4)\n",
        "        self.add(color_grid, self.coordinate_labels)\n",
        "        self.color_grid = color_grid\n",
        "\n",
        "    def add_dots(self):\n",
        "        z_list = [\n",
        "            complex(x, y)**2\n",
        "            for x in self.dot_x_range\n",
        "            for y in self.dot_y_range\n",
        "        ]\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                self.background_plane.number_to_point(z),\n",
        "                color = self.dot_color,\n",
        "                radius = self.big_dot_radius,\n",
        "            )\n",
        "            for z in z_list\n",
        "        ])\n",
        "        dots.sort(get_norm)\n",
        "        self.add(dots)\n",
        "        self.dots = dots\n",
        "\n",
        "    def show_missing_point(self):\n",
        "        z_list = [complex(6, 8), complex(9, 12), complex(3, 4)]\n",
        "        points = list(map(\n",
        "            self.background_plane.number_to_point,\n",
        "            z_list \n",
        "        ))\n",
        "        dots = VGroup(*list(map(Dot, points)))\n",
        "        for dot in dots[:2]:\n",
        "            dot.set_stroke(RED, 4)\n",
        "            dot.set_fill(opacity = 0)\n",
        "        labels = VGroup(*[\n",
        "            OldTex(complex_string_with_i(z))\n",
        "            for z in z_list\n",
        "        ])\n",
        "        labels.set_color(RED)\n",
        "        labels[2].set_color(GREEN)\n",
        "        rhss = VGroup()\n",
        "        for label, dot in zip(labels, dots):\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(dot, UP+RIGHT, SMALL_BUFF)\n",
        "            if label is labels[-1]:\n",
        "                rhs = OldTex(\"= (2+i)^2\")\n",
        "            else:\n",
        "                rhs = OldTex(\"\\\\ne (u+vi)^2\")\n",
        "            rhs.add_background_rectangle()\n",
        "            rhs.next_to(label, RIGHT)\n",
        "            rhss.add(rhs)\n",
        "        triangles = self.get_triangles(z_list)\n",
        "\n",
        "        self.play(FocusOn(dots[0]))\n",
        "        self.play(ShowCreation(dots[0]))\n",
        "        self.play(Write(labels[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(triangles[0]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(rhss[0]))\n",
        "        self.wait(2)\n",
        "        groups = triangles, dots, labels, rhss\n",
        "        for i in 1, 2:\n",
        "            self.play(*[\n",
        "                Transform(group[0], group[i])\n",
        "                for group in groups\n",
        "            ])\n",
        "            self.wait(3)\n",
        "        self.play(*[\n",
        "            FadeOut(group[0])\n",
        "            for group in groups\n",
        "        ])\n",
        "\n",
        "    def show_second_missing_point(self):\n",
        "        z_list = [complex(4, 3), complex(8, 6)]\n",
        "        points = list(map(\n",
        "            self.background_plane.number_to_point,\n",
        "            z_list \n",
        "        ))\n",
        "        dots = VGroup(*list(map(Dot, points)))\n",
        "        dots[0].set_stroke(RED, 4)\n",
        "        dots[0].set_fill(opacity = 0)\n",
        "        labels = VGroup(*[\n",
        "            OldTex(complex_string_with_i(z))\n",
        "            for z in z_list\n",
        "        ])\n",
        "        labels[0].set_color(RED)\n",
        "        labels[1].set_color(GREEN)\n",
        "        rhss = VGroup()\n",
        "        for label, dot in zip(labels, dots):\n",
        "            label.add_background_rectangle()\n",
        "            label.next_to(dot, UP+RIGHT, SMALL_BUFF)\n",
        "            if label is labels[-1]:\n",
        "                rhs = OldTex(\"= (3+i)^2\")\n",
        "            else:\n",
        "                rhs = OldTex(\"\\\\ne (u+vi)^2\")\n",
        "            rhs.add_background_rectangle()\n",
        "            rhs.next_to(label, RIGHT)\n",
        "            rhss.add(rhs)\n",
        "        triangles = self.get_triangles(z_list)\n",
        "        groups = [dots, labels, rhss, triangles]\n",
        "        for group in groups:\n",
        "            group[0].save_state()\n",
        "\n",
        "        self.play(ShowCreation(dots[0]))\n",
        "        self.play(Write(VGroup(labels[0], rhss[0])))\n",
        "        self.play(FadeIn(triangles[0]))\n",
        "        self.wait(3)\n",
        "        self.play(*[Transform(*group) for group in groups])\n",
        "        self.wait(3)\n",
        "        self.play(*[group[0].restore for group in groups])\n",
        "        self.wait(2)\n",
        "\n",
        "    def mention_one_half_rule(self):\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \n",
        "            \"Never need to scale \\\\\\\\ by less than $\\\\frac{1}{2}$\"\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class PointsWeMissAreMultiplesOfOnesWeHit(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Every point we\",\n",
        "            \"miss\",\n",
        "            \"is \\\\\\\\ a multiple of one we\",\n",
        "            \"hit\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"miss\", RED)\n",
        "        words.set_color_by_tex(\"hit\", GREEN)\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class DrawSingleRadialLine(PointsWeMiss):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.background_plane.set_stroke(width = 1)\n",
        "        self.add_transformed_color_grid()\n",
        "        self.color_grid.set_stroke(width = 1)\n",
        "        self.add_dots()\n",
        "        self.draw_line()\n",
        "\n",
        "    def draw_line(self):\n",
        "        point = self.background_plane.coords_to_point(3, 4)\n",
        "        dot = Dot(point, color = RED)\n",
        "        line = Line(\n",
        "            self.plane_center,\n",
        "            self.background_plane.coords_to_point(15, 20),\n",
        "            color = WHITE,\n",
        "        )\n",
        "        added_dots = VGroup(*[\n",
        "            Dot(self.background_plane.coords_to_point(3*k, 4*k))\n",
        "            for k in (2, 3, 5)\n",
        "        ])\n",
        "        added_dots.set_color(GREEN)\n",
        "\n",
        "        self.play(GrowFromCenter(dot))\n",
        "        self.play(Indicate(dot))\n",
        "        self.play(ShowCreation(line), Animation(dot))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, added_dots,\n",
        "            stroke_color = PINK,\n",
        "            stroke_width = 4,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class DrawRadialLines(PointsWeMiss):\n",
        "    CONFIG = {\n",
        "        \"final_unit_size\" : 0.2,\n",
        "        \"dot_x_range\" : list(range(-4, 10)),\n",
        "        \"dot_y_range\" : list(range(-4, 10)),\n",
        "        \"x_label_range\" : list(range(-12, 40, 4)),\n",
        "        \"y_label_range\" : list(range(-4, 32, 4)),\n",
        "        \"big_dot_radius\" : 0.05,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_transformed_color_grid()\n",
        "        self.resize_plane()\n",
        "        self.add_dots()\n",
        "        self.create_lines()\n",
        "        self.show_single_line()\n",
        "        self.show_all_lines()\n",
        "        self.show_triangles()\n",
        "\n",
        "    def resize_plane(self):\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        everything.scale(\n",
        "            self.final_unit_size/self.initial_unit_size,\n",
        "            about_point = self.plane_center\n",
        "        )\n",
        "        self.background_plane.set_stroke(width = 1)\n",
        "\n",
        "    def create_lines(self):\n",
        "        coord_strings = set([])\n",
        "        reduced_coords_yet_to_be_reached = set([])\n",
        "        for dot in self.dots:\n",
        "            point = dot.get_center()\n",
        "            float_coords = self.background_plane.point_to_coords(point)\n",
        "            coords = np.round(float_coords).astype('int')\n",
        "            gcd = fractions.gcd(*coords)\n",
        "            reduced_coords = coords/abs(gcd)\n",
        "\n",
        "            if np.all(coords == [3, 4]):\n",
        "                first_dot = dot\n",
        "\n",
        "            dot.coords = coords\n",
        "            dot.reduced_coords = reduced_coords\n",
        "            coord_strings.add(str(coords))\n",
        "            reduced_coords_yet_to_be_reached.add(str(reduced_coords))\n",
        "        lines = VGroup()\n",
        "        for dot in [first_dot] + list(self.dots):\n",
        "            rc_str = str(dot.reduced_coords)\n",
        "            if rc_str not in reduced_coords_yet_to_be_reached:\n",
        "                continue\n",
        "            reduced_coords_yet_to_be_reached.remove(rc_str)\n",
        "            new_dots = VGroup()\n",
        "            for k in range(50):\n",
        "                new_coords = k*dot.reduced_coords\n",
        "                if str(new_coords) in coord_strings:\n",
        "                    continue\n",
        "                coord_strings.add(str(new_coords))\n",
        "                point = self.background_plane.coords_to_point(*new_coords)\n",
        "                if abs(point[0]) > FRAME_X_RADIUS or abs(point[1]) > FRAME_Y_RADIUS:\n",
        "                    continue\n",
        "                new_dot = Dot(\n",
        "                    point, color = GREEN,\n",
        "                    radius = self.big_dot_radius\n",
        "                )\n",
        "                new_dots.add(new_dot)\n",
        "            line = Line(self.plane_center, dot.get_center())\n",
        "            line.scale(\n",
        "                FRAME_WIDTH/line.get_length(),\n",
        "                about_point = self.plane_center\n",
        "            )\n",
        "            line.set_stroke(width = 1)\n",
        "            line.seed_dot = dot.copy()\n",
        "            line.new_dots = new_dots\n",
        "            lines.add(line)\n",
        "        self.lines = lines\n",
        "\n",
        "    def show_single_line(self):\n",
        "        line = self.lines[0]\n",
        "        dot = line.seed_dot\n",
        "\n",
        "        self.play(\n",
        "            dot.scale, 2,\n",
        "            dot.set_color, RED\n",
        "        )\n",
        "        self.play(ReplacementTransform(dot, line))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, line.new_dots,\n",
        "            stroke_width = 4,\n",
        "            stroke_color = PINK,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_all_lines(self):\n",
        "        seed_dots = VGroup(*[line.seed_dot for line in self.lines])\n",
        "        new_dots = VGroup(*[line.new_dots for line in self.lines])\n",
        "        for dot in seed_dots:\n",
        "            dot.generate_target()\n",
        "            dot.target.scale(1.5)\n",
        "            dot.target.set_color(RED)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, seed_dots,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            seed_dots, self.lines,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, new_dots,\n",
        "            stroke_width = 4,\n",
        "            stroke_color = PINK,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.new_dots = new_dots\n",
        "\n",
        "    def show_triangles(self):\n",
        "        z_list = [\n",
        "            complex(9, 12),\n",
        "            complex(7, 24),\n",
        "            complex(8, 15),\n",
        "            complex(21, 20),\n",
        "            complex(36, 15),\n",
        "        ]\n",
        "        triangles = self.get_triangles(z_list)\n",
        "        triangle = triangles[0]\n",
        "\n",
        "        self.play(FadeIn(triangle))\n",
        "        self.wait(2)\n",
        "        for new_triangle in triangles[1:]:\n",
        "            self.play(Transform(triangle, new_triangle))\n",
        "            self.wait(2)\n",
        "\n",
        "class RationalPointsOnUnitCircle(DrawRadialLines):\n",
        "    CONFIG = {\n",
        "        \"initial_unit_size\" : 1.2,\n",
        "        \"final_unit_size\" : 0.4,\n",
        "        \"plane_center\" : 1.5*DOWN\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.show_rational_points_on_unit_circle()\n",
        "        self.divide_by_c_squared()\n",
        "        self.from_rational_point_to_triple()\n",
        "\n",
        "    def add_plane(self):\n",
        "        added_x_coords = list(range(-4, 6, 2))\n",
        "        added_y_coords = list(range(-2, 4, 2))\n",
        "        self.x_label_range += added_x_coords\n",
        "        self.y_label_range += added_y_coords\n",
        "        DrawRadialLines.add_plane(self)\n",
        "\n",
        "    def show_rational_points_on_unit_circle(self):\n",
        "        circle = self.get_unit_circle()\n",
        "\n",
        "        coord_list = [\n",
        "            (12, 5),\n",
        "            (8, 15),\n",
        "            (7, 24),\n",
        "            (3, 4),\n",
        "        ]\n",
        "        groups = VGroup()\n",
        "        for x, y in coord_list:\n",
        "            norm = np.sqrt(x**2 + y**2)\n",
        "            point = self.background_plane.coords_to_point(\n",
        "                x/norm, y/norm\n",
        "            )\n",
        "            dot = Dot(point, color = YELLOW)\n",
        "            line = Line(self.plane_center, point)\n",
        "            line.set_color(dot.get_color())\n",
        "            label = OldTex(\n",
        "                \"{\"+str(x), \"\\\\over\", str(int(norm))+\"}\",\n",
        "                \"+\", \n",
        "                \"{\"+str(y), \"\\\\over\", str(int(norm))+\"}\",\n",
        "                \"i\"\n",
        "            )\n",
        "            label.next_to(dot, UP+RIGHT, buff = 0)\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "            group = VGroup(line, dot, label)\n",
        "            group.coords = (x, y)\n",
        "            groups.add(group)\n",
        "        group = groups[0].copy()\n",
        "\n",
        "        self.add(circle, self.coordinate_labels)\n",
        "        self.play(FadeIn(group))\n",
        "        self.wait()\n",
        "        for new_group in groups[1:]:\n",
        "            self.play(Transform(group, new_group))\n",
        "            self.wait()\n",
        "\n",
        "        self.curr_example_point_group = group\n",
        "        self.next_rational_point_example = groups[0]\n",
        "        self.unit_circle = circle\n",
        "\n",
        "    def divide_by_c_squared(self):\n",
        "        top_line = OldTex(\n",
        "            \"a\", \"^2\", \"+\", \"b\", \"^2\", \"=\", \"c\", \"^2 \\\\phantom{1}\"\n",
        "        )\n",
        "        top_line.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        top_line.to_corner(UP + LEFT)\n",
        "        top_line.shift(RIGHT)\n",
        "        top_rect = BackgroundRectangle(top_line)\n",
        "\n",
        "        second_line = OldTex(\n",
        "            \"\\\\left(\", \"{a\", \"\\\\over\", \"c}\", \"\\\\right)\", \"^2\",\n",
        "            \"+\",\n",
        "            \"\\\\left(\", \"{b\", \"\\\\over\", \"c}\", \"\\\\right)\", \"^2\",\n",
        "            \"=\", \"1\"\n",
        "        )\n",
        "        second_line.move_to(top_line, UP)\n",
        "        second_line.shift_onto_screen()\n",
        "        second_rect = BackgroundRectangle(second_line)\n",
        "\n",
        "        circle_label = OldTexText(\n",
        "            \"All $x+yi$ where \\\\\\\\\",\n",
        "            \"$x^2 + y^2 = 1$\"\n",
        "        )\n",
        "        circle_label.next_to(second_line, DOWN, MED_LARGE_BUFF)\n",
        "        circle_label.shift_onto_screen()\n",
        "        circle_label.set_color_by_tex(\"x^2\", GREEN)\n",
        "        circle_label.add_background_rectangle()\n",
        "        circle_arrow = Arrow(\n",
        "            circle_label.get_bottom(),\n",
        "            self.unit_circle.point_from_proportion(0.45),\n",
        "            color = GREEN\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(top_rect), FadeIn(top_line))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(top_rect, second_rect)\n",
        "        ] + [\n",
        "            ReplacementTransform(\n",
        "                top_line.get_parts_by_tex(tex, substring = False),\n",
        "                second_line.get_parts_by_tex(tex),\n",
        "                run_time = 2,\n",
        "                path_arc = -np.pi/3\n",
        "            )\n",
        "            for tex  in (\"a\", \"b\", \"c\", \"^2\", \"+\", \"=\")\n",
        "        ] + [\n",
        "            ReplacementTransform(\n",
        "                top_line.get_parts_by_tex(\"1\"),\n",
        "                second_line.get_parts_by_tex(\"1\"),\n",
        "                run_time = 2\n",
        "            )\n",
        "        ] + [\n",
        "            Write(\n",
        "                second_line.get_parts_by_tex(tex),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.5)\n",
        "            )\n",
        "            for tex in (\"(\", \")\", \"over\",)\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.play(Write(circle_label))\n",
        "        self.play(ShowCreation(circle_arrow))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(circle_arrow))\n",
        "\n",
        "        self.algebra = VGroup(\n",
        "            second_rect, second_line, circle_label,\n",
        "        )\n",
        "\n",
        "    def from_rational_point_to_triple(self):\n",
        "        rational_point_group = self.next_rational_point_example\n",
        "        scale_factor = self.final_unit_size/self.initial_unit_size\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.curr_example_point_group,\n",
        "            rational_point_group\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                mob.scale_about_point, \n",
        "                scale_factor,\n",
        "                self.plane_center\n",
        "            )\n",
        "            for mob in [\n",
        "                self.background_plane,\n",
        "                self.coordinate_labels,\n",
        "                self.unit_circle,\n",
        "                rational_point_group,\n",
        "            ]\n",
        "        ] + [\n",
        "            Animation(self.algebra),\n",
        "        ])\n",
        "\n",
        "        #mimic_group\n",
        "        point = self.background_plane.coords_to_point(\n",
        "            *rational_point_group.coords\n",
        "        )\n",
        "        dot = Dot(point, color = YELLOW)\n",
        "        line = Line(self.plane_center, point)\n",
        "        line.set_color(dot.get_color())\n",
        "        x, y = rational_point_group.coords\n",
        "        label = OldTex(str(x), \"+\", str(y), \"i\")\n",
        "        label.next_to(dot, UP+RIGHT, buff = 0)\n",
        "        label.add_background_rectangle()\n",
        "        integer_point_group = VGroup(line, dot, label)\n",
        "        distance_label = OldTex(\n",
        "            str(int(np.sqrt(x**2 + y**2)))\n",
        "        )\n",
        "        distance_label.add_background_rectangle()\n",
        "        distance_label.next_to(line.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            rational_point_group, \n",
        "            integer_point_group\n",
        "        ))\n",
        "        self.play(Write(distance_label))\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_unit_circle(self):\n",
        "        template_line = Line(*[\n",
        "            self.background_plane.number_to_point(z)\n",
        "            for z in (-1, 1)\n",
        "        ])\n",
        "        circle = Circle(color = GREEN)\n",
        "        circle.replace(template_line, dim_to_match = 0)\n",
        "        return circle\n",
        "\n",
        "class ProjectPointsOntoUnitCircle(DrawRadialLines):\n",
        "    def construct(self):\n",
        "        ###\n",
        "        self.force_skipping()\n",
        "        self.add_plane()\n",
        "        self.add_transformed_color_grid()\n",
        "        self.resize_plane()\n",
        "        self.add_dots()\n",
        "        self.create_lines()\n",
        "        self.show_all_lines()\n",
        "        self.revert_to_original_skipping_status()\n",
        "        ###\n",
        "\n",
        "        self.add_unit_circle()\n",
        "        self.project_all_dots()\n",
        "        self.zoom_in()\n",
        "        self.draw_infinitely_many_lines()\n",
        "\n",
        "\n",
        "    def add_unit_circle(self):\n",
        "        template_line = Line(*[\n",
        "            self.background_plane.number_to_point(n)\n",
        "            for n in (-1, 1)\n",
        "        ])\n",
        "        circle = Circle(color = BLUE)\n",
        "        circle.replace(template_line, dim_to_match = 0)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.unit_circle = circle\n",
        "\n",
        "    def project_all_dots(self):\n",
        "        dots = self.dots\n",
        "        dots.add(*self.new_dots)\n",
        "        dots.sort(\n",
        "            lambda p : get_norm(p - self.plane_center)\n",
        "        )\n",
        "        unit_length = self.unit_circle.get_width()/2.0\n",
        "        for dot in dots:\n",
        "            dot.generate_target()\n",
        "            point = dot.get_center()\n",
        "            vect = point-self.plane_center\n",
        "            if np.round(vect[0], 3) == 0 and abs(vect[1]) > 2*unit_length:\n",
        "                dot.target.set_fill(opacity = 0)\n",
        "                continue\n",
        "            distance = get_norm(vect)\n",
        "            dot.target.scale(\n",
        "                unit_length/distance,\n",
        "                about_point = self.plane_center\n",
        "            )\n",
        "            dot.target.set_width(0.01)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, dots,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.2\n",
        "        ))\n",
        "\n",
        "    def zoom_in(self):\n",
        "        target_height = 5.0\n",
        "        scale_factor = target_height / self.unit_circle.get_height()\n",
        "        group = VGroup(\n",
        "            self.background_plane, self.coordinate_labels,\n",
        "            self.color_grid,\n",
        "            self.lines, self.unit_circle,\n",
        "            self.dots,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            group.shift, -self.plane_center,\n",
        "            group.scale, scale_factor,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def draw_infinitely_many_lines(self):\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, FRAME_WIDTH*vect)\n",
        "            for vect in compass_directions(1000)\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, lines,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.play(FadeOut(lines))\n",
        "        self.wait()\n",
        "\n",
        "class ICanOnlyDrawFinitely(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"I can only \\\\\\\\ draw finitely\",\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class SupposeMissingPoint(PointsWeMiss):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.background_plane.set_stroke(width = 1)\n",
        "        self.draw_missing_triple()\n",
        "        self.project_onto_unit_circle()\n",
        "\n",
        "    def draw_missing_triple(self):\n",
        "        point = self.background_plane.coords_to_point(12, 5)\n",
        "        origin = self.plane_center\n",
        "        line = Line(origin, point, color = WHITE)\n",
        "        dot = Dot(point, color = YELLOW)\n",
        "        triangle = Polygon(ORIGIN, RIGHT, RIGHT+UP)\n",
        "        triangle.set_stroke(BLUE, 2)\n",
        "        triangle.set_fill(BLUE, 0.5)\n",
        "        triangle.replace(line, stretch = True)\n",
        "        a = OldTex(\"a\")\n",
        "        a.next_to(triangle.get_bottom(), UP, SMALL_BUFF)\n",
        "        b = OldTex(\"b\")\n",
        "        b.add_background_rectangle()\n",
        "        b.next_to(triangle, RIGHT, SMALL_BUFF)\n",
        "        c = OldTex(\"c\")\n",
        "        c.add_background_rectangle()\n",
        "        c.next_to(line.get_center(), UP+LEFT, SMALL_BUFF)\n",
        "        triangle.add(a, b, c)\n",
        "        words = OldTexText(\n",
        "            \"If we missed \\\\\\\\ a triple \\\\dots\"\n",
        "        )\n",
        "        words.add_background_rectangle()\n",
        "        words.next_to(dot, UP+RIGHT)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        self.add(triangle, line, dot)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.words = words\n",
        "        self.triangle = triangle\n",
        "        self.line = line\n",
        "        self.dot = dot\n",
        "\n",
        "\n",
        "    def project_onto_unit_circle(self):\n",
        "        dot, line = self.dot, self.line\n",
        "        template_line = Line(*[\n",
        "            self.background_plane.number_to_point(n)\n",
        "            for n in (-1, 1)\n",
        "        ])\n",
        "        circle = Circle(color = GREEN)\n",
        "        circle.replace(template_line, dim_to_match = 0)\n",
        "        z = self.background_plane.point_to_number(dot.get_center())\n",
        "        z_norm = abs(z)\n",
        "        unit_z = z/z_norm\n",
        "        new_point = self.background_plane.number_to_point(unit_z)\n",
        "        dot.generate_target()\n",
        "        dot.target.move_to(new_point)\n",
        "        line.generate_target()\n",
        "        line.target.scale(1./z_norm, about_point = self.plane_center)\n",
        "\n",
        "        rational_point_word = OldTex(\"(a/c) + (b/c)i\")\n",
        "        rational_point_word.next_to(\n",
        "            self.background_plane.coords_to_point(0, 6), RIGHT\n",
        "        )\n",
        "        rational_point_word.add_background_rectangle()\n",
        "        arrow = Arrow(\n",
        "            rational_point_word.get_bottom(),\n",
        "            dot.target,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.add(dot.copy().fade())\n",
        "        self.add(line.copy().set_stroke(GREY, 1))\n",
        "        self.play(*list(map(MoveToTarget, [dot, line])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(rational_point_word),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ProofTime(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Proof time!\", target_mode = \"hooray\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class FinalProof(RationalPointsOnUnitCircle):\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.draw_rational_point()\n",
        "        self.draw_line_from_example_point()\n",
        "        self.show_slope_is_rational()\n",
        "        self.show_all_rational_slopes()\n",
        "        self.square_example_point()\n",
        "        self.project_onto_circle()\n",
        "        self.show_same_slope()\n",
        "        self.write_v_over_u_slope()\n",
        "\n",
        "    def draw_rational_point(self):\n",
        "        circle = self.get_unit_circle()\n",
        "        coords = (3./5., 4./5.)\n",
        "        point = self.background_plane.coords_to_point(*coords)\n",
        "        dot = Dot(point, color = YELLOW)\n",
        "        label = OldTex(\n",
        "            \"(a/c) + (b/c)i\"\n",
        "        )\n",
        "        label.add_background_rectangle()\n",
        "        label.next_to(dot, UP+RIGHT, buff = 0)\n",
        "\n",
        "        self.add(circle)\n",
        "        self.play(\n",
        "            Write(label, run_time = 2),\n",
        "            DrawBorderThenFill(dot)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.example_dot = dot\n",
        "        self.example_label = label\n",
        "        self.unit_circle = circle\n",
        "\n",
        "    def draw_line_from_example_point(self):\n",
        "        neg_one_point = self.background_plane.number_to_point(-1)\n",
        "        neg_one_dot = Dot(neg_one_point, color = RED)\n",
        "        line = Line(\n",
        "            neg_one_point, self.example_dot.get_center(),\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line, run_time = 2),\n",
        "            Animation(self.example_label)\n",
        "        )\n",
        "        self.play(DrawBorderThenFill(neg_one_dot))\n",
        "        self.wait()\n",
        "\n",
        "        self.neg_one_dot = neg_one_dot\n",
        "        self.secant_line = line\n",
        "\n",
        "    def show_slope_is_rational(self):\n",
        "        p0 = self.neg_one_dot.get_center()\n",
        "        p1 = self.example_dot.get_center()\n",
        "        p_mid = p1[0]*RIGHT + p0[1]*UP\n",
        "\n",
        "        h_line = Line(p0, p_mid, color = MAROON_B)\n",
        "        v_line = Line(p_mid, p1, color = MAROON_B)\n",
        "        run_brace = Brace(h_line, DOWN)\n",
        "        run_text = run_brace.get_text(\n",
        "            \"Run = $1 + \\\\frac{a}{c}$\"\n",
        "        )\n",
        "        run_text.add_background_rectangle()\n",
        "        rise_brace = Brace(v_line, RIGHT)\n",
        "        rise_text = rise_brace.get_text(\"Rise = $\\\\frac{b}{c}$\")\n",
        "        rise_text.add_background_rectangle()\n",
        "\n",
        "        self.play(*list(map(ShowCreation, [h_line, v_line])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(rise_brace),\n",
        "            FadeIn(rise_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(run_brace),\n",
        "            FadeIn(run_text)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.example_dot, self.example_label,\n",
        "            self.secant_line,\n",
        "            h_line, v_line,\n",
        "            run_brace, rise_brace,\n",
        "            run_text, rise_text,\n",
        "        ])))\n",
        "\n",
        "    def show_all_rational_slopes(self):\n",
        "        lines = VGroup()\n",
        "        labels = VGroup()\n",
        "        for u in range(2, 7):\n",
        "            for v in range(1, u):\n",
        "                if fractions.gcd(u, v) != 1:\n",
        "                    continue\n",
        "                z_squared = complex(u, v)**2\n",
        "                unit_z_squared = z_squared/abs(z_squared)\n",
        "                point = self.background_plane.number_to_point(unit_z_squared)\n",
        "                dot = Dot(point, color = YELLOW)\n",
        "                line = Line(\n",
        "                    self.background_plane.number_to_point(-1),\n",
        "                    point,\n",
        "                    color = self.neg_one_dot.get_color()\n",
        "                )\n",
        "                line.add(dot)\n",
        "\n",
        "                label = OldTex(\n",
        "                    \"\\\\text{Slope = }\",\n",
        "                    str(v), \"/\", str(u)\n",
        "                )\n",
        "                label.add_background_rectangle()\n",
        "                label.next_to(\n",
        "                    self.background_plane.coords_to_point(1, 1.5),\n",
        "                    RIGHT\n",
        "                )\n",
        "\n",
        "                lines.add(line)\n",
        "                labels.add(label)\n",
        "        line = lines[0]\n",
        "        label = labels[0]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeIn(label)\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_line, new_label in zip(lines, labels)[1:]:\n",
        "            self.play(\n",
        "                Transform(line, new_line),\n",
        "                Transform(label, new_label),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(*list(map(FadeOut, [line, label])))\n",
        "\n",
        "    def square_example_point(self):\n",
        "        z = complex(2, 1)\n",
        "        point = self.background_plane.number_to_point(z)\n",
        "        uv_dot = Dot(point, color = YELLOW)\n",
        "        uv_label = OldTex(\"u\", \"+\", \"v\", \"i\")\n",
        "        uv_label.add_background_rectangle()\n",
        "        uv_label.next_to(uv_dot, DOWN+RIGHT, buff = 0)\n",
        "        uv_line = Line(\n",
        "            self.plane_center, point,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        uv_arc = Arc(\n",
        "            angle = uv_line.get_angle(),\n",
        "            radius = 0.75\n",
        "        )\n",
        "        uv_arc.shift(self.plane_center)\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.next_to(uv_arc, RIGHT, SMALL_BUFF, DOWN)\n",
        "        theta.scale(0.8)\n",
        "\n",
        "        square_point = self.background_plane.number_to_point(z**2)\n",
        "        square_dot = Dot(square_point, color = MAROON_B)\n",
        "        square_label = OldTex(\"(u+vi)^2\")\n",
        "        square_label.add_background_rectangle()\n",
        "        square_label.next_to(square_dot, RIGHT)\n",
        "        square_line = Line(\n",
        "            self.plane_center, square_point,\n",
        "            color = MAROON_B\n",
        "        )\n",
        "        square_arc = Arc(\n",
        "            angle = square_line.get_angle(),\n",
        "            radius = 0.65\n",
        "        )\n",
        "        square_arc.shift(self.plane_center)\n",
        "        two_theta = OldTex(\"2\\\\theta\")\n",
        "        two_theta.next_to(\n",
        "            self.background_plane.coords_to_point(0, 1),\n",
        "            UP+RIGHT, SMALL_BUFF, \n",
        "        )\n",
        "        two_theta_arrow = Arrow(\n",
        "            two_theta.get_right(),\n",
        "            square_arc.point_from_proportion(0.75),\n",
        "            tip_length = 0.15,\n",
        "            path_arc = -np.pi/2,\n",
        "            color = WHITE,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.two_theta_group = VGroup(two_theta, two_theta_arrow)\n",
        "\n",
        "        z_to_z_squared_arrow = Arrow(\n",
        "            point, square_point, \n",
        "            path_arc = np.pi/3,\n",
        "            color = WHITE\n",
        "        )\n",
        "        z_to_z_squared = OldTex(\"z\", \"\\\\to\", \"z^2\")\n",
        "        z_to_z_squared.set_color_by_tex(\"z\", YELLOW)\n",
        "        z_to_z_squared.set_color_by_tex(\"z^2\", MAROON_B)\n",
        "        z_to_z_squared.add_background_rectangle()\n",
        "        z_to_z_squared.next_to(\n",
        "            z_to_z_squared_arrow.point_from_proportion(0.5),\n",
        "            RIGHT, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(uv_label),\n",
        "            DrawBorderThenFill(uv_dot)\n",
        "        )\n",
        "        self.play(ShowCreation(uv_line))\n",
        "        self.play(ShowCreation(uv_arc))\n",
        "        self.play(Write(theta))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(z_to_z_squared_arrow),\n",
        "            FadeIn(z_to_z_squared)\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                m1.copy(), m2,\n",
        "                path_arc = np.pi/3\n",
        "            )\n",
        "            for m1, m2 in [\n",
        "                (uv_dot, square_dot),\n",
        "                (uv_line, square_line),\n",
        "                (uv_label, square_label),\n",
        "                (uv_arc, square_arc),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(two_theta),\n",
        "            ShowCreation(two_theta_arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(self.two_theta_group))\n",
        "\n",
        "        self.theta_group = VGroup(uv_arc, theta)\n",
        "        self.uv_line = uv_line\n",
        "        self.uv_dot = uv_dot\n",
        "        self.uv_label = uv_label\n",
        "        self.square_line = square_line\n",
        "        self.square_dot = square_dot\n",
        "\n",
        "    def project_onto_circle(self):\n",
        "        line = self.square_line.copy()\n",
        "        dot = self.square_dot.copy()\n",
        "        self.square_line.fade()\n",
        "        self.square_dot.fade()\n",
        "\n",
        "        radius = self.unit_circle.get_width()/2\n",
        "        line.generate_target()\n",
        "        line.target.scale(\n",
        "            radius / line.get_length(),\n",
        "            about_point = line.get_start()\n",
        "        )\n",
        "        dot.generate_target()\n",
        "        dot.target.move_to(line.target.get_end())\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(line),\n",
        "            MoveToTarget(dot),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(self.two_theta_group))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.two_theta_group))\n",
        "        self.wait(6) ##circle geometry\n",
        "\n",
        "        self.rational_point_dot = dot\n",
        "\n",
        "    def show_same_slope(self):\n",
        "        line = Line(\n",
        "            self.neg_one_dot.get_center(),\n",
        "            self.rational_point_dot.get_center(),\n",
        "            color = self.neg_one_dot.get_color()\n",
        "        )\n",
        "        theta_group_copy = self.theta_group.copy()\n",
        "        same_slope_words = OldTexText(\"Same slope\")\n",
        "        same_slope_words.add_background_rectangle()\n",
        "        same_slope_words.shift(4*LEFT + 0.33*UP)\n",
        "        line_copies = VGroup(\n",
        "            line.copy(),\n",
        "            self.uv_line.copy()\n",
        "        )\n",
        "        line_copies.generate_target()\n",
        "        line_copies.target.next_to(same_slope_words, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            theta_group_copy.shift,\n",
        "            line.get_start() - self.uv_line.get_start()\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(same_slope_words),\n",
        "            MoveToTarget(line_copies)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.same_slope_words = same_slope_words\n",
        "\n",
        "    def write_v_over_u_slope(self):\n",
        "        p0 = self.plane_center\n",
        "        p1 = self.uv_dot.get_center()\n",
        "        p_mid = p1[0]*RIGHT + p0[1]*UP\n",
        "        h_line = Line(p0, p_mid, color = YELLOW)\n",
        "        v_line = Line(p_mid, p1, color = YELLOW)\n",
        "\n",
        "        rhs = OldTex(\"=\", \"{v\", \"\\\\over\", \"u}\")\n",
        "        rhs.next_to(self.same_slope_words, RIGHT)\n",
        "        rect = SurroundingRectangle(VGroup(*rhs[1:]))\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.5)\n",
        "        morty.next_to(self.same_slope_words, UP, buff = 0)\n",
        "\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                self.uv_label.get_part_by_tex(tex).copy(),\n",
        "                rhs.get_part_by_tex(tex),\n",
        "                run_time = 2\n",
        "            )\n",
        "            for tex in (\"u\", \"v\")\n",
        "        ] + [\n",
        "            Write(rhs.get_part_by_tex(tex))\n",
        "            for tex in (\"=\", \"over\")\n",
        "        ])\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(morty)\n",
        "        )\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Free to choose!\",\n",
        "            bubble_config = {\"height\" : 1.5, \"width\" : 3},\n",
        "            target_mode = \"hooray\",\n",
        "            look_at = rect\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class BitOfCircleGeometry(Scene):\n",
        "    def construct(self):\n",
        "        circle = Circle(color = BLUE, radius = 3)\n",
        "        p0, p1, p2 = [\n",
        "            circle.point_from_proportion(alpha)\n",
        "            for alpha in (0, 0.15, 0.55)\n",
        "        ]\n",
        "        O = circle.get_center()\n",
        "        O_dot = Dot(O, color = WHITE)\n",
        "        self.add(circle, O_dot)\n",
        "\n",
        "\n",
        "        groups = VGroup()\n",
        "        for point, tex, color in (O, \"2\", MAROON_B), (p2, \"\", RED):\n",
        "            line1 = Line(point, p0)\n",
        "            line2 = Line(point, p1)\n",
        "            dot1 = Dot(p0)\n",
        "            dot2 = Dot(p1)\n",
        "            angle = line1.get_angle()\n",
        "            arc = Arc(\n",
        "                angle = line2.get_angle()-line1.get_angle(), \n",
        "                start_angle = line1.get_angle(),\n",
        "                radius = 0.75,\n",
        "                color = WHITE\n",
        "            )\n",
        "            arc.set_stroke(YELLOW, 3)\n",
        "            arc.shift(point)\n",
        "            label = OldTex(tex + \"\\\\theta\")\n",
        "            label.next_to(\n",
        "                arc.point_from_proportion(0.9), RIGHT\n",
        "            )\n",
        "\n",
        "            group = VGroup(line1, line2, dot1, dot2)\n",
        "            group.set_color(color)\n",
        "            group.add(arc, label)\n",
        "            if len(groups) == 0:\n",
        "                self.play(*list(map(ShowCreation, [dot1, dot2])))\n",
        "                self.play(*list(map(ShowCreation, [line1, line2])))\n",
        "                self.play(ShowCreation(arc))\n",
        "                self.play(FadeIn(label))\n",
        "            groups.add(group)\n",
        "\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            groups[0].copy(), groups[1]\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class PatreonThanksTriples(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"David Beyer\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Ankit Agarwal\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Juan Benet\",\n",
        "            \"Othman Alikhan\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Tomohiro Furusawa\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"John Haley\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Suraj Pratap\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Ahmad Bamieh\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(DrawRadialLines):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_plane()\n",
        "        self.add_transformed_color_grid()\n",
        "        self.color_grid.set_stroke(width = 5)\n",
        "        self.resize_plane()\n",
        "        self.add_dots()\n",
        "        self.create_lines()\n",
        "        self.show_single_line()\n",
        "        self.show_all_lines()\n",
        "\n",
        "        rect = Rectangle(\n",
        "            height = 4.3, width = 4.2,\n",
        "            stroke_width = 3,\n",
        "            stroke_color = WHITE,\n",
        "            fill_color = BLACK,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        rect.to_corner(UP+RIGHT, buff = 0.01)\n",
        "        triples = VGroup(*list(map(Tex, [\n",
        "            \"3^2 + 4^2 = 5^2\",\n",
        "            \"5^2 + 12^2 = 13^2\",\n",
        "            \"8^2 + 15^2 = 17^2\",\n",
        "            \"\\\\vdots\"\n",
        "        ])))\n",
        "        triples.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        triples.next_to(rect.get_top(), DOWN)\n",
        "        self.add(rect, triples)\n",
        "\n",
        "class Poster(DrawRadialLines):\n",
        "    CONFIG = {\n",
        "        \"final_unit_size\" : 0.1,\n",
        "        \"plane_center\" : ORIGIN,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        self.add_plane()\n",
        "        self.add_transformed_color_grid()\n",
        "        self.color_grid.set_stroke(width = 5)\n",
        "        self.resize_plane()\n",
        "        self.add_dots()\n",
        "        self.create_lines()\n",
        "        self.show_single_line()\n",
        "        self.show_all_lines()\n",
        "\n",
        "        for dot_group in self.dots, self.new_dots:\n",
        "            for dot in dot_group.family_members_with_points():\n",
        "                dot.scale(0.5)\n",
        "        self.remove(self.coordinate_labels)\n",
        "\n",
        "        # rect = Rectangle(\n",
        "        #     height = 4.3, width = 4.2,\n",
        "        #     stroke_width = 3,\n",
        "        #     stroke_color = WHITE,\n",
        "        #     fill_color = BLACK,\n",
        "        #     fill_opacity = 1,\n",
        "        # )\n",
        "        # rect.to_corner(UP+RIGHT, buff = 0.01)\n",
        "        # triples = VGroup(*map(Tex, [\n",
        "        #     \"3^2 + 4^2 = 5^2\",\n",
        "        #     \"5^2 + 12^2 = 13^2\",\n",
        "        #     \"8^2 + 15^2 = 17^2\",\n",
        "        #     \"\\\\vdots\"\n",
        "        # ]))\n",
        "        # triples.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        # triples.next_to(rect.get_top(), DOWN)\n",
        "        # self.add(rect, triples)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}