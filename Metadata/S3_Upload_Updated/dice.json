{
    "topic": "is demonstrating the concept of a probability distribution and how to calculate the probability of each outcome",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.convolutions.discrete import *\n",
        "from _2023.clt.main import *\n",
        "\n",
        "\n",
        "SKEW_DISTRIBUTION = [0.12, 0.23, 0.31, 0.18, 0.12, 0.04]\n",
        "\n",
        "# Helpers\n",
        "\n",
        "\n",
        "def get_bar_group(\n",
        "    dist,\n",
        "    bar_colors=(BLUE_D, TEAL_D),\n",
        "    value_labels=None,\n",
        "    width_ratio=0.7,\n",
        "    height=2.0,\n",
        "    number_config=dict(),\n",
        "    label_buff=SMALL_BUFF,\n",
        "):\n",
        "    bars = dist_to_bars(dist, bar_colors=bar_colors, height=height)\n",
        "    p_labels = VGroup(*(DecimalNumber(x, **number_config) for x in dist))\n",
        "    p_labels.set_max_width(width_ratio * bars[0].get_width())\n",
        "    for p_label, bar in zip(p_labels, bars):\n",
        "        p_label.next_to(bar, UP, SMALL_BUFF)\n",
        "\n",
        "    if value_labels is None:\n",
        "        value_labels = VectorizedPoint().replicate(len(dist))\n",
        "\n",
        "    for value_label, bar in zip(value_labels, bars):\n",
        "        value_label.set_width(width_ratio * bars[0].get_width())\n",
        "        value_label.next_to(bar, DOWN, buff=label_buff)\n",
        "\n",
        "    labeled_bars = VGroup(*(\n",
        "        VGroup(bar, value_label, p_label)\n",
        "        for bar, value_label, p_label in zip(bars, value_labels, p_labels)\n",
        "    ))\n",
        "    for group in labeled_bars:\n",
        "        group.bar, group.die, group.value_label = group\n",
        "\n",
        "    return labeled_bars\n",
        "\n",
        "\n",
        "def die_sum_labels(color1=BLUE_E, color2=RED_E, height=1.0):\n",
        "    die1, die2 = dice = [\n",
        "        DieFace(1, fill_color=color)\n",
        "        for color in [color1, color2]\n",
        "    ]\n",
        "    for die in dice:\n",
        "        die.remove(die[1])\n",
        "        die.set_height(height / 3)\n",
        "\n",
        "    result = VGroup()\n",
        "    for n in range(2, 13):\n",
        "        sum_sym = VGroup(\n",
        "            die1.copy(),\n",
        "            Tex(\"+\", font_size=24),\n",
        "            die2.copy(),\n",
        "            Tex(\"=\", font_size=24).rotate(90 * DEGREES),\n",
        "            Tex(str(n), font_size=30),\n",
        "        )\n",
        "        sum_sym.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        sum_sym[:2].shift(0.05 * DOWN)\n",
        "        sum_sym[:1].shift(0.05 * DOWN)\n",
        "        sum_sym.set_height(height)\n",
        "        result.add(sum_sym)\n",
        "    result.arrange(RIGHT)\n",
        "    return result\n",
        "\n",
        "\n",
        "def rotate_sum_label(sum_label):\n",
        "    sum_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "    sum_label[-2].rotate(90 * DEGREES)\n",
        "    sum_label[-2:].set_height(sum_label.get_height(), about_edge=LEFT)\n",
        "    sum_label[-2:].shift(SMALL_BUFF * RIGHT)\n",
        "    sum_label[-1].shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "\n",
        "def p_mob(mob, scale_factor=1.0):\n",
        "    used_mob = mob.copy()\n",
        "    aspect_ratio = mob.get_width() / mob.get_height()\n",
        "    Os = \"O\" * int(np.round(aspect_ratio))\n",
        "    tex = Tex(f\"P({Os})\")\n",
        "    used_mob.replace(tex[Os], dim_to_match=0)\n",
        "    used_mob.scale(scale_factor)\n",
        "    result = VGroup(*tex[:2], used_mob, tex[-1])\n",
        "    result.arg = used_mob\n",
        "    return result\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class SumAlongDiagonal(InteractiveScene):\n",
        "    samples = 4\n",
        "\n",
        "    dist1 = EXP_DISTRIBUTION\n",
        "    dist2 = SKEW_DISTRIBUTION\n",
        "\n",
        "    dist1_colors = (BLUE_D, TEAL_D)\n",
        "    dist2_colors = (RED_D, GOLD_E)\n",
        "    sum_colors = (GREEN_E, YELLOW_E)\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup distributions\n",
        "        dist1 = self.dist1\n",
        "        dist2 = self.dist2\n",
        "        blue_dice = get_die_faces(fill_color=BLUE_E, dot_color=WHITE)\n",
        "        red_dice = get_die_faces(fill_color=RED_E, dot_color=WHITE)\n",
        "        bar_groups = VGroup(\n",
        "            get_bar_group(dist1, self.dist1_colors, blue_dice),\n",
        "            get_bar_group(dist2, self.dist2_colors, red_dice),\n",
        "        )\n",
        "\n",
        "        bar_groups.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        bar_groups.to_edge(LEFT)\n",
        "\n",
        "        self.add(bar_groups)\n",
        "\n",
        "        # Setup the sum distribution\n",
        "        conv_dist = np.convolve(dist1, dist2)\n",
        "        sum_labels = die_sum_labels()\n",
        "        sum_bar_group = get_bar_group(\n",
        "            conv_dist, self.sum_colors, sum_labels,\n",
        "            number_config=dict(num_decimal_places=3, font_size=30),\n",
        "            label_buff=MED_SMALL_BUFF,\n",
        "        )\n",
        "        sum_bar_group.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        sum_bar_group.set_y(0)\n",
        "\n",
        "        buckets = VGroup()\n",
        "        for bar in sum_bar_group:\n",
        "            base = Line(LEFT, RIGHT)\n",
        "            base.match_width(bar)\n",
        "            base.move_to(bar[0], DOWN)\n",
        "            v_lines = Line(DOWN, UP).replicate(2)\n",
        "            v_lines.set_height(6)\n",
        "            v_lines[0].move_to(base.get_left(), DOWN)\n",
        "            v_lines[1].move_to(base.get_right(), DOWN)\n",
        "            bucket = VGroup(base, *v_lines)\n",
        "            bucket.set_stroke(GREY_C, 2)\n",
        "            buckets.add(bucket)\n",
        "\n",
        "        self.add(sum_labels)\n",
        "        self.add(buckets)\n",
        "\n",
        "        # Repeatedly sample from these two (for a while)\n",
        "        self.show_repeated_samples(\n",
        "            dist1, dist2, *bar_groups, buckets, sum_labels,\n",
        "            n_animated_runs=1, n_total_runs=2,\n",
        "        )\n",
        "\n",
        "        # Ask about sum values\n",
        "        rects = VGroup(*(\n",
        "            SurroundingRectangle(sum_label)\n",
        "            for sum_label in sum_labels\n",
        "        ))\n",
        "        words1 = Text(\"What's the probability\\nof this?\", font_size=36)\n",
        "        words2 = Text(\"Or this?\", font_size=36)\n",
        "\n",
        "        words1.next_to(rects[0], DOWN, MED_SMALL_BUFF)\n",
        "        words2.next_to(rects[1], DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(rects[0]), FadeIn(words1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingStrings(words1, words2, run_time=1),\n",
        "            FadeOut(rects[0]),\n",
        "            FadeIn(rects[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in range(1, len(rects) - 1):\n",
        "            self.play(\n",
        "                FadeOut(rects[i]), FadeIn(rects[i + 1]),\n",
        "                words2.animate.match_x(rects[i + 1]),\n",
        "                run_time=0.5\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(words2), FadeOut(rects[-1]))\n",
        "        self.play(FadeOut(sum_labels), FadeOut(buckets))\n",
        "\n",
        "        # Draw grid of dice values\n",
        "        grid = Square().get_grid(6, 6, buff=0, fill_rows_first=False, )\n",
        "        grid.flip(RIGHT)\n",
        "        grid.set_stroke(WHITE, 1)\n",
        "        grid.set_height(5.5)\n",
        "        grid.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        grid.to_edge(UP)\n",
        "\n",
        "        blue_row = blue_dice.copy()\n",
        "        red_col = red_dice.copy()\n",
        "        for square, die in zip(grid[::6], blue_row):\n",
        "            die.set_width(0.5 * square.get_width())\n",
        "            die.next_to(square, DOWN)\n",
        "        for square, die in zip(grid, red_col):\n",
        "            die.set_width(0.5 * square.get_width())\n",
        "            die.next_to(square, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(grid, lag_ratio=0.5),\n",
        "            TransformFromCopy(blue_dice, blue_row),\n",
        "            TransformFromCopy(red_dice, red_col),\n",
        "        )\n",
        "\n",
        "        dice_pairs = VGroup()\n",
        "        anims = []\n",
        "        for n, square in enumerate(grid):\n",
        "            templates = VGroup(\n",
        "                blue_row[n // 6],\n",
        "                red_col[n % 6],\n",
        "            )\n",
        "            pair = templates.copy()\n",
        "            pair.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            pair.set_width(square.get_width() * 0.7)\n",
        "            pair.move_to(square)\n",
        "            dice_pairs.add(pair)\n",
        "            anims.extend([\n",
        "                TransformFromCopy(templates, pair),\n",
        "            ])\n",
        "\n",
        "        self.play(LaggedStart(*anims, lag_ratio=0.1))\n",
        "        self.add(dice_pairs)\n",
        "        self.wait()\n",
        "\n",
        "        full_table = VGroup(blue_row, red_col, grid, dice_pairs)\n",
        "\n",
        "        # Highlight (4, 2) pair\n",
        "        pairs = [\n",
        "            (1, 1),\n",
        "            (1, 2),\n",
        "            (1, 3),\n",
        "            (1, 4),\n",
        "            (1, 5),\n",
        "            (2, 5),\n",
        "            (2, 4),\n",
        "            (2, 3),\n",
        "            (3, 3),\n",
        "            (3, 2),\n",
        "            (4, 2),\n",
        "        ]\n",
        "\n",
        "        for pair in pairs:\n",
        "            self.isolate_pairs(bar_groups, full_table, pair)\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "\n",
        "        # Show the probability of (4, 2)\n",
        "        def get_p_label(dice):\n",
        "            p_label = VGroup(\n",
        "                p_mob(dice), Tex(\"=\"),\n",
        "                p_mob(dice[0]),\n",
        "                p_mob(dice[1]),\n",
        "            )\n",
        "            p_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            return p_label\n",
        "\n",
        "        i0, j0 = pairs[-1]\n",
        "        p_label = get_p_label(dice_pairs[(i0 - 1) * 6 + (j0 - 1)])\n",
        "        p_label.to_edge(UP)\n",
        "        p_label.shift(2.5 * LEFT)\n",
        "\n",
        "        movers = VGroup(\n",
        "            dice_pairs[(i0 - 1) * 6 + j0 - 1],\n",
        "            blue_row[(i0 - 1)],\n",
        "            red_col[(j0 - 1)],\n",
        "        ).copy()\n",
        "        self.play(\n",
        "            bar_groups.animate.set_width(2.5, about_edge=DL),\n",
        "            full_table.animate.set_width(5.5, about_edge=DR),\n",
        "            LaggedStart(\n",
        "                movers[0].animate.replace(p_label[0][2]),\n",
        "                movers[1].animate.replace(p_label[2][2]),\n",
        "                movers[2].animate.replace(p_label[3][2]),\n",
        "                lag_ratio=0.25,\n",
        "            ),\n",
        "        )\n",
        "        self.play(FadeIn(p_label))\n",
        "        self.remove(movers)\n",
        "        self.wait()\n",
        "\n",
        "        # Show numerical product\n",
        "        prod_rhs = Tex(\"= (0.00)(0.00)\")\n",
        "        num_rhs = Tex(\"= 0.000\")\n",
        "\n",
        "        value1, value2 = prod_rhs.make_number_changeable(\"0.00\", replace_all=True)\n",
        "        value1.set_value(dist1[i0 - 1]).set_color(BLUE)\n",
        "        value2.set_value(dist2[j0 - 1]).set_color(RED)\n",
        "        prod_rhs.next_to(p_label[1], DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        pair_prob = num_rhs.make_number_changeable(\"0.000\")\n",
        "        pair_prob.set_value(dist1[i0 - 1] * dist2[j0 - 1])\n",
        "        num_rhs.next_to(prod_rhs, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            Transform(bar_groups[0][i0 - 1][2].copy(), value1.copy(), remover=True),\n",
        "            Transform(bar_groups[1][j0 - 1][2].copy(), value2.copy(), remover=True),\n",
        "            Write(prod_rhs, lag_ratio=0.1),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(num_rhs, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        example = VGroup(p_label, prod_rhs, num_rhs)\n",
        "\n",
        "        # Assumption\n",
        "        morty = Mortimer(height=2.0).flip()\n",
        "        morty.next_to(example, DOWN, buff=2.0)\n",
        "        morty.shift(0.5 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            morty.says(\n",
        "                \"Assuming rolls\\nare independent!\",\n",
        "                mode=\"surprised\",\n",
        "            ),\n",
        "            VFadeIn(morty),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(morty, morty.bubble, morty.bubble.content)))\n",
        "\n",
        "        # Set up the multiplication table\n",
        "        full_table.generate_target()\n",
        "        full_table.target.set_width(6.5)\n",
        "        full_table.target.set_opacity(1)\n",
        "        full_table.target[2].set_fill(opacity=0)\n",
        "        full_table.target.to_edge(RIGHT, buff=1.5)\n",
        "        full_table.target.set_y(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(full_table),\n",
        "            example.animate.scale(0.75, about_edge=UL).shift(0.5 * LEFT)\n",
        "        )\n",
        "\n",
        "        marginal_labels = VGroup(*(\n",
        "            VGroup(*(bar[2] for bar in group)).copy()\n",
        "            for group in bar_groups\n",
        "        ))\n",
        "        margin_dice = VGroup(*full_table[:2], full_table[3])\n",
        "        for margins, dice in zip(marginal_labels, margin_dice):\n",
        "            margins.generate_target()\n",
        "            dice.generate_target()\n",
        "            for die, prob in zip(dice.target, margins.target):\n",
        "                center = die.get_center()\n",
        "                die.scale(0.7)\n",
        "                die.set_opacity(0.85)\n",
        "                prob.next_to(die, DOWN, buff=0.125)\n",
        "                prob.scale(1.5)\n",
        "                VGroup(prob, die).move_to(center)\n",
        "\n",
        "        marginal_labels[0].target.set_fill(BLUE, 1)\n",
        "        marginal_labels[1].target.set_fill(RED, 1)\n",
        "\n",
        "        margin_dice[2].generate_target()\n",
        "        for dice in margin_dice[2].target:\n",
        "            dice.scale(0.75, about_edge=UP)\n",
        "            dice.set_opacity(0.85)\n",
        "            dice.set_stroke(width=1)\n",
        "            dice.shift(0.1 * UP)\n",
        "\n",
        "        for groups in zip(marginal_labels, margin_dice):\n",
        "            self.play(*map(MoveToTarget, groups), lag_ratio=0.001)\n",
        "        self.play(MoveToTarget(margin_dice[2], lag_ratio=0.001))\n",
        "        self.wait()\n",
        "\n",
        "        full_table.add(marginal_labels)\n",
        "\n",
        "        # Fill in multiplication table\n",
        "        grid_probs = VGroup()\n",
        "        self.add(grid_probs)\n",
        "        for n, square in enumerate(grid):\n",
        "            i, j = n // 6, n % 6\n",
        "            dice = margin_dice[2][n]\n",
        "            margin1 = marginal_labels[0][i]\n",
        "            margin2 = marginal_labels[1][j]\n",
        "            prob = DecimalNumber(\n",
        "                margin1.get_value() * margin2.get_value(),\n",
        "                num_decimal_places=3\n",
        "            )\n",
        "            prob.set_height(margin1.get_height())\n",
        "            prob.next_to(dice, DOWN, SMALL_BUFF)\n",
        "\n",
        "            rects = VGroup(*(\n",
        "                SurroundingRectangle(mob, buff=SMALL_BUFF)\n",
        "                for mob in [margin1, margin2, prob]\n",
        "            ))\n",
        "            rects.set_stroke(YELLOW, 1)\n",
        "\n",
        "            grid_probs.add(prob)\n",
        "\n",
        "            value1.set_value(dist1[i])\n",
        "            value2.set_value(dist2[j])\n",
        "            pair_prob.set_value(dist1[i] * dist2[j])\n",
        "            new_p_label = get_p_label(dice.copy().set_opacity(1))\n",
        "            new_p_label.replace(p_label, dim_to_match=1)\n",
        "            p_label.become(new_p_label)\n",
        "\n",
        "            bar_groups.set_opacity(0.35)\n",
        "            bar_groups[0][i].set_opacity(1)\n",
        "            bar_groups[1][j].set_opacity(1)\n",
        "\n",
        "            self.add(rects)\n",
        "            self.wait(0.25)\n",
        "            self.remove(rects)\n",
        "        self.wait()\n",
        "\n",
        "        full_table.add(grid_probs)\n",
        "\n",
        "        # Fade out example\n",
        "        self.play(\n",
        "            FadeOut(example),\n",
        "            bar_groups.animate.set_opacity(1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show it as a 3d plot\n",
        "        bar_groups.fix_in_frame()\n",
        "        sum_bar_group.fix_in_frame()\n",
        "\n",
        "        bars_3d = VGroup()\n",
        "        scale_factor = 30\n",
        "        for square, prob in zip(grid, grid_probs):\n",
        "            prism = VCube()\n",
        "            prism.set_fill(GREY_D, 0.85)\n",
        "            prism.set_stroke(WHITE, 1, 0.5)\n",
        "            prism.match_width(square)\n",
        "            prism.set_depth(scale_factor * prob.get_value(), stretch=True)\n",
        "            prism.move_to(square, IN)\n",
        "            prism.save_state()\n",
        "            prism.stretch(0.001, 2, about_edge=IN)\n",
        "            prism.set_opacity(0)\n",
        "            bars_3d.add(prism)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, bars_3d),\n",
        "            self.frame.animate.reorient(12, 65, 0).move_to([-0.48, 0.37, 0.77]).set_height(9.43),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.add(full_table, *bars_3d)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(43, 66, 0).move_to([-0.06, 0.21, -0.29]).set_height(10.59),\n",
        "            run_time=7,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show sum distribution\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, bar_groups, shift=2 * LEFT),\n",
        "            FadeIn(sum_bar_group),\n",
        "            full_table.animate.to_edge(LEFT),\n",
        "            self.frame.animate.reorient(4, 65, 0).move_to([0.64, 0.8, 0.69]).set_height(10.59),\n",
        "            *(\n",
        "                MaintainPositionRelativeTo(bar, full_table)\n",
        "                for bar in bars_3d\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Reposition\n",
        "        self.play(\n",
        "            self.frame.animate.to_default_state(),\n",
        "            FadeOut(bars_3d),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add up along all diagonals\n",
        "        low_group = VGroup(blue_row, marginal_labels[0])\n",
        "        left_group = VGroup(red_col, marginal_labels[1])\n",
        "        diagonals = VGroup(*(\n",
        "            VGroup(*(\n",
        "                VGroup(dice_pairs[n], grid_probs[n])\n",
        "                for n in range(36)\n",
        "                if (n // 6) + (n % 6) == s\n",
        "            ))\n",
        "            for s in range(11)\n",
        "        ))\n",
        "\n",
        "        diagonals.save_state()\n",
        "        rects = VGroup()\n",
        "        diagonals.rotate(45 * DEGREES)\n",
        "        for diagonal in diagonals:\n",
        "            rect = SurroundingRectangle(diagonal)\n",
        "            rect.stretch(0.9, 1)\n",
        "            rect.round_corners()\n",
        "            rects.add(rect)\n",
        "        VGroup(rects, diagonals).rotate(-45 * DEGREES, about_point=diagonals.get_center())\n",
        "\n",
        "        rects.set_fill(YELLOW, 0.25)\n",
        "        rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "        last_rect = VGroup(low_group, left_group)\n",
        "        for n, rect in zip(it.count(), rects):\n",
        "            self.add(rect, diagonals)\n",
        "            diagonals.generate_target()\n",
        "            diagonals.target.set_opacity(0.5)\n",
        "            diagonals.target[n].set_opacity(1)\n",
        "\n",
        "            sum_bar_group.generate_target()\n",
        "            sum_bar_group.target.set_opacity(0.4)\n",
        "            sum_bar_group.target[n].set_opacity(1)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(last_rect),\n",
        "                FadeIn(rect),\n",
        "                MoveToTarget(diagonals),\n",
        "                MoveToTarget(sum_bar_group),\n",
        "            )\n",
        "            last_rect = rect\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            diagonals.animate.set_opacity(1),\n",
        "            sum_bar_group.animate.set_opacity(1),\n",
        "            FadeOut(last_rect),\n",
        "            FadeIn(low_group),\n",
        "            FadeIn(left_group),\n",
        "        )\n",
        "\n",
        "        # Show 3d grid again\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(27, 66, 0).move_to([-0.16, 1.41, 0.77]).set_height(9.36),\n",
        "            FadeIn(bars_3d),\n",
        "            sum_bar_group.animate.to_edge(RIGHT),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go through diagonals of the plot\n",
        "        sorted_bars = VGroup(*bars_3d)\n",
        "        camera_pos = self.frame.get_implied_camera_location()\n",
        "        sorted_bars.sort(lambda p: -get_norm(p - camera_pos))\n",
        "        self.add(*sorted_bars)\n",
        "\n",
        "        diagonal_bar_groups = VGroup().replicate(11)\n",
        "\n",
        "        for s in range(11):\n",
        "            sum_bar_group.generate_target()\n",
        "            sum_bar_group.target.set_opacity(0.2)\n",
        "            sum_bar_group.target[s].set_opacity(1)\n",
        "\n",
        "            for n, bar in enumerate(bars_3d):\n",
        "                bar.generate_target()\n",
        "                bar.target.set_opacity(0.1)\n",
        "                bar.target.set_stroke(width=0)\n",
        "                if (n // 6) + (n % 6) == s:\n",
        "                    bar.target.set_opacity(1)\n",
        "                    diagonal_bar_groups[s].add(bar)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(sum_bar_group),\n",
        "                *map(MoveToTarget, bars_3d),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            bars_3d.animate.set_opacity(0.8).set_stroke(width=0.5),\n",
        "            sum_bar_group.animate.set_opacity(1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight bars\n",
        "        bars_3d.save_state()\n",
        "        bar_highlights = bars_3d.copy()\n",
        "        bar_highlights.set_fill(opacity=0)\n",
        "        bar_highlights.set_stroke(TEAL, 3)\n",
        "        self.play(ShowCreationThenFadeOut(bar_highlights, lag_ratio=0.001, run_time=2))\n",
        "\n",
        "        # Collapase diagonals\n",
        "        bars_3d.generate_target()\n",
        "        for bar in bars_3d.target:\n",
        "            bar.stretch(0.5, 0)\n",
        "            bar.stretch(0.5, 1)\n",
        "        bars_3d.target.set_fill(opacity=1)\n",
        "        bars_3d.target.set_submobject_colors_by_gradient(GREEN_D, YELLOW_D)\n",
        "        bars_3d.target.set_stroke(WHITE, 1)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(36, 46, 0).move_to([-0.56, 0.55, 1.22]).set_height(7.71),\n",
        "            MoveToTarget(bars_3d),\n",
        "            # FadeOut(full_table, IN),\n",
        "            sum_bar_group.animate.set_width(4.0).to_edge(RIGHT),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        diagonal_bar_groups.apply_depth_test()\n",
        "        new_diagonals = diagonal_bar_groups.copy()\n",
        "        for group in new_diagonals:\n",
        "            group.arrange(IN, buff=0)\n",
        "        new_diagonals.arrange(UR, buff=MED_SMALL_BUFF, aligned_edge=IN)\n",
        "        new_diagonals.move_to(bars_3d.get_corner(DR))\n",
        "        new_diagonals.shift(DR)\n",
        "        \n",
        "        self.play(\n",
        "            self.frame.animate.reorient(40, 61, 0).move_to([1.69, 0.33, -0.73]).set_height(12.96),\n",
        "            ReplacementTransform(\n",
        "                diagonal_bar_groups, new_diagonals,\n",
        "                lag_ratio=0.001,\n",
        "            ),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.add(full_table, new_diagonals)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(40, 85, 0).move_to([3.05, 1.93, 0.77]).set_height(14.93),\n",
        "            sum_bar_group.animate.set_width(5.5, about_edge=RIGHT),\n",
        "            FadeOut(full_table),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_repeated_samples(\n",
        "        self,\n",
        "        dist1,\n",
        "        dist2,\n",
        "        bar_group1,\n",
        "        bar_group2,\n",
        "        buckets,\n",
        "        sum_labels,\n",
        "        n_animated_runs=20,\n",
        "        n_total_runs=150,\n",
        "        marker_height=0.1,\n",
        "        marker_color=YELLOW_D,\n",
        "    ):\n",
        "        marker_template = Rectangle(\n",
        "            height=marker_height,\n",
        "            width=buckets[0].get_width() * 0.8,\n",
        "            fill_color=marker_color,\n",
        "            fill_opacity=1,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "        )\n",
        "        markers = VGroup(*(\n",
        "            VGroup(VectorizedPoint(bucket.get_bottom()))\n",
        "            for bucket in buckets\n",
        "        ))\n",
        "\n",
        "        var1 = scipy.stats.rv_discrete(values=(range(6), dist1))\n",
        "        var2 = scipy.stats.rv_discrete(values=(range(6), dist2))\n",
        "\n",
        "        for n in range(n_total_runs):\n",
        "            x = var1.rvs()\n",
        "            y = var2.rvs()\n",
        "\n",
        "            animate = n < n_animated_runs\n",
        "\n",
        "            # Show dice\n",
        "            dice = VGroup()\n",
        "            for group, value in [(bar_group1, x), (bar_group2, y)]:\n",
        "                die = group[value][1].copy()\n",
        "                die.set_opacity(1)\n",
        "                die.scale(2)\n",
        "                die.next_to(group, RIGHT, LARGE_BUFF)\n",
        "                dice.add(die)\n",
        "                group.set_opacity(0.5)\n",
        "                group[value].set_opacity(1)\n",
        "                self.add(die)\n",
        "                self.wait(0.25 if animate else 0.0)\n",
        "\n",
        "            # Highlight sum\n",
        "            sum_labels.set_opacity(0.25)\n",
        "            sum_labels[x + y].set_opacity(1)\n",
        "\n",
        "            # Drop marker in the appropriate sum bucket\n",
        "            marker = marker_template.copy()\n",
        "            marker.move_to(markers[x + y].get_top(), DOWN)\n",
        "            if animate:\n",
        "                self.play(FadeIn(marker, DOWN, rate_func=rush_into, run_time=0.5))\n",
        "                self.wait(0.5)\n",
        "\n",
        "            markers[x + y].add(marker)\n",
        "            self.add(markers)\n",
        "\n",
        "            if animate:\n",
        "                self.play(LaggedStart(\n",
        "                    FadeOut(dice[0]),\n",
        "                    bar_group1.animate.set_opacity(0.5),\n",
        "                    FadeOut(dice[1]),\n",
        "                    bar_group2.animate.set_opacity(0.5),\n",
        "                    sum_labels.animate.set_opacity(0.25),\n",
        "                    run_time=0.5\n",
        "                ))\n",
        "            else:\n",
        "                self.wait(0.1)\n",
        "                self.remove(dice)\n",
        "                VGroup(bar_group1, bar_group2).set_opacity(0.5)\n",
        "                sum_labels.set_opacity(0.25)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(markers, lag_ratio=0.01),\n",
        "            bar_group1.animate.set_opacity(1),\n",
        "            bar_group2.animate.set_opacity(1),\n",
        "            sum_labels.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "    def isolate_pairs(self, bar_groups, full_table, *ij_tuples):\n",
        "        full_table.set_opacity(0.25)\n",
        "        full_table[2].set_fill(opacity=0)\n",
        "        bar_groups.set_opacity(0.35)\n",
        "\n",
        "        for i, j in ij_tuples:\n",
        "            im1 = i - 1\n",
        "            jm1 = j - 1\n",
        "            n = im1 * 6 + jm1\n",
        "\n",
        "            bar_groups[0][im1].set_opacity(1)\n",
        "            bar_groups[1][jm1].set_opacity(1)\n",
        "\n",
        "            full_table[0][im1].set_opacity(1)\n",
        "            full_table[1][jm1].set_opacity(1)\n",
        "            full_table[2][n].set_stroke(opacity=1)\n",
        "            full_table[3][n].set_opacity(1)\n",
        "\n",
        "\n",
        "class ConvolveDiscreteDistributions(SumAlongDiagonal):\n",
        "    long_form = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up two distributions\n",
        "        dist1 = self.dist1\n",
        "        dist2 = self.dist2\n",
        "        blue_dice = get_die_faces(fill_color=BLUE_E, dot_color=WHITE)\n",
        "        red_dice = get_die_faces(fill_color=RED_E, dot_color=WHITE)\n",
        "        top_bars, low_bars = bar_groups = VGroup(\n",
        "            get_bar_group(dist1, self.dist1_colors, blue_dice),\n",
        "            get_bar_group(dist2, self.dist2_colors, red_dice),\n",
        "        )\n",
        "\n",
        "        bar_groups.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        bar_groups.to_edge(LEFT)\n",
        "\n",
        "        self.add(bar_groups)\n",
        "\n",
        "        # Setup the sum distribution\n",
        "        conv_dist = np.convolve(dist1, dist2)\n",
        "        sum_labels = die_sum_labels()\n",
        "        sum_bar_group = get_bar_group(conv_dist, self.sum_colors, sum_labels)\n",
        "        sum_bar_group.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        sum_bar_group.set_y(0)\n",
        "\n",
        "        self.add(sum_bar_group)\n",
        "\n",
        "        # V lines\n",
        "        v_lines = get_bar_dividing_lines(top_bars)\n",
        "        for bar in top_bars:\n",
        "            v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "            v_line.set_stroke(GREY_C, 1, 0.75)\n",
        "            v_line.set_x(bar.get_left()[0])\n",
        "            v_line.set_y(0)\n",
        "            v_lines.add(v_line)\n",
        "        v_lines.add(v_lines[-1].copy().set_x(top_bars.get_right()[0]))\n",
        "\n",
        "        # Flip\n",
        "        low_bars.target = low_bars.generate_target()\n",
        "        low_bars.target.arrange(LEFT, aligned_edge=DOWN, buff=0).move_to(low_bars)\n",
        "        low_bars.target.move_to(low_bars)\n",
        "\n",
        "        rect = SurroundingRectangle(low_bars)\n",
        "        label = Text(\"Flip this\")\n",
        "        label.next_to(rect, RIGHT)\n",
        "\n",
        "        low_arrow = Arrow(low_bars.get_right(), low_bars.get_left())\n",
        "        low_arrow.set_stroke(color=YELLOW)\n",
        "        low_arrow.next_to(low_bars, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(low_bars, path_arc=PI / 3, lag_ratio=0.005)\n",
        "        )\n",
        "        self.play(ShowCreation(low_arrow), FadeOut(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(label), FadeOut(low_arrow),\n",
        "            ShowCreation(v_lines, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show corresponding pairs\n",
        "        rows = VGroup(blue_dice, VGroup(*reversed(red_dice))).copy()\n",
        "        pairs = VGroup(*(VGroup(*pair) for pair in zip(*rows)))\n",
        "        self.play(rows.animate.arrange(UP, SMALL_BUFF).next_to(bar_groups, RIGHT))\n",
        "\n",
        "        rows.generate_target()\n",
        "        rows.target.rotate(-90 * DEGREES)\n",
        "        for row in rows.target:\n",
        "            for die in row:\n",
        "                die.rotate(90 * DEGREES)\n",
        "        rows.target.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        rows.target.set_height(5)\n",
        "        rows.target.next_to(bar_groups, RIGHT, buff=1)\n",
        "\n",
        "        sum_bar_group.generate_target()\n",
        "        sum_bar_group.target.set_opacity(0.25)\n",
        "        sum_bar_group.target[7 - 2].set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rows, run_time=2),\n",
        "            MoveToTarget(sum_bar_group),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go through all pairs\n",
        "        last_rect = VMobject()\n",
        "        for n in [*range(6), *range(4, -1, -1)]:\n",
        "            pair = pairs[n]\n",
        "            rect = SurroundingRectangle(pair)\n",
        "            rect.round_corners()\n",
        "            bar_groups.generate_target()\n",
        "            bar_groups.target.set_opacity(0.35)\n",
        "            bar_groups.target[0][n].set_opacity(1)\n",
        "            bar_groups.target[1][5 - n].set_opacity(1)\n",
        "            self.play(\n",
        "                FadeIn(rect),\n",
        "                FadeOut(last_rect),\n",
        "                MoveToTarget(bar_groups),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_rect), bar_groups.animate.set_opacity(1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(pairs), sum_bar_group.animate.set_opacity(1))\n",
        "\n",
        "        # March!\n",
        "        for bars in bar_groups:\n",
        "            for i, bar in zip(it.count(1), bars):\n",
        "                bar.index = i\n",
        "\n",
        "        for n in [7, 5, *range(2, 13)]:\n",
        "            sum_bar_group.generate_target()\n",
        "            sum_bar_group.target.set_opacity(0.25)\n",
        "            sum_bar_group.target[n - 2].set_opacity(1.0)\n",
        "\n",
        "            self.play(\n",
        "                get_row_shift(top_bars, low_bars, n),\n",
        "                MoveToTarget(sum_bar_group),\n",
        "            )\n",
        "            pairs = get_aligned_pairs(top_bars, low_bars, n)\n",
        "\n",
        "            label_pairs = VGroup(*(VGroup(m1.value_label, m2.value_label) for m1, m2 in pairs))\n",
        "            die_pairs = VGroup(*(VGroup(m1.die, m2.die) for m1, m2 in pairs))\n",
        "            pair_rects = VGroup(*(\n",
        "                SurroundingRectangle(pair, buff=0.05).set_stroke(YELLOW, 2).round_corners()\n",
        "                for pair in pairs\n",
        "            ))\n",
        "            pair_rects.set_stroke(YELLOW, 2)\n",
        "            for rect in pair_rects:\n",
        "                rect.set_width(label_pairs[0].get_width() + 0.125, stretch=True)\n",
        "\n",
        "            fade_anims = []\n",
        "\n",
        "            # Spell out the full dot product\n",
        "            products = VGroup()\n",
        "            die_pair_targets = VGroup()\n",
        "            for die_pair in die_pairs:\n",
        "                product = VGroup(\n",
        "                    p_mob(die_pair[0]),\n",
        "                    p_mob(die_pair[1]),\n",
        "                )\n",
        "                product.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "                die_pair_targets.add(VGroup(\n",
        "                    product[0].arg,\n",
        "                    product[1].arg,\n",
        "                ))\n",
        "                products.add(product)\n",
        "\n",
        "            products.arrange(DOWN, buff=0.75)\n",
        "            products.move_to(midpoint(sum_bar_group.get_left(), bar_groups.get_right()))\n",
        "            products.shift(2 * UP).shift_onto_screen()\n",
        "            plusses = Tex(\"+\", font_size=48).replicate(len(pairs))\n",
        "            plusses[-1].scale(0).set_opacity(0)\n",
        "            for plus, lp1, lp2 in zip(plusses, products, products[1:]):\n",
        "                plus.move_to(VGroup(lp1, lp2))\n",
        "\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(products),\n",
        "                ShowIncreasingSubsets(plusses),\n",
        "                ShowIncreasingSubsets(pair_rects),\n",
        "                run_time=0.35 * len(products)\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "\n",
        "            prod_group = VGroup(*products, *plusses)\n",
        "            mover = prod_group.copy()\n",
        "            mover.sort(lambda p: -p[1])\n",
        "            mover.generate_target()\n",
        "            mover.target.set_opacity(0)\n",
        "            for mob in mover.target:\n",
        "                mob.replace(sum_bar_group[n - 2].value_label, stretch=True)\n",
        "            self.play(MoveToTarget(mover, remover=True, lag_ratio=0.002))\n",
        "            self.wait(0.5)\n",
        "            self.play(\n",
        "                FadeOut(prod_group),\n",
        "                FadeOut(pair_rects),\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            get_row_shift(top_bars, low_bars, 7),\n",
        "            sum_bar_group.animate.set_opacity(1.0),\n",
        "            run_time=0.5\n",
        "        )\n",
        "\n",
        "        # Distribution labels\n",
        "        plabel_kw = dict(tex_to_color_map={\"X\": BLUE, \"Y\": RED})\n",
        "        PX = Tex(\"P_X\", **plabel_kw)\n",
        "        PY = Tex(\"P_Y\", **plabel_kw)\n",
        "        PXY = Tex(\"P_{X + Y}\", **plabel_kw)\n",
        "\n",
        "        PX.next_to(top_bars.get_corner(UR), DR)\n",
        "        PY.next_to(low_bars.get_corner(UR), DR)\n",
        "        PXY.next_to(sum_bar_group, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        # Function label\n",
        "        func_label = Text(\"Function\", font_size=36)\n",
        "        func_label.next_to(PX, UP, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        func_label.shift_onto_screen(buff=SMALL_BUFF)\n",
        "        arrow = Arrow(func_label, PX.get_top(), buff=0.2)\n",
        "        VGroup(func_label, arrow).set_color(YELLOW)\n",
        "        x_args = VGroup(*(\n",
        "            Tex(\n",
        "                f\"({x}) = {np.round(dist1[x - 1], 2)}\"\n",
        "            ).next_to(PX, RIGHT, SMALL_BUFF)\n",
        "            for x in range(1, 7)\n",
        "        ))\n",
        "\n",
        "        # Die rectangles\n",
        "        die_rects = VGroup()\n",
        "        value_rects = VGroup()\n",
        "        for index, x_arg in enumerate(x_args):\n",
        "            x_die = top_bars[index].die\n",
        "            value_label = top_bars[index].value_label\n",
        "            die_rect = SurroundingRectangle(x_die, buff=SMALL_BUFF)\n",
        "            value_rect = SurroundingRectangle(value_label, buff=SMALL_BUFF)\n",
        "            for rect in die_rect, value_rect:\n",
        "                rect.set_stroke(YELLOW, 2).round_corners()\n",
        "            die_rects.add(die_rect)\n",
        "            value_rects.add(value_rect)\n",
        "\n",
        "        index = 2\n",
        "        x_arg = x_args[index]\n",
        "        die_rect = die_rects[index]\n",
        "        value_rect = value_rects[index]\n",
        "        x_die = top_bars[index].die\n",
        "        value_label = top_bars[index].value_label\n",
        "\n",
        "        # Describe the distribution as a function\n",
        "        top_rect = SurroundingRectangle(top_bars)\n",
        "        top_rect.set_stroke(BLUE, 3)\n",
        "        top_rect.round_corners(radius=0.25)\n",
        "\n",
        "        self.play(ShowCreation(top_rect))\n",
        "        self.play(\n",
        "            Write(PX),\n",
        "            Write(func_label),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(ShowCreation(die_rect), FadeOut(top_rect))\n",
        "        self.play(FadeTransform(x_die.copy(), x_arg[:3]))\n",
        "        self.play(TransformFromCopy(die_rect, value_rect))\n",
        "        self.play(FadeTransform(value_label.copy(), x_arg[3:]))\n",
        "        self.wait()\n",
        "        for i in range(6):\n",
        "            self.remove(*die_rects, *value_rects, *x_args)\n",
        "            self.add(die_rects[i], value_rects[i], x_args[i])\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Label other distribution functions\n",
        "        func_group = VGroup(func_label, arrow)\n",
        "        func_group_Y = func_group.copy().shift(PY.get_center() - PX.get_center())\n",
        "        func_group_XY = func_group.copy().shift(PXY.get_center() - PX.get_center())\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(func_group, func_group_Y),\n",
        "            Write(PY),\n",
        "            FadeOut(die_rects[-1]),\n",
        "            FadeOut(value_rects[-1])\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(func_group, func_group_XY),\n",
        "            Write(PXY),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            func_group, func_group_Y, func_group_XY, x_args[-1]\n",
        "        )))\n",
        "\n",
        "        # Label convolution\n",
        "        sum_bar_group.generate_target()\n",
        "        sum_bar_group.target.shift(DOWN)\n",
        "        conv_def = Tex(\n",
        "            R\"\\big[P_X * P_Y\\big](s) = \\sum_{x = 1}^6 P_X(x) \\cdot P_Y(s - x)\",\n",
        "            font_size=36,\n",
        "            isolate=[\"x = 1\", \"6\"],\n",
        "            **plabel_kw,\n",
        "        )\n",
        "        conv_def.next_to(sum_bar_group.target, UP, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        PXY_arg = Tex(\"(s)\", font_size=36)\n",
        "        PXY.generate_target()\n",
        "        lhs = conv_def[:10]\n",
        "        PXY.target.next_to(lhs, UP, LARGE_BUFF).shift_onto_screen(buff=SMALL_BUFF)\n",
        "        PXY_arg.next_to(PXY.target, RIGHT, buff=SMALL_BUFF)\n",
        "        eq = Tex(\"=\").rotate(90 * DEGREES)\n",
        "        eq.move_to(midpoint(PXY.target.get_bottom(), lhs.get_top()))\n",
        "\n",
        "        conv_rect = SurroundingRectangle(conv_def[\"P_X * P_Y\"], buff=0.05)\n",
        "        conv_rect.set_stroke(YELLOW, 2)\n",
        "        conv_word = Text(\"Convolution\")\n",
        "        conv_word.match_color(conv_rect)\n",
        "        conv_word.next_to(conv_rect, DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(sum_bar_group),\n",
        "            MoveToTarget(PXY),\n",
        "            FadeIn(PXY_arg, UP),\n",
        "            Write(eq),\n",
        "            TransformFromCopy(PX, lhs[1:3]),\n",
        "            TransformFromCopy(PY, lhs[4:6]),\n",
        "            Write(VGroup(lhs[0], lhs[3], *lhs[6:])),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(conv_word),\n",
        "            ShowCreation(conv_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            conv_rect.animate.become(SurroundingRectangle(conv_def[\"*\"], buff=0.05, stroke_width=1))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(conv_word), FadeOut(conv_rect))\n",
        "\n",
        "        self.add(conv_def)\n",
        "        conv_def[10:].set_opacity(0)\n",
        "\n",
        "        # Question right hand side\n",
        "        question_rhs = Text(\"= (What formula goes here?)\", font_size=30)\n",
        "        question_rhs.next_to(conv_def[:10], RIGHT)\n",
        "        self.play(Write(question_rhs))\n",
        "        self.wait()\n",
        "\n",
        "        # Show example input of 4\n",
        "        ex_rhs = Tex(R\"(4) = P_{-}(1)P_{-}(3) + P_{-}(2)P_{-}(2) + P_{-}(3)P_{-}(1)\")\n",
        "        ex_rhs.scale(0.9)\n",
        "        ex_rhs.next_to(PXY, RIGHT, buff=0.1)\n",
        "        for n, dot in enumerate(ex_rhs[\"-\"]):\n",
        "            even = n % 2 == 0\n",
        "            substr = Tex(\"X\" if even else \"Y\", font_size=24)\n",
        "            substr.set_color(BLUE if even else RED)\n",
        "            substr.move_to(dot)\n",
        "            dot[0].become(substr)\n",
        "            ex_rhs[ex_rhs.submobjects.index(dot[0]) + 2].match_color(substr)\n",
        "\n",
        "        PXY_copy = PXY.copy()\n",
        "        PXY_copy.generate_target()\n",
        "        VGroup(PXY_copy.target, ex_rhs).to_edge(RIGHT, buff=-0.5)\n",
        "\n",
        "        eq.generate_target()\n",
        "        eq.target.rotate(-90 * DEGREES)\n",
        "        eq.target.next_to(conv_def, LEFT)\n",
        "\n",
        "        PXY.generate_target()\n",
        "        PXY.target.next_to(eq.target, LEFT)\n",
        "        VGroup(PXY.target, eq.target).align_to(PXY_copy.target, LEFT)\n",
        "\n",
        "        example_box = SurroundingRectangle(VGroup(PXY_copy.target, ex_rhs))\n",
        "        example_box.set_stroke(TEAL, 1)\n",
        "        example_words = Text(\"For example\")\n",
        "        example_words.match_color(example_box)\n",
        "        example_words.next_to(example_box, UP)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(PXY_copy),\n",
        "            MoveToTarget(eq),\n",
        "            MoveToTarget(PXY),\n",
        "            Transform(PXY_arg, ex_rhs[\"(4)\"], remover=True),\n",
        "            conv_def.animate.next_to(eq.target, RIGHT),\n",
        "            MaintainPositionRelativeTo(question_rhs, conv_def),\n",
        "            FadeIn(ex_rhs, LEFT),\n",
        "            PX.animate.next_to(bar_groups[0], LEFT),\n",
        "            PY.animate.next_to(bar_groups[1], LEFT),\n",
        "            self.frame.animate.set_height(9).move_to(0.5 * UP),\n",
        "            sum_bar_group.animate.shift(0.5 * DOWN),\n",
        "            ShowCreation(example_box),\n",
        "            FadeIn(example_words, UP),\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        example = VGroup(PXY_copy, ex_rhs)\n",
        "        self.add(example)\n",
        "\n",
        "        # Cycle through cases\n",
        "        example_box.save_state()\n",
        "        for part in ex_rhs[re.compile(R\"P[^+]*P[^+]*\\)\")]:\n",
        "            self.play(\n",
        "                example_box.animate.replace(part, stretch=True).scale(1.1).set_stroke(width=2),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(FadeOut(example_box))\n",
        "        self.wait()\n",
        "\n",
        "        # Show full definition\n",
        "        general_words = Text(\"In general\")\n",
        "        general_words.next_to(conv_def, UP)\n",
        "        general_words.match_x(example_words)\n",
        "        general_words.set_color(TEAL)\n",
        "\n",
        "        example_words.generate_target()\n",
        "        example_words.target.scale(0.75)\n",
        "        example_words.target.set_y(4.5)\n",
        "        example_words.target.set_color(GREY_B)\n",
        "\n",
        "        conv_def.set_opacity(1)\n",
        "        self.play(\n",
        "            Write(conv_def[10:]),\n",
        "            FadeOut(question_rhs, DOWN),\n",
        "            FadeIn(general_words, DOWN),\n",
        "            MoveToTarget(example_words),\n",
        "            example.animate.scale(0.75).next_to(example_words.target, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Talk through formula\n",
        "        s_arrow = Vector(0.5 * DOWN, stroke_color=YELLOW)\n",
        "        s_arrow.next_to(conv_def[\"s\"][0], UP, SMALL_BUFF)\n",
        "        x_arrow, y_arrow = s_arrow.replicate(2)\n",
        "        x_arrow.next_to(conv_def[\"x\"][1], UP, SMALL_BUFF)\n",
        "        y_arrow.next_to(conv_def[\"s - x\"], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(GrowArrow(s_arrow))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(s_arrow, x_arrow),\n",
        "            TransformFromCopy(s_arrow, y_arrow),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        xeq1 = conv_def[\"x = 1\"]\n",
        "        y_arrow.save_state()\n",
        "        self.play(\n",
        "            s_arrow.animate.scale(0.75).rotate(90 * DEGREES).next_to(xeq1, LEFT, SMALL_BUFF),\n",
        "            y_arrow.animate.scale(0.75).rotate(-90 * DEGREES).next_to(xeq1, RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            s_arrow.animate.next_to(conv_def[\"6\"], LEFT, SMALL_BUFF),\n",
        "            y_arrow.animate.next_to(conv_def[\"6\"], RIGHT, SMALL_BUFF),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(y_arrow),\n",
        "            FadeOut(s_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(FadeOut(x_arrow), FadeOut(y_arrow)))\n",
        "\n",
        "        # Show zero'd example\n",
        "        bar_groups.generate_target()\n",
        "        bar_groups.target.scale(2 / 3, about_point=top_bars.get_top() + UP)\n",
        "\n",
        "        example_words = TexText(\"Plugging in $s = 4$\")\n",
        "        example_words.next_to(conv_def, DOWN, buff=1.0)\n",
        "\n",
        "        example = Tex(\n",
        "            R\"\"\"\n",
        "            [P_X * P_Y](4) =\n",
        "            &P_X(1) \\cdot P_Y(3) \\; + \\\\\n",
        "            &P_X(2) \\cdot P_Y(2) \\; + \\\\\n",
        "            &P_X(3) \\cdot P_Y(1) \\; + \\\\\n",
        "            &P_X(4) \\cdot P_Y(0) \\; + \\\\\n",
        "            &P_X(5) \\cdot P_Y(-1) \\; + \\\\\n",
        "            &P_X(6) \\cdot P_Y(-2)\n",
        "            \"\"\", \n",
        "            t2c={\n",
        "                \"X\": BLUE,\n",
        "                \"Y\": RED,\n",
        "            },\n",
        "            font_size=36\n",
        "        )\n",
        "        example.next_to(example_words, DOWN, buff=0.5)\n",
        "\n",
        "        summands = VGroup(*(\n",
        "            example[Rf\"P_X({x}) \\cdot P_Y({4 - x})\"]\n",
        "            for x in range(1, 7)\n",
        "        ))\n",
        "        plusses = example[\"+\"]\n",
        "        plusses.shift(SMALL_BUFF * RIGHT)\n",
        "        plusses.add(VectorizedPoint(summands[-1].get_center()))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(example[R\"[P_X * P_Y](4) =\"]),\n",
        "            FadeOut(v_lines),\n",
        "            MoveToTarget(bar_groups),\n",
        "            MaintainPositionRelativeTo(PX, bar_groups[0]),\n",
        "            Write(example_words),\n",
        "            PY.animate.next_to(bar_groups.target[1], RIGHT).match_x(PX),\n",
        "            sum_bar_group.animate.scale(0.5).next_to(bar_groups.target, DOWN, buff=0.75, aligned_edge=LEFT),\n",
        "        )\n",
        "        last_rect = VectorizedPoint(summands[0].get_center())\n",
        "        for x, summand, plus in zip(it.count(1), summands, plusses):\n",
        "            rect = SurroundingRectangle(VGroup(summand, plus))\n",
        "            rect.set_stroke(BLUE, 2)\n",
        "            rect.round_corners()\n",
        "            rect.add(Tex(Rf\"x = {x}\").next_to(rect, DOWN, SMALL_BUFF))\n",
        "            self.play(\n",
        "                FadeTransform(\n",
        "                    conv_def[R\"P_X(x) \\cdot P_Y(s - x)\"].copy(),\n",
        "                    summand,\n",
        "                ),\n",
        "                FadeTransform(last_rect, rect),\n",
        "                FadeIn(plus),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            self.wait()\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_rect))\n",
        "\n",
        "        # Highlight zeros\n",
        "        zeroed_terms = VGroup(*(\n",
        "            example[Rf\"P_Y({n})\"]\n",
        "            for n in range(0, -4, -1)\n",
        "        ))\n",
        "        zeroed_rect = SurroundingRectangle(zeroed_terms)\n",
        "        zeroed_rect.set_stroke(RED, 3)\n",
        "        zeroed_rect.stretch(1.3, 0, about_edge=LEFT)\n",
        "        zeroed_rect.round_corners()\n",
        "\n",
        "        eq_zero = Tex(\"= 0\")\n",
        "        eq_zero.next_to(zeroed_rect, RIGHT)\n",
        "        eq_zero.set_color(RED)\n",
        "\n",
        "        self.play(ShowCreation(zeroed_rect))\n",
        "        self.wait()\n",
        "        self.play(Write(eq_zero))\n",
        "        self.play(\n",
        "            summands[3:].animate.set_opacity(0.35),\n",
        "            plusses[3:].animate.set_opacity(0.35),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_bars_creation(self, bars, lag_ratio=0.05, run_time=3):\n",
        "        anims = []\n",
        "        for bar in bars:\n",
        "            rect, num, face = bar\n",
        "            num.rect = rect\n",
        "            rect.save_state()\n",
        "            rect.stretch(0, 1, about_edge=DOWN)\n",
        "            rect.set_opacity(0)\n",
        "\n",
        "            anims.extend([\n",
        "                FadeIn(face),\n",
        "                rect.animate.restore(),\n",
        "                CountInFrom(num, 0),\n",
        "                UpdateFromAlphaFunc(num, lambda m, a: m.next_to(m.rect, UP, SMALL_BUFF).set_opacity(a)),\n",
        "            ])\n",
        "\n",
        "        return LaggedStart(*anims, lag_ratio=lag_ratio, run_time=run_time)\n",
        "\n",
        "\n",
        "class ShowConvolutionOfLists(SumAlongDiagonal):\n",
        "    def construct(self):\n",
        "        # Set up two distributions\n",
        "        dist1 = self.dist1\n",
        "        dist2 = self.dist2\n",
        "        conv_dist = np.convolve(dist1, dist2)\n",
        "        kw = dict(height=1.5)\n",
        "        blue_bars, red_bars, sum_bars = bar_groups = VGroup(\n",
        "            get_bar_group(dist1, self.dist1_colors, **kw),\n",
        "            get_bar_group(dist2, self.dist2_colors, **kw),\n",
        "            get_bar_group(conv_dist, self.sum_colors, **kw),\n",
        "        )\n",
        "\n",
        "        # Create equation\n",
        "        parens = Tex(\"()()\")\n",
        "        parens.stretch(2, 1)\n",
        "        parens.match_height(bar_groups)\n",
        "        asterisk = Tex(\"*\", font_size=96)\n",
        "        equation = VGroup(\n",
        "            parens[0], blue_bars, parens[1],\n",
        "            asterisk,\n",
        "            parens[2], red_bars, parens[3],\n",
        "            Tex(\"=\", font_size=96),\n",
        "            sum_bars,\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.to_edge(UP, buff=1.0)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.remove(sum_bars)\n",
        "        self.play(\n",
        "            TransformFromCopy(blue_bars, sum_bars, lag_ratio=0.003),\n",
        "            TransformFromCopy(red_bars, sum_bars, lag_ratio=0.003),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name operation\n",
        "        arrow = Vector(0.5 * DOWN)\n",
        "        arrow.next_to(asterisk, UP)\n",
        "        name = Text(\"Convolution\", font_size=60)\n",
        "        name.next_to(arrow, UP)\n",
        "        VGroup(arrow, name).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(name),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.play(FlashAround(asterisk))\n",
        "        self.wait()\n",
        "\n",
        "        # Lists of numbers vs functions\n",
        "        list_words = Text(\"List of numbers\", font_size=36).replicate(3)\n",
        "        func_words = Text(\"Function\", font_size=36).replicate(3)\n",
        "        crosses = VGroup()\n",
        "        for list_word, func_word, bar_group in zip(list_words, func_words, bar_groups):\n",
        "            list_word.next_to(bar_group, DOWN)\n",
        "            func_word.next_to(bar_group, DOWN)\n",
        "            crosses.add(Cross(list_word))\n",
        "\n",
        "        for list_word, bar_group in zip(list_words, bar_groups):\n",
        "            self.play(\n",
        "                FadeIn(list_word, DOWN),\n",
        "                LaggedStart(*(\n",
        "                    FlashAround(bar[2], time_width=1.5, buff=0.05)\n",
        "                    for bar in bar_group\n",
        "                ), lag_ratio=0.03, run_time=2)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, crosses, lag_ratio=0.1, run_time=1))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, func_words, shift=0.5 * DOWN, scale=0.5, lag_ratio=0.5),\n",
        "            list_words.animate.shift(0.5 * DOWN),\n",
        "            crosses.animate.shift(0.5 * DOWN),n\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Cycle through appropriate pairs\n",
        "        for s in range(len(sum_bars)):\n",
        "            bar_groups.set_opacity(0.75)\n",
        "            sum_bars[s].set_opacity(1)\n",
        "            for x in range(len(blue_bars)):\n",
        "                bar_groups[:2].set_opacity(0.75)\n",
        "                y = s - x\n",
        "                if 0 <= y < len(red_bars):\n",
        "                    blue_bars[x].set_opacity(1)\n",
        "                    red_bars[y].set_opacity(1)\n",
        "                    self.wait(0.25)\n",
        "            self.wait(0.5)\n",
        "        self.play(bar_groups.animate.set_opacity(1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ConvolveMatchingDiscreteDistributions(ConvolveDiscreteDistributions):\n",
        "    dist1 = EXP_DISTRIBUTION\n",
        "    dist2 = EXP_DISTRIBUTION\n",
        "\n",
        "\n",
        "class RepeatedDiscreteConvolutions(InteractiveScene):\n",
        "    distribution = EXP_DISTRIBUTION\n",
        "\n",
        "    def construct(self):\n",
        "        # Divide up space\n",
        "        h_lines = Line(LEFT, RIGHT).set_width(FRAME_WIDTH).replicate(4)\n",
        "        h_lines.arrange(DOWN, buff=FRAME_HEIGHT / 3).center()\n",
        "        h_lines.set_stroke(WHITE, 1)\n",
        "        self.add(h_lines[1:3])\n",
        "\n",
        "        # Initial distributions\n",
        "        dist = self.distribution\n",
        "        top_bars = self.get_bar_group(dist, colors=(BLUE, TEAL))\n",
        "        top_bars.next_to(h_lines[1], UP, SMALL_BUFF)\n",
        "\n",
        "        low_bars = top_bars.copy()\n",
        "        low_bars.set_y(-top_bars.get_y())\n",
        "        low_bars.next_to(h_lines[2], UP, SMALL_BUFF)\n",
        "\n",
        "        VGroup(top_bars, low_bars).shift(2 * LEFT)\n",
        "\n",
        "        self.add(top_bars)\n",
        "        self.add(low_bars)\n",
        "\n",
        "        # Add labels\n",
        "\n",
        "        # Repeated convolution\n",
        "        self.flip_bar_group(low_bars)\n",
        "        low_bars.save_state()\n",
        "        for n in range(5):\n",
        "            new_bars = self.show_convolution(top_bars, low_bars)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                new_bars.animate.move_to(top_bars, DL).set_anim_args(path_arc=-120 * DEGREES),\n",
        "                FadeOut(top_bars, UP),\n",
        "                Restore(low_bars),\n",
        "            )\n",
        "            # TODO, things with labels\n",
        "\n",
        "            top_bars = new_bars\n",
        "\n",
        "    def get_bar_group(\n",
        "        self, \n",
        "        dist, \n",
        "        colors=(BLUE, TEAL), \n",
        "        y_unit=4,\n",
        "        bar_width=0.35,\n",
        "        num_decimal_places=2,\n",
        "        min_value=1,\n",
        "    ):\n",
        "        bars = self.get_bars(dist, colors, y_unit, bar_width)\n",
        "        result = VGroup(\n",
        "            bars,\n",
        "            self.get_bar_value_labels(bars, min_value),\n",
        "            self.get_bar_prob_labels(bars, dist, num_decimal_places),\n",
        "        )\n",
        "        result.dist = dist\n",
        "        return result\n",
        "\n",
        "    def get_bars(self, dist, colors=(BLUE, TEAL), y_unit=4, bar_width=0.35):\n",
        "        axes = Axes(\n",
        "            (0, len(dist)), (0, 1),\n",
        "            height=y_unit,\n",
        "            width=bar_width * len(dist)\n",
        "        )\n",
        "        bars = ChartBars(axes, dist, fill_opacity=0.75)\n",
        "        bars.set_submobject_colors_by_gradient(*colors)\n",
        "        return bars\n",
        "\n",
        "    def get_bar_value_labels(self, bars, min_value=1):\n",
        "        values = VGroup(*(\n",
        "            Integer(x + min_value, font_size=16)\n",
        "            for x in range(len(bars))\n",
        "        ))\n",
        "        for bar, value in zip(bars, values):\n",
        "            value.next_to(bar, DOWN, SMALL_BUFF)\n",
        "\n",
        "        return values\n",
        "\n",
        "    def get_bar_prob_labels(self, bars, dist, num_decimal_places=2):\n",
        "        probs = VGroup(*(\n",
        "            DecimalNumber(p, font_size=16, num_decimal_places=num_decimal_places)\n",
        "            for p in dist\n",
        "        ))\n",
        "        for bar, prob in zip(bars, probs):\n",
        "            prob.set_max_width(0.75 * bar.get_width())\n",
        "            prob.next_to(bar, UP, SMALL_BUFF)\n",
        "\n",
        "        return probs\n",
        "\n",
        "    def get_dist_label(self, indices):\n",
        "        index_strs = [f\"X_{{{i}}}\" for i in indices]\n",
        "        if len(indices) > 3:\n",
        "            index_strs = [index_strs[0], R\"\\cdots\", index_strs[-1]]\n",
        "        sub_tex = \"+\".join(index_strs)\n",
        "        return Tex(f\"P_{{{sub_tex}}}\")\n",
        "\n",
        "    def flip_bar_group(self, bar_group):\n",
        "        bars = bar_group[0]\n",
        "        bars.target = bars.generate_target()\n",
        "        bars.target.arrange(LEFT, buff=0, aligned_edge=DOWN)\n",
        "        bars.target.align_to(bars[0], DR)\n",
        "        self.play(\n",
        "            MoveToTarget(bars, lag_ratio=0.05, path_arc=0.5),\n",
        "            *(\n",
        "                MaintainPositionRelativeTo(\n",
        "                    VGroup(value, prob), bar\n",
        "                )\n",
        "                for bar, value, prob in zip(*bar_group)\n",
        "            ),\n",
        "        )\n",
        "        self.add(bar_group)\n",
        "\n",
        "    def show_convolution(self, top_bars, low_bars):\n",
        "        # New bars\n",
        "        new_dist = np.convolve(top_bars.dist, low_bars.dist)\n",
        "        new_bars = self.get_bar_group(\n",
        "            new_dist,\n",
        "            y_unit=8,\n",
        "            num_decimal_places=3,\n",
        "            min_value=top_bars[1][0].get_value() + low_bars[1][0].get_value(),\n",
        "        )\n",
        "        new_bars.next_to(BOTTOM, UP)\n",
        "        new_bars.align_to(top_bars, LEFT)\n",
        "\n",
        "        # March!\n",
        "        for n in range(len(new_bars[0])):\n",
        "            x_diff = top_bars[0][0].get_x() - low_bars[0][0].get_x()\n",
        "            x_diff += low_bars[0][0].get_width() * n\n",
        "            self.play(\n",
        "                low_bars.animate.shift(x_diff * RIGHT),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            index_pairs = [\n",
        "                (k, n - k) for k in range(n + 1)\n",
        "                if 0 <= n - k < len(low_bars[0])\n",
        "                if 0 <= k < len(top_bars[0])\n",
        "            ]\n",
        "            highlights = VGroup(*(\n",
        "                VGroup(top_bars[0][i].copy(), low_bars[0][j].copy())\n",
        "                for i, j in index_pairs\n",
        "            ))\n",
        "            highlights.set_color(YELLOW)\n",
        "\n",
        "            conv_rect, value_label, prob_label = (group[n] for group in new_bars)\n",
        "            partial_rects = VGroup()\n",
        "            partial_labels = VGroup()\n",
        "\n",
        "            products = [top_bars.dist[i] * low_bars.dist[j] for i, j in index_pairs]\n",
        "            for partial_value in np.cumsum(products):\n",
        "                rect = conv_rect.copy()\n",
        "                rect.stretch(\n",
        "                    partial_value / new_bars.dist[n],\n",
        "                    dim=1,\n",
        "                    about_edge=DOWN,\n",
        "                )\n",
        "                label = prob_label.copy()\n",
        "                label.set_value(partial_value)\n",
        "                label.next_to(rect, UP, SMALL_BUFF)\n",
        "                partial_rects.add(rect)\n",
        "                partial_labels.add(label)\n",
        "\n",
        "            self.add(value_label)\n",
        "            self.play(\n",
        "                ShowSubmobjectsOneByOne(highlights, remover=True),\n",
        "                ShowSubmobjectsOneByOne(partial_rects, remover=True),\n",
        "                ShowSubmobjectsOneByOne(partial_labels, remover=True),\n",
        "                run_time=0.15 * len(products)\n",
        "            )\n",
        "            self.add(*(group[:n + 1] for group in new_bars))\n",
        "            self.wait(0.5)\n",
        "\n",
        "        return new_bars\n"
    ]
}