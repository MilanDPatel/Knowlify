{
    "topic": "demonstrates the extraction of frames from a video file and their display in a grid",
    "code": [
        "import cv2\n",
        "from pathlib import Path\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class ExtractFramesFromFootage(InteractiveScene):\n",
        "    video_file = \"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2024/holograms/SceneModel/MultiplePOVs.2.mp4\"\n",
        "    image_dir = \"/tmp/\"\n",
        "    frequency = 0.25\n",
        "    start_time = 0\n",
        "    end_time = 14\n",
        "    small_image_size = (1080, 1080)\n",
        "    n_cols = 8\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        # Open the video file\n",
        "        self.video = cv2.VideoCapture(self.video_file)\n",
        "        self.video_fps = self.video.get(cv2.CAP_PROP_FPS)\n",
        "        self.video_duration = self.video.get(cv2.CAP_PROP_FRAME_COUNT) / self.video_fps\n",
        "\n",
        "    def tear_down(self):\n",
        "        super().tear_down()\n",
        "        self.video.release()\n",
        "\n",
        "    def construct(self):\n",
        "        video_box = Square()\n",
        "        video_box.set_height(4)\n",
        "        video_box.to_edge(LEFT)\n",
        "        video_box.set_stroke(WHITE, 0.0)\n",
        "        self.add(video_box)\n",
        "\n",
        "        # Collect images\n",
        "        start_time = self.start_time\n",
        "        end_time = min(self.end_time, self.video_duration)\n",
        "        times = np.arange(start_time, end_time, self.frequency)\n",
        "        images = Group()\n",
        "        for time in ProgressDisplay(times, desc=\"Loading images\"):\n",
        "            image = self.image_from_timestamp(time)\n",
        "            if image is not None:\n",
        "                border = SurroundingRectangle(image, buff=0)\n",
        "                border.set_stroke(WHITE, 1)\n",
        "                images.add(Group(border, image))\n",
        "\n",
        "        # Show clip extraction\n",
        "        images.arrange_in_grid(n_cols=self.n_cols, buff=0.1 * images[0].get_width())\n",
        "        images.set_width(FRAME_WIDTH - video_box.get_width() - 1.5)\n",
        "        images.to_corner(UR, buff=0.25)\n",
        "        flash = video_box.copy()\n",
        "        flash.set_fill(WHITE, 0.25)\n",
        "\n",
        "        for image in images:\n",
        "            self.add(image)\n",
        "            self.play(FadeOut(flash, run_time=self.frequency / 2))\n",
        "            self.wait(self.frequency / 2)\n",
        "\n",
        "        # Add still\n",
        "        still_image = images[-1].copy()\n",
        "        still_image.replace(video_box)\n",
        "        self.add(still_image)\n",
        "        self.wait()\n",
        "\n",
        "        # Do something to zoom in on example frames\n",
        "\n",
        "    def image_from_timestamp(self, time):\n",
        "        video_name = Path(self.video_file).stem\n",
        "        file_name = Path(self.image_dir, f\"{video_name}_{time}.png\")\n",
        "\n",
        "        frame_number = int(time * self.video_fps)\n",
        "        self.video.set(cv2.CAP_PROP_POS_FRAMES, frame_number)\n",
        "        ret, frame = self.video.read()\n",
        "        if not ret:\n",
        "            print(f\"Failed to capture at {time}\")\n",
        "            return\n",
        "        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n",
        "        pil_image = Image.fromarray(rgb_frame)\n",
        "        small_image = pil_image.resize(self.small_image_size, Image.LANCZOS)\n",
        "        small_image.save(file_name)\n",
        "\n",
        "        return ImageMobject(file_name)\n"
    ]
}