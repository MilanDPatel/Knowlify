{
    "topic": "demonstrates the concept of solving a linear system using Cramer's rule.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "X_COLOR = GREEN\n",
        "Y_COLOR = RED\n",
        "Z_COLOR = BLUE\n",
        "OUTPUT_COLOR = YELLOW\n",
        "INPUT_COLOR = MAROON_B\n",
        "\n",
        "\n",
        "OUTPUT_DIRECTORY = \"eola2/cramer\"\n",
        "\n",
        "\n",
        "def get_cramer_matrix(matrix, output_vect, index=0):\n",
        "    \"\"\"\n",
        "    The inputs matrix and output_vect should be Matrix mobjects\n",
        "    \"\"\"\n",
        "    new_matrix = np.array(matrix.mob_matrix)\n",
        "    new_matrix[:, index] = output_vect.mob_matrix[:, 0]\n",
        "    # Create a new Matrix mobject with copies of these entries\n",
        "    result = Matrix(new_matrix, element_to_mobject=lambda m: m.copy())\n",
        "    result.match_height(matrix)\n",
        "    return result\n",
        "\n",
        "\n",
        "class LinearSystem(VGroup):\n",
        "    CONFIG = {\n",
        "        \"matrix_config\": {\n",
        "            \"element_to_mobject\": Integer,\n",
        "        },\n",
        "        \"dimensions\": 3,\n",
        "        \"min_int\": -9,\n",
        "        \"max_int\": 10,\n",
        "        \"height\": 4,\n",
        "    }\n",
        "\n",
        "    def __init__(self, matrix=None, output_vect=None, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        if matrix is None:\n",
        "            dim = self.dimensions\n",
        "            matrix = np.random.randint(\n",
        "                self.min_int,\n",
        "                self.max_int,\n",
        "                size=(dim, dim)\n",
        "            )\n",
        "        else:\n",
        "            dim = len(matrix)\n",
        "        self.matrix_mobject = Matrix(matrix, **self.matrix_config)\n",
        "        self.equals = OldTex(\"=\")\n",
        "        self.equals.scale(1.5)\n",
        "\n",
        "        colors = [X_COLOR, Y_COLOR, Z_COLOR][:dim]\n",
        "        chars = [\"x\", \"y\", \"z\"][:dim]\n",
        "        self.input_vect_mob = Matrix(np.array(chars))\n",
        "        self.input_vect_mob.elements.set_color_by_gradient(*colors)\n",
        "\n",
        "        if output_vect is None:\n",
        "            output_vect = np.random.randint(\n",
        "                self.min_int, self.max_int, size=(dim, 1))\n",
        "        self.output_vect_mob = IntegerMatrix(output_vect)\n",
        "        self.output_vect_mob.elements.set_color(OUTPUT_COLOR)\n",
        "\n",
        "        for mob in self.matrix_mobject, self.input_vect_mob, self.output_vect_mob:\n",
        "            mob.set_height(self.height)\n",
        "\n",
        "        self.add(\n",
        "            self.matrix_mobject,\n",
        "            self.input_vect_mob,\n",
        "            self.equals,\n",
        "            self.output_vect_mob,\n",
        "        )\n",
        "        self.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class AltOpeningQuote(OpeningQuote):\n",
        "    def construct(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"Jerry\": YELLOW,\n",
        "                \"Kramer\": BLUE,\n",
        "            },\n",
        "            \"arg_separator\": \"\",\n",
        "            \"alignment\": \"\",\n",
        "        }\n",
        "        parts = VGroup(\n",
        "            OldTexText(\"Jerry: Ah, you're crazy!\", **kw),\n",
        "            OldTexText(\n",
        "                \"Kramer:\",\n",
        "                \"{} Am I? Or am I so sane that\\\\\\\\\",\n",
        "                \"you just blew your mind?\",\n",
        "                **kw\n",
        "            ),\n",
        "            OldTexText(\"Jerry: It's impossible!\", **kw),\n",
        "            OldTexText(\n",
        "                \"Kramer:\", \"{} Is it?! Or is it so possible\\\\\\\\\",\n",
        "                \"your head is spinning like a top?\",\n",
        "                **kw\n",
        "            )\n",
        "        )\n",
        "        for part in parts[1::2]:\n",
        "            part[-1].align_to(part[-2], LEFT)\n",
        "\n",
        "        parts.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.add(parts[0])\n",
        "        self.play(FadeIn(parts[1], lag_ratio=0.1, run_time=2))\n",
        "        self.play(FadeIn(parts[2], lag_ratio=0))\n",
        "        self.play(FadeIn(parts[3], lag_ratio=0.1, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CramerOpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\": [\"Computers are useless. They \\\\\\\\ can only give you answers.\"],\n",
        "        \"author\": \"Pablo Picasso\",\n",
        "    }\n",
        "\n",
        "\n",
        "class LeaveItToComputers(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        system = LinearSystem(height=3)\n",
        "        system.next_to(self.pi_creatures, UP)\n",
        "        system.generate_target()\n",
        "        system.target.scale(0.5)\n",
        "        system.target.to_corner(UL)\n",
        "\n",
        "        cramer_groups = VGroup()\n",
        "        for i in range(3):\n",
        "            numer_matrix = get_cramer_matrix(\n",
        "                system.matrix_mobject, system.output_vect_mob,\n",
        "                index=i\n",
        "            )\n",
        "            # color = colors[i]\n",
        "            color = YELLOW\n",
        "            VGroup(*numer_matrix.mob_matrix[:, i]).set_color(color)\n",
        "            VGroup(*numer_matrix.mob_matrix[:, i]).set_stroke(color, 1)\n",
        "            numer = VGroup(\n",
        "                get_det_text(numer_matrix, initial_scale_factor=3),\n",
        "                numer_matrix\n",
        "            )\n",
        "            numer.to_corner(UP)\n",
        "            denom_matrix_mobject = system.matrix_mobject.deepcopy()\n",
        "            denom = VGroup(\n",
        "                get_det_text(denom_matrix_mobject, initial_scale_factor=3),\n",
        "                denom_matrix_mobject,\n",
        "            )\n",
        "            rhs = VGroup(numer, Line(LEFT, RIGHT).match_width(numer), denom)\n",
        "            rhs.arrange(DOWN)\n",
        "            rhs.set_height(2.25)\n",
        "            rhs.move_to(self.hold_up_spot, DOWN)\n",
        "            rhs.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "            equals = OldTex(\"=\").next_to(rhs, LEFT)\n",
        "            variable = system.input_vect_mob.elements[i].copy()\n",
        "            variable.next_to(equals, LEFT)\n",
        "            cramer_group = VGroup(variable, equals, rhs)\n",
        "            cramer_group.variable = variable\n",
        "            cramer_group.equals = equals\n",
        "            cramer_group.rhs = rhs\n",
        "            cramer_groups.add(cramer_group)\n",
        "\n",
        "        self.play(\n",
        "            Write(system),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\"pondering\", \"thinking\", \"hooray\")\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                self.teacher, \"Let the computer \\\\\\\\ handle it\",\n",
        "                target_mode=\"shruggie\",\n",
        "            ),\n",
        "            MoveToTarget(system, path_arc=90 * DEGREES),\n",
        "            self.change_students(*[\"confused\"] * 3)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        cg = cramer_groups[0]\n",
        "        scale_factor = 1.5\n",
        "        cg.scale(scale_factor, about_edge=DOWN)\n",
        "        numer, line, denom = cg.rhs\n",
        "        x_copy = system.input_vect_mob.elements[0].copy()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode=\"raise_right_hand\"),\n",
        "            ShowCreation(line),\n",
        "            ReplacementTransform(\n",
        "                system.matrix_mobject.copy(),\n",
        "                denom[1],\n",
        "            ),\n",
        "            Write(denom[0]),\n",
        "            FadeIn(cg.equals),\n",
        "            ReplacementTransform(x_copy, cg.variable),\n",
        "        )\n",
        "        denom_mover = denom.deepcopy()\n",
        "        denom_mover.target = numer.deepcopy()\n",
        "        column1 = VGroup(*denom_mover.target[1].mob_matrix[:, 0])\n",
        "        column1.set_fill(opacity=0)\n",
        "        column1.set_stroke(width=0)\n",
        "        self.play(MoveToTarget(denom_mover))\n",
        "        self.look_at(system)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                system.output_vect_mob.elements.copy(),\n",
        "                VGroup(*numer[1].mob_matrix[:, 0]),\n",
        "                path_arc=90 * DEGREES\n",
        "            ),\n",
        "            self.teacher.change, \"happy\",\n",
        "        )\n",
        "        self.remove(denom_mover)\n",
        "        self.add(cg)\n",
        "        self.play_all_student_changes(\"sassy\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            cramer_groups[0].scale, 1 / scale_factor,\n",
        "            cramer_groups[0].next_to, cramer_groups[1], LEFT, MED_LARGE_BUFF,\n",
        "            FadeIn(cramer_groups[1]),\n",
        "            FadeOut(system),\n",
        "            self.change_students(*3 * [\"horrified\"], look_at=UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(cramer_groups[2]),\n",
        "            cramer_groups[:2].next_to, cramer_groups[2], LEFT, MED_LARGE_BUFF,\n",
        "            self.change_students(*3 * [\"horrified\"], look_at=UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        brace = Brace(cramer_groups, UP)\n",
        "        rule_text = brace.get_text(\"``Cramer's rule''\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(rule_text),\n",
        "            self.change_students(\n",
        "                \"pondering\", \"erm\", \"maybe\",\n",
        "                look_at=brace,\n",
        "            )\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ShowComputer(ThreeDScene):\n",
        "    def construct(self):\n",
        "        laptop = Laptop()\n",
        "        laptop.add_updater(lambda m, dt: m.rotate(0.1 * dt, axis=UP))\n",
        "        self.play(DrawBorderThenFill(\n",
        "            laptop,\n",
        "            lag_ratio=0.1,\n",
        "            rate_func=smooth\n",
        "        ))\n",
        "        self.wait(8)\n",
        "        self.play(FadeOut(laptop))\n",
        "\n",
        "\n",
        "class PrerequisiteKnowledge(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"camera_config\": {\"background_opacity\": 1}\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.remove(*self.pi_creatures)\n",
        "        randy = self.students[1]\n",
        "        self.add(randy)\n",
        "\n",
        "        title = OldTexText(\"Prerequisites\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT).scale(5)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        images = Group(*[\n",
        "            ImageMobject(\"eola%d_thumbnail\" % d)\n",
        "            for d in [5, 7, 6]\n",
        "        ])\n",
        "        images.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        images.next_to(h_line, DOWN, MED_LARGE_BUFF)\n",
        "        for image in images:\n",
        "            rect = SurroundingRectangle(image, color=BLUE)\n",
        "            image.rect = rect\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            randy.change, \"erm\"\n",
        "        )\n",
        "        self.wait()\n",
        "        for image in images:\n",
        "            self.play(\n",
        "                FadeInFromDown(image),\n",
        "                FadeInFromDown(image.rect),\n",
        "                randy.change, \"pondering\"\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class NotTheMostComputationallyEfficient(Scene):\n",
        "    CONFIG = {\n",
        "        \"words\": \"Not the most \\\\\\\\ computationally efficient\",\n",
        "        \"word_height\": 4,\n",
        "        \"opacity\": 0.7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        big_rect = FullScreenFadeRectangle(opacity=self.opacity)\n",
        "        self.add(big_rect)\n",
        "\n",
        "        words = OldTexText(self.words)\n",
        "        words.set_color(RED)\n",
        "        words.set_stroke(WHITE, 1)\n",
        "        words.set_width(FRAME_WIDTH - 2 * MED_LARGE_BUFF)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GaussTitle(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Gaussian Elimination\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        line = Line(LEFT, RIGHT).scale(7)\n",
        "        line.next_to(title, DOWN)\n",
        "        self.play(\n",
        "            FadeIn(title, lag_ratio=0.2),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhyLearnIt(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What?!?  Then why \\\\\\\\ learn it?\",\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "            index=2,\n",
        "            target_mode=\"angry\",\n",
        "        )\n",
        "        self.play_all_student_changes(\"angry\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\"erm\", \"happy\" \"pondering\"),\n",
        "            RemovePiCreatureBubble(self.students[2], target_mode=\"pondering\"),\n",
        "        )\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SetupSimpleSystemOfEquations(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"matrix\": [[3, 2], [-1, 2]],\n",
        "        \"output_vect\": [-4, -2],\n",
        "        \"quit_before_final_transformation\": False,\n",
        "        \"array_scale_factor\": 0.75,\n",
        "        \"compare_to_big_system\": True,\n",
        "        \"transition_to_geometric_view\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.remove_grid()\n",
        "        self.introduce_system()\n",
        "        self.from_system_to_matrix()\n",
        "        self.show_geometry()\n",
        "\n",
        "    def remove_grid(self):\n",
        "        self.clear()\n",
        "\n",
        "    def introduce_system(self):\n",
        "        system = self.system = self.get_system(self.matrix, self.output_vect)\n",
        "        dim = len(self.matrix)\n",
        "        big_dim = 7  # Big system size\n",
        "        big_matrix = np.random.randint(-9, 10, size=(big_dim, big_dim))\n",
        "        big_output_vect = np.random.randint(-9, 10, size=big_dim)\n",
        "        big_matrix[:dim, :dim] = self.matrix\n",
        "        big_output_vect[:dim] = self.output_vect\n",
        "        big_system = self.get_system(big_matrix, big_output_vect)\n",
        "\n",
        "        unknown_circles = VGroup(*[\n",
        "            Circle(color=YELLOW).replace(term).scale(1.5)\n",
        "            for term in system.unknowns\n",
        "        ])\n",
        "        unknown_circles.set_stroke(YELLOW, 2)\n",
        "        for circle in unknown_circles:\n",
        "            circle.save_state()\n",
        "            circle.scale(5)\n",
        "            circle.fade(1)\n",
        "        row_rects = VGroup(*list(map(SurroundingRectangle, system)))\n",
        "        row_rects.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.add(system)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, unknown_circles,\n",
        "            lambda m: (m.restore,),\n",
        "            lag_ratio=0.7\n",
        "        ))\n",
        "        self.play(FadeOut(unknown_circles))\n",
        "        self.play(LaggedStartMap(ShowCreation, row_rects,\n",
        "                              run_time=1, lag_ratio=0.8))\n",
        "        self.play(FadeOut(row_rects))\n",
        "        self.wait()\n",
        "        if self.compare_to_big_system:\n",
        "            self.remove(system)\n",
        "            self.play(ReplacementTransform(system.copy(), big_system))\n",
        "            self.wait(2)\n",
        "            # Oh yeah, super readable line...\n",
        "            cutoff = 3 * dim - 1\n",
        "            self.play(*[\n",
        "                ReplacementTransform(big_system[i][:cutoff], system[i][:cutoff])\n",
        "                for i in range(dim)\n",
        "            ] + [\n",
        "                ReplacementTransform(big_system[i][-2:], system[i][-2:])\n",
        "                for i in range(dim)\n",
        "            ] + [\n",
        "                FadeOut(big_system[i][start:end])\n",
        "                for i in range(big_dim)\n",
        "                for start in [cutoff if i < dim else 0]\n",
        "                for end in [-2 if i < dim else len(big_system[i])]\n",
        "            ])\n",
        "            self.remove(big_system, system)\n",
        "            self.add(system)\n",
        "\n",
        "    def from_system_to_matrix(self):\n",
        "        # dim = len(self.matrix)\n",
        "        system_in_lines = self.system\n",
        "        matrix_system = self.matrix_system = LinearSystem(\n",
        "            self.matrix, self.output_vect, height=2\n",
        "        )\n",
        "        matrix_system.center()\n",
        "\n",
        "        corner_rect = self.corner_rect = SurroundingRectangle(\n",
        "            matrix_system, buff=MED_SMALL_BUFF\n",
        "        )\n",
        "        corner_rect.set_stroke(width=0)\n",
        "        corner_rect.set_fill(BLACK, opacity=0.8)\n",
        "        corner_rect.set_height(2)\n",
        "        corner_rect.to_corner(UL, buff=0)\n",
        "\n",
        "        self.play(system_in_lines.to_edge, UP)\n",
        "        system_in_lines_copy = system_in_lines.deepcopy()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(*list(map(VGroup, system_in_lines_copy.matrix_elements))),\n",
        "                matrix_system.matrix_mobject.elements,\n",
        "            ),\n",
        "            Write(matrix_system.matrix_mobject.brackets),\n",
        "            Write(matrix_system.output_vect_mob.brackets),\n",
        "            Write(matrix_system.input_vect_mob.brackets),\n",
        "            Write(matrix_system.equals)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(*list(map(VGroup, system_in_lines_copy.output_vect_elements))),\n",
        "            matrix_system.output_vect_mob.elements,\n",
        "        ))\n",
        "        self.play(*[\n",
        "            ReplacementTransform(uk, elem)\n",
        "            for uk, elem in zip(\n",
        "                system_in_lines_copy.unknowns,\n",
        "                it.cycle(matrix_system.input_vect_mob.elements)\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        if self.transition_to_geometric_view:\n",
        "            self.play(\n",
        "                Write(self.background_plane),\n",
        "                Write(self.plane),\n",
        "                FadeOut(system_in_lines),\n",
        "                FadeIn(corner_rect),\n",
        "                matrix_system.set_height, corner_rect.get_height() - MED_LARGE_BUFF,\n",
        "                matrix_system.move_to, corner_rect,\n",
        "            )\n",
        "            self.play(*list(map(GrowArrow, self.basis_vectors)))\n",
        "\n",
        "            self.add_foreground_mobject(corner_rect)\n",
        "            self.add_foreground_mobject(matrix_system)\n",
        "\n",
        "    def show_geometry(self):\n",
        "        system = self.matrix_system\n",
        "        matrix_mobject = system.matrix_mobject\n",
        "        columns = VGroup(*[\n",
        "            VGroup(*matrix_mobject.mob_matrix[:, i])\n",
        "            for i in (0, 1)\n",
        "        ])\n",
        "\n",
        "        matrix = np.array(self.matrix)\n",
        "        first_half_matrix = np.identity(matrix.shape[0])\n",
        "        first_half_matrix[:, 0] = matrix[:, 0]\n",
        "        second_half_matrix = np.dot(\n",
        "            matrix,\n",
        "            np.linalg.inv(first_half_matrix),\n",
        "        )\n",
        "\n",
        "        scale_factor = self.array_scale_factor\n",
        "\n",
        "        column_mobs = VGroup()\n",
        "        for i in 0, 1:\n",
        "            column_mob = IntegerMatrix(matrix[:, i])\n",
        "            column_mob.elements.set_color([X_COLOR, Y_COLOR][i])\n",
        "            column_mob.scale(scale_factor)\n",
        "            column_mob.next_to(\n",
        "                self.plane.coords_to_point(*matrix[:, i]), RIGHT)\n",
        "            column_mob.add_to_back(BackgroundRectangle(column_mob))\n",
        "            column_mobs.add(column_mob)\n",
        "\n",
        "        output_vect_mob = self.get_vector(self.output_vect, color=OUTPUT_COLOR)\n",
        "        output_vect_label = system.output_vect_mob.deepcopy()\n",
        "        output_vect_label.add_to_back(BackgroundRectangle(output_vect_label))\n",
        "        output_vect_label.generate_target()\n",
        "        output_vect_label.target.scale(scale_factor)\n",
        "        output_vect_label.target.next_to(\n",
        "            output_vect_mob.get_end(), LEFT, SMALL_BUFF)\n",
        "\n",
        "        input_vect = np.dot(np.linalg.inv(self.matrix), self.output_vect)\n",
        "        input_vect_mob = self.get_vector(input_vect, color=INPUT_COLOR)\n",
        "        q_marks = OldTex(\"????\")\n",
        "        q_marks.set_color_by_gradient(INPUT_COLOR, OUTPUT_COLOR)\n",
        "        q_marks.next_to(input_vect_mob.get_end(), DOWN, SMALL_BUFF)\n",
        "        q_marks_rect = SurroundingRectangle(q_marks, color=WHITE)\n",
        "\n",
        "        # Show output vector\n",
        "        self.play(\n",
        "            GrowArrow(output_vect_mob),\n",
        "            MoveToTarget(output_vect_label),\n",
        "        )\n",
        "        self.add_foreground_mobjects(output_vect_mob, output_vect_label)\n",
        "        self.wait()\n",
        "\n",
        "        # Show columns\n",
        "        for column, color in zip(columns, [X_COLOR, Y_COLOR]):\n",
        "            rect = SurroundingRectangle(column, color=WHITE)\n",
        "            self.play(\n",
        "                column.set_color, color,\n",
        "                system.input_vect_mob.elements.set_color, WHITE,\n",
        "                ShowPassingFlash(rect),\n",
        "            )\n",
        "        matrices = [first_half_matrix, second_half_matrix]\n",
        "        for column, column_mob, m in zip(columns, column_mobs, matrices):\n",
        "            column_mob.save_state()\n",
        "            column_mob[0].scale(0).move_to(matrix_mobject)\n",
        "            column_mob.elements.become(column)\n",
        "            column_mob.brackets.become(matrix_mobject.brackets)\n",
        "            self.add_foreground_mobject(column_mob)\n",
        "            self.apply_matrix(m, added_anims=[\n",
        "                ApplyMethod(column_mob.restore, path_arc=90 * DEGREES)\n",
        "            ])\n",
        "        self.wait()\n",
        "\n",
        "        # Do inverse transformation to reveal input\n",
        "        self.remove_foreground_mobjects(column_mobs)\n",
        "        self.apply_inverse(self.matrix, run_time=1, added_anims=[\n",
        "            ReplacementTransform(output_vect_mob.copy(), input_vect_mob),\n",
        "            ReplacementTransform(output_vect_label.elements.copy(), q_marks),\n",
        "            FadeOut(column_mobs)\n",
        "        ])\n",
        "        self.play(ShowPassingFlash(q_marks_rect))\n",
        "        self.wait(2)\n",
        "        if not self.quit_before_final_transformation:\n",
        "            self.apply_matrix(self.matrix, added_anims=[\n",
        "                FadeOut(q_marks),\n",
        "                ReplacementTransform(input_vect_mob, output_vect_mob),\n",
        "                FadeIn(column_mobs),\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "        self.q_marks = q_marks\n",
        "        self.input_vect_mob = input_vect_mob\n",
        "        self.output_vect_mob = output_vect_mob\n",
        "        self.output_vect_label = output_vect_label\n",
        "        self.column_mobs = column_mobs\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_system(self, matrix, output_vect):\n",
        "        if len(matrix) <= 3:\n",
        "            chars = \"xyzwv\"\n",
        "        else:\n",
        "            chars = [\"x_%d\" % d for d in range(len(matrix))]\n",
        "        colors = [\n",
        "            color\n",
        "            for i, color in zip(\n",
        "                list(range(len(matrix))),\n",
        "                it.cycle([X_COLOR, Y_COLOR, Z_COLOR, YELLOW, MAROON_B, TEAL])\n",
        "            )\n",
        "        ]\n",
        "        system = VGroup()\n",
        "        system.matrix_elements = VGroup()\n",
        "        system.output_vect_elements = VGroup()\n",
        "        system.unknowns = VGroup()\n",
        "        for row, num in zip(matrix, output_vect):\n",
        "            args = []\n",
        "            for i in range(len(row)):\n",
        "                if i + 1 == len(row):\n",
        "                    sign = \"=\"\n",
        "                elif row[i + 1] < 0:\n",
        "                    sign = \"-\"\n",
        "                else:\n",
        "                    sign = \"+\"\n",
        "                args += [str(abs(row[i])), chars[i], sign]\n",
        "            args.append(str(num))\n",
        "            line = OldTex(*args)\n",
        "            line.set_color_by_tex_to_color_map(dict([\n",
        "                (char, color)\n",
        "                for char, color in zip(chars, colors)\n",
        "            ]))\n",
        "            system.add(line)\n",
        "            system.matrix_elements.add(*line[0:-1:3])\n",
        "            system.unknowns.add(*line[1:-1:3])\n",
        "            system.output_vect_elements.add(line[-1])\n",
        "\n",
        "        system.output_vect_elements.set_color(OUTPUT_COLOR)\n",
        "        system.arrange(\n",
        "            DOWN,\n",
        "            buff=0.75,\n",
        "            index_of_submobject_to_align=-2\n",
        "        )\n",
        "        return system\n",
        "\n",
        "\n",
        "class FloatingMinus(Scene):\n",
        "    def construct(self):\n",
        "        minus = OldTex(\"-\")\n",
        "        self.add(minus)\n",
        "        self.play(minus.shift, 2.9 * UP, run_time=1)\n",
        "\n",
        "\n",
        "class ShowZeroDeterminantCase(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"show_basis_vectors\": True,\n",
        "        \"matrix\": [[3, -2.0], [1, -2.0 / 3]],\n",
        "        \"tex_scale_factor\": 1.25,\n",
        "        \"det_eq_symbol\": \"=\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_equation()\n",
        "        self.show_det_zero()\n",
        "\n",
        "    def add_equation(self):\n",
        "        equation = self.equation = OldTex(\n",
        "            \"A\", \"\\\\vec{\\\\textbf{x}}\", \"=\", \"\\\\vec{\\\\textbf{v}}\"\n",
        "        )\n",
        "        equation.scale(self.tex_scale_factor)\n",
        "        equation.set_color_by_tex(\"{x}\", INPUT_COLOR)\n",
        "        equation.set_color_by_tex(\"{v}\", OUTPUT_COLOR)\n",
        "        equation.add_background_rectangle()\n",
        "        equation.to_corner(UL)\n",
        "        self.add(equation)\n",
        "        self.add_foreground_mobject(equation)\n",
        "\n",
        "    def show_det_zero(self):\n",
        "        matrix = self.matrix\n",
        "\n",
        "        # vect_in_span = [2, 2.0 / 3]\n",
        "        vect_in_span = [2, 2.0 / 3]\n",
        "        vect_off_span = [1, 2]\n",
        "        vect_in_span_mob = self.get_vector(vect_in_span, color=OUTPUT_COLOR)\n",
        "        vect_off_span_mob = self.get_vector(vect_off_span, color=OUTPUT_COLOR)\n",
        "\n",
        "        for vect_mob in vect_in_span_mob, vect_off_span_mob:\n",
        "            circle = Circle(color=WHITE, radius=0.15, stroke_width=2)\n",
        "            circle.move_to(vect_mob.get_end())\n",
        "            vect_mob.circle = circle\n",
        "\n",
        "        vect_off_span_words = OldTexText(\"No input lands here\")\n",
        "        vect_off_span_words.next_to(vect_off_span_mob.circle, UP)\n",
        "        vect_off_span_words.add_background_rectangle()\n",
        "\n",
        "        vect_in_span_words = OldTexText(\"Many inputs lands here\")\n",
        "        vect_in_span_words.next_to(vect_in_span_mob.circle, DR)\n",
        "        vect_in_span_words.shift_onto_screen()\n",
        "        vect_in_span_words.add_background_rectangle()\n",
        "\n",
        "        moving_group = VGroup(self.plane, self.basis_vectors)\n",
        "        moving_group.save_state()\n",
        "\n",
        "        solution = np.dot(np.linalg.pinv(matrix), vect_in_span)\n",
        "        import sympy\n",
        "        null_space_basis = np.array(sympy.Matrix(matrix).nullspace())\n",
        "        null_space_basis = null_space_basis.flatten().astype(float)\n",
        "        solution_vectors = VGroup(*[\n",
        "            self.get_vector(\n",
        "                solution + x * null_space_basis,\n",
        "                rectangular_stem_width=0.025,\n",
        "                tip_length=0.2,\n",
        "            )\n",
        "            for x in np.linspace(-4, 4, 20)\n",
        "        ])\n",
        "        solution_vectors.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "\n",
        "        self.apply_matrix(matrix, path_arc=0)\n",
        "        self.wait()\n",
        "        self.show_det_equation()\n",
        "        self.wait()\n",
        "\n",
        "        # Mention zero determinants\n",
        "        self.play(GrowArrow(vect_off_span_mob))\n",
        "        self.play(\n",
        "            ShowCreation(vect_off_span_mob.circle),\n",
        "            Write(vect_off_span_words),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(vect_off_span_mob.circle),\n",
        "            ReplacementTransform(vect_off_span_mob, vect_in_span_mob),\n",
        "            ReplacementTransform(vect_off_span_words, vect_in_span_words),\n",
        "            ReplacementTransform(vect_off_span_mob.circle,\n",
        "                                 vect_in_span_mob.circle),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(vect_in_span_words),\n",
        "            FadeOut(vect_in_span_mob.circle),\n",
        "            ApplyMethod(moving_group.restore, run_time=2),\n",
        "            ReplacementTransform(\n",
        "                VGroup(vect_in_span_mob),\n",
        "                solution_vectors,\n",
        "                run_time=2,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def show_det_equation(self):\n",
        "        equation = self.equation\n",
        "        det_equation = OldTex(\n",
        "            \"\\\\det(\", \"A\", \")\", self.det_eq_symbol, \"0\"\n",
        "        )\n",
        "        det_equation.scale(self.tex_scale_factor)\n",
        "        det_equation.next_to(\n",
        "            equation, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        det_rect = BackgroundRectangle(det_equation)\n",
        "        self.play(\n",
        "            FadeIn(det_rect),\n",
        "            Write(det_equation[0]),\n",
        "            ReplacementTransform(\n",
        "                equation.get_part_by_tex(\"A\").copy(),\n",
        "                det_equation.get_part_by_tex(\"A\").copy(),\n",
        "            ),\n",
        "            Write(det_equation[2:]),\n",
        "        )\n",
        "        self.add_foreground_mobject(det_rect, det_equation)\n",
        "\n",
        "\n",
        "class NonZeroDeterminantCase(ShowZeroDeterminantCase, SetupSimpleSystemOfEquations):\n",
        "    CONFIG = {\n",
        "        \"det_eq_symbol\": \"\\\\neq\"\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_equation()\n",
        "        self.show_det_equation()\n",
        "\n",
        "        output_vect = self.output_vect\n",
        "        matrix = self.matrix\n",
        "        input_vect = np.dot(np.linalg.inv(matrix), output_vect)\n",
        "\n",
        "        input_vect_mob = self.get_vector(input_vect, color=INPUT_COLOR)\n",
        "        output_vect_mob = self.get_vector(output_vect, color=OUTPUT_COLOR)\n",
        "\n",
        "        input_vect_label = OldTexText(\"Input\")\n",
        "        input_vect_label.next_to(input_vect_mob.get_end(), DOWN, SMALL_BUFF)\n",
        "        input_vect_label.match_color(input_vect_mob)\n",
        "        output_vect_label = OldTexText(\"Output\")\n",
        "        output_vect_label.next_to(output_vect_mob.get_end(), DOWN, SMALL_BUFF)\n",
        "        output_vect_label.match_color(output_vect_mob)\n",
        "        for label in input_vect_label, output_vect_label:\n",
        "            label.scale(1.25, about_edge=UP)\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "        self.apply_matrix(matrix)\n",
        "        self.wait()\n",
        "        self.apply_inverse(matrix)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(input_vect_mob),\n",
        "            Write(input_vect_label),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(input_vect_mob, input_vect_label)\n",
        "        self.apply_matrix(matrix, added_anims=[\n",
        "            ReplacementTransform(input_vect_mob.copy(), output_vect_mob),\n",
        "            ReplacementTransform(input_vect_label.copy(), output_vect_label),\n",
        "        ], run_time=2)\n",
        "        self.wait()\n",
        "        self.remove(output_vect_mob, output_vect_label)\n",
        "        self.apply_inverse(matrix, added_anims=[\n",
        "            ReplacementTransform(output_vect_mob.copy(), input_vect_mob),\n",
        "            ReplacementTransform(output_vect_label.copy(), input_vect_label),\n",
        "        ], run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThinkOfPuzzleAsLinearCombination(SetupSimpleSystemOfEquations):\n",
        "    CONFIG = {\n",
        "        \"output_vect\": [-4, -2],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        super(ThinkOfPuzzleAsLinearCombination, self).construct()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.rearrange_equation_as_linear_combination()\n",
        "        self.show_linear_combination_of_vectors()\n",
        "\n",
        "    def rearrange_equation_as_linear_combination(self):\n",
        "        system = self.matrix_system\n",
        "        corner_rect = self.corner_rect\n",
        "        matrix, input_vect, equals, output_vect = system\n",
        "\n",
        "        columns = VGroup(*[\n",
        "            VGroup(*matrix.mob_matrix[:, i].flatten())\n",
        "            for i in (0, 1)\n",
        "        ])\n",
        "        column_arrays = VGroup(*[\n",
        "            MobjectMatrix(matrix.deepcopy().mob_matrix[:, i])\n",
        "            for i in (0, 1)\n",
        "        ])\n",
        "        for column_array in column_arrays:\n",
        "            column_array.match_height(output_vect)\n",
        "        x, y = input_vect.elements\n",
        "        movers = VGroup(x, y, equals, output_vect)\n",
        "        for mover in movers:\n",
        "            mover.generate_target()\n",
        "        plus = OldTex(\"+\")\n",
        "\n",
        "        new_system = VGroup(\n",
        "            x.target, column_arrays[0], plus,\n",
        "            y.target, column_arrays[1],\n",
        "            equals.target,\n",
        "            output_vect.target\n",
        "        )\n",
        "        new_system.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        new_system.move_to(matrix, LEFT)\n",
        "\n",
        "        corner_rect.generate_target()\n",
        "        corner_rect.target.stretch_to_fit_width(\n",
        "            new_system.get_width() + MED_LARGE_BUFF,\n",
        "            about_edge=LEFT\n",
        "        )\n",
        "\n",
        "        self.remove_foreground_mobjects(corner_rect, system)\n",
        "        self.play(\n",
        "            MoveToTarget(corner_rect),\n",
        "            FadeOut(input_vect.brackets),\n",
        "            ReplacementTransform(matrix.brackets, column_arrays[0].brackets),\n",
        "            ReplacementTransform(matrix.brackets.copy(),\n",
        "                                 column_arrays[1].brackets),\n",
        "            ReplacementTransform(columns[0], column_arrays[0].elements),\n",
        "            ReplacementTransform(columns[1], column_arrays[1].elements),\n",
        "            Write(plus, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            *[\n",
        "                MoveToTarget(mover, replace_mobject_with_target_in_scene=True)\n",
        "                for mover in movers\n",
        "            ],\n",
        "            path_arc=90 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.add_foreground_mobject(corner_rect, new_system)\n",
        "        self.wait()\n",
        "\n",
        "    def show_linear_combination_of_vectors(self):\n",
        "        basis_vectors = self.basis_vectors\n",
        "        input_vect = np.dot(np.linalg.inv(self.matrix), self.output_vect)\n",
        "        origin = self.plane.coords_to_point(0, 0)\n",
        "        for basis, scalar in zip(basis_vectors, input_vect):\n",
        "            basis.ghost = basis.copy()\n",
        "            basis.ghost.set_color(average_color(basis.get_color(), BLACK))\n",
        "            self.add_foreground_mobjects(basis.ghost, basis)\n",
        "            basis.generate_target()\n",
        "            basis_coords = np.array(\n",
        "                self.plane.point_to_coords(basis.get_end()))\n",
        "            new_coords = scalar * basis_coords\n",
        "            basis.target.put_start_and_end_on(\n",
        "                origin, self.plane.coords_to_point(*new_coords),\n",
        "            )\n",
        "\n",
        "        dashed_lines = VGroup(*[DashedLine(LEFT, RIGHT) for x in range(2)])\n",
        "\n",
        "        def update_dashed_lines(lines):\n",
        "            for i in 0, 1:\n",
        "                lines[i].put_start_and_end_on(\n",
        "                    basis_vectors[i].get_start(),\n",
        "                    basis_vectors[i].get_end(),\n",
        "                )\n",
        "                lines[i].shift(basis_vectors[1 - i].get_end() - origin)\n",
        "            return lines\n",
        "        update_dashed_lines(dashed_lines)\n",
        "        self.play(LaggedStartMap(ShowCreation, dashed_lines, lag_ratio=0.7))\n",
        "        for basis in basis_vectors:\n",
        "            self.play(\n",
        "                MoveToTarget(basis, run_time=2),\n",
        "                UpdateFromFunc(dashed_lines, update_dashed_lines)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WrongButHelpful(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"What's next is wrong, \\\\\\\\ but helpful\")\n",
        "        self.play_student_changes(\"sassy\", \"sad\", \"angry\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class LookAtDotProducts(SetupSimpleSystemOfEquations):\n",
        "    CONFIG = {\n",
        "        \"quit_before_final_transformation\": True,\n",
        "        \"equation_scale_factor\": 0.7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        super(LookAtDotProducts, self).construct()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        self.remove_corner_system()\n",
        "        self.show_dot_products()\n",
        "\n",
        "    def remove_corner_system(self):\n",
        "        to_remove = [self.corner_rect, self.matrix_system]\n",
        "        self.remove_foreground_mobjects(*to_remove)\n",
        "        self.remove(*to_remove)\n",
        "\n",
        "        q_marks = self.q_marks\n",
        "        input_vect_mob = self.input_vect_mob\n",
        "\n",
        "        equations = self.equations = VGroup()\n",
        "        for i in 0, 1:\n",
        "            basis = [0, 0]\n",
        "            basis[i] = 1\n",
        "            equation = VGroup(\n",
        "                Matrix([\"x\", \"y\"]),\n",
        "                OldTex(\"\\\\cdot\"),\n",
        "                IntegerMatrix(basis),\n",
        "                OldTex(\"=\"),\n",
        "                OldTex([\"x\", \"y\"][i]),\n",
        "            )\n",
        "            for part in equation:\n",
        "                if isinstance(part, Matrix):\n",
        "                    part.scale(self.array_scale_factor)\n",
        "            equation[2].elements.set_color([X_COLOR, Y_COLOR][i])\n",
        "            equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            equation.scale(self.equation_scale_factor)\n",
        "            equations.add(equation)\n",
        "        equations.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        equations.to_corner(UL)\n",
        "        corner_rect = self.corner_rect = BackgroundRectangle(\n",
        "            equations, opacity=0.8)\n",
        "        self.resize_corner_rect_to_mobjet(corner_rect, equations)\n",
        "        corner_rect.save_state()\n",
        "        self.resize_corner_rect_to_mobjet(corner_rect, equations[0])\n",
        "\n",
        "        xy_vect_mob = Matrix([\"x\", \"y\"], include_background_rectangle=True)\n",
        "        xy_vect_mob.scale(self.array_scale_factor)\n",
        "        xy_vect_mob.next_to(input_vect_mob.get_end(), DOWN, SMALL_BUFF)\n",
        "        q_marks.add_background_rectangle()\n",
        "        q_marks.next_to(xy_vect_mob, RIGHT)\n",
        "\n",
        "        origin = self.plane.coords_to_point(0, 0)\n",
        "        input_vect_end = input_vect_mob.get_end()\n",
        "        x_point = (input_vect_end - origin)[0] * RIGHT + origin\n",
        "        y_point = (input_vect_end - origin)[1] * UP + origin\n",
        "        v_dashed_line = DashedLine(input_vect_end, x_point)\n",
        "        h_dashed_line = DashedLine(input_vect_end, y_point)\n",
        "\n",
        "        h_brace = Brace(Line(x_point, origin), UP, buff=SMALL_BUFF)\n",
        "        v_brace = Brace(Line(y_point, origin), RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(xy_vect_mob)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(corner_rect),\n",
        "            FadeIn(equations[0][:-1]),\n",
        "            ShowCreation(v_dashed_line),\n",
        "            GrowFromCenter(h_brace),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(h_brace.copy(), equations[0][-1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            corner_rect.restore,\n",
        "            Animation(equations[0]),\n",
        "            FadeIn(equations[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(equations[1][-1].copy(), v_brace),\n",
        "            ShowCreation(h_dashed_line),\n",
        "            GrowFromCenter(v_brace)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.to_fade = VGroup(\n",
        "            h_dashed_line, v_dashed_line,\n",
        "            h_brace, v_brace,\n",
        "            xy_vect_mob, q_marks,\n",
        "        )\n",
        "\n",
        "    def show_dot_products(self):\n",
        "        moving_equations = self.equations.copy()\n",
        "        transformed_equations = VGroup()\n",
        "        implications = VGroup()\n",
        "        transformed_input_rects = VGroup()\n",
        "        transformed_basis_rects = VGroup()\n",
        "        for equation in moving_equations:\n",
        "            equation.generate_target()\n",
        "            xy_vect, dot, basis, equals, coord = equation.target\n",
        "            T1, lp1, rp1 = OldTex(\"T\", \"(\", \")\")\n",
        "            lp1.scale(1, about_edge=LEFT)\n",
        "            rp1.scale(1, about_edge=LEFT)\n",
        "            for paren in lp1, rp1:\n",
        "                paren.stretch_to_fit_height(equation.get_height())\n",
        "            T2, lp2, rp2 = T1.copy(), lp1.copy(), rp1.copy()\n",
        "            transformed_equation = VGroup(\n",
        "                T1, lp1, xy_vect, rp1, dot,\n",
        "                T2, lp2, basis, rp2, equals,\n",
        "                coord\n",
        "            )\n",
        "            transformed_equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            # transformed_equation.scale(self.equation_scale_factor)\n",
        "\n",
        "            implies = OldTex(\"\\\\Rightarrow\").scale(1.2)\n",
        "            implies.next_to(equation, RIGHT)\n",
        "            implies.set_color(BLUE)\n",
        "\n",
        "            transformed_equation.next_to(implies, RIGHT)\n",
        "            implications.add(implies)\n",
        "\n",
        "            transformed_input_rects.add(SurroundingRectangle(\n",
        "                transformed_equation[:4],\n",
        "                color=OUTPUT_COLOR\n",
        "            ))\n",
        "            transformed_basis_rects.add(SurroundingRectangle(\n",
        "                transformed_equation[5:5 + 4],\n",
        "                color=basis.elements.get_color()\n",
        "            ))\n",
        "\n",
        "            for mob in [implies]:\n",
        "                mob.add(OldTex(\"?\").next_to(mob, UP, SMALL_BUFF))\n",
        "\n",
        "            transformed_equation.parts_to_write = VGroup(\n",
        "                T1, lp1, rp1, T2, lp2, rp2\n",
        "            )\n",
        "\n",
        "            transformed_equations.add(transformed_equation)\n",
        "\n",
        "        corner_rect = self.corner_rect\n",
        "        corner_rect.generate_target()\n",
        "        group = VGroup(self.equations, transformed_equations)\n",
        "        self.resize_corner_rect_to_mobjet(corner_rect.target, group)\n",
        "\n",
        "        for array in [self.output_vect_label] + list(self.column_mobs):\n",
        "            array.rect = SurroundingRectangle(array)\n",
        "            array.rect.match_color(array.elements)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(corner_rect),\n",
        "            Animation(self.equations),\n",
        "            FadeOut(self.to_fade),\n",
        "            LaggedStartMap(Write, implications),\n",
        "        )\n",
        "        self.remove(self.input_vect_mob)\n",
        "        self.apply_matrix(self.matrix, added_anims=[\n",
        "            Animation(VGroup(corner_rect, self.equations, implications)),\n",
        "            MoveToTarget(moving_equations[0]),\n",
        "            LaggedStartMap(FadeIn, transformed_equations[0].parts_to_write),\n",
        "            FadeIn(self.column_mobs),\n",
        "            ReplacementTransform(\n",
        "                self.input_vect_mob.copy(), self.output_vect_mob)\n",
        "        ])\n",
        "        self.play(\n",
        "            MoveToTarget(moving_equations[1]),\n",
        "            LaggedStartMap(FadeIn, transformed_equations[1].parts_to_write),\n",
        "            path_arc=-30 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show rectangles\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, transformed_input_rects, lag_ratio=0.8),\n",
        "            ShowCreation(self.output_vect_label.rect),\n",
        "        )\n",
        "        for tbr, column_mob in zip(transformed_basis_rects, self.column_mobs):\n",
        "            self.play(\n",
        "                ShowCreation(tbr),\n",
        "                ShowCreation(column_mob.rect),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(\n",
        "            transformed_input_rects,\n",
        "            transformed_basis_rects,\n",
        "            self.output_vect_label.rect,\n",
        "            *[cm.rect for cm in self.column_mobs]\n",
        "        )))\n",
        "\n",
        "        # These computations assume plane is centered at ORIGIN\n",
        "        output_vect = self.output_vect_mob.get_end()\n",
        "        c1 = self.basis_vectors[0].get_end()\n",
        "        c2 = self.basis_vectors[1].get_end()\n",
        "        x_point = c1 * np.dot(output_vect, c1) / (get_norm(c1)**2)\n",
        "        y_point = c2 * np.dot(output_vect, c2) / (get_norm(c2)**2)\n",
        "\n",
        "        dashed_line_to_x = DashedLine(self.output_vect_mob.get_end(), x_point)\n",
        "        dashed_line_to_y = DashedLine(self.output_vect_mob.get_end(), y_point)\n",
        "\n",
        "        self.play(ShowCreation(dashed_line_to_x))\n",
        "        self.play(ShowCreation(dashed_line_to_y))\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def resize_corner_rect_to_mobjet(self, rect, mobject):\n",
        "        rect.stretch_to_fit_width(\n",
        "            mobject.get_width() + MED_LARGE_BUFF + SMALL_BUFF)\n",
        "        rect.stretch_to_fit_height(\n",
        "            mobject.get_height() + MED_LARGE_BUFF + SMALL_BUFF)\n",
        "        rect.to_corner(UL, buff=0)\n",
        "        return rect\n",
        "\n",
        "\n",
        "class NotAtAllTrue(NotTheMostComputationallyEfficient):\n",
        "    CONFIG = {\n",
        "        \"words\": \"Not at all \\\\\\\\ True\",\n",
        "        \"word_height\": 4,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShowDotProductChanging(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"matrix\": [[2, -5.0 / 3], [-5.0 / 3, 2]],\n",
        "        \"v\": [1, 2],\n",
        "        \"w\": [2, 1],\n",
        "        \"v_label\": \"v\",\n",
        "        \"w_label\": \"w\",\n",
        "        \"v_color\": YELLOW,\n",
        "        \"w_color\": MAROON_B,\n",
        "        \"rhs1\": \"> 0\",\n",
        "        \"rhs2\": \"< 0\",\n",
        "        \"foreground_plane_kwargs\": {\n",
        "            \"x_radius\": 2 * FRAME_WIDTH,\n",
        "            \"y_radius\": 2 * FRAME_HEIGHT,\n",
        "        },\n",
        "        \"equation_scale_factor\": 1.5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        v_mob = self.add_vector(self.v, self.v_color, animate=False)\n",
        "        w_mob = self.add_vector(self.w, self.w_color, animate=False)\n",
        "        kwargs = {\n",
        "            \"transformation_name\": \"T\",\n",
        "            \"at_tip\": True,\n",
        "            \"animate\": False,\n",
        "        }\n",
        "        v_label = self.add_transformable_label(v_mob, self.v_label, **kwargs)\n",
        "        w_label = self.add_transformable_label(w_mob, self.w_label, **kwargs)\n",
        "\n",
        "        start_equation = self.get_equation(v_label, w_label, self.rhs1)\n",
        "        start_equation.to_corner(UR)\n",
        "        self.play(\n",
        "            Write(start_equation[0::2]),\n",
        "            ReplacementTransform(v_label.copy(), start_equation[1]),\n",
        "            ReplacementTransform(w_label.copy(), start_equation[3]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(start_equation)\n",
        "        self.apply_matrix(self.matrix)\n",
        "        self.wait()\n",
        "\n",
        "        end_equation = self.get_equation(v_label, w_label, self.rhs2)\n",
        "        end_equation.next_to(start_equation, DOWN, aligned_edge=RIGHT)\n",
        "        self.play(\n",
        "            FadeIn(end_equation[0]),\n",
        "            ReplacementTransform(\n",
        "                start_equation[2::2].copy(),\n",
        "                end_equation[2::2],\n",
        "            ),\n",
        "            ReplacementTransform(v_label.copy(), end_equation[1]),\n",
        "            ReplacementTransform(w_label.copy(), end_equation[3]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_equation(self, v_label, w_label, rhs):\n",
        "        equation = VGroup(\n",
        "            v_label.copy(),\n",
        "            OldTex(\"\\\\cdot\"),\n",
        "            w_label.copy(),\n",
        "            OldTex(rhs),\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.add_to_back(BackgroundRectangle(equation))\n",
        "        equation.scale(self.equation_scale_factor)\n",
        "        return equation\n",
        "\n",
        "\n",
        "class ShowDotProductChangingAwayFromZero(ShowDotProductChanging):\n",
        "    CONFIG = {\n",
        "        \"matrix\": [[2, 2], [0, -1]],\n",
        "        \"v\": [1, 0],\n",
        "        \"w\": [0, 1],\n",
        "        \"v_label\": \"x\",\n",
        "        \"w_label\": \"y\",\n",
        "        \"v_color\": X_COLOR,\n",
        "        \"w_color\": Y_COLOR,\n",
        "        \"rhs1\": \"= 0\",\n",
        "        \"rhs2\": \"\\\\ne 0\",\n",
        "    }\n",
        "\n",
        "\n",
        "class OrthonormalWords(Scene):\n",
        "    def construct(self):\n",
        "        v_tex = \"\\\\vec{\\\\textbf{v}}\"\n",
        "        w_tex = \"\\\\vec{\\\\textbf{w}}\"\n",
        "        top_words = OldTex(\n",
        "            \"\\\\text{If }\",\n",
        "            \"T(\", v_tex, \")\", \"\\\\cdot\",\n",
        "            \"T(\", w_tex, \")\", \"=\",\n",
        "            v_tex, \"\\\\cdot\", w_tex,\n",
        "            \"\\\\text{ for all }\", v_tex, \"\\\\text{ and }\", w_tex,\n",
        "        )\n",
        "        top_words.set_color_by_tex_to_color_map({\n",
        "            v_tex: YELLOW,\n",
        "            w_tex: MAROON_B,\n",
        "        })\n",
        "        bottom_words = OldTexText(\n",
        "            \"$T$\", \"is\", \"``Orthonormal''\"\n",
        "        )\n",
        "        bottom_words.set_color_by_tex(\"Orthonormal\", BLUE)\n",
        "        words = VGroup(top_words, bottom_words)\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        for word in words:\n",
        "            word.add_background_rectangle()\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowSomeOrthonormalTransformations(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "        \"n_angles\": 7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        for x in range(self.n_angles):\n",
        "            angle = TAU * np.random.random() - TAU / 2\n",
        "            matrix = rotation_matrix(angle, OUT)[:2, :2]\n",
        "            if x in [2, 4]:\n",
        "                matrix[:, 1] *= -1\n",
        "            self.apply_matrix(matrix, run_time=1)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class SolvingASystemWithOrthonormalMatrix(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"array_scale_factor\": 0.6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup system\n",
        "        angle = TAU / 12\n",
        "        matrix = np.array([\n",
        "            [np.cos(angle), -np.sin(angle)],\n",
        "            [np.sin(angle), np.cos(angle)]\n",
        "        ])\n",
        "        output_vect = [1, 2]\n",
        "        symbolic_matrix = [\n",
        "            [\"\\\\cos(30^\\\\circ)\", \"-\\\\sin(30^\\\\circ)\"],\n",
        "            [\"\\\\sin(30^\\\\circ)\", \"\\\\cos(30^\\\\circ)\"],\n",
        "        ]\n",
        "        system = LinearSystem(\n",
        "            matrix=symbolic_matrix,\n",
        "            output_vect=output_vect,\n",
        "            matrix_config={\n",
        "                \"h_buff\": 2.5,\n",
        "                \"element_to_mobject\": Tex,\n",
        "            },\n",
        "            height=1.25,\n",
        "        )\n",
        "        system.to_corner(UL)\n",
        "        system.matrix_mobject.set_column_colors(X_COLOR, Y_COLOR)\n",
        "        system.input_vect_mob.elements.set_color(WHITE)\n",
        "        system_rect = BackgroundRectangle(system, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        matrix_brace = Brace(system.matrix_mobject, DOWN, buff=SMALL_BUFF)\n",
        "        orthonomal_label = OldTexText(\"Orthonormal\")\n",
        "        orthonomal_label.set_color(WHITE)\n",
        "        orthonomal_label.next_to(matrix_brace, DOWN, SMALL_BUFF)\n",
        "        orthonomal_label.add_background_rectangle()\n",
        "\n",
        "        # Input and output vectors\n",
        "        output_vect_mob = self.get_vector(output_vect, color=OUTPUT_COLOR)\n",
        "        output_vect_label = system.output_vect_mob.copy()\n",
        "        output_vect_label.add_background_rectangle()\n",
        "        output_vect_label.scale(self.array_scale_factor)\n",
        "        output_vect_label.next_to(\n",
        "            output_vect_mob.get_end(), RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        input_vect = np.dot(np.linalg.inv(matrix), output_vect)\n",
        "        input_vect_mob = self.get_vector(input_vect, color=INPUT_COLOR)\n",
        "        input_vect_label = OldTexText(\"Mystery input vector\")\n",
        "        input_vect_label.add_background_rectangle()\n",
        "        input_vect_label.next_to(input_vect_mob.get_end(), RIGHT, SMALL_BUFF)\n",
        "        input_vect_label.match_color(input_vect_mob)\n",
        "\n",
        "        # Column arrays\n",
        "        column_mobs = VGroup()\n",
        "        for i, vect in zip(list(range(2)), [DR, DL]):\n",
        "            elements = system.matrix_mobject.deepcopy().mob_matrix[:, i]\n",
        "            column_mob = MobjectMatrix(elements)\n",
        "            column_mob.add_background_rectangle()\n",
        "            column_mob.scale(self.array_scale_factor)\n",
        "            column_mob.next_to(\n",
        "                self.get_vector(matrix[:, i]).get_end(), vect,\n",
        "                buff=SMALL_BUFF\n",
        "            )\n",
        "            column_mobs.add(column_mob)\n",
        "        column_mobs[1].shift(SMALL_BUFF * UP)\n",
        "\n",
        "        # Dot product lines\n",
        "        x_point = self.plane.coords_to_point(input_vect[0], 0)\n",
        "        y_point = self.plane.coords_to_point(0, input_vect[1])\n",
        "        input_dashed_lines = VGroup(\n",
        "            DashedLine(input_vect_mob.get_end(), x_point),\n",
        "            DashedLine(input_vect_mob.get_end(), y_point),\n",
        "        )\n",
        "        output_dashed_lines = input_dashed_lines.copy()\n",
        "        output_dashed_lines.apply_matrix(matrix)\n",
        "\n",
        "        self.add_foreground_mobjects(system_rect, system)\n",
        "        self.add_foreground_mobjects(matrix_brace, orthonomal_label)\n",
        "        self.add_foreground_mobjects(output_vect_mob, output_vect_label)\n",
        "        self.plane.set_stroke(width=2)\n",
        "\n",
        "        self.apply_matrix(matrix)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, output_dashed_lines))\n",
        "        self.play(*self.get_column_animations(system.matrix_mobject, column_mobs))\n",
        "        self.wait()\n",
        "        self.remove(*output_dashed_lines)\n",
        "        self.apply_inverse(matrix, added_anims=[\n",
        "            FadeOut(column_mobs),\n",
        "            ReplacementTransform(output_vect_mob.copy(), input_vect_mob),\n",
        "            ReplacementTransform(\n",
        "                output_dashed_lines.copy(), input_dashed_lines),\n",
        "            FadeIn(input_vect_label),\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.remove(input_dashed_lines, input_vect_mob)\n",
        "        self.apply_matrix(matrix, added_anims=[\n",
        "            FadeOut(input_vect_label),\n",
        "            ReplacementTransform(input_vect_mob.copy(), output_vect_mob),\n",
        "            ReplacementTransform(input_dashed_lines.copy(),\n",
        "                                 output_dashed_lines),\n",
        "            FadeIn(column_mobs),\n",
        "        ])\n",
        "\n",
        "        # Write dot product equations\n",
        "        equations = VGroup()\n",
        "        for i in 0, 1:\n",
        "            moving_output_vect_label = output_vect_label.copy()\n",
        "            moving_column_mob = column_mobs[i].copy()\n",
        "            moving_var = system.input_vect_mob.elements[i].copy()\n",
        "            equation = VGroup(\n",
        "                moving_var.generate_target(),\n",
        "                OldTex(\"=\"),\n",
        "                moving_output_vect_label.generate_target(),\n",
        "                OldTex(\"\\\\cdot\"),\n",
        "                moving_column_mob.generate_target(use_deepcopy=True)\n",
        "            )\n",
        "            equation.movers = VGroup(\n",
        "                moving_var, moving_output_vect_label, moving_column_mob\n",
        "            )\n",
        "            for element in moving_column_mob.target.get_family():\n",
        "                if not isinstance(element, Tex):\n",
        "                    continue\n",
        "                tex_string = element.get_tex()\n",
        "                if \"sin\" in tex_string or \"cos\" in tex_string:\n",
        "                    element.set_stroke(width=1)\n",
        "                    element.scale(1.25)\n",
        "            equation.to_write = equation[1::2]\n",
        "            equation[2].match_height(equation[4])\n",
        "            equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            equation.background_rectangle = BackgroundRectangle(equation)\n",
        "            equation.add_to_back(equation.background_rectangle)\n",
        "            equations.add(equation)\n",
        "        equations.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        equations.scale(1.25)\n",
        "        equations.to_corner(UR, buff=MED_SMALL_BUFF)\n",
        "        equations_rect = BackgroundRectangle(equations, buff=MED_LARGE_BUFF)\n",
        "        equations_rect.set_fill(opacity=0.9)\n",
        "\n",
        "        for i, equation in enumerate(equations):\n",
        "            anims = [\n",
        "                FadeIn(equation.background_rectangle),\n",
        "                Write(equation.to_write),\n",
        "                LaggedStartMap(\n",
        "                    MoveToTarget, equation.movers,\n",
        "                    path_arc=60 * DEGREES\n",
        "                )\n",
        "            ]\n",
        "            if i == 0:\n",
        "                anims.insert(0, FadeIn(equations_rect))\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "\n",
        "    def get_column_animations(self, matrix_mobject, column_mobs):\n",
        "        def get_kwargs(i):\n",
        "            return {\n",
        "                \"rate_func\": squish_rate_func(smooth, 0.4 * i, 0.6 + 0.4 * i),\n",
        "                \"run_time\": 2,\n",
        "            }\n",
        "        return list(it.chain(*[\n",
        "            [\n",
        "                FadeIn(cm[0], **get_kwargs(i)),\n",
        "                ReplacementTransform(\n",
        "                    matrix_mobject.brackets.copy(),\n",
        "                    cm.brackets,\n",
        "                    **get_kwargs(i)\n",
        "                ),\n",
        "                ReplacementTransform(\n",
        "                    VGroup(*matrix_mobject.mob_matrix[:, i]).copy(),\n",
        "                    cm.elements,\n",
        "                    **get_kwargs(i)\n",
        "                ),\n",
        "            ]\n",
        "            for i, cm in enumerate(column_mobs)\n",
        "        ]))\n",
        "\n",
        "\n",
        "class TransitionToParallelogramIdea(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        teacher_words = OldTexText(\n",
        "            \"Now ask about \\\\\\\\ other geometric \\\\\\\\ views of\",\n",
        "            \"$x$\", \"and\", \"$y$\"\n",
        "        )\n",
        "        teacher_words.set_color_by_tex_to_color_map({\n",
        "            \"$x$\": X_COLOR,\n",
        "            \"$y$\": Y_COLOR,\n",
        "        })\n",
        "\n",
        "        self.student_says(\n",
        "            \"But that's a super \\\\\\\\ specific case\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"angry\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            teacher_words,\n",
        "            added_anims=[self.change_students(*[\"pondering\"] * 3)]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TransformingAreasYCoord(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        # Determines whether x-coordinate or y-coordinate is computed\n",
        "        \"index\": 1,\n",
        "        \"matrix\": [[2, -1], [0, 1]],\n",
        "        \"input_vect\": [3, 2],\n",
        "        \"array_scale_factor\": 0.7,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_matrix()\n",
        "        self.init_plane()\n",
        "        self.show_coord_parallelogram()\n",
        "        self.transform_space()\n",
        "        self.solve_for_coord()\n",
        "\n",
        "    def init_matrix(self):\n",
        "        self.matrix = np.array(self.matrix)\n",
        "\n",
        "    def init_plane(self):\n",
        "        self.plane.set_stroke(width=2)\n",
        "\n",
        "    def show_coord_parallelogram(self):\n",
        "        index = self.index\n",
        "        non_index = (index + 1) % 2\n",
        "\n",
        "        input_vect = self.input_vect\n",
        "        input_vect_mob = self.get_vector(input_vect, color=INPUT_COLOR)\n",
        "        input_vect_label = Matrix([\"x\", \"y\"])\n",
        "        input_vect_label.add_background_rectangle()\n",
        "        input_vect_label.scale(self.array_scale_factor)\n",
        "        self.set_input_vect_label_position(input_vect_mob, input_vect_label)\n",
        "\n",
        "        mystery_words = OldTexText(\"Mystery input vector\")\n",
        "        mystery_words.next_to(input_vect_label, RIGHT)\n",
        "        mystery_words.add_background_rectangle()\n",
        "\n",
        "        # Add basis vector labels\n",
        "        basis_labels = self.basis_labels = VGroup()\n",
        "        basis_vectors = self.basis_vectors\n",
        "        chars = [\"\\\\imath\", \"\\\\jmath\"]\n",
        "        directions = [\"right\", \"left\"]\n",
        "        for basis, char, direction in zip(basis_vectors, chars, directions):\n",
        "            label = self.get_vector_label(\n",
        "                basis, \"\\\\mathbf{\\\\hat{%s}}\" % char,\n",
        "                direction=direction\n",
        "            )\n",
        "            self.basis_labels.add(label)\n",
        "\n",
        "        ip = self.get_input_parallelogram(input_vect_mob)\n",
        "        area_arrow_direction = 1.5 * DOWN + RIGHT if self.index == 0 else DR\n",
        "        area_arrow = Vector(\n",
        "            area_arrow_direction, color=WHITE,\n",
        "            rectangular_stem_width=0.025,\n",
        "            tip_length=0.2,\n",
        "        )\n",
        "        area_arrow.shift(ip.get_center() - area_arrow.get_end() + SMALL_BUFF * DL)\n",
        "        area_words = OldTex(\n",
        "            \"\\\\text{Area}\", \"=\", \"1\", \"\\\\times\",\n",
        "            [\"x\", \"y\"][index]\n",
        "        )\n",
        "        area_words.next_to(\n",
        "            area_arrow.get_start(), UL, SMALL_BUFF,\n",
        "            submobject_to_align=area_words[0]\n",
        "        )\n",
        "        area_words.set_color_by_tex_to_color_map({\n",
        "            \"Area\": YELLOW,\n",
        "            \"x\": X_COLOR,\n",
        "            \"y\": Y_COLOR,\n",
        "        })\n",
        "        area_words.rect = BackgroundRectangle(area_words)\n",
        "\n",
        "        origin = self.plane.coords_to_point(0, 0)\n",
        "        unit_brace = Brace(\n",
        "            Line(origin, basis_vectors[non_index].get_end()),\n",
        "            [DOWN, LEFT][non_index],\n",
        "            buff=SMALL_BUFF\n",
        "        )\n",
        "        one = unit_brace.get_tex(\"1\")\n",
        "        one.add_background_rectangle()\n",
        "        coord_brace = self.get_parallelogram_braces(ip)[index]\n",
        "\n",
        "        self.add(input_vect_mob, input_vect_label)\n",
        "        self.add(basis_labels)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ip),\n",
        "            Animation(VGroup(basis_vectors, input_vect_mob))\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(SurroundingRectangle(basis_labels[non_index])),\n",
        "            GrowArrow(self.basis_vectors[non_index].copy(), remover=True)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(SurroundingRectangle(input_vect_label)),\n",
        "            GrowArrow(input_vect_mob.copy(), remover=True),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(area_words.rect),\n",
        "            Write(area_words[:2]),\n",
        "            GrowArrow(area_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(basis_labels),\n",
        "            GrowFromCenter(unit_brace),\n",
        "            FadeIn(one),\n",
        "            FadeIn(area_words[2])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(coord_brace),\n",
        "            FadeIn(coord_brace.label),\n",
        "            FadeIn(area_words[3:]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            area_words.rect.stretch_to_fit_width,\n",
        "            area_words[:3].get_width() + SMALL_BUFF, {\"about_edge\": LEFT},\n",
        "            FadeOut(area_words[2:4]),\n",
        "            area_words[4].shift,\n",
        "            (area_words[2].get_left()[0] - area_words[4].get_left()[0]) * RIGHT,\n",
        "            Animation(area_words[:2]),\n",
        "        )\n",
        "        area_words.remove(*area_words[2:4])\n",
        "        self.wait()\n",
        "\n",
        "        # Run with me\n",
        "        morty = Mortimer(height=2).flip()\n",
        "        morty.to_corner(DL)\n",
        "        randy = Randolph(height=2, color=BLUE_C).flip()\n",
        "        randy.move_to(4 * RIGHT)\n",
        "        randy.to_edge(DOWN)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", ip)\n",
        "        self.play(Blink(randy), FadeIn(morty))\n",
        "        self.play(\n",
        "            PiCreatureSays(morty, \"Run with \\\\\\\\ me here...\", look_at=randy.eyes),\n",
        "            randy.look_at, morty.eyes,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(FadeOut(VGroup(morty, morty.bubble, morty.bubble.content, randy)))\n",
        "\n",
        "        # Signed area\n",
        "        signed = OldTexText(\"Signed\")\n",
        "        signed.match_color(area_words[0])\n",
        "        signed.next_to(area_words, LEFT)\n",
        "\n",
        "        brace_group = VGroup(coord_brace, coord_brace.label)\n",
        "\n",
        "        def update_brace_group(brace_group):\n",
        "            new_brace = self.get_parallelogram_braces(ip)[index]\n",
        "            new_group = VGroup(new_brace, new_brace.label)\n",
        "            Transform(brace_group, new_group).update(1)\n",
        "\n",
        "        area_words.add_to_back(signed)\n",
        "        self.play(\n",
        "            area_words.rect.stretch_to_fit_width, area_words.get_width(),\n",
        "            {\"about_edge\": RIGHT},\n",
        "            Write(signed),\n",
        "            Animation(area_words),\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromFunc(\n",
        "                ip, lambda m: Transform(m, self.get_input_parallelogram(input_vect_mob)).update(1)\n",
        "            ),\n",
        "            input_vect_mob.rotate, np.pi, {\"about_point\": origin},\n",
        "            Animation(self.basis_vectors),\n",
        "            UpdateFromFunc(brace_group, update_brace_group),\n",
        "            UpdateFromFunc(\n",
        "                input_vect_label,\n",
        "                lambda ivl: self.set_input_vect_label_position(input_vect_mob, ivl)\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(area_arrow, ip),\n",
        "            MaintainPositionRelativeTo(area_words.rect, area_arrow),\n",
        "            MaintainPositionRelativeTo(area_words, area_arrow),\n",
        "            run_time=9,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "        )\n",
        "\n",
        "        # Fade out unneeded bits\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            unit_brace, one, coord_brace, coord_brace.label,\n",
        "        )))\n",
        "\n",
        "        self.input_parallelogram = ip\n",
        "        self.area_words = area_words\n",
        "        self.area_arrow = area_arrow\n",
        "        self.input_vect_mob = input_vect_mob\n",
        "        self.input_vect_label = input_vect_label\n",
        "\n",
        "    def transform_space(self):\n",
        "        matrix = self.matrix\n",
        "        ip = self.input_parallelogram\n",
        "        area_words = self.area_words\n",
        "        area_arrow = self.area_arrow\n",
        "        input_vect_mob = self.input_vect_mob\n",
        "        input_vect_label = self.input_vect_label\n",
        "        basis_vectors = self.basis_vectors\n",
        "        index = self.index\n",
        "        non_index = (index + 1) % 2\n",
        "\n",
        "        apply_words = OldTexText(\"Apply\")\n",
        "        apply_words.add_background_rectangle()\n",
        "        matrix_mobject = IntegerMatrix(self.matrix)\n",
        "        matrix_mobject.set_column_colors(X_COLOR, Y_COLOR)\n",
        "        matrix_mobject.add_background_rectangle()\n",
        "        matrix_mobject.next_to(apply_words, RIGHT)\n",
        "        matrix_brace = Brace(matrix_mobject, DOWN, buff=SMALL_BUFF)\n",
        "        matrix_label = matrix_brace.get_tex(\"A\")\n",
        "        matrix_label.add_background_rectangle()\n",
        "        apply_group = VGroup(apply_words, matrix_mobject, matrix_brace, matrix_label)\n",
        "        apply_group.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        area_scale_words = OldTexText(\"All areas get scaled by\", \"$\\\\det(A)$\")\n",
        "        area_scale_words.scale(1.5)\n",
        "        area_scale_words.move_to(2 * DOWN)\n",
        "        area_scale_words.add_background_rectangle()\n",
        "\n",
        "        blobs = VGroup(\n",
        "            Circle(radius=0.5).move_to(2 * LEFT + UP),\n",
        "            Square(side_length=1).rotate(TAU / 12).move_to(2 * UP + 0.5 * RIGHT),\n",
        "            OldTex(\"\\\\pi\").scale(3).move_to(3 * RIGHT)\n",
        "        )\n",
        "        blobs.set_stroke(YELLOW, 3)\n",
        "        blobs.set_fill(YELLOW, 0.3)\n",
        "\n",
        "        # Initial transform\n",
        "        self.add_transformable_mobject(ip)\n",
        "        self.add(self.basis_vectors)\n",
        "        self.add_vector(input_vect_mob, animate=False)\n",
        "        self.play(\n",
        "            Write(apply_words), FadeIn(matrix_mobject),\n",
        "            GrowFromCenter(matrix_brace), Write(matrix_label),\n",
        "        )\n",
        "        self.add_foreground_mobjects(apply_group)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            area_words.rect, area_words, area_arrow, input_vect_label,\n",
        "        ])))\n",
        "        self.apply_matrix(matrix)\n",
        "        self.wait(2)\n",
        "        self.apply_inverse(matrix, run_time=0)\n",
        "\n",
        "        # Show many areas\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, blobs),\n",
        "            Write(area_scale_words)\n",
        "        )\n",
        "        self.add_transformable_mobject(blobs)\n",
        "        self.add_foreground_mobject(area_scale_words)\n",
        "        self.apply_matrix(matrix)\n",
        "\n",
        "        # Ask about parallelogram\n",
        "        ip_copy = ip.copy()\n",
        "        ip_copy.set_stroke(BLACK, 4)\n",
        "        ip_copy.set_fill(BLACK, 0)\n",
        "\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.scale(1.5)\n",
        "        q_marks.rect = BackgroundRectangle(q_marks)\n",
        "        q_marks_group = VGroup(q_marks, q_marks.rect)\n",
        "        q_marks_group.rotate(input_vect_mob.get_angle())\n",
        "        q_marks_group.move_to(ip)\n",
        "\n",
        "        column_mobs = VGroup()\n",
        "        for i, vect in zip(list(range(2)), [DOWN, LEFT]):\n",
        "            column = matrix_mobject.deepcopy().mob_matrix[:, i]\n",
        "            column_mob = MobjectMatrix(column)\n",
        "            column_mob.scale(self.array_scale_factor)\n",
        "            column_mob.next_to(basis_vectors[i].get_end(), vect)\n",
        "            column_mob.add_background_rectangle()\n",
        "            column_mobs.add(column_mob)\n",
        "        column_mob = column_mobs[non_index]\n",
        "\n",
        "        transformed_input_vect_label = VGroup(input_vect_label.copy())\n",
        "        transformed_input_vect_label.add_to_back(matrix_label.copy())\n",
        "        transformed_input_vect_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        transformed_input_vect_label.next_to(input_vect_mob.get_end(), UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowPassingFlash(ip_copy),\n",
        "            FadeIn(q_marks.rect),\n",
        "            Animation(ip),\n",
        "            Animation(basis_vectors),\n",
        "            Animation(input_vect_mob),\n",
        "            Write(q_marks),\n",
        "            LaggedStartMap(FadeOut, blobs),\n",
        "        )\n",
        "        self.transformable_mobjects.remove(blobs)\n",
        "        self.play(\n",
        "            FadeIn(column_mob.background_rectangle),\n",
        "            ReplacementTransform(\n",
        "                matrix_mobject.brackets.copy(), column_mob.brackets\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                VGroup(*matrix_mobject.mob_matrix[:, non_index]).copy(),\n",
        "                column_mob.elements\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(matrix_label.copy(), transformed_input_vect_label[0]),\n",
        "            FadeIn(transformed_input_vect_label[1])\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Back to input state\n",
        "        self.remove(q_marks.rect)\n",
        "        self.apply_inverse(matrix, added_anims=[\n",
        "            FadeOut(q_marks),\n",
        "            FadeOut(transformed_input_vect_label),\n",
        "            FadeOut(column_mob),\n",
        "            FadeIn(area_words.rect),\n",
        "            FadeIn(area_words),\n",
        "            FadeIn(area_arrow),\n",
        "        ])\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show how parallelogram scales by det(A)\n",
        "        self.apply_matrix(matrix, added_anims=[\n",
        "            UpdateFromFunc(\n",
        "                area_arrow,\n",
        "                lambda a: a.put_start_and_end_on(\n",
        "                    area_arrow.get_start(), ip.get_center() + SMALL_BUFF * DL\n",
        "                )\n",
        "            ),\n",
        "            Animation(area_words.rect),\n",
        "            Animation(area_words),\n",
        "        ])\n",
        "\n",
        "        det_A = area_scale_words.get_part_by_tex(\"det\").copy()\n",
        "        det_A.generate_target()\n",
        "        det_A.target.scale(1.0 / 1.5)\n",
        "        det_A.target.next_to(\n",
        "            area_words[1:3], RIGHT, SMALL_BUFF,\n",
        "            aligned_edge=DOWN,\n",
        "            submobject_to_align=det_A.target[0]\n",
        "        )\n",
        "        coord = area_words[-1]\n",
        "        coord.generate_target()\n",
        "        coord.target.next_to(det_A.target, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            area_words.rect.match_width, VGroup(area_words, coord.target),\n",
        "            {\"stretch\": True, \"about_edge\": LEFT},\n",
        "            Animation(area_words),\n",
        "            MoveToTarget(det_A),\n",
        "            MoveToTarget(coord),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        area_words.submobjects.insert(-1, det_A)\n",
        "\n",
        "        self.area_scale_words = area_scale_words\n",
        "        self.apply_group = apply_group\n",
        "\n",
        "    def solve_for_coord(self):\n",
        "        apply_group = self.apply_group\n",
        "        area_words = self.area_words.copy()\n",
        "        index = self.index\n",
        "        non_index = (index + 1) % 2\n",
        "\n",
        "        # Setup rearrangement\n",
        "        signed, area, equals, det, coord = area_words\n",
        "        for part in area_words:\n",
        "            part.add_background_rectangle()\n",
        "            part.generate_target()\n",
        "        apply_word, matrix_mobject, matrix_brace, matrix_label = apply_group\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT).match_width(det)\n",
        "        frac = VGroup(area.target, h_line, det.target)\n",
        "        frac.arrange(DOWN)\n",
        "        coord_equation = VGroup(coord.target, equals.target, frac)\n",
        "        equals.target.next_to(coord.target, RIGHT)\n",
        "        frac.next_to(equals.target, RIGHT, submobject_to_align=h_line)\n",
        "        coord_equation.next_to(ORIGIN, DOWN, buff=1.2)\n",
        "        coord_equation.to_edge(LEFT)\n",
        "\n",
        "        output_vect = np.dot(self.matrix, self.input_vect)\n",
        "        new_matrix = np.array(self.matrix)\n",
        "        new_matrix[:, self.index] = output_vect\n",
        "\n",
        "        # Setup rhs\n",
        "        frac_matrix_height = 1.5\n",
        "        matrix_mobject_copy = matrix_mobject.copy()\n",
        "        matrix_mobject_copy.set_height(frac_matrix_height)\n",
        "        denom_det_text = get_det_text(matrix_mobject_copy)\n",
        "        top_matrix_mobject = IntegerMatrix(new_matrix)\n",
        "        top_matrix_mobject.set_height(frac_matrix_height)\n",
        "        top_matrix_mobject.set_column_colors(X_COLOR, Y_COLOR)\n",
        "        VGroup(*top_matrix_mobject.mob_matrix[:, self.index]).set_color(MAROON_B)\n",
        "        top_matrix_mobject.add_background_rectangle()\n",
        "        num_det_text = get_det_text(top_matrix_mobject)\n",
        "        rhs_h_line = Line(LEFT, RIGHT)\n",
        "        rhs_h_line.match_width(num_det_text)\n",
        "        rhs = VGroup(\n",
        "            VGroup(num_det_text, top_matrix_mobject),\n",
        "            rhs_h_line,\n",
        "            VGroup(matrix_mobject_copy, denom_det_text)\n",
        "        )\n",
        "        rhs.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        rhs_equals = OldTex(\"=\")\n",
        "        rhs_equals.next_to(h_line, RIGHT)\n",
        "        rhs.next_to(rhs_equals, submobject_to_align=rhs_h_line)\n",
        "\n",
        "        # Setup linear system\n",
        "        output_vect_label = IntegerMatrix(output_vect)\n",
        "        output_vect_label.elements.match_color(self.input_vect_mob)\n",
        "        output_vect_label.scale(self.array_scale_factor)\n",
        "        output_vect_label.add_background_rectangle()\n",
        "        self.set_input_vect_label_position(self.input_vect_mob, output_vect_label)\n",
        "\n",
        "        matrix_mobject.generate_target()\n",
        "        system_input = Matrix([\"x\", \"y\"])\n",
        "        system_input.add_background_rectangle()\n",
        "        system_output = output_vect_label.copy()\n",
        "        system_output.generate_target()\n",
        "        system_eq = OldTex(\"=\")\n",
        "        for array in system_input, system_output.target:\n",
        "            array.match_height(matrix_mobject.target)\n",
        "        system = VGroup(\n",
        "            matrix_mobject.target,\n",
        "            system_input, system_eq, system_output.target\n",
        "        )\n",
        "        system.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        system.to_corner(UL)\n",
        "\n",
        "        # Rearrange\n",
        "        self.play(\n",
        "            FadeOut(self.area_scale_words),\n",
        "            ShowCreation(h_line),\n",
        "            *list(map(MoveToTarget, area_words[1:])),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(matrix_mobject.copy(), matrix_mobject_copy),\n",
        "            Write(rhs_equals),\n",
        "            Write(denom_det_text),\n",
        "            ShowCreation(rhs_h_line)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show output coord\n",
        "        self.play(\n",
        "            FadeIn(output_vect_label.background_rectangle),\n",
        "            ReplacementTransform(\n",
        "                self.input_vect_mob.copy(),\n",
        "                output_vect_label.elements,\n",
        "            ),\n",
        "            Write(output_vect_label.brackets),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(apply_word),\n",
        "            MoveToTarget(matrix_mobject),\n",
        "            MaintainPositionRelativeTo(matrix_brace, matrix_mobject),\n",
        "            MaintainPositionRelativeTo(matrix_label, matrix_mobject),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(system_input),\n",
        "            FadeIn(system_eq),\n",
        "            MoveToTarget(system_output),\n",
        "            area_words.rect.stretch_to_fit_width, self.area_words[1:].get_width(),\n",
        "            {\"about_edge\": RIGHT},\n",
        "            Animation(self.area_words[1:]),\n",
        "            FadeOut(self.area_words[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        replaced_column = VGroup(*top_matrix_mobject.mob_matrix[:, self.index])\n",
        "        replaced_column.set_fill(opacity=0)\n",
        "        self.play(\n",
        "            ReplacementTransform(matrix_mobject_copy.copy(), top_matrix_mobject),\n",
        "            ReplacementTransform(denom_det_text.copy(), num_det_text),\n",
        "        )\n",
        "        self.wiggle_vector(self.basis_vectors[non_index])\n",
        "        self.wait()\n",
        "        self.wiggle_vector(self.input_vect_mob)\n",
        "        self.remove(replaced_column)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                output_vect_label.elements.copy(),\n",
        "                replaced_column.copy().set_fill(opacity=1),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        replaced_column.set_fill(opacity=1)\n",
        "        self.wait()\n",
        "\n",
        "        # Circle equation\n",
        "        equation = VGroup(\n",
        "            area_words[1:], h_line,\n",
        "            rhs_equals, rhs,\n",
        "        )\n",
        "        equation_rect = SurroundingRectangle(equation)\n",
        "        equation_rect.set_stroke(YELLOW, 3)\n",
        "        equation_rect.set_fill(BLACK, 0.9)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(equation_rect),\n",
        "            Animation(equation)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_input_parallelogram(self, input_vect_mob):\n",
        "        input_vect = np.array(self.plane.point_to_coords(input_vect_mob.get_end()))\n",
        "        matrix = self.matrix\n",
        "        dim = matrix.shape[0]\n",
        "        # Transofmration from unit square to input parallelogram\n",
        "        square_to_ip = self.square_to_ip = np.identity(dim)\n",
        "        square_to_ip[:, self.index] = np.array(input_vect)\n",
        "\n",
        "        ip = self.get_unit_square()\n",
        "        ip.apply_matrix(self.square_to_ip)\n",
        "        if input_vect[self.index] < 0:\n",
        "            ip.set_color(GOLD)\n",
        "\n",
        "        return ip\n",
        "\n",
        "    def get_parallelogram_braces(self, input_parallelogram):\n",
        "        braces = VGroup(*[\n",
        "            Brace(\n",
        "                input_parallelogram, vect,\n",
        "                buff=SMALL_BUFF,\n",
        "                min_num_quads=3,\n",
        "                max_num_quads=3,\n",
        "            )\n",
        "            for vect in (DOWN, RIGHT)\n",
        "        ])\n",
        "        for brace, tex, color in zip(braces, \"xy\", [X_COLOR, Y_COLOR]):\n",
        "            brace.label = brace.get_tex(tex, buff=SMALL_BUFF)\n",
        "            brace.label.add_background_rectangle()\n",
        "            brace.label.set_color(color)\n",
        "        return braces\n",
        "\n",
        "    def set_input_vect_label_position(self, input_vect_mob, input_vect_label):\n",
        "        direction = np.sign(input_vect_mob.get_vector())\n",
        "        input_vect_label.next_to(input_vect_mob.get_end(), direction, buff=SMALL_BUFF)\n",
        "        return input_vect_label\n",
        "\n",
        "    def wiggle_vector(self, vector_mob):\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                vector_mob, 15 * DEGREES,\n",
        "                about_point=ORIGIN,\n",
        "                rate_func=wiggle,\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "class TransformingAreasXCoord(TransformingAreasYCoord):\n",
        "    CONFIG = {\n",
        "        \"index\": 0,\n",
        "    }\n",
        "\n",
        "\n",
        "class ThreeDDotVectorWithKHat(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ZEqualsVDotK(Scene):\n",
        "    def construct(self):\n",
        "        equation = VGroup(\n",
        "            OldTex(\"z\"),\n",
        "            OldTex(\"=\"),\n",
        "            Matrix([\"x\", \"y\", \"z\"]),\n",
        "            OldTex(\"\\\\cdot\"),\n",
        "            IntegerMatrix([0, 0, 1]),\n",
        "        )\n",
        "        equation[2].elements.set_color_by_gradient(X_COLOR, Y_COLOR, Z_COLOR)\n",
        "        equation[4].elements.set_color(BLUE)\n",
        "        equation.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        equation.to_edge(LEFT)\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class InputParallelepipedAngledView(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class InputParallelepipedTopViewToSideView(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ParallelepipedForXCoordinate(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ParallelepipedForYCoordinate(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ThreeDCoordinatesAsVolumes(Scene):\n",
        "    def construct(self):\n",
        "        colors = [X_COLOR, Y_COLOR, Z_COLOR]\n",
        "        x, y, z = coords = VGroup(*list(map(Tex, \"xyz\")))\n",
        "        coords.set_color_by_gradient(*colors)\n",
        "        matrix = IntegerMatrix(np.identity(3))\n",
        "        matrix.set_column_colors(*colors)\n",
        "        det_text = get_det_text(matrix)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(det_text[0], LEFT)\n",
        "        equals.shift(SMALL_BUFF * DOWN)\n",
        "        coords.next_to(equals, LEFT)\n",
        "\n",
        "        columns = VGroup(*[\n",
        "            VGroup(*matrix.mob_matrix[:, i])\n",
        "            for i in range(3)\n",
        "        ])\n",
        "\n",
        "        coord_column = coords.copy()\n",
        "        for coord, m_elem in zip(coord_column, columns[2]):\n",
        "            coord.move_to(m_elem)\n",
        "        coord_column.set_color(WHITE)\n",
        "        coord_column[2].set_color(BLUE)\n",
        "        coord_column.generate_target()\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, VGroup(\n",
        "            z, equals, det_text, matrix.brackets,\n",
        "            VGroup(*matrix.mob_matrix[:, :2].flatten()),\n",
        "            coord_column\n",
        "        )))\n",
        "        self.wait(2)\n",
        "        coord_column.target.move_to(columns[1])\n",
        "        coord_column.target.set_color_by_gradient(WHITE, Y_COLOR, WHITE)\n",
        "        self.play(\n",
        "            MoveToTarget(coord_column, path_arc=np.pi),\n",
        "            FadeOut(columns[1]),\n",
        "            FadeIn(columns[2]),\n",
        "            FadeInFromDown(y),\n",
        "            z.shift, UP,\n",
        "            z.fade, 1,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        coord_column.target.move_to(columns[0])\n",
        "        coord_column.target.set_color_by_gradient(X_COLOR, WHITE, WHITE)\n",
        "        self.play(\n",
        "            MoveToTarget(coord_column, path_arc=np.pi),\n",
        "            FadeOut(columns[0]),\n",
        "            FadeIn(columns[1]),\n",
        "            FadeInFromDown(x),\n",
        "            y.shift, UP,\n",
        "            y.fade, 1,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WriteCramersRule(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"``Cramer's Rule''\")\n",
        "        words.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        words.add_background_rectangle()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CramersYEvaluation(Scene):\n",
        "    def construct(self):\n",
        "        frac = OldTex(\"{(2)(2) - (4)(0) \\\\over (2)(1) - (-1)(0)}\")[0]\n",
        "        VGroup(frac[1], frac[11], frac[15], frac[26]).set_color(GREEN)\n",
        "        VGroup(frac[4], frac[8]).set_color(MAROON_B)\n",
        "        VGroup(frac[18], frac[22], frac[23]).set_color(RED)\n",
        "\n",
        "        group = VGroup(\n",
        "            OldTex(\"=\"), frac,\n",
        "            OldTex(\"= \\\\frac{4}{2}\"), OldTex(\"=2\")\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "\n",
        "        self.add(group)\n",
        "        self.wait(1)\n",
        "\n",
        "\n",
        "# Largely copy-pasted.  Not great, but what are you gonna do.\n",
        "class CramersXEvaluation(Scene):\n",
        "    def construct(self):\n",
        "        frac = OldTex(\"{(4)(1) - (-1)(2) \\\\over (2)(1) - (-1)(0)}\")[0]\n",
        "        VGroup(frac[1], frac[12]).set_color(MAROON_B)\n",
        "        VGroup(frac[4], frac[8], frac[9]).set_color(RED)\n",
        "        VGroup(frac[16], frac[27]).set_color(GREEN)\n",
        "        VGroup(frac[19], frac[23], frac[24]).set_color(RED)\n",
        "\n",
        "        group = VGroup(\n",
        "            OldTex(\"=\"), frac,\n",
        "            OldTex(\"= \\\\frac{6}{2}\"), OldTex(\"=3\")\n",
        "        )\n",
        "        group.arrange(RIGHT)\n",
        "        group.add_to_back(BackgroundRectangle(group))\n",
        "\n",
        "        self.add(group)\n",
        "        self.wait(1)\n",
        "\n",
        "\n",
        "class FourPlusTwo(Scene):\n",
        "    def construct(self):\n",
        "        p1 = OldTex(\"(4)(1)\")\n",
        "        p2 = OldTex(\"-(-1)(2)\")\n",
        "        p2.next_to(p1, RIGHT, SMALL_BUFF)\n",
        "        b1 = Brace(p1, UP)\n",
        "        b2 = Brace(p2, UP)\n",
        "        t1 = b1.get_tex(\"4\", buff=SMALL_BUFF)\n",
        "        t2 = b2.get_tex(\"+2\", buff=SMALL_BUFF)\n",
        "\n",
        "        for b, t in (b1, t1), (b2, t2):\n",
        "            t.set_stroke(BLACK, 3, background=True)\n",
        "            self.play(\n",
        "                GrowFromCenter(b),\n",
        "                Write(t)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Equals2(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTex(\"=2\").add_background_rectangle())\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Equals3(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTex(\"=3\").add_background_rectangle())\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Introduce3DSystem(SetupSimpleSystemOfEquations):\n",
        "    CONFIG = {\n",
        "        \"matrix\": [[3, 2, -7], [1, 2, -4], [4, 0, 1]],\n",
        "        \"output_vect\": [4, 2, 5],\n",
        "        \"compare_to_big_system\": False,\n",
        "        \"transition_to_geometric_view\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.remove_grid()\n",
        "        self.introduce_system()\n",
        "        self.from_system_to_matrix()\n",
        "\n",
        "\n",
        "class MysteryInputLabel(Scene):\n",
        "    def construct(self):\n",
        "        brace = Brace(Line(ORIGIN, RIGHT), DOWN)\n",
        "        text = brace.get_text(\"Mystery input\")\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(text)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThinkItThroughYourself(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Try thinking \\\\\\\\ it through!\",\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class TransformParallelepipedWithoutGrid(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TransformParallelepipedWithGrid(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AreYouPausingAndPondering(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Are you pausing \\\\\\\\ and pondering?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.change_students(*3 * [\"guilty\"])]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play_all_student_changes(\n",
        "            \"thinking\",\n",
        "            added_anims=[\n",
        "                RemovePiCreatureBubble(self.teacher, target_mode=\"raise_right_hand\")\n",
        "            ],\n",
        "            look_at=self.screen\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class Thumbnail(TransformingAreasYCoord, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"background_plane_kwargs\": {\n",
        "            \"y_max\": 6,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        TransformingAreasYCoord.setup(self)\n",
        "        MovingCameraScene.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.matrix = np.array(self.matrix)\n",
        "        vect = self.add_vector([1, 1.5], color=MAROON_B)\n",
        "        ip = self.get_input_parallelogram(vect)\n",
        "        self.add_transformable_mobject(ip)\n",
        "        self.apply_transposed_matrix([[2, -0.5], [1, 2]])\n",
        "        self.square.set_fill(opacity=0.7)\n",
        "        self.square.set_sheen(0.75, UR)\n",
        "        self.camera_frame.shift(UP)\n",
        "\n",
        "        words = OldTexText(\"Cramer's\", \"rule\")\n",
        "        words.scale(3)\n",
        "        words.set_stroke(BLACK, 6, background=True)\n",
        "        words.to_edge(UP, buff=-MED_LARGE_BUFF)\n",
        "        words.add_background_rectangle()\n",
        "        self.add(words)\n"
    ]
}