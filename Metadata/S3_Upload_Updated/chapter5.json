{
    "topic": "The mathematical concept being demonstrated is the derivative of the exponential function $e^x$.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2017.eoc.chapter4 import ThreeLinesChainRule\n",
        "\n",
        "class ExpFootnoteOpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "        \"Who has not been amazed to learn that the function\",\n",
        "        \"$y = e^x$,\", \"like a phoenix rising again from its own\",\n",
        "        \"ashes, is its own derivative?\",\n",
        "        ],\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"$y = e^x$\" : MAROON_B\n",
        "        },\n",
        "        \"author\" : \"Francois le Lionnais\"\n",
        "    }\n",
        "\n",
        "class LastVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        last_video = series[2]\n",
        "        last_video.save_state()\n",
        "        this_video = series[3]\n",
        "\n",
        "        known_formulas = VGroup(*list(map(Tex, [\n",
        "            \"\\\\frac{d(x^n)}{dx} = nx^{n-1}\",\n",
        "            \"\\\\frac{d(\\\\sin(x))}{dx} = \\\\cos(x)\",\n",
        "        ])))\n",
        "        known_formulas.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "        )\n",
        "        known_formulas.set_height(2.5)\n",
        "        exp_question = OldTex(\"2^x\", \", 7^x, \", \"e^x\", \" ???\")\n",
        "\n",
        "        last_video_brace = Brace(last_video)\n",
        "        known_formulas.next_to(last_video_brace, DOWN)\n",
        "        known_formulas.shift(MED_LARGE_BUFF*LEFT)\n",
        "        last_video_brace.save_state()\n",
        "        last_video_brace.shift(3*LEFT)\n",
        "        last_video_brace.set_fill(opacity = 0)\n",
        "\n",
        "        self.add(series)\n",
        "        self.play(\n",
        "            last_video_brace.restore,\n",
        "            last_video.set_color, YELLOW,\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(Write(known_formulas))\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            exp_question, index = 1,\n",
        "            added_anims = [self.get_teacher().change_mode, \"pondering\"]\n",
        "        )\n",
        "        self.wait(3)\n",
        "        e_to_x = exp_question.get_part_by_tex(\"e^x\")\n",
        "        self.play(\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            e_to_x.scale, 1.5,\n",
        "            e_to_x.set_color, YELLOW,\n",
        "            e_to_x.next_to, self.teacher.get_corner(UP+LEFT), UP\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class PopulationSizeGraphVsPopulationMassGraph(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "class DoublingPopulation(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"time_color\" : YELLOW,\n",
        "        \"pi_creature_grid_dimensions\" : (8, 8),\n",
        "        \"pi_creature_grid_height\" : 6,\n",
        "    }\n",
        "    \n",
        "    def construct(self):\n",
        "        self.remove(self.get_pi_creatures())\n",
        "        self.introduce_expression()\n",
        "        self.introduce_pi_creatures()\n",
        "        self.count_through_days()\n",
        "        self.ask_about_dM_dt()\n",
        "        self.growth_per_day()\n",
        "        self.relate_growth_rate_to_pop_size()\n",
        "\n",
        "    def introduce_expression(self):\n",
        "        f_x = OldTex(\"f(x)\", \"=\", \"2^x\")\n",
        "        f_t = OldTex(\"f(t)\", \"=\", \"2^t\")\n",
        "        P_t = OldTex(\"P(t)\", \"=\", \"2^t\")\n",
        "        M_t = OldTex(\"M(t)\", \"=\", \"2^t\")\n",
        "        functions = VGroup(f_x, f_t, P_t, M_t)\n",
        "        for function in functions:\n",
        "            function.scale(1.2)\n",
        "            function.to_corner(UP+LEFT)\n",
        "        for function in functions[1:]:\n",
        "            for i, j in (0, 2), (2, 1):\n",
        "                function[i][j].set_color(self.time_color)\n",
        "\n",
        "        t_expression = OldTex(\"t\", \"=\", \"\\\\text{Time (in days)}\")\n",
        "        t_expression.to_corner(UP+RIGHT)\n",
        "        t_expression[0].set_color(self.time_color)\n",
        "\n",
        "        pop_brace, mass_brace = [\n",
        "            Brace(function[0], DOWN)\n",
        "            for function in (P_t, M_t)\n",
        "        ]\n",
        "        for brace, word in (pop_brace, \"size\"), (mass_brace, \"mass\"):\n",
        "            text = brace.get_text(\"Population %s\"%word)\n",
        "            text.to_edge(LEFT)\n",
        "            brace.text = text\n",
        "\n",
        "        self.play(Write(f_x))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(f_x, f_t),\n",
        "            FadeIn(\n",
        "                t_expression,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            )\n",
        "        )\n",
        "        self.play(Transform(f_x, P_t))\n",
        "        self.play(\n",
        "            GrowFromCenter(pop_brace),\n",
        "            Write(pop_brace.text, run_time = 2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.function = f_x\n",
        "        self.pop_brace = pop_brace\n",
        "        self.t_expression = t_expression\n",
        "        self.mass_function = M_t\n",
        "        self.mass_brace = mass_brace\n",
        "\n",
        "    def introduce_pi_creatures(self):\n",
        "        creatures = self.get_pi_creatures()\n",
        "        total_num_days = self.get_num_days()\n",
        "        num_start_days = 4\n",
        "\n",
        "        self.reset()\n",
        "        for x in range(num_start_days):\n",
        "            self.let_one_day_pass()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(self.function, self.mass_function),\n",
        "            Transform(self.pop_brace, self.mass_brace),\n",
        "            Transform(self.pop_brace.text, self.mass_brace.text),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(total_num_days-num_start_days):\n",
        "            self.let_one_day_pass()\n",
        "            self.wait()\n",
        "        self.joint_blink(shuffle = False)\n",
        "        self.wait()\n",
        "\n",
        "    def count_through_days(self):\n",
        "        self.reset()\n",
        "        brace = self.get_population_size_descriptor()\n",
        "        days_to_let_pass = 3\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        for x in range(days_to_let_pass):\n",
        "            self.let_one_day_pass()\n",
        "            new_brace = self.get_population_size_descriptor()\n",
        "            self.play(Transform(brace, new_brace))\n",
        "            self.wait()\n",
        "\n",
        "        self.population_size_descriptor = brace\n",
        "\n",
        "    def ask_about_dM_dt(self):\n",
        "        dM_dt_question = OldTex(\"{dM\", \"\\\\over dt}\", \"=\", \"???\")\n",
        "        dM, dt, equals, q_marks = dM_dt_question\n",
        "        dM_dt_question.next_to(self.function, DOWN, buff = LARGE_BUFF)\n",
        "        dM_dt_question.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.pop_brace),\n",
        "            FadeOut(self.pop_brace.text),\n",
        "            Write(dM_dt_question)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        for mob in dM, dt:\n",
        "            self.play(Indicate(mob))\n",
        "            self.wait()\n",
        "\n",
        "        self.dM_dt_question = dM_dt_question\n",
        "\n",
        "    def growth_per_day(self):\n",
        "        day_to_day, frac = self.get_from_day_to_day_label()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.dM_dt_question),\n",
        "            FadeOut(self.population_size_descriptor),\n",
        "            FadeIn(day_to_day)\n",
        "        )\n",
        "        rect = self.let_day_pass_and_highlight_new_creatures(frac)\n",
        "\n",
        "        for x in range(2):\n",
        "            new_day_to_day, new_frac = self.get_from_day_to_day_label()\n",
        "            self.play(*list(map(FadeOut, [rect, frac])))\n",
        "            frac = new_frac\n",
        "            self.play(Transform(day_to_day, new_day_to_day))\n",
        "            rect = self.let_day_pass_and_highlight_new_creatures(frac)\n",
        "        self.play(*list(map(FadeOut, [rect, frac, day_to_day])))\n",
        "\n",
        "    def let_day_pass_and_highlight_new_creatures(self, frac):\n",
        "        num_new_creatures = 2**self.get_curr_day()\n",
        "\n",
        "        self.let_one_day_pass()\n",
        "        new_creatures = VGroup(\n",
        "            *self.get_on_screen_pi_creatures()[-num_new_creatures:]\n",
        "        )\n",
        "        rect = Rectangle(\n",
        "            color = GREEN,\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.3,\n",
        "        )\n",
        "        rect.replace(new_creatures, stretch = True)\n",
        "        rect.stretch_to_fit_height(rect.get_height()+MED_SMALL_BUFF)\n",
        "        rect.stretch_to_fit_width(rect.get_width()+MED_SMALL_BUFF)\n",
        "        self.play(DrawBorderThenFill(rect))\n",
        "        self.play(Write(frac))\n",
        "        self.wait()\n",
        "        return rect\n",
        "\n",
        "    def relate_growth_rate_to_pop_size(self):\n",
        "        false_deriv = OldTex(\n",
        "            \"{d(2^t) \", \"\\\\over dt}\", \"= 2^t\"\n",
        "        )\n",
        "        difference_eq = OldTex(\n",
        "            \"{ {2^{t+1} - 2^t} \\\\over\", \"1}\", \"= 2^t\"\n",
        "        )\n",
        "        real_deriv = OldTex(\n",
        "            \"{ {2^{t+dt} - 2^t} \\\\over\", \"dt}\", \"= \\\\, ???\"\n",
        "        )\n",
        "        VGroup(\n",
        "            false_deriv[0][3], \n",
        "            false_deriv[2][-1],\n",
        "            difference_eq[0][1],\n",
        "            difference_eq[0][-2],\n",
        "            difference_eq[2][-1],\n",
        "            difference_eq[2][-1],\n",
        "            real_deriv[0][1],\n",
        "            real_deriv[0][-2],\n",
        "        ).set_color(YELLOW)\n",
        "        VGroup(\n",
        "            difference_eq[0][3],\n",
        "            difference_eq[1][-1],\n",
        "            real_deriv[0][3],\n",
        "            real_deriv[0][4],\n",
        "            real_deriv[1][-2],\n",
        "            real_deriv[1][-1],\n",
        "        ).set_color(GREEN)\n",
        "\n",
        "        expressions = [false_deriv, difference_eq, real_deriv]\n",
        "        text_arg_list = [\n",
        "            (\"Tempting\", \"...\",),\n",
        "            (\"Rate of change\", \"\\\\\\\\ over one full day\"),\n",
        "            (\"Rate of change\", \"\\\\\\\\ in a small time\"),\n",
        "        ]\n",
        "        for expression, text_args in zip(expressions, text_arg_list):\n",
        "            expression.next_to(\n",
        "                self.function, DOWN, \n",
        "                buff = LARGE_BUFF,\n",
        "                aligned_edge = LEFT,\n",
        "            )\n",
        "            expression.brace = Brace(expression, DOWN)\n",
        "            expression.brace_text = expression.brace.get_text(*text_args)\n",
        "\n",
        "        time = self.t_expression[-1]\n",
        "        new_time = OldTex(\"3\")\n",
        "        new_time.move_to(time, LEFT)\n",
        "\n",
        "        fading_creatures = VGroup(*self.get_on_screen_pi_creatures()[8:])\n",
        "\n",
        "\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            false_deriv, false_deriv.brace, false_deriv.brace_text\n",
        "        ])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(time, new_time),\n",
        "            FadeOut(fading_creatures)\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(3):\n",
        "            self.let_one_day_pass(run_time = 2)\n",
        "            self.wait(2)\n",
        "\n",
        "        for expression in difference_eq, real_deriv:\n",
        "            expression.brace_text[1].set_color(GREEN)\n",
        "            self.play(\n",
        "                Transform(false_deriv, expression),\n",
        "                Transform(false_deriv.brace, expression.brace),\n",
        "                Transform(false_deriv.brace_text, expression.brace_text),\n",
        "            )\n",
        "            self.wait(3)\n",
        "        self.reset()\n",
        "        for x in range(self.get_num_days()):\n",
        "            self.let_one_day_pass()\n",
        "        self.wait()\n",
        "\n",
        "        rect = Rectangle(color = YELLOW)\n",
        "        rect.replace(real_deriv)\n",
        "        rect.stretch_to_fit_width(rect.get_width()+MED_SMALL_BUFF)\n",
        "        rect.stretch_to_fit_height(rect.get_height()+MED_SMALL_BUFF)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            false_deriv.brace, false_deriv.brace_text\n",
        "        ])))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda pi : pi.change_mode(\"pondering\").look_at(real_deriv),\n",
        "                pi,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.5)\n",
        "            )\n",
        "            for pi in self.get_pi_creatures()\n",
        "            for a in [0.5*random.random()]\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "    ###########\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        width, height = self.pi_creature_grid_dimensions\n",
        "        creature_array = VGroup(*[\n",
        "            VGroup(*[\n",
        "                PiCreature(mode = \"plain\")\n",
        "                for y in range(height)\n",
        "            ]).arrange(UP, buff = MED_LARGE_BUFF)\n",
        "            for x in range(width)\n",
        "        ]).arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        creatures = VGroup(*it.chain(*creature_array))\n",
        "        creatures.set_height(self.pi_creature_grid_height)\n",
        "        creatures.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        colors = color_gradient([BLUE, GREEN, GREY_BROWN], len(creatures))\n",
        "        random.shuffle(colors)\n",
        "        for creature, color in zip(creatures, colors):\n",
        "            creature.set_color(color)\n",
        "\n",
        "        return creatures\n",
        "\n",
        "    def reset(self):\n",
        "        time = self.t_expression[-1]\n",
        "        faders = [time] + list(self.get_on_screen_pi_creatures())\n",
        "        new_time = OldTex(\"0\")\n",
        "        new_time.next_to(self.t_expression[-2], RIGHT)\n",
        "        first_creature = self.get_pi_creatures()[0]\n",
        "\n",
        "        self.play(*list(map(FadeOut, faders)))\n",
        "        self.play(*list(map(FadeIn, [first_creature, new_time])))\n",
        "        self.t_expression.submobjects[-1] = new_time\n",
        "\n",
        "    def let_one_day_pass(self, run_time = 2):\n",
        "        all_creatures = self.get_pi_creatures()\n",
        "        on_screen_creatures = self.get_on_screen_pi_creatures()\n",
        "        low_i = len(on_screen_creatures)\n",
        "        high_i = min(2*low_i, len(all_creatures))\n",
        "        new_creatures = VGroup(*all_creatures[low_i:high_i])\n",
        "\n",
        "        to_children_anims = []\n",
        "        growing_anims = []\n",
        "        for old_pi, pi in zip(on_screen_creatures, new_creatures):\n",
        "            pi.save_state()\n",
        "            child = pi.copy()\n",
        "            child.scale(0.25, about_point = child.get_bottom())\n",
        "            child.eyes.scale(1.5, about_point = child.eyes.get_bottom())\n",
        "            pi.move_to(old_pi)\n",
        "            pi.set_fill(opacity = 0)\n",
        "\n",
        "            index = list(new_creatures).index(pi)\n",
        "            prop = float(index)/len(new_creatures)\n",
        "            alpha  = np.clip(len(new_creatures)/8.0, 0, 0.5)\n",
        "            rate_func = squish_rate_func(\n",
        "                smooth, alpha*prop, alpha*prop+(1-alpha)\n",
        "            )\n",
        "\n",
        "            to_child_anim = Transform(pi, child, rate_func = rate_func)\n",
        "            to_child_anim.update(1)\n",
        "            growing_anim = ApplyMethod(pi.restore, rate_func = rate_func)\n",
        "            to_child_anim.update(0)\n",
        "\n",
        "            to_children_anims.append(to_child_anim)\n",
        "            growing_anims.append(growing_anim)\n",
        "\n",
        "        time = self.t_expression[-1]\n",
        "        total_new_creatures = len(on_screen_creatures) + len(new_creatures)\n",
        "        new_time = OldTex(str(int(np.log2(total_new_creatures))))\n",
        "        new_time.move_to(time, LEFT)\n",
        "\n",
        "        growing_anims.append(Transform(time, new_time))\n",
        "\n",
        "        self.play(*to_children_anims, run_time = run_time/2.0)\n",
        "        self.play(*growing_anims, run_time = run_time/2.0)\n",
        "        \n",
        "    def get_num_pi_creatures_on_screen(self):\n",
        "        mobjects = self.get_mobjects()\n",
        "        return sum([\n",
        "            pi in mobjects for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "\n",
        "    def get_population_size_descriptor(self):\n",
        "        on_screen_creatures = self.get_on_screen_pi_creatures()\n",
        "        brace = Brace(on_screen_creatures, LEFT)\n",
        "        n = len(on_screen_creatures)\n",
        "        label = brace.get_text(\n",
        "            \"$2^%d$\"%int(np.log2(n)),\n",
        "            \"$=%d$\"%n,\n",
        "        )\n",
        "        brace.add(label)\n",
        "        return brace\n",
        "\n",
        "    def get_num_days(self):\n",
        "        x, y = self.pi_creature_grid_dimensions\n",
        "        return int(np.log2(x*y))\n",
        "\n",
        "    def get_curr_day(self):\n",
        "        return int(np.log2(len(self.get_on_screen_pi_creatures())))\n",
        "\n",
        "    def get_from_day_to_day_label(self):\n",
        "        curr_day = self.get_curr_day()\n",
        "        top_words = OldTexText(\n",
        "            \"From day\", str(curr_day), \n",
        "            \"to\", str(curr_day+1), \":\"\n",
        "        )\n",
        "        top_words.set_width(4)\n",
        "        top_words.next_to(\n",
        "            self.function, DOWN,\n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        top_words[1].set_color(GREEN)\n",
        "\n",
        "        bottom_words = OldTex(\n",
        "            str(2**curr_day),\n",
        "            \"\\\\text{ creatures}\", \"\\\\over {1 \\\\text{ day}}\"\n",
        "        )\n",
        "        bottom_words[0].set_color(GREEN)\n",
        "        bottom_words.next_to(top_words, DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        return top_words, bottom_words\n",
        "\n",
        "class GraphOfTwoToT(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"$t$\",\n",
        "        \"y_axis_label\" : \"$M$\",\n",
        "        \"x_labeled_nums\" : list(range(1, 7)),\n",
        "        \"y_labeled_nums\" : list(range(8, 40, 8)),\n",
        "        \"x_max\" : 6,\n",
        "        \"y_min\" : 0,\n",
        "        \"y_max\" : 32,\n",
        "        \"y_tick_frequency\" : 2,\n",
        "        \"graph_origin\" : 2.5*DOWN + 5*LEFT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        example_t = 3\n",
        "        graph = self.get_graph(lambda t : 2**t, color = BLUE_C)\n",
        "        self.graph = graph\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, \"M(t) = 2^t\",\n",
        "            direction = LEFT,\n",
        "        )\n",
        "        label_group = self.get_label_group(example_t)\n",
        "        v_line, brace, height_label, ss_group, slope_label = label_group\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_dx = 1,\n",
        "            run_time = 0\n",
        "        )\n",
        "        self.remove(ss_group)\n",
        "\n",
        "        #Draw graph and revert to tangent\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "        self.play(Write(ss_group))\n",
        "        self.wait()\n",
        "        for target_dx in 0.01, 1, 0.01:\n",
        "            self.animate_secant_slope_group_change(\n",
        "                ss_group,\n",
        "                target_dx = target_dx\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        #Mark up with values\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(height_label, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                slope_label, \n",
        "                run_time = 4,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                height_label.copy(),\n",
        "                slope_label.get_part_by_tex(\"2^\")\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Vary value\n",
        "        threes = VGroup(height_label[1], slope_label[2][1])\n",
        "        ts = VGroup(*[\n",
        "            OldTex(\"t\").set_color(YELLOW).scale(0.75).move_to(three)\n",
        "            for three in threes\n",
        "        ])\n",
        "        self.play(Transform(threes, ts))\n",
        "\n",
        "        alt_example_t = example_t+1\n",
        "        def update_label_group(group, alpha):\n",
        "            t = interpolate(example_t, alt_example_t, alpha)\n",
        "            new_group = self.get_label_group(t)\n",
        "            Transform(group, new_group).update(1)\n",
        "            for t, three in zip(ts, threes):\n",
        "                t.move_to(three)\n",
        "            Transform(threes, ts).update(1)\n",
        "            return group\n",
        "\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            label_group, update_label_group,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            label_group, update_label_group,\n",
        "            run_time = 3,\n",
        "            rate_func = lambda t : 1 - 1.5*smooth(t)\n",
        "        ))\n",
        "\n",
        "    def get_label_group(self, t):\n",
        "        graph = self.graph\n",
        "\n",
        "        v_line = self.get_vertical_line_to_graph(\n",
        "            t, graph,\n",
        "            color = YELLOW,\n",
        "        )\n",
        "        brace = Brace(v_line, RIGHT)\n",
        "        height_label = brace.get_text(\"$2^%d$\"%t)\n",
        "\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            t, graph, dx = 0.01,\n",
        "            df_label = \"dM\",\n",
        "            dx_label = \"dt\",\n",
        "            dx_line_color = GREEN,\n",
        "            secant_line_color = RED,\n",
        "        )\n",
        "        slope_label = OldTex(\n",
        "            \"\\\\text{Slope}\", \"=\", \n",
        "            \"2^%d\"%t,\n",
        "            \"(%.7f\\\\dots)\"%np.log(2)\n",
        "        )\n",
        "        slope_label.next_to(\n",
        "            ss_group.secant_line.point_from_proportion(0.65),\n",
        "            DOWN+RIGHT,\n",
        "            buff = 0\n",
        "        )\n",
        "        slope_label.set_color_by_tex(\"Slope\", RED)\n",
        "        return VGroup(\n",
        "            v_line, brace, height_label,\n",
        "            ss_group, slope_label\n",
        "        )\n",
        "\n",
        "class SimpleGraphOfTwoToT(GraphOfTwoToT):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        func = lambda t : 2**t\n",
        "        graph = self.get_graph(func)\n",
        "        line_pairs = VGroup()\n",
        "        for x in 1, 2, 3, 4, 5:\n",
        "            point = self.coords_to_point(x, func(x))\n",
        "            x_axis_point = self.coords_to_point(x, 0)\n",
        "            y_axis_point = self.coords_to_point(0, func(x))\n",
        "            line_pairs.add(VGroup(\n",
        "                DashedLine(x_axis_point, point),\n",
        "                DashedLine(y_axis_point, point),\n",
        "            ))\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(graph, run_time = 2))\n",
        "        for pair in line_pairs:\n",
        "            self.play(ShowCreation(pair))\n",
        "        self.wait()\n",
        "\n",
        "class FakeDiagram(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        gs = GraphScene(skip_animations = True)\n",
        "        gs.setup_axes()\n",
        "        background_graph, foreground_graph = graphs = VGroup(*[\n",
        "            gs.get_graph(\n",
        "                lambda t : np.log(2)*2**t,\n",
        "                x_min = -8,\n",
        "                x_max = 2 + dx\n",
        "            )\n",
        "            for dx in (0.25, 0)\n",
        "        ])\n",
        "        for graph in graphs:\n",
        "            end_point = graph.get_points()[-1]\n",
        "            axis_point = end_point[0]*RIGHT + gs.graph_origin[1]*UP\n",
        "            for alpha in np.linspace(0, 1, 20):\n",
        "                point = interpolate(axis_point, graph.get_points()[0], alpha)\n",
        "                graph.add_line_to(point)\n",
        "            graph.set_stroke(width = 1)\n",
        "            graph.set_fill(opacity = 1)\n",
        "            graph.set_color(BLUE_D)\n",
        "        background_graph.set_color(YELLOW)\n",
        "        background_graph.set_stroke(width = 0.5)\n",
        "\n",
        "        graphs.next_to(self.teacher, UP+LEFT, LARGE_BUFF)\n",
        "        two_to_t = OldTex(\"2^t\")\n",
        "        two_to_t.next_to(\n",
        "            foreground_graph.get_corner(DOWN+RIGHT), UP+LEFT\n",
        "        )\n",
        "        corner_line = Line(*[\n",
        "            graph.get_corner(DOWN+RIGHT)\n",
        "            for graph in graphs\n",
        "        ])\n",
        "        dt_brace = Brace(corner_line, DOWN, buff = SMALL_BUFF)\n",
        "        dt = dt_brace.get_text(\"$dt$\")\n",
        "\n",
        "        side_brace = Brace(graphs, RIGHT, buff = SMALL_BUFF)\n",
        "        deriv = side_brace.get_text(\"$\\\\frac{d(2^t)}{dt}$\")\n",
        "\n",
        "        circle = Circle(color = RED)\n",
        "        circle.replace(deriv, stretch = True)\n",
        "        circle.scale(1.5)\n",
        "\n",
        "        words = OldTexText(\"Not a real explanation\")\n",
        "        words.to_edge(UP)\n",
        "        arrow = Arrow(words.get_bottom(), two_to_t.get_corner(UP+LEFT))\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        diagram = VGroup(\n",
        "            graphs, two_to_t, dt_brace, dt, \n",
        "            side_brace, deriv, circle,\n",
        "            words, arrow\n",
        "        )\n",
        "\n",
        "        self.play(self.teacher.change_mode, \"raise_right_hand\")\n",
        "        self.play(\n",
        "            Animation(VectorizedPoint(graphs.get_right())),\n",
        "            DrawBorderThenFill(foreground_graph),\n",
        "            Write(two_to_t)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                foreground_graph.copy(),\n",
        "                background_graph,\n",
        "            ),\n",
        "            Animation(foreground_graph),\n",
        "            Animation(two_to_t),\n",
        "            GrowFromCenter(dt_brace),\n",
        "            Write(dt)\n",
        "        )\n",
        "        self.play(GrowFromCenter(side_brace))\n",
        "        self.play(Write(deriv, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            self.teacher.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(arrow),\n",
        "            self.teacher.change_mode, \"shruggie\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(diagram),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"plain\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"More numerical \\\\\\\\ than visual...\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.diagram = diagram\n",
        "\n",
        "class AnalyzeExponentRatio(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"base\" : 2,\n",
        "        \"base_str\" : \"2\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        base_str = self.base_str\n",
        "\n",
        "        func_def = OldTex(\"M(\", \"t\", \")\", \"= \", \"%s^\"%base_str, \"t\")\n",
        "        func_def.to_corner(UP+LEFT)\n",
        "        self.add(func_def)\n",
        "\n",
        "        ratio = OldTex(\n",
        "            \"{ {%s^\"%base_str, \"{t\", \"+\", \"dt}\", \"-\", \n",
        "            \"%s^\"%base_str, \"t}\",\n",
        "            \"\\\\over \\\\,\", \"dt}\"\n",
        "        )\n",
        "        ratio.shift(UP+LEFT)\n",
        "\n",
        "        lhs = OldTex(\"{dM\", \"\\\\over \\\\,\", \"dt}\", \"(\", \"t\", \")\", \"=\")\n",
        "        lhs.next_to(ratio, LEFT)\n",
        "\n",
        "\n",
        "        two_to_t_plus_dt = VGroup(*ratio[:4])\n",
        "        two_to_t = VGroup(*ratio[5:7])\n",
        "        two_to_t_two_to_dt = OldTex(\n",
        "            \"%s^\"%base_str, \"t\", \n",
        "            \"%s^\"%base_str, \"{dt}\"\n",
        "        )\n",
        "        two_to_t_two_to_dt.move_to(two_to_t_plus_dt, DOWN+LEFT)\n",
        "        exp_prop_brace = Brace(two_to_t_two_to_dt, UP)\n",
        "\n",
        "        one = OldTex(\"1\")\n",
        "        one.move_to(ratio[5], DOWN)\n",
        "        lp, rp = parens = OldTex(\"()\")\n",
        "        parens.stretch(1.3, 1)\n",
        "        parens.set_height(ratio.get_height())\n",
        "        lp.next_to(ratio, LEFT, buff = 0)\n",
        "        rp.next_to(ratio, RIGHT, buff = 0)\n",
        "\n",
        "        extracted_two_to_t = OldTex(\"%s^\"%base_str, \"t\")\n",
        "        extracted_two_to_t.next_to(lp, LEFT, buff = SMALL_BUFF)\n",
        "\n",
        "        expressions = [\n",
        "            ratio, two_to_t_two_to_dt, \n",
        "            extracted_two_to_t, lhs, func_def\n",
        "        ]\n",
        "        for expression in expressions:\n",
        "            expression.set_color_by_tex(\"t\", YELLOW)\n",
        "            expression.set_color_by_tex(\"dt\", GREEN)\n",
        "\n",
        "        #Apply exponential property\n",
        "        self.play(\n",
        "            Write(ratio), Write(lhs),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            two_to_t_plus_dt.next_to, exp_prop_brace, UP,\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                two_to_t_plus_dt.copy(), two_to_t_two_to_dt,\n",
        "                run_time = 2,\n",
        "                path_arc = np.pi,\n",
        "            ),\n",
        "            FadeIn(exp_prop_brace)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Talk about exponential property\n",
        "        add_exp_rect, mult_rect = rects = [\n",
        "            Rectangle(\n",
        "                stroke_color = BLUE,\n",
        "                stroke_width = 2,\n",
        "            ).replace(mob).scale(1.1)\n",
        "            for mob in [\n",
        "                VGroup(*two_to_t_plus_dt[1:]),\n",
        "                two_to_t_two_to_dt\n",
        "            ]\n",
        "        ]\n",
        "        words = VGroup(*[\n",
        "            OldTexText(s, \" ideas\")\n",
        "            for s in (\"Additive\", \"Multiplicative\")\n",
        "        ])\n",
        "        words[0].move_to(words[1], LEFT)\n",
        "        words.set_color(BLUE)\n",
        "        words.next_to(two_to_t_plus_dt, RIGHT, buff = 1.5*LARGE_BUFF)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(word.get_left(), rect, color = words.get_color())\n",
        "            for word, rect in zip(words, rects)\n",
        "        ])\n",
        "\n",
        "        self.play(ShowCreation(add_exp_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            add_exp_rect.copy(), mult_rect\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.change_mode(\"happy\")\n",
        "        self.play(Write(words[0], run_time = 2))\n",
        "        self.play(ShowCreation(arrows[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(*words),\n",
        "            Transform(*arrows),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            words[0], arrows[0], add_exp_rect, mult_rect,\n",
        "            two_to_t_plus_dt, exp_prop_brace,\n",
        "        ])))\n",
        "\n",
        "        #Factor out 2^t\n",
        "        self.play(*[\n",
        "            FadeIn(\n",
        "                mob,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            )\n",
        "            for mob in (one, lp, rp)\n",
        "        ] + [\n",
        "            ReplacementTransform(\n",
        "                mob, extracted_two_to_t,\n",
        "                path_arc = np.pi/2,\n",
        "                run_time = 2,\n",
        "            )\n",
        "            for mob in (two_to_t, VGroup(*two_to_t_two_to_dt[:2]))\n",
        "        ] + [\n",
        "            lhs.next_to, extracted_two_to_t, LEFT\n",
        "        ])\n",
        "        self.change_mode(\"pondering\")\n",
        "        shifter = VGroup(ratio[4], one, *two_to_t_two_to_dt[2:])\n",
        "        stretcher = VGroup(lp, ratio[7], rp)\n",
        "        self.play(\n",
        "            shifter.next_to, ratio[7], UP,\n",
        "            stretcher.stretch_in_place, 0.9, 0\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Ask about dt -> 0\n",
        "        brace = Brace(VGroup(extracted_two_to_t, ratio), DOWN)\n",
        "        alt_brace = Brace(parens, DOWN)\n",
        "        dt_to_zero = OldTex(\"dt\", \"\\\\to 0\")\n",
        "        dt_to_zero.set_color_by_tex(\"dt\", GREEN)\n",
        "        dt_to_zero.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(dt_to_zero))\n",
        "        self.wait(2)\n",
        "\n",
        "        #Who cares\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.7)\n",
        "        randy.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            self.pi_creature.change_mode, \"plain\",\n",
        "        )\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Who cares?\", \n",
        "            bubble_config = {\"direction\" : LEFT},\n",
        "            target_mode = \"angry\",\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(randy),\n",
        "            FadeOut(randy),\n",
        "            self.pi_creature.change_mode, \"hooray\",\n",
        "            self.pi_creature.look_at, parens\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(brace, alt_brace),\n",
        "            dt_to_zero.next_to, alt_brace, DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Highlight separation\n",
        "        rects = [\n",
        "            Rectangle(\n",
        "                stroke_color = color,\n",
        "                stroke_width = 2,\n",
        "            ).replace(mob, stretch = True).scale(1.1)\n",
        "            for mob, color in [\n",
        "                (VGroup(parens, dt_to_zero), GREEN), \n",
        "                (extracted_two_to_t, YELLOW),\n",
        "            ]\n",
        "        ]\n",
        "        self.play(ShowCreation(rects[0]))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(rects[0].copy(), rects[1]))\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, rects)))\n",
        "\n",
        "        #Plug in specific values\n",
        "        static_constant = self.try_specific_dt_values()\n",
        "        constant = static_constant.copy()\n",
        "\n",
        "        #Replace with actual constant\n",
        "        limit_term = VGroup(\n",
        "            brace, dt_to_zero, ratio[4], one, rects[0],\n",
        "            *ratio[7:]+two_to_t_two_to_dt[2:]\n",
        "        )\n",
        "        self.play(FadeIn(rects[0]))\n",
        "        self.play(limit_term.to_corner, DOWN+LEFT)\n",
        "        self.play(\n",
        "            lp.stretch, 0.5, 1,\n",
        "            lp.stretch, 0.8, 0,\n",
        "            lp.next_to, extracted_two_to_t[0], RIGHT,\n",
        "            rp.stretch, 0.5, 1,\n",
        "            rp.stretch, 0.8, 0,\n",
        "            rp.next_to, lp, RIGHT, SMALL_BUFF,\n",
        "            rp.shift, constant.get_width()*RIGHT,\n",
        "            constant.next_to, extracted_two_to_t[0], RIGHT, MED_LARGE_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "\n",
        "        #Indicate distinction between dt group and t group again\n",
        "        for mob in limit_term, extracted_two_to_t:\n",
        "            self.play(FocusOn(mob))\n",
        "            self.play(Indicate(mob))\n",
        "        self.wait()\n",
        "\n",
        "        #hold_final_value\n",
        "        derivative = VGroup(\n",
        "            lhs, extracted_two_to_t, parens, constant\n",
        "        )\n",
        "        func_def_rhs = VGroup(*func_def[-2:]).copy()\n",
        "        func_lp, func_rp = func_parens = OldTex(\"()\")\n",
        "        func_parens.set_fill(opacity = 0)\n",
        "        func_lp.next_to(func_def_rhs[0], LEFT, buff = 0)\n",
        "        func_rp.next_to(func_lp, RIGHT, buff = func_def_rhs.get_width())\n",
        "        func_def_rhs.add(func_parens)\n",
        "        M = lhs[0][1]\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(M),\n",
        "            func_def_rhs.move_to, M, LEFT,\n",
        "            func_def_rhs.set_fill, None, 1,\n",
        "        )\n",
        "        lhs[0].submobjects[1] = func_def_rhs\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            derivative.next_to, self.pi_creature, UP,\n",
        "            derivative.to_edge, RIGHT,\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for mob in extracted_two_to_t, constant:\n",
        "            self.play(Indicate(mob))\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "    def try_specific_dt_values(self):\n",
        "        expressions = []\n",
        "        for num_zeros in [1, 2, 4, 7]:\n",
        "            dt_str = \"0.\" + num_zeros*\"0\" + \"1\"\n",
        "            dt_num = float(dt_str)\n",
        "            output_num = (self.base**dt_num - 1) / dt_num\n",
        "            output_str = \"%.7f\\\\dots\"%output_num\n",
        "\n",
        "            expression = OldTex(\n",
        "                \"{%s^\"%self.base_str, \"{%s}\"%dt_str, \"-1\", \n",
        "                \"\\\\over \\\\,\", \"%s}\"%dt_str, \n",
        "                \"=\", output_str\n",
        "            )\n",
        "            expression.set_color_by_tex(dt_str, GREEN)\n",
        "            expression.set_color_by_tex(output_str, BLUE)\n",
        "            expression.to_corner(UP+RIGHT)\n",
        "            expressions.append(expression)\n",
        "\n",
        "        curr_expression = expressions[0]\n",
        "        self.play(\n",
        "            Write(curr_expression),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for expression in expressions[1:]:\n",
        "            self.play(Transform(curr_expression, expression))\n",
        "            self.wait(2)\n",
        "        return curr_expression[-1]\n",
        "\n",
        "class ExponentRatioWithThree(AnalyzeExponentRatio):\n",
        "    CONFIG = {\n",
        "        \"base\" : 3,\n",
        "        \"base_str\" : \"3\",\n",
        "    }\n",
        "\n",
        "class ExponentRatioWithSeven(AnalyzeExponentRatio):\n",
        "    CONFIG = {\n",
        "        \"base\" : 7,\n",
        "        \"base_str\" : \"7\",\n",
        "    }\n",
        "\n",
        "class ExponentRatioWithEight(AnalyzeExponentRatio):\n",
        "    CONFIG = {\n",
        "        \"base\" : 8,\n",
        "        \"base_str\" : \"8\",\n",
        "    }\n",
        "\n",
        "class ExponentRatioWithE(AnalyzeExponentRatio):\n",
        "    CONFIG = {\n",
        "        \"base\" : np.exp(1),\n",
        "        \"base_str\" : \"e\",\n",
        "    }\n",
        "\n",
        "class CompareTwoConstantToEightConstant(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        two_deriv, eight_deriv = derivs = VGroup(*[\n",
        "            self.get_derivative_expression(base)\n",
        "            for base in (2, 8)\n",
        "        ])\n",
        "\n",
        "        derivs.arrange(\n",
        "            DOWN, buff = 1.5, aligned_edge = LEFT\n",
        "        )\n",
        "        derivs.to_edge(LEFT, LARGE_BUFF).shift(UP)\n",
        "        arrow = Arrow(*[deriv[-2] for deriv in derivs])\n",
        "        times_three = OldTex(\"\\\\times 3\")\n",
        "        times_three.next_to(arrow, RIGHT)\n",
        "\n",
        "        why = OldTexText(\"Why?\")\n",
        "        why.next_to(self.pi_creature, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(eight_deriv)\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            eight_deriv.copy(),\n",
        "            two_deriv\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(\n",
        "            Write(times_three),\n",
        "            self.pi_creature.change_mode, \"thinking\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(\n",
        "            Animation(derivs),\n",
        "            Write(why),\n",
        "            self.pi_creature.change, \"confused\", derivs\n",
        "        )\n",
        "        self.wait()\n",
        "        for deriv in derivs:\n",
        "            for index in -5, -2:\n",
        "                self.play(Indicate(deriv[index]))\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_derivative_expression(self, base):\n",
        "        base_str = str(base)\n",
        "        const_str = \"%.4f\\\\dots\"%np.log(base)\n",
        "        result = OldTex(\n",
        "            \"{d(\", base_str, \"^t\", \")\", \"\\\\over\", \"dt}\", \n",
        "            \"=\", base_str, \"^t\", \"(\", const_str, \")\"\n",
        "        )\n",
        "        tex_color_paris = [\n",
        "            (\"t\", YELLOW), \n",
        "            (\"dt\", GREEN), \n",
        "            (const_str, BLUE)\n",
        "        ]\n",
        "        for tex, color in tex_color_paris:\n",
        "            result.set_color_by_tex(tex, color)\n",
        "        return result\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Randolph().flip()\n",
        "        self.pi_creature.to_edge(DOWN).shift(3*RIGHT)\n",
        "        return self.pi_creature\n",
        "\n",
        "class AskAboutConstantOne(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        note = OldTex(\n",
        "            \"{ d(a^\", \"t\", \")\", \"\\\\over \\\\,\", \"dt}\", \n",
        "            \"=\", \"a^\", \"t\", \"(\\\\text{Some constant})\"\n",
        "        )\n",
        "        note.set_color_by_tex(\"t\", YELLOW)\n",
        "        note.set_color_by_tex(\"dt\", GREEN)\n",
        "        note.set_color_by_tex(\"constant\", BLUE)\n",
        "        note.to_corner(UP+LEFT)\n",
        "        self.add(note)\n",
        "\n",
        "        self.student_says(\n",
        "            \"Is there a base where\\\\\\\\\",\n",
        "            \"that constant is 1?\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"raise_right_hand\", \"thinking\",\n",
        "            # look_at = self.get_students()[1].bubble\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(note[-1], run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"There is!\\\\\\\\\",\n",
        "            \"$e = 2.71828\\\\dots$\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class WhyPi(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius = 1, color = MAROON_B)\n",
        "        circle.rotate(np.pi/2)\n",
        "        circle.to_edge(UP)\n",
        "        ghost_circle = circle.copy()\n",
        "        ghost_circle.set_stroke(width = 1)\n",
        "        diam = Line(circle.get_left(), circle.get_right())\n",
        "        diam.set_color(YELLOW)\n",
        "        one = OldTex(\"1\")\n",
        "        one.next_to(diam, UP)\n",
        "        circum = diam.copy()\n",
        "        circum.set_color(circle.get_color())\n",
        "        circum.scale(np.pi)\n",
        "        circum.next_to(circle, DOWN, LARGE_BUFF)\n",
        "        circum.insert_n_curves(circle.get_num_curves()-2)\n",
        "        circum.make_jagged()\n",
        "        pi = OldTex(\"\\\\pi\")\n",
        "        pi.next_to(circum, UP)\n",
        "        why = OldTexText(\"Why?\")\n",
        "        why.next_to(self.pi_creature, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(ghost_circle, circle, diam, one)\n",
        "        self.wait()\n",
        "        self.play(Transform(circle, circum, run_time = 2))\n",
        "        self.play(\n",
        "            Write(pi),\n",
        "            Write(why),\n",
        "            self.pi_creature.change_mode, \"confused\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "    #######\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.pi_creature = Randolph()\n",
        "        self.pi_creature.to_corner(DOWN+LEFT)\n",
        "        return self.pi_creature\n",
        "\n",
        "class GraphOfExp(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -3,\n",
        "        \"x_max\" : 3,\n",
        "        \"x_tick_frequency\" : 1,\n",
        "        \"x_axis_label\" : \"t\",\n",
        "        \"x_labeled_nums\" : list(range(-3, 4)),\n",
        "        \"x_axis_width\" : 11,\n",
        "        \"graph_origin\" : 2*DOWN + LEFT,\n",
        "        \"example_inputs\" : [1, 2],\n",
        "        \"small_dx\" : 0.01,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.show_slopes()\n",
        "\n",
        "    def show_slopes(self):\n",
        "        graph = self.get_graph(np.exp)\n",
        "        graph_label = self.get_graph_label(\n",
        "            graph, \"e^t\", direction = LEFT\n",
        "        )\n",
        "        graph_label.shift(MED_SMALL_BUFF*LEFT)\n",
        "\n",
        "        start_input, target_input = self.example_inputs\n",
        "        ss_group = self.get_secant_slope_group(\n",
        "            start_input, graph,\n",
        "            dx = self.small_dx,\n",
        "            dx_label = \"dt\",\n",
        "            df_label = \"d(e^t)\",\n",
        "            secant_line_color = YELLOW,\n",
        "        )\n",
        "        v_lines = [\n",
        "            self.get_vertical_line_to_graph(\n",
        "                x, graph, \n",
        "                color = WHITE,\n",
        "            )\n",
        "            for x in self.example_inputs\n",
        "        ]\n",
        "        height_labels = [\n",
        "            OldTex(\"e^%d\"%x).next_to(vl, RIGHT, SMALL_BUFF)\n",
        "            for vl, x in zip(v_lines, self.example_inputs)\n",
        "        ]\n",
        "        slope_labels = [\n",
        "            OldTexText(\n",
        "                \"Slope = $e^%d$\"%x\n",
        "            ).next_to(vl.get_top(), UP+RIGHT).shift(0.7*RIGHT/x)\n",
        "           for vl, x in zip(v_lines, self.example_inputs)\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph, run_time = 2),\n",
        "            Write(\n",
        "                graph_label, \n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShowCreation, ss_group)))\n",
        "        self.play(Write(slope_labels[0]))\n",
        "        self.play(ShowCreation(v_lines[0]))\n",
        "        self.play(Write(height_labels[0]))\n",
        "        self.wait(2)\n",
        "        self.animate_secant_slope_group_change(\n",
        "            ss_group,\n",
        "            target_x = target_input,\n",
        "            run_time = 2,\n",
        "            added_anims = [\n",
        "                Transform(\n",
        "                    *pair, \n",
        "                    path_arc = np.pi/6,\n",
        "                    run_time = 2\n",
        "                )\n",
        "                for pair in [\n",
        "                    slope_labels,\n",
        "                    v_lines,\n",
        "                    height_labels,\n",
        "                ]\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.graph = graph\n",
        "        self.ss_group = ss_group\n",
        "\n",
        "class Chapter4Wrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Chapter 4 chain rule intuition\")\n",
        "        title.to_edge(UP)\n",
        "        rect = Rectangle(width = 16, height = 9)\n",
        "        rect.set_height(1.5*FRAME_Y_RADIUS)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class ApplyChainRule(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        deriv_equation = OldTex(\n",
        "            \"{d(\", \"e^\", \"{3\", \"t}\", \")\", \"\\\\over\", \"dt}\",\n",
        "            \"=\", \"3\", \"e^\", \"{3\", \"t}\",\n",
        "        )\n",
        "        deriv_equation.next_to(self.teacher, UP+LEFT)\n",
        "        deriv_equation.shift(UP)\n",
        "        deriv_equation.set_color_by_tex(\"3\", BLUE)\n",
        "        deriv = VGroup(*deriv_equation[:7])\n",
        "        exponent = VGroup(*deriv_equation[-2:])\n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(exponent, stretch = True)\n",
        "        circle.scale(1.5)\n",
        "\n",
        "        self.teacher_says(\"Think of the \\\\\\\\ chain rule\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.play(\n",
        "            Write(deriv),\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode = \"raise_right_hand\"\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                *deriv_equation.get_parts_by_tex(\n",
        "                    tex, substring = False\n",
        "                ).copy()[:2],\n",
        "                path_arc = -np.pi,\n",
        "                run_time = 2\n",
        "            )\n",
        "            for tex in (\"e^\", \"{3\", \"t}\")\n",
        "        ] + [\n",
        "            Write(deriv_equation.get_part_by_tex(\"=\"))\n",
        "        ])\n",
        "        self.play(self.teacher.change_mode, \"happy\")\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(Transform(\n",
        "            *deriv_equation.get_parts_by_tex(\"3\").copy()[-1:-3:-1]\n",
        "        ))\n",
        "        self.play(FadeOut(circle))\n",
        "        self.wait(3)\n",
        "\n",
        "class ChainRuleIntuition(ThreeLinesChainRule):\n",
        "    CONFIG = {\n",
        "        \"line_configs\" : [\n",
        "            {\n",
        "                \"func\" : lambda t : t,\n",
        "                \"func_label\" : \"t\",\n",
        "                \"triangle_color\" : WHITE,\n",
        "                \"center_y\" : 3,\n",
        "                \"x_min\" : 0,\n",
        "                \"x_max\" : 3,\n",
        "                \"numbers_to_show\" : list(range(4)),\n",
        "                \"big_tick_numbers\" : list(range(4)),\n",
        "                \"tick_frequency\" : 1,\n",
        "            },\n",
        "            {\n",
        "                \"func\" : lambda t : 3*t,\n",
        "                \"func_label\" : \"3t\",\n",
        "                \"triangle_color\" : GREEN,\n",
        "                \"center_y\" : 0.5,\n",
        "                \"x_min\" : 0,\n",
        "                \"x_max\" : 3,\n",
        "                \"numbers_to_show\" : list(range(0, 4)),\n",
        "                \"big_tick_numbers\" : list(range(4)),\n",
        "                \"tick_frequency\" : 1,\n",
        "            },\n",
        "            {\n",
        "                \"func\" : lambda t : np.exp(3*t),\n",
        "                \"func_label\" : \"e^{3t}\",\n",
        "                \"triangle_color\" : BLUE,\n",
        "                \"center_y\" : -2,\n",
        "                \"x_min\" : 0,\n",
        "                \"x_max\" : 10,\n",
        "                \"numbers_to_show\" : list(range(0, 11, 3)),\n",
        "                \"big_tick_numbers\" : list(range(11)),\n",
        "                \"tick_frequency\" : 1,\n",
        "            },\n",
        "        ],\n",
        "        \"example_x\" : 0.4,\n",
        "        \"start_x\" : 0.4,\n",
        "        \"max_x\" : 0.6,\n",
        "        \"min_x\" : 0.2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.introduce_line_group()\n",
        "        self.nudge_x()\n",
        "\n",
        "    def nudge_x(self):\n",
        "        lines, labels = self.line_group\n",
        "        def get_value_points():\n",
        "            return [\n",
        "                label[0].get_bottom()\n",
        "                for label in labels\n",
        "            ]\n",
        "        starts = get_value_points()\n",
        "        self.animate_x_change(self.example_x + self.dx, run_time = 0)\n",
        "        ends = get_value_points()\n",
        "        self.animate_x_change(self.example_x, run_time = 0)\n",
        "\n",
        "        nudge_lines = VGroup()\n",
        "        braces = VGroup()\n",
        "        numbers = VGroup()\n",
        "        for start, end, line, label, config in zip(starts, ends, lines, labels, self.line_configs):\n",
        "            color = label[0].get_color()\n",
        "            nudge_line = Line(start, end)\n",
        "            nudge_line.set_stroke(color, width = 6)\n",
        "            brace = Brace(nudge_line, DOWN, buff = SMALL_BUFF)\n",
        "            brace.set_color(color)\n",
        "            func_label = config[\"func_label\"]\n",
        "            if len(func_label) == 1:\n",
        "                text = \"$d%s$\"%func_label\n",
        "            else:\n",
        "                text = \"$d(%s)$\"%func_label\n",
        "            brace.text = brace.get_text(text, buff = SMALL_BUFF)\n",
        "            brace.text.set_color(color)\n",
        "            brace.add(brace.text)\n",
        "\n",
        "            line.add(nudge_line)\n",
        "            nudge_lines.add(nudge_line)\n",
        "            braces.add(brace)\n",
        "            numbers.add(line.numbers)\n",
        "            line.remove(*line.numbers)\n",
        "        dt_brace, d3t_brace, dexp3t_brace = braces\n",
        "\n",
        "        self.play(*list(map(FadeIn, [nudge_lines, braces])))\n",
        "        self.wait()\n",
        "        for count in range(3):\n",
        "            for dx in self.dx, 0:\n",
        "                self.animate_x_change(\n",
        "                    self.example_x + dx, \n",
        "                    run_time = 2\n",
        "                )\n",
        "        self.wait()\n",
        "\n",
        "class WhyNaturalLogOf2ShowsUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_e_to_the_three_t()\n",
        "        self.show_e_to_log_2()\n",
        "\n",
        "    def add_e_to_the_three_t(self):\n",
        "        exp_c = self.get_exp_C(\"c\")\n",
        "        exp_c.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                exp_c, \n",
        "                run_time = 2, \n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.look_at(4*LEFT + UP)\n",
        "        self.wait(3)\n",
        "\n",
        "        self.exp_c = exp_c\n",
        "\n",
        "    def show_e_to_log_2(self):\n",
        "        equation = OldTex(\n",
        "            \"2\", \"^t\", \"= e^\", \"{\\\\ln(2)\", \"t}\"\n",
        "        )\n",
        "        equation.move_to(self.exp_c)\n",
        "        t_group = equation.get_parts_by_tex(\"t\")\n",
        "        non_t_group = VGroup(*equation)\n",
        "        non_t_group.remove(*t_group)\n",
        "\n",
        "        log_words = OldTexText(\"``$e$ to the \", \"\\\\emph{what}\", \"equals 2?''\")\n",
        "        log_words.set_color_by_tex(\"what\", BLUE)\n",
        "        log_words.next_to(equation, UP+LEFT)\n",
        "        log_words_arrow = Arrow(\n",
        "            log_words.get_right(),\n",
        "            equation.get_part_by_tex(\"ln(2)\").get_corner(UP+LEFT),\n",
        "            color = BLUE,\n",
        "        )\n",
        "\n",
        "        derivative = OldTex(\n",
        "            \"\\\\ln(2)\", \"2\", \"^t\", \"=\", \"\\\\ln(2)\", \"e^\", \"{\\\\ln(2)\", \"t}\"\n",
        "        )\n",
        "        derivative.move_to(equation)\n",
        "        for tex_mob in equation, derivative:\n",
        "            tex_mob.set_color_by_tex(\"ln(2)\", BLUE)\n",
        "            tex_mob.set_color_by_tex(\"t\", YELLOW)\n",
        "        derivative_arrow = Arrow(1.5*UP, ORIGIN, buff = 0)\n",
        "        derivative_arrow.set_color(WHITE)\n",
        "        derivative_arrow.next_to(\n",
        "            derivative.get_parts_by_tex(\"=\"), UP\n",
        "        )\n",
        "        derivative_symbol = OldTexText(\"Derivative\")\n",
        "        derivative_symbol.next_to(derivative_arrow, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(non_t_group),\n",
        "            self.exp_c.next_to, equation, LEFT, 2*LARGE_BUFF,\n",
        "            self.exp_c.to_edge, UP,\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"erm\")\n",
        "        self.play(\n",
        "            Write(log_words),\n",
        "            ShowCreation(\n",
        "                log_words_arrow, \n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            )\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = log_words\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        t_group.save_state()\n",
        "        t_group.shift(UP)\n",
        "        t_group.set_fill(opacity = 0)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                t_group.restore,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            self.teacher.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FocusOn(self.exp_c))\n",
        "        self.play(Indicate(self.exp_c, scale_factor = 1.05))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.play(\n",
        "            equation.next_to, derivative_arrow, UP,\n",
        "            equation.shift, MED_SMALL_BUFF*RIGHT,\n",
        "            FadeOut(VGroup(log_words, log_words_arrow)),\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(derivative_arrow),\n",
        "            Write(derivative_symbol),\n",
        "            Write(derivative)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(self.teacher.change_mode, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "        student = self.get_students()[1]\n",
        "        ln = derivative.get_part_by_tex(\"ln(2)\").copy()\n",
        "        rhs = OldTex(\"=%s\"%self.get_log_str(2))\n",
        "        self.play(\n",
        "            ln.next_to, student, UP+LEFT, MED_LARGE_BUFF,\n",
        "            student.change_mode, \"raise_left_hand\",\n",
        "        )\n",
        "        rhs.next_to(ln, RIGHT)\n",
        "        self.play(Write(rhs))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_exp_C(self, C):\n",
        "        C_str = str(C)\n",
        "        result = OldTex(\n",
        "            \"{d(\", \"e^\", \"{%s\"%C_str, \"t}\", \")\", \"\\\\over\", \"dt}\",\n",
        "            \"=\", C_str, \"e^\", \"{%s\"%C_str, \"t}\",\n",
        "        )\n",
        "        result.set_color_by_tex(C_str, BLUE)\n",
        "        result.C_str = C_str\n",
        "        return result\n",
        "\n",
        "    def get_a_to_t(self, a):\n",
        "        a_str = str(a)\n",
        "        log_str = self.get_log_str(a)\n",
        "        result = OldTex(\n",
        "            \"{d(\", a_str, \"^t\", \")\", \"\\\\over\", \"dt}\",\n",
        "            \"=\", log_str, a_str, \"^t\"\n",
        "        )\n",
        "        result.set_color_by_tex(log_str, BLUE)\n",
        "        return result\n",
        "\n",
        "    def get_log_str(self, a):\n",
        "        return \"%.4f\\\\dots\"%np.log(float(a))\n",
        "\n",
        "class CompareWaysToWriteExponentials(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"y_max\" : 50,\n",
        "        \"y_tick_frequency\" : 5,\n",
        "        \"x_max\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        bases = list(range(2, 7))\n",
        "        graphs = [\n",
        "            self.get_graph(lambda t : base**t, color = GREEN)\n",
        "            for base in bases\n",
        "        ]\n",
        "        graph = graphs[0]\n",
        "\n",
        "        a_to_t = OldTex(\"a^t\")\n",
        "        a_to_t.move_to(self.coords_to_point(6, 45))\n",
        "\n",
        "        cross = OldTex(\"\\\\times\")\n",
        "        cross.set_color(RED)\n",
        "        cross.replace(a_to_t, stretch = True)\n",
        "        e_to_ct = OldTex(\"e^\", \"{c\", \"t}\")\n",
        "        e_to_ct.set_color_by_tex(\"c\", BLUE)\n",
        "        e_to_ct.scale(1.5)\n",
        "        e_to_ct.next_to(a_to_t, DOWN)\n",
        "\n",
        "        equations = VGroup()\n",
        "        for base in bases:\n",
        "            log_str =  \"%.4f\\\\dots\"%np.log(base)\n",
        "            equation = OldTex(\n",
        "                str(base), \"^t\", \"=\",\n",
        "                \"e^\", \"{(%s)\"%log_str, \"t}\", \n",
        "            )\n",
        "            equation.set_color_by_tex(log_str, BLUE)\n",
        "            equation.scale(1.2)\n",
        "            equations.add(equation)\n",
        "\n",
        "        equation = equations[0]\n",
        "        equations.next_to(e_to_ct, DOWN, LARGE_BUFF, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            Write(\n",
        "                a_to_t,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1) \n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Write(cross, run_time = 2))\n",
        "        self.play(Write(e_to_ct, run_time = 2))\n",
        "        self.wait(2)\n",
        "        self.play(Write(equation))\n",
        "        self.wait(2)\n",
        "        for new_graph, new_equation in zip(graphs, equations)[1:]:\n",
        "            self.play(\n",
        "                Transform(graph, new_graph),\n",
        "                Transform(equation, new_equation)\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.wait()\n",
        "\n",
        "class ManyExponentialForms(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        lhs = OldTex(\"2\", \"^t\")\n",
        "        rhs_list = [\n",
        "            OldTex(\"=\", \"%s^\"%tex, \"{(%.5f\\\\dots)\"%log, \"t}\")\n",
        "            for tex, log in [\n",
        "                (\"e\", np.log(2)),\n",
        "                (\"\\\\pi\", np.log(2)/np.log(np.pi)),\n",
        "                (\"42\", np.log(2)/np.log(42)),\n",
        "            ]\n",
        "        ]\n",
        "        group = VGroup(lhs, *rhs_list)\n",
        "        group.arrange(RIGHT)\n",
        "        group.set_width(FRAME_WIDTH - LARGE_BUFF)\n",
        "        group.next_to(self.get_pi_creatures(), UP, 2*LARGE_BUFF)\n",
        "        for part in group:\n",
        "            part.set_color_by_tex(\"t\", YELLOW)\n",
        "            const = part.get_part_by_tex(\"dots\")\n",
        "            if const:\n",
        "                const.set_color(BLUE)\n",
        "                brace = Brace(const, UP)\n",
        "                log = brace.get_text(\n",
        "                    \"$\\\\log_{%s}(2)$\"%part[1].get_tex()[:-1]\n",
        "                )\n",
        "                log.set_color(BLUE)\n",
        "                part.add(brace, log)\n",
        "        exp = VGroup(*rhs_list[0][1:4])\n",
        "        rect = BackgroundRectangle(group)\n",
        "\n",
        "        self.add(lhs, rhs_list[0])\n",
        "        self.wait()\n",
        "        for rhs in rhs_list[1:]:\n",
        "            self.play(FadeIn(\n",
        "                rhs, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "            ))\n",
        "            self.wait(2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            exp.next_to, self.teacher, UP+LEFT,\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyFunction(\n",
        "                lambda m : m.shift(SMALL_BUFF*UP).set_color(RED),\n",
        "                part,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(there_and_back, a, a+0.3)\n",
        "            )\n",
        "            for part, a in zip(exp[1], np.linspace(0, 0.7, len(exp[1])))\n",
        "        ])\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = exp\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class TooManySymbols(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Too symbol heavy!\",\n",
        "            target_mode = \"pleading\"\n",
        "        )\n",
        "        self.play(self.teacher.change_mode, \"guilty\")\n",
        "        self.wait(3)\n",
        "\n",
        "class TemperatureOverTimeOfWarmWater(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : 0,\n",
        "        \"x_axis_label\" : \"$t$\",\n",
        "        \"y_axis_label\" : \"Temperature\",\n",
        "        \"T_room\" : 4,\n",
        "        \"include_solution\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(\n",
        "            lambda t : 3*np.exp(-0.3*t) + self.T_room,\n",
        "            color = RED\n",
        "        )\n",
        "        h_line = DashedLine(*[\n",
        "            self.coords_to_point(x, self.T_room)\n",
        "            for x in (self.x_min, self.x_max)\n",
        "        ])\n",
        "        T_room_label = OldTex(\"T_{\\\\text{room}}\")\n",
        "        T_room_label.next_to(h_line, LEFT)\n",
        "\n",
        "        ode = OldTex(\n",
        "            \"\\\\frac{d\\\\Delta T}{dt} = -k \\\\Delta T\"\n",
        "        )\n",
        "        ode.to_corner(UP+RIGHT)\n",
        "\n",
        "        solution = OldTex(\n",
        "            \"\\\\Delta T(\", \"t\", \") = e\", \"^{-k\", \"t}\"\n",
        "        )\n",
        "        solution.next_to(ode, DOWN, MED_LARGE_BUFF)\n",
        "        solution.set_color_by_tex(\"t\", YELLOW)\n",
        "        solution.set_color_by_tex(\"Delta\", WHITE)\n",
        "\n",
        "        delta_T_brace = Brace(graph, RIGHT)\n",
        "        delta_T_label = OldTex(\"\\\\Delta T\")\n",
        "        delta_T_group = VGroup(delta_T_brace, delta_T_label)\n",
        "        def update_delta_T_group(group):\n",
        "            brace, label = group\n",
        "            v_line = Line(\n",
        "                graph.get_points()[-1],\n",
        "                graph.get_points()[-1][0]*RIGHT + h_line.get_center()[1]*UP\n",
        "            )\n",
        "            brace.set_height(v_line.get_height())\n",
        "            brace.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "            label.set_height(min(\n",
        "                label.get_height(),\n",
        "                brace.get_height()\n",
        "            ))\n",
        "            label.next_to(brace, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.add(ode)\n",
        "        self.play(\n",
        "            Write(T_room_label),\n",
        "            ShowCreation(h_line, run_time = 2)\n",
        "        )\n",
        "        if self.include_solution:\n",
        "            self.play(Write(solution))\n",
        "        graph_growth = ShowCreation(graph, rate_func=linear)\n",
        "        delta_T_group_update = UpdateFromFunc(\n",
        "            delta_T_group, update_delta_T_group\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(delta_T_brace),\n",
        "            Write(delta_T_label),\n",
        "        )\n",
        "        self.play(graph_growth, delta_T_group_update, run_time = 15)\n",
        "        self.wait(2)\n",
        "\n",
        "class TemperatureOverTimeOfWarmWaterWithSolution(TemperatureOverTimeOfWarmWater):\n",
        "    CONFIG = {\n",
        "        \"include_solution\" : True\n",
        "    }\n",
        "\n",
        "class InvestedMoney(Scene):\n",
        "    def construct(self):\n",
        "        # cash_str = \"\\\\$\\\\$\\\\$\"\n",
        "        cash_str = \"M\"\n",
        "        equation = OldTex(\n",
        "            \"{d\", cash_str, \"\\\\over\", \"dt}\",\n",
        "            \"=\", \"(1 + r)\", cash_str\n",
        "        )\n",
        "        equation.set_color_by_tex(cash_str, GREEN)\n",
        "        equation.next_to(ORIGIN, LEFT)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(LEFT, RIGHT, color = WHITE)\n",
        "        arrow.next_to(equation)\n",
        "\n",
        "        solution = OldTex(\n",
        "            cash_str, \"(\", \"t\", \")\", \"=\", \"e^\", \"{(1+r)\", \"t}\"\n",
        "        )\n",
        "        solution.set_color_by_tex(\"t\", YELLOW)\n",
        "        solution.set_color_by_tex(cash_str, GREEN)\n",
        "        solution.next_to(arrow, RIGHT)\n",
        "\n",
        "        cash = OldTex(\"\\\\$\")\n",
        "        cash_pile = VGroup(*[\n",
        "            cash.copy().shift(\n",
        "                x*(1+MED_SMALL_BUFF)*cash.get_width()*RIGHT +\\\n",
        "                y*(1+MED_SMALL_BUFF)*cash.get_height()*UP\n",
        "            )\n",
        "            for x in range(40)\n",
        "            for y in range(8)\n",
        "        ])\n",
        "        cash_pile.set_color(GREEN)\n",
        "        cash_pile.center()\n",
        "        cash_pile.shift(DOWN)\n",
        "\n",
        "        anims = []\n",
        "        cash_size = len(cash_pile)\n",
        "        run_time = 10\n",
        "        const = np.log(cash_size)/run_time\n",
        "        for i, cash in enumerate(cash_pile):\n",
        "            start_time = np.log(i+1)/const\n",
        "            prop = start_time/run_time\n",
        "            rate_func = squish_rate_func(\n",
        "                smooth,\n",
        "                np.clip(prop-0.5/run_time, 0, 1),\n",
        "                np.clip(prop+0.5/run_time, 0, 1),\n",
        "            )\n",
        "            anims.append(GrowFromCenter(\n",
        "                cash, rate_func = rate_func,\n",
        "            ))\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(*anims, run_time = run_time)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(solution, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(cash_pile))\n",
        "        self.play(*anims, run_time = run_time)\n",
        "        self.wait()\n",
        "\n",
        "class NaturalLog(Scene):\n",
        "    def construct(self):\n",
        "        expressions = VGroup(*list(map(self.get_expression, [2, 3, 7])))\n",
        "        expressions.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        expressions.to_edge(LEFT)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            expressions, \n",
        "            run_time = 3, \n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            expressions.set_fill, None, 1,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        )\n",
        "        self.wait()\n",
        "        for i in 0, 2, 1:\n",
        "            self.show_natural_loggedness(expressions[i])\n",
        "\n",
        "    def show_natural_loggedness(self, expression):\n",
        "        base, constant = expression[1], expression[-3]\n",
        "\n",
        "        log_constant, exp_constant = constant.copy(), constant.copy()\n",
        "        log_base, exp_base = base.copy(), base.copy()\n",
        "        log_equals, exp_equals = list(map(Tex, \"==\"))\n",
        "\n",
        "        ln = OldTex(\"\\\\ln(2)\")\n",
        "        log_base.move_to(ln[-2])        \n",
        "        ln.remove(ln[-2])\n",
        "        log_equals.next_to(ln, LEFT)\n",
        "        log_constant.next_to(log_equals, LEFT)\n",
        "        log_expression = VGroup(\n",
        "            ln, log_constant, log_equals, log_base\n",
        "        )\n",
        "\n",
        "        e = OldTex(\"e\")\n",
        "        exp_constant.scale(0.7)\n",
        "        exp_constant.next_to(e, UP+RIGHT, buff = 0)\n",
        "        exp_base.next_to(exp_equals, RIGHT)\n",
        "        VGroup(exp_base, exp_equals).next_to(\n",
        "            VGroup(e, exp_constant), RIGHT, \n",
        "            aligned_edge = DOWN\n",
        "        )\n",
        "        exp_expression = VGroup(\n",
        "            e, exp_constant, exp_equals, exp_base\n",
        "        )\n",
        "\n",
        "        for group, vect in (log_expression, UP), (exp_expression, DOWN):\n",
        "            group.to_edge(RIGHT)\n",
        "            group.shift(vect)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(base.copy(), log_base),\n",
        "            ReplacementTransform(constant.copy(), log_constant),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(Write(ln), Write(log_equals))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                log_expression.copy(),\n",
        "                exp_expression,\n",
        "                run_time = 2,\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        ln_a = expression[-1]\n",
        "        self.play(\n",
        "            FadeOut(expression[-2]),\n",
        "            FadeOut(constant),\n",
        "            ln_a.move_to, constant, LEFT,\n",
        "            ln_a.set_color, BLUE\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [log_expression, exp_expression])))\n",
        "        self.wait()\n",
        "\n",
        "    def get_expression(self, base):\n",
        "        expression = OldTex(\n",
        "            \"{d(\", \"%d^\"%base, \"t\", \")\", \"\\\\over \\\\,\", \"dt}\",\n",
        "            \"=\", \"%d^\"%base, \"t\", \"(%.4f\\\\dots)\"%np.log(base),\n",
        "        )\n",
        "        expression.set_color_by_tex(\"t\", YELLOW)\n",
        "        expression.set_color_by_tex(\"dt\", GREEN)\n",
        "        expression.set_color_by_tex(\"\\\\dots\", BLUE)\n",
        "\n",
        "        brace = Brace(expression.get_part_by_tex(\"\\\\dots\"), UP)\n",
        "        brace_text = brace.get_text(\"$\\\\ln(%d)$\"%base)\n",
        "        for mob in brace, brace_text:\n",
        "            mob.set_fill(opacity = 0)\n",
        "\n",
        "        expression.add(brace, brace_text)\n",
        "        return expression\n",
        "\n",
        "class NextVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[3]\n",
        "        next_video = series[4]\n",
        "        brace = Brace(this_video, DOWN)\n",
        "        this_video.save_state()\n",
        "        this_video.set_color(YELLOW)\n",
        "\n",
        "        this_tex = OldTex(\n",
        "            \"{d(\", \"a^t\", \") \\\\over dt} = \", \"a^t\", \"\\\\ln(a)\"\n",
        "        )\n",
        "        this_tex[1][1].set_color(YELLOW)\n",
        "        this_tex[3][1].set_color(YELLOW)\n",
        "        this_tex.next_to(brace, DOWN)\n",
        "\n",
        "        next_tex = VGroup(*list(map(TexText, [\n",
        "            \"Chain rule\", \"Product rule\", \"$\\\\vdots$\"\n",
        "        ])))\n",
        "        next_tex.arrange(DOWN)\n",
        "        next_tex.next_to(brace, DOWN)\n",
        "        next_tex.shift(\n",
        "            next_video.get_center()[0]*RIGHT\\\n",
        "            -next_tex.get_center()[0]*RIGHT\n",
        "        )\n",
        "\n",
        "        self.add(series, brace, *this_tex[:3])\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"pondering\", \"erm\",\n",
        "            look_at = this_tex\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            this_tex[1].copy(), this_tex[3]\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(this_tex[4]),\n",
        "            ReplacementTransform(\n",
        "                this_tex[3][0].copy(),\n",
        "                this_tex[4][3],\n",
        "                path_arc = np.pi,\n",
        "                remover = True\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(this_tex.replace, this_video)\n",
        "        self.play(\n",
        "            brace.next_to, next_video, DOWN,\n",
        "            this_video.restore,\n",
        "            Animation(this_tex),\n",
        "            next_video.set_color, YELLOW,\n",
        "            Write(next_tex),\n",
        "            self.get_teacher().change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = next_tex\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class ExpPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali  Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Nathan Pellegrin\",\n",
        "            \"Karan Bhargava\", \n",
        "            \"Justin Helps\",\n",
        "            \"Ankit   Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Daan Smedinga\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Albert Nguyen\",\n",
        "            \"Nils Schneider\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(GraphOfTwoToT):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"x_labeled_nums\" : None,\n",
        "        \"y_labeled_nums\" : None,\n",
        "        \"y_max\" : 32,\n",
        "        \"y_tick_frequency\" : 4,\n",
        "        \"graph_origin\" : 3*DOWN + 5*LEFT,\n",
        "        \"x_axis_width\" : 12,\n",
        "    }\n",
        "    def construct(self):\n",
        "        derivative = OldTex(\n",
        "            \"\\\\frac{d(a^t)}{dt} =\", \"a^t \\\\ln(a)\"\n",
        "        )\n",
        "        derivative[0][3].set_color(YELLOW)\n",
        "        derivative[1][1].set_color(YELLOW)\n",
        "        derivative[0][2].set_color(BLUE)\n",
        "        derivative[1][0].set_color(BLUE)\n",
        "        derivative[1][5].set_color(BLUE)\n",
        "        derivative.scale(2)\n",
        "        derivative.add_background_rectangle()\n",
        "        derivative.to_corner(DOWN+RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        # brace = Brace(Line(LEFT, RIGHT), UP)\n",
        "        # brace.set_width(derivative[1].get_width())\n",
        "        # brace.next_to(derivative[1], UP)\n",
        "        # question = OldTexText(\"Why?\")\n",
        "        # question.scale(2.5)\n",
        "        # question.next_to(brace, UP)\n",
        "\n",
        "        # randy = Randolph()\n",
        "        # randy.scale(1.3)\n",
        "        # randy.next_to(ORIGIN, LEFT).to_edge(DOWN)\n",
        "        # randy.change_mode(\"pondering\")\n",
        "\n",
        "        question = OldTexText(\"What is $e\\\\,$?\")\n",
        "        e = question[-2]\n",
        "        e.scale(1.2, about_point = e.get_bottom())\n",
        "        e.set_color(BLUE)\n",
        "        question.scale(3)\n",
        "        question.add_background_rectangle()\n",
        "        question.to_edge(UP)\n",
        "        # randy.look_at(question)\n",
        "\n",
        "        self.setup_axes()\n",
        "        graph = self.get_graph(np.exp)\n",
        "        graph.set_stroke(YELLOW, 8)\n",
        "\n",
        "        self.add(graph, question, derivative)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}