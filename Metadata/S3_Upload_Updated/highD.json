{
    "topic": "demonstrates the concept of a slider, which is a mathematical tool used to explore and manipulate",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "##########\n",
        "#force_skipping\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "##########\n",
        "\n",
        "class Slider(NumberLine):\n",
        "    CONFIG = {\n",
        "        \"color\" : WHITE,\n",
        "        \"x_min\" : -1,\n",
        "        \"x_max\" : 1,\n",
        "        \"unit_size\" : 2,\n",
        "        \"center_value\" : 0,\n",
        "        \"number_scale_val\" : 0.75,\n",
        "        \"label_scale_val\" : 1,\n",
        "        \"big_tick_numbers\" : [],\n",
        "        \"line_to_number_vect\" : LEFT,\n",
        "        \"line_to_number_buff\" : MED_LARGE_BUFF,\n",
        "        \"dial_radius\" : 0.1,\n",
        "        \"dial_color\" : YELLOW,\n",
        "        \"include_real_estate_ticks\" : True,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        NumberLine.__init__(self, **kwargs)\n",
        "        self.rotate(np.pi/2)\n",
        "        self.init_dial()\n",
        "        if self.include_real_estate_ticks:\n",
        "            self.add_real_estate_ticks()\n",
        "\n",
        "    def init_dial(self):\n",
        "        dial = Dot(\n",
        "            radius = self.dial_radius,\n",
        "            color = self.dial_color,\n",
        "        )\n",
        "        dial.move_to(self.number_to_point(self.center_value))\n",
        "        re_dial = dial.copy()\n",
        "        re_dial.set_fill(opacity = 0)\n",
        "        self.add(dial, re_dial)\n",
        "\n",
        "        self.dial = dial\n",
        "        self.re_dial = re_dial\n",
        "        self.last_sign = -1\n",
        "\n",
        "    def add_label(self, tex):\n",
        "        label = OldTex(tex)\n",
        "        label.scale(self.label_scale_val)\n",
        "        label.move_to(self.get_top())\n",
        "        label.shift(MED_LARGE_BUFF*UP)\n",
        "        self.add(label)\n",
        "        self.label = label\n",
        "\n",
        "    def add_real_estate_ticks(\n",
        "        self, \n",
        "        re_per_tick = 0.05,\n",
        "        colors = [BLUE, RED],\n",
        "        max_real_estate = 1,\n",
        "        ):\n",
        "        self.real_estate_ticks = VGroup(*[   \n",
        "            self.get_tick(self.center_value + u*np.sqrt(x + re_per_tick))\n",
        "            for x in np.arange(0, max_real_estate, re_per_tick)\n",
        "            for u in [-1, 1]\n",
        "        ])\n",
        "        self.real_estate_ticks.set_stroke(width = 3)\n",
        "        self.real_estate_ticks.set_color_by_gradient(*colors)\n",
        "        self.add(self.real_estate_ticks)\n",
        "        self.add(self.dial)\n",
        "        return self.real_estate_ticks\n",
        "\n",
        "    def set_value(self, x):\n",
        "        re = (x - self.center_value)**2\n",
        "        for dial, val in (self.dial, x), (self.re_dial, re):\n",
        "            dial.move_to(self.number_to_point(val))\n",
        "        return self\n",
        "\n",
        "    def set_center_value(self, x):\n",
        "        self.center_value = x\n",
        "        return self\n",
        "\n",
        "    def change_real_estate(self, d_re):\n",
        "        left_over = 0\n",
        "        curr_re = self.get_real_estate()\n",
        "        if d_re < -curr_re:\n",
        "            left_over = d_re + curr_re\n",
        "            d_re = -curr_re\n",
        "        self.set_real_estate(curr_re + d_re)\n",
        "        return left_over\n",
        "\n",
        "    def set_real_estate(self, target_re):\n",
        "        if target_re < 0:\n",
        "            raise Exception(\"Cannot set real estate below 0\")\n",
        "        self.re_dial.move_to(self.number_to_point(target_re))\n",
        "        self.update_dial_by_re_dial()\n",
        "        return self\n",
        "\n",
        "    def get_dial_supplement_animation(self):\n",
        "        return UpdateFromFunc(self.dial, self.update_dial_by_re_dial)\n",
        "\n",
        "    def update_dial_by_re_dial(self, dial = None):\n",
        "        dial = dial or self.dial\n",
        "        re = self.get_real_estate()\n",
        "        sign = np.sign(self.get_value() - self.center_value)\n",
        "        if sign == 0:\n",
        "            sign = -self.last_sign\n",
        "            self.last_sign *= -1\n",
        "        dial.move_to(self.number_to_point(\n",
        "            self.center_value + sign*np.sqrt(abs(re))\n",
        "        ))\n",
        "        return dial\n",
        "\n",
        "    def get_value(self):\n",
        "        return self.point_to_number(self.dial.get_center())\n",
        "\n",
        "    def get_real_estate(self):\n",
        "        return self.point_to_number(self.re_dial.get_center())\n",
        "\n",
        "    def copy(self):\n",
        "        return self.deepcopy()\n",
        "\n",
        "class SliderScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 4,\n",
        "        \"slider_spacing\" : MED_LARGE_BUFF,\n",
        "        \"slider_config\" : {},\n",
        "        \"center_point\" : None,\n",
        "        \"total_real_estate\" : 1,\n",
        "        \"ambiently_change_sliders\" : False,\n",
        "        \"ambient_velocity_magnitude\" : 1.0,\n",
        "        \"ambient_acceleration_magnitude\" : 1.0,\n",
        "        \"ambient_jerk_magnitude\" : 1.0/2,\n",
        "    }\n",
        "    def setup(self):\n",
        "        if self.center_point is None:\n",
        "            self.center_point = np.zeros(self.n_sliders)\n",
        "        sliders = VGroup(*[\n",
        "            Slider(center_value = cv, **self.slider_config)\n",
        "            for cv in self.center_point\n",
        "        ])\n",
        "        sliders.arrange(RIGHT, buff = self.slider_spacing)\n",
        "        sliders[0].add_numbers()\n",
        "        sliders[0].set_value(\n",
        "            self.center_point[0] + np.sqrt(self.total_real_estate)\n",
        "        )\n",
        "        self.sliders = sliders\n",
        "        \n",
        "        self.add_labels_to_sliders()\n",
        "        self.add(sliders)\n",
        "\n",
        "    def add_labels_to_sliders(self):\n",
        "        if len(self.sliders) <= 4:\n",
        "            for slider, char in zip(self.sliders, \"xyzw\"):\n",
        "                slider.add_label(char)\n",
        "            for slider in self.sliders[1:]:\n",
        "                slider.label.align_to(self.sliders[0].label, UP)\n",
        "        else:\n",
        "            for i, slider in enumerate(self.sliders):\n",
        "                slider.add_label(\"x_{%d}\"%(i+1))\n",
        "        return self\n",
        "\n",
        "    def reset_dials(self, values, run_time = 1, **kwargs):\n",
        "        target_vector = self.get_target_vect_from_subset_of_values(values, **kwargs)\n",
        "\n",
        "        radius = np.sqrt(self.total_real_estate)\n",
        "        def update_sliders(sliders):\n",
        "            curr_vect = self.get_vector()\n",
        "            curr_vect -= self.center_point\n",
        "            curr_vect *= radius/get_norm(curr_vect)\n",
        "            curr_vect += self.center_point\n",
        "            self.set_to_vector(curr_vect)\n",
        "            return sliders\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, value)\n",
        "            for value, slider in zip(target_vector, self.sliders)\n",
        "        ] + [\n",
        "            UpdateFromFunc(self.sliders, update_sliders)\n",
        "        ], run_time = run_time)\n",
        "\n",
        "    def get_target_vect_from_subset_of_values(self, values, fixed_indices = None):\n",
        "        if fixed_indices is None: \n",
        "            fixed_indices = []\n",
        "        curr_vector = self.get_vector()\n",
        "        target_vector = np.array(self.center_point, dtype = 'float')\n",
        "        unspecified_vector = np.array(self.center_point, dtype = 'float')\n",
        "        unspecified_indices = []\n",
        "        for i in range(len(curr_vector)):\n",
        "            if i < len(values) and values[i] is not None:\n",
        "                target_vector[i] = values[i]\n",
        "            else:\n",
        "                unspecified_indices.append(i)\n",
        "                unspecified_vector[i] = curr_vector[i]\n",
        "        used_re = get_norm(target_vector - self.center_point)**2\n",
        "        left_over_re = self.total_real_estate - used_re\n",
        "        if left_over_re < -0.001:\n",
        "            raise Exception(\"Overspecified reset\")\n",
        "        uv_norm = get_norm(unspecified_vector - self.center_point)\n",
        "        if uv_norm == 0 and left_over_re > 0:\n",
        "            unspecified_vector[unspecified_indices] = 1\n",
        "            uv_norm = get_norm(unspecified_vector - self.center_point)\n",
        "        if uv_norm > 0:\n",
        "            unspecified_vector -= self.center_point\n",
        "            unspecified_vector *= np.sqrt(left_over_re)/uv_norm\n",
        "            unspecified_vector += self.center_point\n",
        "        return target_vector + unspecified_vector - self.center_point\n",
        "\n",
        "    def set_to_vector(self, vect):\n",
        "        assert len(vect) == len(self.sliders)\n",
        "        for slider, value in zip(self.sliders, vect):\n",
        "            slider.set_value(value)\n",
        "\n",
        "    def get_vector(self):\n",
        "        return np.array([slider.get_value() for slider in self.sliders])\n",
        "\n",
        "    def get_center_point(self):\n",
        "        return np.array([slider.center_value for slider in self.sliders])\n",
        "\n",
        "    def set_center_point(self, new_center_point):\n",
        "        self.center_point = np.array(new_center_point)\n",
        "        for x, slider in zip(new_center_point, self.sliders):\n",
        "            slider.set_center_value(x)\n",
        "        return self\n",
        "\n",
        "    def get_current_total_real_estate(self):\n",
        "        return sum([\n",
        "            slider.get_real_estate()\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "\n",
        "    def get_all_dial_supplement_animations(self):\n",
        "        return [\n",
        "            slider.get_dial_supplement_animation()\n",
        "            for slider in self.sliders\n",
        "        ]\n",
        "\n",
        "    def initialize_ambiant_slider_movement(self):\n",
        "        self.ambiently_change_sliders = True\n",
        "        self.ambient_change_end_time = np.inf\n",
        "        self.ambient_change_time = 0\n",
        "        self.ambient_velocity, self.ambient_acceleration, self.ambient_jerk = [\n",
        "            self.get_random_vector(magnitude)\n",
        "            for magnitude in [\n",
        "                self.ambient_velocity_magnitude,\n",
        "                self.ambient_acceleration_magnitude,\n",
        "                self.ambient_jerk_magnitude,\n",
        "            ]\n",
        "        ]\n",
        "        ##Ensure counterclockwise rotations in 2D\n",
        "        if len(self.ambient_velocity) == 2:\n",
        "            cross = np.cross(self.get_vector(), self.ambient_velocity)\n",
        "            if cross < 0:\n",
        "                self.ambient_velocity *= -1\n",
        "        self.add_foreground_mobjects(self.sliders)\n",
        "\n",
        "    def wind_down_ambient_movement(self, time = 1, wait = True):\n",
        "        self.ambient_change_end_time = self.ambient_change_time + time\n",
        "        if wait:\n",
        "            self.wait(time)\n",
        "            if self.skip_animations:\n",
        "                self.ambient_change_time += time\n",
        "\n",
        "    def ambient_slider_movement_update(self):\n",
        "        #Set velocity_magnitude based on start up or wind down\n",
        "        velocity_magnitude = float(self.ambient_velocity_magnitude)\n",
        "        if self.ambient_change_time <= 1:\n",
        "            velocity_magnitude *= smooth(self.ambient_change_time)\n",
        "        time_until_end = self.ambient_change_end_time - self.ambient_change_time\n",
        "        if time_until_end <= 1:\n",
        "            velocity_magnitude *= smooth(time_until_end)\n",
        "        if time_until_end < 0:\n",
        "            self.ambiently_change_sliders = False\n",
        "            return\n",
        "\n",
        "        center_point = self.get_center_point()\n",
        "        target_vector = self.get_vector() - center_point\n",
        "        if get_norm(target_vector) == 0:\n",
        "            return\n",
        "        vectors_and_magnitudes = [\n",
        "            (self.ambient_acceleration, self.ambient_acceleration_magnitude),\n",
        "            (self.ambient_velocity, velocity_magnitude),\n",
        "            (target_vector, np.sqrt(self.total_real_estate)),\n",
        "        ]\n",
        "        jerk = self.get_random_vector(self.ambient_jerk_magnitude)\n",
        "        deriv = jerk\n",
        "        for vect, mag in vectors_and_magnitudes:\n",
        "            vect += self.frame_duration*deriv\n",
        "            if vect is self.ambient_velocity:\n",
        "                unit_r_vect = target_vector / get_norm(target_vector)\n",
        "                vect -= np.dot(vect, unit_r_vect)*unit_r_vect\n",
        "            vect *= mag/get_norm(vect)\n",
        "            deriv = vect\n",
        "\n",
        "        self.set_to_vector(target_vector + center_point)\n",
        "        self.ambient_change_time += self.frame_duration\n",
        "\n",
        "    def get_random_vector(self, magnitude):\n",
        "        result = 2*np.random.random(len(self.sliders)) - 1\n",
        "        result *= magnitude / get_norm(result)\n",
        "        return result\n",
        "\n",
        "    def update_frame(self, *args, **kwargs):\n",
        "        if self.ambiently_change_sliders:\n",
        "            self.ambient_slider_movement_update()\n",
        "        Scene.update_frame(self, *args, **kwargs)\n",
        "\n",
        "    def wait(self, time = 1):\n",
        "        if self.ambiently_change_sliders:\n",
        "            self.play(Animation(self.sliders, run_time = time))\n",
        "        else:\n",
        "            Scene.wait(self,time)\n",
        "\n",
        "##########\n",
        "\n",
        "class MathIsATease(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        lashes = VGroup()\n",
        "        for eye in randy.eyes:\n",
        "            for angle in np.linspace(-np.pi/3, np.pi/3, 12):\n",
        "                lash = Line(ORIGIN, RIGHT)\n",
        "                lash.set_stroke(GREY_D, 2)\n",
        "                lash.set_width(0.27)\n",
        "                lash.next_to(ORIGIN, RIGHT, buff = 0)\n",
        "                lash.rotate(angle + np.pi/2)\n",
        "                lash.shift(eye.get_center())\n",
        "                lashes.add(lash)\n",
        "        lashes.do_in_place(lashes.stretch, 0.8, 1)\n",
        "        lashes.shift(0.04*DOWN)\n",
        "\n",
        "\n",
        "        fan = SVGMobject(\n",
        "            file_name = \"fan\",\n",
        "            fill_opacity = 1,\n",
        "            fill_color = YELLOW,\n",
        "            stroke_width = 2,\n",
        "            stroke_color = YELLOW,\n",
        "            height = 0.7,\n",
        "        )\n",
        "        VGroup(*fan[-12:]).set_fill(YELLOW_E)\n",
        "        fan.rotate(-np.pi/4)\n",
        "        fan.move_to(randy)\n",
        "        fan.shift(0.85*UP+0.25*LEFT)\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(\n",
        "            ShowCreation(lashes, lag_ratio = 0),\n",
        "            randy.change, \"tease\",\n",
        "            randy.look, OUT,\n",
        "        )\n",
        "        self.add_foreground_mobjects(fan)\n",
        "        eye_bottom_y = randy.eyes.get_bottom()[1]\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                lashes.apply_function, \n",
        "                lambda p : [p[0], eye_bottom_y, p[2]],\n",
        "                rate_func = Blink.CONFIG[\"rate_func\"],\n",
        "            ),\n",
        "            Blink(randy),\n",
        "            DrawBorderThenFill(fan),\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                lashes.apply_function, \n",
        "                lambda p : [p[0], eye_bottom_y, p[2]],\n",
        "                rate_func = Blink.CONFIG[\"rate_func\"],\n",
        "            ),\n",
        "            Blink(randy),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class TODODeterminants(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Determinants clip\"\n",
        "    }\n",
        "\n",
        "class CircleToPairsOfPoints(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane(written_coordinate_height = 0.3)\n",
        "        plane.scale(2)\n",
        "        plane.add_coordinates(y_vals = [-1, 1])\n",
        "        background_plane = plane.copy()\n",
        "        background_plane.set_color(GREY)\n",
        "        background_plane.fade()\n",
        "        circle = Circle(radius = 2, color = YELLOW)\n",
        "\n",
        "        x, y = [np.sqrt(2)/2]*2\n",
        "        dot = Dot(2*x*RIGHT + 2*y*UP, color = GREY_B)\n",
        "\n",
        "        equation = OldTex(\"x\", \"^2\", \"+\", \"y\", \"^2\", \"=\", \"1\")\n",
        "        equation.set_color_by_tex(\"x\", GREEN)\n",
        "        equation.set_color_by_tex(\"y\", RED)\n",
        "        equation.to_corner(UP+LEFT)\n",
        "        equation.add_background_rectangle()\n",
        "\n",
        "        coord_pair = OldTex(\"(\", \"-%.02f\"%x, \",\", \"-%.02f\"%y, \")\") \n",
        "        fixed_numbers = coord_pair.get_parts_by_tex(\"-\")\n",
        "        fixed_numbers.set_fill(opacity = 0)\n",
        "        coord_pair.add_background_rectangle()\n",
        "        coord_pair.next_to(dot, UP+RIGHT, SMALL_BUFF)\n",
        "        numbers = VGroup(*[\n",
        "            DecimalNumber(val).replace(num, dim_to_match = 1)\n",
        "            for val, num in zip([x, y], fixed_numbers)\n",
        "        ])\n",
        "        numbers[0].set_color(GREEN)\n",
        "        numbers[1].set_color(RED)\n",
        "\n",
        "        def get_update_func(i):\n",
        "            return lambda t : dot.get_center()[i]/2.0\n",
        "\n",
        "\n",
        "        self.add(background_plane, plane)\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(\n",
        "            FadeIn(coord_pair),\n",
        "            Write(numbers, run_time = 1),\n",
        "            ShowCreation(dot),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(equation),\n",
        "            *[\n",
        "                Transform(\n",
        "                    number.copy(),\n",
        "                    equation.get_parts_by_tex(tex),\n",
        "                    remover = True\n",
        "                )\n",
        "                for tex, number in zip(\"xy\", numbers)\n",
        "            ]\n",
        "        )\n",
        "        self.play(FocusOn(dot, run_time = 1))\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                dot, run_time = 7, in_place = False,\n",
        "                rate_func = smooth,\n",
        "            ),\n",
        "            MaintainPositionRelativeTo(coord_pair, dot),\n",
        "            *[\n",
        "                ChangingDecimal(\n",
        "                    num, get_update_func(i),\n",
        "                    tracked_mobject = fixed_num\n",
        "                )\n",
        "                for num, i, fixed_num in zip(\n",
        "                    numbers, (0, 1), fixed_numbers\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ######### Rotation equations ##########\n",
        "\n",
        "        rot_equation = OldTex(\n",
        "            \"\\\\Rightarrow\"\n",
        "            \"\\\\big(\\\\cos(\\\\theta)x - \\\\sin(\\\\theta)y\\\\big)^2 + \",\n",
        "            \"\\\\big(\\\\sin(\\\\theta)x + \\\\cos(\\\\theta)y\\\\big)^2 = 1\",\n",
        "        )\n",
        "        rot_equation.scale(0.9)\n",
        "        rot_equation.next_to(equation, RIGHT)\n",
        "        rot_equation.add_background_rectangle()\n",
        "\n",
        "        words = OldTexText(\"Rotational \\\\\\\\ symmetry\")\n",
        "        words.next_to(ORIGIN, UP)\n",
        "        words.to_edge(RIGHT)\n",
        "        words.add_background_rectangle()\n",
        "\n",
        "        arrow = Arrow(\n",
        "            words.get_left(), rot_equation.get_bottom(),\n",
        "            path_arc = -np.pi/6\n",
        "        )\n",
        "        randy = Randolph(color = GREY_BROWN)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(rot_equation, run_time = 2),\n",
        "            FadeOut(coord_pair),\n",
        "            FadeOut(numbers),\n",
        "            FadeOut(dot),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(randy.change, \"confused\", rot_equation)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            Write(words, run_time = 1),\n",
        "            ShowCreation(arrow),\n",
        "            randy.look_at, words\n",
        "        )\n",
        "        plane.remove(*plane.coordinate_labels)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                plane, np.pi/3, \n",
        "                run_time = 4,\n",
        "                rate_func = there_and_back\n",
        "            ),\n",
        "            Animation(equation),\n",
        "            Animation(rot_equation),\n",
        "            Animation(words),\n",
        "            Animation(arrow),\n",
        "            Animation(circle),\n",
        "            randy.change, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class GreatSourceOfMaterial(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"It's a great source \\\\\\\\ of material.\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class CirclesSpheresSumsSquares(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BackAndForth(Scene):\n",
        "    def construct(self):\n",
        "        analytic = OldTexText(\"Analytic\")\n",
        "        analytic.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        analytic.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        geometric = OldTexText(\"Geometric\")\n",
        "        geometric.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        geometric.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.to_edge(UP, LARGE_BUFF)\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        self.add(analytic, geometric, h_line, v_line)\n",
        "\n",
        "        pair = OldTex(\"(\", \"x\", \",\", \"y\", \")\")\n",
        "        pair.shift(FRAME_X_RADIUS*LEFT/2 + FRAME_Y_RADIUS*UP/3)\n",
        "        triplet = OldTex(\"(\", \"x\", \",\", \"y\", \",\", \"z\", \")\")\n",
        "        triplet.shift(FRAME_X_RADIUS*LEFT/2 + FRAME_Y_RADIUS*DOWN/2)\n",
        "        for mob in pair, triplet:\n",
        "            arrow = DoubleArrow(LEFT, RIGHT)\n",
        "            arrow.move_to(mob)\n",
        "            arrow.shift(2*RIGHT)\n",
        "            mob.arrow = arrow\n",
        "        circle_eq = OldTex(\"x\", \"^2\", \"+\", \"y\", \"^2\", \"=\", \"1\")\n",
        "        circle_eq.move_to(pair)\n",
        "        sphere_eq = OldTex(\"x\", \"^2\", \"+\", \"y\", \"^2\", \"+\", \"z\", \"^2\", \"=\", \"1\")\n",
        "        sphere_eq.move_to(triplet)\n",
        "\n",
        "        plane = NumberPlane(x_unit_size = 2, y_unit_size = 2)\n",
        "        circle = Circle(radius = 2, color = YELLOW)\n",
        "        plane_group = VGroup(plane, circle)\n",
        "        plane_group.scale(0.4)\n",
        "        plane_group.next_to(h_line, DOWN, SMALL_BUFF)\n",
        "        plane_group.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "\n",
        "\n",
        "        self.play(Write(pair))\n",
        "        # self.play(ShowCreation(pair.arrow))\n",
        "        self.play(ShowCreation(plane, run_time = 3))\n",
        "        self.play(Write(triplet))\n",
        "        # self.play(ShowCreation(triplet.arrow))\n",
        "        self.wait(3)\n",
        "        for tup, eq, to_draw in (pair, circle_eq, circle), (triplet, sphere_eq, VMobject()):\n",
        "            for mob in tup, eq:\n",
        "                mob.xyz = VGroup(*[sm for sm in map(mob.get_part_by_tex, \"xyz\") if sm is not None])\n",
        "            self.play(\n",
        "                ReplacementTransform(tup.xyz, eq.xyz),\n",
        "                FadeOut(VGroup(*[sm for sm in tup if sm not in tup.xyz])),\n",
        "            )\n",
        "            self.play(\n",
        "                Write(VGroup(*[sm for sm in eq if sm not in eq.xyz])),\n",
        "                ShowCreation(to_draw)\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "class SphereForming(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class PreviousVideos(Scene):\n",
        "    def construct(self):\n",
        "        titles = VGroup(*list(map(TexText, [\n",
        "            \"Pi hiding in prime regularities\",\n",
        "            \"Visualizing all possible pythagorean triples\",\n",
        "            \"Borsuk-Ulam theorem\",\n",
        "        ])))\n",
        "        titles.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        screen = ScreenRectangle(height = 6)\n",
        "        screen.next_to(titles, DOWN)\n",
        "\n",
        "        title = titles[0]\n",
        "        self.add(title, screen)\n",
        "        self.wait(2)\n",
        "        for new_title in titles[1:]:\n",
        "            self.play(Transform(title, new_title))\n",
        "            self.wait(2)\n",
        "\n",
        "class TODOTease(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Tease\"\n",
        "    }\n",
        "\n",
        "class AskAboutLongerLists(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\n",
        "            \"What about \\\\\\\\\", \n",
        "            \"$(x_1, x_2, x_3, x_4)?$\"\n",
        "        )\n",
        "        tup = question[1]\n",
        "        alt_tups = list(map(TexText, [\n",
        "            \"$(x_1, x_2, x_3, x_4, x_5)?$\",\n",
        "            \"$(x_1, x_2, \\\\dots, x_{99}, x_{100})?$\"\n",
        "        ]))\n",
        "\n",
        "        self.student_says(question, run_time = 1)\n",
        "        self.wait()\n",
        "        for alt_tup in alt_tups:\n",
        "            alt_tup.move_to(tup)\n",
        "            self.play(Transform(tup, alt_tup))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"confused\"]*3,\n",
        "            look_at = self.teacher.get_top() + 2*UP\n",
        "        )\n",
        "        self.play(self.teacher.look, UP)\n",
        "        self.wait(5)\n",
        "        self.student_says(\n",
        "            \"I...don't see it.\",\n",
        "            target_mode = \"maybe\",\n",
        "            index = 0\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class FourDCubeRotation(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class HypersphereRotation(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class FourDSurfaceRotating(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class Professionals(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.introduce_characters()\n",
        "        self.add_equation()\n",
        "        self.analogies()\n",
        "\n",
        "    def introduce_characters(self):\n",
        "        titles = VGroup(*list(map(TexText, [\n",
        "            \"Mathematician\",\n",
        "            \"Computer scientist\",\n",
        "            \"Physicist\",\n",
        "        ])))\n",
        "        self.remove(*self.pi_creatures)\n",
        "        for title, pi in zip(titles, self.pi_creatures):\n",
        "            title.next_to(pi, DOWN)\n",
        "            self.play(\n",
        "                Animation(VectorizedPoint(pi.eyes.get_center())),\n",
        "                FadeIn(pi),\n",
        "                Write(title, run_time = 1),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def add_equation(self):\n",
        "        quaternion = OldTex(\n",
        "            \"\\\\frac{1}{2}\", \"+\", \n",
        "            \"0\", \"\\\\textbf{i}\", \"+\",\n",
        "            \"\\\\frac{\\\\sqrt{6}}{4}\", \"\\\\textbf{j}\", \"+\",\n",
        "            \"\\\\frac{\\\\sqrt{6}}{4}\", \"\\\\textbf{k}\",\n",
        "        )\n",
        "        quaternion.scale(0.7)\n",
        "        quaternion.next_to(self.mathy, UP)\n",
        "        quaternion.set_color_by_tex_to_color_map({\n",
        "            \"i\" : RED,\n",
        "            \"j\" : GREEN,\n",
        "            \"k\" : BLUE,\n",
        "        })\n",
        "\n",
        "        array = OldTex(\"[a_1, a_2, \\\\dots, a_{100}]\")\n",
        "        array.next_to(self.compy, UP)\n",
        "\n",
        "        kets = OldTex(\n",
        "            \"\\\\alpha\",\n",
        "            \"|\\\\!\\\\uparrow\\\\rangle + \",\n",
        "            \"\\\\beta\",\n",
        "            \"|\\\\!\\\\downarrow\\\\rangle\"\n",
        "        )\n",
        "        kets.set_color_by_tex_to_color_map({\n",
        "            \"\\\\alpha\" : GREEN,\n",
        "            \"\\\\beta\" : RED,\n",
        "        })\n",
        "        kets.next_to(self.physy, UP)\n",
        "\n",
        "\n",
        "        terms = VGroup(quaternion, array, kets)\n",
        "        for term, pi in zip(terms, self.pi_creatures):\n",
        "            self.play(\n",
        "                Write(term, run_time = 1),\n",
        "                pi.change, \"pondering\", term\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.terms = terms\n",
        "\n",
        "    def analogies(self):\n",
        "        examples = VGroup()\n",
        "        plane = ComplexPlane(\n",
        "            x_radius = 2.5,\n",
        "            y_radius = 1.5,\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        plane.add(Circle(color = YELLOW))\n",
        "        plane.scale(0.75)\n",
        "        examples.add(plane)\n",
        "        examples.add(Circle())\n",
        "        examples.arrange(RIGHT, buff = 2)\n",
        "        examples.to_edge(UP, buff = LARGE_BUFF)\n",
        "        labels = VGroup(*list(map(TexText, [\"2D\", \"3D\"])))\n",
        "\n",
        "        title = OldTexText(\"Fly by instruments\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        for label, example in zip(labels, examples):\n",
        "            label.next_to(example, DOWN)\n",
        "            self.play(\n",
        "                ShowCreation(example),\n",
        "                Write(label, run_time = 1)\n",
        "            )\n",
        "            example.add(label)\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(examples),\n",
        "            self.terms.shift, UP,\n",
        "            Write(title, run_time = 2)\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                pi.change, mode, self.terms.get_left(),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.5)\n",
        "            )\n",
        "            for pi, mode, a in zip(\n",
        "                self.pi_creatures, \n",
        "                [\"confused\", \"sassy\", \"erm\"],\n",
        "                np.linspace(0, 0.5, len(self.pi_creatures))\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Animation(self.terms[-1]))\n",
        "        self.wait(2)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        self.mathy = Mathematician()\n",
        "        self.physy = PiCreature(color = PINK)\n",
        "        self.compy = PiCreature(color = PURPLE)\n",
        "        pi_creatures = VGroup(self.mathy, self.compy, self.physy)\n",
        "        for pi in pi_creatures:\n",
        "            pi.scale(0.7)\n",
        "        pi_creatures.arrange(RIGHT, buff = 3)\n",
        "        pi_creatures.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        return pi_creatures\n",
        "\n",
        "class OfferAHybrid(SliderScene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.sliders)\n",
        "        titles = self.get_titles()\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(titles, DOWN)\n",
        "        v_lines = VGroup(*[\n",
        "            Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "            for x in range(2)\n",
        "        ])\n",
        "        v_lines.generate_target()\n",
        "        for line, vect in zip(v_lines.target, [LEFT, RIGHT]):\n",
        "            line.shift(vect*FRAME_X_RADIUS/3)\n",
        "\n",
        "        equation = OldTex(\"x^2 + y^2 + z^2 = 1\")\n",
        "        equation.generate_target()\n",
        "        equation.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        equation.target.shift(FRAME_WIDTH*LEFT/3)\n",
        "\n",
        "        self.add(titles, h_line, v_lines, equation)\n",
        "        self.wait()\n",
        "        self.play(*list(map(MoveToTarget, [titles, v_lines, equation])))\n",
        "        self.play(Write(self.sliders, run_time = 1))\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(10)\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.wait()\n",
        "\n",
        "    def get_titles(self):\n",
        "        titles = VGroup(*list(map(TexText, [\n",
        "            \"Analytic\", \"Hybrid\", \"Geometric\"\n",
        "        ])))\n",
        "        titles.to_edge(UP)\n",
        "        titles[1].set_color(BLUE)\n",
        "        titles.generate_target()\n",
        "        titles[1].scale(0.001)\n",
        "        titles[0].shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        titles.target[0].shift(FRAME_WIDTH*LEFT/3)\n",
        "        titles[2].shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        titles.target[2].shift(FRAME_WIDTH*RIGHT/3)\n",
        "        return titles\n",
        "\n",
        "class TODOBoxExample(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Box Example\"\n",
        "    }\n",
        "\n",
        "class RotatingSphereWithWanderingPoint(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class DismissProjection(PiCreatureScene):\n",
        "    CONFIG = { \n",
        "        \"screen_rect_color\" : WHITE,\n",
        "        \"example_vect\" : np.array([0.52, 0.26, 0.53, 0.60]),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.show_all_spheres()\n",
        "        self.discuss_4d_sphere_definition()\n",
        "        self.talk_through_animation()\n",
        "        self.transition_to_next_scene()\n",
        "        \n",
        "    def show_all_spheres(self):\n",
        "        equations = VGroup(*list(map(Tex, [\n",
        "            \"x^2 + y^2 = 1\",\n",
        "            \"x^2 + y^2 + z^2 = 1\",\n",
        "            \"x^2 + y^2 + z^2 + w^2 = 1\",\n",
        "        ])))\n",
        "        colors = [YELLOW, GREEN, BLUE]\n",
        "        for equation, edge, color in zip(equations, [LEFT, ORIGIN, RIGHT], colors):\n",
        "            equation.set_color(color)\n",
        "            equation.shift(3*UP)\n",
        "            equation.to_edge(edge)\n",
        "        equations[1].shift(LEFT)\n",
        "\n",
        "        spheres = VGroup(\n",
        "            self.get_circle(equations[0]),\n",
        "            self.get_sphere_screen(equations[1], DOWN),\n",
        "            self.get_sphere_screen(equations[2], DOWN),\n",
        "        )\n",
        "        \n",
        "        for equation, sphere in zip(equations, spheres):\n",
        "            self.play(\n",
        "                Write(equation),\n",
        "                LaggedStartMap(ShowCreation, sphere),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.equations = equations\n",
        "        self.spheres = spheres\n",
        "\n",
        "    def get_circle(self, equation):\n",
        "        result = VGroup(\n",
        "            NumberPlane(\n",
        "                x_radius = 2.5,\n",
        "                y_radius = 2,\n",
        "            ).fade(0.4),\n",
        "            Circle(color = YELLOW, radius = 1),\n",
        "        )\n",
        "        result.scale(0.7)\n",
        "        result.next_to(equation, DOWN)\n",
        "        return result\n",
        "\n",
        "    def get_sphere_screen(self, equation, vect):\n",
        "        square = Rectangle()\n",
        "        square.set_width(equation.get_width())\n",
        "        square.stretch_to_fit_height(3)\n",
        "        square.next_to(equation, vect)\n",
        "        square.set_color(self.screen_rect_color)\n",
        "        return square\n",
        "\n",
        "    def discuss_4d_sphere_definition(self):\n",
        "        sphere = self.spheres[-1]\n",
        "        equation = self.equations[-1]\n",
        "\n",
        "        sphere_words = OldTexText(\"``4-dimensional sphere''\")\n",
        "        sphere_words.next_to(sphere, DOWN+LEFT, buff = LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            sphere_words.get_right(), sphere.get_bottom(), \n",
        "            path_arc = np.pi/3, \n",
        "            color = BLUE\n",
        "        )\n",
        "        descriptor = OldTex(\n",
        "            \"\\\\text{Just lists of numbers like }\", \n",
        "            \"(%.02f \\\\,, %.02f \\\\,, %.02f \\\\,, %.02f \\\\,)\"%tuple(self.example_vect)\n",
        "        )\n",
        "        descriptor[1].set_color(BLUE)\n",
        "        descriptor.next_to(sphere_words, DOWN)\n",
        "        dot = Dot(descriptor[1].get_top())\n",
        "        dot.set_fill(WHITE, opacity = 0.75)\n",
        "\n",
        "        self.play(\n",
        "            Write(sphere_words),\n",
        "            ShowCreation(\n",
        "                arrow,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            run_time = 3,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(descriptor, run_time = 2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dot.move_to, equation.get_left(),\n",
        "            dot.set_fill, None, 0,\n",
        "            path_arc = -np.pi/12\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.sphere_words = sphere_words\n",
        "        self.sphere_arrow = arrow\n",
        "        self.descriptor = descriptor\n",
        "\n",
        "    def talk_through_animation(self):\n",
        "        sphere = self.spheres[-1]\n",
        "\n",
        "        morty = self.pi_creature\n",
        "        alt_dims = VGroup(*list(map(TexText, [\"5D\", \"6D\", \"7D\"])))\n",
        "        alt_dims.next_to(morty.eyes, UP, SMALL_BUFF)\n",
        "        alt_dim = alt_dims[0]\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(morty.change, \"raise_right_hand\", sphere)\n",
        "        self.wait(3)\n",
        "        self.play(morty.change, \"confused\", sphere)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.change, \"erm\", alt_dims,\n",
        "            FadeIn(alt_dim)\n",
        "        )\n",
        "        for new_alt_dim in alt_dims[1:]:\n",
        "            self.wait()\n",
        "            self.play(Transform(alt_dim, new_alt_dim))\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"concerned_musician\")\n",
        "        self.play(FadeOut(alt_dim))\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"angry\", sphere)\n",
        "        self.wait(2)\n",
        "\n",
        "    def transition_to_next_scene(self):\n",
        "        equation = self.equations[-1]\n",
        "        self.equations.remove(equation)\n",
        "        tup = self.descriptor[1]\n",
        "        self.descriptor.remove(tup)\n",
        "\n",
        "        equation.generate_target()\n",
        "        equation.target.center().to_edge(UP)\n",
        "        tup.generate_target()\n",
        "        tup.target.next_to(equation.target, DOWN)\n",
        "        tup.target.set_color(WHITE)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(*[\n",
        "            self.equations, self.spheres,\n",
        "            self.sphere_words, self.sphere_arrow,\n",
        "            self.descriptor,\n",
        "            self.pi_creature\n",
        "        ])))\n",
        "        self.play(*list(map(MoveToTarget, [equation, tup])))\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Mortimer().scale(0.8).to_corner(DOWN+RIGHT)\n",
        "\n",
        "class RotatingSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class Introduce4DSliders(SliderScene):\n",
        "    CONFIG = {\n",
        "        \"slider_config\" : {\n",
        "            \"include_real_estate_ticks\" : False,\n",
        "            \"big_tick_numbers\" : [-1, 0, 1],\n",
        "            \"tick_frequency\" : 0.25,\n",
        "            \"tick_size\" : 0.05,\n",
        "            \"dial_color\" : YELLOW,\n",
        "        },\n",
        "        \"slider_spacing\" : LARGE_BUFF,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.match_last_scene()\n",
        "        self.introduce_sliders()\n",
        "        self.ask_about_constraint()\n",
        "\n",
        "    def match_last_scene(self):\n",
        "        self.start_vect = DismissProjection.CONFIG[\"example_vect\"]\n",
        "        self.remove(self.sliders)\n",
        "\n",
        "        equation = OldTex(\"x^2 + y^2 + z^2 + w^2 = 1\")\n",
        "        x, y, z, w = self.start_vect\n",
        "        tup = OldTex(\n",
        "            \"(\", \"%.02f \\\\,\"%x, \n",
        "            \",\", \"%.02f \\\\,\"%y, \n",
        "            \",\", \"%.02f \\\\,\"%z, \n",
        "            \",\", \"%.02f \\\\,\"%w, \")\"\n",
        "        )\n",
        "        equation.center().to_edge(UP)\n",
        "        equation.set_color(BLUE)\n",
        "        tup.next_to(equation, DOWN)\n",
        "\n",
        "        self.sliders.next_to(tup, DOWN)\n",
        "        self.sliders.shift(0.8*LEFT)\n",
        "\n",
        "        self.add(equation, tup)\n",
        "        self.wait()\n",
        "        self.equation = equation\n",
        "        self.tup = tup\n",
        "\n",
        "    def introduce_sliders(self):\n",
        "        self.set_to_vector(self.start_vect)\n",
        "\n",
        "        numbers = self.tup.get_parts_by_tex(\".\")\n",
        "        self.tup.remove(*numbers)\n",
        "        dials = VGroup(*[slider.dial for slider in self.sliders])\n",
        "        dial_copies = dials.copy()\n",
        "        dials.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, self.sliders))\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                num, dial,\n",
        "                run_time = 3,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.5),\n",
        "                remover = True\n",
        "            )\n",
        "            for num, dial, a in zip(\n",
        "                numbers, dial_copies, \n",
        "                np.linspace(0, 0.5, len(numbers))\n",
        "            )\n",
        "        ])\n",
        "        dials.set_fill(opacity = 1)\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.play(FadeOut(self.tup))\n",
        "        self.wait(10)\n",
        "\n",
        "    def ask_about_constraint(self):\n",
        "        equation = self.equation\n",
        "        rect = SurroundingRectangle(equation, color = GREEN)\n",
        "        randy = Randolph().scale(0.5)\n",
        "        randy.next_to(rect, DOWN+LEFT, LARGE_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"pondering\", rect)\n",
        "        self.wait()\n",
        "        for mob in self.sliders, rect:\n",
        "            self.play(randy.look_at, mob)\n",
        "            self.play(Blink(randy))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "class TwoDimensionalCase(Introduce4DSliders):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 2,\n",
        "    }\n",
        "    def setup(self):\n",
        "        SliderScene.setup(self)\n",
        "        self.sliders.shift(RIGHT)\n",
        "        for number in self.sliders[0].numbers:\n",
        "            value = int(number.get_tex())\n",
        "            number.move_to(center_of_mass([\n",
        "                slider.number_to_point(value)\n",
        "                for slider in self.sliders\n",
        "            ]))\n",
        "\n",
        "        plane = NumberPlane(\n",
        "            x_radius = 2.5,\n",
        "            y_radius = 2.5,\n",
        "        )\n",
        "        plane.fade(0.25)\n",
        "        plane.axes.set_color(GREY)\n",
        "        plane.add_coordinates()\n",
        "        plane.to_edge(LEFT)\n",
        "        origin = plane.coords_to_point(0, 0)\n",
        "\n",
        "        circle = Circle(radius = 1, color = WHITE)\n",
        "        circle.move_to(plane.coords_to_point(*self.center_point))\n",
        "\n",
        "        dot = Dot(color = YELLOW)\n",
        "        dot.move_to(plane.coords_to_point(1, 0))\n",
        "\n",
        "        equation = OldTex(\"x^2 + y^2 = 1\")\n",
        "        equation.to_corner(UP + RIGHT)\n",
        "\n",
        "        self.add(plane, circle, dot, equation)\n",
        "        self.add_foreground_mobjects(dot)\n",
        "\n",
        "        self.plane = plane\n",
        "        self.circle = circle\n",
        "        self.dot = dot\n",
        "        self.equation = equation\n",
        "\n",
        "    def construct(self):\n",
        "        self.let_values_wander()\n",
        "        self.introduce_real_estate()\n",
        "        self.let_values_wander(6)\n",
        "        self.comment_on_cheap_vs_expensive_real_estate()\n",
        "        self.nudge_x_from_one_example()\n",
        "        self.note_circle_steepness()\n",
        "        self.add_tick_marks()\n",
        "        self.write_distance_squared()\n",
        "\n",
        "    def let_values_wander(self, total_time = 5):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(total_time - 1)\n",
        "        self.wind_down_ambient_movement()\n",
        "\n",
        "    def introduce_real_estate(self):\n",
        "        x_squared_mob = VGroup(*self.equation[:2])\n",
        "        y_squared_mob = VGroup(*self.equation[3:5])\n",
        "        x_rect = SurroundingRectangle(x_squared_mob)\n",
        "        y_rect = SurroundingRectangle(y_squared_mob)\n",
        "        rects = VGroup(x_rect, y_rect)\n",
        "\n",
        "        decimals = VGroup(*[\n",
        "            DecimalNumber(num**2) \n",
        "            for num in self.get_vector()\n",
        "        ])\n",
        "        decimals.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        decimals.next_to(rects, DOWN, LARGE_BUFF)\n",
        "\n",
        "        real_estate_word = OldTexText(\"``Real estate''\")\n",
        "        real_estate_word.next_to(decimals, DOWN, MED_LARGE_BUFF)\n",
        "        self.play(FadeIn(real_estate_word))\n",
        "\n",
        "        colors = GREEN, RED\n",
        "        arrows = VGroup()\n",
        "        for rect, decimal, color in zip(rects, decimals, colors):\n",
        "            rect.set_color(color)\n",
        "            decimal.set_color(color)\n",
        "            arrow = Arrow(\n",
        "                rect.get_bottom()+SMALL_BUFF*UP, decimal.get_top(),\n",
        "                tip_length = 0.2,\n",
        "            )\n",
        "            arrow.set_color(color)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                Write(decimal)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        sliders = self.sliders\n",
        "        def create_update_func(i):\n",
        "            return lambda alpha : sliders[i].get_real_estate()\n",
        "\n",
        "        self.add_foreground_mobjects(decimals)\n",
        "        self.decimals = decimals\n",
        "        self.decimal_update_anims = [\n",
        "            ChangingDecimal(decimal, create_update_func(i))\n",
        "            for i, decimal in enumerate(decimals)\n",
        "        ]\n",
        "        self.real_estate_word = real_estate_word\n",
        "\n",
        "    def comment_on_cheap_vs_expensive_real_estate(self):\n",
        "        blue_rects = VGroup()\n",
        "        red_rects = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            for x1, x2 in (-0.5, 0.5), (0.75, 1.0), (-1.0, -0.75):\n",
        "                p1, p2 = list(map(slider.number_to_point, [x1, x2]))\n",
        "                rect = Rectangle(\n",
        "                    stroke_width = 0,\n",
        "                    fill_opacity = 0.5,\n",
        "                    width = 0.25,\n",
        "                    height = (p2-p1)[1]\n",
        "                )\n",
        "                rect.move_to((p1+p2)/2)\n",
        "                if np.mean([x1, x2]) == 0:\n",
        "                    rect.set_color(BLUE)\n",
        "                    blue_rects.add(rect)\n",
        "                else:\n",
        "                    rect.set_color(RED)\n",
        "                    red_rects.add(rect)\n",
        "\n",
        "        blue_rects.save_state()\n",
        "        self.play(DrawBorderThenFill(blue_rects))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(blue_rects, red_rects))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(red_rects))\n",
        "\n",
        "        blue_rects.restore()\n",
        "        self.real_estate_rects = VGroup(blue_rects, red_rects)\n",
        "\n",
        "    def nudge_x_from_one_example(self):\n",
        "        x_re = self.decimals[0]\n",
        "        rect = SurroundingRectangle(x_re)\n",
        "\n",
        "        self.reset_dials([1, 0])\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(FocusOn(self.dot))\n",
        "        self.wait()\n",
        "        self.reset_dials([0.9, -np.sqrt(0.19)])\n",
        "\n",
        "        x_brace, y_brace = [\n",
        "            Brace(\n",
        "                VGroup(slider.dial, Dot(slider.number_to_point(0))),\n",
        "                vect\n",
        "            )\n",
        "            for slider, vect in zip(self.sliders, [LEFT, RIGHT])\n",
        "        ]\n",
        "        x_text = x_brace.get_tex(\"0.9\")\n",
        "        y_text = y_brace.get_tex(\"%.02f\"%self.sliders[1].get_value())\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(x_brace),\n",
        "            Write(x_text)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(x_text.copy()), x_re\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowFromCenter(y_brace),\n",
        "            Write(y_text),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(self.real_estate_rects))\n",
        "        self.reset_dials([1, 0], run_time = 1)\n",
        "        self.reset_dials([0.9, -np.sqrt(0.19)], run_time = 2)\n",
        "        self.play(FadeOut(self.real_estate_rects))\n",
        "        self.play(*list(map(FadeOut, [x_brace, y_brace, x_text, y_text])))\n",
        "        self.wait()\n",
        "\n",
        "    def note_circle_steepness(self):\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(0.5, 1),\n",
        "            self.plane.coords_to_point(1.5, -1),\n",
        "        )\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        rect.replace(line, stretch = True)\n",
        "\n",
        "        self.play(DrawBorderThenFill(rect, stroke_color = YELLOW))\n",
        "        for x, u in (1, 1), (0.8, 1), (1, 1), (0.8, -1), (1, 1):\n",
        "            self.reset_dials([x, u*np.sqrt(1 - x**2)])\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "    def add_tick_marks(self):\n",
        "        self.remove_foreground_mobjects(self.sliders)\n",
        "        self.add(self.sliders)\n",
        "        old_ticks = VGroup()\n",
        "        all_ticks = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            slider.tick_size = 0.1\n",
        "            slider.add_real_estate_ticks()\n",
        "            slider.remove(slider.get_tick_marks())\n",
        "            all_ticks.add(*slider.real_estate_ticks)\n",
        "            old_ticks.add(*slider.get_tick_marks()[:-3])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(old_ticks),\n",
        "            ShowCreation(all_ticks, run_time = 3),\n",
        "            Animation(VGroup(*[slider.dial for slider in self.sliders])),\n",
        "        )\n",
        "        self.add_foreground_mobjects(self.sliders)\n",
        "        self.wait()\n",
        "        for x in np.arange(0.95, 0.05, -0.05):\n",
        "            self.reset_dials(\n",
        "                [np.sqrt(x), np.sqrt(1-x)],\n",
        "                run_time = 0.5\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(10)\n",
        "\n",
        "    def write_distance_squared(self):\n",
        "        d_squared = OldTex(\"(\\\\text{Distance})^2\")\n",
        "        d_squared.next_to(self.real_estate_word, DOWN)\n",
        "        d_squared.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(d_squared))\n",
        "        self.wait(3)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def update_frame(self, *args, **kwargs):\n",
        "        if hasattr(self, \"dot\"):\n",
        "            x, y = self.get_vector()\n",
        "            self.dot.move_to(self.plane.coords_to_point(x, y))\n",
        "        if hasattr(self, \"decimals\"):\n",
        "            for anim in self.decimal_update_anims:\n",
        "                anim.update(0)\n",
        "        SliderScene.update_frame(self, *args, **kwargs)\n",
        "\n",
        "class TwoDimensionalCaseIntro(TwoDimensionalCase):\n",
        "    def construct(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(10)\n",
        "\n",
        "class ThreeDCase(TwoDimensionalCase):\n",
        "    CONFIG = { \n",
        "        \"n_sliders\" : 3,\n",
        "        \"slider_config\" : {\n",
        "            \"include_real_estate_ticks\" : True,\n",
        "            \"big_tick_numbers\" : [],\n",
        "            \"tick_frequency\" : 1,\n",
        "            \"tick_size\" : 0.1,\n",
        "        },\n",
        "    }\n",
        "    def setup(self):\n",
        "        SliderScene.setup(self)\n",
        "        self.equation = OldTex(\n",
        "            \"x^2\", \"+\", \"y^2\", \"+\", \"z^2\", \"=\", \"1\"\n",
        "        )\n",
        "        self.equation.to_corner(UP+RIGHT)\n",
        "        self.add(self.equation)\n",
        "\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_real_estate_decimals()\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.point_out_third_slider()\n",
        "        self.wait(3)\n",
        "        self.hold_x_at(0.5, 12)\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.hold_x_at(0.85, 12)\n",
        "        return\n",
        "        self.hold_x_at(1, 5)\n",
        "\n",
        "    def add_real_estate_decimals(self):\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(self.equation.get_part_by_tex(char))\n",
        "            for char in \"xyz\"\n",
        "        ])\n",
        "\n",
        "        decimals = VGroup(*[\n",
        "            DecimalNumber(num**2)\n",
        "            for num in self.get_vector()\n",
        "        ])\n",
        "        decimals.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        decimals.next_to(rects, DOWN, LARGE_BUFF)\n",
        "\n",
        "        colors = [GREEN, RED, BLUE]\n",
        "        arrows = VGroup()\n",
        "        for rect, decimal, color in zip(rects, decimals, colors):\n",
        "            rect.set_color(color)\n",
        "            decimal.set_color(color)\n",
        "            arrow = Arrow(\n",
        "                rect.get_bottom()+SMALL_BUFF*UP, decimal.get_top(),\n",
        "                tip_length = 0.2,\n",
        "                color = color\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "        real_estate_word = OldTexText(\"``Real estate''\")\n",
        "        real_estate_word.next_to(decimals, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        sliders = self.sliders\n",
        "        def create_update_func(i):\n",
        "            return lambda alpha : sliders[i].get_real_estate()\n",
        "        self.add_foreground_mobjects(decimals)\n",
        "        self.decimals = decimals\n",
        "        self.decimal_update_anims = [\n",
        "            ChangingDecimal(decimal, create_update_func(i))\n",
        "            for i, decimal in enumerate(decimals)\n",
        "        ]\n",
        "        self.add(rects, arrows, real_estate_word)\n",
        "        self.rects = rects\n",
        "        self.arrows = arrows\n",
        "        self.real_estate_word = real_estate_word\n",
        "\n",
        "    def point_out_third_slider(self):\n",
        "        rect = SurroundingRectangle(self.sliders[-1])\n",
        "        self.wait(4)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait(8)\n",
        "\n",
        "    def hold_x_at(self, x_val, wait_time):\n",
        "        #Save these\n",
        "        all_sliders = self.sliders\n",
        "        original_total_real_estate = self.total_real_estate\n",
        "\n",
        "        self.reset_dials([x_val], run_time = 3)\n",
        "        self.sliders = VGroup(*self.sliders[1:])\n",
        "        self.total_real_estate = self.total_real_estate-x_val**2\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(wait_time-2)\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.sliders = all_sliders\n",
        "        self.total_real_estate = original_total_real_estate\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "\n",
        "    ####\n",
        "\n",
        "class ThreeDCaseInsert(ThreeDCase):\n",
        "    def construct(self):\n",
        "        self.add_real_estate_decimals()\n",
        "        self.reset_dials([0.85, np.sqrt(1-0.85**2)], run_time = 0)\n",
        "        self.reset_dials([1], run_time = 3)\n",
        "        self.wait()\n",
        "\n",
        "class SphereAtRest(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BugOnASurface(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"You're a bug \\\\\\\\ on a surface\")\n",
        "        self.wait(3)\n",
        "\n",
        "class SphereWithWanderingDotAtX0point5(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class MoveSphereSliceFromPoint5ToPoint85(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class SphereWithWanderingDotAtX0point85(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class MoveSphereSliceFromPoint85To1(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BugOnTheSurfaceSlidersPart(ThreeDCase):\n",
        "    CONFIG = {\n",
        "        \"run_time\" : 30\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_real_estate_decimals()\n",
        "        self.reset_dials([0.9], run_time = 0)\n",
        "        time_range = np.arange(0, self.run_time, self.frame_duration)\n",
        "        for time in ProgressDisplay(time_range):\n",
        "            t = 0.3*np.sin(2*np.pi*time/7.0) + 1\n",
        "            u = 0.3*np.sin(4*np.pi*time/7.0) + 1.5\n",
        "            self.set_to_vector([\n",
        "                np.cos(u),\n",
        "                np.sin(u)*np.cos(t),\n",
        "                np.sin(u)*np.sin(t),\n",
        "            ])\n",
        "            self.wait(self.frame_duration)\n",
        "\n",
        "class BugOnTheSurfaceSpherePart(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class FourDCase(SliderScene, TeacherStudentsScene):\n",
        "    def setup(self):\n",
        "        TeacherStudentsScene.setup(self)\n",
        "        SliderScene.setup(self)\n",
        "        self.sliders.scale(0.9)\n",
        "        self.sliders.to_edge(UP)\n",
        "        self.sliders.shift(2*RIGHT)\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_initial_exchange()\n",
        "        self.fix_one_slider()\n",
        "        self.ask_now_what()\n",
        "        self.set_aside_sliders()\n",
        "\n",
        "    def show_initial_exchange(self):\n",
        "        dot = Dot(fill_opacity = 0)\n",
        "        dot.to_corner(UP+LEFT, buff = 2)\n",
        "        self.play(Animation(dot))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Animation(self.sliders),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = self.sliders\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "    def fix_one_slider(self):\n",
        "        x_slider = self.sliders[0]\n",
        "        dial = x_slider.dial\n",
        "        self.wind_down_ambient_movement(wait = False)\n",
        "        self.play(self.teacher.change, \"speaking\")\n",
        "        self.sliders.remove(x_slider)\n",
        "        self.total_real_estate = get_norm(self.get_vector())**2\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        arrow = Arrow(LEFT, RIGHT, color = GREEN)\n",
        "        arrow.next_to(dial, LEFT)\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            dial.set_color, arrow.get_color()\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"confused\", \"hooray\",\n",
        "            look_at = self.sliders,\n",
        "            added_anims = [self.teacher.change, \"plain\"]\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.x_slider = x_slider\n",
        "        self.x_arrow = arrow\n",
        "\n",
        "    def ask_now_what(self):\n",
        "        self.student_says(\n",
        "            \"Okay...now what?\",\n",
        "            target_mode = \"raise_left_hand\",\n",
        "            index = 0,\n",
        "            added_anims = [self.teacher.change, \"plain\"]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            None, \"pondering\", \"pondering\",\n",
        "            look_at = self.students[0].bubble,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(RemovePiCreatureBubble(self.students[0]))\n",
        "\n",
        "    def set_aside_sliders(self):\n",
        "        self.sliders.add(self.x_slider)\n",
        "        self.total_real_estate = 1\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.play(\n",
        "            self.sliders.scale, 0.5,\n",
        "            self.sliders.to_corner, UP+RIGHT,\n",
        "            FadeOut(self.x_arrow)\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"Time for some \\\\\\\\ high-dimensional \\\\\\\\ strangeness!\",\n",
        "            target_mode = \"hooray\",\n",
        "        )\n",
        "        self.wait(7)\n",
        "\n",
        "    #####\n",
        "    def non_blink_wait(self, time = 1):\n",
        "        SliderScene.wait(self, time)\n",
        "\n",
        "class TwoDBoxExample(Scene):\n",
        "    def setup(self):\n",
        "        scale_factor = 1.7\n",
        "        self.plane = NumberPlane()\n",
        "        self.plane.scale(scale_factor)\n",
        "        self.plane.add_coordinates()\n",
        "        self.plane.axes.set_color(GREY)\n",
        "        self.add(self.plane)\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_box()\n",
        "        self.label_corner_coordinates()\n",
        "        self.add_corner_circles()\n",
        "        self.add_center_circle()\n",
        "        self.compute_radius()\n",
        "\n",
        "    def add_box(self):\n",
        "        box = Square(color = RED, stroke_width = 6)\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(-1, -1),\n",
        "            self.plane.coords_to_point(1, 1),\n",
        "        )\n",
        "        box.replace(line, stretch = True)\n",
        "        self.play(ShowCreation(box))\n",
        "        self.wait()\n",
        "\n",
        "    def label_corner_coordinates(self):\n",
        "        corner_dots = VGroup()\n",
        "        coords_group = VGroup()\n",
        "        for x, y in it.product(*[[1, -1]]*2):\n",
        "            point = self.plane.coords_to_point(x, y)\n",
        "            dot = Dot(point, color = WHITE)\n",
        "            coords = OldTex(\"(%d, %d)\"%(x, y))\n",
        "            coords.add_background_rectangle()\n",
        "            coords.next_to(point, point, SMALL_BUFF)\n",
        "            corner_dots.add(dot)\n",
        "            coords_group.add(coords)\n",
        "\n",
        "            self.play(\n",
        "                ShowCreation(dot),\n",
        "                Write(coords, run_time = 1)\n",
        "            )\n",
        "\n",
        "        self.add_foreground_mobjects(coords_group)\n",
        "        self.corner_dots = corner_dots\n",
        "        self.coords_group = coords_group\n",
        "\n",
        "    def add_corner_circles(self):\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(-1, 0),\n",
        "            self.plane.coords_to_point(1, 0),\n",
        "        )\n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(line, dim_to_match = 0)\n",
        "        circles = VGroup(*[\n",
        "            circle.copy().move_to(dot)\n",
        "            for dot in self.corner_dots\n",
        "        ])\n",
        "\n",
        "        radius = Line(ORIGIN, self.plane.coords_to_point(1, 0))\n",
        "        radius.set_stroke(GREY, 6)\n",
        "        radius.rotate(-np.pi/4)\n",
        "        c0_center = circles[0].get_center()\n",
        "        radius.shift(c0_center)\n",
        "        r_equals_1 = OldTex(\"r = 1\")\n",
        "        r_equals_1.add_background_rectangle()\n",
        "        r_equals_1.next_to(\n",
        "            radius.point_from_proportion(0.75),\n",
        "            UP+RIGHT, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, circles))\n",
        "        self.play(\n",
        "            ShowCreation(radius),\n",
        "            Write(r_equals_1)\n",
        "        )\n",
        "        for angle in -np.pi/4, -np.pi/2, 3*np.pi/4:\n",
        "            self.play(Rotating(\n",
        "                radius, about_point = c0_center,\n",
        "                radians = angle,\n",
        "                run_time = 1,\n",
        "                rate_func = smooth,\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "        self.play(*list(map(FadeOut, [radius, r_equals_1])))\n",
        "        self.wait()\n",
        "\n",
        "        self.corner_radius = radius\n",
        "        self.corner_circles = circles\n",
        "\n",
        "    def add_center_circle(self):\n",
        "        r = np.sqrt(2) - 1\n",
        "        radius = Line(ORIGIN, self.plane.coords_to_point(r, 0))\n",
        "        radius.set_stroke(WHITE)\n",
        "        circle = Circle(color = GREEN)\n",
        "        circle.replace(\n",
        "            VGroup(radius, radius.copy().rotate(np.pi)),\n",
        "            dim_to_match = 0\n",
        "        )\n",
        "        radius.rotate(np.pi/4)\n",
        "        r_equals_q = OldTex(\"r\", \"= ???\")\n",
        "        r_equals_q[1].add_background_rectangle()\n",
        "        r_equals_q.next_to(radius, RIGHT, buff = -SMALL_BUFF)\n",
        "\n",
        "        self.play(GrowFromCenter(circle, run_time = 2))\n",
        "        self.play(circle.scale, 1.2, rate_func = wiggle)\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(Write(r_equals_q))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(r_equals_q[1]))\n",
        "\n",
        "        self.inner_radius = radius\n",
        "        self.inner_circle = circle\n",
        "        self.inner_r = r_equals_q[0]\n",
        "\n",
        "    def compute_radius(self):\n",
        "        triangle = Polygon(\n",
        "            ORIGIN, \n",
        "            self.plane.coords_to_point(1, 0),\n",
        "            self.plane.coords_to_point(1, 1),\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.5,\n",
        "            stroke_width = 6,\n",
        "            stroke_color = WHITE,\n",
        "        )\n",
        "        bottom_one = OldTex(\"1\")\n",
        "        bottom_one.next_to(triangle.get_bottom(), UP, SMALL_BUFF)\n",
        "        bottom_one.shift(MED_SMALL_BUFF*RIGHT)\n",
        "        side_one = OldTex(\"1\")\n",
        "        side_one.next_to(triangle, RIGHT)\n",
        "        sqrt_1_plus_1 = OldTex(\"\\\\sqrt\", \"{1^2 + 1^2}\")\n",
        "        sqrt_2 = OldTex(\"\\\\sqrt\", \"{2}\")\n",
        "        for sqrt in sqrt_1_plus_1, sqrt_2:\n",
        "            sqrt.add_background_rectangle()\n",
        "            sqrt.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "            sqrt.rotate(np.pi/4)\n",
        "            sqrt.shift(triangle.get_center())\n",
        "\n",
        "        root_2_value = OldTex(\"\\\\sqrt{2} \\\\approx 1.414\")\n",
        "        root_2_value.to_corner(UP+RIGHT)\n",
        "        root_2_value.add_background_rectangle()\n",
        "        root_2_minus_1_value = OldTex(\n",
        "            \"\\\\sqrt{2} - 1 \\\\approx 0.414\"\n",
        "        )\n",
        "        root_2_minus_1_value.next_to(root_2_value, DOWN)\n",
        "        root_2_minus_1_value.to_edge(RIGHT)\n",
        "        root_2_minus_1_value.add_background_rectangle()\n",
        "\n",
        "        corner_radius = self.corner_radius\n",
        "        c0_center = self.corner_circles[0].get_center()\n",
        "        corner_radius.rotate(-np.pi/2, about_point = c0_center)\n",
        "\n",
        "        rhs = OldTex(\"=\", \"\\\\sqrt\", \"{2}\", \"-1\")\n",
        "        rhs.next_to(self.inner_r, RIGHT, SMALL_BUFF, DOWN)\n",
        "        rhs.shift(0.5*SMALL_BUFF*DOWN)\n",
        "        sqrt_2_target = VGroup(*rhs[1:3])\n",
        "        rhs.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(triangle),\n",
        "            Write(VGroup(bottom_one, side_one, sqrt_1_plus_1))\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(sqrt_1_plus_1, sqrt_2))\n",
        "        self.play(\n",
        "            Write(root_2_value, run_time = 1),\n",
        "            *list(map(FadeOut, [bottom_one, side_one]))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(corner_radius))\n",
        "        self.play(Rotating(\n",
        "            corner_radius, about_point = c0_center,\n",
        "            run_time = 2,\n",
        "            rate_func = smooth\n",
        "        ))\n",
        "        self.play(FadeOut(triangle), Animation(corner_radius))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(rhs),\n",
        "            Transform(sqrt_2, sqrt_2_target),\n",
        "        )\n",
        "        self.play(Write(root_2_minus_1_value))\n",
        "        self.wait(2)\n",
        "\n",
        "class ThreeDBoxExample(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ThreeDCubeCorners(Scene):\n",
        "    def construct(self):\n",
        "        coordinates = VGroup(*[\n",
        "            OldTex(\"(%d,\\\\, %d,\\\\, %d)\"%(x, y, z))\n",
        "            for x, y, z in it.product(*3*[[1, -1]])\n",
        "        ])\n",
        "        coordinates.arrange(DOWN, aligned_edge = LEFT)\n",
        "        name = OldTexText(\"Corners: \")\n",
        "        name.next_to(coordinates[0], LEFT)\n",
        "        group = VGroup(name, coordinates)\n",
        "        group.set_height(FRAME_HEIGHT - 1)\n",
        "        group.to_edge(LEFT)\n",
        "\n",
        "        self.play(Write(name, run_time = 2))\n",
        "        self.play(LaggedStartMap(FadeIn, coordinates, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "class ShowDistanceFormula(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        rule = OldTex(\n",
        "            \"||(\", \"x_1\", \", \", \"x_2\", \"\\\\dots, \", \"x_n\", \")||\", \n",
        "            \"=\", \n",
        "            \"\\\\sqrt\", \"{x_1^2\", \" + \", \"x_2^2\", \" +\\\\cdots\", \"x_n^2\", \"}\"\n",
        "        )\n",
        "        rule.set_color_by_tex_to_color_map({\n",
        "            \"x_1\" : GREEN,\n",
        "            \"x_2\" : RED,\n",
        "            \"x_n\" : BLUE,\n",
        "        })\n",
        "        for part in rule.get_parts_by_tex(\"x_\"):\n",
        "            if len(part) > 2:\n",
        "                part[1].set_color(WHITE)\n",
        "        rule.next_to(self.teacher, UP, LARGE_BUFF)\n",
        "        rule.to_edge(RIGHT)\n",
        "        rule.shift(UP)\n",
        "\n",
        "        rule.save_state()\n",
        "        rule.shift(2*DOWN)\n",
        "        rule.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            rule.restore,\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.student_says(\"Why?\", index = 0)\n",
        "        self.play(self.teacher.change, \"thinking\")\n",
        "        self.wait(3)\n",
        "\n",
        "class GeneralizePythagoreanTheoremBeyondTwoD(ThreeDScene):\n",
        "    def construct(self):\n",
        "        tex_to_color_map = {\n",
        "            \"x\" : GREEN,\n",
        "            \"y\" : RED,\n",
        "            \"z\" : BLUE,\n",
        "        }\n",
        "        rect = Rectangle(\n",
        "            height = 4, width = 5,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 0.2,\n",
        "        )\n",
        "        diag = Line(\n",
        "            rect.get_corner(DOWN+LEFT),\n",
        "            rect.get_corner(UP+RIGHT),\n",
        "            color = YELLOW\n",
        "        )\n",
        "        bottom = Line(rect.get_left(), rect.get_right())\n",
        "        bottom.move_to(rect.get_bottom())\n",
        "        bottom.set_color(tex_to_color_map[\"x\"])\n",
        "        side = Line(rect.get_bottom(), rect.get_top())\n",
        "        side.move_to(rect.get_right())\n",
        "        side.set_color(tex_to_color_map[\"y\"])\n",
        "\n",
        "        x = OldTex(\"x\")\n",
        "        x.next_to(rect.get_bottom(), UP, SMALL_BUFF)\n",
        "        y = OldTex(\"y\")\n",
        "        y.next_to(rect.get_right(), LEFT, SMALL_BUFF)\n",
        "        hyp = OldTex(\"\\\\sqrt\", \"{x\", \"^2 + \", \"y\", \"^2}\")\n",
        "        hyp.set_color_by_tex_to_color_map(tex_to_color_map)\n",
        "        hyp.next_to(ORIGIN, UP)\n",
        "        hyp.rotate(diag.get_angle())\n",
        "        hyp.shift(diag.get_center())\n",
        "        group = VGroup(rect, bottom, side, diag, x, y, hyp)\n",
        "\n",
        "        self.add(rect)\n",
        "        for line, tex in (bottom, x), (side, y), (diag, hyp):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                Write(tex, run_time = 1)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            group.rotate, 0.45*np.pi, LEFT,\n",
        "            group.shift, 2*DOWN\n",
        "        )\n",
        "\n",
        "        corner = diag.get_end()\n",
        "        z_line = Line(corner, corner + 3*UP)\n",
        "        z_line.set_color(tex_to_color_map[\"z\"])\n",
        "        z = OldTex(\"z\")\n",
        "        z.set_color(tex_to_color_map[\"z\"])\n",
        "        z.next_to(z_line, RIGHT)\n",
        "        dot = Dot(z_line.get_end())\n",
        "        three_d_diag = Line(diag.get_start(), z_line.get_end())\n",
        "        three_d_diag.set_color(MAROON_B)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(z_line),\n",
        "            ShowCreation(dot),\n",
        "            Write(z, run_time = 1)\n",
        "        )\n",
        "        self.play(ShowCreation(three_d_diag))\n",
        "        self.wait()\n",
        "\n",
        "        full_group = VGroup(group, z_line, z, three_d_diag, dot)\n",
        "        self.play(Rotating(\n",
        "            full_group, radians = -np.pi/6,\n",
        "            axis = UP, \n",
        "            run_time = 10,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class ThreeDBoxFormulas(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTex(\n",
        "            \"||(1, 1, 1)||\", \"=\", \"???\"\n",
        "        )\n",
        "        answer = OldTex(\n",
        "            \"||(1, 1, 1)||\", \"&=\", \"\\\\sqrt{1^2 + 1^2 + 1^2}\\\\\\\\\",\n",
        "            \"&= \\\\sqrt{3}\\\\\\\\\", \"&\\\\approx\", \"1.73\",\n",
        "        )\n",
        "        for mob in question, answer:\n",
        "            mob.to_corner(UP+LEFT)\n",
        "        inner_r = OldTex(\n",
        "            \"\\\\text{Inner radius}\", \"&=\", \"\\\\sqrt{3} - 1\\\\\\\\\",\n",
        "            \"&\\\\approx\", \"0.73\"\n",
        "        )\n",
        "        inner_r.next_to(answer, DOWN, LARGE_BUFF, LEFT)\n",
        "        inner_r.set_color(GREEN_C)\n",
        "        VGroup(question, answer).shift(0.55*RIGHT)\n",
        "\n",
        "        self.play(Write(question))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(question, answer))\n",
        "        self.wait(2)\n",
        "        self.play(Write(inner_r))\n",
        "        self.wait(2)\n",
        "\n",
        "class AskAboutHigherDimensions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"What happens for \\\\\\\\ higher dimensions?\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "        self.student_thinks(\n",
        "            \"$\\\\sqrt{N} - 1$\",\n",
        "            target_mode = \"happy\",\n",
        "            index = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        pi = self.students[1]\n",
        "        self.play(pi.change, \"confused\", pi.bubble)\n",
        "        self.wait(3)\n",
        "\n",
        "class TenSliders(SliderScene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 10,\n",
        "        \"run_time\": 30,\n",
        "        \"slider_spacing\" : 0.75,\n",
        "        \"ambient_acceleration_magnitude\" : 2.0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(self.run_time)\n",
        "        self.wind_down_ambient_movement()\n",
        "\n",
        "class TwoDBoxWithSliders(TwoDimensionalCase):\n",
        "    CONFIG = {\n",
        "        \"slider_config\" : {\n",
        "            \"include_real_estate_ticks\" : True,\n",
        "            \"tick_frequency\" : 1,\n",
        "            \"big_tick_numbers\" : [],\n",
        "            \"tick_size\" : 0.1,\n",
        "            \"dial_color\" : YELLOW,\n",
        "            \"x_min\" : -2,\n",
        "            \"x_max\" : 2,\n",
        "            \"unit_size\" : 1.5,\n",
        "        },\n",
        "        \"center_point\" : [1, -1],\n",
        "    }\n",
        "    def setup(self):\n",
        "        TwoDimensionalCase.setup(self)\n",
        "        ##Correct from previous setup\n",
        "        self.remove(self.equation)\n",
        "        self.sliders.shift(RIGHT)\n",
        "        VGroup(*self.get_top_level_mobjects()).shift(RIGHT)\n",
        "        x_slider = self.sliders[0]\n",
        "        for number in x_slider.numbers:\n",
        "            value = int(number.get_tex())\n",
        "            number.next_to(\n",
        "                x_slider.number_to_point(value), \n",
        "                LEFT, MED_SMALL_BUFF\n",
        "            )\n",
        "        self.plane.axes.set_color(BLUE)\n",
        "\n",
        "        ##Add box material\n",
        "        corner_circles = VGroup(*[\n",
        "            self.circle.copy().move_to(\n",
        "                self.plane.coords_to_point(*coords)\n",
        "            ).set_color(GREY)\n",
        "            for coords in ((1, 1), (-1, 1), (-1, -1))\n",
        "        ])\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(-1, -1),\n",
        "            self.plane.coords_to_point(1, 1),\n",
        "        )\n",
        "        box = Square(color = RED)\n",
        "        box.replace(line, stretch = True)\n",
        "\n",
        "        self.add(box, corner_circles)\n",
        "        self.box = box\n",
        "        self.corner_circles = corner_circles\n",
        "\n",
        "    def construct(self):\n",
        "        self.ask_about_off_center_circle()\n",
        "        self.recenter_circle()\n",
        "        self.write_x_and_y_real_estate()\n",
        "        self.swap_with_top_right_circle()\n",
        "        self.show_center_circle()\n",
        "        self.describe_tangent_point()\n",
        "        self.perterb_point()\n",
        "        self.wander_on_inner_circle()\n",
        "        self.ask_about_inner_real_estate()\n",
        "\n",
        "    def ask_about_off_center_circle(self):\n",
        "        question = OldTexText(\"Off-center circles?\")\n",
        "        question.next_to(self.plane, UP)\n",
        "\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.play(Write(question))\n",
        "        self.wait(4)\n",
        "        self.wind_down_ambient_movement()\n",
        "\n",
        "        self.question = question\n",
        "\n",
        "    def recenter_circle(self):\n",
        "        original_center_point = self.center_point\n",
        "\n",
        "        self.play(\n",
        "            self.circle.move_to, self.plane.coords_to_point(0, 0),\n",
        "            Animation(self.sliders),\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    mob.shift,\n",
        "                    slider.number_to_point(0)-slider.number_to_point(slider.center_value)\n",
        "                )\n",
        "                for slider in self.sliders\n",
        "                for mob in [slider.real_estate_ticks, slider.dial]\n",
        "            ]\n",
        "        )\n",
        "        self.center_point = [0, 0]\n",
        "        for x, slider in zip(self.center_point, self.sliders):\n",
        "            slider.center_value = x\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(7)\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.play(\n",
        "            self.circle.move_to, \n",
        "                self.plane.coords_to_point(*original_center_point),\n",
        "            Animation(self.sliders),\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    mob.shift,\n",
        "                    slider.number_to_point(x)-slider.number_to_point(0)\n",
        "                )\n",
        "                for x, slider in zip(original_center_point, self.sliders)\n",
        "                for mob in [slider.real_estate_ticks, slider.dial]\n",
        "            ]\n",
        "        )\n",
        "        self.center_point = original_center_point\n",
        "        for x, slider in zip(self.center_point, self.sliders):\n",
        "            slider.center_value = x\n",
        "\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(5)\n",
        "\n",
        "    def write_x_and_y_real_estate(self):\n",
        "        phrases = VGroup(\n",
        "            OldTexText(\"$x$\", \"real estate:\", \"$(x-1)^2$\"),\n",
        "            OldTexText(\"$y$\", \"real estate:\", \"$(y+1)^2$\"),\n",
        "        )\n",
        "        phrases.next_to(self.plane, UP)\n",
        "        phrases[0].set_color_by_tex(\"x\", GREEN)\n",
        "        phrases[1].set_color_by_tex(\"y\", RED)\n",
        "        x_brace, y_brace = [\n",
        "            Brace(slider.real_estate_ticks, RIGHT)\n",
        "            for slider in self.sliders\n",
        "        ]\n",
        "        x_brace.set_color(GREEN)\n",
        "        y_brace.set_color(RED)\n",
        "\n",
        "        self.play(FadeOut(self.question))\n",
        "        self.play(\n",
        "            Write(phrases[0]),\n",
        "            GrowFromCenter(x_brace)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            Transform(*phrases),\n",
        "            Transform(x_brace, y_brace)\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.wind_down_ambient_movement(wait = False)\n",
        "        self.play(*list(map(FadeOut, [x_brace, phrases[0]])))\n",
        "\n",
        "    def swap_with_top_right_circle(self):\n",
        "        alt_circle = self.corner_circles[0]\n",
        "        slider = self.sliders[1]\n",
        "\n",
        "        self.play(\n",
        "            self.circle.move_to, alt_circle,\n",
        "            alt_circle.move_to, self.circle,\n",
        "            Animation(slider),\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    mob.shift,\n",
        "                    slider.number_to_point(1) - slider.number_to_point(-1)\n",
        "                )\n",
        "                for mob in (slider.real_estate_ticks, slider.dial)\n",
        "            ]\n",
        "        )\n",
        "        slider.center_value = 1\n",
        "        self.center_point[1] = 1\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_center_circle(self):\n",
        "        origin = self.plane.coords_to_point(0, 0)\n",
        "        radius = get_norm(\n",
        "            self.plane.coords_to_point(np.sqrt(2)-1, 0) - origin\n",
        "        )\n",
        "        circle = Circle(radius = radius, color = GREEN)\n",
        "        circle.move_to(origin)\n",
        "\n",
        "        self.play(FocusOn(circle))\n",
        "        self.play(GrowFromCenter(circle, run_time = 2))\n",
        "        self.wait(3)\n",
        "\n",
        "    def describe_tangent_point(self):\n",
        "        target_vector = np.array([\n",
        "            1-np.sqrt(2)/2, 1-np.sqrt(2)/2\n",
        "        ])\n",
        "        point = self.plane.coords_to_point(*target_vector)\n",
        "        origin = self.plane.coords_to_point(0, 0)\n",
        "        h_line = Line(point[1]*UP + origin[0]*RIGHT, point)\n",
        "        v_line = Line(point[0]*RIGHT+origin[1]*UP, point)\n",
        "\n",
        "        while get_norm(self.get_vector()-target_vector) > 0.5:\n",
        "            self.wait()\n",
        "        self.wind_down_ambient_movement(0)\n",
        "        self.reset_dials(target_vector)\n",
        "        self.play(*list(map(ShowCreation, [h_line, v_line])))\n",
        "        self.wait()\n",
        "\n",
        "        re_line = DashedLine(\n",
        "            self.sliders[0].dial.get_left() + MED_SMALL_BUFF*LEFT,\n",
        "            self.sliders[1].dial.get_right() + MED_SMALL_BUFF*RIGHT,\n",
        "        )\n",
        "        words = OldTexText(\"Evenly shared \\\\\\\\ real estate\")\n",
        "        words.scale(0.8)\n",
        "        words.next_to(re_line, RIGHT)\n",
        "        self.play(ShowCreation(re_line))\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.evenly_shared_words = words\n",
        "        self.re_line = re_line\n",
        "\n",
        "    def perterb_point(self):\n",
        "        #Perturb dials\n",
        "        target_vector = np.array([\n",
        "            1 - np.sqrt(0.7),\n",
        "            1 - np.sqrt(0.3),\n",
        "        ])\n",
        "        ghost_dials = VGroup(*[\n",
        "            slider.dial.copy()\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        ghost_dials.set_fill(WHITE, opacity = 0.75)\n",
        "\n",
        "        self.add_foreground_mobjects(ghost_dials)\n",
        "        self.reset_dials(target_vector)\n",
        "        self.wait()\n",
        "\n",
        "        #Comment on real estate exchange\n",
        "        x_words = OldTexText(\"Gain expensive \\\\\\\\\", \"real estate\")\n",
        "        y_words = OldTexText(\"Give up cheap \\\\\\\\\", \"real estate\")\n",
        "        VGroup(x_words, y_words).scale(0.8)\n",
        "        x_words.next_to(self.re_line, UP+LEFT)\n",
        "        x_words.shift(SMALL_BUFF*(DOWN+LEFT))\n",
        "        y_words.next_to(self.re_line, UP+RIGHT)\n",
        "        y_words.shift(MED_LARGE_BUFF*UP)\n",
        "\n",
        "        x_arrow, y_arrow = [\n",
        "            Arrow(\n",
        "                words[1].get_edge_center(vect), self.sliders[i].dial,\n",
        "                tip_length = 0.15,\n",
        "            )\n",
        "            for i, words, vect in zip(\n",
        "                (0, 1), [x_words, y_words], [RIGHT, LEFT]\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        self.play(\n",
        "            Write(x_words, run_time = 2),\n",
        "            ShowCreation(x_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.evenly_shared_words))\n",
        "        self.play(\n",
        "            Write(y_words, run_time = 2),\n",
        "            ShowCreation(y_arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Swap perspective\n",
        "        word_starts = VGroup(y_words[0], x_words[0])\n",
        "        crosses = VGroup()\n",
        "        new_words = VGroup()\n",
        "        for w1, w2 in zip(word_starts, reversed(word_starts)):\n",
        "            crosses.add(Cross(w1))\n",
        "            w1_copy = w1.copy()\n",
        "            w1_copy.generate_target()\n",
        "            w1_copy.target.next_to(w2, UP, SMALL_BUFF)\n",
        "            new_words.add(w1_copy)\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                slider.real_estate_ticks.shift,\n",
        "                slider.number_to_point(0)-slider.number_to_point(1)\n",
        "            )\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(crosses))\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, new_words),\n",
        "            Animation(crosses)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        #Return to original position\n",
        "        target_vector = np.array(2*[1-np.sqrt(0.5)])\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(*[\n",
        "            ghost_dials, \n",
        "            x_words, y_words, \n",
        "            x_arrow, y_arrow, \n",
        "            crosses, new_words, \n",
        "        ])))\n",
        "        self.remove_foreground_mobjects(ghost_dials)\n",
        "        self.reset_dials(target_vector)\n",
        "        self.center_point = np.zeros(2)\n",
        "        for x, slider in zip(self.center_point, self.sliders):\n",
        "            slider.center_value = x\n",
        "        self.set_to_vector(target_vector)\n",
        "        self.total_real_estate = self.get_current_total_real_estate()\n",
        "        self.wait(2)\n",
        "\n",
        "    def wander_on_inner_circle(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(9)\n",
        "\n",
        "    def ask_about_inner_real_estate(self):\n",
        "        question = OldTexText(\"What is \\\\\\\\ $x^2 + y^2$?\")\n",
        "        question.next_to(self.re_line, RIGHT)\n",
        "\n",
        "        rhs = OldTex(\"<0.5^2 + 0.5^2\")\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(question, DOWN)\n",
        "        rhs.to_edge(RIGHT)\n",
        "\n",
        "        half_line = Line(*[\n",
        "            slider.number_to_point(0.5) + MED_LARGE_BUFF*vect\n",
        "            for slider, vect in zip(self.sliders, [LEFT, RIGHT])\n",
        "        ])\n",
        "        half = OldTex(\"0.5\")\n",
        "        half.scale(self.sliders[0].number_scale_val)\n",
        "        half.next_to(half_line, LEFT, SMALL_BUFF)\n",
        "\n",
        "        target_vector = np.array(2*[1-np.sqrt(0.5)])\n",
        "        while get_norm(target_vector - self.get_vector()) > 0.5:\n",
        "            self.wait()\n",
        "        self.wind_down_ambient_movement(0)\n",
        "        self.reset_dials(target_vector)\n",
        "        self.play(Write(question))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            ShowCreation(half_line),\n",
        "            Write(half)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(rhs))\n",
        "        self.wait(3)\n",
        "\n",
        "class AskWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Wait, why?\",\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class MentionComparisonToZeroPointFive(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Comparing to $0.5$ will \\\\\\\\\"+\\\n",
        "            \"be surprisingly useful!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ThreeDBoxExampleWithSliders(SliderScene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 3,\n",
        "        \"slider_config\" : {\n",
        "            \"x_min\" : -2,\n",
        "            \"x_max\" : 2,\n",
        "            \"unit_size\" : 1.5,\n",
        "        },\n",
        "        \"center_point\" : np.ones(3),\n",
        "    }\n",
        "    def setup(self):\n",
        "        SliderScene.setup(self)\n",
        "        self.sliders.shift(2*RIGHT)\n",
        "\n",
        "    def construct(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.name_corner_sphere()\n",
        "        self.point_out_closest_point()\n",
        "        self.compare_to_halfway_point()\n",
        "        self.reframe_as_inner_sphere_point()\n",
        "        self.place_bound_on_inner_real_estate()\n",
        "        self.comment_on_inner_sphere_smallness()\n",
        "\n",
        "    def name_corner_sphere(self):\n",
        "        sphere_name = OldTexText(\n",
        "            \"\"\"Sphere with radius 1\\\\\\\\\n",
        "            centered at (1, 1, 1)\"\"\"\n",
        "        )\n",
        "        sphere_name.to_corner(UP+LEFT)\n",
        "        arrow = Arrow(\n",
        "            sphere_name, VGroup(*self.sliders[0].numbers[-2:]),\n",
        "            color = BLUE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, sphere_name,),\n",
        "            ShowCreation(arrow, rate_func = squish_rate_func(smooth, 0.7, 1)),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.sphere_name = sphere_name\n",
        "        self.arrow = arrow\n",
        "\n",
        "    def point_out_closest_point(self):\n",
        "        target_x = 1-np.sqrt(1./3)\n",
        "        target_vector = np.array(3*[target_x])\n",
        "        re_words = OldTexText(\n",
        "            \"$x$, $y$ and $z$ each have \\\\\\\\\",\n",
        "            \"$\\\\frac{1}{3}$\", \"units of real estate\"\n",
        "        )\n",
        "        re_words.to_corner(UP+LEFT)\n",
        "        re_line = DashedLine(*[\n",
        "            self.sliders[i].number_to_point(target_x) + MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (2, RIGHT)]\n",
        "        ])\n",
        "        new_arrow = Arrow(\n",
        "            re_words.get_corner(DOWN+RIGHT), re_line.get_left(),\n",
        "            color = BLUE\n",
        "        )\n",
        "\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, x)\n",
        "            for x, slider in zip(target_vector, self.sliders)\n",
        "        ])\n",
        "        self.play(ShowCreation(re_line))\n",
        "        self.play(\n",
        "            FadeOut(self.sphere_name),\n",
        "            Transform(self.arrow, new_arrow),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, re_words))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.re_words = re_words\n",
        "        self.re_line = re_line\n",
        "\n",
        "    def compare_to_halfway_point(self):\n",
        "        half_line = Line(*[\n",
        "            self.sliders[i].number_to_point(0.5)+MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (2, RIGHT)]\n",
        "        ])\n",
        "        half_line.set_stroke(MAROON_B, 6)\n",
        "        half_label = OldTex(\"0.5\")\n",
        "        half_label.scale(self.sliders[0].number_scale_val)\n",
        "        half_label.next_to(half_line, LEFT, MED_SMALL_BUFF)\n",
        "        half_label.set_color(half_line.get_color())\n",
        "\n",
        "        curr_vector = self.get_vector()\n",
        "        target_vector = 0.5*np.ones(3)\n",
        "        ghost_dials = VGroup(*[\n",
        "            slider.dial.copy().set_fill(WHITE, 0.5)\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "\n",
        "        cross = Cross(self.re_words.get_parts_by_tex(\"frac\"))\n",
        "        new_re = OldTex(\"(0.5)^2 = 0.25\")\n",
        "        new_re.next_to(cross, DOWN, MED_SMALL_BUFF, LEFT)\n",
        "        new_re.set_color(MAROON_B)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.arrow),\n",
        "            Write(half_label, run_time = 1),\n",
        "            ShowCreation(half_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(ghost_dials)\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, 0.5)\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(Write(new_re))\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(new_re),\n",
        "            FadeOut(cross),\n",
        "            *[\n",
        "                ApplyMethod(slider.set_value, x)\n",
        "                for x, slider in zip(curr_vector, self.sliders)\n",
        "            ]\n",
        "        )\n",
        "\n",
        "    def reframe_as_inner_sphere_point(self):\n",
        "        s = self.sliders[0]\n",
        "        shift_vect = s.number_to_point(0)-s.number_to_point(1)\n",
        "        curr_vector = self.get_vector()\n",
        "        self.set_center_point(np.zeros(3))\n",
        "        self.set_to_vector(curr_vector)\n",
        "        self.total_real_estate = self.get_current_total_real_estate()\n",
        "\n",
        "        all_re_ticks = VGroup(*[\n",
        "            slider.real_estate_ticks\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        inner_sphere_words = OldTexText(\n",
        "            \"Also a point on \\\\\\\\\", \"the inner sphere\"\n",
        "        )\n",
        "        inner_sphere_words.next_to(self.re_line, RIGHT)\n",
        "        question = OldTexText(\"How much \\\\\\\\\", \"real estate?\")\n",
        "        question.next_to(self.re_line, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Animation(self.sliders),\n",
        "            FadeOut(self.re_words),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, all_re_ticks,\n",
        "                lambda m : (m.shift, shift_vect)\n",
        "            )\n",
        "        )\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.play(Write(inner_sphere_words))\n",
        "        self.wait(5)\n",
        "        self.wind_down_ambient_movement(0)\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, x)\n",
        "            for slider, x in zip(self.sliders, curr_vector)\n",
        "        ])\n",
        "        self.play(ReplacementTransform(\n",
        "            inner_sphere_words, question\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.re_question = question\n",
        "\n",
        "    def place_bound_on_inner_real_estate(self):\n",
        "        bound = OldTex(\n",
        "            \"&< 3(0.5)^2 \",\n",
        "            \"= 0.75\"\n",
        "        )\n",
        "        bound.next_to(self.re_question, DOWN)\n",
        "        bound.to_edge(RIGHT)\n",
        "\n",
        "        self.play(Write(bound))\n",
        "        self.wait(2)\n",
        "\n",
        "    def comment_on_inner_sphere_smallness(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(15)\n",
        "\n",
        "class Rotating3DCornerSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class FourDBoxExampleWithSliders(ThreeDBoxExampleWithSliders):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 4,\n",
        "        \"center_point\" : np.ones(4),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.list_corner_coordinates()\n",
        "        self.show_16_corner_spheres()\n",
        "        self.show_closest_point()\n",
        "        self.show_real_estate_at_closest_point()\n",
        "        self.reframe_as_inner_sphere_point()\n",
        "        self.compute_inner_radius_numerically()\n",
        "        self.inner_sphere_touches_box()\n",
        "\n",
        "    def list_corner_coordinates(self):\n",
        "        title = OldTexText(\n",
        "            \"$2 \\\\!\\\\times\\\\! 2 \\\\!\\\\times\\\\! 2 \\\\!\\\\times\\\\! 2$ box vertices:\"\n",
        "        )\n",
        "        title.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        coordinates = list(it.product(*4*[[1, -1]]))\n",
        "        coordinate_mobs = VGroup(*[\n",
        "            OldTex(\"(%d, %d, %d, %d)\"%tup)\n",
        "            for tup in coordinates\n",
        "        ])\n",
        "        coordinate_mobs.arrange(DOWN, aligned_edge = LEFT)\n",
        "        coordinate_mobs.scale(0.8)\n",
        "        left_column = VGroup(*coordinate_mobs[:8])\n",
        "        right_column = VGroup(*coordinate_mobs[8:])\n",
        "        right_column.next_to(left_column, RIGHT)\n",
        "        coordinate_mobs.next_to(title, DOWN)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.play(LaggedStartMap(FadeIn, coordinate_mobs))\n",
        "        self.wait()\n",
        "\n",
        "        self.coordinate_mobs = coordinate_mobs\n",
        "        self.coordinates = coordinates\n",
        "        self.box_vertices_title = title\n",
        "\n",
        "    def show_16_corner_spheres(self):\n",
        "        sphere_words = VGroup(OldTexText(\"Sphere centered at\"))\n",
        "        sphere_words.scale(0.8)\n",
        "        sphere_words.next_to(self.sliders, RIGHT)\n",
        "        sphere_words.shift(2*UP)\n",
        "\n",
        "        self.add(sphere_words)\n",
        "        pairs = list(zip(self.coordinate_mobs, self.coordinates))\n",
        "        for coord_mob, coords in pairs[1:] + [pairs[0]]:\n",
        "            coord_mob.set_color(GREEN)\n",
        "            coord_mob_copy = coord_mob.copy()\n",
        "            coord_mob_copy.next_to(sphere_words, DOWN)\n",
        "            for slider, x in zip(self.sliders, coords):\n",
        "                point = slider.number_to_point(x)\n",
        "                slider.real_estate_ticks.move_to(point)\n",
        "                slider.dial.move_to(point)\n",
        "            self.sliders[0].dial.move_to(\n",
        "                self.sliders[0].number_to_point(coords[0]+1)\n",
        "            )\n",
        "            self.add(coord_mob_copy)\n",
        "            self.wait()\n",
        "            self.remove(coord_mob_copy)\n",
        "            coord_mob.set_color(WHITE)\n",
        "        self.add(coord_mob_copy)\n",
        "        sphere_words.add(coord_mob_copy)\n",
        "        self.sphere_words = sphere_words\n",
        "\n",
        "        self.play(\n",
        "            self.sliders.center,\n",
        "            sphere_words.shift, LEFT,\n",
        "            *list(map(FadeOut, [\n",
        "                self.coordinate_mobs, self.box_vertices_title\n",
        "            ]))\n",
        "        )\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(4)\n",
        "\n",
        "    def show_closest_point(self):\n",
        "        target_vector = 0.5*np.ones(4)\n",
        "        re_line = DashedLine(*[\n",
        "            self.sliders[i].number_to_point(0.5)+MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (-1, RIGHT)]\n",
        "        ])\n",
        "        half_label = OldTex(\"0.5\")\n",
        "        half_label.scale(self.sliders[0].number_scale_val)\n",
        "        half_label.next_to(re_line, LEFT, MED_SMALL_BUFF)\n",
        "        half_label.set_color(MAROON_B)\n",
        "\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, x)\n",
        "            for x, slider in zip(target_vector, self.sliders)\n",
        "        ])\n",
        "        self.play(ShowCreation(re_line))\n",
        "        self.play(Write(half_label))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.re_line = re_line\n",
        "        self.half_label = half_label\n",
        "\n",
        "    def show_real_estate_at_closest_point(self):\n",
        "        words = OldTexText(\"Total real estate:\")\n",
        "        value = OldTex(\"4(0.5)^2 = 4(0.25) = 1\")\n",
        "        value.next_to(words, DOWN)\n",
        "        re_words = VGroup(words, value)\n",
        "        re_words.scale(0.8)\n",
        "        re_words.next_to(self.sphere_words, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        re_rects = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            rect = Rectangle(\n",
        "                width = 2*slider.tick_size,\n",
        "                height = 0.5*slider.unit_size,\n",
        "                stroke_width = 0,\n",
        "                fill_color = MAROON_B,\n",
        "                fill_opacity = 0.75,\n",
        "            )\n",
        "            rect.move_to(slider.number_to_point(0.75))\n",
        "            re_rects.add(rect)\n",
        "\n",
        "        self.play(FadeIn(re_words))\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, re_rects, run_time = 3))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.re_words = re_words\n",
        "        self.re_rects = re_rects\n",
        "\n",
        "    def reframe_as_inner_sphere_point(self):\n",
        "        sphere_words = self.sphere_words\n",
        "        sphere_words.generate_target()\n",
        "        sphere_words.target.shift(2*DOWN)\n",
        "        old_coords = sphere_words.target[1]\n",
        "        new_coords = OldTex(\"(0, 0, 0, 0)\")\n",
        "        new_coords.replace(old_coords, dim_to_match = 1)\n",
        "        new_coords.set_color(old_coords.get_color())\n",
        "        Transform(old_coords, new_coords).update(1)\n",
        "\n",
        "        self.play(Animation(self.sliders), *[\n",
        "            ApplyMethod(\n",
        "                s.real_estate_ticks.move_to, s.number_to_point(0),\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, a, a+0.5)\n",
        "            )\n",
        "            for s, a in zip(self.sliders, np.linspace(0, 0.5, 4))\n",
        "        ])\n",
        "        self.play(\n",
        "            MoveToTarget(sphere_words),\n",
        "            self.re_words.next_to, sphere_words.target, UP, MED_LARGE_BUFF,\n",
        "            path_arc = np.pi\n",
        "        )\n",
        "        self.wait(2)\n",
        "        re_shift_vect = 0.5*self.sliders[0].unit_size*DOWN\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, self.re_rects,\n",
        "            lambda m : (m.shift, re_shift_vect),\n",
        "            path_arc = np.pi\n",
        "        ))\n",
        "        self.wait()\n",
        "        re_words_rect = SurroundingRectangle(self.re_words)\n",
        "        self.play(ShowCreation(re_words_rect))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(re_words_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_center_point(np.zeros(4))\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(4)\n",
        "\n",
        "    def compute_inner_radius_numerically(self):\n",
        "        computation = OldTex(\n",
        "            \"R_\\\\text{Inner}\", \n",
        "            \"&= ||(1, 1, 1, 1)|| - 1 \\\\\\\\\",\n",
        "            # \"&= \\\\sqrt{1^2 + 1^2 + 1^2 + 1^2} - 1 \\\\\\\\\",\n",
        "            \"&= \\\\sqrt{4} - 1 \\\\\\\\\",\n",
        "            \"&= 1\"\n",
        "        )\n",
        "        computation.scale(0.8)\n",
        "        computation.to_corner(UP+LEFT)\n",
        "        computation.shift(DOWN)\n",
        "        brace = Brace(VGroup(*computation[1][1:-2]), UP)\n",
        "        brace_text = brace.get_text(\"Distance to corner\")\n",
        "        brace_text.scale(0.8, about_point = brace_text.get_bottom())\n",
        "        VGroup(brace, brace_text).set_color(RED)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, computation, run_time = 3))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(brace_text, run_time = 2))\n",
        "        self.wait(16)\n",
        "\n",
        "        computation.add(brace, brace_text)\n",
        "        self.computation = computation\n",
        "\n",
        "    def inner_sphere_touches_box(self):\n",
        "        touching_words = OldTexText(\n",
        "            \"This point touches\\\\\\\\\",\n",
        "            \"the $2 \\\\!\\\\times\\\\! 2 \\\\!\\\\times\\\\! 2 \\\\!\\\\times\\\\! 2$ box!\"\n",
        "        )\n",
        "        touching_words.to_corner(UP+LEFT)\n",
        "        arrow = Arrow(MED_SMALL_BUFF*DOWN, 3*RIGHT+DOWN)\n",
        "        arrow.set_color(BLUE)\n",
        "        arrow.shift(touching_words.get_bottom())\n",
        "\n",
        "        self.wind_down_ambient_movement(wait = False)\n",
        "        self.play(FadeOut(self.computation))\n",
        "        self.reset_dials([1])\n",
        "        self.play(Write(touching_words))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait(2)\n",
        "\n",
        "class TwoDInnerSphereTouchingBox(TwoDBoxWithSliders, PiCreatureScene):\n",
        "    def setup(self):\n",
        "        TwoDBoxWithSliders.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.remove(self.sliders)\n",
        "        self.remove(self.dot)\n",
        "        self.circle.set_color(GREY)\n",
        "        self.randy.next_to(self.plane, RIGHT, LARGE_BUFF, DOWN)\n",
        "\n",
        "    def construct(self):\n",
        "        little_inner_circle, big_inner_circle = [\n",
        "            Circle(\n",
        "                radius = radius*self.plane.x_unit_size,\n",
        "                color = GREEN\n",
        "            ).move_to(self.plane.coords_to_point(0, 0))\n",
        "            for radius in (np.sqrt(2)-1, 1)\n",
        "        ]\n",
        "        randy = self.randy\n",
        "        tangency_points = VGroup(*[\n",
        "            Dot(self.plane.coords_to_point(x, y))\n",
        "            for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]\n",
        "        ])\n",
        "        tangency_points.set_fill(YELLOW, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(little_inner_circle),\n",
        "            randy.change, \"pondering\", little_inner_circle\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                little_inner_circle.copy(), big_inner_circle\n",
        "            ),\n",
        "            little_inner_circle.fade,\n",
        "            randy.change, \"confused\"\n",
        "        )\n",
        "        big_inner_circle.save_state()\n",
        "        self.play(big_inner_circle.move_to, self.circle)\n",
        "        self.play(big_inner_circle.restore)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, tangency_points,\n",
        "            rate_func = double_smooth\n",
        "        ))\n",
        "        self.play(randy.change, \"maybe\")\n",
        "        self.play(randy.look_at, self.circle)\n",
        "        self.wait()\n",
        "        self.play(randy.look_at, little_inner_circle)\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.randy = Randolph().flip()\n",
        "        return self.randy\n",
        "\n",
        "class FiveDBoxExampleWithSliders(FourDBoxExampleWithSliders):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 5,\n",
        "        \"center_point\" : np.ones(5),\n",
        "    }\n",
        "    def setup(self):\n",
        "        FourDBoxExampleWithSliders.setup(self)\n",
        "        self.sliders.center()\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_32_corner_spheres()\n",
        "        self.show_closest_point()\n",
        "        self.show_halfway_point()\n",
        "        self.reframe_as_inner_sphere_point()\n",
        "        self.compute_radius()\n",
        "        self.poke_out_of_box()\n",
        "\n",
        "    def show_32_corner_spheres(self):\n",
        "        sphere_words = VGroup(OldTexText(\"Sphere centered at\"))\n",
        "        sphere_words.next_to(self.sliders, RIGHT, MED_LARGE_BUFF)\n",
        "        sphere_words.shift(2.5*UP)\n",
        "        self.add(sphere_words)\n",
        "\n",
        "        n_sphere_words = OldTexText(\"32 corner spheres\")\n",
        "        n_sphere_words.to_edge(LEFT)\n",
        "        n_sphere_words.shift(2*UP)\n",
        "        self.add(n_sphere_words)\n",
        "\n",
        "        for coords in it.product(*5*[[-1, 1]]):\n",
        "            s = str(tuple(coords))\n",
        "            s = s.replace(\"1\", \"+1\")\n",
        "            s = s.replace(\"-+1\", \"-1\")\n",
        "            coords_mob = OldTex(s)\n",
        "            coords_mob.set_color(GREEN)\n",
        "            coords_mob.next_to(sphere_words, DOWN)\n",
        "            for slider, x in zip(self.sliders, coords):\n",
        "                for mob in slider.real_estate_ticks, slider.dial:\n",
        "                    mob.move_to(slider.number_to_point(x))\n",
        "            self.sliders[0].dial.move_to(\n",
        "                self.sliders[0].number_to_point(coords[0]+1)\n",
        "            )\n",
        "            self.add(coords_mob)\n",
        "            self.wait(0.25)\n",
        "            self.remove(coords_mob)\n",
        "        self.add(coords_mob)\n",
        "        sphere_words.add(coords_mob)\n",
        "        self.sphere_words = sphere_words\n",
        "\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.play(FadeOut(n_sphere_words))\n",
        "        self.wait(3)\n",
        "\n",
        "    def show_closest_point(self):\n",
        "        target_x = 1-np.sqrt(0.2)\n",
        "        re_line = DashedLine(*[\n",
        "            self.sliders[i].number_to_point(target_x)+MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (-1, RIGHT)]\n",
        "        ])\n",
        "        re_words = OldTexText(\n",
        "            \"$0.2$\", \"units of real \\\\\\\\ estate each\"\n",
        "        )\n",
        "        re_words.next_to(self.sphere_words, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        re_rects = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            rect = Rectangle(\n",
        "                width = 2*slider.tick_size,\n",
        "                height = (1-target_x)*slider.unit_size,\n",
        "                stroke_width = 0,\n",
        "                fill_color = GREEN,\n",
        "                fill_opacity = 0.75,\n",
        "            )\n",
        "            rect.move_to(slider.number_to_point(1), UP)\n",
        "            re_rects.add(rect)\n",
        "        \n",
        "        self.wind_down_ambient_movement()\n",
        "        self.reset_dials(5*[target_x])\n",
        "        self.play(\n",
        "            ShowCreation(re_line),\n",
        "            Write(re_words, run_time = 2)\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, re_rects,\n",
        "            rate_func = double_smooth\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.re_rects = re_rects\n",
        "        self.re_words = re_words\n",
        "        self.re_line = re_line\n",
        "\n",
        "    def show_halfway_point(self):\n",
        "        half_line = Line(*[\n",
        "            self.sliders[i].number_to_point(0.5)+MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (-1, RIGHT)]\n",
        "        ])\n",
        "        half_line.set_color(MAROON_B)\n",
        "        half_label = OldTex(\"0.5\")\n",
        "        half_label.scale(self.sliders[0].number_scale_val)\n",
        "        half_label.next_to(half_line, LEFT, MED_SMALL_BUFF)\n",
        "        half_label.set_color(half_line.get_color())\n",
        "\n",
        "        curr_vector = self.get_vector()\n",
        "        ghost_dials = VGroup(*[\n",
        "            slider.dial.copy().set_fill(WHITE, 0.75)\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        point_25 = OldTex(\"0.25\")\n",
        "        point_25.set_color(half_label.get_color())\n",
        "        point_25.move_to(self.re_words[0], RIGHT)\n",
        "        self.re_words.save_state()\n",
        "\n",
        "        self.play(\n",
        "            Write(half_label),\n",
        "            ShowCreation(half_line)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.add(ghost_dials)\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, 0.5)\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "        self.play(Transform(self.re_words[0], point_25))\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(slider.set_value, x)\n",
        "            for x, slider in zip(curr_vector, self.sliders)\n",
        "        ])\n",
        "        self.play(self.re_words.restore)\n",
        "\n",
        "    def reframe_as_inner_sphere_point(self):\n",
        "        s = self.sliders[0]\n",
        "        shift_vect = s.number_to_point(0)-s.number_to_point(1)\n",
        "        re_ticks = VGroup(*[\n",
        "            slider.real_estate_ticks\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "\n",
        "        re_rects = self.re_rects\n",
        "        re_rects.generate_target()\n",
        "        for rect, slider in zip(re_rects.target, self.sliders):\n",
        "            height = slider.unit_size*(1-np.sqrt(0.2))\n",
        "            rect.set_height(height)\n",
        "            rect.move_to(slider.number_to_point(0), DOWN)\n",
        "\n",
        "        self.sphere_words.generate_target()\n",
        "        old_coords = self.sphere_words.target[1]\n",
        "        new_coords = OldTex(str(tuple(5*[0])))\n",
        "        new_coords.replace(old_coords, dim_to_match = 1)\n",
        "        new_coords.set_color(old_coords.get_color())\n",
        "        Transform(old_coords, new_coords).update(1)\n",
        "\n",
        "        self.re_words.generate_target()\n",
        "        new_re = OldTex(\"0.31\")\n",
        "        new_re.set_color(GREEN)\n",
        "        old_re = self.re_words.target[0]\n",
        "        new_re.move_to(old_re, RIGHT)\n",
        "        Transform(old_re, new_re).update(1)\n",
        "\n",
        "        self.play(\n",
        "            Animation(self.sliders),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, re_ticks,\n",
        "                lambda m : (m.shift, shift_vect),\n",
        "                path_arc = np.pi\n",
        "            ),\n",
        "            MoveToTarget(self.sphere_words),\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                re_rects, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = np.pi\n",
        "            ),\n",
        "            MoveToTarget(self.re_words),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_center_point(np.zeros(5))\n",
        "        self.total_real_estate = (np.sqrt(5)-1)**2\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(12)\n",
        "\n",
        "    def compute_radius(self):\n",
        "        computation = OldTex(\n",
        "            \"R_{\\\\text{inner}} &= \\\\sqrt{5}-1 \\\\\\\\\",\n",
        "            \"&\\\\approx 1.24\"\n",
        "        )\n",
        "        computation.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(Write(computation, run_time = 2))\n",
        "        self.wait(12)\n",
        "\n",
        "    def poke_out_of_box(self):\n",
        "        self.wind_down_ambient_movement(0)\n",
        "        self.reset_dials([np.sqrt(5)-1])\n",
        "\n",
        "        words = OldTexText(\"Poking outside \\\\\\\\ the box!\")\n",
        "        words.to_edge(LEFT)\n",
        "        words.set_color(RED)\n",
        "        arrow = Arrow(\n",
        "            words.get_top(),\n",
        "            self.sliders[0].dial,\n",
        "            path_arc = -np.pi/3,\n",
        "            color = words.get_color()\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class SkipAheadTo10(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Let's skip ahead \\\\\\\\ to 10 dimensions\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pleading\", \"confused\", \"horrified\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class TenDBoxExampleWithSliders(FiveDBoxExampleWithSliders):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 10,\n",
        "        \"center_point\" : np.ones(10),\n",
        "        \"ambient_velocity_magnitude\" : 2.0,\n",
        "        \"ambient_acceleration_magnitude\" : 3.0,\n",
        "    }\n",
        "    def setup(self):\n",
        "        FourDBoxExampleWithSliders.setup(self)\n",
        "        self.sliders.to_edge(RIGHT)\n",
        "\n",
        "    def construct(self):\n",
        "        self.initial_wandering()\n",
        "        self.show_closest_point()\n",
        "        self.reframe_as_inner_sphere_point()\n",
        "        self.compute_inner_radius_numerically()\n",
        "        self.wander_on_inner_sphere()\n",
        "        self.poke_outside_outer_box()\n",
        "\n",
        "    def initial_wandering(self):\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(9)\n",
        "\n",
        "    def show_closest_point(self):\n",
        "        target_x = 1-np.sqrt(1./self.n_sliders)\n",
        "        re_line = DashedLine(*[\n",
        "            self.sliders[i].number_to_point(target_x)+MED_SMALL_BUFF*vect\n",
        "            for i, vect in [(0, LEFT), (-1, RIGHT)]\n",
        "        ])\n",
        "\n",
        "        re_rects = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            rect = Rectangle(\n",
        "                width = 2*slider.tick_size,\n",
        "                height = (1-target_x)*slider.unit_size,\n",
        "                stroke_width = 0,\n",
        "                fill_color = GREEN,\n",
        "                fill_opacity = 0.75,\n",
        "            )\n",
        "            rect.move_to(slider.number_to_point(1), UP)\n",
        "            re_rects.add(rect)\n",
        "        \n",
        "        self.wind_down_ambient_movement()\n",
        "        self.reset_dials(self.n_sliders*[target_x])\n",
        "        self.play(ShowCreation(re_line))\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, re_rects,\n",
        "            rate_func = double_smooth\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.re_line = re_line\n",
        "        self.re_rects = re_rects\n",
        "\n",
        "    def reframe_as_inner_sphere_point(self):\n",
        "        s = self.sliders[0]\n",
        "        shift_vect = s.number_to_point(0)-s.number_to_point(1)\n",
        "        re_ticks = VGroup(*[\n",
        "            slider.real_estate_ticks\n",
        "            for slider in self.sliders\n",
        "        ])\n",
        "\n",
        "        re_rects = self.re_rects\n",
        "        re_rects.generate_target()\n",
        "        for rect, slider in zip(re_rects.target, self.sliders):\n",
        "            height = slider.unit_size*(1-np.sqrt(1./self.n_sliders))\n",
        "            rect.stretch_to_fit_height(height)\n",
        "            rect.move_to(slider.number_to_point(0), DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Animation(self.sliders),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, re_ticks,\n",
        "                lambda m : (m.shift, shift_vect),\n",
        "                path_arc = np.pi\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                re_rects, \n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5,\n",
        "                path_arc = np.pi\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_center_point(np.zeros(self.n_sliders))\n",
        "        self.total_real_estate = (np.sqrt(self.n_sliders)-1)**2\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "        self.wait(5)\n",
        "\n",
        "    def compute_inner_radius_numerically(self):\n",
        "        computation = OldTex(\n",
        "            \"R_{\\\\text{inner}} &= \\\\sqrt{10}-1 \\\\\\\\\",\n",
        "            \"&\\\\approx 2.16\"\n",
        "        )\n",
        "        computation.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(Write(computation, run_time = 2))\n",
        "\n",
        "    def wander_on_inner_sphere(self):\n",
        "        self.wait(10)\n",
        "\n",
        "    def poke_outside_outer_box(self):\n",
        "        self.wind_down_ambient_movement()\n",
        "        self.reset_dials([np.sqrt(10)-1])\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Outside the \\\\emph{outer} \\\\\\\\\",\n",
        "            \"bounding box!\"\n",
        "        )\n",
        "        words.to_edge(LEFT)\n",
        "        words.set_color(RED)\n",
        "        arrow = Arrow(\n",
        "            words.get_top(), \n",
        "            self.sliders[0].dial,\n",
        "            path_arc = -np.pi/3,\n",
        "            color = words.get_color()\n",
        "        )\n",
        "        self.play(\n",
        "            Write(words, run_time = 2),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class TwoDOuterBox(TwoDInnerSphereTouchingBox):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"$4 \\\\!\\\\times\\\\! 4$ outer bounding box\")\n",
        "        words.next_to(self.plane, UP)\n",
        "        words.set_color(MAROON_B)\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(-2, -2),\n",
        "            self.plane.coords_to_point(2, 2),\n",
        "        )\n",
        "        box = Square(color = words.get_color())\n",
        "        box.replace(line, stretch = True)\n",
        "        box.set_stroke(width = 8)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            ShowCreation(box),\n",
        "            self.randy.change, \"pondering\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.outer_box = box\n",
        "\n",
        "class ThreeDOuterBoundingBox(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ThreeDOuterBoundingBoxWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"$4 \\\\!\\\\times\\\\! 4\\\\!\\\\times\\\\! 4$ outer\\\\\\\\\",\n",
        "            \"bounding box\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH-1)\n",
        "        words.to_edge(DOWN)\n",
        "        words.set_color(MAROON_B)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait(4)\n",
        "\n",
        "class FaceDistanceDoesntDependOnDimension(TwoDOuterBox):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        TwoDOuterBox.construct(self)\n",
        "        self.randy.change(\"confused\")\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        line = Line(\n",
        "            self.plane.coords_to_point(0, 0),\n",
        "            self.outer_box.get_right(),\n",
        "            buff = 0,\n",
        "            stroke_width = 6,\n",
        "            color = YELLOW\n",
        "        )\n",
        "        length_words = OldTexText(\"Always 2, in all dimensions\")\n",
        "        length_words.next_to(self.plane, RIGHT, MED_LARGE_BUFF, UP)\n",
        "        arrow = Arrow(length_words[4].get_bottom(), line.get_center())\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(\n",
        "            Write(length_words),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.play(self.randy.change, \"thinking\")\n",
        "        self.wait(3)\n",
        "\n",
        "class TenDCornerIsVeryFarAway(TenDBoxExampleWithSliders):\n",
        "    CONFIG = {\n",
        "        \"center_point\" : np.zeros(10)\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_re_rects()\n",
        "\n",
        "    def show_re_rects(self):\n",
        "        re_rects = VGroup()\n",
        "        for slider in self.sliders:\n",
        "            rect = Rectangle(\n",
        "                width = 2*slider.tick_size,\n",
        "                height = slider.unit_size,\n",
        "                stroke_width = 0,\n",
        "                fill_color = GREEN,\n",
        "                fill_opacity = 0.75,\n",
        "            )\n",
        "            rect.move_to(slider.number_to_point(0), DOWN)\n",
        "            re_rects.add(rect)\n",
        "            rect.save_state()\n",
        "            rect.stretch_to_fit_height(0)\n",
        "            rect.move_to(rect.saved_state, DOWN)\n",
        "\n",
        "        self.set_to_vector(np.zeros(10))\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, re_rects,\n",
        "                lambda m : (m.restore,),\n",
        "                lag_ratio = 0.3,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, self.sliders,\n",
        "                lambda m : (m.set_value, 1),\n",
        "                lag_ratio = 0.3,\n",
        "            ),\n",
        "            run_time = 10,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class InnerRadiusIsUnbounded(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Inner radius \\\\\\\\ is unbounded\")\n",
        "        self.play_student_changes(*[\"erm\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ProportionOfSphereInBox(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_axis_label\" : \"Dimension\",\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"y_max\" : 1.5,\n",
        "        \"y_min\" : 0,\n",
        "        \"y_tick_frequency\" : 0.25,\n",
        "        \"y_labeled_nums\" : np.linspace(0.25, 1, 4),\n",
        "        \"x_min\" : 0,\n",
        "        \"x_max\" : 50,\n",
        "        \"x_tick_frequency\" : 5,\n",
        "        \"x_labeled_nums\" : list(range(10, 50, 10)),\n",
        "        \"num_graph_anchor_points\" : 100,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        title = OldTexText(\n",
        "            \"Proportion of inner sphere \\\\\\\\ inside box\"\n",
        "        )\n",
        "        title.next_to(self.y_axis, RIGHT, MED_SMALL_BUFF, UP)\n",
        "        self.add(title)\n",
        "\n",
        "        graph = self.get_graph(lambda x : np.exp(0.1*(9-x)))\n",
        "        max_y = self.coords_to_point(0, 1)[1]\n",
        "        too_high = graph.get_points()[:,1] > max_y\n",
        "        graph.get_points()[too_high, 1] = max_y\n",
        "\n",
        "        footnote = OldTexText(\"\"\"\n",
        "            \\\\begin{flushleft}\n",
        "            *I may or may not have used an easy-to-compute \\\\\\\\\n",
        "            but not-totally-accurate curve here, due to \\\\\\\\\n",
        "            the surprising difficulty in computing the real \\\\\\\\\n",
        "            proportion :)\n",
        "            \\\\end{flushleft}\n",
        "        \"\"\",)\n",
        "        footnote.scale(0.75)\n",
        "        footnote.next_to(\n",
        "            graph.point_from_proportion(0.3),\n",
        "            UP+RIGHT, SMALL_BUFF\n",
        "        )\n",
        "        footnote.set_color(YELLOW)\n",
        "\n",
        "        self.play(ShowCreation(graph, run_time = 5, rate_func=linear))\n",
        "        self.wait()\n",
        "        self.add(footnote)\n",
        "        self.wait(0.25)\n",
        "\n",
        "class ShowingToFriend(PiCreatureScene, SliderScene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 10,\n",
        "        \"ambient_acceleration_magnitude\" : 3.0,\n",
        "        \"seconds_to_blink\" : 4,\n",
        "    }\n",
        "    def setup(self):\n",
        "        PiCreatureScene.setup(self)\n",
        "        SliderScene.setup(self)\n",
        "        self.sliders.scale(0.75)\n",
        "        self.sliders.next_to(\n",
        "            self.morty.get_corner(UP+LEFT), UP, MED_LARGE_BUFF\n",
        "        )\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "\n",
        "    def construct(self):\n",
        "        morty, randy = self.morty, self.randy\n",
        "        self.play(morty.change, \"raise_right_hand\", self.sliders)\n",
        "        self.play(randy.change, \"happy\", self.sliders)\n",
        "        self.wait(7)\n",
        "        self.play(randy.change, \"skeptical\", morty.eyes)\n",
        "        self.wait(3)\n",
        "        self.play(randy.change, \"thinking\", self.sliders)\n",
        "        self.wait(6)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        self.morty = Mortimer()\n",
        "        self.morty.to_edge(DOWN).shift(4*RIGHT)\n",
        "        self.randy = Randolph()\n",
        "        self.randy.to_edge(DOWN).shift(4*LEFT)\n",
        "        return VGroup(self.morty, self.randy)\n",
        "\n",
        "    def non_blink_wait(self, time = 1):\n",
        "        SliderScene.wait(self, time)\n",
        "\n",
        "class QuestionsFromStudents(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Is 10-dimensional \\\\\\\\ space real?\",\n",
        "            target_mode = \"sassy\",\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"No less real \\\\\\\\ than reals\",\n",
        "            target_mode = \"shruggie\",\n",
        "            content_introduction_class = FadeIn,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.student_says(\n",
        "            \"How do you think \\\\\\\\ about volume?\",\n",
        "            index = 0,\n",
        "            content_introduction_class = FadeIn,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"How do cubes work?\",\n",
        "            index = 2,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class FunHighDSpherePhenomena(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\n",
        "            \"Fun high-D sphere phenomena\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(BLUE)\n",
        "        h_line = Line(LEFT, RIGHT).scale(5)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "\n",
        "        items = VGroup(*list(map(TexText, [\n",
        "            \"$\\\\cdot$ Most volume is near the equator\",\n",
        "            \"$\\\\cdot$ Most volume is near the surface\",\n",
        "            \"$\\\\cdot$ Sphere packing in 8 dimensions\",\n",
        "            \"$\\\\cdot$ Sphere packing in 24 dimensions\",\n",
        "        ])))\n",
        "        items.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        items.next_to(h_line, DOWN)\n",
        "\n",
        "        for item in items:\n",
        "            self.play(LaggedStartMap(FadeIn, item, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "class TODOBugOnSurface(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Bug on surface\"\n",
        "    }\n",
        "\n",
        "class CoordinateFree(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane(x_radius = 2.5, y_radius = 2.5)\n",
        "        plane.add_coordinates()\n",
        "        plane.to_corner(UP+LEFT)\n",
        "        self.add(plane)\n",
        "\n",
        "        circles = VGroup(*[\n",
        "            Circle(color = YELLOW).move_to(\n",
        "                plane.coords_to_point(*coords)\n",
        "            )\n",
        "            for coords in it.product(*2*[[-1, 1]])\n",
        "        ])\n",
        "        inner_circle = Circle(\n",
        "            radius = np.sqrt(2)-1,\n",
        "            color = GREEN\n",
        "        ).move_to(plane.coords_to_point(0, 0))\n",
        "\n",
        "        self.add_foreground_mobjects(circles, inner_circle)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            self.pi_creature, \"Lose the \\\\\\\\ coordinates!\",\n",
        "            target_mode = \"hooray\"\n",
        "        ))\n",
        "        self.play(FadeOut(plane, run_time = 2))\n",
        "        self.wait(3)\n",
        "\n",
        "class Skeptic(TeacherStudentsScene, SliderScene):\n",
        "    def setup(self):\n",
        "        SliderScene.setup(self)\n",
        "        TeacherStudentsScene.setup(self)\n",
        "\n",
        "        self.sliders.scale(0.7)\n",
        "        self.sliders.next_to(self.teacher, UP, aligned_edge = LEFT)\n",
        "        self.sliders.to_edge(UP)\n",
        "        self.initialize_ambiant_slider_movement()\n",
        "\n",
        "    def construct(self):\n",
        "        analytic_thought = VGroup(OldTexText(\"No different from\"))\n",
        "        equation = OldTex(\n",
        "            \"x\", \"^2 + \", \"y\", \"^2 + \", \"z\", \"^2 + \", \"w\", \"^2 = 1\"\n",
        "        )\n",
        "        variables = VGroup(*[\n",
        "            equation.get_part_by_tex(tex)\n",
        "            for tex in \"xyzw\"\n",
        "        ])\n",
        "        slider_labels = VGroup(*[\n",
        "            slider.label for slider in self.sliders\n",
        "        ])\n",
        "        equation.next_to(analytic_thought, DOWN)\n",
        "        analytic_thought.add(equation)\n",
        "\n",
        "        all_real_estate_ticks = VGroup(*it.chain(*[\n",
        "            slider.real_estate_ticks\n",
        "            for slider in self.sliders\n",
        "        ]))\n",
        "\n",
        "        box = Square(color = RED)\n",
        "        box.next_to(self.sliders, LEFT)\n",
        "        line = Line(box.get_center(), box.get_corner(UP+RIGHT))\n",
        "        line.set_color(YELLOW)\n",
        "\n",
        "        self.student_says(\n",
        "            analytic_thought,\n",
        "            index = 0,\n",
        "            target_mode = \"sassy\",\n",
        "            added_anims = [self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        equation.remove(*variables)\n",
        "        self.play(ReplacementTransform(variables, slider_labels))\n",
        "        self.play(\n",
        "            self.teacher.change, \"pondering\", slider_labels,\n",
        "            RemovePiCreatureBubble(\n",
        "                self.students[0], target_mode = \"hesitant\"\n",
        "            ),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        bubble = self.teacher.get_bubble(\n",
        "            \"It's much \\\\\\\\ more playful!\",\n",
        "            bubble_type = SpeechBubble\n",
        "        )\n",
        "        bubble.resize_to_content()\n",
        "        VGroup(bubble, bubble.content).next_to(self.teacher, UP+LEFT)\n",
        "        self.play(\n",
        "            self.teacher.change, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode = \"raise_right_hand\",\n",
        "                look_at = self.sliders\n",
        "            ),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"pondering\")\n",
        "                for pi in self.students\n",
        "            ]\n",
        "        )\n",
        "        self.play(Animation(self.sliders), LaggedStartMap(\n",
        "            ApplyMethod, all_real_estate_ticks,\n",
        "            lambda m : (m.shift, SMALL_BUFF*LEFT),\n",
        "            rate_func = wiggle,\n",
        "            lag_ratio = 0.3,\n",
        "            run_time = 4,\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(box),\n",
        "            self.teacher.change, \"happy\"\n",
        "        )\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait(3)\n",
        "\n",
        "    #####\n",
        "    def non_blink_wait(self, time = 1):\n",
        "        SliderScene.wait(self, time)\n",
        "\n",
        "class ClipFrom4DBoxExampleTODO(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Clip from 4d box example\"\n",
        "    }\n",
        "\n",
        "class JustBecauseYouCantVisualize(Scene):\n",
        "    def construct(self):\n",
        "        phrase = \"\\\\raggedright \"\n",
        "        phrase += \"Just because you can't visualize\\\\\\\\ \"\n",
        "        phrase += \"something   doesn't mean you can't\\\\\\\\ \"\n",
        "        phrase += \"still think about it visually.\"\n",
        "        phrase_mob = OldTexText(*phrase.split(\" \"))\n",
        "        phrase_mob.set_color_by_tex(\"visual\", YELLOW)\n",
        "        phrase_mob.next_to(ORIGIN, UP)\n",
        "\n",
        "        for part in phrase_mob:\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, part,\n",
        "                run_time = 0.05*len(part)\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "class Announcements(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Announcements\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        h_line = Line(LEFT, RIGHT).scale(3)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "\n",
        "        items = VGroup(*list(map(TexText, [\n",
        "            \"$\\\\cdot$ Where to learn more\",\n",
        "            \"$\\\\cdot$ Q\\\\&A Followup (podcast!)\",\n",
        "        ])))\n",
        "        items.arrange(DOWN, aligned_edge = LEFT)\n",
        "        items.next_to(h_line, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(items[0], run_time = 2),\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change, \"hooray\", items)\n",
        "            for pi in self.pi_creatures\n",
        "        ])\n",
        "        self.play(Write(items[1], run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"https://brilliant.org/3b1b/\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "        self.remove(rect)\n",
        "        self.play(\n",
        "            url.next_to, self.pi_creature, UP+LEFT\n",
        "        )\n",
        "        url_rect = SurroundingRectangle(url)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(FadeOut(url_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class BrilliantGeometryQuiz(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BrilliantScrollThroughCourses(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class Podcast(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Podcast!\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        title.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        self.add(title)\n",
        "\n",
        "        q_and_a = OldTexText(\"Q\\\\&A Followup\")\n",
        "        q_and_a.next_to(self.teacher.get_corner(UP+LEFT), UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, self.pi_creatures,\n",
        "                lambda pi : (pi.change, \"hooray\", title)\n",
        "            ), \n",
        "            Write(title)\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            Write(q_and_a),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "class HighDPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"Ali Yahya\",\n",
        "            \"William\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"James Park\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"dave nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Corey Ogburn\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Xueqi Li\",\n",
        "            \"David Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Amir Fayazi\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Michael McGuffin\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Tomohiro Furusawa\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(SliderScene):\n",
        "    CONFIG = {\n",
        "        \"n_sliders\" : 10,\n",
        "    }\n",
        "    def construct(self):\n",
        "        for slider in self.sliders:\n",
        "            self.remove(slider.label)\n",
        "            slider.remove(slider.label)\n",
        "        vect = np.random.random(10) - 0.5\n",
        "        vect /= get_norm(vect)\n",
        "        self.set_to_vector(vect)\n",
        "\n",
        "        title = OldTexText(\"10D Sphere?\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "class TenDThumbnail(Scene):\n",
        "    def construct(self):\n",
        "        square = Square()\n",
        "        square.set_height(3.5)\n",
        "        square.set_stroke(YELLOW, 5)\n",
        "        r = square.get_width() / 2\n",
        "        circles = VGroup(*[\n",
        "            Circle(radius=r).move_to(corner)\n",
        "            for corner in square.get_vertices()\n",
        "        ])\n",
        "        circles.set_stroke(BLUE, 5)\n",
        "        circles.set_fill(BLUE, 0.5)\n",
        "        circles.set_sheen(0.5, UL)\n",
        "        lil_circle = Circle(\n",
        "            radius=(np.sqrt(2) - 1) * r\n",
        "        )\n",
        "        lil_circle.set_stroke(YELLOW, 3)\n",
        "        lil_circle.set_fill(YELLOW, 0.5)\n",
        "\n",
        "        group = VGroup(circles, lil_circle, square)\n",
        "        group.to_edge(LEFT)\n",
        "        square.scale(2)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"What\\\\\\\\\"\n",
        "            \"about\\\\\\\\\"\n",
        "            \"in 10D?\\\\\\\\\"\n",
        "            # \"dimensions?\"\n",
        "        )\n",
        "        words.set_height(5)\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            words[0][0].get_left(),\n",
        "            lil_circle.get_center(),\n",
        "            path_arc=90 * DEGREES,\n",
        "            buff=0.5,\n",
        "        )\n",
        "        arrow.set_color(RED)\n",
        "        arrow.set_stroke(width=12)\n",
        "        arrow_group = VGroup(\n",
        "            arrow.copy().set_stroke(BLACK, 16),\n",
        "            arrow,\n",
        "        )\n",
        "\n",
        "        self.add(group)\n",
        "        self.add(words)\n",
        "        self.add(arrow_group)\n"
    ]
}