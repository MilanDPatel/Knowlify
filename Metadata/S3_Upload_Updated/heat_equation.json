{
    "topic": "demonstrates the concept of temperature distribution on a body with many temperatures.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part2.shared_constructs import *\n",
        "\n",
        "\n",
        "class TwoDBodyWithManyTemperatures(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"cells_per_side\": 20,\n",
        "        \"body_height\": 6,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.introduce_body()\n",
        "        self.show_temperature_at_all_points()\n",
        "\n",
        "    def introduce_body(self):\n",
        "        height = self.body_height\n",
        "        buff = 0.025\n",
        "        rows = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Dot(\n",
        "                    # stroke_width=0.5,\n",
        "                    stroke_width=0,\n",
        "                    fill_opacity=1,\n",
        "                )\n",
        "                for x in range(self.cells_per_side)\n",
        "            ]).arrange(RIGHT, buff=buff)\n",
        "            for y in range(self.cells_per_side)\n",
        "        ]).arrange(DOWN, buff=buff)\n",
        "        for row in rows[1::2]:\n",
        "            row.submobjects.reverse()\n",
        "\n",
        "        body = self.body = VGroup(*it.chain(*rows))\n",
        "        body.set_height(height)\n",
        "        body.center()\n",
        "        body.to_edge(LEFT)\n",
        "\n",
        "        axes = self.axes = Axes(\n",
        "            x_min=-5, x_max=5,\n",
        "            y_min=-5, y_max=5,\n",
        "        )\n",
        "        axes.match_height(body)\n",
        "        axes.move_to(body)\n",
        "\n",
        "        for cell in body:\n",
        "            self.color_cell(cell)\n",
        "        # body.set_stroke(WHITE, 0.5)  # Do this?\n",
        "\n",
        "        plate = Square(\n",
        "            stroke_width=0,\n",
        "            fill_color=GREY_D,\n",
        "            sheen_direction=UL,\n",
        "            sheen_factor=1,\n",
        "            fill_opacity=1,\n",
        "        )\n",
        "        plate.replace(body)\n",
        "\n",
        "        plate_words = OldTexText(\"Piece of \\\\\\\\ metal\")\n",
        "        plate_words.scale(2)\n",
        "        plate_words.set_stroke(BLACK, 2, background=True)\n",
        "        plate_words.set_color(BLACK)\n",
        "        plate_words.move_to(plate)\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(plate),\n",
        "            Write(\n",
        "                plate_words,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(plate_words)\n",
        "\n",
        "    def show_temperature_at_all_points(self):\n",
        "        body = self.body\n",
        "        start_corner = body[0].get_center()\n",
        "\n",
        "        dot = Dot(radius=0.01, color=WHITE)\n",
        "        dot.move_to(start_corner)\n",
        "\n",
        "        get_point = dot.get_center\n",
        "\n",
        "        lhs = OldTex(\"T = \")\n",
        "        lhs.next_to(body, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        decimal = DecimalNumber(\n",
        "            num_decimal_places=1,\n",
        "            unit=\"^\\\\circ\"\n",
        "        )\n",
        "        decimal.next_to(lhs, RIGHT, MED_SMALL_BUFF, DOWN)\n",
        "        decimal.add_updater(\n",
        "            lambda d: d.set_value(\n",
        "                40 + 50 * self.point_to_temp(get_point())\n",
        "            )\n",
        "        )\n",
        "\n",
        "        arrow = Arrow(color=YELLOW)\n",
        "        arrow.set_stroke(BLACK, 8, background=True)\n",
        "        arrow.tip.set_stroke(BLACK, 2, background=True)\n",
        "        # arrow.add_to_back(arrow.copy().set_stroke(BLACK, 5))\n",
        "        arrow.add_updater(lambda a: a.put_start_and_end_on(\n",
        "            lhs.get_left() + MED_SMALL_BUFF * LEFT,\n",
        "            get_point(),\n",
        "        ))\n",
        "\n",
        "        dot.add_updater(lambda p: p.move_to(\n",
        "            body[-1] if (1 < len(body)) else start_corner\n",
        "        ))\n",
        "        self.add(body, dot, lhs, decimal, arrow)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(\n",
        "                body,\n",
        "                run_time=10,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(dot)\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(lhs),\n",
        "            FadeOut(decimal),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def point_to_temp(self, point, time=0):\n",
        "        x, y = self.axes.point_to_coords(point)\n",
        "        return two_d_temp_func(\n",
        "            0.3 * x, 0.3 * y, t=time\n",
        "        )\n",
        "\n",
        "    def color_cell(self, cell, vect=RIGHT):\n",
        "        p0 = cell.get_corner(-vect)\n",
        "        p1 = cell.get_corner(vect)\n",
        "        colors = []\n",
        "        for point in p0, p1:\n",
        "            temp = self.point_to_temp(point)\n",
        "            color = temperature_to_color(temp)\n",
        "            colors.append(color)\n",
        "        cell.set_color(color=colors)\n",
        "        cell.set_sheen_direction(vect)\n",
        "        return cell\n",
        "\n",
        "\n",
        "class TwoDBodyWithManyTemperaturesGraph(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class TwoDBodyWithManyTemperaturesContour(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class BringTwoRodsTogether(Scene):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.05,\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -1,\n",
        "            \"x_max\": 11,\n",
        "            \"y_min\": -10,\n",
        "            \"y_max\": 100,\n",
        "            \"y_axis_config\": {\n",
        "                \"unit_size\": 0.06,\n",
        "                \"tick_frequency\": 10,\n",
        "            },\n",
        "        },\n",
        "        \"y_labels\": range(20, 100, 20),\n",
        "        \"graph_x_min\": 0,\n",
        "        \"graph_x_max\": 10,\n",
        "        \"midpoint\": 5,\n",
        "        \"max_temp\": 90,\n",
        "        \"min_temp\": 10,\n",
        "        \"wait_time\": 30,\n",
        "        \"default_n_rod_pieces\": 20,\n",
        "        \"alpha\": 1.0,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.setup_graph()\n",
        "        self.setup_clock()\n",
        "\n",
        "        self.show_rods()\n",
        "        self.show_equilibration()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = Axes(**self.axes_config)\n",
        "        axes.center().to_edge(UP)\n",
        "\n",
        "        y_label = axes.get_y_axis_label(\"\\\\text{Temperature}\")\n",
        "        y_label.to_edge(UP)\n",
        "        axes.y_axis.label = y_label\n",
        "        axes.y_axis.add(y_label)\n",
        "        axes.y_axis.add_numbers(*self.y_labels)\n",
        "\n",
        "        self.axes = axes\n",
        "        self.y_label = y_label\n",
        "\n",
        "    def setup_graph(self):\n",
        "        graph = self.axes.get_graph(\n",
        "            self.initial_function,\n",
        "            x_min=self.graph_x_min,\n",
        "            x_max=self.graph_x_max,\n",
        "            step_size=self.step_size,\n",
        "            discontinuities=[self.midpoint],\n",
        "        )\n",
        "        graph.color_using_background_image(\"VerticalTempGradient\")\n",
        "\n",
        "        self.graph = graph\n",
        "\n",
        "    def setup_clock(self):\n",
        "        clock = Clock()\n",
        "        clock.set_height(1)\n",
        "        clock.to_corner(UR)\n",
        "        clock.shift(MED_LARGE_BUFF * LEFT)\n",
        "\n",
        "        time_lhs = OldTexText(\"Time: \")\n",
        "        time_label = DecimalNumber(\n",
        "            0, num_decimal_places=2,\n",
        "        )\n",
        "        time_rhs = OldTexText(\"s\")\n",
        "        time_group = VGroup(\n",
        "            time_lhs,\n",
        "            time_label,\n",
        "            # time_rhs\n",
        "        )\n",
        "        time_group.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        time_rhs.shift(SMALL_BUFF * LEFT)\n",
        "        time_group.next_to(clock, DOWN)\n",
        "\n",
        "        self.time_group = time_group\n",
        "        self.time_label = time_label\n",
        "        self.clock = clock\n",
        "\n",
        "    def show_rods(self):\n",
        "        rod1, rod2 = rods = VGroup(\n",
        "            self.get_rod(0, 5),\n",
        "            self.get_rod(5, 10),\n",
        "        )\n",
        "        rod1.set_color(rod1[0].get_color())\n",
        "        rod2.set_color(rod2[-1].get_color())\n",
        "\n",
        "        rods.save_state()\n",
        "        rods.space_out_submobjects(1.5)\n",
        "        rods.center()\n",
        "\n",
        "        labels = VGroup(\n",
        "            OldTex(\"90^\\\\circ\"),\n",
        "            OldTex(\"10^\\\\circ\"),\n",
        "        )\n",
        "        for rod, label in zip(rods, labels):\n",
        "            label.next_to(rod, DOWN)\n",
        "            rod.label = label\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rod1, UP),\n",
        "            Write(rod1.label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(rod2, DOWN),\n",
        "            Write(rod2.label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.rods = rods\n",
        "        self.rod_labels = labels\n",
        "\n",
        "    def show_equilibration(self):\n",
        "        rods = self.rods\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        labels = self.rod_labels\n",
        "        self.play(\n",
        "            Write(axes),\n",
        "            rods.restore,\n",
        "            rods.space_out_submobjects, 1.1,\n",
        "            FadeIn(self.time_group),\n",
        "            FadeIn(self.clock),\n",
        "            *[\n",
        "                MaintainPositionRelativeTo(\n",
        "                    rod.label, rod\n",
        "                )\n",
        "                for rod in rods\n",
        "            ],\n",
        "        )\n",
        "\n",
        "        br1 = Rectangle(height=0.2, width=1)\n",
        "        br1.set_stroke(width=0)\n",
        "        br1.set_fill(BLACK, opacity=1)\n",
        "        br2 = br1.copy()\n",
        "        br1.add_updater(lambda b: b.move_to(axes.c2p(0, 90)))\n",
        "        br1.add_updater(\n",
        "            lambda b: b.align_to(rods[0].get_right(), LEFT)\n",
        "        )\n",
        "        br2.add_updater(lambda b: b.move_to(axes.c2p(0, 10)))\n",
        "        br2.add_updater(\n",
        "            lambda b: b.align_to(rods[1].get_left(), RIGHT)\n",
        "        )\n",
        "\n",
        "        self.add(graph, br1, br2)\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            labels[0].align_to, axes.c2p(0, 87), UP,\n",
        "            labels[1].align_to, axes.c2p(0, 13), DOWN,\n",
        "        )\n",
        "        self.play()\n",
        "        self.play(\n",
        "            rods.restore,\n",
        "            rate_func=rush_into,\n",
        "        )\n",
        "        self.remove(br1, br2)\n",
        "\n",
        "        graph.add_updater(self.update_graph)\n",
        "        self.time_label.add_updater(\n",
        "            lambda d, dt: d.increment_value(dt)\n",
        "        )\n",
        "        rods.add_updater(self.update_rods)\n",
        "\n",
        "        self.play(\n",
        "            self.get_clock_anim(self.wait_time),\n",
        "            FadeOut(labels)\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_clock_anim(self, time, **kwargs):\n",
        "        config = {\n",
        "            \"run_time\": time,\n",
        "            \"hours_passed\": time,\n",
        "        }\n",
        "        config.update(kwargs)\n",
        "        return ClockPassesTime(self.clock, **config)\n",
        "\n",
        "    def initial_function(self, x):\n",
        "        epsilon = 1e-10\n",
        "        if x < self.midpoint - epsilon:\n",
        "            return self.max_temp\n",
        "        elif x > self.midpoint + epsilon:\n",
        "            return self.min_temp\n",
        "        else:\n",
        "            return (self.min_temp + self.max_temp) / 2\n",
        "\n",
        "    def update_graph(self, graph, dt, alpha=None, n_mini_steps=500):\n",
        "        if alpha is None:\n",
        "            alpha = self.alpha\n",
        "        points = np.append(\n",
        "            graph.get_start_anchors(),\n",
        "            [graph.get_last_point()],\n",
        "            axis=0,\n",
        "        )\n",
        "        for k in range(n_mini_steps):\n",
        "            y_change = np.zeros(points.shape[0])\n",
        "            dx = points[1][0] - points[0][0]\n",
        "            for i in range(len(points)):\n",
        "                p = points[i]\n",
        "                lp = points[max(i - 1, 0)]\n",
        "                rp = points[min(i + 1, len(points) - 1)]\n",
        "                d2y = (rp[1] - 2 * p[1] + lp[1])\n",
        "\n",
        "                if (0 < i < len(points) - 1):\n",
        "                    second_deriv = d2y / (dx**2)\n",
        "                else:\n",
        "                    second_deriv = 2 * d2y / (dx**2)\n",
        "                    # second_deriv = 0\n",
        "\n",
        "                y_change[i] = alpha * second_deriv * dt / n_mini_steps\n",
        "\n",
        "            # y_change[0] = y_change[1]\n",
        "            # y_change[-1] = y_change[-2]\n",
        "            # y_change[0] = 0\n",
        "            # y_change[-1] = 0\n",
        "            # y_change -= np.mean(y_change)\n",
        "            points[:, 1] += y_change\n",
        "        graph.set_points_smoothly(points)\n",
        "        return graph\n",
        "\n",
        "    def get_second_derivative(self, x, dx=0.001):\n",
        "        graph = self.graph\n",
        "        x_min = self.graph_x_min\n",
        "        x_max = self.graph_x_max\n",
        "\n",
        "        ly, y, ry = [\n",
        "            graph.point_from_proportion(\n",
        "                inverse_interpolate(x_min, x_max, alt_x)\n",
        "            )[1]\n",
        "            for alt_x in (x - dx, x, x + dx)\n",
        "        ]\n",
        "\n",
        "        # At the boundary, don't return the second deriv,\n",
        "        # but instead something matching the Neumann\n",
        "        # boundary condition.\n",
        "        if x == x_max:\n",
        "            return (ly - y) / dx\n",
        "        elif x == x_min:\n",
        "            return (ry - y) / dx\n",
        "        else:\n",
        "            d2y = ry - 2 * y + ly\n",
        "            return d2y / (dx**2)\n",
        "\n",
        "    def get_rod(self, x_min, x_max, n_pieces=None):\n",
        "        if n_pieces is None:\n",
        "            n_pieces = self.default_n_rod_pieces\n",
        "        axes = self.axes\n",
        "        line = Line(axes.c2p(x_min, 0), axes.c2p(x_max, 0))\n",
        "        rod = VGroup(*[\n",
        "            Square()\n",
        "            for n in range(n_pieces)\n",
        "        ])\n",
        "        rod.arrange(RIGHT, buff=0)\n",
        "        rod.match_width(line)\n",
        "        rod.set_height(0.2, stretch=True)\n",
        "        rod.move_to(axes.c2p(x_min, 0), LEFT)\n",
        "        rod.set_fill(opacity=1)\n",
        "        rod.set_stroke(width=1)\n",
        "        rod.set_sheen_direction(RIGHT)\n",
        "        self.color_rod_by_graph(rod)\n",
        "        return rod\n",
        "\n",
        "    def update_rods(self, rods):\n",
        "        for rod in rods:\n",
        "            self.color_rod_by_graph(rod)\n",
        "\n",
        "    def color_rod_by_graph(self, rod):\n",
        "        for piece in rod:\n",
        "            piece.set_color(color=[\n",
        "                self.rod_point_to_color(piece.get_left()),\n",
        "                self.rod_point_to_color(piece.get_right()),\n",
        "            ])\n",
        "\n",
        "    def rod_point_to_graph_y(self, point):\n",
        "        axes = self.axes\n",
        "        x = axes.x_axis.p2n(point)\n",
        "\n",
        "        graph = self.graph\n",
        "        alpha = inverse_interpolate(\n",
        "            self.graph_x_min,\n",
        "            self.graph_x_max,\n",
        "            x,\n",
        "        )\n",
        "        return axes.y_axis.p2n(\n",
        "            graph.point_from_proportion(alpha)\n",
        "        )\n",
        "\n",
        "    def y_to_color(self, y):\n",
        "        y_max = self.max_temp\n",
        "        y_min = self.min_temp\n",
        "        alpha = inverse_interpolate(y_min, y_max, y)\n",
        "        return temperature_to_color(interpolate(-0.8, 0.8, alpha))\n",
        "\n",
        "    def rod_point_to_color(self, point):\n",
        "        return self.y_to_color(\n",
        "            self.rod_point_to_graph_y(point)\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowEvolvingTempGraphWithArrows(BringTwoRodsTogether):\n",
        "    CONFIG = {\n",
        "        \"alpha\": 0.1,\n",
        "        \"arrow_xs\": np.linspace(0, 10, 22)[1:-1],\n",
        "        \"arrow_scale_factor\": 0.5,\n",
        "        \"max_magnitude\": 1.5,\n",
        "        \"wait_time\": 30,\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "            (5, 0.3),\n",
        "            (7, 0.2),\n",
        "            (21, 0.1),\n",
        "            (41, 0.05),\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_clock()\n",
        "        self.add_rod()\n",
        "        self.add_arrows()\n",
        "        self.initialize_updaters()\n",
        "        self.let_play()\n",
        "\n",
        "    def add_axes(self):\n",
        "        self.setup_axes()\n",
        "        self.add(self.axes)\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.setup_graph()\n",
        "        self.add(self.graph)\n",
        "\n",
        "    def add_clock(self):\n",
        "        self.setup_clock()\n",
        "        self.add(self.clock)\n",
        "        self.add(self.time_label)\n",
        "        self.time_label.next_to(self.clock, DOWN)\n",
        "\n",
        "    def add_rod(self):\n",
        "        rod = self.rod = self.get_rod(\n",
        "            self.graph_x_min,\n",
        "            self.graph_x_max,\n",
        "        )\n",
        "        self.add(rod)\n",
        "\n",
        "    def add_arrows(self):\n",
        "        graph = self.graph\n",
        "        x_min = self.graph_x_min\n",
        "        x_max = self.graph_x_max\n",
        "\n",
        "        xs = self.arrow_xs\n",
        "        arrows = VGroup(*[Vector(DOWN) for x in xs])\n",
        "        asf = self.arrow_scale_factor\n",
        "\n",
        "        def update_arrows(arrows):\n",
        "            for x, arrow in zip(xs, arrows):\n",
        "                d2y_dx2 = self.get_second_derivative(x)\n",
        "                mag = asf * np.sign(d2y_dx2) * abs(d2y_dx2)\n",
        "                mag = np.clip(\n",
        "                    mag,\n",
        "                    -self.max_magnitude,\n",
        "                    self.max_magnitude,\n",
        "                )\n",
        "                arrow.put_start_and_end_on(\n",
        "                    ORIGIN, mag * UP\n",
        "                )\n",
        "                point = graph.point_from_proportion(\n",
        "                    inverse_interpolate(x_min, x_max, x)\n",
        "                )\n",
        "                arrow.shift(point - arrow.get_start())\n",
        "                arrow.set_color(\n",
        "                    self.rod_point_to_color(point)\n",
        "                )\n",
        "\n",
        "        arrows.add_updater(update_arrows)\n",
        "\n",
        "        self.add(arrows)\n",
        "        self.arrows = arrows\n",
        "\n",
        "    def initialize_updaters(self):\n",
        "        if hasattr(self, \"graph\"):\n",
        "            self.graph.add_updater(self.update_graph)\n",
        "        if hasattr(self, \"rod\"):\n",
        "            self.rod.add_updater(self.color_rod_by_graph)\n",
        "        if hasattr(self, \"time_label\"):\n",
        "            self.time_label.add_updater(\n",
        "                lambda d, dt: d.increment_value(dt)\n",
        "            )\n",
        "\n",
        "    def let_play(self):\n",
        "        self.run_clock(self.wait_time)\n",
        "\n",
        "    def run_clock(self, time):\n",
        "        self.play(\n",
        "            ClockPassesTime(\n",
        "                self.clock,\n",
        "                run_time=time,\n",
        "                hours_passed=time,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def temp_func(self, x, t):\n",
        "        new_x = TAU * x / 10\n",
        "        return 50 + 20 * np.sum([\n",
        "            amp * np.sin(freq * new_x) *\n",
        "            np.exp(-(self.alpha * freq**2) * t)\n",
        "            for freq, amp in self.freq_amplitude_pairs\n",
        "        ])\n",
        "\n",
        "    def initial_function(self, x, time=0):\n",
        "        return self.temp_func(x, 0)\n",
        "\n",
        "\n",
        "class TalkThrough1DHeatGraph(ShowEvolvingTempGraphWithArrows, SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "            (5, 0.3),\n",
        "            (7, 0.2),\n",
        "        ],\n",
        "        \"surface_resolution\": 20,\n",
        "        \"graph_slice_step\": 10 / 20,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_rod()\n",
        "\n",
        "        self.emphasize_graph()\n",
        "        self.emphasize_rod()\n",
        "        self.show_x_axis()\n",
        "        self.show_changes_over_time()\n",
        "        self.show_surface()\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.graph = self.get_graph()\n",
        "        self.add(self.graph)\n",
        "\n",
        "    def emphasize_graph(self):\n",
        "        graph = self.graph\n",
        "        q_marks = VGroup(*[\n",
        "            OldTex(\"?\").move_to(\n",
        "                graph.point_from_proportion(a),\n",
        "                UP,\n",
        "            ).set_stroke(BLACK, 3, background=True)\n",
        "            for a in np.linspace(0, 1, 20)\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            Succession(\n",
        "                FadeInFromLarge(q_mark),\n",
        "                FadeOut(q_mark, DOWN),\n",
        "            )\n",
        "            for q_mark in q_marks\n",
        "        ]))\n",
        "        self.wait()\n",
        "\n",
        "    def emphasize_rod(self):\n",
        "        alt_rod = self.get_rod(0, 10, 50)\n",
        "        word = OldTexText(\"Rod\")\n",
        "        word.scale(2)\n",
        "        word.next_to(alt_rod, UP, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    Rotating(piece, rate_func=smooth)\n",
        "                    for piece in alt_rod\n",
        "                ],\n",
        "                run_time=2,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            Write(word)\n",
        "        )\n",
        "        self.remove(*alt_rod)\n",
        "        self.wait()\n",
        "\n",
        "        self.rod_word = word\n",
        "\n",
        "    def show_x_axis(self):\n",
        "        rod = self.rod\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        x_axis = axes.x_axis\n",
        "        x_numbers = x_axis.get_number_mobjects(*range(1, 11))\n",
        "        x_axis_label = OldTex(\"x\")\n",
        "        x_axis_label.next_to(x_axis.get_right(), UP)\n",
        "\n",
        "        self.play(\n",
        "            rod.set_opacity, 0.5,\n",
        "            FadeIn(x_axis_label, UL),\n",
        "            LaggedStartMap(\n",
        "                FadeInFrom, x_numbers,\n",
        "                lambda m: (m, UP),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show x-values\n",
        "        triangle = ArrowTip(\n",
        "            start_angle=-90 * DEGREES,\n",
        "            color=GREY_B,\n",
        "        )\n",
        "        x_tracker = ValueTracker(PI)\n",
        "        get_x = x_tracker.get_value\n",
        "\n",
        "        def get_x_point():\n",
        "            return x_axis.n2p(get_x())\n",
        "\n",
        "        def get_graph_point():\n",
        "            return graph.point_from_proportion(\n",
        "                inverse_interpolate(\n",
        "                    self.graph_x_min,\n",
        "                    self.graph_x_max,\n",
        "                    get_x(),\n",
        "                )\n",
        "            )\n",
        "\n",
        "        triangle.add_updater(\n",
        "            lambda t: t.next_to(get_x_point(), UP)\n",
        "        )\n",
        "        x_label = VGroup(\n",
        "            OldTex(\"x\"),\n",
        "            OldTex(\"=\"),\n",
        "            DecimalNumber(\n",
        "                0,\n",
        "                num_decimal_places=3,\n",
        "                include_background_rectangle=True,\n",
        "            ).scale(0.9)\n",
        "        )\n",
        "        x_label.set_stroke(BLACK, 5, background=True)\n",
        "        x_label.add_updater(lambda m: m[-1].set_value(get_x()))\n",
        "        x_label.add_updater(lambda m: m.arrange(RIGHT, buff=SMALL_BUFF))\n",
        "        x_label.add_updater(lambda m: m[-1].align_to(m[0], DOWN))\n",
        "        x_label.add_updater(lambda m: m.next_to(triangle, UP, SMALL_BUFF))\n",
        "        x_label.add_updater(lambda m: m.shift(SMALL_BUFF * RIGHT))\n",
        "        rod_piece = always_redraw(\n",
        "            lambda: self.get_rod(\n",
        "                get_x() - 0.05, get_x() + 0.05,\n",
        "                n_pieces=1,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(triangle, UP),\n",
        "            FadeIn(x_label),\n",
        "            FadeIn(rod_piece),\n",
        "            FadeOut(self.rod_word),\n",
        "        )\n",
        "        for value in [np.exp(2), (np.sqrt(5) + 1) / 2]:\n",
        "            self.play(x_tracker.set_value, value, run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        # Show graph\n",
        "        v_line = always_redraw(\n",
        "            lambda: DashedLine(\n",
        "                get_x_point(),\n",
        "                get_graph_point(),\n",
        "                color=self.rod_point_to_color(get_x_point()),\n",
        "            )\n",
        "        )\n",
        "        graph_dot = Dot()\n",
        "        graph_dot.add_updater(\n",
        "            lambda m: m.set_color(\n",
        "                self.rod_point_to_color(m.get_center())\n",
        "            )\n",
        "        )\n",
        "        graph_dot.add_updater(\n",
        "            lambda m: m.move_to(get_graph_point())\n",
        "        )\n",
        "        t_label = OldTex(\"T(\", \"x\", \")\")\n",
        "        t_label.set_stroke(BLACK, 3, background=True)\n",
        "        t_label.add_updater(\n",
        "            lambda m: m.next_to(graph_dot, UR, buff=0)\n",
        "        )\n",
        "\n",
        "        self.add(v_line, rod_piece, x_label, triangle)\n",
        "        self.play(\n",
        "            TransformFromCopy(x_label[0], t_label[1]),\n",
        "            FadeIn(t_label[0::2]),\n",
        "            ShowCreation(v_line),\n",
        "            GrowFromPoint(graph_dot, get_x_point()),\n",
        "        )\n",
        "        self.add(t_label)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x_tracker.set_value, TAU,\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        self.x_tracker = x_tracker\n",
        "        self.graph_label_group = VGroup(\n",
        "            v_line, rod_piece, triangle, x_label,\n",
        "            graph_dot, t_label,\n",
        "        )\n",
        "        self.set_variables_as_attrs(*self.graph_label_group)\n",
        "        self.set_variables_as_attrs(x_numbers, x_axis_label)\n",
        "\n",
        "    def show_changes_over_time(self):\n",
        "        graph = self.graph\n",
        "        t_label = self.t_label\n",
        "        new_t_label = OldTex(\"T(\", \"x\", \",\", \"t\", \")\")\n",
        "        new_t_label.set_color_by_tex(\"t\", YELLOW)\n",
        "        new_t_label.match_updaters(t_label)\n",
        "\n",
        "        self.setup_clock()\n",
        "        clock = self.clock\n",
        "        time_label = self.time_label\n",
        "        time_group = self.time_group\n",
        "\n",
        "        time = 5\n",
        "        self.play(\n",
        "            FadeIn(clock),\n",
        "            FadeIn(time_group),\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_graph_time_change_animation(\n",
        "                graph, time\n",
        "            ),\n",
        "            ClockPassesTime(clock),\n",
        "            ChangeDecimalToValue(\n",
        "                time_label, time,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                t_label,\n",
        "                new_t_label,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 0.7),\n",
        "            ),\n",
        "            run_time=time\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(\n",
        "                new_t_label.get_part_by_tex(\"t\")\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(clock),\n",
        "            ChangeDecimalToValue(time_label, 0),\n",
        "            VFadeOut(time_group),\n",
        "            self.get_graph_time_change_animation(\n",
        "                graph,\n",
        "                new_time=0,\n",
        "            ),\n",
        "            run_time=1,\n",
        "            rate_func=smooth,\n",
        "        )\n",
        "\n",
        "        self.graph_label_group.remove(t_label)\n",
        "        self.graph_label_group.add(new_t_label)\n",
        "\n",
        "    def show_surface(self):\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        t_min = 0\n",
        "        t_max = 10\n",
        "\n",
        "        axes_copy = axes.deepcopy()\n",
        "        self.original_axes = self.axes\n",
        "\n",
        "        # Set rod final state\n",
        "        final_graph = self.get_graph(t_max)\n",
        "        curr_graph = self.graph\n",
        "        self.graph = final_graph\n",
        "        final_rod = self.rod.copy()\n",
        "        final_rod.set_opacity(1)\n",
        "        self.color_rod_by_graph(final_rod)\n",
        "        self.graph = curr_graph\n",
        "\n",
        "        # Time axis\n",
        "        t_axis = NumberLine(\n",
        "            x_min=t_min,\n",
        "            x_max=t_max,\n",
        "        )\n",
        "        origin = axes.c2p(0, 0)\n",
        "        t_axis.shift(origin - t_axis.n2p(0))\n",
        "        t_axis.add_numbers(\n",
        "            *range(1, t_max + 1),\n",
        "            direction=UP,\n",
        "        )\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        time_label.scale(1.5)\n",
        "        time_label.next_to(t_axis, UP)\n",
        "        t_axis.time_label = time_label\n",
        "        t_axis.add(time_label)\n",
        "        # t_axis.rotate(90 * DEGREES, LEFT, about_point=origin)\n",
        "        t_axis.rotate(90 * DEGREES, UP, about_point=origin)\n",
        "\n",
        "        # New parts of graph\n",
        "        step = self.graph_slice_step\n",
        "        graph_slices = VGroup(*[\n",
        "            self.get_graph(time=t).shift(\n",
        "                t * IN\n",
        "            )\n",
        "            for t in np.arange(0, t_max + step, step)\n",
        "        ])\n",
        "        graph_slices.set_stroke(width=1)\n",
        "        graph_slices.set_shade_in_3d(True)\n",
        "\n",
        "        # Input plane\n",
        "        x_axis = self.axes.x_axis\n",
        "        y = axes.c2p(0, 0)[1]\n",
        "        surface_config = {\n",
        "            \"u_min\": self.graph_x_min,\n",
        "            \"u_max\": self.graph_x_max,\n",
        "            \"v_min\": t_min,\n",
        "            \"v_max\": t_max,\n",
        "            \"resolution\": self.surface_resolution,\n",
        "        }\n",
        "        input_plane = ParametricSurface(\n",
        "            lambda x, t: np.array([\n",
        "                x_axis.n2p(x)[0],\n",
        "                y,\n",
        "                t_axis.n2p(t)[2],\n",
        "            ]),\n",
        "            **surface_config,\n",
        "        )\n",
        "        input_plane.set_style(\n",
        "            fill_opacity=0.5,\n",
        "            fill_color=BLUE_B,\n",
        "            stroke_width=0.5,\n",
        "            stroke_color=WHITE,\n",
        "        )\n",
        "\n",
        "        # Surface\n",
        "        y_axis = axes.y_axis\n",
        "        surface = ParametricSurface(\n",
        "            lambda x, t: np.array([\n",
        "                x_axis.n2p(x)[0],\n",
        "                y_axis.n2p(self.temp_func(x, t))[1],\n",
        "                t_axis.n2p(t)[2],\n",
        "            ]),\n",
        "            **surface_config,\n",
        "        )\n",
        "        surface.set_style(\n",
        "            fill_opacity=0.1,\n",
        "            fill_color=GREY_B,\n",
        "            stroke_width=0.5,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_opacity=0.5,\n",
        "        )\n",
        "\n",
        "        # Rotate everything on screen and move camera\n",
        "        # in such a way that it looks the same\n",
        "        curr_group = Group(*self.get_mobjects())\n",
        "        curr_group.clear_updaters()\n",
        "        self.set_camera_orientation(\n",
        "            phi=90 * DEGREES,\n",
        "        )\n",
        "        mobs = [\n",
        "            curr_group,\n",
        "            graph_slices,\n",
        "            t_axis,\n",
        "            input_plane,\n",
        "            surface,\n",
        "        ]\n",
        "        for mob in mobs:\n",
        "            self.orient_mobject_for_3d(mob)\n",
        "\n",
        "        # Clean current mobjects\n",
        "        self.x_label.set_stroke(BLACK, 2, background=True)\n",
        "        self.x_label[-1][0].fade(1)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-85 * DEGREES,\n",
        "            added_anims=[\n",
        "                Write(input_plane),\n",
        "                Write(t_axis),\n",
        "                FadeOut(self.graph_label_group),\n",
        "                self.rod.set_opacity, 1,\n",
        "            ]\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "        self.add(*graph_slices, *self.get_mobjects())\n",
        "        self.play(\n",
        "            FadeIn(surface),\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(graph, graph_slice)\n",
        "                for graph_slice in graph_slices\n",
        "            ], lag_ratio=0.02)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Show slices\n",
        "        self.axes = axes_copy  # So get_graph works...\n",
        "        slicing_plane = Rectangle(\n",
        "            stroke_width=0,\n",
        "            fill_color=WHITE,\n",
        "            fill_opacity=0.2,\n",
        "        )\n",
        "        slicing_plane.set_shade_in_3d(True)\n",
        "        slicing_plane.replace(\n",
        "            Line(axes_copy.c2p(0, 0), axes_copy.c2p(10, 100)),\n",
        "            stretch=True\n",
        "        )\n",
        "        self.orient_mobject_for_3d(slicing_plane)\n",
        "\n",
        "        def get_time_slice(t):\n",
        "            new_slice = self.get_graph(t)\n",
        "            new_slice.set_shade_in_3d(True)\n",
        "            self.orient_mobject_for_3d(new_slice)\n",
        "            new_slice.shift(t * UP)\n",
        "            return new_slice\n",
        "\n",
        "        graph.set_shade_in_3d(True)\n",
        "        t_tracker = ValueTracker(0)\n",
        "        graph.add_updater(lambda g: g.become(\n",
        "            get_time_slice(t_tracker.get_value())\n",
        "        ))\n",
        "\n",
        "        self.orient_mobject_for_3d(final_rod)\n",
        "        final_rod.shift(10 * UP)\n",
        "        kw = {\"run_time\": 10, \"rate_func\": linear}\n",
        "        self.rod.save_state()\n",
        "        self.play(\n",
        "            ApplyMethod(t_tracker.set_value, 10, **kw),\n",
        "            Transform(self.rod, final_rod, **kw),\n",
        "            ApplyMethod(slicing_plane.shift, 10 * UP, **kw),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            t_axis,\n",
        "            input_plane,\n",
        "            surface,\n",
        "            graph_slices,\n",
        "            slicing_plane,\n",
        "            t_tracker,\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_graph(self, time=0):\n",
        "        graph = self.axes.get_graph(\n",
        "            lambda x: self.temp_func(x, time),\n",
        "            x_min=self.graph_x_min,\n",
        "            x_max=self.graph_x_max,\n",
        "            step_size=self.step_size,\n",
        "        )\n",
        "        graph.time = time\n",
        "        graph.color_using_background_image(\"VerticalTempGradient\")\n",
        "        return graph\n",
        "\n",
        "    def get_graph_time_change_animation(self, graph, new_time, **kwargs):\n",
        "        old_time = graph.time\n",
        "        graph.time = new_time\n",
        "        config = {\n",
        "            \"run_time\": abs(new_time - old_time),\n",
        "            \"rate_func\": linear,\n",
        "        }\n",
        "        config.update(kwargs)\n",
        "\n",
        "        return UpdateFromAlphaFunc(\n",
        "            graph,\n",
        "            lambda g, a: g.become(\n",
        "                self.get_graph(interpolate(\n",
        "                    old_time, new_time, a\n",
        "                ))\n",
        "            ),\n",
        "            **config\n",
        "        )\n",
        "\n",
        "    def orient_mobject_for_3d(self, mob):\n",
        "        mob.rotate(\n",
        "            90 * DEGREES,\n",
        "            axis=RIGHT,\n",
        "            about_point=ORIGIN\n",
        "        )\n",
        "        return mob\n",
        "\n",
        "\n",
        "class ContrastXChangesToTChanges(TalkThrough1DHeatGraph):\n",
        "    CONFIG = {\n",
        "        # \"surface_resolution\": 5,\n",
        "        # \"graph_slice_step\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.catchup_with_last_scene()\n",
        "        self.emphasize_dimensions_of_input_space()\n",
        "        self.reset_time_to_zero()\n",
        "\n",
        "        self.show_changes_with_x()\n",
        "        self.show_changes_with_t()\n",
        "\n",
        "    def catchup_with_last_scene(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_rod()\n",
        "\n",
        "        self.rod_word = Point()\n",
        "        self.show_x_axis()\n",
        "        self.show_surface()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def emphasize_dimensions_of_input_space(self):\n",
        "        plane = self.input_plane\n",
        "        plane_copy = plane.copy()\n",
        "        plane_copy.set_color(BLUE_E)\n",
        "        plane_copy.shift(SMALL_BUFF * 0.5 * OUT)\n",
        "\n",
        "        plane_copy1 = plane_copy.copy()\n",
        "        plane_copy1.stretch(0.01, 1, about_edge=DOWN)\n",
        "        plane_copy0 = plane_copy1.copy()\n",
        "        plane_copy0.stretch(0, 0, about_edge=LEFT)\n",
        "\n",
        "        words = OldTexText(\"2d input\\\\\\\\space\")\n",
        "        words.scale(2)\n",
        "        words.move_to(plane.get_center() + SMALL_BUFF * OUT)\n",
        "\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            self.camera.phi_tracker.set_value, 60 * DEGREES,\n",
        "            self.camera.theta_tracker.set_value, -90 * DEGREES,\n",
        "            run_time=1\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(plane_copy0, plane_copy1)\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(plane_copy1, plane_copy)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(plane_copy))\n",
        "\n",
        "        self.input_plane_words = words\n",
        "\n",
        "    def reset_time_to_zero(self):\n",
        "        self.play(\n",
        "            self.t_tracker.set_value, 0,\n",
        "            VFadeOut(self.slicing_plane),\n",
        "            Restore(self.rod),\n",
        "        )\n",
        "\n",
        "    def show_changes_with_x(self):\n",
        "        alpha_tracker = ValueTracker(0)\n",
        "        line = always_redraw(\n",
        "            lambda: self.get_tangent_line(\n",
        "                self.graph, alpha_tracker.get_value(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeOut(self.input_plane_words),\n",
        "            self.camera.phi_tracker.set_value, 80 * DEGREES,\n",
        "            self.camera.theta_tracker.set_value, -90 * DEGREES,\n",
        "        )\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 0.425,\n",
        "            run_time=5,\n",
        "            rate_func=bezier([0, 0, 1, 1]),\n",
        "        )\n",
        "\n",
        "        # Show dx and dT\n",
        "        p0 = line.point_from_proportion(0.3)\n",
        "        p2 = line.point_from_proportion(0.7)\n",
        "        p1 = np.array([p2[0], *p0[1:]])\n",
        "        dx_line = DashedLine(p0, p1)\n",
        "        dT_line = DashedLine(p1, p2)\n",
        "        dx = OldTex(\"dx\")\n",
        "        dT = OldTex(\"dT\")\n",
        "        VGroup(dx, dT).scale(0.7)\n",
        "        VGroup(dx, dT).rotate(90 * DEGREES, RIGHT)\n",
        "        dx.next_to(dx_line, IN, SMALL_BUFF)\n",
        "        dT.next_to(dT_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(dx_line),\n",
        "            FadeIn(dx, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dT_line),\n",
        "            FadeIn(dT, IN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [\n",
        "            line, dx_line, dT_line, dx, dT,\n",
        "        ]))\n",
        "\n",
        "    def show_changes_with_t(self):\n",
        "        slices = self.graph_slices\n",
        "        slice_alpha = 0.075\n",
        "        graph = VMobject()\n",
        "        graph.set_points_smoothly([\n",
        "            gs.point_from_proportion(slice_alpha)\n",
        "            for gs in slices\n",
        "        ])\n",
        "        graph.color_using_background_image(\"VerticalTempGradient\")\n",
        "        graph.set_shade_in_3d(True)\n",
        "\n",
        "        alpha_tracker = ValueTracker(0)\n",
        "        line = always_redraw(\n",
        "            lambda: self.get_tangent_line(\n",
        "                graph, alpha_tracker.get_value(),\n",
        "            )\n",
        "        )\n",
        "\n",
        "        plane = Square()\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.set_fill(WHITE, 0.1)\n",
        "        plane.set_shade_in_3d(True)\n",
        "        plane.rotate(90 * DEGREES, RIGHT)\n",
        "        plane.rotate(90 * DEGREES, OUT)\n",
        "        plane.set_height(10)\n",
        "        plane.set_depth(8, stretch=True)\n",
        "        plane.move_to(self.t_axis.n2p(0), IN + DOWN)\n",
        "        plane.shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            self.camera.theta_tracker.set_value, -20 * DEGREES,\n",
        "            self.camera.frame_center.shift, 4 * LEFT,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                graph.copy(),\n",
        "                remover=True\n",
        "            ),\n",
        "            FadeIn(plane, 6 * DOWN, run_time=2),\n",
        "            VFadeIn(line),\n",
        "            ApplyMethod(\n",
        "                alpha_tracker.set_value, 1,\n",
        "                run_time=8,\n",
        "            ),\n",
        "        )\n",
        "        self.add(graph)\n",
        "\n",
        "        self.begin_ambient_camera_rotation(-0.02)\n",
        "        self.camera.frame_center.add_updater(\n",
        "            lambda m, dt: m.shift(0.05 * dt * RIGHT)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(line),\n",
        "            FadeOut(plane),\n",
        "        )\n",
        "        self.wait(30)  # Let rotate\n",
        "\n",
        "        self.t_graph = graph\n",
        "\n",
        "    #\n",
        "    def get_tangent_line(self, graph, alpha, d_alpha=0.001, length=2):\n",
        "        if alpha < 1 - d_alpha:\n",
        "            a1 = alpha\n",
        "            a2 = alpha + d_alpha\n",
        "        else:\n",
        "            a1 = alpha - d_alpha\n",
        "            a2 = alpha\n",
        "\n",
        "        p1 = graph.point_from_proportion(a1)\n",
        "        p2 = graph.point_from_proportion(a2)\n",
        "        line = Line(p1, p2, color=WHITE)\n",
        "        line.scale(\n",
        "            length / line.get_length()\n",
        "        )\n",
        "        line.move_to(p1)\n",
        "        return line\n",
        "\n",
        "\n",
        "class TransitionToTempVsTime(ContrastXChangesToTChanges):\n",
        "    CONFIG = {\n",
        "        # \"surface_resolution\": 5,\n",
        "        # \"graph_slice_step\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.catchup_with_last_scene()\n",
        "\n",
        "        axes = self.original_axes\n",
        "        t_axis = self.t_axis\n",
        "        y_axis = axes.y_axis\n",
        "        x_axis = axes.x_axis\n",
        "\n",
        "        for mob in self.get_mobjects():\n",
        "            mob.clear_updaters()\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.move_camera(\n",
        "            phi=90 * DEGREES,\n",
        "            theta=0 * DEGREES,\n",
        "            added_anims=[\n",
        "                Rotate(\n",
        "                    y_axis, 90 * DEGREES,\n",
        "                    axis=OUT,\n",
        "                    about_point=y_axis.n2p(0),\n",
        "                ),\n",
        "                FadeOut(VGroup(\n",
        "                    self.graph_slices,\n",
        "                    self.surface,\n",
        "                    self.slicing_plane,\n",
        "                    self.rod,\n",
        "                    self.graph,\n",
        "                    self.x_numbers,\n",
        "                    self.x_axis_label,\n",
        "                    self.t_graph,\n",
        "                )),\n",
        "                self.camera.frame_center.move_to, 5 * LEFT,\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            VGroup(x_axis, self.input_plane).stretch,\n",
        "            0, 0, {\"about_point\": y_axis.n2p(0)},\n",
        "        )\n",
        "        self.play(\n",
        "            t_axis.time_label.scale, 1 / 1.5,\n",
        "            t_axis.time_label.next_to, t_axis, IN, MED_LARGE_BUFF,\n",
        "            t_axis.numbers.shift, 0.7 * IN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def catchup_with_last_scene(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_rod()\n",
        "\n",
        "        self.rod_word = Point()\n",
        "        self.show_x_axis()\n",
        "        self.show_surface()\n",
        "\n",
        "        self.emphasize_dimensions_of_input_space()\n",
        "        self.reset_time_to_zero()\n",
        "\n",
        "        self.show_changes_with_x()\n",
        "        self.show_changes_with_t()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "\n",
        "class ShowDelTermsAsTinyNudges(TransitionToTempVsTime):\n",
        "    CONFIG = {\n",
        "        # \"surface_resolution\": 5,\n",
        "        # \"graph_slice_step\": 1,\n",
        "        \"tangent_line_length\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.catchup_with_last_scene()\n",
        "        self.stop_camera()\n",
        "        self.show_del_t()\n",
        "        self.show_del_x()\n",
        "\n",
        "    def stop_camera(self):\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        for mob in self.get_mobjects():\n",
        "            mob.clear_updaters()\n",
        "\n",
        "    def show_del_x(self):\n",
        "        x_tracker = ValueTracker(3)\n",
        "        dx_tracker = ValueTracker(0.5)\n",
        "\n",
        "        line_group = self.get_line_group(\n",
        "            self.graph,\n",
        "            x_tracker,\n",
        "            dx_tracker,\n",
        "            corner_index=0,\n",
        "        )\n",
        "        dx_line, dT_line, tan_line = line_group\n",
        "\n",
        "        del_x = OldTex(\"\\\\partial x\")\n",
        "        del_x.set_color(GREEN)\n",
        "        del_x.line = dx_line\n",
        "        del_x.direction = OUT\n",
        "        del_T = OldTex(\"\\\\partial T\")\n",
        "        del_T.line = dT_line\n",
        "        del_T.direction = RIGHT\n",
        "        syms = VGroup(del_T, del_x)\n",
        "        for sym in syms:\n",
        "            sym.add_updater(lambda m: m.set_width(\n",
        "                dx_line.get_length()\n",
        "            ))\n",
        "            sym.rect = SurroundingRectangle(sym)\n",
        "            group = VGroup(sym, sym.rect)\n",
        "            group.rotate(90 * DEGREES, RIGHT)\n",
        "\n",
        "        for sym in syms:\n",
        "            sym.add_updater(lambda m: m.next_to(\n",
        "                m.line, m.direction, SMALL_BUFF,\n",
        "            ))\n",
        "            sym.rect.move_to(sym)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-90 * DEGREES,\n",
        "            added_anims=[\n",
        "                self.camera.frame_center.move_to, ORIGIN,\n",
        "            ],\n",
        "        )\n",
        "        for sym in reversed(syms):\n",
        "            self.play(\n",
        "                FadeIn(sym, -sym.direction),\n",
        "                ShowCreation(\n",
        "                    sym.line.copy(),\n",
        "                    remover=True\n",
        "                ),\n",
        "            )\n",
        "            self.add(sym.line)\n",
        "        self.play(ShowCreation(tan_line))\n",
        "        for sym in syms:\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(sym.rect)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.add(line_group)\n",
        "        self.play(\n",
        "            dx_tracker.set_value, 0.01,\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(syms),\n",
        "            FadeOut(line_group),\n",
        "        )\n",
        "\n",
        "    def show_del_t(self):\n",
        "        # Largely copy pasted from above.\n",
        "        # Reconsolidate if any of this will actually\n",
        "        # be used later.\n",
        "        t_tracker = ValueTracker(1)\n",
        "        dt_tracker = ValueTracker(1)\n",
        "\n",
        "        line_group = self.get_line_group(\n",
        "            self.t_graph, t_tracker, dt_tracker,\n",
        "            corner_index=1,\n",
        "        )\n",
        "        dt_line, dT_line, tan_line = line_group\n",
        "\n",
        "        del_t = OldTex(\"\\\\partial t\")\n",
        "        del_t.set_color(YELLOW)\n",
        "        del_t.line = dt_line\n",
        "        del_t.direction = OUT\n",
        "        del_T = OldTex(\"\\\\partial T\")\n",
        "        del_T.line = dT_line\n",
        "        del_T.direction = UP\n",
        "        syms = VGroup(del_T, del_t)\n",
        "        for sym in syms:\n",
        "            sym.rect = SurroundingRectangle(sym)\n",
        "            group = VGroup(sym, sym.rect)\n",
        "            group.rotate(90 * DEGREES, RIGHT)\n",
        "            group.rotate(90 * DEGREES, OUT)\n",
        "            sym.add_updater(lambda m: m.set_height(\n",
        "                0.8 * dT_line.get_length()\n",
        "            ))\n",
        "\n",
        "        del_t.add_updater(lambda m: m.set_height(\n",
        "            min(0.5, m.line.get_length())\n",
        "        ))\n",
        "        del_T.add_updater(lambda m: m.set_depth(\n",
        "            min(0.5, m.line.get_length())\n",
        "        ))\n",
        "        for sym in syms:\n",
        "            sym.add_updater(lambda m: m.next_to(\n",
        "                m.line, m.direction, SMALL_BUFF,\n",
        "            ))\n",
        "            sym.rect.move_to(sym)\n",
        "\n",
        "        self.move_camera(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-10 * DEGREES,\n",
        "            added_anims=[\n",
        "                self.camera.frame_center.move_to, 5 * LEFT,\n",
        "            ],\n",
        "        )\n",
        "        for sym in reversed(syms):\n",
        "            self.play(\n",
        "                FadeIn(sym, -sym.direction),\n",
        "                ShowCreation(\n",
        "                    sym.line.copy(),\n",
        "                    remover=True\n",
        "                ),\n",
        "            )\n",
        "            self.add(sym.line)\n",
        "        self.play(ShowCreation(tan_line))\n",
        "        for sym in syms:\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(sym.rect)\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.add(line_group)\n",
        "        self.play(\n",
        "            dt_tracker.set_value, 0.01,\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(syms),\n",
        "            FadeOut(line_group),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_line_group(self, graph, input_tracker, nudge_tracker, corner_index):\n",
        "        get_x = input_tracker.get_value\n",
        "        get_dx = nudge_tracker.get_value\n",
        "\n",
        "        def get_graph_point(x):\n",
        "            return graph.point_from_proportion(\n",
        "                inverse_interpolate(\n",
        "                    self.graph_x_min,\n",
        "                    self.graph_x_max,\n",
        "                    x,\n",
        "                )\n",
        "            )\n",
        "\n",
        "        def get_corner(p1, p2):\n",
        "            result = np.array(p1)\n",
        "            result[corner_index] = p2[corner_index]\n",
        "            return result\n",
        "\n",
        "        line_group = VGroup(\n",
        "            Line(color=WHITE),\n",
        "            Line(color=RED),\n",
        "            Line(color=WHITE, stroke_width=2),\n",
        "        )\n",
        "\n",
        "        def update_line_group(group):\n",
        "            dxl, dTl, tl = group\n",
        "            p0 = get_graph_point(get_x())\n",
        "            p2 = get_graph_point(get_x() + get_dx())\n",
        "            p1 = get_corner(p0, p2)\n",
        "\n",
        "            dxl.set_points_as_corners([p0, p1])\n",
        "            dTl.set_points_as_corners([p1, p2])\n",
        "            tl.set_points_as_corners([p0, p2])\n",
        "            tl.scale(\n",
        "                self.tangent_line_length / tl.get_length()\n",
        "            )\n",
        "        line_group.add_updater(update_line_group)\n",
        "        return line_group\n",
        "\n",
        "\n",
        "class ShowCurvatureToRateOfChangeIntuition(ShowEvolvingTempGraphWithArrows):\n",
        "    CONFIG = {\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.7),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "            (5, 0.3),\n",
        "            (7, 0.2),\n",
        "        ],\n",
        "        \"arrow_xs\": [0.7, 3.8, 4.6, 5.4, 6.2, 9.3],\n",
        "        \"arrow_scale_factor\": 0.2,\n",
        "        \"max_magnitude\": 1.0,\n",
        "        \"wait_time\": 20,\n",
        "    }\n",
        "\n",
        "    def let_play(self):\n",
        "        arrows = self.arrows\n",
        "        curves = VGroup(*[\n",
        "            self.get_mini_curve(\n",
        "                inverse_interpolate(\n",
        "                    self.graph_x_min,\n",
        "                    self.graph_x_max,\n",
        "                    x,\n",
        "                )\n",
        "            )\n",
        "            for x in self.arrow_xs\n",
        "        ])\n",
        "        curves.set_stroke(WHITE, 5)\n",
        "\n",
        "        curve_words = VGroup()\n",
        "        for curve, arrow in zip(curves, arrows):\n",
        "            word = OldTexText(\"curve\")\n",
        "            word.scale(0.7)\n",
        "            word.next_to(curve, arrow.get_vector()[1] * DOWN, SMALL_BUFF)\n",
        "            curve_words.add(word)\n",
        "\n",
        "        self.remove(arrows)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(curves),\n",
        "            LaggedStartMap(FadeIn, curve_words),\n",
        "            self.y_label.set_fill, {\"opacity\": 0},\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(*arrows, curves)\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeOut(VGroup(curves, curve_words)))\n",
        "        self.add(arrows)\n",
        "        super().let_play()\n",
        "\n",
        "    def get_mini_curve(self, alpha, d_alpha=0.02):\n",
        "        result = VMobject()\n",
        "        result.pointwise_become_partial(\n",
        "            self.graph,\n",
        "            alpha - d_alpha,\n",
        "            alpha + d_alpha,\n",
        "        )\n",
        "        return result\n",
        "\n",
        "\n",
        "class DiscreteSetup(ShowEvolvingTempGraphWithArrows):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 1,\n",
        "        \"rod_piece_size_ratio\": 1 / 3,\n",
        "        \"dashed_line_stroke_opacity\": 1.0,\n",
        "        \"dot_radius\": DEFAULT_DOT_RADIUS,\n",
        "        \"freq_amplitude_pairs\": [\n",
        "            (1, 0.5),\n",
        "            (2, 1),\n",
        "            (3, 0.5),\n",
        "            (4, 0.3),\n",
        "            (5, 0.3),\n",
        "            (7, 0.2),\n",
        "            (21, 0.1),\n",
        "            # (41, 0.05),\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.discretize()\n",
        "        self.let_time_pass()\n",
        "        self.show_nieghbor_rule()\n",
        "        self.focus_on_three_points()\n",
        "        self.show_difference_formula()\n",
        "        self.gut_check_new_interpretation()\n",
        "        self.write_second_difference()\n",
        "        self.emphasize_final_expression()\n",
        "\n",
        "    def add_axes(self):\n",
        "        super().add_axes()\n",
        "        self.axes.shift(MED_SMALL_BUFF * LEFT)\n",
        "\n",
        "    def add_graph(self):\n",
        "        points = self.get_points(time=0)\n",
        "        graph = VMobject()\n",
        "        graph.set_points_smoothly(points)\n",
        "        graph.color_using_background_image(\"VerticalTempGradient\")\n",
        "\n",
        "        self.add(graph)\n",
        "\n",
        "        self.graph = graph\n",
        "        self.points = points\n",
        "\n",
        "    def discretize(self):\n",
        "        axes = self.axes\n",
        "        x_axis = axes.x_axis\n",
        "        graph = self.graph\n",
        "\n",
        "        piecewise_graph = CurvesAsSubmobjects(graph)\n",
        "        dots = self.get_dots()\n",
        "        v_lines = VGroup(*map(self.get_v_line, dots))\n",
        "\n",
        "        rod_pieces = VGroup()\n",
        "        for x in self.get_sample_inputs():\n",
        "            piece = Line(LEFT, RIGHT)\n",
        "            piece.set_width(\n",
        "                self.step_size * self.rod_piece_size_ratio\n",
        "            )\n",
        "            piece.move_to(axes.c2p(x, 0))\n",
        "            piece.set_color(\n",
        "                self.rod_point_to_color(piece.get_center())\n",
        "            )\n",
        "            rod_pieces.add(piece)\n",
        "\n",
        "        word = OldTexText(\"Discrete version\")\n",
        "        word.scale(1.5)\n",
        "        word.next_to(x_axis, UP)\n",
        "        word.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        self.remove(graph)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                piecewise_graph, dots,\n",
        "            ),\n",
        "            Write(word, run_time=1)\n",
        "        )\n",
        "        self.add(v_lines, word)\n",
        "        self.play(\n",
        "            x_axis.fade, 0.8,\n",
        "            TransformFromCopy(\n",
        "                x_axis.tick_marks[1:],\n",
        "                rod_pieces,\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, v_lines)\n",
        "        )\n",
        "        self.play(FadeOut(word))\n",
        "        self.wait()\n",
        "\n",
        "        self.rod_pieces = rod_pieces\n",
        "        self.dots = dots\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def let_time_pass(self):\n",
        "        dots = self.dots\n",
        "\n",
        "        t_tracker = ValueTracker(0)\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.add(t_tracker)\n",
        "\n",
        "        self.add_clock()\n",
        "        self.time_label.next_to(self.clock, DOWN)\n",
        "        self.time_label.add_updater(\n",
        "            lambda m: m.set_value(t_tracker.get_value())\n",
        "        )\n",
        "        dots.add_updater(lambda d: d.become(\n",
        "            self.get_dots(t_tracker.get_value())\n",
        "        ))\n",
        "        run_time = 5\n",
        "        self.play(\n",
        "            ClockPassesTime(\n",
        "                self.clock,\n",
        "                run_time=run_time,\n",
        "                hours_passed=run_time,\n",
        "            ),\n",
        "        )\n",
        "        t_tracker.clear_updaters()\n",
        "        t_tracker.set_value(run_time)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            t_tracker.set_value, 0,\n",
        "            FadeOut(self.clock),\n",
        "            FadeOut(self.time_label),\n",
        "        )\n",
        "        self.remove(t_tracker)\n",
        "        dots.clear_updaters()\n",
        "\n",
        "    def show_nieghbor_rule(self):\n",
        "        dots = self.dots\n",
        "        rod_pieces = self.rod_pieces\n",
        "        index = self.index = 2\n",
        "\n",
        "        p1, p2, p3 = rod_pieces[index:index + 3]\n",
        "        d1, d2, d3 = dots[index:index + 3]\n",
        "        point_label = OldTexText(\"Point\")\n",
        "        neighbors_label = OldTexText(\"Neighbors\")\n",
        "        words = VGroup(point_label, neighbors_label)\n",
        "        for word in words:\n",
        "            word.scale(0.7)\n",
        "            word.add_background_rectangle()\n",
        "\n",
        "        point_label.next_to(p2, DOWN)\n",
        "        neighbors_label.next_to(p2, UP, buff=1)\n",
        "        bottom = neighbors_label.get_bottom()\n",
        "        kw = {\n",
        "            \"buff\": 0.1,\n",
        "            \"stroke_width\": 2,\n",
        "            \"tip_length\": 0.15\n",
        "        }\n",
        "        arrows = VGroup(\n",
        "            Arrow(bottom, p1.get_center(), **kw),\n",
        "            Arrow(bottom, p3.get_center(), **kw),\n",
        "        )\n",
        "        arrows.set_color(WHITE)\n",
        "\n",
        "        dot = Dot()\n",
        "        dot.set_fill(GREY, opacity=0.2)\n",
        "        dot.replace(p2)\n",
        "        dot.scale(3)\n",
        "\n",
        "        self.play(\n",
        "            dot.scale, 0,\n",
        "            dot.set_opacity, 0,\n",
        "            FadeIn(point_label, DOWN)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(neighbors_label, DOWN),\n",
        "            *map(GrowArrow, arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Let d2 change\n",
        "        self.play(\n",
        "            d1.set_y, 3,\n",
        "            d3.set_y, 3,\n",
        "        )\n",
        "\n",
        "        def get_v():\n",
        "            return 0.25 * np.sum([\n",
        "                d1.get_y(),\n",
        "                -2 * d2.get_y(),\n",
        "                + d3.get_y(),\n",
        "            ])\n",
        "        v_vect_fader = ValueTracker(0)\n",
        "        v_vect = always_redraw(\n",
        "            lambda: Vector(\n",
        "                get_v() * UP,\n",
        "                color=temperature_to_color(\n",
        "                    get_v(), -2, 2,\n",
        "                ),\n",
        "            ).shift(d2.get_center()).set_opacity(\n",
        "                v_vect_fader.get_value(),\n",
        "            )\n",
        "        )\n",
        "        d2.add_updater(\n",
        "            lambda d, dt: d.shift(\n",
        "                get_v() * dt * UP,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(v_vect)\n",
        "        self.play(v_vect_fader.set_value, 1)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            d1.set_y, 0,\n",
        "            d3.set_y, 0,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(FadeOut(VGroup(\n",
        "            point_label,\n",
        "            neighbors_label,\n",
        "            arrows\n",
        "        )))\n",
        "\n",
        "        self.v_vect = v_vect\n",
        "        self.example_pieces = VGroup(p1, p2, p3)\n",
        "        self.example_dots = VGroup(d1, d2, d3)\n",
        "\n",
        "    def focus_on_three_points(self):\n",
        "        dots = self.example_dots\n",
        "        d1, d2, d3 = dots\n",
        "        pieces = self.example_pieces\n",
        "        y_axis = self.axes.y_axis\n",
        "\n",
        "        x_labels, T_labels = [\n",
        "            VGroup(*[\n",
        "                OldTex(\"{}_{}\".format(s, i))\n",
        "                for i in [1, 2, 3]\n",
        "            ]).scale(0.8)\n",
        "            for s in (\"x\", \"T\")\n",
        "        ]\n",
        "        for xl, piece in zip(x_labels, pieces):\n",
        "            xl.next_to(piece, DOWN)\n",
        "            xl.add_background_rectangle()\n",
        "        for Tl, dot in zip(T_labels, dots):\n",
        "            Tl.dot = dot\n",
        "            Tl.add_updater(lambda m: m.next_to(\n",
        "                m.dot, RIGHT, SMALL_BUFF\n",
        "            ))\n",
        "            Tl.add_background_rectangle()\n",
        "        T1, T2, T3 = T_labels\n",
        "\n",
        "        d2.movement_updater = d2.get_updaters()[0]\n",
        "        dots.clear_updaters()\n",
        "        self.remove(self.v_vect)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(pieces),\n",
        "            FadeOut(self.dots[:self.index]),\n",
        "            FadeOut(self.v_lines[:self.index]),\n",
        "            FadeOut(self.rod_pieces[:self.index]),\n",
        "            FadeOut(self.dots[self.index + 3:]),\n",
        "            FadeOut(self.v_lines[self.index + 3:]),\n",
        "            FadeOut(self.rod_pieces[self.index + 3:]),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, x_labels,\n",
        "            lambda m: (m, LEFT),\n",
        "            lag_ratio=0.3,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.play(\n",
        "            d3.set_y, 1,\n",
        "            d2.set_y, 0.25,\n",
        "            d1.set_y, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*[\n",
        "            TransformFromCopy(xl, Tl)\n",
        "            for xl, Tl in zip(x_labels, T_labels)\n",
        "        ], lag_ratio=0.3, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show lines\n",
        "        h_lines = VGroup(*map(self.get_h_line, dots))\n",
        "        hl1, hl2, hl3 = h_lines\n",
        "\n",
        "        average_pointer = ArrowTip(\n",
        "            start_angle=0,\n",
        "            length=0.2,\n",
        "        )\n",
        "        average_pointer.set_color(YELLOW)\n",
        "        average_pointer.stretch(0.25, 1)\n",
        "        average_pointer.add_updater(\n",
        "            lambda m: m.move_to(\n",
        "                0.5 * (hl1.get_start() + hl3.get_start()),\n",
        "                RIGHT\n",
        "            )\n",
        "        )\n",
        "        average_arrows = always_redraw(lambda: VGroup(*[\n",
        "            Arrow(\n",
        "                hl.get_start(),\n",
        "                average_pointer.get_right(),\n",
        "                color=WHITE,\n",
        "                buff=0.0,\n",
        "            )\n",
        "            for hl in [hl1, hl3]\n",
        "        ]))\n",
        "        average_label = OldTex(\n",
        "            \"{T_1\", \"+\", \"T_3\", \"\\\\over\", \"2}\"\n",
        "        )\n",
        "        average_label.scale(0.5)\n",
        "        average_label.add_updater(lambda m: m.next_to(\n",
        "            average_pointer, LEFT, SMALL_BUFF\n",
        "        ))\n",
        "\n",
        "        average_rect = SurroundingRectangle(average_label)\n",
        "        average_rect.add_updater(\n",
        "            lambda m: m.move_to(average_label)\n",
        "        )\n",
        "        average_words = OldTexText(\"Neighbor\\\\\\\\average\")\n",
        "        average_words.match_width(average_rect)\n",
        "        average_words.match_color(average_rect)\n",
        "        average_words.add_updater(\n",
        "            lambda m: m.next_to(average_rect, UP, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        mini_T1 = average_label.get_part_by_tex(\"T_1\")\n",
        "        mini_T3 = average_label.get_part_by_tex(\"T_3\")\n",
        "        for mini, line in (mini_T1, hl1), (mini_T3, hl3):\n",
        "            mini.save_state()\n",
        "            mini.next_to(line, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.add(hl1, hl3, T_labels)\n",
        "        y_axis.remove(y_axis.numbers)\n",
        "        self.play(\n",
        "            GrowFromPoint(hl1, hl1.get_end()),\n",
        "            GrowFromPoint(hl3, hl3.get_end()),\n",
        "            TransformFromCopy(\n",
        "                T1, mini_T1,\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                T3, mini_T3,\n",
        "            ),\n",
        "            FadeOut(y_axis.numbers),\n",
        "            y_axis.set_stroke, {\"width\": 1},\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(average_pointer),\n",
        "            Restore(mini_T1),\n",
        "            Restore(mini_T3),\n",
        "            FadeIn(average_label[1]),\n",
        "            FadeIn(average_label[3:]),\n",
        "            *map(GrowArrow, average_arrows)\n",
        "        )\n",
        "        self.add(average_arrows, average_label)\n",
        "        self.play(\n",
        "            ShowCreation(average_rect),\n",
        "            FadeIn(average_words),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromPoint(hl2, hl2.get_end())\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show formula\n",
        "        formula = OldTex(\n",
        "            \"\\\\left(\",\n",
        "            \"{T_1\", \"+\", \"T_3\", \"\\\\over\", \"2}\",\n",
        "            \"-\", \"T_2\",\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        formula.to_corner(UR, buff=MED_LARGE_BUFF)\n",
        "        formula.shift(1.7 * LEFT)\n",
        "        brace = Brace(formula, DOWN)\n",
        "        diff_value = DecimalNumber(include_sign=True)\n",
        "        diff_value.add_updater(lambda m: m.set_value(\n",
        "            y_axis.p2n(average_pointer.get_right()) -\n",
        "            y_axis.p2n(d2.get_center())\n",
        "        ))\n",
        "        diff_value.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                average_label.deepcopy(),\n",
        "                formula[1:1 + len(average_label)]\n",
        "            ),\n",
        "            TransformFromCopy(T2, formula[-2]),\n",
        "            FadeIn(formula[-3]),\n",
        "            FadeIn(formula[-1]),\n",
        "            FadeIn(formula[0]),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(diff_value)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Changes\n",
        "        self.play(FadeIn(self.v_vect))\n",
        "        d2.add_updater(d2.movement_updater)\n",
        "        self.wait(5)\n",
        "\n",
        "        self.play(\n",
        "            d3.set_y, 3,\n",
        "            d1.set_y, 2.5,\n",
        "            d2.set_y, -2,\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            d3.set_y, 1,\n",
        "            d1.set_y, -1,\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show derivative\n",
        "        lhs = OldTex(\n",
        "            \"{dT_2\", \"\\\\over\", \"dt}\", \"=\", \"\\\\alpha\"\n",
        "        )\n",
        "        dt = lhs.get_part_by_tex(\"dt\")\n",
        "        alpha = lhs.get_part_by_tex(\"\\\\alpha\")\n",
        "        lhs.next_to(formula, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(Write(lhs))\n",
        "        self.play(ShowCreationThenFadeAround(dt))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(alpha))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            FadeOut(diff_value),\n",
        "        )\n",
        "\n",
        "        self.lhs = lhs\n",
        "        self.rhs = formula\n",
        "\n",
        "    def show_difference_formula(self):\n",
        "        lhs = self.lhs\n",
        "        rhs = self.rhs\n",
        "        d1, d2, d3 = self.example_dots\n",
        "\n",
        "        new_rhs = OldTex(\n",
        "            \"=\",\n",
        "            \"{\\\\alpha\", \"\\\\over\", \"2}\",\n",
        "            \"\\\\left(\",\n",
        "            \"(\", \"T_3\", \"-\", \"T_2\", \")\",\n",
        "            \"-\",\n",
        "            \"(\", \"T_2\", \"-\", \"T_1\", \")\",\n",
        "            \"\\\\right)\"\n",
        "        )\n",
        "        big_parens = VGroup(\n",
        "            new_rhs.get_part_by_tex(\"\\\\left(\"),\n",
        "            new_rhs.get_part_by_tex(\"\\\\right)\"),\n",
        "        )\n",
        "        for paren in big_parens:\n",
        "            paren.scale(2)\n",
        "        new_rhs.next_to(rhs, DOWN)\n",
        "        new_rhs.align_to(lhs.get_part_by_tex(\"=\"), LEFT)\n",
        "\n",
        "        def p2p_anim(mob1, mob2, tex, index=0):\n",
        "            return TransformFromCopy(\n",
        "                mob1.get_parts_by_tex(tex)[index],\n",
        "                mob2.get_parts_by_tex(tex)[index],\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            p2p_anim(lhs, new_rhs, \"=\"),\n",
        "            p2p_anim(rhs, new_rhs, \"\\\\left(\"),\n",
        "            p2p_anim(rhs, new_rhs, \"\\\\right)\"),\n",
        "            p2p_anim(lhs, new_rhs, \"\\\\alpha\"),\n",
        "            p2p_anim(rhs, new_rhs, \"\\\\over\"),\n",
        "            p2p_anim(rhs, new_rhs, \"2\"),\n",
        "        )\n",
        "        self.play(\n",
        "            p2p_anim(rhs, new_rhs, \"T_3\"),\n",
        "            p2p_anim(rhs, new_rhs, \"-\"),\n",
        "            p2p_anim(rhs, new_rhs, \"T_2\"),\n",
        "            FadeIn(new_rhs.get_parts_by_tex(\"(\")[1]),\n",
        "            FadeIn(new_rhs.get_parts_by_tex(\")\")[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            p2p_anim(rhs, new_rhs, \"T_2\", -1),\n",
        "            p2p_anim(rhs, new_rhs, \"-\", -1),\n",
        "            p2p_anim(rhs, new_rhs, \"T_1\"),\n",
        "            FadeIn(new_rhs.get_parts_by_tex(\"-\")[1]),\n",
        "            FadeIn(new_rhs.get_parts_by_tex(\"(\")[2]),\n",
        "            FadeIn(new_rhs.get_parts_by_tex(\")\")[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.rhs2 = new_rhs\n",
        "\n",
        "        # Show deltas\n",
        "        T1_index = new_rhs.index_of_part_by_tex(\"T_1\")\n",
        "        T3_index = new_rhs.index_of_part_by_tex(\"T_3\")\n",
        "        diff1 = new_rhs[T1_index - 2:T1_index + 1]\n",
        "        diff2 = new_rhs[T3_index:T3_index + 3]\n",
        "        brace1 = Brace(diff1, DOWN, buff=SMALL_BUFF)\n",
        "        brace2 = Brace(diff2, DOWN, buff=SMALL_BUFF)\n",
        "        delta_T1 = OldTex(\"\\\\Delta T_1\")\n",
        "        delta_T1.next_to(brace1, DOWN, SMALL_BUFF)\n",
        "        delta_T2 = OldTex(\"\\\\Delta T_2\")\n",
        "        delta_T2.next_to(brace2, DOWN, SMALL_BUFF)\n",
        "        minus = OldTex(\"-\")\n",
        "        minus.move_to(Line(\n",
        "            delta_T1.get_right(),\n",
        "            delta_T2.get_left(),\n",
        "        ))\n",
        "        braces = VGroup(brace1, brace2)\n",
        "        deltas = VGroup(delta_T1, delta_T2)\n",
        "\n",
        "        kw = {\n",
        "            \"direction\": LEFT,\n",
        "            \"buff\": SMALL_BUFF,\n",
        "            \"min_num_quads\": 2,\n",
        "        }\n",
        "        lil_brace1 = always_redraw(lambda: Brace(\n",
        "            Line(d1.get_left(), d2.get_left()), **kw\n",
        "        ))\n",
        "        lil_brace2 = always_redraw(lambda: Brace(\n",
        "            Line(d2.get_left(), d3.get_left()), **kw\n",
        "        ))\n",
        "        lil_braces = VGroup(lil_brace1, lil_brace2)\n",
        "        lil_delta_T1 = delta_T1.copy()\n",
        "        lil_delta_T2 = delta_T2.copy()\n",
        "        lil_deltas = VGroup(lil_delta_T1, lil_delta_T2)\n",
        "        for brace, delta in zip(lil_braces, lil_deltas):\n",
        "            delta.brace = brace\n",
        "            delta.add_updater(lambda d: d.next_to(\n",
        "                d.brace, LEFT, SMALL_BUFF,\n",
        "            ))\n",
        "\n",
        "        delta_T1.set_color(BLUE)\n",
        "        lil_delta_T1.set_color(BLUE)\n",
        "        delta_T2.set_color(RED)\n",
        "        lil_delta_T2.set_color(RED)\n",
        "\n",
        "        double_difference_brace = Brace(deltas, DOWN)\n",
        "        double_difference_words = OldTexText(\n",
        "            \"Difference of differences\"\n",
        "        )\n",
        "        double_difference_words.next_to(\n",
        "            double_difference_brace, DOWN\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace1),\n",
        "            GrowFromCenter(lil_brace1),\n",
        "            FadeIn(delta_T1),\n",
        "            FadeIn(lil_delta_T1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace2),\n",
        "            GrowFromCenter(lil_brace2),\n",
        "            FadeIn(delta_T2),\n",
        "            FadeIn(lil_delta_T2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(minus),\n",
        "            GrowFromCenter(double_difference_brace),\n",
        "            Write(double_difference_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.braces = braces\n",
        "        self.deltas = deltas\n",
        "        self.delta_minus = minus\n",
        "        self.lil_braces = lil_braces\n",
        "        self.lil_deltas = lil_deltas\n",
        "        self.double_difference_brace = double_difference_brace\n",
        "        self.double_difference_words = double_difference_words\n",
        "\n",
        "    def gut_check_new_interpretation(self):\n",
        "        lil_deltas = self.lil_deltas\n",
        "        d1, d2, d3 = self.example_dots\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(lil_deltas[0]))\n",
        "        self.play(ShowCreationThenFadeAround(lil_deltas[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            d2.shift, MED_SMALL_BUFF * UP,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            d3.set_y, 3,\n",
        "            d1.set_y, -0.5,\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            d3.set_y, 1.5,\n",
        "            d1.set_y, -2,\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "    def write_second_difference(self):\n",
        "        dd_word = self.double_difference_words\n",
        "\n",
        "        delta_delta = OldTex(\"\\\\Delta \\\\Delta T_1\")\n",
        "        delta_delta.set_color(MAROON_B)\n",
        "\n",
        "        delta_delta.move_to(dd_word, UP)\n",
        "\n",
        "        second_difference_word = OldTexText(\n",
        "            \"``Second difference''\"\n",
        "        )\n",
        "        second_difference_word.next_to(delta_delta, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(dd_word, UP),\n",
        "            FadeIn(delta_delta, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(second_difference_word),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Random play\n",
        "        d1, d2, d3 = self.example_dots\n",
        "        self.play(\n",
        "            d3.set_y, 3,\n",
        "            d1.set_y, -0.5,\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            d3.set_y, 1.5,\n",
        "            d1.set_y, -2,\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        self.delta_delta = delta_delta\n",
        "        self.second_difference_word = second_difference_word\n",
        "\n",
        "    def emphasize_final_expression(self):\n",
        "        lhs = self.lhs\n",
        "        rhs = self.rhs\n",
        "        rhs2 = self.rhs2\n",
        "        old_dd = self.delta_delta\n",
        "        dd = old_dd.copy()\n",
        "        old_ao2 = rhs2[1:4]\n",
        "        ao2 = old_ao2.copy()\n",
        "\n",
        "        new_lhs = lhs[:-1]\n",
        "        full_rhs = VGroup(\n",
        "            lhs[-1],\n",
        "            lhs[-2].copy(),\n",
        "            rhs,\n",
        "            rhs2,\n",
        "            self.braces,\n",
        "            self.deltas,\n",
        "            self.delta_minus,\n",
        "            self.double_difference_brace,\n",
        "            old_dd,\n",
        "            self.second_difference_word,\n",
        "        )\n",
        "        new_rhs = VGroup(ao2, dd)\n",
        "        new_rhs.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        new_rhs.next_to(new_lhs, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            full_rhs.to_edge, DOWN, {\"buff\": LARGE_BUFF},\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(old_ao2, ao2),\n",
        "            TransformFromCopy(old_dd, dd),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(\n",
        "                VGroup(new_lhs, new_rhs)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_sample_inputs(self):\n",
        "        return np.arange(\n",
        "            self.graph_x_min,\n",
        "            self.graph_x_max + self.step_size,\n",
        "            self.step_size,\n",
        "        )\n",
        "\n",
        "    def get_points(self, time=0):\n",
        "        return [\n",
        "            self.axes.c2p(x, self.temp_func(x, t=time))\n",
        "            for x in self.get_sample_inputs()\n",
        "        ]\n",
        "\n",
        "    def get_dots(self, time=0):\n",
        "        points = self.get_points(time)\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                point,\n",
        "                radius=self.dot_radius\n",
        "            )\n",
        "            for point in points\n",
        "        ])\n",
        "        dots.color_using_background_image(\"VerticalTempGradient\")\n",
        "        return dots\n",
        "\n",
        "    def get_dot_dashed_line(self, dot, index, color=False):\n",
        "        direction = np.zeros(3)\n",
        "        direction[index] = -1\n",
        "\n",
        "        def get_line():\n",
        "            p1 = dot.get_edge_center(direction)\n",
        "            p0 = np.array(p1)\n",
        "            p0[index] = self.axes.c2p(0, 0)[index]\n",
        "            result = DashedLine(\n",
        "                p0, p1,\n",
        "                stroke_width=2,\n",
        "                color=WHITE,\n",
        "                stroke_opacity=self.dashed_line_stroke_opacity,\n",
        "            )\n",
        "            if color:\n",
        "                result.color_using_background_image(\n",
        "                    \"VerticalTempGradient\"\n",
        "                )\n",
        "            return result\n",
        "        return always_redraw(get_line)\n",
        "\n",
        "    def get_h_line(self, dot):\n",
        "        return self.get_dot_dashed_line(dot, 0, True)\n",
        "\n",
        "    def get_v_line(self, dot):\n",
        "        return self.get_dot_dashed_line(dot, 1)\n",
        "\n",
        "\n",
        "class ShowFinitelyManyX(DiscreteSetup):\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        axes = self.axes\n",
        "        axes.fade(1)\n",
        "        points = [\n",
        "            axes.c2p(x, 0)\n",
        "            for x in self.get_sample_inputs()[1:]\n",
        "        ]\n",
        "        x_labels = VGroup(*[\n",
        "            OldTex(\"x_{}\".format(i)).next_to(\n",
        "                p, DOWN\n",
        "            )\n",
        "            for i, p in enumerate(points)\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, x_labels\n",
        "        ))\n",
        "        self.play(LaggedStartMap(FadeOut, x_labels))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DiscreteGraphStillImage1(DiscreteSetup):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.discretize()\n",
        "\n",
        "\n",
        "class DiscreteGraphStillImageFourth(DiscreteGraphStillImage1):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.25,\n",
        "    }\n",
        "\n",
        "\n",
        "class DiscreteGraphStillImageTenth(DiscreteGraphStillImage1):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.1,\n",
        "        \"dashed_line_stroke_opacity\": 0.25,\n",
        "        \"dot_radius\": 0.04,\n",
        "    }\n",
        "\n",
        "\n",
        "class DiscreteGraphStillImageHundredth(DiscreteGraphStillImage1):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.01,\n",
        "        \"dashed_line_stroke_opacity\": 0.1,\n",
        "        \"dot_radius\": 0.01,\n",
        "    }\n",
        "\n",
        "\n",
        "class TransitionToContinuousCase(DiscreteSetup):\n",
        "    CONFIG = {\n",
        "        \"step_size\": 0.1,\n",
        "        \"tangent_line_length\": 3,\n",
        "        \"wait_time\": 30,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.show_temperature_difference()\n",
        "        self.show_second_derivative()\n",
        "        self.show_curvature_examples()\n",
        "        self.show_time_changes()\n",
        "\n",
        "    def add_graph(self):\n",
        "        self.setup_graph()\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                self.graph,\n",
        "                run_time=3,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_temperature_difference(self):\n",
        "        x_tracker = ValueTracker(2)\n",
        "        dx_tracker = ValueTracker(1)\n",
        "\n",
        "        line_group = self.get_line_group(\n",
        "            x_tracker,\n",
        "            dx_tracker,\n",
        "        )\n",
        "        dx_line, dT_line, tan_line, dx_sym, dT_sym = line_group\n",
        "        tan_line.set_stroke(width=0)\n",
        "\n",
        "        brace = Brace(dx_line, UP)\n",
        "        fixed_distance = OldTexText(\"Fixed\\\\\\\\distance\")\n",
        "        fixed_distance.scale(0.7)\n",
        "        fixed_distance.next_to(brace, UP)\n",
        "        delta_T = OldTex(\"\\\\Delta T\")\n",
        "        delta_T.move_to(dT_sym, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(VGroup(dx_line, dT_line)),\n",
        "            FadeIn(delta_T, LEFT)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeInFromDown(fixed_distance),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(delta_T, UP),\n",
        "            FadeIn(dT_sym, DOWN),\n",
        "            FadeOut(brace, UP),\n",
        "            FadeOut(fixed_distance, UP),\n",
        "            FadeIn(dx_sym, DOWN),\n",
        "        )\n",
        "        self.add(line_group)\n",
        "        self.play(\n",
        "            dx_tracker.set_value, 0.01,\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            dx_tracker.set_value, 0.3,\n",
        "        )\n",
        "\n",
        "        # Show rate of change\n",
        "        to_zero = OldTex(\"\\\\rightarrow 0\")\n",
        "        to_zero.match_height(dT_sym)\n",
        "        to_zero.next_to(dT_sym, buff=SMALL_BUFF)\n",
        "\n",
        "        ratio = OldTex(\n",
        "            \"{\\\\partial T\", \"\\\\over\", \"\\\\partial x}\"\n",
        "        )\n",
        "        ratio[0].match_style(dT_sym)\n",
        "        ratio.to_edge(UP)\n",
        "\n",
        "        self.play(ShowCreationThenFadeAround(\n",
        "            dT_sym,\n",
        "            surrounding_rectangle_config={\n",
        "                \"buff\": 0.05,\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        ))\n",
        "        self.play(GrowFromPoint(to_zero, dT_sym.get_right()))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                dT_sym,\n",
        "                ratio.get_part_by_tex(\"\\\\partial T\")\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                dx_sym,\n",
        "                ratio.get_part_by_tex(\"\\\\partial x\")\n",
        "            ),\n",
        "            Write(ratio.get_part_by_tex(\"\\\\over\"))\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                tan_line.copy().set_stroke(width=2),\n",
        "                remover=True\n",
        "            ),\n",
        "            FadeOut(to_zero),\n",
        "        )\n",
        "        tan_line.set_stroke(width=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Look at neighbors\n",
        "        x0 = x_tracker.get_value()\n",
        "        dx = dx_tracker.get_value()\n",
        "        v_line, lv_line, rv_line = v_lines = VGroup(*[\n",
        "            self.get_v_line(x)\n",
        "            for x in [x0, x0 - dx, x0 + dx]\n",
        "        ])\n",
        "        v_lines[1:].set_color(BLUE)\n",
        "\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            TransformFromCopy(v_line, lv_line),\n",
        "            TransformFromCopy(v_line, rv_line),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(v_lines[1:]),\n",
        "            ApplyMethod(\n",
        "                dx_tracker.set_value, 0.01,\n",
        "                run_time=2\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        self.line_group = line_group\n",
        "        self.deriv = ratio\n",
        "        self.x_tracker = x_tracker\n",
        "        self.dx_tracker = dx_tracker\n",
        "        self.v_line = v_line\n",
        "\n",
        "    def show_second_derivative(self):\n",
        "        x_tracker = self.x_tracker\n",
        "        deriv = self.deriv\n",
        "        v_line = self.v_line\n",
        "\n",
        "        deriv_of_deriv = OldTex(\n",
        "            \"{\\\\partial\",\n",
        "            \"\\\\left(\",\n",
        "            \"{\\\\partial T\", \"\\\\over\", \"\\\\partial x}\",\n",
        "            \"\\\\right)\",\n",
        "            \"\\\\over\",\n",
        "            \"\\\\partial x}\"\n",
        "        )\n",
        "        deriv_of_deriv.set_color_by_tex(\"\\\\partial T\", RED)\n",
        "\n",
        "        deriv_of_deriv.to_edge(UP)\n",
        "        dT_index = deriv_of_deriv.index_of_part_by_tex(\"\\\\partial T\")\n",
        "        inner_deriv = deriv_of_deriv[dT_index:dT_index + 3]\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(deriv, inner_deriv),\n",
        "            Write(VGroup(*filter(\n",
        "                lambda m: m not in inner_deriv,\n",
        "                deriv_of_deriv,\n",
        "            )))\n",
        "        )\n",
        "        v_line.add_updater(lambda m: m.become(\n",
        "            self.get_v_line(x_tracker.get_value())\n",
        "        ))\n",
        "        for change in [-0.1, 0.1]:\n",
        "            self.play(\n",
        "                x_tracker.increment_value, change,\n",
        "                run_time=3\n",
        "            )\n",
        "\n",
        "        # Write second deriv\n",
        "        second_deriv = OldTex(\n",
        "            \"{\\\\partial^2 T\", \"\\\\over\", \"\\\\partial x^2}\"\n",
        "        )\n",
        "        second_deriv[0].set_color(RED)\n",
        "        eq = OldTex(\"=\")\n",
        "        eq.next_to(deriv_of_deriv, RIGHT)\n",
        "        second_deriv.next_to(eq, RIGHT)\n",
        "        second_deriv.align_to(deriv_of_deriv, DOWN)\n",
        "        eq.match_y(second_deriv.get_part_by_tex(\"\\\\over\"))\n",
        "\n",
        "        self.play(Write(eq))\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                deriv_of_deriv.get_parts_by_tex(\"\\\\partial\")[:2],\n",
        "                second_deriv.get_parts_by_tex(\"\\\\partial^2 T\"),\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(second_deriv.get_part_by_tex(\"\\\\over\")),\n",
        "            TransformFromCopy(\n",
        "                deriv_of_deriv.get_parts_by_tex(\"\\\\partial x\"),\n",
        "                second_deriv.get_parts_by_tex(\"\\\\partial x\"),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_curvature_examples(self):\n",
        "        x_tracker = self.x_tracker\n",
        "        v_line = self.v_line\n",
        "        line_group = self.line_group\n",
        "\n",
        "        x_tracker.set_value(3.6)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x_tracker.set_value, 3.8,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        x_tracker.set_value(6.2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x_tracker.set_value, 6.4,\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #\n",
        "        dx = 0.2\n",
        "        neighbor_lines = always_redraw(lambda: VGroup(*[\n",
        "            self.get_v_line(\n",
        "                x_tracker.get_value() + u * dx,\n",
        "                line_class=Line,\n",
        "            )\n",
        "            for u in [-1, 1]\n",
        "        ]))\n",
        "        neighbor_lines.set_color(BLUE)\n",
        "\n",
        "        self.play(FadeOut(line_group))\n",
        "        self.play(*[\n",
        "            TransformFromCopy(v_line, nl)\n",
        "            for nl in neighbor_lines\n",
        "        ])\n",
        "        self.add(neighbor_lines)\n",
        "        self.play(\n",
        "            x_tracker.set_value, 5,\n",
        "            run_time=5,\n",
        "            rate_func=lambda t: smooth(t, 3)\n",
        "        )\n",
        "        v_line.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(v_line),\n",
        "            FadeOut(neighbor_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_time_changes(self):\n",
        "        self.setup_clock()\n",
        "        graph = self.graph\n",
        "\n",
        "        time_label = self.time_label\n",
        "        clock = self.clock\n",
        "        time_label.next_to(clock, DOWN)\n",
        "\n",
        "        graph.add_updater(self.update_graph)\n",
        "        time_label.add_updater(\n",
        "            lambda d, dt: d.increment_value(dt)\n",
        "        )\n",
        "\n",
        "        self.add(time_label)\n",
        "        self.add_arrows()\n",
        "        self.play(\n",
        "            ClockPassesTime(\n",
        "                clock,\n",
        "                run_time=self.wait_time,\n",
        "                hours_passed=self.wait_time,\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_v_line(self, x, line_class=DashedLine, stroke_width=2):\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "        line = line_class(\n",
        "            axes.c2p(x, 0),\n",
        "            graph.point_from_proportion(\n",
        "                inverse_interpolate(\n",
        "                    self.graph_x_min,\n",
        "                    self.graph_x_max,\n",
        "                    x,\n",
        "                )\n",
        "            ),\n",
        "            stroke_width=stroke_width,\n",
        "        )\n",
        "        return line\n",
        "\n",
        "    def get_line_group(self,\n",
        "                       x_tracker,\n",
        "                       dx_tracker,\n",
        "                       dx_tex=\"\\\\partial x\",\n",
        "                       dT_tex=\"\\\\partial T\",\n",
        "                       max_sym_width=0.5,\n",
        "                       ):\n",
        "        graph = self.graph\n",
        "        get_x = x_tracker.get_value\n",
        "        get_dx = dx_tracker.get_value\n",
        "\n",
        "        dx_line = Line(color=WHITE)\n",
        "        dT_line = Line(color=RED)\n",
        "        tan_line = Line(color=WHITE)\n",
        "        lines = VGroup(dx_line, dT_line, tan_line)\n",
        "        lines.set_stroke(width=2)\n",
        "        dx_sym = OldTex(dx_tex)\n",
        "        dT_sym = OldTex(dT_tex)\n",
        "        dT_sym.match_color(dT_line)\n",
        "        syms = VGroup(dx_sym, dT_sym)\n",
        "\n",
        "        group = VGroup(*lines, *syms)\n",
        "\n",
        "        def update_group(group):\n",
        "            dxl, dTl, tanl, dxs, dTs = group\n",
        "            x = get_x()\n",
        "            dx = get_dx()\n",
        "            p0, p2 = [\n",
        "                graph.point_from_proportion(\n",
        "                    inverse_interpolate(\n",
        "                        self.graph_x_min,\n",
        "                        self.graph_x_max,\n",
        "                        x\n",
        "                    )\n",
        "                )\n",
        "                for x in [x, x + dx]\n",
        "            ]\n",
        "            p1 = np.array([p2[0], *p0[1:]])\n",
        "            dxl.put_start_and_end_on(p0, p1)\n",
        "            dTl.put_start_and_end_on(p1, p2)\n",
        "            tanl.put_start_and_end_on(p0, p2)\n",
        "            tanl.scale(\n",
        "                self.tangent_line_length /\n",
        "                tanl.get_length()\n",
        "            )\n",
        "            dxs.match_width(dxl)\n",
        "            dTs.set_height(0.7 * dTl.get_height())\n",
        "            for sym in dxs, dTs:\n",
        "                if sym.get_width() > max_sym_width:\n",
        "                    sym.set_width(max_sym_width)\n",
        "            dxs.next_to(\n",
        "                dxl, -dTl.get_vector(), SMALL_BUFF,\n",
        "            )\n",
        "            dTs.next_to(\n",
        "                dTl, dxl.get_vector(), SMALL_BUFF,\n",
        "            )\n",
        "\n",
        "        group.add_updater(update_group)\n",
        "        return group\n",
        "\n",
        "\n",
        "class ShowManyVLines(TransitionToContinuousCase):\n",
        "    CONFIG = {\n",
        "        \"wait_time\": 20,\n",
        "        \"max_denom\": 10,\n",
        "        \"x_step\": 0.025,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_axes()\n",
        "        self.add_graph()\n",
        "        self.add_v_lines()\n",
        "        self.show_time_changes()\n",
        "\n",
        "    def add_arrows(self):\n",
        "        pass\n",
        "\n",
        "    def add_v_lines(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        v_lines = always_redraw(lambda: VGroup(*[\n",
        "            self.get_v_line(\n",
        "                x,\n",
        "                line_class=Line,\n",
        "                stroke_width=0.5,\n",
        "            )\n",
        "            for x in np.arange(0, 10, self.x_step)\n",
        "        ]))\n",
        "        group = VGroup(*v_lines)\n",
        "\n",
        "        x_pointer = ArrowTip(start_angle=PI / 2)\n",
        "        x_pointer.set_color(WHITE)\n",
        "        x_pointer.next_to(axes.c2p(0, 0), DOWN, buff=0)\n",
        "        x_eq = VGroup(\n",
        "            OldTex(\"x=\"),\n",
        "            DecimalNumber(0)\n",
        "        )\n",
        "        x_eq.add_updater(\n",
        "            lambda m: m.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        )\n",
        "        x_eq.add_updater(\n",
        "            lambda m: m[1].set_value(axes.x_axis.p2n(x_pointer.get_top()))\n",
        "        )\n",
        "        x_eq.add_updater(lambda m: m.next_to(\n",
        "            x_pointer, DOWN, SMALL_BUFF,\n",
        "            submobject_to_align=x_eq[0]\n",
        "        ))\n",
        "\n",
        "        self.add(x_pointer, x_eq)\n",
        "        self.play(\n",
        "            Write(\n",
        "                group,\n",
        "                remover=True,\n",
        "                lag_ratio=self.x_step / 2,\n",
        "                run_time=6,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                x_pointer.next_to,\n",
        "                axes.c2p(10, 0),\n",
        "                DOWN, {\"buff\": 0},\n",
        "                rate_func=linear,\n",
        "                run_time=5,\n",
        "            ),\n",
        "        )\n",
        "        self.add(v_lines)\n",
        "        x_eq.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(x_eq),\n",
        "            FadeOut(x_pointer),\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowNewtonsLawGraph(Scene):\n",
        "    CONFIG = {\n",
        "        \"k\": 0.2,\n",
        "        \"initial_water_temp\": 80,\n",
        "        \"room_temp\": 20,\n",
        "        \"delta_T_color\": YELLOW,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.show_temperatures()\n",
        "        self.show_graph()\n",
        "        self.show_equation()\n",
        "        self.talk_through_examples()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        axes = Axes(\n",
        "            x_min=0,\n",
        "            x_max=10,\n",
        "            y_min=0,\n",
        "            y_max=100,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.06,\n",
        "                \"tick_frequency\": 10,\n",
        "            },\n",
        "            center_point=5 * LEFT + 2.5 * DOWN\n",
        "        )\n",
        "        x_axis = axes.x_axis\n",
        "        y_axis = axes.y_axis\n",
        "        y_axis.add_numbers(*range(20, 100, 20))\n",
        "        x_axis.add_numbers(*range(1, 11))\n",
        "\n",
        "        x_axis.label = OldTexText(\"Time\")\n",
        "        x_axis.label.next_to(x_axis, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        y_axis.label = OldTex(\"\\\\text{Temperature}\")\n",
        "        y_axis.label.next_to(y_axis, RIGHT, buff=SMALL_BUFF)\n",
        "        y_axis.label.align_to(axes, UP)\n",
        "        for axis in [x_axis, y_axis]:\n",
        "            axis.add(axis.label)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.axes = axes\n",
        "\n",
        "    def show_temperatures(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        water_dot = Dot()\n",
        "        water_dot.color_using_background_image(\"VerticalTempGradient\")\n",
        "        water_dot.move_to(axes.c2p(0, self.initial_water_temp))\n",
        "        room_line = DashedLine(\n",
        "            axes.c2p(0, self.room_temp),\n",
        "            axes.c2p(10, self.room_temp),\n",
        "        )\n",
        "        room_line.set_color(BLUE)\n",
        "        room_line.color_using_background_image(\"VerticalTempGradient\")\n",
        "\n",
        "        water_arrow = Vector(LEFT, color=WHITE)\n",
        "        water_arrow.next_to(water_dot, RIGHT, SMALL_BUFF)\n",
        "        water_words = OldTexText(\n",
        "            \"Initial water\\\\\\\\temperature\"\n",
        "        )\n",
        "        water_words.scale(0.7)\n",
        "        water_words.next_to(water_arrow, RIGHT)\n",
        "\n",
        "        room_words = OldTexText(\"Room temperature\")\n",
        "        room_words.scale(0.7)\n",
        "        room_words.next_to(room_line, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(water_dot, RIGHT),\n",
        "            GrowArrow(water_arrow),\n",
        "            Write(water_words),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(ShowCreation(room_line))\n",
        "        self.play(FadeInFromDown(room_words))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            water_dot,\n",
        "            water_arrow,\n",
        "            water_words,\n",
        "            room_line,\n",
        "            room_words,\n",
        "        )\n",
        "\n",
        "    def show_graph(self):\n",
        "        axes = self.axes\n",
        "        water_dot = self.water_dot\n",
        "\n",
        "        k = self.k\n",
        "        rt = self.room_temp\n",
        "        t0 = self.initial_water_temp\n",
        "        graph = axes.get_graph(\n",
        "            lambda t: rt + (t0 - rt) * np.exp(-k * t)\n",
        "        )\n",
        "        graph.color_using_background_image(\"VerticalTempGradient\")\n",
        "\n",
        "        def get_x():\n",
        "            return axes.x_axis.p2n(water_dot.get_center())\n",
        "\n",
        "        brace_line = always_redraw(lambda: Line(\n",
        "            axes.c2p(get_x(), rt),\n",
        "            water_dot.get_center(),\n",
        "            stroke_width=0,\n",
        "        ))\n",
        "        brace = always_redraw(\n",
        "            lambda: Brace(\n",
        "                brace_line, RIGHT, buff=SMALL_BUFF\n",
        "            )\n",
        "        )\n",
        "\n",
        "        delta_T = OldTex(\"\\\\Delta T\")\n",
        "        delta_T.set_color(self.delta_T_color)\n",
        "        delta_T.add_updater(lambda m: m.next_to(\n",
        "            brace, RIGHT, SMALL_BUFF\n",
        "        ))\n",
        "\n",
        "        self.add(brace_line)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(delta_T),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            UpdateFromFunc(\n",
        "                water_dot,\n",
        "                lambda m: m.move_to(graph.get_end())\n",
        "            ),\n",
        "            run_time=10,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = graph\n",
        "        self.brace = brace\n",
        "        self.delta_T = delta_T\n",
        "\n",
        "    def show_equation(self):\n",
        "        delta_T = self.delta_T\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"{d ({\\\\Delta T}) \\\\over dt} = -k \\\\cdot {\\\\Delta T}\",\n",
        "            tex_to_color_map={\n",
        "                \"{\\\\Delta T}\": self.delta_T_color,\n",
        "                \"-k\": WHITE,\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        equation.to_corner(UR)\n",
        "        equation.shift(LEFT)\n",
        "\n",
        "        delta_T_parts = equation.get_parts_by_tex(\"\\\\Delta T\")\n",
        "        eq_i = equation.index_of_part_by_tex(\"=\")\n",
        "        deriv = equation[:eq_i]\n",
        "        prop_to = equation.get_part_by_tex(\"-k\")\n",
        "        parts = VGroup(deriv, prop_to, delta_T_parts[1])\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Rate of change\",\n",
        "            \"is proportional to\",\n",
        "            \"itself\",\n",
        "        )\n",
        "        words.scale(0.7)\n",
        "        words.next_to(equation, DOWN)\n",
        "        colors = [BLUE, WHITE, YELLOW]\n",
        "        for part, word, color in zip(parts, words, colors):\n",
        "            part.word = word\n",
        "            word.set_color(color)\n",
        "            word.save_state()\n",
        "        words[0].next_to(parts[0], DOWN)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                VGroup(delta_T),\n",
        "                delta_T_parts,\n",
        "            ),\n",
        "            Write(VGroup(*filter(\n",
        "                lambda p: p not in delta_T_parts,\n",
        "                equation\n",
        "            )))\n",
        "        )\n",
        "\n",
        "        rects = VGroup()\n",
        "        for part in parts:\n",
        "            rect = SurroundingRectangle(\n",
        "                part,\n",
        "                color=part.word.get_color(),\n",
        "                buff=SMALL_BUFF,\n",
        "                stroke_width=2,\n",
        "            )\n",
        "            anims = [\n",
        "                ShowCreation(rect),\n",
        "                FadeIn(part.word),\n",
        "            ]\n",
        "            if part is parts[1]:\n",
        "                anims.append(Restore(words[0]))\n",
        "            self.play(*anims)\n",
        "            rects.add(rect)\n",
        "\n",
        "        self.play(FadeOut(rects, lag_ratio=0.2))\n",
        "\n",
        "        self.equation = equation\n",
        "        self.equation_words = words\n",
        "\n",
        "    def talk_through_examples(self):\n",
        "        dot = self.water_dot\n",
        "        graph = self.graph\n",
        "\n",
        "        self.play(\n",
        "            MoveAlongPath(\n",
        "                dot, graph,\n",
        "                rate_func=lambda t: smooth(1 - t),\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_slope_line(self, graph, x):\n",
        "        pass\n"
    ]
}