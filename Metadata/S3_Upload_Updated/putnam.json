{
    "topic": "is demonstrating the concept of a Putnam competition, specifically the format and scoring system for",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "class ShowExampleTest(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class IntroducePutnam(Scene):\n",
        "    CONFIG = {\n",
        "        \"dont_animate\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Putnam Competition\")\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        title.set_color(BLUE)\n",
        "        six_hours = OldTexText(\"6\", \"hours\")\n",
        "        three_hours = OldTexText(\"3\", \"hours\")\n",
        "        for mob in six_hours, three_hours:\n",
        "            mob.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "            # mob.set_color(BLUE)\n",
        "        three_hours.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "        three_hours_copy = three_hours.copy()\n",
        "        three_hours_copy.shift(FRAME_X_RADIUS*RIGHT)\n",
        "\n",
        "        question_groups = VGroup(*[\n",
        "            VGroup(*[\n",
        "                OldTexText(\"%s%d)\"%(c, i))\n",
        "                for i in range(1, 7)\n",
        "            ]).arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "            for c in (\"A\", \"B\")\n",
        "        ]).arrange(RIGHT, buff = FRAME_X_RADIUS - MED_SMALL_BUFF)\n",
        "        question_groups.to_edge(LEFT)\n",
        "        question_groups.to_edge(DOWN, MED_LARGE_BUFF)\n",
        "        flat_questions = VGroup(*it.chain(*question_groups))\n",
        "\n",
        "        rects = VGroup()\n",
        "        for questions in question_groups:\n",
        "            rect = SurroundingRectangle(questions, buff = MED_SMALL_BUFF)\n",
        "            rect.set_stroke(WHITE, 2)\n",
        "            rect.stretch_to_fit_width(FRAME_X_RADIUS - 1)\n",
        "            rect.move_to(questions.get_left() + MED_SMALL_BUFF*LEFT, LEFT)\n",
        "            rects.add(rect)\n",
        "\n",
        "        out_of_tens = VGroup()\n",
        "        for question in flat_questions:\n",
        "            out_of_ten = OldTex(\"/10\")\n",
        "            out_of_ten.set_color(GREEN)\n",
        "            out_of_ten.move_to(question)\n",
        "            dist = rects[0].get_width() - 1.2\n",
        "            out_of_ten.shift(dist*RIGHT)\n",
        "            out_of_tens.add(out_of_ten)\n",
        "\n",
        "        out_of_120 = OldTex(\"/120\")\n",
        "        out_of_120.next_to(title, RIGHT, LARGE_BUFF)\n",
        "        out_of_120.set_color(GREEN)\n",
        "\n",
        "        out_of_120.generate_target()\n",
        "        out_of_120.target.to_edge(RIGHT, LARGE_BUFF)\n",
        "        median = OldTex(\"2\")\n",
        "        median.next_to(out_of_120.target, LEFT, SMALL_BUFF)\n",
        "        median.set_color(RED)\n",
        "        median.align_to(out_of_120[-1])\n",
        "        median_words = OldTexText(\"Typical median $\\\\rightarrow$\")\n",
        "        median_words.next_to(median, LEFT)\n",
        "\n",
        "        difficulty_strings = [\n",
        "            \"Pretty hard\",\n",
        "            \"Hard\",\n",
        "            \"Harder\",\n",
        "            \"Very hard\",\n",
        "            \"Ughhh\",\n",
        "            \"Can I go home?\"\n",
        "        ]\n",
        "        colors = color_gradient([YELLOW, RED], len(difficulty_strings))\n",
        "        difficulties = VGroup()\n",
        "        for i, s, color in zip(it.count(), difficulty_strings, colors):\n",
        "            for question_group in question_groups:\n",
        "                question = question_group[i]\n",
        "                text = OldTexText(\"\\\\dots %s \\\\dots\"%s)\n",
        "                text.scale(0.7)\n",
        "                text.next_to(question, RIGHT)\n",
        "                text.set_color(color)\n",
        "                difficulties.add(text)\n",
        "\n",
        "\n",
        "        if self.dont_animate:        \n",
        "            test = VGroup()\n",
        "            test.rect = rects[0]\n",
        "            test.questions = question_groups[0]\n",
        "            test.out_of_tens = VGroup(*out_of_tens[:6])\n",
        "            test.difficulties = VGroup(*difficulties[::2])\n",
        "            test.digest_mobject_attrs()\n",
        "            self.test = test\n",
        "            return\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(Write(six_hours))\n",
        "        self.play(LaggedStartMap(\n",
        "            GrowFromCenter, flat_questions,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.play(\n",
        "            ReplacementTransform(six_hours, three_hours),\n",
        "            ReplacementTransform(six_hours.copy(), three_hours_copy),\n",
        "            *list(map(ShowCreation, rects))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, out_of_tens,\n",
        "            run_time = 3,\n",
        "            stroke_color = YELLOW\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            out_of_tens.copy(), VGroup(out_of_120),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            title.next_to, median_words.copy(), LEFT, LARGE_BUFF,\n",
        "            MoveToTarget(out_of_120),\n",
        "            Write(median_words)\n",
        "        )\n",
        "        self.play(Write(median))\n",
        "        for difficulty in difficulties:\n",
        "            self.play(FadeIn(difficulty))\n",
        "        self.wait()\n",
        "\n",
        "class NatureOf5sAnd6s(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"test_scale_val\" : 0.65\n",
        "    }\n",
        "    def construct(self):\n",
        "        test = self.get_test()\n",
        "\n",
        "        self.students.fade(1)\n",
        "        self.play(\n",
        "            test.scale, self.test_scale_val,\n",
        "            test.to_corner, UP+LEFT,\n",
        "            FadeIn(self.teacher),\n",
        "            self.change_students(\n",
        "                *[\"horrified\"]*3,\n",
        "                look_at = test\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        mover = VGroup(\n",
        "            test.questions[-1].copy(),\n",
        "            test.difficulties[-1].copy(),\n",
        "        )\n",
        "        mover.generate_target()\n",
        "        mover.target.scale(1./self.test_scale_val)\n",
        "        mover.target.next_to(\n",
        "            self.teacher.get_corner(UP+LEFT), UP,\n",
        "        )\n",
        "        new_words = OldTexText(\"\\\\dots Potentially very elegant \\\\dots\")\n",
        "        new_words.set_color(GREEN)\n",
        "        new_words.set_height(mover.target[1].get_height())\n",
        "        new_words.next_to(mover.target[0], RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(mover),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.play(Transform(mover[1], new_words))\n",
        "        self.look_at((FRAME_X_RADIUS*RIGHT + FRAME_Y_RADIUS*UP)/2)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_test(self):\n",
        "        prev_scene = IntroducePutnam(dont_animate = True)\n",
        "        return prev_scene.test\n",
        "\n",
        "class OtherVideoClips(Scene):\n",
        "    def construct(self):\n",
        "        rect = ScreenRectangle()\n",
        "        rect.set_height(6.5)\n",
        "        rect.center()\n",
        "        rect.to_edge(DOWN)\n",
        "        titles = list(map(TexText, [\n",
        "            \"Essence of calculus, chapter 1\",\n",
        "            \"Pi hiding in prime regularities\",\n",
        "            \"How do cryptocurrencies work?\"\n",
        "        ]))\n",
        "\n",
        "        self.add(rect)\n",
        "        last_title = None\n",
        "        for title in titles:\n",
        "            title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "            if last_title:\n",
        "                self.play(ReplacementTransform(last_title, title))\n",
        "            else:\n",
        "                self.play(FadeIn(title))\n",
        "            self.wait(3)\n",
        "            last_title = title\n",
        "\n",
        "class IntroduceTetrahedron(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class IntroduceTetrahedronSupplement(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"4\", \"random$^*$ points on sphere\")\n",
        "        title.set_color(YELLOW)\n",
        "        question = OldTexText(\"Probability that this tetrahedron \\\\\\\\ contains the sphere's center?\")\n",
        "        question.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "        group = VGroup(title, question)\n",
        "        group.set_width(FRAME_WIDTH-1)\n",
        "        group.to_edge(DOWN)\n",
        "\n",
        "        for n in range(1, 4):\n",
        "            num = OldTexText(str(n))\n",
        "            num.replace(title[0], dim_to_match = 1)\n",
        "            num.set_color(YELLOW)\n",
        "            self.add(num)\n",
        "            self.wait(0.7)\n",
        "            self.remove(num)\n",
        "        self.add(title[0])\n",
        "        self.play(FadeIn(title[1], lag_ratio = 0.5))\n",
        "        self.wait(2)\n",
        "        self.play(Write(question))\n",
        "        self.wait(2)\n",
        "\n",
        "class IntroduceTetrahedronFootnote(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            $^*$Chosen independently with a \\\\\\\\\n",
        "            uniform distribution on the sphere.\n",
        "        \"\"\")\n",
        "        words.to_corner(UP+LEFT)\n",
        "        self.add(words)\n",
        "        self.wait(2)\n",
        "\n",
        "class HowDoYouStart(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"How do you even start?\",\n",
        "            target_mode = \"raise_left_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"raise_left_hand\", \"erm\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\"Try a simpler case.\")\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class TwoDCase(Scene):\n",
        "    CONFIG = {\n",
        "        \"center\" : ORIGIN,\n",
        "        \"random_seed\" : 4,\n",
        "        \"radius\" : 2.5,\n",
        "        \"center_color\" : BLUE,\n",
        "        \"point_color\" : YELLOW,\n",
        "        \"positive_triangle_color\" : BLUE,\n",
        "        \"negative_triangle_color\" : RED,\n",
        "        \"triangle_fill_opacity\" : 0.25,\n",
        "        \"n_initial_random_choices\" : 9,\n",
        "        \"n_p3_random_moves\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_circle()\n",
        "        self.choose_three_random_points()\n",
        "        self.simplify_further()\n",
        "        self.fix_two_points_in_place()\n",
        "        self.note_special_region()\n",
        "        self.draw_lines_through_center()\n",
        "        self.ask_about_probability_p3_lands_in_this_arc()\n",
        "        self.various_arc_sizes_for_p1_p2_placements()\n",
        "        self.ask_about_average_arc_size()\n",
        "        self.fix_p1_in_place()\n",
        "        self.overall_probability()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"2D Case\")\n",
        "        title.to_corner(UP+LEFT)\n",
        "        self.add(title)\n",
        "        self.set_variables_as_attrs(title)\n",
        "\n",
        "    def add_circle(self):\n",
        "        circle = Circle(radius = self.radius, color = WHITE)\n",
        "        center_dot = Dot(color = self.center_color).center()\n",
        "        radius = DashedLine(ORIGIN, circle.radius*RIGHT)\n",
        "        VGroup(circle, center_dot, radius).shift(self.center)\n",
        "\n",
        "        self.add(center_dot)\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotating(radius, angle = 2*np.pi, about_point = self.center),\n",
        "            rate_func = smooth,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play(ShowCreation(\n",
        "            radius,\n",
        "            rate_func = lambda t : smooth(1-t),\n",
        "            remover = True\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(circle, center_dot)\n",
        "\n",
        "    def choose_three_random_points(self):\n",
        "        point_mobs = self.get_point_mobs()\n",
        "        point_labels = self.get_point_mob_labels()\n",
        "        triangle = self.get_triangle()\n",
        "        self.point_labels_update = self.get_labels_update(point_mobs, point_labels)\n",
        "        self.triangle_update = self.get_triangle_update(point_mobs, triangle)\n",
        "        self.update_animations = [\n",
        "            self.triangle_update,\n",
        "            self.point_labels_update,\n",
        "        ]\n",
        "        for anim in self.update_animations:\n",
        "            anim.update(0)\n",
        "\n",
        "        question = OldTexText(\n",
        "            \"Probability that \\\\\\\\ this triangle \\\\\\\\\",\n",
        "            \"contains the center\", \"?\",\n",
        "            arg_separator = \"\",\n",
        "        )\n",
        "        question.set_color_by_tex(\"center\", self.center_color)\n",
        "        question.scale(0.8)\n",
        "        question.to_corner(UP+RIGHT)\n",
        "        self.question = question\n",
        "\n",
        "        self.play(LaggedStartMap(DrawBorderThenFill, point_mobs))\n",
        "        self.play(FadeIn(triangle))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(Write, point_labels))\n",
        "        self.wait()\n",
        "        self.play(Write(question))\n",
        "        for x in range(self.n_initial_random_choices):\n",
        "            self.change_point_mobs_randomly()\n",
        "            self.wait()\n",
        "        angles = self.get_point_mob_angles()\n",
        "        target_angles = [5*np.pi/8, 7*np.pi/8, 0]\n",
        "        self.change_point_mobs([ta - a for a, ta in zip(angles, target_angles)])\n",
        "        self.wait()\n",
        "\n",
        "    def simplify_further(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.75)\n",
        "        morty.to_edge(DOWN)\n",
        "        morty.shift(3.5*LEFT)\n",
        "\n",
        "        bubble = SpeechBubble(\n",
        "            direction = RIGHT,\n",
        "            height = 3, width = 3\n",
        "        )\n",
        "        bubble.pin_to(morty)\n",
        "        bubble.to_edge(LEFT, SMALL_BUFF)\n",
        "        bubble.write(\"Simplify \\\\\\\\ more!\")\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change, \"happy\",\n",
        "            morty.fade, 1,\n",
        "            *list(map(FadeOut, [bubble, bubble.content]))\n",
        "        )\n",
        "        self.remove(morty)\n",
        "\n",
        "    def fix_two_points_in_place(self):\n",
        "        push_pins = VGroup()\n",
        "        for point_mob in self.point_mobs[:-1]:\n",
        "            push_pin = SVGMobject(file_name = \"push_pin\")\n",
        "            push_pin.set_height(0.5)\n",
        "            push_pin.move_to(point_mob.get_center(), DOWN)\n",
        "            line = Line(ORIGIN, UP)\n",
        "            line.set_stroke(WHITE, 2)\n",
        "            line.set_height(0.1)\n",
        "            line.move_to(push_pin, UP)\n",
        "            line.shift(0.3*SMALL_BUFF*(2*DOWN+LEFT))\n",
        "            push_pin.add(line)\n",
        "            push_pin.set_fill(GREY_B)\n",
        "            push_pin.save_state()\n",
        "            push_pin.shift(UP)\n",
        "            push_pin.fade(1)\n",
        "            push_pins.add(push_pin)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, push_pins,\n",
        "            lambda mob : (mob.restore,)\n",
        "        ))\n",
        "        self.add_foreground_mobjects(push_pins)\n",
        "        d_thetas = 2*np.pi*np.random.random(self.n_p3_random_moves)\n",
        "        for d_theta in d_thetas:\n",
        "            self.change_point_mobs([0, 0, d_theta])\n",
        "            self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(push_pins)\n",
        "\n",
        "    def note_special_region(self):\n",
        "        point_mobs = self.point_mobs\n",
        "        angles = self.get_point_mob_angles()\n",
        "\n",
        "        all_arcs = self.get_all_arcs()\n",
        "        arc = all_arcs[-1]\n",
        "        arc_lines = VGroup()\n",
        "        for angle in angles[:2]:\n",
        "            line = Line(LEFT, RIGHT).scale(SMALL_BUFF)\n",
        "            line.shift(self.radius*RIGHT)\n",
        "            line.rotate(angle + np.pi)\n",
        "            line.shift(self.center)\n",
        "            line.set_stroke(arc.get_color())\n",
        "            arc_lines.add(line)\n",
        "\n",
        "        self.play(ShowCreation(arc_lines))\n",
        "        self.change_point_mobs([0, 0, angles[0]+np.pi-angles[2]])\n",
        "        self.change_point_mobs(\n",
        "            [0, 0, arc.angle],\n",
        "            ShowCreation(arc, run_time = 2)\n",
        "        )\n",
        "        self.change_point_mobs([0, 0, np.pi/4 - angles[1]])\n",
        "        self.change_point_mobs([0, 0, 0.99*np.pi], run_time = 4)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(all_arcs, arc, arc_lines)\n",
        "\n",
        "    def draw_lines_through_center(self):\n",
        "        point_mobs = self.point_mobs\n",
        "        angles = self.get_point_mob_angles()\n",
        "        all_arcs = self.all_arcs\n",
        "\n",
        "        lines = self.get_center_lines()\n",
        "\n",
        "        self.add_foreground_mobjects(self.center_dot)\n",
        "        for line in lines:\n",
        "            self.play(ShowCreation(line))\n",
        "        self.play(FadeIn(all_arcs), Animation(point_mobs))\n",
        "        self.remove(self.circle)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            all_arcs.space_out_submobjects, 1.5,\n",
        "            Animation(point_mobs),\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 1.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_point_mobs(\n",
        "            [0, 0, np.mean(angles[:2])+np.pi-angles[2]]\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in range(3):\n",
        "            self.change_point_mobs([0, 0, np.pi/2])\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_probability_p3_lands_in_this_arc(self):\n",
        "        arc = self.arc\n",
        "\n",
        "        arrow = Vector(LEFT, color = BLUE)\n",
        "        arrow.next_to(arc.get_center(), RIGHT, MED_LARGE_BUFF)\n",
        "        question = OldTexText(\"Probability of landing \\\\\\\\ in this arc?\")\n",
        "        question.scale(0.8)\n",
        "        question.next_to(arrow, RIGHT)\n",
        "        question.shift_onto_screen()\n",
        "        question.shift(SMALL_BUFF*UP)\n",
        "\n",
        "        answer = OldTex(\n",
        "            \"{\\\\text{Length of arc}\", \"\\\\over\",\n",
        "            \"\\\\text{Circumference}}\"\n",
        "        )\n",
        "        answer.set_color_by_tex(\"arc\", BLUE)\n",
        "        answer.scale(0.8)\n",
        "        answer.next_to(arrow, RIGHT)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.rotate(np.pi/2)\n",
        "        equals.next_to(answer, UP, buff = 0.35)\n",
        "\n",
        "        self.play(FadeIn(question), GrowArrow(arrow))\n",
        "        self.have_p3_jump_around_randomly(15)\n",
        "        self.play(\n",
        "            question.next_to, answer, UP, LARGE_BUFF,\n",
        "            Write(equals),\n",
        "            FadeIn(answer)\n",
        "        )\n",
        "        self.have_p3_jump_around_randomly(4)\n",
        "        angles = self.get_point_mob_angles()\n",
        "        self.change_point_mobs(\n",
        "            [0, 0, 1.35*np.pi - angles[2]],\n",
        "            run_time = 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        question.add(equals)\n",
        "        self.arc_prob_question = question\n",
        "        self.arc_prob = answer\n",
        "        self.arc_size_arrow = arrow\n",
        "\n",
        "    def various_arc_sizes_for_p1_p2_placements(self):\n",
        "        arc = self.arc\n",
        "\n",
        "        self.triangle.save_state()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            self.push_pins, self.triangle, self.arc_lines\n",
        "        ])))\n",
        "        self.update_animations.remove(self.triangle_update)\n",
        "        self.update_animations += [\n",
        "            self.get_center_lines_update(self.point_mobs, self.center_lines),\n",
        "            self.get_arcs_update(self.all_arcs)\n",
        "        ]\n",
        "\n",
        "        #90 degree angle\n",
        "        self.change_point_mobs_to_angles([np.pi/2, np.pi], run_time = 1)\n",
        "        elbow = VGroup(\n",
        "            Line(DOWN, DOWN+RIGHT),\n",
        "            Line(DOWN+RIGHT, RIGHT),\n",
        "        )\n",
        "        elbow.scale(0.25)\n",
        "        elbow.shift(self.center)\n",
        "        ninety_degrees = OldTex(\"90^\\\\circ\")\n",
        "        ninety_degrees.next_to(elbow, DOWN+RIGHT, buff = 0)\n",
        "        proportion = DecimalNumber(0.25)\n",
        "        proportion.set_color(self.center_color)\n",
        "        # proportion.next_to(arc.point_from_proportion(0.5), DOWN, MED_LARGE_BUFF)\n",
        "        proportion.next_to(self.arc_size_arrow, DOWN)\n",
        "        def proportion_update_func(alpha):\n",
        "            angles = self.get_point_mob_angles()\n",
        "            diff = abs(angles[1]-angles[0])/(2*np.pi)\n",
        "            return min(diff, 1-diff)\n",
        "        proportion_update = ChangingDecimal(proportion, proportion_update_func)\n",
        "\n",
        "        self.play(ShowCreation(elbow), FadeIn(ninety_degrees))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                arc.rotate, np.pi/12,\n",
        "                rate_func = wiggle,\n",
        "            )\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, proportion, run_time = 1))\n",
        "        self.wait()\n",
        "\n",
        "        #Non right angles\n",
        "        angle_pairs = [\n",
        "            (0.26*np.pi, 1.24*np.pi), \n",
        "            (0.73*np.pi, 0.78*np.pi),\n",
        "            (0.5*np.pi, np.pi),\n",
        "        ]\n",
        "        self.update_animations.append(proportion_update)\n",
        "        for angle_pair in angle_pairs:\n",
        "            self.change_point_mobs_to_angles(\n",
        "                angle_pair,\n",
        "                VGroup(elbow, ninety_degrees).fade, 1,\n",
        "            )\n",
        "            self.remove(elbow, ninety_degrees)\n",
        "            self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(proportion, proportion_update)\n",
        "\n",
        "    def ask_about_average_arc_size(self):\n",
        "        proportion = self.proportion\n",
        "        brace = Brace(proportion, DOWN, buff = SMALL_BUFF)\n",
        "        average = brace.get_text(\"Average?\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(average)\n",
        "        )\n",
        "        for x in range(6):\n",
        "            self.change_point_mobs_to_angles(\n",
        "                2*np.pi*np.random.random(2)\n",
        "            )\n",
        "        self.change_point_mobs_to_angles(\n",
        "            [1.2*np.pi, 0.3*np.pi]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(brace, average)\n",
        "\n",
        "    def fix_p1_in_place(self):\n",
        "        push_pin = self.push_pins[0]\n",
        "        P1, P2, P3 = point_mobs = self.point_mobs\n",
        "\n",
        "        self.change_point_mobs_to_angles([0.9*np.pi])\n",
        "        push_pin.move_to(P1.get_center(), DOWN)\n",
        "        push_pin.save_state()\n",
        "        push_pin.shift(UP)\n",
        "        push_pin.fade(1)\n",
        "        self.play(push_pin.restore)\n",
        "        for angle in [0.89999*np.pi, -0.09999*np.pi, 0.4*np.pi]:\n",
        "            self.change_point_mobs_to_angles(\n",
        "                [0.9*np.pi, angle],\n",
        "                run_time = 4,\n",
        "            )\n",
        "        self.play(FadeOut(self.average[-1]))\n",
        "\n",
        "    def overall_probability(self):\n",
        "        point_mobs = self.point_mobs\n",
        "        triangle = self.triangle\n",
        "\n",
        "        one_fourth = OldTex(\"1/4\")\n",
        "        one_fourth.set_color(BLUE)\n",
        "        one_fourth.next_to(self.question, DOWN)\n",
        "\n",
        "        self.triangle_update.update(1)\n",
        "        self.play(\n",
        "            FadeIn(triangle),\n",
        "            Animation(point_mobs)\n",
        "        )\n",
        "        self.update_animations.append(self.triangle_update)\n",
        "        self.have_p3_jump_around_randomly(8, wait_time = 0.25)\n",
        "        self.play(ReplacementTransform(\n",
        "            self.proportion.copy(), VGroup(one_fourth)\n",
        "        ))\n",
        "        self.have_p3_jump_around_randomly(32, wait_time = 0.25)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_point_mobs(self):\n",
        "        points = np.array([\n",
        "            self.center + rotate_vector(self.radius*RIGHT, theta)\n",
        "            for theta in 2*np.pi*np.random.random(3)\n",
        "        ])\n",
        "        for index in 0, 1, 0:\n",
        "            if self.points_contain_center(points):\n",
        "                break\n",
        "            points[index] -= self.center\n",
        "            points[index] *= -1\n",
        "            points[index] += self.center\n",
        "        point_mobs = self.point_mobs = VGroup(*[\n",
        "            Dot().move_to(point) for point in points            \n",
        "        ])\n",
        "        point_mobs.set_color(self.point_color)\n",
        "        return point_mobs\n",
        "\n",
        "    def get_point_mob_labels(self):\n",
        "        point_labels = VGroup(*[\n",
        "            OldTex(\"P_%d\"%(i+1))\n",
        "            for i in range(len(self.point_mobs))\n",
        "        ])\n",
        "        point_labels.set_color(self.point_mobs.get_color())\n",
        "        self.point_labels = point_labels\n",
        "        return point_labels\n",
        "\n",
        "    def get_triangle(self):\n",
        "        triangle = self.triangle = RegularPolygon(n = 3)\n",
        "        triangle.set_fill(WHITE, opacity = self.triangle_fill_opacity)\n",
        "        return triangle\n",
        "\n",
        "    def get_center_lines(self):\n",
        "        angles = self.get_point_mob_angles()\n",
        "        lines = VGroup()\n",
        "        for angle in angles[:2]:\n",
        "            line = DashedLine(\n",
        "                self.radius*RIGHT, self.radius*LEFT\n",
        "            )\n",
        "            line.rotate(angle)\n",
        "            line.shift(self.center)\n",
        "            line.set_color(self.point_color)\n",
        "            lines.add(line)\n",
        "        self.center_lines = lines\n",
        "        return lines\n",
        "\n",
        "    def get_labels_update(self, point_mobs, labels):\n",
        "        def update_labels(labels):\n",
        "            for point_mob, label in zip(point_mobs, labels):\n",
        "                label.move_to(point_mob)\n",
        "                vect = point_mob.get_center() - self.center\n",
        "                vect /= get_norm(vect)\n",
        "                label.shift(MED_LARGE_BUFF*vect)\n",
        "            return labels\n",
        "        return UpdateFromFunc(labels, update_labels)\n",
        "\n",
        "    def get_triangle_update(self, point_mobs, triangle):\n",
        "        def update_triangle(triangle):\n",
        "            points = [pm.get_center() for pm in point_mobs]\n",
        "            triangle.set_points_as_corners(points)\n",
        "            if self.points_contain_center(points):\n",
        "                triangle.set_color(self.positive_triangle_color)\n",
        "            else:\n",
        "                triangle.set_color(self.negative_triangle_color)\n",
        "            return triangle\n",
        "        return UpdateFromFunc(triangle, update_triangle)\n",
        "\n",
        "    def get_center_lines_update(self, point_mobs, center_lines):\n",
        "        def update_lines(center_lines):\n",
        "            for point_mob, line in zip(point_mobs, center_lines):\n",
        "                point = point_mob.get_center() - self.center\n",
        "                line.rotate(\n",
        "                    angle_of_vector(point) - line.get_angle()\n",
        "                )\n",
        "                line.move_to(self.center)\n",
        "            return center_lines\n",
        "        return UpdateFromFunc(center_lines, update_lines)\n",
        "\n",
        "    def get_arcs_update(self, all_arcs):\n",
        "        def update_arcs(arcs):\n",
        "            new_arcs = self.get_all_arcs()\n",
        "            Transform(arcs, new_arcs).update(1)\n",
        "            return arcs\n",
        "        return UpdateFromFunc(all_arcs, update_arcs)\n",
        "\n",
        "    def get_all_arcs(self):\n",
        "        angles = self.get_point_mob_angles()\n",
        "        all_arcs = VGroup()\n",
        "        for da0, da1 in it.product(*[[0, np.pi]]*2):\n",
        "            arc_angle = (angles[1]+da1) - (angles[0]+da0)\n",
        "            arc_angle = (arc_angle+np.pi)%(2*np.pi)-np.pi\n",
        "            arc = Arc(\n",
        "                start_angle = angles[0]+da0,\n",
        "                angle = arc_angle,\n",
        "                radius = self.radius,\n",
        "                stroke_width = 5,\n",
        "            )\n",
        "            arc.shift(self.center)\n",
        "            all_arcs.add(arc)\n",
        "        all_arcs.set_color_by_gradient(RED, MAROON_B, PINK, BLUE)\n",
        "        self.all_arcs = all_arcs\n",
        "        return all_arcs\n",
        "\n",
        "    def points_contain_center(self, points):\n",
        "        p0, p1, p2 = points\n",
        "        v1 = p1 - p0\n",
        "        v2 = p2 - p0\n",
        "        c = self.center - p0\n",
        "        M = np.matrix([v1[:2], v2[:2]]).T\n",
        "        M_inv = np.linalg.inv(M)\n",
        "        coords = np.dot(M_inv, c[:2])\n",
        "        return np.all(coords > 0) and (np.sum(coords.flatten()) <= 1)\n",
        "\n",
        "    def get_point_mob_theta_change_anim(self, point_mob, d_theta):\n",
        "        curr_theta = angle_of_vector(point_mob.get_center() - self.center)\n",
        "        d_theta = (d_theta + np.pi)%(2*np.pi) - np.pi\n",
        "        new_theta = curr_theta + d_theta\n",
        "\n",
        "        def update_point(point_mob, alpha):\n",
        "            theta = interpolate(curr_theta, new_theta, alpha)\n",
        "            point_mob.move_to(self.center + self.radius*(\n",
        "                np.cos(theta)*RIGHT + np.sin(theta)*UP\n",
        "            ))\n",
        "            return point_mob\n",
        "        return UpdateFromAlphaFunc(point_mob, update_point, run_time = 2)\n",
        "\n",
        "    def change_point_mobs(self, d_thetas, *added_anims, **kwargs):\n",
        "        anims = it.chain(\n",
        "            self.update_animations,\n",
        "            [\n",
        "                self.get_point_mob_theta_change_anim(pm, dt)\n",
        "                for pm, dt in zip(self.point_mobs, d_thetas)\n",
        "            ],\n",
        "            added_anims\n",
        "        )\n",
        "        self.play(*anims, **kwargs)\n",
        "        for update in self.update_animations:\n",
        "            update.update(1)\n",
        " \n",
        "    def change_point_mobs_randomly(self, *added_anims, **kwargs):\n",
        "        d_thetas = 2*np.pi*np.random.random(len(self.point_mobs))\n",
        "        self.change_point_mobs(d_thetas, *added_anims, **kwargs)\n",
        "\n",
        "    def change_point_mobs_to_angles(self, target_angles, *added_anims, **kwargs):\n",
        "        angles = self.get_point_mob_angles()\n",
        "        n_added_targets = len(angles) - len(target_angles)\n",
        "        target_angles = list(target_angles) + list(angles[-n_added_targets:])\n",
        "        self.change_point_mobs(\n",
        "            [ta-a for a, ta in zip(angles, target_angles)],\n",
        "            *added_anims, **kwargs\n",
        "        )\n",
        "\n",
        "    def get_point_mob_angles(self):\n",
        "        point_mobs = self.point_mobs\n",
        "        points = [pm.get_center() - self.center for pm in point_mobs]\n",
        "        return np.array(list(map(angle_of_vector, points)))\n",
        "\n",
        "    def have_p3_jump_around_randomly(self, n_jumps, wait_time = 0.75, run_time = 0):\n",
        "        for x in range(n_jumps):\n",
        "            self.change_point_mobs(\n",
        "                [0, 0, 2*np.pi*random.random()],\n",
        "                run_time = run_time\n",
        "            )\n",
        "            self.wait(wait_time)\n",
        "\n",
        "class FixThreePointsOnSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AddCenterLinesAndPlanesToSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AverageSizeOfSphericalTriangleSection(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AverageSizeOfSphericalTriangleSectionSupplement(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Average size of \\\\\\\\\", \"this section\", \"?\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"section\", GREEN)\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(DOWN)\n",
        "        self.play(Write(words))\n",
        "        self.wait(3)\n",
        "\n",
        "class TryASurfaceIntegral(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Can you do \\\\\\\\ a surface integral?\")\n",
        "        self.play_student_changes(\"confused\", \"raise_left_hand\", \"confused\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"I mean...you can \\\\emph{try}\",\n",
        "            target_mode = \"sassy\",\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class RevisitTwoDCase(TwoDCase):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 4,\n",
        "        \"center\" : 3*LEFT + 0.5*DOWN,\n",
        "        \"radius\" : 2,\n",
        "        \"n_random_trials\" : 200,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.setup_circle()\n",
        "        self.show_probability()\n",
        "        self.add_lines_and_comment_on_them()\n",
        "        self.rewrite_random_procedure()\n",
        "        self.four_possibilities_for_coin_flips()\n",
        "\n",
        "    def setup_circle(self):\n",
        "        point_mobs = self.get_point_mobs()\n",
        "        point_labels = self.get_point_mob_labels()\n",
        "        triangle = self.get_triangle()\n",
        "        circle = Circle(radius = self.radius, color = WHITE)\n",
        "        center_dot = Dot(color = self.center_color)\n",
        "        VGroup(circle, center_dot).shift(self.center)\n",
        "\n",
        "        self.point_labels_update = self.get_labels_update(point_mobs, point_labels)\n",
        "        self.triangle_update = self.get_triangle_update(point_mobs, triangle)\n",
        "        self.update_animations = [\n",
        "            self.triangle_update,\n",
        "            self.point_labels_update,\n",
        "        ]\n",
        "        for anim in self.update_animations:\n",
        "            anim.update(1)\n",
        "\n",
        "        self.add(\n",
        "            center_dot, circle, triangle, \n",
        "            point_mobs, point_labels\n",
        "        )\n",
        "        self.add_foreground_mobjects(center_dot)\n",
        "        self.set_variables_as_attrs(circle, center_dot)\n",
        "\n",
        "    def show_probability(self):\n",
        "        title = OldTex(\n",
        "            \"P(\\\\text{triangle contains the center})\",\n",
        "            \"=\", \"1/4\"\n",
        "        )\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        title.set_color_by_tex(\"1/4\", BLUE)\n",
        "        four = title[-1][-1]\n",
        "        four_circle = Circle(color = YELLOW)\n",
        "        four_circle.replace(four, dim_to_match = 1)\n",
        "        four_circle.scale(1.2)\n",
        "\n",
        "        self.n_in = 0\n",
        "        self.n_out = 0\n",
        "        frac = OldTex(\n",
        "            \"{0\", \"\\\\over\", \"\\\\quad 0\", \"+\", \"0 \\\\quad}\", \"=\"\n",
        "        )\n",
        "        placeholders = frac.get_parts_by_tex(\"0\")\n",
        "        positions = [ORIGIN, RIGHT, LEFT]\n",
        "        frac.next_to(self.circle, RIGHT, 1.5*LARGE_BUFF)\n",
        "\n",
        "        def place_random_triangles(n, wait_time):\n",
        "            for x in range(n):\n",
        "                self.change_point_mobs_randomly(run_time = 0)\n",
        "                contain_center = self.points_contain_center(\n",
        "                    [pm.get_center() for pm in self.point_mobs]\n",
        "                )\n",
        "                if contain_center:\n",
        "                    self.n_in += 1\n",
        "                else:\n",
        "                    self.n_out += 1\n",
        "                nums = list(map(Integer, [self.n_in, self.n_in, self.n_out]))\n",
        "                VGroup(*nums[:2]).set_color(self.positive_triangle_color)\n",
        "                VGroup(*nums[2:]).set_color(self.negative_triangle_color)\n",
        "                for num, placeholder, position in zip(nums, placeholders, positions):\n",
        "                    num.move_to(placeholder, position)\n",
        "                decimal = DecimalNumber(float(self.n_in)/(self.n_in + self.n_out))\n",
        "                decimal.next_to(frac, RIGHT, SMALL_BUFF)\n",
        "\n",
        "                self.add(decimal, *nums)\n",
        "                self.wait(wait_time)\n",
        "                self.remove(decimal, *nums)\n",
        "            return VGroup(decimal, *nums)\n",
        "\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.add(frac)\n",
        "        self.remove(*placeholders)\n",
        "        place_random_triangles(10, 0.25)\n",
        "        nums = place_random_triangles(self.n_random_trials, 0.05)\n",
        "        self.add(nums)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [frac, nums, title])))\n",
        "\n",
        "    def add_lines_and_comment_on_them(self):\n",
        "        center_lines = self.get_center_lines()\n",
        "        center_lines.save_state()\n",
        "        center_line_shadows = center_lines.copy()\n",
        "        center_line_shadows.set_stroke(GREY_B, 2)\n",
        "        arcs = self.get_all_arcs()\n",
        "\n",
        "        center_lines.generate_target()\n",
        "        center_lines.target.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        rect = SurroundingRectangle(center_lines.target, buff = MED_SMALL_BUFF)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "\n",
        "        words1 = OldTexText(\"Helpful new objects\")\n",
        "        words2 = OldTexText(\"Reframe problem around these\")\n",
        "        for words in words1, words2:\n",
        "            words.scale(0.8)\n",
        "            words.next_to(rect, UP)\n",
        "            words.shift_onto_screen()\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, center_lines, run_time = 1))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, arcs, run_time = 1),\n",
        "            Animation(self.point_mobs),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(center_line_shadows)\n",
        "        self.play(MoveToTarget(center_lines))\n",
        "        self.play(ShowCreation(rect), Write(words1))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(words1, words2))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            center_lines.restore,\n",
        "            center_lines.fade, 1,\n",
        "            *list(map(FadeOut, [\n",
        "                rect, words2, center_line_shadows,\n",
        "                self.triangle, arcs,\n",
        "                self.point_mobs,\n",
        "                self.point_labels,\n",
        "            ]))\n",
        "        )\n",
        "        center_lines.restore()\n",
        "        self.remove(center_lines)\n",
        "\n",
        "    def rewrite_random_procedure(self):\n",
        "        point_mobs = self.point_mobs\n",
        "        center_lines = self.center_lines \n",
        "\n",
        "        random_procedure = OldTexText(\"Random procedure\")\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.stretch_to_fit_width(random_procedure.get_width())\n",
        "        underline.scale(1.1)\n",
        "        underline.next_to(random_procedure, DOWN)\n",
        "        group = VGroup(random_procedure, underline)\n",
        "        group.to_corner(UP+RIGHT)\n",
        "\n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"Choose 3 random points\",\n",
        "            \"Choose 2 random lines\",\n",
        "            \"Flip coin for each line \\\\\\\\ to get $P_1$ and $P_2$\",\n",
        "            \"Choose $P_3$ at random\"\n",
        "        ])))\n",
        "        words.scale(0.8)\n",
        "        words.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        words.next_to(underline, DOWN)\n",
        "        words[1].set_color(YELLOW)\n",
        "\n",
        "        point_label_groups = VGroup()\n",
        "        for point_mob, label in zip(self.point_mobs, self.point_labels):\n",
        "            group = VGroup(point_mob, label)\n",
        "            group.save_state()\n",
        "            group.move_to(words[0], LEFT)\n",
        "            group.fade(1)\n",
        "            point_label_groups.add(group)\n",
        "        self.point_label_groups = point_label_groups\n",
        "\n",
        "        cross = Cross(words[0])\n",
        "        cross.set_stroke(RED, 6)\n",
        "\n",
        "        self.center_lines_update = self.get_center_lines_update(\n",
        "            point_mobs, center_lines\n",
        "        )\n",
        "        self.update_animations.append(self.center_lines_update)\n",
        "        self.update_animations.remove(self.triangle_update)\n",
        "\n",
        "        #Choose random points\n",
        "        self.play(\n",
        "            Write(random_procedure),\n",
        "            ShowCreation(underline)\n",
        "        )\n",
        "        self.play(FadeIn(words[0]))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, point_label_groups,\n",
        "            lambda mob : (mob.restore,),\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(cross), \n",
        "            point_label_groups.fade, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Choose two random lines\n",
        "        self.center_lines_update.update(1)\n",
        "        self.play(\n",
        "            FadeIn(words[1]),\n",
        "            LaggedStartMap(GrowFromCenter, center_lines)\n",
        "        )\n",
        "        for x in range(3):\n",
        "            self.change_point_mobs_randomly(run_time = 1)\n",
        "        self.change_point_mobs_to_angles([0.8*np.pi, 1.3*np.pi])\n",
        "\n",
        "        #Flip a coin for each line\n",
        "        def flip_point_label_back_and_forth(point_mob, label):\n",
        "            for x in range(6):\n",
        "                point_mob.rotate(np.pi, about_point = self.center)\n",
        "                self.point_labels_update.update(1)\n",
        "                self.wait(0.5)\n",
        "            self.wait(0.5)\n",
        "\n",
        "        def choose_p1_and_p2():\n",
        "            for group in point_label_groups[:2]:\n",
        "                group.set_fill(self.point_color, 1)\n",
        "                flip_point_label_back_and_forth(*group)\n",
        "\n",
        "        choose_p1_and_p2()\n",
        "        self.play(Write(words[2]))\n",
        "\n",
        "        #Seems convoluted\n",
        "        randy = Randolph().flip()\n",
        "        randy.scale(0.5)\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(2*RIGHT)\n",
        "\n",
        "        self.play(point_label_groups.fade, 1)\n",
        "        self.change_point_mobs_randomly(run_time = 1)\n",
        "        choose_p1_and_p2()\n",
        "        point_label_groups.fade(1)\n",
        "        self.change_point_mobs_randomly(FadeIn(randy))\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, \"Seems \\\\\\\\ convoluted\",\n",
        "                bubble_config = {\"height\" : 2, \"width\" : 2},\n",
        "                target_mode = \"confused\"\n",
        "            )\n",
        "        )\n",
        "        choose_p1_and_p2()\n",
        "        self.play(\n",
        "            FadeOut(randy.bubble),\n",
        "            FadeOut(randy.bubble.content),\n",
        "            randy.change, \"pondering\",\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "        #Choosing the third point\n",
        "        self.change_point_mobs([0, 0, -np.pi/2], run_time = 0)\n",
        "        p3_group = point_label_groups[2]\n",
        "        p3_group.save_state()\n",
        "        p3_group.move_to(words[3], LEFT)\n",
        "\n",
        "        self.play(Write(words[3], run_time = 1))\n",
        "        self.play(\n",
        "            p3_group.restore,\n",
        "            p3_group.set_fill, YELLOW, 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Swap(*words[2:4]))\n",
        "        self.wait()\n",
        "\n",
        "        #Once the continuous randomness is handled\n",
        "        rect = SurroundingRectangle(VGroup(words[1], words[3]))\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        brace = Brace(words[2], DOWN)\n",
        "        brace_text = brace.get_text(\"4 equally likely outcomes\")\n",
        "        brace_text.scale(0.8)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(brace_text))\n",
        "        self.wait()\n",
        "\n",
        "        self.random_procedure_words = words\n",
        "\n",
        "    def four_possibilities_for_coin_flips(self):\n",
        "        arcs = self.all_arcs\n",
        "        point_mobs = self.point_mobs\n",
        "        arc = arcs[-1]\n",
        "        point_label_groups = self.point_label_groups\n",
        "        arc_update = self.get_arcs_update(arcs)\n",
        "        arc_update.update(1)\n",
        "        self.update_animations.append(arc_update)\n",
        "\n",
        "        def second_arc_update_func(arcs):\n",
        "            VGroup(*arcs[:-1]).set_stroke(width = 0)\n",
        "            arcs[-1].set_stroke(PINK, 6)\n",
        "            return arcs\n",
        "        second_arc_update = UpdateFromFunc(arcs, second_arc_update_func)\n",
        "        second_arc_update.update(1)\n",
        "        self.update_animations.append(second_arc_update)\n",
        "        self.update_animations.append(Animation(point_label_groups))\n",
        "\n",
        "        def do_the_rounds():\n",
        "            for index in 0, 1, 0, 1:\n",
        "                point_mob = point_mobs[index]\n",
        "                point_mob.generate_target()\n",
        "                point_mob.target.rotate(\n",
        "                    np.pi, about_point = self.center,\n",
        "                )\n",
        "                self.play(\n",
        "                    MoveToTarget(point_mob),\n",
        "                    *self.update_animations,\n",
        "                    run_time = np.sqrt(2)/4 #Hacky reasons to be irrational\n",
        "                )\n",
        "                self.wait()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        do_the_rounds()\n",
        "        self.triangle_update.update(1)\n",
        "        self.remove(arcs)\n",
        "        self.update_animations.remove(arc_update)\n",
        "        self.update_animations.remove(second_arc_update)\n",
        "        self.play(FadeIn(self.triangle))\n",
        "        self.wait()\n",
        "        self.update_animations.insert(0, self.triangle_update)\n",
        "        do_the_rounds()\n",
        "        self.wait()\n",
        "        self.change_point_mobs_randomly()\n",
        "        for x in range(2):\n",
        "            do_the_rounds()\n",
        "\n",
        "class ThisIsWhereItGetsGood(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"This is where \\\\\\\\ things get good\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class ContrastTwoRandomProcesses(TwoDCase):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 1.5,\n",
        "        \"random_seed\" : 0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        circle = Circle(color = WHITE, radius = self.radius)\n",
        "        point_mobs = self.get_point_mobs()\n",
        "        for point in point_mobs:\n",
        "            point.scale(1.5)\n",
        "            point.set_stroke(RED, 1)\n",
        "        labels = self.get_point_mob_labels()\n",
        "        self.get_labels_update(point_mobs, labels).update(1)\n",
        "        center_lines = self.get_center_lines()\n",
        "        point_label_groups = VGroup(*[\n",
        "            VGroup(*pair) for pair in zip(point_mobs, labels)\n",
        "        ])\n",
        "\n",
        "        right_circles = VGroup(*[\n",
        "            VGroup(circle, *point_label_groups[:i+1]).copy()\n",
        "            for i in range(3)\n",
        "        ])\n",
        "        left_circles = VGroup(\n",
        "            VGroup(circle, center_lines).copy(),\n",
        "            VGroup(\n",
        "                circle, center_lines, \n",
        "                point_label_groups[2]\n",
        "            ).copy(),\n",
        "            VGroup(\n",
        "                circle, center_lines, \n",
        "                *point_label_groups[2::-1]\n",
        "            ).copy(),\n",
        "        )\n",
        "        for circles in left_circles, right_circles:\n",
        "            circles.scale(0.5)\n",
        "            circles[0].to_edge(UP, buff = MED_LARGE_BUFF)\n",
        "            circles[2].to_edge(DOWN, buff = MED_LARGE_BUFF)\n",
        "            for c1, c2 in zip(circles, circles[1:]):\n",
        "                circles.add(Arrow(c1[0], c2[0], color = GREEN))\n",
        "        left_circles.shift(3*LEFT)\n",
        "        right_circles.shift(3*RIGHT)\n",
        "\n",
        "        vs = OldTexText(\"vs.\")\n",
        "        self.show_creation_of_circle_group(left_circles)\n",
        "        self.play(Write(vs))\n",
        "        self.show_creation_of_circle_group(right_circles)\n",
        "        self.wait()\n",
        "\n",
        "    def show_creation_of_circle_group(self, group):\n",
        "        circles = group[:3]\n",
        "        arrows = group[3:]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(circles[0][0]),\n",
        "            FadeIn(VGroup(*circles[0][1:])),\n",
        "        )\n",
        "        for c1, c2, arrow in zip(circles, circles[1:], arrows):\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                ApplyMethod(\n",
        "                    c1.copy().shift, \n",
        "                    c2[0].get_center() - c1[0].get_center(),\n",
        "                    remover = True\n",
        "                )\n",
        "            )\n",
        "            self.add(c2)\n",
        "            n = len(c2) - len(c1)\n",
        "            self.play(*list(map(GrowFromCenter, c2[-n:])))\n",
        "\n",
        "class Rewrite3DRandomProcedure(Scene):\n",
        "    def construct(self):\n",
        "        random_procedure = OldTexText(\"Random procedure\")\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.stretch_to_fit_width(random_procedure.get_width())\n",
        "        underline.scale(1.1)\n",
        "        underline.next_to(random_procedure, DOWN)\n",
        "        group = VGroup(random_procedure, underline)\n",
        "        group.to_corner(UP+LEFT)\n",
        "        \n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"Choose 4 random points\",\n",
        "            \"Choose 3 random lines\",\n",
        "            \"Choose $P_4$ at random\",\n",
        "            \"Flip coin for each line \\\\\\\\ to get $P_1$, $P_2$, $P_3$\",\n",
        "        ])))\n",
        "        words.scale(0.8)\n",
        "        words.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        words.next_to(underline, DOWN)\n",
        "        words[1].set_color(YELLOW)\n",
        "        cross = Cross(words[0])\n",
        "        cross.set_stroke(RED, 6)\n",
        "\n",
        "        self.play(\n",
        "            Write(random_procedure),\n",
        "            ShowCreation(underline)\n",
        "        )\n",
        "        self.play(FadeIn(words[0]))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, words[1]))\n",
        "        self.play(LaggedStartMap(FadeIn, words[2]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(words[3]))\n",
        "        self.wait(3)\n",
        "\n",
        "class AntipodalViewOfThreeDCase(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ThreeDAnswer(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Probability that the tetrahedron contains center:\", \n",
        "            \"$\\\\frac{1}{8}$\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(DOWN)\n",
        "        words[1].set_color(BLUE)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class FormalWriteupScreenCapture(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class Formality(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Write-up by Ralph Howard and Paul Sisson (link below)\"\n",
        "        )\n",
        "        words.scale(0.7)\n",
        "        words.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.student_says(\n",
        "            \"How would you \\\\\\\\ write that down?\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"erm\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(words),\n",
        "            FadeOut(self.students[1].bubble),\n",
        "            FadeOut(self.students[1].bubble.content),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = words\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "class ProblemSolvingTakeaways(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Problem solving takeaways\")\n",
        "        underline = Line(LEFT, RIGHT)\n",
        "        underline.set_width(title.get_width()*1.1)\n",
        "        underline.next_to(title, DOWN)\n",
        "        group = VGroup(title, underline)\n",
        "        group.to_corner(UP+LEFT)\n",
        "\n",
        "        points = VGroup(*[\n",
        "            OldTexText(string, alignment = \"\")\n",
        "            for string in [\n",
        "                \"Ask a simpler version \\\\\\\\ of the question\",\n",
        "                \"Try reframing the question \\\\\\\\ around new constructs\",\n",
        "            ]\n",
        "        ])\n",
        "        points[0].set_color(BLUE)\n",
        "        points[1].set_color(YELLOW)\n",
        "        points.arrange(\n",
        "            DOWN, buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        points.next_to(group, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(title), ShowCreation(underline))\n",
        "        self.wait()\n",
        "        for point in points:\n",
        "            self.play(Write(point))\n",
        "            self.wait(3)\n",
        "\n",
        "class BrilliantPuzzle(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        students = self.students\n",
        "        tests = VGroup()\n",
        "        for student in students:\n",
        "            test = self.get_test()\n",
        "            test.move_to(0.75*student.get_center())\n",
        "            tests.add(test)\n",
        "            student.test = test\n",
        "        for i, student in enumerate(students):\n",
        "            student.right = students[(i+1)%len(students)]\n",
        "            student.left = students[(i-1)%len(students)]\n",
        "        arrows = VGroup()\n",
        "        for s1, s2 in adjacent_pairs(self.students):\n",
        "            arrow = Arrow(\n",
        "                s1.get_center(), s2.get_center(), \n",
        "                path_arc = np.pi/2,\n",
        "                buff = 0.8\n",
        "            )\n",
        "            arrow.tip.shift(SMALL_BUFF*arrow.get_vector())\n",
        "            arrow.tip.shift(-0.1*SMALL_BUFF*arrow.tip.get_center())\n",
        "            # arrow.shift(-MED_SMALL_BUFF*arrow.get_vector())\n",
        "            arrow.set_color(RED)\n",
        "            arrow.pointing_right = True\n",
        "            arrows.add(arrow)\n",
        "            s1.arrow = arrow\n",
        "            arrow.student = s1\n",
        "\n",
        "        title = OldTexText(\"Puzzle from Brilliant\")\n",
        "        title.scale(0.75)\n",
        "        title.to_corner(UP+LEFT)\n",
        "\n",
        "        question = OldTexText(\"Expected number of \\\\\\\\ circled students?\")\n",
        "        question.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.remove(students)\n",
        "        self.play(Write(title))\n",
        "        self.play(LaggedStartMap(GrowFromCenter, students))\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, tests),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, students,\n",
        "                lambda m : (m.change, \"horrified\", m.test)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, students,\n",
        "            lambda m : (m.change, \"conniving\")\n",
        "        ))\n",
        "        self.play(LaggedStartMap(ShowCreation, arrows))\n",
        "        for x in range(2):\n",
        "            self.swap_arrows_randomly(arrows)\n",
        "        self.wait()\n",
        "        circles = self.circle_students()\n",
        "        self.play(Write(question))\n",
        "        for x in range(10):\n",
        "            self.swap_arrows_randomly(arrows, FadeOut(circles))\n",
        "            circles = self.circle_students()\n",
        "            self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_test(self):\n",
        "        lines = VGroup(*[Line(ORIGIN, 0.5*RIGHT) for x in range(6)])\n",
        "        lines.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        rect = SurroundingRectangle(lines)\n",
        "        rect.set_stroke(WHITE)\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "        test = VGroup(rect, lines)\n",
        "        test.set_height(0.5)\n",
        "        return test\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        self.students = VGroup(*[\n",
        "            PiCreature(\n",
        "                color = random.choice([BLUE_C, BLUE_D, BLUE_E, GREY_BROWN])\n",
        "            ).scale(0.25).move_to(3*vect)\n",
        "            for vect in compass_directions(8)\n",
        "        ])\n",
        "        return self.students\n",
        "\n",
        "    def get_arrow_swap_anim(self, arrow):\n",
        "        arrow.generate_target()\n",
        "        if arrow.pointing_right:\n",
        "            target_color = GREEN\n",
        "            target_angle = np.pi - np.pi/4\n",
        "        else:\n",
        "            target_color = RED\n",
        "            target_angle = np.pi + np.pi/4\n",
        "        arrow.target.set_color(target_color)\n",
        "        arrow.target.rotate(\n",
        "            target_angle, \n",
        "            about_point = arrow.student.get_center()\n",
        "        )\n",
        "        arrow.pointing_right = not arrow.pointing_right\n",
        "        return MoveToTarget(arrow, path_arc = np.pi)\n",
        "\n",
        "    def swap_arrows_randomly(self, arrows, *added_anims):\n",
        "        anims = []\n",
        "        for arrow in arrows:\n",
        "            if random.choice([True, False]):\n",
        "                anims.append(self.get_arrow_swap_anim(arrow))\n",
        "        self.play(*anims + list(added_anims))\n",
        "\n",
        "    def circle_students(self):\n",
        "        circles = VGroup()\n",
        "        circled_students = list(self.students)\n",
        "        for student in self.students:\n",
        "            if student.arrow.pointing_right:\n",
        "                to_remove = student.right\n",
        "            else:\n",
        "                to_remove = student.left\n",
        "            if to_remove in circled_students:\n",
        "                circled_students.remove(to_remove)\n",
        "        for student in circled_students:\n",
        "            circle = Circle(color = YELLOW)\n",
        "            circle.set_height(1.2*student.get_height())\n",
        "            circle.move_to(student)\n",
        "            circles.add(circle)\n",
        "            self.play(ShowCreation(circle))\n",
        "        return circles\n",
        "\n",
        "class ScrollThroughBrilliantCourses(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class BrilliantProbability(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class Promotion(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"seconds_to_blink\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        url = OldTexText(\"https://brilliant.org/3b1b/\")\n",
        "        url.to_corner(UP+LEFT)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5.5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(url),\n",
        "            self.pi_creature.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"thinking\")\n",
        "        self.wait()\n",
        "        self.look_at(url)\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(10)\n",
        "        self.change_mode(\"raise_right_hand\")\n",
        "        self.wait(10)\n",
        "\n",
        "        self.remove(rect)\n",
        "        self.play(\n",
        "            url.next_to, self.pi_creature, UP+LEFT\n",
        "        )\n",
        "        url_rect = SurroundingRectangle(url)\n",
        "        self.play(ShowCreation(url_rect))\n",
        "        self.play(FadeOut(url_rect))\n",
        "        self.wait(3)\n",
        "\n",
        "class AddedPromoWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"First\", \"$2^8$\", \"vistors get\",\n",
        "            \"$(e^\\\\pi - \\\\pi)\\\\%$\", \"off\"\n",
        "        )\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(DOWN)\n",
        "        words.set_color_by_tex(\"2^8\", YELLOW)\n",
        "        words.set_color_by_tex(\"pi\", PINK)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class PatreonThanks(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Randall Hunt\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"David Kedmey\",\n",
        "            \"Marcus Schiebold\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"James Park\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Delton\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Jake Alzapiedi\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Taro Yoshioka\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Dagan Harrington\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Eric Chow\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Awoo\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}