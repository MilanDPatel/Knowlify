{
    "topic": "demonstrates the concept of linearity in heat equation.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.diffyq.part3.temperature_graphs import TemperatureGraphScene\n",
        "from _2019.diffyq.part2.wordy_scenes import WriteHeatEquationTemplate\n",
        "\n",
        "\n",
        "class ShowLinearity(WriteHeatEquationTemplate, TemperatureGraphScene):\n",
        "    CONFIG = {\n",
        "        \"temp_text\": \"Temp\",\n",
        "        \"alpha\": 0.1,\n",
        "        \"axes_config\": {\n",
        "            \"z_max\": 2,\n",
        "            \"z_min\": -2,\n",
        "            \"z_axis_config\": {\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"unit_size\": 1.5,\n",
        "            },\n",
        "        },\n",
        "        \"default_surface_config\": {\n",
        "            \"resolution\": (16, 16)\n",
        "            # \"resolution\": (4, 4)\n",
        "        },\n",
        "        \"freqs\": [2, 5],\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        TemperatureGraphScene.setup(self)\n",
        "        WriteHeatEquationTemplate.setup(self)\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_camera()\n",
        "        self.add_three_graphs()\n",
        "        self.show_words()\n",
        "        self.add_function_labels()\n",
        "        self.change_scalars()\n",
        "\n",
        "    def init_camera(self):\n",
        "        self.camera.set_distance(1000)\n",
        "\n",
        "    def add_three_graphs(self):\n",
        "        axes_group = self.get_axes_group()\n",
        "        axes0, axes1, axes2 = axes_group\n",
        "        freqs = self.freqs\n",
        "        scalar_trackers = Group(\n",
        "            ValueTracker(1),\n",
        "            ValueTracker(1),\n",
        "        )\n",
        "        graphs = VGroup(\n",
        "            self.get_graph(axes0, [freqs[0]], [scalar_trackers[0]]),\n",
        "            self.get_graph(axes1, [freqs[1]], [scalar_trackers[1]]),\n",
        "            self.get_graph(axes2, freqs, scalar_trackers),\n",
        "        )\n",
        "\n",
        "        plus = OldTex(\"+\").scale(2)\n",
        "        equals = OldTex(\"=\").scale(2)\n",
        "        plus.move_to(midpoint(\n",
        "            axes0.get_right(),\n",
        "            axes1.get_left(),\n",
        "        ))\n",
        "        equals.move_to(midpoint(\n",
        "            axes1.get_right(),\n",
        "            axes2.get_left(),\n",
        "        ))\n",
        "\n",
        "        self.add(axes_group)\n",
        "        self.add(graphs)\n",
        "        self.add(plus)\n",
        "        self.add(equals)\n",
        "\n",
        "        self.axes_group = axes_group\n",
        "        self.graphs = graphs\n",
        "        self.scalar_trackers = scalar_trackers\n",
        "        self.plus = plus\n",
        "        self.equals = equals\n",
        "\n",
        "    def show_words(self):\n",
        "        equation = self.get_d1_equation()\n",
        "        name = OldTexText(\"Heat equation\")\n",
        "        name.next_to(equation, DOWN)\n",
        "        name.set_color_by_gradient(RED, YELLOW)\n",
        "        group = VGroup(equation, name)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        shift_val = 0.5 * RIGHT\n",
        "\n",
        "        arrow = Vector(1.5 * RIGHT)\n",
        "        arrow.move_to(group)\n",
        "        arrow.shift(shift_val)\n",
        "        linear_word = OldTexText(\"``Linear''\")\n",
        "        linear_word.scale(2)\n",
        "        linear_word.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.add(group)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            group.next_to, arrow, LEFT\n",
        "        )\n",
        "        self.play(FadeIn(linear_word, LEFT))\n",
        "        self.wait()\n",
        "\n",
        "    def add_function_labels(self):\n",
        "        axes_group = self.axes_group\n",
        "        graphs = self.graphs\n",
        "\n",
        "        solution_labels = VGroup()\n",
        "        for axes in axes_group:\n",
        "            label = OldTexText(\"Solution\", \"$\\\\checkmark$\")\n",
        "            label.set_color_by_tex(\"checkmark\", GREEN)\n",
        "            label.next_to(axes, DOWN)\n",
        "            solution_labels.add(label)\n",
        "\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"T_1\": BLUE,\n",
        "                \"T_2\": GREEN,\n",
        "            }\n",
        "        }\n",
        "        T1 = OldTex(\"a\", \"T_1\", **kw)\n",
        "        T2 = OldTex(\"b\", \"T_2\", **kw)\n",
        "        T_sum = OldTex(\"T_1\", \"+\", \"T_2\", **kw)\n",
        "        T_sum_with_scalars = OldTex(\n",
        "            \"a\", \"T_1\", \"+\", \"b\", \"T_2\", **kw\n",
        "        )\n",
        "\n",
        "        T1.next_to(graphs[0], UP)\n",
        "        T2.next_to(graphs[1], UP)\n",
        "        T_sum.next_to(graphs[2], UP)\n",
        "        T_sum.shift(SMALL_BUFF * DOWN)\n",
        "        T_sum_with_scalars.move_to(T_sum)\n",
        "\n",
        "        a_brace = Brace(T1[0], UP, buff=SMALL_BUFF)\n",
        "        b_brace = Brace(T2[0], UP, buff=SMALL_BUFF)\n",
        "        s1_decimal = DecimalNumber()\n",
        "        s1_decimal.match_color(T1[1])\n",
        "        s1_decimal.next_to(a_brace, UP, SMALL_BUFF)\n",
        "        s1_decimal.add_updater(lambda m: m.set_value(\n",
        "            self.scalar_trackers[0].get_value()\n",
        "        ))\n",
        "        s2_decimal = DecimalNumber()\n",
        "        s2_decimal.match_color(T2[1])\n",
        "        s2_decimal.next_to(b_brace, UP, SMALL_BUFF)\n",
        "        s2_decimal.add_updater(lambda m: m.set_value(\n",
        "            self.scalar_trackers[1].get_value()\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(T1[1], DOWN),\n",
        "            FadeIn(solution_labels[0], UP),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(T2[1], DOWN),\n",
        "            FadeIn(solution_labels[1], UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(T1[1], T_sum[0]),\n",
        "            TransformFromCopy(T2[1], T_sum[2]),\n",
        "            TransformFromCopy(self.plus, T_sum[1]),\n",
        "            *[\n",
        "                Transform(\n",
        "                    graph.copy().set_fill(opacity=0),\n",
        "                    graphs[2].copy().set_fill(opacity=0),\n",
        "                    remover=True\n",
        "                )\n",
        "                for graph in graphs[:2]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(solution_labels[2], UP))\n",
        "        self.wait()\n",
        "\n",
        "        # Show constants\n",
        "        self.play(\n",
        "            FadeIn(T1[0]),\n",
        "            FadeIn(T2[0]),\n",
        "            FadeIn(a_brace),\n",
        "            FadeIn(b_brace),\n",
        "            FadeIn(s1_decimal),\n",
        "            FadeIn(s2_decimal),\n",
        "            FadeOut(T_sum),\n",
        "            FadeIn(T_sum_with_scalars),\n",
        "        )\n",
        "\n",
        "    def change_scalars(self):\n",
        "        s1, s2 = self.scalar_trackers\n",
        "\n",
        "        kw = {\n",
        "            \"run_time\": 2,\n",
        "        }\n",
        "        for graph in self.graphs:\n",
        "            graph.resume_updating()\n",
        "        self.play(s2.set_value, -0.5, **kw)\n",
        "        self.play(s1.set_value, -0.2, **kw)\n",
        "        self.play(s2.set_value, 1.5, **kw)\n",
        "        self.play(s1.set_value, 1.2, **kw)\n",
        "        self.play(s2.set_value, 0.3, **kw)\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_axes_group(self):\n",
        "        axes_group = VGroup(*[\n",
        "            self.get_axes()\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        axes_group.arrange(RIGHT, buff=2)\n",
        "        axes_group.set_width(FRAME_WIDTH - 1)\n",
        "        axes_group.to_edge(DOWN, buff=1)\n",
        "        return axes_group\n",
        "\n",
        "    def get_axes(self, **kwargs):\n",
        "        axes = self.get_three_d_axes(**kwargs)\n",
        "        # axes.input_plane.set_fill(opacity=0)\n",
        "        # axes.input_plane.set_stroke(width=0.5)\n",
        "        # axes.add(axes.input_plane)\n",
        "        self.orient_three_d_mobject(axes)\n",
        "        axes.rotate(-5 * DEGREES, UP)\n",
        "        axes.set_width(4)\n",
        "        axes.x_axis.label.next_to(\n",
        "            axes.x_axis.get_end(), DOWN,\n",
        "            buff=2 * SMALL_BUFF\n",
        "        )\n",
        "        return axes\n",
        "\n",
        "    def get_graph(self, axes, freqs, scalar_trackers):\n",
        "        L = axes.x_max\n",
        "        a = self.alpha\n",
        "\n",
        "        def func(x, t):\n",
        "            scalars = [st.get_value() for st in scalar_trackers]\n",
        "            return np.sum([\n",
        "                s * np.cos(k * x) * np.exp(-a * (k**2) * t)\n",
        "                for freq, s in zip(freqs, scalars)\n",
        "                for k in [freq * PI / L]\n",
        "            ])\n",
        "\n",
        "        def get_surface_graph_group():\n",
        "            return VGroup(\n",
        "                self.get_surface(axes, func),\n",
        "                self.get_time_slice_graph(axes, func, t=0),\n",
        "            )\n",
        "\n",
        "        result = always_redraw(get_surface_graph_group)\n",
        "        result.func = func\n",
        "        result.suspend_updating()\n",
        "        return result\n",
        "\n",
        "\n",
        "class CombineSeveralSolutions(ShowLinearity):\n",
        "    CONFIG = {\n",
        "        \"default_surface_config\": {\n",
        "            \"resolution\": (16, 16),\n",
        "            # \"resolution\": (4, 4),\n",
        "        },\n",
        "        \"n_top_graphs\": 5,\n",
        "        \"axes_config\": {\n",
        "            \"y_max\": 15,\n",
        "        },\n",
        "        \"target_scalars\": [\n",
        "            0.81, -0.53, 0.41, 0.62, -0.95\n",
        "        ],\n",
        "        \"final_run_time\": 14,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_camera()\n",
        "        self.add_all_axes()\n",
        "        self.setup_all_graphs()\n",
        "        self.show_infinite_family()\n",
        "        self.show_sum()\n",
        "        self.show_time_passing()\n",
        "\n",
        "    def add_all_axes(self):\n",
        "        top_axes_group = VGroup(*[\n",
        "            self.get_axes(\n",
        "                z_min=-1.25,\n",
        "                z_max=1.25,\n",
        "                z_axis_config={\n",
        "                    \"unit_size\": 2,\n",
        "                    \"tick_frequency\": 0.5,\n",
        "                },\n",
        "            )\n",
        "            for x in range(self.n_top_graphs)\n",
        "        ])\n",
        "        top_axes_group.arrange(RIGHT, buff=2)\n",
        "        top_axes_group.set_width(FRAME_WIDTH - 1.5)\n",
        "        top_axes_group.to_corner(UL)\n",
        "        dots = OldTex(\"\\\\dots\")\n",
        "        dots.next_to(top_axes_group, RIGHT)\n",
        "\n",
        "        low_axes = self.get_axes()\n",
        "        low_axes.center()\n",
        "        low_axes.scale(1.2)\n",
        "        low_axes.to_edge(DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        self.add(top_axes_group)\n",
        "        self.add(dots)\n",
        "        self.add(low_axes)\n",
        "\n",
        "        self.top_axes_group = top_axes_group\n",
        "        self.low_axes = low_axes\n",
        "\n",
        "    def setup_all_graphs(self):\n",
        "        scalar_trackers = Group(*[\n",
        "            ValueTracker(1)\n",
        "            for x in range(self.n_top_graphs)\n",
        "        ])\n",
        "        freqs = np.arange(self.n_top_graphs)\n",
        "        freqs += 1\n",
        "        self.top_graphs = VGroup(*[\n",
        "            self.get_graph(axes, [n], [st])\n",
        "            for axes, n, st in zip(\n",
        "                self.top_axes_group,\n",
        "                freqs,\n",
        "                scalar_trackers,\n",
        "            )\n",
        "        ])\n",
        "        self.low_graph = self.get_graph(\n",
        "            self.low_axes, freqs, scalar_trackers\n",
        "        )\n",
        "\n",
        "        self.scalar_trackers = scalar_trackers\n",
        "\n",
        "    def show_infinite_family(self):\n",
        "        top_axes_group = self.top_axes_group\n",
        "        top_graphs = self.top_graphs\n",
        "        scalar_trackers = self.scalar_trackers\n",
        "\n",
        "        decimals = self.get_decimals(\n",
        "            top_axes_group, scalar_trackers\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            AnimationGroup(\n",
        "                Write(graph[0]),\n",
        "                FadeIn(graph[1]),\n",
        "            )\n",
        "            for graph in top_graphs\n",
        "        ]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(decimals))\n",
        "        for graph in top_graphs:\n",
        "            graph.resume_updating()\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            ApplyMethod(st.set_value, value)\n",
        "            for st, value in zip(\n",
        "                scalar_trackers,\n",
        "                self.target_scalars,\n",
        "            )\n",
        "        ]), run_time=3)\n",
        "        self.wait()\n",
        "\n",
        "    def show_sum(self):\n",
        "        top_graphs = self.top_graphs\n",
        "        low_graph = self.low_graph\n",
        "        low_graph.resume_updating()\n",
        "        low_graph.update()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                Transform(\n",
        "                    top_graph.copy().set_fill(opacity=0),\n",
        "                    low_graph.copy().set_fill(opacity=0),\n",
        "                    remover=True,\n",
        "                )\n",
        "                for top_graph in top_graphs\n",
        "            ]),\n",
        "            FadeIn(\n",
        "                low_graph,\n",
        "                rate_func=squish_rate_func(smooth, 0.7, 1)\n",
        "            ),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_time_passing(self):\n",
        "        all_graphs = [*self.top_graphs, self.low_graph]\n",
        "        all_axes = [*self.top_axes_group, self.low_axes]\n",
        "\n",
        "        time_tracker = ValueTracker(0)\n",
        "        get_t = time_tracker.get_value\n",
        "\n",
        "        anims = [\n",
        "            ApplyMethod(\n",
        "                time_tracker.set_value, 1,\n",
        "                run_time=1,\n",
        "                rate_func=linear\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        for axes, graph_group in zip(all_axes, all_graphs):\n",
        "            graph_group.clear_updaters()\n",
        "            surface, gslice = graph_group\n",
        "            plane = self.get_const_time_plane(axes)\n",
        "            plane.t_tracker.add_updater(\n",
        "                lambda m: m.set_value(get_t())\n",
        "            )\n",
        "            gslice.axes = axes\n",
        "            gslice.func = graph_group.func\n",
        "            gslice.add_updater(lambda m: m.become(\n",
        "                self.get_time_slice_graph(\n",
        "                    m.axes, m.func, t=get_t()\n",
        "                )\n",
        "            ))\n",
        "            self.add(gslice)\n",
        "            self.add(plane.t_tracker)\n",
        "            anims.append(FadeIn(plane))\n",
        "\n",
        "        self.play(*anims)\n",
        "        run_time = self.final_run_time\n",
        "        self.play(\n",
        "            time_tracker.increment_value, run_time,\n",
        "            run_time=run_time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    #\n",
        "    def get_decimals(self, axes_group, scalar_trackers):\n",
        "        result = VGroup()\n",
        "        for axes, st in zip(axes_group, scalar_trackers):\n",
        "            decimal = DecimalNumber()\n",
        "            decimal.move_to(axes.get_bottom(), UP)\n",
        "            decimal.shift(SMALL_BUFF * RIGHT)\n",
        "            decimal.set_color(YELLOW)\n",
        "            decimal.scalar_tracker = st\n",
        "            times = OldTex(\"\\\\times\")\n",
        "            times.next_to(decimal, LEFT, SMALL_BUFF)\n",
        "            decimal.add_updater(lambda d: d.set_value(\n",
        "                d.scalar_tracker.get_value()\n",
        "            ))\n",
        "            group = VGroup(times, decimal)\n",
        "            group.scale(0.7)\n",
        "            result.add(group)\n",
        "        return result\n",
        "\n",
        "\n",
        "class CycleThroughManyLinearCombinations(CombineSeveralSolutions):\n",
        "    CONFIG = {\n",
        "        \"default_surface_config\": {\n",
        "            \"resolution\": (16, 16),\n",
        "            # \"resolution\": (4, 4),\n",
        "        },\n",
        "        \"n_cycles\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.init_camera()\n",
        "        self.add_all_axes()\n",
        "        self.setup_all_graphs()\n",
        "        #\n",
        "        self.cycle_through_superpositions()\n",
        "\n",
        "    def cycle_through_superpositions(self):\n",
        "        top_graphs = self.top_graphs\n",
        "        low_graph = self.low_graph\n",
        "        scalar_trackers = self.scalar_trackers\n",
        "        self.add(self.get_decimals(\n",
        "            self.top_axes_group, scalar_trackers\n",
        "        ))\n",
        "\n",
        "        for graph in [low_graph, *top_graphs]:\n",
        "            graph.resume_updating()\n",
        "            self.add(graph)\n",
        "\n",
        "        nst = len(scalar_trackers)\n",
        "        for x in range(self.n_cycles):\n",
        "            self.play(LaggedStart(*[\n",
        "                ApplyMethod(st.set_value, value)\n",
        "                for st, value in zip(\n",
        "                    scalar_trackers,\n",
        "                    3 * np.random.random(nst) - 1.5\n",
        "                )\n",
        "            ]), run_time=3)\n",
        "            self.wait()\n"
    ]
}