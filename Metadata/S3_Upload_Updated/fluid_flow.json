{
    "topic": "demonstrates the concept of fluid flow.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class FluidFlow(Scene):\n",
        "    CONFIG = {\n",
        "        \"vector_spacing\" : 1,\n",
        "        \"dot_spacing\" : 0.5,\n",
        "        \"dot_color\" : BLUE_C,\n",
        "        \"text_color\" : WHITE,\n",
        "        \"vector_color\" : YELLOW,\n",
        "        \"vector_length\" : 0.5,\n",
        "        \"points_height\" : FRAME_Y_RADIUS,\n",
        "        \"points_width\" : FRAME_X_RADIUS,\n",
        "    }\n",
        "    def use_function(self, function):\n",
        "        self.function = function\n",
        "\n",
        "    def get_points(self, spacing):\n",
        "        x_radius, y_radius = [\n",
        "            val-val%spacing\n",
        "            for val in self.points_width, self.points_height\n",
        "        ]\n",
        "        return map(np.array, it.product(\n",
        "            np.arange(-x_radius, x_radius+spacing, spacing),\n",
        "            np.arange(-y_radius, y_radius+spacing, spacing),\n",
        "            [0]\n",
        "        ))\n",
        "\n",
        "\n",
        "    def add_axes(self, show_creation = False):\n",
        "        self.axes = Axes(color = WHITE, tick_frequency = 1)\n",
        "        self.add(self.axes)\n",
        "        if show_creation:\n",
        "            self.play(ShowCreation(self.axes))\n",
        "            self.wait()\n",
        "\n",
        "    def add_dots(self, show_creation = False):\n",
        "        points = self.get_points(self.dot_spacing)\n",
        "        self.dots = VMobject(*map(Dot, points))\n",
        "        self.dots.set_color(self.dot_color)\n",
        "        self.add(self.dots)\n",
        "        if show_creation:\n",
        "            self.play(ShowCreation(self.dots))\n",
        "            self.wait()\n",
        "\n",
        "    def add_vectors(self, true_length = False, show_creation = False):\n",
        "        if not hasattr(self, \"function\"):\n",
        "            raise Exception(\"Must run use_function first\")\n",
        "        points = self.get_points(self.vector_spacing)\n",
        "        points = filter(\n",
        "            lambda p : get_norm(self.function(p)) > 0.01,\n",
        "            points\n",
        "        )\n",
        "        directions = map(self.function, points)\n",
        "        if not true_length:\n",
        "            directions = [\n",
        "                self.vector_length*d/get_norm(d)\n",
        "                for d in directions\n",
        "            ]\n",
        "        self.vectors = VMobject(*[\n",
        "            Vector(\n",
        "                direction,\n",
        "                color = self.vector_color,\n",
        "                tip_length = 0.1,\n",
        "            ).shift(point)\n",
        "            for point, direction in zip(points, directions)\n",
        "        ])\n",
        "        self.add(self.vectors)\n",
        "        if show_creation:\n",
        "            self.play(ShowCreation(self.vectors))\n",
        "            self.wait()\n",
        "\n",
        "    def flow(self, **kwargs):\n",
        "        if not hasattr(self, \"function\"):\n",
        "            raise Exception(\"Must run use_function first\")\n",
        "        # Warning, this is now depricated\n",
        "        self.play(ApplyToCenters(\n",
        "            PhaseFlow,\n",
        "            self.dots.split(),\n",
        "            function = self.function,\n",
        "            **kwargs\n",
        "        ))\n",
        "\n",
        "    def label(self, text, time = 5):\n",
        "        mob = OldTexText(text)\n",
        "        mob.scale(1.5)\n",
        "        mob.to_edge(UP)\n",
        "        mob.set_color(self.text_color)        \n",
        "        rectangle = Polygon(*[\n",
        "            mob.get_corner(vect) + 0.3*vect\n",
        "            for vect in [\n",
        "                UP+RIGHT,\n",
        "                UP+LEFT,\n",
        "                DOWN+LEFT,\n",
        "                DOWN+RIGHT\n",
        "            ]\n",
        "        ])\n",
        "        rectangle.set_fill(BLACK, 1.0)\n",
        "        self.add(rectangle, mob)\n",
        "        self.wait(time)\n",
        "        self.remove(mob, rectangle)\n",
        "\n",
        "\n",
        "class VectorFieldExample(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : 4,\n",
        "        \"points_width\" : 4,\n",
        "        \"vector_spacing\" : 0.5,\n",
        "        \"vector_length\" : 0.3\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : 0.5*((2*y)**3-9*(2*y))*RIGHT+0.5*((2*x)**3-9*(2*x))*UP\n",
        "        )\n",
        "        self.add_axes(show_creation = True)\n",
        "        self.add_vectors(show_creation = True)\n",
        "        self.add_dots(show_creation = True)\n",
        "        self.show_frame()\n",
        "        self.flow(run_time = 30, virtual_time = 3)\n",
        "\n",
        "class VectorFieldExampleWithoutArrows(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : 0.5*(y**3-9*y)*RIGHT+0.5*(x**3-9*x)*UP\n",
        "        )\n",
        "        self.add_axes(show_creation = True)\n",
        "        self.add_dots(show_creation = True)\n",
        "        self.flow(run_time = 30, virtual_time = 3)\n",
        "\n",
        "\n",
        "class VectorFieldExampleTwo(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_width\" : 3*FRAME_X_RADIUS,\n",
        "        \"points_height\" : 1.4*FRAME_Y_RADIUS\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : RIGHT+np.sin(x)*UP\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots(show_creation = True)\n",
        "        for x in range(10):\n",
        "            self.flow(\n",
        "                run_time = 1,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "\n",
        "class VectorFieldExampleThree(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda p : p/(2*get_norm(0.5*p)**0.5+0.01)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()  \n",
        "        self.add_dots(show_creation = True)\n",
        "        self.flow(run_time = 2, virtual_time = 2)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class VectorFieldExampleFour(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : 1.FRAME_WIDTH,\n",
        "        \"points_width\" : 1.FRAME_WIDTH,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : (x*UP - y*RIGHT)/5\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors(true_length = True)  \n",
        "        self.add_dots(show_creation = True)\n",
        "        self.show_frame()\n",
        "        self.play(Rotating(\n",
        "            self.dots, \n",
        "            run_time = 10, \n",
        "            axis = OUT\n",
        "        ))\n",
        "        self.wait(2)        \n",
        "\n",
        "\n",
        "class FluxArticleExample(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"vector_length\" : 0.4,\n",
        "        \"vector_color\" : BLUE_D,\n",
        "        \"points_height\" : FRAME_Y_RADIUS,\n",
        "        \"points_width\" : FRAME_X_RADIUS,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : (x**2+y**2)*((np.sin(x)**2)*RIGHT + np.cos(y)*UP)\n",
        "        )\n",
        "        # self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.show_frame()\n",
        "        self.add_dots()        \n",
        "        self.flow(run_time = 2, virtual_time = 0.1)\n",
        "        self.wait(2)\n",
        "\n",
        "class NegativeDivergenceExamlpe(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_width\" : FRAME_WIDTH,\n",
        "        \"points_height\" : FRAME_HEIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        circle = Circle(color = YELLOW_C)\n",
        "        self.use_function(\n",
        "            lambda p : -p/(2*get_norm(0.5*p)**0.5+0.01)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "        self.add_dots(show_creation = True)        \n",
        "        self.flow(\n",
        "            run_time = 1, \n",
        "            virtual_time = 1,\n",
        "            rate_func = smooth\n",
        "       )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class PositiveDivergenceExample(FluidFlow):\n",
        "    def construct(self):\n",
        "        circle = Circle(color = YELLOW_C)\n",
        "        self.use_function(\n",
        "            lambda p : p/(2*get_norm(0.5*p)**0.5+0.01)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.wait()\n",
        "        self.add_dots(show_creation = True)        \n",
        "        self.flow(\n",
        "            run_time = 1, \n",
        "            virtual_time = 1, \n",
        "            rate_func = smooth\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class DivergenceArticleExample(FluidFlow):\n",
        "    def construct(self):\n",
        "        def raw_function((x, y, z)):\n",
        "            return (2*x-y, y*y, 0)\n",
        "        def normalized_function(p):\n",
        "            result = raw_function(p)\n",
        "            return result/(get_norm(result)+0.01)\n",
        "        self.use_function(normalized_function)\n",
        "\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        self.flow(\n",
        "            virtual_time = 4,\n",
        "            run_time = 5\n",
        "        )\n",
        "\n",
        "class QuadraticField(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : 0.25*((x*x-y*y)*RIGHT+x*y*UP)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        self.flow(\n",
        "            virtual_time = 10,\n",
        "            run_time = 20,\n",
        "            rate_func=linear\n",
        "        )\n",
        "\n",
        "\n",
        "class IncompressibleFluid(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_width\" : FRAME_WIDTH,\n",
        "        \"points_height\" : 1.4*FRAME_Y_RADIUS\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : RIGHT+np.sin(x)*UP\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        for x in range(8):\n",
        "            self.flow(\n",
        "                run_time = 1,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "class ConstantInwardFlow(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : FRAME_HEIGHT,\n",
        "        \"points_width\" : FRAME_WIDTH,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda p : -3*p/(get_norm(p)+0.1)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        for x in range(5):\n",
        "            self.flow(\n",
        "                run_time = 5,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ConstantOutwardFlow(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda p : p/(2*get_norm(0.5*p)**0.5+0.01)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        for x in range(10):\n",
        "            self.flow(rate_func=linear)\n",
        "            dot = self.dots.split()[0].copy()\n",
        "            dot.center()\n",
        "            new_dots = [\n",
        "                dot.copy().shift(0.5*vect)\n",
        "                for vect in [\n",
        "                    UP, DOWN, LEFT, RIGHT, \n",
        "                    UP+RIGHT, UP+LEFT, DOWN+RIGHT, DOWN+LEFT\n",
        "                ]\n",
        "            ]\n",
        "            self.dots.add(*new_dots)\n",
        "\n",
        "\n",
        "class ConstantPositiveCurl(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : FRAME_X_RADIUS,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda p : 0.5*(-p[1]*RIGHT+p[0]*UP)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors(true_length = True)\n",
        "        self.add_dots()\n",
        "        for x in range(10):\n",
        "            self.flow(\n",
        "                rate_func=linear\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "class ComplexCurlExample(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : np.cos(x+y)*RIGHT+np.sin(x*y)*UP\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors(true_length = True)\n",
        "        self.add_dots()\n",
        "        for x in range(4):\n",
        "            self.flow(\n",
        "                run_time = 5,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "\n",
        "class SingleSwirl(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : FRAME_X_RADIUS,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda p : (-p[1]*RIGHT+p[0]*UP)/get_norm(p)\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.add_dots()\n",
        "        for x in range(10):\n",
        "            self.flow(rate_func=linear)\n",
        "\n",
        "\n",
        "class CurlArticleExample(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : 3*FRAME_Y_RADIUS,\n",
        "        \"points_width\" : 3*FRAME_X_RADIUS\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : np.cos(0.5*(x+y))*RIGHT + np.sin(0.25*x*y)*UP\n",
        "        )\n",
        "        circle = Circle().shift(3*UP)\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.add_dots()\n",
        "        self.show_frame()\n",
        "        self.flow(\n",
        "            rate_func=linear,\n",
        "            run_time = 15,\n",
        "            virtual_time = 10\n",
        "        )\n",
        "\n",
        "\n",
        "class FourSwirlsWithoutCircles(FluidFlow):\n",
        "    CONFIG = {\n",
        "        \"points_height\" : FRAME_X_RADIUS,\n",
        "    }\n",
        "    def construct(self):\n",
        "        circles = [\n",
        "            Circle().shift(3*vect)\n",
        "            for vect in compass_directions()\n",
        "        ]\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : 0.5*(y**3-9*y)*RIGHT+(x**3-9*x)*UP\n",
        "        )\n",
        "        self.add_axes()\n",
        "        self.add_vectors()\n",
        "        # for circle in circles:\n",
        "        #     self.play(ShowCreation(circle))\n",
        "        self.add_dots()\n",
        "        self.add_extra_dots()\n",
        "        self.flow(\n",
        "            virtual_time = 2,\n",
        "            run_time = 20,\n",
        "            rate_func=linear\n",
        "        )\n",
        "\n",
        "    def add_extra_dots(self):\n",
        "        dots = self.dots.split()\n",
        "        for vect in UP+LEFT, DOWN+RIGHT:\n",
        "            for n in range(5, 15):\n",
        "                dots.append(\n",
        "                    dots[0].copy().center().shift(n*vect)\n",
        "                )\n",
        "        self.dots = VMobject(*dots)\n",
        "\n",
        "\n",
        "class CopyPlane(Scene):\n",
        "    def construct(self):\n",
        "        def special_rotate(mob):\n",
        "            mob.rotate(0.9*np.pi/2, RIGHT, about_point = ORIGIN)\n",
        "            mob.rotate(-np.pi/4, UP, about_point = ORIGIN)\n",
        "            return mob\n",
        "        plane = NumberPlane()\n",
        "        copies = [\n",
        "            special_rotate(plane.copy().shift(u*n*OUT))\n",
        "            for n in range(1, 3)\n",
        "            for u in -1, 1\n",
        "        ]\n",
        "        line = Line(4*IN, 4*OUT)\n",
        "\n",
        "\n",
        "        self.add(plane)\n",
        "        self.play(*[\n",
        "            ApplyFunction(special_rotate, mob, run_time = 3)\n",
        "            for mob in plane, line\n",
        "        ])\n",
        "        self.wait()\n",
        "        for copy in copies:\n",
        "            self.play(Transform(plane.copy(), copy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DropletFlow(FluidFlow):\n",
        "    def construct(self):\n",
        "        seconds = 60*5\n",
        "        droplets = Group(*[\n",
        "            PointDot(x*RIGHT+y*UP, radius = 0.15, density = 120)\n",
        "            for x in range(-7, 9)\n",
        "            for y in range(-3, 4)\n",
        "        ])\n",
        "        droplets.set_color_by_gradient(BLUE, GREEN, YELLOW)\n",
        "        self.use_function(\n",
        "            lambda (x, y, z) : y*RIGHT+np.sin(2*np.pi*x)*UP,\n",
        "        )\n",
        "        self.add(NumberPlane().fade())\n",
        "        self.play(ShowCreation(droplets))\n",
        "        n_steps = int(seconds * self.camera.frame_rate)\n",
        "        from tqdm import tqdm as ProgressDisplay\n",
        "        for x in ProgressDisplay(range(n_steps)):\n",
        "            for d in droplets:\n",
        "                if x%10 == 0:\n",
        "                    d.filter_out(\n",
        "                        lambda p : abs(p[0]) > 1.5*FRAME_X_RADIUS or abs(p[1]) > 1.5*FRAME_Y_RADIUS\n",
        "                    )\n",
        "                for p in d.points:\n",
        "                    p += 0.001*self.function(p)\n",
        "            self.wait(1 / self.camera.frame_rate)\n",
        "\n",
        "\n",
        "class AltDropletFlow(FluidFlow):\n",
        "    def construct(self):\n",
        "        self.use_function(lambda (x, y, z):\n",
        "            (np.sin(x)+np.sin(y))*RIGHT+\\\n",
        "            (np.sin(x)-np.sin(y))*UP\n",
        "        )\n",
        "        self.add_dots()\n",
        "        self.flow(\n",
        "            rate_func=linear,\n",
        "            run_time = 10,\n",
        "            virtual_time = 2\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}