{
    "topic": "demonstrates the concept of multiplication in mathematics, specifically the multiplication of two numbers on a",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "ARROW_CONFIG = {\"stroke_width\" : 2*DEFAULT_STROKE_WIDTH}\n",
        "LIGHT_RED = RED_E\n",
        "\n",
        "def matrix_to_string(matrix):\n",
        "    return \"--\".join([\"-\".join(map(str, row)) for row in matrix])\n",
        "\n",
        "def matrix_mobject(matrix):\n",
        "    return OldTexText(\n",
        "        \"\"\"\n",
        "        \\\\left(\n",
        "            \\\\begin{array}{%s}\n",
        "                %d & %d \\\\\\\\\n",
        "                %d & %d\n",
        "            \\\\end{array}\n",
        "        \\\\right)\n",
        "        \"\"\"%tuple([\"c\"*matrix.shape[1]] + list(matrix.flatten())),\n",
        "        size = \"\\\\Huge\"\n",
        "    )\n",
        "\n",
        "class ShowMultiplication(NumberLineScene):\n",
        "    args_list = [\n",
        "        (2, True),\n",
        "        (0.5, True),\n",
        "        (-3, True),\n",
        "        (-3, True),\n",
        "        (2, True),\n",
        "        (6, True),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(num, show_original_line):\n",
        "        end_string = \"WithCopiedOriginalLine\" if show_original_line else \"\"\n",
        "        return str(num) + end_string\n",
        "    @staticmethod\n",
        "    def string_to_args(string):\n",
        "        parts = string.split()\n",
        "        if len(parts) == 2:\n",
        "            num, original_line = parts\n",
        "            show_original_line = original_line == \"WithCopiedOriginalLine\"\n",
        "            return float(num), False\n",
        "        else:\n",
        "            return float(parts[0]), False\n",
        "\n",
        "    def construct(self, num, show_original_line):\n",
        "        config = {\n",
        "            \"density\" : max(abs(num), 1)*DEFAULT_POINT_DENSITY_1D,\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH\n",
        "        }\n",
        "        if abs(num) < 1:\n",
        "            config[\"numerical_radius\"] = FRAME_X_RADIUS/num\n",
        "\n",
        "        NumberLineScene.construct(self, **config)\n",
        "        if show_original_line:\n",
        "            self.copy_original_line()\n",
        "        self.wait()\n",
        "        self.show_multiplication(num, run_time = 1.5)\n",
        "        self.wait()\n",
        "\n",
        "    def copy_original_line(self):\n",
        "        copied_line = deepcopy(self.number_line)\n",
        "        copied_num_mobs = deepcopy(self.number_mobs)\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                lambda m : m.shift(DOWN).set_color(\"lightgreen\"), \n",
        "                copied_line\n",
        "            ), *[\n",
        "                ApplyMethod(mob.shift, DOWN)\n",
        "                for mob in copied_num_mobs\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ExamplesOfOneDimensionalLinearTransforms(ShowMultiplication):\n",
        "    args_list = []\n",
        "    @staticmethod\n",
        "    def args_to_string():\n",
        "        return \"\"\n",
        "\n",
        "    def construct(self):\n",
        "        for num in [2, 0.5, -3]:\n",
        "            self.clear()            \n",
        "            ShowMultiplication.construct(self, num, False)\n",
        "\n",
        "\n",
        "\n",
        "class ExamplesOfNonlinearOneDimensionalTransforms(NumberLineScene):\n",
        "    def construct(self):\n",
        "        def sinx_plux_x(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return (np.sin(x) + 1.2*x, y, z)\n",
        "\n",
        "        def shift_zero(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return (2*x+4, y, z)\n",
        "\n",
        "        self.nonlinear = OldTexText(\"Not a Linear Transform\")\n",
        "        self.nonlinear.set_color(LIGHT_RED).to_edge(UP, buff = 1.5)\n",
        "        pairs = [\n",
        "            (sinx_plux_x, \"numbers don't remain evenly spaced\"),\n",
        "            (shift_zero, \"zero does not remain fixed\")\n",
        "        ]\n",
        "        for func, explanation in pairs:\n",
        "            self.run_function(func, explanation)\n",
        "            self.wait(3)\n",
        "\n",
        "    def run_function(self, function, explanation):\n",
        "        self.clear()\n",
        "        self.add(self.nonlinear)\n",
        "        config = {\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH,\n",
        "            \"density\" : 5*DEFAULT_POINT_DENSITY_1D,\n",
        "        }\n",
        "        NumberLineScene.construct(self, **config)\n",
        "        words = OldTexText(explanation).set_color(LIGHT_RED)\n",
        "        words.next_to(self.nonlinear, DOWN, buff = 0.5)\n",
        "        self.add(words)\n",
        "\n",
        "        self.play(\n",
        "            ApplyPointwiseFunction(function, self.number_line),\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    mob.shift,\n",
        "                    function(mob.get_center()) - mob.get_center()\n",
        "                )\n",
        "                for mob in self.number_mobs\n",
        "            ],\n",
        "            run_time = 2.0\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowTwoThenThree(ShowMultiplication):\n",
        "    args_list = []\n",
        "    @staticmethod\n",
        "    def args_to_string():\n",
        "        return \"\"\n",
        "\n",
        "    def construct(self):\n",
        "        config = {\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH,\n",
        "            \"density\" : 6*DEFAULT_POINT_DENSITY_1D,\n",
        "        }\n",
        "        NumberLineScene.construct(self, **config)\n",
        "        self.copy_original_line()\n",
        "        self.show_multiplication(2)\n",
        "        self.wait()\n",
        "        self.show_multiplication(3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "########################################################\n",
        "\n",
        "class TransformScene2D(Scene):\n",
        "    def add_number_plane(self, density_factor = 1, use_faded_lines = True):\n",
        "        config = {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_WIDTH,\n",
        "            \"density\" : DEFAULT_POINT_DENSITY_1D*density_factor,\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH\n",
        "        }\n",
        "        if not use_faded_lines:\n",
        "            config[\"x_faded_line_frequency\"] = None\n",
        "            config[\"y_faded_line_frequency\"] = None\n",
        "        self.number_plane = NumberPlane(**config)\n",
        "        self.add(self.number_plane)\n",
        "\n",
        "    def add_background(self):\n",
        "        grey_plane = NumberPlane(color = \"grey\")\n",
        "        num_mobs = grey_plane.get_coordinate_labels()\n",
        "        self.paint_into_background(grey_plane, *num_mobs)\n",
        "\n",
        "    def add_x_y_arrows(self):\n",
        "        self.x_arrow = Arrow(\n",
        "            ORIGIN, \n",
        "            self.number_plane.num_pair_to_point((1, 0)),\n",
        "            color = \"lightgreen\",\n",
        "            **ARROW_CONFIG\n",
        "        )\n",
        "        self.y_arrow = Arrow(\n",
        "            ORIGIN,\n",
        "            self.number_plane.num_pair_to_point((0, 1)),\n",
        "            color = LIGHT_RED,\n",
        "            **ARROW_CONFIG\n",
        "        )\n",
        "        self.add(self.x_arrow, self.y_arrow)\n",
        "        self.number_plane.filter_out(\n",
        "            lambda x_y_z : (0 < x_y_z[0]) and (x_y_z[0] < 1) and (abs(x_y_z[1]) < 0.1)\n",
        "        )\n",
        "        self.number_plane.filter_out(\n",
        "            lambda x_y_z1 : (0 < x_y_z1[1]) and (x_y_z1[1] < 1) and (abs(x_y_z1[0]) < 0.1)\n",
        "        )\n",
        "        return self\n",
        "\n",
        "\n",
        "class ShowMatrixTransform(TransformScene2D):\n",
        "    args_list = [\n",
        "        ([[1, 3], [-2, 0]], False, False),\n",
        "        ([[1, 3], [-2, 0]], True, False),\n",
        "        ([[1, 0.5], [0.5, 1]], True, False),\n",
        "        ([[2, 0], [0, 2]], True, False),\n",
        "        ([[0.5, 0], [0, 0.5]], True, False),\n",
        "        ([[-1, 0], [0, -1]], True, False),\n",
        "        ([[0, 1], [1, 0]], True, False),\n",
        "        ([[-2, 0], [-1, -1]], True, False),\n",
        "        ([[0, -1], [1, 0]], True, False),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(matrix, with_background, show_matrix):\n",
        "        background_string = \"WithBackground\" if with_background else \"WithoutBackground\"\n",
        "        show_string = \"ShowingMatrix\" if show_matrix else \"\"\n",
        "        return matrix_to_string(matrix) + background_string + show_string\n",
        "\n",
        "    def construct(self, matrix, with_background, show_matrix):\n",
        "        matrix = np.array(matrix)\n",
        "        number_plane_config = {\n",
        "            \"density_factor\" : self.get_density_factor(matrix)\n",
        "        }\n",
        "        if with_background:\n",
        "            self.add_background()\n",
        "            number_plane_config[\"use_faded_lines\"] = False\n",
        "            self.add_number_plane(**number_plane_config)\n",
        "            self.add_x_y_arrows()\n",
        "        else:\n",
        "            self.add_number_plane(**number_plane_config)\n",
        "        if show_matrix:\n",
        "            self.add(matrix_mobject(matrix).to_corner(UP+LEFT))\n",
        "        def func(mobject):\n",
        "            mobject.get_points()[:, :2] = np.dot(mobject.get_points()[:, :2], np.transpose(matrix))\n",
        "            return mobject\n",
        "\n",
        "        self.wait()\n",
        "        kwargs = {\n",
        "            \"run_time\" : 2.0,\n",
        "            \"path_func\" : self.get_path_func(matrix)\n",
        "        }\n",
        "        anims = [ApplyFunction(func, self.number_plane, **kwargs)]\n",
        "        if hasattr(self, \"x_arrow\") and hasattr(self, \"y_arrow\"):\n",
        "            for arrow, index in (self.x_arrow, 0), (self.y_arrow, 1):\n",
        "                new_arrow = Arrow(\n",
        "                    ORIGIN,\n",
        "                    self.number_plane.num_pair_to_point(matrix[:,index]),\n",
        "                    color = arrow.get_color(),\n",
        "                    **ARROW_CONFIG\n",
        "                )\n",
        "                arrow.remove_tip()\n",
        "                new_arrow.remove_tip()\n",
        "                Mobject.align_data_and_family(arrow, new_arrow)\n",
        "                arrow.add_tip()\n",
        "                new_arrow.add_tip()\n",
        "                anims.append(Transform(arrow, new_arrow, **kwargs))\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    def get_density_factor(self, matrix):\n",
        "        max_norm = max([\n",
        "            abs(get_norm(column))\n",
        "            for column in np.transpose(matrix)\n",
        "        ])\n",
        "        return max(max_norm, 1)\n",
        "\n",
        "    def get_path_func(self, matrix):\n",
        "        rotational_components = np.array([\n",
        "            np.log(multiplier*complex(*matrix[:,i])).imag\n",
        "            for i, multiplier in [(0, 1), (1, complex(0, -1))]\n",
        "        ])\n",
        "        rotational_components[rotational_components == -np.pi] = np.pi\n",
        "        return path_along_arc(np.mean(rotational_components))\n",
        "\n",
        "\n",
        "class ExamplesOfTwoDimensionalLinearTransformations(ShowMatrixTransform):\n",
        "    args_list = []\n",
        "    @staticmethod\n",
        "    def args_to_string():\n",
        "        return \"\"\n",
        "\n",
        "    def construct(self):\n",
        "        matrices = [\n",
        "            [[1, 0.5], \n",
        "             [0.5, 1]],\n",
        "            [[0, -1],\n",
        "             [2, 0]],\n",
        "            [[1, 3],\n",
        "             [-2, 0]],\n",
        "        ]\n",
        "        for matrix in matrices:\n",
        "            self.clear()\n",
        "            ShowMatrixTransform.construct(self, matrix, False, False)\n",
        "\n",
        "\n",
        "class ExamplesOfNonlinearTwoDimensionalTransformations(Scene):\n",
        "    def construct(self):\n",
        "        Scene.construct(self)\n",
        "        def squiggle(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return (x+np.sin(y), y+np.cos(x), z)\n",
        "\n",
        "        def shift_zero(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return (2*x + 3*y + 4, -1*x+y+2, z)\n",
        "\n",
        "        self.nonlinear = OldTexText(\"Nonlinear Transform\")\n",
        "        self.nonlinear.set_color(LIGHT_RED)\n",
        "        self.nonlinear.to_edge(UP, buff = 1.5)\n",
        "        pairs = [\n",
        "            (squiggle, \"lines do not remain straight\"),\n",
        "            (shift_zero, \"the origin does not remain fixed\")\n",
        "        ]\n",
        "        self.get_blackness()\n",
        "        for function, explanation in pairs:\n",
        "            self.apply_function(function, explanation)\n",
        "\n",
        "\n",
        "    def apply_function(self, function, explanation):\n",
        "        self.clear()\n",
        "        config = {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_WIDTH,\n",
        "            \"density\" : 3*DEFAULT_POINT_DENSITY_1D,\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH\n",
        "        }\n",
        "        number_plane = NumberPlane(**config)\n",
        "        numbers = number_plane.get_coordinate_labels()\n",
        "        words = OldTexText(explanation)\n",
        "        words.set_color(LIGHT_RED)\n",
        "        words.next_to(self.nonlinear, DOWN, buff = 0.5)\n",
        "\n",
        "        self.add(number_plane, *numbers)\n",
        "        self.add(self.blackness, self.nonlinear, words)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyPointwiseFunction(function, number_plane),\n",
        "            *[\n",
        "                ApplyMethod(\n",
        "                    mob.shift,\n",
        "                    function(mob.get_center())-mob.get_center()\n",
        "                )\n",
        "                for mob in numbers\n",
        "            ] + [\n",
        "                Animation(self.blackness),\n",
        "                Animation(words),\n",
        "                Animation(self.nonlinear)\n",
        "            ],\n",
        "            run_time = 2.0\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    def get_blackness(self):\n",
        "        vertices = [\n",
        "            3.5*LEFT+1.05*UP,\n",
        "            3.5*RIGHT+1.05*UP,\n",
        "            3.5*RIGHT+2.75*UP,\n",
        "            3.5*LEFT+2.75*UP,\n",
        "        ]\n",
        "\n",
        "        region = region_from_polygon_vertices(*vertices)\n",
        "        image = disp.paint_region(region, color = WHITE)\n",
        "        self.blackness = OldTexText(\"\")\n",
        "        ImageMobject.generate_points_from_image_array(self.blackness, image)\n",
        "        self.blackness.set_color(BLACK)\n",
        "        rectangle = Rectangle(width = 7, height=1.7)\n",
        "        rectangle.set_color(WHITE)\n",
        "        rectangle.shift(self.blackness.get_center())\n",
        "        self.blackness.add(rectangle)\n",
        "        self.blackness.scale(0.95)\n",
        "\n",
        "\n",
        "class TrickyExamplesOfNonlinearTwoDimensionalTransformations(Scene):\n",
        "    def construct(self):\n",
        "        config = {\n",
        "            \"x_radius\" : 0.6*FRAME_WIDTH,\n",
        "            \"y_radius\" : 0.6*FRAME_WIDTH,\n",
        "            \"density\" : 10*DEFAULT_POINT_DENSITY_1D,\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH\n",
        "        }\n",
        "        number_plane = NumberPlane(**config)\n",
        "        phrase1, phrase2 = OldTexText([\n",
        "            \"These might look like they keep lines straight...\",\n",
        "            \"but diagonal lines get curved\"\n",
        "        ]).to_edge(UP, buff = 1.5).split()\n",
        "        phrase2.set_color(LIGHT_RED)\n",
        "        diagonal = Line(\n",
        "            DOWN*FRAME_Y_RADIUS+LEFT*FRAME_X_RADIUS,\n",
        "            UP*FRAME_Y_RADIUS+RIGHT*FRAME_X_RADIUS,\n",
        "            density = 10*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "\n",
        "        def sunrise(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return ((FRAME_Y_RADIUS+y)*x, y, z)\n",
        "\n",
        "        def squished(x_y_z):\n",
        "            (x, y, z) = x_y_z\n",
        "            return (x + np.sin(x), y+np.sin(y), z)\n",
        "\n",
        "        self.get_blackness()\n",
        "\n",
        "        self.run_function(sunrise, number_plane, phrase1)\n",
        "        self.run_function(squished, number_plane, phrase1)\n",
        "        phrase1.add(phrase2)\n",
        "        self.add(phrase1)\n",
        "        self.play(ShowCreation(diagonal))\n",
        "        self.remove(diagonal)\n",
        "        number_plane.add(diagonal)\n",
        "        self.run_function(sunrise, number_plane, phrase1)\n",
        "        self.run_function(squished, number_plane, phrase1, False)\n",
        "\n",
        "\n",
        "    def run_function(self, function, plane, phrase, remove_plane = True):\n",
        "        number_plane = deepcopy(plane)\n",
        "        self.add(number_plane, self.blackness, phrase)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyPointwiseFunction(function, number_plane, run_time = 2.0),\n",
        "            Animation(self.blackness),            \n",
        "            Animation(phrase),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        if remove_plane:\n",
        "            self.remove(number_plane)\n",
        "\n",
        "    def get_blackness(self):\n",
        "        vertices = [\n",
        "            4.5*LEFT+1.25*UP,\n",
        "            4.5*RIGHT+1.25*UP,\n",
        "            4.5*RIGHT+2.75*UP,\n",
        "            4.5*LEFT+2.75*UP,\n",
        "        ]\n",
        "\n",
        "        region = region_from_polygon_vertices(*vertices)\n",
        "        image = disp.paint_region(region, color = WHITE)\n",
        "        self.blackness = OldTexText(\"\")\n",
        "        ImageMobject.generate_points_from_image_array(self.blackness, image)\n",
        "        self.blackness.set_color(BLACK)\n",
        "        rectangle = Rectangle(width = 9, height=1.5)\n",
        "        rectangle.set_color(WHITE)\n",
        "        rectangle.shift(self.blackness.get_center())\n",
        "        self.blackness.add(rectangle)\n",
        "        self.blackness.scale(0.95)\n",
        "\n",
        "\n",
        "############# HORRIBLE! ##########################\n",
        "class ShowMatrixTransformWithDot(TransformScene2D):\n",
        "    args_list = [\n",
        "        ([[1, 3], [-2, 0]], True, False),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(matrix, with_background, show_matrix):\n",
        "        background_string = \"WithBackground\" if with_background else \"WithoutBackground\"\n",
        "        show_string = \"ShowingMatrix\" if show_matrix else \"\"\n",
        "        return matrix_to_string(matrix) + background_string + show_string\n",
        "\n",
        "    def construct(self, matrix, with_background, show_matrix):\n",
        "        matrix = np.array(matrix)\n",
        "        number_plane_config = {\n",
        "            \"density_factor\" : self.get_density_factor(matrix),\n",
        "        }\n",
        "        if with_background:\n",
        "            self.add_background()\n",
        "            number_plane_config[\"use_faded_lines\"] = False\n",
        "            self.add_number_plane(**number_plane_config)\n",
        "            self.add_x_y_arrows()\n",
        "        else:\n",
        "            self.add_number_plane(**number_plane_config)\n",
        "        if show_matrix:\n",
        "            self.add(matrix_mobject(matrix).to_corner(UP+LEFT))\n",
        "        def func(mobject):\n",
        "            mobject.get_points()[:, :2] = np.dot(mobject.get_points()[:, :2], np.transpose(matrix))\n",
        "            return mobject\n",
        "        dot = Dot((-1, 2, 0), color = \"yellow\")\n",
        "        self.add(dot)\n",
        "        x_arrow_copy = deepcopy(self.x_arrow)\n",
        "        y_arrow_copy = Arrow(LEFT, LEFT+2*UP, color = LIGHT_RED, **ARROW_CONFIG)\n",
        "\n",
        "        self.play(ApplyMethod(x_arrow_copy.rotate, np.pi))\n",
        "        self.play(ShowCreation(y_arrow_copy))\n",
        "        self.wait()\n",
        "        self.remove(x_arrow_copy, y_arrow_copy)\n",
        "        kwargs = {\n",
        "            \"run_time\" : 2.0,\n",
        "            \"path_func\" : self.get_path_func(matrix)\n",
        "        }\n",
        "        anims = [\n",
        "            ApplyFunction(func, self.number_plane, **kwargs),\n",
        "            ApplyMethod(dot.shift, func(deepcopy(dot)).get_center()-dot.get_center(), **kwargs),\n",
        "        ]\n",
        "        if hasattr(self, \"x_arrow\") and hasattr(self, \"y_arrow\"):\n",
        "            for arrow, index in (self.x_arrow, 0), (self.y_arrow, 1):\n",
        "                new_arrow = Arrow(\n",
        "                    ORIGIN,\n",
        "                    self.number_plane.num_pair_to_point(matrix[:,index]),\n",
        "                    color = arrow.get_color(),\n",
        "                    **ARROW_CONFIG\n",
        "                )\n",
        "                arrow.remove_tip()\n",
        "                new_arrow.remove_tip()\n",
        "                Mobject.align_data_and_family(arrow, new_arrow)\n",
        "                arrow.add_tip()\n",
        "                new_arrow.add_tip()\n",
        "                anims.append(Transform(arrow, new_arrow, **kwargs))\n",
        "        self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "        x_arrow_copy = deepcopy(self.x_arrow)\n",
        "        y_arrow_copy = Arrow(LEFT+2*UP, 5*RIGHT+2*UP, color = LIGHT_RED, **ARROW_CONFIG)\n",
        "        self.play(ApplyMethod(x_arrow_copy.rotate, np.pi))\n",
        "        self.play(ShowCreation(y_arrow_copy))\n",
        "        self.wait(3)\n",
        "        self.remove(x_arrow_copy, y_arrow_copy)        \n",
        "\n",
        "    def get_density_factor(self, matrix):\n",
        "        max_norm = max([\n",
        "            abs(get_norm(column))\n",
        "            for column in np.transpose(matrix)\n",
        "        ])\n",
        "        return max(max_norm, 1)\n",
        "\n",
        "    def get_path_func(self, matrix):\n",
        "        rotational_components = [\n",
        "            sign*np.arccos(matrix[i,i]/get_norm(matrix[:,i]))\n",
        "            for i in [0, 1]\n",
        "            for sign in [((-1)**i)*np.sign(matrix[1-i, i])]\n",
        "        ]\n",
        "        average_rotation = sum(rotational_components)/2\n",
        "        if abs(average_rotation) < np.pi / 2:\n",
        "            return straight_path\n",
        "        elif average_rotation > 0:\n",
        "            return counterclockwise_path()\n",
        "        else:\n",
        "            return clockwise_path()\n",
        "\n",
        "\n",
        "class Show90DegreeRotation(TransformScene2D):\n",
        "    def construct(self):\n",
        "        self.add_number_plane()\n",
        "        self.add_background()\n",
        "        self.add_x_y_arrows()\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            RotationAsTransform(mob, run_time = 2.0)\n",
        "            for mob in (self.number_plane, self.x_arrow, self.y_arrow)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n"
    ]
}