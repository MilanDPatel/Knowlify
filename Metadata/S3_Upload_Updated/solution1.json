{
    "topic": "demonstrates the concept of mass and its effect on an object's motion.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2019.clacks.question import *\n",
        "from _2018.div_curl import ShowTwoPopulations\n",
        "\n",
        "\n",
        "OUTPUT_DIRECTORY = \"clacks/solution1\"\n",
        "\n",
        "\n",
        "class FromPuzzleToSolution(MovingCameraScene):\n",
        "    def construct(self):\n",
        "        big_rect = FullScreenFadeRectangle()\n",
        "        big_rect.set_fill(GREY_D, 0.5)\n",
        "        self.add(big_rect)\n",
        "\n",
        "        rects = VGroup(ScreenRectangle(), ScreenRectangle())\n",
        "        rects.set_height(3)\n",
        "        rects.arrange(RIGHT, buff=2)\n",
        "\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Puzzle\"),\n",
        "            OldTexText(\"Solution\"),\n",
        "        )\n",
        "\n",
        "        images = Group(\n",
        "            ImageMobject(\"BlocksAndWallExampleMass16\"),\n",
        "            ImageMobject(\"AnalyzeCircleGeometry\"),\n",
        "        )\n",
        "        for title, rect, image in zip(titles, rects, images):\n",
        "            title.scale(1.5)\n",
        "            title.next_to(rect, UP)\n",
        "            image.replace(rect)\n",
        "            self.add(image, rect, title)\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        frame.save_state()\n",
        "\n",
        "        self.play(\n",
        "            frame.replace, images[0],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(frame, run_time=3))\n",
        "        self.play(\n",
        "            frame.replace, images[1],\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass16(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 16,\n",
        "                \"velocity\": -1.5,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class Mass16WithElasticLabel(Mass1e1WithElasticLabel):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 16,\n",
        "            }\n",
        "        },\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass64(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 64,\n",
        "                \"velocity\": -1.5,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMass1e4(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e4,\n",
        "                \"velocity\": -1.5,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 25,\n",
        "    }\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMassMillion(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e6,\n",
        "                \"velocity\": -0.9,\n",
        "                \"label_text\": \"$100^{3}$ kg\"\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 30,\n",
        "        \"million_fade_time\": 4,\n",
        "        \"min_time_between_sounds\": 0.002,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add_million_label()\n",
        "\n",
        "    def add_million_label(self):\n",
        "        first_label = self.blocks.block1.label\n",
        "        brace = Brace(first_label[:-2], UP, buff=SMALL_BUFF)\n",
        "        new_label = OldTex(\"1{,}000{,}000\")\n",
        "        new_label.next_to(brace, UP, buff=SMALL_BUFF)\n",
        "        new_label.add(brace)\n",
        "        new_label.set_color(YELLOW)\n",
        "\n",
        "        def update_label(label):\n",
        "            d_time = self.get_time() - self.million_fade_time\n",
        "            opacity = smooth(d_time)\n",
        "            label.set_fill(opacity=d_time)\n",
        "\n",
        "        new_label.add_updater(update_label)\n",
        "        first_label.add(new_label)\n",
        "\n",
        "\n",
        "class BlocksAndWallExampleMassTrillion(BlocksAndWallExample):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"mass\": 1e12,\n",
        "                \"velocity\": -1,\n",
        "            },\n",
        "        },\n",
        "        \"wait_time\": 30,\n",
        "        \"min_time_between_sounds\": 0.001,\n",
        "    }\n",
        "\n",
        "\n",
        "class First6DigitsOfPi(DigitsOfPi):\n",
        "    CONFIG = {\"n_digits\": 6}\n",
        "\n",
        "\n",
        "class FavoritesInDescription(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"(See the description for \\\\\\\\ some favorites)\")\n",
        "        words.scale(1.5)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class V1EqualsV2Line(Scene):\n",
        "    def construct(self):\n",
        "        line = Line(LEFT, 7 * RIGHT)\n",
        "        eq = OldTex(\"v_1\", \"=\", \"v_2\")\n",
        "        eq.set_color_by_tex(\"v_\", RED)\n",
        "        eq.next_to(RIGHT, UR, SMALL_BUFF)\n",
        "        self.play(\n",
        "            Write(eq, run_time=1),\n",
        "            ShowCreation(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PhaseSpaceTitle(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Phase space\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.next_to(title, DOWN)\n",
        "        self.add(rect)\n",
        "        self.play(Write(title, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutFindingNewVelocities(Scene):\n",
        "    CONFIG = {\n",
        "        \"floor_y\": -3,\n",
        "        \"wall_x\": -6.5,\n",
        "        \"wall_height\": 7,\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 10,\n",
        "            \"fill_color\": BLUE_E,\n",
        "            \"velocity\": -1,\n",
        "        },\n",
        "        \"block2_config\": {\"mass\": 1},\n",
        "        \"block1_start_x\": 7,\n",
        "        \"block2_start_x\": 3,\n",
        "        \"v_arrow_scale_value\": 1.0,\n",
        "        \"is_halted\": False,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.add_clack_sound_file()\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_clack_sound_file()\n",
        "        self.add_floor()\n",
        "        self.add_wall()\n",
        "        self.add_blocks()\n",
        "        self.add_velocity_labels()\n",
        "\n",
        "        self.ask_about_transfer()\n",
        "        self.show_ms_and_vs()\n",
        "        self.show_value_on_equations()\n",
        "\n",
        "    def add_clack_sound_file(self):\n",
        "        self.clack_file = os.path.join(SOUND_DIR, \"clack.wav\")\n",
        "\n",
        "    def add_floor(self):\n",
        "        floor = self.floor = Line(\n",
        "            self.wall_x * RIGHT,\n",
        "            (FRAME_WIDTH / 2) * RIGHT,\n",
        "        )\n",
        "        floor.shift(self.floor_y * UP)\n",
        "        self.add(floor)\n",
        "\n",
        "    def add_wall(self):\n",
        "        wall = self.wall = Wall(height=self.wall_height)\n",
        "        wall.move_to(\n",
        "            self.wall_x * RIGHT + self.floor_y * UP,\n",
        "            DR,\n",
        "        )\n",
        "        self.add(wall)\n",
        "\n",
        "    def add_blocks(self):\n",
        "        block1 = self.block1 = Block(**self.block1_config)\n",
        "        block2 = self.block2 = Block(**self.block2_config)\n",
        "        blocks = self.blocks = VGroup(block1, block2)\n",
        "        block1.move_to(self.block1_start_x * RIGHT + self.floor_y * UP, DOWN)\n",
        "        block2.move_to(self.block2_start_x * RIGHT + self.floor_y * UP, DOWN)\n",
        "\n",
        "        self.add_velocity_phase_space_point()\n",
        "        # Add arrows\n",
        "        for block in blocks:\n",
        "            arrow = Vector(self.block_to_v_vector(block))\n",
        "            arrow.set_color(RED)\n",
        "            arrow.set_stroke(BLACK, 1, background=True)\n",
        "            arrow.move_to(block.get_center(), RIGHT)\n",
        "            block.arrow = arrow\n",
        "            block.add(arrow)\n",
        "\n",
        "            block.v_label = DecimalNumber(\n",
        "                block.velocity,\n",
        "                num_decimal_places=2,\n",
        "                background_stroke_width=2,\n",
        "            )\n",
        "            block.v_label.set_color(RED)\n",
        "            block.add(block.v_label)\n",
        "\n",
        "        # Add updater\n",
        "        blocks.add_updater(self.update_blocks)\n",
        "        self.add(\n",
        "            blocks,\n",
        "            block2.arrow, block1.arrow,\n",
        "            block2.v_label, block1.v_label,\n",
        "        )\n",
        "\n",
        "    def add_velocity_phase_space_point(self):\n",
        "        self.vps_point = VectorizedPoint([\n",
        "            np.sqrt(self.block1.mass) * self.block1.velocity,\n",
        "            np.sqrt(self.block2.mass) * self.block2.velocity,\n",
        "            0\n",
        "        ])\n",
        "\n",
        "    def add_velocity_labels(self):\n",
        "        v_labels = self.get_next_velocity_labels()\n",
        "\n",
        "        self.add(v_labels)\n",
        "\n",
        "    def ask_about_transfer(self):\n",
        "        energy_expression, momentum_expression = \\\n",
        "            self.get_energy_and_momentum_expressions()\n",
        "        energy_words = OldTexText(\"Conservation of energy:\")\n",
        "        energy_words.move_to(UP)\n",
        "        energy_words.to_edge(LEFT, buff=1.5)\n",
        "        momentum_words = OldTexText(\"Conservation of momentum:\")\n",
        "        momentum_words.next_to(\n",
        "            energy_words, DOWN,\n",
        "            buff=0.7,\n",
        "        )\n",
        "\n",
        "        energy_expression.next_to(energy_words, RIGHT, MED_LARGE_BUFF)\n",
        "        momentum_expression.next_to(energy_expression, DOWN)\n",
        "        momentum_expression.next_to(momentum_words, RIGHT)\n",
        "\n",
        "        velocity_labels = self.all_velocity_labels\n",
        "        randy = Randolph(height=2)\n",
        "        randy.next_to(velocity_labels, DR)\n",
        "        randy.save_state()\n",
        "        randy.fade(1)\n",
        "\n",
        "        # Up to collisions\n",
        "        self.go_through_next_collision(include_velocity_label_animation=True)\n",
        "        self.play(\n",
        "            randy.restore,\n",
        "            randy.change, \"pondering\", velocity_labels[0],\n",
        "        )\n",
        "        self.halt()\n",
        "        self.play(randy.look_at, velocity_labels[-1])\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(energy_words, RIGHT),\n",
        "            FadeInFromDown(energy_expression),\n",
        "            FadeOut(randy),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(momentum_words, RIGHT),\n",
        "            FadeInFromDown(momentum_expression)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.energy_expression = energy_expression\n",
        "        self.energy_words = energy_words\n",
        "        self.momentum_expression = momentum_expression\n",
        "        self.momentum_words = momentum_words\n",
        "\n",
        "    def show_ms_and_vs(self):\n",
        "        block1 = self.block1\n",
        "        block2 = self.block2\n",
        "        energy_expression = self.energy_expression\n",
        "        momentum_expression = self.momentum_expression\n",
        "\n",
        "        for block in self.blocks:\n",
        "            block.shift_onto_screen()\n",
        "\n",
        "        m1_labels = VGroup(\n",
        "            block1.label,\n",
        "            energy_expression.get_part_by_tex(\"m_1\"),\n",
        "            momentum_expression.get_part_by_tex(\"m_1\"),\n",
        "        )\n",
        "        m2_labels = VGroup(\n",
        "            block2.label,\n",
        "            energy_expression.get_part_by_tex(\"m_2\"),\n",
        "            momentum_expression.get_part_by_tex(\"m_2\"),\n",
        "        )\n",
        "        v1_labels = VGroup(\n",
        "            block1.v_label,\n",
        "            energy_expression.get_part_by_tex(\"v_1\"),\n",
        "            momentum_expression.get_part_by_tex(\"v_1\"),\n",
        "        )\n",
        "        v2_labels = VGroup(\n",
        "            block2.v_label,\n",
        "            energy_expression.get_part_by_tex(\"v_2\"),\n",
        "            momentum_expression.get_part_by_tex(\"v_2\"),\n",
        "        )\n",
        "        label_groups = VGroup(\n",
        "            m1_labels, m2_labels,\n",
        "            v1_labels, v2_labels,\n",
        "        )\n",
        "        for group in label_groups:\n",
        "            group.rects = VGroup(*map(\n",
        "                SurroundingRectangle,\n",
        "                group\n",
        "            ))\n",
        "\n",
        "        for group in label_groups:\n",
        "            self.play(LaggedStartMap(\n",
        "                ShowCreation, group.rects,\n",
        "                lag_ratio=0.8,\n",
        "                run_time=1,\n",
        "            ))\n",
        "            self.play(FadeOut(group.rects))\n",
        "\n",
        "    def show_value_on_equations(self):\n",
        "        energy_expression = self.energy_expression\n",
        "        momentum_expression = self.momentum_expression\n",
        "        energy_text = VGroup(energy_expression, self.energy_words)\n",
        "        momentum_text = VGroup(momentum_expression, self.momentum_words)\n",
        "        block1 = self.block1\n",
        "        block2 = self.block2\n",
        "        block1.save_state()\n",
        "        block2.save_state()\n",
        "\n",
        "        v_terms, momentum_v_terms = [\n",
        "            VGroup(*[\n",
        "                expr.get_part_by_tex(\"v_{}\".format(d))\n",
        "                for d in [1, 2]\n",
        "            ])\n",
        "            for expr in [energy_expression, momentum_expression]\n",
        "        ]\n",
        "        v_braces = VGroup(*[\n",
        "            Brace(term, UP, buff=SMALL_BUFF)\n",
        "            for term in v_terms\n",
        "        ])\n",
        "        v_decimals = VGroup(*[DecimalNumber(0) for x in range(2)])\n",
        "\n",
        "        def update_v_decimals(v_decimals):\n",
        "            values = self.get_velocities()\n",
        "            for decimal, value, brace in zip(v_decimals, values, v_braces):\n",
        "                decimal.set_value(value)\n",
        "                decimal.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        update_v_decimals(v_decimals)\n",
        "\n",
        "        energy_const_brace, momentum_const_brace = [\n",
        "            Brace(\n",
        "                expr.get_part_by_tex(\"const\"), UP,\n",
        "                buff=SMALL_BUFF,\n",
        "            )\n",
        "            for expr in [energy_expression, momentum_expression]\n",
        "        ]\n",
        "\n",
        "        sqrt_m_vect = np.array([\n",
        "            np.sqrt(self.block1.mass),\n",
        "            np.sqrt(self.block2.mass),\n",
        "            0\n",
        "        ])\n",
        "\n",
        "        def get_energy():\n",
        "            return 0.5 * get_norm(self.vps_point.get_location())**2\n",
        "\n",
        "        def get_momentum():\n",
        "            return np.dot(self.vps_point.get_location(), sqrt_m_vect)\n",
        "\n",
        "        energy_decimal = DecimalNumber(get_energy())\n",
        "        energy_decimal.next_to(energy_const_brace, UP, SMALL_BUFF)\n",
        "        momentum_decimal = DecimalNumber(get_momentum())\n",
        "        momentum_decimal.next_to(momentum_const_brace, UP, SMALL_BUFF)\n",
        "\n",
        "        VGroup(\n",
        "            energy_const_brace, energy_decimal,\n",
        "            momentum_const_brace, momentum_decimal,\n",
        "        ).set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreationThenFadeAround(energy_expression),\n",
        "            momentum_text.set_fill, {\"opacity\": 0.25},\n",
        "            FadeOut(self.all_velocity_labels),\n",
        "        )\n",
        "        self.play(*[\n",
        "            *map(GrowFromCenter, v_braces),\n",
        "            *map(VFadeIn, v_decimals),\n",
        "            GrowFromCenter(energy_const_brace),\n",
        "            FadeIn(energy_decimal),\n",
        "        ])\n",
        "        energy_decimal.add_updater(\n",
        "            lambda m: m.set_value(get_energy())\n",
        "        )\n",
        "        v_decimals.add_updater(update_v_decimals)\n",
        "        self.add(v_decimals)\n",
        "        self.unhalt()\n",
        "        self.vps_point.save_state()\n",
        "        for x in range(8):\n",
        "            self.go_through_next_collision()\n",
        "        energy_decimal.clear_updaters()\n",
        "        momentum_decimal.set_value(get_momentum())\n",
        "        self.halt()\n",
        "        self.play(*[\n",
        "            momentum_text.set_fill, {\"opacity\": 1},\n",
        "            FadeOut(energy_text),\n",
        "            FadeOut(energy_const_brace),\n",
        "            FadeOut(energy_decimal),\n",
        "            GrowFromCenter(momentum_const_brace),\n",
        "            FadeIn(momentum_decimal),\n",
        "            *[\n",
        "                ApplyMethod(b.next_to, vt, UP, SMALL_BUFF)\n",
        "                for b, vt in zip(v_braces, momentum_v_terms)\n",
        "            ],\n",
        "        ])\n",
        "        self.unhalt()\n",
        "        self.vps_point.restore()\n",
        "        momentum_decimal.add_updater(\n",
        "            lambda m: m.set_value(get_momentum())\n",
        "        )\n",
        "        momentum_decimal.add_updater(\n",
        "            lambda m: m.next_to(momentum_const_brace, UP, SMALL_BUFF)\n",
        "        )\n",
        "        for x in range(9):\n",
        "            self.go_through_next_collision()\n",
        "        self.wait(10)\n",
        "\n",
        "    # Helpers\n",
        "\n",
        "    def get_energy_and_momentum_expressions(self):\n",
        "        tex_to_color_map = {\n",
        "            \"v_1\": RED_B,\n",
        "            \"v_2\": RED_B,\n",
        "            \"m_1\": BLUE_C,\n",
        "            \"m_2\": BLUE_C,\n",
        "        }\n",
        "        energy_expression = OldTex(\n",
        "            \"\\\\frac{1}{2} m_1 (v_1)^2 + \",\n",
        "            \"\\\\frac{1}{2} m_2 (v_2)^2 = \",\n",
        "            \"\\\\text{const.}\",\n",
        "            tex_to_color_map=tex_to_color_map,\n",
        "        )\n",
        "        momentum_expression = OldTex(\n",
        "            \"m_1 v_1 + m_2 v_2 =\", \"\\\\text{const.}\",\n",
        "            tex_to_color_map=tex_to_color_map\n",
        "        )\n",
        "        return VGroup(\n",
        "            energy_expression,\n",
        "            momentum_expression,\n",
        "        )\n",
        "\n",
        "    def go_through_next_collision(self, include_velocity_label_animation=False):\n",
        "        block2 = self.block2\n",
        "        if block2.velocity >= 0:\n",
        "            self.wait_until(self.blocks_are_hitting)\n",
        "            self.add_sound(self.clack_file)\n",
        "            self.transfer_momentum()\n",
        "            edge = RIGHT\n",
        "        else:\n",
        "            self.wait_until(self.block2_is_hitting_wall)\n",
        "            self.add_sound(self.clack_file)\n",
        "            self.reflect_block2()\n",
        "            edge = LEFT\n",
        "        anims = [Flash(block2.get_edge_center(edge))]\n",
        "        if include_velocity_label_animation:\n",
        "            anims.append(self.get_next_velocity_labels_animation())\n",
        "        self.play(*anims, run_time=0.5)\n",
        "\n",
        "    def get_next_velocity_labels_animation(self):\n",
        "        return FadeIn(\n",
        "            self.get_next_velocity_labels(),\n",
        "            LEFT,\n",
        "            run_time=0.5\n",
        "        )\n",
        "\n",
        "    def get_next_velocity_labels(self, v1=None, v2=None):\n",
        "        new_labels = self.get_velocity_labels(v1, v2)\n",
        "        if hasattr(self, \"all_velocity_labels\"):\n",
        "            arrow = Vector(RIGHT)\n",
        "            arrow.next_to(self.all_velocity_labels)\n",
        "            new_labels.next_to(arrow, RIGHT)\n",
        "            new_labels.add(arrow)\n",
        "        else:\n",
        "            self.all_velocity_labels = VGroup()\n",
        "        self.all_velocity_labels.add(new_labels)\n",
        "        return new_labels\n",
        "\n",
        "    def get_velocity_labels(self, v1=None, v2=None):\n",
        "        default_vs = self.get_velocities()\n",
        "        v1 = v1 or default_vs[0]\n",
        "        v2 = v2 or default_vs[1]\n",
        "        labels = VGroup(\n",
        "            OldTex(\"v_1 = {:.2f}\".format(v1)),\n",
        "            OldTex(\"v_2 = {:.2f}\".format(v2)),\n",
        "        )\n",
        "        labels.arrange(\n",
        "            DOWN,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        labels.scale(0.9)\n",
        "        for label in labels:\n",
        "            label[:2].set_color(RED)\n",
        "        labels.next_to(self.wall, RIGHT)\n",
        "        labels.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        return labels\n",
        "\n",
        "    def update_blocks(self, blocks, dt):\n",
        "        for block, velocity in zip(blocks, self.get_velocities()):\n",
        "            block.velocity = velocity\n",
        "            if not self.is_halted:\n",
        "                block.shift(block.velocity * dt * RIGHT)\n",
        "            center = block.get_center()\n",
        "            block.arrow.put_start_and_end_on(\n",
        "                center,\n",
        "                center + self.block_to_v_vector(block),\n",
        "            )\n",
        "            max_height = 0.25\n",
        "            block.v_label.set_value(block.velocity)\n",
        "            if block.v_label.get_height() > max_height:\n",
        "                block.v_label.set_height(max_height)\n",
        "            block.v_label.next_to(\n",
        "                block.arrow.get_start(), UP,\n",
        "                buff=SMALL_BUFF,\n",
        "            )\n",
        "        return blocks\n",
        "\n",
        "    def block_to_v_vector(self, block):\n",
        "        return block.velocity * self.v_arrow_scale_value * RIGHT\n",
        "\n",
        "    def blocks_are_hitting(self):\n",
        "        x1 = self.block1.get_left()[0]\n",
        "        x2 = self.block2.get_right()[0]\n",
        "        buff = 0.01\n",
        "        return (x1 < x2 + buff)\n",
        "\n",
        "    def block2_is_hitting_wall(self):\n",
        "        x2 = self.block2.get_left()[0]\n",
        "        buff = 0.01\n",
        "        return (x2 < self.wall_x + buff)\n",
        "\n",
        "    def get_velocities(self):\n",
        "        m1 = self.block1.mass\n",
        "        m2 = self.block2.mass\n",
        "        vps_coords = self.vps_point.get_location()\n",
        "        return [\n",
        "            vps_coords[0] / np.sqrt(m1),\n",
        "            vps_coords[1] / np.sqrt(m2),\n",
        "        ]\n",
        "\n",
        "    def transfer_momentum(self):\n",
        "        m1 = self.block1.mass\n",
        "        m2 = self.block2.mass\n",
        "        theta = np.arctan(np.sqrt(m2 / m1))\n",
        "        self.reflect_block2()\n",
        "        self.vps_point.rotate(2 * theta, about_point=ORIGIN)\n",
        "\n",
        "    def reflect_block2(self):\n",
        "        self.vps_point.get_points()[:, 1] *= -1\n",
        "\n",
        "    def halt(self):\n",
        "        self.is_halted = True\n",
        "\n",
        "    def unhalt(self):\n",
        "        self.is_halted = False\n",
        "\n",
        "\n",
        "class IntroduceVelocityPhaseSpace(AskAboutFindingNewVelocities):\n",
        "    CONFIG = {\n",
        "        \"wall_height\": 1.5,\n",
        "        \"floor_y\": -3.5,\n",
        "        \"block1_start_x\": 5,\n",
        "        \"block2_start_x\": 0,\n",
        "        \"axes_config\": {\n",
        "            \"x_axis_config\": {\n",
        "                \"x_min\": -5.5,\n",
        "                \"x_max\": 6,\n",
        "            },\n",
        "            \"y_axis_config\": {\n",
        "                \"x_min\": -3.5,\n",
        "                \"x_max\": 4,\n",
        "            },\n",
        "            \"axis_config\": {\n",
        "                \"unit_size\": 0.7,\n",
        "            },\n",
        "        },\n",
        "        \"momentum_line_scale_factor\": 4,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_wall_floor_and_blocks()\n",
        "        self.show_two_equations()\n",
        "        self.draw_axes()\n",
        "        self.draw_ellipse()\n",
        "        self.rescale_axes()\n",
        "        self.show_starting_point()\n",
        "        self.show_initial_collide()\n",
        "        self.ask_about_where_to_land()\n",
        "        self.show_conservation_of_momentum_equation()\n",
        "        self.show_momentum_line()\n",
        "        self.reiterate_meaning_of_line_and_circle()\n",
        "        self.reshow_first_jump()\n",
        "        self.show_bounce_off_wall()\n",
        "        self.show_reflection_about_x()\n",
        "        self.show_remaining_collisions()\n",
        "\n",
        "    def add_wall_floor_and_blocks(self):\n",
        "        self.add_floor()\n",
        "        self.add_wall()\n",
        "        self.add_blocks()\n",
        "        self.halt()\n",
        "\n",
        "    def show_two_equations(self):\n",
        "        equations = self.get_energy_and_momentum_expressions()\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        equations.shift(UP)\n",
        "        v1_terms, v2_terms = v_terms = VGroup(*[\n",
        "            VGroup(*[\n",
        "                expr.get_parts_by_tex(tex)\n",
        "                for expr in equations\n",
        "            ])\n",
        "            for tex in (\"v_1\", \"v_2\")\n",
        "        ])\n",
        "        for eq in equations:\n",
        "            eq.highlighted_copy = eq.copy()\n",
        "            eq.highlighted_copy.set_fill(opacity=0)\n",
        "            eq.highlighted_copy.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.add(equations)\n",
        "        self.play(\n",
        "            ShowCreation(equations[0].highlighted_copy),\n",
        "            run_time=0.75,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(equations[0].highlighted_copy),\n",
        "            ShowCreation(equations[1].highlighted_copy),\n",
        "            run_time=0.75,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(equations[1].highlighted_copy),\n",
        "            run_time=0.75,\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, v_terms,\n",
        "            lag_ratio=0.75,\n",
        "            rate_func=there_and_back,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.equations = equations\n",
        "\n",
        "    def draw_axes(self):\n",
        "        equations = self.equations\n",
        "        energy_expression, momentum_expression = equations\n",
        "\n",
        "        axes = self.axes = Axes(**self.axes_config)\n",
        "        axes.to_edge(UP, buff=SMALL_BUFF)\n",
        "        axes.set_stroke(width=2)\n",
        "\n",
        "        # Axes labels\n",
        "        x_axis_labels = VGroup(\n",
        "            OldTex(\"x = \", \"v_1\"),\n",
        "            OldTex(\"x = \", \"\\\\sqrt{m_1}\", \"\\\\cdot\", \"v_1\"),\n",
        "        )\n",
        "        y_axis_labels = VGroup(\n",
        "            OldTex(\"y = \", \"v_2\"),\n",
        "            OldTex(\"y = \", \"\\\\sqrt{m_2}\", \"\\\\cdot\", \"v_2\"),\n",
        "        )\n",
        "        axis_labels = self.axis_labels = VGroup(x_axis_labels, y_axis_labels)\n",
        "        for label_group in axis_labels:\n",
        "            for label in label_group:\n",
        "                label.set_color_by_tex(\"v_\", RED)\n",
        "                label.set_color_by_tex(\"m_\", BLUE)\n",
        "        for label in x_axis_labels:\n",
        "            label.next_to(axes.x_axis.get_right(), UP)\n",
        "        for label in y_axis_labels:\n",
        "            label.next_to(axes.y_axis.get_top(), DR)\n",
        "\n",
        "        # Introduce axes and labels\n",
        "        self.play(\n",
        "            equations.scale, 0.8,\n",
        "            equations.to_corner, UL, {\"buff\": MED_SMALL_BUFF},\n",
        "            Write(axes),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            momentum_expression.set_fill, {\"opacity\": 0.2},\n",
        "            Indicate(energy_expression, scale_factor=1.05),\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(2):\n",
        "            tex = \"v_{}\".format(n + 1)\n",
        "            self.play(\n",
        "                TransformFromCopy(\n",
        "                    energy_expression.get_part_by_tex(tex),\n",
        "                    axis_labels[n][0].get_part_by_tex(tex),\n",
        "                ),\n",
        "                FadeInFromDown(axis_labels[n][0][0]),\n",
        "            )\n",
        "\n",
        "        # Show vps_dot\n",
        "        vps_dot = self.vps_dot = Dot(color=RED)\n",
        "        vps_dot.set_stroke(BLACK, 2, background=True)\n",
        "        vps_dot.add_updater(\n",
        "            lambda m: m.move_to(axes.coords_to_point(\n",
        "                *self.get_velocities()\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        vps_point = self.vps_point\n",
        "        vps_point.save_state()\n",
        "        kwargs = {\n",
        "            \"path_arc\": PI / 3,\n",
        "            \"run_time\": 2,\n",
        "        }\n",
        "        target_locations = [\n",
        "            6 * RIGHT + 2 * UP,\n",
        "            6 * RIGHT + 2 * DOWN,\n",
        "            6 * LEFT + 1 * UP,\n",
        "        ]\n",
        "        self.add(vps_dot)\n",
        "        for target_location in target_locations:\n",
        "            self.play(\n",
        "                vps_point.move_to, target_location,\n",
        "                **kwargs,\n",
        "            )\n",
        "        self.play(Restore(vps_point, **kwargs))\n",
        "        self.wait()\n",
        "\n",
        "    def draw_ellipse(self):\n",
        "        vps_dot = self.vps_dot\n",
        "        vps_point = self.vps_point\n",
        "        axes = self.axes\n",
        "        energy_expression = self.equations[0]\n",
        "\n",
        "        ellipse = self.ellipse = Circle(color=YELLOW)\n",
        "        ellipse.set_stroke(BLACK, 5, background=True)\n",
        "        ellipse.rotate(PI)\n",
        "        mass_ratio = self.block1.mass / self.block2.mass\n",
        "        ellipse.replace(\n",
        "            Polygon(*[\n",
        "                axes.coords_to_point(x, y * np.sqrt(mass_ratio))\n",
        "                for x, y in [(1, 0), (0, 1), (-1, 0), (0, -1)]\n",
        "            ]),\n",
        "            stretch=True\n",
        "        )\n",
        "\n",
        "        self.play(Indicate(energy_expression, scale_factor=1.05))\n",
        "        self.add(ellipse, vps_dot)\n",
        "        self.play(\n",
        "            ShowCreation(ellipse),\n",
        "            Rotating(vps_point, about_point=ORIGIN),\n",
        "            run_time=6,\n",
        "            rate_func=lambda t: smooth(t, 3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def rescale_axes(self):\n",
        "        ellipse = self.ellipse\n",
        "        axis_labels = self.axis_labels\n",
        "        equations = self.equations\n",
        "        vps_point = self.vps_point\n",
        "        vps_dot = self.vps_dot\n",
        "        vps_dot.clear_updaters()\n",
        "        vps_dot.add_updater(\n",
        "            lambda m: m.move_to(ellipse.get_left())\n",
        "        )\n",
        "\n",
        "        mass_ratio = self.block1.mass / self.block2.mass\n",
        "        brief_circle = ellipse.copy()\n",
        "        brief_circle.stretch(np.sqrt(mass_ratio), 0)\n",
        "        brief_circle.set_stroke(WHITE, 2)\n",
        "\n",
        "        xy_equation = self.xy_equation = OldTex(\n",
        "            \"\\\\frac{1}{2}\",\n",
        "            \"\\\\left(\", \"x^2\", \"+\", \"y^2\", \"\\\\right)\",\n",
        "            \"=\", \"\\\\text{const.}\"\n",
        "        )\n",
        "        xy_equation.scale(0.8)\n",
        "        xy_equation.next_to(equations[0], DOWN)\n",
        "\n",
        "        self.play(ShowCreationThenFadeOut(brief_circle))\n",
        "        for i, labels, block in zip(it.count(), axis_labels, self.blocks):\n",
        "            self.play(ShowCreationThenFadeAround(labels[0]))\n",
        "            self.play(\n",
        "                ReplacementTransform(labels[0][0], labels[1][0]),\n",
        "                ReplacementTransform(labels[0][-1], labels[1][-1]),\n",
        "                FadeInFromDown(labels[1][1:-1]),\n",
        "                ellipse.stretch, np.sqrt(block.mass), i,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        vps_dot.clear_updaters()\n",
        "        vps_dot.add_updater(\n",
        "            lambda m: m.move_to(self.axes.coords_to_point(\n",
        "                *self.vps_point.get_location()[:2]\n",
        "            ))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(xy_equation, UP),\n",
        "            FadeOut(equations[1])\n",
        "        )\n",
        "        self.wait()\n",
        "        curr_x = vps_point.get_location()[0]\n",
        "        for x in [0.5 * curr_x, 2 * curr_x, curr_x]:\n",
        "            axes_center = self.axes.coords_to_point(0, 0)\n",
        "            self.play(\n",
        "                vps_point.move_to, x * RIGHT,\n",
        "                UpdateFromFunc(\n",
        "                    ellipse,\n",
        "                    lambda m: m.set_width(\n",
        "                        2 * get_norm(\n",
        "                            vps_dot.get_center() - axes_center,\n",
        "                        ),\n",
        "                    ).move_to(axes_center)\n",
        "                ),\n",
        "                run_time=2,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def show_starting_point(self):\n",
        "        vps_dot = self.vps_dot\n",
        "        block1, block2 = self.blocks\n",
        "\n",
        "        self.unhalt()\n",
        "        self.wait(3)\n",
        "        self.halt()\n",
        "        self.play(ShowCreationThenFadeAround(vps_dot))\n",
        "        self.wait()\n",
        "\n",
        "    def show_initial_collide(self):\n",
        "        self.unhalt()\n",
        "        self.go_through_next_collision()\n",
        "        self.wait()\n",
        "        self.halt()\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_where_to_land(self):\n",
        "        self.play(\n",
        "            Rotating(\n",
        "                self.vps_point,\n",
        "                about_point=ORIGIN,\n",
        "                run_time=6,\n",
        "                rate_func=lambda t: smooth(t, 3),\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_conservation_of_momentum_equation(self):\n",
        "        equations = self.equations\n",
        "        energy_expression, momentum_expression = equations\n",
        "        momentum_expression.set_fill(opacity=1)\n",
        "        momentum_expression.shift(MED_SMALL_BUFF * UP)\n",
        "        momentum_expression.shift(MED_SMALL_BUFF * LEFT)\n",
        "        xy_equation = self.xy_equation\n",
        "\n",
        "        momentum_xy_equation = self.momentum_xy_equation = OldTex(\n",
        "            \"\\\\sqrt{m_1}\", \"x\", \"+\",\n",
        "            \"\\\\sqrt{m_2}\", \"y\", \"=\",\n",
        "            \"\\\\text{const.}\",\n",
        "        )\n",
        "        momentum_xy_equation.set_color_by_tex(\"m_\", BLUE)\n",
        "        momentum_xy_equation.scale(0.8)\n",
        "        momentum_xy_equation.next_to(\n",
        "            momentum_expression, DOWN,\n",
        "            buff=MED_LARGE_BUFF,\n",
        "            aligned_edge=RIGHT,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(xy_equation),\n",
        "            energy_expression.set_fill, {\"opacity\": 0.2},\n",
        "            FadeInFromDown(momentum_expression)\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(momentum_expression))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(momentum_xy_equation, UP))\n",
        "        self.wait()\n",
        "\n",
        "    def show_momentum_line(self):\n",
        "        vps_dot = self.vps_dot\n",
        "        m1 = self.block1.mass\n",
        "        m2 = self.block2.mass\n",
        "        line = Line(np.sqrt(m2) * LEFT, np.sqrt(m1) * DOWN)\n",
        "        line.scale(self.momentum_line_scale_factor)\n",
        "        line.set_stroke(GREEN, 3)\n",
        "        line.move_to(vps_dot)\n",
        "\n",
        "        slope_label = OldTex(\n",
        "            \"\\\\text{Slope =}\", \"-\\\\sqrt{\\\\frac{m_1}{m_2}}\"\n",
        "        )\n",
        "        slope_label.scale(0.8)\n",
        "        slope_label.next_to(vps_dot, LEFT, LARGE_BUFF)\n",
        "        slope_arrow = Arrow(\n",
        "            slope_label.get_right(),\n",
        "            line.point_from_proportion(0.45),\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        slope_group = VGroup(line, slope_label, slope_arrow)\n",
        "        foreground_mobs = VGroup(\n",
        "            self.equations[1], self.momentum_xy_equation,\n",
        "            self.blocks, self.vps_dot\n",
        "        )\n",
        "        for mob in foreground_mobs:\n",
        "            if isinstance(mob, Tex):\n",
        "                mob.set_stroke(BLACK, 3, background=True)\n",
        "\n",
        "        self.add(line, *foreground_mobs)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(\n",
        "            FadeIn(slope_label, RIGHT),\n",
        "            GrowArrow(slope_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(slope_group, *foreground_mobs)\n",
        "        self.play(slope_group.shift, 4 * RIGHT, run_time=3)\n",
        "        self.play(slope_group.shift, 5 * LEFT, run_time=3)\n",
        "        self.play(\n",
        "            slope_group.shift, RIGHT,\n",
        "            run_time=1,\n",
        "            rate_func=lambda t: t**4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.momentum_line = line\n",
        "        self.slope_group = slope_group\n",
        "\n",
        "    def reiterate_meaning_of_line_and_circle(self):\n",
        "        line_vect = self.momentum_line.get_vector()\n",
        "        vps_point = self.vps_point\n",
        "\n",
        "        for x in [0.25, -0.5, 0.25]:\n",
        "            self.play(\n",
        "                vps_point.shift, x * line_vect,\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Rotating(\n",
        "            vps_point,\n",
        "            about_point=ORIGIN,\n",
        "            rate_func=lambda t: smooth(t, 3),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def reshow_first_jump(self):\n",
        "        vps_point = self.vps_point\n",
        "        curr_point = vps_point.get_location()\n",
        "        start_point = get_norm(curr_point) * LEFT\n",
        "\n",
        "        for n in range(8):\n",
        "            vps_point.move_to(\n",
        "                [start_point, curr_point][n % 2]\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "\n",
        "    def show_bounce_off_wall(self):\n",
        "        self.unhalt()\n",
        "        self.go_through_next_collision()\n",
        "        self.halt()\n",
        "\n",
        "    def show_reflection_about_x(self):\n",
        "        vps_point = self.vps_point\n",
        "\n",
        "        curr_location = vps_point.get_location()\n",
        "        old_location = np.array(curr_location)\n",
        "        old_location[1] *= -1\n",
        "\n",
        "        # self.play(\n",
        "        #     ApplyMethod(\n",
        "        #         self.block2.move_to, self.wall.get_corner(DR), DL,\n",
        "        #         path_arc=30 * DEGREES,\n",
        "        #     )\n",
        "        # )\n",
        "        for n in range(4):\n",
        "            self.play(\n",
        "                vps_point.move_to,\n",
        "                [old_location, curr_location][n % 2]\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        group = VGroup(\n",
        "            self.ellipse,\n",
        "            self.lines[-1],\n",
        "            self.vps_dot.copy().clear_updaters()\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                Rotate(\n",
        "                    group, PI, RIGHT,\n",
        "                    about_point=self.axes.coords_to_point(0, 0)\n",
        "                ),\n",
        "            )\n",
        "        self.remove(group[-1])\n",
        "\n",
        "    def show_remaining_collisions(self):\n",
        "        line = self.momentum_line\n",
        "        # slope_group = self.slope_group\n",
        "        vps_dot = self.vps_dot\n",
        "        axes = self.axes\n",
        "        slope = np.sqrt(self.block2.mass / self.block1.mass)\n",
        "\n",
        "        end_region = Polygon(\n",
        "            axes.coords_to_point(0, 0),\n",
        "            axes.coords_to_point(10, 0),\n",
        "            axes.coords_to_point(10, slope * 10),\n",
        "            stroke_width=0,\n",
        "            fill_color=GREEN,\n",
        "            fill_opacity=0.3\n",
        "        )\n",
        "\n",
        "        self.unhalt()\n",
        "        for x in range(7):\n",
        "            self.go_through_next_collision()\n",
        "            if x == 0:\n",
        "                self.halt()\n",
        "                self.play(line.move_to, vps_dot)\n",
        "                self.wait()\n",
        "                self.unhalt()\n",
        "        self.play(FadeIn(end_region))\n",
        "        self.go_through_next_collision()\n",
        "        self.wait(5)\n",
        "\n",
        "    # Helpers\n",
        "    def add_update_line(self, func):\n",
        "        if not hasattr(self, \"lines\"):\n",
        "            self.lines = VGroup()\n",
        "        if hasattr(self, \"vps_dot\"):\n",
        "            old_vps_point = self.vps_dot.get_center()\n",
        "            func()\n",
        "            self.vps_dot.update()\n",
        "            new_vps_point = self.vps_dot.get_center()\n",
        "            line = Line(old_vps_point, new_vps_point)\n",
        "            line.set_stroke(WHITE, 2)\n",
        "            self.add(line)\n",
        "            self.lines.add(line)\n",
        "        else:\n",
        "            func()\n",
        "\n",
        "    def transfer_momentum(self):\n",
        "        self.add_update_line(super().transfer_momentum)\n",
        "\n",
        "    def reflect_block2(self):\n",
        "        self.add_update_line(super().reflect_block2)\n",
        "\n",
        "\n",
        "class IntroduceVelocityPhaseSpaceWith16(IntroduceVelocityPhaseSpace):\n",
        "    CONFIG = {\n",
        "        \"block1_config\": {\n",
        "            \"mass\": 16,\n",
        "            \"velocity\": -0.5,\n",
        "        },\n",
        "        \"momentum_line_scale_factor\": 0,\n",
        "    }\n",
        "\n",
        "\n",
        "class SimpleRect(Scene):\n",
        "    def construct(self):\n",
        "        self.add(Rectangle(width=6, height=2, color=WHITE))\n",
        "\n",
        "\n",
        "class SurprisedRandy(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"surprised\", 3 * UR)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"pondering\", 3 * UR)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(randy))\n",
        "\n",
        "\n",
        "class HuntForPi(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Hunt for $\\\\pi$!\",\n",
        "            bubble_config={\"direction\": LEFT},\n",
        "            target_mode=\"hooray\"\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"hooray\",\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class StretchBySqrt10(Scene):\n",
        "    def construct(self):\n",
        "        arrow = DoubleArrow(2 * LEFT, 2 * RIGHT)\n",
        "        arrow.tip[1].shift(0.05 * LEFT)\n",
        "        value = OldTex(\"\\\\sqrt{10}\")\n",
        "        value.next_to(arrow, UP)\n",
        "        arrow.save_state()\n",
        "        arrow.stretch(0, 0)\n",
        "        self.play(\n",
        "            Restore(arrow),\n",
        "            Write(value, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class XCoordNegative(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height=4, width=4)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(RED, 0.5)\n",
        "        rect.save_state()\n",
        "        rect.stretch(0, 0, about_edge=RIGHT)\n",
        "        self.play(Restore(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class YCoordZero(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height=4, width=8)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(WHITE, 0.5)\n",
        "        rect.save_state()\n",
        "        self.play(\n",
        "            rect.stretch, 0.01, 1,\n",
        "            rect.set_fill, {\"opacity\": 1}\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CircleDiagramFromSlidingBlocks(Scene):\n",
        "    CONFIG = {\n",
        "        \"BlocksAndWallSceneClass\": BlocksAndWallExampleMass1e1,\n",
        "        \"circle_config\": {\n",
        "            \"radius\": 2,\n",
        "            \"stroke_color\": YELLOW,\n",
        "            \"stroke_width\": 3,\n",
        "        },\n",
        "        \"lines_style\": {\n",
        "            \"stroke_color\": WHITE,\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"style\": {\n",
        "                \"stroke_color\": GREY_B,\n",
        "                \"stroke_width\": 1,\n",
        "            },\n",
        "            \"width\": 5,\n",
        "            \"height\": 4.5,\n",
        "        },\n",
        "        \"end_zone_style\": {\n",
        "            \"stroke_width\": 0,\n",
        "            \"fill_color\": GREEN,\n",
        "            \"fill_opacity\": 0.3,\n",
        "        },\n",
        "        \"show_dot\": True,\n",
        "        \"show_vector\": False,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        sliding_blocks_scene = self.BlocksAndWallSceneClass(\n",
        "            show_flash_animations=False,\n",
        "            write_to_movie=False,\n",
        "            wait_time=0,\n",
        "            file_writer_config={\n",
        "                \"output_directory\": \".\",\n",
        "            }\n",
        "        )\n",
        "        blocks = sliding_blocks_scene.blocks\n",
        "        times = [pair[1] for pair in blocks.clack_data]\n",
        "        self.mass_ratio = 1 / blocks.mass_ratio\n",
        "        self.show_circle_lines(\n",
        "            times=times,\n",
        "            slope=(-1 / np.sqrt(blocks.mass_ratio))\n",
        "        )\n",
        "\n",
        "    def show_circle_lines(self, times, slope):\n",
        "        circle = self.get_circle()\n",
        "        axes = self.get_axes()\n",
        "        lines = self.get_lines(circle.radius, slope)\n",
        "        end_zone = self.get_end_zone()\n",
        "\n",
        "        dot = Dot(color=RED, radius=0.06)\n",
        "        dot.move_to(lines[0].get_start())\n",
        "\n",
        "        vector = Vector(lines[0].get_start())\n",
        "        vector.set_color(RED)\n",
        "        vector.add_updater(lambda v: v.put_start_and_end_on(\n",
        "            ORIGIN, dot.get_center()\n",
        "        ))\n",
        "        vector.set_stroke(BLACK, 2, background=True)\n",
        "\n",
        "        dot.set_opacity(int(self.show_dot))\n",
        "        vector.set_opacity(int(self.show_vector))\n",
        "\n",
        "        self.add(end_zone, axes, circle, dot, vector)\n",
        "\n",
        "        last_time = 0\n",
        "        for time, line in zip(times, lines):\n",
        "            if time > 300:\n",
        "                time = last_time + 1\n",
        "            self.wait(time - last_time)\n",
        "            last_time = time\n",
        "            dot.move_to(line.get_end())\n",
        "            self.add(line, dot, vector)\n",
        "        self.wait()\n",
        "\n",
        "    def get_circle(self):\n",
        "        circle = Circle(**self.circle_config)\n",
        "        circle.rotate(PI)  # Nice to have start point on left\n",
        "        return circle\n",
        "\n",
        "    def get_axes(self):\n",
        "        config = self.axes_config\n",
        "        axes = VGroup(\n",
        "            Line(LEFT, RIGHT).set_width(config[\"width\"]),\n",
        "            Line(DOWN, UP).set_height(config[\"height\"])\n",
        "        )\n",
        "        axes.set_style(**config[\"style\"])\n",
        "        return axes\n",
        "\n",
        "    def get_lines(self, radius, slope):\n",
        "        theta = np.arctan(-1 / slope)\n",
        "        n_clacks = int(PI / theta)\n",
        "        points = []\n",
        "        for n in range(n_clacks + 1):\n",
        "            theta_mult = (n + 1) // 2\n",
        "            angle = 2 * theta * theta_mult\n",
        "            if n % 2 == 0:\n",
        "                angle *= -1\n",
        "            new_point = radius * np.array([\n",
        "                -np.cos(angle), -np.sin(angle), 0\n",
        "            ])\n",
        "            points.append(new_point)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(p1, p2)\n",
        "            for p1, p2 in zip(points, points[1:])\n",
        "        ])\n",
        "        lines.set_style(**self.lines_style)\n",
        "        return lines\n",
        "\n",
        "    def get_end_zone(self):\n",
        "        slope = 1 / np.sqrt(self.mass_ratio)\n",
        "        x = self.axes_config[\"width\"] / 2\n",
        "        zone = Polygon(\n",
        "            ORIGIN, x * RIGHT, x * RIGHT + slope * x * UP,\n",
        "        )\n",
        "        zone.set_style(**self.end_zone_style)\n",
        "        return zone\n",
        "\n",
        "\n",
        "class CircleDiagramFromSlidingBlocksSameMass(CircleDiagramFromSlidingBlocks):\n",
        "    CONFIG = {\n",
        "        \"BlocksAndWallSceneClass\": BlocksAndWallExampleSameMass\n",
        "    }\n",
        "\n",
        "\n",
        "class CircleDiagramFromSlidingBlocksSameMass1e1(CircleDiagramFromSlidingBlocks):\n",
        "    CONFIG = {\n",
        "        \"BlocksAndWallSceneClass\": BlocksAndWallExampleMass1e1\n",
        "    }\n",
        "\n",
        "\n",
        "class CircleDiagramFromSlidingBlocks1e2(CircleDiagramFromSlidingBlocks):\n",
        "    CONFIG = {\n",
        "        \"BlocksAndWallSceneClass\": BlocksAndWallExampleMass1e2\n",
        "    }\n",
        "\n",
        "\n",
        "class CircleDiagramFromSlidingBlocks1e4(CircleDiagramFromSlidingBlocks):\n",
        "    CONFIG = {\n",
        "        \"BlocksAndWallSceneClass\": BlocksAndWallExampleMass1e4\n",
        "    }\n",
        "\n",
        "\n",
        "class AnnouncePhaseDiagram(CircleDiagramFromSlidingBlocks):\n",
        "    def construct(self):\n",
        "        pd_words = OldTexText(\"Phase diagram\")\n",
        "        pd_words.scale(1.5)\n",
        "        pd_words.move_to(self.hold_up_spot, DOWN)\n",
        "        pd_words_border = pd_words.copy()\n",
        "        pd_words_border.set_stroke(YELLOW, 2)\n",
        "        pd_words_border.set_fill(opacity=0)\n",
        "\n",
        "        simple_words = OldTexText(\"Simple but powerful\")\n",
        "        simple_words.next_to(pd_words, UP, LARGE_BUFF)\n",
        "        simple_words.shift(LEFT)\n",
        "        simple_words.set_color(BLUE)\n",
        "        simple_arrow = Arrow(\n",
        "            simple_words.get_bottom(),\n",
        "            pd_words.get_top(),\n",
        "            color=simple_words.get_color(),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(pd_words)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"pondering\",\n",
        "            added_anims=[ShowCreationThenFadeOut(pd_words_border)]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(simple_words, RIGHT),\n",
        "            GrowArrow(simple_arrow),\n",
        "            self.teacher.change, \"hooray\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"thinking\", \"happy\", \"thinking\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class AnalyzeCircleGeometry(CircleDiagramFromSlidingBlocks, MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"mass_ratio\": 16,\n",
        "        \"circle_config\": {\n",
        "            \"radius\": 3,\n",
        "        },\n",
        "        \"axes_config\": {\n",
        "            \"width\": FRAME_WIDTH,\n",
        "            \"height\": FRAME_HEIGHT,\n",
        "        },\n",
        "        \"lines_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_mass_ratio_label()\n",
        "        self.add_circle_with_lines()\n",
        "        self.show_equal_arc_lengths()\n",
        "        self.use_arc_lengths_to_count()\n",
        "        self.focus_on_three_points()\n",
        "        self.show_likewise_for_all_jumps()\n",
        "        self.drop_arc_for_each_hop()\n",
        "        self.try_adding_one_more_arc()\n",
        "        self.zoom_out()\n",
        "\n",
        "    def add_mass_ratio_label(self, mass_ratio=None):\n",
        "        mass_ratio = mass_ratio or self.mass_ratio\n",
        "        mass_ratio_label = OldTexText(\n",
        "            \"Mass ratio =\", \"{:,} : 1\".format(mass_ratio)\n",
        "        )\n",
        "        mass_ratio_label.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        self.add(mass_ratio_label)\n",
        "        self.mass_ratio_label = mass_ratio_label\n",
        "\n",
        "    def add_circle_with_lines(self):\n",
        "        circle = self.get_circle()\n",
        "        axes = self.get_axes()\n",
        "        axes_labels = self.get_axes_labels(axes)\n",
        "        slope = -np.sqrt(self.mass_ratio)\n",
        "        lines = self.get_lines(\n",
        "            radius=circle.radius,\n",
        "            slope=slope,\n",
        "        )\n",
        "        end_zone = self.get_end_zone()\n",
        "\n",
        "        end_zone_words = OldTexText(\"End zone\")\n",
        "        end_zone_words.set_height(0.25)\n",
        "        end_zone_words.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "        end_zone_words.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        end_zone_words.set_color(GREEN)\n",
        "\n",
        "        self.add(\n",
        "            axes, axes_labels,\n",
        "            circle, end_zone, end_zone_words,\n",
        "        )\n",
        "        self.play(ShowCreation(lines, run_time=3, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            circle, axes, lines,\n",
        "            end_zone, end_zone_words,\n",
        "        )\n",
        "\n",
        "    def show_equal_arc_lengths(self):\n",
        "        circle = self.circle\n",
        "        radius = circle.radius\n",
        "        theta = self.theta = np.arctan(1 / np.sqrt(self.mass_ratio))\n",
        "        n_arcs = int(PI / (2 * theta))\n",
        "\n",
        "        lower_arcs = VGroup(*[\n",
        "            Arc(\n",
        "                start_angle=(PI + n * 2 * theta),\n",
        "                angle=(2 * theta),\n",
        "                radius=radius\n",
        "            )\n",
        "            for n in range(n_arcs + 1)\n",
        "        ])\n",
        "        lower_arcs[0::2].set_color(RED)\n",
        "        lower_arcs[1::2].set_color(BLUE)\n",
        "\n",
        "        upper_arcs = lower_arcs.copy()\n",
        "        upper_arcs.rotate(PI, axis=RIGHT, about_point=ORIGIN)\n",
        "        upper_arcs[0::2].set_color(BLUE)\n",
        "        upper_arcs[1::2].set_color(RED)\n",
        "\n",
        "        all_arcs = VGroup(*it.chain(*zip(lower_arcs, upper_arcs)))\n",
        "        if int(PI / theta) % 2 == 1:\n",
        "            all_arcs.remove(all_arcs[-1])\n",
        "\n",
        "        arc_copies = lower_arcs.copy()\n",
        "        for arc_copy in arc_copies:\n",
        "            arc_copy.generate_target()\n",
        "        for arc in arc_copies:\n",
        "            arc.target.rotate(-(arc.start_angle - PI + theta))\n",
        "\n",
        "        equal_signs = VGroup(*[\n",
        "            OldTex(\"=\") for x in range(len(lower_arcs))\n",
        "        ])\n",
        "        equal_signs.scale(0.8)\n",
        "        for sign in equal_signs:\n",
        "            sign.generate_target()\n",
        "\n",
        "        movers = VGroup(*it.chain(*zip(\n",
        "            arc_copies, equal_signs\n",
        "        )))\n",
        "        movers.remove(movers[-1])\n",
        "        mover_targets = VGroup(*[mover.target for mover in movers])\n",
        "        mover_targets.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        mover_targets.next_to(ORIGIN, DOWN)\n",
        "        mover_targets.to_edge(LEFT)\n",
        "\n",
        "        equal_signs.scale(0)\n",
        "        equal_signs.fade(1)\n",
        "        equal_signs.move_to(mover_targets)\n",
        "\n",
        "        all_arcs.save_state()\n",
        "        for arc in all_arcs:\n",
        "            arc.rotate(90 * DEGREES)\n",
        "            arc.fade(1)\n",
        "            arc.set_stroke(width=20)\n",
        "        self.play(Restore(\n",
        "            all_arcs, lag_ratio=0.5,\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(MoveToTarget, movers))\n",
        "        self.wait()\n",
        "\n",
        "        self.arcs_equation = movers\n",
        "        self.lower_arcs = lower_arcs\n",
        "        self.upper_arcs = upper_arcs\n",
        "        self.all_arcs = all_arcs\n",
        "\n",
        "    def use_arc_lengths_to_count(self):\n",
        "        all_arcs = self.all_arcs\n",
        "        lines = self.lines\n",
        "\n",
        "        arc_counts = VGroup()\n",
        "        for n, arc in enumerate(all_arcs):\n",
        "            count_mob = Integer(n + 1)\n",
        "            count_mob.scale(0.75)\n",
        "            buff = SMALL_BUFF\n",
        "            if len(all_arcs) > 100:\n",
        "                count_mob.scale(0.1)\n",
        "                count_mob.set_stroke(WHITE, 0.25)\n",
        "                buff = 0.4 * SMALL_BUFF\n",
        "            point = arc.point_from_proportion(0.5)\n",
        "            count_mob.next_to(point, normalize(point), buff)\n",
        "            arc_counts.add(count_mob)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(lines),\n",
        "            FadeOut(all_arcs),\n",
        "            FadeOut(self.arcs_equation),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(all_arcs),\n",
        "            ShowIncreasingSubsets(lines),\n",
        "            ShowIncreasingSubsets(arc_counts),\n",
        "            run_time=5,\n",
        "            rate_func=bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for group in all_arcs, arc_counts:\n",
        "            targets = VGroup()\n",
        "            for elem in group:\n",
        "                elem.generate_target()\n",
        "                targets.add(elem.target)\n",
        "            targets.space_out_submobjects(1.2)\n",
        "\n",
        "        kwargs = {\n",
        "            \"rate_func\": there_and_back,\n",
        "            \"run_time\": 3,\n",
        "        }\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, all_arcs, **kwargs),\n",
        "            LaggedStartMap(MoveToTarget, arc_counts, **kwargs),\n",
        "        )\n",
        "\n",
        "        self.arc_counts = arc_counts\n",
        "\n",
        "    def focus_on_three_points(self):\n",
        "        lines = self.lines\n",
        "        arcs = self.all_arcs\n",
        "        arc_counts = self.arc_counts\n",
        "        theta = self.theta\n",
        "\n",
        "        arc = arcs[4]\n",
        "\n",
        "        lines.save_state()\n",
        "        line_pair = lines[3:5]\n",
        "        lines_to_fade = VGroup(*lines[:3], *lines[5:])\n",
        "\n",
        "        three_points = [\n",
        "            line_pair[0].get_start(),\n",
        "            line_pair[1].get_start(),\n",
        "            line_pair[1].get_end(),\n",
        "        ]\n",
        "        three_dots = VGroup(*map(Dot, three_points))\n",
        "        three_dots.set_color(RED)\n",
        "\n",
        "        theta_arc = Arc(\n",
        "            radius=1,\n",
        "            start_angle=-90 * DEGREES,\n",
        "            angle=theta\n",
        "        )\n",
        "        theta_arc.shift(three_points[1])\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.next_to(theta_arc, DOWN, SMALL_BUFF)\n",
        "\n",
        "        center_lines = VGroup(\n",
        "            Line(three_points[0], ORIGIN),\n",
        "            Line(ORIGIN, three_points[2]),\n",
        "        )\n",
        "        center_lines.match_style(line_pair)\n",
        "\n",
        "        two_theta_arc = Arc(\n",
        "            radius=1,\n",
        "            start_angle=(center_lines[0].get_angle() + PI),\n",
        "            angle=2 * theta\n",
        "        )\n",
        "        two_theta_label = OldTex(\"2\\\\theta\")\n",
        "        arc_center = two_theta_arc.point_from_proportion(0.5)\n",
        "        two_theta_label.next_to(\n",
        "            arc_center, normalize(arc_center), SMALL_BUFF\n",
        "        )\n",
        "        two_theta_label.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        to_fade = VGroup(arc_counts, arcs, lines_to_fade)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut, VGroup(*to_fade.family_members_with_points())\n",
        "            )\n",
        "        )\n",
        "        lines_to_fade.fade(1)\n",
        "        self.play(FadeInFromLarge(three_dots[0]))\n",
        "        self.play(TransformFromCopy(*three_dots[:2]))\n",
        "        self.play(TransformFromCopy(*three_dots[1:3]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(theta_arc),\n",
        "            FadeIn(theta_label, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            line_pair.set_stroke, WHITE, 1,\n",
        "            TransformFromCopy(line_pair, center_lines),\n",
        "            TransformFromCopy(theta_arc, two_theta_arc),\n",
        "            TransformFromCopy(theta_label, two_theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(two_theta_arc, arc),\n",
        "            two_theta_label.move_to, 2.7 * arc_center,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.three_dots = three_dots\n",
        "        self.theta_group = VGroup(theta_arc, theta_label)\n",
        "        self.center_lines_group = VGroup(\n",
        "            center_lines, two_theta_arc,\n",
        "        )\n",
        "        self.two_theta_label = two_theta_label\n",
        "\n",
        "    def show_likewise_for_all_jumps(self):\n",
        "        lines = self.lines\n",
        "        arcs = self.all_arcs\n",
        "\n",
        "        every_other_line = lines[::2]\n",
        "\n",
        "        self.play(\n",
        "            Restore(\n",
        "                lines,\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            ),\n",
        "            FadeOut(self.center_lines_group),\n",
        "            FadeOut(self.three_dots),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyFunction, every_other_line,\n",
        "            lambda line: (\n",
        "                lambda l: l.scale(10 / l.get_length()).set_stroke(BLUE, 3),\n",
        "                line\n",
        "            )\n",
        "        ))\n",
        "        self.play(Restore(lines))\n",
        "        self.wait()\n",
        "\n",
        "        # Shift theta label\n",
        "        last_point = lines[3].get_end()\n",
        "        last_arc = arcs[4]\n",
        "        two_theta_label = self.two_theta_label\n",
        "        theta_group_copy = self.theta_group.copy()\n",
        "        for line, arc in zip(lines[5:10:2], arcs[6:11:2]):\n",
        "            new_point = line.get_end()\n",
        "            arc_point = arc.point_from_proportion(0.5)\n",
        "            self.play(\n",
        "                theta_group_copy.shift, new_point - last_point,\n",
        "                two_theta_label.move_to, 1.1 * arc_point,\n",
        "                FadeIn(arc),\n",
        "                FadeOut(last_arc),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_point = new_point\n",
        "            last_arc = arc\n",
        "        self.play(\n",
        "            FadeOut(theta_group_copy),\n",
        "            FadeOut(two_theta_label),\n",
        "            FadeOut(last_arc),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def drop_arc_for_each_hop(self):\n",
        "        lines = self.lines\n",
        "        arcs = self.all_arcs\n",
        "\n",
        "        two_theta_labels = VGroup()\n",
        "        wedges = VGroup()\n",
        "        for arc in arcs:\n",
        "            label = OldTex(\"2\\\\theta\")\n",
        "            label.scale(0.8)\n",
        "            label.move_to(1.1 * arc.point_from_proportion(0.5))\n",
        "            two_theta_labels.add(label)\n",
        "\n",
        "            wedge = arc.copy()\n",
        "            wedge.add_line_to(ORIGIN)\n",
        "            wedge.add_line_to(wedge.get_points()[0])\n",
        "            wedge.set_stroke(width=0)\n",
        "            wedge.set_fill(arc.get_color(), 0.2)\n",
        "            wedges.add(wedge)\n",
        "\n",
        "        self.remove(lines)\n",
        "        for line, arc, label, wedge in zip(lines, arcs, two_theta_labels, wedges):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeIn(arc, normalize(arc.get_center())),\n",
        "                FadeIn(label, normalize(arc.get_center())),\n",
        "                FadeIn(wedge),\n",
        "            )\n",
        "\n",
        "        self.wedges = wedges\n",
        "        self.two_theta_labels = two_theta_labels\n",
        "\n",
        "    def try_adding_one_more_arc(self):\n",
        "        wedges = self.wedges\n",
        "        theta = self.theta\n",
        "\n",
        "        last_wedge = wedges[-1]\n",
        "        new_wedge = last_wedge.copy()\n",
        "        new_wedge.set_color(PURPLE)\n",
        "        new_wedge.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(FadeIn(new_wedge))\n",
        "        for angle in [-2 * theta, 4 * DEGREES, -2 * DEGREES]:\n",
        "            self.play(Rotate(new_wedge, angle, about_point=ORIGIN))\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            new_wedge.shift, 10 * RIGHT,\n",
        "            rate_func=running_start,\n",
        "            path_arc=-30 * DEGREES,\n",
        "        )\n",
        "        self.remove(new_wedge)\n",
        "\n",
        "    def zoom_out(self):\n",
        "        frame = self.camera_frame\n",
        "        self.play(\n",
        "            frame.scale, 2, {\"about_point\": (TOP + RIGHT_SIDE)},\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "    def get_axes_labels(self, axes):\n",
        "        axes_labels = VGroup(\n",
        "            OldTex(\"x = \", \"\\\\sqrt{m_1}\", \"\\\\cdot\", \"v_1\"),\n",
        "            OldTex(\"y = \", \"\\\\sqrt{m_2}\", \"\\\\cdot\", \"v_2\"),\n",
        "        )\n",
        "        for label in axes_labels:\n",
        "            label.set_height(0.4)\n",
        "        axes_labels[0].next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "        axes_labels[0].to_edge(RIGHT, MED_SMALL_BUFF)\n",
        "        axes_labels[1].next_to(ORIGIN, RIGHT, SMALL_BUFF)\n",
        "        axes_labels[1].to_edge(UP, SMALL_BUFF)\n",
        "        return axes_labels\n",
        "\n",
        "\n",
        "class InscribedAngleTheorem(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_circle()\n",
        "        self.let_point_vary()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Inscribed angle theorem\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_circle(self):\n",
        "        # Boy is this over engineered...\n",
        "        circle = self.circle = Circle(\n",
        "            color=BLUE,\n",
        "            radius=2,\n",
        "        )\n",
        "        center_dot = Dot(circle.get_center(), color=WHITE)\n",
        "        self.add(circle, center_dot)\n",
        "\n",
        "        angle_trackers = self.angle_trackers = VGroup(\n",
        "            ValueTracker(TAU / 4),\n",
        "            ValueTracker(PI),\n",
        "            ValueTracker(-TAU / 4),\n",
        "        )\n",
        "\n",
        "        def get_point(angle):\n",
        "            return circle.point_from_proportion(\n",
        "                (angle % TAU) / TAU\n",
        "            )\n",
        "\n",
        "        def get_dot(angle):\n",
        "            dot = Dot(get_point(angle))\n",
        "            dot.set_color(RED)\n",
        "            dot.set_stroke(BLACK, 3, background=True)\n",
        "            return dot\n",
        "\n",
        "        def get_dots():\n",
        "            return VGroup(*[\n",
        "                get_dot(at.get_value())\n",
        "                for at in angle_trackers\n",
        "            ])\n",
        "\n",
        "        def update_labels(labels):\n",
        "            center = circle.get_center()\n",
        "            for dot, label in zip(dots, labels):\n",
        "                label.move_to(\n",
        "                    center + 1.2 * (dot.get_center() - center)\n",
        "                )\n",
        "\n",
        "        def get_lines():\n",
        "            lines = VGroup(*[\n",
        "                Line(d1.get_center(), d2.get_center())\n",
        "                for d1, d2 in zip(dots, dots[1:])\n",
        "            ])\n",
        "            lines.set_stroke(WHITE, 3)\n",
        "            return lines\n",
        "\n",
        "        def get_center_lines():\n",
        "            points = [\n",
        "                dots[0].get_center(),\n",
        "                circle.get_center(),\n",
        "                dots[2].get_center(),\n",
        "            ]\n",
        "            lines = VGroup(*[\n",
        "                Line(p1, p2)\n",
        "                for p1, p2 in zip(points, points[1:])\n",
        "            ])\n",
        "            lines.set_stroke(GREY_B, 3)\n",
        "            return lines\n",
        "\n",
        "        def get_angle_label(lines, tex, reduce_angle=True):\n",
        "            a1 = (lines[0].get_angle() + PI) % TAU\n",
        "            a2 = lines[1].get_angle()\n",
        "            diff = (a2 - a1)\n",
        "            if reduce_angle:\n",
        "                diff = ((diff + PI) % TAU) - PI\n",
        "            point = lines[0].get_end()\n",
        "            arc = Arc(\n",
        "                start_angle=a1,\n",
        "                angle=diff,\n",
        "                radius=0.5,\n",
        "            )\n",
        "            arc.shift(point)\n",
        "            arc_center = arc.point_from_proportion(0.5)\n",
        "            label = OldTex(tex)\n",
        "            vect = (arc_center - point)\n",
        "            vect = (0.3 + get_norm(vect)) * normalize(vect)\n",
        "            label.move_to(point + vect)\n",
        "            return VGroup(arc, label)\n",
        "\n",
        "        def get_theta_label():\n",
        "            return get_angle_label(lines, \"\\\\theta\")\n",
        "\n",
        "        def get_2theta_label():\n",
        "            return get_angle_label(center_lines, \"2\\\\theta\", False)\n",
        "\n",
        "        dots = get_dots()\n",
        "        lines = get_lines()\n",
        "        center_lines = get_center_lines()\n",
        "        labels = VGroup(*[\n",
        "            OldTex(\"P_{}\".format(n + 1))\n",
        "            for n in range(3)\n",
        "        ])\n",
        "        update_labels(labels)\n",
        "        theta_label = get_theta_label()\n",
        "        two_theta_label = get_2theta_label()\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(labels[0]),\n",
        "            FadeInFromLarge(dots[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(*labels[:2]),\n",
        "            TransformFromCopy(*dots[:2]),\n",
        "            ShowCreation(lines[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(lines[1]),\n",
        "            TransformFromCopy(*labels[1:3]),\n",
        "            TransformFromCopy(*dots[1:3]),\n",
        "            Write(theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Add updaters\n",
        "        labels.add_updater(update_labels)\n",
        "        dots.add_updater(lambda m: m.become(get_dots()))\n",
        "        lines.add_updater(lambda m: m.become(get_lines()))\n",
        "        center_lines.add_updater(lambda m: m.become(get_center_lines()))\n",
        "        theta_label.add_updater(lambda m: m.become(get_theta_label()))\n",
        "        two_theta_label.add_updater(lambda m: m.become(get_2theta_label()))\n",
        "\n",
        "        self.add(labels, lines, dots, theta_label)\n",
        "        # Further animations\n",
        "        self.play(\n",
        "            angle_trackers[0].set_value, TAU / 8,\n",
        "        )\n",
        "        self.play(\n",
        "            angle_trackers[2].set_value, -TAU / 8,\n",
        "        )\n",
        "        self.wait()\n",
        "        center_lines.update()\n",
        "        two_theta_label.update()\n",
        "        self.play(\n",
        "            TransformFromCopy(lines.copy().clear_updaters(), center_lines),\n",
        "            TransformFromCopy(theta_label.copy().clear_updaters(), two_theta_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(center_lines, two_theta_label)\n",
        "\n",
        "    def let_point_vary(self):\n",
        "        p1_tracker, p2_tracker, p3_tracker = self.angle_trackers\n",
        "\n",
        "        kwargs = {\"run_time\": 2}\n",
        "        for angle in [TAU / 4, 3 * TAU / 4]:\n",
        "            self.play(\n",
        "                p2_tracker.set_value, angle,\n",
        "                **kwargs\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            p1_tracker.set_value, PI,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            p3_tracker.set_value, TAU / 3,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            p2_tracker.set_value, 7 * TAU / 8,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleSlopeLabel(Scene):\n",
        "    def construct(self):\n",
        "        label = OldTex(\n",
        "            \"\\\\text{Slope}\", \"=\",\n",
        "            \"-\\\\frac{\\\\sqrt{m_1}}{\\\\sqrt{m_2}}\"\n",
        "        )\n",
        "        vector = Vector(DOWN + 2 * LEFT, color=WHITE)\n",
        "        vector.move_to(label[0].get_bottom(), UR)\n",
        "        vector.shift(SMALL_BUFF * DOWN)\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            GrowArrow(vector),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AddTwoThetaManyTimes(Scene):\n",
        "    def construct(self):\n",
        "        expression = OldTex(\n",
        "            \"2\\\\theta\", \"+\",\n",
        "            \"2\\\\theta\", \"+\",\n",
        "            \"2\\\\theta\", \"+\",\n",
        "            \"\\\\cdots\", \"+\",\n",
        "            \"2\\\\theta\",\n",
        "            \"<\", \"2\\\\pi\",\n",
        "        )\n",
        "        expression.to_corner(UL)\n",
        "\n",
        "        brace = Brace(expression[:-2], DOWN)\n",
        "        question = brace.get_text(\"Max number of times?\")\n",
        "        question.set_color(YELLOW)\n",
        "\n",
        "        central_question_group = self.get_central_question()\n",
        "        simplified, lil_brace, new_question = central_question_group\n",
        "        central_question_group.next_to(question, DOWN, LARGE_BUFF)\n",
        "        new_question.align_to(question, LEFT)\n",
        "\n",
        "        for n in range(5):\n",
        "            self.add(expression[:2 * n + 1])\n",
        "            self.wait(0.25)\n",
        "        self.play(\n",
        "            FadeIn(expression[-2:], LEFT),\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(question, UP)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            TransformFromCopy(expression[:-2], simplified[:3]),\n",
        "            TransformFromCopy(expression[-2:], simplified[3:]),\n",
        "            TransformFromCopy(brace, lil_brace),\n",
        "        )\n",
        "        self.play(Write(new_question))\n",
        "        self.wait()\n",
        "\n",
        "        self.central_question_group = central_question_group\n",
        "        self.show_example()\n",
        "\n",
        "    def get_central_question(self, brace_vect=DOWN):\n",
        "        expression = OldTex(\n",
        "            \"N\", \"\\\\cdot\", \"\\\\theta\", \"<\", \"\\\\pi\"\n",
        "        )\n",
        "        N = expression[0]\n",
        "        N.set_color(BLUE)\n",
        "        brace = Brace(N, brace_vect, buff=SMALL_BUFF)\n",
        "        question = brace.get_text(\n",
        "            \"Maximal integer?\",\n",
        "        )\n",
        "        question.set_color(YELLOW)\n",
        "        result = VGroup(expression, brace, question)\n",
        "        result.to_corner(UL)\n",
        "        return result\n",
        "\n",
        "    def show_example(self):\n",
        "        equation = self.get_changable_equation(0.01, n_decimal_places=2)\n",
        "        expression, brace, question = self.central_question_group\n",
        "        N_mob, dot_theta_eq, rhs, comp_pi = equation\n",
        "\n",
        "        equation.next_to(expression, DOWN, 2, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(expression[0], N_mob),\n",
        "            TransformFromCopy(expression[1:4], dot_theta_eq),\n",
        "            TransformFromCopy(expression[4], rhs),\n",
        "            TransformFromCopy(expression[4], comp_pi),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(N_mob, 314, run_time=5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ChangeDecimalToValue(N_mob, 315))\n",
        "        self.wait()\n",
        "        self.play(ChangeDecimalToValue(N_mob, 314))\n",
        "        self.wait()\n",
        "        self.play(ShowCreationThenFadeAround(N_mob))\n",
        "\n",
        "    #\n",
        "    def get_changable_equation(self, value, tex_string=None, n_decimal_places=10):\n",
        "        int_mob = Integer(1)\n",
        "        int_mob.set_color(BLUE)\n",
        "        formatter = \"({:0.\" + str(n_decimal_places) + \"f})\"\n",
        "        tex_string = tex_string or formatter.format(value)\n",
        "        tex_mob = OldTex(\"\\\\cdot\", tex_string, \"=\")\n",
        "        rhs = DecimalNumber(value, num_decimal_places=n_decimal_places)\n",
        "\n",
        "        def align_number(mob):\n",
        "            y0 = mob[0].get_center()[1]\n",
        "            y1 = tex_mob[1][1:-1].get_center()[1]\n",
        "            mob.shift((y1 - y0) * UP)\n",
        "\n",
        "        int_mob.add_updater(\n",
        "            lambda m: m.next_to(tex_mob, LEFT, SMALL_BUFF)\n",
        "        )\n",
        "        int_mob.add_updater(align_number)\n",
        "        rhs.add_updater(\n",
        "            lambda m: m.set_value(value * int_mob.get_value())\n",
        "        )\n",
        "        rhs.add_updater(\n",
        "            lambda m: m.next_to(tex_mob, RIGHT, SMALL_BUFF)\n",
        "        )\n",
        "        rhs.add_updater(align_number)\n",
        "\n",
        "        def get_comp_pi():\n",
        "            if rhs.get_value() < np.pi:\n",
        "                result = OldTex(\"< \\\\pi\")\n",
        "                result.set_color(GREEN)\n",
        "            elif rhs.get_value() > np.pi:\n",
        "                result = OldTex(\"> \\\\pi\")\n",
        "                result.set_color(RED)\n",
        "            else:\n",
        "                result = OldTex(\"= \\\\pi\")\n",
        "            result.next_to(rhs, RIGHT, 2 * SMALL_BUFF)\n",
        "            result[1].scale(1.5, about_edge=LEFT)\n",
        "            return result\n",
        "\n",
        "        comp_pi = always_redraw(get_comp_pi)\n",
        "\n",
        "        return VGroup(int_mob, tex_mob, rhs, comp_pi)\n",
        "\n",
        "\n",
        "class AskAboutTheta(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"But what is $\\\\theta$?\",\n",
        "            target_mode=\"raise_left_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"confused\", \"sassy\", \"raise_left_hand\",\n",
        "            added_anims=[self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ComputeThetaFor1e4(AnalyzeCircleGeometry):\n",
        "    CONFIG = {\n",
        "        \"mass_ratio\": 100,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_mass_ratio_label()\n",
        "        self.add_circle_with_three_lines()\n",
        "        self.write_slope()\n",
        "        self.show_tangent()\n",
        "\n",
        "    def add_circle_with_three_lines(self):\n",
        "        circle = self.get_circle()\n",
        "        axes = self.get_axes()\n",
        "        slope = -np.sqrt(self.mass_ratio)\n",
        "        lines = self.get_lines(\n",
        "            radius=circle.radius,\n",
        "            slope=slope,\n",
        "        )\n",
        "        end_zone = self.get_end_zone()\n",
        "        axes_labels = self.get_axes_labels(axes)\n",
        "        axes.add(axes_labels)\n",
        "\n",
        "        lines_to_fade = VGroup(*lines[:11], *lines[13:])\n",
        "        two_lines = lines[11:13]\n",
        "\n",
        "        theta = self.theta = np.arctan(-1 / slope)\n",
        "        arc = Arc(\n",
        "            start_angle=(-90 * DEGREES),\n",
        "            angle=theta,\n",
        "            radius=2,\n",
        "            arc_center=two_lines[0].get_end(),\n",
        "        )\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.scale(0.8)\n",
        "        theta_label.next_to(arc, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(end_zone, axes, circle)\n",
        "        self.play(ShowCreation(lines, rate_func=linear))\n",
        "        self.play(\n",
        "            lines_to_fade.set_stroke, WHITE, 1, 0.3,\n",
        "            ShowCreation(arc),\n",
        "            FadeIn(theta_label, UP)\n",
        "        )\n",
        "\n",
        "        self.two_lines = two_lines\n",
        "        self.lines = lines\n",
        "        self.circle = circle\n",
        "        self.axes = axes\n",
        "        self.theta_label_group = VGroup(theta_label, arc)\n",
        "\n",
        "    def write_slope(self):\n",
        "        line = self.two_lines[1]\n",
        "        slope_label = OldTex(\n",
        "            \"\\\\text{Slope}\", \"=\",\n",
        "            \"\\\\frac{\\\\text{rise}}{\\\\text{run}}\", \"=\",\n",
        "            \"\\\\frac{-\\\\sqrt{m_1}}{\\\\sqrt{m_2}}\", \"=\", \"-10\"\n",
        "        )\n",
        "        for mob in slope_label:\n",
        "            mob.add_to_back(mob.copy().set_stroke(BLACK, 6))\n",
        "        slope_label.next_to(line.get_center(), UR, buff=1)\n",
        "        slope_arrow = Arrow(\n",
        "            slope_label[0].get_bottom(),\n",
        "            line.point_from_proportion(0.45),\n",
        "            color=RED,\n",
        "            buff=SMALL_BUFF,\n",
        "        )\n",
        "        new_line = line.copy().set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(slope_label[:3]),\n",
        "            ShowCreation(new_line),\n",
        "            GrowArrow(slope_arrow),\n",
        "        )\n",
        "        self.remove(new_line)\n",
        "        line.match_style(new_line)\n",
        "        self.play(\n",
        "            FadeIn(slope_label[3:5], LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(slope_label[5]),\n",
        "            TransformFromCopy(\n",
        "                self.mass_ratio_label[1][:3],\n",
        "                slope_label[6]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.slope_label = slope_label\n",
        "        self.slope_arrow = slope_arrow\n",
        "\n",
        "    def show_tangent(self):\n",
        "        l1, l2 = self.two_lines\n",
        "        theta = self.theta\n",
        "        theta_label_group = self.theta_label_group\n",
        "\n",
        "        tan_equation = OldTex(\n",
        "            \"\\\\tan\", \"(\", \"\\\\theta\", \")\", \"=\",\n",
        "            \"{\\\\text{run}\", \"\\\\over\", \"-\\\\text{rise}}\", \"=\",\n",
        "            \"\\\\frac{1}{10}\",\n",
        "        )\n",
        "        tan_equation.scale(0.9)\n",
        "        tan_equation.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        tan_equation.shift(2 * UP)\n",
        "        run_word = tan_equation.get_part_by_tex(\"run\")\n",
        "        rise_word = tan_equation.get_part_by_tex(\"rise\")\n",
        "\n",
        "        p1, p2 = l1.get_start(), l1.get_end()\n",
        "        p3 = p1 + get_norm(p2 - p1) * np.tan(theta) * RIGHT\n",
        "        triangle = Polygon(p1, p2, p3)\n",
        "        triangle.set_stroke(width=0)\n",
        "        triangle.set_fill(GREEN, 0.5)\n",
        "\n",
        "        opposite = Line(p1, p3)\n",
        "        adjacent = Line(p1, p2)\n",
        "        opposite.set_stroke(BLUE, 3)\n",
        "        adjacent.set_stroke(PINK, 3)\n",
        "\n",
        "        arctan_equation = OldTex(\n",
        "            \"\\\\theta\", \"=\", \"\\\\arctan\", \"(\", \"1 / 10\", \")\"\n",
        "        )\n",
        "        arctan_equation.next_to(tan_equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(tan_equation[:8]),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(theta_label_group[1], opposite),\n",
        "            run_word.set_color, opposite.get_color()\n",
        "        )\n",
        "        self.play(WiggleOutThenIn(run_word))\n",
        "        self.play(\n",
        "            TransformFromCopy(opposite, adjacent),\n",
        "            rise_word.set_color, adjacent.get_color()\n",
        "        )\n",
        "        self.play(WiggleOutThenIn(rise_word))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(\n",
        "            self.slope_label[-1],\n",
        "            tan_equation[-2:],\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "        indices = [2, 4, 0, 1, -1, 3]\n",
        "        movers = VGroup(*[tan_equation[i] for i in indices]).copy()\n",
        "        for mover, target in zip(movers, arctan_equation):\n",
        "            mover.target = target\n",
        "        # Swap last two\n",
        "        sm = movers.submobjects\n",
        "        sm[-1], sm[-2] = sm[-2], sm[-1]\n",
        "        self.play(LaggedStartMap(\n",
        "            Transform, movers[:-1],\n",
        "            lambda m: (m, m.target),\n",
        "            lag_ratio=1,\n",
        "            run_time=1,\n",
        "            path_arc=PI / 6,\n",
        "        ))\n",
        "        self.play(MoveToTarget(movers[-1]))\n",
        "        self.remove(movers)\n",
        "        self.add(arctan_equation)\n",
        "        self.play(ShowCreationThenFadeAround(arctan_equation))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThetaChart(Scene):\n",
        "    def construct(self):\n",
        "        self.create_columns()\n",
        "        self.populate_columns()\n",
        "        self.show_values()\n",
        "        self.highlight_example(2)\n",
        "        self.highlight_example(3)\n",
        "\n",
        "    def create_columns(self):\n",
        "        titles = VGroup(*[\n",
        "            OldTexText(\"Mass ratio\"),\n",
        "            OldTexText(\"$\\\\theta$ formula\"),\n",
        "            OldTexText(\"$\\\\theta$ value\"),\n",
        "        ])\n",
        "        titles.scale(1.5)\n",
        "        titles.arrange(RIGHT, buff=1.5)\n",
        "        titles[1].shift(MED_SMALL_BUFF * LEFT)\n",
        "        titles[2].shift(MED_SMALL_BUFF * RIGHT)\n",
        "        titles.to_corner(UL)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for t1, t2 in zip(titles, titles[1:]):\n",
        "            line = Line(TOP, BOTTOM)\n",
        "            x = np.mean([t1.get_center()[0], t2.get_center()[0]])\n",
        "            line.shift(x * RIGHT)\n",
        "            lines.add(line)\n",
        "\n",
        "        h_line = Line(LEFT_SIDE, RIGHT_SIDE)\n",
        "        h_line.next_to(titles, DOWN)\n",
        "        h_line.to_edge(LEFT, buff=0)\n",
        "        lines.add(h_line)\n",
        "        lines.set_stroke(WHITE, 1)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromDown, titles),\n",
        "            LaggedStartMap(ShowCreation, lines, lag_ratio=0.8),\n",
        "        )\n",
        "\n",
        "        self.h_line = h_line\n",
        "        self.titles = titles\n",
        "\n",
        "    def populate_columns(self):\n",
        "        top_h_line = self.h_line\n",
        "        x_vals = [t.get_center()[0] for t in self.titles]\n",
        "\n",
        "        entries = [\n",
        "            (\n",
        "                \"$m_1$ : $m_2$\",\n",
        "                \"$\\\\arctan(\\\\sqrt{m_2} / \\\\sqrt{m_1})$\",\n",
        "                \"\"\n",
        "            )\n",
        "        ] + [\n",
        "            (\n",
        "                \"{:,} : 1\".format(10**(2 * exp)),\n",
        "                \"$\\\\arctan(1 / {:,})$\".format(10**exp),\n",
        "                self.get_theta_decimal(exp),\n",
        "            )\n",
        "            for exp in [1, 2, 3, 4, 5]\n",
        "        ]\n",
        "\n",
        "        h_lines = VGroup(top_h_line)\n",
        "        entry_mobs = VGroup()\n",
        "        for entry in entries:\n",
        "            mobs = VGroup(*map(TexText, entry))\n",
        "            for mob, x in zip(mobs, x_vals):\n",
        "                mob.shift(x * RIGHT)\n",
        "            delta_y = (mobs.get_height() / 2) + MED_SMALL_BUFF\n",
        "            y = h_lines[-1].get_center()[1] - delta_y\n",
        "            mobs.shift(y * UP)\n",
        "            mobs[0].set_color(BLUE)\n",
        "            mobs[2].set_color(YELLOW)\n",
        "            entry_mobs.add(mobs)\n",
        "\n",
        "            h_line = DashedLine(LEFT_SIDE, RIGHT_SIDE)\n",
        "            h_line.shift((y - delta_y) * UP)\n",
        "            h_lines.add(h_line)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeInFromDown,\n",
        "                VGroup(*[em[:2] for em in entry_mobs]),\n",
        "            ),\n",
        "            LaggedStartMap(ShowCreation, h_lines[1:]),\n",
        "            lag_ratio=0.1,\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        self.entry_mobs = entry_mobs\n",
        "        self.h_lines = h_lines\n",
        "\n",
        "    def show_values(self):\n",
        "        values = VGroup(*[em[2] for em in self.entry_mobs])\n",
        "        for value in values:\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, value,\n",
        "                lag_ratio=0.1,\n",
        "                run_time=0.5\n",
        "            ))\n",
        "            self.wait(0.5)\n",
        "\n",
        "    def highlight_example(self, exp):\n",
        "        entry_mobs = self.entry_mobs\n",
        "        example = entry_mobs[exp]\n",
        "        other_entries = VGroup(*entry_mobs[:exp], *entry_mobs[exp + 1:])\n",
        "\n",
        "        value = example[-1]\n",
        "        rhs = OldTex(\"\\\\approx {:}\".format(10**(-exp)))\n",
        "        rhs.next_to(value, RIGHT)\n",
        "        rhs.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        value.generate_target()\n",
        "        value.target.set_fill(opacity=1)\n",
        "        value.target.scale(0.9)\n",
        "        value.target.next_to(rhs, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            other_entries.set_fill, {\"opacity\": 0.25},\n",
        "            example.set_fill, {\"opacity\": 1},\n",
        "            ShowCreationThenFadeAround(example)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(value),\n",
        "            Write(rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "        value.add(rhs)\n",
        "\n",
        "    def get_theta_decimal(self, exp):\n",
        "        theta = np.arctan(10**(-exp))\n",
        "        rounded_theta = np.floor(1e10 * theta) / 1e10\n",
        "        return \"{:0.10f}\\\\dots\".format(rounded_theta)\n",
        "\n",
        "\n",
        "class CentralQuestionFor1e2(AddTwoThetaManyTimes):\n",
        "    CONFIG = {\n",
        "        \"exp\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        exp = self.exp\n",
        "        question = self.get_central_question(UP)\n",
        "        pi_value = OldTex(\" = {:0.10f}\\\\dots\".format(PI))\n",
        "        pi_value.next_to(question[0][-1], RIGHT, SMALL_BUFF)\n",
        "        pi_value.shift(0.3 * SMALL_BUFF * UP)\n",
        "        question.add(pi_value)\n",
        "\n",
        "        max_count = int(PI * 10**exp)\n",
        "\n",
        "        question.center().to_edge(UP)\n",
        "        self.add(question)\n",
        "\n",
        "        b10_equation = self.get_changable_equation(\n",
        "            10**(-exp), n_decimal_places=exp\n",
        "        )\n",
        "        b10_equation.next_to(question, DOWN, buff=1.5)\n",
        "        arctan_equation = self.get_changable_equation(\n",
        "            np.arctan(10**(-exp)), n_decimal_places=10,\n",
        "        )\n",
        "        arctan_equation.next_to(b10_equation, DOWN, MED_LARGE_BUFF)\n",
        "        eq_centers = [\n",
        "            eq[1][2].get_center()\n",
        "            for eq in [b10_equation, arctan_equation]\n",
        "        ]\n",
        "        arctan_equation.shift((eq_centers[1][0] - eq_centers[1][0]) * RIGHT)\n",
        "\n",
        "        # b10_brace = Brace(b10_equation[1][1][1:-1], UP)\n",
        "        arctan_brace = Brace(arctan_equation[1][1][1:-1], DOWN)\n",
        "        # b10_tex = b10_brace.get_tex(\"1 / 10\")\n",
        "        arctan_tex = arctan_brace.get_tex(\n",
        "            \"\\\\theta = \\\\arctan(1 / {:,})\".format(10**exp)\n",
        "        )\n",
        "\n",
        "        int_mobs = b10_equation[0], arctan_equation[0]\n",
        "\n",
        "        self.add(*b10_equation, *arctan_equation)\n",
        "        # self.add(b10_brace, b10_tex)\n",
        "        self.add(arctan_brace, arctan_tex)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ChangeDecimalToValue(int_mob, max_count, run_time=8)\n",
        "            for int_mob in int_mobs\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ChangeDecimalToValue(int_mob, max_count + 1, run_time=1)\n",
        "            for int_mob in int_mobs\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ChangeDecimalToValue(int_mob, max_count, run_time=1)\n",
        "            for int_mob in int_mobs\n",
        "        ])\n",
        "        self.play(ShowCreationThenFadeAround(int_mobs[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AnalyzeCircleGeometry1e2(AnalyzeCircleGeometry):\n",
        "    CONFIG = {\n",
        "        \"mass_ratio\": 100,\n",
        "    }\n",
        "\n",
        "\n",
        "class CentralQuestionFor1e3(CentralQuestionFor1e2):\n",
        "    CONFIG = {\"exp\": 3}\n",
        "\n",
        "\n",
        "class AskAboutArctanOfSmallValues(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "\n",
        "        equation1 = OldTex(\n",
        "            \"\\\\arctan\", \"(\", \"x\", \")\", \"\\\\approx\", \"x\"\n",
        "        )\n",
        "        equation1.set_color_by_tex(\"arctan\", YELLOW)\n",
        "        equation2 = OldTex(\n",
        "            \"x\", \"\\\\approx\", \"\\\\tan\", \"(\", \"x\", \")\",\n",
        "        )\n",
        "        equation2.set_color_by_tex(\"tan\", BLUE)\n",
        "        for mob in equation1, equation2:\n",
        "            mob.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(equation1),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(\n",
        "                \"erm\", \"sassy\", \"confused\"\n",
        "            )\n",
        "        )\n",
        "        self.look_at(3 * UL)\n",
        "        self.play(equation1.shift, UP)\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                VGroup(*[equation1[i] for i in (2, 4, 5)]),\n",
        "                VGroup(*[equation2[i] for i in (0, 1, 4)]),\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(\n",
        "                VGroup(*[equation1[i] for i in (0, 1, 3)]),\n",
        "                VGroup(*[equation2[i] for i in (2, 3, 5)]),\n",
        "            ),\n",
        "            self.change_students(\n",
        "                \"confused\", \"erm\", \"sassy\",\n",
        "            ),\n",
        "        )\n",
        "        self.look_at(3 * UL)\n",
        "        self.wait(3)\n",
        "        # self.student_says(\"Why?\", target_mode=\"maybe\")\n",
        "        # self.wait(3)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"For small $x$\")\n",
        "        subtitle = OldTexText(\"(e.g. $x = 0.001$)\")\n",
        "        subtitle.scale(0.75)\n",
        "        subtitle.next_to(title, DOWN)\n",
        "        title.add(subtitle)\n",
        "        # title.scale(1.5)\n",
        "        # title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        title.move_to(self.hold_up_spot)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "class ActanAndTanGraphs(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\": -PI / 8,\n",
        "        \"x_max\": 5 * PI / 8,\n",
        "        \"y_min\": -PI / 8,\n",
        "        \"y_max\": 4 * PI / 8,\n",
        "        \"x_tick_frequency\": PI / 8,\n",
        "        \"x_leftmost_tick\": -PI / 8,\n",
        "        \"y_tick_frequency\": PI / 8,\n",
        "        \"y_leftmost_tick\": -PI / 8,\n",
        "        \"x_axis_width\": 10,\n",
        "        \"y_axis_height\": 7,\n",
        "        \"graph_origin\": 2.5 * DOWN + 5 * LEFT,\n",
        "        \"num_graph_anchor_points\": 500,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        axes = self.axes\n",
        "        labels = VGroup(\n",
        "            OldTex(\"\\\\pi / 8\"),\n",
        "            OldTex(\"\\\\pi / 4\"),\n",
        "            OldTex(\"3\\\\pi / 8\"),\n",
        "            OldTex(\"\\\\pi / 2\"),\n",
        "        )\n",
        "        for n, label in zip(it.count(1), labels):\n",
        "            label.scale(0.75)\n",
        "            label.next_to(self.coords_to_point(n * PI / 8, 0), DOWN)\n",
        "            self.add(label)\n",
        "\n",
        "        id_graph = self.get_graph(lambda x: x, x_max=1.5)\n",
        "        arctan_graph = self.get_graph(np.arctan, x_max=1.5)\n",
        "        tan_graph = self.get_graph(np.tan, x_max=1.5)\n",
        "        graphs = VGroup(id_graph, arctan_graph, tan_graph)\n",
        "\n",
        "        id_label = OldTex(\"f(x) = x\")\n",
        "        arctan_label = OldTex(\"\\\\arctan(x)\")\n",
        "        tan_label = OldTex(\"\\\\tan(x)\")\n",
        "        labels = VGroup(id_label, arctan_label, tan_label)\n",
        "        for label, graph in zip(labels, graphs):\n",
        "            label.match_color(graph)\n",
        "            label.next_to(graph.get_points()[-1], RIGHT)\n",
        "            if label.get_bottom()[1] > FRAME_HEIGHT / 2:\n",
        "                label.next_to(graph.point_from_proportion(0.75), LEFT)\n",
        "\n",
        "        arctan_x_tracker = ValueTracker(3 * PI / 8)\n",
        "        arctan_v_line = always_redraw(\n",
        "            lambda: self.get_vertical_line_to_graph(\n",
        "                arctan_x_tracker.get_value(),\n",
        "                arctan_graph,\n",
        "                line_class=DashedLine,\n",
        "                color=WHITE,\n",
        "            )\n",
        "        )\n",
        "        tan_x_tracker = ValueTracker(2 * PI / 8)\n",
        "        tan_v_line = always_redraw(\n",
        "            lambda: self.get_vertical_line_to_graph(\n",
        "                tan_x_tracker.get_value(),\n",
        "                tan_graph,\n",
        "                line_class=DashedLine,\n",
        "                color=WHITE,\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(\n",
        "            ShowCreation(id_graph),\n",
        "            Write(id_label)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(arctan_graph),\n",
        "            Write(arctan_label)\n",
        "        )\n",
        "        self.add(arctan_v_line)\n",
        "        self.play(arctan_x_tracker.set_value, 0, run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(arctan_graph, tan_graph),\n",
        "            TransformFromCopy(arctan_label, tan_label),\n",
        "        )\n",
        "        self.add(tan_v_line)\n",
        "        self.play(tan_x_tracker.set_value, 0, run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UnitCircleIntuition(Scene):\n",
        "    def construct(self):\n",
        "        self.draw_unit_circle()\n",
        "        self.show_angle()\n",
        "        self.show_fraction()\n",
        "        self.show_fraction_approximation()\n",
        "\n",
        "    def draw_unit_circle(self):\n",
        "        unit_size = 2.5\n",
        "        axes = Axes(\n",
        "            axis_config={\"unit_size\": unit_size},\n",
        "            x_min=-2.5, x_max=2.5,\n",
        "            y_min=-1.5, y_max=1.5,\n",
        "        )\n",
        "        axes.set_stroke(width=1)\n",
        "        self.add(axes)\n",
        "\n",
        "        radius_line = Line(ORIGIN, axes.coords_to_point(1, 0))\n",
        "        radius_line.set_color(BLUE)\n",
        "        r_label = OldTex(\"1\")\n",
        "        r_label.add_updater(\n",
        "            lambda m: m.next_to(radius_line.get_center(), DOWN, SMALL_BUFF)\n",
        "        )\n",
        "        circle = Circle(radius=unit_size, color=WHITE)\n",
        "\n",
        "        self.add(radius_line, r_label)\n",
        "        self.play(\n",
        "            Rotating(radius_line, about_point=ORIGIN),\n",
        "            ShowCreation(circle),\n",
        "            run_time=2,\n",
        "            rate_func=smooth,\n",
        "        )\n",
        "\n",
        "        self.radius_line = radius_line\n",
        "        self.r_label = r_label\n",
        "        self.circle = circle\n",
        "        self.axes = axes\n",
        "\n",
        "    def show_angle(self):\n",
        "        circle = self.circle\n",
        "\n",
        "        tan_eq = OldTex(\n",
        "            \"\\\\tan\", \"(\", \"\\\\theta\", \")\", \"=\",\n",
        "            tex_to_color_map={\"\\\\theta\": RED},\n",
        "        )\n",
        "        tan_eq.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        tan_eq.to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        theta_tracker = ValueTracker(0)\n",
        "        get_theta = theta_tracker.get_value\n",
        "\n",
        "        def get_r_line():\n",
        "            return Line(\n",
        "                circle.get_center(),\n",
        "                circle.point_at_angle(get_theta())\n",
        "            )\n",
        "        r_line = always_redraw(get_r_line)\n",
        "\n",
        "        def get_arc(radius=None, **kwargs):\n",
        "            if radius is None:\n",
        "                alpha = inverse_interpolate(0, 20 * DEGREES, get_theta())\n",
        "                radius = interpolate(2, 1, alpha)\n",
        "            return Arc(\n",
        "                radius=radius,\n",
        "                start_angle=0,\n",
        "                angle=get_theta(),\n",
        "                arc_center=circle.get_center(),\n",
        "                **kwargs\n",
        "            )\n",
        "        arc = always_redraw(get_arc)\n",
        "        self.circle_arc = always_redraw(\n",
        "            lambda: get_arc(radius=circle.radius, color=RED)\n",
        "        )\n",
        "\n",
        "        def get_theta_label():\n",
        "            label = OldTex(\"\\\\theta\")\n",
        "            label.set_height(min(arc.get_height(), 0.3))\n",
        "            label.set_color(RED)\n",
        "            center = circle.get_center()\n",
        "            vect = arc.point_from_proportion(0.5) - center\n",
        "            vect = (get_norm(vect) + 2 * SMALL_BUFF) * normalize(vect)\n",
        "            label.move_to(center + vect)\n",
        "            return label\n",
        "        theta_label = always_redraw(get_theta_label)\n",
        "\n",
        "        def get_height_line():\n",
        "            p2 = circle.point_at_angle(get_theta())\n",
        "            p1 = np.array(p2)\n",
        "            p1[1] = circle.get_center()[1]\n",
        "            return Line(\n",
        "                p1, p2,\n",
        "                stroke_color=YELLOW,\n",
        "                stroke_width=3,\n",
        "            )\n",
        "        self.height_line = always_redraw(get_height_line)\n",
        "\n",
        "        def get_width_line():\n",
        "            p2 = circle.get_center()\n",
        "            p1 = circle.point_at_angle(get_theta())\n",
        "            p1[1] = p2[1]\n",
        "            return Line(\n",
        "                p1, p2,\n",
        "                stroke_color=PINK,\n",
        "                stroke_width=3,\n",
        "            )\n",
        "        self.width_line = always_redraw(get_width_line)\n",
        "\n",
        "        def get_h_label():\n",
        "            label = OldTex(\"h\")\n",
        "            height_line = self.height_line\n",
        "            label.match_color(height_line)\n",
        "            label.set_height(min(height_line.get_height(), 0.3))\n",
        "            label.set_stroke(BLACK, 3, background=True)\n",
        "            label.next_to(height_line, RIGHT, SMALL_BUFF)\n",
        "            return label\n",
        "        self.h_label = always_redraw(get_h_label)\n",
        "\n",
        "        def get_w_label():\n",
        "            label = OldTex(\"w\")\n",
        "            width_line = self.width_line\n",
        "            label.match_color(width_line)\n",
        "            label.next_to(width_line, DOWN, SMALL_BUFF)\n",
        "            return label\n",
        "        self.w_label = always_redraw(get_w_label)\n",
        "\n",
        "        self.add(r_line, theta_label, arc, self.radius_line)\n",
        "        self.play(\n",
        "            FadeInFromDown(tan_eq),\n",
        "            theta_tracker.set_value, 20 * DEGREES,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.tan_eq = tan_eq\n",
        "        self.theta_tracker = theta_tracker\n",
        "\n",
        "    def show_fraction(self):\n",
        "        height_line = self.height_line\n",
        "        width_line = self.width_line\n",
        "        h_label = self.h_label\n",
        "        w_label = self.w_label\n",
        "        tan_eq = self.tan_eq\n",
        "\n",
        "        rhs = OldTex(\n",
        "            \"{\\\\text{height}\", \"\\\\over\", \"\\\\text{width}}\"\n",
        "        )\n",
        "        rhs.next_to(tan_eq, RIGHT)\n",
        "        rhs.get_part_by_tex(\"height\").match_color(height_line)\n",
        "        rhs.get_part_by_tex(\"width\").match_color(width_line)\n",
        "\n",
        "        for mob in [height_line, width_line, h_label, w_label]:\n",
        "            mob.update()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(height_line.copy().clear_updaters(), remover=True),\n",
        "            FadeIn(h_label.copy().clear_updaters(), RIGHT, remover=True),\n",
        "            Write(rhs[:2])\n",
        "        )\n",
        "        self.add(height_line, h_label)\n",
        "        self.play(\n",
        "            ShowCreation(width_line.copy().clear_updaters(), remover=True),\n",
        "            FadeIn(w_label.copy().clear_updaters(), UP, remover=True),\n",
        "            self.r_label.fade, 1,\n",
        "            Write(rhs[2])\n",
        "        )\n",
        "        self.add(width_line, w_label)\n",
        "        self.wait()\n",
        "\n",
        "        self.rhs = rhs\n",
        "\n",
        "    def show_fraction_approximation(self):\n",
        "        theta_tracker = self.theta_tracker\n",
        "        approx_rhs = OldTex(\n",
        "            \"\\\\approx\", \"{\\\\theta\", \"\\\\over\", \"1}\",\n",
        "        )\n",
        "        height, over1, width = self.rhs\n",
        "        approx, theta, over2, one = approx_rhs\n",
        "        approx_rhs.set_color_by_tex(\"\\\\theta\", RED)\n",
        "        approx_rhs.next_to(self.rhs, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(theta_tracker.set_value, 5 * DEGREES)\n",
        "        self.play(Write(VGroup(approx, over2)))\n",
        "        self.wait()\n",
        "        self.play(Indicate(width))\n",
        "        self.play(TransformFromCopy(width, one))\n",
        "        self.wait()\n",
        "        self.play(Indicate(height))\n",
        "        self.play(TransformFromCopy(height, theta))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TangentTaylorSeries(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        series = OldTex(\n",
        "            \"\\\\tan\", \"(\", \"\\\\theta\", \")\", \"=\", \"\\\\theta\", \"+\",\n",
        "            \"\\\\frac{1}{3}\", \"\\\\theta\", \"^3\", \"+\",\n",
        "            \"\\\\frac{2}{15}\", \"\\\\theta\", \"^5\", \"+\", \"\\\\cdots\",\n",
        "            tex_to_color_map={\"\\\\theta\": YELLOW},\n",
        "        )\n",
        "        series.move_to(2 * UP)\n",
        "        series.move_to(self.hold_up_spot, DOWN)\n",
        "        series_error = series[7:]\n",
        "        series_error_rect = SurroundingRectangle(series_error)\n",
        "\n",
        "        example = OldTex(\n",
        "            \"\\\\tan\", \"\\\\left(\", \"\\\\frac{1}{100}\", \"\\\\right)\",\n",
        "            \"=\", \"\\\\frac{1}{100}\", \"+\",\n",
        "            \"\\\\frac{1}{3}\", \"\\\\left(\",\n",
        "            \"\\\\frac{1}{1{,}000{,}000}\",\n",
        "            \"\\\\right)\", \"+\",\n",
        "            \"\\\\frac{2}{15}\", \"\\\\left(\",\n",
        "            \"\\\\frac{1}{10{,}000{,}000{,}000}\",\n",
        "            \"\\\\right)\", \"+\", \"\\\\cdots\",\n",
        "        )\n",
        "        example.set_color_by_tex(\"\\\\frac{1}{1\", BLUE)\n",
        "        example.set_width(FRAME_WIDTH - 1)\n",
        "        example.next_to(self.students, UP, buff=2)\n",
        "        example.shift_onto_screen()\n",
        "        error = example[7:]\n",
        "        error_rect = SurroundingRectangle(error)\n",
        "        error_rect.set_color(RED)\n",
        "        error_decimal = DecimalNumber(\n",
        "            np.tan(0.01) - 0.01,\n",
        "            num_decimal_places=15,\n",
        "        )\n",
        "        error_decimal.next_to(error_rect, DOWN)\n",
        "        approx = OldTex(\"\\\\approx\")\n",
        "        approx.next_to(error_decimal, LEFT)\n",
        "        error_decimal.add(approx)\n",
        "        error_decimal.match_color(error_rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(series),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(series_error_rect),\n",
        "            self.change_students(*3 * [\"pondering\"])\n",
        "        )\n",
        "        self.play(FadeOut(series_error_rect))\n",
        "        self.play(\n",
        "            series.center, series.to_edge, UP,\n",
        "        )\n",
        "        self.look_at(series)\n",
        "        self.play(\n",
        "            TransformFromCopy(series[:8], example[:8]),\n",
        "            TransformFromCopy(series[8], example[9]),\n",
        "            TransformFromCopy(series[10:12], example[11:13]),\n",
        "            TransformFromCopy(series[12], example[14]),\n",
        "            TransformFromCopy(series[14:], example[16:]),\n",
        "            *map(GrowFromCenter, [example[i] for i in (8, 10, 13, 15)])\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"confused\", \"sad\")\n",
        "        self.play(ShowCreation(error_rect))\n",
        "        self.play(ShowIncreasingSubsets(error_decimal))\n",
        "        self.play_all_student_changes(\"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class AnalyzeCircleGeometry1e4(AnalyzeCircleGeometry):\n",
        "    CONFIG = {\n",
        "        \"mass_ratio\": 10000,\n",
        "    }\n",
        "\n",
        "\n",
        "class SumUpWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"To sum up:\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        screen_rect = ScreenRectangle(height=6)\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "        self.add(FullScreenFadeRectangle(\n",
        "            fill_color=GREY_D,\n",
        "            fill_opacity=0.5\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeInFromDown(title),\n",
        "            FadeIn(screen_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ConservationLawSummary(Scene):\n",
        "    def construct(self):\n",
        "        energy_eq = OldTex(\n",
        "            \"\\\\frac{1}{2}\", \"m_1\", \"(\", \"v_1\", \")\", \"^2\", \"+\",\n",
        "            \"\\\\frac{1}{2}\", \"m_2\", \"(\", \"v_2\", \")\", \"^2\", \"=\",\n",
        "            \"\\\\text{const.}\",\n",
        "        )\n",
        "        energy_word = OldTexText(\"Energy\")\n",
        "        energy_word.scale(2)\n",
        "        circle = Circle(color=YELLOW, radius=2)\n",
        "        energy_group = VGroup(energy_word, energy_eq, circle)\n",
        "        momentum_eq = OldTex(\n",
        "            \"m_1\", \"v_1\", \"+\", \"m_2\", \"v_2\", \"=\",\n",
        "            \"\\\\text{const.}\",\n",
        "        )\n",
        "        momentum_word = OldTexText(\"Momentum\")\n",
        "        momentum_word.scale(2)\n",
        "        line = Line(ORIGIN, RIGHT + np.sqrt(10) * DOWN)\n",
        "        line.set_color(GREEN)\n",
        "        momentum_group = VGroup(momentum_word, momentum_eq, line)\n",
        "\n",
        "        equations = VGroup(energy_eq, momentum_eq)\n",
        "        words = VGroup(energy_word, momentum_word)\n",
        "\n",
        "        for equation in equations:\n",
        "            equation.set_color_by_tex(\"m_\", BLUE)\n",
        "            equation.set_color_by_tex(\"v_\", RED)\n",
        "\n",
        "        words.arrange(\n",
        "            DOWN, buff=3,\n",
        "        )\n",
        "        words.to_edge(LEFT, buff=1.5)\n",
        "\n",
        "        for group in energy_group, momentum_group:\n",
        "            arrow = Arrow(\n",
        "                LEFT, 2 * RIGHT,\n",
        "                rectangular_stem_width=0.1,\n",
        "                tip_length=0.5,\n",
        "                color=WHITE\n",
        "            )\n",
        "            arrow.next_to(group[0], RIGHT)\n",
        "            group[1].next_to(group[0], DOWN)\n",
        "            group[2].next_to(arrow, RIGHT)\n",
        "            group[2].set_stroke(width=6)\n",
        "            group.add(arrow)\n",
        "        # line.scale(4, about_edge=DR)\n",
        "        red_energy_word = energy_word.copy()\n",
        "        red_energy_word.set_fill(opacity=0)\n",
        "        red_energy_word.set_stroke(RED, 2)\n",
        "\n",
        "        self.add(energy_group, momentum_group)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenDestruction,\n",
        "                red_energy_word\n",
        "            ),\n",
        "        )\n",
        "        for color in [RED, BLUE, PINK, YELLOW]:\n",
        "            self.play(ShowCreation(\n",
        "                circle.copy().set_color(color),\n",
        "            ))\n",
        "\n",
        "\n",
        "class FinalCommentsOnPhaseSpace(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_related_fields()\n",
        "        self.state_to_point()\n",
        "        self.puzzle_as_remnant()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = self.title = OldTexText(\"Phase space\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(YELLOW)\n",
        "\n",
        "        self.play(Write(title))\n",
        "\n",
        "    def show_related_fields(self):\n",
        "        title = self.title\n",
        "\n",
        "        images = Group(\n",
        "            ImageMobject(\"ClacksThumbnail\"),\n",
        "            ImageMobject(\"PictoralODE\"),\n",
        "            # ImageMobject(\"DoublePendulumStart\"),\n",
        "            ImageMobject(\"MobiusStrip\"),\n",
        "        )\n",
        "        colors = [BLUE_D, GREY_BROWN, BLUE_C]\n",
        "        for image, color in zip(images, colors):\n",
        "            image.set_height(2.5)\n",
        "            image.add(SurroundingRectangle(\n",
        "                image,\n",
        "                color=color,\n",
        "                stroke_width=5,\n",
        "                buff=0,\n",
        "            ))\n",
        "        images.arrange(RIGHT)\n",
        "        images.move_to(DOWN)\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                title.get_bottom(), image.get_top(),\n",
        "                color=WHITE,\n",
        "            )\n",
        "            for image in images\n",
        "        ])\n",
        "\n",
        "        for image, arrow in zip(images, arrows):\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                GrowFromPoint(image, title.get_bottom()),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        self.to_fade = Group(images, arrows)\n",
        "\n",
        "    def state_to_point(self):\n",
        "        state = OldTexText(\"State\")\n",
        "        arrow = Arrow(\n",
        "            2 * LEFT, 2 * RIGHT,\n",
        "            color=WHITE,\n",
        "            rectangular_stem_width=0.1,\n",
        "            tip_length=0.5\n",
        "        )\n",
        "        point = OldTexText(\"Point\")\n",
        "        dynamics = OldTexText(\"Dynamics\")\n",
        "        geometry = OldTexText(\"Geometry\")\n",
        "        words = VGroup(state, point, dynamics, geometry)\n",
        "        for word in words:\n",
        "            word.scale(2)\n",
        "\n",
        "        group = VGroup(state, arrow, point)\n",
        "        group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        group.move_to(2.5 * DOWN)\n",
        "\n",
        "        dynamics.move_to(state, RIGHT)\n",
        "        geometry.move_to(point, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.to_fade, UP),\n",
        "            FadeIn(state, UP)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(point, LEFT)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for w1, w2 in [(state, dynamics), (point, geometry)]:\n",
        "            self.play(\n",
        "                FadeOut(w1, UP),\n",
        "                FadeIn(w2, DOWN),\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "    def puzzle_as_remnant(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class AltShowTwoPopulations(ShowTwoPopulations):\n",
        "    CONFIG = {\n",
        "        \"count_word_scale_val\": 2,\n",
        "    }\n",
        "\n",
        "\n",
        "class SimpleTeacherHolding(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(self.teacher.change, \"raise_right_hand\")\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"Juan Benet\",\n",
        "            \"Vassili Philippov\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Matt Russell\",\n",
        "            \"soekul\",\n",
        "            \"Richard Barthel\",\n",
        "            \"Nathan Jessurun\",\n",
        "            \"Ali Yahya\",\n",
        "            \"dave nicponski\",\n",
        "            \"Yu Jun\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Roy Larson\",\n",
        "            \"Joseph Kelly\",\n",
        "            \"Peter Mcinerney\",\n",
        "            \"Scott Walter, Ph.D.\",\n",
        "            \"Magnus Lysfjord\",\n",
        "            \"Evan Phillips\",\n",
        "            \"Graham\",\n",
        "            \"Mauricio Collares\",\n",
        "            \"Quantopian\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"John Shaughnessy\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"David Gow\",\n",
        "            \"J\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Bob Sanderson\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Robert Teed\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Jeff Linse\",\n",
        "            \"John Haley\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Awoo\",\n",
        "            \"Linh Tran\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"David Clark\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Jason Hise\",\n",
        "            \"Ankalagon\",\n",
        "            \"Dave B\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Chris Connett\",\n",
        "            \"Eric Younge\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Delton Ding\",\n",
        "            \"James Hughes\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Yaw Etse\",\n",
        "            \"John Griffith\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Jameel Syed\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"Solara570\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"Song Gao\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Michael Faust\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Nero Li\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Devarsh Desai\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Jan Pijpers\",\n",
        "            \"L0j1k\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Richard Comish\",\n",
        "            \"Zach Cardwell\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Danger Dai\",\n",
        "            \"Dave Kester\",\n",
        "            \"eaglle\",\n",
        "            \"Florian Chudigiewitsch\",\n",
        "            \"Roobie\",\n",
        "            \"Xavier Bernard\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Kanan Gill\",\n",
        "            \"j eduardo perez\",\n",
        "            \"Antonio Juarez\",\n",
        "            \"Owen Campbell-Moore\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class SolutionThumbnail(Thumbnail):\n",
        "    CONFIG = {\n",
        "        \"sliding_blocks_config\": {\n",
        "            \"block1_config\": {\n",
        "                \"label_text\": \"$100^{d}$ kg\",\n",
        "            },\n",
        "            \"collect_clack_data\": False,\n",
        "        },\n",
        "    }\n",
        "\n",
        "    def add_text(self):\n",
        "        word = OldTexText(\"Solution\")\n",
        "        question = OldTexText(\"How many collisions?\")\n",
        "        word.set_width(7)\n",
        "        question.match_width(word)\n",
        "        question.next_to(word, UP)\n",
        "        group = VGroup(word, question)\n",
        "        group.to_edge(UP, buff=MED_LARGE_BUFF)\n",
        "        word.set_color(RED)\n",
        "        question.set_color(YELLOW)\n",
        "        group.set_stroke(RED, 2, background=True)\n",
        "        self.add(group)\n"
    ]
}