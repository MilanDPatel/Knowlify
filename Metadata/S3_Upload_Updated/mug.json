{
    "topic": "demonstrates the concept of a \"snowflake\" animation, where a",
    "code": [
        "#!/usr/bin/env python\n",
        "# -*- coding: utf-8 -*-\n",
        "\n",
        "from manim_imports_ext import *\n",
        "# from _2017.efvgt import ConfettiSpiril\n",
        "\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "\n",
        "class HappyHolidays(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        hats = VGroup(*list(map(\n",
        "            self.get_hat, self.pi_creatures\n",
        "        )))\n",
        "        self.add(self.get_snowflakes())\n",
        "        self.play_student_changes(\n",
        "            *[\"hooray\"]*3,\n",
        "            look_at = FRAME_Y_RADIUS*UP,\n",
        "            added_anims = [self.teacher.change, \"hooray\"]\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            DrawBorderThenFill, hats\n",
        "        ), Animation(self.pi_creatures))\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"wave_2\", \"wave_1\",\n",
        "            look_at = FRAME_Y_RADIUS*UP,\n",
        "        )\n",
        "        self.look_at(self.teacher.get_corner(UP+LEFT))\n",
        "        self.wait(2)\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_hat(self, pi):\n",
        "        hat = SVGMobject(\n",
        "            file_name = \"santa_hat\",\n",
        "            height = 0.5*pi.get_height()\n",
        "        )\n",
        "        hat.rotate(-np.pi/12)\n",
        "        vect = RIGHT\n",
        "        if not pi.is_flipped():\n",
        "            hat.flip()\n",
        "            vect = LEFT\n",
        "        hat.set_fill(RED_D)\n",
        "        hat.set_stroke(width=0)\n",
        "        hat[0].set_points(hat[0].get_points()[8 * 4:])\n",
        "        hat[0].set_fill(\"#DDDDDD\")\n",
        "        hat[2].set_fill(WHITE)\n",
        "        hat.add(hat[0])\n",
        "        hat.next_to(pi.body, UP, buff = SMALL_BUFF)\n",
        "        hat.shift(SMALL_BUFF*vect)\n",
        "        return hat\n",
        "\n",
        "    def get_snowflakes(self, n_flakes = 50):\n",
        "        snowflakes = VGroup(*[\n",
        "            SVGMobject(\n",
        "                file_name = \"snowflake\",\n",
        "                height = 0.5,\n",
        "                stroke_width = 0,\n",
        "                fill_opacity = 0.75,\n",
        "                fill_color = WHITE,\n",
        "            ).rotate(np.pi/12, RIGHT)\n",
        "            for x in range(n_flakes)\n",
        "        ])\n",
        "        def random_confetti_spiral(mob, **kwargs):\n",
        "            return ConfettiSpiril(\n",
        "                mob, x_start = 2*random.random()*FRAME_X_RADIUS - FRAME_X_RADIUS,\n",
        "                **kwargs\n",
        "            )\n",
        "        snowflake_spirils = LaggedStartMap(\n",
        "            random_confetti_spiral, snowflakes,\n",
        "            run_time = 10,\n",
        "            rate_func = lambda x : x,\n",
        "        )\n",
        "        return turn_animation_into_updater(snowflake_spirils)\n",
        "\n",
        "class UtilitiesPuzzleScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"object_height\" : 0.75,\n",
        "        \"h_distance\" : 2,\n",
        "        \"v_distance\" : 2,\n",
        "        \"line_width\" : 4,\n",
        "    }\n",
        "    def setup_configuration(self):\n",
        "        houses = VGroup()\n",
        "        for x in range(3):\n",
        "            house = SVGMobject(file_name = \"house\")\n",
        "            house.set_stroke(BLACK, 5, background=True)\n",
        "            house.set_height(self.object_height)\n",
        "            house.set_fill(GREY_B)\n",
        "            house.move_to(x*self.h_distance*RIGHT)\n",
        "            houses.add(house)\n",
        "        houses.move_to(self.v_distance*UP/2)\n",
        "\n",
        "        utilities = VGroup(*[\n",
        "            self.get_utility(u, c).move_to(x*self.h_distance*RIGHT)\n",
        "            for x, u, c in zip(\n",
        "                it.count(),\n",
        "                [\"fire\", \"electricity\", \"water\"], \n",
        "                [RED_D, YELLOW_C, BLUE_D]\n",
        "            )\n",
        "        ])\n",
        "        utilities.move_to(self.v_distance*DOWN/2)\n",
        "        objects = VGroup(houses, utilities)\n",
        "        bounding_box = SurroundingRectangle(\n",
        "            objects,   \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            stroke_width = 0\n",
        "        )\n",
        "        objects.add(bounding_box)\n",
        "        self.add(objects)\n",
        "        self.houses = houses\n",
        "        self.utilities = utilities\n",
        "        self.objects = objects\n",
        "        self.bounding_box = bounding_box\n",
        "\n",
        "\n",
        "    def get_utility(self, name, color):\n",
        "        circle = Circle(\n",
        "            fill_color = color,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        utility = SVGMobject(\n",
        "            file_name = name,\n",
        "            height = 0.65*circle.get_height(),\n",
        "            fill_color = WHITE,\n",
        "        )\n",
        "        utility.insert_n_curves(100)\n",
        "        utility.set_stroke(width=0)\n",
        "        if color == YELLOW:\n",
        "            utility.set_fill(GREY_D)\n",
        "        utility.move_to(circle)\n",
        "        circle.add(utility)\n",
        "        circle.set_height(self.object_height)\n",
        "        return circle\n",
        "\n",
        "    def get_line(\n",
        "        self, utility_index, house_index, \n",
        "        *midpoints,\n",
        "        **kwargs\n",
        "        ):\n",
        "        prop = kwargs.pop(\"prop\", 1.0)\n",
        "        utility = self.utilities[utility_index]\n",
        "        points = [utility.get_center()]\n",
        "        points += list(midpoints)\n",
        "        points += [self.houses[house_index].get_center()]\n",
        "        line = Line(\n",
        "            points[0], points[-1],\n",
        "            color = utility[0].get_color(),\n",
        "            stroke_width = self.line_width\n",
        "        )\n",
        "        line.set_points_smoothly(points)\n",
        "        line.pointwise_become_partial(line, 0, prop)\n",
        "        return line\n",
        "\n",
        "    def get_almost_solution_lines(self):\n",
        "        bb = self.bounding_box\n",
        "        return VGroup(\n",
        "            VGroup(\n",
        "                self.get_line(0, 0),\n",
        "                self.get_line(0, 1),\n",
        "                self.get_line(0, 2, bb.get_top()),\n",
        "            ),\n",
        "            VGroup(\n",
        "                self.get_line(1, 0, bb.get_corner(DOWN+LEFT)),\n",
        "                self.get_line(1, 1),\n",
        "                self.get_line(1, 2, bb.get_corner(DOWN+RIGHT)),\n",
        "            ),\n",
        "            VGroup(\n",
        "                self.get_line(2, 0, bb.get_top()),\n",
        "                self.get_line(2, 1),\n",
        "                self.get_line(2, 2),\n",
        "            ),\n",
        "        )\n",
        "\n",
        "    def get_straight_lines(self):\n",
        "        return VGroup(*[\n",
        "            VGroup(*[self.get_line(i, j) for j in range(3)])\n",
        "            for i in range(3)\n",
        "        ])\n",
        "\n",
        "    def get_no_crossing_words(self):\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.next_to(self.bounding_box.get_top(), UP, SMALL_BUFF)\n",
        "        words = OldTexText(\"No crossing!\")\n",
        "        words.next_to(arrow, UP, buff = SMALL_BUFF)\n",
        "        result = VGroup(words, arrow)\n",
        "        result.set_color(\"RED\")\n",
        "        return result\n",
        "\n",
        "    def get_region(self, *bounding_edges):\n",
        "        region = VMobject(mark_paths_closed = True)\n",
        "        for i, edge in enumerate(bounding_edges):\n",
        "            new_edge = edge.copy()\n",
        "            if i%2 == 1:\n",
        "                new_edge.set_points(new_edge.get_points()[::-1])\n",
        "            region.append_vectorized_mobject(new_edge)\n",
        "        region.set_stroke(width = 0)\n",
        "        region.set_fill(WHITE, opacity = 1)\n",
        "        return region\n",
        "\n",
        "    def convert_objects_to_dots(self, run_time = 2):\n",
        "        group = VGroup(*it.chain(self.houses, self.utilities))\n",
        "        for mob in group:\n",
        "            mob.target = Dot(color = mob.get_color())\n",
        "            mob.target.scale(2)\n",
        "            mob.target.move_to(mob)\n",
        "        self.play(LaggedStartMap(MoveToTarget, group, run_time = run_time))\n",
        "\n",
        "class PauseIt(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creatures\n",
        "        morty.center().to_edge(DOWN)\n",
        "        self.pi_creature_says(\n",
        "            \"Pause it!\", target_mode = \"surprised\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        \n",
        "class AboutToyPuzzles(UtilitiesPuzzleScene, TeacherStudentsScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creatures)\n",
        "        self.lay_out_puzzle()\n",
        "        self.point_to_abstractions()\n",
        "        self.show_this_video()\n",
        "\n",
        "    def lay_out_puzzle(self):\n",
        "        self.setup_configuration()\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        lines = VGroup(*it.chain(*self.get_almost_solution_lines()))\n",
        "        no_crossing_words = self.get_no_crossing_words()\n",
        "\n",
        "        self.remove(self.objects)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(houses[1], houses[1]).copy().fade(1),\n",
        "                VGroup(houses[0], houses[2]),\n",
        "                rate_func = squish_rate_func(smooth, 0.35, 1),\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            FadeIn(houses[1]),\n",
        "            LaggedStartMap(DrawBorderThenFill, utilities, run_time = 2)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreation, lines, \n",
        "                run_time = 3\n",
        "            ),\n",
        "            Animation(self.objects)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(no_crossing_words[0]),\n",
        "            GrowArrow(no_crossing_words[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.objects.add_to_back(lines, no_crossing_words)\n",
        "\n",
        "    def point_to_abstractions(self):\n",
        "        objects = self.objects\n",
        "        objects.generate_target()\n",
        "        objects.target.scale(0.5)\n",
        "        objects.target.move_to(\n",
        "            (FRAME_Y_RADIUS*DOWN + FRAME_X_RADIUS*LEFT)/2\n",
        "        )\n",
        "\n",
        "        eulers = OldTex(*\"V-E+F=2\")\n",
        "        eulers.set_color_by_tex_to_color_map({\n",
        "            \"V\" : RED,\n",
        "            \"E\" : GREEN,\n",
        "            \"F\" : BLUE,\n",
        "        })\n",
        "        eulers.to_edge(UP, buff = 2)\n",
        "\n",
        "        cube = Cube()\n",
        "        cube.set_stroke(WHITE, 2)\n",
        "        cube.set_height(0.75)\n",
        "        cube.pose_at_angle()\n",
        "        cube.next_to(eulers, UP)\n",
        "\n",
        "        tda = OldTexText(\"Topological \\\\\\\\ Data Analysis\")\n",
        "        tda.move_to(DOWN + 4*RIGHT)\n",
        "\n",
        "        arrow_from_eulers = Arrow(\n",
        "            eulers.get_bottom(), tda.get_corner(UP+LEFT),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            objects.scale, 0.5,\n",
        "            objects.move_to, DOWN + 4*LEFT,\n",
        "        )\n",
        "        arrow_to_eulers = Arrow(\n",
        "            self.houses[2].get_corner(UP+LEFT),\n",
        "            eulers.get_bottom(),\n",
        "            color = WHITE\n",
        "        )\n",
        "        always_rotate(cube, axis=UP)\n",
        "        self.play(\n",
        "            GrowArrow(arrow_to_eulers),\n",
        "            Write(eulers),\n",
        "            FadeIn(cube)\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            GrowArrow(arrow_from_eulers),\n",
        "            Write(tda)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            eulers, cube, tda,\n",
        "            arrows = VGroup(arrow_to_eulers, arrow_from_eulers),\n",
        "        )\n",
        "\n",
        "    def show_this_video(self):\n",
        "        screen_rect = FullScreenFadeRectangle(\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 2,\n",
        "            fill_opacity = 0,\n",
        "        )\n",
        "        everything = VGroup(\n",
        "            self.objects, self.arrows, self.eulers, \n",
        "            self.cube, self.tda,\n",
        "            screen_rect,\n",
        "        )\n",
        "\n",
        "        self.teacher.save_state()\n",
        "        self.teacher.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            everything.scale, 0.5,\n",
        "            everything.next_to, self.teacher, UP+LEFT,\n",
        "            self.teacher.restore,\n",
        "            self.teacher.change, \"raise_right_hand\", UP+LEFT,\n",
        "            LaggedStartMap(FadeIn, self.students)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3, look_at = everything\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "class ThisPuzzleIsHard(UtilitiesPuzzleScene, PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.introduce_components()\n",
        "        self.failed_attempts()\n",
        "        self.ask_meta_puzzle()\n",
        "\n",
        "    def introduce_components(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        try_it = OldTexText(\"Try it yourself!\")\n",
        "        try_it.to_edge(UP)\n",
        "\n",
        "        self.setup_configuration()\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        self.remove(self.objects)\n",
        "        house = houses[0]\n",
        "\n",
        "        puzzle_words = OldTexText(\"\"\"\n",
        "            Puzzle: Connect each house to \\\\\\\\\n",
        "            each utility without crossing lines.\n",
        "        \"\"\")\n",
        "        # puzzle_words.next_to(self.objects, UP)\n",
        "        puzzle_words.to_edge(UP)\n",
        "\n",
        "        self.add(try_it)\n",
        "        self.play(Animation(try_it))\n",
        "        self.play(\n",
        "            LaggedStartMap(DrawBorderThenFill, houses),\n",
        "            LaggedStartMap(GrowFromCenter, utilities),\n",
        "            try_it.set_width, house.get_width(),\n",
        "            try_it.fade, 1,\n",
        "            try_it.move_to, house,\n",
        "            self.pi_creature.change, \"happy\",\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, puzzle_words))\n",
        "\n",
        "        self.add_foreground_mobjects(self.objects)\n",
        "        self.set_variables_as_attrs(puzzle_words)\n",
        "\n",
        "    def failed_attempts(self):\n",
        "        bb = self.bounding_box\n",
        "        utilities = self.utilities\n",
        "        houses = self.houses\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        line_sets = [\n",
        "            [\n",
        "                self.get_line(0, 0),\n",
        "                self.get_line(1, 1),\n",
        "                self.get_line(2, 2),\n",
        "                self.get_line(0, 1),\n",
        "                self.get_line(2, 1),\n",
        "                self.get_line(0, 2, bb.get_corner(UP+LEFT)),\n",
        "                self.get_line(\n",
        "                    2, 0, bb.get_corner(DOWN+LEFT),\n",
        "                    prop = 0.85,\n",
        "                ),\n",
        "                self.get_line(\n",
        "                    2, 0, bb.get_corner(UP+RIGHT), bb.get_top(),\n",
        "                    prop = 0.73,\n",
        "                ),\n",
        "            ],\n",
        "            [\n",
        "                self.get_line(0, 0),\n",
        "                self.get_line(1, 1),\n",
        "                self.get_line(2, 2),\n",
        "                self.get_line(0, 1),\n",
        "                self.get_line(1, 2),\n",
        "                self.get_line(\n",
        "                    2, 0, \n",
        "                    bb.get_bottom(),\n",
        "                    bb.get_corner(DOWN+LEFT)\n",
        "                ),\n",
        "                self.get_line(0, 2, bb.get_top()),\n",
        "                self.get_line(\n",
        "                    2, 1,\n",
        "                    utilities[1].get_bottom() + MED_SMALL_BUFF*DOWN,\n",
        "                    utilities[1].get_left() + MED_SMALL_BUFF*LEFT,\n",
        "                ),\n",
        "                self.get_line(\n",
        "                    1, 0, houses[2].get_corner(UP+LEFT) + MED_LARGE_BUFF*LEFT,\n",
        "                    prop = 0.49,\n",
        "                ),\n",
        "                self.get_line(\n",
        "                    1, 2, bb.get_right(),\n",
        "                    prop = 0.25,\n",
        "                ),\n",
        "            ],\n",
        "            [\n",
        "                self.get_line(0, 0),\n",
        "                self.get_line(0, 1),\n",
        "                self.get_line(0, 2, bb.get_top()),\n",
        "                self.get_line(1, 0, bb.get_corner(DOWN+LEFT)),\n",
        "                self.get_line(1, 1),\n",
        "                self.get_line(1, 2, bb.get_corner(DOWN+RIGHT)),\n",
        "                self.get_line(2, 1),\n",
        "                self.get_line(2, 2),\n",
        "                self.get_line(2, 0, bb.get_top(), prop = 0.45),\n",
        "                self.get_line(2, 0, prop = 0.45),\n",
        "            ],\n",
        "        ]\n",
        "        modes = [\"confused\", \"sassy\", \"angry\"]\n",
        "\n",
        "        for line_set, mode in zip(line_sets, modes):\n",
        "            good_lines = VGroup(*line_set[:-2])\n",
        "            bad_lines = line_set[-2:]\n",
        "            self.play(LaggedStartMap(ShowCreation, good_lines))\n",
        "            for bl in bad_lines:\n",
        "                self.play(\n",
        "                    ShowCreation(\n",
        "                        bl,\n",
        "                        rate_func = bezier([0, 0, 0, 1, 1, 1, 1, 1, 0.3, 1, 1]),\n",
        "                        run_time = 1.5\n",
        "                    ),\n",
        "                    randy.change, mode,\n",
        "                )\n",
        "                self.play(ShowCreation(\n",
        "                    bl, rate_func = lambda t : smooth(1-t),\n",
        "                ))\n",
        "                self.remove(bl)\n",
        "            self.play(LaggedStartMap(FadeOut, good_lines))\n",
        "\n",
        "    def ask_meta_puzzle(self):\n",
        "        randy = self.pi_creature\n",
        "        group = VGroup(\n",
        "            self.puzzle_words,\n",
        "            self.objects,\n",
        "        )\n",
        "        rect = SurroundingRectangle(group, color = BLUE, buff = MED_LARGE_BUFF)\n",
        "        group.add(rect)\n",
        "        group.generate_target()\n",
        "        group.target.scale(0.75)\n",
        "        group.target.shift(DOWN)\n",
        "        group[-1].set_stroke(width = 0)\n",
        "\n",
        "        meta_puzzle_words = OldTexText(\"\"\"\n",
        "            Meta-puzzle: Prove that this\\\\\\\\\n",
        "            is impossible.\n",
        "        \"\"\")\n",
        "        meta_puzzle_words.next_to(group.target, UP)\n",
        "        meta_puzzle_words.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(group),\n",
        "            randy.change, \"pondering\"\n",
        "        )\n",
        "        self.play(Write(meta_puzzle_words))\n",
        "        self.play(randy.change, \"confused\")\n",
        "\n",
        "        straight_lines = self.get_straight_lines()\n",
        "        almost_solution_lines = self.get_almost_solution_lines()\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, straight_lines,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.8\n",
        "        ), Blink(randy))\n",
        "        self.play(Transform(\n",
        "            straight_lines, almost_solution_lines,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    ######\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().to_corner(DOWN+LEFT)\n",
        "\n",
        "class IntroduceGraph(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        pi_creatures = self.pi_creatures\n",
        "        dots = VGroup(*[\n",
        "            Dot(color = pi.get_color()).scale(2).move_to(pi)\n",
        "            for pi in pi_creatures\n",
        "        ])\n",
        "        lines = VGroup(*[\n",
        "            Line(pi1.get_center(), pi2.get_center())\n",
        "            for pi1, pi2 in it.combinations(pi_creatures, 2)\n",
        "        ])\n",
        "\n",
        "        graph_word = OldTexText(\"``\", \"\", \"Graph\", \"''\", arg_separator = \"\")\n",
        "        graph_word.to_edge(UP)\n",
        "        planar_graph_word = OldTexText(\"``\", \"Planar\", \" graph\", \"''\", arg_separator = \"\")\n",
        "        planar_graph_word.move_to(graph_word)\n",
        "\n",
        "        vertices_word = OldTexText(\"Vertices\")\n",
        "        vertices_word.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        vertices_word.set_color(YELLOW)\n",
        "\n",
        "        vertex_arrows = VGroup(*[\n",
        "            Arrow(vertices_word.get_left(), dot)\n",
        "            for dot in dots[-2:]\n",
        "        ])\n",
        "\n",
        "        edge_word = OldTexText(\"Edge\")\n",
        "        edge_word.next_to(lines, LEFT, LARGE_BUFF)\n",
        "        edge_arrow = Arrow(\n",
        "            edge_word, lines, buff = SMALL_BUFF,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, pi_creatures))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, pi_creatures,\n",
        "                lambda pi : (pi.change, \"pondering\", lines)\n",
        "            )\n",
        "        )\n",
        "        self.play(Write(graph_word))\n",
        "        self.play(ReplacementTransform(\n",
        "            pi_creatures, dots,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.add_foreground_mobjects(dots)\n",
        "        self.play(\n",
        "            FadeIn(vertex_arrows),\n",
        "            FadeIn(vertices_word),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, lines,\n",
        "            lambda l : (l.rotate, np.pi/12),\n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.play(\n",
        "            FadeIn(edge_word),\n",
        "            GrowArrow(edge_arrow),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        line = lines[2]\n",
        "        self.play(\n",
        "            line.set_points_smoothly, [\n",
        "                line.get_start(),\n",
        "                dots.get_left() + MED_SMALL_BUFF*LEFT,\n",
        "                dots.get_corner(DOWN+LEFT) + MED_SMALL_BUFF*(DOWN+LEFT),\n",
        "                dots.get_bottom() + MED_SMALL_BUFF*DOWN,\n",
        "                line.get_end(),\n",
        "            ],\n",
        "            VGroup(edge_word, edge_arrow).shift, MED_LARGE_BUFF*LEFT,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(graph_word, planar_graph_word))\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        pis = VGroup(\n",
        "            PiCreature(color = BLUE_D),\n",
        "            PiCreature(color = GREY_BROWN),\n",
        "            PiCreature(color = BLUE_C).flip(),\n",
        "            PiCreature(color = BLUE_E).flip(),\n",
        "        )\n",
        "        pis.scale(0.5)\n",
        "        pis.arrange_in_grid(buff = 2)\n",
        "        return pis\n",
        "\n",
        "class IsK33Planar(UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        self.objects.shift(MED_LARGE_BUFF*DOWN)\n",
        "\n",
        "        straight_lines = self.get_straight_lines()\n",
        "        almost_solution_lines = self.get_almost_solution_lines()\n",
        "\n",
        "        question = OldTexText(\"Is\", \"this graph\", \"planar?\")\n",
        "        question.set_color_by_tex(\"this graph\", YELLOW)\n",
        "        question.to_edge(UP)\n",
        "        brace = Brace(question.get_part_by_tex(\"graph\"), DOWN, buff = SMALL_BUFF)\n",
        "        fancy_name = brace.get_text(\n",
        "            \"``Complete bipartite graph $K_{3, 3}$''\",\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        fancy_name.set_color(YELLOW)\n",
        "\n",
        "        self.add(question)\n",
        "        self.convert_objects_to_dots()\n",
        "        self.play(LaggedStartMap(ShowCreation, straight_lines))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            LaggedStartMap(FadeIn, fancy_name),\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            straight_lines, almost_solution_lines,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "class TwoKindsOfViewers(PiCreatureScene, UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        objects = self.objects\n",
        "        objects.remove(self.bounding_box)\n",
        "        lines = self.get_straight_lines()\n",
        "        objects.add_to_back(lines)\n",
        "        objects.scale(0.75)\n",
        "        objects.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        self.remove(objects)\n",
        "\n",
        "        pi1, pi2 = self.pi_creatures\n",
        "        words = OldTexText(\n",
        "            \"$(V-E+F)$\", \"kinds of viewers\"\n",
        "        )\n",
        "        words.to_edge(UP)\n",
        "        eulers = words.get_part_by_tex(\"V-E+F\")\n",
        "        eulers.set_color(GREEN)\n",
        "        non_eulers = VGroup(*[m for m in words if m is not eulers])\n",
        "\n",
        "        self.add(words)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            pi1.shift, 2*LEFT,\n",
        "            pi2.shift, 2*RIGHT,\n",
        "        )\n",
        "\n",
        "        know_eulers = OldTexText(\"Know about \\\\\\\\ Euler's formula\")\n",
        "        know_eulers.next_to(pi1, DOWN)\n",
        "        know_eulers.set_color(GREEN)\n",
        "        dont = OldTexText(\"Don't\")\n",
        "        dont.next_to(pi2, DOWN)\n",
        "        dont.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(know_eulers),\n",
        "            pi1.change, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(dont),\n",
        "            pi2.change, \"maybe\", eulers,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.pi_creature_thinks(\n",
        "            pi1, \"\",\n",
        "            bubble_config = {\"width\" : 3, \"height\" : 2},\n",
        "            target_mode = \"thinking\"\n",
        "        )\n",
        "        self.play(pi2.change, \"confused\", eulers)\n",
        "        self.wait()\n",
        "\n",
        "        ### Out of thin air\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            non_eulers, pi1, pi2, pi1.bubble,\n",
        "            know_eulers, dont\n",
        "        ])))\n",
        "        self.play(eulers.next_to, ORIGIN, LEFT, LARGE_BUFF)\n",
        "        arrow = Arrow(eulers, objects, color = WHITE)\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            LaggedStartMap(DrawBorderThenFill, VGroup(*it.chain(*objects)))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            objects.move_to, eulers, RIGHT,\n",
        "            eulers.move_to, objects, LEFT,\n",
        "            path_arc = np.pi,\n",
        "            run_time = 1.5,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        group = VGroup(Randolph(color = BLUE_C), Randolph())\n",
        "        group.scale(0.7)\n",
        "        group.shift(MED_LARGE_BUFF*DOWN)\n",
        "        return group\n",
        "\n",
        "class IntroduceRegions(UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        objects = self.objects\n",
        "        lines, line_groups, regions = self.get_lines_line_groups_and_regions()\n",
        "        back_region = regions[0]\n",
        "        front_regions = VGroup(*regions[1:])\n",
        "\n",
        "        self.convert_objects_to_dots(run_time = 0)\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, lines,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.add_foreground_mobjects(lines, objects)\n",
        "        self.wait()\n",
        "        for region in front_regions:\n",
        "            self.play(FadeIn(region))\n",
        "        self.play(\n",
        "            FadeIn(back_region),\n",
        "            Animation(front_regions),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(regions))\n",
        "\n",
        "        ##Paint bucket\n",
        "        paint_bucket = SVGMobject(\n",
        "            file_name = \"paint_bucket\",\n",
        "            height = 0.5,\n",
        "        )\n",
        "        paint_bucket.flip()\n",
        "        paint_bucket.move_to(8*LEFT + 5*UP)\n",
        "\n",
        "        def click(region):\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    region,\n",
        "                    lambda m, a : m.set_fill(opacity = int(2*a)),\n",
        "                ),\n",
        "                ApplyMethod(\n",
        "                    paint_bucket.scale, 0.5,\n",
        "                    rate_func = there_and_back,\n",
        "                ),\n",
        "                run_time = 0.25,\n",
        "            )\n",
        "\n",
        "        self.play(\n",
        "            paint_bucket.next_to, utilities, DOWN+LEFT, SMALL_BUFF\n",
        "        )\n",
        "        click(regions[1])\n",
        "        self.play(paint_bucket.next_to, utilities[1], UP+RIGHT, SMALL_BUFF)\n",
        "        click(regions[2])\n",
        "        self.play(paint_bucket.next_to, houses[1], RIGHT)\n",
        "        click(regions[3])\n",
        "        self.play(paint_bucket.move_to, 4*LEFT + 2*UP)\n",
        "        self.add_foreground_mobjects(front_regions, lines, objects)\n",
        "        click(back_region)\n",
        "        self.remove_foreground_mobjects(front_regions)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(back_region),\n",
        "            FadeOut(front_regions[0]),\n",
        "            FadeOut(paint_bucket),\n",
        "            *list(map(Animation, front_regions[1:]))\n",
        "        )\n",
        "\n",
        "        #Line tries to escape\n",
        "        point_sets = [\n",
        "            [\n",
        "                VGroup(*houses[1:]).get_center(),\n",
        "                houses[2].get_top() + MED_SMALL_BUFF*UP,\n",
        "            ],\n",
        "            [\n",
        "                houses[1].get_top() + SMALL_BUFF*UP,\n",
        "                utilities[0].get_center(),\n",
        "            ],\n",
        "            [VGroup(houses[1], utilities[1]).get_center()],\n",
        "            [\n",
        "                utilities[2].get_center() + 0.75*(DOWN+RIGHT)\n",
        "            ],\n",
        "        ]\n",
        "        escape_lines = VGroup(*[\n",
        "            Line(LEFT, RIGHT).set_points_smoothly(\n",
        "                [utilities[2].get_center()] + point_set\n",
        "            )\n",
        "            for point_set in point_sets\n",
        "        ])\n",
        "\n",
        "        self.wait()\n",
        "        for line in escape_lines:\n",
        "            self.play(ShowCreation(line,\n",
        "                rate_func = lambda t : 0.8*smooth(t)\n",
        "            ))\n",
        "            self.play(ShowCreation(line,\n",
        "                rate_func = lambda t : smooth(1 - t)\n",
        "            ))\n",
        "\n",
        "    def get_lines_line_groups_and_regions(self):\n",
        "        lines = self.get_almost_solution_lines()\n",
        "        flat_lines = VGroup(*it.chain(*lines))\n",
        "        flat_lines.remove(lines[2][0])\n",
        "\n",
        "        line_groups = [\n",
        "            VGroup(*[lines[i][j] for i, j in ij_set])\n",
        "            for ij_set in [\n",
        "                [(0, 0), (1, 0), (1, 1), (0, 1)],\n",
        "                [(1, 1), (2, 1), (2, 2), (1, 2)],\n",
        "                [(0, 2), (2, 2), (2, 1), (0, 1)],\n",
        "                [(0, 0), (1, 0), (1, 2), (0, 2)],\n",
        "            ]\n",
        "        ]\n",
        "        regions = VGroup(*[\n",
        "            self.get_region(*line_group)\n",
        "            for line_group in line_groups\n",
        "        ])\n",
        "        back_region = FullScreenFadeRectangle(fill_opacity = 1 )\n",
        "        regions.submobjects.pop()\n",
        "        regions.submobjects.insert(0, back_region)\n",
        "        front_regions = VGroup(*regions[1:])\n",
        "\n",
        "        back_region.set_color(BLUE_E)\n",
        "        front_regions.set_color_by_gradient(GREEN_E, MAROON_E)\n",
        "\n",
        "        return flat_lines, line_groups, regions\n",
        "\n",
        "class FromLastVideo(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"From last video\")\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height = 6)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(2)\n",
        "\n",
        "class AskAboutRegions(IntroduceRegions):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        self.convert_objects_to_dots(run_time = 0)\n",
        "        objects = self.objects\n",
        "        lines, line_groups, regions = self.get_lines_line_groups_and_regions()\n",
        "        back_region = regions[0]\n",
        "        front_regions = VGroup(*regions[1:])\n",
        "        missing_lines = VGroup(\n",
        "            self.get_line(2, 0, self.objects.get_top()),\n",
        "            self.get_line(\n",
        "                2, 0, \n",
        "                self.objects.get_bottom() + DOWN,\n",
        "                self.objects.get_corner(DOWN+LEFT) + DOWN+LEFT,\n",
        "            )\n",
        "        )\n",
        "        missing_lines.set_stroke(width = 5)\n",
        "\n",
        "        front_regions.save_state()\n",
        "        front_regions.generate_target()\n",
        "        front_regions.target.scale(0.5)\n",
        "        front_regions.target.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        front_regions.target.to_edge(UP)\n",
        "\n",
        "        self.add(front_regions)\n",
        "        self.add_foreground_mobjects(lines, objects)\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(front_regions))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, front_regions,\n",
        "            lambda m : (m.rotate, np.pi/12),\n",
        "            rate_func = wiggle,\n",
        "            lag_ratio = 0.75,\n",
        "            run_time = 1\n",
        "        ))\n",
        "        self.play(front_regions.restore)\n",
        "        self.wait()\n",
        "\n",
        "        #Show missing lines\n",
        "        for line in missing_lines:\n",
        "            self.play(ShowCreation(\n",
        "                line,\n",
        "                rate_func = there_and_back,\n",
        "                run_time = 2,\n",
        "            ))\n",
        "\n",
        "        #Count regions\n",
        "        count = OldTex(\"1\")\n",
        "        count.scale(1.5)\n",
        "        count.to_edge(UP)\n",
        "        self.play(\n",
        "            FadeIn(back_region), \n",
        "            FadeIn(count),\n",
        "            Animation(front_regions)\n",
        "        )\n",
        "        last_region = None\n",
        "        for n, region in zip(it.count(2), front_regions):\n",
        "            new_count = OldTex(str(n))\n",
        "            new_count.replace(count, dim_to_match = 1)\n",
        "            self.remove(count)\n",
        "            self.add(new_count)\n",
        "            count = new_count\n",
        "\n",
        "            region.save_state()\n",
        "            anims = [ApplyMethod(region.set_color, YELLOW)]\n",
        "            if last_region:\n",
        "                anims.append(ApplyMethod(last_region.restore))\n",
        "            anims.append(Animation(front_regions))\n",
        "            self.play(*anims, run_time = 0.25)\n",
        "            self.wait(0.5)\n",
        "            last_region = region\n",
        "        self.play(last_region.restore)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(count))\n",
        "\n",
        "        #Count edges per region\n",
        "        fade_rect = FullScreenFadeRectangle(opacity = 0.8)\n",
        "        line_group = line_groups[0].copy()\n",
        "        region = front_regions[0].copy()\n",
        "        self.foreground_mobjects = []\n",
        "        def show_lines(line_group):\n",
        "            lg_copy = line_group.copy()\n",
        "            lg_copy.set_stroke(WHITE, 6)\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, lg_copy,\n",
        "                run_time = 3,\n",
        "                rate_func = there_and_back,\n",
        "                lag_ratio = 0.4,\n",
        "                remover = True,\n",
        "            ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(fade_rect),\n",
        "            Animation(region),\n",
        "            Animation(line_group),\n",
        "        )\n",
        "        show_lines(line_group)\n",
        "        last_line_group = line_group\n",
        "        last_region = region\n",
        "        for i in range(1, 3):\n",
        "            line_group = line_groups[i].copy()\n",
        "            region = front_regions[i].copy()\n",
        "            self.play(\n",
        "                FadeOut(last_region),\n",
        "                FadeOut(last_line_group),\n",
        "                FadeIn(region),\n",
        "                FadeIn(line_group),\n",
        "            )\n",
        "            show_lines(line_group)\n",
        "            last_line_group = line_group\n",
        "            last_region = region\n",
        "        self.play(\n",
        "            FadeOut(fade_rect),\n",
        "            FadeOut(last_region),\n",
        "            FadeOut(last_line_group),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class NewRegionClosedOnlyForNodesWithEdges(UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        self.convert_objects_to_dots(run_time = 0)\n",
        "        objects = self.objects\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "\n",
        "        bb = self.bounding_box\n",
        "        lines = VGroup(\n",
        "            self.get_line(2, 1),\n",
        "            self.get_line(0, 1),\n",
        "            self.get_line(0, 2,\n",
        "                bb.get_corner(UP+LEFT),\n",
        "                bb.get_top() + MED_LARGE_BUFF*UP,\n",
        "            ),\n",
        "            self.get_line(2, 2),\n",
        "        )\n",
        "        lit_line = lines[2].copy()\n",
        "        lit_line.set_points(lit_line.get_points()[::-1])\n",
        "        lit_line.set_stroke(WHITE, 5)\n",
        "\n",
        "        region = self.get_region(*lines)\n",
        "        region.set_fill(MAROON_E)\n",
        "\n",
        "        arrow = Vector(DOWN+LEFT, color = WHITE)\n",
        "        arrow.next_to(houses[2], UP+RIGHT, buff = SMALL_BUFF)\n",
        "        words = OldTexText(\"Already has \\\\\\\\ an edge\")\n",
        "        words.next_to(arrow.get_start(), UP, SMALL_BUFF)\n",
        "\n",
        "        for line in lines[:-1]:\n",
        "            self.play(ShowCreation(line))\n",
        "        lines[-1].pointwise_become_partial(lines[-1], 0, 0.92)\n",
        "        lines[-1].save_state()\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(lines[-1]))\n",
        "        self.add(region, lines, objects)\n",
        "        self.wait()\n",
        "        self.remove(region)\n",
        "        self.play(ShowCreation(lines[-1], \n",
        "            rate_func = lambda t : smooth(1-2*t*(1-t))\n",
        "        ))\n",
        "        self.add(region, lines, objects)\n",
        "        self.wait()\n",
        "        self.remove(region)\n",
        "        self.play(\n",
        "            ShowCreation(lines[-1],\n",
        "                rate_func = lambda t : smooth(1-0.5*t)\n",
        "            ),\n",
        "            FadeIn(words),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(ShowCreationThenDestruction(lit_line))\n",
        "        self.play(lines[-1].restore)\n",
        "        self.add(region, lines, objects)\n",
        "        self.wait(2)\n",
        "\n",
        "class LightUpNodes(IntroduceRegions):\n",
        "    CONFIG = {\n",
        "        \"vertices_word\" : \"Lit vertices\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        self.setup_regions()\n",
        "        self.setup_counters()\n",
        "        self.describe_one_as_lit()\n",
        "        self.show_rule_for_lighting()\n",
        "\n",
        "    def setup_configuration(self):\n",
        "        IntroduceRegions.setup_configuration(self)\n",
        "        self.convert_objects_to_dots(run_time = 0)\n",
        "        self.objects.shift(DOWN)\n",
        "\n",
        "    def setup_regions(self):\n",
        "        lines, line_groups, regions = self.get_lines_line_groups_and_regions()\n",
        "        back_region = regions[0]\n",
        "        front_regions = VGroup(*regions[1:])\n",
        "        self.set_variables_as_attrs(\n",
        "            lines, line_groups, regions,\n",
        "            back_region, front_regions,\n",
        "        )\n",
        "\n",
        "    def setup_counters(self):\n",
        "        titles = [\n",
        "            OldTexText(\"\\\\# %s\"%self.vertices_word),\n",
        "            OldTexText(\"\\\\# Edges\"),\n",
        "            OldTexText(\"\\\\# Regions\"),\n",
        "        ]\n",
        "        for title, vect in zip(titles, [LEFT, ORIGIN, RIGHT]):\n",
        "            title.shift(FRAME_X_RADIUS*vect/2)\n",
        "            title.to_edge(UP)\n",
        "            underline = Line(LEFT, RIGHT)\n",
        "            underline.stretch_to_fit_width(title.get_width())\n",
        "            underline.next_to(title, DOWN, SMALL_BUFF)\n",
        "            title.add(underline)\n",
        "            self.add(title)\n",
        "        self.count_titles = titles\n",
        "        self.v_count, self.e_count, self.f_count = self.counts = list(map(\n",
        "            Integer, [1, 0, 1]\n",
        "        ))\n",
        "        for count, title in zip(self.counts, titles):\n",
        "            count.next_to(title, DOWN)\n",
        "            self.add(count)\n",
        "\n",
        "    def describe_one_as_lit(self):\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        vertices = VGroup(*it.chain(houses, utilities))\n",
        "        dim_arrows = VGroup()\n",
        "        for vertex in vertices:\n",
        "            arrow = Vector(0.5*(DOWN+LEFT), color = WHITE)\n",
        "            arrow.next_to(vertex, UP+RIGHT, SMALL_BUFF)\n",
        "            vertex.arrow = arrow\n",
        "            dim_arrows.add(arrow)\n",
        "        lit_vertex = utilities[0]\n",
        "        lit_arrow = lit_vertex.arrow\n",
        "        lit_arrow.rotate(np.pi/2, about_point = lit_vertex.get_center())\n",
        "        dim_arrows.remove(lit_arrow)\n",
        "        lit_word = OldTexText(\"Lit up\")\n",
        "        lit_word.next_to(lit_arrow.get_start(), UP, SMALL_BUFF)\n",
        "        dim_word = OldTexText(\"Dim\")\n",
        "        dim_word.next_to(dim_arrows[1].get_start(), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        dot = Dot().move_to(self.v_count)\n",
        "\n",
        "        self.play(\n",
        "            vertices.set_fill, None, 0,\n",
        "            vertices.set_stroke, None, 1,\n",
        "        )\n",
        "        self.play(ReplacementTransform(dot, lit_vertex))\n",
        "        self.play(\n",
        "            FadeIn(lit_word),\n",
        "            GrowArrow(lit_arrow)\n",
        "        )\n",
        "        self.play(*self.get_lit_vertex_animations(lit_vertex))\n",
        "        self.play(\n",
        "            FadeIn(dim_word),\n",
        "            LaggedStartMap(GrowArrow, dim_arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            lit_word, lit_arrow, dim_word, dim_arrows\n",
        "        ])))\n",
        "\n",
        "    def show_rule_for_lighting(self):\n",
        "        lines = self.lines\n",
        "        regions = self.regions\n",
        "        line_groups = self.line_groups\n",
        "        objects = self.objects\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "\n",
        "        #First region, lines 0, 1, 4, 3\n",
        "        lines[4].rotate(np.pi)\n",
        "        region = regions[1]\n",
        "\n",
        "        self.play(ShowCreation(lines[0]))\n",
        "        self.play(*self.get_count_change_animations(0, 1, 0))\n",
        "        self.play(*it.chain(\n",
        "            self.get_lit_vertex_animations(houses[0]),\n",
        "            self.get_count_change_animations(1, 0, 0)\n",
        "        ))\n",
        "        self.wait()\n",
        "        for line, vertex in (lines[1], houses[1]), (lines[4], utilities[1]):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                *self.get_count_change_animations(0, 1, 0)\n",
        "            )\n",
        "            self.play(*it.chain(\n",
        "                self.get_lit_vertex_animations(vertex),\n",
        "                self.get_count_change_animations(1, 0, 0),\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(lines[3], run_time = 2),\n",
        "            *self.get_count_change_animations(0, 1, 0)\n",
        "        )\n",
        "        self.add_foreground_mobjects(line_groups[0])\n",
        "        self.add_foreground_mobjects(objects)\n",
        "        self.play(\n",
        "            FadeIn(region),\n",
        "            *self.get_count_change_animations(0, 0, 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Next region, lines 2, 7, 8\n",
        "        region = regions[3]\n",
        "        lines[6].rotate(np.pi)\n",
        "\n",
        "        for line, vertex in (lines[2], houses[2]), (lines[6], utilities[2]):\n",
        "            self.play(ShowCreation(line), *it.chain(\n",
        "                self.get_lit_vertex_animations(\n",
        "                    vertex,\n",
        "                    run_time = 2, \n",
        "                    squish_range = (0.5, 1),\n",
        "                ),\n",
        "                self.get_count_change_animations(1, 1, 0)\n",
        "            ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(lines[7]),\n",
        "            *self.get_count_change_animations(0, 1, 1)\n",
        "        )\n",
        "        self.add_foreground_mobjects(line_groups[2])\n",
        "        self.add_foreground_mobjects(objects)\n",
        "        self.play(FadeIn(region))\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_count_change_animations(self, *changes):\n",
        "        anims = []\n",
        "        for change, count in zip(changes, self.counts):\n",
        "            if change == 0:\n",
        "                continue\n",
        "            new_count = Integer(count.number + 1)\n",
        "            new_count.move_to(count)\n",
        "            anims.append(Transform(\n",
        "                count, new_count,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ))\n",
        "            count.number += 1\n",
        "            anims.append(self.get_plus_one_anim(count))\n",
        "\n",
        "        return anims\n",
        "\n",
        "    def get_plus_one_anim(self, count):\n",
        "        plus_one = OldTex(\"+1\")\n",
        "        plus_one.set_color(YELLOW)\n",
        "        plus_one.move_to(count)\n",
        "        plus_one.next_to(count, DOWN)\n",
        "        plus_one.generate_target()\n",
        "        plus_one.target.move_to(count)\n",
        "        plus_one.target.set_fill(opacity = 0)\n",
        "        move = MoveToTarget(plus_one, remover = True)\n",
        "        grow = GrowFromCenter(plus_one)\n",
        "        return UpdateFromAlphaFunc(\n",
        "            plus_one,\n",
        "            lambda m, a : (\n",
        "                (grow if a < 0.5 else move).update(2*a%1)\n",
        "            ),\n",
        "            remover = True,\n",
        "            rate_func = double_smooth,\n",
        "            run_time = 2\n",
        "        )\n",
        "\n",
        "    def get_lit_vertex_animations(self, vertex, run_time = 1, squish_range = (0, 1)):\n",
        "        line = Line(\n",
        "            LEFT, RIGHT,\n",
        "            stroke_width = 0,\n",
        "            stroke_color = BLACK,\n",
        "        )\n",
        "        line.set_width(0.5*vertex.get_width())\n",
        "        line.next_to(ORIGIN, buff = 0.75*vertex.get_width())\n",
        "        lines = VGroup(*[\n",
        "            line.copy().rotate(angle)\n",
        "            for angle in np.arange(0, 2*np.pi, np.pi/4)\n",
        "        ])\n",
        "        lines.move_to(vertex)\n",
        "        random.shuffle(lines.submobjects)\n",
        "        return [\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, lines,\n",
        "                lambda l : (l.set_stroke, YELLOW, 4),\n",
        "                rate_func = squish_rate_func(there_and_back, *squish_range),\n",
        "                lag_ratio = 0.75,\n",
        "                remover = True,\n",
        "                run_time = run_time\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                vertex.set_fill, None, 1,\n",
        "                run_time = run_time,\n",
        "                rate_func = squish_rate_func(smooth, *squish_range)\n",
        "            ),\n",
        "        ]\n",
        "\n",
        "class ShowRule(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        new_edge = OldTexText(\"New edge\")\n",
        "        new_vertex = OldTexText(\"New (lit) vertex\")\n",
        "        new_vertex.next_to(new_edge, UP+RIGHT, MED_LARGE_BUFF)\n",
        "        new_region = OldTexText(\"New region\")\n",
        "        new_region.next_to(new_edge, DOWN+RIGHT, MED_LARGE_BUFF)\n",
        "        VGroup(new_vertex, new_region).shift(RIGHT)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                new_edge.get_right(), mob.get_left(), \n",
        "                color = WHITE,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            for mob in (new_vertex, new_region)\n",
        "        ])\n",
        "        for word, arrow in zip([\"Either\", \"or\"], arrows):\n",
        "            word_mob = OldTexText(word)\n",
        "            word_mob.scale(0.65)\n",
        "            word_mob.next_to(ORIGIN, UP, SMALL_BUFF)\n",
        "            word_mob.rotate(arrow.get_angle())\n",
        "            word_mob.shift(arrow.get_center())\n",
        "            word_mob.set_color(GREEN)\n",
        "            arrow.add(word_mob)\n",
        "        new_vertex.set_color(YELLOW)\n",
        "        new_edge.set_color(BLUE)\n",
        "        new_region.set_color(RED)\n",
        "        rule = VGroup(new_edge, arrows, new_vertex, new_region)\n",
        "        rule.center().to_edge(UP)\n",
        "\n",
        "        nine_total = OldTexText(\"(9 total)\")\n",
        "        nine_total.next_to(new_edge, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Animation(rule),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"confused\"]*3,\n",
        "            look_at = rule\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Write(nine_total),\n",
        "            self.teacher.change, \"happy\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"thinking\"]*3, \n",
        "            look_at = rule\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class ConcludeFiveRegions(LightUpNodes):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        self.setup_regions()\n",
        "        self.setup_counters()\n",
        "\n",
        "        self.describe_start_setup()\n",
        "        self.show_nine_lines_to_start()\n",
        "        self.show_five_to_lit_up_nodes()\n",
        "        self.relate_four_lines_to_regions()\n",
        "        self.conclude_about_five_regions()\n",
        "\n",
        "    def describe_start_setup(self):\n",
        "        to_dim = VGroup(*it.chain(self.houses, self.utilities[1:]))\n",
        "        to_dim.set_stroke(width = 1)\n",
        "        to_dim.set_fill(opacity = 0)\n",
        "\n",
        "        full_screen_rect = FullScreenFadeRectangle(\n",
        "            fill_color = GREY_B,\n",
        "            fill_opacity = 0.25,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Indicate(self.v_count),\n",
        "            *self.get_lit_vertex_animations(self.utilities[0])\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                full_screen_rect,\n",
        "                rate_func = there_and_back,\n",
        "                remover = True,\n",
        "            ),\n",
        "            Indicate(self.f_count),\n",
        "            *list(map(Animation, self.mobjects))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_nine_lines_to_start(self):\n",
        "        line_sets = self.get_straight_lines()\n",
        "        line_sets.target = VGroup()\n",
        "        for lines in line_sets:\n",
        "            lines.generate_target()\n",
        "            for line in lines.target:\n",
        "                line.rotate(-line.get_angle())\n",
        "                line.set_width(1.5)\n",
        "            lines.target.arrange(DOWN)\n",
        "            line_sets.target.add(lines.target)\n",
        "        line_sets.target.arrange(DOWN)\n",
        "        line_sets.target.center()\n",
        "        line_sets.target.to_edge(RIGHT)\n",
        "\n",
        "        for lines in line_sets:\n",
        "            self.play(LaggedStartMap(ShowCreation, lines, run_time = 1))\n",
        "            self.play(MoveToTarget(lines))\n",
        "        self.wait()\n",
        "\n",
        "        ghost_lines = line_sets.copy()\n",
        "        ghost_lines.fade(0.9)\n",
        "        self.add(ghost_lines, line_sets)\n",
        "        self.side_lines = VGroup(*it.chain(*line_sets))\n",
        "\n",
        "    def show_five_to_lit_up_nodes(self):\n",
        "        side_lines = self.side_lines\n",
        "        lines = self.lines\n",
        "        vertices = VGroup(*it.chain(self.houses, self.utilities))\n",
        "        line_indices = [0, 1, 4, 6, 7]\n",
        "        vertex_indices = [0, 1, 4, 5, 2]\n",
        "\n",
        "        for li, vi in zip(line_indices, vertex_indices):\n",
        "            side_line = side_lines[li]\n",
        "            line = lines[li]\n",
        "            vertex = vertices[vi]\n",
        "            self.play(ReplacementTransform(side_line, line))\n",
        "            self.play(*it.chain(\n",
        "                self.get_count_change_animations(1, 1, 0),\n",
        "                self.get_lit_vertex_animations(vertex),\n",
        "            ))\n",
        "\n",
        "    def relate_four_lines_to_regions(self):\n",
        "        f_rect = SurroundingRectangle(\n",
        "            VGroup(self.count_titles[-1], self.f_count)\n",
        "        )\n",
        "        on_screen_side_lines = VGroup(*[m for m in self.side_lines if m in self.mobjects])\n",
        "        side_lines_rect = SurroundingRectangle(on_screen_side_lines)\n",
        "        side_lines_rect.set_color(WHITE)\n",
        "\n",
        "        self.play(ShowCreation(side_lines_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(side_lines_rect, f_rect))\n",
        "        self.play(FadeOut(f_rect))\n",
        "        self.wait()\n",
        "\n",
        "    def conclude_about_five_regions(self):\n",
        "        lines = self.lines\n",
        "        side_lines = self.side_lines\n",
        "        regions = self.regions[1:]\n",
        "        line_groups = self.line_groups\n",
        "        line_indices = [3, 5, 2]\n",
        "        objects = self.objects\n",
        "\n",
        "        for region, line_group, li in zip(regions, line_groups, line_indices):\n",
        "            self.play(ReplacementTransform(\n",
        "                side_lines[li], lines[li]\n",
        "            ))\n",
        "            self.play(\n",
        "                FadeIn(region), \n",
        "                Animation(line_group), \n",
        "                Animation(objects),\n",
        "                *self.get_count_change_animations(0, 1, 1)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        #Conclude\n",
        "        words = OldTexText(\"Last line must \\\\\\\\ introduce 5th region\")\n",
        "        words.scale(0.8)\n",
        "        words.set_color(BLUE)\n",
        "        rect = SurroundingRectangle(self.f_count)\n",
        "        rect.set_color(BLUE)\n",
        "        words.next_to(rect, DOWN)\n",
        "        randy = Randolph().flip()\n",
        "        randy.scale(0.5)\n",
        "        randy.next_to(words, RIGHT, SMALL_BUFF, DOWN)\n",
        "        self.play(ShowCreation(rect), Write(words))\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "class WhatsWrongWithFive(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What's wrong with \\\\\\\\ 5 regions?\",\n",
        "            target_mode = \"maybe\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class CyclesHaveAtLeastFour(UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        houses, utilities = self.houses, self.utilities\n",
        "        vertices = VGroup(\n",
        "            houses[0], utilities[0],\n",
        "            houses[1], utilities[1], houses[0],\n",
        "        )\n",
        "        lines = [\n",
        "            VectorizedPoint(),\n",
        "            self.get_line(0, 0),\n",
        "            self.get_line(0, 1),\n",
        "            self.get_line(1, 1),\n",
        "            self.get_line(1, 0, self.objects.get_corner(DOWN+LEFT)),\n",
        "        ]\n",
        "        for line in lines[1::2]:\n",
        "            line.set_points(line.get_points()[::-1])\n",
        "        arrows = VGroup()\n",
        "        for vertex in vertices:\n",
        "            vect = vertices.get_center() - vertex.get_center()\n",
        "            arrow = Vector(vect, color = WHITE)\n",
        "            arrow.next_to(vertex, -vect, buff = 0)\n",
        "            vertex.arrow = arrow\n",
        "            arrows.add(arrow)\n",
        "        word_strings = [\n",
        "            \"Start at a house\",\n",
        "            \"Go to a utility\",\n",
        "            \"Go to another house\",\n",
        "            \"Go to another utility\",\n",
        "            \"Back to the start\",\n",
        "        ]\n",
        "        words = VGroup()\n",
        "        for word_string, arrow in zip(word_strings, arrows):\n",
        "            vect = arrow.get_vector()[1]*UP\n",
        "            word = OldTexText(word_string)\n",
        "            word.next_to(arrow.get_start(), -vect)\n",
        "            words.add(word)\n",
        "\n",
        "        count = Integer(-1)\n",
        "        count.fade(1)\n",
        "        count.to_edge(UP)\n",
        "\n",
        "        last_word = None\n",
        "        last_arrow = None\n",
        "\n",
        "        for line, word, arrow in zip(lines, words, arrows):\n",
        "            anims = []\n",
        "            for mob in last_word, last_arrow:\n",
        "                if mob:\n",
        "                    anims.append(FadeOut(mob))\n",
        "            new_count = Integer(count.number + 1)\n",
        "            new_count.move_to(count)\n",
        "            anims += [\n",
        "                FadeIn(word),\n",
        "                GrowArrow(arrow),\n",
        "                ShowCreation(line),\n",
        "                FadeOut(count),\n",
        "                FadeIn(new_count),\n",
        "            ]\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            last_word = word\n",
        "            last_arrow = arrow\n",
        "            count = new_count\n",
        "        self.wait(2)\n",
        "\n",
        "class FiveRegionsFourEdgesEachGraph(Scene):\n",
        "    CONFIG = {\n",
        "        \"v_color\" : WHITE,\n",
        "        \"e_color\" : YELLOW,\n",
        "        \"f_colors\" : (BLUE, RED_E, BLUE_E),\n",
        "        \"n_edge_double_count_examples\" : 6,\n",
        "        \"random_seed\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_squares()\n",
        "        self.transition_to_graph()\n",
        "        self.count_edges_per_region()\n",
        "        self.each_edges_has_two_regions()\n",
        "        self.ten_total_edges()\n",
        "\n",
        "    def draw_squares(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"5\", \"regions\"),\n",
        "            OldTexText(\"4\", \"edges each\"),\n",
        "        )\n",
        "        words.arrange(DOWN)\n",
        "        words.to_edge(UP)\n",
        "        words[0][0].set_color(self.f_colors[0])\n",
        "        words[1][0].set_color(self.e_color)\n",
        "\n",
        "        squares = VGroup(*[Square() for x in range(5)])\n",
        "        squares.scale(0.5)\n",
        "        squares.set_stroke(width = 0)\n",
        "        squares.set_fill(opacity = 1)\n",
        "        squares.set_color_by_gradient(*self.f_colors)\n",
        "        squares.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        squares.next_to(words, DOWN, LARGE_BUFF)\n",
        "        all_edges = VGroup()\n",
        "        all_vertices = VGroup()\n",
        "        for square in squares:\n",
        "            corners = square.get_anchors()[:4]\n",
        "            square.edges = VGroup(*[\n",
        "                Line(c1, c2, color = self.e_color)\n",
        "                for c1, c2 in adjacent_pairs(corners)\n",
        "            ])\n",
        "            square.vertices = VGroup(*[\n",
        "                Dot(color = self.v_color).move_to(c)\n",
        "                for c in corners\n",
        "            ])\n",
        "            all_edges.add(*square.edges)\n",
        "            all_vertices.add(*square.vertices)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words[0]),\n",
        "            LaggedStartMap(FadeIn, squares, run_time = 1.5)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(words[1]),\n",
        "            LaggedStartMap(ShowCreation, all_edges),\n",
        "            LaggedStartMap(GrowFromCenter, all_vertices),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add_foreground_mobjects(words)\n",
        "        self.set_variables_as_attrs(words, squares)\n",
        "\n",
        "    def transition_to_graph(self):\n",
        "        squares = self.squares\n",
        "        words = self.words\n",
        "\n",
        "        points = np.array([\n",
        "            UP+LEFT,\n",
        "            UP+RIGHT,\n",
        "            DOWN+RIGHT,\n",
        "            DOWN+LEFT,\n",
        "            3*(UP+RIGHT),\n",
        "            3*(DOWN+LEFT),\n",
        "            3*(DOWN+RIGHT),\n",
        "        ])\n",
        "        points *= 0.75\n",
        "\n",
        "        regions = VGroup(*[\n",
        "            Square().set_points_as_corners(points[indices])\n",
        "            for indices in [\n",
        "                [0, 1, 2, 3],\n",
        "                [0, 4, 2, 1],\n",
        "                [5, 0, 3, 2],\n",
        "                [5, 2, 4, 6],\n",
        "                [6, 4, 0, 5],\n",
        "            ]\n",
        "        ])\n",
        "        regions.set_stroke(width = 0)\n",
        "        regions.set_fill(opacity = 1)\n",
        "        regions.set_color_by_gradient(*self.f_colors)\n",
        "\n",
        "        all_edges = VGroup()\n",
        "        all_movers = VGroup()\n",
        "        for region, square in zip(regions, squares):\n",
        "            corners = region.get_anchors()[:4]\n",
        "            region.edges = VGroup(*[\n",
        "                Line(c1, c2, color = self.e_color)\n",
        "                for c1, c2 in adjacent_pairs(corners)\n",
        "            ])\n",
        "            all_edges.add(*region.edges)\n",
        "            region.vertices = VGroup(*[\n",
        "                Dot(color = self.v_color).move_to(c)\n",
        "                for c in corners\n",
        "            ])\n",
        "            mover = VGroup(\n",
        "                square, square.edges, square.vertices,\n",
        "            )\n",
        "            mover.target = VGroup(\n",
        "                region, region.edges, region.vertices\n",
        "            )\n",
        "            all_movers.add(mover)\n",
        "\n",
        "        back_region = FullScreenFadeRectangle()\n",
        "        back_region.set_fill(regions[-1].get_color(), 0.5)\n",
        "        regions[-1].set_fill(opacity = 0)\n",
        "        back_region.add(regions[-1].copy().set_fill(BLACK, 1))\n",
        "        back_region.edges = regions[-1].edges\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                back_region,\n",
        "                rate_func = squish_rate_func(smooth, 0.7, 1),\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, all_movers,\n",
        "                run_time = 3,\n",
        "                replace_mobject_with_target_in_scene = True,\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            regions, all_edges, back_region,\n",
        "            graph = VGroup(*[m.target for m in all_movers])\n",
        "        )\n",
        "\n",
        "    def count_edges_per_region(self):\n",
        "        all_edges = self.all_edges\n",
        "        back_region = self.back_region\n",
        "        regions = self.regions\n",
        "        graph = self.graph\n",
        "        all_vertices = VGroup(*[r.vertices for r in regions])\n",
        "\n",
        "        ghost_edges = all_edges.copy()\n",
        "        ghost_edges.set_stroke(GREY_B, 1)\n",
        "\n",
        "        count = Integer(0)\n",
        "        count.scale(2)\n",
        "        count.next_to(graph, RIGHT, buff = 2)\n",
        "        count.set_fill(YELLOW, opacity = 0)\n",
        "\n",
        "        last_region = VGroup(back_region, *regions[1:])\n",
        "        last_region.add(all_edges)\n",
        "\n",
        "        for region in list(regions[:-1]) + [back_region]:\n",
        "            self.play(\n",
        "                FadeIn(region),\n",
        "                Animation(ghost_edges),\n",
        "                FadeOut(last_region),\n",
        "                Animation(count),\n",
        "                Animation(all_vertices),\n",
        "            )\n",
        "            for edge in region.edges:\n",
        "                new_count = Integer(count.number + 1)\n",
        "                new_count.replace(count, dim_to_match = 1)\n",
        "                new_count.set_color(count.get_color())\n",
        "                self.play(\n",
        "                    ShowCreation(edge),\n",
        "                    FadeOut(count),\n",
        "                    FadeIn(new_count),\n",
        "                    run_time = 0.5\n",
        "                )\n",
        "                count = new_count\n",
        "            last_region = VGroup(region, region.edges)\n",
        "        self.wait()\n",
        "        self.add_foreground_mobjects(count)\n",
        "        self.play(\n",
        "            FadeOut(last_region),\n",
        "            Animation(ghost_edges),\n",
        "            Animation(all_vertices),\n",
        "        )\n",
        "\n",
        "        self.set_variables_as_attrs(count, ghost_edges, all_vertices)\n",
        "\n",
        "    def each_edges_has_two_regions(self):\n",
        "        regions = list(self.regions[:-1]) + [self.back_region]\n",
        "        back_region = self.back_region\n",
        "        self.add_foreground_mobjects(self.ghost_edges, self.all_vertices)\n",
        "\n",
        "        edge_region_pair_groups = []\n",
        "        for r1, r2 in it.combinations(regions, 2):\n",
        "            for e1 in r1.edges:\n",
        "                for e2 in r2.edges:\n",
        "                    diff = e1.get_center()-e2.get_center()\n",
        "                    if get_norm(diff) < 0.01:\n",
        "                        edge_region_pair_groups.append(VGroup(\n",
        "                            e1, r1, r2\n",
        "                        ))\n",
        "\n",
        "        for x in range(self.n_edge_double_count_examples):\n",
        "            edge, r1, r2 = random.choice(edge_region_pair_groups)\n",
        "            if r2 is back_region:\n",
        "                #Flip again, maybe you're still unlucky, maybe not\n",
        "                edge, r1, r2 = random.choice(edge_region_pair_groups)\n",
        "            self.play(ShowCreation(edge))\n",
        "            self.add_foreground_mobjects(edge)\n",
        "            self.play(FadeIn(r1), run_time = 0.5)\n",
        "            self.play(FadeIn(r2), Animation(r1), run_time = 0.5)\n",
        "            self.wait(0.5)\n",
        "            self.play(*list(map(FadeOut, [r2, r1, edge])), run_time = 0.5)\n",
        "            self.remove_foreground_mobjects(edge)\n",
        "\n",
        "    def ten_total_edges(self):\n",
        "        double_count = self.count\n",
        "        brace = Brace(double_count, UP)\n",
        "        words = brace.get_text(\"Double-counts \\\\\\\\ edges\")\n",
        "        regions = self.regions\n",
        "\n",
        "        edges = VGroup(*it.chain(\n",
        "            regions[0].edges,\n",
        "            regions[-1].edges,\n",
        "            [regions[1].edges[1]],\n",
        "            [regions[2].edges[3]],\n",
        "        ))\n",
        "\n",
        "        count = Integer(0)\n",
        "        count.scale(2)\n",
        "        count.set_fill(WHITE, 0)\n",
        "        count.next_to(self.graph, LEFT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        for edge in edges:\n",
        "            new_count = Integer(count.number + 1)\n",
        "            new_count.replace(count, dim_to_match = 1)\n",
        "            self.play(\n",
        "                ShowCreation(edge),\n",
        "                FadeOut(count),\n",
        "                FadeIn(new_count),\n",
        "                run_time = 0.5\n",
        "            )\n",
        "            count = new_count\n",
        "        self.wait()\n",
        "\n",
        "class EulersFormulaForGeneralPlanarGraph(LightUpNodes, ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"vertices_word\" : \"Vertices\"\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_counters()\n",
        "        self.show_creation_of_graph()\n",
        "        self.show_formula()\n",
        "        self.transform_into_cube()\n",
        "\n",
        "    def show_creation_of_graph(self):\n",
        "        points = np.array([\n",
        "            UP+LEFT,\n",
        "            UP+RIGHT,\n",
        "            DOWN+RIGHT,\n",
        "            DOWN+LEFT,\n",
        "            3*(UP+LEFT),\n",
        "            3*(UP+RIGHT),\n",
        "            3*(DOWN+RIGHT),\n",
        "            3*(DOWN+LEFT),\n",
        "        ])\n",
        "        points *= 0.75\n",
        "        points += DOWN\n",
        "        vertices = VGroup(*list(map(Dot, points)))\n",
        "        vertices.set_color(YELLOW)\n",
        "        edges = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Line(p1, p2, color = WHITE)\n",
        "                for p2 in points\n",
        "            ])\n",
        "            for p1 in points\n",
        "        ])\n",
        "        regions = self.get_cube_faces(points)\n",
        "        regions.set_stroke(width = 0)\n",
        "        regions.set_fill(opacity = 1)\n",
        "        regions.set_color_by_gradient(GREEN, RED, BLUE_E)\n",
        "        regions[-1].set_fill(opacity = 0)\n",
        "\n",
        "        pairs = [\n",
        "            (edges[0][1], vertices[1]),\n",
        "            (edges[1][2], vertices[2]),\n",
        "            (edges[2][6], vertices[6]),\n",
        "            (edges[6][5], vertices[5]),\n",
        "            (edges[5][1], regions[2]),\n",
        "            (edges[0][4], vertices[4]),\n",
        "            (edges[4][5], regions[1]),\n",
        "            (edges[0][3], vertices[3]),\n",
        "            (edges[3][2], regions[0]),\n",
        "            (edges[4][7], vertices[7]),\n",
        "            (edges[7][3], regions[4]),\n",
        "            (edges[7][6], regions[3]),\n",
        "        ]\n",
        "\n",
        "        self.add_foreground_mobjects(vertices[0])\n",
        "        self.wait()\n",
        "        for edge, obj in pairs:\n",
        "            anims = [ShowCreation(edge)]\n",
        "            if obj in vertices:\n",
        "                obj.save_state()\n",
        "                obj.move_to(edge.get_start())\n",
        "                anims.append(ApplyMethod(obj.restore))\n",
        "                anims += self.get_count_change_animations(1, 1, 0)\n",
        "                self.add_foreground_mobjects(obj)\n",
        "            else:\n",
        "                anims = [FadeIn(obj)] + anims\n",
        "                anims += self.get_count_change_animations(0, 1, 1)\n",
        "            self.play(*anims)\n",
        "            self.add_foreground_mobjects(edge)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(edges, vertices, regions)\n",
        "\n",
        "    def show_formula(self):\n",
        "        counts = VGroup(*self.counts)\n",
        "        count_titles = VGroup(*self.count_titles)\n",
        "        groups = [count_titles, counts]\n",
        "\n",
        "        for group in groups:\n",
        "            group.symbols = VGroup(*list(map(Tex, [\"-\", \"+\", \"=\"])))\n",
        "            group.generate_target()\n",
        "            line = VGroup(*it.chain(*list(zip(group.target, group.symbols))))\n",
        "            line.arrange(RIGHT)\n",
        "            line.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        VGroup(counts.target, counts.symbols).shift(0.75*DOWN)\n",
        "        for mob in count_titles.target:\n",
        "            mob[-1].fade(1)\n",
        "        count_titles.symbols.shift(0.5*SMALL_BUFF*UP)\n",
        "        twos = VGroup(*[\n",
        "            OldTex(\"2\").next_to(group.symbols, RIGHT)\n",
        "            for group in groups\n",
        "        ])\n",
        "        twos.shift(0.5*SMALL_BUFF*UP)\n",
        "\n",
        "        words = OldTexText(\"``Euler's characteristic formula''\")\n",
        "        words.next_to(counts.target, DOWN)\n",
        "        words.shift(MED_LARGE_BUFF*RIGHT)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        for group in groups:\n",
        "            self.play(\n",
        "                MoveToTarget(group),\n",
        "                Write(group.symbols)\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Write(twos))\n",
        "        self.wait()\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "        self.top_formula = VGroup(count_titles, count_titles.symbols, twos[0])\n",
        "        self.bottom_formula = VGroup(counts, counts.symbols, twos[1])\n",
        "\n",
        "    def transform_into_cube(self):\n",
        "        regions = self.regions\n",
        "        points = np.array([\n",
        "            UP+LEFT,\n",
        "            UP+RIGHT,\n",
        "            DOWN+RIGHT,\n",
        "            DOWN+LEFT,\n",
        "            UP+LEFT+2*IN,\n",
        "            UP+RIGHT+2*IN,\n",
        "            DOWN+RIGHT+2*IN,\n",
        "            DOWN+LEFT+2*IN,\n",
        "        ])\n",
        "        cube = self.get_cube_faces(points)\n",
        "        cube.shift(OUT)\n",
        "        cube.rotate(np.pi/12, RIGHT)\n",
        "        cube.rotate(np.pi/6, UP)\n",
        "        cube.shift(MED_LARGE_BUFF*DOWN)\n",
        "        shade_in_3d(cube)\n",
        "\n",
        "        for face, region in zip(cube, regions):\n",
        "            face.set_fill(region.get_color(), opacity = 0.8)\n",
        "\n",
        "        self.remove(self.edges)\n",
        "        regions.set_stroke(WHITE, 3)\n",
        "        cube.set_stroke(WHITE, 3)\n",
        "\n",
        "        new_formula = OldTex(\"V - E + F = 2\")\n",
        "        new_formula.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        new_formula.align_to(self.bottom_formula, RIGHT)\n",
        "\n",
        "        self.play(FadeOut(self.vertices))\n",
        "        self.play(ReplacementTransform(regions, cube, run_time = 2))\n",
        "        cube.sort(lambda p : -p[2])\n",
        "        always_rotate(cube, axis=UP, about_point=ORIGIN)\n",
        "        self.add(cube)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(self.top_formula),\n",
        "            FadeIn(new_formula)\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "    ###\n",
        "\n",
        "    def get_cube_faces(self, eight_points):\n",
        "        return VGroup(*[\n",
        "            Square().set_points_as_corners(eight_points[indices])\n",
        "            for indices in [\n",
        "                [0, 1, 2, 3],\n",
        "                [0, 4, 5, 1],\n",
        "                [1, 5, 6, 2],\n",
        "                [2, 6, 7, 3],\n",
        "                [3, 7, 4, 0],\n",
        "                [4, 5, 6, 7],\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "class YouGaveFriendsAnImpossiblePuzzle(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"You gave friends \\\\\\\\ an impossible puzzle?\",\n",
        "            target_mode = \"sassy\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"angry\", \"sassy\", \"angry\",\n",
        "            added_anims = [self.teacher.change, \"happy\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class FunnyStory(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Funny story\", target_mode = \"hooray\")\n",
        "        self.wait()\n",
        "        self.play_student_changes(\n",
        "            *[\"happy\"]*3,\n",
        "            added_anims = [RemovePiCreatureBubble(\n",
        "                self.teacher,\n",
        "                target_mode = \"raise_right_hand\"\n",
        "            )],\n",
        "            look_at = UP+2*RIGHT\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "class QuestionWrapper(Scene):\n",
        "    def construct(self):\n",
        "        question = OldTexText(\n",
        "            \"Where\", \"\\\\emph{specifically}\", \"does\\\\\\\\\", \n",
        "            \"this proof break down?\",\n",
        "        )\n",
        "        question.to_edge(UP)\n",
        "        question.set_color_by_tex(\"specifically\", YELLOW)\n",
        "        screen_rect = ScreenRectangle(height = 5.5)\n",
        "        screen_rect.next_to(question, DOWN)\n",
        "\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait()\n",
        "        for word in question:\n",
        "            self.play(LaggedStartMap(\n",
        "                FadeIn, word,\n",
        "                run_time = 0.05*len(word)\n",
        "            ))\n",
        "            self.wait(0.05)\n",
        "        self.wait()\n",
        "\n",
        "class Homework(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Consider this \\\\\\\\ homework\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "        self.student_says(\n",
        "            \"$V-E+F=0$ on \\\\\\\\ a torus!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\"Not good enough!\", target_mode = \"surprised\")\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class WantToLearnMore(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Want to learn more?\")\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "class PatreonThanks(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Randall Hunt\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Onuralp Soylemez\",\n",
        "            \"John Bjorn Nelson\",\n",
        "            \"Yaw Etse\",\n",
        "            \"David Barbetta\",\n",
        "            \"Julio Cesar Campo Neto\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"Oliver Steele\",\n",
        "            \"George Chiesa\",\n",
        "            \"supershabam\",\n",
        "            \"James Park\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Isak Hietala\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Dagan Harrington\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Eric Chow\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Awoo\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Shimin  Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class NewMugThumbnail(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTex(\n",
        "            \"V - E + F = 0\",\n",
        "            tex_to_color_map={\"0\": YELLOW},\n",
        "        )\n",
        "        title.scale(3)\n",
        "        title.to_edge(UP)\n",
        "        image = ImageMobject(\"sci_youtubers_thumbnail\")\n",
        "        image.set_height(5.5)\n",
        "        image.next_to(title, DOWN)\n",
        "        self.add(title, image)\n",
        "\n",
        "class Thumbnail3(UtilitiesPuzzleScene):\n",
        "    def construct(self):\n",
        "        self.setup_configuration()\n",
        "        lines = self.get_almost_solution_lines()\n",
        "        lines.set_stroke(WHITE, 5, opacity=0.9)\n",
        "\n",
        "        group = VGroup(lines, self.objects)\n",
        "        group.set_height(5.5)\n",
        "        group.to_edge(DOWN, buff=0.1)\n",
        "\n",
        "        self.add(*group)\n",
        "\n",
        "        words = OldTexText(\"No crossing\\\\\\\\allowed!\", font_size=72)\n",
        "        words.to_corner(UL)\n",
        "        # words.shift(3 * RIGHT)\n",
        "        arrow = Arrow(\n",
        "            words.get_corner(UR) + 0.1 * DOWN,\n",
        "            group.get_top() + 0.35 * DOWN + 0.15 * RIGHT,\n",
        "            path_arc=-75 * DEGREES,\n",
        "            thickness=0.1,\n",
        "        )\n",
        "        arrow.set_fill(RED)\n",
        "\n",
        "        self.add(words, arrow)\n",
        "\n"
    ]
}