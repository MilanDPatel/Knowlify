{
    "topic": "The Fourier Transform is a mathematical concept that describes the decomposition of a function into its constituent frequencies",
    "code": [
        "# -*- coding: utf-8 -*-\n",
        "import scipy.integrate\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "USE_ALMOST_FOURIER_BY_DEFAULT = True\n",
        "NUM_SAMPLES_FOR_FFT = 1000\n",
        "DEFAULT_COMPLEX_TO_REAL_FUNC = lambda z : z.real\n",
        "\n",
        "\n",
        "def get_fourier_graph(\n",
        "    axes, time_func, t_min, t_max,\n",
        "    n_samples = NUM_SAMPLES_FOR_FFT,\n",
        "    complex_to_real_func = lambda z : z.real,\n",
        "    color = RED,\n",
        "    ):\n",
        "    # N = n_samples\n",
        "    # T = time_range/n_samples\n",
        "    time_range = float(t_max - t_min)\n",
        "    time_step_size = time_range/n_samples\n",
        "    time_samples = np.vectorize(time_func)(np.linspace(t_min, t_max, n_samples))\n",
        "    fft_output = np.fft.fft(time_samples)\n",
        "    frequencies = np.linspace(0.0, n_samples/(2.0*time_range), n_samples//2)\n",
        "    #  #Cycles per second of fouier_samples[1]\n",
        "    # (1/time_range)*n_samples\n",
        "    # freq_step_size = 1./time_range\n",
        "    graph = VMobject()\n",
        "    graph.set_points_smoothly([\n",
        "        axes.coords_to_point(\n",
        "            x, complex_to_real_func(y)/n_samples,\n",
        "        )\n",
        "        for x, y in zip(frequencies, fft_output[:n_samples//2])\n",
        "    ])\n",
        "    graph.set_color(color)\n",
        "    f_min, f_max = [\n",
        "        axes.x_axis.point_to_number(graph.get_points()[i])\n",
        "        for i in (0, -1)\n",
        "    ]\n",
        "    graph.underlying_function = lambda f : axes.y_axis.point_to_number(\n",
        "        graph.point_from_proportion((f - f_min)/(f_max - f_min))\n",
        "    )\n",
        "    return graph\n",
        "\n",
        "def get_fourier_transform(\n",
        "    func, t_min, t_max, \n",
        "    complex_to_real_func = DEFAULT_COMPLEX_TO_REAL_FUNC,\n",
        "    use_almost_fourier = USE_ALMOST_FOURIER_BY_DEFAULT,\n",
        "    **kwargs ##Just eats these\n",
        "    ):\n",
        "    scalar = 1./(t_max - t_min) if use_almost_fourier else 1.0\n",
        "    def fourier_transform(f):\n",
        "        z = scalar*scipy.integrate.quad(\n",
        "            lambda t : func(t)*np.exp(complex(0, -TAU*f*t)),\n",
        "            t_min, t_max\n",
        "        )[0]\n",
        "        return complex_to_real_func(z)\n",
        "    return fourier_transform\n",
        "\n",
        "\n",
        "class TODOStub(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "##\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Fourier Transform\")\n",
        "        title.scale(1.2)\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        func = lambda t : np.cos(2*TAU*t) + np.cos(3*TAU*t)\n",
        "        graph = FunctionGraph(func, x_min = 0, x_max = 5)\n",
        "        graph.stretch(0.25, 1)\n",
        "        graph.next_to(title, DOWN)\n",
        "        graph.to_edge(LEFT)\n",
        "        graph.set_color(BLUE)\n",
        "        fourier_graph = FunctionGraph(\n",
        "            get_fourier_transform(func, 0, 5),\n",
        "            x_min = 0, x_max = 5\n",
        "        )\n",
        "        fourier_graph.move_to(graph)\n",
        "        fourier_graph.to_edge(RIGHT)\n",
        "        fourier_graph.set_color(RED)\n",
        "        arrow = Arrow(graph, fourier_graph, color = WHITE)\n",
        "        self.add(title, graph)\n",
        "\n",
        "        self.student_thinks(\n",
        "            \"What's that?\",\n",
        "            look_at = title,\n",
        "            target_mode = \"confused\",\n",
        "            index = 1,\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            ReplacementTransform(graph.copy(), fourier_graph)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.student_thinks(\n",
        "            \"Pssht, I got this\",\n",
        "            target_mode = \"tease\",\n",
        "            index = 2,\n",
        "            added_anims = [RemovePiCreatureBubble(self.students[1])]\n",
        "        )\n",
        "        self.play(self.teacher.change, \"hesitant\")\n",
        "        self.wait(2)\n",
        "\n",
        "class TODOInsertUnmixingSound(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Show unmixing sound\"\n",
        "    }\n",
        "\n",
        "class OtherContexts(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        items = VGroup(*list(map(TexText, [\n",
        "            \"Extracting frequencies from sound\",\n",
        "            \"Uncertainty principle\",\n",
        "            \"Riemann Zeta function and primes\",\n",
        "            \"Differential equations\",\n",
        "        ])))\n",
        "        items.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        items.to_corner(UP+LEFT)\n",
        "        items[1:].set_fill(opacity = 0.2)\n",
        "\n",
        "        morty = self.pi_creature\n",
        "        morty.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.add(items)\n",
        "        for item in items[1:]:\n",
        "            self.play(\n",
        "                LaggedStartMap(\n",
        "                    ApplyMethod, item,\n",
        "                    lambda m : (m.set_fill, {\"opacity\" : 1}),\n",
        "                ), \n",
        "                morty.change, \"thinking\",\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class TODOInsertCosineWrappingAroundCircle(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Give a picture-in-picture \\\\\\\\ of cosine wrapping around circle\",\n",
        "    }\n",
        "\n",
        "class AddingPureFrequencies(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"A_frequency\" : 2.1,\n",
        "        \"A_color\" : YELLOW,\n",
        "        \"D_color\" : PINK,\n",
        "        \"F_color\" : TEAL,\n",
        "        \"C_color\" : RED,\n",
        "        \"sum_color\" : GREEN,\n",
        "        \"equilibrium_height\" : 1.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_speaker()\n",
        "        self.play_A440()\n",
        "        self.measure_air_pressure()\n",
        "        self.play_lower_pitch()\n",
        "        self.play_mix()\n",
        "        self.separate_out_parts()\n",
        "        self.draw_sum_at_single_point()\n",
        "        self.draw_full_sum()\n",
        "        self.add_more_notes()\n",
        "\n",
        "    def add_speaker(self):\n",
        "        speaker = SVGMobject(file_name = \"speaker\")\n",
        "        speaker.to_edge(DOWN)\n",
        "\n",
        "        self.add(speaker)\n",
        "        self.speaker = speaker\n",
        "\n",
        "    def play_A440(self):\n",
        "        randy = self.pi_creature\n",
        "        A_label = OldTexText(\"A440\")\n",
        "        A_label.set_color(self.A_color)\n",
        "        A_label.next_to(self.speaker, UP)\n",
        "\n",
        "        self.broadcast(\n",
        "            FadeIn(A_label),\n",
        "            Succession(\n",
        "                ApplyMethod, randy.change, \"pondering\",\n",
        "                Animation, randy,\n",
        "                Blink, randy\n",
        "            )\n",
        "        )\n",
        "\n",
        "        self.set_variables_as_attrs(A_label)\n",
        "\n",
        "    def measure_air_pressure(self):\n",
        "        randy = self.pi_creature\n",
        "        axes = Axes(\n",
        "            y_min = -2, y_max = 2,\n",
        "            x_min = 0, x_max = 10,\n",
        "            axis_config = {\"include_tip\" : False},\n",
        "        )\n",
        "        axes.stretch_to_fit_height(2)\n",
        "        axes.to_corner(UP+LEFT)\n",
        "        axes.shift(LARGE_BUFF*DOWN)\n",
        "        eh = self.equilibrium_height\n",
        "        equilibrium_line = DashedLine(\n",
        "            axes.coords_to_point(0, eh),\n",
        "            axes.coords_to_point(axes.x_max, eh),\n",
        "            stroke_width = 2,\n",
        "            stroke_color = GREY_B\n",
        "        )\n",
        "\n",
        "        frequency = self.A_frequency\n",
        "        graph = self.get_wave_graph(frequency, axes)\n",
        "        func = graph.underlying_function\n",
        "        graph.set_color(self.A_color)\n",
        "        pressure = OldTexText(\"Pressure\")\n",
        "        time = OldTexText(\"Time\")\n",
        "        for label in pressure, time:\n",
        "            label.scale(0.8)\n",
        "        pressure.next_to(axes.y_axis, UP)\n",
        "        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF)\n",
        "        time.next_to(axes.x_axis.get_right(), DOWN+LEFT)\n",
        "        axes.labels = VGroup(pressure, time)\n",
        "\n",
        "        n = 10\n",
        "        brace = Brace(Line(\n",
        "            axes.coords_to_point(n/frequency, func(n/frequency)),\n",
        "            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)),\n",
        "        ), UP)\n",
        "        words = brace.get_text(\"Imagine 440 per second\", buff = SMALL_BUFF)\n",
        "        words.scale(0.8, about_point = words.get_bottom())\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pressure),\n",
        "            ShowCreation(axes.y_axis)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(time),\n",
        "            ShowCreation(axes.x_axis)\n",
        "        )\n",
        "        self.broadcast(\n",
        "            ShowCreation(graph, run_time = 4, rate_func=linear),\n",
        "            ShowCreation(equilibrium_line),\n",
        "        )\n",
        "        axes.add(equilibrium_line)\n",
        "        self.play(\n",
        "            randy.change, \"erm\", graph,\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        graph.save_state()\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            FadeOut(words),\n",
        "            VGroup(axes, graph, axes.labels).shift, 0.8*UP,\n",
        "            graph.fade, 0.85,\n",
        "            graph.shift, 0.8*UP,\n",
        "        )\n",
        "\n",
        "        graph.saved_state.move_to(graph)\n",
        "        self.set_variables_as_attrs(axes, A_graph = graph)\n",
        "\n",
        "    def play_lower_pitch(self):\n",
        "        axes = self.axes\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        frequency = self.A_frequency*(2.0/3.0)\n",
        "        graph = self.get_wave_graph(frequency, axes)\n",
        "        graph.set_color(self.D_color)\n",
        "\n",
        "        D_label = OldTexText(\"D294\")\n",
        "        D_label.set_color(self.D_color)\n",
        "        D_label.move_to(self.A_label)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.A_label),\n",
        "            GrowFromCenter(D_label),\n",
        "        )\n",
        "        self.broadcast(\n",
        "            ShowCreation(graph, run_time = 4, rate_func=linear),\n",
        "            randy.change, \"happy\",\n",
        "            n_circles = 6,\n",
        "        )\n",
        "        self.play(randy.change, \"confused\", graph)\n",
        "        self.wait(2)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            D_label,\n",
        "            D_graph = graph\n",
        "        )\n",
        "\n",
        "    def play_mix(self):\n",
        "        self.A_graph.restore()\n",
        "        self.broadcast(\n",
        "            self.get_broadcast_animation(n_circles = 6),\n",
        "            self.pi_creature.change, \"thinking\",\n",
        "            *[\n",
        "                ShowCreation(graph, run_time = 4, rate_func=linear)\n",
        "                for graph in (self.A_graph, self.D_graph)\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def separate_out_parts(self):\n",
        "        axes = self.axes\n",
        "        speaker = self.speaker\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        A_axes = axes.deepcopy()\n",
        "        A_graph = self.A_graph\n",
        "        A_label = self.A_label\n",
        "        D_axes = axes.deepcopy()\n",
        "        D_graph = self.D_graph\n",
        "        D_label = self.D_label\n",
        "        movers = [A_axes, A_graph, A_label, D_axes, D_graph, D_label]\n",
        "        for mover in movers:\n",
        "            mover.generate_target()\n",
        "        D_target_group = VGroup(D_axes.target, D_graph.target)\n",
        "        A_target_group = VGroup(A_axes.target, A_graph.target)\n",
        "        D_target_group.next_to(axes, DOWN, MED_LARGE_BUFF)\n",
        "        A_target_group.next_to(D_target_group, DOWN, MED_LARGE_BUFF)\n",
        "        A_label.fade(1)\n",
        "        A_label.target.next_to(A_graph.target, UP)\n",
        "        D_label.target.next_to(D_graph.target, UP)\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(MoveToTarget, movers)),\n",
        "            [\n",
        "                ApplyMethod(mob.shift, FRAME_Y_RADIUS*DOWN, remover = True)\n",
        "                for mob in  (randy, speaker)\n",
        "            ]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(A_axes, D_axes)\n",
        "\n",
        "    def draw_sum_at_single_point(self):\n",
        "        axes = self.axes\n",
        "        A_axes = self.A_axes\n",
        "        D_axes = self.D_axes\n",
        "        A_graph = self.A_graph\n",
        "        D_graph = self.D_graph\n",
        "\n",
        "        x = 2.85\n",
        "        A_line = self.get_A_graph_v_line(x)\n",
        "        D_line = self.get_D_graph_v_line(x)\n",
        "        lines = VGroup(A_line, D_line)\n",
        "        sum_lines = lines.copy()\n",
        "        sum_lines.generate_target()\n",
        "        self.stack_v_lines(x, sum_lines.target)\n",
        "\n",
        "        top_axes_point = axes.coords_to_point(x, self.equilibrium_height)\n",
        "        x_point = np.array(top_axes_point)\n",
        "        x_point[1] = 0\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS).move_to(x_point)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(GrowFromCenter(v_line))\n",
        "        self.play(FadeOut(v_line))\n",
        "        self.play(*list(map(ShowCreation, lines)))\n",
        "        self.wait()\n",
        "        self.play(MoveToTarget(sum_lines, path_arc = np.pi/4))\n",
        "        self.wait(2)\n",
        "        # self.play(*[\n",
        "        #     Transform(\n",
        "        #         line, \n",
        "        #         VectorizedPoint(axes.coords_to_point(0, self.equilibrium_height)),\n",
        "        #         remover = True\n",
        "        #     )\n",
        "        #     for line, axes in [\n",
        "        #         (A_line, A_axes),\n",
        "        #         (D_line, D_axes),\n",
        "        #         (sum_lines, axes),\n",
        "        #     ]\n",
        "        # ])\n",
        "        self.lines_to_fade = VGroup(A_line, D_line, sum_lines)\n",
        "\n",
        "    def draw_full_sum(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        def new_func(x):\n",
        "            result = self.A_graph.underlying_function(x)\n",
        "            result += self.D_graph.underlying_function(x)\n",
        "            result -= self.equilibrium_height\n",
        "            return result\n",
        "\n",
        "        sum_graph = axes.get_graph(new_func)\n",
        "        sum_graph.set_color(self.sum_color)\n",
        "        thin_sum_graph = sum_graph.copy().fade()\n",
        "\n",
        "        A_graph = self.A_graph\n",
        "        D_graph = self.D_graph\n",
        "        D_axes = self.D_axes\n",
        "\n",
        "        rect = Rectangle(\n",
        "            height = 2.5*FRAME_Y_RADIUS,\n",
        "            width = MED_SMALL_BUFF,\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 0.4\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(A_graph.copy(), thin_sum_graph),\n",
        "            ReplacementTransform(D_graph.copy(), thin_sum_graph),\n",
        "            # FadeOut(self.lines_to_fade)\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_graph_line_animation(self.A_axes, self.A_graph),\n",
        "            self.get_graph_line_animation(self.D_axes, self.D_graph),\n",
        "            self.get_graph_line_animation(axes, sum_graph.deepcopy()),\n",
        "            ShowCreation(sum_graph),\n",
        "            run_time = 15,\n",
        "            rate_func=linear\n",
        "        )\n",
        "        self.remove(thin_sum_graph)\n",
        "        self.wait()\n",
        "        for x in 2.85, 3.57:\n",
        "            rect.move_to(D_axes.coords_to_point(x, 0))\n",
        "            self.play(GrowFromPoint(rect, rect.get_top()))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(rect))\n",
        "\n",
        "        self.sum_graph = sum_graph\n",
        "\n",
        "    def add_more_notes(self):\n",
        "        axes = self.axes\n",
        "\n",
        "        A_group = VGroup(self.A_axes, self.A_graph, self.A_label)\n",
        "        D_group = VGroup(self.D_axes, self.D_graph, self.D_label)\n",
        "        squish_group = VGroup(A_group, D_group)\n",
        "        squish_group.generate_target()\n",
        "        squish_group.target.stretch(0.5, 1)\n",
        "        squish_group.target.next_to(axes, DOWN, buff = -SMALL_BUFF)\n",
        "        for group in squish_group.target:\n",
        "            label = group[-1]\n",
        "            bottom = label.get_bottom()\n",
        "            label.stretch_in_place(0.5, 0)\n",
        "            label.move_to(bottom, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(squish_group),\n",
        "            FadeOut(self.lines_to_fade),\n",
        "        )\n",
        "\n",
        "        F_axes = self.D_axes.deepcopy()\n",
        "        C_axes = self.A_axes.deepcopy()\n",
        "        VGroup(F_axes, C_axes).next_to(squish_group, DOWN)\n",
        "        F_graph = self.get_wave_graph(self.A_frequency*4.0/5, F_axes)\n",
        "        F_graph.set_color(self.F_color)\n",
        "        C_graph = self.get_wave_graph(self.A_frequency*6.0/5, C_axes)\n",
        "        C_graph.set_color(self.C_color)\n",
        "\n",
        "        F_label = OldTexText(\"F349\")\n",
        "        C_label = OldTexText(\"C523\")\n",
        "        for label, graph in (F_label, F_graph), (C_label, C_graph):\n",
        "            label.scale(0.5)\n",
        "            label.set_color(graph.get_stroke_color())\n",
        "            label.next_to(graph, UP, SMALL_BUFF)\n",
        "\n",
        "        graphs = VGroup(self.A_graph, self.D_graph, F_graph, C_graph)\n",
        "        def new_sum_func(x):\n",
        "            result = sum([\n",
        "                graph.underlying_function(x) - self.equilibrium_height\n",
        "                for graph in graphs\n",
        "            ])\n",
        "            result *= 0.5\n",
        "            return result + self.equilibrium_height\n",
        "        new_sum_graph = self.axes.get_graph(\n",
        "            new_sum_func, \n",
        "            num_graph_points = 200\n",
        "        )\n",
        "        new_sum_graph.set_color(BLUE_C)\n",
        "        thin_new_sum_graph = new_sum_graph.copy().fade()\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(ShowCreation, [F_axes, C_axes, F_graph, C_graph])),\n",
        "            list(map(Write, [F_label, C_label])),\n",
        "            list(map(FadeOut, [self.sum_graph]))\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            graphs.copy(), thin_new_sum_graph\n",
        "        ))\n",
        "        kwargs = {\"rate_func\" : None, \"run_time\" : 10}\n",
        "        self.play(ShowCreation(new_sum_graph.copy(), **kwargs), *[\n",
        "            self.get_graph_line_animation(curr_axes, graph, **kwargs)\n",
        "            for curr_axes, graph in [\n",
        "                (self.A_axes, self.A_graph),\n",
        "                (self.D_axes, self.D_graph),\n",
        "                (F_axes, F_graph),\n",
        "                (C_axes, C_graph),\n",
        "                (axes, new_sum_graph),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def broadcast(self, *added_anims, **kwargs):\n",
        "        self.play(self.get_broadcast_animation(**kwargs), *added_anims)\n",
        "\n",
        "    def get_broadcast_animation(self, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 5)\n",
        "        kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 10)\n",
        "        return Broadcast(self.speaker[1], **kwargs)\n",
        "\n",
        "    def get_wave_graph(self, frequency, axes):\n",
        "        tail_len = 3.0\n",
        "        x_min, x_max = axes.x_min, axes.x_max\n",
        "        def func(x):\n",
        "            value = 0.7*np.cos(2*np.pi*frequency*x)\n",
        "            if x - x_min < tail_len:\n",
        "                value *= smooth((x-x_min)/tail_len)\n",
        "            if x_max - x < tail_len:\n",
        "                value *= smooth((x_max - x )/tail_len)\n",
        "            return value + self.equilibrium_height\n",
        "        ngp = 2*(x_max - x_min)*frequency + 1\n",
        "        graph = axes.get_graph(func, num_graph_points = int(ngp))\n",
        "        return graph\n",
        "\n",
        "    def get_A_graph_v_line(self, x):\n",
        "        return self.get_graph_v_line(x, self.A_axes, self.A_graph)\n",
        "\n",
        "    def get_D_graph_v_line(self, x):\n",
        "        return self.get_graph_v_line(x, self.D_axes, self.D_graph)\n",
        "\n",
        "    def get_graph_v_line(self, x, axes, graph):\n",
        "        result = Line(\n",
        "            axes.coords_to_point(x, self.equilibrium_height),\n",
        "            # axes.coords_to_point(x, graph.underlying_function(x)),\n",
        "            graph.point_from_proportion(float(x)/axes.x_max),\n",
        "            color = WHITE,\n",
        "            buff = 0,\n",
        "        )\n",
        "        return result\n",
        "\n",
        "    def stack_v_lines(self, x, lines):\n",
        "        point = self.axes.coords_to_point(x, self.equilibrium_height)\n",
        "        A_line, D_line = lines\n",
        "        A_line.shift(point - A_line.get_start())\n",
        "        D_line.shift(A_line.get_end()-D_line.get_start())\n",
        "        A_line.set_color(self.A_color)\n",
        "        D_line.set_color(self.D_color)\n",
        "        return lines\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Randolph().to_corner(DOWN+LEFT)\n",
        "\n",
        "    def get_graph_line_animation(self, axes, graph, **kwargs):\n",
        "        line = self.get_graph_v_line(0, axes, graph)\n",
        "        x_max = axes.x_max\n",
        "        def update_line(line, alpha):\n",
        "            x = alpha*x_max\n",
        "            Transform(line, self.get_graph_v_line(x, axes, graph)).update(1)\n",
        "            return line\n",
        "\n",
        "        return UpdateFromAlphaFunc(line, update_line, **kwargs)\n",
        "\n",
        "class BreakApartSum(Scene):\n",
        "    CONFIG = {\n",
        "        \"frequencies\" : [0.5, 1.5, 2, 2.5, 5],\n",
        "        \"equilibrium_height\" : 2.0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_initial_sound()\n",
        "        self.decompose_sound()\n",
        "        self.ponder_question()\n",
        "\n",
        "    def show_initial_sound(self):\n",
        "        def func(x):\n",
        "            return self.equilibrium_height + 0.2*np.sum([\n",
        "                np.cos(2*np.pi*f*x)\n",
        "                for f in self.frequencies\n",
        "            ])\n",
        "        axes = Axes(\n",
        "            x_min = 0, x_max = 5,\n",
        "            y_min = -1, y_max = 5,\n",
        "            x_axis_config = {\n",
        "                \"include_tip\" : False,\n",
        "                \"unit_size\" : 2.0,\n",
        "            },\n",
        "            y_axis_config = {\n",
        "                \"include_tip\" : False,\n",
        "                \"unit_size\" : 0.5,\n",
        "            },\n",
        "        )\n",
        "        axes.stretch_to_fit_width(FRAME_WIDTH - 2)\n",
        "        axes.stretch_to_fit_height(3)\n",
        "        axes.center()\n",
        "        axes.to_edge(LEFT)\n",
        "        graph = axes.get_graph(func, num_graph_points = 200)\n",
        "        graph.set_color(YELLOW)\n",
        "\n",
        "        v_line = Line(ORIGIN, 4*UP)\n",
        "        v_line.move_to(axes.coords_to_point(0, 0), DOWN)\n",
        "        dot = Dot(color = PINK)\n",
        "        dot.move_to(graph.point_from_proportion(0))\n",
        "\n",
        "        self.add(axes, graph)\n",
        "        self.play(\n",
        "            v_line.move_to, axes.coords_to_point(5, 0), DOWN,\n",
        "            MoveAlongPath(dot, graph),\n",
        "            run_time = 8,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [dot, v_line])))\n",
        "\n",
        "        self.set_variables_as_attrs(axes, graph)\n",
        "\n",
        "    def decompose_sound(self):\n",
        "        axes, graph = self.axes, self.graph\n",
        "\n",
        "        pure_graphs = VGroup(*[\n",
        "            axes.get_graph(\n",
        "                lambda x : 0.5*np.cos(2*np.pi*freq*x),\n",
        "                num_graph_points = 100,\n",
        "            )\n",
        "            for freq in self.frequencies\n",
        "        ])\n",
        "        pure_graphs.set_color_by_gradient(BLUE, RED)\n",
        "        pure_graphs.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        h_line = DashedLine(6*LEFT, 6*RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(axes),\n",
        "            graph.to_edge, UP\n",
        "        )\n",
        "        pure_graphs.next_to(graph, DOWN, LARGE_BUFF)\n",
        "        h_line.next_to(graph, DOWN, MED_LARGE_BUFF)\n",
        "        self.play(ShowCreation(h_line))\n",
        "        for pure_graph in reversed(pure_graphs):\n",
        "            self.play(ReplacementTransform(graph.copy(), pure_graph))\n",
        "        self.wait()\n",
        "\n",
        "        self.all_graphs = VGroup(graph, h_line, pure_graphs)\n",
        "        self.pure_graphs = pure_graphs\n",
        "\n",
        "    def ponder_question(self):\n",
        "        all_graphs = self.all_graphs\n",
        "        pure_graphs = self.pure_graphs\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(randy),\n",
        "            all_graphs.scale, 0.75,\n",
        "            all_graphs.to_corner, UP+RIGHT,\n",
        "        )\n",
        "        self.play(randy.change, \"pondering\", all_graphs)\n",
        "        self.play(Blink(randy))\n",
        "        rect = SurroundingRectangle(pure_graphs, color = WHITE)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            LaggedStartMap(\n",
        "                ApplyFunction, pure_graphs,\n",
        "                lambda g : (lambda m : m.shift(SMALL_BUFF*UP).set_color(YELLOW), g),\n",
        "                rate_func = wiggle\n",
        "            )\n",
        "        )\n",
        "        self.play(FadeOut(rect))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class Quadrant(VMobject):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 2,\n",
        "        \"stroke_width\": 0,\n",
        "        \"fill_opacity\" : 1,\n",
        "        \"density\" : 50,\n",
        "        \"density_exp\" : 2.0,\n",
        "    }\n",
        "    def init_points(self):\n",
        "        points = [r*RIGHT for r in np.arange(0, self.radius, 1./self.density)]\n",
        "        points += [\n",
        "            self.radius*(np.cos(theta)*RIGHT + np.sin(theta)*UP)\n",
        "            for theta in np.arange(0, TAU/4, 1./(self.radius*self.density))\n",
        "        ]\n",
        "        points += [r*UP for r in np.arange(self.radius, 0, -1./self.density)]\n",
        "        self.set_points_smoothly(points)\n",
        "\n",
        "class UnmixMixedPaint(Scene):\n",
        "    CONFIG = {\n",
        "        \"colors\" : [BLUE, RED, YELLOW, GREEN],\n",
        "    }\n",
        "    def construct(self):\n",
        "        angles = np.arange(4)*np.pi/2\n",
        "        quadrants = VGroup(*[\n",
        "            Quadrant().rotate(angle, about_point = ORIGIN).set_color(color)\n",
        "            for color, angle in zip(self.colors, angles)\n",
        "        ])\n",
        "        quadrants.add(*it.chain(*[\n",
        "            quadrants.copy().rotate(angle)\n",
        "            for angle in np.linspace(0, 0.02*TAU, 10)\n",
        "        ]))\n",
        "        quadrants.set_fill(opacity = 0.5)\n",
        "\n",
        "        mud_color = average_color(*self.colors)\n",
        "        mud_circle = Circle(radius = 2, stroke_width = 0)\n",
        "        mud_circle.set_fill(mud_color, 1)\n",
        "        mud_circle.save_state()\n",
        "        mud_circle.scale(0)\n",
        "\n",
        "        def update_quadrant(quadrant, alpha):\n",
        "            points = quadrant.get_anchors()\n",
        "            dt = 0.03 #Hmm, this has no dependency on frame rate...\n",
        "            norms = np.apply_along_axis(get_norm, 1, points)\n",
        "\n",
        "            points[:,0] -= dt*points[:,1]/np.clip(norms, 0.1, np.inf)\n",
        "            points[:,1] += dt*points[:,0]/np.clip(norms, 0.1, np.inf)\n",
        "\n",
        "            new_norms = np.apply_along_axis(get_norm, 1, points)\n",
        "            new_norms = np.clip(new_norms, 0.001, np.inf)\n",
        "            radius = np.max(norms)\n",
        "            multiplier = norms/new_norms\n",
        "            multiplier = multiplier.reshape((len(multiplier), 1))\n",
        "            multiplier.repeat(points.shape[1], axis = 1)\n",
        "            points *= multiplier\n",
        "            quadrant.set_points_smoothly(points)\n",
        "\n",
        "        self.add(quadrants)\n",
        "        run_time = 30\n",
        "        self.play(\n",
        "            *[\n",
        "                UpdateFromAlphaFunc(quadrant, update_quadrant)\n",
        "                for quadrant in quadrants\n",
        "            ] + [\n",
        "                ApplyMethod(mud_circle.restore, rate_func=linear)\n",
        "            ],\n",
        "            run_time = run_time\n",
        "        )\n",
        "\n",
        "#Incomplete, and probably not useful\n",
        "class MachineThatTreatsOneFrequencyDifferently(Scene):\n",
        "    def construct(self):\n",
        "        graph = self.get_cosine_graph(0.5)\n",
        "        frequency_mob = DecimalNumber(220, num_decimal_places = 0)\n",
        "        frequency_mob.next_to(graph, UP, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.graph = graph\n",
        "        self.frequency_mob = frequency_mob\n",
        "        self.add(graph, frequency_mob)\n",
        "\n",
        "        arrow1, q_marks, arrow2 = group = VGroup(\n",
        "            Vector(DOWN), OldTexText(\"???\").scale(1.5), Vector(DOWN)\n",
        "        )\n",
        "        group.set_color(WHITE)\n",
        "        group.arrange(DOWN)\n",
        "        group.next_to(graph, DOWN)\n",
        "        self.add(group)\n",
        "\n",
        "        self.change_graph_frequency(1)\n",
        "        graph.set_color(GREEN)\n",
        "        self.wait()\n",
        "        graph.set_color(YELLOW)\n",
        "        self.change_graph_frequency(2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def change_graph_frequency(self, frequency, run_time = 2):\n",
        "        graph = self.graph\n",
        "        frequency_mob = self.frequency_mob\n",
        "        curr_frequency = graph.frequency\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                graph, self.get_signal_update_func(graph, frequency),\n",
        "            ),\n",
        "            ChangingDecimal(\n",
        "                frequency_mob, \n",
        "                lambda a : 440*interpolate(curr_frequency, frequency, a)\n",
        "            ),\n",
        "            run_time = run_time,\n",
        "        )\n",
        "        graph.frequency = frequency\n",
        "\n",
        "    def get_signal_update_func(self, graph, target_frequency):\n",
        "        curr_frequency = graph.frequency\n",
        "        def update(graph, alpha):\n",
        "            frequency = interpolate(curr_frequency, target_frequency, alpha)\n",
        "            new_graph = self.get_cosine_graph(frequency)\n",
        "            Transform(graph, new_graph).update(1)\n",
        "            return graph\n",
        "        return update\n",
        "\n",
        "    def get_cosine_graph(self, frequency, num_steps = 200, color = YELLOW):\n",
        "        result = FunctionGraph(\n",
        "            lambda x : 0.5*np.cos(2*np.pi*frequency*x),\n",
        "            num_steps = num_steps\n",
        "        )\n",
        "        result.frequency = frequency\n",
        "        result.shift(2*UP)\n",
        "        return result\n",
        "\n",
        "class FourierMachineScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"time_axes_config\" : {\n",
        "            \"x_min\" : 0,\n",
        "            \"x_max\" : 4.4,\n",
        "            \"x_axis_config\" : {\n",
        "                \"unit_size\" : 3,\n",
        "                \"tick_frequency\" : 0.25,\n",
        "                \"big_tick_numbers\" : [1, 2, 3],\n",
        "            },\n",
        "            \"y_min\" : 0,\n",
        "            \"y_max\" : 2,\n",
        "            \"y_axis_config\" : {\"unit_size\" : 0.8},\n",
        "        },\n",
        "        \"time_label_t\" : 3.4,\n",
        "        \"circle_plane_config\" : {\n",
        "            \"x_radius\" : 2.1,\n",
        "            \"y_radius\" : 2.1,\n",
        "            \"x_unit_size\" : 1,\n",
        "            \"y_unit_size\" : 1,\n",
        "        },\n",
        "        \"frequency_axes_config\" : {\n",
        "            \"axis_config\" : {\n",
        "                \"color\" : TEAL,\n",
        "            },\n",
        "            \"x_min\" : 0,\n",
        "            \"x_max\" : 5.0,\n",
        "            \"x_axis_config\" : {\n",
        "                \"unit_size\" : 1.4,\n",
        "                \"numbers_to_show\" : list(range(1, 6)),\n",
        "            },\n",
        "            \"y_min\" : -1.0,\n",
        "            \"y_max\" : 1.0,\n",
        "            \"y_axis_config\" : {\n",
        "                \"unit_size\" : 1.8,\n",
        "                \"tick_frequency\" : 0.5,\n",
        "                \"label_direction\" : LEFT,\n",
        "            },\n",
        "            \"color\" : TEAL,\n",
        "        },\n",
        "        \"frequency_axes_box_color\" : TEAL_E,\n",
        "        \"text_scale_val\" : 0.75,\n",
        "        \"default_graph_config\" : {\n",
        "            \"num_graph_points\" : 100,\n",
        "            \"color\" : YELLOW,\n",
        "        },\n",
        "        \"equilibrium_height\" : 1,\n",
        "        \"default_y_vector_animation_config\" : {\n",
        "            \"run_time\" : 5,\n",
        "            \"rate_func\" : None,\n",
        "            \"remover\" : True,\n",
        "        },\n",
        "        \"default_time_sweep_config\" : {\n",
        "            \"rate_func\" : None,\n",
        "            \"run_time\" : 5,\n",
        "        },\n",
        "        \"default_num_v_lines_indicating_periods\" : 20,\n",
        "    }\n",
        "\n",
        "    def get_time_axes(self):\n",
        "        time_axes = Axes(**self.time_axes_config)\n",
        "        time_axes.x_axis.add_numbers()\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        intensity_label = OldTexText(\"Intensity\")\n",
        "        labels = VGroup(time_label, intensity_label)\n",
        "        for label in labels:\n",
        "            label.scale(self.text_scale_val)\n",
        "        time_label.next_to(\n",
        "            time_axes.coords_to_point(self.time_label_t,0), \n",
        "            DOWN\n",
        "        )\n",
        "        intensity_label.next_to(time_axes.y_axis.get_top(), RIGHT)\n",
        "        time_axes.labels = labels\n",
        "        time_axes.add(labels)\n",
        "        time_axes.to_corner(UP+LEFT)\n",
        "        self.time_axes = time_axes\n",
        "        return time_axes\n",
        "\n",
        "    def get_circle_plane(self):\n",
        "        circle_plane = NumberPlane(**self.circle_plane_config)\n",
        "        circle_plane.to_corner(DOWN+LEFT)\n",
        "        circle = DashedLine(ORIGIN, TAU*UP).apply_complex_function(np.exp)\n",
        "        circle.scale(circle_plane.x_unit_size)\n",
        "        circle.move_to(circle_plane.coords_to_point(0, 0))\n",
        "        circle_plane.circle = circle\n",
        "        circle_plane.add(circle)\n",
        "        circle_plane.fade()\n",
        "        self.circle_plane = circle_plane\n",
        "        return circle_plane\n",
        "\n",
        "    def get_frequency_axes(self):\n",
        "        frequency_axes = Axes(**self.frequency_axes_config)\n",
        "        frequency_axes.x_axis.add_numbers()\n",
        "        frequency_axes.y_axis.add_numbers(\n",
        "            *frequency_axes.y_axis.get_tick_numbers()\n",
        "        )\n",
        "        box = SurroundingRectangle(\n",
        "            frequency_axes,\n",
        "            buff = MED_SMALL_BUFF,\n",
        "            color = self.frequency_axes_box_color,\n",
        "        )\n",
        "        frequency_axes.box = box\n",
        "        frequency_axes.add(box)\n",
        "        frequency_axes.to_corner(DOWN+RIGHT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        frequency_label = OldTexText(\"Frequency\")\n",
        "        frequency_label.scale(self.text_scale_val)\n",
        "        frequency_label.next_to(\n",
        "            frequency_axes.x_axis.get_right(), DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT,\n",
        "        )\n",
        "        frequency_axes.label = frequency_label\n",
        "        frequency_axes.add(frequency_label)\n",
        "\n",
        "        self.frequency_axes = frequency_axes\n",
        "        return frequency_axes\n",
        "\n",
        "    def get_time_graph(self, func, **kwargs):\n",
        "        if not hasattr(self, \"time_axes\"):\n",
        "            self.get_time_axes()\n",
        "        config = dict(self.default_graph_config)\n",
        "        config.update(kwargs)\n",
        "        graph = self.time_axes.get_graph(func, **config)\n",
        "        return graph\n",
        "\n",
        "    def get_cosine_wave(self, freq = 1, shift_val = 1, scale_val = 0.9):\n",
        "        return self.get_time_graph(\n",
        "            lambda t : shift_val + scale_val*np.cos(TAU*freq*t)\n",
        "        )\n",
        "\n",
        "    def get_fourier_transform_graph(self, time_graph, **kwargs):\n",
        "        if not hasattr(self, \"frequency_axes\"):\n",
        "            self.get_frequency_axes()\n",
        "        func = time_graph.underlying_function\n",
        "        t_axis = self.time_axes.x_axis\n",
        "        t_min = t_axis.point_to_number(time_graph.get_points()[0])\n",
        "        t_max = t_axis.point_to_number(time_graph.get_points()[-1])\n",
        "        f_max = self.frequency_axes.x_max\n",
        "        # result = get_fourier_graph(\n",
        "        #     self.frequency_axes, func, t_min, t_max,\n",
        "        #     **kwargs\n",
        "        # )\n",
        "        # too_far_right_point_indices = [\n",
        "        #     i\n",
        "        #     for i, point in enumerate(result.get_points())\n",
        "        #     if self.frequency_axes.x_axis.point_to_number(point) > f_max\n",
        "        # ]\n",
        "        # if too_far_right_point_indices:\n",
        "        #     i = min(too_far_right_point_indices)\n",
        "        #     prop = float(i)/len(result.get_points())\n",
        "        #     result.pointwise_become_partial(result, 0, prop)\n",
        "        # return result\n",
        "        return self.frequency_axes.get_graph(\n",
        "            get_fourier_transform(func, t_min, t_max, **kwargs),\n",
        "            color = self.center_of_mass_color,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_polarized_mobject(self, mobject, freq = 1.0):\n",
        "        if not hasattr(self, \"circle_plane\"):\n",
        "            self.get_circle_plane()\n",
        "        polarized_mobject = mobject.copy()\n",
        "        polarized_mobject.apply_function(lambda p : self.polarize_point(p, freq))\n",
        "        # polarized_mobject.make_smooth()\n",
        "        mobject.polarized_mobject = polarized_mobject\n",
        "        polarized_mobject.frequency = freq\n",
        "        return polarized_mobject\n",
        "\n",
        "    def polarize_point(self, point, freq = 1.0):\n",
        "        t, y = self.time_axes.point_to_coords(point)\n",
        "        z = y*np.exp(complex(0, -2*np.pi*freq*t))\n",
        "        return self.circle_plane.coords_to_point(z.real, z.imag)\n",
        "\n",
        "    def get_polarized_animation(self, mobject, freq = 1.0):\n",
        "        p_mob = self.get_polarized_mobject(mobject, freq = freq)\n",
        "        def update_p_mob(p_mob):\n",
        "            Transform(\n",
        "                p_mob, \n",
        "                self.get_polarized_mobject(mobject, freq = freq)\n",
        "            ).update(1)\n",
        "            mobject.polarized_mobject = p_mob\n",
        "            return p_mob\n",
        "        return UpdateFromFunc(p_mob, update_p_mob)\n",
        "\n",
        "    def animate_frequency_change(self, mobjects, new_freq, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 3.0)\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        self.play(*[\n",
        "            self.get_frequency_change_animation(mob, new_freq, **kwargs)\n",
        "            for mob in mobjects\n",
        "        ] + added_anims)\n",
        "\n",
        "    def get_frequency_change_animation(self, mobject, new_freq, **kwargs):\n",
        "        if not hasattr(mobject, \"polarized_mobject\"):\n",
        "            mobject.polarized_mobject = self.get_polarized_mobject(mobject)\n",
        "        start_freq = mobject.polarized_mobject.frequency\n",
        "        def update(pm, alpha):\n",
        "            freq = interpolate(start_freq, new_freq, alpha)\n",
        "            new_pm = self.get_polarized_mobject(mobject, freq)\n",
        "            Transform(pm, new_pm).update(1)\n",
        "            mobject.polarized_mobject = pm\n",
        "            mobject.polarized_mobject.frequency = freq\n",
        "            return pm\n",
        "        return UpdateFromAlphaFunc(mobject.polarized_mobject, update, **kwargs)\n",
        "\n",
        "    def get_time_graph_y_vector_animation(self, graph, **kwargs):\n",
        "        config = dict(self.default_y_vector_animation_config)\n",
        "        config.update(kwargs)\n",
        "        vector = Vector(UP, color = WHITE)\n",
        "        graph_copy = graph.copy()\n",
        "        x_axis = self.time_axes.x_axis\n",
        "        x_min = x_axis.point_to_number(graph.get_points()[0])\n",
        "        x_max = x_axis.point_to_number(graph.get_points()[-1])\n",
        "        def update_vector(vector, alpha):\n",
        "            x = interpolate(x_min, x_max, alpha)\n",
        "            vector.put_start_and_end_on(\n",
        "                self.time_axes.coords_to_point(x, 0),\n",
        "                self.time_axes.input_to_graph_point(x, graph_copy)\n",
        "            )\n",
        "            return vector\n",
        "        return UpdateFromAlphaFunc(vector, update_vector, **config)\n",
        "\n",
        "    def get_polarized_vector_animation(self, polarized_graph, **kwargs):\n",
        "        config = dict(self.default_y_vector_animation_config)\n",
        "        config.update(kwargs)\n",
        "        vector = Vector(RIGHT, color = WHITE)\n",
        "        origin = self.circle_plane.coords_to_point(0, 0)\n",
        "        graph_copy = polarized_graph.copy()\n",
        "        def update_vector(vector, alpha):\n",
        "            # Not sure why this is needed, but without smoothing \n",
        "            # out the alpha like this, the vector would occasionally\n",
        "            # jump around\n",
        "            point = center_of_mass([\n",
        "                graph_copy.point_from_proportion(alpha+d)\n",
        "                for d in np.linspace(-0.001, 0.001, 5)\n",
        "            ])\n",
        "            vector.put_start_and_end_on_with_projection(origin, point)\n",
        "            return vector\n",
        "        return UpdateFromAlphaFunc(vector, update_vector, **config)\n",
        "\n",
        "    def get_vector_animations(self, graph, draw_polarized_graph = True, **kwargs):\n",
        "        config = dict(self.default_y_vector_animation_config)\n",
        "        config.update(kwargs)\n",
        "        anims = [\n",
        "            self.get_time_graph_y_vector_animation(graph, **config),\n",
        "            self.get_polarized_vector_animation(graph.polarized_mobject, **config),\n",
        "        ]\n",
        "        if draw_polarized_graph:\n",
        "            new_config = dict(config)\n",
        "            new_config[\"remover\"] = False\n",
        "            anims.append(ShowCreation(graph.polarized_mobject, **new_config))\n",
        "        return anims\n",
        "\n",
        "    def animate_time_sweep(self, freq, n_repeats = 1, t_max = None, **kwargs):\n",
        "        added_anims = kwargs.pop(\"added_anims\", [])\n",
        "        config = dict(self.default_time_sweep_config)\n",
        "        config.update(kwargs)\n",
        "        circle_plane = self.circle_plane\n",
        "        time_axes = self.time_axes\n",
        "        ctp = time_axes.coords_to_point\n",
        "        t_max = t_max or time_axes.x_max\n",
        "        v_line = DashedLine(\n",
        "            ctp(0, 0), ctp(0, time_axes.y_max),\n",
        "            stroke_width = 6,\n",
        "        )\n",
        "        v_line.set_color(RED)\n",
        "\n",
        "        for x in range(n_repeats):\n",
        "            v_line.move_to(ctp(0, 0), DOWN)\n",
        "            self.play(\n",
        "                ApplyMethod(\n",
        "                    v_line.move_to, \n",
        "                    ctp(t_max, 0), DOWN\n",
        "                ),\n",
        "                self.get_polarized_animation(v_line, freq = freq),\n",
        "                *added_anims,\n",
        "                **config\n",
        "            )\n",
        "            self.remove(v_line.polarized_mobject)\n",
        "        self.play(FadeOut(VGroup(v_line, v_line.polarized_mobject)))\n",
        "\n",
        "    def get_v_lines_indicating_periods(self, freq, n_lines = None):\n",
        "        if n_lines is None:\n",
        "            n_lines = self.default_num_v_lines_indicating_periods\n",
        "        period = np.divide(1., max(freq, 0.01))\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(ORIGIN, 1.5*UP).move_to(\n",
        "                self.time_axes.coords_to_point(n*period, 0),\n",
        "                DOWN\n",
        "            )\n",
        "            for n in range(1, n_lines + 1)\n",
        "        ])\n",
        "        v_lines.set_stroke(GREY_B)\n",
        "        return v_lines\n",
        "\n",
        "    def get_period_v_lines_update_anim(self):\n",
        "        def update_v_lines(v_lines):\n",
        "            freq = self.graph.polarized_mobject.frequency\n",
        "            Transform(\n",
        "                v_lines,\n",
        "                self.get_v_lines_indicating_periods(freq)\n",
        "            ).update(1)\n",
        "        return UpdateFromFunc(\n",
        "            self.v_lines_indicating_periods, update_v_lines\n",
        "        )\n",
        "\n",
        "class WrapCosineGraphAroundCircle(FourierMachineScene):\n",
        "    CONFIG = {\n",
        "        \"initial_winding_frequency\" : 0.5,\n",
        "        \"signal_frequency\" : 3.0,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_initial_signal()\n",
        "        self.show_finite_interval()\n",
        "        self.wrap_around_circle()\n",
        "        self.show_time_sweeps()\n",
        "        self.compare_two_frequencies()\n",
        "        self.change_wrapping_frequency()\n",
        "\n",
        "    def show_initial_signal(self):\n",
        "        axes = self.get_time_axes()\n",
        "        graph = self.get_cosine_wave(freq = self.signal_frequency)\n",
        "        self.graph = graph\n",
        "        braces = VGroup(*self.get_peak_braces()[3:6])\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                ORIGIN, 2*UP, color = RED\n",
        "            ).move_to(axes.coords_to_point(x, 0), DOWN)\n",
        "            for x in (1, 2)\n",
        "        ])\n",
        "        words = self.get_bps_label()\n",
        "        words.save_state()\n",
        "        words.next_to(axes.coords_to_point(1.5, 0), DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph, run_time = 2, rate_func=linear))\n",
        "        self.play(\n",
        "            FadeIn(words),\n",
        "            LaggedStartMap(FadeIn, braces),\n",
        "            *list(map(ShowCreation, v_lines))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(braces, v_lines)),\n",
        "            words.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.beats_per_second_label = words\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_finite_interval(self):\n",
        "        axes = self.time_axes\n",
        "        v_line = DashedLine(\n",
        "            axes.coords_to_point(0, 0),\n",
        "            axes.coords_to_point(0, axes.y_max),\n",
        "            color = RED,\n",
        "            stroke_width = 6,\n",
        "        )\n",
        "        h_line = Line(\n",
        "            axes.coords_to_point(0, 0),\n",
        "            axes.coords_to_point(axes.x_max, 0),\n",
        "        )\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = TEAL,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        rect.match_height(v_line)\n",
        "        rect.match_width(h_line, stretch = True)\n",
        "        rect.move_to(v_line, DOWN+LEFT)\n",
        "        right_v_line = v_line.copy()\n",
        "        right_v_line.move_to(rect, RIGHT)\n",
        "\n",
        "        rect.save_state()\n",
        "        rect.stretch(0, 0, about_edge = ORIGIN)\n",
        "        self.play(rect.restore, run_time = 2)\n",
        "        self.play(FadeOut(rect))\n",
        "        for line in v_line, right_v_line:\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(FadeOut(line))\n",
        "        self.wait()\n",
        "\n",
        "    def wrap_around_circle(self):\n",
        "        graph = self.graph\n",
        "        freq = self.initial_winding_frequency\n",
        "        low_freq = freq/3\n",
        "        polarized_graph = self.get_polarized_mobject(graph, low_freq)\n",
        "        circle_plane = self.get_circle_plane()\n",
        "        moving_graph = graph.copy()\n",
        "\n",
        "        self.play(ShowCreation(circle_plane, lag_ratio = 0))\n",
        "        self.play(ReplacementTransform(\n",
        "            moving_graph,\n",
        "            polarized_graph,\n",
        "            run_time = 3,\n",
        "            path_arc = -TAU/2\n",
        "        ))\n",
        "        self.animate_frequency_change([graph], freq)\n",
        "        self.wait()\n",
        "        pg_copy = polarized_graph.copy()\n",
        "        self.remove(polarized_graph)\n",
        "        self.play(pg_copy.fade, 0.75)\n",
        "        self.play(*self.get_vector_animations(graph), run_time = 15)\n",
        "        self.remove(pg_copy)\n",
        "        self.wait()\n",
        "\n",
        "    def show_time_sweeps(self):\n",
        "        freq = self.initial_winding_frequency\n",
        "        graph = self.graph\n",
        "\n",
        "        v_lines = self.get_v_lines_indicating_periods(freq)\n",
        "        winding_freq_label = self.get_winding_frequency_label()\n",
        "\n",
        "        self.animate_time_sweep(\n",
        "            freq = freq,\n",
        "            t_max = 4,\n",
        "            run_time = 6,\n",
        "            added_anims = [FadeIn(v_lines)]\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(winding_freq_label),\n",
        "            *self.get_vector_animations(graph)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.v_lines_indicating_periods = v_lines\n",
        "\n",
        "    def compare_two_frequencies(self):\n",
        "        bps_label = self.beats_per_second_label\n",
        "        wps_label = self.winding_freq_label\n",
        "        for label in bps_label, wps_label:\n",
        "            label.rect = SurroundingRectangle(\n",
        "                label, color = RED\n",
        "            )\n",
        "        graph = self.graph\n",
        "        freq = self.initial_winding_frequency\n",
        "        braces = self.get_peak_braces(buff = 0)\n",
        "\n",
        "        self.play(ShowCreation(bps_label.rect))\n",
        "        self.play(FadeOut(bps_label.rect))\n",
        "        self.play(LaggedStartMap(FadeIn, braces, run_time = 3))\n",
        "        self.play(FadeOut(braces))\n",
        "        self.play(ShowCreation(wps_label.rect))\n",
        "        self.play(FadeOut(wps_label.rect))\n",
        "        self.animate_time_sweep(freq = freq, t_max = 4)\n",
        "        self.wait()\n",
        "\n",
        "    def change_wrapping_frequency(self):\n",
        "        graph = self.graph\n",
        "        v_lines = self.v_lines_indicating_periods\n",
        "        freq_label = self.winding_freq_label[0]\n",
        "\n",
        "        count = 0\n",
        "        for target_freq in [1.23, 0.2, 0.79, 1.55, self.signal_frequency]:\n",
        "            self.play(\n",
        "                Transform(\n",
        "                    v_lines, \n",
        "                    self.get_v_lines_indicating_periods(target_freq)\n",
        "                ),\n",
        "                ChangeDecimalToValue(freq_label, target_freq),\n",
        "                self.get_frequency_change_animation(graph, target_freq),\n",
        "                run_time = 4,\n",
        "            )\n",
        "            self.wait()\n",
        "            if count == 2:\n",
        "                self.play(LaggedStartMap(\n",
        "                    ApplyFunction, v_lines,\n",
        "                    lambda mob : (\n",
        "                        lambda m : m.shift(0.25*UP).set_color(YELLOW), \n",
        "                        mob\n",
        "                    ),\n",
        "                    rate_func = there_and_back\n",
        "                ))\n",
        "                self.animate_time_sweep(target_freq, t_max = 2)\n",
        "            count += 1\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *self.get_vector_animations(graph, False),\n",
        "            run_time = 15\n",
        "        )\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_winding_frequency_label(self):\n",
        "        freq = self.initial_winding_frequency\n",
        "        winding_freq_label = VGroup(\n",
        "            DecimalNumber(freq, num_decimal_places=2),\n",
        "            OldTexText(\"cycles/second\")\n",
        "        )\n",
        "        winding_freq_label.arrange(RIGHT)\n",
        "        winding_freq_label.next_to(\n",
        "            self.circle_plane, RIGHT, aligned_edge = UP\n",
        "        )\n",
        "        self.winding_freq_label = winding_freq_label\n",
        "        return winding_freq_label\n",
        "\n",
        "    def get_peak_braces(self, **kwargs):\n",
        "        peak_points = [\n",
        "            self.time_axes.input_to_graph_point(x, self.graph)\n",
        "            for x in np.arange(0, 3.5, 1./self.signal_frequency)\n",
        "        ]\n",
        "        return VGroup(*[\n",
        "            Brace(Line(p1, p2), UP, **kwargs)\n",
        "            for p1, p2 in zip(peak_points, peak_points[1:])\n",
        "        ])\n",
        "\n",
        "    def get_bps_label(self, freq = 3):\n",
        "        braces = VGroup(*self.get_peak_braces()[freq:2*freq])\n",
        "        words = OldTexText(\"%d beats/second\"%freq)\n",
        "        words.set_width(0.9*braces.get_width())\n",
        "        words.move_to(braces, DOWN)\n",
        "        return words\n",
        "\n",
        "class DrawFrequencyPlot(WrapCosineGraphAroundCircle, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"initial_winding_frequency\" : 3.0,\n",
        "        \"center_of_mass_color\" : RED,\n",
        "        \"center_of_mass_multiple\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.setup_graph()\n",
        "        self.indicate_weight_of_wire()\n",
        "        self.show_center_of_mass_dot()\n",
        "        self.change_to_various_frequencies()\n",
        "        self.introduce_frequency_plot()\n",
        "        self.draw_full_frequency_plot()\n",
        "        self.recap_objects_on_screen()\n",
        "        self.lower_graph()\n",
        "        self.label_as_almost_fourier()\n",
        "\n",
        "    def setup_graph(self):\n",
        "        self.add(self.get_time_axes())\n",
        "        self.add(self.get_circle_plane())\n",
        "        self.graph = self.get_cosine_wave(self.signal_frequency)\n",
        "        self.add(self.graph)\n",
        "        self.add(self.get_polarized_mobject(\n",
        "            self.graph, self.initial_winding_frequency\n",
        "        ))\n",
        "        self.add(self.get_winding_frequency_label())\n",
        "        self.beats_per_second_label = self.get_bps_label()\n",
        "        self.add(self.beats_per_second_label)        \n",
        "        self.v_lines_indicating_periods = self.get_v_lines_indicating_periods(\n",
        "            self.initial_winding_frequency\n",
        "        )\n",
        "        self.add(self.v_lines_indicating_periods)\n",
        "        self.change_frequency(1.03)\n",
        "        self.wait()\n",
        "\n",
        "    def indicate_weight_of_wire(self):\n",
        "        graph = self.graph\n",
        "        pol_graph = graph.polarized_mobject.copy()\n",
        "        pol_graph.save_state()\n",
        "        morty = self.pi_creature\n",
        "        morty.change(\"raise_right_hand\")\n",
        "        morty.save_state()\n",
        "        morty.change(\"plain\")\n",
        "        morty.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            morty.restore,\n",
        "            pol_graph.scale, 0.5,\n",
        "            pol_graph.next_to, morty.get_corner(UP+LEFT), UP, -SMALL_BUFF,\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change, \"lower_right_hand\", pol_graph.get_bottom(),\n",
        "            pol_graph.shift, 0.45*DOWN,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        metal_wire = pol_graph.copy().set_stroke(GREY_B)\n",
        "        self.play(\n",
        "            ShowCreationThenDestruction(metal_wire),\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play(\n",
        "            pol_graph.restore,\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.remove(pol_graph)\n",
        "\n",
        "    def show_center_of_mass_dot(self):\n",
        "        color = self.center_of_mass_color\n",
        "        dot = self.get_center_of_mass_dot()\n",
        "        dot.save_state()\n",
        "        arrow = Vector(DOWN+2*LEFT, color = color)\n",
        "        arrow.next_to(dot.get_center(), UP+RIGHT, buff = SMALL_BUFF)\n",
        "        dot.move_to(arrow.get_start())\n",
        "        words = OldTexText(\"Center of mass\")\n",
        "        words.next_to(arrow.get_start(), RIGHT)\n",
        "        words.set_color(color)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            dot.restore,\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.play(FadeOut(arrow), FadeOut(self.pi_creature))\n",
        "        self.wait()\n",
        "\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "        self.center_of_mass_label = words\n",
        "\n",
        "    def change_to_various_frequencies(self):\n",
        "        self.change_frequency(\n",
        "            3.0, run_time = 30,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *self.get_vector_animations(self.graph),\n",
        "            run_time = 15\n",
        "        )\n",
        "\n",
        "    def introduce_frequency_plot(self):\n",
        "        wps_label = self.winding_freq_label\n",
        "        wps_label.add_to_back(BackgroundRectangle(wps_label))\n",
        "        com_label = self.center_of_mass_label\n",
        "        com_label.add_background_rectangle()\n",
        "        frequency_axes = self.get_frequency_axes()\n",
        "        x_coord_label = OldTexText(\"$x$-coordinate for center of mass\")\n",
        "        x_coord_label.set_color(self.center_of_mass_color)\n",
        "        x_coord_label.scale(self.text_scale_val)\n",
        "        x_coord_label.next_to(\n",
        "            frequency_axes.y_axis.get_top(),\n",
        "            RIGHT, aligned_edge = UP, buff = LARGE_BUFF\n",
        "        )\n",
        "        x_coord_label.add_background_rectangle()\n",
        "        flower_path = ParametricCurve(\n",
        "            lambda t : self.circle_plane.coords_to_point(\n",
        "                np.sin(2*t)*np.cos(t),\n",
        "                np.sin(2*t)*np.sin(t),\n",
        "            ),\n",
        "            t_min = 0, t_max = TAU,\n",
        "        )\n",
        "        flower_path.move_to(self.center_of_mass_dot)\n",
        "\n",
        "        self.play(\n",
        "            wps_label.move_to, self.circle_plane.get_top(),\n",
        "            com_label.move_to, self.circle_plane, DOWN,\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, frequency_axes))\n",
        "        self.wait()\n",
        "        self.play(MoveAlongPath(\n",
        "            self.center_of_mass_dot, flower_path,\n",
        "            run_time = 4,\n",
        "        ))\n",
        "        self.play(ReplacementTransform(\n",
        "            com_label.copy(), x_coord_label\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.x_coord_label = x_coord_label\n",
        "\n",
        "    def draw_full_frequency_plot(self):\n",
        "        graph = self.graph\n",
        "        fourier_graph = self.get_fourier_transform_graph(graph)\n",
        "        fourier_graph.save_state()\n",
        "        fourier_graph_update = self.get_fourier_graph_drawing_update_anim(\n",
        "            fourier_graph\n",
        "        )\n",
        "        v_line = DashedLine(\n",
        "            self.frequency_axes.coords_to_point(0, 0),\n",
        "            self.frequency_axes.coords_to_point(0, 1),\n",
        "            stroke_width = 6,\n",
        "            color = fourier_graph.get_color()\n",
        "        )\n",
        "\n",
        "        self.change_frequency(0.0)\n",
        "        self.generate_fourier_dot_transform(fourier_graph)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.play(\n",
        "            GrowFromCenter(self.fourier_graph_dot),\n",
        "            FadeOut(v_line)\n",
        "        )\n",
        "        f_max = int(self.frequency_axes.x_max)\n",
        "        for freq in [0.2, 1.5, 3.0, 4.0, 5.0]:\n",
        "            fourier_graph.restore()\n",
        "            self.change_frequency(\n",
        "                freq,\n",
        "                added_anims = [fourier_graph_update],\n",
        "                run_time = 8,\n",
        "            )\n",
        "            self.wait()\n",
        "        self.fourier_graph = fourier_graph\n",
        "\n",
        "    def recap_objects_on_screen(self):\n",
        "        rect = FullScreenFadeRectangle()\n",
        "        time_group = VGroup(\n",
        "            self.graph,\n",
        "            self.time_axes,\n",
        "            self.beats_per_second_label,\n",
        "        ).copy()\n",
        "        circle_group = VGroup(\n",
        "            self.graph.polarized_mobject,\n",
        "            self.circle_plane,\n",
        "            self.winding_freq_label,\n",
        "            self.center_of_mass_label,\n",
        "            self.center_of_mass_dot,\n",
        "        ).copy()\n",
        "        frequency_group = VGroup(\n",
        "            self.fourier_graph,\n",
        "            self.frequency_axes,\n",
        "            self.x_coord_label,\n",
        "        ).copy()\n",
        "        groups = [time_group, circle_group, frequency_group]\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "        for group in groups:\n",
        "            graph_copy = group[0].copy().set_color(PINK)\n",
        "            self.play(FadeIn(group))\n",
        "            self.play(ShowCreation(graph_copy))\n",
        "            self.play(FadeOut(graph_copy))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(group))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "    def lower_graph(self):\n",
        "        graph = self.graph\n",
        "        time_axes = self.time_axes\n",
        "        shift_vect = time_axes.coords_to_point(0, 1)\n",
        "        shift_vect -= time_axes.coords_to_point(0, 0)\n",
        "        fourier_graph = self.fourier_graph\n",
        "        new_graph = self.get_cosine_wave(\n",
        "            self.signal_frequency, shift_val = 0\n",
        "        )\n",
        "        new_fourier_graph = self.get_fourier_transform_graph(new_graph)\n",
        "        for mob in graph, time_axes, fourier_graph:\n",
        "            mob.save_state()\n",
        "\n",
        "        new_freq = 0.03\n",
        "        self.change_frequency(new_freq)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            time_axes.shift, shift_vect/2,\n",
        "            graph.shift, -shift_vect/2,\n",
        "            self.get_frequency_change_animation(\n",
        "                self.graph, new_freq\n",
        "            ),\n",
        "            self.center_of_mass_dot_anim,\n",
        "            self.get_period_v_lines_update_anim(),\n",
        "            Transform(fourier_graph, new_fourier_graph),\n",
        "            self.fourier_graph_dot.move_to,\n",
        "                self.frequency_axes.coords_to_point(new_freq, 0),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(self.fourier_graph_dot)\n",
        "        self.generate_fourier_dot_transform(new_fourier_graph)\n",
        "        self.change_frequency(3.0, run_time = 15, rate_func=linear)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            graph.restore, \n",
        "            time_axes.restore,\n",
        "            self.get_frequency_change_animation(\n",
        "                self.graph, 3.0\n",
        "            ),\n",
        "            self.center_of_mass_dot_anim,\n",
        "            self.get_period_v_lines_update_anim(),\n",
        "            fourier_graph.restore,\n",
        "            Animation(self.fourier_graph_dot),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.generate_fourier_dot_transform(self.fourier_graph)\n",
        "        self.wait()\n",
        "        self.play(FocusOn(self.fourier_graph_dot))\n",
        "        self.wait()\n",
        "\n",
        "    def label_as_almost_fourier(self):\n",
        "        x_coord_label = self.x_coord_label\n",
        "        almost_fourier_label = OldTexText(\n",
        "            \"``Almost Fourier Transform''\",\n",
        "        )\n",
        "        almost_fourier_label.move_to(x_coord_label, UP+LEFT)\n",
        "        x_coord_label.generate_target()\n",
        "        x_coord_label.target.next_to(almost_fourier_label, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(x_coord_label),\n",
        "            Write(almost_fourier_label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_center_of_mass_dot(self):\n",
        "        dot = Dot(\n",
        "            self.get_pol_graph_center_of_mass(),\n",
        "            color = self.center_of_mass_color\n",
        "        )\n",
        "        self.center_of_mass_dot = dot\n",
        "        return dot\n",
        "\n",
        "    def get_pol_graph_center_of_mass(self):\n",
        "        pg = self.graph.polarized_mobject\n",
        "        result = center_of_mass(pg.get_anchors())\n",
        "        if self.center_of_mass_multiple != 1:\n",
        "            mult = self.center_of_mass_multiple\n",
        "            origin = self.circle_plane.coords_to_point(0, 0)\n",
        "            result = mult*(result - origin) + origin\n",
        "        return result\n",
        "\n",
        "    def generate_fourier_dot_transform(self, fourier_graph):\n",
        "        self.fourier_graph_dot = Dot(color = WHITE, radius = 0.05)\n",
        "        def update_dot(dot):\n",
        "            f = self.graph.polarized_mobject.frequency\n",
        "            dot.move_to(self.frequency_axes.input_to_graph_point(\n",
        "                f, fourier_graph\n",
        "            ))\n",
        "        self.fourier_graph_dot_anim = UpdateFromFunc(\n",
        "            self.fourier_graph_dot, update_dot\n",
        "        )\n",
        "        self.fourier_graph_dot_anim.update(0)\n",
        "\n",
        "    def get_fourier_graph_drawing_update_anim(self, fourier_graph):\n",
        "        fourier_graph_copy = fourier_graph.copy()\n",
        "        max_freq = self.frequency_axes.x_max\n",
        "        def update_fourier_graph(fg):\n",
        "            freq = self.graph.polarized_mobject.frequency\n",
        "            fg.pointwise_become_partial(\n",
        "                fourier_graph_copy,\n",
        "                0, freq/max_freq\n",
        "            )\n",
        "            return fg\n",
        "        self.fourier_graph_drawing_update_anim = UpdateFromFunc(\n",
        "            fourier_graph, update_fourier_graph\n",
        "        )\n",
        "        return self.fourier_graph_drawing_update_anim\n",
        "\n",
        "    def generate_center_of_mass_dot_update_anim(self, multiplier = 1):\n",
        "        origin = self.circle_plane.coords_to_point(0, 0)\n",
        "        com = self.get_pol_graph_center_of_mass\n",
        "        self.center_of_mass_dot_anim = UpdateFromFunc(\n",
        "            self.center_of_mass_dot, \n",
        "            lambda d : d.move_to(\n",
        "                multiplier*(com()-origin)+origin\n",
        "            )\n",
        "        )\n",
        "\n",
        "    def change_frequency(self, new_freq, **kwargs):\n",
        "        kwargs[\"run_time\"] = kwargs.get(\"run_time\", 3)\n",
        "        rate_func = kwargs.pop(\"rate_func\", None)\n",
        "        if rate_func is None:\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        anims = [self.get_frequency_change_animation(self.graph, new_freq)]\n",
        "        if hasattr(self, \"winding_freq_label\"):\n",
        "            freq_label = [\n",
        "                sm for sm in self.winding_freq_label\n",
        "                if isinstance(sm, DecimalNumber)\n",
        "            ][0]\n",
        "            self.add(freq_label)\n",
        "            anims.append(\n",
        "                ChangeDecimalToValue(freq_label, new_freq)\n",
        "            )\n",
        "        if hasattr(self, \"v_lines_indicating_periods\"):\n",
        "            anims.append(self.get_period_v_lines_update_anim())\n",
        "        if hasattr(self, \"center_of_mass_dot\"):\n",
        "            anims.append(self.center_of_mass_dot_anim)\n",
        "        if hasattr(self, \"fourier_graph_dot\"):\n",
        "            anims.append(self.fourier_graph_dot_anim)\n",
        "        if hasattr(self, \"fourier_graph_drawing_update_anim\"):\n",
        "            anims.append(self.fourier_graph_drawing_update_anim)\n",
        "        for anim in anims:\n",
        "            anim.rate_func = rate_func\n",
        "        anims += added_anims\n",
        "        self.play(*anims, **kwargs)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Mortimer().to_corner(DOWN+RIGHT)\n",
        "\n",
        "class StudentsHorrifiedAtScene(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_student_changes(\n",
        "            *3*[\"horrified\"],\n",
        "            look_at = 2*UP + 3*LEFT\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "class AskAboutAlmostFouierName(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"``Almost'' Fourier transform?\",\n",
        "            target_mode = \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"confused\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"We'll get to the real \\\\\\\\ one in a few minutes\",\n",
        "            added_anims = [self.change_students(*[\"plain\"]*3)]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ShowLowerFrequency(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"signal_frequency\" : 2.0,\n",
        "        \"higher_signal_frequency\" : 3.0,\n",
        "        \"lower_signal_color\" : PINK,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_all_axes()\n",
        "        self.show_lower_frequency_signal()\n",
        "        self.play_with_lower_frequency_signal()\n",
        "\n",
        "    def setup_all_axes(self):\n",
        "        self.add(self.get_time_axes())\n",
        "        self.add(self.get_circle_plane())\n",
        "        self.add(self.get_frequency_axes())\n",
        "        self.remove(self.pi_creature)\n",
        "\n",
        "    def show_lower_frequency_signal(self):\n",
        "        axes = self.time_axes\n",
        "        start_graph = self.get_cosine_wave(freq = self.higher_signal_frequency)\n",
        "        graph = self.get_cosine_wave(\n",
        "            freq = self.signal_frequency,\n",
        "        )\n",
        "        graph.set_color(self.lower_signal_color)\n",
        "        self.graph = graph\n",
        "        ratio = float(self.higher_signal_frequency)/self.signal_frequency\n",
        "\n",
        "        braces = VGroup(*self.get_peak_braces()[2:4])\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(ORIGIN, 1.5*UP).move_to(\n",
        "                axes.coords_to_point(x, 0), DOWN\n",
        "            )\n",
        "            for x in (1, 2)\n",
        "        ])\n",
        "        bps_label = self.get_bps_label(2)\n",
        "        bps_label.save_state()\n",
        "        bps_label.next_to(braces, UP, SMALL_BUFF)\n",
        "\n",
        "\n",
        "        # self.add(start_graph)\n",
        "        self.play(\n",
        "            start_graph.stretch, ratio, 0, {\"about_edge\" : LEFT},\n",
        "            start_graph.set_color, graph.get_color(),\n",
        "        )\n",
        "        self.play(FadeOut(start_graph), Animation(graph))\n",
        "        self.remove(start_graph)\n",
        "        self.play(\n",
        "            Write(bps_label),\n",
        "            LaggedStartMap(FadeIn, braces),\n",
        "            *list(map(ShowCreation, v_lines)),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(v_lines),\n",
        "            FadeOut(braces),\n",
        "            bps_label.restore,\n",
        "        )\n",
        "\n",
        "    def play_with_lower_frequency_signal(self):\n",
        "        freq = 0.1\n",
        "\n",
        "        #Wind up graph\n",
        "        graph = self.graph\n",
        "        pol_graph = self.get_polarized_mobject(graph, freq)\n",
        "        v_lines = self.get_v_lines_indicating_periods(freq)\n",
        "        self.v_lines_indicating_periods = v_lines\n",
        "        wps_label = self.get_winding_frequency_label()\n",
        "        ChangeDecimalToValue(wps_label[0], freq).update(1)\n",
        "        wps_label.add_to_back(BackgroundRectangle(wps_label))\n",
        "        wps_label.move_to(self.circle_plane, UP)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                graph.copy(), pol_graph,\n",
        "                run_time = 2,\n",
        "                path_arc = -TAU/4,\n",
        "            ),\n",
        "            FadeIn(wps_label),\n",
        "        )\n",
        "        self.change_frequency(freq, run_time = 0)\n",
        "        self.change_frequency(0.7)\n",
        "        self.wait()\n",
        "\n",
        "        #Show center of mass\n",
        "        dot = Dot(\n",
        "            self.get_pol_graph_center_of_mass(),\n",
        "            color = self.center_of_mass_color\n",
        "        )\n",
        "        dot.save_state()\n",
        "        self.center_of_mass_dot = dot\n",
        "        com_words = OldTexText(\"Center of mass\")\n",
        "        com_words.add_background_rectangle()\n",
        "        com_words.move_to(self.circle_plane, DOWN)\n",
        "        arrow = Arrow(\n",
        "            com_words.get_top(),\n",
        "            dot.get_center(),\n",
        "            buff = SMALL_BUFF,\n",
        "            color = self.center_of_mass_color\n",
        "        )\n",
        "        dot.move_to(arrow.get_start())\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            dot.restore,\n",
        "            Write(com_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [arrow, com_words])))\n",
        "        self.change_frequency(0.0)\n",
        "        self.wait()\n",
        "\n",
        "        #Show fourier graph\n",
        "        fourier_graph = self.get_fourier_transform_graph(graph)\n",
        "        fourier_graph_update = self.get_fourier_graph_drawing_update_anim(\n",
        "            fourier_graph\n",
        "        )\n",
        "        x_coord_label = OldTexText(\n",
        "            \"x-coordinate of center of mass\"\n",
        "        )\n",
        "        x_coord_label.scale(self.text_scale_val)\n",
        "        x_coord_label.next_to(\n",
        "            self.frequency_axes.input_to_graph_point(\n",
        "                self.signal_frequency, fourier_graph\n",
        "            ), UP\n",
        "        )\n",
        "        x_coord_label.set_color(self.center_of_mass_color)\n",
        "        self.generate_fourier_dot_transform(fourier_graph)\n",
        "\n",
        "        self.play(Write(x_coord_label))\n",
        "        self.change_frequency(\n",
        "            self.signal_frequency,\n",
        "            run_time = 10,\n",
        "            rate_func = smooth,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.change_frequency(\n",
        "            self.frequency_axes.x_max,\n",
        "            run_time = 15,\n",
        "            rate_func = smooth,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            fourier_graph,\n",
        "            fourier_graph_update,\n",
        "        )\n",
        "\n",
        "class MixingUnmixingTODOStub(TODOStub):\n",
        "    CONFIG = {\n",
        "        \"message\" : \"Insert mixing and unmixing of signals\"\n",
        "    }\n",
        "\n",
        "class ShowLinearity(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"high_freq_color\": YELLOW,\n",
        "        \"low_freq_color\": PINK,\n",
        "        \"sum_color\": GREEN,\n",
        "        \"low_freq\" : 3.0,\n",
        "        \"high_freq\" : 4.0,\n",
        "        \"circle_plane_config\" : {\n",
        "            \"x_radius\" : 2.5,\n",
        "            \"y_radius\" : 2.7,\n",
        "            \"x_unit_size\" : 0.8,\n",
        "            \"y_unit_size\" : 0.8,\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.show_sum_of_signals()\n",
        "        self.show_winding_with_sum_graph()\n",
        "        self.show_vector_rotation()\n",
        "\n",
        "    def show_sum_of_signals(self):\n",
        "        low_freq, high_freq = self.low_freq, self.high_freq\n",
        "        axes = self.get_time_axes()\n",
        "        axes_copy = axes.copy()\n",
        "        low_freq_graph, high_freq_graph = [\n",
        "            self.get_cosine_wave(\n",
        "                freq = freq, \n",
        "                scale_val = 0.5,\n",
        "                shift_val = 0.55,\n",
        "            )\n",
        "            for freq in (low_freq, high_freq)\n",
        "        ]\n",
        "        sum_graph = self.get_time_graph(\n",
        "            lambda t : sum([\n",
        "                low_freq_graph.underlying_function(t),\n",
        "                high_freq_graph.underlying_function(t),\n",
        "            ])\n",
        "        )\n",
        "        VGroup(axes_copy, high_freq_graph).next_to(\n",
        "            axes, DOWN, MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        low_freq_label = OldTexText(\"%d Hz\"%int(low_freq))\n",
        "        high_freq_label = OldTexText(\"%d Hz\"%int(high_freq))\n",
        "        sum_label = OldTexText(\n",
        "            \"%d Hz\"%int(low_freq), \"+\",\n",
        "            \"%d Hz\"%int(high_freq)\n",
        "        )\n",
        "        trips = [\n",
        "            (low_freq_label, low_freq_graph, self.low_freq_color), \n",
        "            (high_freq_label, high_freq_graph, self.high_freq_color),\n",
        "            (sum_label, sum_graph, self.sum_color),\n",
        "        ]\n",
        "        for label, graph, color in trips:\n",
        "            label.next_to(graph, UP)\n",
        "            graph.set_color(color)\n",
        "            label.set_color(color)\n",
        "        sum_label[0].match_color(low_freq_graph)\n",
        "        sum_label[2].match_color(high_freq_graph)\n",
        "\n",
        "        self.add(axes, low_freq_graph)\n",
        "        self.play(\n",
        "            FadeIn(axes_copy),\n",
        "            ShowCreation(high_freq_graph),\n",
        "        )\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(high_freq_label, low_freq_label)\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(axes_copy, axes),\n",
        "            ReplacementTransform(high_freq_graph, sum_graph),\n",
        "            ReplacementTransform(low_freq_graph, sum_graph),\n",
        "            ReplacementTransform(\n",
        "                VGroup(low_freq_label, high_freq_label),\n",
        "                sum_label\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_winding_with_sum_graph(self):\n",
        "        graph = self.graph\n",
        "        circle_plane = self.get_circle_plane()\n",
        "        frequency_axes = self.get_frequency_axes()\n",
        "        pol_graph = self.get_polarized_mobject(graph, freq = 0.0)\n",
        "\n",
        "        wps_label = self.get_winding_frequency_label()\n",
        "        ChangeDecimalToValue(wps_label[0], 0.0).update(1)\n",
        "        wps_label.add_to_back(BackgroundRectangle(wps_label))\n",
        "        wps_label.move_to(circle_plane, UP)\n",
        "\n",
        "        v_lines = self.get_v_lines_indicating_periods(0.001)\n",
        "        self.v_lines_indicating_periods = v_lines\n",
        "\n",
        "        dot = Dot(\n",
        "            self.get_pol_graph_center_of_mass(),\n",
        "            color = self.center_of_mass_color\n",
        "        )\n",
        "        self.center_of_mass_dot = dot\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "\n",
        "        fourier_graph = self.get_fourier_transform_graph(graph)\n",
        "        fourier_graph_update = self.get_fourier_graph_drawing_update_anim(\n",
        "            fourier_graph\n",
        "        )\n",
        "        x_coord_label = OldTexText(\n",
        "            \"x-coordinate of center of mass\"\n",
        "        )\n",
        "        x_coord_label.scale(self.text_scale_val)\n",
        "        x_coord_label.next_to(\n",
        "            self.frequency_axes.input_to_graph_point(\n",
        "                self.signal_frequency, fourier_graph\n",
        "            ), UP\n",
        "        )\n",
        "        x_coord_label.set_color(self.center_of_mass_color)\n",
        "        almost_fourier_label = OldTexText(\n",
        "            \"``Almost-Fourier transform''\"\n",
        "        )\n",
        "\n",
        "        self.generate_fourier_dot_transform(fourier_graph)                \n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(\n",
        "                circle_plane, wps_label,\n",
        "                frequency_axes, x_coord_label,\n",
        "            ),\n",
        "            run_time = 1,\n",
        "        ))\n",
        "        self.play(\n",
        "            ReplacementTransform(graph.copy(), pol_graph),\n",
        "            GrowFromCenter(dot)\n",
        "        )\n",
        "        freqs = [\n",
        "            self.low_freq, self.high_freq,\n",
        "            self.frequency_axes.x_max\n",
        "        ]\n",
        "        for freq in freqs:\n",
        "            self.change_frequency(\n",
        "                freq,\n",
        "                run_time = 8,\n",
        "                rate_func = bezier([0, 0, 1, 1]),\n",
        "            )\n",
        "\n",
        "    def show_vector_rotation(self):\n",
        "        self.fourier_graph_drawing_update_anim = Animation(Mobject())\n",
        "        self.change_frequency(self.low_freq)\n",
        "        self.play(*self.get_vector_animations(\n",
        "            self.graph, draw_polarized_graph = False,\n",
        "            run_time = 20,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class ShowCommutativeDiagram(ShowLinearity):\n",
        "    CONFIG = {\n",
        "        \"time_axes_config\" : {\n",
        "            \"x_max\" : 1.9,\n",
        "            \"y_max\" : 2.0,\n",
        "            \"y_min\" : -2.0,\n",
        "            \"y_axis_config\" : {\n",
        "                \"unit_size\" : 0.5,\n",
        "            },\n",
        "            \"x_axis_config\" : {\n",
        "                \"numbers_to_show\" : [1],\n",
        "            }\n",
        "        },\n",
        "        \"time_label_t\" : 1.5,\n",
        "        \"frequency_axes_config\" : {\n",
        "            \"x_min\" : 0.0,\n",
        "            \"x_max\" : 4.0,\n",
        "            \"y_min\" : -0.1,\n",
        "            \"y_max\" : 0.5,\n",
        "            \"y_axis_config\" : {\n",
        "                \"unit_size\" : 1.5,\n",
        "                \"tick_frequency\" : 0.5,\n",
        "            },\n",
        "        }\n",
        "    } \n",
        "    def construct(self):\n",
        "        self.show_diagram()\n",
        "        self.point_out_spikes()\n",
        "\n",
        "    def show_diagram(self):\n",
        "        self.remove(self.pi_creature)\n",
        "\n",
        "        #Setup axes\n",
        "        time_axes = self.get_time_axes()\n",
        "        time_axes.scale(0.8)\n",
        "        ta_group = VGroup(\n",
        "            time_axes, time_axes.deepcopy(), time_axes.deepcopy(),\n",
        "        )\n",
        "        ta_group.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        ta_group.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        frequency_axes = Axes(**self.frequency_axes_config)\n",
        "        frequency_axes.set_color(TEAL)\n",
        "        freq_label = OldTexText(\"Frequency\")\n",
        "        freq_label.scale(self.text_scale_val)\n",
        "        freq_label.next_to(frequency_axes.x_axis, DOWN, SMALL_BUFF, RIGHT)\n",
        "        frequency_axes.label = freq_label\n",
        "        frequency_axes.add(freq_label)\n",
        "        frequency_axes.scale(0.8)\n",
        "        fa_group = VGroup(\n",
        "            frequency_axes, frequency_axes.deepcopy(), frequency_axes.deepcopy()\n",
        "        )\n",
        "        VGroup(ta_group[1], fa_group[1]).shift(MED_LARGE_BUFF*UP)\n",
        "        for ta, fa in zip(ta_group, fa_group):\n",
        "            fa.next_to(\n",
        "                ta.x_axis, RIGHT,\n",
        "                submobject_to_align = fa.x_axis\n",
        "            )\n",
        "            fa.to_edge(RIGHT)\n",
        "            ta.remove(ta.labels)\n",
        "            fa.remove(fa.label)\n",
        "\n",
        "        ## Add graphs\n",
        "        funcs = [\n",
        "            lambda t : np.cos(2*TAU*t),\n",
        "            lambda t : np.cos(3*TAU*t),\n",
        "        ]\n",
        "        funcs.append(lambda t : funcs[0](t)+funcs[1](t))\n",
        "        colors = [\n",
        "            self.low_freq_color, \n",
        "            self.high_freq_color,\n",
        "            self.sum_color,\n",
        "        ]\n",
        "        labels = [\n",
        "            OldTexText(\"2 Hz\"),\n",
        "            OldTexText(\"3 Hz\"),\n",
        "            # OldTexText(\"2 Hz\", \"+\", \"3 Hz\"),\n",
        "            VectorizedPoint()\n",
        "        ]\n",
        "        for func, color, label, ta, fa in zip(funcs, colors, labels, ta_group, fa_group):\n",
        "            time_graph = ta.get_graph(func)\n",
        "            time_graph.set_color(color)\n",
        "            label.set_color(color)\n",
        "            label.scale(0.75)\n",
        "            label.next_to(time_graph, UP, SMALL_BUFF)\n",
        "            fourier = get_fourier_transform(\n",
        "                func, ta.x_min, 4*ta.x_max\n",
        "            )\n",
        "            fourier_graph = fa.get_graph(fourier)\n",
        "            fourier_graph.set_color(self.center_of_mass_color)\n",
        "\n",
        "            arrow = Arrow(\n",
        "                ta.x_axis, fa.x_axis, \n",
        "                color = WHITE,\n",
        "                buff = MED_LARGE_BUFF,\n",
        "            )\n",
        "            words = OldTexText(\"Almost-Fourier \\\\\\\\ transform\")\n",
        "            words.scale(0.6)\n",
        "            words.next_to(arrow, UP)\n",
        "            arrow.words = words\n",
        "\n",
        "            ta.graph = time_graph\n",
        "            ta.graph_label = label\n",
        "            ta.arrow = arrow\n",
        "            ta.add(time_graph, label)\n",
        "            fa.graph = fourier_graph\n",
        "            fa.add(fourier_graph)\n",
        "        # labels[-1][0].match_color(labels[0])\n",
        "        # labels[-1][2].match_color(labels[1])\n",
        "\n",
        "\n",
        "        #Add arrows\n",
        "        sum_arrows = VGroup()\n",
        "        for group in ta_group, fa_group:\n",
        "            arrow = Arrow(\n",
        "                group[1].graph, group[2].graph,\n",
        "                color = WHITE,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            arrow.scale(0.8, about_edge = UP)\n",
        "            arrow.words = OldTexText(\"Sum\").scale(0.75)\n",
        "            arrow.words.next_to(arrow, RIGHT, buff = MED_SMALL_BUFF)\n",
        "            sum_arrows.add(arrow)\n",
        "\n",
        "        def apply_transform(index):\n",
        "            ta = ta_group[index].deepcopy()\n",
        "            fa = fa_group[index]\n",
        "            anims = [\n",
        "                ReplacementTransform(\n",
        "                    getattr(ta, attr), getattr(fa, attr)\n",
        "                )\n",
        "                for attr in (\"x_axis\", \"y_axis\", \"graph\")\n",
        "            ]\n",
        "            anims += [\n",
        "                GrowArrow(ta.arrow),\n",
        "                Write(ta.arrow.words),\n",
        "            ]\n",
        "            if index == 0:\n",
        "                anims.append(ReplacementTransform(\n",
        "                    ta.labels[0],\n",
        "                    fa.label\n",
        "                ))\n",
        "            self.play(*anims, run_time = 1.5)\n",
        "\n",
        "\n",
        "        #Animations\n",
        "        self.add(*ta_group[:2])\n",
        "        self.add(ta_group[0].labels)\n",
        "        self.wait()\n",
        "        apply_transform(0)\n",
        "        apply_transform(1)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(sum_arrows[1]),\n",
        "            Write(sum_arrows[1].words),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    fa.copy(), fa_group[2]\n",
        "                )\n",
        "                for fa in fa_group[:2]\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            GrowArrow(sum_arrows[0]),\n",
        "            Write(sum_arrows[0].words),\n",
        "            *[\n",
        "                ReplacementTransform(\n",
        "                    mob.copy(), ta_group[2], \n",
        "                    run_time = 1\n",
        "                )\n",
        "                for mob in ta_group[:2]\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        apply_transform(2)\n",
        "        self.wait()\n",
        "\n",
        "        self.time_axes_group = ta_group\n",
        "        self.frequency_axes_group = fa_group\n",
        "\n",
        "    def point_out_spikes(self):\n",
        "        fa_group = self.frequency_axes_group\n",
        "        freqs = self.low_freq, self.high_freq\n",
        "        flat_rects = VGroup()\n",
        "        for freq, axes in zip(freqs, fa_group[:2]):\n",
        "            flat_rect = SurroundingRectangle(axes.x_axis)\n",
        "            flat_rect.stretch(0.5, 1)\n",
        "            spike_rect = self.get_spike_rect(axes, freq)\n",
        "            flat_rect.match_style(spike_rect)\n",
        "            flat_rect.target = spike_rect\n",
        "            flat_rects.add(flat_rect)\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, flat_rects))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(MoveToTarget, flat_rects))\n",
        "        self.wait()\n",
        "\n",
        "        sum_spike_rects = VGroup(*[\n",
        "            self.get_spike_rect(fa_group[2], freq)\n",
        "            for freq in freqs\n",
        "        ])\n",
        "        self.play(ReplacementTransform(\n",
        "            flat_rects, sum_spike_rects\n",
        "        ))\n",
        "        self.play(LaggedStartMap(\n",
        "            WiggleOutThenIn, sum_spike_rects,\n",
        "            run_time = 1,\n",
        "            lag_ratio = 0.7,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_spike_rect(self, axes, freq):\n",
        "        peak_point = axes.input_to_graph_point(\n",
        "            freq, axes.graph\n",
        "        )\n",
        "        f_axis_point = axes.coords_to_point(freq, 0)\n",
        "        line = Line(f_axis_point, peak_point)\n",
        "        spike_rect = SurroundingRectangle(line)\n",
        "        spike_rect.set_stroke(width = 0)\n",
        "        spike_rect.set_fill(YELLOW, 0.5)\n",
        "        return spike_rect\n",
        "\n",
        "class PauseAndPonder(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Pause and \\\\\\\\ ponder!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"thinking\"]*3)\n",
        "        self.wait(4)\n",
        "\n",
        "class BeforeGettingToTheFullMath(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(\n",
        "            \"\\\\hat{g}(f) = \\\\int_{-\\\\infty}^{\\\\infty}\" + \\\n",
        "            \"g(t)e^{-2\\\\pi i f t}dt\"\n",
        "        )\n",
        "        formula.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(formula),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.change_students(*[\"confused\"]*3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                formula.next_to, FRAME_X_RADIUS*RIGHT, RIGHT,\n",
        "                path_arc = TAU/16,\n",
        "                rate_func = running_start,\n",
        "            ),\n",
        "            self.change_students(*[\"pondering\"]*3)\n",
        "        )\n",
        "        self.teacher_says(\"Consider sound editing\\\\dots\")\n",
        "        self.wait(3)\n",
        "\n",
        "class FilterOutHighPitch(AddingPureFrequencies, ShowCommutativeDiagram):\n",
        "    def construct(self):\n",
        "        self.add_speaker()\n",
        "        self.play_sound()\n",
        "        self.show_intensity_vs_time_graph()\n",
        "        self.take_fourier_transform()\n",
        "        self.filter_out_high_pitch()\n",
        "        self.mention_inverse_transform()\n",
        "\n",
        "    def play_sound(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        self.play(\n",
        "            Succession(\n",
        "                ApplyMethod, randy.look_at, self.speaker,\n",
        "                Animation, randy,\n",
        "                ApplyMethod, randy.change, \"telepath\", randy,\n",
        "                Animation, randy, \n",
        "                Blink, randy,\n",
        "                Animation, randy, {\"run_time\" : 2},\n",
        "            ),\n",
        "            *self.get_broadcast_anims(),\n",
        "            run_time = 7\n",
        "        )\n",
        "        self.play(randy.change, \"angry\", self.speaker)\n",
        "        self.wait()\n",
        "\n",
        "    def show_intensity_vs_time_graph(self):\n",
        "        randy = self.pi_creature\n",
        "\n",
        "        axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 12,\n",
        "            y_min = -6,\n",
        "            y_max = 6,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 0.15,\n",
        "                \"tick_frequency\" : 3,\n",
        "            }\n",
        "        )\n",
        "        axes.set_stroke(width = 2)\n",
        "        axes.to_corner(UP+LEFT)\n",
        "        time_label = OldTexText(\"Time\")\n",
        "        intensity_label = OldTexText(\"Intensity\")\n",
        "        labels = VGroup(time_label, intensity_label)\n",
        "        labels.scale(0.75)\n",
        "        time_label.next_to(\n",
        "            axes.x_axis, DOWN, \n",
        "            aligned_edge = RIGHT,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        intensity_label.next_to(\n",
        "            axes.y_axis, RIGHT, \n",
        "            aligned_edge = UP,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        axes.labels = labels\n",
        "\n",
        "        func = lambda t : sum([\n",
        "            np.cos(TAU*f*t)\n",
        "            for f in (0.5, 0.7, 1.0, 1.2, 3.0,)\n",
        "        ])\n",
        "        graph = axes.get_graph(func)\n",
        "        graph.set_color(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(axes), \n",
        "            FadeIn(axes.labels), \n",
        "            randy.change, \"pondering\", axes,\n",
        "            ShowCreation(\n",
        "                graph, run_time = 4, \n",
        "                rate_func = bezier([0, 0, 1, 1])\n",
        "            ),\n",
        "            *self.get_broadcast_anims(run_time = 6)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.time_axes = axes\n",
        "        self.time_graph = graph\n",
        "\n",
        "    def take_fourier_transform(self):\n",
        "        time_axes = self.time_axes\n",
        "        time_graph = self.time_graph\n",
        "        randy = self.pi_creature\n",
        "        speaker = self.speaker\n",
        "\n",
        "        frequency_axes = Axes(\n",
        "            x_min = 0,\n",
        "            x_max = 3.5,\n",
        "            x_axis_config = {\"unit_size\" : 3.5},\n",
        "            y_min = 0,\n",
        "            y_max = 1,\n",
        "            y_axis_config = {\"unit_size\" : 2},\n",
        "        )\n",
        "        frequency_axes.set_color(TEAL)\n",
        "        frequency_axes.next_to(time_axes, DOWN, LARGE_BUFF, LEFT)\n",
        "        freq_label = OldTexText(\"Frequency\")\n",
        "        freq_label.scale(0.75)\n",
        "        freq_label.next_to(frequency_axes.x_axis, DOWN, MED_SMALL_BUFF, RIGHT)\n",
        "        frequency_axes.label = freq_label\n",
        "\n",
        "        fourier_func = get_fourier_transform(\n",
        "            time_graph.underlying_function, \n",
        "            t_min = 0, t_max = 30,\n",
        "        )\n",
        "        # def alt_fourier_func(t):\n",
        "        #     bell = smooth(t)*0.3*np.exp(-0.8*(t-0.9)**2)\n",
        "        #     return bell + (smooth(t/3)+0.2)*fourier_func(t)\n",
        "        fourier_graph = frequency_axes.get_graph(\n",
        "            fourier_func, num_graph_points = 150,\n",
        "        )\n",
        "        fourier_graph.set_color(RED)\n",
        "        frequency_axes.graph = fourier_graph\n",
        "\n",
        "        arrow = Arrow(time_graph, fourier_graph, color = WHITE)\n",
        "        ft_words = OldTexText(\"Fourier \\\\\\\\ transform\")\n",
        "        ft_words.next_to(arrow, RIGHT)\n",
        "\n",
        "        spike_rect = self.get_spike_rect(frequency_axes, 3)\n",
        "        spike_rect.stretch(2, 0)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(time_axes.copy(), frequency_axes),\n",
        "            ReplacementTransform(time_graph.copy(), fourier_graph),\n",
        "            ReplacementTransform(time_axes.labels[0].copy(), freq_label),\n",
        "            GrowArrow(arrow),\n",
        "            Write(ft_words),\n",
        "            VGroup(randy, speaker).shift, FRAME_Y_RADIUS*DOWN,\n",
        "        )\n",
        "        self.remove(randy, speaker)\n",
        "        self.wait()\n",
        "        self.play(DrawBorderThenFill(spike_rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.frequency_axes = frequency_axes\n",
        "        self.fourier_graph = fourier_graph\n",
        "        self.spike_rect = spike_rect\n",
        "        self.to_fourier_arrow = arrow\n",
        "\n",
        "    def filter_out_high_pitch(self): \n",
        "        fourier_graph = self.fourier_graph\n",
        "        spike_rect = self.spike_rect\n",
        "        frequency_axes = self.frequency_axes\n",
        "\n",
        "        def filtered_func(f):\n",
        "            result = fourier_graph.underlying_function(f)\n",
        "            result *= np.clip(smooth(3-f), 0, 1)\n",
        "            return result\n",
        "\n",
        "        new_graph = frequency_axes.get_graph(\n",
        "            filtered_func, num_graph_points = 300\n",
        "        )\n",
        "        new_graph.set_color(RED)\n",
        "\n",
        "        self.play(spike_rect.stretch, 4, 0)\n",
        "        self.play(\n",
        "            Transform(fourier_graph, new_graph),\n",
        "            spike_rect.stretch, 0.01, 1, {\n",
        "                \"about_point\" : frequency_axes.coords_to_point(0, 0)\n",
        "            },\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def mention_inverse_transform(self):\n",
        "        time_axes = self.time_axes\n",
        "        time_graph = self.time_graph\n",
        "        fourier_graph = self.fourier_graph\n",
        "        frequency_axes = self.frequency_axes\n",
        "        f_min = frequency_axes.x_min\n",
        "        f_max = frequency_axes.x_max\n",
        "\n",
        "        filtered_graph = time_axes.get_graph(\n",
        "            lambda t : time_graph.underlying_function(t)-np.cos(TAU*3*t)\n",
        "        )\n",
        "        filtered_graph.set_color(BLUE_C)\n",
        "\n",
        "        to_fourier_arrow = self.to_fourier_arrow\n",
        "        arrow = to_fourier_arrow.copy()\n",
        "        arrow.rotate(TAU/2, about_edge = LEFT)\n",
        "        arrow.shift(MED_SMALL_BUFF*LEFT)\n",
        "        inv_fourier_words = OldTexText(\"Inverse Fourier \\\\\\\\ transform\")\n",
        "        inv_fourier_words.next_to(arrow, LEFT)\n",
        "        VGroup(arrow, inv_fourier_words).set_color(MAROON_B)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(inv_fourier_words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            time_graph.fade, 0.9,\n",
        "            ReplacementTransform(\n",
        "                fourier_graph.copy(), filtered_graph\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_broadcast_anims(self, run_time = 7, **kwargs):\n",
        "        return [\n",
        "            self.get_broadcast_animation(\n",
        "                n_circles = n,\n",
        "                run_time = run_time,\n",
        "                big_radius = 7,\n",
        "                start_stroke_width = 5,\n",
        "                **kwargs\n",
        "            )\n",
        "            for n in (5, 7, 10, 12)\n",
        "        ]\n",
        "\n",
        "class AskAboutInverseFourier(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Inverse Fourier?\")\n",
        "        self.play_student_changes(\"confused\", \"raise_right_hand\", \"confused\")\n",
        "        self.wait(2)\n",
        "\n",
        "class ApplyFourierToFourier(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"time_axes_config\" : {\n",
        "            \"y_min\" : -1.5,\n",
        "            \"y_max\" : 1.5,\n",
        "            \"x_max\" : 5,\n",
        "            \"x_axis_config\" : {\n",
        "                \"numbers_to_show\" : list(range(1, 5)),\n",
        "                \"unit_size\" : 2.5,\n",
        "            },\n",
        "        },\n",
        "        \"frequency_axes_config\" : {\n",
        "            \"y_min\" : -0.6,\n",
        "            \"y_max\" : 0.6,\n",
        "        },\n",
        "        \"circle_plane_config\" : {\n",
        "            \"x_radius\" : 1.5,\n",
        "            \"y_radius\" : 1.35,\n",
        "            \"x_unit_size\" : 1.5,\n",
        "            \"y_unit_size\" : 1.5,\n",
        "        },\n",
        "        \"default_num_v_lines_indicating_periods\" : 0,\n",
        "        \"signal_frequency\" : 2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_fourier_display()\n",
        "        self.swap_graphs()\n",
        "\n",
        "    def setup_fourier_display(self):\n",
        "        self.force_skipping()\n",
        "        self.setup_graph()\n",
        "        self.show_center_of_mass_dot()\n",
        "        self.introduce_frequency_plot()\n",
        "        self.draw_full_frequency_plot()\n",
        "        self.time_axes.remove(self.time_axes.labels)\n",
        "        self.remove(self.beats_per_second_label)\n",
        "        VGroup(\n",
        "            self.time_axes, self.graph,\n",
        "            self.frequency_axes, self.fourier_graph,\n",
        "            self.x_coord_label,\n",
        "            self.fourier_graph_dot,\n",
        "        ).to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def swap_graphs(self):\n",
        "        fourier_graph = self.fourier_graph\n",
        "        time_graph = self.graph\n",
        "        wound_up_graph = time_graph.polarized_mobject\n",
        "        time_axes = self.time_axes\n",
        "        frequency_axes = self.frequency_axes\n",
        "\n",
        "        f_max = self.frequency_axes.x_max\n",
        "        new_fourier_graph = time_axes.get_graph(\n",
        "            lambda t : 2*fourier_graph.underlying_function(t)\n",
        "        )\n",
        "        new_fourier_graph.match_style(fourier_graph)\n",
        "\n",
        "        self.remove(fourier_graph)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                fourier_graph.copy(), \n",
        "                new_fourier_graph\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                time_graph.shift, 3*UP+10*LEFT,\n",
        "                remover = True,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            wound_up_graph.next_to, FRAME_X_RADIUS*LEFT, LEFT,\n",
        "            remover = True\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.graph = new_fourier_graph\n",
        "        wound_up_graph = self.get_polarized_mobject(new_fourier_graph, freq = 0)\n",
        "        double_fourier_graph = frequency_axes.get_graph(\n",
        "            lambda t : 0.25*np.cos(TAU*2*t)\n",
        "        ).set_color(PINK)\n",
        "        self.fourier_graph = double_fourier_graph\n",
        "        self.remove(self.fourier_graph_dot)\n",
        "        self.get_fourier_graph_drawing_update_anim(double_fourier_graph)\n",
        "        self.generate_fourier_dot_transform(double_fourier_graph)\n",
        "        self.center_of_mass_dot.set_color(PINK)\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "        def new_get_pol_graph_center_of_mass():\n",
        "            result = DrawFrequencyPlot.get_pol_graph_center_of_mass(self)\n",
        "            result -= self.circle_plane.coords_to_point(0, 0)\n",
        "            result *= 25\n",
        "            result += self.circle_plane.coords_to_point(0, 0)\n",
        "            return result\n",
        "        self.get_pol_graph_center_of_mass = new_get_pol_graph_center_of_mass\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(self.graph.copy(), wound_up_graph),\n",
        "            ChangeDecimalToValue(\n",
        "                self.winding_freq_label[1], 0.0,\n",
        "                run_time = 0.2,\n",
        "            )\n",
        "        )\n",
        "        self.change_frequency(5.0, run_time = 15, rate_func=linear)\n",
        "        self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_cosine_wave(self, freq, **kwargs):\n",
        "        kwargs[\"shift_val\"] = 0\n",
        "        kwargs[\"scale_val\"] = 1.0\n",
        "        return DrawFrequencyPlot.get_cosine_wave(self, freq, **kwargs)\n",
        "\n",
        "class WriteComplexExponentialExpression(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"signal_frequency\" : 2.0,\n",
        "        \"default_num_v_lines_indicating_periods\" : 0,\n",
        "        \"time_axes_scale_val\" : 0.7,\n",
        "        \"initial_winding_frequency\" : 0.1,\n",
        "        \"circle_plane_config\" : {\n",
        "            \"unit_size\" : 2,\n",
        "            \"y_radius\" : FRAME_Y_RADIUS+LARGE_BUFF,\n",
        "            \"x_radius\" : FRAME_X_RADIUS+LARGE_BUFF\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.setup_plane()\n",
        "        self.setup_graph()\n",
        "        self.show_winding_with_both_coordinates()\n",
        "        self.show_plane_as_complex_plane()\n",
        "        self.show_eulers_formula()\n",
        "        self.show_winding_graph_expression()\n",
        "        self.find_center_of_mass()\n",
        "\n",
        "    def setup_plane(self):\n",
        "        circle_plane = ComplexPlane(**self.circle_plane_config)\n",
        "        circle_plane.shift(DOWN+LEFT)\n",
        "        circle = DashedLine(ORIGIN, TAU*UP)\n",
        "        circle.apply_complex_function(\n",
        "            lambda z : R3_to_complex(\n",
        "                circle_plane.number_to_point(np.exp(z))\n",
        "            )\n",
        "        )\n",
        "        circle_plane.add(circle)\n",
        "\n",
        "        time_axes = self.get_time_axes()\n",
        "        time_axes.background_rectangle = BackgroundRectangle(\n",
        "            time_axes, \n",
        "            fill_opacity = 0.9,\n",
        "            buff = MED_SMALL_BUFF,\n",
        "        ) \n",
        "        time_axes.add_to_back(time_axes.background_rectangle)\n",
        "        time_axes.scale(self.time_axes_scale_val)\n",
        "        time_axes.to_corner(UP+LEFT, buff = 0)\n",
        "        time_axes.set_stroke(color = WHITE, width = 1)\n",
        "\n",
        "        self.add(circle_plane)\n",
        "        self.add(time_axes)\n",
        "\n",
        "        self.circle_plane = circle_plane\n",
        "        self.time_axes = time_axes\n",
        "\n",
        "    def setup_graph(self):\n",
        "        plane = self.circle_plane\n",
        "        graph = self.graph = self.get_cosine_wave(\n",
        "            freq = self.signal_frequency,\n",
        "            scale_val = 0.5,\n",
        "            shift_val = 0.75,\n",
        "        )\n",
        "        freq = self.initial_winding_frequency\n",
        "        pol_graph = self.get_polarized_mobject(graph, freq = freq)\n",
        "        wps_label = self.get_winding_frequency_label()\n",
        "        ChangeDecimalToValue(wps_label[0], freq).update(1)\n",
        "        wps_label.add_to_back(BackgroundRectangle(wps_label))\n",
        "        wps_label.next_to(plane.coords_to_point(0, 1), DOWN)\n",
        "        wps_label.to_edge(LEFT)\n",
        "        self.get_center_of_mass_dot()\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "\n",
        "        self.add(graph, pol_graph, wps_label)\n",
        "        self.set_variables_as_attrs(pol_graph, wps_label)\n",
        "        self.time_axes_group = VGroup(self.time_axes, graph)\n",
        "\n",
        "    def show_winding_with_both_coordinates(self):\n",
        "        com_dot = self.center_of_mass_dot\n",
        "        plane = self.circle_plane\n",
        "        v_line = Line(ORIGIN, UP)\n",
        "        h_line = Line(ORIGIN, RIGHT)\n",
        "        lines = VGroup(v_line, h_line)\n",
        "        lines.set_color(PINK)\n",
        "        def lines_update(lines):\n",
        "            point = com_dot.get_center()\n",
        "            x, y = plane.point_to_coords(point)\n",
        "            h_line.put_start_and_end_on(\n",
        "                plane.coords_to_point(0, y), point\n",
        "            )\n",
        "            v_line.put_start_and_end_on(\n",
        "                plane.coords_to_point(x, 0), point\n",
        "            )\n",
        "        lines_update_anim = Mobject.add_updater(lines, lines_update)\n",
        "        lines_update_anim.update(0)\n",
        "        self.add(lines_update_anim)\n",
        "\n",
        "        self.change_frequency(\n",
        "            2.04, \n",
        "            added_anims = [\n",
        "                self.center_of_mass_dot_anim,\n",
        "            ],\n",
        "            run_time = 15,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.dot_component_anim = lines_update_anim\n",
        "\n",
        "    def show_plane_as_complex_plane(self):\n",
        "        to_fade = VGroup(\n",
        "            self.time_axes_group, self.pol_graph, self.wps_label\n",
        "        )\n",
        "        plane = self.circle_plane\n",
        "        dot = self.center_of_mass_dot\n",
        "        complex_plane_title = OldTexText(\"Complex plane\")\n",
        "        complex_plane_title.add_background_rectangle()\n",
        "        complex_plane_title.to_edge(UP)\n",
        "        coordinate_labels = plane.get_coordinate_labels()\n",
        "        number_label = DecimalNumber(\n",
        "            0, include_background_rectangle = True,\n",
        "        )\n",
        "        number_label_update_anim = ContinualChangingDecimal(\n",
        "            number_label, \n",
        "            lambda a : plane.point_to_number(dot.get_center()),\n",
        "            position_update_func = lambda l : l.next_to(\n",
        "                dot, DOWN+RIGHT,\n",
        "                buff = SMALL_BUFF\n",
        "            ),\n",
        "        )\n",
        "        number_label_update_anim.update(0)\n",
        "        flower_path = ParametricCurve(\n",
        "            lambda t : plane.coords_to_point(\n",
        "                np.sin(2*t)*np.cos(t),\n",
        "                np.sin(2*t)*np.sin(t),\n",
        "            ),\n",
        "            t_min = 0, t_max = TAU,\n",
        "        )\n",
        "        flower_path.move_to(self.center_of_mass_dot)\n",
        "\n",
        "        self.play(FadeOut(to_fade))\n",
        "        self.play(Write(complex_plane_title))\n",
        "        self.play(Write(coordinate_labels))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(number_label))\n",
        "        self.add(number_label_update_anim)\n",
        "        self.play(MoveAlongPath(\n",
        "            dot, flower_path, \n",
        "            run_time = 10,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            self.pol_graph, run_time = 3,\n",
        "        ))\n",
        "        self.play(FadeOut(self.pol_graph))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(VGroup(\n",
        "            dot, self.dot_component_anim.mobject, number_label\n",
        "        )))\n",
        "        self.remove(self.dot_component_anim)\n",
        "        self.remove(number_label_update_anim)\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            number_label,\n",
        "            number_label_update_anim,\n",
        "            complex_plane_title,\n",
        "        )\n",
        "\n",
        "    def show_eulers_formula(self):\n",
        "        plane = self.circle_plane\n",
        "\n",
        "        ghost_dot = Dot(ORIGIN, fill_opacity = 0)\n",
        "        def get_t():\n",
        "            return ghost_dot.get_center()[0]\n",
        "        def get_circle_point(scalar = 1, t_shift = 0):\n",
        "            return plane.number_to_point(\n",
        "                scalar*np.exp(complex(0, get_t()+t_shift))\n",
        "            )\n",
        "        vector = Vector(plane.number_to_point(1), color = GREEN)\n",
        "        exp_base = OldTex(\"e\").scale(1.3)\n",
        "        exp_base.add_background_rectangle()\n",
        "        exp_decimal = DecimalNumber(0, unit = \"i\", include_background_rectangle = True)\n",
        "        exp_decimal.scale(0.75)\n",
        "        VGroup(exp_base, exp_decimal).match_color(vector)\n",
        "        exp_decimal_update = ContinualChangingDecimal(\n",
        "            exp_decimal, lambda a : get_t(),\n",
        "            position_update_func = lambda d : d.move_to(\n",
        "                exp_base.get_corner(UP+RIGHT), DOWN+LEFT\n",
        "            )\n",
        "        )\n",
        "        exp_base_update = Mobject.add_updater(\n",
        "            exp_base, lambda e : e.move_to(get_circle_point(\n",
        "                scalar = 1.1, t_shift = 0.01*TAU\n",
        "            ))\n",
        "        )\n",
        "        vector_update = Mobject.add_updater(\n",
        "            vector, lambda v : v.put_start_and_end_on(\n",
        "                plane.number_to_point(0), get_circle_point()\n",
        "            )\n",
        "        )\n",
        "        updates = [exp_base_update, exp_decimal_update, vector_update]\n",
        "        for update in updates:\n",
        "            update.update(0)\n",
        "\n",
        "        #Show initial vector\n",
        "        self.play(\n",
        "            GrowArrow(vector),\n",
        "            FadeIn(exp_base),\n",
        "            Write(exp_decimal)\n",
        "        )\n",
        "        self.add(*updates)\n",
        "        self.play(ghost_dot.shift, 2*RIGHT, run_time = 3)\n",
        "        self.wait()\n",
        "\n",
        "        #Show arc\n",
        "        arc, circle = [\n",
        "            Line(ORIGIN, t*UP)\n",
        "            for t in (get_t(), TAU)\n",
        "        ]\n",
        "        for mob in arc, circle:\n",
        "            mob.insert_n_curves(20)\n",
        "            mob.set_stroke(RED, 4)\n",
        "            mob.apply_function(\n",
        "                lambda p : plane.number_to_point(\n",
        "                    np.exp(R3_to_complex(p))\n",
        "                )\n",
        "            )\n",
        "        distance_label = DecimalNumber(\n",
        "            exp_decimal.number,\n",
        "            unit = \"\\\\text{units}\"\n",
        "        )\n",
        "        distance_label[-1].shift(SMALL_BUFF*RIGHT)\n",
        "        distance_label.match_color(arc)\n",
        "        distance_label.add_background_rectangle()\n",
        "        distance_label.move_to(\n",
        "            plane.number_to_point(\n",
        "                1.1*np.exp(complex(0, 0.4*get_t())),\n",
        "            ),\n",
        "            DOWN+LEFT\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(arc))\n",
        "        self.play(ReplacementTransform(\n",
        "            exp_decimal.copy(), distance_label\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(distance_label))\n",
        "\n",
        "        #Show full cycle\n",
        "        self.remove(arc)\n",
        "        self.play(\n",
        "            ghost_dot.move_to, TAU*RIGHT,\n",
        "            ShowCreation(\n",
        "                circle, \n",
        "                rate_func = lambda a : interpolate(\n",
        "                    2.0/TAU, 1, smooth(a)\n",
        "                ),\n",
        "            ),\n",
        "            run_time = 6,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        #Write exponential expression\n",
        "        exp_expression = OldTex(\"e\", \"^{-\", \"2\\\\pi i\", \"f\", \"t}\")\n",
        "        e, minus, two_pi_i, f, t = exp_expression\n",
        "        exp_expression.next_to(\n",
        "            plane.coords_to_point(1, 1), \n",
        "            UP+RIGHT\n",
        "        )\n",
        "        f.set_color(RED)\n",
        "        t.set_color(YELLOW)\n",
        "        exp_expression.add_background_rectangle()\n",
        "        two_pi_i_f_t_group = VGroup(two_pi_i, f, t)\n",
        "        two_pi_i_f_t_group.save_state()\n",
        "        two_pi_i_f_t_group.move_to(minus, LEFT)\n",
        "        exp_expression[1].remove(minus)\n",
        "        t.save_state()\n",
        "        t.align_to(f, LEFT)\n",
        "        exp_expression[1].remove(f)\n",
        "\n",
        "        labels = VGroup()\n",
        "        for sym, word in (t, \"Time\"), (f, \"Frequency\"):\n",
        "            label = OldTexText(word)\n",
        "            label.match_style(sym)\n",
        "            label.next_to(sym, UP, buff = MED_LARGE_BUFF)\n",
        "            label.add_background_rectangle()\n",
        "            label.arrow = Arrow(label, sym, buff = SMALL_BUFF)\n",
        "            label.arrow.match_style(sym)\n",
        "            labels.add(label)\n",
        "        time_label, frequency_label = labels\n",
        "        example_frequency = OldTex(\"f = 1/10\")\n",
        "        example_frequency.add_background_rectangle()\n",
        "        example_frequency.match_style(frequency_label)\n",
        "        example_frequency.move_to(frequency_label, DOWN)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            VGroup(exp_base[1], exp_decimal[1]).copy(),\n",
        "            exp_expression\n",
        "        ))\n",
        "        self.play(FadeOut(circle))\n",
        "        self.wait()\n",
        "\n",
        "        ghost_dot.move_to(ORIGIN)\n",
        "        always_shift(ghost_dot, rate = TAU)\n",
        "        self.add(ghost_dot)\n",
        "        \n",
        "        self.play(\n",
        "            Write(time_label),\n",
        "            GrowArrow(time_label.arrow),\n",
        "        )\n",
        "        self.wait(12.5) #Leave time to say let's slow down\n",
        "        self.remove(ghost_dot)\n",
        "        self.play(\n",
        "            FadeOut(time_label),\n",
        "            FadeIn(frequency_label),\n",
        "            t.restore,\n",
        "            GrowFromPoint(f, frequency_label.get_center()),\n",
        "            ReplacementTransform(\n",
        "                time_label.arrow,\n",
        "                frequency_label.arrow,\n",
        "            )\n",
        "        )\n",
        "        ghost_dot.move_to(ORIGIN)\n",
        "        ghost_dot.clear_updaters()\n",
        "        always_shift(ghost_dot, rate=0.1*TAU)\n",
        "        self.add(ghost_dot)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(frequency_label),\n",
        "            FadeIn(example_frequency)\n",
        "        )\n",
        "        self.wait(15) #Give time to reference other video\n",
        "        #Reverse directions\n",
        "        ghost_dot.clear_updaters()\n",
        "        always_shift(ghost_dot, rate=-0.1 * TAU)\n",
        "        self.play(\n",
        "            FadeOut(example_frequency),\n",
        "            FadeOut(frequency_label.arrow),\n",
        "            GrowFromCenter(minus),\n",
        "            two_pi_i_f_t_group.restore\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        ghost_dot.clear_updaters()\n",
        "        self.remove(*updates)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            update.mobject\n",
        "            for update in updates\n",
        "            if update.mobject is not vector\n",
        "        ])))\n",
        "        self.play(ghost_dot.move_to, ORIGIN)\n",
        "\n",
        "        exp_expression[1].add(minus, f)\n",
        "        exp_expression[1].sort(lambda p : p[0])\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            ambient_ghost_dot_movement, ghost_dot,\n",
        "            vector, vector_update, exp_expression\n",
        "        )\n",
        "\n",
        "    def show_winding_graph_expression(self):\n",
        "        ambient_ghost_dot_movement = self.ambient_ghost_dot_movement\n",
        "        ghost_dot = self.ghost_dot\n",
        "        vector = self.vector\n",
        "        exp_expression = self.exp_expression\n",
        "        plane = self.circle_plane\n",
        "        time_axes_group = self.time_axes_group\n",
        "        graph = self.graph\n",
        "        pol_graph = self.get_polarized_mobject(graph, freq = 0.2)\n",
        "        g_label = OldTex(\"g(t)\")\n",
        "        g_label.match_color(graph)\n",
        "        g_label.next_to(graph, UP)\n",
        "        g_label.add_background_rectangle()\n",
        "        g_scalar = g_label.copy()\n",
        "        g_scalar.move_to(exp_expression, DOWN+LEFT)\n",
        "\n",
        "        vector_animations = self.get_vector_animations(graph)\n",
        "        vector_animations[1].mobject = vector\n",
        "        graph_y_vector = vector_animations[0].mobject\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(time_axes_group),\n",
        "            FadeOut(self.complex_plane_title)\n",
        "        )\n",
        "        self.play(Write(g_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(g_label.copy(), g_scalar),\n",
        "            exp_expression.next_to, g_scalar, RIGHT, SMALL_BUFF,\n",
        "            exp_expression.shift, 0.5*SMALL_BUFF*UP,\n",
        "        )\n",
        "        self.play(*vector_animations, run_time = 15)\n",
        "        self.add(*self.mobjects_from_last_animation)\n",
        "        self.wait()\n",
        "\n",
        "        integrand = VGroup(g_scalar, exp_expression)\n",
        "        rect = SurroundingRectangle(integrand)\n",
        "        morty = Mortimer()\n",
        "        morty.next_to(rect, DOWN+RIGHT)\n",
        "        morty.shift_onto_screen()\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(morty)\n",
        "        )\n",
        "        self.play(morty.change, \"raise_right_hand\")\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"hooray\", rect)\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            morty, rect, graph_y_vector, vector\n",
        "        ])))\n",
        "\n",
        "        self.integrand = integrand\n",
        "\n",
        "    def find_center_of_mass(self):\n",
        "        integrand = self.integrand\n",
        "        integrand.generate_target()\n",
        "        integrand.target.to_edge(RIGHT, buff = LARGE_BUFF)\n",
        "        integrand.target.shift(MED_LARGE_BUFF*DOWN)\n",
        "        sum_expr = OldTex(\n",
        "            \"{1\", \"\\\\over\", \"N}\",\n",
        "            \"\\\\sum\", \"_{k = 1}\", \"^N\",\n",
        "        )\n",
        "        sum_expr.add_background_rectangle()\n",
        "        sum_expr.shift(SMALL_BUFF*(UP+5*RIGHT))\n",
        "        sum_expr.next_to(integrand.target, LEFT)\n",
        "\n",
        "        integral = OldTex(\n",
        "            \"{1\", \"\\\\over\", \"t_2 - t_1}\",\n",
        "            \"\\\\int\", \"_{t_1}\", \"^{t_2}\"\n",
        "        )\n",
        "        integral.move_to(sum_expr, RIGHT)\n",
        "        time_interval_indicator = SurroundingRectangle(integral[2])\n",
        "        integral.add_background_rectangle()\n",
        "        axes = self.time_axes\n",
        "        time_interval = Line(\n",
        "            axes.coords_to_point(axes.x_min, 0),\n",
        "            axes.coords_to_point(axes.x_max, 0),\n",
        "        )\n",
        "        time_interval.match_style(time_interval_indicator)\n",
        "        time_interval_indicator.add(time_interval)\n",
        "        dt_mob = OldTex(\"dt\")\n",
        "        dt_mob.next_to(integrand.target, RIGHT, SMALL_BUFF, DOWN)\n",
        "        dt_mob.add_background_rectangle()\n",
        "\n",
        "        dots = self.show_center_of_mass_sampling(20)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(sum_expr),\n",
        "            MoveToTarget(integrand),\n",
        "        )\n",
        "\n",
        "        #Add k subscript to t's\n",
        "        t1 = integrand[0][1][2]\n",
        "        t2 = integrand[1][1][-1]\n",
        "        t_mobs = VGroup(t1, t2)\n",
        "        t_mobs.save_state()\n",
        "        t_mobs.generate_target()\n",
        "        for i, t_mob in enumerate(t_mobs.target):\n",
        "            k = OldTex(\"k\")\n",
        "            k.match_style(t_mob)\n",
        "            k.match_height(t_mob)\n",
        "            k.scale(0.5)\n",
        "            k.move_to(t_mob.get_corner(DOWN+RIGHT), LEFT)\n",
        "            k.add_background_rectangle()\n",
        "            t_mob.add(k)\n",
        "            if i == 0:\n",
        "                t_mob.shift(0.5*SMALL_BUFF*LEFT)\n",
        "\n",
        "        self.play(MoveToTarget(t_mobs))\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, dots[1],\n",
        "            rate_func = there_and_back,\n",
        "            color = TEAL,\n",
        "        ))\n",
        "        self.show_center_of_mass_sampling(100)\n",
        "        dots = self.show_center_of_mass_sampling(500)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(dots))\n",
        "        self.play(\n",
        "            ReplacementTransform(sum_expr, integral),\n",
        "            FadeIn(dt_mob),\n",
        "            t_mobs.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(time_interval_indicator))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(time_interval_indicator))\n",
        "        self.wait()\n",
        "\n",
        "        #Show confusion\n",
        "        randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.next_to(integrand, DOWN, LARGE_BUFF)\n",
        "        randy.to_edge(RIGHT)\n",
        "        full_expression_rect = SurroundingRectangle(\n",
        "            VGroup(integral, dt_mob), color = RED\n",
        "        )\n",
        "        com_dot = self.center_of_mass_dot\n",
        "        self.center_of_mass_dot_anim.update(0)\n",
        "        com_arrow = Arrow(\n",
        "            full_expression_rect.get_left(), com_dot,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        com_arrow.match_color(com_dot)\n",
        "\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", integral)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(full_expression_rect))\n",
        "        self.play(\n",
        "            randy.change, \"thinking\", self.pol_graph,\n",
        "            GrowArrow(com_arrow),\n",
        "            GrowFromCenter(com_dot),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "\n",
        "    def show_center_of_mass_sampling(self, n_dots):\n",
        "        time_graph = self.graph\n",
        "        pol_graph = self.graph.polarized_mobject\n",
        "        axes = self.time_axes\n",
        "\n",
        "        dot = Dot(radius = 0.05, color = PINK)\n",
        "        pre_dots = VGroup(*[\n",
        "            dot.copy().move_to(axes.coords_to_point(t, 0))\n",
        "            for t in np.linspace(axes.x_min, axes.x_max, n_dots)\n",
        "        ])\n",
        "        pre_dots.set_fill(opacity = 0)\n",
        "        for graph in time_graph, pol_graph:\n",
        "            if hasattr(graph, \"dots\"):\n",
        "                graph.dot_fade_anims = [FadeOut(graph.dots)]\n",
        "            else:\n",
        "                graph.dot_fade_anims = []\n",
        "            graph.save_state()\n",
        "            graph.generate_target()\n",
        "            if not hasattr(graph, \"is_faded\"):\n",
        "                graph.target.fade(0.7)\n",
        "            graph.is_faded = True\n",
        "            graph.dots = VGroup(*[\n",
        "                dot.copy().move_to(graph.point_from_proportion(a))\n",
        "                for a in np.linspace(0, 1, n_dots)\n",
        "            ])\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                pre_dots, time_graph.dots,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            MoveToTarget(time_graph),\n",
        "            *time_graph.dot_fade_anims\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                time_graph.copy(), pol_graph.target\n",
        "            ),\n",
        "            MoveToTarget(pol_graph),\n",
        "            ReplacementTransform(\n",
        "                time_graph.dots.copy(),\n",
        "                pol_graph.dots,\n",
        "            ),\n",
        "            *pol_graph.dot_fade_anims,\n",
        "            run_time = 2\n",
        "        )\n",
        "        return VGroup(time_graph.dots, pol_graph.dots)\n",
        "\n",
        "class EulersFormulaViaGroupTheoryWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Euler's formula with introductory group theory\")\n",
        "        title.to_edge(UP)\n",
        "        screen_rect = ScreenRectangle(height = 6)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait(2)\n",
        "\n",
        "class WhyAreYouTellingUsThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"Why are you \\\\\\\\ telling us this?\")\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class BuildUpExpressionStepByStep(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        expression = OldTex(\n",
        "            \"\\\\frac{1}{t_2 - t_1}\", \"\\\\int_{t_1}^{t_2}\",\n",
        "            \"g(t)\", \"e\", \"^{-2\\\\pi i\", \"f\", \"t}\", \"dt\"\n",
        "        )\n",
        "        frac, integral, g, e, two_pi_i, f, t, dt = expression\n",
        "        expression.next_to(self.teacher, UP+LEFT)\n",
        "        t.set_color(YELLOW)\n",
        "        g[2].set_color(YELLOW)\n",
        "        dt[1].set_color(YELLOW)\n",
        "        f.set_color(GREEN)\n",
        "        t.save_state()\n",
        "        t.move_to(f, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeIn(e),\n",
        "            FadeIn(two_pi_i),\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(*[\"pondering\"]*3),\n",
        "            FadeIn(t),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(f),\n",
        "            t.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(g), Blink(self.students[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(integral),\n",
        "            FadeIn(frac),\n",
        "            FadeIn(dt),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\n",
        "            \"Just one final \\\\\\\\ distinction.\",\n",
        "            bubble_config = {\"height\" : 2.5, \"width\" : 3.5},\n",
        "            added_anims = [expression.to_corner, UP+RIGHT]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class ScaleUpCenterOfMass(WriteComplexExponentialExpression):\n",
        "    CONFIG = {\n",
        "        \"time_axes_scale_val\" : 0.6,\n",
        "        \"initial_winding_frequency\" : 2.05\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creature)\n",
        "        self.setup_plane()\n",
        "        self.setup_graph()\n",
        "        self.add_center_of_mass_dot()\n",
        "        self.add_expression()\n",
        "\n",
        "        self.cross_out_denominator()\n",
        "        self.scale_up_center_of_mass()\n",
        "        self.comment_on_current_signal()\n",
        "\n",
        "    def add_center_of_mass_dot(self):\n",
        "        self.center_of_mass_dot = self.get_center_of_mass_dot()\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "        self.add(self.center_of_mass_dot)\n",
        "\n",
        "    def add_expression(self):\n",
        "        expression = OldTex(\n",
        "            \"\\\\frac{1}{t_2 - t_1}\", \"\\\\int_{t_1}^{t_2}\",\n",
        "            \"g(t)\", \"e\", \"^{-2\\\\pi i\", \"f\", \"t}\", \"dt\"\n",
        "        )\n",
        "        frac, integral, g, e, two_pi_i, f, t, dt = expression\n",
        "        expression.to_corner(UP+RIGHT)\n",
        "        t.set_color(YELLOW)\n",
        "        g[2].set_color(YELLOW)\n",
        "        dt[1].set_color(YELLOW)\n",
        "        f.set_color(GREEN)\n",
        "        self.expression = expression\n",
        "        self.add(expression)\n",
        "\n",
        "        self.winding_freq_label.to_edge(RIGHT)\n",
        "        self.winding_freq_label[1].match_color(f)\n",
        "        self.winding_freq_label.align_to(\n",
        "            self.circle_plane.coords_to_point(0, 0.1), DOWN\n",
        "        )\n",
        "\n",
        "    def cross_out_denominator(self):\n",
        "        frac = self.expression[0]\n",
        "        integral = self.expression[1:]\n",
        "        for mob in frac, integral:\n",
        "            mob.add_to_back(BackgroundRectangle(mob))\n",
        "            self.add(mob)\n",
        "        cross = Cross(frac)\n",
        "        brace = Brace(integral, DOWN)\n",
        "        label = brace.get_text(\"The actual \\\\\\\\ Fourier transform\")\n",
        "        label.add_background_rectangle()\n",
        "        label.shift_onto_screen()\n",
        "        rect = SurroundingRectangle(integral)\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.integral = integral\n",
        "        self.frac = frac\n",
        "        self.frac_cross = cross\n",
        "        self.integral_rect = rect\n",
        "        self.integral_brace = brace\n",
        "        self.integral_label = label\n",
        "\n",
        "    def scale_up_center_of_mass(self):\n",
        "        plane = self.circle_plane\n",
        "        origin = plane.coords_to_point(0, 0)\n",
        "        com_dot = self.center_of_mass_dot\n",
        "        com_vector = Arrow(\n",
        "            origin, com_dot.get_center(), \n",
        "            buff = 0\n",
        "        )\n",
        "        com_vector.match_style(com_dot)\n",
        "        vector_to_scale = com_vector.copy()\n",
        "        def get_com_vector_copies(n):\n",
        "            com_vector_copies = VGroup(*[\n",
        "                com_vector.copy().shift(x*com_vector.get_vector())\n",
        "                for x in range(1, n+1)\n",
        "            ])\n",
        "            com_vector_copies.set_color(TEAL)\n",
        "            return com_vector_copies\n",
        "        com_vector_update = UpdateFromFunc(\n",
        "            com_vector,\n",
        "            lambda v : v.put_start_and_end_on(origin, com_dot.get_center())\n",
        "        )\n",
        "\n",
        "        circle = Circle(color = TEAL)\n",
        "        circle.surround(com_dot, buffer_factor = 1.2)\n",
        "\n",
        "        time_span = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = TEAL,\n",
        "            fill_opacity = 0.4\n",
        "        )\n",
        "        axes = self.time_axes\n",
        "        time_span.replace(\n",
        "            Line(axes.coords_to_point(0, 0), axes.coords_to_point(3, 1.5)),\n",
        "            stretch = True\n",
        "        )\n",
        "        time_span.save_state()\n",
        "        time_span.stretch(0, 0, about_edge = LEFT)\n",
        "\n",
        "        graph = self.graph\n",
        "        short_graph, long_graph = [\n",
        "            axes.get_graph(\n",
        "                graph.underlying_function, x_min = 0, x_max = t_max,\n",
        "            ).match_style(graph)\n",
        "            for t_max in (3, 6)\n",
        "        ]\n",
        "        for g in short_graph, long_graph:\n",
        "            self.get_polarized_mobject(g, freq = self.initial_winding_frequency)\n",
        "\n",
        "        self.play(\n",
        "            FocusOn(circle, run_time = 2),\n",
        "            Succession(\n",
        "                ShowCreation, circle,\n",
        "                FadeOut, circle,\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            com_dot.fade, 0.5,\n",
        "            FadeIn(vector_to_scale)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(vector_to_scale.scale, 4, {\"about_point\" : origin})\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(vector_to_scale),\n",
        "            FadeIn(com_vector),\n",
        "        )\n",
        "        self.remove(graph.polarized_mobject)\n",
        "        self.play(\n",
        "            com_dot.move_to, \n",
        "            center_of_mass(short_graph.polarized_mobject.get_points()),\n",
        "            com_vector_update,\n",
        "            time_span.restore,\n",
        "            ShowCreation(short_graph.polarized_mobject),\n",
        "        )\n",
        "        self.wait()\n",
        "        # dot = Dot(fill_opacity = 0.5).move_to(time_span)\n",
        "        # self.play(\n",
        "        #     dot.move_to, com_vector,\n",
        "        #     dot.set_fill, {\"opacity\" : 0},\n",
        "        #     remover = True\n",
        "        # )\n",
        "        com_vector_copies = get_com_vector_copies(2)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                com_vector.copy(), cvc,\n",
        "                path_arc = -TAU/10\n",
        "            )\n",
        "            for cvc in com_vector_copies\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        #Squish_graph\n",
        "        to_squish = VGroup(\n",
        "            axes, graph, \n",
        "            time_span,\n",
        "        )\n",
        "        to_squish.generate_target()\n",
        "        squish_factor = 0.75\n",
        "        to_squish.target.stretch(squish_factor, 0, about_edge = LEFT)\n",
        "        pairs = list(zip(\n",
        "            to_squish.family_members_with_points(), \n",
        "            to_squish.target.family_members_with_points()\n",
        "        ))\n",
        "        to_unsquish = list(axes.x_axis.numbers) + list(axes.labels)\n",
        "        for sm, tsm in pairs:\n",
        "            if sm in to_unsquish:\n",
        "                tsm.stretch(1/squish_factor, 0)\n",
        "            if sm is axes.background_rectangle:\n",
        "                tsm.stretch(1/squish_factor, 0, about_edge = LEFT)\n",
        "\n",
        "        long_graph.stretch(squish_factor, 0)\n",
        "        self.play(\n",
        "            MoveToTarget(to_squish),\n",
        "            FadeOut(com_vector_copies)\n",
        "        )\n",
        "        long_graph.move_to(graph, LEFT)\n",
        "        self.play(\n",
        "            com_dot.move_to, \n",
        "            center_of_mass(long_graph.polarized_mobject.get_points()),\n",
        "            com_vector_update,\n",
        "            time_span.stretch, 2, 0, {\"about_edge\" : LEFT},\n",
        "            *[\n",
        "                ShowCreation(\n",
        "                    mob,\n",
        "                    rate_func = lambda a : interpolate(\n",
        "                        0.5, 1, smooth(a)\n",
        "                    )\n",
        "                )\n",
        "                for mob in (long_graph, long_graph.polarized_mobject)\n",
        "            ],\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.remove(graph, short_graph.polarized_mobject)\n",
        "        self.graph = long_graph\n",
        "        self.wait()\n",
        "        self.play(FocusOn(com_dot))\n",
        "        com_vector_copies = get_com_vector_copies(5)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                com_vector.copy(), cvc,\n",
        "                path_arc = -TAU/10\n",
        "            )\n",
        "            for cvc in com_vector_copies\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        # Scale graph out even longer\n",
        "        to_shift = VGroup(self.integral, self.integral_rect)\n",
        "        to_fade = VGroup(\n",
        "            self.integral_brace, self.integral_label,\n",
        "            self.frac, self.frac_cross\n",
        "        )\n",
        "        self.play(\n",
        "            to_shift.shift, 2*DOWN,\n",
        "            FadeOut(to_fade),\n",
        "            axes.background_rectangle.stretch, 2, 0, {\"about_edge\" : LEFT},\n",
        "            Animation(axes),\n",
        "            Animation(self.graph),\n",
        "            FadeOut(com_vector_copies),\n",
        "        )\n",
        "        self.change_frequency(2.0, added_anims = [com_vector_update])\n",
        "        very_long_graph = axes.get_graph(\n",
        "            graph.underlying_function,\n",
        "            x_min = 0, x_max = 12,\n",
        "        )\n",
        "        very_long_graph.match_style(graph)\n",
        "        self.get_polarized_mobject(very_long_graph, freq = 2.0)\n",
        "        self.play(\n",
        "            com_dot.move_to,\n",
        "            center_of_mass(very_long_graph.polarized_mobject.get_points()),\n",
        "            com_vector_update,\n",
        "            ShowCreation(\n",
        "                very_long_graph,\n",
        "                rate_func = lambda a : interpolate(0.5, 1, a)\n",
        "            ),\n",
        "            ShowCreation(very_long_graph.polarized_mobject)\n",
        "        )\n",
        "        self.remove(graph, graph.polarized_mobject)\n",
        "        self.graph = very_long_graph\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            com_vector.scale, 12, {\"about_point\" : origin},\n",
        "            run_time = 2\n",
        "        )\n",
        "        # com_vector_copies = get_com_vector_copies(11)\n",
        "        # self.play(ReplacementTransform(\n",
        "        #     VGroup(com_vector.copy()), \n",
        "        #     com_vector_copies,\n",
        "        #     path_arc = TAU/10,\n",
        "        #     run_time = 1.5,\n",
        "        #     lag_ratio = 0.5\n",
        "        # ))\n",
        "        self.wait()\n",
        "\n",
        "        self.com_vector = com_vector\n",
        "        self.com_vector_update = com_vector_update\n",
        "        self.com_vector_copies = com_vector_copies\n",
        "\n",
        "    def comment_on_current_signal(self):\n",
        "        graph = self.graph\n",
        "        com_dot = self.center_of_mass_dot \n",
        "        com_vector = self.com_vector\n",
        "        com_vector_update = self.com_vector_update\n",
        "        axes = self.time_axes\n",
        "        origin = self.circle_plane.coords_to_point(0, 0)\n",
        "        wps_label = self.winding_freq_label\n",
        "\n",
        "        new_com_vector_update = UpdateFromFunc(\n",
        "            com_vector, lambda v : v.put_start_and_end_on(\n",
        "                origin, com_dot.get_center()\n",
        "            ).scale(12, about_point = origin)\n",
        "        )\n",
        "\n",
        "        v_lines = self.get_v_lines_indicating_periods(\n",
        "            freq = 1.0, n_lines = 3\n",
        "        )[:2]\n",
        "        graph_portion = axes.get_graph(\n",
        "            graph.underlying_function, x_min = 1, x_max = 2\n",
        "        )\n",
        "        graph_portion.set_color(TEAL)\n",
        "        bps_label = OldTexText(\"2 beats per second\")\n",
        "        bps_label.scale(0.75)\n",
        "        bps_label.next_to(graph_portion, UP, aligned_edge = LEFT)\n",
        "        bps_label.shift(SMALL_BUFF*RIGHT)\n",
        "        bps_label.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(v_lines, lag_ratio = 0),\n",
        "            ShowCreation(graph_portion),\n",
        "            FadeIn(bps_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            bps_label[1][0].copy(), wps_label[1]\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            com_vector.scale, 0.5, {\"about_point\" : origin},\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.change_frequency(2.5,\n",
        "            added_anims = [new_com_vector_update],\n",
        "            run_time = 20,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class TakeAStepBack(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Hang on, go over \\\\\\\\ that again?\",\n",
        "            target_mode = \"confused\"\n",
        "        ),\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.play(self.teacher.change, \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "class SimpleCosineWrappingAroundCircle(WriteComplexExponentialExpression):\n",
        "    CONFIG = {\n",
        "        \"initial_winding_frequency\" : 0,\n",
        "        \"circle_plane_config\" : {\n",
        "            \"unit_size\" : 3,\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_plane()\n",
        "        self.setup_graph()\n",
        "        self.remove(self.pi_creature)\n",
        "        self.winding_freq_label.shift(7*LEFT)\n",
        "        VGroup(self.time_axes, self.graph).shift(4*UP)\n",
        "        VGroup(\n",
        "            self.circle_plane,\n",
        "            self.graph.polarized_mobject\n",
        "        ).move_to(ORIGIN)\n",
        "        self.add(self.get_center_of_mass_dot())\n",
        "        self.generate_center_of_mass_dot_update_anim()\n",
        "\n",
        "        self.change_frequency(\n",
        "            2.0, \n",
        "            rate_func=linear, \n",
        "            run_time = 30\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SummarizeTheFullTransform(DrawFrequencyPlot):\n",
        "    CONFIG = {\n",
        "        \"time_axes_config\" : {\n",
        "            \"x_max\" : 4.5,\n",
        "            \"x_axis_config\" : {\n",
        "                \"unit_size\" : 1.2,\n",
        "                \"tick_frequency\" : 0.5,\n",
        "                # \"big_tick_numbers\" : range(0, 10, 2),\n",
        "                # \"numbers_to_show\" : range(0, 10, 2),\n",
        "            }\n",
        "        },\n",
        "        \"frequency_axes_config\" : {\n",
        "            \"x_max\" : 5,\n",
        "            \"x_axis_config\" : {\n",
        "                \"unit_size\" : 1,\n",
        "                \"numbers_to_show\" : list(range(1, 5)),\n",
        "            },\n",
        "            \"y_max\" : 2,\n",
        "            \"y_min\" : -2,\n",
        "            \"y_axis_config\" : {\n",
        "                \"unit_size\" : 0.75,\n",
        "                \"tick_frequency\" : 1,\n",
        "            },\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_all_axes()\n",
        "        self.show_transform_function()\n",
        "        self.show_winding()\n",
        "\n",
        "    def setup_all_axes(self):\n",
        "        time_axes = self.get_time_axes()\n",
        "        time_label, intensity_label = time_axes.labels\n",
        "        time_label.next_to(\n",
        "            time_axes.x_axis.get_right(), \n",
        "            DOWN, SMALL_BUFF\n",
        "        )\n",
        "        intensity_label.next_to(time_axes.y_axis, UP, buff = SMALL_BUFF)\n",
        "        intensity_label.to_edge(LEFT)\n",
        "\n",
        "        frequency_axes = self.get_frequency_axes()\n",
        "        frequency_axes.to_corner(UP+RIGHT)\n",
        "        frequency_axes.shift(RIGHT)\n",
        "        fy_axis = frequency_axes.y_axis\n",
        "        for number in fy_axis.numbers:\n",
        "            number.add_background_rectangle()\n",
        "        fy_axis.remove(*fy_axis.numbers[1::2])\n",
        "        frequency_axes.remove(frequency_axes.box)\n",
        "        frequency_axes.label.shift_onto_screen()\n",
        "\n",
        "        circle_plane = self.get_circle_plane()\n",
        "\n",
        "        self.set_variables_as_attrs(time_axes, frequency_axes, circle_plane)\n",
        "        self.add(time_axes)\n",
        "\n",
        "    def show_transform_function(self):\n",
        "        time_axes = self.time_axes\n",
        "        frequency_axes = self.frequency_axes\n",
        "        def func(t):\n",
        "            return 0.5*(2+np.cos(2*TAU*t) + np.cos(3*TAU*t))\n",
        "        fourier_func = get_fourier_transform(\n",
        "            func, \n",
        "            t_min = time_axes.x_min,\n",
        "            t_max = time_axes.x_max,\n",
        "            use_almost_fourier = False,\n",
        "        )\n",
        "\n",
        "        graph = time_axes.get_graph(func)\n",
        "        graph.set_color(GREEN)\n",
        "        fourier_graph = frequency_axes.get_graph(fourier_func)\n",
        "        fourier_graph.set_color(RED)\n",
        "\n",
        "        g_t = OldTex(\"g(t)\")\n",
        "        g_t[-2].match_color(graph)\n",
        "        g_t.next_to(graph, UP)\n",
        "        g_hat_f = OldTex(\"\\\\hat g(f)\")\n",
        "        g_hat_f[-2].match_color(fourier_graph)\n",
        "        g_hat_f.next_to(\n",
        "            frequency_axes.input_to_graph_point(2, fourier_graph),\n",
        "            UP\n",
        "        )\n",
        "\n",
        "        morty = self.pi_creature\n",
        "\n",
        "        time_label = time_axes.labels[0]\n",
        "        frequency_label = frequency_axes.label\n",
        "        for label in time_label, frequency_label:\n",
        "            label.rect = SurroundingRectangle(label)\n",
        "        time_label.rect.match_style(graph)\n",
        "        frequency_label.rect.match_style(fourier_graph)\n",
        "\n",
        "        self.add(graph)\n",
        "        g_t.save_state()\n",
        "        g_t.move_to(morty, UP+LEFT)\n",
        "        g_t.fade(1)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            g_t.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(frequency_axes, run_time = 1))\n",
        "        self.play(\n",
        "            ReplacementTransform(graph.copy(), fourier_graph),\n",
        "            ReplacementTransform(g_t.copy(), g_hat_f),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for label in time_label, frequency_label:\n",
        "            self.play(\n",
        "                ShowCreation(label.rect),\n",
        "                morty.change, \"thinking\"\n",
        "            )\n",
        "            self.play(FadeOut(label.rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            graph, fourier_graph,\n",
        "            g_t, g_hat_f\n",
        "        )\n",
        "\n",
        "    def show_winding(self):\n",
        "        plane = self.circle_plane\n",
        "        graph = self.graph\n",
        "        fourier_graph = self.fourier_graph\n",
        "        morty = self.pi_creature\n",
        "        g_hat_f = self.g_hat_f\n",
        "        g_hat_f_rect = SurroundingRectangle(g_hat_f)\n",
        "        g_hat_f_rect.set_color(TEAL)\n",
        "        g_hat_rect = SurroundingRectangle(g_hat_f[0])\n",
        "        g_hat_rect.match_style(g_hat_f_rect)\n",
        "\n",
        "        g_hat_f.generate_target()\n",
        "        g_hat_f.target.next_to(plane, RIGHT)\n",
        "        g_hat_f.target.shift(UP)\n",
        "        arrow = Arrow(\n",
        "            g_hat_f.target.get_left(),\n",
        "            plane.coords_to_point(0, 0),\n",
        "            color = self.center_of_mass_color,\n",
        "        )\n",
        "\n",
        "        frequency_axes = self.frequency_axes\n",
        "        imaginary_fourier_graph = frequency_axes.get_graph(\n",
        "            get_fourier_transform(\n",
        "                graph.underlying_function,\n",
        "                t_min = self.time_axes.x_min,\n",
        "                t_max = self.time_axes.x_max,\n",
        "                real_part = False,\n",
        "                use_almost_fourier = False,\n",
        "            )\n",
        "        )\n",
        "        imaginary_fourier_graph.set_color(BLUE)\n",
        "        imaginary_fourier_graph.shift(\n",
        "            frequency_axes.x_axis.get_right() - \\\n",
        "            imaginary_fourier_graph.get_points()[-1],\n",
        "        )\n",
        "\n",
        "        real_part = OldTexText(\n",
        "            \"Real part of\", \"$\\\\hat g(f)$\"\n",
        "        )\n",
        "        real_part[1].match_style(g_hat_f)\n",
        "        real_part.move_to(g_hat_f)\n",
        "        real_part.to_edge(RIGHT)\n",
        "\n",
        "        self.get_polarized_mobject(graph, freq = 0)\n",
        "        update_pol_graph = UpdateFromFunc(\n",
        "            graph.polarized_mobject,\n",
        "            lambda m : m.set_stroke(width = 2)\n",
        "        )\n",
        "        com_dot = self.get_center_of_mass_dot()\n",
        "\n",
        "        winding_run_time = 40.0\n",
        "        g_hat_f_indication = Succession(\n",
        "            Animation, Mobject(), {\"run_time\" : 4},\n",
        "            FocusOn, g_hat_f,\n",
        "            ShowCreation, g_hat_f_rect,\n",
        "            Animation, Mobject(),\n",
        "            Transform, g_hat_f_rect, g_hat_rect,\n",
        "            Animation, Mobject(),\n",
        "            FadeOut, g_hat_f_rect,\n",
        "            Animation, Mobject(),\n",
        "            MoveToTarget, g_hat_f,\n",
        "            UpdateFromAlphaFunc, com_dot, lambda m, a : m.set_fill(opacity = a),\n",
        "            Animation, Mobject(), {\"run_time\" : 2},\n",
        "            GrowArrow, arrow,\n",
        "            FadeOut, arrow,\n",
        "            Animation, Mobject(), {\"run_time\" : 5},\n",
        "            Write, real_part, {\"run_time\" : 2},\n",
        "            Animation, Mobject(), {\"run_time\" : 3},\n",
        "            ShowCreation, imaginary_fourier_graph, {\"run_time\" : 3},\n",
        "            rate_func = squish_rate_func(\n",
        "                lambda x : x, 0, 31./winding_run_time\n",
        "            ),\n",
        "            run_time = winding_run_time\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(plane),\n",
        "            ReplacementTransform(\n",
        "                graph.copy(), graph.polarized_mobject\n",
        "            ),\n",
        "            morty.change, \"happy\",\n",
        "        )\n",
        "        self.generate_center_of_mass_dot_update_anim(multiplier = 4.5)\n",
        "        self.generate_fourier_dot_transform(fourier_graph)\n",
        "        self.change_frequency(\n",
        "            5.0, \n",
        "            rate_func=linear, \n",
        "            run_time = winding_run_time,\n",
        "            added_anims = [\n",
        "                g_hat_f_indication, \n",
        "                update_pol_graph,\n",
        "                Animation(frequency_axes.x_axis.numbers),\n",
        "                Animation(self.fourier_graph_dot),\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SummarizeFormula(Scene):\n",
        "    def construct(self):\n",
        "        expression = self.get_expression()\n",
        "        screen_rect = ScreenRectangle(height = 5)\n",
        "        screen_rect.to_edge(DOWN)\n",
        "\n",
        "        exp_rect, g_exp_rect, int_rect = [\n",
        "            SurroundingRectangle(VGroup(\n",
        "                expression.get_part_by_tex(p1),\n",
        "                expression.get_part_by_tex(p2),\n",
        "            ))\n",
        "            for p1, p2 in [(\"e\", \"t}\"), (\"g({}\", \"t}\"), (\"\\\\int\", \"dt\")]\n",
        "        ]\n",
        "\n",
        "        self.add(expression)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(screen_rect),\n",
        "            ShowCreation(exp_rect),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Transform(exp_rect, g_exp_rect))\n",
        "        self.wait(2)\n",
        "        self.play(Transform(exp_rect, int_rect))\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_expression(self):\n",
        "        expression = OldTex(\n",
        "            \"\\\\hat g(\", \"f\", \")\", \"=\", \"\\\\int\", \"_{t_1}\", \"^{t_2}\",\n",
        "            \"g({}\", \"t\", \")\", \"e\", \"^{-2\\\\pi i\", \"f\", \"t}\", \"dt\"\n",
        "        )\n",
        "        expression.set_color_by_tex(\n",
        "            \"t\", YELLOW, substring = False,\n",
        "        )\n",
        "        expression.set_color_by_tex(\"t}\", YELLOW)\n",
        "        expression.set_color_by_tex(\n",
        "            \"f\", RED, substring = False,\n",
        "        )\n",
        "        expression.scale(1.2)\n",
        "        expression.to_edge(UP)\n",
        "        return expression\n",
        "\n",
        "class OneSmallNote(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Just one \\\\\\\\ small note...\",\n",
        "            # target_mode = \n",
        "        )\n",
        "        self.play_student_changes(\"erm\", \"happy\", \"sassy\")\n",
        "        self.wait(2)\n",
        "\n",
        "class BoundsAtInfinity(SummarizeFormula):\n",
        "    def construct(self):\n",
        "        expression = self.get_expression()\n",
        "        self.add(expression)\n",
        "        self.add_graph()\n",
        "        axes = self.axes\n",
        "        graph = self.graph\n",
        "\n",
        "        time_interval = self.get_time_interval(-2, 2)\n",
        "        wide_interval = self.get_time_interval(-FRAME_X_RADIUS, FRAME_X_RADIUS)\n",
        "        bounds = VGroup(*reversed(expression.get_parts_by_tex(\"t_\")))\n",
        "        bound_rects = VGroup(*[\n",
        "            SurroundingRectangle(b, buff = 0.5*SMALL_BUFF)\n",
        "            for b in bounds\n",
        "        ])\n",
        "        bound_rects.set_color(TEAL)\n",
        "        inf_bounds = VGroup(*[\n",
        "            VGroup(OldTex(s + \"\\\\infty\"))\n",
        "            for s in (\"-\", \"+\")\n",
        "        ])\n",
        "        decimal_bounds = VGroup(*[DecimalNumber(0) for x in range(2)])\n",
        "        for bound, inf_bound, d_bound in zip(bounds, inf_bounds, decimal_bounds):\n",
        "            for new_bound in inf_bound, d_bound:\n",
        "                new_bound.scale(0.7)\n",
        "                new_bound.move_to(bound, LEFT)\n",
        "                new_bound.bound = bound\n",
        "        def get_db_num_update(vect):\n",
        "            return lambda a : axes.x_axis.point_to_number(\n",
        "                time_interval.get_edge_center(vect)\n",
        "            )\n",
        "        decimal_updates = [\n",
        "            ChangingDecimal(\n",
        "                db, get_db_num_update(vect),\n",
        "                position_update_func = lambda m : m.move_to(\n",
        "                    m.bound, LEFT\n",
        "                )\n",
        "            )\n",
        "            for db, vect in zip(decimal_bounds, [LEFT, RIGHT])\n",
        "        ]\n",
        "        for update in decimal_updates:\n",
        "            update.update(1)\n",
        "\n",
        "        time_interval.save_state()\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            self.get_time_interval(0, 0.01), time_interval\n",
        "        ))\n",
        "        self.play(LaggedStartMap(ShowCreation, bound_rects))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(bound_rects))\n",
        "        self.play(ReplacementTransform(bounds, inf_bounds))\n",
        "        self.play(Transform(\n",
        "            time_interval, wide_interval,\n",
        "            run_time = 4,\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.play(\n",
        "            ReplacementTransform(inf_bounds, decimal_bounds),\n",
        "            time_interval.restore,\n",
        "        )\n",
        "        self.play(\n",
        "            VGroup(axes, graph).stretch, 0.05, 0,\n",
        "            Transform(time_interval, wide_interval),\n",
        "            UpdateFromAlphaFunc(\n",
        "                axes.x_axis.numbers, \n",
        "                lambda m, a : m.set_fill(opacity = 1-a)\n",
        "            ),\n",
        "            *decimal_updates,\n",
        "            run_time = 12,\n",
        "            rate_func = bezier([0, 0, 1, 1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    def add_graph(self):\n",
        "        axes = Axes(\n",
        "            x_min = -140,\n",
        "            x_max = 140,\n",
        "            y_min = -2, \n",
        "            y_max = 2,\n",
        "            axis_config = {\n",
        "                \"include_tip\" : False,\n",
        "            },\n",
        "        )\n",
        "        axes.x_axis.add_numbers(*list(filter(\n",
        "            lambda x : x != 0,\n",
        "            list(range(-8, 10, 2)),\n",
        "        )))\n",
        "        axes.shift(DOWN)\n",
        "        self.add(axes)\n",
        "\n",
        "        def func(x):\n",
        "            return np.exp(-0.1*x**2)*(1 + np.cos(TAU*x))\n",
        "        graph = axes.get_graph(func)\n",
        "        self.add(graph)\n",
        "        graph.set_color(YELLOW)\n",
        "\n",
        "        self.set_variables_as_attrs(axes, graph)\n",
        "\n",
        "    def get_time_interval(self, t1, t2):\n",
        "        line = Line(*[\n",
        "            self.axes.coords_to_point(t, 0)\n",
        "            for t in (t1, t2)\n",
        "        ])\n",
        "        rect = Rectangle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = TEAL,\n",
        "            fill_opacity = 0.5,\n",
        "        )\n",
        "        rect.match_width(line)\n",
        "        rect.stretch_to_fit_height(2.5)\n",
        "        rect.move_to(line, DOWN)\n",
        "        return rect\n",
        "\n",
        "class MoreToCover(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Much more to say...\",\n",
        "            target_mode = \"hooray\",\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"SO MUCH!\",\n",
        "            target_mode = \"surprised\",\n",
        "            added_anims = [self.change_students(*3*[\"happy\"])],\n",
        "            run_time = 0.5\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class ShowUncertaintyPrinciple(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Uncertainty principle\")\n",
        "        self.add(title)\n",
        "        top_axes = Axes(\n",
        "            x_min = -FRAME_X_RADIUS,\n",
        "            x_max = FRAME_X_RADIUS,\n",
        "            y_min = 0,\n",
        "            y_max = 3,\n",
        "            y_axis_config = {\n",
        "                \"unit_size\" : 0.6,\n",
        "                \"include_tip\" : False,\n",
        "            }\n",
        "        )\n",
        "        bottom_axes = top_axes.deepcopy()\n",
        "        arrow = Vector(DOWN, color = WHITE)\n",
        "        group = VGroup(\n",
        "            title, top_axes, arrow, bottom_axes\n",
        "        )\n",
        "        group.arrange(DOWN)\n",
        "        title.shift(MED_SMALL_BUFF*UP)\n",
        "        group.to_edge(UP)\n",
        "        fourier_word = OldTexText(\"Fourier transform\")\n",
        "        fourier_word.next_to(arrow, RIGHT)\n",
        "        self.add(group, fourier_word)\n",
        "\n",
        "        ghost_dot = Dot(RIGHT, fill_opacity = 0)\n",
        "        def get_bell_func(factor = 1):\n",
        "            return lambda x : 2*np.exp(-factor*x**2)\n",
        "        top_graph = top_axes.get_graph(get_bell_func())\n",
        "        top_graph.set_color(YELLOW)\n",
        "        bottom_graph = bottom_axes.get_graph(get_bell_func())\n",
        "        bottom_graph.set_color(RED)\n",
        "        def get_update_func(axes):\n",
        "            def update_graph(graph):\n",
        "                f = ghost_dot.get_center()[0]\n",
        "                if axes == bottom_axes:\n",
        "                    f = 1./f\n",
        "                new_graph = axes.get_graph(get_bell_func(f))\n",
        "                graph.set_points(new_graph.get_points())\n",
        "            return update_graph\n",
        "\n",
        "        factors = [0.3, 0.1, 2, 10, 100, 0.01, 0.5]\n",
        "\n",
        "        self.play(ShowCreation(top_graph))\n",
        "        self.play(ReplacementTransform(\n",
        "            top_graph.copy(),\n",
        "            bottom_graph,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.add(*[\n",
        "            Mobject.add_updater(graph, get_update_func(axes))\n",
        "            for graph, axes in [(top_graph, top_axes), (bottom_graph, bottom_axes)]\n",
        "        ])\n",
        "        for factor in factors:\n",
        "            self.play(\n",
        "                ghost_dot.move_to, factor*RIGHT,\n",
        "                run_time = 2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class XCoordinateLabelTypoFix(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"$x$-coordinate for center of mass\")\n",
        "        words.set_color(RED)\n",
        "        self.add(words)\n",
        "\n",
        "class NextVideoWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Next video\")\n",
        "        title.to_edge(UP)\n",
        "        screen_rect = ScreenRectangle(height = 6)\n",
        "        screen_rect.next_to(title, DOWN)\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(screen_rect))\n",
        "        self.wait(2)\n",
        "\n",
        "class SubscribeOrBinge(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        morty.center().to_edge(DOWN, LARGE_BUFF)\n",
        "        subscribe = OldTexText(\"Subscribe\")\n",
        "        subscribe.set_color(RED)\n",
        "        subscribe.next_to(morty, UP+RIGHT)\n",
        "        binge = OldTexText(\"Binge\")\n",
        "        binge.set_color(BLUE)\n",
        "        binge.next_to(morty, UP+LEFT)\n",
        "\n",
        "        videos = VGroup(*[VideoIcon() for x in range(30)])\n",
        "        colors = it.cycle([BLUE_D, BLUE_E, BLUE_C, GREY_BROWN])\n",
        "        for video, color in zip(videos, colors):\n",
        "            video.set_color(color)\n",
        "        videos.move_to(binge.get_bottom(), UP)\n",
        "        video_anim = LaggedStartMap(\n",
        "            Succession, videos, \n",
        "            lambda v : (\n",
        "                FadeIn, v,\n",
        "                ApplyMethod, v.shift, 5*DOWN, {\"run_time\" : 6},\n",
        "            ),\n",
        "            run_time = 10\n",
        "        )\n",
        "        sub_arrow = Arrow(\n",
        "            subscribe.get_bottom(),\n",
        "            Dot().to_corner(DOWN+RIGHT, buff = LARGE_BUFF),\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        for word in subscribe, binge:\n",
        "            word.save_state()\n",
        "            word.shift(DOWN)\n",
        "            word.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            subscribe.restore,\n",
        "            morty.change, \"raise_left_hand\"\n",
        "        )\n",
        "        self.play(GrowArrow(sub_arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            video_anim,\n",
        "            Succession(\n",
        "                AnimationGroup(\n",
        "                    ApplyMethod(binge.restore),\n",
        "                    ApplyMethod(morty.change, \"raise_right_hand\", binge),\n",
        "                ),\n",
        "                Blink, morty,\n",
        "                ApplyMethod, morty.change, \"shruggie\", videos,\n",
        "                Animation, Mobject(), {\"run_time\" : 2},\n",
        "                Blink, morty,\n",
        "                Animation, Mobject(), {\"run_time\" : 4}\n",
        "            )\n",
        "        )\n",
        "\n",
        "class CloseWithAPuzzle(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Close with a puzzle!\", run_time = 1)\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class PuzzleDescription(Scene):\n",
        "    def construct(self):\n",
        "        lines = VGroup(\n",
        "            OldTexText(\"Convex set\", \"$C$\", \"in $\\\\mathds{R}^3$\"),\n",
        "            OldTexText(\"Boundary\", \"$B$\", \"$=$\", \"$\\\\partial C$\"),\n",
        "            OldTexText(\"$D$\", \"$=\\\\{p+q | p, q \\\\in B\\\\}$\"),\n",
        "            OldTexText(\"Prove that\", \"$D$\", \"is convex\")\n",
        "        )\n",
        "        for line in lines:\n",
        "            line.set_color_by_tex_to_color_map({\n",
        "                \"$C$\" : BLUE_D,\n",
        "                \"\\\\partial C\" : BLUE_D,\n",
        "                \"$B$\" : BLUE_C,\n",
        "                \"$D$\" : YELLOW,\n",
        "            })\n",
        "        VGroup(lines[2][1][2], lines[2][1][6]).set_color(RED)\n",
        "        VGroup(lines[2][1][4], lines[2][1][8]).set_color(MAROON_B)\n",
        "        lines[2][1][10].set_color(BLUE_C)\n",
        "        lines.scale(1.25)\n",
        "        lines.arrange(DOWN, buff = LARGE_BUFF, aligned_edge = LEFT)\n",
        "\n",
        "        lines.to_corner(UP+RIGHT)\n",
        "\n",
        "        for line in lines:\n",
        "            self.play(Write(line))\n",
        "            self.wait(2)\n",
        "\n",
        "class SponsorScreenGrab(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        morty = self.pi_creature\n",
        "        screen = ScreenRectangle(height = 5)\n",
        "        screen.to_corner(UP+LEFT)\n",
        "        screen.shift(MED_LARGE_BUFF*DOWN)\n",
        "        url = OldTexText(\"janestreet.com/3b1b\")\n",
        "        url.next_to(screen, UP)\n",
        "\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            ShowCreation(screen)\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.wait(2)\n",
        "        for mode in \"happy\", \"thinking\", \"pondering\", \"thinking\":\n",
        "            self.play(morty.change, mode, screen)\n",
        "            self.wait(4)\n",
        "\n",
        "class FourierEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"CrypticSwarm\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Juan Benet\",\n",
        "            \"Markus Persson\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Burt Humburg\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Sh\u00ecm\u00edn Kuang\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Robert Teed\",\n",
        "            \"One on Epsilon\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Mark Govea\",\n",
        "            \"John Haley\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Randall Hunt\",\n",
        "            \"Desmos\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Awoo\",\n",
        "            \"Dr David G. Stork\",\n",
        "            \"Linh Tran\",\n",
        "            \"Jason Hise\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Ankalagon\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Eric Chow\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"David Kedmey\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"supershabam\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Isak Hietala\",\n",
        "            \"James Thornton\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Waleed Hamied\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Yaw Etse\",\n",
        "            \"David B\",\n",
        "            \"Julio Cesar Campo Neto\",\n",
        "            \"Delton Ding\",\n",
        "            \"George Chiesa\",\n",
        "            \"Chloe Zhou\",\n",
        "            \"Alexander Nye\",\n",
        "            \"Ross Garber\",\n",
        "            \"Wang HaoRan\",\n",
        "            \"Felix Tripier\",\n",
        "            \"Arthur Zey\",\n",
        "            \"Norton\",\n",
        "            \"Kevin Le\",\n",
        "            \"Alexander Feldman\",\n",
        "            \"David MacCumber\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Fourier\\\\\\\\\", \"Visualized\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.set_stroke(RED, 2)\n",
        "        title.scale(2.5)\n",
        "        title.add_background_rectangle()\n",
        "\n",
        "        def func(t):\n",
        "            return np.cos(2*TAU*t) + np.cos(3*TAU*t) + np.cos(5*t)\n",
        "        fourier = get_fourier_transform(func, -5, 5)\n",
        "\n",
        "        graph = FunctionGraph(func, (-5, 5, 0.01))\n",
        "        graph.set_color(BLUE)\n",
        "        fourier_graph = FunctionGraph(fourier, (0, 6, 0.01))\n",
        "        fourier_graph.set_color(YELLOW)\n",
        "        for g in graph, fourier_graph:\n",
        "            g.stretch_to_fit_height(2)\n",
        "            g.stretch_to_fit_width(10)\n",
        "            g.set_stroke(width=6)\n",
        "\n",
        "        pol_graphs = VGroup()\n",
        "        for f in np.linspace(1.98, 2.02, 5):\n",
        "            pol_graph = ParametricCurve(\n",
        "                lambda t : complex_to_R3(\n",
        "                    (2+np.cos(2*TAU*t)+np.cos(3*TAU*t))*np.exp(-complex(0, TAU*f*t))\n",
        "                ),\n",
        "                t_range=(-5, 5, 0.01),\n",
        "            )\n",
        "            pol_graph.match_color(graph)\n",
        "            pol_graph.set_height(2)\n",
        "            pol_graphs.add(pol_graph)\n",
        "        pol_graphs.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        pol_graphs.set_color_by_gradient(BLUE_C, TEAL, GREEN)\n",
        "        pol_graphs.match_width(graph)\n",
        "        pol_graphs.set_stroke(width=1)\n",
        "\n",
        "        parts = VGroup(graph, pol_graphs, fourier_graph)\n",
        "        parts[1].set_width(parts[0].get_width() - 1)\n",
        "        parts.arrange(\n",
        "            DOWN, buff=LARGE_BUFF,\n",
        "            aligned_edge=RIGHT\n",
        "        )\n",
        "        parts.to_edge(RIGHT)\n",
        "        self.add(parts)\n",
        "\n",
        "        words = VGroup(OldTexText(\"Signal\"), OldTexText(\"Winding\"), OldTexText(\"Transform\"))\n",
        "        for word, part in zip(words, parts):\n",
        "            word.scale(1.5)\n",
        "            word.next_to(part, LEFT)\n",
        "            word.to_edge(LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "        rect = SurroundingRectangle(pol_graphs[2])\n",
        "        rect.set_stroke(RED, 2)\n",
        "        dot = Dot(fourier_graph.pfp(2 / 6), color=RED)\n",
        "        dot.set_stroke(BLACK, 3, background=True)\n",
        "        dot.shift(0.01 * RIGHT)\n",
        "        line = Line(dot.get_center(), rect.get_corner(DL), buff=0.1)\n",
        "        line.match_style(rect)\n",
        "\n",
        "        self.add(dot, line, rect)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}