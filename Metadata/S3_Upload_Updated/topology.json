{
    "topic": "The mathematical concept being demonstrated is the creation of a uniform-ish distribution of points on a sphere using",
    "code": [
        "from manimlib import *\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "def fibonacci_sphere(samples=1000):\n",
        "    \"\"\"\n",
        "    Create uniform-ish points on a sphere\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    samples : int\n",
        "        Number of points to create. The default is 1000.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    points : NumPy array\n",
        "        Points on the unit sphere.\n",
        "\n",
        "    \"\"\"\n",
        "\n",
        "    # Define the golden angle\n",
        "    phi = np.pi * (np.sqrt(5)-1)\n",
        "\n",
        "    # Define y-values of points\n",
        "    pos = np.array(range(samples),ndmin=2)\n",
        "    y = 1 - (pos/(samples - 1)) * 2\n",
        "\n",
        "    # Define radius of cross-section at y\n",
        "    radius = np.sqrt(1-y*y)\n",
        "\n",
        "    # Define the golden angle increment\n",
        "    theta = phi * pos\n",
        "\n",
        "    # Define x- and z- values of poitns\n",
        "    x = np.cos(theta)*radius\n",
        "    z = np.sin(theta)*radius\n",
        "\n",
        "    # Merge together x,y,z\n",
        "    points = np.concatenate((x,y,z))\n",
        "\n",
        "    # Transpose to get coordinates in right place\n",
        "    points = np.transpose(points)\n",
        "\n",
        "    return points\n",
        "\n",
        "\n",
        "def sanitize_3D_vector(pt):\n",
        "    \"\"\"\n",
        "    Attempts to format input as a NumPy array of size (N,3)\n",
        "    \"\"\"\n",
        "\n",
        "    # Try to convert the input to a NumPy array of the right size\n",
        "    pts = np.array(pt,ndmin=2)\n",
        "\n",
        "    if len(pts.shape) > 2:\n",
        "        raise ValueError(\"3D vectors cannot have depth more than 2.\")\n",
        "\n",
        "    if pts.shape[1] != 3:\n",
        "        raise ValueError(\"3D vectors must have 3 components.\")\n",
        "\n",
        "    return pts\n",
        "\n",
        "\n",
        "def sanitize_scalar(x):\n",
        "    \"\"\"\n",
        "    Attemps to format input as a NumPy array of size (N,)\n",
        "    \"\"\"\n",
        "\n",
        "    # Try to convert input to a NumPy array of the right size\n",
        "    x_array = np.array(x,ndmin=1)\n",
        "\n",
        "    if len(x_array.shape) > 1:\n",
        "        raise ValueError(\"Scalars cannot have depth more than 2.\")\n",
        "\n",
        "    return x_array\n",
        "\n",
        "\n",
        "def direction_field(pt, discontinuities=\"equator\", epsilon=0.01):\n",
        "    \"\"\"\n",
        "    Parameters\n",
        "    ----------\n",
        "    pt : NumPy array (N,3), parallelizable\n",
        "        Point on the unit sphere\n",
        "\n",
        "    discontinuities : str\n",
        "        Specifies where the direction field can be discontinuous.\n",
        "        Three options:\n",
        "            \"equator\"\n",
        "            \"two\"\n",
        "            \"one\"\n",
        "\n",
        "    epsilon : float\n",
        "        Determines error used in dealing with discontinuities\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    vec : NumPy array (N,3), parallelizable\n",
        "        Associated unit vector\n",
        "    \"\"\"\n",
        "\n",
        "    # Sanitize inputs\n",
        "    pts = sanitize_3D_vector(pt)\n",
        "\n",
        "    # Get coordinates of the points\n",
        "    (x,y,z) = np.transpose(pts)\n",
        "\n",
        "    # Split operation based on the number of discontinuities\n",
        "\n",
        "    if discontinuities == \"equator\":\n",
        "        # Define mask depending on whether we are close to the equator\n",
        "        mask = (abs(z) < 0.1)\n",
        "\n",
        "        # Define behavior on equator\n",
        "        equator = np.stack((-y,x,0*z))\n",
        "\n",
        "        # Define behavior off equator\n",
        "        non_equator = np.stack((0*x,z,-y))\n",
        "\n",
        "        # Combine using the mask\n",
        "        perp = mask*equator + np.logical_not(mask)*non_equator\n",
        "\n",
        "    elif discontinuities == \"two\":\n",
        "        # Define mask depending on whether we are near the poles\n",
        "        mask = abs(abs(z)-1) < epsilon\n",
        "\n",
        "        # Define behavior around poles\n",
        "        poles = np.stack((0*x,z,-y))\n",
        "\n",
        "        # Define behavior away from poles\n",
        "        non_poles = np.stack((-y,x,0*z))\n",
        "\n",
        "        # Combine using the mask\n",
        "        perp = mask*poles + np.logical_not(mask)*non_poles\n",
        "\n",
        "    elif discontinuities == \"one\":\n",
        "        # Define mask depending on whether we are near the north pole\n",
        "        mask = abs(z-1) < epsilon\n",
        "\n",
        "        # Define behavior around north pole\n",
        "        north_pole = np.stack((0*x,z,-y))\n",
        "\n",
        "        # Define behavior away from north pole\n",
        "        X = x**2 - y**2 - (z-1)**2\n",
        "        Y = 2*x*y\n",
        "        Z = 2*x*(z-1)\n",
        "\n",
        "        non_north_pole = np.stack((X,Y,Z))\n",
        "\n",
        "        # Combine using the mask\n",
        "        perp = mask*north_pole + np.logical_not(mask)*non_north_pole\n",
        "\n",
        "    else:\n",
        "        raise NotImplementedError()\n",
        "\n",
        "    # Determine number of vectors\n",
        "    field = np.transpose(perp)\n",
        "    num_pts = field.shape[0]\n",
        "\n",
        "    # normalize vector field before returning\n",
        "    norm = np.linalg.norm(field, axis=1)\n",
        "    norm = np.reshape(norm,[num_pts,1])\n",
        "    vec = field/norm\n",
        "\n",
        "    return vec\n",
        "\n",
        "\n",
        "def distension(pt,t):\n",
        "    \"\"\"\n",
        "    Helper function for computing amount to distend homotopy.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    pt : NumPy array (M,3), parallelizable\n",
        "        Point on the unit sphere\n",
        "    t : float or NumPy array (N,)\n",
        "        Time elapsed (between 0 and 1)\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    rho_factor : NumPy array (N,M)\n",
        "        Adjustment to distance from the origin\n",
        "    \"\"\"\n",
        "\n",
        "    # Compute the scaling factor from time\n",
        "    time_factor = np.sin(np.pi * t)\n",
        "\n",
        "    # Compute the scaling factor from space\n",
        "    (x,y,z) = np.transpose(pt)\n",
        "    space_factor = y*z\n",
        "\n",
        "    # Combine the factors\n",
        "    rho_factor = np.tensordot(time_factor, space_factor, axes = 0)\n",
        "\n",
        "    return rho_factor\n",
        "\n",
        "\n",
        "def great_circle_map(pt, t, discontinuities=\"one\", distend=0, epsilon=0.01):\n",
        "    \"\"\"\n",
        "    Parameters\n",
        "    ----------\n",
        "    pt : NumPy array (M,3), parallelizable\n",
        "        Point on the unit sphere\n",
        "\n",
        "    t : float or NumPy array (N,)\n",
        "        Time elapsed (between 0 and 1)\n",
        "\n",
        "    discontinuities : str\n",
        "        Specifies where the direction field can be discontinuous.\n",
        "        Three options:\n",
        "            \"equator\"\n",
        "            \"two\"\n",
        "            \"one\"\n",
        "\n",
        "    distend : float or NumPy array (T,)\n",
        "        Amount to distend from spherical surface\n",
        "\n",
        "    epsilon : float\n",
        "        Determines error used in dealing with discontinuities\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    new_pts : NumPy array (N,T,M,3), parallelizable\n",
        "        Location of pt after time t\n",
        "    \"\"\"\n",
        "\n",
        "    # Sanitize inputs\n",
        "    times = sanitize_scalar(t)\n",
        "    dist_factors = sanitize_scalar(distend)\n",
        "    pts = sanitize_3D_vector(pt)\n",
        "\n",
        "    # Calculate initial unit vectors\n",
        "    units = direction_field(pts, discontinuities, epsilon)\n",
        "\n",
        "    # Compute weights for the great circle map\n",
        "    scaled_times = np.pi * times\n",
        "    u1 = np.cos(scaled_times)\n",
        "    u2 = np.sin(scaled_times)\n",
        "\n",
        "    # Compute linear combination using the constructed weights\n",
        "    base_pts = (np.tensordot(u1, pts,axes=0) + np.tensordot(u2, units,axes=0))\n",
        "\n",
        "    # Compute distension factors\n",
        "    rho_factors = distension(pts, times)\n",
        "    full_factors = 1 + np.tensordot(rho_factors, dist_factors,axes=0)\n",
        "\n",
        "    # Reshape the base points and the scaling factors so that they can be multiplied together cleanly\n",
        "    base_pts_reshaped = np.expand_dims(base_pts, axis=2)\n",
        "    factors_reshaped = np.expand_dims(full_factors, axis=-1)\n",
        "\n",
        "    # Combine and then reshape the array for convenience\n",
        "    new_pts = base_pts_reshaped * factors_reshaped\n",
        "    new_pts = new_pts.transpose((0,2,1,3))\n",
        "\n",
        "    return new_pts\n",
        "\n",
        "\n",
        "### TEST FUNCTIONS\n",
        "\n",
        "def test_direction_field(num_pts=1000,epsilon=0.001):\n",
        "    \"\"\"\n",
        "    Function to test correctness of direction_field\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    num_pts : int\n",
        "        Number of points on sphere to test. The default is 1000.\n",
        "    epsilon : float\n",
        "        Acceptable error. The default is 0.001.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    None\n",
        "    \"\"\"\n",
        "\n",
        "    points = fibonacci_sphere(num_pts)\n",
        "\n",
        "\n",
        "    failed_counts = {\"equator\":0,\"two\":0,\"one\":0}\n",
        "\n",
        "    for disc in [\"equator\",\"two\",\"one\"]:\n",
        "        field = direction_field(points,discontinuities=disc,epsilon=epsilon)\n",
        "        dots = (points*field).sum(axis=1)\n",
        "\n",
        "        failures = (abs(dots) >= epsilon).sum(axis=0)\n",
        "        failed_counts[disc] = failures\n",
        "\n",
        "    print(\"Number of points where the direction field failed to be orthogonal to the sphere.\")\n",
        "    print(\"\")\n",
        "\n",
        "    for key in failed_counts.keys():\n",
        "        value = failed_counts[key]\n",
        "\n",
        "        print(f\"{key}: {value} points\")\n",
        "\n",
        "    print(\"\")\n",
        "    print(\"Count completed.\")        \n",
        "    return None\n",
        "\n",
        "\n",
        "def test_great_circle_map(discontinuities=\"one\"):\n",
        "    \"\"\"\n",
        "    Tests correctness of great_circle_map\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    discontinuities : str\n",
        "        Selects base vector field. The default is \"one\".\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    None.\n",
        "\n",
        "    \"\"\"\n",
        "\n",
        "    # Define acceptable error\n",
        "    epsilon = 0.000001\n",
        "\n",
        "    # Initialize points on the sphere to try\n",
        "    pts = fibonacci_sphere(15)\n",
        "\n",
        "    # Initialize distension amounts\n",
        "    distends = [0.1*x for x in range(11)]\n",
        "\n",
        "    # Initialize first batch of points\n",
        "    end_pts = great_circle_map(pts,[0,1],discontinuities=discontinuities,distend=distends)\n",
        "\n",
        "    # Check whether dimensions match what they should be\n",
        "    pts_dims = end_pts.shape\n",
        "\n",
        "    if len(pts_dims) != 4:\n",
        "        print(\"Warning! Array has an incorrect number of dimensions.\")\n",
        "\n",
        "    elif pts_dims != (2,len(distends),len(pts),3):\n",
        "        print(\"Warning: Dimensions of array are incorrect.\")\n",
        "\n",
        "    else:\n",
        "        print(\"Array has expected dimensions.\")\n",
        "        print(\"\")\n",
        "\n",
        "    # Separate points belonging to the beginning and end of the homotopy\n",
        "    beginning = end_pts[0]\n",
        "    ending = end_pts[1]\n",
        "\n",
        "    identity_pass = True\n",
        "    antipode_pass = True\n",
        "\n",
        "    # Go through all copies of beginning; see if they match the identity\n",
        "    for distend,pts_copy in zip(distends,beginning):\n",
        "        if np.linalg.norm(pts-pts_copy) > epsilon:\n",
        "            if identity_pass:\n",
        "                print(\"Warning! At time t=0, non-identity map at distensions:\")\n",
        "\n",
        "            identity_pass = False\n",
        "\n",
        "            print(distend)\n",
        "\n",
        "    # If there have been no errors, print success\n",
        "    if identity_pass:\n",
        "        print(\"Homotopy correctly defaults to identity at time t=0\")\n",
        "        print(\"No dependence on distension\")\n",
        "\n",
        "    print(\"\")\n",
        "\n",
        "    # Go through all copies of ending; see if they match antipode\n",
        "    for distend,pts_copy in zip(distends,ending):\n",
        "        if np.linalg.norm(pts+pts_copy) > epsilon:\n",
        "            if antipode_pass :\n",
        "                print(\"Warning! At time t=1, non-antipode map at distensions:\")\n",
        "\n",
        "            antipode_pass = False\n",
        "\n",
        "            print(distend)\n",
        "\n",
        "    # If there have been no errors, print success\n",
        "    if antipode_pass:\n",
        "        print(\"Homotopy correctly defaults to antipode at time t=1\")\n",
        "        print(\"No dependence on distension\")\n",
        "\n",
        "    print(\"\")\n",
        "\n",
        "    # Initialize second batch of points\n",
        "    halfway_pts = great_circle_map(pts,1/2,discontinuities=discontinuities)[0][0]\n",
        "\n",
        "    # At zero distension, halfway points should be sqrt(2) away from where they started\n",
        "\n",
        "    # Compute distance between halfway points and original\n",
        "    distances = np.linalg.norm(halfway_pts-pts,axis=1)\n",
        "\n",
        "    # Compute discrepancy away from sqrt(2) expected distance\n",
        "    discrepancies = np.abs(distances - np.sqrt(2))\n",
        "\n",
        "    # Check whether maximum discrepancy is larger than the tolerance\n",
        "    if np.max(discrepancies) > epsilon:\n",
        "        print(\"Warning! Points tested at the halfway point at zero distension are in the wrong position.\")\n",
        "    else:\n",
        "        print(\"Points are halfway around the great circle at t=1/2 with distension 0.\")\n",
        "\n",
        "    print(\"\")\n",
        "\n",
        "    # Initialize third batch of points\n",
        "    infinitesimal_pts = great_circle_map(pts,epsilon**2,discontinuities=discontinuities)[0][0]\n",
        "\n",
        "    # At zero distension, moving points an infinitesimal amount should agree with the underlying vector field\n",
        "\n",
        "    # Compute difference in positions to get velocity\n",
        "    velocities_actual = infinitesimal_pts - beginning[0]\n",
        "\n",
        "    # Compute underlying field and rescale\n",
        "    units = direction_field(pts,discontinuities=discontinuities)\n",
        "    velocities_expected = units * np.pi * (epsilon**2)\n",
        "\n",
        "    # Compute differences between velocities\n",
        "    velocity_discrepancy = np.linalg.norm(velocities_actual - velocities_expected,axis=1)\n",
        "\n",
        "    if np.max(velocity_discrepancy) > epsilon:\n",
        "        print(\"Warning! Points do not appear to move in the direction of the vector field.\")\n",
        "    else:\n",
        "        print(\"Points move in the direction of the vector field.\")\n",
        "\n",
        "    print(\"\")\n",
        "\n",
        "    # Compute fourth batch of points\n",
        "    # Choose a selection of random times between 0 and 1\n",
        "    times=np.random.rand(5)\n",
        "    distension_pts = great_circle_map(pts,times,discontinuities=discontinuities,distend=distends)\n",
        "\n",
        "    # Pull out subarray with zero distension\n",
        "    zero_distension_pts = distension_pts[0:,0:1,0:,0:]\n",
        "\n",
        "    # Compute norms of all points and normalize\n",
        "    norms = np.expand_dims(np.linalg.norm(distension_pts,axis=-1),axis=-1)\n",
        "    normalized_pts = distension_pts/norms\n",
        "\n",
        "    # Normalized points should match zero distension ones\n",
        "    differences = normalized_pts - zero_distension_pts\n",
        "    discrepancies = np.linalg.norm(differences,axis=-1)\n",
        "\n",
        "    if np.max(discrepancies) > epsilon:\n",
        "        print(\"Warning! Discrepancy is shifting the directions of points, not just radially.\")\n",
        "    else:\n",
        "        print(\"Discrepancy moves points only radially.\")\n",
        "\n",
        "    print(\"\")\n",
        "    print(\"All tests completed.\")\n",
        "\n",
        "    return None\n",
        "\n",
        "\n",
        "## Manim Scenes\n",
        "\n",
        "def spherical_surface(theta, phi):\n",
        "    X = np.sin(phi) * np.cos(theta)\n",
        "    Y = np.sin(phi) * np.sin(theta)\n",
        "    Z = np.cos(phi)\n",
        "    return np.array([[X, Y, Z]])\n",
        "\n",
        "\n",
        "def spherical_eversion(theta, phi, t):\n",
        "    pt = spherical_surface(theta, phi)\n",
        "    new_pt = great_circle_map(pt, t, discontinuities=\"one\", distend=0.5)\n",
        "    return new_pt[0][0][0]\n",
        "\n",
        "\n",
        "class SurfaceTestForSenia(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        axes = ThreeDAxes()\n",
        "\n",
        "        time_tracker = ValueTracker(0)\n",
        "\n",
        "        def get_surface(t):\n",
        "            return ParametricSurface(\n",
        "                lambda u, v: spherical_eversion(u, v, t),\n",
        "                u_range=(0, 2 * PI),\n",
        "                v_range=(0.1, PI),\n",
        "                resolution=(25, 25),\n",
        "            )\n",
        "\n",
        "        def update_surface(surface):\n",
        "            surface.match_points(get_surface(time_tracker.get_value()))\n",
        "\n",
        "        surface = TexturedSurface(get_surface(0), \"Tower2\")\n",
        "\n",
        "        self.frame.reorient(-3, 60, 0, (-0.02, 0.05, 0.09), 4.26)  # Use shift-D to copy frame state\n",
        "        self.add(axes)\n",
        "        self.add(surface)\n",
        "        self.play(\n",
        "            time_tracker.animate.set_value(1).set_anim_args(rate_func=linear),\n",
        "            UpdateFromFunc(surface, update_surface),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(surface),\n",
        "            self.frame.animate.reorient(41, 70, 0, (-0.17, 0.22, 0.06), 5.33)\n",
        "        )"
    ]
}