{
    "topic": "The mathematical concept being demonstrated is the creation of a binary tree, where each node has two children",
    "code": [
        "from mobject.geometry import *\n",
        "from _2018.eop.reusables.eop_helpers import *\n",
        "from _2018.eop.reusables.eop_constants import *\n",
        "\n",
        "class CoinFlipTree(VGroup):\n",
        "    CONFIG = {\n",
        "        \"total_width\": 12,\n",
        "        \"level_height\": 0.8,\n",
        "        \"nb_levels\": 4,\n",
        "        \"sort_until_level\": 3\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "\n",
        "        self.rows = []\n",
        "        for n in range(self.nb_levels + 1):\n",
        "            if n <= self.sort_until_level:\n",
        "                self.create_row(n, sorted = True)\n",
        "            else:\n",
        "                self.create_row(n, sorted = False)\n",
        "            \n",
        "\n",
        "        for row in self.rows:\n",
        "            for leaf in row:\n",
        "                dot = Dot()\n",
        "                dot.move_to(leaf[0])\n",
        "                line = Line(leaf[2], leaf[0])\n",
        "                if leaf[2][0] > leaf[0][0]:\n",
        "                    line_color = COLOR_HEADS\n",
        "                else:\n",
        "                    line_color = COLOR_TAILS\n",
        "                line.set_stroke(color = line_color)\n",
        "                group = VGroup()\n",
        "                group.add(dot)\n",
        "                group.add_to_back(line)\n",
        "                self.add(group)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def create_row(self, level, sorted = True):\n",
        "\n",
        "        if level == 0:\n",
        "            new_row = [[ORIGIN,0,ORIGIN]] # is its own parent\n",
        "            self.rows.append(new_row)\n",
        "            return\n",
        "\n",
        "        previous_row = self.rows[level - 1]\n",
        "        new_row = []\n",
        "        dx = float(self.total_width) / (2 ** level)\n",
        "        x = - 0.5 * self.total_width + 0.5 * dx\n",
        "        y = - self.level_height * level\n",
        "        for root in previous_row:\n",
        "            root_point = root[0]\n",
        "            root_tally = root[1]\n",
        "            for i in range(2): # 0 = heads = left, 1 = tails = right\n",
        "                leaf = x * RIGHT + y * UP\n",
        "                new_row.append([leaf, root_tally + i, root_point]) # leaf and its parent\n",
        "                x += dx\n",
        "\n",
        "        if sorted:\n",
        "            # sort the new_row by its tallies\n",
        "            sorted_row = []\n",
        "            x = - 0.5 * self.total_width + 0.5 * dx\n",
        "            for i in range(level + 1):\n",
        "                for leaf in new_row:\n",
        "                    if leaf[1] == i:\n",
        "                        sorted_leaf = leaf\n",
        "                        sorted_leaf[0][0] = x\n",
        "                        x += dx\n",
        "                        sorted_row.append(leaf)\n",
        "            self.rows.append(sorted_row)\n",
        "        else:\n",
        "            self.rows.append(new_row)\n"
    ]
}