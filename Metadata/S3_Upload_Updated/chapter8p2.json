{
    "topic": "The mathematical concept being demonstrated is the cross product of two vectors, which is a way to compute the",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2016.eola.chapter5 import get_det_text\n",
        "from _2016.eola.chapter8 import *\n",
        "\n",
        "\n",
        "class OpeningQuote(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"From [Grothendieck], I have also learned not\",\n",
        "            \"to take glory in the \", \n",
        "            \"difficulty of a proof:\", \n",
        "            \"difficulty means we have not understood.\",\n",
        "            \"The idea is to be able to \",\n",
        "            \"paint a landscape\",\n",
        "            \"in which the proof is obvious.\",\n",
        "            arg_separator = \" \"\n",
        "        )\n",
        "        words.set_color_by_tex(\"difficulty of a proof:\", RED)\n",
        "        words.set_color_by_tex(\"paint a landscape\", GREEN)\n",
        "        words.set_width(FRAME_WIDTH - 2)\n",
        "        words.to_edge(UP)\n",
        "        author = OldTexText(\"-Pierre Deligne\")\n",
        "        author.set_color(YELLOW)\n",
        "        author.next_to(words, DOWN, buff = 0.5)\n",
        "\n",
        "        self.play(FadeIn(words))\n",
        "        self.wait(4)\n",
        "        self.play(Write(author, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "class CrossProductSymbols(Scene):\n",
        "    def construct(self):\n",
        "        v_tex, w_tex, p_tex = get_vect_tex(*\"vwp\")\n",
        "        equation = OldTex(\n",
        "            v_tex, \"\\\\times\", w_tex, \"=\", p_tex\n",
        "        )\n",
        "        equation.set_color_by_tex(v_tex, V_COLOR)\n",
        "        equation.set_color_by_tex(w_tex, W_COLOR)\n",
        "        equation.set_color_by_tex(p_tex, P_COLOR)\n",
        "        brace = Brace(equation[-1])\n",
        "        brace.stretch_to_fit_width(0.7)\n",
        "        vector_text = brace.get_text(\"Vector\")\n",
        "        vector_text.set_color(RED)\n",
        "        self.add(equation)\n",
        "        self.play(*list(map(Write, [brace, vector_text])))\n",
        "        self.wait()\n",
        "\n",
        "class DeterminantTrickCopy(DeterminantTrick):\n",
        "    pass\n",
        "\n",
        "class BruteForceVerification(Scene):\n",
        "    def construct(self):\n",
        "        v = Matrix([\"v_1\", \"v_2\", \"v_3\"])\n",
        "        w = Matrix([\"w_1\", \"w_2\", \"w_3\"])\n",
        "        v1, v2, v3 = v.get_entries()\n",
        "        w1, w2, w3 = w.get_entries()\n",
        "        v.set_color(V_COLOR)\n",
        "        w.set_color(W_COLOR)\n",
        "        def get_term(e1, e2, e3, e4):\n",
        "            group = VGroup(\n",
        "                e1.copy(), e2.copy(), \n",
        "                OldTex(\"-\"),\n",
        "                e3.copy(), e4.copy(),\n",
        "            )\n",
        "            group.arrange()\n",
        "            return group\n",
        "        cross = Matrix(list(it.starmap(get_term, [\n",
        "            (v2, w3, v3, w2),\n",
        "            (v3, w1, v1, w3),\n",
        "            (v1, w2, v2, w1),\n",
        "        ])))\n",
        "        cross_product = VGroup(\n",
        "            v.copy(), OldTex(\"\\\\times\"), w.copy(),\n",
        "            OldTex(\"=\"), cross.copy()\n",
        "        )\n",
        "        cross_product.arrange()\n",
        "        cross_product.scale(0.75)\n",
        "\n",
        "        formula_word = OldTexText(\"Numerical formula\")\n",
        "        computation_words = OldTexText(\"\"\"\n",
        "            Facts you could (painfully)\n",
        "            verify computationally\n",
        "        \"\"\")\n",
        "        computation_words.scale(0.75)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        computation_words.to_edge(UP, buff = MED_SMALL_BUFF/2)\n",
        "        h_line.next_to(computation_words, DOWN)\n",
        "        formula_word.next_to(h_line, UP, buff = MED_SMALL_BUFF)\n",
        "        computation_words.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        formula_word.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "\n",
        "        cross_product.next_to(formula_word, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        self.add(formula_word, computation_words)\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            ShowCreation(v_line),\n",
        "            Write(cross_product)\n",
        "        )\n",
        "\n",
        "        v_tex, w_tex = get_vect_tex(*\"vw\")\n",
        "        v_dot, w_dot = [\n",
        "            OldTex(\n",
        "                tex, \"\\\\cdot\", \n",
        "                \"(\", v_tex, \"\\\\times\", w_tex, \")\",\n",
        "                \"= 0\"\n",
        "            )\n",
        "            for tex in (v_tex, w_tex)\n",
        "        ]\n",
        "        theta_def = OldTex(\n",
        "            \"\\\\theta\", \n",
        "            \"= \\\\cos^{-1} \\\\big(\", v_tex, \"\\\\cdot\", w_tex, \"/\",\n",
        "            \"(||\", v_tex, \"||\", \"\\\\cdot\", \"||\", w_tex, \"||)\", \"\\\\big)\"\n",
        "        )\n",
        "\n",
        "        length_check = OldTex(\n",
        "            \"||\", \"(\", v_tex, \"\\\\times\", w_tex, \")\", \"|| = \",\n",
        "            \"(||\", v_tex, \"||)\",\n",
        "            \"(||\", w_tex, \"||)\",\n",
        "            \"\\\\sin(\", \"\\\\theta\", \")\"\n",
        "        )\n",
        "        last_point = h_line.get_center()+FRAME_X_RADIUS*RIGHT/2\n",
        "        max_width = FRAME_X_RADIUS-1\n",
        "        for mob in v_dot, w_dot, theta_def, length_check:\n",
        "            mob.set_color_by_tex(v_tex, V_COLOR)\n",
        "            mob.set_color_by_tex(w_tex, W_COLOR)\n",
        "            mob.set_color_by_tex(\"\\\\theta\", GREEN)\n",
        "            mob.next_to(last_point, DOWN, buff = MED_SMALL_BUFF)\n",
        "            if mob.get_width() > max_width:\n",
        "                mob.set_width(max_width)\n",
        "            last_point = mob\n",
        "            self.play(FadeIn(mob))\n",
        "        self.wait()\n",
        "\n",
        "class ButWeCanDoBetter(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"But we can do \\\\\\\\ better than that\")\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "class Prerequisites(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Prerequisites\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(YELLOW)\n",
        "\n",
        "        rect = Rectangle(width = 16, height = 9, color = BLUE)\n",
        "        rect.set_width(FRAME_X_RADIUS - 1)\n",
        "        left_rect, right_rect = [\n",
        "            rect.copy().shift(DOWN/2).to_edge(edge)\n",
        "            for edge in (LEFT, RIGHT)\n",
        "        ]\n",
        "        chapter5 = OldTexText(\"\"\"\n",
        "            \\\\centering \n",
        "            Chapter 5 \n",
        "            Determinants\n",
        "        \"\"\")\n",
        "        chapter7 = OldTexText(\"\"\"\n",
        "            \\\\centering\n",
        "            Chapter 7: \n",
        "            Dot products and duality\n",
        "        \"\"\")\n",
        "\n",
        "        self.add(title)\n",
        "        for chapter, rect in (chapter5, left_rect), (chapter7, right_rect):\n",
        "            if chapter.get_width() > rect.get_width():\n",
        "                chapter.set_width(rect.get_width())\n",
        "            chapter.next_to(rect, UP)\n",
        "            self.play(\n",
        "                Write(chapter5), \n",
        "                ShowCreation(left_rect)\n",
        "            )\n",
        "        self.play(\n",
        "            Write(chapter7),\n",
        "            ShowCreation(right_rect)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class DualityReview(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Quick\", \"duality\", \"review\")\n",
        "        words[1].set_color_by_gradient(BLUE, YELLOW)\n",
        "        self.teacher_says(words, target_mode = \"surprised\")\n",
        "        self.play_student_changes(\"pondering\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class DotProductToTransformSymbol(Scene):\n",
        "    CONFIG = {\n",
        "        \"vect_coords\" : [2, 1]\n",
        "    }\n",
        "    def construct(self):\n",
        "        v_mob = OldTex(get_vect_tex(\"v\"))\n",
        "        v_mob.set_color(V_COLOR)\n",
        "\n",
        "        matrix = Matrix([self.vect_coords])\n",
        "        vector = Matrix(self.vect_coords)\n",
        "        matrix.set_column_colors(X_COLOR, Y_COLOR)\n",
        "        vector.set_column_colors(YELLOW)\n",
        "        _input = Matrix([\"x\", \"y\"])\n",
        "        _input.get_entries().set_color_by_gradient(X_COLOR, Y_COLOR)\n",
        "        left_input, right_input = [_input.copy() for x in range(2)]\n",
        "        dot, equals = list(map(Tex, [\"\\\\cdot\", \"=\"]))\n",
        "        equation = VGroup(\n",
        "            vector, dot, left_input, equals,\n",
        "            matrix, right_input\n",
        "        )\n",
        "        equation.arrange()\n",
        "        left_brace = Brace(VGroup(vector, left_input))\n",
        "        right_brace = Brace(matrix, UP)\n",
        "        left_words = left_brace.get_text(\"Dot product\")\n",
        "        right_words = right_brace.get_text(\"Transform\")\n",
        "        right_words.set_width(right_brace.get_width())\n",
        "\n",
        "        right_v_brace = Brace(right_input, UP)\n",
        "        right_v_mob = v_mob.copy()\n",
        "        right_v_brace.put_at_tip(right_v_mob)\n",
        "        right_input.add(right_v_brace, right_v_mob)\n",
        "        left_v_brace = Brace(left_input, UP)\n",
        "        left_v_mob = v_mob.copy()\n",
        "        left_v_brace.put_at_tip(left_v_mob)\n",
        "        left_input.add(left_v_brace, left_v_mob)        \n",
        "\n",
        "\n",
        "        self.add(matrix, right_input)\n",
        "        self.play(\n",
        "            GrowFromCenter(right_brace),\n",
        "            Write(right_words, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(dot),\n",
        "            Transform(matrix.copy(), vector),\n",
        "            Transform(right_input.copy(), left_input)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(left_brace),\n",
        "            Write(left_words, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class MathematicalWild(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"In the mathematical wild\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.shift(DOWN)\n",
        "        bubble = ThoughtBubble(width = 5, height = 4)\n",
        "        bubble.write(\"\"\"\n",
        "            \\\\centering\n",
        "            Some linear \n",
        "            transformation\n",
        "            to the number line\n",
        "        \"\"\")\n",
        "        bubble.content.set_color(BLUE)\n",
        "        bubble.content.shift(MED_SMALL_BUFF*UP/2)\n",
        "        bubble.remove(*bubble[:-1])\n",
        "        bubble.add(bubble.content)\n",
        "        bubble.next_to(randy.get_corner(UP+RIGHT), RIGHT)\n",
        "        vector = Vector([1, 2])\n",
        "        vector.move_to(randy.get_corner(UP+LEFT), aligned_edge = DOWN+LEFT)\n",
        "        dual_words = OldTexText(\"Dual vector\")\n",
        "        dual_words.set_color_by_gradient(BLUE, YELLOW)\n",
        "        dual_words.next_to(vector, LEFT)\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(FadeIn(bubble))\n",
        "        self.play(randy.change_mode, \"sassy\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.look, UP+LEFT)\n",
        "        self.play(\n",
        "            ShowCreation(vector),\n",
        "            randy.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(dual_words))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class ThreeStepPlan(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"The plan\")\n",
        "        title.set_color(YELLOW)\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        v_tex, w_tex = get_vect_tex(*\"vw\")\n",
        "        v_text, w_text, cross_text = [\n",
        "            \"$%s$\"%s \n",
        "            for s in (v_tex, w_tex, v_tex + \"\\\\times\" + w_tex)\n",
        "        ]\n",
        "        steps = [\n",
        "            OldTexText(\n",
        "                \"1. Define a 3d-to-1d\", \"linear \\\\\\\\\", \"transformation\",\n",
        "                \"in terms of\", v_text, \"and\", w_text\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"2. Find its\", \"dual vector\"\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"3. Show that this dual is\", cross_text\n",
        "            )\n",
        "        ]\n",
        "        linear, transformation = steps[0][1:1+2]\n",
        "        steps[0].set_color_by_tex(v_text, V_COLOR)\n",
        "        steps[0].set_color_by_tex(w_text, W_COLOR)\n",
        "        steps[1][1].set_color_by_gradient(BLUE, YELLOW)\n",
        "        steps[2].set_color_by_tex(cross_text, P_COLOR)\n",
        "        VGroup(*steps).arrange(\n",
        "            DOWN, aligned_edge = LEFT, buff = LARGE_BUFF\n",
        "        ).next_to(h_line, DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(h_line))\n",
        "        for step in steps:\n",
        "            self.play(Write(step, run_time = 2))\n",
        "            self.wait()\n",
        "\n",
        "        linear_transformation = OldTexText(\"Linear\", \"transformation\")\n",
        "        linear_transformation.next_to(h_line, DOWN, MED_SMALL_BUFF)\n",
        "        det = self.get_det()\n",
        "        rect = Rectangle(width = 16, height = 9, color = BLUE)\n",
        "        rect.set_height(3.5)\n",
        "        left_right_arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        left_right_arrow.shift(DOWN)\n",
        "        det.next_to(left_right_arrow, LEFT)\n",
        "        rect.next_to(left_right_arrow, RIGHT)\n",
        "\n",
        "        steps[0].remove(linear, transformation)\n",
        "        self.play(\n",
        "            Transform(\n",
        "                VGroup(linear, transformation), \n",
        "                linear_transformation\n",
        "            ),\n",
        "            *list(map(FadeOut, steps))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(left_right_arrow))\n",
        "        self.play(Write(det))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait(0)\n",
        "\n",
        "    def get_det(self):\n",
        "        matrix = Matrix(np.array([\n",
        "            [\"\\\\hat{\\\\imath}\", \"\\\\hat{\\\\jmath}\", \"\\\\hat{k}\"],\n",
        "            [\"v_%d\"%d for d in range(1, 4)],\n",
        "            [\"w_%d\"%d for d in range(1, 4)],\n",
        "        ]).T)\n",
        "        matrix.set_column_colors(X_COLOR, V_COLOR, W_COLOR)\n",
        "        matrix.get_mob_matrix()[1, 0].set_color(Y_COLOR)\n",
        "        matrix.get_mob_matrix()[2, 0].set_color(Z_COLOR)\n",
        "        VGroup(*matrix.get_mob_matrix()[1, 1:]).shift(0.15*DOWN)\n",
        "        VGroup(*matrix.get_mob_matrix()[2, 1:]).shift(0.35*DOWN)\n",
        "        det_text = get_det_text(matrix)\n",
        "        det_text.add(matrix)\n",
        "        return det_text\n",
        "\n",
        "class DefineDualTransform(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_triple_cross_product()\n",
        "        self.write_function()\n",
        "        self.introduce_dual_vector()\n",
        "        self.expand_dot_product()\n",
        "        self.ask_question()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"What a student might think\")\n",
        "        title.not_real = OldTexText(\"Not the real cross product\")\n",
        "        for mob in title, title.not_real:\n",
        "            mob.set_width(FRAME_X_RADIUS - 1)\n",
        "            mob.set_color(RED)\n",
        "            mob.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_triple_cross_product(self):\n",
        "        colors = [WHITE, ORANGE, W_COLOR]\n",
        "        tex_mobs = list(map(Tex, get_vect_tex(*\"uvw\")))\n",
        "        u_tex, v_tex, w_tex = tex_mobs\n",
        "        arrays = [\n",
        "            Matrix([\"%s_%d\"%(s, d) for d in range(1, 4)])\n",
        "            for s in \"uvw\"\n",
        "        ]\n",
        "        defs_equals = VGroup()\n",
        "        definitions = VGroup()\n",
        "        for array, tex_mob, color in zip(arrays, tex_mobs, colors):\n",
        "            array.set_column_colors(color)\n",
        "            tex_mob.set_color(color)\n",
        "            equals = OldTex(\"=\")\n",
        "            definition = VGroup(tex_mob, equals, array)\n",
        "            definition.arrange(RIGHT)\n",
        "            definitions.add(definition)\n",
        "            defs_equals.add(equals)\n",
        "        definitions.arrange(buff = MED_SMALL_BUFF)\n",
        "        definitions.shift(2*DOWN)\n",
        "\n",
        "        mobs_with_targets = list(it.chain(\n",
        "            tex_mobs, *[a.get_entries() for a in arrays]\n",
        "        ))\n",
        "        for mob in mobs_with_targets:\n",
        "            mob.target = mob.copy()\n",
        "        matrix = Matrix(np.array([\n",
        "            [e.target for e in array.get_entries()]\n",
        "            for array in arrays\n",
        "        ]).T)\n",
        "        det_text = get_det_text(matrix, background_rect = False)\n",
        "        syms = times1, times2, equals = [\n",
        "            OldTex(sym) \n",
        "            for sym in (\"\\\\times\", \"\\\\times\", \"=\",)\n",
        "        ]\n",
        "        triple_cross = VGroup(\n",
        "            u_tex.target, times1, v_tex.target, times2, w_tex.target, equals\n",
        "        )\n",
        "        triple_cross.arrange()\n",
        "\n",
        "        final_mobs = VGroup(triple_cross, VGroup(det_text, matrix))\n",
        "        final_mobs.arrange()\n",
        "        final_mobs.next_to(self.title, DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        for mob in definitions, final_mobs:\n",
        "            mob.set_width(FRAME_X_RADIUS - 1)\n",
        "\n",
        "        for array in arrays:\n",
        "            brackets = array.get_brackets()\n",
        "            brackets.target = matrix.get_brackets()\n",
        "            mobs_with_targets.append(brackets)\n",
        "        for def_equals in defs_equals:\n",
        "            def_equals.target = equals\n",
        "            mobs_with_targets.append(def_equals)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            definitions,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            Transform(mob.copy(), mob.target)\n",
        "            for mob in tex_mobs\n",
        "        ] + [\n",
        "            Write(times1),\n",
        "            Write(times2),\n",
        "        ])\n",
        "        triple_cross.add(*self.get_mobjects_from_last_animation()[:3])\n",
        "        self.play(*[\n",
        "            Transform(mob.copy(), mob.target)\n",
        "            for mob in mobs_with_targets\n",
        "            if mob not in tex_mobs\n",
        "        ])\n",
        "        u_entries = self.get_mobjects_from_last_animation()[:3]\n",
        "        v_entries = self.get_mobjects_from_last_animation()[3:6]\n",
        "        w_entries = self.get_mobjects_from_last_animation()[6:9]\n",
        "        self.play(Write(det_text))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.det_text = det_text\n",
        "        self.definitions = definitions\n",
        "        self.u_entries = u_entries\n",
        "        self.v_entries = v_entries\n",
        "        self.w_entries = w_entries\n",
        "        self.matrix = matrix\n",
        "        self.triple_cross = triple_cross\n",
        "        self.v_tex, self.w_tex = v_tex, w_tex\n",
        "        self.equals = equals\n",
        "\n",
        "    def write_function(self):\n",
        "        brace = Brace(self.det_text, DOWN)\n",
        "        number_text = brace.get_text(\"Number\")\n",
        "        self.play(Transform(self.title, self.title.not_real))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(self.definitions))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(number_text)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        x, y, z = variables = list(map(Tex, \"xyz\"))\n",
        "        for var, entry in zip(variables, self.u_entries):\n",
        "            var.scale(0.8) \n",
        "            var.move_to(entry)\n",
        "            entry.target = var\n",
        "        brace.target = Brace(z)\n",
        "        brace.target.stretch_to_fit_width(0.5)\n",
        "        number_text.target = brace.target.get_text(\"Variable\")\n",
        "        v_brace = Brace(self.matrix.get_mob_matrix()[0, 1], UP)\n",
        "        w_brace = Brace(self.matrix.get_mob_matrix()[0, 2], UP)\n",
        "        for vect_brace, tex in (v_brace, self.v_tex), (w_brace, self.w_tex):\n",
        "            vect_brace.stretch_to_fit_width(brace.target.get_width())\n",
        "            new_tex = tex.copy()\n",
        "            vect_brace.put_at_tip(new_tex)\n",
        "            vect_brace.tex = new_tex\n",
        "        func_tex = OldTex(\n",
        "            \"f\\\\left(%s\\\\right)\"%matrix_to_tex_string(list(\"xyz\"))\n",
        "        )\n",
        "        func_tex.scale(0.7)\n",
        "        func_input = Matrix(list(\"xyz\"))\n",
        "        func_input_template = VGroup(*func_tex[3:-2])\n",
        "        func_input.set_height(func_input_template.get_height())\n",
        "        func_input.next_to(VGroup(*func_tex[:3]), RIGHT)\n",
        "        VGroup(*func_tex[-2:]).next_to(func_input, RIGHT)\n",
        "        func_tex[0].scale(1.5)\n",
        "\n",
        "        func_tex = VGroup(\n",
        "            VGroup(*[func_tex[i] for i in (0, 1, 2, -2, -1)]),\n",
        "            func_input\n",
        "        )\n",
        "        func_tex.next_to(self.equals, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.title),\n",
        "            FadeOut(self.triple_cross),\n",
        "            *[\n",
        "                Transform(mob, mob.target)\n",
        "                for mob in [brace, number_text]\n",
        "            ]\n",
        "        )\n",
        "        self.play(*[\n",
        "            Transform(mob, mob.target)\n",
        "            for mob in self.u_entries\n",
        "        ])\n",
        "        self.play(*[\n",
        "            Write(VGroup(vect_brace, vect_brace.tex))\n",
        "            for vect_brace in (v_brace, w_brace)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(Write(func_tex))\n",
        "        self.wait()\n",
        "\n",
        "        self.func_tex = func_tex\n",
        "        self.variables_text = VGroup(brace, number_text)\n",
        "\n",
        "    def introduce_dual_vector(self):\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        colors = [X_COLOR, Y_COLOR, Z_COLOR]\n",
        "        q_marks = VGroup(*list(map(TexText, \"???\")))\n",
        "        q_marks.scale(2)\n",
        "        q_marks.set_color_by_gradient(*colors)\n",
        "\n",
        "        title = VGroup(OldTexText(\"This function is linear\"))\n",
        "        title.set_color(GREEN)\n",
        "        title.to_edge(UP)\n",
        "        matrix = Matrix([list(q_marks.copy())])\n",
        "        matrix.set_height(self.func_tex.get_height()/2)\n",
        "        dual_vector = Matrix(list(q_marks))\n",
        "        dual_vector.set_height(self.func_tex.get_height())\n",
        "        dual_vector.get_brackets()[0].shift(0.2*LEFT)\n",
        "        dual_vector.get_entries().shift(0.1*LEFT)\n",
        "        dual_vector.scale(1.25)\n",
        "        dual_dot = VGroup(\n",
        "            dual_vector,\n",
        "            OldTex(\"\\\\cdot\").next_to(dual_vector)\n",
        "        )\n",
        "        matrix_words = OldTexText(\"\"\"\n",
        "            $1 \\\\times 3$ matrix encoding the \n",
        "            3d-to-1d linear transformation\n",
        "        \"\"\")\n",
        "\n",
        "        self.play(\n",
        "            Write(title, run_time = 2),\n",
        "            everything.shift, DOWN\n",
        "        )\n",
        "        self.remove(everything)\n",
        "        self.add(*everything)\n",
        "        self.wait()\n",
        "\n",
        "        func, func_input = self.func_tex\n",
        "        func_input.target = func_input.copy()\n",
        "        func_input.target.scale(1.2)\n",
        "        func_input.target.move_to(self.func_tex, aligned_edge = RIGHT)\n",
        "        matrix.next_to(func_input.target, LEFT)\n",
        "        dual_dot.next_to(func_input.target, LEFT)\n",
        "        matrix_words.next_to(matrix, DOWN, buff = 1.5)\n",
        "        matrix_words.shift_onto_screen()\n",
        "        matrix_arrow = Arrow(\n",
        "            matrix_words.get_top(),\n",
        "            matrix.get_bottom(),\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(func, matrix),\n",
        "            MoveToTarget(func_input),\n",
        "            FadeOut(self.variables_text),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(matrix_words),\n",
        "            ShowCreation(matrix_arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [matrix_words, matrix_arrow])))\n",
        "        self.play(\n",
        "            Transform(func, dual_vector),\n",
        "            Write(dual_dot[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        p_coords = VGroup(*list(map(Tex, [\n",
        "            \"p_%d\"%d for d in range(1, 4)\n",
        "        ])))\n",
        "        p_coords.set_color(RED)        \n",
        "        p_array = Matrix(list(p_coords))\n",
        "        p_array.set_height(dual_vector.get_height())\n",
        "        p_array.move_to(dual_vector, aligned_edge = RIGHT)\n",
        "        p_brace = Brace(p_array, UP)\n",
        "        p_tex = OldTex(get_vect_tex(\"p\"))\n",
        "        p_tex.set_color(P_COLOR)\n",
        "        p_brace.put_at_tip(p_tex)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(p_brace),\n",
        "            Write(p_tex)\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            func, p_array,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.remove(func)\n",
        "        self.add(p_array)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(title))\n",
        "        self.wait()\n",
        "\n",
        "        self.p_array = p_array\n",
        "        self.input_array = func_input\n",
        "\n",
        "    def expand_dot_product(self):\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        self.play(everything.to_edge, UP)\n",
        "        self.remove(everything)\n",
        "        self.add(*everything)\n",
        "        to_fade = VGroup()\n",
        "\n",
        "        p_entries = self.p_array.get_entries()\n",
        "        input_entries = self.input_array.get_entries()\n",
        "        dot_components = VGroup()\n",
        "        for p, x, i in zip(p_entries, input_entries, it.count()):\n",
        "            if i == 2:\n",
        "                x.sym  = OldTex(\"=\")\n",
        "            else:\n",
        "                x.sym  = OldTex(\"+\")\n",
        "            p.sym = OldTex(\"\\\\cdot\")\n",
        "            p.target = p.copy().scale(2)\n",
        "            x.target = x.copy().scale(2)\n",
        "            component = VGroup(p.target, p.sym, x.target, x.sym)\n",
        "            component.arrange()\n",
        "            dot_components.add(component)\n",
        "        dot_components.arrange()\n",
        "        dot_components.next_to(ORIGIN, LEFT)\n",
        "        dot_components.shift(1.5*DOWN)\n",
        "        dot_arrow = Arrow(self.p_array.get_corner(DOWN+RIGHT), dot_components)\n",
        "        to_fade.add(dot_arrow)\n",
        "        self.play(ShowCreation(dot_arrow))\n",
        "        new_ps = VGroup()\n",
        "        for p, x in zip(p_entries, input_entries):\n",
        "            self.play(\n",
        "                MoveToTarget(p.copy()),\n",
        "                MoveToTarget(x.copy()),\n",
        "                Write(p.sym),\n",
        "                Write(x.sym)\n",
        "            )\n",
        "            mobs = self.get_mobjects_from_last_animation()\n",
        "            new_ps.add(mobs[0])\n",
        "            to_fade.add(*mobs[1:])\n",
        "            self.wait()\n",
        "\n",
        "        x, y, z = self.u_entries\n",
        "        v1, v2, v3 = self.v_entries\n",
        "        w1, w2, w3 = self.w_entries\n",
        "        cross_components = VGroup()\n",
        "        quints = [\n",
        "            (x, v2, w3, v3, w2),\n",
        "            (y, v3, w1, v1, w3),\n",
        "            (z, v1, w2, v2, w1),\n",
        "        ]\n",
        "        quints = [\n",
        "            [m.copy() for m in quint]\n",
        "            for quint in quints\n",
        "        ]\n",
        "        for i, quint in enumerate(quints):\n",
        "            sym_strings = [\"(\", \"\\\\cdot\", \"-\", \"\\\\cdot\", \")\"]\n",
        "            if i < 2:\n",
        "                sym_strings[-1] += \"+\"\n",
        "            syms = list(map(Tex, sym_strings))\n",
        "            for mob, sym in zip(quint, syms):\n",
        "                mob.target = mob.copy()\n",
        "                mob.target.scale(1.5)\n",
        "                mob.sym = sym\n",
        "            quint_targets = [mob.target for mob in quint]\n",
        "            component = VGroup(*it.chain(*list(zip(quint_targets, syms))))\n",
        "            component.arrange()\n",
        "            cross_components.add(component)\n",
        "            to_fade.add(syms[0], syms[-1], quint[0])\n",
        "        cross_components.arrange(DOWN, aligned_edge = LEFT, buff = MED_SMALL_BUFF)\n",
        "        cross_components.next_to(dot_components, RIGHT)\n",
        "        for quint in quints:\n",
        "            self.play(*[\n",
        "                ApplyMethod(mob.set_color, YELLOW)\n",
        "                for mob in quint\n",
        "            ])\n",
        "            self.wait(0.5)\n",
        "            self.play(*[\n",
        "                MoveToTarget(mob)\n",
        "                for mob in quint\n",
        "            ] + [\n",
        "                Write(mob.sym)\n",
        "                for mob in quint\n",
        "            ])\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            ApplyFunction(\n",
        "                lambda m : m.arrange(\n",
        "                    DOWN, buff = MED_SMALL_BUFF+SMALL_BUFF\n",
        "                ).next_to(cross_components, LEFT),\n",
        "                new_ps\n",
        "            ),\n",
        "            *list(map(FadeOut, to_fade))\n",
        "        )\n",
        "        self.play(*[\n",
        "            Write(OldTex(\"=\").next_to(p, buff = 2*SMALL_BUFF))\n",
        "            for p in new_ps\n",
        "        ])\n",
        "        equals = self.get_mobjects_from_last_animation()\n",
        "        self.wait(2)\n",
        "\n",
        "        everything = everything.copy()\n",
        "        self.play(\n",
        "            FadeOut(VGroup(*self.get_mobjects())),\n",
        "            Animation(everything)\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(everything)\n",
        "\n",
        "    def ask_question(self):\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        p_tex = \"$%s$\"%get_vect_tex(\"p\")\n",
        "        question = OldTexText(\n",
        "            \"What vector\", \n",
        "            p_tex, \n",
        "            \"has \\\\\\\\ the property that\"\n",
        "        )\n",
        "        question.to_edge(UP)\n",
        "        question.set_color(YELLOW)\n",
        "        question.set_color_by_tex(p_tex, P_COLOR)\n",
        "        everything.target = everything.copy()\n",
        "        everything.target.next_to(\n",
        "            question, DOWN, buff = MED_SMALL_BUFF\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(everything),\n",
        "            Write(question)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class WhyAreWeDoingThis(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Um...why are \\\\\\\\ we doing this?\",\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.play(self.get_teacher().change_mode, \"erm\")\n",
        "        self.play_student_changes(\"plain\", \"confused\", \"raise_left_hand\")\n",
        "        self.random_blink()\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"raise_left_hand\")\n",
        "        self.random_blink(5)\n",
        "\n",
        "class ThreeDTripleCrossProduct(Scene):\n",
        "    pass #Simple parallelepiped\n",
        "\n",
        "class ThreeDMovingVariableVector(Scene):\n",
        "    pass #white u moves around\n",
        "\n",
        "class ThreeDMovingVariableVectorWithCrossShowing(Scene):\n",
        "    pass #white u moves around, red p is present\n",
        "\n",
        "class NowForTheCoolPart(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Now for the\\\\\\\\\", \n",
        "            \"cool part\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\n",
        "            \"Let's answer the same question,\\\\\\\\\",\n",
        "            \"but this time geometrically\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink(2)\n",
        "\n",
        "class ThreeDDotProductProjection(Scene):\n",
        "    pass #\n",
        "\n",
        "class DotProductWords(Scene):\n",
        "    def construct(self):\n",
        "        p_tex = \"$%s$\"%get_vect_tex(\"p\")\n",
        "        p_mob = OldTexText(p_tex)\n",
        "        p_mob.scale(1.5)\n",
        "        p_mob.set_color(P_COLOR)\n",
        "        input_array = Matrix(list(\"xyz\"))\n",
        "        dot_product = VGroup(p_mob, Dot(radius = 0.07), input_array)\n",
        "        dot_product.arrange(buff = MED_SMALL_BUFF/2)\n",
        "        equals = OldTex(\"=\")\n",
        "        dot_product.next_to(equals, LEFT)\n",
        "        words = VGroup(*it.starmap(TexText, [\n",
        "            (\"(Length of projection)\",),\n",
        "            (\"(Length of \", p_tex, \")\",)\n",
        "        ]))\n",
        "        times = OldTex(\"\\\\times\")\n",
        "        words[1].set_color_by_tex(p_tex, P_COLOR)\n",
        "        words[0].next_to(equals, RIGHT)\n",
        "        words[1].next_to(words[0], DOWN, aligned_edge = LEFT)\n",
        "        times.next_to(words[0], RIGHT)\n",
        "\n",
        "        everyone = VGroup(dot_product, equals, times, words)\n",
        "        everyone.center().set_width(FRAME_X_RADIUS - 1)\n",
        "        self.add(dot_product)\n",
        "        self.play(Write(equals))\n",
        "        self.play(Write(words[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(times),\n",
        "            Write(words[1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ThreeDProjectToPerpendicular(Scene):\n",
        "    pass #\n",
        "\n",
        "class GeometricVolumeWords(Scene):\n",
        "    def construct(self):\n",
        "        v_tex, w_tex = [\n",
        "            \"$%s$\"%s\n",
        "            for s in get_vect_tex(*\"vw\")\n",
        "        ]\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"(Area of\", \"parallelogram\", \")$\\\\times$\"),\n",
        "            OldTexText(\n",
        "                \"(Component of $%s$\"%matrix_to_tex_string(list(\"xyz\")),\n",
        "                \"perpendicular to\", v_tex, \"and\", w_tex, \")\"\n",
        "            )\n",
        "        )\n",
        "        words[0].set_color_by_tex(\"parallelogram\", BLUE)\n",
        "        words[1].set_color_by_tex(v_tex, ORANGE)\n",
        "        words[1].set_color_by_tex(w_tex, W_COLOR)\n",
        "        words.arrange(RIGHT)\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(DOWN, buff = SMALL_BUFF)\n",
        "        for word in words:\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "\n",
        "class WriteXYZ(Scene):\n",
        "    def construct(self):\n",
        "        self.play(Write(Matrix(list(\"xyz\"))))\n",
        "        self.wait()\n",
        "\n",
        "class ThreeDDotProductWithCross(Scene):\n",
        "    pass \n",
        "\n",
        "class CrossVectorEmphasisWords(Scene):\n",
        "    def construct(self):\n",
        "        v_tex, w_tex = [\"$%s$\"%s for s in get_vect_tex(*\"vw\")]\n",
        "        words = [\n",
        "            OldTexText(\"Perpendicular to\", v_tex, \"and\", w_tex),\n",
        "            OldTexText(\"Length = (Area of \", \"parallelogram\", \")\")\n",
        "        ]\n",
        "        for word in words:\n",
        "            word.set_color_by_tex(v_tex, ORANGE)\n",
        "            word.set_color_by_tex(w_tex, W_COLOR)\n",
        "            word.set_color_by_tex(\"parallelogram\", BLUE)\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(word))\n",
        "\n",
        "class NextVideo(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"\"\"\n",
        "            Next video: Change of basis\n",
        "        \"\"\")\n",
        "        title.to_edge(UP, buff = MED_SMALL_BUFF/2)\n",
        "        rect = Rectangle(width = 16, height = 9, color = BLUE)\n",
        "        rect.set_height(6)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "class ChangeOfBasisPreview(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"include_background_plane\" : False,\n",
        "        \"foreground_plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_WIDTH,\n",
        "            \"secondary_line_ratio\" : 0\n",
        "        },\n",
        "        \"t_matrix\" : [[2, 1], [-1, 1]],\n",
        "        \"i_target_color\" : YELLOW,\n",
        "        \"j_target_color\" : MAROON_B,\n",
        "        \"sum_color\" : PINK,\n",
        "        \"vector\" : [-1, 2],\n",
        "    }\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        pinky = Mortimer(color = PINK)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        pinky.to_corner(DOWN+RIGHT)\n",
        "        self.plane.fade()\n",
        "\n",
        "        self.add_foreground_mobject(randy, pinky)\n",
        "        coords = Matrix(self.vector)\n",
        "        coords.add_to_back(BackgroundRectangle(coords))\n",
        "        self.add_foreground_mobject(coords)\n",
        "        coords.move_to(\n",
        "            randy.get_corner(UP+RIGHT),\n",
        "            aligned_edge = DOWN+LEFT\n",
        "        )\n",
        "        coords.target = coords.copy()\n",
        "        coords.target.move_to(\n",
        "            pinky.get_corner(UP+LEFT),\n",
        "            aligned_edge = DOWN+RIGHT\n",
        "        )\n",
        "        self.play(\n",
        "            Write(coords),\n",
        "            randy.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.scale_basis_vectors()\n",
        "        self.apply_transposed_matrix(\n",
        "            self.t_matrix,\n",
        "            added_anims = [\n",
        "                MoveToTarget(coords),\n",
        "                ApplyMethod(pinky.change_mode, \"speaking\"),\n",
        "                ApplyMethod(randy.change_mode, \"plain\"),\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change_mode, \"erm\",\n",
        "            self.i_hat.set_color, self.i_target_color,\n",
        "            self.j_hat.set_color, self.j_target_color,\n",
        "        )\n",
        "        self.i_hat.color = self.i_target_color\n",
        "        self.j_hat.color = self.j_target_color\n",
        "        self.scale_basis_vectors()\n",
        "\n",
        "    def scale_basis_vectors(self):\n",
        "        for vect in self.i_hat, self.j_hat:\n",
        "            vect.save_state()\n",
        "        self.play(self.i_hat.scale, self.vector[0])\n",
        "        self.play(self.j_hat.scale, self.vector[1])\n",
        "        self.play(self.j_hat.shift, self.i_hat.get_end())\n",
        "        sum_vect = Vector(self.j_hat.get_end(), color = self.sum_color)\n",
        "        self.play(ShowCreation(sum_vect))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(sum_vect),\n",
        "            self.i_hat.restore,\n",
        "            self.j_hat.restore,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}