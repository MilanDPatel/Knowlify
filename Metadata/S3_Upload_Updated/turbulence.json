{
    "topic": "The mathematical concept being demonstrated is the creation and destruction of a set of spirals, with each spir",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.div_curl import PureAirfoilFlow\n",
        "from _2018.div_curl import move_submobjects_along_vector_field\n",
        "from _2018.div_curl import move_points_along_vector_field\n",
        "from _2018.div_curl import four_swirls_function\n",
        "from _2018.lost_lecture import ShowWord\n",
        "\n",
        "\n",
        "class CreationDestructionMobject(VMobject):\n",
        "    CONFIG = {\n",
        "        \"start_time\": 0,\n",
        "        \"frequency\": 0.25,\n",
        "        \"max_ratio_shown\": 0.3,\n",
        "        \"use_copy\": True,\n",
        "    }\n",
        "\n",
        "    def __init__(self, template, **kwargs):\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        if self.use_copy:\n",
        "            self.ghost_mob = template.copy().fade(1)\n",
        "            self.add(self.ghost_mob)\n",
        "        else:\n",
        "            self.ghost_mob = template\n",
        "            # Don't add\n",
        "        self.shown_mob = template.deepcopy()\n",
        "        self.shown_mob.clear_updaters()\n",
        "        self.add(self.shown_mob)\n",
        "        self.total_time = self.start_time\n",
        "\n",
        "        def update(mob, dt):\n",
        "            mob.total_time += dt\n",
        "            period = 1.0 / mob.frequency\n",
        "            unsmooth_alpha = (mob.total_time % period) / period\n",
        "            alpha = bezier([0, 0, 1, 1])(unsmooth_alpha)\n",
        "            mrs = mob.max_ratio_shown\n",
        "            mob.shown_mob.pointwise_become_partial(\n",
        "                mob.ghost_mob,\n",
        "                max(interpolate(-mrs, 1, alpha), 0),\n",
        "                min(interpolate(0, 1 + mrs, alpha), 1),\n",
        "            )\n",
        "\n",
        "        self.add_updater(update)\n",
        "\n",
        "\n",
        "class Eddy(VMobject):\n",
        "    CONFIG = {\n",
        "        \"cd_mob_config\": {\n",
        "            \"frequency\": 0.2,\n",
        "            \"max_ratio_shown\": 0.3\n",
        "        },\n",
        "        \"n_spirils\": 5,\n",
        "        \"n_layers\": 20,\n",
        "        \"radius\": 1,\n",
        "        \"colors\": [BLUE_A, BLUE_E],\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        lines = self.get_lines()\n",
        "        # self.add(lines)\n",
        "        self.add(*[\n",
        "            CreationDestructionMobject(line, **self.cd_mob_config)\n",
        "            for line in lines\n",
        "        ])\n",
        "        self.randomize_times()\n",
        "\n",
        "    def randomize_times(self):\n",
        "        for submob in self.submobjects:\n",
        "            if hasattr(submob, \"total_time\"):\n",
        "                T = 1.0 / submob.frequency\n",
        "                submob.total_time = T * random.random()\n",
        "\n",
        "    def get_lines(self):\n",
        "        a = 0.2\n",
        "        return VGroup(*[\n",
        "            self.get_line(r=self.radius * (1 - a + 2 * a * random.random()))\n",
        "            for x in range(self.n_layers)\n",
        "        ])\n",
        "\n",
        "    def get_line(self, r):\n",
        "        return ParametricCurve(\n",
        "            lambda t: r * (t + 1)**(-1) * np.array([\n",
        "                np.cos(TAU * t),\n",
        "                np.sin(TAU * t),\n",
        "                0,\n",
        "            ]),\n",
        "            t_min=0.1 * random.random(),\n",
        "            t_max=self.n_spirils,\n",
        "            stroke_width=1,\n",
        "            color=interpolate_color(*self.colors, random.random())\n",
        "        )\n",
        "\n",
        "\n",
        "class Chaos(Eddy):\n",
        "    CONFIG = {\n",
        "        \"n_lines\": 12,\n",
        "        \"height\": 1,\n",
        "        \"width\": 2,\n",
        "        \"n_midpoints\": 4,\n",
        "        \"cd_mob_config\": {\n",
        "            \"use_copy\": False,\n",
        "            \"frequency\": 1,\n",
        "            \"max_ratio_shown\": 0.8\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        rect = Rectangle(height=self.height, width=self.width)\n",
        "        rect.move_to(ORIGIN, DL)\n",
        "        rect.fade(1)\n",
        "        self.rect = rect\n",
        "        self.add(rect)\n",
        "\n",
        "        lines = self.get_lines()\n",
        "        self.add(*[\n",
        "            CreationDestructionMobject(line, **self.cd_mob_config)\n",
        "            for line in lines\n",
        "        ])\n",
        "        self.randomize_times()\n",
        "        lines.fade(1)\n",
        "        self.add(lines)\n",
        "\n",
        "    def get_lines(self):\n",
        "        return VGroup(*[\n",
        "            self.get_line(y)\n",
        "            for y in np.linspace(0, self.height, self.n_lines)\n",
        "        ])\n",
        "\n",
        "    def get_line(self, y):\n",
        "        frequencies = [0] + list(2 + 2 * np.random.random(self.n_midpoints)) + [0]\n",
        "        rect = self.rect\n",
        "        line = Line(\n",
        "            y * UP, y * UP + self.width * RIGHT,\n",
        "            stroke_width=1\n",
        "        )\n",
        "        line.insert_n_curves(self.n_midpoints)\n",
        "        line.total_time = random.random()\n",
        "        delta_h = self.height / (self.n_lines - 1)\n",
        "\n",
        "        def update(line, dt):\n",
        "            x0, y0 = rect.get_corner(DL)[:2]\n",
        "            x1, y1 = rect.get_corner(UR)[:2]\n",
        "            line.total_time += dt\n",
        "            xs = np.linspace(x0, x1, self.n_midpoints + 2)\n",
        "            new_anchors = [\n",
        "                np.array([\n",
        "                    x + 1.0 * delta_h * np.cos(f * line.total_time),\n",
        "                    y0 + y + 1.0 * delta_h * np.cos(f * line.total_time),\n",
        "                    0\n",
        "                ])\n",
        "                for (x, f) in zip(xs, frequencies)\n",
        "            ]\n",
        "            line.set_points_smoothly(new_anchors)\n",
        "\n",
        "        line.add_updater(update)\n",
        "        return line\n",
        "\n",
        "\n",
        "class DoublePendulum(VMobject):\n",
        "    CONFIG = {\n",
        "        \"start_angles\": [3 * PI / 7, 3 * PI / 4],\n",
        "        \"color1\": BLUE,\n",
        "        \"color2\": RED,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        line1 = Line(ORIGIN, UP)\n",
        "        dot1 = Dot(color=self.color1)\n",
        "        dot1.add_updater(lambda d: d.move_to(line1.get_end()))\n",
        "        line2 = Line(UP, 2 * UP)\n",
        "        dot2 = Dot(color=self.color2)\n",
        "        dot2.add_updater(lambda d: d.move_to(line2.get_end()))\n",
        "        self.add(line1, line2, dot1, dot2)\n",
        "\n",
        "        # Largely copied from https://scipython.com/blog/the-double-pendulum/\n",
        "        # Pendulum rod lengths (m), bob masses (kg).\n",
        "        L1, L2 = 1, 1\n",
        "        m1, m2 = 1, 1\n",
        "        # The gravitational acceleration (m.s-2).\n",
        "        g = 9.81\n",
        "\n",
        "        self.state_vect = np.array([\n",
        "            self.start_angles[0], 0,\n",
        "            self.start_angles[1], 0,\n",
        "        ])\n",
        "        self.state_vect += np.random.random(4) * 1e-7\n",
        "\n",
        "        def update(group, dt):\n",
        "            for x in range(2):\n",
        "                line1, line2 = group.submobjects[:2]\n",
        "                theta1, z1, theta2, z2 = group.state_vect\n",
        "\n",
        "                c, s = np.cos(theta1 - theta2), np.sin(theta1 - theta2)\n",
        "\n",
        "                theta1dot = z1\n",
        "                z1dot = (m2 * g * np.sin(theta2) * c - m2 * s * (L1 * (z1**2) * c + L2 * z2**2) -\n",
        "                         (m1 + m2) * g * np.sin(theta1)) / L1 / (m1 + m2 * s**2)\n",
        "                theta2dot = z2\n",
        "                z2dot = ((m1 + m2) * (L1 * (z1**2) * s - g * np.sin(theta2) + g * np.sin(theta1) * c) +\n",
        "                         m2 * L2 * (z2**2) * s * c) / L2 / (m1 + m2 * s**2)\n",
        "\n",
        "                group.state_vect += 0.5 * dt * np.array([\n",
        "                    theta1dot, z1dot, theta2dot, z2dot,\n",
        "                ])\n",
        "                group.state_vect[1::2] *= 0.9999\n",
        "\n",
        "            p1 = L1 * np.sin(theta1) * RIGHT - L1 * np.cos(theta1) * UP\n",
        "            p2 = p1 + L2 * np.sin(theta2) * RIGHT - L2 * np.cos(theta2) * UP\n",
        "\n",
        "            line1.put_start_and_end_on(ORIGIN, p1)\n",
        "            line2.put_start_and_end_on(p1, p2)\n",
        "\n",
        "        self.add_updater(update)\n",
        "\n",
        "\n",
        "class DoublePendulums(VGroup):\n",
        "    def __init__(self, **kwargs):\n",
        "        colors = [BLUE, RED, YELLOW, PINK, MAROON_B, PURPLE, GREEN]\n",
        "        VGroup.__init__(\n",
        "            self,\n",
        "            *[\n",
        "                DoublePendulum(\n",
        "                    color1=random.choice(colors),\n",
        "                    color2=random.choice(colors),\n",
        "                )\n",
        "                for x in range(5)\n",
        "            ],\n",
        "            **kwargs,\n",
        "        )\n",
        "\n",
        "\n",
        "class Diffusion(VMobject):\n",
        "    CONFIG = {\n",
        "        \"height\": 1.5,\n",
        "        \"n_dots\": 1000,\n",
        "        \"colors\": [RED, BLUE]\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "        self.add_dots()\n",
        "        self.add_invisible_circles()\n",
        "\n",
        "    def add_dots(self):\n",
        "        dots = VGroup(*[Dot() for x in range(self.n_dots)])\n",
        "        dots.arrange_in_grid(buff=SMALL_BUFF)\n",
        "        dots.center()\n",
        "        dots.set_height(self.height)\n",
        "        dots.sort(lambda p: p[0])\n",
        "        dots[:len(dots) // 2].set_color(self.colors[0])\n",
        "        dots[len(dots) // 2:].set_color(self.colors[1])\n",
        "        dots.set_fill(opacity=0.8)\n",
        "        self.dots = dots\n",
        "        self.add(dots)\n",
        "\n",
        "    def add_invisible_circles(self):\n",
        "        circles = VGroup()\n",
        "        for dot in self.dots:\n",
        "            point = dot.get_center()\n",
        "            radius = get_norm(point)\n",
        "            circle = Circle(radius=radius)\n",
        "            circle.rotate(angle_of_vector(point))\n",
        "            circle.fade(1)\n",
        "            circles.add(circle)\n",
        "            self.add_updater_to_dot(dot, circle)\n",
        "        self.add(circles)\n",
        "\n",
        "    def add_updater_to_dot(self, dot, circle):\n",
        "        dot.total_time = 0\n",
        "        radius = get_norm(dot.get_center())\n",
        "        freq = 0.1 + 0.05 * random.random() + 0.05 / radius\n",
        "\n",
        "        def update(dot, dt):\n",
        "            dot.total_time += dt\n",
        "            prop = (freq * dot.total_time) % 1\n",
        "            dot.move_to(circle.point_from_proportion(prop))\n",
        "\n",
        "        dot.add_updater(update)\n",
        "\n",
        "\n",
        "class NavierStokesEquations(Tex):\n",
        "    CONFIG = {\n",
        "        \"tex_to_color_map\": {\n",
        "            \"\\\\rho\": YELLOW,\n",
        "            \"\\\\mu\": GREEN,\n",
        "            \"\\\\textbf{v}\": BLUE,\n",
        "            \"p{}\": RED,\n",
        "        },\n",
        "        \"width\": 10,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        v_tex = \"\\\\textbf{v}\"\n",
        "        Tex.__init__(\n",
        "            self,\n",
        "            \"\\\\rho\",\n",
        "            \"\\\\left(\"\n",
        "            \"{\\\\partial\", v_tex, \"\\\\over\",\n",
        "            \"\\\\partial\", \"t}\",\n",
        "            \"+\",\n",
        "            v_tex, \"\\\\cdot\", \"\\\\nabla\", v_tex,\n",
        "            \"\\\\right)\",\n",
        "            \"=\",\n",
        "            \"-\", \"\\\\nabla\", \"p{}\", \"+\",\n",
        "            \"\\\\mu\", \"\\\\nabla^2\", v_tex, \"+\",\n",
        "            # \"\\\\frac{1}{3}\", \"\\\\mu\", \"\\\\nabla\",\n",
        "            # \"(\", \"\\\\nabla\", \"\\\\cdot\", v_tex, \")\", \"+\",\n",
        "            \"\\\\textbf{F}\",\n",
        "            \"\\\\qquad\\\\qquad\",\n",
        "            \"\\\\nabla\", \"\\\\cdot\", v_tex, \"=\", \"0\",\n",
        "            **kwargs\n",
        "        )\n",
        "        self.set_width(self.width)\n",
        "\n",
        "    def get_labels(self):\n",
        "        parts = self.get_parts()\n",
        "        words = [\n",
        "            \"Analogous to \\\\\\\\ mass $\\\\times$ acceleration\",\n",
        "            \"Pressure\\\\\\\\forces\",\n",
        "            \"Viscous\\\\\\\\forces\",\n",
        "            \"External\\\\\\\\forces\",\n",
        "        ]\n",
        "\n",
        "        result = VGroup()\n",
        "        braces = VGroup()\n",
        "        word_mobs = VGroup()\n",
        "        for i, part, word in zip(it.count(), parts, words):\n",
        "            brace = Brace(part, DOWN, buff=SMALL_BUFF)\n",
        "            word_mob = brace.get_text(word)\n",
        "            word_mob.scale(0.7, about_edge=UP)\n",
        "            word_mobs.add(word_mob)\n",
        "            braces.add(brace)\n",
        "            result.add(VGroup(brace, word_mob))\n",
        "        word_mobs[1:].arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        word_mobs[1:].next_to(braces[2], DOWN, SMALL_BUFF)\n",
        "        word_mobs[1].set_color(RED)\n",
        "        word_mobs[2].set_color(GREEN)\n",
        "        return result\n",
        "\n",
        "    def get_parts(self):\n",
        "        return VGroup(\n",
        "            self[:12],\n",
        "            self[13:16],\n",
        "            self[17:20],\n",
        "            self[21:22],\n",
        "        )\n",
        "\n",
        "\n",
        "class Test(Scene):\n",
        "    def construct(self):\n",
        "        self.add(DoublePendulums())\n",
        "        self.wait(30)\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class EddyReference(Scene):\n",
        "    CONFIG = {\n",
        "        \"radius\": 1,\n",
        "        \"label\": \"Eddy\",\n",
        "        \"label\": \"\",\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        eddy = Eddy(radius=self.radius)\n",
        "        new_eddy = eddy.get_lines()\n",
        "        for line in new_eddy:\n",
        "            line.set_stroke(\n",
        "                width=(3 + 3 * random.random())\n",
        "            )\n",
        "        label = OldTexText(self.label)\n",
        "        label.next_to(new_eddy, UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreationThenDestruction, new_eddy),\n",
        "            FadeIn(\n",
        "                label,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "\n",
        "class EddyReferenceWithLabel(EddyReference):\n",
        "    CONFIG = {\n",
        "        \"label\": \"Eddy\"\n",
        "    }\n",
        "\n",
        "\n",
        "class EddyLabels(Scene):\n",
        "    def construct(self):\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"Large eddy\"),\n",
        "            OldTexText(\"Medium eddy\"),\n",
        "            OldTexText(\"Small eddy\"),\n",
        "        )\n",
        "        for label in labels:\n",
        "            self.play(FadeIn(\n",
        "                label,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                run_time=3\n",
        "            ))\n",
        "\n",
        "\n",
        "class LargeEddyReference(EddyReference):\n",
        "    CONFIG = {\n",
        "        \"radius\": 2,\n",
        "        \"label\": \"\"\n",
        "    }\n",
        "\n",
        "\n",
        "class MediumEddyReference(EddyReference):\n",
        "    CONFIG = {\n",
        "        \"radius\": 0.8,\n",
        "        \"label\": \"Medium eddy\"\n",
        "    }\n",
        "\n",
        "\n",
        "class SmallEddyReference(EddyReference):\n",
        "    CONFIG = {\n",
        "        \"radius\": 0.25,\n",
        "        \"label\": \"Small eddy\"\n",
        "    }\n",
        "\n",
        "\n",
        "class SomeTurbulenceEquations(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy, morty = self.pi_creatures\n",
        "        navier_stokes = NavierStokesEquations()\n",
        "        line = Line(randy.get_right(), morty.get_left())\n",
        "        navier_stokes.replace(line, dim_to_match=0)\n",
        "        navier_stokes.scale(1.2)\n",
        "\n",
        "        distribution = OldTex(\n",
        "            \"E(k) \\\\propto k^{-5/3}\",\n",
        "            tex_to_color_map={\n",
        "                \"k\": GREEN,\n",
        "                \"-5/3\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        distribution.next_to(morty, UL)\n",
        "        brace = Brace(distribution, DOWN, buff=SMALL_BUFF)\n",
        "        brace_words = brace.get_text(\"Explained soon...\")\n",
        "        brace_group = VGroup(brace, brace_words)\n",
        "\n",
        "        self.play(\n",
        "            Write(navier_stokes),\n",
        "            randy.change, \"confused\", navier_stokes,\n",
        "            morty.change, \"confused\", navier_stokes,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\", distribution,\n",
        "            randy.look_at, distribution,\n",
        "            FadeInFromDown(distribution),\n",
        "            navier_stokes.fade, 0.5,\n",
        "        )\n",
        "        self.play(GrowFromCenter(brace_group))\n",
        "        self.play(randy.change, \"pondering\", distribution)\n",
        "        self.wait(3)\n",
        "        dist_group = VGroup(distribution, brace_group)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(randy, morty, navier_stokes)),\n",
        "            dist_group.scale, 1.5,\n",
        "            dist_group.center,\n",
        "            dist_group.to_edge, UP,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy, morty = Randolph(), Mortimer()\n",
        "        randy.to_corner(DL)\n",
        "        morty.to_corner(DR)\n",
        "        return (randy, morty)\n",
        "\n",
        "\n",
        "class JokeRingEquation(Scene):\n",
        "    def construct(self):\n",
        "        items = VGroup(\n",
        "            OldTexText(\"Container with a lip\"),\n",
        "            OldTexText(\"Fill with smoke (or fog)\"),\n",
        "            OldTexText(\"Hold awkwardly\"),\n",
        "        )\n",
        "        line = Line(LEFT, RIGHT).set_width(items.get_width() + 1)\n",
        "        items.add(line)\n",
        "        items.add(OldTexText(\"Vortex ring\"))\n",
        "        items.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        line.shift(LEFT)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.next_to(line.get_left(), UR, SMALL_BUFF)\n",
        "        line.add(plus)\n",
        "        items.to_edge(RIGHT)\n",
        "\n",
        "        point = 3.8 * LEFT + 0.2 * UP\n",
        "        arrow1 = Arrow(\n",
        "            items[0].get_left(), point + 0.8 * UP + 0.3 * RIGHT,\n",
        "            path_arc=90 * DEGREES,\n",
        "        )\n",
        "        arrow1.pointwise_become_partial(arrow1, 0, 0.99)\n",
        "\n",
        "        arrow2 = Arrow(\n",
        "            items[1].get_left(), point,\n",
        "        )\n",
        "        arrows = VGroup(arrow1, arrow2)\n",
        "\n",
        "        for i in 0, 1:\n",
        "            self.play(\n",
        "                FadeInFromDown(items[i]),\n",
        "                ShowCreation(arrows[i])\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, items[2:]))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(arrows))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VideoOnPhysicsGirlWrapper(Scene):\n",
        "    def construct(self):\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        title = OldTexText(\"Video on Physics Girl\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LightBouncingOffFogParticle(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Light bouncing\\\\\\\\\",\n",
        "            \"off fog particles\"\n",
        "        )\n",
        "        arrow = Vector(UP + 0.5 * RIGHT)\n",
        "        arrow.next_to(words, UP)\n",
        "        arrow.set_color(WHITE)\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NightHawkInLightWrapper(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"NightHawkInLight\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        rect = ScreenRectangle(height=6)\n",
        "        rect.next_to(title, DOWN)\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CarefulWithLasers(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        randy = self.students[1]\n",
        "        randy2 = self.students[2]\n",
        "        # randy.change('hooray')\n",
        "        laser = VGroup(\n",
        "            Rectangle(\n",
        "                height=0.1,\n",
        "                width=0.3,\n",
        "                fill_color=GREY_B,\n",
        "                fill_opacity=1,\n",
        "                stroke_color=GREY_D,\n",
        "                stroke_width=1,\n",
        "            ),\n",
        "            Line(ORIGIN, 10 * RIGHT, color=GREEN_SCREEN)\n",
        "        )\n",
        "        laser.arrange(RIGHT, buff=0)\n",
        "        laser.rotate(45 * DEGREES)\n",
        "        laser.shift(randy.get_corner(UR) - laser[0].get_center() + 0.1 * DR)\n",
        "\n",
        "        laser.time = 0\n",
        "\n",
        "        def update_laser(laser, dt):\n",
        "            laser.time += dt\n",
        "            laser.rotate(\n",
        "                0.5 * dt * np.sin(laser.time),\n",
        "                about_point=laser[0].get_center()\n",
        "            )\n",
        "        laser.add_updater(update_laser)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, self.pi_creatures, run_time=1))\n",
        "        self.add(self.pi_creatures, laser)\n",
        "        for pi in self.pi_creatures:\n",
        "            pi.add_updater(lambda p: p.look_at(laser[1]))\n",
        "        self.play(\n",
        "            ShowCreation(laser),\n",
        "            self.change_students(\n",
        "                \"surprised\", \"hooray\", \"horrified\",\n",
        "                look_at=laser\n",
        "            )\n",
        "        )\n",
        "        self.teacher_says(\n",
        "            \"Careful with \\\\\\\\ the laser!\",\n",
        "            target_mode=\"angry\"\n",
        "        )\n",
        "        self.wait(2.2)\n",
        "        morty.save_state()\n",
        "        randy2.save_state()\n",
        "        self.play(\n",
        "            morty.blink, randy2.blink,\n",
        "            run_time=0.3\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            morty.restore, randy2.restore,\n",
        "            run_time=0.3\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class SetAsideTurbulence(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.pi_creature_says(\n",
        "            \"Forget vortex rings\",\n",
        "            target_mode=\"speaking\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.pi_creature_says(\n",
        "            \"look at that\\\\\\\\ turbulence!\",\n",
        "            target_mode=\"surprised\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        return morty\n",
        "\n",
        "\n",
        "class WavingRodLabel(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"(Waving a small flag \\\\\\\\ through the air)\"\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SeekOrderWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Seek order amidst chaos\")\n",
        "        words.scale(1.5)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LongEddy(Scene):\n",
        "    def construct(self):\n",
        "        self.add(Eddy())\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class LongDoublePendulum(Scene):\n",
        "    def construct(self):\n",
        "        self.add(DoublePendulums())\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class LongDiffusion(Scene):\n",
        "    def construct(self):\n",
        "        self.add(Diffusion())\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class AskAboutTurbulence(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.pi_creatures_ask()\n",
        "        self.divide_by_qualitative_quantitative()\n",
        "        self.three_qualitative_descriptors()\n",
        "        self.rigorous_definition()\n",
        "\n",
        "    def pi_creatures_ask(self):\n",
        "        morty = self.teacher\n",
        "        randy = self.students[1]\n",
        "        morty.change(\"surprised\")\n",
        "\n",
        "        words = OldTexText(\"Wait,\", \"what\", \"exactly \\\\\\\\\", \"is turbulence?\")\n",
        "        question = OldTexText(\"What\", \"is turbulence?\")\n",
        "        question.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH - 1)\n",
        "        h_line.next_to(question, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.student_says(\n",
        "            words,\n",
        "            target_mode='raise_left_hand',\n",
        "            added_anims=[morty.change, 'pondering']\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"erm\", \"raise_left_hand\", \"confused\",\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            FadeOut(randy.bubble),\n",
        "            ReplacementTransform(VGroup(words[1], words[3]), question),\n",
        "            FadeOut(VGroup(words[0], words[2])),\n",
        "            self.change_students(\n",
        "                *3 * [\"pondering\"],\n",
        "                look_at=question\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            LaggedStartMap(\n",
        "                FadeOutAndShiftDown, self.pi_creatures,\n",
        "                run_time=1,\n",
        "                lag_ratio=0.8\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.question = question\n",
        "        self.h_line = h_line\n",
        "\n",
        "    def divide_by_qualitative_quantitative(self):\n",
        "        v_line = Line(\n",
        "            self.h_line.get_center(),\n",
        "            FRAME_HEIGHT * DOWN / 2,\n",
        "        )\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Features\", color=YELLOW),\n",
        "            OldTexText(\"Rigorous definition\", color=BLUE),\n",
        "        )\n",
        "        words.next_to(self.h_line, DOWN)\n",
        "        words[0].shift(FRAME_WIDTH * LEFT / 4)\n",
        "        words[1].shift(FRAME_WIDTH * RIGHT / 4)\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            LaggedStartMap(FadeInFromDown, words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.words = words\n",
        "\n",
        "    def three_qualitative_descriptors(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"- Eddies\"),\n",
        "            OldTexText(\"- Chaos\"),\n",
        "            OldTexText(\"- Diffusion\"),\n",
        "        )\n",
        "        words.arrange(\n",
        "            DOWN, buff=1.25,\n",
        "            aligned_edge=LEFT\n",
        "        )\n",
        "        words.to_edge(LEFT)\n",
        "        words.shift(MED_LARGE_BUFF * DOWN)\n",
        "\n",
        "        # objects = VGroup(\n",
        "        #     Eddy(),\n",
        "        #     DoublePendulum(),\n",
        "        #     Diffusion(),\n",
        "        # )\n",
        "\n",
        "        # for word, obj in zip(words, objects):\n",
        "        for word in words:\n",
        "            # obj.next_to(word, RIGHT)\n",
        "            self.play(\n",
        "                FadeInFromDown(word),\n",
        "                # VFadeIn(obj)\n",
        "            )\n",
        "        self.wait(3)\n",
        "\n",
        "    def rigorous_definition(self):\n",
        "        randy = Randolph()\n",
        "        randy.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        randy.change(\"pondering\", self.words[1])\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"shruggie\")\n",
        "        for x in range(2):\n",
        "            self.play(Blink(randy))\n",
        "            self.wait()\n",
        "        self.play(randy.look, LEFT)\n",
        "        self.wait(2)\n",
        "        self.play(randy.look, UP)\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BumpyPlaneRide(Scene):\n",
        "    def construct(self):\n",
        "        plane = SVGMobject(file_name=\"plane2\")\n",
        "        self.add(plane)\n",
        "\n",
        "        total_time = 0\n",
        "        while total_time < 10:\n",
        "            point = 2 * np.append(np.random.random(2), 2) + DL\n",
        "            point *= 0.2\n",
        "            time = 0.2 * random.random()\n",
        "            total_time += time\n",
        "            arc = PI * random.random() - PI / 2\n",
        "            self.play(\n",
        "                plane.move_to, point,\n",
        "                run_time=time,\n",
        "                path_arc=arc\n",
        "            )\n",
        "\n",
        "\n",
        "class PureAirfoilFlowCopy(PureAirfoilFlow):\n",
        "    def modify_vector_field(self, vector_field):\n",
        "        PureAirfoilFlow.modify_vector_field(self, vector_field)\n",
        "        vector_field.set_fill(opacity=0.1)\n",
        "        vector_field.set_stroke(opacity=0.1)\n",
        "\n",
        "\n",
        "class LaminarFlowLabel(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Laminar flow\")\n",
        "        words.scale(1.5)\n",
        "        words.to_edge(UP)\n",
        "        subwords = OldTexText(\n",
        "            \"`Lamina', in Latin, means \\\\\\\\\"\n",
        "            \"``a thin sheet of material''\",\n",
        "            tex_to_color_map={\"Lamina\": YELLOW},\n",
        "            arg_separator=\"\",\n",
        "        )\n",
        "        subwords.next_to(words, DOWN, MED_LARGE_BUFF)\n",
        "        VGroup(words, subwords).set_background_stroke(width=4)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(FadeInFromDown(subwords))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HighCurlFieldBreakingLayers(Scene):\n",
        "    CONFIG = {\n",
        "        \"flow_anim\": move_submobjects_along_vector_field,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        lines = VGroup(*[\n",
        "            self.get_line()\n",
        "            for x in range(20)\n",
        "        ])\n",
        "        lines.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        lines[0::2].set_color(BLUE)\n",
        "        lines[1::2].set_color(RED)\n",
        "        all_dots = VGroup(*it.chain(*lines))\n",
        "\n",
        "        def func(p):\n",
        "            vect = four_swirls_function(p)\n",
        "            norm = get_norm(vect)\n",
        "            if norm > 2:\n",
        "                vect *= 4.0 / get_norm(vect)**2\n",
        "            return vect\n",
        "\n",
        "        self.add(lines)\n",
        "        self.add(self.flow_anim(all_dots, func))\n",
        "        self.wait(16)\n",
        "\n",
        "    def get_line(self):\n",
        "        line = VGroup(*[Dot() for x in range(100)])\n",
        "        line.set_height(0.1)\n",
        "        line.arrange(RIGHT, buff=0)\n",
        "        line.set_width(10)\n",
        "        return line\n",
        "\n",
        "\n",
        "class HighCurlFieldBreakingLayersLines(HighCurlFieldBreakingLayers):\n",
        "    CONFIG = {\n",
        "        \"flow_anim\": move_points_along_vector_field\n",
        "    }\n",
        "\n",
        "    def get_line(self):\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.insert_n_curves(500)\n",
        "        line.set_width(5)\n",
        "        return line\n",
        "\n",
        "\n",
        "class VorticitySynonyms(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"High\", \"vorticity\"),\n",
        "            OldTex(\n",
        "                \"\\\\text{a.k.a} \\\\,\",\n",
        "                \"|\\\\nabla \\\\times \\\\vec{\\\\textbf{v}}| > 0\"\n",
        "            ),\n",
        "            OldTexText(\"a.k.a\", \"high\", \"swirly-swirly\", \"factor\"),\n",
        "        )\n",
        "        words[0].set_color_by_tex(\"vorticity\", BLUE)\n",
        "        words[1].set_color_by_tex(\"nabla\", BLUE)\n",
        "        words[2].set_color_by_tex(\"swirly\", BLUE)\n",
        "        words.arrange(\n",
        "            DOWN,\n",
        "            aligned_edge=LEFT,\n",
        "            buff=MED_LARGE_BUFF\n",
        "        )\n",
        "\n",
        "        for word in words:\n",
        "            word.add_background_rectangle()\n",
        "            self.play(FadeInFromDown(word))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class VorticityDoesNotImplyTurbulence(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        t_to_v = OldTexText(\n",
        "            \"Turbulence\", \"$\\\\Rightarrow$\", \"Vorticity\",\n",
        "        )\n",
        "        v_to_t = OldTexText(\n",
        "            \"Vorticity\", \"$\\\\Rightarrow$\", \"Turbulence\",\n",
        "        )\n",
        "        for words in t_to_v, v_to_t:\n",
        "            words.move_to(self.hold_up_spot, DR)\n",
        "            words.set_color_by_tex_to_color_map({\n",
        "                \"Vorticity\": BLUE,\n",
        "                \"Turbulence\": GREEN,\n",
        "            })\n",
        "        v_to_t.submobjects.reverse()\n",
        "        cross = Cross(v_to_t[1])\n",
        "\n",
        "        morty = self.teacher\n",
        "        self.play(\n",
        "            morty.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(t_to_v)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(t_to_v.shift, 2 * UP,)\n",
        "        self.play(\n",
        "            TransformFromCopy(t_to_v, v_to_t, path_arc=PI / 2),\n",
        "            self.change_students(\n",
        "                \"erm\", \"confused\", \"sassy\",\n",
        "                run_time=1\n",
        "            ),\n",
        "            ShowCreation(cross, run_time=2),\n",
        "        )\n",
        "        self.add(cross)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SurroundingRectangleSnippet(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle()\n",
        "        rect.set_color(YELLOW)\n",
        "        rect.set_stroke(width=5)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "\n",
        "\n",
        "class FeynmanOnTurbulence(Scene):\n",
        "    def construct(self):\n",
        "        feynman = ImageMobject(\"Feynman_Woods\", height=4)\n",
        "        name = OldTexText(\"Richard Feynman\")\n",
        "        name.next_to(feynman, DOWN)\n",
        "        quote = OldTexText(\n",
        "            \"``\", \"Turbulence\", \"is the most\\\\\\\\\"\n",
        "            \"important\", \"unsolved problem\\\\\\\\\",\n",
        "            \"of classical physics.''\",\n",
        "            tex_to_color_map={\n",
        "                \"Turbulence\": BLUE,\n",
        "                \"unsolved problem\\\\\\\\\": YELLOW,\n",
        "            },\n",
        "        )\n",
        "        quote[0].shift(SMALL_BUFF * RIGHT)\n",
        "        quote.next_to(feynman, RIGHT)\n",
        "        Group(feynman, name, quote).center()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(feynman, UP),\n",
        "            FadeIn(name, DOWN),\n",
        "            Write(quote, run_time=4)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowNavierStokesEquations(Scene):\n",
        "    def construct(self):\n",
        "        self.introduce_equations()\n",
        "        self.ask_about_evolution()\n",
        "        self.ask_about_reasonable()\n",
        "        self.ask_about_blowup()\n",
        "        self.show_money()\n",
        "\n",
        "    def introduce_equations(self):\n",
        "        name = OldTexText(\"Navier-Stokes equations (incompressible)\")\n",
        "        equations = NavierStokesEquations()\n",
        "        name.to_edge(UP)\n",
        "        equations.next_to(name, DOWN, MED_LARGE_BUFF)\n",
        "        labels = equations.get_labels()\n",
        "        parts = equations.get_parts()\n",
        "        newtons_second = OldTexText(\n",
        "            \"Newton's 2nd law \\\\\\\\ $ma = F$\"\n",
        "        )\n",
        "        newtons_second.next_to(parts, DOWN)\n",
        "        variables = OldTex(\n",
        "            \"&\\\\textbf{v}\", \"\\\\text{ is velocity}\\\\\\\\\",\n",
        "            \"&\\\\rho\", \"\\\\text{ is density}\\\\\\\\\",\n",
        "            \"&p{}\", \"\\\\text{ is pressure}\\\\\\\\\",\n",
        "            \"&\\\\mu\", \"\\\\text{ is viscosity}\\\\\\\\\",\n",
        "            tex_to_color_map=NavierStokesEquations.CONFIG[\"tex_to_color_map\"]\n",
        "        )\n",
        "        variables.to_corner(DL)\n",
        "\n",
        "        self.play(FadeInFromDown(equations))\n",
        "        self.play(Write(name))\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFrom, variables,\n",
        "            lambda m: (m, RIGHT),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(newtons_second))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(labels[0]),\n",
        "            newtons_second.next_to, variables, RIGHT, LARGE_BUFF\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(parts[0]))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeInFrom, labels[1:]))\n",
        "        self.wait(3)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut, VGroup(*it.chain(labels, variables, newtons_second))\n",
        "        ))\n",
        "\n",
        "        self.equations = equations\n",
        "\n",
        "    def ask_about_evolution(self):\n",
        "        words = OldTexText(\n",
        "            \"Given a start state...\",\n",
        "            \"...how does it evolve?\"\n",
        "        )\n",
        "        words.arrange(RIGHT, buff=2)\n",
        "\n",
        "        words.next_to(self.equations, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(words[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(words[1]))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(words))\n",
        "\n",
        "    def ask_about_reasonable(self):\n",
        "        question = OldTexText(\n",
        "            \"Do ``reasonable'' \\\\\\\\\"\n",
        "            \"solutions always\\\\\\\\\"\n",
        "            \"exist?\"\n",
        "        )\n",
        "        self.play(FadeInFromDown(question))\n",
        "        self.wait()\n",
        "\n",
        "        self.reasonable_question = question\n",
        "\n",
        "    def ask_about_blowup(self):\n",
        "        axes, graph = self.get_axes_and_graph()\n",
        "        question = OldTexText(\"Is this possible?\")\n",
        "        question.set_color(YELLOW)\n",
        "        question.move_to(axes.get_corner(UR), LEFT)\n",
        "        question.align_to(axes, UP)\n",
        "        q_arrow = Arrow(\n",
        "            question.get_bottom(),\n",
        "            graph.point_from_proportion(0.8),\n",
        "            buff=SMALL_BUFF,\n",
        "            path_arc=-60 * DEGREES\n",
        "        )\n",
        "        q_arrow.set_stroke(WHITE, 3)\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "        morty.change('confused', graph)\n",
        "\n",
        "        self.play(\n",
        "            Write(axes, run_time=1),\n",
        "            self.reasonable_question.to_edge, LEFT,\n",
        "            self.reasonable_question.shift, DOWN,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(morty),\n",
        "        )\n",
        "        self.add(q_arrow, morty)\n",
        "        self.play(ShowCreation(q_arrow), Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(morty.look_at, question)\n",
        "        self.wait()\n",
        "        self.play(morty.change, \"maybe\", graph)\n",
        "        self.wait(2)\n",
        "        to_fade = VGroup(question, q_arrow, axes, graph)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, to_fade),\n",
        "            morty.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.morty = morty\n",
        "\n",
        "    def show_money(self):\n",
        "        # Million dollar problem\n",
        "        problem = OldTexText(\n",
        "            \"Navier-Stokes existence \\\\\\\\ and smoothness problems\"\n",
        "        )\n",
        "        money = OldTexText(\"\\\\$1{,}000{,}000\")\n",
        "        money.set_color(GREEN)\n",
        "        money.next_to(problem, DOWN)\n",
        "        pi1 = Randolph()\n",
        "        pi2 = self.morty\n",
        "        pi1.to_corner(DL)\n",
        "        pis = VGroup(pi1, pi2)\n",
        "        for pi in pis:\n",
        "            pi.change(\"pondering\")\n",
        "            pi.money_eyes = VGroup()\n",
        "            for eye in pi.eyes:\n",
        "                cash = OldTex(\"\\\\$\")\n",
        "                cash.set_color(GREEN)\n",
        "                cash.replace(eye, dim_to_match=1)\n",
        "                pi.money_eyes.add(cash)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                self.reasonable_question,\n",
        "                problem,\n",
        "            ),\n",
        "            pi2.look_at, problem,\n",
        "            pi1.look_at, problem,\n",
        "            VFadeIn(pi1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeInFromLarge(money))\n",
        "        self.play(\n",
        "            pi1.change, \"hooray\",\n",
        "            pi2.change, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(pi1.pupils, pi1.money_eyes),\n",
        "            ReplacementTransform(pi2.pupils, pi2.money_eyes),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    # Helpers\n",
        "    def get_axes_and_graph(self):\n",
        "        axes = Axes(\n",
        "            x_min=-1,\n",
        "            x_max=5,\n",
        "            y_min=-1,\n",
        "            y_max=5,\n",
        "        )\n",
        "        time = OldTexText(\"Time\")\n",
        "        time.next_to(axes.x_axis, RIGHT)\n",
        "        ke = OldTexText(\"Kinetic energy\")\n",
        "        ke.next_to(axes.y_axis, UP)\n",
        "        axes.add(time, ke)\n",
        "        axes.set_height(4)\n",
        "        axes.center()\n",
        "        axes.to_edge(DOWN)\n",
        "        v_line = DashedLine(\n",
        "            axes.coords_to_point(4, 0),\n",
        "            axes.coords_to_point(4, 5),\n",
        "        )\n",
        "        axes.add(v_line)\n",
        "        graph = axes.get_graph(\n",
        "            lambda x: -1.0 / (x - 4),\n",
        "            x_min=0.01,\n",
        "            x_max=3.8,\n",
        "        )\n",
        "        graph.set_color(BLUE)\n",
        "        return axes, graph\n",
        "\n",
        "\n",
        "class NewtonsSecond(Scene):\n",
        "    def construct(self):\n",
        "        square = Square(\n",
        "            stroke_color=WHITE,\n",
        "            fill_color=GREY_B,\n",
        "            fill_opacity=0.5,\n",
        "            side_length=1\n",
        "        )\n",
        "        label = OldTex(\"m\")\n",
        "        label.scale(1.5)\n",
        "        label.move_to(square)\n",
        "        square.add(label)\n",
        "        square.save_state()\n",
        "        arrows = VGroup(\n",
        "            Vector(0.5 * UP).next_to(square, UP, buff=0),\n",
        "            Vector(RIGHT).next_to(square, RIGHT, buff=0),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            square.shift, 4 * RIGHT + 2 * UP,\n",
        "            rate_func=lambda t: t**2,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        square.restore()\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows)\n",
        "        )\n",
        "        square.add(arrows)\n",
        "        self.play(\n",
        "            square.shift, 4 * RIGHT + 2 * UP,\n",
        "            rate_func=lambda t: t**2,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CandleLabel(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"Candle\")\n",
        "        arrow = Vector(DR, color=WHITE)\n",
        "        arrow.move_to(word.get_bottom() + SMALL_BUFF * DOWN, UL)\n",
        "        self.play(\n",
        "            FadeInFromDown(word),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FiguresOfFluidDynamics(Scene):\n",
        "    def construct(self):\n",
        "        names = [\n",
        "            \"Leonhard Euler\",\n",
        "            \"George Stokes\",\n",
        "            \"Hermann von Helmholtz\",\n",
        "            \"Lewis Richardson\",\n",
        "            \"Geoffrey Taylor\",\n",
        "            \"Andrey Kolmogorov\",\n",
        "        ]\n",
        "        images = Group(*[\n",
        "            ImageMobject(name.replace(\" \", \"_\"), height=3)\n",
        "            for name in names\n",
        "        ])\n",
        "        images.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        image_groups = Group()\n",
        "        for image, name in zip(images, names):\n",
        "            name_mob = OldTexText(name)\n",
        "            name_mob.scale(0.6)\n",
        "            name_mob.next_to(image, DOWN)\n",
        "            image_groups.add(Group(image, name_mob))\n",
        "        image_groups.arrange_in_grid(2, 3)\n",
        "        image_groups.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromDown, image_groups,\n",
        "            lag_ratio=0.5,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "        to_fade = image_groups[:-1]\n",
        "        to_fade.generate_target()\n",
        "        to_fade.target.space_out_submobjects(3)\n",
        "        to_fade.target.shift(3 * UL)\n",
        "        to_fade.target.fade(1)\n",
        "        self.play(\n",
        "            MoveToTarget(to_fade, remover=True),\n",
        "            image_groups[-1].set_height, 5,\n",
        "            image_groups[-1].center,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KineticEnergyBreakdown(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Kinetic energy breakdown\")\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        v_line = Line(h_line.get_center(), FRAME_HEIGHT * DOWN / 2)\n",
        "        lc_title = OldTexText(\"Simpler physics\")\n",
        "        lc_title.set_color(YELLOW)\n",
        "        rc_title = OldTexText(\"Turbulence physics\")\n",
        "        rc_title.set_color(GREEN)\n",
        "        for word, vect in (lc_title, LEFT), (rc_title, RIGHT):\n",
        "            word.next_to(h_line, DOWN)\n",
        "            word.shift(FRAME_WIDTH * vect / 4)\n",
        "\n",
        "        left_items = VGroup(\n",
        "            OldTexText(\"- Big moving things\"),\n",
        "            OldTexText(\"- Heat\"),\n",
        "        )\n",
        "        left_items.arrange(DOWN, aligned_edge=LEFT)\n",
        "        left_items.next_to(lc_title, DOWN, MED_LARGE_BUFF)\n",
        "        left_items.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(VGroup(*it.chain(\n",
        "                title, h_line, v_line, lc_title, rc_title\n",
        "            )))\n",
        "        )\n",
        "        self.wait()\n",
        "        for item in left_items:\n",
        "            self.play(FadeIn(item))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MovingCar(Scene):\n",
        "    def construct(self):\n",
        "        car = Car()\n",
        "        x = 3\n",
        "        car.move_to(x * LEFT)\n",
        "        self.play(MoveCar(car, x * RIGHT, run_time=4))\n",
        "\n",
        "\n",
        "class Heat(Scene):\n",
        "    def construct(self):\n",
        "        box = Square(\n",
        "            side_length=2,\n",
        "            stroke_color=WHITE,\n",
        "        )\n",
        "        balls = VGroup(*[\n",
        "            self.get_ball(box)\n",
        "            for x in range(20)\n",
        "        ])\n",
        "\n",
        "        self.add(box, balls)\n",
        "        self.wait(20)\n",
        "\n",
        "    def get_ball(self, box):\n",
        "        speed_factor = random.random()\n",
        "        ball = Dot(\n",
        "            radius=0.05,\n",
        "            color=interpolate_color(BLUE, RED, speed_factor)\n",
        "        )\n",
        "        speed = 2 + 3 * speed_factor\n",
        "        direction = rotate_vector(RIGHT, TAU * random.random())\n",
        "        ball.velocity = speed * direction\n",
        "        x0, y0, z0 = box.get_corner(DL)\n",
        "        x1, y1, z1 = box.get_corner(UR)\n",
        "        ball.move_to(np.array([\n",
        "            interpolate(x0, x1, random.random()),\n",
        "            interpolate(y0, y1, random.random()),\n",
        "            0\n",
        "        ]))\n",
        "\n",
        "        def update(ball, dt):\n",
        "            ball.shift(ball.velocity * dt)\n",
        "            if ball.get_left()[0] < box.get_left()[0]:\n",
        "                ball.velocity[0] = abs(ball.velocity[0])\n",
        "            if ball.get_right()[0] > box.get_right()[0]:\n",
        "                ball.velocity[0] = -abs(ball.velocity[0])\n",
        "            if ball.get_bottom()[1] < box.get_bottom()[1]:\n",
        "                ball.velocity[1] = abs(ball.velocity[1])\n",
        "            if ball.get_top()[1] > box.get_top()[1]:\n",
        "                ball.velocity[1] = -abs(ball.velocity[1])\n",
        "            return ball\n",
        "\n",
        "        ball.add_updater(update)\n",
        "        return ball\n",
        "\n",
        "\n",
        "class GrowArrowScene(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Arrow(UP, DOWN, color=WHITE)\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Poem(Scene):\n",
        "    def construct(self):\n",
        "        picture = ImageMobject(\"Lewis_Richardson\")\n",
        "        picture.set_height(4)\n",
        "        picture.center().to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        title = OldTexText(\"Poem by Lewis F. Richardson\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        poem_text = \"\"\"\n",
        "            Big{\\\\,\\\\,}whirls have little{\\\\,\\\\,}whirls\\\\\\\\\n",
        "            which feed on their velocity,\\\\\\\\\n",
        "            And little{\\\\,\\\\,}whirls have lesser{\\\\,\\\\,}whirls\\\\\\\\\n",
        "            And so on to viscosity.\\\\\\\\\n",
        "        \"\"\"\n",
        "        poem_words = [s for s in poem_text.split(\" \") if s]\n",
        "        poem = OldTexText(*poem_words, alignment=\"\")\n",
        "        poem.next_to(picture, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.add(picture)\n",
        "        self.play(FadeIn(title, DOWN))\n",
        "        self.wait()\n",
        "        for word in poem:\n",
        "            if \"whirl\" in word.get_tex():\n",
        "                word.set_color(BLUE)\n",
        "            self.play(ShowWord(word))\n",
        "            self.wait(0.005 * len(word)**1.5)\n",
        "\n",
        "\n",
        "class SwirlDiameterD(Scene):\n",
        "    def construct(self):\n",
        "        kwargs = {\n",
        "            \"path_arc\": PI,\n",
        "            \"buff\": SMALL_BUFF,\n",
        "            \"color\": WHITE\n",
        "        }\n",
        "        swirl = VGroup(\n",
        "            Arrow(RIGHT, LEFT, **kwargs),\n",
        "            Arrow(LEFT, RIGHT, **kwargs),\n",
        "        )\n",
        "        swirl.set_stroke(width=5)\n",
        "        f = 1.5\n",
        "        swirl.scale(f)\n",
        "\n",
        "        h_line = DashedLine(\n",
        "            f * LEFT, f * RIGHT,\n",
        "            color=YELLOW,\n",
        "        )\n",
        "        D_label = OldTex(\"D\")\n",
        "        D_label.scale(2)\n",
        "        D_label.next_to(h_line, UP, SMALL_BUFF)\n",
        "        D_label.match_color(h_line)\n",
        "        # diam = VGroup(h_line, D_label)\n",
        "\n",
        "        self.play(*map(ShowCreation, swirl))\n",
        "        self.play(\n",
        "            GrowFromCenter(h_line),\n",
        "            FadeIn(D_label, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KolmogorovGraph(Scene):\n",
        "    def construct(self):\n",
        "        axes = Axes(\n",
        "            x_min=-1,\n",
        "            y_min=-1,\n",
        "            x_max=7,\n",
        "            y_max=9,\n",
        "            y_axis_config={\n",
        "                \"unit_size\": 0.7,\n",
        "            }\n",
        "        )\n",
        "        axes.center().shift(1.5 * RIGHT)\n",
        "        x_label = OldTex(\"\\\\log(D)\")\n",
        "        x_label.next_to(axes.x_axis.get_right(), UP)\n",
        "        y_label = OldTex(\"\\\\log(\\\\text{K.E. at length scale D})\")\n",
        "        y_label.scale(0.8)\n",
        "        y_label.next_to(axes.y_axis.get_top(), LEFT)\n",
        "        y_label.shift_onto_screen()\n",
        "        axes.add(x_label, y_label)\n",
        "\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                axes.coords_to_point(x, 0),\n",
        "                axes.coords_to_point(x, 9),\n",
        "                color=YELLOW,\n",
        "                stroke_width=1\n",
        "            )\n",
        "            for x in [0.5, 5]\n",
        "        ])\n",
        "        inertial_subrange = OldTexText(\"``Inertial subrange''\")\n",
        "        inertial_subrange.scale(0.7)\n",
        "        inertial_subrange.next_to(v_lines.get_bottom(), UP)\n",
        "\n",
        "        def func(x):\n",
        "            if 0.5 < x < 5:\n",
        "                return (5 / 3) * x\n",
        "            elif x < 0.5:\n",
        "                return 5 * (x - 0.5) + 0.5 * (5 / 3)\n",
        "            elif x > 5:\n",
        "                return np.log(x) + (5 / 3) * 5 - np.log(5)\n",
        "\n",
        "        graph = axes.get_graph(func, x_min=0.3, x_max=7)\n",
        "\n",
        "        prop_label = OldTex(\"\\\\text{K.E.} \\\\propto D^{5/3}\")\n",
        "        prop_label.next_to(\n",
        "            graph.point_from_proportion(0.5), UL,\n",
        "            buff=0\n",
        "        )\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(FadeInFromDown(prop_label))\n",
        "        self.wait()\n",
        "        self.add(v_lines)\n",
        "        self.play(Write(inertial_subrange))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TechnicalNote(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Technical note:\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_color(RED)\n",
        "        self.add(title)\n",
        "\n",
        "        words = OldTexText(\"\"\"\n",
        "            This idea of quantifying the energy held at different\n",
        "            length scales is typically defined\n",
        "            in terms of an ``energy spectrum'' involving the Fourier\n",
        "            transform of a function measuring the correlations\n",
        "            between the fluid's velocities at different points in space.\n",
        "            I know, yikes!\n",
        "            \\\\quad\\\\\\\\\n",
        "            \\\\quad\\\\\\\\\n",
        "            Building up the relevant background for that is a bit cumbersome,\n",
        "            so we'll be thinking about the energy at different scales in\n",
        "            terms of all eddy's with a given diameter.  This is admittedly\n",
        "            a less well-defined notion, but it does capture the spirit\n",
        "            of Kolmogorov's result.\n",
        "            \\\\quad\\\\\\\\\n",
        "            \\\\quad\\\\\\\\\n",
        "            See the links in the description for more details,\n",
        "            if you're curious.\n",
        "        \"\"\", alignment=\"\")\n",
        "        words.scale(0.75)\n",
        "        words.next_to(title, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.add(title, words)\n",
        "\n",
        "\n",
        "class FiveThirds(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"5/3\", \"is a sort of fundamental\\\\\\\\ constant of turbulence\"\n",
        "        )\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(\"pondering\", \"maybe\", \"erm\")\n",
        "        self.play(\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            FadeOut(words[1]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            words[0].scale, 1.5,\n",
        "            words[0].move_to, self.hold_up_spot\n",
        "        )\n",
        "        self.play_student_changes(\"thinking\", \"pondering\", \"hooray\")\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class TurbulenceGifLabel(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Turbulence in 2d\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        attribution = OldTexText(\n",
        "            \"Animation by Gabe Weymouth (@gabrielweymouth)\"\n",
        "        )\n",
        "        attribution.scale(0.5)\n",
        "        attribution.to_edge(DOWN)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.play(FadeIn(attribution, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VortexStretchingLabel(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Vortex stretching\")\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VortedStretching(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"n_circles\": 200,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        axes = ThreeDAxes()\n",
        "        axes.set_stroke(width=1)\n",
        "        self.add(axes)\n",
        "        self.move_camera(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-145 * DEGREES,\n",
        "            run_time=0,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation()\n",
        "\n",
        "        short_circles = self.get_cylinder_circles(2, 0.5, 0.5)\n",
        "        tall_circles = short_circles.copy().scale(0.125)\n",
        "        tall_circles.stretch(16 * 4, 2)\n",
        "        torus_circles = tall_circles.copy()\n",
        "        for circle in torus_circles:\n",
        "            circle.shift(RIGHT)\n",
        "            z = circle.get_center()[2]\n",
        "            circle.shift(z * IN)\n",
        "            angle = PI * z / 2\n",
        "            circle.rotate(angle, axis=DOWN, about_point=ORIGIN)\n",
        "\n",
        "        circles = short_circles.copy()\n",
        "        flow_lines = self.get_flow_lines(circles)\n",
        "\n",
        "        self.add(circles, flow_lines)\n",
        "        self.play(LaggedStartMap(ShowCreation, circles))\n",
        "        self.wait(5)\n",
        "        self.play(Transform(circles, tall_circles, run_time=3))\n",
        "        self.wait(10)\n",
        "        self.play(Transform(\n",
        "            circles, torus_circles,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait(10)\n",
        "\n",
        "    def get_cylinder_circles(self, radius, radius_var, max_z):\n",
        "        return VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t: np.array([\n",
        "                    np.cos(TAU * t) * r,\n",
        "                    np.sin(TAU * t) * r,\n",
        "                    z\n",
        "                ]),\n",
        "                **self.get_circle_kwargs()\n",
        "            )\n",
        "            for z in sorted(max_z * np.random.random(self.n_circles))\n",
        "            for r in [radius + radius_var * random.random()]\n",
        "        ]).center()\n",
        "\n",
        "    def get_torus_circles(self, out_r, in_r, in_r_var):\n",
        "        result = VGroup()\n",
        "        for u in sorted(np.random.random(self.n_circles)):\n",
        "            r = in_r + in_r_var * random.random()\n",
        "            circle = ParametricCurve(\n",
        "                lambda t: r * np.array([\n",
        "                    np.cos(TAU * t),\n",
        "                    np.sin(TAU * t),\n",
        "                    0,\n",
        "                ]),\n",
        "                **self.get_circle_kwargs()\n",
        "            )\n",
        "            circle.shift(out_r * RIGHT)\n",
        "            circle.rotate(\n",
        "                TAU * u - PI,\n",
        "                about_point=ORIGIN,\n",
        "                axis=DOWN,\n",
        "            )\n",
        "            result.add(circle)\n",
        "        return result\n",
        "\n",
        "    def get_flow_lines(self, circle_group):\n",
        "        window = 0.3\n",
        "\n",
        "        def update_circle(circle, dt):\n",
        "            circle.total_time += dt\n",
        "            diameter = get_norm(\n",
        "                circle.template.point_from_proportion(0) -\n",
        "                circle.template.point_from_proportion(0.5)\n",
        "            )\n",
        "            modulus = np.sqrt(diameter) + 0.1\n",
        "            alpha = (circle.total_time % modulus) / modulus\n",
        "            circle.pointwise_become_partial(\n",
        "                circle.template,\n",
        "                max(interpolate(-window, 1, alpha), 0),\n",
        "                min(interpolate(0, 1 + window, alpha), 1),\n",
        "            )\n",
        "\n",
        "        result = VGroup()\n",
        "        for template in circle_group:\n",
        "            circle = template.deepcopy()\n",
        "            circle.set_stroke(\n",
        "                color=interpolate_color(BLUE_A, BLUE_E, random.random()),\n",
        "                # width=3 * random.random()\n",
        "                width=1,\n",
        "            )\n",
        "            circle.template = template\n",
        "            circle.total_time = 4 * random.random()\n",
        "            circle.add_updater(update_circle)\n",
        "            result.add(circle)\n",
        "        return result\n",
        "\n",
        "    def get_circle_kwargs(self):\n",
        "        return {\n",
        "            \"stroke_color\": BLACK,\n",
        "            \"stroke_width\": 0,\n",
        "        }\n",
        "\n",
        "\n",
        "class TurbulenceEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\": [\n",
        "            \"1stViewMaths\",\n",
        "            \"Adrian Robinson\",\n",
        "            \"Alexis Olson\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Ankalagon\",\n",
        "            \"Art Ianuzzi\",\n",
        "            \"Awoo\",\n",
        "            \"Ayan Doss\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Brian Staroselsky\",\n",
        "            \"Britt Selvitelle\",\n",
        "            \"Carla Kirby\",\n",
        "            \"Charles Southerland\",\n",
        "            \"Chris Connett\",\n",
        "            \"Christian Kaiser\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Danger Dai\",\n",
        "            \"Dave B\",\n",
        "            \"Dave Kester\",\n",
        "            \"David Clark\",\n",
        "            \"Delton Ding\",\n",
        "            \"Devarsh Desai\",\n",
        "            \"eaglle\",\n",
        "            \"Eric Younge\",\n",
        "            \"Eryq Ouithaqueue\",\n",
        "            \"Federico Lebron\",\n",
        "            \"Florian Chudigiewitsch\",\n",
        "            \"Giovanni Filippi\",\n",
        "            \"Hal Hildebrand\",\n",
        "            \"Igor Napolskikh\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Jameel Syed\",\n",
        "            \"James Hughes\",\n",
        "            \"Jan Pijpers\",\n",
        "            \"Jason Hise\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Jeff Straathof\",\n",
        "            \"Jerry Ling\",\n",
        "            \"John Griffith\",\n",
        "            \"John Haley\",\n",
        "            \"John V Wertheim\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Jonathan Wilson\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Kai-Siang Ang\",\n",
        "            \"Kanan Gill\",\n",
        "            \"L0j1k\",\n",
        "            \"Linh Tran\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Ludwig Schubert\",\n",
        "            \"Lukas -krtek.net- Novy\",\n",
        "            \"Magister Mugit\",\n",
        "            \"Magnus Dahlstr\u00f6m\",\n",
        "            \"Mark B Bahu\",\n",
        "            \"Markus Persson\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"Matt Langford\",\n",
        "            \"Matt Roveto\",\n",
        "            \"Matthew Cocke\",\n",
        "            \"Mehdi Razavi\",\n",
        "            \"Michael Faust\",\n",
        "            \"Michael Hardel\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"M\u00e1rton Vaitkus\",\n",
        "            \"Nero Li\",\n",
        "            \"Oliver Steele\",\n",
        "            \"Omar Zrien\",\n",
        "            \"Peter Ehrnstrom\",\n",
        "            \"Prasant Jagannath\",\n",
        "            \"Randy C. Will\",\n",
        "            \"Richard Burgmann\",\n",
        "            \"Ripta Pasay\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Robert Teed\",\n",
        "            \"Roobie\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Ryan Williams\",\n",
        "            \"Sindre Reino Trosterud\",\n",
        "            \"Solara570\",\n",
        "            \"Song Gao\",\n",
        "            \"Steven Soloway\",\n",
        "            \"Steven Tomlinson\",\n",
        "            \"Stevie Metke\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Valeriy Skobelev\",\n",
        "            \"Xavier Bernard\",\n",
        "            \"Yaw Etse\",\n",
        "            \"YinYangBalance.Asia\",\n",
        "            \"Zach Cardwell\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class LaserWord(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Laser\").scale(2))\n",
        "\n",
        "\n",
        "class TurbulenceWord(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"Turbulence\").scale(2))\n",
        "\n",
        "\n",
        "class ArrowScene(Scene):\n",
        "    def construct(self):\n",
        "        arrow = Arrow(LEFT, RIGHT, color=WHITE)\n",
        "        arrow.add_to_back(arrow.copy().set_stroke(BLACK, 5))\n",
        "        self.add(arrow)\n"
    ]
}