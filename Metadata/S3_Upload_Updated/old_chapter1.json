{
    "topic": "is demonstrating the concept of a circle with a radius and a center point.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "#### Warning, scenes here not updated based on most recent GraphScene changes #######\n",
        "\n",
        "class CircleScene(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 1.5,\n",
        "        \"stroke_color\" : WHITE,\n",
        "        \"fill_color\" : BLUE_E,\n",
        "        \"fill_opacity\" : 0.5,\n",
        "        \"radial_line_color\" : MAROON_B,\n",
        "        \"outer_ring_color\" : GREEN_E,\n",
        "        \"dR\" : 0.1,\n",
        "        \"dR_color\" : YELLOW,\n",
        "        \"unwrapped_tip\" : ORIGIN,\n",
        "        \"include_pi_creature\" : False,\n",
        "        \"circle_corner\" : UP+LEFT\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.circle = Circle(\n",
        "            radius = self.radius,\n",
        "            stroke_color = self.stroke_color,\n",
        "            fill_color = self.fill_color,\n",
        "            fill_opacity = self.fill_opacity,\n",
        "        )\n",
        "        self.circle.to_corner(self.circle_corner, buff = MED_LARGE_BUFF)\n",
        "        self.radius_line = Line(\n",
        "            self.circle.get_center(),\n",
        "            self.circle.get_right(),\n",
        "            color = self.radial_line_color\n",
        "        )\n",
        "        self.radius_brace = Brace(self.radius_line, buff = SMALL_BUFF)\n",
        "        self.radius_label = self.radius_brace.get_text(\"$R$\", buff = SMALL_BUFF)\n",
        "\n",
        "        self.add(\n",
        "            self.circle, self.radius_line, \n",
        "            self.radius_brace, self.radius_label\n",
        "        )\n",
        "\n",
        "        self.pi_creature = self.create_pi_creature()\n",
        "        if self.include_pi_creature:\n",
        "            self.add(self.pi_creature)\n",
        "        else:\n",
        "            self.pi_creature.set_fill(opacity = 0)\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        return Mortimer().to_corner(DOWN+RIGHT)\n",
        "\n",
        "    def introduce_circle(self, added_anims = []):\n",
        "        self.remove(self.circle)\n",
        "        self.play(\n",
        "            ShowCreation(self.radius_line),\n",
        "            GrowFromCenter(self.radius_brace),\n",
        "            Write(self.radius_label),\n",
        "        )\n",
        "        self.circle.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                self.radius_line, 2*np.pi-0.001, \n",
        "                about_point = self.circle.get_center(),\n",
        "            ),\n",
        "            ShowCreation(self.circle),\n",
        "            *added_anims,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            self.circle.set_fill, self.fill_color, self.fill_opacity,\n",
        "            Animation(self.radius_line),\n",
        "            Animation(self.radius_brace),\n",
        "            Animation(self.radius_label),\n",
        "        )\n",
        "\n",
        "    def increase_radius(self, numerical_dr = True, run_time = 2):\n",
        "        radius_mobs = VGroup(\n",
        "            self.radius_line, self.radius_brace, self.radius_label\n",
        "        )\n",
        "        nudge_line = Line(\n",
        "            self.radius_line.get_right(),\n",
        "            self.radius_line.get_right() + self.dR*RIGHT,\n",
        "            color = self.dR_color\n",
        "        )\n",
        "        nudge_arrow = Arrow(\n",
        "            nudge_line.get_center() + 0.5*RIGHT+DOWN,\n",
        "            nudge_line.get_center(),\n",
        "            color = YELLOW,\n",
        "            buff = SMALL_BUFF,\n",
        "            tip_length = 0.2,\n",
        "        )\n",
        "        if numerical_dr:\n",
        "            nudge_label = OldTex(\"%.01f\"%self.dR)\n",
        "        else:\n",
        "            nudge_label = OldTex(\"dr\")\n",
        "        nudge_label.set_color(self.dR_color)\n",
        "        nudge_label.scale(0.75)\n",
        "        nudge_label.next_to(nudge_arrow.get_start(), DOWN)\n",
        "\n",
        "        radius_mobs.add(nudge_line, nudge_arrow, nudge_label)\n",
        "\n",
        "        outer_ring = self.get_outer_ring()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(outer_ring),            \n",
        "            ShowCreation(nudge_line),\n",
        "            ShowCreation(nudge_arrow),\n",
        "            Write(nudge_label),\n",
        "            run_time = run_time/2.\n",
        "        )\n",
        "        self.wait(run_time/2.)\n",
        "        self.nudge_line = nudge_line\n",
        "        self.nudge_arrow = nudge_arrow\n",
        "        self.nudge_label = nudge_label\n",
        "        self.outer_ring = outer_ring\n",
        "        return outer_ring\n",
        "\n",
        "    def get_ring(self, radius, dR, color = GREEN):\n",
        "        ring = Circle(radius = radius + dR).center()\n",
        "        inner_ring = Circle(radius = radius)\n",
        "        inner_ring.rotate(np.pi, RIGHT)\n",
        "        ring.append_vectorized_mobject(inner_ring)\n",
        "        ring.set_stroke(width = 0)\n",
        "        ring.set_fill(color)\n",
        "        ring.move_to(self.circle)\n",
        "        ring.R = radius \n",
        "        ring.dR = dR\n",
        "        return ring\n",
        "\n",
        "    def get_outer_ring(self):\n",
        "        return self.get_ring(\n",
        "            radius = self.radius, dR = self.dR,\n",
        "            color = self.outer_ring_color\n",
        "        )\n",
        "\n",
        "    def unwrap_ring(self, ring, **kwargs):\n",
        "        self.unwrap_rings(ring, **kwargs)\n",
        "\n",
        "    def unwrap_rings(self, *rings, **kwargs):\n",
        "        added_anims = kwargs.get(\"added_anims\", [])\n",
        "        rings = VGroup(*rings)\n",
        "        unwrapped = VGroup(*[\n",
        "            self.get_unwrapped(ring, **kwargs)\n",
        "            for ring in rings\n",
        "        ])\n",
        "        self.play(\n",
        "            rings.rotate, np.pi/2,\n",
        "            rings.next_to, unwrapped.get_bottom(), UP,\n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(rings, unwrapped, run_time = 3),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def get_unwrapped(self, ring, to_edge = LEFT, **kwargs):\n",
        "        R = ring.R\n",
        "        R_plus_dr = ring.R + ring.dR\n",
        "        n_anchors = ring.get_num_curves()\n",
        "        result = VMobject()\n",
        "        result.set_points_as_corners([\n",
        "            interpolate(np.pi*R_plus_dr*LEFT,  np.pi*R_plus_dr*RIGHT, a)\n",
        "            for a in np.linspace(0, 1, n_anchors/2)\n",
        "        ]+[\n",
        "            interpolate(np.pi*R*RIGHT+ring.dR*UP,  np.pi*R*LEFT+ring.dR*UP, a)\n",
        "            for a in np.linspace(0, 1, n_anchors/2)\n",
        "        ])\n",
        "        result.set_style_data(\n",
        "            stroke_color = ring.get_stroke_color(),\n",
        "            stroke_width = ring.get_stroke_width(),\n",
        "            fill_color = ring.get_fill_color(),\n",
        "            fill_opacity = ring.get_fill_opacity(),\n",
        "        )\n",
        "        result.move_to(self.unwrapped_tip, aligned_edge = DOWN)\n",
        "        result.shift(R_plus_dr*DOWN)\n",
        "        result.to_edge(to_edge)\n",
        "\n",
        "        return result\n",
        "\n",
        "######################\n",
        "\n",
        "class PatronsOnly(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.shift(2*DOWN)\n",
        "        title = OldTexText(\"\"\"\n",
        "            This is a draft\n",
        "            for patrons only\n",
        "        \"\"\")\n",
        "        title.set_color(RED)\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            morty.change_mode, \"wave_1\"\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"pondering\",\n",
        "            morty.look_at, title\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class Introduction(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.show_series()\n",
        "        self.look_to_center()        \n",
        "        self.go_through_students()\n",
        "        self.zoom_in_on_first()\n",
        "\n",
        "    def show_series(self):\n",
        "        series = VideoSeries()\n",
        "        series.to_edge(UP)\n",
        "        this_video = series[0]\n",
        "        this_video.set_color(YELLOW)\n",
        "        this_video.save_state()\n",
        "        this_video.set_fill(opacity = 0)\n",
        "        this_video.center()\n",
        "        this_video.set_height(FRAME_HEIGHT)\n",
        "        self.this_video = this_video\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Welcome to \\\\\\\\\",\n",
        "            \"Essence of calculus\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Essence of calculus\", YELLOW)\n",
        "        self.remove(self.teacher)\n",
        "        self.teacher.change_mode(\"happy\")\n",
        "        self.add(self.teacher)\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                series,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            ),\n",
        "            Blink(self.get_teacher())\n",
        "        )\n",
        "        self.teacher_says(words, target_mode = \"hooray\")\n",
        "        self.play(\n",
        "            ApplyMethod(this_video.restore, run_time = 3),\n",
        "            *[\n",
        "                ApplyFunction(\n",
        "                    lambda p : p.change_mode(\"hooray\").look_at(series[1]),\n",
        "                    pi\n",
        "                )\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        def homotopy(x, y, z, t):\n",
        "            alpha = (0.7*x + FRAME_X_RADIUS)/(FRAME_WIDTH)\n",
        "            beta = squish_rate_func(smooth, alpha-0.15, alpha+0.15)(t)\n",
        "            return (x, y - 0.3*np.sin(np.pi*beta), z)\n",
        "        self.play(\n",
        "            Homotopy(\n",
        "                homotopy, series, \n",
        "                apply_function_kwargs = {\"maintain_smoothness\" : False},\n",
        "            ),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, series[-1])\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ],\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.teacher.bubble),\n",
        "            FadeOut(self.teacher.bubble.content),\n",
        "            *[\n",
        "                ApplyMethod(pi.change_mode, \"happy\")\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "\n",
        "    def look_to_center(self):\n",
        "        anims = []\n",
        "        for pi in self.get_pi_creatures():\n",
        "            anims += [\n",
        "                pi.change_mode, \"pondering\",\n",
        "                pi.look_at, 2*UP\n",
        "            ]\n",
        "        self.play(*anims)\n",
        "        self.random_blink(6)\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change_mode, \"happy\")\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "\n",
        "    def go_through_students(self):\n",
        "        pi1, pi2, pi3 = self.get_students()\n",
        "        for pi in pi1, pi2, pi3:\n",
        "            pi.save_state()\n",
        "        bubble = pi1.get_bubble(width = 5)\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "        remembered_symbols = VGroup(\n",
        "            OldTex(\"\\\\int_0^1 \\\\frac{1}{1-x^2}\\\\,dx\").shift(UP+LEFT),\n",
        "            OldTex(\"\\\\frac{d}{dx} e^x = e^x\").shift(DOWN+RIGHT),\n",
        "        )\n",
        "        cant_wait = OldTexText(\"I literally \\\\\\\\ can't wait\")\n",
        "        big_derivative = OldTex(\"\"\"\n",
        "            \\\\frac{d}{dx} \\\\left( \\\\sin(x^2)2^{\\\\sqrt{x}} \\\\right)\n",
        "        \"\"\")\n",
        "\n",
        "        self.play(\n",
        "            pi1.change_mode, \"confused\",\n",
        "            pi1.look_at, bubble.get_right(),\n",
        "            ShowCreation(bubble),\n",
        "            pi2.fade,\n",
        "            pi3.fade,\n",
        "        )\n",
        "        bubble.add_content(remembered_symbols)\n",
        "        self.play(Write(remembered_symbols))\n",
        "        self.play(ApplyMethod(\n",
        "            remembered_symbols.fade, 0.7,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.play(\n",
        "            pi1.restore,\n",
        "            pi1.fade,\n",
        "            pi2.restore,\n",
        "            pi2.change_mode, \"hooray\",\n",
        "            pi2.look_at, bubble.get_right(),\n",
        "            bubble.pin_to, pi2,\n",
        "            FadeOut(remembered_symbols),\n",
        "        )\n",
        "        bubble.add_content(cant_wait)\n",
        "        self.play(Write(cant_wait, run_time = 2))\n",
        "        self.play(Blink(pi2))\n",
        "        self.play(\n",
        "            pi2.restore,\n",
        "            pi2.fade,\n",
        "            pi3.restore,\n",
        "            pi3.change_mode, \"pleading\",\n",
        "            pi3.look_at, bubble.get_right(),\n",
        "            bubble.pin_to, pi3,\n",
        "            FadeOut(cant_wait)\n",
        "        )\n",
        "        bubble.add_content(big_derivative)\n",
        "        self.play(Write(big_derivative))\n",
        "        self.play(Blink(pi3))\n",
        "        self.wait()\n",
        "\n",
        "    def zoom_in_on_first(self):\n",
        "        this_video = self.this_video\n",
        "        self.remove(this_video)\n",
        "        this_video.generate_target()\n",
        "        this_video.target.set_height(FRAME_HEIGHT)\n",
        "        this_video.target.center()        \n",
        "        this_video.target.set_fill(opacity = 0)\n",
        "\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        self.play(\n",
        "            FadeOut(everything),\n",
        "            MoveToTarget(this_video, run_time = 2)\n",
        "        )\n",
        "\n",
        "class IntroduceCircle(Scene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius = 3, color = WHITE)\n",
        "        circle.to_edge(LEFT)\n",
        "        radius = Line(circle.get_center(), circle.get_right())\n",
        "        radius.set_color(MAROON_B)\n",
        "        R = OldTex(\"R\").next_to(radius, UP)\n",
        "\n",
        "        area, circumference = words = VGroup(*list(map(TexText, [\n",
        "            \"Area =\", \"Circumference =\"\n",
        "        ])))\n",
        "        area.set_color(BLUE)\n",
        "        circumference.set_color(YELLOW)\n",
        "\n",
        "        words.arrange(DOWN, aligned_edge = LEFT)\n",
        "        words.next_to(circle, RIGHT)\n",
        "        words.to_edge(UP)\n",
        "        pi_R, pre_squared = OldTex(\"\\\\pi R\", \"{}^2\")\n",
        "        squared = OldTex(\"2\").replace(pre_squared)\n",
        "        area_form = VGroup(pi_R, squared)\n",
        "        area_form.next_to(area, RIGHT)\n",
        "        two, pi_R = OldTex(\"2\", \"\\\\pi R\")\n",
        "        circum_form = VGroup(pi_R, two)\n",
        "        circum_form.next_to(circumference, RIGHT)\n",
        "\n",
        "        derivative = OldTex(\n",
        "            \"\\\\frac{d}{dR}\", \"\\\\pi R^2\", \"=\", \"2\\\\pi R\"\n",
        "        )\n",
        "        integral = OldTex(\n",
        "            \"\\\\int_0^R\", \"2\\\\pi r\", \"\\\\, dR = \", \"\\\\pi R^2\"\n",
        "        )\n",
        "        up_down_arrow = OldTex(\"\\\\Updownarrow\")\n",
        "        calc_stuffs = VGroup(derivative, up_down_arrow, integral)\n",
        "        calc_stuffs.arrange(DOWN)\n",
        "        calc_stuffs.next_to(words, DOWN, buff = LARGE_BUFF, aligned_edge = LEFT)\n",
        "\n",
        "        brace = Brace(calc_stuffs, RIGHT)\n",
        "        to_be_explained = brace.get_text(\"To be \\\\\\\\ explained\")\n",
        "        VGroup(brace, to_be_explained).set_color(GREEN)\n",
        "\n",
        "        self.play(ShowCreation(radius), Write(R))\n",
        "        self.play(\n",
        "            Rotate(radius, 2*np.pi, about_point = circle.get_center()),\n",
        "            ShowCreation(circle)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(area),\n",
        "            Write(area_form),\n",
        "            circle.set_fill, area.get_color(), 0.5,\n",
        "            Animation(radius),\n",
        "            Animation(R),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            circle.set_stroke, circumference.get_color(),\n",
        "            FadeIn(circumference),\n",
        "            Animation(radius),\n",
        "            Animation(R),\n",
        "        )\n",
        "        self.play(Transform(\n",
        "            area_form.copy(),\n",
        "            circum_form,\n",
        "            path_arc = -np.pi/2,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            area_form.copy().replace, derivative[1],\n",
        "            circum_form.copy().replace, derivative[3],\n",
        "            Write(derivative[0]),\n",
        "            Write(derivative[2]),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            area_form.copy().replace, integral[3],\n",
        "            Transform(circum_form.copy(), integral[1]),\n",
        "            Write(integral[0]),\n",
        "            Write(integral[2]),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(up_down_arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(to_be_explained)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class HeartOfCalculus(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.graph_function(lambda x : 3*np.sin(x/2) + x)\n",
        "        rect_sets = [\n",
        "            self.get_riemann_rectangles(\n",
        "                0, self.x_max, 1./(2**n), stroke_width = 1./(n+1)\n",
        "            )\n",
        "            for n in range(6)\n",
        "        ]\n",
        "\n",
        "        rects = rect_sets.pop(0)\n",
        "        rects.save_state()\n",
        "        rects.stretch_to_fit_height(0)\n",
        "        rects.shift(\n",
        "            (self.graph_origin[1] - rects.get_center()[1])*UP\n",
        "        )\n",
        "        self.play(\n",
        "            rects.restore,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        )\n",
        "        while rect_sets:\n",
        "            self.play(\n",
        "                Transform(rects, rect_sets.pop(0)),\n",
        "                run_time = 2\n",
        "            )\n",
        "\n",
        "class PragmatismToArt(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        morty.shift(LEFT)\n",
        "        pragmatism = OldTexText(\"Pragmatism\")\n",
        "        art = OldTexText(\"Art\")\n",
        "        pragmatism.move_to(morty.get_corner(UP+LEFT), aligned_edge = DOWN)\n",
        "        art.move_to(morty.get_corner(UP+RIGHT), aligned_edge = DOWN)\n",
        "        art.shift(0.2*(LEFT+UP))\n",
        "\n",
        "        circle1 = Circle(\n",
        "            radius = 2,\n",
        "            fill_opacity = 1,\n",
        "            fill_color = BLUE_E,            \n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        circle2 = Circle(\n",
        "            radius = 2,\n",
        "            stroke_color = YELLOW\n",
        "        )\n",
        "        arrow = DoubleArrow(LEFT, RIGHT, color = WHITE)\n",
        "        circle_group = VGroup(circle1, arrow, circle2)\n",
        "        circle_group.arrange()\n",
        "        circle_group.to_corner(UP+LEFT)\n",
        "        circle2.save_state()\n",
        "        circle2.move_to(circle1)\n",
        "        q_marks = OldTexText(\"???\").next_to(arrow, UP)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, pragmatism,\n",
        "            Write(pragmatism, run_time = 1),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_left_hand\",\n",
        "            morty.look_at, art,\n",
        "            Transform(\n",
        "                VectorizedPoint(morty.get_corner(UP+RIGHT)),\n",
        "                art\n",
        "            ),\n",
        "            pragmatism.fade, 0.7,\n",
        "            pragmatism.rotate, np.pi/4,\n",
        "            pragmatism.shift, DOWN+LEFT\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            GrowFromCenter(circle1),\n",
        "            morty.look_at, circle1\n",
        "        )\n",
        "        self.play(ShowCreation(circle2))\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(q_marks),\n",
        "            circle2.restore\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "class IntroduceTinyChangeInArea(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"include_pi_creature\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        new_area_form, minus, area_form = expression = OldTex(\n",
        "            \"\\\\pi (R + 0.1)^2\", \"-\", \"\\\\pi R^2\"\n",
        "        )\n",
        "        VGroup(*new_area_form[4:7]).set_color(self.dR_color)\n",
        "        expression_brace = Brace(expression, UP)\n",
        "        change_in_area = expression_brace.get_text(\"Change in area\")\n",
        "        change_in_area.set_color(self.outer_ring_color)\n",
        "        area_brace = Brace(area_form)\n",
        "        area_word = area_brace.get_text(\"Area\")\n",
        "        area_word.set_color(BLUE)\n",
        "        new_area_brace = Brace(new_area_form)\n",
        "        new_area_word = new_area_brace.get_text(\"New area\")\n",
        "        group = VGroup(\n",
        "            expression, expression_brace, change_in_area,\n",
        "            area_brace, area_word, new_area_brace, new_area_word\n",
        "        )\n",
        "        group.to_edge(UP).shift(RIGHT)\n",
        "        group.save_state()\n",
        "        area_group = VGroup(area_form, area_brace, area_word)\n",
        "        area_group.save_state()\n",
        "        area_group.next_to(self.circle, RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.introduce_circle(\n",
        "            added_anims = [self.pi_creature.change_mode, \"speaking\"]\n",
        "        )\n",
        "        self.play(Write(area_group))\n",
        "        self.change_mode(\"happy\")\n",
        "        outer_ring = self.increase_radius()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            area_group.restore,            \n",
        "            GrowFromCenter(expression_brace),\n",
        "            Write(new_area_form), \n",
        "            Write(minus), \n",
        "            Write(change_in_area),\n",
        "            self.pi_creature.change_mode, \"confused\",\n",
        "        )\n",
        "        self.play(\n",
        "            Write(new_area_word),\n",
        "            GrowFromCenter(new_area_brace)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            group.fade, 0.7,\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            outer_ring.set_color, YELLOW,\n",
        "            Animation(self.nudge_arrow),\n",
        "            Animation(self.nudge_line),\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.show_unwrapping(outer_ring)\n",
        "        self.play(group.restore)\n",
        "        self.work_out_expression(group)\n",
        "        self.second_unwrapping(outer_ring)\n",
        "        insignificant = OldTexText(\"Insignificant\")\n",
        "        insignificant.set_color(self.dR_color)\n",
        "        insignificant.move_to(self.error_words)\n",
        "        self.play(Transform(self.error_words, insignificant))\n",
        "        self.wait()\n",
        "\n",
        "        big_rect = Rectangle(\n",
        "            width = FRAME_WIDTH,\n",
        "            height = FRAME_HEIGHT,\n",
        "            fill_color = BLACK, \n",
        "            fill_opacity = 0.85,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(big_rect),\n",
        "            area_form.set_color, BLUE,\n",
        "            self.two_pi_R.set_color, GREEN,\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "\n",
        "    def show_unwrapping(self, outer_ring):\n",
        "        almost_rect = outer_ring.copy()        \n",
        "        self.unwrap_ring(\n",
        "            almost_rect,\n",
        "            added_anims = [self.pi_creature.change_mode, \"pondering\"]\n",
        "        )\n",
        "\n",
        "        circum_brace = Brace(almost_rect, UP).scale(0.95)\n",
        "        dR_brace = OldTex(\"\\\\}\")\n",
        "        dR_brace.stretch(0.5, 1)\n",
        "        dR_brace.next_to(almost_rect, RIGHT)\n",
        "        two_pi_R = circum_brace.get_text(\"$2\\\\pi R$\")\n",
        "        dR = OldTex(\"$0.1$\").scale(0.7).next_to(dR_brace, RIGHT)\n",
        "        dR.set_color(self.dR_color)\n",
        "\n",
        "        two_pi_R.generate_target()\n",
        "        dR.generate_target()\n",
        "        lp, rp = OldTex(\"()\")\n",
        "        change_in_area = OldTexText(\n",
        "            \"Change in area $\\\\approx$\"\n",
        "        )\n",
        "        final_area = VGroup(\n",
        "            change_in_area,\n",
        "            two_pi_R.target, lp, dR.target.scale(1./0.7), rp\n",
        "        )\n",
        "        final_area.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        final_area.next_to(almost_rect, DOWN, buff = MED_LARGE_BUFF)\n",
        "        final_area.set_color(GREEN_A)\n",
        "        final_area[3].set_color(self.dR_color)\n",
        "        change_in_area.shift(0.1*LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(circum_brace),\n",
        "            Write(two_pi_R)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(dR_brace),\n",
        "            Write(dR)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(two_pi_R.copy()),\n",
        "            MoveToTarget(dR.copy()),\n",
        "            Write(change_in_area, run_time = 1),\n",
        "            Write(lp),\n",
        "            Write(rp),\n",
        "        )\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(final_area)\n",
        "        self.play(\n",
        "            self.pi_creature.change_mode, \"happy\",\n",
        "            self.pi_creature.look_at, final_area\n",
        "        )\n",
        "        self.wait()\n",
        "        group = VGroup(\n",
        "            almost_rect, final_area, two_pi_R, dR,\n",
        "            circum_brace, dR_brace\n",
        "        )\n",
        "        self.play(group.fade)\n",
        "\n",
        "    def work_out_expression(self, expression_group):\n",
        "        exp, exp_brace, title, area_brace, area_word, new_area_brace, new_area_word = expression_group\n",
        "        new_area_form, minus, area_form = exp\n",
        "\n",
        "        expanded = OldTex(\n",
        "            \"\\\\pi R^2\", \"+\", \"2\\\\pi R (0.1)\", \n",
        "            \"+\", \"\\\\pi (0.1)^2\", \"-\", \"\\\\pi R^2\",\n",
        "        )\n",
        "        pi_R_squared, plus, two_pi_R_dR, plus2, pi_dR_squared, minus2, pi_R_squared2 = expanded\n",
        "        for subset in two_pi_R_dR[4:7], pi_dR_squared[2:5]:\n",
        "            VGroup(*subset).set_color(self.dR_color)\n",
        "        expanded.next_to(new_area_form, DOWN, aligned_edge = LEFT, buff = MED_SMALL_BUFF)\n",
        "        expanded.shift(LEFT/2.)\n",
        "\n",
        "        faders = [area_brace, area_word, new_area_brace, new_area_word]\n",
        "        self.play(*list(map(FadeOut, faders)))\n",
        "        trips = [\n",
        "            ([0, 2, 8], pi_R_squared, plus),\n",
        "            ([8, 0, 2, 1, 4, 5, 6, 7], two_pi_R_dR, plus2),\n",
        "            ([0, 1, 4, 5, 6, 7, 8], pi_dR_squared, VGroup()),\n",
        "        ]\n",
        "        to_remove = []\n",
        "        for subset, target, writer in trips:\n",
        "            starter = VGroup(\n",
        "                *np.array(list(new_area_form.copy()))[subset]\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(starter, target, run_time = 2),\n",
        "                Write(writer)\n",
        "            )\n",
        "            to_remove += self.get_mobjects_from_last_animation()\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            Transform(minus.copy(), minus2),\n",
        "            Transform(area_form.copy(), pi_R_squared2),\n",
        "        )\n",
        "        to_remove += self.get_mobjects_from_last_animation()\n",
        "        self.remove(*to_remove)\n",
        "        self.add(self.pi_creature, *expanded)\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.set_color, RED)\n",
        "            for mob in (pi_R_squared, pi_R_squared2)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.fade, 0.7)\n",
        "            for mob in (plus, pi_R_squared, pi_R_squared2, minus2)\n",
        "        ]) \n",
        "        self.wait()\n",
        "\n",
        "        approx_brace = Brace(two_pi_R_dR)\n",
        "        error_brace = Brace(pi_dR_squared, buff = SMALL_BUFF)\n",
        "        error_words = error_brace.get_text(\"Error\", buff = SMALL_BUFF)\n",
        "        error_words.set_color(RED)\n",
        "        self.error_words = error_words\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(approx_brace),\n",
        "            self.pi_creature.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(error_brace),\n",
        "            Write(error_words),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.two_pi_R = VGroup(*two_pi_R_dR[:3])\n",
        "\n",
        "    def second_unwrapping(self, outer_ring):\n",
        "        almost_rect = outer_ring.copy()\n",
        "        rect = Rectangle(\n",
        "            width = 2*np.pi*self.radius,\n",
        "            height = self.dR,\n",
        "            fill_color = self.outer_ring_color,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        self.play(\n",
        "            almost_rect.set_color, YELLOW,\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.unwrap_ring(almost_rect)\n",
        "        self.wait()\n",
        "        rect.move_to(almost_rect)\n",
        "        self.play(FadeIn(rect))\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        return morty\n",
        "\n",
        "class CleanUpABit(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Let's clean that\n",
        "            up a bit\n",
        "        \"\"\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class BuildToDADR(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"include_pi_creature\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.outer_ring = self.increase_radius()\n",
        "        self.write_initial_terms()\n",
        "        self.show_fractions()\n",
        "        self.transition_to_dR()\n",
        "        self.elaborate_on_d()\n",
        "        self.not_infinitely_small()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        return morty\n",
        "\n",
        "    def write_initial_terms(self):\n",
        "        change = OldTexText(\"Change in area\")\n",
        "        change.set_color(GREEN_B)\n",
        "        equals, two_pi_R, dR, plus, pi, dR2, squared = rhs = OldTex(\n",
        "            \"=\", \"2 \\\\pi R\", \"(0.1)\", \"+\", \"\\\\pi\", \"(0.1)\", \"^2\"\n",
        "        )\n",
        "        VGroup(dR, dR2).set_color(self.dR_color)\n",
        "        change.next_to(self.circle, buff = LARGE_BUFF)\n",
        "        rhs.next_to(change)\n",
        "\n",
        "        circum_brace = Brace(two_pi_R, UP)\n",
        "        circum_text = circum_brace.get_text(\"Circumference\")\n",
        "        error_brace = Brace(VGroup(pi, squared), UP)\n",
        "        error_text = error_brace.get_text(\"Error\")\n",
        "        error_text.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            Write(change, run_time = 1),\n",
        "            self.pi_creature.change_mode, \"pondering\",\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, [equals, two_pi_R, dR])),\n",
        "            list(map(FadeIn, [circum_text, circum_brace]))\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, [plus, pi, dR2, squared])),\n",
        "            list(map(FadeIn, [error_brace, error_text]))\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.change = change\n",
        "        self.circum_term = VGroup(two_pi_R, dR)\n",
        "        self.circum_term.label = VGroup(circum_brace, circum_text)\n",
        "        self.error_term = VGroup(pi, dR2, squared)\n",
        "        self.error_term.label = VGroup(error_brace, error_text)        \n",
        "        self.equals = equals\n",
        "        self.plus = plus\n",
        "\n",
        "    def show_fractions(self):\n",
        "        terms = [self.change, self.circum_term, self.error_term]\n",
        "        for term in terms:\n",
        "            term.frac_line = OldTex(\"\\\\frac{\\\\quad}{\\\\quad}\")\n",
        "            term.frac_line.stretch_to_fit_width(term.get_width())\n",
        "            term.frac_line.next_to(term, DOWN, buff = SMALL_BUFF)\n",
        "            term.denom = OldTex(\"(0.1)\")\n",
        "            term.denom.next_to(term.frac_line, DOWN, buff = SMALL_BUFF)\n",
        "            term.denom.set_color(self.dR_color)\n",
        "            term.denom.save_state()\n",
        "            term.denom.replace(self.nudge_label)\n",
        "\n",
        "        self.equals.generate_target()\n",
        "        self.equals.target.next_to(self.change.frac_line, RIGHT)\n",
        "        self.plus.generate_target()\n",
        "        self.plus.target.next_to(self.circum_term.frac_line, RIGHT)\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            [Write(term.frac_line) for term in terms],\n",
        "            list(map(MoveToTarget, [self.equals, self.plus]))\n",
        "        ))\n",
        "        self.play(*[term.denom.restore for term in terms])\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.outer_ring.set_color, YELLOW,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.play(\n",
        "            self.nudge_label.scale, 2,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait(2)\n",
        "        canceleres = VGroup(self.circum_term[1], self.circum_term.denom)\n",
        "        self.play(canceleres.set_color, RED)\n",
        "        self.play(FadeOut(canceleres))\n",
        "        self.remove(self.circum_term)\n",
        "        self.play(\n",
        "            self.circum_term[0].move_to, self.circum_term.frac_line, LEFT,\n",
        "            self.circum_term[0].shift, 0.1*UP,\n",
        "            FadeOut(self.circum_term.frac_line),\n",
        "            MaintainPositionRelativeTo(\n",
        "                self.circum_term.label,\n",
        "                self.circum_term[0]\n",
        "            )\n",
        "        )\n",
        "        self.circum_term = self.circum_term[0]\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(self.error_term[-1]),\n",
        "            FadeOut(self.error_term.denom)\n",
        "        )\n",
        "        self.error_term.remove(self.error_term[-1])\n",
        "        self.play(\n",
        "            self.error_term.move_to, self.error_term.frac_line,\n",
        "            self.error_term.shift, 0.3*LEFT + 0.15*UP,\n",
        "            FadeOut(self.error_term.frac_line),\n",
        "            self.plus.shift, 0.7*LEFT + 0.1*UP,\n",
        "            MaintainPositionRelativeTo(\n",
        "                self.error_term.label,\n",
        "                self.error_term\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def transition_to_dR(self):\n",
        "        dRs = VGroup(\n",
        "            self.nudge_label, \n",
        "            self.change.denom,\n",
        "            self.error_term[1],\n",
        "        )\n",
        "        error_brace, error_text = self.error_term.label\n",
        "        for s, width in (\"(0.01)\", 0.05), (\"(0.001)\", 0.03), (\"dR\", 0.03):\n",
        "            new_dRs = VGroup(*[\n",
        "                OldTex(s).move_to(mob, LEFT)\n",
        "                for mob in dRs\n",
        "            ])\n",
        "            new_dRs.set_color(self.dR_color)\n",
        "            new_outer_ring = self.get_ring(self.radius, width)\n",
        "            new_nudge_line = self.nudge_line.copy()\n",
        "            new_nudge_line.set_width(width)\n",
        "            new_nudge_line.move_to(self.nudge_line, LEFT)\n",
        "            error_brace.target = error_brace.copy()\n",
        "            error_brace.target.stretch_to_fit_width(\n",
        "                VGroup(self.error_term[0], new_dRs[-1]).get_width()\n",
        "            )\n",
        "            error_brace.target.move_to(error_brace, LEFT)\n",
        "            self.play(\n",
        "                MoveToTarget(error_brace),\n",
        "                Transform(self.outer_ring, new_outer_ring),\n",
        "                Transform(self.nudge_line, new_nudge_line),\n",
        "                *[\n",
        "                    Transform(*pair)\n",
        "                    for pair in zip(dRs, new_dRs)\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "            if s == \"(0.001)\":\n",
        "                self.plus.generate_target()\n",
        "                self.plus.target.next_to(self.circum_term)\n",
        "                self.error_term.generate_target()\n",
        "                self.error_term.target.next_to(self.plus.target)\n",
        "                error_brace.target = Brace(self.error_term.target)\n",
        "                error_text.target = error_brace.target.get_text(\"Truly tiny\")\n",
        "                error_text.target.set_color(error_text.get_color())\n",
        "                self.play(*list(map(MoveToTarget, [\n",
        "                    error_brace, error_text, self.plus, self.error_term\n",
        "                ])))\n",
        "                self.wait()\n",
        "\n",
        "        difference_text = OldTexText(\n",
        "            \"``Tiny \" , \"d\", \"ifference in \", \"$R$\", \"''\",\n",
        "            arg_separator = \"\"\n",
        "\n",
        "        )\n",
        "        difference_text.set_color_by_tex(\"d\", self.dR_color)\n",
        "        difference_text.next_to(self.pi_creature, UP+RIGHT)\n",
        "        difference_arrow = Arrow(difference_text, self.change.denom)\n",
        "        self.play(\n",
        "            Write(difference_text, run_time = 2),\n",
        "            ShowCreation(difference_arrow),\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        dA = OldTex(\"dA\")\n",
        "        dA.set_color(self.change.get_color())\n",
        "        frac_line = self.change.frac_line\n",
        "        frac_line.generate_target()\n",
        "        frac_line.target.stretch_to_fit_width(dA.get_width())\n",
        "        frac_line.target.next_to(self.equals, LEFT)\n",
        "        dA.next_to(frac_line.target, UP, 2*SMALL_BUFF)\n",
        "        self.change.denom.generate_target()\n",
        "        self.change.denom.target.next_to(frac_line.target, DOWN, 2*SMALL_BUFF)\n",
        "        A = OldTex(\"A\").replace(difference_text[3])\n",
        "        difference_arrow.target = Arrow(difference_text, dA.get_left())\n",
        "        self.play(\n",
        "            Transform(self.change, dA),\n",
        "            MoveToTarget(frac_line),\n",
        "            MoveToTarget(self.change.denom),\n",
        "            Transform(difference_text[3], A),\n",
        "            difference_text[1].set_color, dA.get_color(),\n",
        "            MoveToTarget(difference_arrow),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [difference_text, difference_arrow])))\n",
        "\n",
        "    def elaborate_on_d(self):\n",
        "        arc = Arc(-np.pi, start_angle = -np.pi/2)\n",
        "        arc.set_height(\n",
        "            self.change.get_center()[1]-self.change.denom.get_center()[1]\n",
        "        )\n",
        "        arc.next_to(self.change.frac_line, LEFT)\n",
        "        arc.add_tip()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            self.pi_creature.change_mode, \"sassy\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.pi_creature.shrug)\n",
        "        self.play(FadeOut(arc))\n",
        "        self.wait()\n",
        "\n",
        "        d = OldTexText(\"``$d$''\")\n",
        "        arrow = OldTex(\"\\\\Rightarrow\")\n",
        "        arrow.next_to(d)\n",
        "        ignore_error = OldTexText(\"Ignore error\")\n",
        "        d_group = VGroup(d, arrow, ignore_error)\n",
        "        d_group.arrange()\n",
        "        d_group.next_to(\n",
        "            self.pi_creature.get_corner(UP+RIGHT), \n",
        "            buff = LARGE_BUFF\n",
        "        )\n",
        "        error_group = VGroup(\n",
        "            self.plus, self.error_term, self.error_term.label\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Write(d),\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.play(*list(map(Write, [arrow, ignore_error])))\n",
        "        self.play(error_group.fade, 0.8)\n",
        "        self.wait(2)\n",
        "        equality_brace = Brace(VGroup(self.change.denom, self.circum_term))\n",
        "        equal_word = equality_brace.get_text(\"Equality\")\n",
        "        VGroup(equality_brace, equal_word).set_color(BLUE)\n",
        "        self.play(\n",
        "            GrowFromCenter(equality_brace),\n",
        "            Write(equal_word, run_time = 1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*list(map(FadeOut, [equality_brace, equal_word])))\n",
        "\n",
        "        less_wrong_philosophy = OldTexText(\"``Less wrong'' philosophy\")\n",
        "        less_wrong_philosophy.move_to(ignore_error, LEFT)\n",
        "        self.play(Transform(ignore_error, less_wrong_philosophy))\n",
        "        self.wait()\n",
        "\n",
        "        big_dR = 0.3\n",
        "        big_outer_ring = self.get_ring(self.radius, big_dR)\n",
        "        big_nudge_line = self.nudge_line.copy()\n",
        "        big_nudge_line.stretch_to_fit_width(big_dR)\n",
        "        big_nudge_line.move_to(self.nudge_line, LEFT)\n",
        "        new_nudge_arrow = Arrow(self.nudge_label, big_nudge_line, buff = SMALL_BUFF)\n",
        "        self.outer_ring.save_state()\n",
        "        self.nudge_line.save_state()\n",
        "        self.nudge_arrow.save_state()\n",
        "        self.play(\n",
        "            Transform(self.outer_ring, big_outer_ring),\n",
        "            Transform(self.nudge_line, big_nudge_line),\n",
        "            Transform(self.nudge_arrow, new_nudge_arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            *[\n",
        "                mob.restore \n",
        "                for mob in [\n",
        "                    self.outer_ring,\n",
        "                    self.nudge_line,\n",
        "                    self.nudge_arrow,\n",
        "                ]\n",
        "            ],\n",
        "            rate_func=linear,\n",
        "            run_time = 7\n",
        "        )\n",
        "        self.play(self.pi_creature.change_mode, \"hooray\")\n",
        "        self.less_wrong_philosophy = VGroup(\n",
        "            d, arrow, ignore_error\n",
        "        )\n",
        "\n",
        "    def not_infinitely_small(self):\n",
        "        randy = Randolph().flip()\n",
        "        randy.scale(0.7)\n",
        "        randy.to_corner(DOWN+RIGHT)\n",
        "        bubble = SpeechBubble()\n",
        "        bubble.write(\"$dR$ is infinitely small\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.stretch(0.7, 1)\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "        bubble.add_content(bubble.content)\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            randy.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        to_infs = [self.change, self.change.denom, self.nudge_label]\n",
        "        for mob in to_infs:\n",
        "            mob.save_state()\n",
        "            mob.inf = OldTex(\"1/\\\\infty\")\n",
        "            mob.inf.set_color(mob.get_color())\n",
        "            mob.inf.move_to(mob)\n",
        "        self.play(*[\n",
        "            Transform(mob, mob.inf)\n",
        "            for mob in to_infs\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(self.pi_creature.change_mode, \"pleading\")\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            [mob.restore for mob in to_infs],\n",
        "            list(map(FadeOut, [bubble, bubble.content])),\n",
        "            [randy.change_mode, \"erm\"],\n",
        "            [self.pi_creature.change_mode, \"happy\"],\n",
        "        ))\n",
        "        for n in range(7):\n",
        "            target = OldTex(\"0.%s1\"%(\"0\"*n))\n",
        "            target.set_color(self.nudge_label.get_color())\n",
        "            target.move_to(self.nudge_label, LEFT)\n",
        "            self.outer_ring.target = self.get_ring(self.radius, 0.1/(n+1))\n",
        "            self.nudge_line.get_center = self.nudge_line.get_left\n",
        "            self.play(\n",
        "                Transform(self.nudge_label, target),\n",
        "                MoveToTarget(self.outer_ring),\n",
        "                self.nudge_line.stretch_to_fit_width, 0.1/(n+1)\n",
        "            )\n",
        "        self.wait()\n",
        "        bubble.write(\"Wrong!\")\n",
        "        bubble.resize_to_content()\n",
        "        bubble.stretch(0.7, 1)\n",
        "        bubble.pin_to(randy)\n",
        "        bubble.add_content(bubble.content)\n",
        "        self.play(\n",
        "            FadeIn(bubble),\n",
        "            Write(bubble.content, run_time = 1),\n",
        "            randy.change_mode, \"angry\",\n",
        "        )\n",
        "        self.play(randy.set_color, RED)\n",
        "        self.play(self.pi_creature.change_mode, \"guilty\")\n",
        "        self.wait()\n",
        "\n",
        "        new_bubble = self.pi_creature.get_bubble(SpeechBubble)\n",
        "        new_bubble.set_fill(BLACK, opacity = 0.8)\n",
        "        new_bubble.write(\"But it gets \\\\\\\\ less wrong!\")\n",
        "        new_bubble.resize_to_content()\n",
        "        new_bubble.pin_to(self.pi_creature)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            FadeOut(bubble.content),\n",
        "            ShowCreation(new_bubble),\n",
        "            Write(new_bubble.content),\n",
        "            randy.change_mode, \"erm\",\n",
        "            randy.set_color, BLUE_E,\n",
        "            self.pi_creature.change_mode, \"shruggie\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class NameDerivative(IntroduceTinyChangeInArea):\n",
        "    def construct(self):\n",
        "        self.increase_radius(run_time = 0)\n",
        "        self.change_nudge_label()\n",
        "        self.name_derivative_for_cricle()\n",
        "        self.interpret_geometrically()\n",
        "        self.show_limiting_process()\n",
        "        self.reference_approximation()\n",
        "        self.emphasize_equality()\n",
        "\n",
        "    def change_nudge_label(self):\n",
        "        new_label = OldTex(\"dR\")\n",
        "        new_label.move_to(self.nudge_label)\n",
        "        new_label.to_edge(UP)        \n",
        "        new_label.set_color(self.nudge_label.get_color())\n",
        "        new_arrow = Arrow(new_label, self.nudge_line)\n",
        "\n",
        "        self.remove(self.nudge_label, self.nudge_arrow)\n",
        "        self.nudge_label = new_label\n",
        "        self.nudge_arrow = new_arrow\n",
        "        self.add(self.nudge_label, self.nudge_arrow)\n",
        "        self.wait()\n",
        "\n",
        "    def name_derivative_for_cricle(self):\n",
        "        dA_dR, equals, d_formula_dR, equals2, two_pi_R = dArea_fom = OldTex(\n",
        "            \"\\\\frac{dA}{dR}\", \n",
        "            \"=\", \"\\\\frac{d(\\\\pi R^2)}{dR}\",\n",
        "            \"=\", \"2\\\\pi R\"\n",
        "        )\n",
        "        dArea_fom.to_edge(UP, buff = MED_LARGE_BUFF).shift(RIGHT)\n",
        "        dA, frac_line, dR = VGroup(*dA_dR[:2]), dA_dR[2], VGroup(*dA_dR[3:])\n",
        "        dA.set_color(GREEN_B)\n",
        "        dR.set_color(self.dR_color)\n",
        "        VGroup(*d_formula_dR[7:]).set_color(self.dR_color)\n",
        "\n",
        "\n",
        "        dA_dR_circle = Circle()\n",
        "        dA_dR_circle.replace(dA_dR, stretch = True)\n",
        "        dA_dR_circle.scale(1.5)\n",
        "        dA_dR_circle.set_color(BLUE)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"``Derivative'' of $A$\\\\\\\\\",\n",
        "            \"with respect to $R$\"\n",
        "        )\n",
        "        words.next_to(dA_dR_circle, DOWN, buff = 1.5*LARGE_BUFF)\n",
        "        words.shift(0.5*LEFT)\n",
        "        arrow = Arrow(words, dA_dR_circle)\n",
        "        arrow.set_color(dA_dR_circle.get_color())\n",
        "\n",
        "        self.play(Transform(self.outer_ring.copy(), dA, run_time = 2))\n",
        "        self.play(\n",
        "            Transform(self.nudge_line.copy(), dR, run_time = 2),\n",
        "            Write(frac_line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(dA_dR_circle),\n",
        "            ShowCreation(arrow),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(equals, d_formula_dR)))\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(equals2, two_pi_R)))\n",
        "        self.wait()\n",
        "        self.dArea_fom = dArea_fom\n",
        "        self.words = words\n",
        "        self.two_pi_R = two_pi_R\n",
        "\n",
        "    def interpret_geometrically(self):\n",
        "        target_formula = OldTex(\n",
        "            \"\\\\frac{d \\\\quad}{dR} = \"\n",
        "        )\n",
        "        VGroup(*target_formula[2:4]).set_color(self.dR_color)\n",
        "        target_formula.scale(1.3)\n",
        "        target_formula.next_to(self.dArea_fom, DOWN)\n",
        "        target_formula.shift(2*RIGHT + 0.5*DOWN)\n",
        "\n",
        "        area_form = VGroup(*self.dArea_fom[2][2:5]).copy()\n",
        "        area_form.set_color(BLUE_D)\n",
        "        circum_form = self.dArea_fom[-1]\n",
        "\n",
        "        circle_width = 1\n",
        "        area_circle = self.circle.copy()\n",
        "        area_circle.set_stroke(width = 0)\n",
        "        area_circle.generate_target()\n",
        "        area_circle.target.set_width(circle_width)\n",
        "        area_circle.target.next_to(target_formula[0], RIGHT, buff = 0)\n",
        "        area_circle.target.set_color(BLUE_D)\n",
        "        circum_circle = self.circle.copy()\n",
        "        circum_circle.set_fill(opacity = 0)\n",
        "        circum_circle.generate_target()\n",
        "        circum_circle.target.set_width(circle_width)\n",
        "        circum_circle.target.next_to(target_formula)\n",
        "\n",
        "        self.play(\n",
        "            Write(target_formula),\n",
        "            MoveToTarget(area_circle),\n",
        "            MoveToTarget(\n",
        "                circum_circle,\n",
        "                run_time = 2,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            self.pi_creature.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(area_circle.copy(), area_form))\n",
        "        self.remove(area_form)\n",
        "        self.play(Transform(circum_circle.copy(), circum_form))\n",
        "        self.change_mode(\"happy\")\n",
        "\n",
        "    def show_limiting_process(self):\n",
        "        big_dR = 0.3\n",
        "        small_dR = 0.01\n",
        "        big_ring = self.get_ring(self.radius, big_dR)\n",
        "        small_ring = self.get_ring(self.radius, small_dR)\n",
        "        big_nudge_line = self.nudge_line.copy().set_width(big_dR)\n",
        "        small_nudge_line = self.nudge_line.copy().set_width(small_dR)\n",
        "        for line in big_nudge_line, small_nudge_line:\n",
        "            line.move_to(self.nudge_line, LEFT)\n",
        "        new_nudge_arrow = Arrow(self.nudge_label, big_nudge_line)\n",
        "        small_nudge_arrow = Arrow(self.nudge_label, small_nudge_line)\n",
        "\n",
        "        ring_group = VGroup(self.outer_ring, self.nudge_line, self.nudge_arrow)\n",
        "        ring_group.save_state()\n",
        "        big_group = VGroup(big_ring, big_nudge_line, new_nudge_arrow)\n",
        "        small_group = VGroup(small_ring, small_nudge_line, small_nudge_arrow)\n",
        "\n",
        "        fracs = VGroup()\n",
        "        sample_dRs = [0.3, 0.1, 0.01]\n",
        "        for dR in sample_dRs:\n",
        "            dA = 2*np.pi*dR + np.pi*(dR**2)\n",
        "            frac = OldTex(\"\\\\frac{%.3f}{%.2f}\"%(dA, dR))\n",
        "            VGroup(*frac[:5]).set_color(self.outer_ring.get_color())\n",
        "            VGroup(*frac[6:]).set_color(self.dR_color)\n",
        "            fracs.add(frac)\n",
        "        fracs.add(OldTex(\"\\\\cdots \\\\rightarrow\"))\n",
        "        fracs.add(OldTex(\"???\"))\n",
        "        fracs[-1].set_color_by_gradient(self.dR_color, self.outer_ring.get_color())\n",
        "        fracs.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        fracs.to_corner(DOWN+LEFT)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        for frac in fracs[:len(sample_dRs)] + [fracs[-1]]:\n",
        "            arrow = Arrow(self.words.get_bottom(), frac.get_top())\n",
        "            arrow.set_color(WHITE)\n",
        "            if frac is fracs[-1]:\n",
        "                check = OldTex(\"\\\\checkmark\")\n",
        "                check.set_color(GREEN)\n",
        "                check.next_to(arrow.get_center(), UP+RIGHT, SMALL_BUFF)\n",
        "                arrow.add(check)\n",
        "            else:\n",
        "                cross = OldTex(\"\\\\times\")\n",
        "                cross.set_color(RED)\n",
        "                cross.move_to(arrow.get_center())\n",
        "                cross.set_stroke(RED, width = 5)\n",
        "                arrow.add(cross)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            Transform(ring_group, big_group),\n",
        "            self.pi_creature.change_mode, \"sassy\"\n",
        "        )\n",
        "        for n, frac in enumerate(fracs):\n",
        "            anims = [FadeIn(frac)]\n",
        "            num_fracs = len(sample_dRs)\n",
        "            if n < num_fracs:\n",
        "                anims.append(ShowCreation(arrows[n]))\n",
        "                anims.append(Transform(\n",
        "                    ring_group, small_group,\n",
        "                    rate_func = lambda t : t*(1./(num_fracs-n)),\n",
        "                    run_time = 2\n",
        "                ))\n",
        "            elif n > num_fracs:\n",
        "                anims.append(ShowCreation(arrows[-1]))\n",
        "            self.play(*anims)\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            ring_group.restore,\n",
        "            self.pi_creature.change_mode, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def reference_approximation(self):\n",
        "        ring_copy = self.outer_ring.copy()\n",
        "        self.unwrap_ring(ring_copy)\n",
        "        self.wait()\n",
        "        self.last_mover = ring_copy\n",
        "\n",
        "    def emphasize_equality(self):\n",
        "        equals = self.dArea_fom[-2]\n",
        "\n",
        "        self.play(Transform(self.last_mover, equals))\n",
        "        self.remove(self.last_mover)\n",
        "        self.play(\n",
        "            equals.scale, 1.5,\n",
        "            equals.set_color, GREEN,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            self.two_pi_R.set_stroke, YELLOW, 3,\n",
        "            rate_func = there_and_back,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        new_words = OldTexText(\n",
        "            \"Systematically\\\\\\\\\",\n",
        "            \"ignore error\"\n",
        "        )\n",
        "        new_words.move_to(self.words)\n",
        "        self.play(Transform(self.words, new_words))\n",
        "        self.wait()\n",
        "\n",
        "class DerivativeAsTangentLine(ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"zoomed_canvas_frame_shape\" : (4, 4),\n",
        "        \"zoom_factor\" : 10,\n",
        "        \"R_min\" : 0,\n",
        "        \"R_max\" : 2.5,\n",
        "        \"R_to_zoom_in_on\" : 2,\n",
        "        \"little_rect_nudge\" : 0.075*(UP+RIGHT),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.show_zoomed_in_steps()\n",
        "        self.show_tangent_lines()\n",
        "        self.state_commonality()\n",
        "\n",
        "    def setup_axes(self):\n",
        "        x_axis = NumberLine(\n",
        "            x_min = -0.25, \n",
        "            x_max = 4,\n",
        "            unit_size = 2,\n",
        "            tick_frequency = 0.25,\n",
        "            leftmost_tick = -0.25,\n",
        "            big_tick_numbers = [0, 1, 2, 3, 4],\n",
        "            color = GREY\n",
        "        )\n",
        "        x_axis.shift(2.5*DOWN)\n",
        "        x_axis.shift(4*LEFT)\n",
        "        x_axis.add_numbers(1, 2, 3, 4)\n",
        "        x_label = OldTex(\"R\")\n",
        "        x_label.next_to(x_axis, RIGHT+UP, buff = SMALL_BUFF)\n",
        "        self.x_axis_label = x_label\n",
        "\n",
        "        y_axis = NumberLine(\n",
        "            x_min = -2,\n",
        "            x_max = 20,\n",
        "            unit_size = 0.3,\n",
        "            tick_frequency = 2.5,\n",
        "            leftmost_tick = 0,\n",
        "            longer_tick_multiple = -2,\n",
        "            big_tick_numbers = [0, 5, 10, 15, 20],\n",
        "            color = GREY\n",
        "        )\n",
        "        y_axis.shift(x_axis.number_to_point(0)-y_axis.number_to_point(0))\n",
        "        y_axis.rotate(np.pi/2, about_point = y_axis.number_to_point(0))\n",
        "        y_axis.add_numbers(5, 10, 15, 20)\n",
        "        y_axis.numbers.shift(0.4*UP+0.5*LEFT)\n",
        "        y_label = OldTex(\"A\")\n",
        "        y_label.next_to(y_axis.get_top(), RIGHT, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        def func(alpha):\n",
        "            R = interpolate(self.R_min, self.R_max, alpha)\n",
        "            x = x_axis.number_to_point(R)[0]\n",
        "            output = np.pi*(R**2)\n",
        "            y = y_axis.number_to_point(output)[1]\n",
        "            return x*RIGHT + y*UP\n",
        "\n",
        "        graph = ParametricCurve(func, color = BLUE)\n",
        "        graph_label = OldTex(\"A(R) = \\\\pi R^2\")\n",
        "        graph_label.set_color(BLUE)\n",
        "        graph_label.next_to(\n",
        "            graph.point_from_proportion(2), LEFT\n",
        "        )\n",
        "\n",
        "        self.play(Write(VGroup(x_axis, y_axis)))\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.play(Write(VGroup(x_label, y_label)))\n",
        "        self.wait()\n",
        "\n",
        "        self.x_axis, self.y_axis = x_axis, y_axis\n",
        "        self.graph = graph\n",
        "        self.graph_label = graph_label\n",
        "\n",
        "    def graph_point(self, R):\n",
        "        alpha = (R - self.R_min)/(self.R_max - self.R_min)\n",
        "        return self.graph.point_from_proportion(alpha)\n",
        "\n",
        "    def angle_of_tangent(self, R, dR = 0.01):\n",
        "        vect = self.graph_point(R + dR) - self.graph_point(R)\n",
        "        return angle_of_vector(vect)\n",
        "\n",
        "    def show_zoomed_in_steps(self):\n",
        "        R = self.R_to_zoom_in_on\n",
        "        dR = 0.05\n",
        "        graph_point = self.graph_point(R)\n",
        "        nudged_point = self.graph_point(R+dR)\n",
        "        interim_point = nudged_point[0]*RIGHT + graph_point[1]*UP\n",
        "\n",
        "\n",
        "        self.activate_zooming()        \n",
        "        dot = Dot(color = YELLOW)\n",
        "        dot.scale(0.1)\n",
        "        dot.move_to(graph_point)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [\n",
        "            self.little_rectangle,\n",
        "            self.big_rectangle\n",
        "        ])))\n",
        "        self.play(\n",
        "            self.little_rectangle.move_to, \n",
        "            graph_point+self.little_rect_nudge\n",
        "        )\n",
        "        self.play(FadeIn(dot))\n",
        "\n",
        "        dR_line = Line(graph_point, interim_point)\n",
        "        dR_line.set_color(YELLOW)\n",
        "        dA_line = Line(interim_point, nudged_point)\n",
        "        dA_line.set_color(GREEN)\n",
        "        tiny_buff = SMALL_BUFF/self.zoom_factor\n",
        "        for line, vect, char in (dR_line, DOWN, \"R\"), (dA_line, RIGHT, \"A\"):\n",
        "            line.brace = Brace(Line(LEFT, RIGHT))\n",
        "            line.brace.scale(1./self.zoom_factor)\n",
        "            line.brace.stretch_to_fit_width(line.get_length())\n",
        "            line.brace.rotate(line.get_angle())\n",
        "            line.brace.next_to(line, vect, buff = tiny_buff)\n",
        "            line.text = OldTex(\"d%s\"%char)\n",
        "            line.text.scale(1./self.zoom_factor)\n",
        "            line.text.set_color(line.get_color())\n",
        "            line.text.next_to(line.brace, vect, buff = tiny_buff)\n",
        "            self.play(ShowCreation(line))\n",
        "            self.play(Write(VGroup(line.brace, line.text)))\n",
        "            self.wait()\n",
        "\n",
        "        deriv_is_slope = OldTex(\n",
        "            \"\\\\frac{dA}{dR} =\", \"\\\\text{Slope}\"\n",
        "        )\n",
        "        self.slope_word = deriv_is_slope[1]\n",
        "        VGroup(*deriv_is_slope[0][:2]).set_color(GREEN)\n",
        "        VGroup(*deriv_is_slope[0][3:5]).set_color(YELLOW)\n",
        "        deriv_is_slope.next_to(self.y_axis, RIGHT)\n",
        "        deriv_is_slope.shift(UP)\n",
        "\n",
        "        self.play(Write(deriv_is_slope))\n",
        "        self.wait()\n",
        "\n",
        "        ### Whoa boy, this aint' gonna be pretty\n",
        "        self.dot = dot\n",
        "        self.small_step_group = VGroup(\n",
        "            dR_line, dR_line.brace, dR_line.text,\n",
        "            dA_line, dA_line.brace, dA_line.text,\n",
        "        )\n",
        "        def update_small_step_group(group):\n",
        "            R = self.x_axis.point_to_number(dot.get_center())\n",
        "            graph_point = self.graph_point(R)\n",
        "            nudged_point = self.graph_point(R+dR)\n",
        "            interim_point = nudged_point[0]*RIGHT + graph_point[1]*UP\n",
        "\n",
        "            dR_line.put_start_and_end_on(graph_point, interim_point)\n",
        "            dA_line.put_start_and_end_on(interim_point, nudged_point)\n",
        "\n",
        "            dR_line.brace.stretch_to_fit_width(dR_line.get_width())\n",
        "            dR_line.brace.next_to(dR_line, DOWN, buff = tiny_buff)\n",
        "            dR_line.text.next_to(dR_line.brace, DOWN, buff = tiny_buff)\n",
        "\n",
        "            dA_line.brace.stretch_to_fit_height(dA_line.get_height())\n",
        "            dA_line.brace.next_to(dA_line, RIGHT, buff = tiny_buff)\n",
        "            dA_line.text.next_to(dA_line.brace, RIGHT, buff = tiny_buff)\n",
        "        self.update_small_step_group = update_small_step_group\n",
        "\n",
        "    def show_tangent_lines(self):\n",
        "        R = self.R_to_zoom_in_on\n",
        "        line = Line(LEFT, RIGHT).scale(FRAME_Y_RADIUS)\n",
        "        line.set_color(MAROON_B)\n",
        "        line.rotate(self.angle_of_tangent(R))\n",
        "        line.move_to(self.graph_point(R))\n",
        "        x_axis_y = self.x_axis.number_to_point(0)[1]\n",
        "        two_pi_R = OldTex(\"= 2\\\\pi R\")\n",
        "        two_pi_R.next_to(self.slope_word, DOWN, aligned_edge = RIGHT)\n",
        "        two_pi_R.shift(0.5*LEFT)\n",
        "\n",
        "        def line_update_func(line):\n",
        "            R = self.x_axis.point_to_number(self.dot.get_center())\n",
        "            line.rotate(\n",
        "                self.angle_of_tangent(R) - line.get_angle()\n",
        "            )\n",
        "            line.move_to(self.dot)\n",
        "        def update_little_rect(rect):\n",
        "            R = self.x_axis.point_to_number(self.dot.get_center())\n",
        "            rect.move_to(self.graph_point(R) + self.little_rect_nudge)\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.wait()\n",
        "        self.note_R_value_of_point()\n",
        "\n",
        "        alphas = np.arange(0, 1, 0.01)\n",
        "        graph_points = list(map(self.graph.point_from_proportion, alphas))\n",
        "        curr_graph_point = self.graph_point(R)\n",
        "        self.last_alpha = alphas[np.argmin([\n",
        "            get_norm(point - curr_graph_point)\n",
        "            for point in graph_points\n",
        "        ])]\n",
        "        def shift_everything_to_alpha(alpha, run_time = 3):\n",
        "            self.play(\n",
        "                MoveAlongPath(\n",
        "                    self.dot, self.graph,\n",
        "                    rate_func = lambda t : interpolate(self.last_alpha, alpha, smooth(t))\n",
        "                ),\n",
        "                UpdateFromFunc(line, line_update_func),\n",
        "                UpdateFromFunc(self.small_step_group, self.update_small_step_group),\n",
        "                UpdateFromFunc(self.little_rectangle, update_little_rect),\n",
        "                run_time = run_time\n",
        "            )\n",
        "            self.last_alpha = alpha\n",
        "\n",
        "        for alpha in 0.95, 0.2:\n",
        "            shift_everything_to_alpha(alpha)\n",
        "        self.wait()\n",
        "        self.play(Write(two_pi_R))\n",
        "        self.wait()\n",
        "        shift_everything_to_alpha(0.8, 4)\n",
        "        self.wait()\n",
        "\n",
        "    def note_R_value_of_point(self):\n",
        "        R = self.R_to_zoom_in_on\n",
        "        point = self.graph_point(R)\n",
        "        R_axis_point = point[0]*RIGHT + 2.5*DOWN\n",
        "\n",
        "        dashed_line = DashedLine(point, R_axis_point, color = RED)\n",
        "        dot = Dot(R_axis_point, color = RED)\n",
        "        arrow = Arrow(\n",
        "            self.x_axis_label.get_left(),\n",
        "            dot,\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.play(ShowCreation(dashed_line))\n",
        "        self.play(ShowCreation(dot))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(dot.scale, 2, rate_func = there_and_back)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [dashed_line, dot, arrow])))\n",
        "\n",
        "    def state_commonality(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_edge(DOWN).shift(2*RIGHT)\n",
        "        bubble = morty.get_bubble(SpeechBubble, height = 2)\n",
        "        bubble.set_fill(BLACK, opacity = 0.8)\n",
        "        bubble.shift(0.5*DOWN)        \n",
        "        bubble.write(\"This is the standard view\")\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "            morty.change_mode, \"surprised\"\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        new_words = OldTexText(\"Which is...fine...\")\n",
        "        new_words.move_to(bubble.content, RIGHT)\n",
        "        self.play(\n",
        "            bubble.stretch_to_fit_width, 5,\n",
        "            bubble.shift, RIGHT,\n",
        "            Transform(bubble.content, new_words),            \n",
        "            morty.change_mode, \"hesitant\"\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "class SimpleConfusedPi(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        confused = Randolph(mode = \"confused\")\n",
        "        for pi in randy, confused:\n",
        "            pi.flip()\n",
        "            pi.look(UP+LEFT)\n",
        "            pi.scale(2)\n",
        "            pi.rotate(np.pi/2)\n",
        "        self.play(Transform(randy, confused))\n",
        "        self.wait()\n",
        "\n",
        "class TangentLinesAreNotEverything(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Tangent lines are just\n",
        "            one way to visualize \n",
        "            derivatives\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\"raise_left_hand\", \"pondering\", \"erm\")\n",
        "        self.random_blink(3)\n",
        "\n",
        "class OnToIntegrals(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"On to integrals!\", target_mode = \"hooray\")\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "class IntroduceConcentricRings(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 2.5,\n",
        "        \"special_ring_index\" : 10,\n",
        "        \"include_pi_creature\" : True,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.build_up_rings()\n",
        "        self.add_up_areas()\n",
        "        self.unwrap_special_ring()\n",
        "        self.write_integral()\n",
        "        self.ask_about_approx()\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        return morty\n",
        "\n",
        "    def build_up_rings(self):\n",
        "        self.circle.set_fill(opacity = 0)\n",
        "        rings = VGroup(*[\n",
        "            self.get_ring(r, self.dR)\n",
        "            for r in np.arange(0, self.radius, self.dR)\n",
        "        ])\n",
        "        rings.set_color_by_gradient(BLUE_E, GREEN_E)\n",
        "        rings.set_stroke(BLACK, width = 1)\n",
        "        outermost_ring = rings[-1]\n",
        "        dr_line = Line(\n",
        "            rings[-2].get_top(), \n",
        "            rings[-1].get_top(),\n",
        "            color = YELLOW\n",
        "        )\n",
        "        dr_text = OldTex(\"dr\")\n",
        "        dr_text.move_to(self.circle.get_corner(UP+RIGHT))\n",
        "        dr_text.shift(LEFT)\n",
        "        dr_text.set_color(YELLOW)\n",
        "        dr_arrow = Arrow(dr_text, dr_line, buff = SMALL_BUFF)\n",
        "        self.dr_group = VGroup(dr_text, dr_arrow, dr_line)\n",
        "\n",
        "\n",
        "        foreground_group = VGroup(self.radius_brace, self.radius_label, self.radius_line)\n",
        "        self.play(\n",
        "            FadeIn(outermost_ring), \n",
        "            Animation(foreground_group)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(dr_text),\n",
        "            ShowCreation(dr_arrow),\n",
        "            ShowCreation(dr_line)\n",
        "        )\n",
        "        foreground_group.add(dr_line, dr_arrow, dr_text)        \n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                VGroup(*rings[:-1]),\n",
        "                lag_ratio=1,\n",
        "                run_time = 5\n",
        "            ),\n",
        "            Animation(foreground_group)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.foreground_group = foreground_group\n",
        "        self.rings = rings\n",
        "\n",
        "    def add_up_areas(self):\n",
        "        start_rings = VGroup(*self.rings[:4])\n",
        "        moving_rings = start_rings.copy()\n",
        "        moving_rings.generate_target()\n",
        "        moving_rings.target.set_stroke(width = 0)\n",
        "        plusses = VGroup(*[Tex(\"+\") for ring in moving_rings])\n",
        "        area_sum = VGroup(*it.chain(*list(zip(\n",
        "            [ring for ring in moving_rings.target],\n",
        "            plusses\n",
        "        ))))\n",
        "        dots_equals_area = OldTex(\"\\\\dots\", \"=\", \"\\\\pi R^2\")\n",
        "        area_sum.add(*dots_equals_area)\n",
        "        area_sum.arrange()\n",
        "        area_sum.to_edge(RIGHT)\n",
        "        area_sum.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "        dots_equals_area[-1].shift(0.1*UP)\n",
        "        self.area_sum_rhs = dots_equals_area[-1]\n",
        "\n",
        "        # start_rings.set_fill(opacity = 0.3)\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                moving_rings,\n",
        "                lag_ratio = 0.5,\n",
        "            ),\n",
        "            Write(\n",
        "                VGroup(plusses, dots_equals_area),\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1)\n",
        "            ),\n",
        "            Animation(self.foreground_group),\n",
        "            run_time = 5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.area_sum = area_sum\n",
        "\n",
        "    def unwrap_special_ring(self):\n",
        "        rings = self.rings\n",
        "        foreground_group = self.foreground_group\n",
        "        special_ring = rings[self.special_ring_index]\n",
        "        special_ring.save_state()\n",
        "\n",
        "        radius = (special_ring.get_width()-2*self.dR)/2.\n",
        "        radial_line = Line(ORIGIN, radius*RIGHT)\n",
        "        radial_line.rotate(np.pi/4)\n",
        "        radial_line.shift(self.circle.get_center())\n",
        "        radial_line.set_color(YELLOW)\n",
        "        r_label = OldTex(\"r\")\n",
        "        r_label.next_to(radial_line.get_center(), UP+LEFT, buff = SMALL_BUFF)\n",
        "\n",
        "        rings.generate_target()\n",
        "        rings.save_state()\n",
        "        rings.target.set_fill(opacity = 0.3)\n",
        "        rings.target.set_stroke(BLACK)\n",
        "        rings.target[self.special_ring_index].set_fill(opacity = 1)\n",
        "        self.play(\n",
        "            MoveToTarget(rings),\n",
        "            Animation(foreground_group)\n",
        "        )\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(Write(r_label))\n",
        "        self.foreground_group.add(radial_line, r_label)\n",
        "        self.wait()\n",
        "        self.unwrap_ring(special_ring, to_edge = RIGHT)\n",
        "\n",
        "        brace = Brace(special_ring, UP)\n",
        "        brace.stretch_in_place(0.9, 0)\n",
        "        two_pi_r = brace.get_text(\"$2\\\\pi r$\")\n",
        "        left_brace = OldTex(\"\\\\{\")\n",
        "        left_brace.stretch_to_fit_height(1.5*self.dR)\n",
        "        left_brace.next_to(special_ring, LEFT, buff = SMALL_BUFF)\n",
        "        dr = OldTex(\"dr\")\n",
        "        dr.next_to(left_brace, LEFT, buff = SMALL_BUFF)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(two_pi_r)\n",
        "        )\n",
        "        self.play(GrowFromCenter(left_brace), Write(dr))\n",
        "        self.wait()\n",
        "\n",
        "        think_concrete = OldTexText(\"Think $dr = 0.1$\")\n",
        "        think_concrete.next_to(dr, DOWN+LEFT, buff = LARGE_BUFF)\n",
        "        arrow = Arrow(think_concrete.get_top(), dr)\n",
        "        self.play(\n",
        "            Write(think_concrete),\n",
        "            ShowCreation(arrow),\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        less_wrong = OldTexText(\"\"\"\n",
        "            Approximations get\n",
        "            less wrong\n",
        "        \"\"\")\n",
        "        less_wrong.next_to(self.pi_creature, LEFT, aligned_edge = UP)\n",
        "        self.play(Write(less_wrong))\n",
        "        self.wait()\n",
        "\n",
        "        self.special_ring = special_ring\n",
        "        self.radial_line = radial_line\n",
        "        self.r_label = r_label\n",
        "        self.to_fade = VGroup(\n",
        "            brace, left_brace, two_pi_r, dr, \n",
        "            think_concrete, arrow, less_wrong\n",
        "        )\n",
        "        self.two_pi_r = two_pi_r.copy()\n",
        "        self.dr = dr.copy()\n",
        "\n",
        "    def write_integral(self):\n",
        "        brace = Brace(self.area_sum)\n",
        "        formula_q = brace.get_text(\"Nice formula?\")\n",
        "        int_sym, R, zero = def_int = OldTex(\"\\\\int\", \"_0\", \"^R\")\n",
        "        self.two_pi_r.generate_target()\n",
        "        self.dr.generate_target()\n",
        "        equals_pi_R_squared = OldTex(\"= \\\\pi R^2\")\n",
        "        integral_expression = VGroup(\n",
        "            def_int, self.two_pi_r.target,\n",
        "            self.dr.target, equals_pi_R_squared\n",
        "        )\n",
        "        integral_expression.arrange()\n",
        "        integral_expression.next_to(brace, DOWN)\n",
        "        self.integral_expression = VGroup(*integral_expression[:-1])\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(formula_q),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        last = VMobject()\n",
        "        last.save_state()\n",
        "        for ring in self.rings:\n",
        "            ring.save_state()\n",
        "            target = ring.copy()\n",
        "            target.set_fill(opacity = 1)\n",
        "            self.play(\n",
        "                last.restore,\n",
        "                Transform(ring, target),\n",
        "                Animation(self.foreground_group),\n",
        "                run_time = 0.5\n",
        "            )\n",
        "            last = ring\n",
        "        self.play(last.restore)\n",
        "        self.wait()\n",
        "\n",
        "        ghost = self.rings.copy()\n",
        "        for mob in self.area_sum_rhs, self.two_pi_r:\n",
        "            ghost.set_fill(opacity = 0.1)\n",
        "            self.play(Transform(ghost, mob))\n",
        "            self.wait()\n",
        "        self.remove(ghost)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(FadeOut(formula_q))\n",
        "        self.play(Write(int_sym))\n",
        "        self.wait()\n",
        "        self.rings.generate_target()\n",
        "        self.rings.target.set_fill(opacity = 1)\n",
        "        self.play(\n",
        "            MoveToTarget(self.rings, rate_func = there_and_back),\n",
        "            Animation(self.foreground_group)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.grow_and_shrink_r_line(zero, R)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(self.two_pi_r),\n",
        "            MoveToTarget(self.dr),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(self.to_fade),\n",
        "            ApplyMethod(self.rings.restore, run_time = 2),\n",
        "            Animation(self.foreground_group)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(equals_pi_R_squared))\n",
        "        self.wait()\n",
        "        self.equals = equals_pi_R_squared[0]\n",
        "        self.integral_terms = VGroup(\n",
        "            self.integral_expression[1], \n",
        "            self.integral_expression[2], \n",
        "            self.int_lower_bound, \n",
        "            self.int_upper_bound,\n",
        "            VGroup(*equals_pi_R_squared[1:])\n",
        "        )\n",
        "\n",
        "    def grow_and_shrink_r_line(self, zero_target, R_target):\n",
        "        self.radial_line.get_center = self.circle.get_center\n",
        "        self.radial_line.save_state()\n",
        "        self.radial_line.generate_target()\n",
        "        self.radial_line.target.scale(\n",
        "            0.1 / self.radial_line.get_length()\n",
        "        )\n",
        "        self.r_label.generate_target()\n",
        "        self.r_label.save_state()\n",
        "        equals_0 = OldTex(\"=0\")\n",
        "        r_equals_0 = VGroup(self.r_label.target, equals_0)\n",
        "        r_equals_0.arrange(buff = SMALL_BUFF)\n",
        "        r_equals_0.next_to(self.radial_line.target, UP+LEFT, buff = SMALL_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(self.radial_line),\n",
        "            MoveToTarget(self.r_label),\n",
        "            GrowFromCenter(equals_0)\n",
        "        )\n",
        "        self.play(equals_0[-1].copy().replace, zero_target)\n",
        "        self.remove(self.get_mobjects_from_last_animation()[0])\n",
        "        self.add(zero_target)\n",
        "        self.wait()\n",
        "        self.radial_line.target.scale(\n",
        "            self.radius/self.radial_line.get_length()\n",
        "        )\n",
        "        equals_0.target = OldTex(\"=R\")\n",
        "        equals_0.target.next_to(\n",
        "            self.radial_line.target.get_center_of_mass(),\n",
        "            UP+LEFT, buff = SMALL_BUFF\n",
        "        )\n",
        "        self.r_label.target.next_to(equals_0.target, LEFT, buff = SMALL_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(self.radial_line),\n",
        "            MoveToTarget(self.r_label),\n",
        "            MoveToTarget(equals_0)\n",
        "        )\n",
        "        self.play(equals_0[-1].copy().replace, R_target)\n",
        "        self.remove(self.get_mobjects_from_last_animation()[0])\n",
        "        self.add(R_target)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.radial_line.restore,\n",
        "            self.r_label.restore,\n",
        "            FadeOut(equals_0)\n",
        "        )\n",
        "        self.int_lower_bound, self.int_upper_bound = zero_target, R_target\n",
        "\n",
        "    def ask_about_approx(self):\n",
        "        approx = OldTex(\"\\\\approx\").replace(self.equals)\n",
        "        self.equals.save_state()\n",
        "        question = OldTexText(\n",
        "            \"Should this be\\\\\\\\\",\n",
        "            \"an approximation?\"\n",
        "        )\n",
        "        question.next_to(approx, DOWN, buff = 1.3*LARGE_BUFF)\n",
        "        arrow = Arrow(question, approx, buff = MED_SMALL_BUFF)\n",
        "        approach_words = OldTexText(\"Consider\\\\\\\\\", \"$dr \\\\to 0$\")\n",
        "        approach_words.move_to(question, RIGHT)\n",
        "        int_brace = Brace(self.integral_expression)\n",
        "        integral_word = int_brace.get_text(\"``Integral''\")\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.equals, approx),\n",
        "            Write(question),\n",
        "            ShowCreation(arrow),\n",
        "            self.pi_creature.change_mode, \"confused\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(ring.set_stroke, ring.get_color(), width = 1)\n",
        "            for ring in self.rings\n",
        "        ] + [\n",
        "            FadeOut(self.dr_group),\n",
        "            Animation(self.foreground_group)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(question, approach_words),\n",
        "            Transform(arrow, Arrow(approach_words, approx)),\n",
        "            self.equals.restore,\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.integral_expression.set_color_by_gradient, BLUE, GREEN,\n",
        "            GrowFromCenter(int_brace),\n",
        "            Write(integral_word)\n",
        "        )\n",
        "        self.wait()\n",
        "        for term in self.integral_terms:\n",
        "            term.save_state()\n",
        "            self.play(term.set_color, YELLOW)\n",
        "            self.play(term.restore)\n",
        "        self.wait(3)\n",
        "\n",
        "class AskAboutGeneralCircles(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            What about integrals\n",
        "            beyond this circle\n",
        "            example?\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\"confused\")\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\n",
        "            \"All in due time\",\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(2)\n",
        "\n",
        "class GraphIntegral(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_min\" : -0.25,\n",
        "        \"x_max\" : 4,\n",
        "        \"x_tick_frequency\" : 0.25,\n",
        "        \"x_leftmost_tick\" : -0.25,\n",
        "        \"x_labeled_nums\" : list(range(1, 5)),\n",
        "        \"x_axis_label\" : \"r\",\n",
        "        \"y_min\" : -2,\n",
        "        \"y_max\" : 25,\n",
        "        \"y_tick_frequency\" : 2.5,\n",
        "        \"y_bottom_tick\" : 0,\n",
        "        \"y_labeled_nums\" : list(range(5, 30, 5)),\n",
        "        \"y_axis_label\" : \"\",\n",
        "        \"dr\" : 0.125,\n",
        "        \"R\" : 3.5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.func = lambda r : 2*np.pi*r\n",
        "        integral = OldTex(\"\\\\int_0^R 2\\\\pi r \\\\, dr\")\n",
        "        integral.to_edge(UP).shift(LEFT)\n",
        "        self.little_r = integral[5]\n",
        "\n",
        "        self.play(Write(integral))\n",
        "        self.wait()\n",
        "        self.setup_axes()\n",
        "        self.show_horizontal_axis()\n",
        "        self.add_rectangles()\n",
        "        self.thinner_rectangles()\n",
        "        self.ask_about_area()\n",
        "\n",
        "    def show_horizontal_axis(self):\n",
        "        arrows = [\n",
        "            Arrow(self.little_r, self.coords_to_point(*coords))\n",
        "            for coords in ((0, 0), (self.x_max, 0))\n",
        "        ]\n",
        "        moving_arrow = arrows[0].copy()\n",
        "        self.play(\n",
        "            ShowCreation(moving_arrow),\n",
        "            self.little_r.set_color, YELLOW\n",
        "        )\n",
        "        for arrow in reversed(arrows):\n",
        "            self.play(Transform(moving_arrow, arrow, run_time = 4))\n",
        "        self.play(\n",
        "            FadeOut(moving_arrow),\n",
        "            self.little_r.set_color, WHITE\n",
        "        )\n",
        "        \n",
        "    def add_rectangles(self):\n",
        "        tick_height = 0.2\n",
        "        special_tick_index = 12\n",
        "        ticks = VGroup(*[\n",
        "            Line(UP, DOWN).move_to(self.coords_to_point(x, 0))\n",
        "            for x in np.arange(0, self.R+self.dr, self.dr)\n",
        "        ])\n",
        "        ticks.stretch_to_fit_height(tick_height)\n",
        "        ticks.set_color(YELLOW)\n",
        "        R_label = OldTex(\"R\")\n",
        "        R_label.next_to(self.coords_to_point(self.R, 0), DOWN)\n",
        "\n",
        "        values_words = OldTexText(\"Values of $r$\")\n",
        "        values_words.shift(UP)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                values_words.get_bottom(), \n",
        "                tick.get_center(), \n",
        "                tip_length = 0.15\n",
        "            )\n",
        "            for tick in ticks\n",
        "        ])\n",
        "\n",
        "        dr_brace = Brace(\n",
        "            VGroup(*ticks[special_tick_index:special_tick_index+2]), \n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        dr_text = dr_brace.get_text(\"$dr$\", buff = SMALL_BUFF)\n",
        "        # dr_text.set_color(YELLOW)\n",
        "\n",
        "        rectangles = self.get_rectangles(self.dr)\n",
        "        special_rect = rectangles[special_tick_index]\n",
        "        left_brace = Brace(special_rect, LEFT)\n",
        "        height_label = left_brace.get_text(\"$2\\\\pi r$\")\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(ticks, lag_ratio = 0.5),\n",
        "            Write(R_label)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(values_words),\n",
        "            ShowCreation(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(dr_brace),\n",
        "            Write(dr_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        rectangles.save_state()\n",
        "        rectangles.stretch_to_fit_height(0)\n",
        "        rectangles.move_to(self.graph_origin, DOWN+LEFT)\n",
        "        self.play(*list(map(FadeOut, [arrows, values_words])))\n",
        "        self.play(\n",
        "            rectangles.restore, \n",
        "            Animation(ticks),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(rect.fade, 0.7)\n",
        "            for rect in rectangles\n",
        "            if rect is not special_rect\n",
        "        ] + [Animation(ticks)])\n",
        "        self.play(\n",
        "            GrowFromCenter(left_brace),\n",
        "            Write(height_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        graph = self.graph_function(\n",
        "            lambda r : 2*np.pi*r, \n",
        "            animate = False\n",
        "        )\n",
        "        graph_label = self.label_graph(\n",
        "            self.graph, \"f(r) = 2\\\\pi r\", \n",
        "            proportion = 0.5,\n",
        "            direction = LEFT,\n",
        "            animate = False\n",
        "        )\n",
        "        self.play(\n",
        "            rectangles.restore,\n",
        "            Animation(ticks),\n",
        "            FadeOut(left_brace),\n",
        "            Transform(height_label, graph_label),\n",
        "            ShowCreation(graph)\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(*list(map(FadeOut, [ticks, dr_brace, dr_text])))\n",
        "        self.rectangles = rectangles\n",
        "\n",
        "    def thinner_rectangles(self):\n",
        "        for x in range(2, 8):\n",
        "            new_rects = self.get_rectangles(\n",
        "                dr = self.dr/x, stroke_width = 1./x\n",
        "            )\n",
        "            self.play(Transform(self.rectangles, new_rects))\n",
        "        self.wait()\n",
        "\n",
        "    def ask_about_area(self):\n",
        "        question = OldTexText(\"What's this \\\\\\\\ area\")\n",
        "        question.to_edge(RIGHT).shift(2*UP)\n",
        "        arrow = Arrow(\n",
        "            question.get_bottom(), \n",
        "            self.rectangles, \n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_rectangles(self, dr, stroke_width = 1):\n",
        "        return self.get_riemann_rectangles(\n",
        "            0, self.R, dr, stroke_width = stroke_width\n",
        "        )\n",
        "\n",
        "class MoreOnThisLater(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            More details on\n",
        "            integrals later\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\n",
        "            \"raise_right_hand\", \n",
        "            \"raise_left_hand\",\n",
        "            \"raise_left_hand\",\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\"\"\"\n",
        "            This is just\n",
        "            a preview\n",
        "        \"\"\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class FundamentalTheorem(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"circle_corner\" : ORIGIN,\n",
        "        \"radius\" : 1.5,\n",
        "        \"area_color\" : BLUE,\n",
        "        \"circum_color\" : WHITE,\n",
        "        \"unwrapped_tip\" : 2.5*UP,\n",
        "        \"include_pi_creature\" : False\n",
        "    }\n",
        "    def setup(self):\n",
        "        CircleScene.setup(self)\n",
        "        group = VGroup(\n",
        "            self.circle, self.radius_line,\n",
        "            self.radius_brace, self.radius_label\n",
        "        )\n",
        "        self.remove(*group)\n",
        "        group.shift(DOWN)\n",
        "\n",
        "        self.foreground_group = VGroup(\n",
        "            self.radius_line,\n",
        "            self.radius_brace,\n",
        "            self.radius_label,\n",
        "        )\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        return morty\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_derivative_terms()\n",
        "        self.add_integral_terms()\n",
        "        self.think_about_it()\n",
        "        self.bring_in_circle()\n",
        "        self.show_outer_ring()\n",
        "        self.show_all_rings()\n",
        "        self.emphasize_oposites()\n",
        "\n",
        "    def add_derivative_terms(self):\n",
        "        symbolic = OldTex(\n",
        "            \"\\\\frac{d(\\\\pi R^2)}{dR} =\", \"2\\\\pi R\"\n",
        "        )\n",
        "        VGroup(*symbolic[0][2:5]).set_color(self.area_color)\n",
        "        VGroup(*symbolic[0][7:9]).set_color(self.dR_color)\n",
        "        symbolic[1].set_color(self.circum_color)\n",
        "\n",
        "        geometric = OldTex(\"\\\\frac{d \\\\quad}{dR}=\")\n",
        "        VGroup(*geometric[2:4]).set_color(self.dR_color)\n",
        "        radius = geometric[0].get_height()\n",
        "        area_circle = Circle(\n",
        "            stroke_width = 0,\n",
        "            fill_color = self.area_color,\n",
        "            fill_opacity = 0.5,\n",
        "            radius = radius\n",
        "        )\n",
        "        area_circle.next_to(geometric[0], buff = SMALL_BUFF)\n",
        "        circum_circle = Circle(\n",
        "            color = self.circum_color,\n",
        "            radius = radius\n",
        "        )\n",
        "        circum_circle.next_to(geometric, RIGHT)\n",
        "        geometric.add(area_circle, circum_circle)\n",
        "        self.derivative_terms = VGroup(symbolic, geometric)\n",
        "        self.derivative_terms.arrange(\n",
        "            DOWN, buff = LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        self.derivative_terms.next_to(ORIGIN, LEFT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(self.derivative_terms),\n",
        "            self.pi_creature.change_mode, \"hooray\"\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def add_integral_terms(self):\n",
        "        symbolic = OldTex(\n",
        "            \"\\\\int_0^R\", \"2\\\\pi r\", \"\\\\cdot\", \"dr\", \"=\", \"\\\\pi R^2\"\n",
        "        )\n",
        "        symbolic.set_color_by_tex(\"2\\\\pi r\", self.circum_color)\n",
        "        symbolic.set_color_by_tex(\"dr\", self.dR_color)\n",
        "        symbolic.set_color_by_tex(\"\\\\pi R^2\", self.area_color)\n",
        "\n",
        "        geometric = symbolic.copy()\n",
        "        area_circle = Circle(\n",
        "            radius = geometric[-1].get_width()/2,\n",
        "            stroke_width = 0,\n",
        "            fill_color = self.area_color,\n",
        "            fill_opacity = 0.5\n",
        "        )\n",
        "        area_circle.move_to(geometric[-1])\n",
        "        circum_circle = Circle(\n",
        "            radius = geometric[1].get_width()/2,\n",
        "            color = self.circum_color\n",
        "        )\n",
        "        circum_circle.move_to(geometric[1])\n",
        "        geometric.submobjects[1] = circum_circle\n",
        "        geometric.submobjects[-1] = area_circle\n",
        "\n",
        "        self.integral_terms = VGroup(symbolic, geometric)\n",
        "        self.integral_terms.arrange(\n",
        "            DOWN, \n",
        "            buff = LARGE_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        self.integral_terms.next_to(ORIGIN, RIGHT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(self.integral_terms))\n",
        "        self.wait()\n",
        "\n",
        "    def think_about_it(self):\n",
        "        for mode in \"confused\", \"pondering\", \"surprised\":\n",
        "            self.change_mode(mode)\n",
        "            self.wait()\n",
        "\n",
        "    def bring_in_circle(self):\n",
        "        self.play(\n",
        "            FadeOut(self.derivative_terms[0]),\n",
        "            FadeOut(self.integral_terms[0]),\n",
        "            self.derivative_terms[1].to_corner, UP+LEFT, MED_LARGE_BUFF,\n",
        "            self.integral_terms[1].to_corner, UP+RIGHT, MED_LARGE_BUFF,\n",
        "            self.pi_creature.change_mode, \"speaking\"\n",
        "        )\n",
        "        self.introduce_circle()\n",
        "\n",
        "    def show_outer_ring(self):\n",
        "        self.increase_radius(numerical_dr = False)\n",
        "        self.foreground_group.add(self.nudge_line, self.nudge_arrow)\n",
        "        self.wait()\n",
        "        ring_copy = self.outer_ring.copy()\n",
        "        ring_copy.save_state()\n",
        "        self.unwrap_ring(ring_copy, to_edge = LEFT)\n",
        "        brace = Brace(ring_copy, UP)\n",
        "        brace.stretch_in_place(0.95, 0)\n",
        "        deriv = brace.get_text(\"$\\\\dfrac{dA}{dR}$\")\n",
        "        VGroup(*deriv[:2]).set_color(self.outer_ring.get_color())\n",
        "        VGroup(*deriv[-2:]).set_color(self.dR_color)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(deriv),\n",
        "            self.pi_creature.change_mode, \"happy\"\n",
        "        )\n",
        "        self.to_fade = VGroup(deriv, brace)\n",
        "        self.to_restore = ring_copy        \n",
        "\n",
        "    def show_all_rings(self):\n",
        "        rings = VGroup(*[\n",
        "            self.get_ring(radius = r, dR = self.dR)\n",
        "            for r in np.arange(0, self.radius, self.dR)\n",
        "        ])\n",
        "        rings.set_color_by_gradient(BLUE_E, GREEN_E)\n",
        "        rings.save_state()\n",
        "        integrand = self.integral_terms[1][1]\n",
        "        for ring in rings:\n",
        "            Transform(ring, integrand).update(1)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                rings.restore,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 5\n",
        "            ),\n",
        "            Animation(self.foreground_group),\n",
        "        )\n",
        "\n",
        "    def emphasize_oposites(self):\n",
        "        self.play(\n",
        "            FadeOut(self.to_fade),\n",
        "            self.to_restore.restore,\n",
        "            Animation(self.foreground_group),\n",
        "            run_time = 2\n",
        "        )\n",
        "        arrow = DoubleArrow(\n",
        "            self.derivative_terms[1],\n",
        "            self.integral_terms[1],\n",
        "        )\n",
        "        opposites = OldTexText(\"Opposites\")\n",
        "        opposites.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(opposites)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class NameTheFundamentalTheorem(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        symbols = OldTex(\n",
        "            \"\\\\frac{d}{dx} \\\\int_0^x f(t)dt = f(x)\",\n",
        "        )\n",
        "        symbols.to_corner(UP+LEFT)\n",
        "        brace = Brace(symbols)\n",
        "        abstract = brace.get_text(\"Abstract version\")\n",
        "        self.add(symbols)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(abstract),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, symbols)\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.random_blink()\n",
        "        self.teacher_says(\"\"\"\n",
        "            This is known as\n",
        "            the ``fundamental \n",
        "            theorem of calculus''\n",
        "        \"\"\", width = 5, height = 5, target_mode = \"hooray\")\n",
        "        self.random_blink(3)\n",
        "        self.teacher_says(\"\"\"\n",
        "            We'll get here\n",
        "            in due time.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class CalculusInANutshell(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"circle_corner\" : ORIGIN,\n",
        "        \"radius\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        self.morph_word()\n",
        "        self.show_remainder_of_series()\n",
        "\n",
        "    def morph_word(self):\n",
        "        calculus = OldTexText(\"Calculus\")\n",
        "        calculus.scale(1.5)\n",
        "        calculus.to_edge(UP)\n",
        "        dR = self.radius/float(len(calculus.split()))\n",
        "        rings = VGroup(*[\n",
        "            self.get_ring(rad, 0.95*dR)\n",
        "            for rad in np.arange(0, self.radius, dR)\n",
        "        ])\n",
        "        for ring in rings:\n",
        "            ring.add(ring.copy().rotate(np.pi))\n",
        "        for mob in calculus, rings:\n",
        "            mob.set_color_by_gradient(BLUE, GREEN)\n",
        "        rings.set_stroke(width = 0) \n",
        "\n",
        "        self.play(Write(calculus))\n",
        "        self.wait()\n",
        "        self.play(Transform(\n",
        "            calculus, rings,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_remainder_of_series(self):\n",
        "        series = VideoSeries()\n",
        "        first = series[0]\n",
        "        first.set_fill(YELLOW)\n",
        "        first.save_state()\n",
        "        first.center()\n",
        "        first.set_height(FRAME_Y_RADIUS*2)\n",
        "        first.set_fill(opacity = 0)\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        everything.generate_target()\n",
        "        everything.target.scale(series[1].get_height()/first.get_height())\n",
        "        everything.target.shift(first.saved_state.get_center())\n",
        "        everything.target.set_fill(opacity = 0.1)\n",
        "\n",
        "        second = series[1]\n",
        "        brace = Brace(second)\n",
        "        derivatives = brace.get_text(\"Derivatives\")\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(everything),\n",
        "            first.restore,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(FadeIn(\n",
        "            VGroup(*series[1:]),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(derivatives)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class Thumbnail(CircleScene):\n",
        "    CONFIG = {\n",
        "        \"radius\" : 2,\n",
        "        \"circle_corner\" : ORIGIN\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        title = OldTexText(\"Essence of \\\\\\\\ calculus\")\n",
        "        title.scale(2)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        area_circle = Circle(\n",
        "            fill_color = BLUE,\n",
        "            fill_opacity = 0.5,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        circum_circle = Circle(\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        deriv_eq = OldTex(\"\\\\frac{d \\\\quad}{dR} = \")\n",
        "        int_eq = OldTex(\"\\\\int_0^R \\\\quad = \") \n",
        "        target_height = deriv_eq[0].get_height()*2\n",
        "        area_circle.set_height(target_height)\n",
        "        circum_circle.set_height(target_height)\n",
        "\n",
        "        area_circle.next_to(deriv_eq[0], buff = SMALL_BUFF)\n",
        "        circum_circle.next_to(deriv_eq)\n",
        "        deriv_eq.add(area_circle.copy(), circum_circle.copy())\n",
        "\n",
        "        area_circle.next_to(int_eq)\n",
        "        circum_circle.next_to(int_eq[-1], LEFT)\n",
        "        int_eq.add(area_circle, circum_circle)\n",
        "\n",
        "        for mob in deriv_eq, int_eq:\n",
        "            mob.scale(1.5)\n",
        "\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\").scale(2)\n",
        "        arrow.shift(DOWN)\n",
        "        deriv_eq.next_to(arrow, LEFT)\n",
        "        int_eq.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.add(title, arrow, deriv_eq, int_eq)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}