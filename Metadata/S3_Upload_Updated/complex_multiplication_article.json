{
    "topic": "demonstrates the concept of complex power.",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from functools import reduce\n",
        "\n",
        "DEFAULT_PLANE_CONFIG = {\n",
        "    \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH\n",
        "    }\n",
        "\n",
        "\n",
        "class SuccessiveComplexMultiplications(ComplexMultiplication):\n",
        "    args_list = [\n",
        "        (complex(1, 2), complex(1, -2)),\n",
        "        (complex(-2, 1), complex(-2, -1)),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(*multipliers):\n",
        "        return \"_\".join([str(m)[1:-1] for m in  multipliers])\n",
        "\n",
        "    @staticmethod\n",
        "    def string_to_args(arg_string):\n",
        "        args_string.replac(\"i\", \"j\")\n",
        "        return list(map(copmlex, arg_string.split()))\n",
        "\n",
        "    def construct(self, *multipliers):\n",
        "        norm = abs(reduce(op.mul, multipliers, 1))\n",
        "        shrink_factor = FRAME_X_RADIUS/max(FRAME_X_RADIUS, norm)\n",
        "        plane_config = {\n",
        "            \"density\" : norm*DEFAULT_POINT_DENSITY_1D,\n",
        "            \"unit_to_spatial_width\" : shrink_factor,\n",
        "            \"x_radius\" : shrink_factor*FRAME_X_RADIUS,\n",
        "            \"y_radius\" : shrink_factor*FRAME_Y_RADIUS,\n",
        "        }\n",
        "        ComplexMultiplication.construct(self, multipliers[0], **plane_config)\n",
        "\n",
        "        one_dot = self.draw_dot(\"1\", 1, True)\n",
        "        one_dot_copy = deepcopy(one_dot)\n",
        "\n",
        "        for multiplier, count in zip(multipliers, it.count()):\n",
        "            if multiplier == multipliers[0]:\n",
        "                tex = \"z\"\n",
        "            elif np.conj(multiplier) == multipliers[0]:\n",
        "                tex = \"\\\\bar z\"\n",
        "            else:\n",
        "                tex = \"z_%d\"%count\n",
        "            self.draw_dot(tex, multiplier)\n",
        "\n",
        "        for multiplier in multipliers:\n",
        "            self.multiplier = multiplier\n",
        "            self.apply_multiplication()\n",
        "            new_one = deepcopy(one_dot_copy)\n",
        "            self.mobjects_to_move_without_molding.append(new_one)\n",
        "\n",
        "\n",
        "\n",
        "class ShowComplexPower(SuccessiveComplexMultiplications):\n",
        "    args_list = [\n",
        "        (complex(0, 1), 1),\n",
        "        (complex(0, 1), 2),\n",
        "        (np.exp(complex(0, 2*np.pi/5)), 1),\n",
        "        (np.exp(complex(0, 2*np.pi/5)), 5),\n",
        "        (np.exp(complex(0, 4*np.pi/5)), 5),\n",
        "        (np.exp(complex(0, -2*np.pi/5)), 5),\n",
        "        (complex(1, np.sqrt(3)), 1),\n",
        "        (complex(1, np.sqrt(3)), 3),\n",
        "    ]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(multiplier, num_repeats):\n",
        "        start = ComplexMultiplication.args_to_string(multiplier)\n",
        "        return start + \"ToThe%d\"%num_repeats\n",
        "\n",
        "    @staticmethod\n",
        "    def string_to_args(arg_string):\n",
        "        parts = arg_string.split()\n",
        "        if len(parts) < 2 or len(parts) > 3:\n",
        "            raise Exception(\"Invalid arguments\")\n",
        "        multiplier = complex(parts[0])\n",
        "        num_repeats = int(parts[1])\n",
        "        return multiplier, num_repeats\n",
        "\n",
        "    def construct(self, multiplier, num_repeats):\n",
        "        SuccessiveComplexMultiplications.construct(\n",
        "            [multiplier]*num_repeats\n",
        "        )\n",
        "\n",
        "\n",
        "class ComplexDivision(ComplexMultiplication):\n",
        "    args_list = [\n",
        "        complex(np.sqrt(3), 1),\n",
        "        complex(1./3, -1./3),\n",
        "        complex(1, 2),\n",
        "    ]\n",
        "\n",
        "    def construct(self, num):\n",
        "        ComplexMultiplication.construct(self, 1./num)\n",
        "        self.draw_dot(\"1\", 1, False),\n",
        "        self.draw_dot(\"z\", num, True)\n",
        "        self.apply_multiplication()\n",
        "\n",
        "class ConjugateDivisionExample(ComplexMultiplication):\n",
        "    args_list = [\n",
        "        complex(1, 2),\n",
        "    ]\n",
        "\n",
        "    def construct(self, num):\n",
        "        ComplexMultiplication.construct(self, np.conj(num), radius = 2.5*FRAME_X_RADIUS)\n",
        "        self.draw_dot(\"1\", 1, True)\n",
        "        self.draw_dot(\"\\\\bar z\", self.multiplier)\n",
        "        self.apply_multiplication()\n",
        "        self.multiplier = 1./(abs(num)**2)\n",
        "        self.anim_config[\"path_func\"] = straight_path\n",
        "        self.apply_multiplication()\n",
        "        self.wait()\n",
        "\n",
        "class DrawSolutionsToZToTheNEqualsW(Scene):\n",
        "    @staticmethod\n",
        "    def args_to_string(n, w):\n",
        "        return str(n) + \"_\" + complex_string(w)\n",
        "\n",
        "    @staticmethod\n",
        "    def string_to_args(args_string):\n",
        "        parts = args_string.split()\n",
        "        return int(parts[0]), complex(parts[1])\n",
        "\n",
        "    def construct(self, n, w):\n",
        "        w = complex(w)\n",
        "        plane_config = DEFAULT_PLANE_CONFIG.copy()\n",
        "        norm = abs(w)\n",
        "        theta = np.log(w).imag\n",
        "        radius = norm**(1./n)\n",
        "        zoom_value = (FRAME_Y_RADIUS-0.5)/radius\n",
        "        plane_config[\"unit_to_spatial_width\"] = zoom_value\n",
        "        plane = ComplexPlane(**plane_config)\n",
        "        circle = Circle(\n",
        "            radius = radius*zoom_value,\n",
        "            stroke_width = plane.stroke_width\n",
        "        )\n",
        "        solutions = [\n",
        "            radius*np.exp(complex(0, 1)*(2*np.pi*k + theta)/n)\n",
        "            for k in range(n)\n",
        "        ]\n",
        "        points = list(map(plane.number_to_point, solutions))\n",
        "        dots = [\n",
        "            Dot(point, color = BLUE_B, radius = 0.1)\n",
        "            for point in points\n",
        "        ]\n",
        "        lines = [Line(*pair) for pair in adjacent_pairs(points)]\n",
        "\n",
        "        self.add(plane, circle, *dots+lines)\n",
        "        self.add(*plane.get_coordinate_labels())\n",
        "\n",
        "\n",
        "class DrawComplexAngleAndMagnitude(Scene):\n",
        "    args_list = [\n",
        "        (\n",
        "            (\"1+i\\\\sqrt{3}\", complex(1, np.sqrt(3)) ),\n",
        "            (\"\\\\frac{\\\\sqrt{3}}{2} - \\\\frac{1}{2}i\", complex(np.sqrt(3)/2, -1./2)),\n",
        "        ),\n",
        "        ((\"1+i\", complex(1, 1)),),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*reps_and_nums):\n",
        "        return \"--\".join([\n",
        "            complex_string(num) \n",
        "            for rep, num in reps_and_nums\n",
        "        ])\n",
        "\n",
        "    def construct(self, *reps_and_nums):\n",
        "        radius = max([abs(n.imag) for r, n in reps_and_nums]) + 1\n",
        "        plane_config = {\n",
        "            \"color\" : \"grey\",\n",
        "            \"unit_to_spatial_width\" : FRAME_Y_RADIUS / radius,\n",
        "        }\n",
        "        plane_config.update(DEFAULT_PLANE_CONFIG)\n",
        "        self.plane = ComplexPlane(**plane_config)\n",
        "        coordinates = self.plane.get_coordinate_labels()\n",
        "        # self.plane.add_spider_web()\n",
        "        self.add(self.plane, *coordinates)\n",
        "        for rep, num in reps_and_nums:\n",
        "            self.draw_number(rep, num)\n",
        "            self.add_angle_label(num)\n",
        "            self.add_lines(rep, num)\n",
        "\n",
        "    def draw_number(self, tex_representation, number):\n",
        "        point = self.plane.number_to_point(number)\n",
        "        dot = Dot(point)\n",
        "        label = OldTex(tex_representation)\n",
        "        max_width = 0.8*self.plane.unit_to_spatial_width\n",
        "        if label.get_width() > max_width:\n",
        "            label.set_width(max_width)\n",
        "        dot_to_label_dir = RIGHT if point[0] > 0 else LEFT\n",
        "        edge = label.get_edge_center(-dot_to_label_dir)\n",
        "        buff = 0.1\n",
        "        label.shift(point - edge + buff*dot_to_label_dir)\n",
        "        label.set_color(YELLOW)\n",
        "\n",
        "        self.add_mobjects_among(list(locals().values()))\n",
        "\n",
        "\n",
        "    def add_angle_label(self, number):\n",
        "        arc = Arc(\n",
        "            np.log(number).imag, \n",
        "            radius = 0.2\n",
        "        )\n",
        "\n",
        "        self.add_mobjects_among(list(locals().values()))\n",
        "\n",
        "    def add_lines(self, tex_representation, number):\n",
        "        point = self.plane.number_to_point(number)\n",
        "        x_line, y_line, num_line = [\n",
        "            Line(\n",
        "                start, end,\n",
        "                color = color, \n",
        "                stroke_width = self.plane.stroke_width\n",
        "            )\n",
        "            for start, end, color in zip(\n",
        "                [ORIGIN, point[0]*RIGHT, ORIGIN],\n",
        "                [point[0]*RIGHT, point, point],\n",
        "                [BLUE_D, GOLD_E, WHITE]\n",
        "            )\n",
        "        ]\n",
        "        # tex_representation.replace(\"i\", \"\")\n",
        "        # if \"+\" in tex_representation:\n",
        "        #     tex_parts = tex_representation.split(\"+\")\n",
        "        # elif \"-\" in tex_representation:\n",
        "        #     tex_parts = tex_representation.split(\"-\")\n",
        "        # x_label, y_label = map(Tex, tex_parts)\n",
        "        # for label in x_label, y_label:\n",
        "        #     label.set_height(0.5)\n",
        "        # x_label.next_to(x_line, point[1]*DOWN/abs(point[1]))\n",
        "        # y_label.next_to(y_line, point[0]*RIGHT/abs(point[0]))\n",
        "        norm = get_norm(point)\n",
        "        brace = Underbrace(ORIGIN, ORIGIN+norm*RIGHT)\n",
        "        if point[1] > 0:\n",
        "            brace.rotate(np.pi, RIGHT)\n",
        "        brace.rotate(np.log(number).imag)\n",
        "        norm_label = OldTex(\"%.1f\"%abs(number))\n",
        "        norm_label.scale(0.5)\n",
        "        axis = OUT if point[1] > 0 else IN\n",
        "        norm_label.next_to(brace, rotate_vector(point, np.pi/2, axis))\n",
        "\n",
        "        self.add_mobjects_among(list(locals().values()))\n",
        "\n"
    ]
}