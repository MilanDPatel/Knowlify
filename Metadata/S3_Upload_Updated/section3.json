{
    "topic": "The mathematical concept being demonstrated is the relationship between infinite sums and finite representations of numbers.",
    "code": [
        "from manim_imports_ext import *\n",
        "import displayer as disp\n",
        "\n",
        "from hilbert.curves import \\\n",
        "    TransformOverIncreasingOrders, FlowSnake, HilbertCurve, \\\n",
        "    SnakeCurve, Sierpinski\n",
        "from hilbert.section1 import get_mathy_and_bubble\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class SectionThree(Scene):\n",
        "    def construct(self):\n",
        "        self.add(OldTexText(\"A few words on the usefulness of infinite math\"))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class InfiniteResultsFiniteWorld(Scene):\n",
        "    def construct(self):\n",
        "        left_words = OldTexText(\"Infinite result\")\n",
        "        right_words = OldTexText(\"Finite world\")\n",
        "        for words in left_words, right_words:\n",
        "            words.scale(0.8)\n",
        "        left_formula = OldTex(\n",
        "            \"\\\\sum_{n = 0}^{\\\\infty} 2^n = -1\"\n",
        "        )\n",
        "        right_formula = OldTex(\"111\\\\cdots111\")\n",
        "        for formula in left_formula, right_formula:\n",
        "            formula.add(\n",
        "                Brace(formula, UP),\n",
        "            )\n",
        "            formula.ingest_submobjects()\n",
        "        right_overwords = OldTexText(\n",
        "            \"\\\\substack{\\\n",
        "                \\\\text{How computers} \\\\\\\\ \\\n",
        "                \\\\text{represent $-1$}\\\n",
        "            }\"\n",
        "        ).scale(1.5)\n",
        "\n",
        "        left_mobs = [left_words, left_formula]\n",
        "        right_mobs = [right_words, right_formula]\n",
        "        for mob in left_mobs:\n",
        "            mob.to_edge(RIGHT, buff = 1)\n",
        "            mob.shift(FRAME_X_RADIUS*LEFT)\n",
        "        for mob in right_mobs:\n",
        "            mob.to_edge(LEFT, buff = 1)\n",
        "            mob.shift(FRAME_X_RADIUS*RIGHT)\n",
        "        arrow = Arrow(left_words, right_words)\n",
        "        right_overwords.next_to(right_formula, UP)\n",
        "\n",
        "        self.play(ShimmerIn(left_words))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(ShimmerIn(right_words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(left_formula),\n",
        "            ApplyMethod(left_words.next_to, left_formula, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(right_formula),\n",
        "            Transform(right_words, right_overwords)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.finite_analog(\n",
        "            Mobject(left_formula, left_words),\n",
        "            arrow,\n",
        "            Mobject(right_formula, right_words)\n",
        "        )\n",
        "\n",
        "\n",
        "    def finite_analog(self, left_mob, arrow, right_mob):\n",
        "        self.clear()\n",
        "        self.add(left_mob, arrow, right_mob)\n",
        "        ex = OldTexText(\"\\\\times\")\n",
        "        ex.set_color(RED)\n",
        "        # ex.shift(arrow.get_center())\n",
        "        middle = OldTex(\n",
        "            \"\\\\sum_{n=0}^N 2^n \\\\equiv -1 \\\\mod 2^{N+1}\"\n",
        "        )\n",
        "        finite_analog = OldTexText(\"Finite analog\")\n",
        "        finite_analog.scale(0.8)\n",
        "        brace = Brace(middle, UP)\n",
        "        finite_analog.next_to(brace, UP)\n",
        "        new_left = left_mob.copy().to_edge(LEFT)\n",
        "        new_right = right_mob.copy().to_edge(RIGHT)\n",
        "        left_arrow, right_arrow = [\n",
        "            Arrow(\n",
        "                mob1.get_right()[0]*RIGHT,\n",
        "                mob2.get_left()[0]*RIGHT,\n",
        "                buff = 0\n",
        "            )\n",
        "            for mob1, mob2 in [\n",
        "                (new_left, middle), \n",
        "                (middle, new_right)\n",
        "            ]\n",
        "        ]\n",
        "        for mob in ex, middle:\n",
        "            mob.sort_points(get_norm)\n",
        "\n",
        "        self.play(GrowFromCenter(ex))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(left_mob, new_left),\n",
        "            Transform(arrow.copy(), left_arrow),\n",
        "            DelayByOrder(Transform(ex, middle)),\n",
        "            Transform(arrow, right_arrow),\n",
        "            Transform(right_mob, new_right)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShimmerIn(finite_analog)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.equivalence(\n",
        "            left_mob,\n",
        "            left_arrow, \n",
        "            Mobject(middle, brace, finite_analog)\n",
        "        )\n",
        "\n",
        "    def equivalence(self, left_mob, arrow, right_mob):\n",
        "        self.clear()\n",
        "        self.add(left_mob, arrow, right_mob)\n",
        "        words = OldTexText(\"is equivalent to\")\n",
        "        words.shift(0.25*LEFT)\n",
        "        words.set_color(BLUE)\n",
        "        new_left = left_mob.copy().shift(RIGHT)\n",
        "        new_right = right_mob.copy()\n",
        "        new_right.shift(\n",
        "            (words.get_right()[0]-\\\n",
        "             right_mob.get_left()[0]+\\\n",
        "             0.5\n",
        "            )*RIGHT\n",
        "        )\n",
        "        for mob in arrow, words:\n",
        "            mob.sort_points(get_norm)     \n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(left_mob.shift, RIGHT),\n",
        "            Transform(arrow, words),\n",
        "            ApplyMethod(right_mob.to_edge, RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HilbertCurvesStayStable(Scene):\n",
        "    def construct(self):\n",
        "        scale_factor = 0.9\n",
        "        grid = Grid(4, 4, stroke_width = 1)\n",
        "        curve = HilbertCurve(order = 2)\n",
        "        for mob in grid, curve:\n",
        "            mob.scale(scale_factor)\n",
        "        words = OldTexText(\"\"\"\n",
        "            Sequence of curves is stable \n",
        "            $\\\\leftrightarrow$ existence of limit curve\n",
        "        \"\"\", size = \"\\\\normal\")\n",
        "        words.scale(1.25)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.add(curve, grid)\n",
        "        self.wait()\n",
        "        for n in range(3, 7):\n",
        "            if n == 5:\n",
        "                self.play(ShimmerIn(words))\n",
        "            new_grid = Grid(2**n, 2**n, stroke_width = 1)\n",
        "            new_curve = HilbertCurve(order = n)\n",
        "            for mob in new_grid, new_curve:\n",
        "                mob.scale(scale_factor)\n",
        "            self.play(\n",
        "                ShowCreation(new_grid),\n",
        "                Animation(curve)\n",
        "            )\n",
        "            self.remove(grid)\n",
        "            grid = new_grid\n",
        "            self.play(Transform(curve, new_curve))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class InfiniteObjectsEncapsulateFiniteObjects(Scene):\n",
        "    def get_triangles(self):\n",
        "        triangle = Polygon(\n",
        "            LEFT/np.sqrt(3),\n",
        "            UP,\n",
        "            RIGHT/np.sqrt(3),\n",
        "            color = GREEN\n",
        "        )\n",
        "        triangles = Mobject(\n",
        "            triangle.copy().scale(0.5).shift(LEFT),\n",
        "            triangle,\n",
        "            triangle.copy().scale(0.3).shift(0.5*UP+RIGHT)\n",
        "        )\n",
        "        triangles.center()\n",
        "        return triangles\n",
        "\n",
        "    def construct(self):\n",
        "        words =[\n",
        "            OldTexText(text, size = \"\\\\large\")\n",
        "            for text in [\n",
        "                \"Truths about infinite objects\", \n",
        "                \" encapsulate \", \n",
        "                \"facts about finite objects\"\n",
        "            ]\n",
        "        ]\n",
        "        \n",
        "        words[0].set_color(RED)\n",
        "        words[1].next_to(words[0])\n",
        "        words[2].set_color(GREEN).next_to(words[1])\n",
        "        Mobject(*words).center().to_edge(UP)\n",
        "        infinite_objects = [\n",
        "            OldTex(\n",
        "                \"\\\\sum_{n=0}^\\\\infty\", \n",
        "                size = \"\\\\normal\"\n",
        "            ).set_color(RED_E),\n",
        "            Sierpinski(order = 8).scale(0.3),\n",
        "            OldTexText(\n",
        "                \"$\\\\exists$ something infinite $\\\\dots$\"\n",
        "            ).set_color(RED_B)\n",
        "        ]\n",
        "        finite_objects = [\n",
        "            OldTex(\n",
        "                \"\\\\sum_{n=0}^N\",\n",
        "                size = \"\\\\normal\"\n",
        "            ).set_color(GREEN_E),\n",
        "            self.get_triangles(),\n",
        "            OldTexText(\n",
        "                \"$\\\\forall$ finite somethings $\\\\dots$\"\n",
        "            ).set_color(GREEN_B)\n",
        "        ]\n",
        "        for infinite, finite, n in zip(infinite_objects, finite_objects, it.count(1, 2)):\n",
        "            infinite.next_to(words[0], DOWN, buff = n)\n",
        "            finite.next_to(words[2], DOWN, buff = n)\n",
        "\n",
        "        self.play(ShimmerIn(words[0]))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(infinite_objects[0]))\n",
        "        self.play(ShowCreation(infinite_objects[1]))\n",
        "        self.play(ShimmerIn(infinite_objects[2]))\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(words[1]), ShimmerIn(words[2]))\n",
        "        self.play(ShimmerIn(finite_objects[0]))\n",
        "        self.play(ShowCreation(finite_objects[1]))\n",
        "        self.play(ShimmerIn(finite_objects[2]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class StatementRemovedFromReality(Scene):\n",
        "    def construct(self):\n",
        "        mathy, bubble = get_mathy_and_bubble()\n",
        "        bubble.stretch_to_fit_width(4)\n",
        "        mathy.to_corner(DOWN+LEFT)\n",
        "        bubble.pin_to(mathy)\n",
        "        bubble.shift(LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        morty_bubble = SpeechBubble()\n",
        "        morty_bubble.stretch_to_fit_width(4)\n",
        "        morty_bubble.pin_to(morty)\n",
        "        bubble.write(\"\"\"\n",
        "            Did you know a curve \\\\\\\\\n",
        "            can fill all space?\n",
        "        \"\"\")\n",
        "        morty_bubble.write(\"Who cares?\")\n",
        "\n",
        "        self.add(mathy, morty)\n",
        "        for bub, buddy in [(bubble, mathy), (morty_bubble, morty)]:\n",
        "            self.play(Transform(\n",
        "                Point(bub.get_tip()),\n",
        "                bub\n",
        "            ))\n",
        "            self.play(ShimmerIn(bub.content))\n",
        "            self.play(ApplyMethod(\n",
        "                buddy.blink,\n",
        "                rate_func = squish_rate_func(there_and_back)\n",
        "            ))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}