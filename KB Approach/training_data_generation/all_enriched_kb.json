[
  {
    "code": [
      "from manim import *",
      "",
      "class FollowingGraphCamera(MovingCameraScene):",
      "    def construct(self):",
      "        self.camera.frame.save_state()",
      "",
      "        # create the axes and the curve",
      "        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])",
      "        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])",
      "",
      "        # create dots based on the graph",
      "        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)",
      "        dot_1 = Dot(ax.i2gp(graph.t_min, graph))",
      "        dot_2 = Dot(ax.i2gp(graph.t_max, graph))",
      "",
      "        self.add(ax, graph, dot_1, dot_2, moving_dot)",
      "        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))",
      "",
      "        def update_curve(mob):",
      "            mob.move_to(moving_dot.get_center())",
      "",
      "        self.camera.frame.add_updater(update_curve)",
      "        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))",
      "        self.camera.frame.remove_updater(update_curve)",
      "",
      "        self.play(Restore(self.camera.frame))"
    ],
    "topic": "Camera following graph",
    "description": "Shows a camera smoothly following a moving dot along a sine curve on coordinate axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GradientImageFromArray(Scene):",
      "    def construct(self):",
      "        n = 256",
      "        imageArray = np.uint8(",
      "            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]",
      "        )",
      "        image = ImageMobject(imageArray).scale(2)",
      "        image.background_rectangle = SurroundingRectangle(image, color=GREEN)",
      "        self.add(image, image.background_rectangle)"
    ],
    "topic": "gradient image display",
    "description": "Displays a grayscale gradient image with a green rectangular border."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingZoomedSceneAround(ZoomedScene):",
      "# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven",
      "    def __init__(self, **kwargs):",
      "        ZoomedScene.__init__(",
      "            self,",
      "            zoom_factor=0.3,",
      "            zoomed_display_height=1,",
      "            zoomed_display_width=6,",
      "            image_frame_stroke_width=20,",
      "            zoomed_camera_config={",
      "                \"default_frame_stroke_width\": 3,",
      "                },",
      "            **kwargs",
      "        )",
      "",
      "    def construct(self):",
      "        dot = Dot().shift(UL * 2)",
      "        image = ImageMobject(np.uint8([[0, 100, 30, 200],",
      "                                       [255, 0, 5, 33]]))",
      "        image.height = 7",
      "        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)",
      "        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)",
      "",
      "        self.add(image, dot)",
      "        zoomed_camera = self.zoomed_camera",
      "        zoomed_display = self.zoomed_display",
      "        frame = zoomed_camera.frame",
      "        zoomed_display_frame = zoomed_display.display_frame",
      "",
      "        frame.move_to(dot)",
      "        frame.set_color(PURPLE)",
      "        zoomed_display_frame.set_color(RED)",
      "        zoomed_display.shift(DOWN)",
      "",
      "        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)",
      "        self.add_foreground_mobject(zd_rect)",
      "",
      "        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))",
      "",
      "        frame_text.next_to(frame, DOWN)",
      "",
      "        self.play(Create(frame), FadeIn(frame_text, shift=UP))",
      "        self.activate_zooming()",
      "",
      "        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)",
      "        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)",
      "        self.play(FadeIn(zoomed_camera_text, shift=UP))",
      "        # Scale in        x   y  z",
      "        scale_factor = [0.5, 1.5, 0]",
      "        self.play(",
      "            frame.animate.scale(scale_factor),",
      "            zoomed_display.animate.scale(scale_factor),",
      "            FadeOut(zoomed_camera_text),",
      "            FadeOut(frame_text)",
      "        )",
      "        self.wait()",
      "        self.play(ScaleInPlace(zoomed_display, 2))",
      "        self.wait()",
      "        self.play(frame.animate.shift(2.5 * DOWN))",
      "        self.wait()",
      "        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))",
      "        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))",
      "        self.wait()"
    ],
    "topic": "zoomed scene animation",
    "description": "Demonstrates a zoomed camera effect moving around a dot and image, with text annotations and scaling transformations."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingGroupToDestination(Scene):",
      "    def construct(self):",
      "        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)",
      "        dest = Dot([4, 3, 0], color=YELLOW)",
      "        self.add(group, dest)",
      "        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))",
      "        self.wait(0.5)"
    ],
    "topic": "group movement",
    "description": "Animates a group of dots shifting to align with a destination dot's position."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BraceAnnotation(Scene):",
      "    def construct(self):",
      "        dot = Dot([-2, -1, 0])",
      "        dot2 = Dot([2, 1, 0])",
      "        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)",
      "        b1 = Brace(line)",
      "        b1text = b1.get_text(\"Horizontal distance\")",
      "        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())",
      "        b2text = b2.get_tex(\"x-x_1\")",
      "        self.add(line, dot, dot2, b1, b2, b1text, b2text)"
    ],
    "topic": "brace annotation",
    "description": "Illustrates a line segment with braces showing horizontal distance and a mathematical expression."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BooleanOperations(Scene):",
      "    def construct(self):",
      "        ellipse1 = Ellipse(",
      "            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10",
      "        ).move_to(LEFT)",
      "        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)",
      "        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)",
      "        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)",
      "        self.play(FadeIn(ellipse_group))",
      "",
      "        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)",
      "        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))",
      "        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)",
      "        self.play(FadeIn(intersection_text))",
      "",
      "        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)",
      "        union_text = Text(\"Union\", font_size=23)",
      "        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))",
      "        union_text.next_to(u, UP)",
      "        self.play(FadeIn(union_text))",
      "",
      "        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)",
      "        exclusion_text = Text(\"Exclusion\", font_size=23)",
      "        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))",
      "        exclusion_text.next_to(e, UP)",
      "        self.play(FadeIn(exclusion_text))",
      "",
      "        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)",
      "        difference_text = Text(\"Difference\", font_size=23)",
      "        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))",
      "        difference_text.next_to(d, UP)",
      "        self.play(FadeIn(difference_text))"
    ],
    "topic": "Boolean operations visualization",
    "description": "Demonstrates Boolean operations on ellipses, showing intersection, union, exclusion, and difference with labeled animations."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RotationUpdater(Scene):",
      "    def construct(self):",
      "        def updater_forth(mobj, dt):",
      "            mobj.rotate_about_origin(dt)",
      "        def updater_back(mobj, dt):",
      "            mobj.rotate_about_origin(-dt)",
      "        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)",
      "        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)",
      "        line_moving.add_updater(updater_forth)",
      "        self.add(line_reference, line_moving)",
      "        self.wait(2)",
      "        line_moving.remove_updater(updater_forth)",
      "        line_moving.add_updater(updater_back)",
      "        self.wait(2)",
      "        line_moving.remove_updater(updater_back)",
      "        self.wait(0.5)"
    ],
    "topic": "rotating line animation",
    "description": "Shows a yellow line rotating back and forth around the origin, alternating directions after a pause."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ThreeDCameraRotation(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        circle=Circle()",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(circle,axes)",
      "        self.begin_ambient_camera_rotation(rate=0.1)",
      "        self.wait()",
      "        self.stop_ambient_camera_rotation()",
      "        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.wait()"
    ],
    "topic": "3D camera rotation",
    "description": "Displays a 3D scene with a circle and axes, featuring a rotating camera view."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ThreeDLightSourcePosition(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        sphere = Surface(",
      "            lambda u, v: np.array([",
      "                1.5 * np.cos(u) * np.cos(v),",
      "                1.5 * np.cos(u) * np.sin(v),",
      "                1.5 * np.sin(u)",
      "            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],",
      "            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)",
      "        )",
      "        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(axes, sphere)"
    ],
    "topic": "3D lighting effect",
    "description": "Displays a 3D sphere with a movable light source affecting its shading and appearance."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArgMinExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}",
      "        )",
      "        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")",
      "",
      "        t = ValueTracker(0)",
      "",
      "        def func(x):",
      "            return 2 * (x - 5) ** 2",
      "        graph = ax.plot(func, color=MAROON)",
      "",
      "        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]",
      "        dot = Dot(point=initial_point)",
      "",
      "        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))",
      "        x_space = np.linspace(*ax.x_range[:2],200)",
      "        minimum_index = func(x_space).argmin()",
      "",
      "        self.add(ax, labels, graph, dot)",
      "        self.play(t.animate.set_value(x_space[minimum_index]))",
      "        self.wait()"
    ],
    "topic": "2D function optimization",
    "description": "Animates a dot moving along a parabola to find and highlight its minimum point."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingDots(Scene):",
      "    def construct(self):",
      "        d1,d2=Dot(color=BLUE),Dot(color=GREEN)",
      "        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)",
      "        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)",
      "        x=ValueTracker(0)",
      "        y=ValueTracker(0)",
      "        d1.add_updater(lambda z: z.set_x(x.get_value()))",
      "        d2.add_updater(lambda z: z.set_y(y.get_value()))",
      "        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))",
      "        self.add(d1,d2,l1)",
      "        self.play(x.animate.set_value(5))",
      "        self.play(y.animate.set_value(4))",
      "        self.wait()"
    ],
    "topic": "moving dots and line",
    "description": "Animates two dots moving horizontally and vertically while a line dynamically connects them."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingFrameBox(Scene):",
      "    def construct(self):",
      "        text=MathTex(",
      "            \"\\\\frac{d}{dx}f(x)g(x)=\",\"f(x)\\\\frac{d}{dx}g(x)\",\"+\",",
      "            \"g(x)\\\\frac{d}{dx}f(x)\"",
      "        )",
      "        self.play(Write(text))",
      "        framebox1 = SurroundingRectangle(text[1], buff = .1)",
      "        framebox2 = SurroundingRectangle(text[3], buff = .1)",
      "        self.play(",
      "            Create(framebox1),",
      "        )",
      "        self.wait()",
      "        self.play(",
      "            ReplacementTransform(framebox1,framebox2),",
      "        )",
      "        self.wait()"
    ],
    "topic": "text highlighting",
    "description": "Animates the highlighting of different parts of a mathematical expression using surrounding rectangles."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingAngle(Scene):",
      "    def construct(self):",
      "        rotation_center = LEFT",
      "",
      "        theta_tracker = ValueTracker(110)",
      "        line1 = Line(LEFT, RIGHT)",
      "        line_moving = Line(LEFT, RIGHT)",
      "        line_ref = line_moving.copy()",
      "        line_moving.rotate(",
      "            theta_tracker.get_value() * DEGREES, about_point=rotation_center",
      "        )",
      "        a = Angle(line1, line_moving, radius=0.5, other_angle=False)",
      "        tex = MathTex(r\"\\theta\").move_to(",
      "            Angle(",
      "                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False",
      "            ).point_from_proportion(0.5)",
      "        )",
      "",
      "        self.add(line1, line_moving, a, tex)",
      "        self.wait()",
      "",
      "        line_moving.add_updater(",
      "            lambda x: x.become(line_ref.copy()).rotate(",
      "                theta_tracker.get_value() * DEGREES, about_point=rotation_center",
      "            )",
      "        )",
      "",
      "        a.add_updater(",
      "            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))",
      "        )",
      "        tex.add_updater(",
      "            lambda x: x.move_to(",
      "                Angle(",
      "                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False",
      "                ).point_from_proportion(0.5)",
      "            )",
      "        )",
      "",
      "        self.play(theta_tracker.animate.set_value(40))",
      "        self.play(theta_tracker.animate.increment_value(140))",
      "        self.play(tex.animate.set_color(RED), run_time=0.5)",
      "        self.play(theta_tracker.animate.set_value(350))"
    ],
    "topic": "angle rotation animation",
    "description": "Illustrates a rotating angle between two lines with an updating angle label."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingAround(Scene):",
      "    def construct(self):",
      "        square = Square(color=BLUE, fill_opacity=1)",
      "",
      "        self.play(square.animate.shift(LEFT))",
      "        self.play(square.animate.set_fill(ORANGE))",
      "        self.play(square.animate.scale(0.3))",
      "        self.play(square.animate.rotate(0.4))"
    ],
    "topic": "square transformation",
    "description": "Animates a blue square moving left, changing color to orange, scaling down, and rotating."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class VectorArrow(Scene):",
      "    def construct(self):",
      "        dot = Dot(ORIGIN)",
      "        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)",
      "        numberplane = NumberPlane()",
      "        origin_text = Text('(0, 0)').next_to(dot, DOWN)",
      "        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)",
      "        self.add(numberplane, dot, arrow, origin_text, tip_text)"
    ],
    "topic": "vector visualization",
    "description": "Displays a vector arrow from the origin to the point (2, 2) on a number plane with coordinate labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FixedInFrameMObjectTest(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)",
      "        text3d = Text(\"This is a 3D text\")",
      "        self.add_fixed_in_frame_mobjects(text3d)",
      "        text3d.to_corner(UL)",
      "        self.add(axes)",
      "        self.wait()"
    ],
    "topic": "3D text with axes",
    "description": "Displays 3D axes with static 3D text fixed in the upper left corner."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SineCurveUnitCircle(Scene):",
      "    # contributed by heejin_park, https://infograph.tistory.com/230",
      "    def construct(self):",
      "        self.show_axis()",
      "        self.show_circle()",
      "        self.move_dot_and_draw_curve()",
      "        self.wait()",
      "",
      "    def show_axis(self):",
      "        x_start = np.array([-6,0,0])",
      "        x_end = np.array([6,0,0])",
      "",
      "        y_start = np.array([-4,-2,0])",
      "        y_end = np.array([-4,2,0])",
      "",
      "        x_axis = Line(x_start, x_end)",
      "        y_axis = Line(y_start, y_end)",
      "",
      "        self.add(x_axis, y_axis)",
      "        self.add_x_labels()",
      "",
      "        self.origin_point = np.array([-4,0,0])",
      "        self.curve_start = np.array([-3,0,0])",
      "",
      "    def add_x_labels(self):",
      "        x_labels = [",
      "            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),",
      "            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),",
      "        ]",
      "",
      "        for i in range(len(x_labels)):",
      "            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)",
      "            self.add(x_labels[i])",
      "",
      "    def show_circle(self):",
      "        circle = Circle(radius=1)",
      "        circle.move_to(self.origin_point)",
      "        self.add(circle)",
      "        self.circle = circle",
      "",
      "    def move_dot_and_draw_curve(self):",
      "        orbit = self.circle",
      "        origin_point = self.origin_point",
      "",
      "        dot = Dot(radius=0.08, color=YELLOW)",
      "        dot.move_to(orbit.point_from_proportion(0))",
      "        self.t_offset = 0",
      "        rate = 0.25",
      "",
      "        def go_around_circle(mob, dt):",
      "            self.t_offset += (dt * rate)",
      "            # print(self.t_offset)",
      "            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))",
      "",
      "        def get_line_to_circle():",
      "            return Line(origin_point, dot.get_center(), color=BLUE)",
      "",
      "        def get_line_to_curve():",
      "            x = self.curve_start[0] + self.t_offset * 4",
      "            y = dot.get_center()[1]",
      "            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )",
      "",
      "",
      "        self.curve = VGroup()",
      "        self.curve.add(Line(self.curve_start,self.curve_start))",
      "        def get_curve():",
      "            last_line = self.curve[-1]",
      "            x = self.curve_start[0] + self.t_offset * 4",
      "            y = dot.get_center()[1]",
      "            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)",
      "            self.curve.add(new_line)",
      "",
      "            return self.curve",
      "",
      "        dot.add_updater(go_around_circle)",
      "",
      "        origin_to_circle_line = always_redraw(get_line_to_circle)",
      "        dot_to_curve_line = always_redraw(get_line_to_curve)",
      "        sine_curve_line = always_redraw(get_curve)",
      "",
      "        self.add(dot)",
      "        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)",
      "        self.wait(8.5)",
      "",
      "        dot.remove_updater(go_around_circle)"
    ],
    "topic": "Sine wave generation",
    "description": "Illustrates the generation of a sine wave from a unit circle by moving a dot around the circle and projecting its vertical position onto a horizontal axis."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ThreeDCameraIllusionRotation(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        circle=Circle()",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(circle,axes)",
      "        self.begin_3dillusion_camera_rotation(rate=2)",
      "        self.wait(PI/2)",
      "        self.stop_3dillusion_camera_rotation()"
    ],
    "topic": "3D camera rotation illusion",
    "description": "Displays a static circle and 3D axes with an illusion of camera rotation around them."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointWithTrace(Scene):",
      "    def construct(self):",
      "        path = VMobject()",
      "        dot = Dot()",
      "        path.set_points_as_corners([dot.get_center(), dot.get_center()])",
      "        def update_path(path):",
      "            previous_path = path.copy()",
      "            previous_path.add_points_as_corners([dot.get_center()])",
      "            path.become(previous_path)",
      "        path.add_updater(update_path)",
      "        self.add(path, dot)",
      "        self.play(Rotating(dot, angle=PI, about_point=RIGHT, run_time=2))",
      "        self.wait()",
      "        self.play(dot.animate.shift(UP))",
      "        self.play(dot.animate.shift(LEFT))",
      "        self.wait()"
    ],
    "topic": "Point tracing path",
    "description": "Animates a dot rotating and moving while leaving a trace of its path."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GraphAreaPlot(Scene):",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 5],",
      "            y_range=[0, 6],",
      "            x_axis_config={\"numbers_to_include\": [2, 3]},",
      "            tips=False,",
      "        )",
      "",
      "        labels = ax.get_axis_labels()",
      "",
      "        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)",
      "        curve_2 = ax.plot(",
      "            lambda x: 0.8 * x ** 2 - 3 * x + 4,",
      "            x_range=[0, 4],",
      "            color=GREEN_B,",
      "        )",
      "",
      "        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)",
      "        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)",
      "",
      "        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)",
      "        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)",
      "",
      "        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)"
    ],
    "topic": "Area under curves",
    "description": "Illustrates two intersecting curves with shaded areas representing Riemann rectangles and bounded regions between vertical lines."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ThreeDSurfacePlot(ThreeDScene):",
      "    def construct(self):",
      "        resolution_fa = 24",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)",
      "",
      "        def param_gauss(u, v):",
      "            x = u",
      "            y = v",
      "            sigma, mu = 0.4, [0.0, 0.0]",
      "            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))",
      "            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))",
      "            return np.array([x, y, z])",
      "",
      "        gauss_plane = Surface(",
      "            param_gauss,",
      "            resolution=(resolution_fa, resolution_fa),",
      "            v_range=[-2, +2],",
      "            u_range=[-2, +2]",
      "        )",
      "",
      "        gauss_plane.scale(2, about_point=ORIGIN)",
      "        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)",
      "        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)",
      "        axes = ThreeDAxes()",
      "        self.add(axes,gauss_plane)"
    ],
    "topic": "3D Gaussian surface",
    "description": "Visualizes a 3D Gaussian surface with a checkerboard pattern on a set of 3D axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class HeatDiagramPlot(Scene):",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 40, 5],",
      "            y_range=[-8, 32, 5],",
      "            x_length=9,",
      "            y_length=6,",
      "            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},",
      "            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},",
      "            tips=False,",
      "        )",
      "        labels = ax.get_axis_labels(",
      "            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")",
      "        )",
      "",
      "        x_vals = [0, 8, 38, 39]",
      "        y_vals = [20, 0, 0, -5]",
      "        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)",
      "",
      "        self.add(ax, labels, graph)"
    ],
    "topic": "2D line graph",
    "description": "Plots a line graph on axes representing heat change versus temperature with labeled axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolygonOnAxes(Scene):",
      "    def get_rectangle_corners(self, bottom_left, top_right):",
      "        return [",
      "            (top_right[0], top_right[1]),",
      "            (bottom_left[0], top_right[1]),",
      "            (bottom_left[0], bottom_left[1]),",
      "            (top_right[0], bottom_left[1]),",
      "        ]",
      "",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 10],",
      "            y_range=[0, 10],",
      "            x_length=6,",
      "            y_length=6,",
      "            axis_config={\"include_tip\": False},",
      "        )",
      "",
      "        t = ValueTracker(5)",
      "        k = 25",
      "",
      "        graph = ax.plot(",
      "            lambda x: k / x,",
      "            color=YELLOW_D,",
      "            x_range=[k / 10, 10.0, 0.01],",
      "            use_smoothing=False,",
      "        )",
      "",
      "        def get_rectangle():",
      "            polygon = Polygon(",
      "                *[",
      "                    ax.c2p(*i)",
      "                    for i in self.get_rectangle_corners(",
      "                        (0, 0), (t.get_value(), k / t.get_value())",
      "                    )",
      "                ]",
      "            )",
      "            polygon.stroke_width = 1",
      "            polygon.set_fill(BLUE, opacity=0.5)",
      "            polygon.set_stroke(YELLOW_B)",
      "            return polygon",
      "",
      "        polygon = always_redraw(get_rectangle)",
      "",
      "        dot = Dot()",
      "        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))",
      "        dot.set_z_index(10)",
      "",
      "        self.add(ax, graph, dot)",
      "        self.play(Create(polygon))",
      "        self.play(t.animate.set_value(10))",
      "        self.play(t.animate.set_value(k / 10))",
      "        self.play(t.animate.set_value(5))"
    ],
    "topic": "Dynamic rectangle on graph",
    "description": "Illustrates a rectangle dynamically changing size on a hyperbolic graph as a dot traces the curve."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ManimCELogo(Scene):",
      "    def construct(self):",
      "        self.camera.background_color = \"#ece6e2\"",
      "        logo_green = \"#87c2a5\"",
      "        logo_blue = \"#525893\"",
      "        logo_red = \"#e07a5f\"",
      "        logo_black = \"#343434\"",
      "        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=logo_black).scale(7)",
      "        ds_m.shift(2.25 * LEFT + 1.5 * UP)",
      "        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)",
      "        square = Square(color=logo_blue, fill_opacity=1).shift(UP)",
      "        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)",
      "        logo = VGroup(triangle, square, circle, ds_m)  # order matters",
      "        logo.move_to(ORIGIN)",
      "        self.add(logo)"
    ],
    "topic": "logo animation",
    "description": "Displays the Manim Community Edition logo with colored geometric shapes and a large letter M."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class OpeningManim(Scene):",
      "    def construct(self):",
      "        title = Tex(r\"This is some \\LaTeX\")",
      "        basel = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")",
      "        VGroup(title, basel).arrange(DOWN)",
      "        self.play(",
      "            Write(title),",
      "            FadeIn(basel, shift=DOWN),",
      "        )",
      "        self.wait()",
      "",
      "        transform_title = Tex(\"That was a transform\")",
      "        transform_title.to_corner(UP + LEFT)",
      "        self.play(",
      "            Transform(title, transform_title),",
      "            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),",
      "        )",
      "        self.wait()",
      "",
      "        grid = NumberPlane()",
      "        grid_title = Tex(\"This is a grid\", font_size=72)",
      "        grid_title.move_to(transform_title)",
      "",
      "        self.add(grid, grid_title)  # Make sure title is on top of grid",
      "        self.play(",
      "            FadeOut(title),",
      "            FadeIn(grid_title, shift=UP),",
      "            Create(grid, run_time=3, lag_ratio=0.1),",
      "        )",
      "        self.wait()",
      "",
      "        grid_transform_title = Tex(",
      "            r\"That was a non-linear function \\\\ applied to the grid\"",
      "        )",
      "        grid_transform_title.move_to(grid_title, UL)",
      "        grid.prepare_for_nonlinear_transform()",
      "        self.play(",
      "            grid.animate.apply_function(",
      "                lambda p: p",
      "                          + np.array(",
      "                    [",
      "                        np.sin(p[1]),",
      "                        np.sin(p[0]),",
      "                        0,",
      "                    ]",
      "                )",
      "            ),",
      "            run_time=3,",
      "        )",
      "        self.wait()",
      "        self.play(Transform(grid_title, grid_transform_title))",
      "        self.wait()"
    ],
    "topic": "LaTeX and grid transformation",
    "description": "Animates LaTeX text and a mathematical equation, followed by a transformation of a grid using a non-linear function."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SinAndCosFunctionPlot(Scene):",
      "    def construct(self):",
      "        axes = Axes(",
      "            x_range=[-10, 10.3, 1],",
      "            y_range=[-1.5, 1.5, 1],",
      "            x_length=10,",
      "            axis_config={\"color\": GREEN},",
      "            x_axis_config={",
      "                \"numbers_to_include\": np.arange(-10, 10.01, 2),",
      "                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),",
      "            },",
      "            tips=False,",
      "        )",
      "        axes_labels = axes.get_axis_labels()",
      "        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)",
      "        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)",
      "",
      "        sin_label = axes.get_graph_label(",
      "            sin_graph, \"\\\\sin(x)\", x_val=-10, direction=UP / 2",
      "        )",
      "        cos_label = axes.get_graph_label(cos_graph, label=\"\\\\cos(x)\")",
      "",
      "        vert_line = axes.get_vertical_line(",
      "            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line",
      "        )",
      "        line_label = axes.get_graph_label(",
      "            cos_graph, r\"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE",
      "        )",
      "",
      "        plot = VGroup(axes, sin_graph, cos_graph, vert_line)",
      "        labels = VGroup(axes_labels, sin_label, cos_label, line_label)",
      "        self.add(plot, labels)"
    ],
    "topic": "Trigonometric function plot",
    "description": "Plots sine and cosine functions on axes with labels and a vertical line at x=2\u03c0."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointMovingOnShapes(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=1, color=BLUE)",
      "        dot = Dot()",
      "        dot2 = dot.copy().shift(RIGHT)",
      "        self.add(dot)",
      "",
      "        line = Line([3, 0, 0], [5, 0, 0])",
      "        self.add(line)",
      "",
      "        self.play(GrowFromCenter(circle))",
      "        self.play(Transform(dot, dot2))",
      "        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)",
      "        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)",
      "        self.wait()"
    ],
    "topic": "point movement on shapes",
    "description": "Animates a dot moving along a circle and rotating around a point on a line."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CapStyleVariants(Scene):",
      "    def construct(self):",
      "        arcs = VGroup(*[",
      "            Arc(",
      "                radius=1,",
      "                start_angle=0,",
      "                angle=TAU / 4,",
      "                stroke_width=20,",
      "                color=GREEN,",
      "                cap_style=cap_style,",
      "            )",
      "            for cap_style in CapStyleType",
      "        ])",
      "        arcs.arrange(RIGHT, buff=1)",
      "        self.add(arcs)",
      "        for arc in arcs:",
      "            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)",
      "            self.add(label)"
    ],
    "topic": "Arc cap styles",
    "description": "Displays arcs with different cap styles arranged horizontally, each labeled with its cap style name."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LineJointVariants(Scene):",
      "    def construct(self):",
      "        mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([",
      "            np.array([-2, 0, 0]),",
      "            np.array([0, 0, 0]),",
      "            np.array([-2, 1, 0]),",
      "        ])",
      "        lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])",
      "        for line, joint_type in zip(lines, LineJointType):",
      "            line.joint_type = joint_type",
      "",
      "        lines.arrange(RIGHT, buff=1)",
      "        self.add(lines)",
      "        for line in lines:",
      "            label = Text(line.joint_type.name).next_to(line, DOWN)",
      "            self.add(label)"
    ],
    "topic": "Line joint types",
    "description": "Displays multiple lines with different joint types, each labeled with its joint type name."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Indications(Scene):",
      "    def construct(self):",
      "        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]",
      "        names = [Tex(i.__name__).scale(3) for i in indications]",
      "",
      "        self.add(names[0])",
      "        for i in range(len(names)):",
      "            if indications[i] is Flash:",
      "                self.play(Flash(UP))",
      "            elif indications[i] is ShowPassingFlash:",
      "                self.play(ShowPassingFlash(Underline(names[i])))",
      "            else:",
      "                self.play(indications[i](names[i]))",
      "            self.play(AnimationGroup(",
      "                FadeOut(names[i], shift=UP*1.5),",
      "                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),",
      "            ))"
    ],
    "topic": "indication animations",
    "description": "Demonstrates various indication effects on text, including wave, circumscribe, flash, focus, indicate, and wiggle, with transitions between each effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Fading(Scene):",
      "    def construct(self):",
      "        tex_in = Tex(\"Fade\", \"In\").scale(3)",
      "        tex_out = Tex(\"Fade\", \"Out\").scale(3)",
      "        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))",
      "        self.play(ReplacementTransform(tex_in, tex_out))",
      "        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))"
    ],
    "topic": "text fading animation",
    "description": "Animates text fading in and out with a transformation between two text states."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Growing(Scene):",
      "    def construct(self):",
      "        square = Square()",
      "        circle = Circle()",
      "        triangle = Triangle()",
      "        arrow = Arrow(LEFT, RIGHT)",
      "        star = Star()",
      "",
      "        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)",
      "        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)",
      "",
      "        self.play(GrowFromPoint(square, ORIGIN))",
      "        self.play(GrowFromCenter(circle))",
      "        self.play(GrowFromEdge(triangle, DOWN))",
      "        self.play(GrowArrow(arrow))",
      "        self.play(SpinInFromNothing(star))"
    ],
    "topic": "Shape growth animation",
    "description": "Animates various geometric shapes growing from different points and directions on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangeDecimalToValueExample(Scene):",
      "    def construct(self):",
      "        number = DecimalNumber(0)",
      "        self.add(number)",
      "        self.play(ChangeDecimalToValue(number, 10, run_time=3))",
      "        self.wait()"
    ],
    "topic": "number animation",
    "description": "Animates a decimal number changing from 0 to 10 over 3 seconds."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangingDecimalExample(Scene):",
      "    def construct(self):",
      "        number = DecimalNumber(0)",
      "        self.add(number)",
      "        self.play(",
      "            ChangingDecimal(",
      "                number,",
      "                lambda a: 5 * a,",
      "                run_time=3",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "changing decimal value",
    "description": "Animates a decimal number increasing from 0 to 5 over 3 seconds."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TracedPathExample(Scene):",
      "    def construct(self):",
      "        circ = Circle(color=RED).shift(4*LEFT)",
      "        dot = Dot(color=RED).move_to(circ.get_start())",
      "        rolling_circle = VGroup(circ, dot)",
      "        trace = TracedPath(circ.get_start)",
      "        rolling_circle.add_updater(lambda m: m.rotate(-0.3))",
      "        self.add(trace, rolling_circle)",
      "        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)"
    ],
    "topic": "traced path animation",
    "description": "Shows a red circle rolling horizontally with its path traced by a dot."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DissipatingPathExample(Scene):",
      "    def construct(self):",
      "        a = Dot(RIGHT * 2)",
      "        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])",
      "        self.add(a, b)",
      "        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))",
      "        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))",
      "        self.wait()"
    ],
    "topic": "traced path animation",
    "description": "Shows a dot moving along a path with a dissipating trace effect as it shifts left."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnimatedBoundaryExample(Scene):",
      "    def construct(self):",
      "        text = Text(\"So shiny!\")",
      "        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],",
      "                                    cycle_rate=3)",
      "        self.add(text, boundary)",
      "        self.wait(2)"
    ],
    "topic": "text with animated boundary",
    "description": "Displays text with a multicolored animated boundary cycling through red, green, and blue."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LagRatios(Scene):",
      "    def construct(self):",
      "        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios",
      "",
      "        # Create dot groups",
      "        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()",
      "        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)",
      "        self.add(groups)",
      "",
      "        # Label groups",
      "        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))",
      "        for group, ratio in zip(groups, ratios):",
      "            self.add(Text(str(ratio), font_size=36).next_to(group, UP))",
      "",
      "        #Animate groups with different lag_ratios",
      "        self.play(AnimationGroup(*[",
      "            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)",
      "            for group, ratio in zip(groups, ratios)",
      "        ]))",
      "",
      "        # lag_ratio also works recursively on nested submobjects:",
      "        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
    ],
    "topic": "lag ratio demonstration",
    "description": "Illustrates the effect of different lag_ratios on the sequential movement of dot groups."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangeDefaultAnimation(Scene):",
      "    def construct(self):",
      "        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)",
      "        Indicate.set_default(color=None)",
      "",
      "        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)",
      "        self.add(S)",
      "        self.play(Rotate(S, PI))",
      "        self.play(Indicate(S))",
      "",
      "        Rotate.set_default()",
      "        Indicate.set_default()"
    ],
    "topic": "square rotation",
    "description": "Animates a blue square rotating 180 degrees and then being indicated with default settings."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DefaultAddScene(Scene):",
      "    def construct(self):",
      "        text_1 = Text(\"I was added with Add!\")",
      "        text_2 = Text(\"Me too!\")",
      "        text_3 = Text(\"And me!\")",
      "        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)",
      "        rect = SurroundingRectangle(texts, buff=0.5)",
      "",
      "        self.play(",
      "            Create(rect, run_time=3.0),",
      "            Succession(",
      "                Wait(1.0),",
      "                # You can Add a Mobject in the middle of an animation...",
      "                Add(text_1),",
      "                Wait(1.0),",
      "                # ...or multiple Mobjects at once!",
      "                Add(text_2, text_3),",
      "            ),",
      "        )",
      "        self.wait()"
    ],
    "topic": "text and rectangle animation",
    "description": "Animates a rectangle being drawn around text, with text elements appearing sequentially using the Add effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AddWithRunTimeScene(Scene):",
      "    def construct(self):",
      "        # A 5x5 grid of circles",
      "        circles = VGroup(",
      "            *[Circle(radius=0.5) for _ in range(25)]",
      "        ).arrange_in_grid(5, 5)",
      "",
      "        self.play(",
      "            Succession(",
      "                # Add a run_time of 0.2 to wait for 0.2 seconds after",
      "                # adding the circle, instead of using Wait(0.2) after Add!",
      "                *[Add(circle, run_time=0.2) for circle in circles],",
      "                rate_func=smooth,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "grid animation",
    "description": "Sequentially adds circles in a 5x5 grid with a smooth transition and short delay between each addition."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BlinkingExample(Scene):",
      "    def construct(self):",
      "        text = Text(\"Blinking\").scale(1.5)",
      "        self.add(text)",
      "        self.play(Blink(text, blinks=3))"
    ],
    "topic": "text animation",
    "description": "Displays the word 'Blinking' with a blinking effect occurring three times."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsingIndicate(Scene):",
      "    def construct(self):",
      "        tex = Tex(\"Indicate\").scale(3)",
      "        self.play(Indicate(tex))",
      "        self.wait()"
    ],
    "topic": "text indication",
    "description": "Highlights the word 'Indicate' by briefly enlarging it on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsingFocusOn(Scene):",
      "    def construct(self):",
      "        dot = Dot(color=YELLOW).shift(DOWN)",
      "        self.add(Tex(\"Focusing on the dot below:\"), dot)",
      "        self.play(FocusOn(dot))",
      "        self.wait()"
    ],
    "topic": "focus effect",
    "description": "Highlights a yellow dot by focusing the viewer's attention on it after displaying introductory text."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsingCircumscribe(Scene):",
      "    def construct(self):",
      "        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)",
      "        self.add(lbl)",
      "        self.play(Circumscribe(lbl))",
      "        self.play(Circumscribe(lbl, Circle))",
      "        self.play(Circumscribe(lbl, fade_out=True))",
      "        self.play(Circumscribe(lbl, time_width=2))",
      "        self.play(Circumscribe(lbl, Circle, True))"
    ],
    "topic": "text circumscription",
    "description": "Demonstrates various circumscription effects around a text label using different styles and parameters."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ApplyingWaves(Scene):",
      "    def construct(self):",
      "        tex = Tex(\"Wiggle\").scale(3)",
      "        self.play(Wiggle(tex))",
      "        self.wait()"
    ],
    "topic": "text wiggle animation",
    "description": "Displays the word 'Wiggle' scaling up and animated with a wiggling effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TimeWidthValues(Scene):",
      "    def construct(self):",
      "        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)",
      "        lbl = VMobject()",
      "        self.add(p, lbl)",
      "        p = p.copy().set_color(BLUE)",
      "        for time_width in [0.2, 0.5, 1, 2]:",
      "            lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))",
      "            self.play(ShowPassingFlash(",
      "                p.copy().set_color(BLUE),",
      "                run_time=2,",
      "                time_width=time_width",
      "            ))"
    ],
    "topic": "Polygon flashing effect",
    "description": "Demonstrates a pentagon flashing with varying time widths, updating a label to show the current time width value."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FlashOnCircle(Scene):",
      "    def construct(self):",
      "        radius = 2",
      "        circle = Circle(radius)",
      "        self.add(circle)",
      "        self.play(Flash(",
      "            circle, line_length=1,",
      "            num_lines=30, color=RED,",
      "            flash_radius=radius+SMALL_BUFF,",
      "            time_width=0.3, run_time=2,",
      "            rate_func = rush_from",
      "        ))"
    ],
    "topic": "circle flash effect",
    "description": "Displays a red flash effect emanating from a circle with multiple lines."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsingFlash(Scene):",
      "    def construct(self):",
      "        dot = Dot(color=YELLOW).shift(DOWN)",
      "        self.add(Tex(\"Flash the dot below:\"), dot)",
      "        self.play(Flash(dot))",
      "        self.wait()"
    ],
    "topic": "flash animation",
    "description": "Highlights a yellow dot with a flash effect after displaying a text prompt."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ApplyingWaves(Scene):",
      "    def construct(self):",
      "        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)",
      "        self.play(ApplyWave(tex))",
      "        self.play(ApplyWave(",
      "            tex,",
      "            direction=RIGHT,",
      "            time_width=0.5,",
      "            amplitude=0.3",
      "        ))",
      "        self.play(ApplyWave(",
      "            tex,",
      "            rate_func=linear,",
      "            ripples=4",
      "        ))"
    ],
    "topic": "text wave animation",
    "description": "Applies wave-like transformations to text with varying directions, amplitudes, and ripple effects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BroadcastExample(Scene):",
      "    def construct(self):",
      "        mob = Circle(radius=4, color=TEAL_A)",
      "        self.play(Broadcast(mob))"
    ],
    "topic": "broadcast animation",
    "description": "Animates a teal circle with a broadcast effect expanding outward."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LaggedStartExample(Scene):",
      "    def construct(self):",
      "        title = Text(\"lag_ratio = 0.25\").to_edge(UP)",
      "",
      "        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)",
      "        dot2 = Dot(point=LEFT * 2, radius=0.16)",
      "        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)",
      "        line_25 = DashedLine(",
      "            start=LEFT + UP * 2,",
      "            end=LEFT + DOWN * 2,",
      "            color=RED",
      "        )",
      "        label = Text(\"25%\", font_size=24).next_to(line_25, UP)",
      "        self.add(title, dot1, dot2, dot3, line_25, label)",
      "",
      "        self.play(LaggedStart(",
      "            dot1.animate.shift(RIGHT * 4),",
      "            dot2.animate.shift(RIGHT * 4),",
      "            dot3.animate.shift(RIGHT * 4),",
      "            lag_ratio=0.25,",
      "            run_time=4",
      "        ))"
    ],
    "topic": "lagged motion animation",
    "description": "Demonstrates three dots moving horizontally with a staggered start using a lag ratio of 0.25."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LaggedStartMapExample(Scene):",
      "    def construct(self):",
      "        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)",
      "        dots = VGroup(",
      "            *[Dot(radius=0.16) for _ in range(35)]",
      "            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)",
      "        self.add(dots, title)",
      "",
      "        # Animate yellow ripple effect",
      "        for mob in dots, title:",
      "            self.play(LaggedStartMap(",
      "                ApplyMethod, mob,",
      "                lambda m : (m.set_color, YELLOW),",
      "                lag_ratio = 0.1,",
      "                rate_func = there_and_back,",
      "                run_time = 2",
      "            ))"
    ],
    "topic": "ripple effect animation",
    "description": "Demonstrates a yellow ripple effect applied to a grid of dots and a title using LaggedStartMap."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SuccessionExample(Scene):",
      "    def construct(self):",
      "        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)",
      "        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)",
      "        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)",
      "        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)",
      "        self.add(dot1, dot2, dot3, dot4)",
      "",
      "        self.play(Succession(",
      "            dot1.animate.move_to(dot2),",
      "            dot2.animate.move_to(dot3),",
      "            dot3.animate.move_to(dot4),",
      "            dot4.animate.move_to(dot1)",
      "        ))"
    ],
    "topic": "Dot movement sequence",
    "description": "Animates four dots moving in a succession pattern, each moving to the position of the next dot in sequence."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FadeInExample(Scene):",
      "    def construct(self):",
      "        dot = Dot(UP * 2 + LEFT)",
      "        self.add(dot)",
      "        tex = Tex(",
      "            \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"",
      "        ).scale(1)",
      "        animations = [",
      "            FadeIn(tex[0]),",
      "            FadeIn(tex[1], shift=DOWN),",
      "            FadeIn(tex[2], target_position=dot),",
      "            FadeIn(tex[3], scale=1.5),",
      "        ]",
      "        self.play(AnimationGroup(*animations, lag_ratio=0.5))"
    ],
    "topic": "text fade-in effects",
    "description": "Demonstrates different FadeIn effects on text with variations in shift, target position, and scale."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FadeInExample(Scene):",
      "    def construct(self):",
      "        dot = Dot(UP * 2 + LEFT)",
      "        self.add(dot)",
      "        tex = Tex(",
      "            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"",
      "        ).scale(1)",
      "        animations = [",
      "            FadeOut(tex[0]),",
      "            FadeOut(tex[1], shift=DOWN),",
      "            FadeOut(tex[2], target_position=dot),",
      "            FadeOut(tex[3], scale=0.5),",
      "        ]",
      "        self.play(AnimationGroup(*animations, lag_ratio=0.5))"
    ],
    "topic": "text fade out",
    "description": "Demonstrates various FadeOut effects on text with different transformations including shift, target position, and scale."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShowDrawBorderThenFill(Scene):",
      "    def construct(self):",
      "        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))"
    ],
    "topic": "shape animation",
    "description": "Animates a square being drawn with its border first and then filled with orange color."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShowWrite(Scene):",
      "    def construct(self):",
      "        self.play(Write(Text(\"Hello\", font_size=144)))"
    ],
    "topic": "text animation",
    "description": "Animates the word 'Hello' appearing on screen using the Write effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShowWriteReversed(Scene):",
      "    def construct(self):",
      "        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))"
    ],
    "topic": "text animation",
    "description": "Animates the text 'Hello' appearing in reverse order using the Write effect."
  },
  {
    "code": [
      ">>> from manim import Write, Text",
      ">>> Write(Text(''))",
      "Write(Text(''))"
    ],
    "topic": "empty text animation",
    "description": "Animates an empty text object using the Write effect, resulting in no visible change."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShowIncreasingSubsetsScene(Scene):",
      "    def construct(self):",
      "        p = VGroup(Dot(), Square(), Triangle())",
      "        self.add(p)",
      "        self.play(ShowIncreasingSubsets(p))",
      "        self.wait()"
    ],
    "topic": "increasing subsets animation",
    "description": "Displays a sequence of shapes (dot, square, triangle) appearing one by one in an increasing order."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UnwriteReverseFalse(Scene):",
      "    def construct(self):",
      "        text = Tex(\"Alice and Bob\").scale(3)",
      "        self.add(text)",
      "        self.play(Unwrite(text, reverse=False))"
    ],
    "topic": "text animation",
    "description": "Displays 'Alice and Bob' text being erased with the Unwrite effect without reversing the order."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UnwriteReverseTrue(Scene):",
      "    def construct(self):",
      "        text = Tex(\"Alice and Bob\").scale(3)",
      "        self.add(text)",
      "        self.play(Unwrite(text))"
    ],
    "topic": "text animation",
    "description": "Animates the text 'Alice and Bob' being removed from the screen with the Unwrite effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShowUncreate(Scene):",
      "    def construct(self):",
      "        self.play(Uncreate(Square()))"
    ],
    "topic": "shape disappearance",
    "description": "Animates the disappearance of a square using the Uncreate effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpiralInExample(Scene):",
      "    def construct(self):",
      "        pi = MathTex(r\"\\pi\").scale(7)",
      "        pi.shift(2.25 * LEFT + 1.5 * UP)",
      "        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)",
      "        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)",
      "        shapes = VGroup(pi, circle, square)",
      "        self.play(SpiralIn(shapes))"
    ],
    "topic": "spiral animation",
    "description": "Animates a pi symbol, circle, and square spiraling into view simultaneously."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DeletingTextExample(Scene):",
      "    def construct(self):",
      "        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)",
      "        cursor = Rectangle(",
      "            color = GREY_A,",
      "            fill_color = GREY_A,",
      "            fill_opacity = 1.0,",
      "            height = 1.1,",
      "            width = 0.5,",
      "        ).move_to(text[0]) # Position the cursor",
      "",
      "        self.play(UntypeWithCursor(text, cursor))",
      "        self.play(Blink(cursor, blinks=2))"
    ],
    "topic": "text deletion animation",
    "description": "Simulates the deletion of the word 'Deleting' with a cursor effect and blinking animation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class InsertingTextExample(Scene):",
      "    def construct(self):",
      "        text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)",
      "        cursor = Rectangle(",
      "            color = GREY_A,",
      "            fill_color = GREY_A,",
      "            fill_opacity = 1.0,",
      "            height = 1.1,",
      "            width = 0.5,",
      "        ).move_to(text[0]) # Position the cursor",
      "",
      "        self.play(TypeWithCursor(text, cursor))",
      "        self.play(Blink(cursor, blinks=2))"
    ],
    "topic": "text insertion animation",
    "description": "Simulates typing the word 'Inserting' with a blinking cursor effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CreateScene(Scene):",
      "    def construct(self):",
      "        self.play(Create(Square()))"
    ],
    "topic": "basic shape creation",
    "description": "Animates the creation of a square using the Create effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class HomotopyExample(Scene):",
      "    def construct(self):",
      "        square = Square()",
      "",
      "        def homotopy(x, y, z, t):",
      "            if t <= 0.25:",
      "                progress = t / 0.25",
      "                return (x, y + progress * 0.2 * np.sin(x), z)",
      "            else:",
      "                wave_progress = (t - 0.25) / 0.75",
      "                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)",
      "",
      "        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))"
    ],
    "topic": "square wave transformation",
    "description": "Animates a square undergoing a vertical wave-like transformation over time."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MoveAlongPathExample(Scene):",
      "    def construct(self):",
      "        d1 = Dot().set_color(ORANGE)",
      "        l1 = Line(LEFT, RIGHT)",
      "        l2 = VMobject()",
      "        self.add(d1, l1, l2)",
      "        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))",
      "        self.play(MoveAlongPath(d1, l1), rate_func=linear)"
    ],
    "topic": "dot moving on line",
    "description": "Animates a dot moving linearly along a horizontal line while a connecting line updates to follow the dot's position."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GrowArrowExample(Scene):",
      "    def construct(self):",
      "        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]",
      "        VGroup(*arrows).set_x(0).arrange(buff=2)",
      "        self.play(GrowArrow(arrows[0]))",
      "        self.play(GrowArrow(arrows[1], point_color=RED))"
    ],
    "topic": "arrow growth animation",
    "description": "Animates two arrows growing from their starting points, with the second arrow changing color to red as it grows."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GrowFromCenterExample(Scene):",
      "    def construct(self):",
      "        squares = [Square() for _ in range(2)]",
      "        VGroup(*squares).set_x(0).arrange(buff=2)",
      "        self.play(GrowFromCenter(squares[0]))",
      "        self.play(GrowFromCenter(squares[1], point_color=RED))"
    ],
    "topic": "shape growth animation",
    "description": "Animates two squares growing from their centers, with the second square's growth highlighted in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GrowFromEdgeExample(Scene):",
      "    def construct(self):",
      "        squares = [Square() for _ in range(4)]",
      "        VGroup(*squares).set_x(0).arrange(buff=1)",
      "        self.play(GrowFromEdge(squares[0], DOWN))",
      "        self.play(GrowFromEdge(squares[1], RIGHT))",
      "        self.play(GrowFromEdge(squares[2], UR))",
      "        self.play(GrowFromEdge(squares[3], UP, point_color=RED))"
    ],
    "topic": "square growth animation",
    "description": "Animates four squares growing from different edges with one changing color to red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GrowFromPointExample(Scene):",
      "    def construct(self):",
      "        dot = Dot(3 * UR, color=GREEN)",
      "        squares = [Square() for _ in range(4)]",
      "        VGroup(*squares).set_x(0).arrange(buff=1)",
      "        self.add(dot)",
      "        self.play(GrowFromPoint(squares[0], ORIGIN))",
      "        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))",
      "        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))",
      "        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))"
    ],
    "topic": "Shape growth animation",
    "description": "Animates four squares growing from different points, including the origin, a specified coordinate, and a green dot."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpinInFromNothingExample(Scene):",
      "    def construct(self):",
      "        squares = [Square() for _ in range(3)]",
      "        VGroup(*squares).set_x(0).arrange(buff=2)",
      "        self.play(SpinInFromNothing(squares[0]))",
      "        self.play(SpinInFromNothing(squares[1], angle=2 * PI))",
      "        self.play(SpinInFromNothing(squares[2], point_color=RED))"
    ],
    "topic": "spinning squares animation",
    "description": "Animates three squares spinning into view from nothing with varying angles and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShiftingSquare(Scene):",
      "    def construct(self):",
      "        sq = Square().set_fill(opacity=1)",
      "        tri = Triangle()",
      "        VGroup(sq, tri).arrange(LEFT)",
      "",
      "        # construct a square which is continuously",
      "        # shifted to the right",
      "        always_shift(sq, RIGHT, rate=5)",
      "",
      "        self.add(sq)",
      "        self.play(tri.animate.set_fill(opacity=1))"
    ],
    "topic": "shifting square animation",
    "description": "Displays a square continuously shifting to the right while a triangle appears with full opacity."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpinningTriangle(Scene):",
      "    def construct(self):",
      "        tri = Triangle().set_fill(opacity=1).set_z_index(2)",
      "        sq = Square().to_edge(LEFT)",
      "",
      "        # will keep spinning while there is an animation going on",
      "        always_rotate(tri, rate=2*PI, about_point=ORIGIN)",
      "",
      "        self.add(tri, sq)",
      "        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)"
    ],
    "topic": "rotating triangle",
    "description": "Displays a triangle continuously spinning while a square moves from left to right across the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TangentAnimation(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        sine = ax.plot(np.sin, color=RED)",
      "        alpha = ValueTracker(0)",
      "        point = always_redraw(",
      "            lambda: Dot(",
      "                sine.point_from_proportion(alpha.get_value()),",
      "                color=BLUE",
      "            )",
      "        )",
      "        tangent = always_redraw(",
      "            lambda: TangentLine(",
      "                sine,",
      "                alpha=alpha.get_value(),",
      "                color=YELLOW,",
      "                length=4",
      "            )",
      "        )",
      "        self.add(ax, sine, point, tangent)",
      "        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)"
    ],
    "topic": "Tangent line animation",
    "description": "Illustrates a tangent line moving along a sine curve with a tracking point."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class WelcomeToManim(Scene):",
      "    def construct(self):",
      "        words = Text(\"Welcome to\")",
      "        banner = ManimBanner().scale(0.5)",
      "        VGroup(words, banner).arrange(DOWN)",
      "",
      "        turn_animation_into_updater(Write(words, run_time=0.9))",
      "        self.add(words)",
      "        self.wait(0.5)",
      "        self.play(banner.expand(), run_time=0.5)"
    ],
    "topic": "introductory text animation",
    "description": "Displays 'Welcome to' text followed by an expanding Manim banner animation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Anagram(Scene):",
      "    def construct(self):",
      "        src = Text(\"the morse code\")",
      "        tar = Text(\"here come dots\")",
      "        self.play(Write(src))",
      "        self.wait(0.5)",
      "        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))",
      "        self.wait(0.5)"
    ],
    "topic": "text transformation",
    "description": "Animates the transformation of the text 'the morse code' into 'here come dots' using a shape-matching effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MatchingEquationParts(Scene):",
      "    def construct(self):",
      "        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)",
      "",
      "        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")",
      "        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")",
      "        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")",
      "",
      "        self.add(eq1)",
      "        self.wait(0.5)",
      "        self.play(TransformMatchingTex(Group(eq1, variables), eq2))",
      "        self.wait(0.5)",
      "        self.play(TransformMatchingTex(eq2, eq3))",
      "        self.wait(0.5)"
    ],
    "topic": "Equation transformation",
    "description": "Transforms an equation step-by-step to show the relationship between variables in a Pythagorean identity."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpeedModifierUpdaterExample(Scene):",
      "    def construct(self):",
      "        a = Dot().shift(LEFT * 4)",
      "        self.add(a)",
      "",
      "        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))",
      "        self.play(",
      "            ChangeSpeed(",
      "                Wait(2),",
      "                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},",
      "                affects_speed_updaters=True,",
      "            )",
      "        )"
    ],
    "topic": "dot movement animation",
    "description": "Animates a dot moving from left to right with variable speed using a speed modifier."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpeedModifierExample(Scene):",
      "    def construct(self):",
      "        a = Dot().shift(LEFT * 4)",
      "        b = Dot().shift(RIGHT * 4)",
      "        self.add(a, b)",
      "        self.play(",
      "            ChangeSpeed(",
      "                AnimationGroup(",
      "                    a.animate(run_time=1).shift(RIGHT * 8),",
      "                    b.animate(run_time=1).shift(LEFT * 8),",
      "                ),",
      "                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},",
      "                rate_func=linear,",
      "            )",
      "        )"
    ],
    "topic": "dot movement animation",
    "description": "Animates two dots moving towards each other with varying speeds controlled by a speed modifier."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpeedModifierUpdaterExample2(Scene):",
      "    def construct(self):",
      "        a = Dot().shift(LEFT * 4)",
      "        self.add(a)",
      "",
      "        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))",
      "        self.wait()",
      "        self.play(",
      "            ChangeSpeed(",
      "                Wait(),",
      "                speedinfo={1: 0},",
      "                affects_speed_updaters=True,",
      "            )",
      "        )"
    ],
    "topic": "dot motion control",
    "description": "Animates a dot moving right with speed modulation using an updater and ChangeSpeed."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsingRotate(Scene):",
      "    def construct(self):",
      "        self.play(",
      "            Rotate(",
      "                Square(side_length=0.5).shift(UP * 2),",
      "                angle=2*PI,",
      "                about_point=ORIGIN,",
      "                rate_func=linear,",
      "            ),",
      "            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),",
      "            )"
    ],
    "topic": "rotating squares",
    "description": "Animates two squares rotating 360 degrees, one above the origin and the other at the origin."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RotatingDifferentAxis(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        cube = Cube()",
      "        arrow2d = Arrow(start=[0, -1.2, 1], end=[0, 1.2, 1], color=YELLOW_E)",
      "        cube_group = VGroup(cube,arrow2d)",
      "        self.set_camera_orientation(gamma=0, phi=40*DEGREES, theta=40*DEGREES)",
      "        self.add(axes, cube_group)",
      "        play_kw = {\"run_time\": 1.5}",
      "        self.play(Rotating(cube_group, PI), **play_kw)",
      "        self.play(Rotating(cube_group, PI, axis=UP), **play_kw)",
      "        self.play(Rotating(cube_group, 180*DEGREES, axis=RIGHT), **play_kw)",
      "        self.wait(0.5)"
    ],
    "topic": "3D cube rotation",
    "description": "Shows a cube with an attached arrow rotating around different axes in a 3D space."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RotatingDemo(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=1, color=BLUE)",
      "        line = Line(start=ORIGIN, end=RIGHT)",
      "        arrow = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)",
      "        vg = VGroup(circle,line,arrow)",
      "        self.add(vg)",
      "        anim_kw = {\"about_point\": arrow.get_start(), \"run_time\": 1}",
      "        self.play(Rotating(arrow, 180*DEGREES, **anim_kw))",
      "        self.play(Rotating(arrow, PI, **anim_kw))",
      "        self.play(Rotating(vg, PI, about_point=RIGHT))",
      "        self.play(Rotating(vg, PI, axis=UP, about_point=ORIGIN))",
      "        self.play(Rotating(vg, PI, axis=RIGHT, about_edge=UP))",
      "        self.play(vg.animate.move_to(ORIGIN))"
    ],
    "topic": "rotating shapes",
    "description": "Demonstrates various rotations of a circle, line, and arrow group around different points and axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ScaleInPlaceExample(Scene):",
      "    def construct(self):",
      "        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))"
    ],
    "topic": "text scaling",
    "description": "Animates the scaling of the text 'Hello World!' in place by a factor of 2."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShrinkToCenterExample(Scene):",
      "    def construct(self):",
      "        self.play(ShrinkToCenter(Text(\"Hello World!\")))"
    ],
    "topic": "text shrink animation",
    "description": "Animates the text 'Hello World!' shrinking to the center of the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class WarpSquare(Scene):",
      "    def construct(self):",
      "        square = Square()",
      "        self.play(",
      "            ApplyPointwiseFunction(",
      "                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "complex transformation",
    "description": "Animates a square being warped by a complex exponential transformation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ReplacementTransformOrTransform(Scene):",
      "    def construct(self):",
      "        # set up the numbers",
      "        r_transform = VGroup(*[Integer(i) for i in range(1,4)])",
      "        text_1 = Text(\"ReplacementTransform\", color=RED)",
      "        r_transform.add(text_1)",
      "",
      "        transform = VGroup(*[Integer(i) for i in range(4,7)])",
      "        text_2 = Text(\"Transform\", color=BLUE)",
      "        transform.add(text_2)",
      "",
      "        ints = VGroup(r_transform, transform)",
      "        texts = VGroup(text_1, text_2).scale(0.75)",
      "        r_transform.arrange(direction=UP, buff=1)",
      "        transform.arrange(direction=UP, buff=1)",
      "",
      "        ints.arrange(buff=2)",
      "        self.add(ints, texts)",
      "",
      "        # The mobs replace each other and none are left behind",
      "        self.play(ReplacementTransform(r_transform[0], r_transform[1]))",
      "        self.play(ReplacementTransform(r_transform[1], r_transform[2]))",
      "",
      "        # The mobs linger after the Transform()",
      "        self.play(Transform(transform[0], transform[1]))",
      "        self.play(Transform(transform[1], transform[2]))",
      "        self.wait()"
    ],
    "topic": "number transformation",
    "description": "Demonstrates the difference between ReplacementTransform and Transform using sequences of numbers and text labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CyclicReplaceExample(Scene):",
      "    def construct(self):",
      "        group = VGroup(Square(), Circle(), Triangle(), Star())",
      "        group.arrange(RIGHT)",
      "        self.add(group)",
      "",
      "        for _ in range(4):",
      "            self.play(CyclicReplace(*group))"
    ],
    "topic": "shape replacement",
    "description": "Animates a cyclic replacement of four geometric shapes arranged in a row."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FadeTransformSubmobjects(Scene):",
      "    def construct(self):",
      "        src = VGroup(Square(), Circle().shift(LEFT + UP))",
      "        src.shift(3*LEFT + 2*UP)",
      "        src_copy = src.copy().shift(4*DOWN)",
      "",
      "        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))",
      "        target.shift(3*RIGHT + 2*UP)",
      "        target_copy = target.copy().shift(4*DOWN)",
      "",
      "        self.play(FadeIn(src), FadeIn(src_copy))",
      "        self.play(",
      "            FadeTransform(src, target),",
      "            FadeTransformPieces(src_copy, target_copy)",
      "        )",
      "        self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
    ],
    "topic": "shape transformation",
    "description": "Animates the transformation of a square and circle into a circle and triangle, with submobjects fading and transforming."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DifferentFadeTransforms(Scene):",
      "    def construct(self):",
      "        starts = [Rectangle(width=4, height=1) for _ in range(3)]",
      "        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)",
      "        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]",
      "        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)",
      "",
      "        self.play(*[FadeIn(s) for s in starts])",
      "        self.play(",
      "            FadeTransform(starts[0], targets[0], stretch=True),",
      "            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),",
      "            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)",
      "        )",
      "",
      "        self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
    ],
    "topic": "shape transformation",
    "description": "Animates rectangles fading into circles with different transformation effects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MoveToTargetExample(Scene):",
      "    def construct(self):",
      "        c = Circle()",
      "",
      "        c.generate_target()",
      "        c.target.set_fill(color=GREEN, opacity=0.5)",
      "        c.target.shift(2*RIGHT + UP).scale(0.5)",
      "",
      "        self.add(c)",
      "        self.play(MoveToTarget(c))"
    ],
    "topic": "shape transformation",
    "description": "Animates a circle changing color, opacity, position, and size to its target state."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FadeToColorExample(Scene):",
      "    def construct(self):",
      "        self.play(FadeToColor(Text(\"Hello World!\"), color=RED))"
    ],
    "topic": "text color change",
    "description": "Animates the text 'Hello World!' changing its color to red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ClockwiseExample(Scene):",
      "    def construct(self):",
      "        dl, dr = Dot(), Dot()",
      "        sl, sr = Square(), Square()",
      "",
      "        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)",
      "        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)",
      "",
      "        self.add(dl, dr)",
      "        self.wait()",
      "        self.play(",
      "            ClockwiseTransform(dl, sl),",
      "            Transform(dr, sr)",
      "        )",
      "        self.wait()"
    ],
    "topic": "shape transformation",
    "description": "Animates a dot transforming into a square using clockwise motion on the left and a direct transformation on the right."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CounterclockwiseTransform_vs_Transform(Scene):",
      "    def construct(self):",
      "        # set up the numbers",
      "        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))",
      "        text_1 = Text(\"CounterclockwiseTransform\", color=RED)",
      "        c_transform.add(text_1)",
      "",
      "        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))",
      "        text_2 = Text(\"Transform\", color=BLUE)",
      "        transform.add(text_2)",
      "",
      "        ints = VGroup(c_transform, transform)",
      "        texts = VGroup(text_1, text_2).scale(0.75)",
      "        c_transform.arrange(direction=UP, buff=1)",
      "        transform.arrange(direction=UP, buff=1)",
      "",
      "        ints.arrange(buff=2)",
      "        self.add(ints, texts)",
      "",
      "        # The mobs move in clockwise direction for ClockwiseTransform()",
      "        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))",
      "",
      "        # The mobs move straight up for Transform()",
      "        self.play(Transform(transform[0], transform[1]))"
    ],
    "topic": "number transformation",
    "description": "Demonstrates the difference between CounterclockwiseTransform and Transform using decimal numbers and text labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RestoreExample(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        s.save_state()",
      "        self.play(FadeIn(s))",
      "        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))",
      "        self.play(s.animate.shift(5*DOWN).rotate(PI/4))",
      "        self.wait()",
      "        self.play(Restore(s), run_time=2)"
    ],
    "topic": "square transformation",
    "description": "Animates a square changing color, opacity, position, and size before restoring to its original state."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TransformPathArc(Scene):",
      "    def construct(self):",
      "        def make_arc_path(start, end, arc_angle):",
      "            points = []",
      "            p_fn = path_along_arc(arc_angle)",
      "            # alpha animates between 0.0 and 1.0, where 0.0",
      "            # is the beginning of the animation and 1.0 is the end.",
      "            for alpha in range(0, 11):",
      "                points.append(p_fn(start, end, alpha / 10.0))",
      "            path = VMobject(stroke_color=YELLOW)",
      "            path.set_points_smoothly(points)",
      "            return path",
      "",
      "        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)",
      "        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]",
      "        # Positive angles move counter-clockwise, negative angles move clockwise.",
      "        examples = [-90, 0, 30, 90, 180, 270]",
      "        anims = []",
      "        for idx, angle in enumerate(examples):",
      "            left_c = left.copy().shift((3 - idx) * UP)",
      "            left_c.fill_color = colors[idx]",
      "            right_c = left_c.copy().shift(4 * RIGHT)",
      "            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),",
      "                                     arc_angle=angle * DEGREES)",
      "            desc = Text('%d\u00b0' % examples[idx]).next_to(left_c, LEFT)",
      "            # Make the circles in front of the text in front of the arcs.",
      "            self.add(",
      "                path_arc.set_z_index(1),",
      "                desc.set_z_index(2),",
      "                left_c.set_z_index(3),",
      "            )",
      "            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))",
      "",
      "        self.play(*anims, run_time=2)",
      "        self.wait()"
    ],
    "topic": "Arc path transformation",
    "description": "Demonstrates circles transforming along various arc paths with different angles, showing the effect of path arc transformations."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ApplyMatrixExample(Scene):",
      "    def construct(self):",
      "        matrix = [[1, 1], [0, 2/3]]",
      "        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))"
    ],
    "topic": "matrix transformation",
    "description": "Applies a 2x2 matrix transformation to both text and a number plane."
  },
  {
    "code": [
      ">>> import numpy as np",
      ">>> from manim import is_closed",
      ">>> is_closed(",
      "...     np.array(",
      "...         [",
      "...             [0, 0, 0],",
      "...             [1, 2, 3],",
      "...             [3, 2, 1],",
      "...             [0, 0, 0],",
      "...         ]",
      "...     )",
      "... )",
      "True",
      ">>> is_closed(",
      "...     np.array(",
      "...         [",
      "...             [0, 0, 0],",
      "...             [1, 2, 3],",
      "...             [3, 2, 1],",
      "...             [1e-10, 1e-10, 1e-10],",
      "...         ]",
      "...     )",
      "... )",
      "True",
      ">>> is_closed(",
      "...     np.array(",
      "...         [",
      "...             [0, 0, 0],",
      "...             [1, 2, 3],",
      "...             [3, 2, 1],",
      "...             [1e-2, 1e-2, 1e-2],",
      "...         ]",
      "...     )",
      "... )",
      "False"
    ],
    "topic": "3D path closure check",
    "description": "Determines if a series of 3D points forms a closed path by checking if the first and last points are sufficiently close."
  },
  {
    "code": [
      ">>> from manim import Square, get_winding_number",
      ">>> polygon = Square()",
      ">>> get_winding_number(polygon.get_vertices())",
      "np.float64(1.0)",
      ">>> polygon.shift(2 * UP)",
      "Square",
      ">>> get_winding_number(polygon.get_vertices())",
      "np.float64(0.0)"
    ],
    "topic": "winding number calculation",
    "description": "Demonstrates the change in winding number of a square as it is shifted vertically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RateFunctions1Example(Scene):",
      "    def construct(self):",
      "        line1 = Line(3*LEFT, 3*RIGHT).shift(UP).set_color(RED)",
      "        line2 = Line(3*LEFT, 3*RIGHT).set_color(GREEN)",
      "        line3 = Line(3*LEFT, 3*RIGHT).shift(DOWN).set_color(BLUE)",
      "",
      "        dot1 = Dot().move_to(line1.get_left())",
      "        dot2 = Dot().move_to(line2.get_left())",
      "        dot3 = Dot().move_to(line3.get_left())",
      "",
      "        label1 = Tex(\"Ease In\").next_to(line1, RIGHT)",
      "        label2 = Tex(\"Ease out\").next_to(line2, RIGHT)",
      "        label3 = Tex(\"Ease In Out\").next_to(line3, RIGHT)",
      "",
      "        self.play(",
      "            FadeIn(VGroup(line1, line2, line3)),",
      "            FadeIn(VGroup(dot1, dot2, dot3)),",
      "            Write(VGroup(label1, label2, label3)),",
      "        )",
      "        self.play(",
      "            MoveAlongPath(dot1, line1, rate_func=rate_functions.ease_in_sine),",
      "            MoveAlongPath(dot2, line2, rate_func=rate_functions.ease_out_sine),",
      "            MoveAlongPath(dot3, line3, rate_func=rate_functions.ease_in_out_sine),",
      "            run_time=7",
      "        )",
      "        self.wait()"
    ],
    "topic": "Rate function comparison",
    "description": "Demonstrates three dots moving along lines with different easing functions: ease in, ease out, and ease in out, each labeled accordingly."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RateFuncExample(Scene):",
      "    def construct(self):",
      "        x = VGroup()",
      "        for k, v in rate_functions.__dict__.items():",
      "            if \"function\" in str(v):",
      "                if (",
      "                    not k.startswith(\"__\")",
      "                    and not k.startswith(\"sqrt\")",
      "                    and not k.startswith(\"bezier\")",
      "                ):",
      "                    try:",
      "                        rate_func = v",
      "                        plot = (",
      "                            ParametricFunction(",
      "                                lambda x: [x, rate_func(x), 0],",
      "                                t_range=[0, 1, .01],",
      "                                use_smoothing=False,",
      "                                color=YELLOW,",
      "                            )",
      "                            .stretch_to_fit_width(1.5)",
      "                            .stretch_to_fit_height(1)",
      "                        )",
      "                        plot_bg = SurroundingRectangle(plot).set_color(WHITE)",
      "                        plot_title = (",
      "                            Text(rate_func.__name__, weight=BOLD)",
      "                            .scale(0.5)",
      "                            .next_to(plot_bg, UP, buff=0.1)",
      "                        )",
      "                        x.add(VGroup(plot_bg, plot, plot_title))",
      "                    except: # because functions `not_quite_there`, `function squish_rate_func` are not working.",
      "                        pass",
      "        x.arrange_in_grid(cols=8)",
      "        x.height = config.frame_height",
      "        x.width = config.frame_width",
      "        x.move_to(ORIGIN).scale(0.95)",
      "        self.add(x)"
    ],
    "topic": "Rate function plots",
    "description": "Displays a grid of plots visualizing various rate functions from the Manim library."
  },
  {
    "code": [
      ">>> from manim import XKCD",
      ">>> XKCD.AVOCADO",
      "ManimColor('#90B134')"
    ],
    "topic": "color definition",
    "description": "Defines the XKCD color 'Avocado' using its hexadecimal code in Manim."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class StraightPathExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.straight_path(),",
      "                run_time=2,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "Dot transformation",
    "description": "Animates dots moving along straight paths from starting to finish points with traced paths."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ClockwisePathExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.clockwise_path(),",
      "                run_time=2,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "Dot transformation",
    "description": "Animates dots moving from starting to finish points along a clockwise path with traced paths."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpiralPathExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.spiral_path(2 * TAU),",
      "                run_time=5,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "spiral path animation",
    "description": "Animates dots moving along a spiral path from starting to finishing points with traced paths."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PathAlongCirclesExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        circle_center = Dot(3 * LEFT)",
      "        self.add(circle_center)",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.path_along_circles(",
      "                    2 * PI, circle_center.get_center()",
      "                ),",
      "                run_time=3,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "Dot transformation along path",
    "description": "Animates dots moving from starting to finish points along circular paths centered at a fixed point."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PathAlongArcExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.path_along_arc(TAU * 2 / 3),",
      "                run_time=3,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "Dot transformation",
    "description": "Animates dots moving along an arc path from starting to finish positions with traced paths."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CounterclockwisePathExample(Scene):",
      "    def construct(self):",
      "        colors = [RED, GREEN, BLUE]",
      "",
      "        starting_points = VGroup(",
      "            *[",
      "                Dot(LEFT + pos, color=color)",
      "                for pos, color in zip([UP, DOWN, LEFT], colors)",
      "            ]",
      "        )",
      "",
      "        finish_points = VGroup(",
      "            *[",
      "                Dot(RIGHT + pos, color=color)",
      "                for pos, color in zip([ORIGIN, UP, DOWN], colors)",
      "            ]",
      "        )",
      "",
      "        self.add(starting_points)",
      "        self.add(finish_points)",
      "        for dot in starting_points:",
      "            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))",
      "",
      "        self.wait()",
      "        self.play(",
      "            Transform(",
      "                starting_points,",
      "                finish_points,",
      "                path_func=utils.paths.counterclockwise_path(),",
      "                run_time=2,",
      "            )",
      "        )",
      "        self.wait()"
    ],
    "topic": "Dot transformation",
    "description": "Animates dots moving along counterclockwise paths from starting to finish points with traced paths."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IndexLabelsExample(Scene):",
      "    def construct(self):",
      "        text = MathTex(",
      "            \"\\\\frac{d}{dx}f(x)g(x)=\",",
      "            \"f(x)\\\\frac{d}{dx}g(x)\",",
      "            \"+\",",
      "            \"g(x)\\\\frac{d}{dx}f(x)\",",
      "        )",
      "",
      "        #index the fist term in the MathTex mob",
      "        indices = index_labels(text[0])",
      "",
      "        text[0][1].set_color(PURPLE_B)",
      "        text[0][8:12].set_color(DARK_BLUE)",
      "",
      "        self.add(text, indices)"
    ],
    "topic": "derivative rule visualization",
    "description": "Displays the product rule for derivatives with indexed labels and color highlights on specific terms."
  },
  {
    "code": [
      ">>> from manim import BS381",
      ">>> BS381.OXFORD_BLUE",
      "ManimColor('#1F3057')"
    ],
    "topic": "color definition",
    "description": "Defines the color Oxford Blue using its hexadecimal code in Manim."
  },
  {
    "code": [
      ">>> from manim import RED, GREEN, BLUE",
      ">>> print(RED)",
      "#FC6255"
    ],
    "topic": "color definition",
    "description": "Displays the RGB hex value of the color RED from Manim's color library"
  },
  {
    "code": [
      ">>> from manim import SVGNAMES",
      ">>> SVGNAMES.LIGHTCORAL",
      "ManimColor('#EF7F7F')"
    ],
    "topic": "color retrieval",
    "description": "Retrieves the Manim color code for the color Light Coral."
  },
  {
    "code": [
      ">>> from manim import AS2700",
      ">>> AS2700.B23_BRIGHT_BLUE",
      "ManimColor('#174F90')"
    ],
    "topic": "color definition",
    "description": "Defines a specific color from the AS2700 standard as a ManimColor object."
  },
  {
    "code": [
      ">>> from manim import DVIPSNAMES",
      ">>> DVIPSNAMES.DARKORCHID",
      "ManimColor('#A4538A')"
    ],
    "topic": "color reference",
    "description": "Retrieves the hexadecimal color code for DARKORCHID from DVIPSNAMES in Manim"
  },
  {
    "code": [
      ">>> from manim import X11",
      ">>> X11.BEIGE",
      "ManimColor('#F5F5DC')"
    ],
    "topic": "color definition",
    "description": "Defines the color BEIGE using its hexadecimal code in Manim"
  },
  {
    "code": [
      ">>> from manim import XKCD",
      ">>> XKCD.MANGO",
      "ManimColor('#FFA62B')"
    ],
    "topic": "color definition",
    "description": "Defines a color using the XKCD color palette with the name MANGO."
  },
  {
    "code": [
      ">>> from manim import RandomColorGenerator, ManimColor, RED, GREEN, BLUE",
      ">>> rnd = RandomColorGenerator()",
      ">>> isinstance(rnd.next(), ManimColor)",
      "True"
    ],
    "topic": "color generation",
    "description": "Demonstrates the generation of a random color and checks its type against ManimColor."
  },
  {
    "code": [
      ">>> from manim import RandomColorGenerator, RED",
      ">>> rnd = RandomColorGenerator(sample_colors=[RED])",
      ">>> rnd.next()",
      "ManimColor('#FC6255')"
    ],
    "topic": "color generation",
    "description": "Generates a random color from a predefined sample and displays its hex value."
  },
  {
    "code": [
      ".. manim:: MyScene",
      "",
      "    class MyScene(Scene):",
      "        def construct(self):",
      "            ..."
    ],
    "topic": "unspecified animation",
    "description": "The animation code is incomplete and does not specify any objects or actions."
  },
  {
    "code": [
      ".. manim:: DirectiveDoctestExample",
      "    :ref_classes: Dot",
      "",
      "    >>> from manim import Create, Dot, RED, Scene",
      "    >>> dot = Dot(color=RED)",
      "    >>> dot.color",
      "    ManimColor('#FC6255')",
      "    >>> class DirectiveDoctestExample(Scene):",
      "    ...     def construct(self):",
      "    ...         self.play(Create(dot))"
    ],
    "topic": "dot creation",
    "description": "Animates the creation of a red dot on the screen."
  },
  {
    "code": [
      "%%manim -v WARNING --disable_caching -qm BannerExample",
      "",
      "config.media_width = \"75%\"",
      "config.media_embed = True",
      "",
      "class BannerExample(Scene):",
      "    def construct(self):",
      "        self.camera.background_color = \"#ece6e2\"",
      "        banner_large = ManimBanner(dark_theme=False).scale(0.7)",
      "        self.play(banner_large.create())",
      "        self.play(banner_large.expand())"
    ],
    "topic": "banner animation",
    "description": "Displays a Manim banner being created and then expanding on a light background."
  },
  {
    "code": [
      "%%manim [CLI options] MyAwesomeScene",
      "",
      "class MyAweseomeScene(Scene):",
      "    def construct(self):",
      "        ..."
    ],
    "topic": "generic scene setup",
    "description": "Sets up a basic scene structure with no specific animations defined"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingAndZoomingCamera(MovingCameraScene):",
      "    def construct(self):",
      "        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)",
      "        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)",
      "        self.add(s, t)",
      "        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))",
      "        self.wait(0.3)",
      "        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))",
      "",
      "        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))"
    ],
    "topic": "camera movement",
    "description": "Shows a camera zooming in on a square and a triangle, then zooming out to show both."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingCameraOnGraph(MovingCameraScene):",
      "    def construct(self):",
      "        self.camera.frame.save_state()",
      "",
      "        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])",
      "        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])",
      "",
      "        dot_1 = Dot(ax.i2gp(graph.t_min, graph))",
      "        dot_2 = Dot(ax.i2gp(graph.t_max, graph))",
      "        self.add(ax, graph, dot_1, dot_2)",
      "",
      "        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))",
      "        self.play(self.camera.frame.animate.move_to(dot_2))",
      "        self.play(Restore(self.camera.frame))",
      "        self.wait()"
    ],
    "topic": "Camera movement on graph",
    "description": "Animates a camera zooming in on and moving along a sine wave graph from one endpoint to another."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangingCameraWidthAndRestore(MovingCameraScene):",
      "    def construct(self):",
      "        text = Text(\"Hello World\").set_color(BLUE)",
      "        self.add(text)",
      "        self.camera.frame.save_state()",
      "        self.play(self.camera.frame.animate.set(width=text.width * 1.2))",
      "        self.wait(0.3)",
      "        self.play(Restore(self.camera.frame))"
    ],
    "topic": "camera zoom animation",
    "description": "Animates a zoom-in effect on text by changing the camera frame width and then restores it to the original state."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingCameraCenter(MovingCameraScene):",
      "    def construct(self):",
      "        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)",
      "        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)",
      "        self.wait(0.3)",
      "        self.add(s, t)",
      "        self.play(self.camera.frame.animate.move_to(s))",
      "        self.wait(0.3)",
      "        self.play(self.camera.frame.animate.move_to(t))"
    ],
    "topic": "camera movement",
    "description": "Animates the camera moving between a red square and a green triangle positioned on opposite sides."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SlidingMultipleScenes(MovingCameraScene):",
      "    def construct(self):",
      "        def create_scene(number):",
      "            frame = Rectangle(width=16,height=9)",
      "            circ = Circle().shift(LEFT)",
      "            text = Tex(f\"This is Scene {str(number)}\").next_to(circ, RIGHT)",
      "            frame.add(circ,text)",
      "            return frame",
      "",
      "        group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)",
      "        self.add(group)",
      "        self.camera.auto_zoom(group[0], animate=False)",
      "        for scene in group:",
      "            self.play(self.camera.auto_zoom(scene))",
      "            self.wait()",
      "",
      "        self.play(self.camera.auto_zoom(group, margin=2))"
    ],
    "topic": "camera zoom scenes",
    "description": "Animates a camera zooming into multiple scenes arranged in a grid, each featuring a circle and text label."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UseZoomedScene(ZoomedScene):",
      "    def construct(self):",
      "        dot = Dot().set_color(GREEN)",
      "        self.add(dot)",
      "        self.wait(1)",
      "        self.activate_zooming(animate=False)",
      "        self.wait(1)",
      "        self.play(dot.animate.shift(LEFT))"
    ],
    "topic": "zoomed dot movement",
    "description": "Displays a green dot being zoomed in on and then shifted to the left."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangingZoomScale(ZoomedScene):",
      "    def __init__(self, **kwargs):",
      "        ZoomedScene.__init__(",
      "            self,",
      "            zoom_factor=0.3,",
      "            zoomed_display_height=1,",
      "            zoomed_display_width=3,",
      "            image_frame_stroke_width=20,",
      "            zoomed_camera_config={",
      "                \"default_frame_stroke_width\": 3,",
      "            },",
      "            **kwargs",
      "        )",
      "",
      "    def construct(self):",
      "        dot = Dot().set_color(GREEN)",
      "        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)",
      "        self.add(dot, sq)",
      "        self.wait(1)",
      "        self.activate_zooming(animate=False)",
      "        self.wait(1)",
      "        self.play(dot.animate.shift(LEFT * 0.3))",
      "",
      "        self.play(self.zoomed_camera.frame.animate.scale(4))",
      "        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))"
    ],
    "topic": "zoom and shift animation",
    "description": "Demonstrates a zoom effect on a scene with a dot and circle, including camera scaling and shifting."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LinearTransformationSceneExample(LinearTransformationScene):",
      "    def __init__(self, **kwargs):",
      "        LinearTransformationScene.__init__(",
      "            self,",
      "            show_coordinates=True,",
      "            leave_ghost_vectors=True,",
      "            **kwargs",
      "        )",
      "",
      "    def construct(self):",
      "        matrix = [[1, 1], [0, 1]]",
      "        self.apply_matrix(matrix)",
      "        self.wait()"
    ],
    "topic": "matrix transformation",
    "description": "Animates a 2x2 matrix transforming the coordinate grid and vectors to illustrate a linear transformation."
  },
  {
    "code": [
      "class MyScene(Scene):",
      "    def construct(self):",
      "        self.play(Write(Text(\"Hello World!\")))"
    ],
    "topic": "text animation",
    "description": "Animates the text 'Hello World!' appearing on the screen using the Write effect"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SoundExample(Scene):",
      "    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/",
      "    def construct(self):",
      "        dot = Dot().set_color(GREEN)",
      "        self.add_sound(\"click.wav\")",
      "        self.add(dot)",
      "        self.wait()",
      "        self.add_sound(\"click.wav\")",
      "        dot.set_color(BLUE)",
      "        self.wait()",
      "        self.add_sound(\"click.wav\")",
      "        dot.set_color(RED)",
      "        self.wait()"
    ],
    "topic": "dot color change",
    "description": "Animates a dot changing color from green to blue to red with sound effects at each change."
  },
  {
    "code": [
      "class SubcaptionExample(Scene):",
      "    def construct(self):",
      "        square = Square()",
      "        circle = Circle()",
      "",
      "        # first option: via the add_subcaption method",
      "        self.add_subcaption(\"Hello square!\", duration=1)",
      "        self.play(Create(square))",
      "",
      "        # second option: within the call to Scene.play",
      "        self.play(",
      "            Transform(square, circle), subcaption=\"The square transforms.\"",
      "        )"
    ],
    "topic": "shape transformation with subcaptions",
    "description": "Animates a square transforming into a circle with accompanying subcaptions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TableExamples(Scene):",
      "    def construct(self):",
      "        t0 = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")],",
      "            top_left_entry=Text(\"TOP\"))",
      "        t0.add_highlighted_cell((2,2), color=GREEN)",
      "        x_vals = np.linspace(-2,2,5)",
      "        y_vals = np.exp(x_vals)",
      "        t1 = DecimalTable(",
      "            [x_vals, y_vals],",
      "            row_labels=[MathTex(\"x\"), MathTex(\"f(x)\")],",
      "            include_outer_lines=True)",
      "        t1.add(t1.get_cell((2,2), color=RED))",
      "        t2 = MathTable(",
      "            [[\"+\", 0, 5, 10],",
      "            [0, 0, 5, 10],",
      "            [2, 2, 7, 12],",
      "            [4, 4, 9, 14]],",
      "            include_outer_lines=True)",
      "        t2.get_horizontal_lines()[:3].set_color(BLUE)",
      "        t2.get_vertical_lines()[:3].set_color(BLUE)",
      "        t2.get_horizontal_lines()[:3].set_z_index(1)",
      "        cross = VGroup(",
      "            Line(UP + LEFT, DOWN + RIGHT),",
      "            Line(UP + RIGHT, DOWN + LEFT))",
      "        a = Circle().set_color(RED).scale(0.5)",
      "        b = cross.set_color(BLUE).scale(0.5)",
      "        t3 = MobjectTable(",
      "            [[a.copy(),b.copy(),a.copy()],",
      "            [b.copy(),a.copy(),a.copy()],",
      "            [a.copy(),b.copy(),b.copy()]])",
      "        t3.add(Line(",
      "            t3.get_corner(DL), t3.get_corner(UR)",
      "        ).set_color(RED))",
      "        vals = np.arange(1,21).reshape(5,4)",
      "        t4 = IntegerTable(",
      "            vals,",
      "            include_outer_lines=True",
      "        )",
      "        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)",
      "        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)",
      "        self.add(g1, g2)"
    ],
    "topic": "Table visualization",
    "description": "Displays various types of tables with highlighted cells, custom labels, and geometric shapes arranged in groups."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CircleWithContent(VGroup):",
      "    def __init__(self, content):",
      "        super().__init__()",
      "        self.circle = Circle()",
      "        self.content = content",
      "        self.add(self.circle, content)",
      "        content.move_to(self.circle.get_center())",
      "",
      "    def clear_content(self):",
      "        self.remove(self.content)",
      "        self.content = None",
      "",
      "    @override_animate(clear_content)",
      "    def _clear_content_animation(self, anim_args=None):",
      "        if anim_args is None:",
      "            anim_args = {}",
      "        anim = Uncreate(self.content, **anim_args)",
      "        self.clear_content()",
      "        return anim",
      "",
      "class AnimationOverrideExample(Scene):",
      "    def construct(self):",
      "        t = Text(\"hello!\")",
      "        my_mobject = CircleWithContent(t)",
      "        self.play(Create(my_mobject))",
      "        self.play(my_mobject.animate.clear_content())",
      "        self.wait()"
    ],
    "topic": "circle content animation",
    "description": "Displays a circle containing text 'hello!' which is then removed with an animation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DeterminantOfAMatrix(Scene):",
      "    def construct(self):",
      "        matrix = Matrix([",
      "            [2, 0],",
      "            [-1, 1]",
      "        ])",
      "",
      "        # scaling down the `det` string",
      "        det = get_det_text(matrix,",
      "                    determinant=3,",
      "                    initial_scale_factor=1)",
      "",
      "        # must add the matrix",
      "        self.add(matrix)",
      "        self.add(det)"
    ],
    "topic": "matrix determinant",
    "description": "Displays a 2x2 matrix with its determinant value shown beside it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MatrixExamples(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])",
      "        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],",
      "            left_bracket=\"(\",",
      "            right_bracket=\")\")",
      "        m2 = DecimalMatrix(",
      "            [[3.456, 2.122], [33.2244, 12.33]],",
      "            element_to_mobject_config={\"num_decimal_places\": 2},",
      "            left_bracket=r\"\\{\",",
      "            right_bracket=r\"\\}\")",
      "        m3 = MobjectMatrix(",
      "            [[Circle().scale(0.3), Square().scale(0.3)],",
      "            [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],",
      "            left_bracket=\"\\\\langle\",",
      "            right_bracket=\"\\\\rangle\")",
      "        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)",
      "        self.add(g)"
    ],
    "topic": "Matrix display",
    "description": "Displays various types of matrices with different bracket styles and contents arranged in a grid."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BraceExample(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        self.add(s)",
      "        for i in np.linspace(0.1,1.0,4):",
      "            br = Brace(s, sharpness=i)",
      "            t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)",
      "            self.add(t)",
      "            self.add(br)",
      "        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)"
    ],
    "topic": "brace sharpness demonstration",
    "description": "Illustrates the effect of varying sharpness on a brace around a square with corresponding text labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BraceTextExample(Scene):",
      "    def construct(self):",
      "        s1 = Square().move_to(2*LEFT)",
      "        self.add(s1)",
      "        br1 = BraceText(s1, \"Label\")",
      "        self.add(br1)",
      "",
      "        s2 = Square().move_to(2*RIGHT)",
      "        self.add(s2)",
      "        br2 = BraceText(s2, \"Label\")",
      "",
      "        br2.change_label(\"new\")",
      "        self.add(br2)",
      "        self.wait(0.1)"
    ],
    "topic": "brace text labeling",
    "description": "Displays two squares with braces and labels, changing one label dynamically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcBraceExample(Scene):",
      "    def construct(self):",
      "        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)",
      "        brace_1 = ArcBrace(arc_1,LEFT)",
      "        group_1 = VGroup(arc_1,brace_1)",
      "",
      "        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)",
      "        brace_2 = ArcBrace(arc_2)",
      "        group_2 = VGroup(arc_2,brace_2)",
      "",
      "        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)",
      "        brace_3 = ArcBrace(arc_3)",
      "        group_3 = VGroup(arc_3,brace_3)",
      "",
      "        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)",
      "        brace_4 = ArcBrace(arc_4)",
      "        group_4 = VGroup(arc_4,brace_4)",
      "",
      "        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)",
      "        self.add(arc_group.center())"
    ],
    "topic": "Arc and Brace Arrangement",
    "description": "Displays multiple arcs with corresponding braces arranged in a grid layout."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BraceBPExample(Scene):",
      "    def construct(self):",
      "        p1 = [0,0,0]",
      "        p2 = [1,2,0]",
      "        brace = BraceBetweenPoints(p1,p2)",
      "        self.play(Create(NumberPlane()))",
      "        self.play(Create(brace))",
      "        self.wait(2)"
    ],
    "topic": "brace annotation",
    "description": "Displays a brace between two points on a number plane to highlight a specific segment."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ImageInterpolationEx(Scene):",
      "    def construct(self):",
      "        img = ImageMobject(np.uint8([[63, 0, 0, 0],",
      "                                        [0, 127, 0, 0],",
      "                                        [0, 0, 191, 0],",
      "                                        [0, 0, 0, 255]",
      "                                        ]))",
      "",
      "        img.height = 2",
      "        img1 = img.copy()",
      "        img2 = img.copy()",
      "        img3 = img.copy()",
      "        img4 = img.copy()",
      "        img5 = img.copy()",
      "",
      "        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])",
      "        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])",
      "        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])",
      "        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])",
      "        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])",
      "        img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))",
      "        img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))",
      "        img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))",
      "        img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))",
      "        img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))",
      "",
      "        x= Group(img1,img2,img3,img4,img5)",
      "        x.arrange()",
      "        self.add(x)"
    ],
    "topic": "Image resampling comparison",
    "description": "Displays a grid of images each using a different resampling algorithm with labels to compare visual differences."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ImageFromArray(Scene):",
      "    def construct(self):",
      "        image = ImageMobject(np.uint8([[0, 100, 30, 200],",
      "                                       [255, 0, 5, 33]]))",
      "        image.height = 7",
      "        self.add(image)"
    ],
    "topic": "grayscale image display",
    "description": "Displays a grayscale image created from a 2x4 numpy array with varying pixel intensities."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DashedVMobjectExample(Scene):",
      "    def construct(self):",
      "        r = 0.5",
      "",
      "        top_row = VGroup()  # Increasing num_dashes",
      "        for dashes in range(1, 12):",
      "            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)",
      "            top_row.add(circ)",
      "",
      "        middle_row = VGroup()  # Increasing dashed_ratio",
      "        for ratio in np.arange(1 / 11, 1, 1 / 11):",
      "            circ = DashedVMobject(",
      "                Circle(radius=r, color=WHITE), dashed_ratio=ratio",
      "            )",
      "            middle_row.add(circ)",
      "",
      "        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)",
      "        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)",
      "        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)",
      "        bottom_row = VGroup(func_even,func_stretched)",
      "",
      "        top_row.arrange(buff=0.3)",
      "        middle_row.arrange()",
      "        bottom_row.arrange(buff=1)",
      "        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)",
      "        self.add(everything)"
    ],
    "topic": "Dashed shapes and function",
    "description": "Illustrates circles with varying dash patterns and a function graph with different dash styles."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShapesWithVDict(Scene):",
      "    def construct(self):",
      "        square = Square().set_color(RED)",
      "        circle = Circle().set_color(YELLOW).next_to(square, UP)",
      "",
      "        # create dict from list of tuples each having key-mobject pair",
      "        pairs = [(\"s\", square), (\"c\", circle)]",
      "        my_dict = VDict(pairs, show_keys=True)",
      "",
      "        # display it just like a VGroup",
      "        self.play(Create(my_dict))",
      "        self.wait()",
      "",
      "        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)",
      "",
      "        # add a key-value pair by wrapping it in a single-element list of tuple",
      "        # after attrs branch is merged, it will be easier like `.add(t=text)`",
      "        my_dict.add([(\"t\", text)])",
      "        self.wait()",
      "",
      "        rect = Rectangle().next_to(text, DOWN)",
      "        # can also do key assignment like a python dict",
      "        my_dict[\"r\"] = rect",
      "",
      "        # access submobjects like a python dict",
      "        my_dict[\"t\"].set_color(PURPLE)",
      "        self.play(my_dict[\"t\"].animate.scale(3))",
      "        self.wait()",
      "",
      "        # also supports python dict styled reassignment",
      "        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)",
      "        self.wait()",
      "",
      "        # remove submobject by key",
      "        my_dict.remove(\"t\")",
      "        self.wait()",
      "",
      "        self.play(Uncreate(my_dict[\"s\"]))",
      "        self.wait()",
      "",
      "        self.play(FadeOut(my_dict[\"c\"]))",
      "        self.wait()",
      "",
      "        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))",
      "        self.wait()",
      "",
      "        # you can also make a VDict from an existing dict of mobjects",
      "        plain_dict = {",
      "            1: Integer(1).shift(DOWN),",
      "            2: Integer(2).shift(2 * DOWN),",
      "            3: Integer(3).shift(3 * DOWN),",
      "        }",
      "",
      "        vdict_from_plain_dict = VDict(plain_dict)",
      "        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))",
      "        self.play(Create(vdict_from_plain_dict))",
      "",
      "        # you can even use zip",
      "        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))",
      "        vdict_using_zip.shift(1.5 * RIGHT)",
      "        self.play(Create(vdict_using_zip))",
      "        self.wait()"
    ],
    "topic": "VDict manipulation",
    "description": "Demonstrates creating, modifying, and animating a VDict containing geometric shapes and text, showcasing dictionary-like operations on Manim objects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AddIterableToVGroupExample(Scene):",
      "    def construct(self):",
      "        v = VGroup(",
      "            Square(),               # Singular VMobject instance",
      "            [Circle(), Triangle()], # List of VMobject instances",
      "            Dot(),",
      "            (Dot() for _ in range(2)), # Iterable that generates VMobjects",
      "        )",
      "        v.arrange()",
      "        self.add(v)"
    ],
    "topic": "VGroup arrangement",
    "description": "Displays a collection of geometric shapes arranged in a sequence using VGroup."
  },
  {
    "code": [
      ">>> from manim import Triangle, Square, VGroup",
      ">>> vg = VGroup()",
      ">>> triangle, square = Triangle(), Square()",
      ">>> vg.add(triangle)",
      "VGroup(Triangle)",
      ">>> vg + square  # a new VGroup is constructed",
      "VGroup(Triangle, Square)",
      ">>> vg  # not modified",
      "VGroup(Triangle)",
      ">>> vg += square",
      ">>> vg  # modifies vg",
      "VGroup(Triangle, Square)",
      ">>> vg.remove(triangle)",
      "VGroup(Square)",
      ">>> vg - square  # a new VGroup is constructed",
      "VGroup()",
      ">>> vg  # not modified",
      "VGroup(Square)",
      ">>> vg -= square",
      ">>> vg  # modifies vg",
      "VGroup()"
    ],
    "topic": "VGroup manipulation",
    "description": "Demonstrates adding and removing shapes from a VGroup to show how the group is modified or remains unchanged."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcShapeIris(Scene):",
      "    def construct(self):",
      "        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]",
      "        radius = [1 + rad * 0.1 for rad in range(len(colors))]",
      "",
      "        circles_group = VGroup()",
      "",
      "        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]",
      "        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)",
      "                            for rad, col in zip(radius, colors)])",
      "        self.add(circles_group)"
    ],
    "topic": "concentric circles",
    "description": "Displays a group of concentric circles with varying radii and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AddToVGroup(Scene):",
      "    def construct(self):",
      "        circle_red = Circle(color=RED)",
      "        circle_green = Circle(color=GREEN)",
      "        circle_blue = Circle(color=BLUE)",
      "        circle_red.shift(LEFT)",
      "        circle_blue.shift(RIGHT)",
      "        gr = VGroup(circle_red, circle_green)",
      "        gr2 = VGroup(circle_blue) # Constructor uses add directly",
      "        self.add(gr,gr2)",
      "        self.wait()",
      "        gr += gr2 # Add group to another",
      "        self.play(",
      "            gr.animate.shift(DOWN),",
      "        )",
      "        gr -= gr2 # Remove group",
      "        self.play( # Animate groups separately",
      "            gr.animate.shift(LEFT),",
      "            gr2.animate.shift(UP),",
      "        )",
      "        self.play( #Animate groups without modification",
      "            (gr+gr2).animate.shift(RIGHT)",
      "        )",
      "        self.play( # Animate group without component",
      "            (gr-circle_red).animate.shift(RIGHT)",
      "        )"
    ],
    "topic": "VGroup manipulation",
    "description": "Demonstrates adding, removing, and animating VGroups of colored circles with shifts in position."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class WidthExample(Scene):",
      "    def construct(self):",
      "        decimal = DecimalNumber().to_edge(UP)",
      "        rect = Rectangle(color=BLUE)",
      "        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)",
      "",
      "        decimal.add_updater(lambda d: d.set_value(rect.width))",
      "",
      "        self.add(rect_copy, rect, decimal)",
      "        self.play(rect.animate.set(width=7))",
      "        self.wait()"
    ],
    "topic": "dynamic rectangle width",
    "description": "Displays a rectangle whose width dynamically updates and is shown as a decimal number."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class HeightExample(Scene):",
      "    def construct(self):",
      "        decimal = DecimalNumber().to_edge(UP)",
      "        rect = Rectangle(color=BLUE)",
      "        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)",
      "",
      "        decimal.add_updater(lambda d: d.set_value(rect.height))",
      "",
      "        self.add(rect_copy, rect, decimal)",
      "        self.play(rect.animate.set(height=5))",
      "        self.wait()"
    ],
    "topic": "rectangle height update",
    "description": "Displays a rectangle whose height increases to 5, with a decimal number showing the current height."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangeOfDirection(Scene):",
      "    def construct(self):",
      "        ccw = RegularPolygon(5)",
      "        ccw.shift(LEFT)",
      "        cw = RegularPolygon(5)",
      "        cw.shift(RIGHT).reverse_direction()",
      "",
      "        self.play(Create(ccw), Create(cw),",
      "        run_time=4)"
    ],
    "topic": "polygon rotation",
    "description": "Displays two pentagons rotating in opposite directions from a central point."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CapStyleExample(Scene):",
      "    def construct(self):",
      "        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)",
      "        line.set_cap_style(CapStyleType.ROUND)",
      "        self.add(line)"
    ],
    "topic": "line style demonstration",
    "description": "Displays a yellow line with a round cap style."
  },
  {
    "code": [
      ">>> from manim import Square, RED",
      ">>> Square(color=RED).get_color() == RED",
      "True"
    ],
    "topic": "color check",
    "description": "Verifies the color of a square object is red without animation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MobjectScaleExample(Scene):",
      "    def construct(self):",
      "        c1 = Circle(1, RED).set_x(-1)",
      "        c2 = Circle(1, GREEN).set_x(1)",
      "",
      "        vg = VGroup(c1, c2)",
      "        vg.set_stroke(width=50)",
      "        self.add(vg)",
      "",
      "        self.play(",
      "            c1.animate.scale(.25),",
      "            c2.animate.scale(.25,",
      "                scale_stroke=True)",
      "        )"
    ],
    "topic": "circle scaling animation",
    "description": "Animates two circles scaling down with different stroke behaviors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RotateMethodExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=1, color=BLUE)",
      "        line = Line(start=ORIGIN, end=RIGHT)",
      "        arrow1 = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)",
      "        group1 = VGroup(circle, line, arrow1)",
      "",
      "        group2 = group1.copy()",
      "        arrow2 = group2[2]",
      "        arrow2.rotate(angle=PI / 4, about_point=arrow2.get_start())",
      "",
      "        group3 = group1.copy()",
      "        arrow3 = group3[2]",
      "        arrow3.rotate(angle=120 * DEGREES, about_point=arrow3.get_start())",
      "",
      "        self.add(VGroup(group1, group2, group3).arrange(RIGHT, buff=1))"
    ],
    "topic": "rotation demonstration",
    "description": "Shows a circle, line, and arrow group with the arrow rotating by different angles in three side-by-side groups."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetSheen(Scene):",
      "    def construct(self):",
      "        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)",
      "        self.add(circle)"
    ],
    "topic": "circle sheen effect",
    "description": "Displays a circle with a sheen effect applied, creating a gradient from the bottom-right direction."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointsAsCornersExample(Scene):",
      "    def construct(self):",
      "        corners = (",
      "            # create square",
      "            UR, UL,",
      "            DL, DR,",
      "            UR,",
      "            # create crosses",
      "            DL, UL,",
      "            DR",
      "        )",
      "        vmob = VMobject(stroke_color=RED)",
      "        vmob.set_points_as_corners(corners).scale(2)",
      "        self.add(vmob)"
    ],
    "topic": "geometric shape animation",
    "description": "Animates the creation of a red polygonal path using specified corner points, scaled by a factor of 2."
  },
  {
    "code": [
      ">>> from manim import Circle",
      ">>> Circle().get_direction()",
      "'CCW'"
    ],
    "topic": "circle orientation",
    "description": "Determines the default drawing direction of a circle as counterclockwise (CCW)"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointFromProportion(Scene):",
      "    def construct(self):",
      "        line = Line(2*DL, 2*UR)",
      "        self.add(line)",
      "        colors = (RED, BLUE, YELLOW)",
      "        proportions = (1/4, 1/2, 3/4)",
      "        for color, proportion in zip(colors, proportions):",
      "            self.add(Dot(color=color).move_to(",
      "                    line.point_from_proportion(proportion)",
      "            ))"
    ],
    "topic": "Line with points",
    "description": "Displays a diagonal line with dots at specified proportions along its length, each dot in a different color."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetFill(Scene):",
      "    def construct(self):",
      "        square = Square().scale(2).set_fill(WHITE,1)",
      "        circle1 = Circle().set_fill(GREEN,0.8)",
      "        circle2 = Circle().set_fill(YELLOW) # No fill_opacity",
      "        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)",
      "        group = Group(circle1,circle2,circle3).arrange()",
      "        self.add(square)",
      "        self.add(group)"
    ],
    "topic": "2D shapes with fill",
    "description": "Displays a large white square with three colored circles arranged inside, each having different fill opacities."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LineGradientExample(Scene):",
      "    def construct(self):",
      "        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)",
      "        new_curve = CurvesAsSubmobjects(curve)",
      "        new_curve.set_color_by_gradient(BLUE, RED)",
      "        self.add(new_curve.shift(UP), curve)"
    ],
    "topic": "Parametric curve gradient",
    "description": "Displays a sinusoidal curve with a gradient color transition from blue to red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PgroupExample(Scene):",
      "    def construct(self):",
      "",
      "        p1 = PointCloudDot(radius=1, density=20, color=BLUE)",
      "        p1.move_to(4.5 * LEFT)",
      "        p2 = PointCloudDot()",
      "        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)",
      "        p3.move_to(4.5 * RIGHT)",
      "        pList = PGroup(p1, p2, p3)",
      "",
      "        self.add(pList)"
    ],
    "topic": "point cloud visualization",
    "description": "Displays three point clouds of varying sizes and colors arranged horizontally."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExamplePoint(Scene):",
      "    def construct(self):",
      "        colorList = [RED, GREEN, BLUE, YELLOW]",
      "        for i in range(200):",
      "            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))",
      "            self.add(point)",
      "        for i in range(200):",
      "            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))",
      "            self.add(point)",
      "        self.add(point)"
    ],
    "topic": "Random point distribution",
    "description": "Displays 400 randomly colored points scattered in a rectangular area with varying density."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointCloudDotExample2(Scene):",
      "    def construct(self):",
      "        plane = ComplexPlane()",
      "        cloud = PointCloudDot(color=RED)",
      "        self.add(",
      "            plane, cloud",
      "        )",
      "        self.wait()",
      "        self.play(",
      "            cloud.animate.apply_complex_function(lambda z: np.exp(z))",
      "        )"
    ],
    "topic": "complex function transformation",
    "description": "Animates a point cloud being transformed by the complex exponential function on a complex plane."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointCloudDotExample(Scene):",
      "    def construct(self):",
      "        cloud_1 = PointCloudDot(color=RED)",
      "        cloud_2 = PointCloudDot(stroke_width=4, radius=1)",
      "        cloud_3 = PointCloudDot(density=15)",
      "",
      "        group = Group(cloud_1, cloud_2, cloud_3).arrange()",
      "        self.add(group)"
    ],
    "topic": "Point cloud visualization",
    "description": "Displays three point clouds with different properties arranged in a group."
  },
  {
    "code": [
      ">>> from manim import Square, RED",
      ">>> Square(color=RED).get_color() == RED",
      "True"
    ],
    "topic": "color check",
    "description": "Verifies that a square's color is set to red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PMobjectExample(Scene):",
      "    def construct(self):",
      "",
      "        pG = PGroup()  # This is just a collection of PMobject's",
      "",
      "        # As the scale factor increases, the number of points",
      "        # removed increases.",
      "        for sf in range(1, 9 + 1):",
      "            p = PointCloudDot(density=20, radius=1).thin_out(sf)",
      "            # PointCloudDot is a type of PMobject",
      "            # and can therefore be added to a PGroup",
      "            pG.add(p)",
      "",
      "        # This organizes all the shapes in a grid.",
      "        pG.arrange_in_grid()",
      "",
      "        self.add(pG)"
    ],
    "topic": "Point cloud animation",
    "description": "Displays a grid of point clouds with varying densities by thinning out points progressively."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleTorus(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        torus = Torus()",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(axes, torus)"
    ],
    "topic": "3D torus visualization",
    "description": "Displays a 3D torus with a set camera orientation in a 3D coordinate system."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CubeExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)",
      "",
      "        axes = ThreeDAxes()",
      "        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)",
      "        self.add(cube)"
    ],
    "topic": "3D cube display",
    "description": "Displays a semi-transparent blue cube in a 3D scene with a set camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExamplePrism(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)",
      "        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)",
      "        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])",
      "        self.add(prismSmall, prismLarge)"
    ],
    "topic": "3D prism visualization",
    "description": "Displays two 3D prisms with different dimensions and orientations in a 3D scene with a set camera angle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleCone(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)",
      "        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)",
      "        self.add(axes, cone)"
    ],
    "topic": "3D cone visualization",
    "description": "Displays a 3D cone oriented along a custom vector with a set camera angle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ParaSurface(ThreeDScene):",
      "    def func(self, u, v):",
      "        return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])",
      "",
      "    def construct(self):",
      "        axes = ThreeDAxes(x_range=[-4,4], x_length=8)",
      "        surface = Surface(",
      "            lambda u, v: axes.c2p(*self.func(u, v)),",
      "            u_range=[-PI, PI],",
      "            v_range=[0, TAU],",
      "            resolution=8,",
      "        )",
      "        self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)",
      "        self.add(axes, surface)"
    ],
    "topic": "3D parametric surface",
    "description": "Displays a 3D parametric surface defined by trigonometric functions on a 3D coordinate system with a fixed camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FillByValueExample(ThreeDScene):",
      "    def construct(self):",
      "        resolution_fa = 8",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)",
      "        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))",
      "        def param_surface(u, v):",
      "            x = u",
      "            y = v",
      "            z = np.sin(x) * np.cos(y)",
      "            return z",
      "        surface_plane = Surface(",
      "            lambda u, v: axes.c2p(u, v, param_surface(u, v)),",
      "            resolution=(resolution_fa, resolution_fa),",
      "            v_range=[0, 5],",
      "            u_range=[0, 5],",
      "            )",
      "        surface_plane.set_style(fill_opacity=1)",
      "        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)",
      "        self.add(axes, surface_plane)"
    ],
    "topic": "3D surface plot",
    "description": "Displays a 3D surface colored by height values, using a sine-cosine function, with a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleSphere(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)",
      "        sphere1 = Sphere(",
      "            center=(3, 0, 0),",
      "            radius=1,",
      "            resolution=(20, 20),",
      "            u_range=[0.001, PI - 0.001],",
      "            v_range=[0, TAU]",
      "        )",
      "        sphere1.set_color(RED)",
      "        self.add(sphere1)",
      "        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))",
      "        sphere2.set_color(GREEN)",
      "        self.add(sphere2)",
      "        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))",
      "        sphere3.set_color(BLUE)",
      "        self.add(sphere3)"
    ],
    "topic": "3D spheres visualization",
    "description": "Displays three colored spheres in 3D space with a fixed camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Dot3DExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)",
      "",
      "        axes = ThreeDAxes()",
      "        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)",
      "        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)",
      "        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)",
      "        self.add(axes, dot_1, dot_2,dot_3)"
    ],
    "topic": "3D dot placement",
    "description": "Displays three colored dots positioned in 3D space on a set of axes with a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleArrow3D(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        arrow = Arrow3D(",
      "            start=np.array([0, 0, 0]),",
      "            end=np.array([2, 2, 2]),",
      "            resolution=8",
      "        )",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(axes, arrow)"
    ],
    "topic": "3D vector visualization",
    "description": "Displays a 3D arrow from origin to point (2, 2, 2) with a set camera orientation"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleCylinder(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        cylinder = Cylinder(radius=2, height=3)",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(axes, cylinder)"
    ],
    "topic": "3D cylinder visualization",
    "description": "Displays a 3D cylinder on coordinate axes with a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PerpLineExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(PI / 3, -PI / 4)",
      "        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)",
      "        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)",
      "        line2 = Line3D.perpendicular_to(line1, color=BLUE)",
      "        self.add(ax, line1, line2)"
    ],
    "topic": "3D perpendicular lines",
    "description": "Displays two 3D lines, one red and one blue, where the blue line is perpendicular to the red line, within a 3D coordinate system."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ParallelLineExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(PI / 3, -PI / 4)",
      "        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)",
      "        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)",
      "        line2 = Line3D.parallel_to(line1, color=YELLOW)",
      "        self.add(ax, line1, line2)"
    ],
    "topic": "3D parallel lines",
    "description": "Displays two parallel 3D lines with different colors on a 3D coordinate system."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleLine3D(ThreeDScene):",
      "    def construct(self):",
      "        axes = ThreeDAxes()",
      "        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        self.add(axes, line)"
    ],
    "topic": "3D line visualization",
    "description": "Displays a 3D line from origin to point (2, 2, 2) with a fixed camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TetrahedronScene(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        obj = Tetrahedron()",
      "        self.add(obj)"
    ],
    "topic": "3D object display",
    "description": "Displays a static 3D tetrahedron with a set camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SquarePyramidScene(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        vertex_coords = [",
      "            [1, 1, 0],",
      "            [1, -1, 0],",
      "            [-1, -1, 0],",
      "            [-1, 1, 0],",
      "            [0, 0, 2]",
      "        ]",
      "        faces_list = [",
      "            [0, 1, 4],",
      "            [1, 2, 4],",
      "            [2, 3, 4],",
      "            [3, 0, 4],",
      "            [0, 1, 2, 3]",
      "        ]",
      "        pyramid = Polyhedron(vertex_coords, faces_list)",
      "        self.add(pyramid)"
    ],
    "topic": "3D pyramid visualization",
    "description": "Displays a 3D square pyramid with a fixed camera orientation showing its structure."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolyhedronSubMobjects(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        octahedron = Octahedron(edge_length = 3)",
      "        octahedron.graph[0].set_color(RED)",
      "        octahedron.faces[2].set_color(YELLOW)",
      "        self.add(octahedron)"
    ],
    "topic": "3D polyhedron coloring",
    "description": "Displays an octahedron with a specific vertex colored red and a face colored yellow, viewed from a set camera angle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IcosahedronScene(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        obj = Icosahedron()",
      "        self.add(obj)"
    ],
    "topic": "3D object display",
    "description": "Displays a static icosahedron with a set camera orientation in 3D space"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DodecahedronScene(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        obj = Dodecahedron()",
      "        self.add(obj)"
    ],
    "topic": "3D object display",
    "description": "Displays a static 3D dodecahedron with a set camera orientation"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class OctahedronScene(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        obj = Octahedron()",
      "        self.add(obj)"
    ],
    "topic": "3D object display",
    "description": "Displays a static 3D octahedron with a set camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ConvexHull3DExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)",
      "        points = [",
      "            [ 1.93192757,  0.44134585, -1.52407061],",
      "            [-0.93302521,  1.23206983,  0.64117067],",
      "            [-0.44350918, -0.61043677,  0.21723705],",
      "            [-0.42640268, -1.05260843,  1.61266094],",
      "            [-1.84449637,  0.91238739, -1.85172623],",
      "            [ 1.72068132, -0.11880457,  0.51881751],",
      "            [ 0.41904805,  0.44938012, -1.86440686],",
      "            [ 0.83864666,  1.66653337,  1.88960123],",
      "            [ 0.22240514, -0.80986286,  1.34249326],",
      "            [-1.29585759,  1.01516189,  0.46187522],",
      "            [ 1.7776499,  -1.59550796, -1.70240747],",
      "            [ 0.80065226, -0.12530398,  1.70063977],",
      "            [ 1.28960948, -1.44158255,  1.39938582],",
      "            [-0.93538943,  1.33617705, -0.24852643],",
      "            [-1.54868271,  1.7444399,  -0.46170734]",
      "        ]",
      "        hull = ConvexHull3D(",
      "            *points,",
      "            faces_config = {\"stroke_opacity\": 0},",
      "            graph_config = {",
      "                \"vertex_type\": Dot3D,",
      "                \"edge_config\": {",
      "                    \"stroke_color\": BLUE,",
      "                    \"stroke_width\": 2,",
      "                    \"stroke_opacity\": 0.05,",
      "                }",
      "            }",
      "        )",
      "        dots = VGroup(*[Dot3D(point) for point in points])",
      "        self.add(hull)",
      "        self.add(dots)"
    ],
    "topic": "3D convex hull",
    "description": "Displays a 3D convex hull enclosing a set of points with a semi-transparent structure and visible vertices."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LinearNN(Scene):",
      "    def construct(self):",
      "        edges = []",
      "        partitions = []",
      "        c = 0",
      "        layers = [2, 3, 3, 2]  # the number of neurons in each layer",
      "",
      "        for i in layers:",
      "            partitions.append(list(range(c + 1, c + i + 1)))",
      "            c += i",
      "        for i, v in enumerate(layers[1:]):",
      "                last = sum(layers[:i+1])",
      "                for j in range(v):",
      "                    for k in range(last - layers[i], last):",
      "                        edges.append((k + 1, j + last + 1))",
      "",
      "        vertices = np.arange(1, sum(layers) + 1)",
      "",
      "        graph = Graph(",
      "            vertices,",
      "            edges,",
      "            layout='partite',",
      "            partitions=partitions,",
      "            layout_scale=3,",
      "            vertex_config={'radius': 0.20},",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Neural network visualization",
    "description": "Displays a layered neural network graph with vertices representing neurons and edges representing connections between layers."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GraphAutoPosition(Scene):",
      "    def construct(self):",
      "        vertices = [1, 2, 3, 4, 5, 6, 7, 8]",
      "        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),",
      "                 (2, 8), (3, 4), (6, 1), (6, 2),",
      "                 (6, 3), (7, 2), (7, 4)]",
      "        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",",
      "                       \"planar\", \"random\", \"shell\",",
      "                       \"spectral\", \"spiral\"]",
      "        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)",
      "                  for lt in autolayouts]",
      "        r1 = VGroup(*graphs[:3]).arrange()",
      "        r2 = VGroup(*graphs[3:6]).arrange()",
      "        r3 = VGroup(*graphs[6:]).arrange()",
      "        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))"
    ],
    "topic": "Graph layout comparison",
    "description": "Displays multiple graphs with the same vertices and edges using different automatic layout algorithms arranged in a grid."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GraphManualPosition(Scene):",
      "    def construct(self):",
      "        vertices = [1, 2, 3, 4]",
      "        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]",
      "        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}",
      "        G = Graph(vertices, edges, layout=lt)",
      "        self.add(G)"
    ],
    "topic": "graph visualization",
    "description": "Displays a manually positioned graph with four vertices and connecting edges in a 2D layout."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import networkx as nx",
      "",
      "class Tree(Scene):",
      "    def construct(self):",
      "        G = nx.Graph()",
      "",
      "        G.add_node(\"ROOT\")",
      "",
      "        for i in range(5):",
      "            G.add_node(\"Child_%i\" % i)",
      "            G.add_node(\"Grandchild_%i\" % i)",
      "            G.add_node(\"Greatgrandchild_%i\" % i)",
      "",
      "            G.add_edge(\"ROOT\", \"Child_%i\" % i)",
      "            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)",
      "            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)",
      "",
      "        self.play(Create(",
      "            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))"
    ],
    "topic": "tree graph animation",
    "description": "Displays a hierarchical tree structure with nodes and edges emerging from a root node."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingVertices(Scene):",
      "    def construct(self):",
      "        vertices = [1, 2, 3, 4]",
      "        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]",
      "        g = Graph(vertices, edges)",
      "        self.play(Create(g))",
      "        self.wait()",
      "        self.play(g[1].animate.move_to([1, 1, 0]),",
      "                  g[2].animate.move_to([-1, 1, 0]),",
      "                  g[3].animate.move_to([1, -1, 0]),",
      "                  g[4].animate.move_to([-1, -1, 0]))",
      "        self.wait()"
    ],
    "topic": "graph vertex movement",
    "description": "Animates the movement of vertices in a graph to new positions while maintaining edge connections."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LabeledModifiedGraph(Scene):",
      "    def construct(self):",
      "        vertices = [1, 2, 3, 4, 5, 6, 7, 8]",
      "        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),",
      "                 (2, 8), (3, 4), (6, 1), (6, 2),",
      "                 (6, 3), (7, 2), (7, 4)]",
      "        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,",
      "                  labels=True, vertex_config={7: {\"fill_color\": RED}},",
      "                  edge_config={(1, 7): {\"stroke_color\": RED},",
      "                               (2, 7): {\"stroke_color\": RED},",
      "                               (4, 7): {\"stroke_color\": RED}})",
      "        self.add(g)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a circular graph with labeled vertices and highlights vertex 7 and its connected edges in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import networkx as nx",
      "",
      "class PartiteGraph(Scene):",
      "    def construct(self):",
      "        G = nx.Graph()",
      "        G.add_nodes_from([0, 1, 2, 3])",
      "        G.add_edges_from([(0, 2), (0,3), (1, 2)])",
      "        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])",
      "        self.play(Create(graph))"
    ],
    "topic": "Partite graph visualization",
    "description": "Displays a partite graph with nodes and edges arranged in partitions, animating its creation."
  },
  {
    "code": [
      "class LargeTreeGeneration(MovingCameraScene):",
      "    DEPTH = 4",
      "    CHILDREN_PER_VERTEX = 3",
      "    LAYOUT_CONFIG = {\"vertex_spacing\": (0.5, 1)}",
      "    VERTEX_CONF = {\"radius\": 0.25, \"color\": BLUE_B, \"fill_opacity\": 1}",
      "",
      "    def expand_vertex(self, g, vertex_id: str, depth: int):",
      "        new_vertices = [",
      "            f\"{vertex_id}/{i}\" for i in range(self.CHILDREN_PER_VERTEX)",
      "        ]",
      "        new_edges = [(vertex_id, child_id) for child_id in new_vertices]",
      "        g.add_edges(",
      "            *new_edges,",
      "            vertex_config=self.VERTEX_CONF,",
      "            positions={",
      "                k: g.vertices[vertex_id].get_center() + 0.1 * DOWN",
      "                for k in new_vertices",
      "            },",
      "        )",
      "        if depth < self.DEPTH:",
      "            for child_id in new_vertices:",
      "                self.expand_vertex(g, child_id, depth + 1)",
      "",
      "        return g",
      "",
      "    def construct(self):",
      "        g = Graph([\"ROOT\"], [], vertex_config=self.VERTEX_CONF)",
      "        g = self.expand_vertex(g, \"ROOT\", 1)",
      "        self.add(g)",
      "",
      "        self.play(",
      "            g.animate.change_layout(",
      "                \"tree\",",
      "                root_vertex=\"ROOT\",",
      "                layout_config=self.LAYOUT_CONFIG,",
      "            )",
      "        )",
      "        self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)"
    ],
    "topic": "Tree graph generation",
    "description": "Animates the expansion of a tree graph from a root vertex, showing hierarchical structure with auto-zooming camera."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PartiteLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"partite\",",
      "            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a partite graph with labeled nodes arranged in specified partitions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class KamadaKawaiLayout(Scene):",
      "    def construct(self):",
      "        from collections import defaultdict",
      "        distances: dict[int, dict[int, float]] = defaultdict(dict)",
      "",
      "        # set desired distances",
      "        distances[1][2] = 1  # distance between vertices 1 and 2 is 1",
      "        distances[2][3] = 1  # distance between vertices 2 and 3 is 1",
      "        distances[3][4] = 2  # etc",
      "        distances[4][5] = 3",
      "        distances[5][6] = 5",
      "        distances[6][1] = 8",
      "",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],",
      "            layout=\"kamada_kawai\",",
      "            layout_config={\"dist\": distances},",
      "            layout_scale=4,",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "graph layout visualization",
    "description": "Displays a graph with six vertices arranged using the Kamada-Kawai layout based on specified distances between vertices."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TreeLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6, 7],",
      "            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],",
      "            layout=\"tree\",",
      "            layout_config={\"root_vertex\": 1},",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "tree graph layout",
    "description": "Displays a tree graph with labeled nodes arranged in a hierarchical layout starting from a root vertex."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpringLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"spring\",",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a graph with six nodes and multiple edges arranged using a spring layout with labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RandomLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"random\",",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "random graph layout",
    "description": "Displays a graph with six nodes and nine edges arranged in a random layout with labeled nodes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PlanarLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"planar\",",
      "            layout_scale=4,",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "planar graph layout",
    "description": "Displays a planar graph with six vertices and labeled edges arranged in a planar layout."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpiralLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"spiral\",",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph spiral layout",
    "description": "Displays a graph of six nodes arranged in a spiral layout with labeled edges."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpectralLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"spectral\",",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a graph with a spectral layout and labeled nodes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShellLayout(Scene):",
      "    def construct(self):",
      "        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6, 7, 8, 9],",
      "            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],",
      "            layout=\"shell\",",
      "            layout_config={\"nlist\": nlist},",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a graph with a shell layout showing nodes and edges with labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CircularLayout(Scene):",
      "    def construct(self):",
      "        graph = Graph(",
      "            [1, 2, 3, 4, 5, 6],",
      "            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],",
      "            layout=\"circular\",",
      "            labels=True",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph visualization",
    "description": "Displays a graph with six nodes and multiple edges arranged in a circular layout with labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CustomLayoutExample(Scene):",
      "    def construct(self):",
      "        import numpy as np",
      "        import networkx as nx",
      "",
      "        # create custom layout",
      "        def custom_layout(",
      "            graph: nx.Graph,",
      "            scale: float | tuple[float, float, float] = 2,",
      "            n: int | None = None,",
      "            *args: Any,",
      "            **kwargs: Any,",
      "        ):",
      "            nodes = sorted(list(graph))",
      "            height = len(nodes) // n",
      "            return {",
      "                node: (scale * np.array([",
      "                    (i % n) - (n-1)/2,",
      "                    -(i // n) + height/2,",
      "                    0",
      "                ])) for i, node in enumerate(graph)",
      "            }",
      "",
      "        # draw graph",
      "        n = 4",
      "        graph = Graph(",
      "            [i for i in range(4 * 2 - 1)],",
      "            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],",
      "            labels=True,",
      "            layout=custom_layout,",
      "            layout_config={'n': n}",
      "        )",
      "        self.add(graph)"
    ],
    "topic": "Graph layout visualization",
    "description": "Displays a custom-layout graph with nodes and edges arranged in a grid pattern."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangeGraphLayout(Scene):",
      "    def construct(self):",
      "        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],",
      "                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],",
      "                          4: [1, 0, 0], 5: [2, 0, 0]}",
      "                  )",
      "        self.play(Create(G))",
      "        self.play(G.animate.change_layout(\"circular\"))",
      "        self.wait()"
    ],
    "topic": "Graph layout transformation",
    "description": "Animates a linear graph changing to a circular layout."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import networkx as nx",
      "",
      "nxgraph = nx.erdos_renyi_graph(14, 0.5)",
      "",
      "class ImportNetworkxGraph(Scene):",
      "    def construct(self):",
      "        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)",
      "        self.play(Create(G))",
      "        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +",
      "                                         3*UP*np.sin(ind/7 * PI))",
      "                    for ind, v in enumerate(G.vertices)])",
      "        self.play(Uncreate(G))"
    ],
    "topic": "network graph animation",
    "description": "Animates the creation and transformation of a network graph using a spring layout, moving vertices in a circular pattern before uncreating the graph."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingDiGraph(Scene):",
      "    def construct(self):",
      "        vertices = [1, 2, 3, 4]",
      "        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]",
      "",
      "        g = DiGraph(vertices, edges)",
      "",
      "        self.add(g)",
      "        self.play(",
      "            g[1].animate.move_to([1, 1, 1]),",
      "            g[2].animate.move_to([-1, 1, 2]),",
      "            g[3].animate.move_to([1, -1, -1]),",
      "            g[4].animate.move_to([-1, -1, 0]),",
      "        )",
      "        self.wait()"
    ],
    "topic": "Directed graph animation",
    "description": "Animates the movement of vertices in a directed graph to new positions in 3D space."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CustomDiGraph(Scene):",
      "    def construct(self):",
      "        vertices = [i for i in range(5)]",
      "        edges = [",
      "            (0, 1),",
      "            (1, 2),",
      "            (3, 2),",
      "            (3, 4),",
      "        ]",
      "",
      "        edge_config = {",
      "            \"stroke_width\": 2,",
      "            \"tip_config\": {",
      "                \"tip_shape\": ArrowSquareTip,",
      "                \"tip_length\": 0.15,",
      "            },",
      "            (3, 4): {",
      "                \"color\": RED,",
      "                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}",
      "            },",
      "        }",
      "",
      "        g = DiGraph(",
      "            vertices,",
      "            edges,",
      "            labels=True,",
      "            layout=\"circular\",",
      "            edge_config=edge_config,",
      "        ).scale(1.4)",
      "",
      "        self.play(Create(g))",
      "        self.wait()"
    ],
    "topic": "Directed graph visualization",
    "description": "Displays a circular layout directed graph with labeled vertices and customized edge styles, highlighting one edge in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UndirectedMovingDiGraph(Scene):",
      "    def construct(self):",
      "        vertices = [i for i in range(5)]",
      "        edges = [",
      "            (0, 1),",
      "            (1, 2),",
      "            (3, 2),",
      "            (3, 4),",
      "        ]",
      "",
      "        edge_config = {",
      "            \"stroke_width\": 2,",
      "            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},",
      "            (3, 4): {\"color\": RED},",
      "        }",
      "",
      "        g = DiGraph(",
      "            vertices,",
      "            edges,",
      "            labels=True,",
      "            layout=\"circular\",",
      "            edge_config=edge_config,",
      "        ).scale(1.4)",
      "",
      "        self.play(Create(g))",
      "        self.wait()",
      "",
      "        self.play(",
      "            g[1].animate.move_to([1, 1, 1]),",
      "            g[2].animate.move_to([-1, 1, 2]),",
      "            g[3].animate.move_to([-1.5, -1.5, -1]),",
      "            g[4].animate.move_to([1, -2, -1]),",
      "        )",
      "        self.wait()"
    ],
    "topic": "Moving directed graph",
    "description": "Displays a directed graph with vertices moving to new positions, highlighting an edge in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ComplexValueTrackerExample(Scene):",
      "    def construct(self):",
      "        tracker = ComplexValueTracker(-2+1j)",
      "        dot = Dot().add_updater(",
      "            lambda x: x.move_to(tracker.points)",
      "        )",
      "",
      "        self.add(NumberPlane(), dot)",
      "",
      "        self.play(tracker.animate.set_value(3+2j))",
      "        self.play(tracker.animate.set_value(tracker.get_value() * 1j))",
      "        self.play(tracker.animate.set_value(tracker.get_value() - 2j))",
      "        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))"
    ],
    "topic": "Complex number animation",
    "description": "Animates a dot moving on a number plane according to changes in a complex value tracker."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ValueTrackerExample(Scene):",
      "    def construct(self):",
      "        tracker = ValueTracker(0)",
      "        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))",
      "        self.add(label)",
      "        self.add(tracker)",
      "        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))",
      "        self.wait(2)"
    ],
    "topic": "moving dot animation",
    "description": "Animates a large dot moving horizontally across the screen as its position is updated over time."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ValueTrackerExample(Scene):",
      "    def construct(self):",
      "        number_line = NumberLine()",
      "        pointer = Vector(DOWN)",
      "        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))",
      "",
      "        tracker = ValueTracker(0)",
      "        pointer.add_updater(",
      "            lambda m: m.next_to(",
      "                        number_line.n2p(tracker.get_value()),",
      "                        UP",
      "                    )",
      "        )",
      "        self.add(number_line, pointer,label)",
      "        tracker += 1.5",
      "        self.wait(1)",
      "        tracker -= 4",
      "        self.wait(0.5)",
      "        self.play(tracker.animate.set_value(5))",
      "        self.wait(0.5)",
      "        self.play(tracker.animate.set_value(3))",
      "        self.play(tracker.animate.increment_value(-2))",
      "        self.wait(0.5)"
    ],
    "topic": "Number line animation",
    "description": "Animates a pointer moving along a number line with a label updating its position based on a changing value tracker."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExpandDirections(Scene):",
      "    def construct(self):",
      "        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]",
      "        self.play(",
      "            banners[0].expand(direction=\"right\"),",
      "            banners[1].expand(direction=\"center\"),",
      "            banners[2].expand(direction=\"left\"),",
      "        )"
    ],
    "topic": "banner expansion animation",
    "description": "Animates three Manim banners expanding in different directions: right, center, and left."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LightThemeBanner(Scene):",
      "    def construct(self):",
      "        self.camera.background_color = \"#ece6e2\"",
      "        banner = ManimBanner(dark_theme=False)",
      "        self.play(banner.create())",
      "        self.play(banner.expand())",
      "        self.wait()",
      "        self.play(Unwrite(banner))"
    ],
    "topic": "Manim banner animation",
    "description": "Displays a light-themed Manim banner that is created, expanded, and then unwritten."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DarkThemeBanner(Scene):",
      "    def construct(self):",
      "        banner = ManimBanner()",
      "        self.play(banner.create())",
      "        self.play(banner.expand())",
      "        self.wait()",
      "        self.play(Unwrite(banner))"
    ],
    "topic": "Manim banner animation",
    "description": "Animates the creation, expansion, and removal of the Manim logo banner."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MobjectTableExample(Scene):",
      "    def construct(self):",
      "        cross = VGroup(",
      "            Line(UP + LEFT, DOWN + RIGHT),",
      "            Line(UP + RIGHT, DOWN + LEFT),",
      "        )",
      "        a = Circle().set_color(RED).scale(0.5)",
      "        b = cross.set_color(BLUE).scale(0.5)",
      "        t0 = MobjectTable(",
      "            [[a.copy(),b.copy(),a.copy()],",
      "            [b.copy(),a.copy(),a.copy()],",
      "            [a.copy(),b.copy(),b.copy()]]",
      "        )",
      "        line = Line(",
      "            t0.get_corner(DL), t0.get_corner(UR)",
      "        ).set_color(RED)",
      "        self.add(t0, line)"
    ],
    "topic": "table with shapes",
    "description": "Displays a 3x3 table of circles and crosses with a diagonal red line."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MathTableExample(Scene):",
      "    def construct(self):",
      "        t0 = MathTable(",
      "            [[\"+\", 0, 5, 10],",
      "            [0, 0, 5, 10],",
      "            [2, 2, 7, 12],",
      "            [4, 4, 9, 14]],",
      "            include_outer_lines=True)",
      "        self.add(t0)"
    ],
    "topic": "math table display",
    "description": "Displays a mathematical table with addition results and includes outer lines for clarity."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IntegerTableExample(Scene):",
      "    def construct(self):",
      "        t0 = IntegerTable(",
      "            [[0,30,45,60,90],",
      "            [90,60,45,30,0]],",
      "            col_labels=[",
      "                MathTex(r\"\\frac{\\sqrt{0}}{2}\"),",
      "                MathTex(r\"\\frac{\\sqrt{1}}{2}\"),",
      "                MathTex(r\"\\frac{\\sqrt{2}}{2}\"),",
      "                MathTex(r\"\\frac{\\sqrt{3}}{2}\"),",
      "                MathTex(r\"\\frac{\\sqrt{4}}{2}\")],",
      "            row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],",
      "            h_buff=1,",
      "            element_to_mobject_config={\"unit\": r\"^{\\circ}\"})",
      "        self.add(t0)"
    ],
    "topic": "trigonometric table",
    "description": "Displays a table of sine and cosine values with corresponding angle labels in degrees and square root fractions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetColumnColorsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")]",
      "        ).set_column_colors([RED,BLUE], GREEN)",
      "        self.add(table)"
    ],
    "topic": "table color formatting",
    "description": "Displays a 2x2 table with column-specific colors applied to the text."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetRowLabelsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        lab = table.get_row_labels()",
      "        for item in lab:",
      "            item.set_color(random_bright_color())",
      "        self.add(table)"
    ],
    "topic": "table with labels",
    "description": "Displays a 2x2 table with row and column labels, where row labels are colored randomly."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetRowsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        table.add(SurroundingRectangle(table.get_rows()[1]))",
      "        self.add(table)"
    ],
    "topic": "table highlighting",
    "description": "Displays a table with a highlighted second row using a surrounding rectangle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetRowColorsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")]",
      "        ).set_row_colors([RED,BLUE], GREEN)",
      "        self.add(table)"
    ],
    "topic": "colored table display",
    "description": "Displays a 2x2 table with row labels and alternating row colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CreateTableExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")],",
      "            include_outer_lines=True)",
      "        self.play(table.create())",
      "        self.wait()"
    ],
    "topic": "table creation",
    "description": "Displays a 2x2 table with labeled rows and columns appearing on screen"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetColumnsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        table.add(SurroundingRectangle(table.get_columns()[1]))",
      "        self.add(table)"
    ],
    "topic": "table highlighting",
    "description": "Displays a table with a highlighted second column using a surrounding rectangle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetEntriesExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        ent = table.get_entries()",
      "        for item in ent:",
      "            item.set_color(random_bright_color())",
      "        table.get_entries((2,2)).rotate(PI)",
      "        self.add(table)"
    ],
    "topic": "table entry manipulation",
    "description": "Displays a table with entries colored randomly and one entry rotated 180 degrees."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AddHighlightedCellExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        table.add_highlighted_cell((2,2), color=GREEN)",
      "        self.add(table)"
    ],
    "topic": "table highlighting",
    "description": "Displays a 2x2 table with the cell at row 2, column 2 highlighted in green."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BackgroundRectanglesExample(Scene):",
      "    def construct(self):",
      "        background = Rectangle(height=6.5, width=13)",
      "        background.set_fill(opacity=.5)",
      "        background.set_color([TEAL, RED, YELLOW])",
      "        self.add(background)",
      "        t0 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table.\"]],",
      "            add_background_rectangles_to_entries=True)",
      "        t1 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table.\"]],",
      "            include_background_rectangle=True)",
      "        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)",
      "        self.add(g)"
    ],
    "topic": "table with background rectangles",
    "description": "Displays two tables with different background rectangle settings on a colored rectangular background."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetEntriesWithoutLabelsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        ent = table.get_entries_without_labels()",
      "        colors = [BLUE, GREEN, YELLOW, RED]",
      "        for k in range(len(colors)):",
      "            ent[k].set_color(colors[k])",
      "        table.get_entries_without_labels((2,2)).rotate(PI)",
      "        self.add(table)"
    ],
    "topic": "table entry manipulation",
    "description": "Displays a table with colored entries and rotates a specific entry without labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetColLabelsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        lab = table.get_col_labels()",
      "        for item in lab:",
      "            item.set_color(random_bright_color())",
      "        self.add(table)"
    ],
    "topic": "table with colored labels",
    "description": "Displays a table with column labels that are randomly colored."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetCellExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        cell = table.get_cell((2,2), color=RED)",
      "        self.add(table, cell)"
    ],
    "topic": "table cell highlighting",
    "description": "Displays a 2x2 table with the cell at row 2, column 2 highlighted in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetHighlightedCellExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        highlight = table.get_highlighted_cell((2,2), color=GREEN)",
      "        table.add_to_back(highlight)",
      "        self.add(table)"
    ],
    "topic": "table cell highlighting",
    "description": "Displays a 2x2 table with the cell at row 2, column 2 highlighted in green."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TableExamples(Scene):",
      "    def construct(self):",
      "        t0 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table in \\\\n Manim.\"]])",
      "        t1 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table.\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        t1.add_highlighted_cell((2,2), color=YELLOW)",
      "        t2 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table.\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")],",
      "            top_left_entry=Star().scale(0.3),",
      "            include_outer_lines=True,",
      "            arrange_in_grid_config={\"cell_alignment\": RIGHT})",
      "        t2.add(t2.get_cell((2,2), color=RED))",
      "        t3 = Table(",
      "            [[\"This\", \"is a\"],",
      "            [\"simple\", \"Table.\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")],",
      "            top_left_entry=Star().scale(0.3),",
      "            include_outer_lines=True,",
      "            line_config={\"stroke_width\": 1, \"color\": YELLOW})",
      "        t3.remove(*t3.get_vertical_lines())",
      "        g = Group(",
      "            t0,t1,t2,t3",
      "        ).scale(0.7).arrange_in_grid(buff=1)",
      "        self.add(g)"
    ],
    "topic": "table creation",
    "description": "Displays multiple styled tables with labels, highlighted cells, and custom entries arranged in a grid."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetHorizontalLinesExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        table.get_horizontal_lines().set_color(RED)",
      "        self.add(table)"
    ],
    "topic": "table with labels",
    "description": "Displays a 2x2 table with labeled rows and columns, highlighting horizontal lines in red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetVerticalLinesExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        table.get_vertical_lines()[0].set_color(RED)",
      "        self.add(table)"
    ],
    "topic": "table with colored line",
    "description": "Displays a 2x2 table with the first vertical line colored red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MobjectScaleExample(Scene):",
      "    def construct(self):",
      "        c1 = Circle(1, RED).set_x(-1)",
      "        c2 = Circle(1, GREEN).set_x(1)",
      "",
      "        vg = VGroup(c1, c2)",
      "        vg.set_stroke(width=50)",
      "        self.add(vg)",
      "",
      "        self.play(",
      "            c1.animate.scale(.25),",
      "            c2.animate.scale(.25,",
      "                scale_stroke=True)",
      "        )"
    ],
    "topic": "circle scaling animation",
    "description": "Animates two circles scaling down with different stroke scaling behaviors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetLabelsExample(Scene):",
      "    def construct(self):",
      "        table = Table(",
      "            [[\"First\", \"Second\"],",
      "            [\"Third\",\"Fourth\"]],",
      "            row_labels=[Text(\"R1\"), Text(\"R2\")],",
      "            col_labels=[Text(\"C1\"), Text(\"C2\")])",
      "        lab = table.get_labels()",
      "        colors = [BLUE, GREEN, YELLOW, RED]",
      "        for k in range(len(colors)):",
      "            lab[k].set_color(colors[k])",
      "        self.add(table)"
    ],
    "topic": "table with colored labels",
    "description": "Displays a table with row and column labels, each label colored differently."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DecimalTableExample(Scene):",
      "    def construct(self):",
      "        x_vals = [-2,-1,0,1,2]",
      "        y_vals = np.exp(x_vals)",
      "        t0 = DecimalTable(",
      "            [x_vals, y_vals],",
      "            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],",
      "            h_buff=1,",
      "            element_to_mobject_config={\"num_decimal_places\": 2})",
      "        self.add(t0)"
    ],
    "topic": "exponential function table",
    "description": "Displays a table comparing x values and their corresponding exponential function values with two decimal precision."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NumberLineExample(Scene):",
      "    def construct(self):",
      "        l0 = NumberLine(",
      "            x_range=[-10, 10, 2],",
      "            length=10,",
      "            color=BLUE,",
      "            include_numbers=True,",
      "            label_direction=UP,",
      "        )",
      "",
      "        l1 = NumberLine(",
      "            x_range=[-10, 10, 2],",
      "            unit_size=0.5,",
      "            numbers_with_elongated_ticks=[-2, 4],",
      "            include_numbers=True,",
      "            font_size=24,",
      "        )",
      "        num6 = l1.numbers[8]",
      "        num6.set_color(RED)",
      "",
      "        l2 = NumberLine(",
      "            x_range=[-2.5, 2.5 + 0.5, 0.5],",
      "            length=12,",
      "            decimal_number_config={\"num_decimal_places\": 2},",
      "            include_numbers=True,",
      "        )",
      "",
      "        l3 = NumberLine(",
      "            x_range=[-5, 5 + 1, 1],",
      "            length=6,",
      "            include_tip=True,",
      "            include_numbers=True,",
      "            rotation=10 * DEGREES,",
      "        )",
      "",
      "        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)",
      "        self.add(line_group)"
    ],
    "topic": "Number line variations",
    "description": "Displays four different number lines with varying configurations, including color, unit size, and rotation, arranged vertically."
  },
  {
    "code": [
      ">>> from manim import NumberLine",
      ">>> number_line = NumberLine()",
      ">>> number_line.number_to_point(0)",
      "array([0., 0., 0.])",
      ">>> number_line.number_to_point(1)",
      "array([1., 0., 0.])",
      ">>> number_line @ 1",
      "array([1., 0., 0.])",
      ">>> number_line.number_to_point([1, 2, 3])",
      "array([[1., 0., 0.],",
      "       [2., 0., 0.],",
      "       [3., 0., 0.]])"
    ],
    "topic": "Number line mapping",
    "description": "Maps numbers to their corresponding points on a number line in a 3D space."
  },
  {
    "code": [
      ">>> from manim import NumberLine",
      ">>> number_line = NumberLine()",
      ">>> number_line.point_to_number((0, 0, 0))",
      "np.float64(0.0)",
      ">>> number_line.point_to_number((1, 0, 0))",
      "np.float64(1.0)",
      ">>> number_line.point_to_number([[0.5, 0, 0], [1, 0, 0], [1.5, 0, 0]])",
      "array([0.5, 1. , 1.5])"
    ],
    "topic": "number line mapping",
    "description": "Maps 3D points to their corresponding numbers on a number line."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetAxisLabelsExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        labels = ax.get_axis_labels(",
      "            Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)",
      "        )",
      "        self.add(ax, labels)"
    ],
    "topic": "axis labeling",
    "description": "Displays coordinate axes with custom labels for the x-axis and y-axis."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointToCoordsExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(x_range=[0, 10, 2]).add_coordinates()",
      "        circ = Circle(radius=0.5).shift(UR * 2)",
      "",
      "        # get the coordinates of the circle with respect to the axes",
      "        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)",
      "",
      "        label = (",
      "            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)",
      "        )",
      "",
      "        self.add(ax, circ, label, Dot(circ.get_right()))"
    ],
    "topic": "Coordinates display",
    "description": "Displays a circle on axes with its coordinates labeled next to it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CoordsToPointExample(Scene):",
      "    def construct(self):",
      "        ax = Axes().add_coordinates()",
      "",
      "        # a dot with respect to the axes",
      "        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)",
      "        lines = ax.get_lines_to_point(ax.c2p(2,2))",
      "",
      "        # a dot with respect to the scene",
      "        # the default plane corresponds to the coordinates of the scene.",
      "        plane = NumberPlane()",
      "        dot_scene = Dot((2,2,0), color=RED)",
      "",
      "        self.add(plane, dot_scene, ax, dot_axes, lines)"
    ],
    "topic": "Coordinate system visualization",
    "description": "Illustrates the placement of dots in both scene and axes coordinate systems, highlighting their positions with lines and color differentiation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LogScalingExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 10, 1],",
      "            y_range=[-2, 6, 1],",
      "            tips=False,",
      "            axis_config={\"include_numbers\": True},",
      "            y_axis_config={\"scaling\": LogBase(custom_labels=True)},",
      "        )",
      "",
      "        # x_min must be > 0 because log is undefined at 0.",
      "        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)",
      "        self.add(ax, graph)"
    ],
    "topic": "Logarithmic scaling graph",
    "description": "Plots a parabola f(x)=x\u00b2 on axes with a logarithmic y-axis scaling."
  },
  {
    "code": [
      ">>> from manim import Axes",
      ">>> import numpy as np",
      ">>> ax = Axes()",
      ">>> np.around(ax.coords_to_point(1, 0, 0), 2)",
      "array([0.86, 0.  , 0.  ])",
      ">>> np.around(ax @ (1, 0, 0), 2)",
      "array([0.86, 0.  , 0.  ])",
      ">>> np.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)",
      "array([[0.  , 0.75, 0.  ],",
      "       [0.86, 0.75, 0.  ],",
      "       [0.86, 0.  , 0.  ]])",
      ">>> np.around(",
      "...     ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2",
      "... )  # Transposed version of the above",
      "array([[0.  , 0.86, 0.86],",
      "       [0.75, 0.75, 0.  ],",
      "       [0.  , 0.  , 0.  ]])"
    ],
    "topic": "coordinate transformation",
    "description": "Demonstrates conversion of coordinates to points on a 2D axis system using the Axes class."
  },
  {
    "code": [
      ">>> from manim import Axes, RIGHT",
      ">>> import numpy as np",
      ">>> ax = Axes(x_range=[0, 10, 2])",
      ">>> np.around(ax.point_to_coords(RIGHT), 2)",
      "array([5.83, 0.  ])",
      ">>> np.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)",
      "array([[5.  , 0.  ],",
      "       [5.83, 0.  ]])"
    ],
    "topic": "coordinate transformation",
    "description": "Calculates and displays the coordinates of specific points in a transformed coordinate system using Axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LineGraphExample(Scene):",
      "    def construct(self):",
      "        plane = NumberPlane(",
      "            x_range = (0, 7),",
      "            y_range = (0, 5),",
      "            x_length = 7,",
      "            axis_config={\"include_numbers\": True},",
      "        )",
      "        plane.center()",
      "        line_graph = plane.plot_line_graph(",
      "            x_values = [0, 1.5, 2, 2.8, 4, 6.25],",
      "            y_values = [1, 3, 2.25, 4, 2.5, 1.75],",
      "            line_color=GOLD_E,",
      "            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),",
      "            stroke_width = 4,",
      "        )",
      "        self.add(plane, line_graph)"
    ],
    "topic": "2D line graph",
    "description": "Displays a line graph on a number plane with specified x and y values, highlighting vertices with dots."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AxesWithDifferentTips(Scene):",
      "    def construct(self):",
      "        ax = Axes(axis_config={'tip_shape': StealthTip})",
      "        self.add(ax)"
    ],
    "topic": "axes visualization",
    "description": "Displays coordinate axes with customized arrow tips using StealthTip shape"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NumberPlaneScaled(Scene):",
      "    def construct(self):",
      "        number_plane = NumberPlane(",
      "            x_range=(-4, 11, 1),",
      "            y_range=(-3, 3, 1),",
      "            x_length=5,",
      "            y_length=2,",
      "        ).move_to(LEFT*3)",
      "",
      "        number_plane_scaled_y = NumberPlane(",
      "            x_range=(-4, 11, 1),",
      "            x_length=5,",
      "            y_length=4,",
      "        ).move_to(RIGHT*3)",
      "",
      "        self.add(number_plane)",
      "        self.add(number_plane_scaled_y)"
    ],
    "topic": "Number plane scaling",
    "description": "Displays two number planes with different y-axis scales positioned side by side."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NumberPlaneExample(Scene):",
      "    def construct(self):",
      "        number_plane = NumberPlane(",
      "            background_line_style={",
      "                \"stroke_color\": TEAL,",
      "                \"stroke_width\": 4,",
      "                \"stroke_opacity\": 0.6",
      "            }",
      "        )",
      "        self.add(number_plane)"
    ],
    "topic": "number plane visualization",
    "description": "Displays a number plane with teal grid lines and specific styling."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetYAxisLabelExample(ThreeDScene):",
      "    def construct(self):",
      "        ax = ThreeDAxes()",
      "        lab = ax.get_y_axis_label(Tex(\"$y$-label\"))",
      "        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)",
      "        self.add(ax, lab)"
    ],
    "topic": "3D axes with label",
    "description": "Displays 3D axes with a label on the y-axis and sets a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetZAxisLabelExample(ThreeDScene):",
      "    def construct(self):",
      "        ax = ThreeDAxes()",
      "        lab = ax.get_z_axis_label(Tex(\"$z$-label\"))",
      "        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)",
      "        self.add(ax, lab)"
    ],
    "topic": "3D axes labeling",
    "description": "Displays a 3D coordinate system with a labeled z-axis and sets a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetAxisLabelsExample(ThreeDScene):",
      "    def construct(self):",
      "        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)",
      "        axes = ThreeDAxes()",
      "        labels = axes.get_axis_labels(",
      "            Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)",
      "        )",
      "        self.add(axes, labels)"
    ],
    "topic": "3D axes labeling",
    "description": "Displays labeled 3D axes with a specific camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ComplexPlaneExample(Scene):",
      "    def construct(self):",
      "        plane = ComplexPlane().add_coordinates()",
      "        self.add(plane)",
      "        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)",
      "        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)",
      "        label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)",
      "        label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)",
      "        self.add(",
      "            d1,",
      "            label1,",
      "            d2,",
      "            label2,",
      "        )"
    ],
    "topic": "Complex plane visualization",
    "description": "Displays a complex plane with two labeled points representing complex numbers 2+i and -3-2i."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetXAxisLabelExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)",
      "        x_label = ax.get_x_axis_label(",
      "            Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5",
      "        )",
      "        self.add(ax, x_label)"
    ],
    "topic": "axes labeling",
    "description": "Displays a set of axes with a label for the x-axis indicating 'x-values'."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class InputToGraphPointExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        curve = ax.plot(lambda x : np.cos(x))",
      "",
      "        # move a square to PI on the cosine curve.",
      "        position = ax.input_to_graph_point(x=PI, graph=curve)",
      "        sq = Square(side_length=1, color=YELLOW).move_to(position)",
      "",
      "        self.add(ax, curve, sq)"
    ],
    "topic": "2D function graph",
    "description": "Plots a cosine curve on axes and moves a yellow square to the point at x=\u03c0 on the curve."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetRiemannRectanglesExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(y_range=[-2, 10])",
      "        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)",
      "",
      "        # the rectangles are constructed from their top right corner.",
      "        # passing an iterable to `color` produces a gradient",
      "        rects_right = ax.get_riemann_rectangles(",
      "            quadratic,",
      "            x_range=[-4, -3],",
      "            dx=0.25,",
      "            color=(TEAL, BLUE_B, DARK_BLUE),",
      "            input_sample_type=\"right\",",
      "        )",
      "",
      "        # the colour of rectangles below the x-axis is inverted",
      "        # due to show_signed_area",
      "        rects_left = ax.get_riemann_rectangles(",
      "            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW",
      "        )",
      "",
      "        bounding_line = ax.plot(",
      "            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]",
      "        )",
      "        bounded_rects = ax.get_riemann_rectangles(",
      "            bounding_line,",
      "            bounded_graph=quadratic,",
      "            dx=0.15,",
      "            x_range=[4, 5],",
      "            show_signed_area=False,",
      "            color=(MAROON_A, RED_B, PURPLE_D),",
      "        )",
      "",
      "        self.add(",
      "            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects",
      "        )"
    ],
    "topic": "Riemann rectangles visualization",
    "description": "Illustrates the approximation of areas under a quadratic curve using Riemann rectangles with different sampling methods and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetLinesToPointExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])",
      "",
      "        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)",
      "        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)",
      "        self.add(ax, lines_1, lines_2, circ)"
    ],
    "topic": "Axes and lines",
    "description": "Displays lines from axes to specific points on a circle in different colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PlotExample(Scene):",
      "    def construct(self):",
      "        # construct the axes",
      "        ax_1 = Axes(",
      "            x_range=[0.001, 6],",
      "            y_range=[-8, 2],",
      "            x_length=5,",
      "            y_length=3,",
      "            tips=False,",
      "        )",
      "        ax_2 = ax_1.copy()",
      "        ax_3 = ax_1.copy()",
      "",
      "        # position the axes",
      "        ax_1.to_corner(UL)",
      "        ax_2.to_corner(UR)",
      "        ax_3.to_edge(DOWN)",
      "        axes = VGroup(ax_1, ax_2, ax_3)",
      "",
      "        # create the logarithmic curves",
      "        def log_func(x):",
      "            return np.log(x)",
      "",
      "        # a curve without adjustments; poor interpolation.",
      "        curve_1 = ax_1.plot(log_func, color=PURE_RED)",
      "",
      "        # disabling interpolation makes the graph look choppy as not enough",
      "        # inputs are available",
      "        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)",
      "",
      "        # taking more inputs of the curve by specifying a step for the",
      "        # x_range yields expected results, but increases rendering time.",
      "        curve_3 = ax_3.plot(",
      "            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN",
      "        )",
      "",
      "        curves = VGroup(curve_1, curve_2, curve_3)",
      "",
      "        self.add(axes, curves)"
    ],
    "topic": "Logarithmic curve plotting",
    "description": "Displays three logarithmic curves with varying interpolation settings to illustrate the effects on graph smoothness and rendering time."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetVerticalLinesToGraph(Scene):",
      "    def construct(self):",
      "        ax = Axes(",
      "            x_range=[0, 8.0, 1],",
      "            y_range=[-1, 1, 0.2],",
      "            axis_config={\"font_size\": 24},",
      "        ).add_coordinates()",
      "",
      "        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)",
      "",
      "        lines = ax.get_vertical_lines_to_graph(",
      "            curve, x_range=[0, 4], num_lines=30, color=BLUE",
      "        )",
      "",
      "        self.add(ax, curve, lines)"
    ],
    "topic": "2D sine graph with lines",
    "description": "Displays a sine curve with vertical lines drawn from the x-axis to the curve over a specified range."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetHorizontalLineExample(Scene):",
      "    def construct(self):",
      "        ax = Axes().add_coordinates()",
      "        point = ax @ (-4, 1.5)",
      "",
      "        dot = Dot(point)",
      "        line = ax.get_horizontal_line(point, line_func=Line)",
      "",
      "        self.add(ax, line, dot)"
    ],
    "topic": "coordinate geometry",
    "description": "Displays a dot on a 2D coordinate plane with a horizontal line extending from it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolarGraphExample(Scene):",
      "    def construct(self):",
      "        plane = PolarPlane()",
      "        r = lambda theta: 2 * np.sin(theta * 5)",
      "        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)",
      "        self.add(plane, graph)"
    ],
    "topic": "polar graph plot",
    "description": "Displays a polar graph of the function r=2*sin(5\u03b8) on a polar plane."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CoordSysExample(Scene):",
      "    def construct(self):",
      "        # the location of the ticks depends on the x_range and y_range.",
      "        grid = Axes(",
      "            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.",
      "            y_range=[0, 1, 0.05],",
      "            x_length=9,",
      "            y_length=5.5,",
      "            axis_config={",
      "                \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),",
      "                \"font_size\": 24,",
      "            },",
      "            tips=False,",
      "        )",
      "",
      "        # Labels for the x-axis and y-axis.",
      "        y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)",
      "        x_label = grid.get_x_axis_label(\"x\")",
      "        grid_labels = VGroup(x_label, y_label)",
      "",
      "        graphs = VGroup()",
      "        for n in np.arange(1, 20 + 0.5, 0.5):",
      "            graphs += grid.plot(lambda x: x ** n, color=WHITE)",
      "            graphs += grid.plot(",
      "                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False",
      "            )",
      "",
      "        # Extra lines and labels for point (1,1)",
      "        graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)",
      "        graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)",
      "        graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)",
      "        graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid @ (1, 1, 0))",
      "        title = Title(",
      "            # spaces between braces to prevent SyntaxError",
      "            r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",",
      "            include_underline=False,",
      "            font_size=40,",
      "        )",
      "",
      "        self.add(title, graphs, grid, grid_labels)"
    ],
    "topic": "Power function graphs",
    "description": "Displays graphs of power functions y=x^n and y=x^(1/n) for n ranging from 1 to 20 on a coordinate grid, highlighting the point (1,1)."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AntiderivativeExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        graph1 = ax.plot(",
      "            lambda x: (x ** 2 - 2) / 3,",
      "            color=RED,",
      "        )",
      "        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)",
      "        self.add(ax, graph1, graph2)"
    ],
    "topic": "Antiderivative visualization",
    "description": "Displays a function and its antiderivative on the same axes with distinct colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DerivativeGraphExample(Scene):",
      "    def construct(self):",
      "        ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})",
      "",
      "        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)",
      "        curve_2 = ax.plot_derivative_graph(curve_1)",
      "        curves = VGroup(curve_1, curve_2)",
      "",
      "        label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)",
      "        label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)",
      "        labels = VGroup(label_1, label_2)",
      "",
      "        self.add(ax, curves, labels)"
    ],
    "topic": "Derivative graph comparison",
    "description": "Displays a quadratic function and its derivative on a coordinate plane with labels for each curve."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PlotSurfaceExample(ThreeDScene):",
      "    def construct(self):",
      "        resolution_fa = 16",
      "        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)",
      "        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))",
      "        def param_trig(u, v):",
      "            x = u",
      "            y = v",
      "            z = 2 * np.sin(x) + 2 * np.cos(y)",
      "            return z",
      "        trig_plane = axes.plot_surface(",
      "            param_trig,",
      "            resolution=(resolution_fa, resolution_fa),",
      "            u_range = (-3, 3),",
      "            v_range = (-3, 3),",
      "            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],",
      "            )",
      "        self.add(axes, trig_plane)"
    ],
    "topic": "3D trigonometric surface plot",
    "description": "Displays a 3D surface plot of a trigonometric function with a gradient color scale on a set of 3D axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetGraphLabelExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)",
      "        label = ax.get_graph_label(",
      "            graph=sin,",
      "            label= MathTex(r\"\\frac{\\pi}{2}\"),",
      "            x_val=PI / 2,",
      "            dot=True,",
      "            direction=UR,",
      "        )",
      "",
      "        self.add(ax, sin, label)"
    ],
    "topic": "2D sine wave plot",
    "description": "Displays a sine wave on coordinate axes with a label at x=\u03c0/2."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetAreaExample(Scene):",
      "    def construct(self):",
      "        ax = Axes().add_coordinates()",
      "        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)",
      "        area = ax.get_area(",
      "            curve,",
      "            x_range=(PI / 2, 3 * PI / 2),",
      "            color=(GREEN_B, GREEN_D),",
      "            opacity=1,",
      "        )",
      "",
      "        self.add(ax, curve, area)"
    ],
    "topic": "Area under curve",
    "description": "Displays the area under the curve of 2*sin(x) between x=\u03c0/2 and x=3\u03c0/2 on coordinate axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolarToPointExample(Scene):",
      "    def construct(self):",
      "        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)",
      "        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))",
      "        self.add(polarplane_pi)",
      "        self.add(polartopoint_vector)"
    ],
    "topic": "polar coordinate vector",
    "description": "Illustrates a vector from the origin to a point in polar coordinates on a polar plane."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ImplicitExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        a = ax.plot_implicit_curve(",
      "            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE",
      "        )",
      "        self.add(ax, a)"
    ],
    "topic": "Implicit curve plot",
    "description": "Displays an implicit curve defined by a function of x and y on coordinate axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ParametricCurveExample(Scene):",
      "    def construct(self):",
      "        ax = Axes()",
      "        cardioid = ax.plot_parametric_curve(",
      "            lambda t: np.array(",
      "                [",
      "                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),",
      "                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),",
      "                    0,",
      "                ]",
      "            ),",
      "            t_range=[0, 2 * PI],",
      "            color=\"#0FF1CE\",",
      "        )",
      "        self.add(ax, cardioid)"
    ],
    "topic": "Parametric curve plot",
    "description": "Displays a cardioid curve plotted on a set of axes using a parametric equation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TLabelExample(Scene):",
      "    def construct(self):",
      "        # defines the axes and linear function",
      "        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)",
      "        func = axes.plot(lambda x: x, color=BLUE)",
      "        # creates the T_label",
      "        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))",
      "        self.add(axes, func, t_label)"
    ],
    "topic": "Linear function plot",
    "description": "Displays a linear function f(x)=x on a set of axes with a label indicating a specific x-value."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetYAxisLabelExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)",
      "        y_label = ax.get_y_axis_label(",
      "            Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),",
      "            edge=LEFT,",
      "            direction=LEFT,",
      "            buff=0.3,",
      "        )",
      "        self.add(ax, y_label)"
    ],
    "topic": "axes labeling",
    "description": "Displays a set of axes with a rotated label for the y-axis indicating 'y-values'."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetVerticalLineExample(Scene):",
      "    def construct(self):",
      "        ax = Axes().add_coordinates()",
      "        point = ax.coords_to_point(-3.5, 2)",
      "",
      "        dot = Dot(point)",
      "        line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})",
      "",
      "        self.add(ax, line, dot)"
    ],
    "topic": "coordinate system visualization",
    "description": "Displays a vertical dashed line from a point on the coordinate axes with a dot marking the point."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetSecantSlopeGroupExample(Scene):",
      "    def construct(self):",
      "        ax = Axes(y_range=[-1, 7])",
      "        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)",
      "        slopes = ax.get_secant_slope_group(",
      "            x=2.0,",
      "            graph=graph,",
      "            dx=1.0,",
      "            dx_label=Tex(\"dx = 1.0\"),",
      "            dy_label=\"dy\",",
      "            dx_line_color=GREEN_B,",
      "            secant_line_length=4,",
      "            secant_line_color=RED_D,",
      "        )",
      "",
      "        self.add(ax, graph, slopes)"
    ],
    "topic": "Secant slope visualization",
    "description": "Illustrates the secant slope of a parabola at a specific point with labeled dx and dy lines."
  },
  {
    "code": [
      ">>> from manim import Axes",
      ">>> ax = Axes()",
      ">>> parabola = ax.plot(lambda x: x**2)",
      ">>> ax.input_to_graph_coords(x=3, graph=parabola)",
      "(3, 9)"
    ],
    "topic": "2D function graph",
    "description": "Plots a parabola f(x)=x\u00b2 on axes and calculates a point on the graph."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolarPlaneExample(Scene):",
      "    def construct(self):",
      "        polarplane_pi = PolarPlane(",
      "            azimuth_units=\"PI radians\",",
      "            size=6,",
      "            azimuth_label_font_size=33.6,",
      "            radius_config={\"font_size\": 33.6},",
      "        ).add_coordinates()",
      "        self.add(polarplane_pi)"
    ],
    "topic": "polar coordinate grid",
    "description": "Displays a polar coordinate plane with labeled azimuth angles in PI radians."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetBarLabelsExample(Scene):",
      "    def construct(self):",
      "        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])",
      "",
      "        c_bar_lbls = chart.get_bar_labels(",
      "            color=WHITE, label_constructor=MathTex, font_size=36",
      "        )",
      "",
      "        self.add(chart, c_bar_lbls)"
    ],
    "topic": "bar chart with labels",
    "description": "Displays a bar chart with values from 10 to 1, each bar labeled with its corresponding value."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ChangeBarValuesExample(Scene):",
      "    def construct(self):",
      "        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]",
      "",
      "        chart = BarChart(",
      "            values,",
      "            y_range=[-10, 10, 2],",
      "            y_axis_config={\"font_size\": 24},",
      "        )",
      "        self.add(chart)",
      "",
      "        chart.change_bar_values(list(reversed(values)))",
      "        self.add(chart.get_bar_labels(font_size=24))"
    ],
    "topic": "bar chart animation",
    "description": "Displays a bar chart with initial values and animates the bars changing to reversed values with labels."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BarChartExample(Scene):",
      "    def construct(self):",
      "        chart = BarChart(",
      "            values=[-5, 40, -10, 20, -3],",
      "            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],",
      "            y_range=[-20, 50, 10],",
      "            y_length=6,",
      "            x_length=10,",
      "            x_axis_config={\"font_size\": 36},",
      "        )",
      "",
      "        c_bar_lbls = chart.get_bar_labels(font_size=48)",
      "",
      "        self.add(chart, c_bar_lbls)"
    ],
    "topic": "bar chart visualization",
    "description": "Displays a bar chart with labeled bars representing positive and negative values."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleSampleSpace(Scene):",
      "    def construct(self):",
      "        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)",
      "        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)",
      "        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)",
      "        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)",
      "        poly_group = VGroup(poly1, poly2, poly3).arrange()",
      "        self.add(poly_group)"
    ],
    "topic": "sample space visualization",
    "description": "Displays three sample space rectangles with varying sizes, opacities, and a vertically divided section showing different probabilities."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ImplicitFunctionExample(Scene):",
      "    def construct(self):",
      "        graph = ImplicitFunction(",
      "            lambda x, y: x * y ** 2 - x ** 2 * y - 2,",
      "            color=YELLOW",
      "        )",
      "        self.add(NumberPlane(), graph)"
    ],
    "topic": "implicit function plot",
    "description": "Displays an implicit function graph on a number plane with a yellow curve."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleFunctionGraph(Scene):",
      "    def construct(self):",
      "        cos_func = FunctionGraph(",
      "            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),",
      "            color=RED,",
      "        )",
      "",
      "        sin_func_1 = FunctionGraph(",
      "            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),",
      "            color=BLUE,",
      "        )",
      "",
      "        sin_func_2 = FunctionGraph(",
      "            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),",
      "            x_range=[-4, 4],",
      "            color=GREEN,",
      "        ).move_to([0, 1, 0])",
      "",
      "        self.add(cos_func, sin_func_1, sin_func_2)"
    ],
    "topic": "2D trigonometric graphs",
    "description": "Displays overlapping cosine and sine waveforms with different frequencies and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DiscontinuousExample(Scene):",
      "    def construct(self):",
      "        ax1 = NumberPlane((-3, 3), (-4, 4))",
      "        ax2 = NumberPlane((-3, 3), (-4, 4))",
      "        VGroup(ax1, ax2).arrange()",
      "        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)",
      "        incorrect = ax1.plot(discontinuous_function, color=RED)",
      "        correct = ax2.plot(",
      "            discontinuous_function,",
      "            discontinuities=[-2, 2],  # discontinuous points",
      "            dt=0.1,  # left and right tolerance of discontinuity",
      "            color=GREEN,",
      "        )",
      "        self.add(ax1, ax2, incorrect, correct)"
    ],
    "topic": "Discontinuous function plot",
    "description": "Illustrates a discontinuous function plotted on two number planes, highlighting incorrect and corrected plots with discontinuities marked."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ThreeDParametricSpring(ThreeDScene):",
      "    def construct(self):",
      "        curve1 = ParametricFunction(",
      "            lambda u: (",
      "                1.2 * np.cos(u),",
      "                1.2 * np.sin(u),",
      "                u * 0.05",
      "            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)",
      "        ).set_shade_in_3d(True)",
      "        axes = ThreeDAxes()",
      "        self.add(axes, curve1)",
      "        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)",
      "        self.wait()"
    ],
    "topic": "3D parametric curve",
    "description": "Displays a 3D helical spring-like curve with a fixed camera orientation."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PlotParametricFunction(Scene):",
      "    def func(self, t):",
      "        return (np.sin(2 * t), np.sin(3 * t), 0)",
      "",
      "    def construct(self):",
      "        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)",
      "        self.add(func.scale(3))"
    ],
    "topic": "Parametric curve animation",
    "description": "Displays a 2D parametric curve defined by sine functions, scaled and colored red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UsefulAnnotations(Scene):",
      "    def construct(self):",
      "        m0 = Dot()",
      "        m1 = AnnotationDot()",
      "        m2 = LabeledDot(\"ii\")",
      "        m3 = LabeledDot(MathTex(r\"\\alpha\").set_color(ORANGE))",
      "        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)",
      "        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)",
      "        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)",
      "",
      "        self.add(m0, m1, m2, m3, m4, m5, m6)",
      "        for i, mobj in enumerate(self.mobjects):",
      "            mobj.shift(DOWN * (i-3))"
    ],
    "topic": "annotated points and arrows",
    "description": "Displays dots and labeled dots with curved arrows and a double arrow, arranged vertically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UnderLine(Scene):",
      "    def construct(self):",
      "        man = Tex(\"Manim\")  # Full Word",
      "        ul = Underline(man)  # Underlining the word",
      "        self.add(man, ul)"
    ],
    "topic": "text underline",
    "description": "Displays the word 'Manim' with an underline beneath it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleCross(Scene):",
      "    def construct(self):",
      "        cross = Cross()",
      "        self.add(cross)"
    ],
    "topic": "simple shape display",
    "description": "Displays a static cross shape on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SurroundingRectExample(Scene):",
      "    def construct(self):",
      "        title = Title(\"A Quote from Newton\")",
      "        quote = Text(",
      "            \"If I have seen further than others, \\n\"",
      "            \"it is by standing upon the shoulders of giants.\",",
      "            color=BLUE,",
      "        ).scale(0.75)",
      "        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)",
      "",
      "        t2 = Tex(r\"Hello World\").scale(1.5)",
      "        box2 = SurroundingRectangle(t2, corner_radius=0.2)",
      "        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)",
      "        self.add(title, mobjects)"
    ],
    "topic": "text highlighting",
    "description": "Displays a quote from Newton and 'Hello World' text, each highlighted with a surrounding rectangle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleBackgroundRectangle(Scene):",
      "    def construct(self):",
      "        circle = Circle().shift(LEFT)",
      "        circle.set_stroke(color=GREEN, width=20)",
      "        triangle = Triangle().shift(2 * RIGHT)",
      "        triangle.set_fill(PINK, opacity=0.5)",
      "        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)",
      "        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)",
      "        self.add(backgroundRectangle1)",
      "        self.add(backgroundRectangle2)",
      "        self.add(circle)",
      "        self.add(triangle)",
      "        self.play(Rotate(backgroundRectangle1, PI / 4))",
      "        self.play(Rotate(backgroundRectangle2, PI / 2))"
    ],
    "topic": "Shape rotation with background",
    "description": "Rotates background rectangles around a circle and a triangle, highlighting them with semi-transparent overlays."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IntersectionExample(Scene):",
      "    def construct(self):",
      "        sq = Square(color=RED, fill_opacity=1)",
      "        sq.move_to([-2, 0, 0])",
      "        cr = Circle(color=BLUE, fill_opacity=1)",
      "        cr.move_to([-1.3, 0.7, 0])",
      "        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)",
      "        un.move_to([1.5, 0, 0])",
      "        self.add(sq, cr, un)"
    ],
    "topic": "shape intersection",
    "description": "Displays a red square and a blue circle with their green intersection shown separately."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DifferenceExample(Scene):",
      "    def construct(self):",
      "        sq = Square(color=RED, fill_opacity=1)",
      "        sq.move_to([-2, 0, 0])",
      "        cr = Circle(color=BLUE, fill_opacity=1)",
      "        cr.move_to([-1.3, 0.7, 0])",
      "        un = Difference(sq, cr, color=GREEN, fill_opacity=1)",
      "        un.move_to([1.5, 0, 0])",
      "        self.add(sq, cr, un)"
    ],
    "topic": "shape difference visualization",
    "description": "Illustrates the difference between a red square and a blue circle, resulting in a green shape."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IntersectionExample(Scene):",
      "    def construct(self):",
      "        sq = Square(color=RED, fill_opacity=1)",
      "        sq.move_to([-2, 0, 0])",
      "        cr = Circle(color=BLUE, fill_opacity=1)",
      "        cr.move_to([-1.3, 0.7, 0])",
      "        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)",
      "        un.move_to([1.5, 0.4, 0])",
      "        self.add(sq, cr, un)"
    ],
    "topic": "shape intersection",
    "description": "Displays a red square and a blue circle with their green exclusion intersection."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UnionExample(Scene):",
      "    def construct(self):",
      "        sq = Square(color=RED, fill_opacity=1)",
      "        sq.move_to([-2, 0, 0])",
      "        cr = Circle(color=BLUE, fill_opacity=1)",
      "        cr.move_to([-1.3, 0.7, 0])",
      "        un = Union(sq, cr, color=GREEN, fill_opacity=1)",
      "        un.move_to([1.5, 0.3, 0])",
      "        self.add(sq, cr, un)"
    ],
    "topic": "geometric shape union",
    "description": "Displays a red square and a blue circle, then shows their union as a green shape."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LabeledLineExample(Scene):",
      "    def construct(self):",
      "        line = LabeledLine(",
      "            label          = '0.5',",
      "            label_position = 0.8,",
      "            label_config = {",
      "                \"font_size\" : 20",
      "            },",
      "            start=LEFT+DOWN,",
      "            end=RIGHT+UP)",
      "",
      "        line.set_length(line.get_length() * 2)",
      "        self.add(line)"
    ],
    "topic": "labeled line animation",
    "description": "Displays a labeled line with a specified label position and doubles its length."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LabeledArrowExample(Scene):",
      "    def construct(self):",
      "        l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)",
      "",
      "        self.add(l_arrow)"
    ],
    "topic": "labeled arrow",
    "description": "Displays an arrow with a label positioned at the midpoint, pointing from left to right and slightly upwards."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LabelExample(Scene):",
      "    def construct(self):",
      "        label = Label(",
      "            label=Text('Label Text', font='sans-serif'),",
      "            box_config = {",
      "                \"color\" : BLUE,",
      "                \"fill_opacity\" : 0.75",
      "            }",
      "        )",
      "        label.scale(3)",
      "        self.add(label)"
    ],
    "topic": "labeled text display",
    "description": "Displays a scaled text label with a colored background box."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LabeledPolygramExample(Scene):",
      "    def construct(self):",
      "        # Define Rings",
      "        ring1 = [",
      "            [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],",
      "            [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],",
      "            [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],",
      "            [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],",
      "            [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]",
      "        ]",
      "        ring2 = [",
      "            [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],",
      "            [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]",
      "        ]",
      "        ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]",
      "",
      "        # Create Polygons (for reference)",
      "        p1 = Polygon(*ring1, fill_opacity=0.75)",
      "        p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)",
      "        p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)",
      "",
      "        # Create Labeled Polygram",
      "        polygram = LabeledPolygram(",
      "            *[ring1, ring2, ring3],",
      "            label=Text('Pole', font='sans-serif'),",
      "            precision=0.01,",
      "        )",
      "",
      "        # Display Circle (for reference)",
      "        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)",
      "",
      "        self.add(p1, p2, p3)",
      "        self.add(polygram)",
      "        self.add(circle)"
    ],
    "topic": "Labeled polygram animation",
    "description": "Displays a labeled polygram composed of three interconnected rings with a reference circle around it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import requests",
      "import json",
      "",
      "class LabeledCountryExample(Scene):",
      "    def construct(self):",
      "        # Fetch JSON data and process arcs",
      "        data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()",
      "        arcs, transform = data['arcs'], data['transform']",
      "        sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]",
      "        ssarcs = sorted(sarcs, key=len, reverse=True)[:1]",
      "",
      "        # Compute Bounding Box",
      "        points = np.concatenate(ssarcs)",
      "        mins, maxs = np.min(points, axis=0), np.max(points, axis=0)",
      "",
      "        # Build Axes",
      "        ax = Axes(",
      "            x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,",
      "            y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,",
      "            tips=False",
      "        )",
      "",
      "        # Adjust Coordinates",
      "        array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]",
      "",
      "        # Add Polygram",
      "        polygram = LabeledPolygram(",
      "            *array,",
      "            label=Text('USA', font='sans-serif'),",
      "            precision=0.01,",
      "            fill_color=BLUE,",
      "            stroke_width=0,",
      "            fill_opacity=0.75",
      "        )",
      "",
      "        # Display Circle (for reference)",
      "        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)",
      "",
      "        self.add(ax)",
      "        self.add(polygram)",
      "        self.add(circle)"
    ],
    "topic": "USA map visualization",
    "description": "Displays a labeled polygram of the USA map with a reference circle on coordinate axes."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ElbowExample(Scene):",
      "    def construct(self):",
      "        elbow_1 = Elbow()",
      "        elbow_2 = Elbow(width=2.0)",
      "        elbow_3 = Elbow(width=2.0, angle=5*PI/4)",
      "",
      "        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)",
      "        self.add(elbow_group)"
    ],
    "topic": "geometric shapes",
    "description": "Displays three elbow shapes with varying sizes and angles arranged in a group."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TangentLineExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=2)",
      "        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right",
      "        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left",
      "        self.add(circle, line_1, line_2)"
    ],
    "topic": "Tangent lines on circle",
    "description": "Displays a circle with two tangent lines at specified points on its circumference."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FilledAngle(Scene):",
      "    def construct(self):",
      "        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)",
      "        l2 = (",
      "            Line(ORIGIN, 2 * UP + RIGHT)",
      "            .set_color(GREEN)",
      "            .rotate(-20 * DEGREES, about_point=ORIGIN)",
      "        )",
      "        norm = l1.get_length()",
      "        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)",
      "        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)",
      "        q1 = a1.points #  save all coordinates of points of angle a1",
      "        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)",
      "        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point",
      "        mfill = VMobject().set_color(ORANGE)",
      "        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)",
      "        self.add(l1, l2)",
      "        self.add(mfill)"
    ],
    "topic": "angle visualization",
    "description": "Illustrates two intersecting lines with a filled angle between them, highlighting the angle in green."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AngleFromThreePointsExample(Scene):",
      "    def construct(self):",
      "        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)",
      "        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)",
      "        self.add(red_angle, sample_angle)"
    ],
    "topic": "angle visualization",
    "description": "Displays two angles formed by three points with different styles and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RightArcAngleExample(Scene):",
      "    def construct(self):",
      "        line1 = Line( LEFT, RIGHT )",
      "        line2 = Line( DOWN, UP )",
      "        rightarcangles = [",
      "            Angle(line1, line2, dot=True),",
      "            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),",
      "            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),",
      "            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),",
      "        ]",
      "        plots = VGroup()",
      "        for angle in rightarcangles:",
      "            plot=VGroup(line1.copy(),line2.copy(), angle)",
      "            plots.add(plot)",
      "        plots.arrange(buff=1.5)",
      "        self.add(plots)"
    ],
    "topic": "angle visualization",
    "description": "Displays multiple angles formed by two intersecting lines with different styles and positions, highlighting the angles with dots."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetValueExample(Scene):",
      "    def construct(self):",
      "        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)",
      "        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)",
      "",
      "        angle = Angle(line1, line2, radius=0.4)",
      "",
      "        value = DecimalNumber(angle.get_value(degrees=True), unit=r\"^{\\circ}\")",
      "        value.next_to(angle, UR)",
      "",
      "        self.add(line1, line2, angle, value)"
    ],
    "topic": "angle measurement",
    "description": "Displays two intersecting lines with the angle between them labeled in degrees."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AngleExample(Scene):",
      "    def construct(self):",
      "        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )",
      "        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )",
      "        angles = [",
      "            Angle(line1, line2),",
      "            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),",
      "            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),",
      "            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),",
      "            Angle(line1, line2, other_angle=True),",
      "            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),",
      "            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),",
      "            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),",
      "        ]",
      "        plots = VGroup()",
      "        for angle in angles:",
      "            plot=VGroup(line1.copy(),line2.copy(), angle)",
      "            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))",
      "        plots.arrange_in_grid(rows=2,buff=1)",
      "        self.add(plots)"
    ],
    "topic": "angle visualization",
    "description": "Displays multiple angles formed by two intersecting lines, highlighting different quadrants and angle properties."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArrowExample(Scene):",
      "    def construct(self):",
      "        left_group = VGroup()",
      "        # As buff increases, the size of the arrow decreases.",
      "        for buff in np.arange(0, 2.2, 0.45):",
      "            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)",
      "        # Required to arrange arrows.",
      "        left_group.arrange(DOWN)",
      "        left_group.move_to(4 * LEFT)",
      "",
      "        middle_group = VGroup()",
      "        # As max_stroke_width_to_length_ratio gets bigger,",
      "        # the width of stroke increases.",
      "        for i in np.arange(0, 5, 0.5):",
      "            middle_group += Arrow(max_stroke_width_to_length_ratio=i)",
      "        middle_group.arrange(DOWN)",
      "",
      "        UR_group = VGroup()",
      "        # As max_tip_length_to_length_ratio increases,",
      "        # the length of the tip increases.",
      "        for i in np.arange(0, 0.3, 0.1):",
      "            UR_group += Arrow(max_tip_length_to_length_ratio=i)",
      "        UR_group.arrange(DOWN)",
      "        UR_group.move_to(4 * RIGHT + 2 * UP)",
      "",
      "        DR_group = VGroup()",
      "        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)",
      "        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)",
      "        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)",
      "        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)",
      "        DR_group.arrange(DOWN)",
      "        DR_group.move_to(4 * RIGHT + 2 * DOWN)",
      "",
      "        self.add(left_group, middle_group, UR_group, DR_group)"
    ],
    "topic": "Arrow properties demonstration",
    "description": "Illustrates various arrow properties by showing groups of arrows with different buffs, stroke widths, tip lengths, and tip shapes arranged on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "from manim.mobject.geometry.tips import ArrowSquareTip",
      "class ArrowExample(Scene):",
      "    def construct(self):",
      "        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)",
      "        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)",
      "        g1 = Group(arrow_1, arrow_2)",
      "",
      "        # the effect of buff",
      "        square = Square(color=MAROON_A)",
      "        arrow_3 = Arrow(start=LEFT, end=RIGHT)",
      "        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)",
      "        g2 = Group(arrow_3, arrow_4, square)",
      "",
      "        # a shorter arrow has a shorter tip and smaller stroke width",
      "        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)",
      "        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)",
      "        g3 = Group(arrow_5, arrow_6)",
      "",
      "        self.add(Group(g1, g2, g3).arrange(buff=2))"
    ],
    "topic": "Arrow visualization",
    "description": "Demonstrates various arrow configurations including different tips, lengths, and buff effects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DashedLineExample(Scene):",
      "    def construct(self):",
      "        # dash_length increased",
      "        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)",
      "        # normal",
      "        dashed_2 = DashedLine(config.left_side, config.right_side)",
      "        # dashed_ratio decreased",
      "        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)",
      "        self.add(dashed_1, dashed_2, dashed_3)"
    ],
    "topic": "Dashed line variations",
    "description": "Displays three dashed lines with different dash lengths and ratios, positioned vertically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RightAngleExample(Scene):",
      "    def construct(self):",
      "        line1 = Line( LEFT, RIGHT )",
      "        line2 = Line( DOWN, UP )",
      "        rightangles = [",
      "            RightAngle(line1, line2),",
      "            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),",
      "            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),",
      "            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),",
      "        ]",
      "        plots = VGroup()",
      "        for rightangle in rightangles:",
      "            plot=VGroup(line1.copy(),line2.copy(), rightangle)",
      "            plots.add(plot)",
      "        plots.arrange(buff=1.5)",
      "        self.add(plots)"
    ],
    "topic": "right angle demonstration",
    "description": "Displays multiple right angles formed by two intersecting lines with varying styles and positions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LineExample(Scene):",
      "    def construct(self):",
      "        line1 = Line(LEFT*2, RIGHT*2)",
      "        line2 = Line(LEFT*2, RIGHT*2, buff=0.5)",
      "        line3 = Line(LEFT*2, RIGHT*2, path_arc=PI/2)",
      "        grp = VGroup(line1,line2,line3).arrange(DOWN, buff=2)",
      "        self.add(grp)"
    ],
    "topic": "Line arrangement",
    "description": "Displays three lines arranged vertically with different configurations and spacing."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class LineExample(Scene):",
      "    def construct(self):",
      "        d = VGroup()",
      "        for i in range(0,10):",
      "            d.add(Dot())",
      "        d.arrange_in_grid(buff=1)",
      "        self.add(d)",
      "        l= Line(d[0], d[1])",
      "        self.add(l)",
      "        self.wait()",
      "        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())",
      "        self.wait()",
      "        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())",
      "        self.wait()"
    ],
    "topic": "dynamic line movement",
    "description": "Animates a line connecting different dots in a grid, changing its endpoints sequentially."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DoubleArrowExample2(Scene):",
      "    def construct(self):",
      "        box = Square()",
      "        p1 = box.get_left()",
      "        p2 = box.get_right()",
      "        d1 = DoubleArrow(p1, p2, buff=0)",
      "        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)",
      "        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)",
      "        Group(d1, d2, d3).arrange(DOWN)",
      "        self.add(box, d1, d2, d3)"
    ],
    "topic": "Double arrow demonstration",
    "description": "Displays a square with three double arrows of varying tip lengths and colors arranged below it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "from manim.mobject.geometry.tips import ArrowCircleFilledTip",
      "class DoubleArrowExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=2.0)",
      "        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())",
      "        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)",
      "        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)",
      "        self.add(group)"
    ],
    "topic": "Double arrow on circle",
    "description": "Displays a circle with a double-headed arrow across its diameter and another double-headed arrow with filled tips arranged above it."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class VectorExample(Scene):",
      "    def construct(self):",
      "        plane = NumberPlane()",
      "        vector_1 = Vector([1,2])",
      "        vector_2 = Vector([-5,-2])",
      "        self.add(plane, vector_1, vector_2)"
    ],
    "topic": "2D vector visualization",
    "description": "Displays two vectors on a 2D number plane with their initial positions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class VectorCoordinateLabel(Scene):",
      "    def construct(self):",
      "        plane = NumberPlane()",
      "",
      "        vec_1 = Vector([1, 2])",
      "        vec_2 = Vector([-3, -2])",
      "        label_1 = vec_1.coordinate_label()",
      "        label_2 = vec_2.coordinate_label(color=YELLOW)",
      "",
      "        self.add(plane, vec_1, vec_2, label_1, label_2)"
    ],
    "topic": "vector coordinate labels",
    "description": "Displays two vectors on a number plane with their coordinate labels, one highlighted in yellow."
  },
  {
    "code": [
      ">>> from manim import Arrow",
      ">>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)",
      ">>> arrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output",
      "array([1.65, 0.  , 0.  ])"
    ],
    "topic": "arrow creation",
    "description": "Creates a 2D arrow pointing right from the origin with a specified tip position."
  },
  {
    "code": [
      ">>> from manim import Arrow",
      ">>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))",
      ">>> round(arrow.tip.length, 3)",
      "0.35"
    ],
    "topic": "arrow creation",
    "description": "Creates an arrow pointing from the origin to the point (1, 2, 0) and checks the length of its tip."
  },
  {
    "code": [
      ">>> from manim import Arrow",
      ">>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)",
      ">>> arrow.tip.vector.round(2) + 0.",
      "array([0.25, 0.25, 0.  ])"
    ],
    "topic": "2D arrow creation",
    "description": "Creates an arrow pointing from the origin to the point (2, 2) in a 2D plane."
  },
  {
    "code": [
      "from manim import *",
      "",
      ">>> from manim import RegularPolygon, Arrow",
      ">>> class MyCustomArrowTip(ArrowTip, RegularPolygon):",
      "...     def __init__(self, length=0.35, **kwargs):",
      "...         RegularPolygon.__init__(self, n=5, **kwargs)",
      "...         self.width = length",
      "...         self.stretch_to_fit_height(length)",
      ">>> arr = Arrow(",
      "...     np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip",
      "... )",
      ">>> isinstance(arr.tip, RegularPolygon)",
      "True",
      ">>> from manim import Scene, Create",
      ">>> class CustomTipExample(Scene):",
      "...     def construct(self):",
      "...         self.play(Create(arr))"
    ],
    "topic": "custom arrow animation",
    "description": "Animates an arrow with a custom pentagonal tip moving from one point to another."
  },
  {
    "code": [
      ">>> from manim import Arrow",
      ">>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)",
      ">>> bool(round(arrow.tip.tip_angle, 5) == round(PI/4, 5))",
      "True"
    ],
    "topic": "arrow creation",
    "description": "Creates an arrow pointing diagonally with a tip angle of 45 degrees."
  },
  {
    "code": [
      ">>> from manim import Arrow",
      ">>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)",
      ">>> arrow.tip.tip_point.round(2) + 0.",
      "array([2., 0., 0.])"
    ],
    "topic": "arrow creation",
    "description": "Creates a horizontal arrow pointing right from the origin to the point (2, 0, 0)."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArrowTipsShowcase(Scene):",
      "    def construct(self):",
      "        tip_names = [",
      "            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',",
      "            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'",
      "        ]",
      "",
      "        big_arrows = [",
      "            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),",
      "            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),",
      "            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),",
      "            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),",
      "",
      "            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),",
      "            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),",
      "            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),",
      "            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)",
      "        ]",
      "",
      "        small_arrows = (",
      "            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows",
      "        )",
      "",
      "        labels = (",
      "            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))",
      "        )",
      "",
      "        self.add(*big_arrows, *small_arrows, *labels)"
    ],
    "topic": "Arrow tip showcase",
    "description": "Displays various arrow tips with corresponding labels, showing both large and scaled-down versions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CutoutExample(Scene):",
      "    def construct(self):",
      "        s1 = Square().scale(2.5)",
      "        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)",
      "        s3 = Square().shift(UP + RIGHT).scale(0.5)",
      "        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)",
      "        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)",
      "        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)",
      "        self.play(Write(c), run_time=4)",
      "        self.wait()"
    ],
    "topic": "geometric cutout animation",
    "description": "Displays a blue cutout of various shapes from a large square with a red outline using the Write effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RegularPolygonExample(Scene):",
      "    def construct(self):",
      "        poly_1 = RegularPolygon(n=6)",
      "        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)",
      "        poly_3 = RegularPolygon(n=10, color=RED)",
      "",
      "        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)",
      "        self.add(poly_group)"
    ],
    "topic": "Regular polygons display",
    "description": "Displays three regular polygons with different configurations arranged in a group."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ConvexHullExample(Scene):",
      "    def construct(self):",
      "        points = [",
      "            [-2.35, -2.25, 0],",
      "            [1.65, -2.25, 0],",
      "            [2.65, -0.25, 0],",
      "            [1.65, 1.75, 0],",
      "            [-0.35, 2.75, 0],",
      "            [-2.35, 0.75, 0],",
      "            [-0.35, -1.25, 0],",
      "            [0.65, -0.25, 0],",
      "            [-1.35, 0.25, 0],",
      "            [0.15, 0.75, 0]",
      "        ]",
      "        hull = ConvexHull(*points, color=BLUE)",
      "        dots = VGroup(*[Dot(point) for point in points])",
      "        self.add(hull)",
      "        self.add(dots)"
    ],
    "topic": "Convex hull visualization",
    "description": "Displays a set of points and their convex hull in 2D space with dots and a blue outline."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SquareExample(Scene):",
      "    def construct(self):",
      "        square_1 = Square(side_length=2.0).shift(DOWN)",
      "        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)",
      "        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)",
      "        self.add(square_1, square_2, square_3)"
    ],
    "topic": "stacked squares",
    "description": "Displays three squares of decreasing size stacked vertically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolygonExample(Scene):",
      "    def construct(self):",
      "        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])",
      "        position_list = [",
      "            [4, 1, 0],  # middle right",
      "            [4, -2.5, 0],  # bottom right",
      "            [0, -2.5, 0],  # bottom left",
      "            [0, 3, 0],  # top left",
      "            [2, 1, 0],  # middle",
      "            [4, 3, 0],  # top right",
      "        ]",
      "        square_and_triangles = Polygon(*position_list, color=PURPLE_B)",
      "        self.add(isosceles, square_and_triangles)"
    ],
    "topic": "polygon shapes",
    "description": "Displays an isosceles triangle and a complex polygon with specified vertex positions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TriangleExample(Scene):",
      "    def construct(self):",
      "        triangle_1 = Triangle()",
      "        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)",
      "        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)",
      "        self.add(tri_group)"
    ],
    "topic": "Triangle arrangement",
    "description": "Displays two triangles of different sizes and orientations arranged side by side."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RegularPolygramExample(Scene):",
      "    def construct(self):",
      "        pentagram = RegularPolygram(5, radius=2)",
      "        self.add(pentagram)"
    ],
    "topic": "geometric shape display",
    "description": "Displays a static pentagram with a specified radius on the scene"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RectangleExample(Scene):",
      "    def construct(self):",
      "        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)",
      "        rect2 = Rectangle(width=1.0, height=4.0)",
      "        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)",
      "        rect3.grid_lines.set_stroke(width=1)",
      "",
      "        rects = Group(rect1, rect2, rect3).arrange(buff=1)",
      "        self.add(rects)"
    ],
    "topic": "Rectangle arrangement",
    "description": "Displays three rectangles of different sizes arranged horizontally with a specified buffer space between them."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DifferentDensitiesExample(Scene):",
      "    def construct(self):",
      "        density_2 = Star(7, outer_radius=2, density=2, color=RED)",
      "        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)",
      "",
      "        self.add(VGroup(density_2, density_3).arrange(RIGHT))"
    ],
    "topic": "star shapes comparison",
    "description": "Displays two star shapes with different densities arranged side by side for comparison."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class StarExample(Scene):",
      "    def construct(self):",
      "        pentagram = RegularPolygram(5, radius=2)",
      "        star = Star(outer_radius=2, color=RED)",
      "",
      "        self.add(pentagram)",
      "        self.play(Create(star), run_time=3)",
      "        self.play(FadeOut(star), run_time=2)"
    ],
    "topic": "star shape animation",
    "description": "Displays a pentagram and animates a red star appearing and then fading out."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import numpy as np",
      "",
      "class PolygramExample(Scene):",
      "    def construct(self):",
      "        hexagram = Polygram(",
      "            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],",
      "            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],",
      "        )",
      "        self.add(hexagram)",
      "",
      "        dot = Dot()",
      "        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)",
      "        self.remove(dot)",
      "        self.wait()"
    ],
    "topic": "polygon path animation",
    "description": "Animates a dot moving along the edges of a hexagram-shaped polygram."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PolygramRoundCorners(Scene):",
      "    def construct(self):",
      "        star = Star(outer_radius=2)",
      "",
      "        shapes = VGroup(star)",
      "        shapes.add(star.copy().round_corners(radius=0.1))",
      "        shapes.add(star.copy().round_corners(radius=0.25))",
      "",
      "        shapes.arrange(RIGHT)",
      "        self.add(shapes)"
    ],
    "topic": "star shape transformation",
    "description": "Displays a star shape with progressively rounded corners arranged in a row."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RoundedRectangleExample(Scene):",
      "    def construct(self):",
      "        rect_1 = RoundedRectangle(corner_radius=0.5)",
      "        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)",
      "",
      "        rect_group = Group(rect_1, rect_2).arrange(buff=1)",
      "        self.add(rect_group)"
    ],
    "topic": "rounded rectangles display",
    "description": "Displays two rounded rectangles of different sizes arranged side by side."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnnulusExample(Scene):",
      "    def construct(self):",
      "        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)",
      "        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)",
      "        self.add(annulus_1, annulus_2)"
    ],
    "topic": "Annulus shapes display",
    "description": "Displays two annuli, one above the other, with different sizes and colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DotExample(Scene):",
      "    def construct(self):",
      "        dot1 = Dot(point=LEFT, radius=0.08)",
      "        dot2 = Dot(point=ORIGIN)",
      "        dot3 = Dot(point=RIGHT)",
      "        self.add(dot1,dot2,dot3)"
    ],
    "topic": "dot placement",
    "description": "Displays three dots positioned at left, center, and right on a horizontal line."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleSector(Scene):",
      "    def construct(self):",
      "        sector = Sector(radius=2)",
      "        sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])",
      "        sector.set_color(RED)",
      "        sector2.set_color(PINK)",
      "        self.add(sector, sector2)"
    ],
    "topic": "sector visualization",
    "description": "Displays two colored sectors with different radii and angles positioned on the scene."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SeveralArcPolygons(Scene):",
      "    def construct(self):",
      "        a = [0, 0, 0]",
      "        b = [2, 0, 0]",
      "        c = [0, 2, 0]",
      "        ap1 = ArcPolygon(a, b, c, radius=2)",
      "        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)",
      "        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})",
      "        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,",
      "                                    arc_config=[{'radius': 1.7, 'color': RED},",
      "                                    {'angle': 20*DEGREES, 'color': BLUE},",
      "                                    {'radius': 1}])",
      "        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()",
      "        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])",
      "        self.wait()"
    ],
    "topic": "Arc polygon variations",
    "description": "Displays four arc polygons with different configurations of radii, angles, and colors arranged in a group."
  },
  {
    "code": [
      ">>> from manim import ArcPolygon",
      ">>> ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])",
      ">>> ap.arcs",
      "[ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]"
    ],
    "topic": "polygon with arcs",
    "description": "Creates a triangular shape with curved edges using arc segments."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BezierSplineExample(Scene):",
      "    def construct(self):",
      "        p1 = np.array([-3, 1, 0])",
      "        p1b = p1 + [1, 0, 0]",
      "        d1 = Dot(point=p1).set_color(BLUE)",
      "        l1 = Line(p1, p1b)",
      "        p2 = np.array([3, -1, 0])",
      "        p2b = p2 - [1, 0, 0]",
      "        d2 = Dot(point=p2).set_color(RED)",
      "        l2 = Line(p2, p2b)",
      "        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)",
      "        self.add(l1, d1, l2, d2, bezier)"
    ],
    "topic": "Bezier curve demonstration",
    "description": "Illustrates a cubic Bezier curve with control points and tangent lines in a 2D plane."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnnularSectorExample(Scene):",
      "    def construct(self):",
      "        # Changes background color to clearly visualize changes in fill_opacity.",
      "        self.camera.background_color = WHITE",
      "",
      "        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.",
      "        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)",
      "",
      "        # Different inner_radius and outer_radius than the default.",
      "        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)",
      "",
      "        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.",
      "        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)",
      "",
      "        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.",
      "        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)",
      "",
      "        self.add(s1, s2, s3, s4)"
    ],
    "topic": "Annular sector visualization",
    "description": "Displays four annular sectors with varying radii, angles, and colors on a white background to demonstrate different properties like fill opacity and angle direction."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SeveralLabeledDots(Scene):",
      "    def construct(self):",
      "        sq = Square(fill_color=RED, fill_opacity=1)",
      "        self.add(sq)",
      "        dot1 = LabeledDot(Tex(\"42\", color=RED))",
      "        dot2 = LabeledDot(MathTex(\"a\", color=GREEN))",
      "        dot3 = LabeledDot(Text(\"ii\", color=BLUE))",
      "        dot4 = LabeledDot(\"3\")",
      "        dot1.next_to(sq, UL)",
      "        dot2.next_to(sq, UR)",
      "        dot3.next_to(sq, DL)",
      "        dot4.next_to(sq, DR)",
      "        self.add(dot1, dot2, dot3, dot4)"
    ],
    "topic": "labeled dots around square",
    "description": "Displays a red square with four labeled dots positioned at its corners, each labeled with different text or math symbols."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcBetweenPointsExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=2, stroke_color=GREY)",
      "        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)",
      "        dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)",
      "        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)",
      "        dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)",
      "        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)",
      "        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)",
      "        self.play(Create(arc))"
    ],
    "topic": "Arc and points visualization",
    "description": "Displays a circle with two labeled points and animates an arc connecting them."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CircleFromPointsExample(Scene):",
      "    def construct(self):",
      "        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)",
      "        dots = VGroup(",
      "            Dot(LEFT),",
      "            Dot(LEFT + UP),",
      "            Dot(UP * 2),",
      "        )",
      "        self.add(NumberPlane(), circle, dots)"
    ],
    "topic": "circle from points",
    "description": "Displays a circle defined by three points with dots marking each point on a coordinate plane"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PointAtAngleExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=2.0)",
      "        p1 = circle.point_at_angle(PI/2)",
      "        p2 = circle.point_at_angle(270*DEGREES)",
      "",
      "        s1 = Square(side_length=0.25).move_to(p1)",
      "        s2 = Square(side_length=0.25).move_to(p2)",
      "        self.add(circle, s1, s2)"
    ],
    "topic": "circle point demonstration",
    "description": "Displays a circle with two squares positioned at specific angles on its circumference."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CircleExample(Scene):",
      "    def construct(self):",
      "        circle_1 = Circle(radius=1.0)",
      "        circle_2 = Circle(radius=1.5, color=GREEN)",
      "        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)",
      "",
      "        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)",
      "        self.add(circle_group)"
    ],
    "topic": "Circle arrangement",
    "description": "Displays three circles of different sizes and colors arranged in a horizontal line."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CircleSurround(Scene):",
      "    def construct(self):",
      "        triangle1 = Triangle()",
      "        circle1 = Circle().surround(triangle1)",
      "        group1 = Group(triangle1,circle1) # treat the two mobjects as one",
      "",
      "        line2 = Line()",
      "        circle2 = Circle().surround(line2, buffer_factor=2.0)",
      "        group2 = Group(line2,circle2)",
      "",
      "        # buffer_factor < 1, so the circle is smaller than the square",
      "        square3 = Square()",
      "        circle3 = Circle().surround(square3, buffer_factor=0.5)",
      "        group3 = Group(square3, circle3)",
      "",
      "        group = Group(group1, group2, group3).arrange(buff=1)",
      "        self.add(group)"
    ],
    "topic": "Geometric shapes arrangement",
    "description": "Displays a triangle, line, and square each surrounded by a circle with varying buffer factors, arranged in a group."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class EllipseExample(Scene):",
      "    def construct(self):",
      "        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)",
      "        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)",
      "        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)",
      "        self.add(ellipse_group)"
    ],
    "topic": "ellipse arrangement",
    "description": "Displays two ellipses of different sizes and colors arranged side by side with a specified buffer space."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcExample(Scene):",
      "    def construct(self):",
      "        self.add(Arc(angle=PI))"
    ],
    "topic": "arc drawing",
    "description": "Displays a semicircular arc spanning 180 degrees."
  },
  {
    "code": [
      ">>> from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints",
      ">>> ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())",
      ">>> ap.arcs",
      "[Arc, ArcBetweenPoints, Arc]"
    ],
    "topic": "arc polygon construction",
    "description": "Constructs a polygon using arcs and an arc between two points."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcPolygonExample2(Scene):",
      "    def construct(self):",
      "        arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,",
      "            \"fill_opacity\": 0.5, \"color\": GREEN}",
      "        poly_conf = {\"color\": None}",
      "        a = [-1, 0, 0]",
      "        b = [1, 0, 0]",
      "        c = [0, np.sqrt(3), 0]",
      "        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)",
      "        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)",
      "        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)",
      "        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)",
      "        self.play(FadeIn(reuleaux_tri))",
      "        self.wait(2)"
    ],
    "topic": "geometric shape animation",
    "description": "Displays a Reuleaux triangle formed by arcs with a fade-in effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArcPolygonExample(Scene):",
      "    def construct(self):",
      "        arc_conf = {\"stroke_width\": 0}",
      "        poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,",
      "              \"fill_opacity\": 1, \"color\": PURPLE}",
      "        a = [-1, 0, 0]",
      "        b = [1, 0, 0]",
      "        c = [0, np.sqrt(3), 0]",
      "        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)",
      "        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)",
      "        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)",
      "        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)",
      "        self.play(FadeIn(reuleaux_tri))",
      "        self.wait(2)"
    ],
    "topic": "geometric shape animation",
    "description": "Displays a Reuleaux triangle by fading in an arc-based polygon with specified styling."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class HelloWorld(Scene):",
      "    def construct(self):",
      "        text = Text('Hello world').scale(3)",
      "        self.add(text)"
    ],
    "topic": "static text display",
    "description": "Displays the text 'Hello world' scaled up on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TextAlignment(Scene):",
      "    def construct(self):",
      "        title = Text(\"K-means clustering and Logistic Regression\", color=WHITE)",
      "        title.scale(0.75)",
      "        self.add(title.to_edge(UP))",
      "",
      "        t1 = Text(\"1. Measuring\").set_color(WHITE)",
      "",
      "        t2 = Text(\"2. Clustering\").set_color(WHITE)",
      "",
      "        t3 = Text(\"3. Regression\").set_color(WHITE)",
      "",
      "        t4 = Text(\"4. Prediction\").set_color(WHITE)",
      "",
      "        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)",
      "        x.set_opacity(0.5)",
      "        x.submobjects[1].set_opacity(1)",
      "        self.add(x)"
    ],
    "topic": "text alignment",
    "description": "Displays a title and a list of steps with one highlighted, demonstrating text alignment and opacity effects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class VariablesWithValueTracker(Scene):",
      "    def construct(self):",
      "        var = 0.5",
      "        on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)",
      "",
      "        # You can also change the colours for the label and value",
      "        on_screen_var.label.set_color(RED)",
      "        on_screen_var.value.set_color(GREEN)",
      "",
      "        self.play(Write(on_screen_var))",
      "        # The above line will just display the variable with",
      "        # its initial value on the screen. If you also wish to",
      "        # update it, you can do so by accessing the `tracker` attribute",
      "        self.wait()",
      "        var_tracker = on_screen_var.tracker",
      "        var = 10.5",
      "        self.play(var_tracker.animate.set_value(var))",
      "        self.wait()",
      "",
      "        int_var = 0",
      "        on_screen_int_var = Variable(",
      "            int_var, Text(\"int_var\"), var_type=Integer",
      "        ).next_to(on_screen_var, DOWN)",
      "        on_screen_int_var.label.set_color(RED)",
      "        on_screen_int_var.value.set_color(GREEN)",
      "",
      "        self.play(Write(on_screen_int_var))",
      "        self.wait()",
      "        var_tracker = on_screen_int_var.tracker",
      "        var = 10.5",
      "        self.play(var_tracker.animate.set_value(var))",
      "        self.wait()",
      "",
      "        # If you wish to have a somewhat more complicated label for your",
      "        # variable with subscripts, superscripts, etc. the default class",
      "        # for the label is MathTex",
      "        subscript_label_var = 10",
      "        on_screen_subscript_var = Variable(subscript_label_var, \"{a}_{i}\").next_to(",
      "            on_screen_int_var, DOWN",
      "        )",
      "        self.play(Write(on_screen_subscript_var))",
      "        self.wait()"
    ],
    "topic": "variable tracking",
    "description": "Displays and updates variables with labels and values, showcasing changes in real-time."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class VariableExample(Scene):",
      "    def construct(self):",
      "        start = 2.0",
      "",
      "        x_var = Variable(start, 'x', num_decimal_places=3)",
      "        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)",
      "        Group(x_var, sqr_var).arrange(DOWN)",
      "",
      "        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))",
      "",
      "        self.add(x_var, sqr_var)",
      "        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)",
      "        self.wait(0.1)"
    ],
    "topic": "Variable tracking",
    "description": "Animates the change of a variable and its square as the variable value increases linearly."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MovingSquareWithUpdaters(Scene):",
      "    def construct(self):",
      "        decimal = DecimalNumber(",
      "            0,",
      "            show_ellipsis=True,",
      "            num_decimal_places=3,",
      "            include_sign=True,",
      "            unit=r\"\\text{M-Units}\",",
      "            unit_buff_per_font_unit=0.003",
      "        )",
      "        square = Square().to_edge(UP)",
      "",
      "        decimal.add_updater(lambda d: d.next_to(square, RIGHT))",
      "        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))",
      "        self.add(square, decimal)",
      "        self.play(",
      "            square.animate.to_edge(DOWN),",
      "            rate_func=there_and_back,",
      "            run_time=5,",
      "        )",
      "        self.wait()"
    ],
    "topic": "moving square with updater",
    "description": "Displays a square moving from top to bottom with an updating decimal showing its vertical position."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IntegerExample(Scene):",
      "    def construct(self):",
      "        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))",
      "        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))",
      "        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))",
      "        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))"
    ],
    "topic": "integer display",
    "description": "Displays several integers with different positions, scales, and colors on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class CodeFromString(Scene):",
      "    def construct(self):",
      "        code = '''from manim import Scene, Square",
      "",
      "class FadeInSquare(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        self.play(FadeIn(s))",
      "        self.play(s.animate.scale(2))",
      "        self.wait()'''",
      "",
      "        rendered_code = Code(",
      "            code_string=code,",
      "            language=\"python\",",
      "            background=\"window\",",
      "            background_config={\"stroke_color\": \"maroon\"},",
      "        )",
      "        self.add(rendered_code)"
    ],
    "topic": "code display",
    "description": "Displays Python code for animating a square with a fade-in and scaling effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "import manim",
      "",
      "class TitleExample(Scene):",
      "    def construct(self):",
      "        banner = ManimBanner()",
      "        title = Title(f\"Manim version {manim.__version__}\")",
      "        self.add(banner, title)"
    ],
    "topic": "title display",
    "description": "Displays the Manim logo alongside the current version number as a title."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BulletedListExample(Scene):",
      "    def construct(self):",
      "        blist = BulletedList(\"Item 1\", \"Item 2\", \"Item 3\", height=2, width=2)",
      "        blist.set_color_by_tex(\"Item 1\", RED)",
      "        blist.set_color_by_tex(\"Item 2\", GREEN)",
      "        blist.set_color_by_tex(\"Item 3\", BLUE)",
      "        self.add(blist)"
    ],
    "topic": "colored bulleted list",
    "description": "Displays a bulleted list with each item in a different color."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Formula(Scene):",
      "    def construct(self):",
      "        t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")",
      "        self.add(t)"
    ],
    "topic": "mathematical equation display",
    "description": "Displays the integral of a derivative equation using MathTex."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TextColorExample(Scene):",
      "    def construct(self):",
      "        text1 = Text('Hello world', color=BLUE).scale(3)",
      "        text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)",
      "        self.add(text1, text2)"
    ],
    "topic": "text color demonstration",
    "description": "Displays two lines of text with different color effects, one solid blue and the other with a blue to green gradient."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class PangoRender(Scene):",
      "    def construct(self):",
      "        morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")",
      "        self.play(Write(morning))",
      "        self.wait(2)"
    ],
    "topic": "text animation",
    "description": "Animates the Tamil word '\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd' appearing with the Write effect."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TextItalicAndBoldExample(Scene):",
      "    def construct(self):",
      "        text1 = Text(\"Hello world\", slant=ITALIC)",
      "        text2 = Text(\"Hello world\", t2s={'world':ITALIC})",
      "        text3 = Text(\"Hello world\", weight=BOLD)",
      "        text4 = Text(\"Hello world\", t2w={'world':BOLD})",
      "        text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)",
      "        text6 = Text(",
      "            \"Visit us at docs.manim.community\",",
      "            t2c={\"docs.manim.community\": YELLOW},",
      "            disable_ligatures=True,",
      "       )",
      "        text6.scale(1.3).shift(DOWN)",
      "        self.add(text1, text2, text3, text4, text5 , text6)",
      "        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)"
    ],
    "topic": "text styling demonstration",
    "description": "Displays various text styling effects including italics, bold, and color highlighting on the phrase 'Hello world' and a URL."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class TextMoreCustomization(Scene):",
      "    def construct(self):",
      "        text1 = Text(",
      "            'Google',",
      "            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',",
      "                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',",
      "                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)",
      "        self.add(text1)"
    ],
    "topic": "text color customization",
    "description": "Displays the word 'Google' with each letter in a different color, mimicking the company's logo."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MultipleFonts(Scene):",
      "    def construct(self):",
      "        morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")",
      "        japanese = Text(",
      "            \"\u65e5\u672c\u3078\u3088\u3046\u3053\u305d\", t2c={\"\u65e5\u672c\": BLUE}",
      "        )  # works same as ``Text``.",
      "        mess = Text(\"Multi-Language\", weight=BOLD)",
      "        russ = Text(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u092e\u0938 \u0928\u092e \u092e \", font=\"sans-serif\")",
      "        hin = Text(\"\u0928\u092e\u0938\u094d\u0924\u0947\", font=\"sans-serif\")",
      "        arb = Text(",
      "            \"\u0635\u0628\u0627\u062d \u0627\u0644\u062e\u064a\u0631 \\n \u062a\u0634\u0631\u0641\u062a \u0628\u0645\u0642\u0627\u0628\u0644\u062a\u0643\", font=\"sans-serif\"",
      "        )  # don't mix RTL and LTR languages nothing shows up then ;-)",
      "        chinese = Text(\"\u81c2\u733f\u300c\u9edb\u6bd4\u300d\u5e36\u8457\u5b69\u5b50\", font=\"sans-serif\")",
      "        self.add(morning, japanese, mess, russ, hin, arb, chinese)",
      "        for i,mobj in enumerate(self.mobjects):",
      "            mobj.shift(DOWN*(i-3))"
    ],
    "topic": "multilingual text display",
    "description": "Displays multiple lines of text in different languages and fonts, each shifted vertically to create a stacked appearance."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Example1Text(Scene):",
      "    def construct(self):",
      "        text = Text('Hello world').scale(3)",
      "        self.add(text)"
    ],
    "topic": "static text display",
    "description": "Displays the text 'Hello world' scaled up in size on the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FontExample(Scene):",
      "    def construct(self):",
      "        text1 = MarkupText(",
      "            'all in sans <span font_family=\"serif\">except this</span>', font=\"sans\"",
      "        )",
      "        text2 = MarkupText(",
      "            '<span font_family=\"serif\">mixing</span> <span font_family=\"sans\">fonts</span> <span font_family=\"monospace\">is ugly</span>'",
      "        )",
      "        text3 = MarkupText(\"special char > or &gt;\")",
      "        text4 = MarkupText(\"special char &lt; and &amp;\")",
      "        group = VGroup(text1, text2, text3, text4).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "text formatting",
    "description": "Displays text with different font styles and special characters arranged vertically."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MarkupElaborateExample(Scene):",
      "    def construct(self):",
      "        text = MarkupText(",
      "            '<span foreground=\"purple\">\u0627</span><span foreground=\"red\">\u064e</span>'",
      "            '\u0644<span foreground=\"blue\">\u0652</span>\u0639<span foreground=\"red\">\u064e</span>\u0631'",
      "            '<span foreground=\"red\">\u064e</span>\u0628<span foreground=\"red\">\u0650</span>\u064a'",
      "            '<span foreground=\"green\">\u0651</span><span foreground=\"red\">\u064e</span>\u0629'",
      "            '<span foreground=\"blue\">\u064f</span>'",
      "        )",
      "        self.add(text)"
    ],
    "topic": "colored text display",
    "description": "Displays Arabic text with each character and diacritic in different colors."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BasicMarkupExample(Scene):",
      "    def construct(self):",
      "        text1 = MarkupText(\"<b>foo</b> <i>bar</i> <b><i>foobar</i></b>\")",
      "        text2 = MarkupText(\"<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>\")",
      "        text3 = MarkupText(\"H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>\")",
      "        text4 = MarkupText(\"type <tt>help</tt> for help\")",
      "        text5 = MarkupText(",
      "            '<span underline=\"double\">foo</span> <span underline=\"error\">bar</span>'",
      "        )",
      "        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "text formatting demonstration",
    "description": "Displays multiple lines of text with various HTML-like formatting styles such as bold, italic, subscript, and underline."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NewlineExample(Scene):",
      "    def construct(self):",
      "        text = MarkupText('foooo<span foreground=\"red\">oo\\nbaa</span>aar')",
      "        self.add(text)"
    ],
    "topic": "formatted text display",
    "description": "Displays text with a portion colored red and containing a newline character."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ColorExample(Scene):",
      "    def construct(self):",
      "        text1 = MarkupText(",
      "            f'all in red <span fgcolor=\"{YELLOW}\">except this</span>', color=RED",
      "        )",
      "        text2 = MarkupText(\"nice gradient\", gradient=(BLUE, GREEN))",
      "        text3 = MarkupText(",
      "            'nice <gradient from=\"RED\" to=\"YELLOW\">intermediate</gradient> gradient',",
      "            gradient=(BLUE, GREEN),",
      "        )",
      "        text4 = MarkupText(",
      "            'fl ligature <gradient from=\"RED\" to=\"YELLOW\">causing trouble</gradient> here'",
      "        )",
      "        text5 = MarkupText(",
      "            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">defeated</gradient> with offset'",
      "        )",
      "        text6 = MarkupText(",
      "            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">floating</gradient> inside'",
      "        )",
      "        text7 = MarkupText(",
      "            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1,1\">floating</gradient> inside'",
      "        )",
      "        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "text color and gradient",
    "description": "Displays various text examples with different colors, gradients, and ligature handling using MarkupText."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NoLigaturesExample(Scene):",
      "    def construct(self):",
      "        text1 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing')",
      "        text2 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing', disable_ligatures=True)",
      "        group = VGroup(text1, text2).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "text rendering comparison",
    "description": "Displays two versions of the same text with and without ligatures, highlighting a gradient effect on part of the text."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MultiLanguage(Scene):",
      "    def construct(self):",
      "        morning = MarkupText(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")",
      "        japanese = MarkupText(",
      "            '<span fgcolor=\"blue\">\u65e5\u672c</span>\u3078\u3088\u3046\u3053\u305d'",
      "        )  # works as in ``Text``.",
      "        mess = MarkupText(\"Multi-Language\", weight=BOLD)",
      "        russ = MarkupText(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u092e\u0938 \u0928\u092e \u092e \", font=\"sans-serif\")",
      "        hin = MarkupText(\"\u0928\u092e\u0938\u094d\u0924\u0947\", font=\"sans-serif\")",
      "        chinese = MarkupText(\"\u81c2\u733f\u300c\u9edb\u6bd4\u300d\u5e36\u8457\u5b69\u5b50\", font=\"sans-serif\")",
      "        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "multilingual text display",
    "description": "Displays a vertical arrangement of text in multiple languages including Tamil, Japanese, English, Russian, Hindi, and Chinese."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MarkupExample(Scene):",
      "    def construct(self):",
      "        text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')",
      "        self.add(text)"
    ],
    "topic": "styled text display",
    "description": "Displays a line of text with blue color and large size, including italicized words."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class UnderlineExample(Scene):",
      "    def construct(self):",
      "        text1 = MarkupText(",
      "            '<span underline=\"double\" underline_color=\"green\">bla</span>'",
      "        )",
      "        text2 = MarkupText(",
      "            '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'",
      "        )",
      "        text3 = MarkupText(",
      "            '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-1\">aabb</gradient>y'",
      "        )",
      "        text4 = MarkupText(",
      "            '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'",
      "        )",
      "        text5 = MarkupText(",
      "            '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-2\">aabb</gradient>y'",
      "        )",
      "        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)",
      "        self.add(group)"
    ],
    "topic": "text styling",
    "description": "Displays multiple lines of text with various underline styles and color gradients."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class JustifyText(Scene):",
      "    def construct(self):",
      "        ipsum_text = (",
      "            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"",
      "            \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"",
      "            \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"",
      "            \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"",
      "            \"leo pulvinar, dignissim est at, venenatis nisi.\"",
      "        )",
      "        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)",
      "        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)",
      "        just_title = Title(\"Justified\")",
      "        njust_title = Title(\"Not Justified\")",
      "        self.add(njust_title, not_justified_text)",
      "        self.play(",
      "            FadeOut(not_justified_text),",
      "            FadeIn(justified_text),",
      "            FadeOut(njust_title),",
      "            FadeIn(just_title),",
      "        )",
      "        self.wait(1)"
    ],
    "topic": "text justification",
    "description": "Animates the transition of a block of text from not justified to justified alignment with title changes."
  },
  {
    "code": [
      ">>> from manim import Rectangle, Circle",
      ">>> import numpy as np",
      ">>> rect = Rectangle(height=2, width=4)",
      ">>> circ = Circle(radius=3)"
    ],
    "topic": "basic shape creation",
    "description": "Creates a rectangle and a circle with specified dimensions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DtUpdater(Scene):",
      "    def construct(self):",
      "        square = Square()",
      "",
      "        #Let the square rotate 90\u00b0 per second",
      "        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))",
      "        self.add(square)",
      "        self.wait(2)"
    ],
    "topic": "rotating square",
    "description": "Animates a square rotating continuously at 90 degrees per second for two seconds."
  },
  {
    "code": [
      ">>> from manim import Square, Rectangle, VGroup, Group, Mobject, VMobject",
      ">>> s, r, m, v = Square(), Rectangle(), Mobject(), VMobject()",
      ">>> vg = VGroup(s, r)",
      ">>> gr = Group(vg, m, v)",
      ">>> gr.get_family()",
      "[Group, VGroup(Square, Rectangle), Square, Rectangle, Mobject, VMobject]"
    ],
    "topic": "group hierarchy",
    "description": "Displays the hierarchical structure of grouped Manim objects including squares, rectangles, and custom objects."
  },
  {
    "code": [
      ">>> from manim import *",
      ">>> sq = Square()",
      ">>> sq.height",
      "np.float64(2.0)",
      ">>> sq.stretch_to_fit_width(5)",
      "Square",
      ">>> sq.width",
      "np.float64(5.0)",
      ">>> sq.height",
      "np.float64(2.0)"
    ],
    "topic": "square transformation",
    "description": "Adjusts a square's width to 5 units while maintaining its height at 2 units."
  },
  {
    "code": [
      ">>> from manim import *",
      ">>> sq = Square()",
      ">>> sq.width",
      "np.float64(2.0)",
      ">>> sq.stretch_to_fit_height(5)",
      "Square",
      ">>> sq.height",
      "np.float64(5.0)",
      ">>> sq.width",
      "np.float64(2.0)"
    ],
    "topic": "square transformation",
    "description": "Demonstrates a square being stretched to increase its height while maintaining its width."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class WidthExample(Scene):",
      "    def construct(self):",
      "        decimal = DecimalNumber().to_edge(UP)",
      "        rect = Rectangle(color=BLUE)",
      "        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)",
      "",
      "        decimal.add_updater(lambda d: d.set_value(rect.width))",
      "",
      "        self.add(rect_copy, rect, decimal)",
      "        self.play(rect.animate.set(width=7))",
      "        self.wait()"
    ],
    "topic": "rectangle width change",
    "description": "Animates a rectangle expanding its width while displaying the changing width value above it."
  },
  {
    "code": [
      ">>> from manim import Square, RED",
      ">>> Square(color=RED).get_color() == RED",
      "True"
    ],
    "topic": "color check",
    "description": "Verifies if a square's color is set to red."
  },
  {
    "code": [
      ">>> from manim import Rectangle, Line, ORIGIN, RIGHT",
      ">>> rect = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)",
      ">>> line = Line(start=ORIGIN,end=RIGHT)",
      ">>> line.align_data(rect)",
      ">>> len(line.get_family()) == len(rect.get_family())",
      "True",
      ">>> line.get_num_points() == rect.get_num_points()",
      "True"
    ],
    "topic": "object alignment",
    "description": "Aligns a line with a rectangle and checks if they have the same number of points and family members"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BecomeScene(Scene):",
      "    def construct(self):",
      "        circ = Circle(fill_color=RED, fill_opacity=0.8)",
      "        square = Square(fill_color=BLUE, fill_opacity=0.2)",
      "        self.add(circ)",
      "        self.wait(0.5)",
      "        circ.become(square)",
      "        self.wait(0.5)"
    ],
    "topic": "shape transformation",
    "description": "Animates a circle transforming into a square with color and opacity change"
  },
  {
    "code": [
      ">>> from manim import *",
      ">>> sq = Square()",
      ">>> sq.height",
      "np.float64(2.0)",
      ">>> sq.scale_to_fit_width(5)",
      "Square",
      ">>> sq.width",
      "np.float64(5.0)",
      ">>> sq.height",
      "np.float64(5.0)"
    ],
    "topic": "square resizing",
    "description": "Demonstrates resizing a square by adjusting its width and height to a specified value."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ApplyFuncExample(Scene):",
      "    def construct(self):",
      "        circ = Circle().scale(1.5)",
      "        circ_ref = circ.copy()",
      "        circ.apply_complex_function(",
      "            lambda x: np.exp(x*1j)",
      "        )",
      "        t = ValueTracker(0)",
      "        circ.add_updater(",
      "            lambda x: x.become(circ_ref.copy().apply_complex_function(",
      "                lambda x: np.exp(x+t.get_value()*1j)",
      "            )).set_color(BLUE)",
      "        )",
      "        self.add(circ_ref)",
      "        self.play(TransformFromCopy(circ_ref, circ))",
      "        self.play(t.animate.set_value(TAU), run_time=3)"
    ],
    "topic": "Complex function transformation",
    "description": "Animates a circle being transformed by a complex exponential function, rotating continuously over time."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GeometricShapes(Scene):",
      "    def construct(self):",
      "        d = Dot()",
      "        c = Circle()",
      "        s = Square()",
      "        t = Triangle()",
      "        d.next_to(c, RIGHT)",
      "        s.next_to(c, LEFT)",
      "        t.next_to(c, DOWN)",
      "        self.add(d, c, s, t)"
    ],
    "topic": "geometric shapes arrangement",
    "description": "Arranges a dot, circle, square, and triangle around a central circle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MatchPointsScene(Scene):",
      "    def construct(self):",
      "        circ = Circle(fill_color=RED, fill_opacity=0.8)",
      "        square = Square(fill_color=BLUE, fill_opacity=0.2)",
      "        self.add(circ)",
      "        self.wait(0.5)",
      "        self.play(circ.animate.match_points(square))",
      "        self.wait(0.5)"
    ],
    "topic": "shape morphing",
    "description": "Animates a red circle morphing into a blue square by matching their points."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnimateWithArgsExample(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        c = Circle()",
      "",
      "        VGroup(s, c).arrange(RIGHT, buff=2)",
      "        self.add(s, c)",
      "",
      "        self.play(",
      "            s.animate(run_time=2).rotate(PI / 2),",
      "            c.animate(rate_func=there_and_back).shift(RIGHT),",
      "        )"
    ],
    "topic": "shape animation",
    "description": "Animates a square rotating and a circle shifting right with a back-and-forth motion."
  },
  {
    "code": [
      ">>> from manim import *",
      ">>> sq = Square()",
      ">>> sq.width",
      "np.float64(2.0)",
      ">>> sq.scale_to_fit_height(5)",
      "Square",
      ">>> sq.height",
      "np.float64(5.0)",
      ">>> sq.width",
      "np.float64(5.0)"
    ],
    "topic": "square scaling",
    "description": "Demonstrates a square being scaled to fit a specified height, altering its dimensions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MobjectScaleExample(Scene):",
      "    def construct(self):",
      "        f1 = Text(\"F\")",
      "        f2 = Text(\"F\").scale(2)",
      "        f3 = Text(\"F\").scale(0.5)",
      "        f4 = Text(\"F\").scale(-1)",
      "",
      "        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)",
      "        self.add(vgroup)"
    ],
    "topic": "text scaling",
    "description": "Displays four instances of the letter 'F' with different scaling factors arranged horizontally."
  },
  {
    "code": [
      "from manim import *",
      "",
      "config.background_color = WHITE",
      "",
      "class ChangedDefaultTextcolor(Scene):",
      "    def construct(self):",
      "        Text.set_default(color=BLACK)",
      "        self.add(Text(\"Changing default values is easy!\"))",
      "",
      "        # we revert the colour back to the default to prevent a bug in the docs.",
      "        Text.set_default(color=WHITE)"
    ],
    "topic": "text color change",
    "description": "Demonstrates changing the default text color to black and then reverting it to white."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class InvertSumobjectsExample(Scene):",
      "    def construct(self):",
      "        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])",
      "        s2 = s.copy()",
      "        s2.invert()",
      "        s2.shift(DOWN)",
      "        self.play(Write(s), Write(s2))"
    ],
    "topic": "object inversion",
    "description": "Displays a line of dots and its vertically inverted copy shifting downward."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ExampleBoxes(Scene):",
      "    def construct(self):",
      "        boxes=VGroup(*[Square() for s in range(0,6)])",
      "        boxes.arrange_in_grid(rows=2, buff=0.1)",
      "        self.add(boxes)"
    ],
    "topic": "grid of squares",
    "description": "Displays a 2x3 grid of squares arranged with minimal spacing."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Example(Scene):",
      "    def construct(self):",
      "        s1 = Square()",
      "        s2 = Square()",
      "        s3 = Square()",
      "        s4 = Square()",
      "        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)",
      "        self.add(x)"
    ],
    "topic": "square arrangement",
    "description": "Displays four squares arranged horizontally with equal spacing."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class InterpolateExample(Scene):",
      "    def construct(self):",
      "        # No need for point alignment:",
      "        dotL = Dot(color=DARK_GREY).to_edge(LEFT)",
      "        dotR = Dot(color=YELLOW).scale(10).to_edge(RIGHT)",
      "        dotMid1 = VMobject().interpolate(dotL, dotR, alpha=0.1)",
      "        dotMid2 = VMobject().interpolate(dotL, dotR, alpha=0.25)",
      "        dotMid3 = VMobject().interpolate(dotL, dotR, alpha=0.5)",
      "        dotMid4 = VMobject().interpolate(dotL, dotR, alpha=0.75)",
      "        dots = VGroup(dotL, dotR, dotMid1, dotMid2, dotMid3, dotMid4)",
      "",
      "        # Needs point alignment:",
      "        line = Line(ORIGIN, UP).to_edge(LEFT)",
      "        sq = Square(color=RED, fill_opacity=1, stroke_color=BLUE).to_edge(RIGHT)",
      "        line.align_points(sq)",
      "        mid1 = VMobject().interpolate(line, sq, alpha=0.1)",
      "        mid2 = VMobject().interpolate(line, sq, alpha=0.25)",
      "        mid3 = VMobject().interpolate(line, sq, alpha=0.5)",
      "        mid4 = VMobject().interpolate(line, sq, alpha=0.75)",
      "        linesquares = VGroup(line, sq, mid1, mid2, mid3, mid4)",
      "",
      "        self.add(VGroup(dots, linesquares).arrange(DOWN, buff=1))"
    ],
    "topic": "Interpolation visualization",
    "description": "Demonstrates interpolation between two dots and between a line and a square, showing intermediate shapes at various alpha values."
  },
  {
    "code": [
      ">>> from manim import Square, GREEN",
      ">>> Square.set_default(color=GREEN, fill_opacity=0.25)",
      ">>> s = Square(); s.color, s.fill_opacity",
      "(ManimColor('#83C167'), 0.25)",
      ">>> Square.set_default()",
      ">>> s = Square(); s.color, s.fill_opacity",
      "(ManimColor('#FFFFFF'), 0.0)"
    ],
    "topic": "square color change",
    "description": "Demonstrates setting and resetting default color and fill opacity for a square."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class RotateMethodExample(Scene):",
      "    def construct(self):",
      "        circle = Circle(radius=1, color=BLUE)",
      "        line = Line(start=ORIGIN, end=RIGHT)",
      "        arrow1 = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)",
      "        group1 = VGroup(circle, line, arrow1)",
      "",
      "        group2 = group1.copy()",
      "        arrow2 = group2[2]",
      "        arrow2.rotate(angle=PI / 4, about_point=arrow2.get_start())",
      "",
      "        group3 = group1.copy()",
      "        arrow3 = group3[2]",
      "        arrow3.rotate(angle=120 * DEGREES, about_point=arrow3.get_start())",
      "",
      "        self.add(VGroup(group1, group2, group3).arrange(RIGHT, buff=1))"
    ],
    "topic": "object rotation",
    "description": "Demonstrates the rotation of arrows within grouped objects at different angles."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class HeightExample(Scene):",
      "    def construct(self):",
      "        decimal = DecimalNumber().to_edge(UP)",
      "        rect = Rectangle(color=BLUE)",
      "        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)",
      "",
      "        decimal.add_updater(lambda d: d.set_value(rect.height))",
      "",
      "        self.add(rect_copy, rect, decimal)",
      "        self.play(rect.animate.set(height=5))",
      "        self.wait()"
    ],
    "topic": "rectangle height change",
    "description": "Displays a rectangle whose height increases to 5, with a numerical display updating to show the current height."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArrangeSumobjectsExample(Scene):",
      "    def construct(self):",
      "        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])",
      "        s.shift(UP).set_color(BLUE)",
      "        s2= s.copy().set_color(RED)",
      "        s2.arrange_submobjects()",
      "        s2.shift(DOWN)",
      "        self.add(s,s2)"
    ],
    "topic": "object arrangement",
    "description": "Displays a group of dots randomly positioned and then arranged in a line, changing color from blue to red."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ToEdgeExample(Scene):",
      "    def construct(self):",
      "        tex_top = Tex(\"I am at the top!\")",
      "        tex_top.to_edge(UP)",
      "        tex_side = Tex(\"I am moving to the side!\")",
      "        c = Circle().shift(2*DOWN)",
      "        self.add(tex_top, tex_side, c)",
      "        tex_side.to_edge(LEFT)",
      "        c.to_edge(RIGHT, buff=0)"
    ],
    "topic": "text and shape positioning",
    "description": "Positions text and a circle at different edges of the screen, demonstrating movement and alignment."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnimateExample(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        self.play(Create(s))",
      "        self.play(s.animate.shift(RIGHT))",
      "        self.play(s.animate.scale(2))",
      "        self.play(s.animate.rotate(PI / 2))",
      "        self.play(Uncreate(s))"
    ],
    "topic": "square transformation",
    "description": "Animates a square being created, shifted, scaled, rotated, and then uncreated."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class FlipExample(Scene):",
      "    def construct(self):",
      "        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)",
      "        self.add(s)",
      "        s2= s.copy().flip()",
      "        self.add(s2)"
    ],
    "topic": "line flip transformation",
    "description": "Displays a line and its flipped copy shifted to the right."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ShuffleSubmobjectsExample(Scene):",
      "    def construct(self):",
      "        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])",
      "        s2= s.copy()",
      "        s2.shuffle_submobjects()",
      "        s2.shift(DOWN)",
      "        self.play(Write(s), Write(s2))"
    ],
    "topic": "dots shuffling",
    "description": "Displays a line of dots and a shuffled version below it using the shuffle_submobjects method."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetZIndex(Scene):",
      "    def construct(self):",
      "        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)",
      "        square = Square(2, fill_opacity=1).set_z_index(2)",
      "        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)",
      "        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0",
      "",
      "        # Displaying order is now defined by z_index values",
      "        self.add(text)",
      "        self.add(square)",
      "        self.add(tex)",
      "        self.add(circle)"
    ],
    "topic": "z-index layering",
    "description": "Demonstrates layering of text and shapes using z-index to control rendering order."
  },
  {
    "code": [
      ">>> from manim import Square, Rectangle, VGroup, Group, Mobject, VMobject",
      ">>> s, r, m, v = Square(), Rectangle(), Mobject(), VMobject()",
      ">>> vg = VGroup(s, r)",
      ">>> gr = Group(vg, m, v)",
      ">>> gr.family_members_with_points()",
      "[Square, Rectangle]"
    ],
    "topic": "grouped shape filtering",
    "description": "Filters and displays only the shapes with points from a group containing various objects."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AnimateChainExample(Scene):",
      "    def construct(self):",
      "        s = Square()",
      "        self.play(Create(s))",
      "        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))",
      "        self.play(Uncreate(s))"
    ],
    "topic": "square transformation",
    "description": "Animates a square being created, shifted, scaled, rotated, and then uncreated."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ToCornerExample(Scene):",
      "    def construct(self):",
      "        c = Circle()",
      "        c.to_corner(UR)",
      "        t = Tex(\"To the corner!\")",
      "        t2 = MathTex(\"x^3\").shift(DOWN)",
      "        self.add(c,t,t2)",
      "        t.to_corner(DL, buff=0)",
      "        t2.to_corner(UL, buff=1.5)"
    ],
    "topic": "object positioning",
    "description": "Positions a circle and two text objects at different corners of the screen."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ArrangeInGrid(Scene):",
      "    def construct(self):",
      "        boxes = VGroup(*[",
      "            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))",
      "            for i in range(24)",
      "        ])",
      "        self.add(boxes)",
      "",
      "        boxes.arrange_in_grid(",
      "            buff=(0.25,0.5),",
      "            col_alignments=\"lccccr\",",
      "            row_alignments=\"uccd\",",
      "            col_widths=[1, *[None]*4, 1],",
      "            row_heights=[1, None, None, 1],",
      "            flow_order=\"dr\"",
      "        )"
    ],
    "topic": "grid arrangement",
    "description": "Displays 24 numbered rectangles arranged in a custom grid layout with specified column and row alignments."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class NextToUpdater(Scene):",
      "    def construct(self):",
      "        def update_label(mobject):",
      "            mobject.set_value(dot.get_center()[0])",
      "            mobject.next_to(dot)",
      "",
      "        dot = Dot(RIGHT*3)",
      "        label = DecimalNumber()",
      "        label.add_updater(update_label)",
      "        self.add(dot, label)",
      "",
      "        self.play(Rotating(dot, angle=TAU, about_point=ORIGIN, run_time=TAU, rate_func=linear))"
    ],
    "topic": "dynamic label update",
    "description": "Displays a dot rotating around the origin with a label dynamically updating its position and value based on the dot's x-coordinate."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class AngleMidPoint(Scene):",
      "    def construct(self):",
      "        line1 = Line(ORIGIN, 2*RIGHT)",
      "        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)",
      "",
      "        a = Angle(line1, line2, radius=1.5, other_angle=False)",
      "        d = Dot(a.get_midpoint()).set_color(RED)",
      "",
      "        self.add(line1, line2, a, d)",
      "        self.wait()"
    ],
    "topic": "angle midpoint visualization",
    "description": "Displays two intersecting lines with an angle marked and a red dot at the angle's midpoint."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class IntegerMatrixExample(Scene):",
      "    def construct(self):",
      "        m0 = IntegerMatrix(",
      "            [[3.7, 2], [42.2, 12]],",
      "            left_bracket=\"(\",",
      "            right_bracket=\")\")",
      "        self.add(m0)"
    ],
    "topic": "matrix display",
    "description": "Displays a 2x2 integer matrix with custom brackets on the screen"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MobjectMatrixExample(Scene):",
      "    def construct(self):",
      "        a = Circle().scale(0.3)",
      "        b = Square().scale(0.3)",
      "        c = MathTex(\"\\\\pi\").scale(2)",
      "        d = Star().scale(0.3)",
      "        m0 = MobjectMatrix([[a, b], [c, d]])",
      "        self.add(m0)"
    ],
    "topic": "matrix of shapes",
    "description": "Displays a 2x2 matrix composed of a circle, square, pi symbol, and star."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetColumnColorsExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],",
      "        ).set_column_colors([RED,BLUE], GREEN)",
      "        self.add(m0)"
    ],
    "topic": "matrix color highlighting",
    "description": "Displays a 2x2 matrix with specified column colors for visual emphasis"
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetRowsExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])",
      "        m0.add(SurroundingRectangle(m0.get_rows()[1]))",
      "        self.add(m0)"
    ],
    "topic": "matrix highlighting",
    "description": "Displays a 2x2 matrix with the second row highlighted by a surrounding rectangle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetEntriesExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[2, 3], [1, 5]])",
      "        ent = m0.get_entries()",
      "        colors = [BLUE, GREEN, YELLOW, RED]",
      "        for k in range(len(colors)):",
      "            ent[k].set_color(colors[k])",
      "        self.add(m0)"
    ],
    "topic": "matrix entry coloring",
    "description": "Displays a 2x2 matrix with each entry colored differently."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class MatrixExamples(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])",
      "        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],",
      "            v_buff=1.3,",
      "            h_buff=0.8,",
      "            bracket_h_buff=SMALL_BUFF,",
      "            bracket_v_buff=SMALL_BUFF,",
      "            left_bracket=r\"\\{\",",
      "            right_bracket=r\"\\}\")",
      "        m1.add(SurroundingRectangle(m1.get_columns()[1]))",
      "        m2 = Matrix([[2, 1], [-1, 3]],",
      "            element_alignment_corner=UL,",
      "            left_bracket=\"(\",",
      "            right_bracket=\")\")",
      "        m3 = Matrix([[2, 1], [-1, 3]],",
      "            left_bracket=r\"\\langle\",",
      "            right_bracket=r\"\\rangle\")",
      "        m4 = Matrix([[2, 1], [-1, 3]],",
      "        ).set_column_colors(RED, GREEN)",
      "        m5 = Matrix([[2, 1], [-1, 3]],",
      "        ).set_row_colors(RED, GREEN)",
      "        g = Group(",
      "            m0,m1,m2,m3,m4,m5",
      "        ).arrange_in_grid(buff=2)",
      "        self.add(g)"
    ],
    "topic": "matrix display variations",
    "description": "Displays multiple matrices with different styles and highlights, arranged in a grid layout."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetColumnsExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])",
      "        m0.add(SurroundingRectangle(m0.get_columns()[1]))",
      "        self.add(m0)"
    ],
    "topic": "matrix column highlight",
    "description": "Displays a 2x2 matrix with the second column highlighted by a surrounding rectangle."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class GetBracketsExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])",
      "        bra = m0.get_brackets()",
      "        colors = [BLUE, GREEN]",
      "        for k in range(len(colors)):",
      "            bra[k].set_color(colors[k])",
      "        self.add(m0)"
    ],
    "topic": "matrix with colored brackets",
    "description": "Displays a matrix with its brackets colored blue and green."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BackgroundRectanglesExample(Scene):",
      "    def construct(self):",
      "        background= Rectangle().scale(3.2)",
      "        background.set_fill(opacity=.5)",
      "        background.set_color([TEAL, RED, YELLOW])",
      "        self.add(background)",
      "        m0 = Matrix([[12, -30], [-1, 15]],",
      "            add_background_rectangles_to_entries=True)",
      "        m1 = Matrix([[2, 0], [-1, 1]],",
      "            include_background_rectangle=True)",
      "        m2 = Matrix([[12, -30], [-1, 15]])",
      "        g = Group(m0, m1, m2).arrange(buff=2)",
      "        self.add(g)"
    ],
    "topic": "matrix display",
    "description": "Displays three matrices with background rectangles on a colored gradient background."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SetRowColorsExample(Scene):",
      "    def construct(self):",
      "        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],",
      "        ).set_row_colors([RED,BLUE], GREEN)",
      "        self.add(m0)"
    ],
    "topic": "matrix color styling",
    "description": "Displays a 2x2 matrix with rows colored red and blue, and elements colored green."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class DecimalMatrixExample(Scene):",
      "    def construct(self):",
      "        m0 = DecimalMatrix(",
      "            [[3.456, 2.122], [33.2244, 12]],",
      "            element_to_mobject_config={\"num_decimal_places\": 2},",
      "            left_bracket=\"\\\\{\",",
      "            right_bracket=\"\\\\}\")",
      "        self.add(m0)"
    ],
    "topic": "matrix display",
    "description": "Displays a 2x2 decimal matrix with custom brackets and rounded elements."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class StreamLineCreation(Scene):",
      "    def construct(self):",
      "        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos",
      "        stream_lines = StreamLines(",
      "            func,",
      "            color=YELLOW,",
      "            x_range=[-7, 7, 1],",
      "            y_range=[-4, 4, 1],",
      "            stroke_width=3,",
      "            virtual_time=1,  # use shorter lines",
      "            max_anchors_per_line=5,  # better performance with fewer anchors",
      "        )",
      "        self.play(stream_lines.create())  # uses virtual_time as run_time",
      "        self.wait()"
    ],
    "topic": "Streamline visualization",
    "description": "Displays animated streamlines illustrating a vector field with directional flow."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class EndAnimation(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT",
      "        stream_lines = StreamLines(",
      "            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE",
      "        )",
      "        self.add(stream_lines)",
      "        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)",
      "        self.wait(1)",
      "        self.play(stream_lines.end_animation())"
    ],
    "topic": "vector field animation",
    "description": "Displays animated streamlines representing a vector field defined by sinusoidal functions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ContinuousMotion(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT",
      "        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)",
      "        self.add(stream_lines)",
      "        stream_lines.start_animation(warm_up=False, flow_speed=1.5)",
      "        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)"
    ],
    "topic": "vector field animation",
    "description": "Displays animated streamlines representing a continuous vector field with sinusoidal components."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BasicUsage(Scene):",
      "    def construct(self):",
      "        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3",
      "        self.add(StreamLines(func))"
    ],
    "topic": "vector field animation",
    "description": "Displays a dynamic streamlines animation of a vector field defined by a lambda function."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SpawningAndFlowingArea(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5",
      "        stream_lines = StreamLines(",
      "            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1",
      "        )",
      "",
      "        spawning_area = Rectangle(width=6, height=4)",
      "        flowing_area = Rectangle(width=8, height=6)",
      "        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]",
      "        for lbl in labels:",
      "            lbl.add_background_rectangle(opacity=0.6, buff=0.05)",
      "",
      "        self.add(stream_lines, spawning_area, flowing_area, *labels)"
    ],
    "topic": "vector field animation",
    "description": "Visualizes a dynamic vector field with labeled spawning and flowing areas."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class ScaleVectorFieldFunction(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP",
      "        vector_field = ArrowVectorField(func)",
      "        self.add(vector_field)",
      "        self.wait()",
      "",
      "        func = VectorField.scale_func(func, 0.5)",
      "        self.play(vector_field.animate.become(ArrowVectorField(func)))",
      "        self.wait()"
    ],
    "topic": "vector field scaling",
    "description": "Animates a vector field being scaled down by a factor of 0.5."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Nudging(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP",
      "        vector_field = ArrowVectorField(",
      "            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2",
      "        )",
      "        self.add(vector_field)",
      "        circle = Circle(radius=2).shift(LEFT)",
      "        self.add(circle.copy().set_color(GRAY))",
      "        dot = Dot().move_to(circle)",
      "",
      "        vector_field.nudge(circle, -2, 60, True)",
      "        vector_field.nudge(dot, -2, 60)",
      "",
      "        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))",
      "        dot.add_updater(vector_field.get_nudge_updater())",
      "        self.add(circle, dot)",
      "        self.wait(6)"
    ],
    "topic": "Vector field animation",
    "description": "Illustrates a circle and a dot being nudged along a vector field defined by sinusoidal functions."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class BasicUsage(Scene):",
      "    def construct(self):",
      "        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3",
      "        self.add(ArrowVectorField(func))"
    ],
    "topic": "vector field visualization",
    "description": "Displays an arrow vector field representing a transformation function in 2D space."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class Coloring(Scene):",
      "    def construct(self):",
      "        func = lambda pos: pos - LEFT * 5",
      "        colors = [RED, YELLOW, BLUE, DARK_GRAY]",
      "        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)",
      "        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)",
      "        vf = ArrowVectorField(",
      "            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors",
      "        )",
      "        self.add(vf, min_radius, max_radius)"
    ],
    "topic": "Vector field visualization",
    "description": "Displays a colored arrow vector field with circles indicating minimum and maximum radius values."
  },
  {
    "code": [
      "from manim import *",
      "",
      "class SizingAndSpacing(Scene):",
      "    def construct(self):",
      "        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT",
      "        vf = ArrowVectorField(func, x_range=[-7, 7, 1])",
      "        self.add(vf)",
      "        self.wait()",
      "",
      "        length_func = lambda x: x / 3",
      "        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)",
      "        self.play(vf.animate.become(vf2))",
      "        self.wait()"
    ],
    "topic": "vector field transformation",
    "description": "Animates the transformation of a vector field by changing the length of the arrows based on a custom function."
  }
]