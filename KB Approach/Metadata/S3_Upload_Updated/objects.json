{
    "topic": "is demonstrating the concept of visualizing the motion of a particle using Manim animation",
    "code": [
        "from __future__ import annotations\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from matplotlib import colormaps\n",
        "\n",
        "\n",
        "from typing import TYPE_CHECKING\n",
        "\n",
        "if TYPE_CHECKING:\n",
        "    from typing import Callable\n",
        "    from manimlib.typing import Vect3\n",
        "\n",
        "\n",
        "spectral_cmap = colormaps.get_cmap(\"Spectral\")\n",
        "\n",
        "# Helper functions\n",
        "\n",
        "\n",
        "def get_spectral_color(alpha):\n",
        "    return Color(rgb=spectral_cmap(alpha)[:3])\n",
        "\n",
        "\n",
        "def get_spectral_colors(n_colors, lower_bound=0, upper_bound=1):\n",
        "    return [\n",
        "        get_spectral_color(alpha)\n",
        "        for alpha in np.linspace(lower_bound, upper_bound, n_colors)\n",
        "    ]\n",
        "\n",
        "\n",
        "def get_axes_and_plane(\n",
        "    x_range=(0, 24),\n",
        "    y_range=(-1, 1),\n",
        "    z_range=(-1, 1),\n",
        "    x_unit=1,\n",
        "    y_unit=2,\n",
        "    z_unit=2,\n",
        "    origin_point=5 * LEFT,\n",
        "    axes_opacity=0.5,\n",
        "    plane_line_style=dict(\n",
        "        stroke_color=GREY_C,\n",
        "        stroke_width=1,\n",
        "        stroke_opacity=0.5\n",
        "    ),\n",
        "):\n",
        "    axes = ThreeDAxes(\n",
        "        x_range=x_range,\n",
        "        y_range=y_range,\n",
        "        z_range=z_range,\n",
        "        width=x_unit * (x_range[1] - x_range[0]),\n",
        "        height=y_unit * (y_range[1] - y_range[0]),\n",
        "        depth=z_unit * (z_range[1] - z_range[0]),\n",
        "    )\n",
        "    axes.shift(origin_point - axes.get_origin())\n",
        "    axes.set_opacity(axes_opacity)\n",
        "    axes.set_flat_stroke(False)\n",
        "    plane = NumberPlane(\n",
        "        axes.x_range, axes.y_range,\n",
        "        width=axes.x_axis.get_length(),\n",
        "        height=axes.y_axis.get_length(),\n",
        "        background_line_style=plane_line_style,\n",
        "        axis_config=dict(stroke_width=0),\n",
        "    )\n",
        "    plane.shift(axes.get_origin() - plane.get_origin())\n",
        "    plane.set_flat_stroke(False)\n",
        "\n",
        "    return axes, plane\n",
        "\n",
        "\n",
        "def get_twist(wave_length, distance):\n",
        "    # 350 is arbitrary. Change\n",
        "    return distance / (wave_length / 350)**2\n",
        "\n",
        "\n",
        "def acceleration_from_position(pos_func, time, dt=1e-3):\n",
        "    p0 = pos_func(time - dt)\n",
        "    p1 = pos_func(time)\n",
        "    p2 = pos_func(time + dt)\n",
        "    return (p0 + p2 - 2 * p1) / dt**2\n",
        "\n",
        "\n",
        "def points_to_particle_info(particle, points, radius=None, c=2.0):\n",
        "    \"\"\"\n",
        "    Given an origin, a set of points, and a radius, this returns:\n",
        "\n",
        "    1) The unit vectors directed from the origin to each point\n",
        "\n",
        "    2) The distances from the origin to each point\n",
        "\n",
        "    3) An adjusted version of those distances where points\n",
        "    within a given radius of the origin are considered to\n",
        "    be farther away, approaching infinity at the origin.\n",
        "    The intent is that when this is used for coulomb/lorenz\n",
        "    forces, field vectors within a radius of a particle don't\n",
        "    blow up\n",
        "    \"\"\"\n",
        "    if radius is None:\n",
        "        radius = particle.get_radius()\n",
        "\n",
        "    if particle.track_position_history:\n",
        "        approx_delays = np.linalg.norm(points - particle.get_center(), axis=1) / c\n",
        "        centers = particle.get_past_position(approx_delays)\n",
        "    else:\n",
        "        centers = particle.get_center()\n",
        "\n",
        "    diffs = points - centers\n",
        "    norms = np.linalg.norm(diffs, axis=1)[:, np.newaxis]\n",
        "    unit_diffs = np.zeros_like(diffs)\n",
        "    np.true_divide(diffs, norms, out=unit_diffs, where=(norms > 0))\n",
        "\n",
        "    adjusted_norms = norms.copy()\n",
        "    mask = (0 < norms) & (norms < radius)\n",
        "    adjusted_norms[mask] = radius * radius / norms[mask]\n",
        "    adjusted_norms[norms == 0] = np.inf\n",
        "\n",
        "    return unit_diffs, norms, adjusted_norms\n",
        "\n",
        "\n",
        "def coulomb_force(points, particle, radius=None):\n",
        "    unit_diffs, norms, adjusted_norms = points_to_particle_info(particle, points, radius)\n",
        "    return particle.get_charge() * unit_diffs / adjusted_norms**2\n",
        "\n",
        "\n",
        "def lorentz_force(\n",
        "    points,\n",
        "    particle,\n",
        "    radius=None,\n",
        "    c=2.0,\n",
        "    epsilon0=0.025,\n",
        "):\n",
        "    unit_diffs, norms, adjusted_norms = points_to_particle_info(particle, points, radius, c)\n",
        "    delays = norms[:, 0] / c\n",
        "\n",
        "    acceleration = particle.get_past_acceleration(delays)\n",
        "    dot_prods = (unit_diffs * acceleration).sum(1)[:, np.newaxis]\n",
        "    a_perp = acceleration - dot_prods * unit_diffs\n",
        "\n",
        "    denom = 4 * PI * epsilon0 * c**2 * adjusted_norms\n",
        "    return -particle.get_charge() * a_perp / denom\n",
        "\n",
        "\n",
        "# For the cylinder\n",
        "\n",
        "\n",
        "class OscillatingWave(VMobject):\n",
        "    def __init__(\n",
        "        self,\n",
        "        axes,\n",
        "        y_amplitude=0.0,\n",
        "        z_amplitude=0.75,\n",
        "        z_phase=0.0,\n",
        "        y_phase=0.0,\n",
        "        wave_len=0.5,\n",
        "        twist_rate=0.0,  # In rotations per unit distance\n",
        "        speed=1.0,\n",
        "        sample_resolution=0.005,\n",
        "        stroke_width=2,\n",
        "        offset=ORIGIN,\n",
        "        color=None,\n",
        "        **kwargs,\n",
        "    ):\n",
        "        self.axes = axes\n",
        "        self.y_amplitude = y_amplitude\n",
        "        self.z_amplitude = z_amplitude\n",
        "        self.z_phase = z_phase\n",
        "        self.y_phase = y_phase\n",
        "        self.wave_len = wave_len\n",
        "        self.twist_rate = twist_rate\n",
        "        self.speed = speed\n",
        "        self.sample_resolution = sample_resolution\n",
        "        self.offset = offset\n",
        "\n",
        "        super().__init__(**kwargs)\n",
        "\n",
        "        color = color or self.get_default_color(wave_len)\n",
        "        self.set_stroke(color, stroke_width)\n",
        "        self.set_flat_stroke(False)\n",
        "\n",
        "        self.time = 0\n",
        "        self.clock_is_stopped = False\n",
        "\n",
        "        self.add_updater(lambda m, dt: m.update_points(dt))\n",
        "\n",
        "    def update_points(self, dt):\n",
        "        if not self.clock_is_stopped:\n",
        "            self.time += dt\n",
        "        xs = np.arange(\n",
        "            self.axes.x_axis.x_min,\n",
        "            self.axes.x_axis.x_max,\n",
        "            self.sample_resolution\n",
        "        )\n",
        "        self.set_points_as_corners(\n",
        "            self.offset + self.xt_to_point(xs, self.time)\n",
        "        )\n",
        "\n",
        "    def stop_clock(self):\n",
        "        self.clock_is_stopped = True\n",
        "\n",
        "    def start_clock(self):\n",
        "        self.clock_is_stopped = False\n",
        "\n",
        "    def xt_to_yz(self, x, t):\n",
        "        phase = TAU * t * self.speed / self.wave_len\n",
        "        y_outs = self.y_amplitude * np.sin(TAU * x / self.wave_len - phase - self.y_phase)\n",
        "        z_outs = self.z_amplitude * np.sin(TAU * x / self.wave_len - phase - self.z_phase)\n",
        "        twist_angles = x * self.twist_rate * TAU\n",
        "        y = np.cos(twist_angles) * y_outs - np.sin(twist_angles) * z_outs\n",
        "        z = np.sin(twist_angles) * y_outs + np.cos(twist_angles) * z_outs\n",
        "\n",
        "        return y, z\n",
        "\n",
        "    def xt_to_point(self, x, t):\n",
        "        y, z = self.xt_to_yz(x, t)\n",
        "        return self.axes.c2p(x, y, z)\n",
        "\n",
        "    def get_default_color(self, wave_len):\n",
        "        return get_spectral_color(inverse_interpolate(\n",
        "            1.5, 0.5, wave_len\n",
        "        ))\n",
        "\n",
        "\n",
        "class MeanWave(VMobject):\n",
        "    def __init__(self, waves, **kwargs):\n",
        "        self.waves = waves\n",
        "        self.offset = np.array(ORIGIN)\n",
        "        self.time = 0\n",
        "        super().__init__(**kwargs)\n",
        "        self.set_flat_stroke(False)\n",
        "        self.add_updater(lambda m, dt: m.update_points(dt))\n",
        "\n",
        "    def update_points(self, dt):\n",
        "        for wave in self.waves:\n",
        "            wave.update_points(dt)\n",
        "\n",
        "        self.time += dt\n",
        "\n",
        "        points = sum(wave.get_points() for wave in self.waves) / len(self.waves)\n",
        "        self.set_points(points)\n",
        "\n",
        "    def xt_to_yz(self, x, t):\n",
        "        return tuple(\n",
        "            np.array([\n",
        "                wave.xt_to_yz(x, t)[i]\n",
        "                for wave in self.waves\n",
        "            ]).mean(0)\n",
        "            for i in (0, 1)\n",
        "        )\n",
        "\n",
        "\n",
        "class SugarCylinder(Cylinder):\n",
        "    def __init__(\n",
        "        self, axes, camera,\n",
        "        radius=0.5,\n",
        "        color=BLUE_A,\n",
        "        opacity=0.2,\n",
        "        shading=(0.5, 0.5, 0.5),\n",
        "        resolution=(51, 101),\n",
        "    ):\n",
        "        super().__init__(\n",
        "            color=color,\n",
        "            opacity=opacity,\n",
        "            resolution=resolution,\n",
        "            shading=shading,\n",
        "        )\n",
        "        self.set_width(2 * axes.z_axis.get_unit_size() * radius)\n",
        "        self.set_depth(axes.x_axis.get_length(), stretch=True)\n",
        "        self.rotate(PI / 2, UP)\n",
        "        self.move_to(axes.get_origin(), LEFT)\n",
        "        # self.set_shading(*shading)\n",
        "        self.always_sort_to_camera(camera)\n",
        "\n",
        "\n",
        "class Polarizer(VGroup):\n",
        "    def __init__(\n",
        "        self, axes,\n",
        "        radius=1.0,\n",
        "        angle=0,\n",
        "        stroke_color=GREY_C,\n",
        "        stroke_width=2,\n",
        "        fill_color=GREY_C,\n",
        "        fill_opacity=0.25,\n",
        "        n_lines=14,\n",
        "        line_opacity=0.2,\n",
        "        arrow_stroke_color=WHITE,\n",
        "        arrow_stroke_width=5,\n",
        "\n",
        "    ):\n",
        "        true_radius = radius * axes.z_axis.get_unit_size()\n",
        "        circle = Circle(\n",
        "            radius=true_radius,\n",
        "            stroke_color=stroke_color,\n",
        "            stroke_width=stroke_width,\n",
        "            fill_color=fill_color,\n",
        "            fill_opacity=fill_opacity,\n",
        "        )\n",
        "\n",
        "        lines = VGroup(*(\n",
        "            Line(circle.pfp(a), circle.pfp(1 - a))\n",
        "            for a in np.arccos(np.linspace(1, -1, n_lines + 2)[1:-1]) / TAU\n",
        "        ))\n",
        "        lines.set_stroke(WHITE, 1, opacity=line_opacity)\n",
        "\n",
        "        arrow = Vector(\n",
        "            0.5 * true_radius * UP,\n",
        "            stroke_color=arrow_stroke_color,\n",
        "            stroke_width=arrow_stroke_width,\n",
        "        )\n",
        "        arrow.move_to(circle.get_top(), DOWN)\n",
        "\n",
        "        super().__init__(\n",
        "            circle, lines, arrow,\n",
        "            # So the center works correctly\n",
        "            VectorizedPoint(circle.get_bottom() + arrow.get_height() * DOWN),\n",
        "        )\n",
        "        self.set_flat_stroke(True)\n",
        "        self.rotate(PI / 2, RIGHT)\n",
        "        self.rotate(PI / 2, IN)\n",
        "        self.rotate(angle, RIGHT)\n",
        "        self.rotate(1 * DEGREES, UP)\n",
        "\n",
        "\n",
        "class ProbagatingRings(VGroup):\n",
        "    def __init__(\n",
        "        self, line,\n",
        "        n_rings=5,\n",
        "        start_width=3,\n",
        "        width_decay_rate=0.1,\n",
        "        stroke_color=WHITE,\n",
        "        growth_rate=2.0,\n",
        "        spacing=0.2,\n",
        "    ):\n",
        "        ring = Circle(radius=1e-3, n_components=101)\n",
        "        ring.set_stroke(stroke_color, start_width)\n",
        "        ring.apply_matrix(z_to_vector(line.get_vector()))\n",
        "        ring.move_to(line)\n",
        "        ring.set_flat_stroke(False)\n",
        "\n",
        "        super().__init__(*ring.replicate(n_rings))\n",
        "\n",
        "        self.growth_rate = growth_rate\n",
        "        self.spacing = spacing\n",
        "        self.width_decay_rate = width_decay_rate\n",
        "        self.start_width = start_width\n",
        "        self.time = 0\n",
        "\n",
        "        self.add_updater(lambda m, dt: self.update_rings(dt))\n",
        "\n",
        "    def update_rings(self, dt):\n",
        "        if dt == 0:\n",
        "            return\n",
        "        self.time += dt\n",
        "        space = 0\n",
        "        for ring in self.submobjects:\n",
        "            effective_time = max(self.time - space, 0)\n",
        "            target_radius = max(effective_time * self.growth_rate, 1e-3)\n",
        "            ring.scale(target_radius / ring.get_radius())\n",
        "            space += self.spacing\n",
        "            ring.set_stroke(width=np.exp(-self.width_decay_rate * effective_time))\n",
        "        return self\n",
        "\n",
        "\n",
        "class TwistedRibbon(ParametricSurface):\n",
        "    def __init__(\n",
        "        self,\n",
        "        axes,\n",
        "        amplitude,\n",
        "        twist_rate,\n",
        "        start_point=(0, 0, 0),\n",
        "        color=WHITE,\n",
        "        opacity=0.4,\n",
        "        resolution=(101, 11),\n",
        "    ):\n",
        "        super().__init__(\n",
        "            lambda u, v: axes.c2p(\n",
        "                u,\n",
        "                v * amplitude * np.sin(TAU * twist_rate * u),\n",
        "                v * amplitude * np.cos(TAU * twist_rate * u)\n",
        "            ),\n",
        "            u_range=axes.x_range[:2],\n",
        "            v_range=(-1, 1),\n",
        "            color=color,\n",
        "            opacity=opacity,\n",
        "            resolution=resolution,\n",
        "            prefered_creation_axis=0,\n",
        "        )\n",
        "        self.shift(axes.c2p(*start_point) - axes.get_origin())\n",
        "\n",
        "\n",
        "# For fields\n",
        "\n",
        "\n",
        "class ChargedParticle(Group):\n",
        "    def __init__(\n",
        "        self,\n",
        "        point=ORIGIN,\n",
        "        charge=1.0,\n",
        "        mass=1.0,\n",
        "        color=RED,\n",
        "        show_sign=True,\n",
        "        sign=\"+\",\n",
        "        radius=0.2,\n",
        "        rotation=0,\n",
        "        sign_stroke_width=2,\n",
        "        track_position_history=True,\n",
        "        history_size=7200,\n",
        "        euler_steps_per_frame=10,\n",
        "    ):\n",
        "        self.charge = charge\n",
        "        self.mass = mass\n",
        "\n",
        "        sphere = TrueDot(radius=radius, color=color)\n",
        "        sphere.make_3d()\n",
        "        sphere.move_to(point)\n",
        "        self.sphere = sphere\n",
        "\n",
        "        self.track_position_history = track_position_history\n",
        "        self.history_size = history_size\n",
        "        self.velocity = np.zeros(3)  # Only used if force are added\n",
        "        self.euler_steps_per_frame = euler_steps_per_frame\n",
        "        self.init_clock(point)\n",
        "\n",
        "        super().__init__(sphere)\n",
        "\n",
        "        if show_sign:\n",
        "            sign = Tex(sign)\n",
        "            sign.set_width(radius)\n",
        "            sign.rotate(rotation, RIGHT)\n",
        "            sign.set_stroke(WHITE, sign_stroke_width)\n",
        "            sign.move_to(sphere)\n",
        "            self.add(sign)\n",
        "            self.sign = sign\n",
        "\n",
        "    # Related to updaters\n",
        "\n",
        "    def update(self, dt: float = 0, recurse: bool = True):\n",
        "        super().update(dt, recurse)\n",
        "        # Do this instead of adding an updater, because\n",
        "        # otherwise all animations require the\n",
        "        # suspend_mobject_updating=false flag\n",
        "        self.increment_clock(dt)\n",
        "\n",
        "    def init_clock(self, start_point):\n",
        "        self.time = 0\n",
        "        self.time_step = 1 / 30  # This will be updated\n",
        "        self.recent_positions = np.tile(start_point, 3).reshape((3, 3))\n",
        "        if self.track_position_history:\n",
        "            self.position_history = np.zeros((self.history_size, 3))\n",
        "            self.acceleration_history = np.zeros((self.history_size, 3))\n",
        "            self.history_index = -1\n",
        "\n",
        "    def increment_clock(self, dt):\n",
        "        if dt == 0:\n",
        "            return self\n",
        "        self.time += dt\n",
        "        self.time_step = dt\n",
        "        self.recent_positions[0:2] = self.recent_positions[1:3]\n",
        "        self.recent_positions[2] = self.get_center()\n",
        "        if self.track_position_history:\n",
        "            self.add_to_position_history()\n",
        "\n",
        "    def add_to_position_history(self):\n",
        "        self.history_index += 1\n",
        "        hist_size = self.history_size\n",
        "        # If overflowing, copy second half of history\n",
        "        # lists to the first half, and reset index\n",
        "        if self.history_index >= hist_size:\n",
        "            for arr in [self.position_history, self.acceleration_history]:\n",
        "                arr[:hist_size // 2, :] = arr[hist_size // 2:, :]\n",
        "            self.history_index = (hist_size // 2) + 1\n",
        "\n",
        "        self.position_history[self.history_index] = self.get_center()\n",
        "        self.acceleration_history[self.history_index] = self.get_acceleration()\n",
        "        return self\n",
        "\n",
        "    def ignore_last_motion(self):\n",
        "        self.recent_positions[:] = self.get_center()\n",
        "        return self\n",
        "\n",
        "    def add_force(self, force_func: Callable[[Vect3], Vect3]):\n",
        "        espf = self.euler_steps_per_frame\n",
        "\n",
        "        def update_from_force(particle, dt):\n",
        "            if dt == 0:\n",
        "                return\n",
        "            for _ in range(espf):\n",
        "                acc = force_func(particle.get_center()) / self.mass\n",
        "                self.velocity += acc * dt / espf\n",
        "                self.shift(self.velocity * dt / espf)\n",
        "\n",
        "        self.add_updater(update_from_force)\n",
        "        return self\n",
        "\n",
        "    def add_spring_force(self, k=1.0, center=None):\n",
        "        center = center if center is not None else self.get_center().copy()\n",
        "        self.add_force(lambda p: k * (center - p))\n",
        "        return self\n",
        "\n",
        "    def add_field_force(self, field):\n",
        "        charge = self.get_charge()\n",
        "        self.add_force(lambda p: charge * field.get_forces([p])[0])\n",
        "        return self\n",
        "\n",
        "    def fix_x(self):\n",
        "        x = self.get_x()\n",
        "        self.add_updater(lambda m: m.set_x(x))\n",
        "\n",
        "    # Getters\n",
        "\n",
        "    def get_charge(self):\n",
        "        return self.charge\n",
        "\n",
        "    def get_radius(self):\n",
        "        return self.sphere.get_radius()\n",
        "\n",
        "    def get_internal_time(self):\n",
        "        return self.time\n",
        "\n",
        "    def scale(self, factor, *args, **kwargs):\n",
        "        super().scale(factor, *args, **kwargs)\n",
        "        self.sphere.set_radius(factor * self.sphere.get_radius())\n",
        "        return self\n",
        "\n",
        "    def get_acceleration(self):\n",
        "        p0, p1, p2 = self.recent_positions\n",
        "        # if (p0 == p1).all() or (p1 == p2).all():\n",
        "        if np.isclose(p0, p1).all() or np.isclose(p1, p2).all():\n",
        "            # Otherwise, starts and stops have artificially\n",
        "            # high acceleration\n",
        "            return np.zeros(3)\n",
        "        return (p0 + p2 - 2 * p1) / self.time_step**2\n",
        "\n",
        "    def get_info_from_delays(self, info_arr, delays):\n",
        "        if not hasattr(self, \"acceleration_history\"):\n",
        "            raise Exception(\"track_position_history is not turned on\")\n",
        "\n",
        "        if len(info_arr) == 0:\n",
        "            return np.zeros((len(delays), 3))\n",
        "\n",
        "        pre_indices = self.history_index - delays / self.time_step\n",
        "        indices = np.clip(pre_indices, 0, self.history_index).astype(int)\n",
        "\n",
        "        return info_arr[indices]\n",
        "\n",
        "    def get_past_acceleration(self, delays):\n",
        "        return self.get_info_from_delays(self.acceleration_history, delays)\n",
        "\n",
        "    def get_past_position(self, delays):\n",
        "        return self.get_info_from_delays(self.position_history, delays)\n",
        "\n",
        "\n",
        "class AccelerationVector(Vector):\n",
        "    def __init__(\n",
        "        self,\n",
        "        particle,\n",
        "        stroke_color=PINK,\n",
        "        stroke_width=4,\n",
        "        flat_stroke=False,\n",
        "        norm_func=lambda n: np.tanh(n),\n",
        "        **kwargs\n",
        "    ):\n",
        "        self.norm_func = norm_func\n",
        "\n",
        "        super().__init__(\n",
        "            RIGHT,\n",
        "            stroke_color=stroke_color,\n",
        "            stroke_width=stroke_width,\n",
        "            flat_stroke=flat_stroke,\n",
        "            **kwargs\n",
        "        )\n",
        "        self.add_updater(lambda m: m.pin_to_particle(particle))\n",
        "\n",
        "    def pin_to_particle(self, particle):\n",
        "        a_vect = particle.get_acceleration()\n",
        "        norm = get_norm(a_vect)\n",
        "        if self.norm_func is not None and norm > 0:\n",
        "            a_vect *= self.norm_func(norm) / norm\n",
        "        center = particle.get_center()\n",
        "        self.put_start_and_end_on(center, center + a_vect)\n",
        "\n",
        "\n",
        "class ChargeBasedVectorField(VectorField):\n",
        "    default_color = BLUE\n",
        "\n",
        "    def __init__(self, *charges, **kwargs):\n",
        "        self.charges = list(charges)\n",
        "        super().__init__(\n",
        "            self.get_forces,\n",
        "            color=kwargs.pop(\"color\", self.default_color),\n",
        "            **kwargs\n",
        "        )\n",
        "        self.add_updater(lambda m: m.update_vectors())\n",
        "\n",
        "    def get_forces(self, points):\n",
        "        # To be implemented in subclasses\n",
        "        return np.zeros_like(points)\n",
        "\n",
        "\n",
        "class CoulombField(ChargeBasedVectorField):\n",
        "    default_color = YELLOW\n",
        "\n",
        "    def get_forces(self, points):\n",
        "        return sum(\n",
        "            coulomb_force(points, charge)\n",
        "            for charge in self.charges\n",
        "        )\n",
        "\n",
        "\n",
        "class LorentzField(ChargeBasedVectorField):\n",
        "    def __init__(\n",
        "        self, *charges,\n",
        "        radius_of_suppression=None,\n",
        "        c=2.0,\n",
        "        **kwargs\n",
        "    ):\n",
        "        self.radius_of_suppression = radius_of_suppression\n",
        "        self.c = c\n",
        "        super().__init__(*charges, **kwargs)\n",
        "\n",
        "    def get_forces(self, points):\n",
        "        return sum(\n",
        "            lorentz_force(\n",
        "                points, charge,\n",
        "                radius=self.radius_of_suppression,\n",
        "                c=self.c\n",
        "            )\n",
        "            for charge in self.charges\n",
        "        )\n",
        "\n",
        "\n",
        "class ColoumbPlusLorentzField(LorentzField):\n",
        "    def get_forces(self, points):\n",
        "        return sum(\n",
        "            lorentz_force(\n",
        "                points, charge,\n",
        "                radius=self.radius_of_suppression,\n",
        "                c=self.c\n",
        "            ) + sum(\n",
        "                coulomb_force(points, charge)\n",
        "                for charge in self.charges\n",
        "            )\n",
        "            for charge in self.charges\n",
        "        )\n",
        "\n",
        "\n",
        "class GraphAsVectorField(VectorField):\n",
        "    def __init__(\n",
        "        self,\n",
        "        axes: Axes | ThreeDAxes,\n",
        "        # Maps x to y, or x to (y, z)\n",
        "        graph_func: Callable[[VectN], VectN] | Callable[[VectN], Tuple[VectN, VectN]],\n",
        "        x_density=10.0,\n",
        "        max_vect_len=np.inf,\n",
        "        **kwargs,\n",
        "    ):\n",
        "        self.sample_xs = np.arange(axes.x_axis.x_min, axes.x_axis.x_max, 1.0 / x_density)\n",
        "        self.axes = axes\n",
        "\n",
        "        def vector_func(points):\n",
        "            output = graph_func(self.sample_xs)\n",
        "            if isinstance(axes, ThreeDAxes):\n",
        "                graph_points = axes.c2p(self.sample_xs, *output)\n",
        "            else:\n",
        "                graph_points = axes.c2p(self.sample_xs, output)\n",
        "            base_points = axes.x_axis.n2p(self.sample_xs)\n",
        "            return graph_points - base_points\n",
        "\n",
        "        super().__init__(\n",
        "            func=vector_func,\n",
        "            max_vect_len=max_vect_len,\n",
        "            **kwargs\n",
        "        )\n",
        "        always(self.update_vectors)\n",
        "\n",
        "    def reset_sample_points(self):\n",
        "        self.sample_points = self.get_sample_points()\n",
        "\n",
        "    def get_sample_points(self, *args, **kwargs):\n",
        "        # Override super class and ignore all length/density information\n",
        "        return self.axes.x_axis.n2p(self.sample_xs)\n",
        "\n",
        "\n",
        "class OscillatingFieldWave(GraphAsVectorField):\n",
        "    def __init__(self, axes, wave, **kwargs):\n",
        "        self.wave = wave\n",
        "        if \"stroke_color\" not in kwargs:\n",
        "            kwargs[\"stroke_color\"] = wave.get_color()\n",
        "        super().__init__(\n",
        "            axes=axes,\n",
        "            graph_func=lambda x: wave.xt_to_yz(x, wave.time),\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "    def get_sample_points(self, *args, **kwargs):\n",
        "        # Override super class and ignore all length/density information\n",
        "        return self.wave.offset + self.axes.x_axis.n2p(self.sample_xs)\n",
        "\n",
        "\n",
        "# Structure\n",
        "\n",
        "\n",
        "class Molecule(Group):\n",
        "    # List of characters\n",
        "    atoms = []\n",
        "\n",
        "    # List of 3d coordinates\n",
        "    coordinates = np.zeros((0, 3))\n",
        "\n",
        "    # List of pairs of indices\n",
        "    bonds = []\n",
        "\n",
        "    atom_to_color = {\n",
        "        \"H\": WHITE,\n",
        "        \"O\": RED,\n",
        "        \"C\": GREY,\n",
        "    }\n",
        "    atom_to_radius = {\n",
        "        \"H\": 0.1,\n",
        "        \"O\": 0.2,\n",
        "        \"C\": 0.19,\n",
        "    }\n",
        "    ball_config = dict(shading=(0.25, 0.5, 0.5), glow_factor=0.25)\n",
        "    stick_config = dict(stroke_width=1, stroke_color=GREY_A, flat_stroke=False)\n",
        "\n",
        "    def __init__(self, height=2.0, **kwargs):\n",
        "        coords = np.array(self.coordinates)\n",
        "        radii = np.array([self.atom_to_radius[atom] for atom in self.atoms])\n",
        "        rgbas = np.array([color_to_rgba(self.atom_to_color[atom]) for atom in self.atoms])\n",
        "\n",
        "        balls = DotCloud(coords, **self.ball_config)\n",
        "        balls.set_radii(radii)\n",
        "        balls.set_rgba_array(rgbas)\n",
        "\n",
        "        sticks = VGroup()\n",
        "        for i, j in self.bonds:\n",
        "            c1, c2 = coords[[i, j], :]\n",
        "            r1, r2 = radii[[i, j]]\n",
        "            unit_vect = normalize(c2 - c1)\n",
        "\n",
        "            sticks.add(Line(\n",
        "                c1 + r1 * unit_vect, c2 - r2 * unit_vect,\n",
        "                **self.stick_config\n",
        "            ))\n",
        "\n",
        "        super().__init__(balls, sticks, **kwargs)\n",
        "\n",
        "        self.apply_depth_test()\n",
        "        self.balls = balls\n",
        "        self.sticks = sticks\n",
        "        self.set_height(height)\n",
        "\n",
        "\n",
        "class Sucrose(Molecule):\n",
        "    atoms = [\n",
        "        \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\",\n",
        "        \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\",\n",
        "        \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\", \"H\",\n",
        "    ]\n",
        "    coordinates = np.array([\n",
        "        [-1.468 ,  0.4385, -0.9184],\n",
        "        [-0.6033, -0.8919,  0.8122],\n",
        "        [ 0.9285,  0.4834, -0.3053],\n",
        "        [-3.0702, -2.0054,  1.1933],\n",
        "        [-4.62  ,  0.6319,  0.7326],\n",
        "        [ 1.2231,  0.2156,  2.5658],\n",
        "        [ 3.6108, -1.7286,  0.6379],\n",
        "        [ 3.15  ,  1.8347,  1.1537],\n",
        "        [-1.9582, -1.848 , -2.43  ],\n",
        "        [-1.3845,  3.245 , -0.8933],\n",
        "        [ 3.8369,  0.2057, -2.5044],\n",
        "        [-1.4947, -0.8632, -0.3037],\n",
        "        [-2.9301, -1.0229,  0.1866],\n",
        "        [-3.229 ,  0.3737,  0.6887],\n",
        "        [-2.5505,  1.2243, -0.3791],\n",
        "        [ 0.7534, -0.7453,  0.3971],\n",
        "        [ 1.6462, -0.7853,  1.639 ],\n",
        "        [ 3.1147, -0.5553,  1.2746],\n",
        "        [ 3.2915,  0.6577,  0.3521],\n",
        "        [ 2.2579,  0.7203, -0.7858],\n",
        "        [-1.0903, -1.9271, -1.3122],\n",
        "        [-2.0027,  2.5323,  0.1653],\n",
        "        [ 2.5886, -0.1903, -1.9666],\n",
        "        [-3.6217, -1.2732, -0.6273],\n",
        "        [-2.8148,  0.5301,  1.6917],\n",
        "        [-3.2289,  1.4361, -1.215 ],\n",
        "        [ 1.0588, -1.5992, -0.2109],\n",
        "        [ 1.5257, -1.753 ,  2.1409],\n",
        "        [ 3.6908, -0.4029,  2.1956],\n",
        "        [ 4.31  ,  0.675 , -0.0511],\n",
        "        [ 2.2441,  1.7505, -1.1644],\n",
        "        [-1.1311, -2.9324, -0.8803],\n",
        "        [-0.0995, -1.7686, -1.74  ],\n",
        "        [-1.2448,  2.3605,  0.9369],\n",
        "        [-2.799 ,  3.1543,  0.5841],\n",
        "        [ 1.821 , -0.1132, -2.7443],\n",
        "        [ 2.6532, -1.2446, -1.6891],\n",
        "        [-3.98  , -1.9485,  1.5318],\n",
        "        [-4.7364,  1.5664,  0.9746],\n",
        "        [ 0.2787,  0.0666,  2.7433],\n",
        "        [ 4.549 , -1.5769,  0.4327],\n",
        "        [ 3.3427,  2.6011,  0.5871],\n",
        "        [-1.6962, -2.5508, -3.0488],\n",
        "        [-0.679 ,  2.6806, -1.2535],\n",
        "        [ 3.7489,  1.1234, -2.8135],\n",
        "    ])\n",
        "    bonds = [\n",
        "        (0, 11),\n",
        "        (0, 14),\n",
        "        (1, 11),\n",
        "        (1, 15),\n",
        "        (2, 15),\n",
        "        (2, 19),\n",
        "        (3, 12),\n",
        "        (3, 37),\n",
        "        (4, 13),\n",
        "        (4, 38),\n",
        "        (5, 16),\n",
        "        (5, 39),\n",
        "        (6, 17),\n",
        "        (6, 40),\n",
        "        (7, 18),\n",
        "        (7, 41),\n",
        "        (8, 20),\n",
        "        (8, 42),\n",
        "        (9, 21),\n",
        "        (9, 43),\n",
        "        (10, 22),\n",
        "        (10, 44),\n",
        "        (11, 12),\n",
        "        (11, 20),\n",
        "        (12, 13),\n",
        "        (12, 23),\n",
        "        (13, 14),\n",
        "        (13, 24),\n",
        "        (14, 21),\n",
        "        (14, 25),\n",
        "        (15, 16),\n",
        "        (15, 26),\n",
        "        (16, 17),\n",
        "        (16, 27),\n",
        "        (17, 18),\n",
        "        (17, 28),\n",
        "        (18, 19),\n",
        "        (18, 29),\n",
        "        (19, 22),\n",
        "        (19, 30),\n",
        "        (20, 31),\n",
        "        (20, 32),\n",
        "        (21, 33),\n",
        "        (21, 34),\n",
        "        (22, 35),\n",
        "        (22, 36),\n",
        "    ]\n",
        "\n",
        "\n",
        "class Carbonate(Molecule):\n",
        "    # List of characters\n",
        "    atoms = [\"O\", \"O\", \"O\", \"C\", \"H\", \"H\"]\n",
        "\n",
        "    # List of 3d coordinates\n",
        "    coordinates = np.array([\n",
        "       [-6.9540e-01, -1.1061e+00,  0.0000e+00],\n",
        "       [-6.9490e-01,  1.1064e+00,  0.0000e+00],                                            \n",
        "       [ 1.3055e+00, -3.0000e-04,  1.0000e-04],\n",
        "       [ 8.4700e-02,  0.0000e+00, -1.0000e-04],\n",
        "       [-1.6350e-01, -1.9304e+00,  1.0000e-04],\n",
        "       [-1.6270e-01,  1.9305e+00,  1.0000e-04],\n",
        "    ])\n",
        "\n",
        "    # List of pairs of indices\n",
        "    bonds = [(0, 3), (0, 4), (1, 3), (1, 5), (2, 3)]\n",
        "    bond_types = [1, 1, 1, 1, 2]\n",
        "\n",
        "\n",
        "class Calcite(Molecule):\n",
        "    atoms = [\n",
        "        \"C\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"C\", \"Ca\", \"C\", \"O\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"C\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"C\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"Ca\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"Ca\", \"C\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \n",
        "    ]\n",
        "    atom_to_color = {\n",
        "        \"Ca\": GREEN,\n",
        "        \"O\": RED,\n",
        "        \"C\": GREY,\n",
        "    }\n",
        "    atom_to_radius = {\n",
        "        \"Ca\": 0.25,\n",
        "        \"O\": 0.2,\n",
        "        \"C\": 0.19,\n",
        "    }\n",
        "\n",
        "    coordinates = np.array([\n",
        "        [-1.43769337, -2.49015797,  1.41822405],\n",
        "        [-1.43769337,  2.49015797,  1.41822405],\n",
        "        [-2.87538675,   .00000000,  2.83644809],\n",
        "        [-2.87538675,   .00000000,  7.09112022],\n",
        "        [-2.48577184,  1.88504958,  1.41822404],\n",
        "        [-1.43769337, -1.27994119,  1.41822404],\n",
        "        [-1.43769337,  7.47047390,  1.41822405],\n",
        "        [-2.87538675,  4.98031594,  2.83644809],\n",
        "        [-2.87538675,  4.98031594,  7.09112022],\n",
        "        [-2.48577184,  6.86536552,  1.41822404],\n",
        "        [-1.43769337,  3.70037474,  1.41822404],\n",
        "        [-2.87538675,  1.21021677,  7.09112022],\n",
        "        [-2.87538675,  9.96063187,  2.83644809],\n",
        "        [-2.87538675,  9.96063187,  7.09112022],\n",
        "        [-1.43769337,  8.68069068,  1.41822404],\n",
        "        [-2.87538675,  6.19053271,  7.09112022],\n",
        "        [ 2.87538675,   .00000000,  1.41822405],\n",
        "        [ 1.43769337, -2.49015797,  2.83644809],\n",
        "        [ 1.43769337, -2.49015797,  7.09112022],\n",
        "        [ 1.82730828,  -.60510839,  1.41822404],\n",
        "        [ 2.87538675,  4.98031594,  1.41822405],\n",
        "        [ 1.43769337,  2.49015797,  2.83644809],\n",
        "        [ 1.43769337,  2.49015797,  7.09112022],\n",
        "        [ -.38961490,  1.88504958,  1.41822404],\n",
        "        [ 1.82730828,  4.37520755,  1.41822404],\n",
        "        [ 2.87538675,  1.21021677,  1.41822404],\n",
        "        [  .00000000,   .00000000,   .00000000],\n",
        "        [  .00000000,   .00000000,  8.50934427],\n",
        "        [  .00000000,   .00000000,  4.25467213],\n",
        "        [-1.04807847,   .60510839,  4.25467213],\n",
        "        [ 1.04807847,   .60510839,  4.25467213],\n",
        "        [  .00000000, -1.21021677,  4.25467213],\n",
        "        [-1.82730828,  -.60510839,  7.09112022],\n",
        "        [  .38961490,  1.88504958,  7.09112022],\n",
        "        [ 1.43769337, -1.27994119,  7.09112022],\n",
        "        [-1.43769337, -2.49015797,  5.67289618],\n",
        "        [-1.43769337, -2.49015797,  9.92756831],\n",
        "        [-2.48577184, -1.88504958,  9.92756831],\n",
        "        [ -.38961490, -1.88504958,  9.92756831],\n",
        "        [ 2.87538675,  9.96063187,  1.41822405],\n",
        "        [ 1.43769337,  7.47047390,  2.83644809],\n",
        "        [ 1.43769337,  7.47047390,  7.09112022],\n",
        "        [ -.38961490,  6.86536552,  1.41822404],\n",
        "        [ 1.82730828,  9.35552349,  1.41822404],\n",
        "        [ 2.87538675,  6.19053271,  1.41822404],\n",
        "        [  .00000000,  4.98031594,   .00000000],\n",
        "        [  .00000000,  4.98031594,  8.50934427],\n",
        "        [  .00000000,  4.98031594,  4.25467213],\n",
        "        [-1.04807847,  5.58542432,  4.25467213],\n",
        "        [ 1.04807847,  5.58542432,  4.25467213],\n",
        "        [  .00000000,  3.77009916,  4.25467213],\n",
        "        [-1.82730828,  4.37520755,  7.09112022],\n",
        "        [  .38961490,  6.86536552,  7.09112022],\n",
        "        [ 1.43769337,  3.70037474,  7.09112022],\n",
        "        [-1.43769337,  2.49015797,  5.67289618],\n",
        "        [-1.43769337,  2.49015797,  9.92756831],\n",
        "        [-2.48577184,  3.09526635,  9.92756831],\n",
        "        [ -.38961490,  3.09526635,  9.92756831],\n",
        "        [-1.43769337,  1.27994120,  9.92756831],\n",
        "        [  .00000000,  9.96063187,   .00000000],\n",
        "        [  .00000000,  9.96063187,  8.50934427],\n",
        "        [  .00000000,  9.96063187,  4.25467213],\n",
        "        [-1.04807847, 10.56574026,  4.25467213],\n",
        "        [ 1.04807847, 10.56574026,  4.25467213],\n",
        "        [  .00000000,  8.75041510,  4.25467213],\n",
        "        [-1.82730828,  9.35552349,  7.09112022],\n",
        "        [ 1.43769337,  8.68069068,  7.09112022],\n",
        "        [-1.43769337,  7.47047390,  5.67289618],\n",
        "        [-1.43769337,  7.47047390,  9.92756831],\n",
        "        [-2.48577184,  8.07558229,  9.92756831],\n",
        "        [ -.38961490,  8.07558229,  9.92756831],\n",
        "        [-1.43769337,  6.26025713,  9.92756831],\n",
        "        [ 7.18846687, -2.49015797,  1.41822405],\n",
        "        [ 7.18846687,  2.49015797,  1.41822405],\n",
        "        [ 5.75077349,   .00000000,  2.83644809],\n",
        "        [ 5.75077349,   .00000000,  7.09112022],\n",
        "        [ 3.92346522,  -.60510839,  1.41822404],\n",
        "        [ 6.14038840,  1.88504958,  1.41822404],\n",
        "        [ 7.18846687, -1.27994119,  1.41822404],\n",
        "        [ 4.31308012, -2.49015797,   .00000000],\n",
        "        [ 4.31308012, -2.49015797,  8.50934427],\n",
        "        [ 4.31308012, -2.49015797,  4.25467213],\n",
        "        [ 3.26500165, -1.88504958,  4.25467213],\n",
        "        [ 5.36115859, -1.88504958,  4.25467213],\n",
        "        [ 4.70269502,  -.60510839,  7.09112022],\n",
        "        [ 7.18846687,  7.47047390,  1.41822405],\n",
        "        [ 5.75077349,  4.98031594,  2.83644809],\n",
        "        [ 5.75077349,  4.98031594,  7.09112022],\n",
        "        [ 3.92346522,  4.37520755,  1.41822404],\n",
        "        [ 6.14038840,  6.86536552,  1.41822404],\n",
        "        [ 7.18846687,  3.70037474,  1.41822404],\n",
        "        [ 4.31308012,  2.49015797,   .00000000],\n",
        "        [ 4.31308012,  2.49015797,  8.50934427],\n",
        "        [ 4.31308012,  2.49015797,  4.25467213],\n",
        "        [ 3.26500165,  3.09526635,  4.25467213],\n",
        "        [ 5.36115859,  3.09526635,  4.25467213],\n",
        "        [ 4.31308012,  1.27994120,  4.25467213],\n",
        "        [ 2.48577184,  1.88504958,  7.09112022],\n",
        "        [ 4.70269502,  4.37520755,  7.09112022],\n",
        "        [ 5.75077349,  1.21021677,  7.09112022],\n",
        "        [ 2.87538675,   .00000000,  5.67289618],\n",
        "        [ 2.87538675,   .00000000,  9.92756831],\n",
        "        [ 1.82730828,   .60510839,  9.92756831],\n",
        "        [ 3.92346522,   .60510839,  9.92756831],\n",
        "        [ 2.87538675, -1.21021677,  9.92756831],\n",
        "        [ 5.75077349,  9.96063187,  2.83644809],\n",
        "        [ 5.75077349,  9.96063187,  7.09112022],\n",
        "        [ 3.92346522,  9.35552349,  1.41822404],\n",
        "        [ 7.18846687,  8.68069068,  1.41822404],\n",
        "        [ 4.31308012,  7.47047390,   .00000000],\n",
        "        [ 4.31308012,  7.47047390,  8.50934427],\n",
        "        [ 4.31308012,  7.47047390,  4.25467213],\n",
        "        [ 3.26500165,  8.07558229,  4.25467213],\n",
        "        [ 5.36115859,  8.07558229,  4.25467213],\n",
        "        [ 4.31308012,  6.26025713,  4.25467213],\n",
        "        [ 2.48577184,  6.86536552,  7.09112022],\n",
        "        [ 4.70269502,  9.35552349,  7.09112022],\n",
        "        [ 5.75077349,  6.19053271,  7.09112022],\n",
        "        [ 2.87538675,  4.98031594,  5.67289618],\n",
        "        [ 2.87538675,  4.98031594,  9.92756831],\n",
        "        [ 1.82730828,  5.58542432,  9.92756831],\n",
        "        [ 3.92346522,  5.58542432,  9.92756831],\n",
        "        [ 2.87538675,  3.77009916,  9.92756831],\n",
        "        [ 2.87538675,  9.96063187,  5.67289618],\n",
        "        [ 2.87538675,  9.96063187,  9.92756831],\n",
        "        [ 1.82730828, 10.56574026,  9.92756831],\n",
        "        [ 3.92346522, 10.56574026,  9.92756831],\n",
        "        [ 2.87538675,  8.75041510,  9.92756831],\n",
        "        [10.06385361, -2.49015797,  2.83644809],\n",
        "        [10.06385361, -2.49015797,  7.09112022],\n",
        "        [10.45346852,  -.60510839,  1.41822404],\n",
        "        [10.06385361,  2.49015797,  2.83644809],\n",
        "        [10.06385361,  2.49015797,  7.09112022],\n",
        "        [ 8.23654533,  1.88504958,  1.41822404],\n",
        "        [10.45346852,  4.37520755,  1.41822404],\n",
        "        [ 8.62616024,   .00000000,   .00000000],\n",
        "        [ 8.62616024,   .00000000,  8.50934427],\n",
        "        [ 8.62616024,   .00000000,  4.25467213],\n",
        "        [ 7.57808177,   .60510839,  4.25467213],\n",
        "        [ 9.67423871,   .60510839,  4.25467213],\n",
        "        [ 8.62616024, -1.21021677,  4.25467213],\n",
        "        [ 6.79885196,  -.60510839,  7.09112022],\n",
        "        [ 9.01577514,  1.88504958,  7.09112022],\n",
        "        [10.06385361, -1.27994119,  7.09112022],\n",
        "        [ 7.18846687, -2.49015797,  5.67289618],\n",
        "        [ 7.18846687, -2.49015797,  9.92756831],\n",
        "        [ 6.14038840, -1.88504958,  9.92756831],\n",
        "        [ 8.23654533, -1.88504958,  9.92756831],\n",
        "        [10.06385361,  7.47047390,  2.83644809],\n",
        "        [10.06385361,  7.47047390,  7.09112022],\n",
        "        [ 8.23654533,  6.86536552,  1.41822404],\n",
        "        [10.45346852,  9.35552349,  1.41822404],\n",
        "        [ 8.62616024,  4.98031594,   .00000000],\n",
        "        [ 8.62616024,  4.98031594,  8.50934427],\n",
        "        [ 8.62616024,  4.98031594,  4.25467213],\n",
        "        [ 7.57808177,  5.58542432,  4.25467213],\n",
        "        [ 9.67423871,  5.58542432,  4.25467213],\n",
        "        [ 8.62616024,  3.77009916,  4.25467213],\n",
        "        [ 6.79885196,  4.37520755,  7.09112022],\n",
        "        [ 9.01577514,  6.86536552,  7.09112022],\n",
        "        [10.06385361,  3.70037474,  7.09112022],\n",
        "        [ 7.18846687,  2.49015797,  5.67289618],\n",
        "        [ 7.18846687,  2.49015797,  9.92756831],\n",
        "        [ 6.14038840,  3.09526635,  9.92756831],\n",
        "        [ 8.23654533,  3.09526635,  9.92756831],\n",
        "        [ 7.18846687,  1.27994120,  9.92756831],\n",
        "        [ 8.62616024,  9.96063187,   .00000000],\n",
        "        [ 8.62616024,  9.96063187,  8.50934427],\n",
        "        [ 8.62616024,  9.96063187,  4.25467213],\n",
        "        [ 7.57808177, 10.56574026,  4.25467213],\n",
        "        [ 9.67423871, 10.56574026,  4.25467213],\n",
        "        [ 8.62616024,  8.75041510,  4.25467213],\n",
        "        [ 6.79885196,  9.35552349,  7.09112022],\n",
        "        [10.06385361,  8.68069068,  7.09112022],\n",
        "        [ 7.18846687,  7.47047390,  5.67289618],\n",
        "        [ 7.18846687,  7.47047390,  9.92756831],\n",
        "        [ 6.14038840,  8.07558229,  9.92756831],\n",
        "        [ 8.23654533,  8.07558229,  9.92756831],\n",
        "        [ 7.18846687,  6.26025713,  9.92756831],\n",
        "        [10.45346852,   .60510839,  9.92756831],\n",
        "        [10.45346852,  5.58542432,  9.92756831],\n",
        "        [10.45346852, 10.56574026,  9.92756831],\n",
        "    ])\n",
        "\n",
        "\n"
    ]
}