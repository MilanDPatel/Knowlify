{
    "topic": "demonstrates the concept of a multilayered glass, where each layer has a",
    "code": [
        "import numpy as np\n",
        "import itertools as it\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from from_3b1b.old.brachistochrone.curves import Cycloid\n",
        "\n",
        "class MultilayeredGlass(PhotonScene, ZoomedScene):\n",
        "    CONFIG = {\n",
        "        \"num_discrete_layers\" : 5,\n",
        "        \"num_variables\" : 3,\n",
        "        \"top_color\" : BLUE_E,\n",
        "        \"bottom_color\" : BLUE_A,\n",
        "        \"zoomed_canvas_frame_shape\" : (5, 5),\n",
        "        \"square_color\" : GREEN_B,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.cycloid = Cycloid(end_theta = np.pi)\n",
        "        self.cycloid.set_color(YELLOW)\n",
        "        self.top = self.cycloid.get_top()[1]\n",
        "        self.bottom = self.cycloid.get_bottom()[1]-1\n",
        "        self.generate_layers()\n",
        "        self.generate_discrete_path()\n",
        "        photon_run = self.photon_run_along_path(\n",
        "            self.discrete_path,\n",
        "            run_time = 1,\n",
        "            rate_func = rush_into\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "        self.continuous_to_smooth()\n",
        "        self.add(*self.layers)\n",
        "        self.show_layer_variables()\n",
        "        self.play(photon_run)\n",
        "        self.play(ShowCreation(self.discrete_path))\n",
        "        self.isolate_bend_points()\n",
        "        self.clear()\n",
        "        self.add(*self.layers)\n",
        "        self.show_main_equation()\n",
        "        self.ask_continuous_question()\n",
        "\n",
        "    def continuous_to_smooth(self):\n",
        "        self.add(*self.layers)\n",
        "        continuous = self.get_continuous_background()\n",
        "        self.add(continuous)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(\n",
        "            continuous,\n",
        "            rate_func = lambda t : smooth(1-t)\n",
        "        ))\n",
        "        self.remove(continuous)\n",
        "        self.wait()\n",
        "        \n",
        "    def get_continuous_background(self):\n",
        "        glass = FilledRectangle(\n",
        "            height = self.top-self.bottom,\n",
        "            width = FRAME_WIDTH,\n",
        "        )\n",
        "        glass.sort_points(lambda p : -p[1])\n",
        "        glass.shift((self.top-glass.get_top()[1])*UP)\n",
        "        glass.set_color_by_gradient(self.top_color, self.bottom_color)\n",
        "        return glass\n",
        "\n",
        "    def generate_layer_info(self):\n",
        "        self.layer_thickness = float(self.top-self.bottom)/self.num_discrete_layers\n",
        "        self.layer_tops = np.arange(\n",
        "            self.top, self.bottom, -self.layer_thickness\n",
        "        )\n",
        "        top_rgb, bottom_rgb = [\n",
        "            np.array(Color(color).get_rgb())\n",
        "            for color in (self.top_color, self.bottom_color)\n",
        "        ]\n",
        "        epsilon = 1./(self.num_discrete_layers-1)\n",
        "        self.layer_colors = [\n",
        "            Color(rgb = interpolate(top_rgb, bottom_rgb, alpha))\n",
        "            for alpha in np.arange(0, 1+epsilon, epsilon)\n",
        "        ]\n",
        "\n",
        "    def generate_layers(self):\n",
        "        self.generate_layer_info()\n",
        "        def create_region(top, color):\n",
        "            return Region(\n",
        "                lambda x, y : (y < top) & (y > top-self.layer_thickness),\n",
        "                color = color\n",
        "            )\n",
        "        self.layers = [\n",
        "            create_region(top, color)\n",
        "            for top, color in zip(self.layer_tops, self.layer_colors)\n",
        "        ]\n",
        "\n",
        "\n",
        "    def generate_discrete_path(self):\n",
        "        points = self.cycloid.points\n",
        "        tops = list(self.layer_tops)\n",
        "        tops.append(tops[-1]-self.layer_thickness)\n",
        "        indices = [\n",
        "            np.argmin(np.abs(points[:, 1]-top))\n",
        "            for top in tops\n",
        "        ]\n",
        "        self.bend_points = points[indices[1:-1]]\n",
        "        self.path_angles = []\n",
        "        self.discrete_path = Mobject1D(\n",
        "            color = YELLOW,\n",
        "            density = 3*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        for start, end in zip(indices, indices[1:]):\n",
        "            start_point, end_point = points[start], points[end]\n",
        "            self.discrete_path.add_line(\n",
        "                start_point, end_point\n",
        "            )\n",
        "            self.path_angles.append(\n",
        "                angle_of_vector(start_point-end_point)-np.pi/2\n",
        "            )\n",
        "        self.discrete_path.add_line(\n",
        "            points[end], FRAME_X_RADIUS*RIGHT+(self.layer_tops[-1]-1)*UP\n",
        "        )\n",
        "\n",
        "    def show_layer_variables(self):\n",
        "        layer_top_pairs = list(zip(\n",
        "            self.layer_tops[:self.num_variables], \n",
        "            self.layer_tops[1:]\n",
        "        ))\n",
        "        v_equations = []\n",
        "        start_ys = []\n",
        "        end_ys = []\n",
        "        center_paths = []\n",
        "        braces = []\n",
        "        for (top1, top2), x in zip(layer_top_pairs, it.count(1)):\n",
        "            eq_mob = OldTex(\n",
        "                [\"v_%d\"%x, \"=\", \"\\sqrt{\\phantom{y_1}}\"],\n",
        "                size = \"\\\\Large\"\n",
        "            )\n",
        "            midpoint = UP*(top1+top2)/2\n",
        "            eq_mob.shift(midpoint)\n",
        "            v_eq = eq_mob.split()\n",
        "            center_paths.append(Line(\n",
        "                midpoint+FRAME_X_RADIUS*LEFT, \n",
        "                midpoint+FRAME_X_RADIUS*RIGHT\n",
        "            ))            \n",
        "            brace_endpoints = Mobject(\n",
        "                Point(self.top*UP+x*RIGHT),\n",
        "                Point(top2*UP+x*RIGHT)\n",
        "            )\n",
        "            brace = Brace(brace_endpoints, RIGHT)\n",
        "\n",
        "            start_y = OldTex(\"y_%d\"%x, size = \"\\\\Large\")\n",
        "            end_y = start_y.copy()            \n",
        "            start_y.next_to(brace, RIGHT)\n",
        "            end_y.shift(v_eq[-1].get_center())\n",
        "            end_y.shift(0.2*RIGHT)\n",
        "\n",
        "            v_equations.append(v_eq)\n",
        "            start_ys.append(start_y)\n",
        "            end_ys.append(end_y)\n",
        "            braces.append(brace)\n",
        "\n",
        "        for v_eq, path, time in zip(v_equations, center_paths, [2, 1, 0.5]):\n",
        "            photon_run = self.photon_run_along_path(\n",
        "                path,\n",
        "                rate_func=linear\n",
        "            )\n",
        "            self.play(\n",
        "                ShimmerIn(v_eq[0]),\n",
        "                photon_run,\n",
        "                run_time = time\n",
        "            )\n",
        "        self.wait()\n",
        "        for start_y, brace in zip(start_ys, braces):\n",
        "            self.add(start_y)            \n",
        "            self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        quads = list(zip(v_equations, start_ys, end_ys, braces))\n",
        "        self.equations = []\n",
        "        for v_eq, start_y, end_y, brace in quads:\n",
        "            self.remove(brace)\n",
        "            self.play(\n",
        "                ShowCreation(v_eq[1]),\n",
        "                ShowCreation(v_eq[2]),\n",
        "                Transform(start_y, end_y)\n",
        "            )\n",
        "\n",
        "            v_eq.append(start_y)\n",
        "            self.equations.append(Mobject(*v_eq))\n",
        "\n",
        "    def isolate_bend_points(self):\n",
        "        arc_radius = 0.1\n",
        "        self.activate_zooming()\n",
        "        little_square = self.get_zoomed_camera_mobject()\n",
        "\n",
        "        for index in range(3):\n",
        "            bend_point = self.bend_points[index]\n",
        "            line = Line(\n",
        "                bend_point+DOWN, \n",
        "                bend_point+UP,\n",
        "                color = WHITE,\n",
        "                density = self.zoom_factor*DEFAULT_POINT_DENSITY_1D\n",
        "            )\n",
        "            angle_arcs = []\n",
        "            for i, rotation in [(index, np.pi/2), (index+1, -np.pi/2)]:\n",
        "                arc = Arc(angle = self.path_angles[i])\n",
        "                arc.scale(arc_radius)\n",
        "                arc.rotate(rotation)\n",
        "                arc.shift(bend_point)\n",
        "                angle_arcs.append(arc)\n",
        "            thetas = []\n",
        "            for i in [index+1, index+2]:\n",
        "                theta = OldTex(\"\\\\theta_%d\"%i)\n",
        "                theta.scale(0.5/self.zoom_factor)\n",
        "                vert = UP if i == index+1 else DOWN\n",
        "                horiz = rotate_vector(vert, np.pi/2)\n",
        "                theta.next_to(\n",
        "                    Point(bend_point), \n",
        "                    horiz, \n",
        "                    buff = 0.01\n",
        "                )\n",
        "                theta.shift(1.5*arc_radius*vert)\n",
        "                thetas.append(theta)\n",
        "            figure_marks = [line] + angle_arcs + thetas                \n",
        "\n",
        "            self.play(ApplyMethod(\n",
        "                little_square.shift,\n",
        "                bend_point - little_square.get_center(),\n",
        "                run_time = 2\n",
        "            ))\n",
        "            self.play(*list(map(ShowCreation, figure_marks)))\n",
        "            self.wait()\n",
        "            equation_frame = little_square.copy()\n",
        "            equation_frame.scale(0.5)\n",
        "            equation_frame.shift(\n",
        "                little_square.get_corner(UP+RIGHT) - \\\n",
        "                equation_frame.get_corner(UP+RIGHT)\n",
        "            )\n",
        "            equation_frame.scale(0.9)\n",
        "            self.show_snells(index+1, equation_frame)\n",
        "            self.remove(*figure_marks)\n",
        "        self.disactivate_zooming()\n",
        "\n",
        "    def show_snells(self, index, frame):\n",
        "        left_text, right_text = [\n",
        "            \"\\\\dfrac{\\\\sin(\\\\theta_%d)}{\\\\phantom{\\\\sqrt{y_1}}}\"%x\n",
        "            for x in (index, index+1)\n",
        "        ]\n",
        "        left, equals, right = OldTex(\n",
        "            [left_text, \"=\", right_text]\n",
        "        ).split()\n",
        "        vs = []\n",
        "        sqrt_ys = []\n",
        "        for x, numerator in [(index, left), (index+1, right)]:\n",
        "            v, sqrt_y = [\n",
        "                OldTex(\n",
        "                    text, size = \"\\\\Large\"\n",
        "                ).next_to(numerator, DOWN)\n",
        "                for text in (\"v_%d\"%x, \"\\\\sqrt{y_%d}\"%x)\n",
        "            ]\n",
        "            vs.append(v)\n",
        "            sqrt_ys.append(sqrt_y)\n",
        "        start, end = [\n",
        "            Mobject(\n",
        "                left.copy(), mobs[0], equals.copy(), right.copy(), mobs[1]\n",
        "            ).replace(frame)\n",
        "            for mobs in (vs, sqrt_ys)\n",
        "        ]\n",
        "\n",
        "        self.add(start)\n",
        "        self.wait(2)\n",
        "        self.play(Transform(\n",
        "            start, end, \n",
        "            path_func = counterclockwise_path()\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.remove(start, end)\n",
        "\n",
        "    def show_main_equation(self):\n",
        "        self.equation = OldTex(\"\"\"\n",
        "            \\\\dfrac{\\\\sin(\\\\theta)}{\\\\sqrt{y}} = \n",
        "            \\\\text{constant}\n",
        "        \"\"\")\n",
        "        self.equation.shift(LEFT)\n",
        "        self.equation.shift(\n",
        "            (self.layer_tops[0]-self.equation.get_top())*UP\n",
        "        )\n",
        "        self.add(self.equation)\n",
        "        self.wait()\n",
        "\n",
        "    def ask_continuous_question(self):\n",
        "        continuous = self.get_continuous_background()\n",
        "        line = Line(\n",
        "            UP, DOWN,\n",
        "            density = self.zoom_factor*DEFAULT_POINT_DENSITY_1D\n",
        "        )\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.scale(0.5/self.zoom_factor)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(continuous),\n",
        "            Animation(self.equation)\n",
        "        )\n",
        "        self.remove(*self.layers)\n",
        "        self.play(ShowCreation(self.cycloid))\n",
        "        self.activate_zooming()\n",
        "        little_square = self.get_zoomed_camera_mobject()\n",
        "\n",
        "        self.add(line)\n",
        "        indices = np.arange(\n",
        "            0, self.cycloid.get_num_points()-1, 10\n",
        "        )\n",
        "        for index in indices:\n",
        "            point = self.cycloid.get_points()[index]\n",
        "            next_point = self.cycloid.get_points()[index+1]\n",
        "            angle = angle_of_vector(point - next_point)\n",
        "            for mob in little_square, line:\n",
        "                mob.shift(point - mob.get_center())\n",
        "            arc = Arc(angle-np.pi/2, start_angle = np.pi/2)\n",
        "            arc.scale(0.1)\n",
        "            arc.shift(point)\n",
        "            self.add(arc)\n",
        "            if angle > np.pi/2 + np.pi/6:\n",
        "                vect_angle = interpolate(np.pi/2, angle, 0.5)\n",
        "                vect = rotate_vector(RIGHT, vect_angle)\n",
        "                theta.center()\n",
        "                theta.shift(point)\n",
        "                theta.shift(0.15*vect)\n",
        "                self.add(theta)\n",
        "            self.wait(self.frame_duration)\n",
        "            self.remove(arc)"
    ]
}