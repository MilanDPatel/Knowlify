{
    "topic": "demonstrates the concept of a bell curve, which is a mathematical representation of a normal distribution",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2023.convolutions2.continuous import *\n",
        "\n",
        "\n",
        "class IntroWords(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        title1 = Text(\"Last video\", font_size=72)\n",
        "        title1.to_edge(UP)\n",
        "        title2 = Text(\"Today: An important example\", font_size=72)\n",
        "        title2.move_to(title1)\n",
        "        VGroup(title1, title2).set_backstroke(width=3)\n",
        "\n",
        "        self.play(Write(title1, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(title1, 0.5 * UP),\n",
        "            FadeIn(title2, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NewIntroWords(InteractiveScene):\n",
        "    def construct(self):\n",
        "        kw = dict(font_size=66)\n",
        "        words = VGroup(\n",
        "            Text(\"Last chapter\", **kw),\n",
        "            Text(\"Convolution between two Gaussians\", **kw),\n",
        "            Text(\"Central Limit Theorem\", **kw),\n",
        "            Text(\"Today: A satisfying visual argument\", **kw),\n",
        "        )\n",
        "        words.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        last_word = VMobject()\n",
        "        for word in words:\n",
        "            self.play(\n",
        "                FadeOut(last_word, 0.5 * UP),\n",
        "                FadeIn(word, 0.5 * UP),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_word = word\n",
        "\n",
        "\n",
        "class MultipleBellishCurves(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        line_style = dict(stroke_color=GREY_B, stroke_width=1)\n",
        "        faded_line_style = dict(stroke_opacity=0.25, **line_style)\n",
        "        all_axes = VGroup(*(\n",
        "            NumberPlane(\n",
        "                (-3, 3), (0, 1, 0.5),\n",
        "                height=1.5, width=4,\n",
        "                background_line_style=line_style,\n",
        "                faded_line_style=faded_line_style,\n",
        "            )\n",
        "            for _ in range(3)\n",
        "        ))\n",
        "        all_axes.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        all_axes.to_edge(LEFT)\n",
        "\n",
        "        # Graphs\n",
        "        def pseudo_bell(x):\n",
        "            A = np.abs(x) + np.exp(-1)\n",
        "            return np.exp(-np.exp(-1)) * A**(-A)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            all_axes[0].get_graph(lambda x: np.exp(-x**2)),\n",
        "            all_axes[1].get_graph(lambda x: 1 / (1 + x**2)),\n",
        "            all_axes[2].get_graph(pseudo_bell),\n",
        "        )\n",
        "        labels = VGroup(\n",
        "            Tex(\"e^{-x^2}\"),\n",
        "            Tex(R\"\\frac{1}{1 + x^2}\"),\n",
        "            Tex(\n",
        "                R\"e^{-1 / e}\\left(|x|+\\frac{1}{e}\\right)^{-\\left(|x|+\\frac{1}{e}\\right)}\",\n",
        "                font_size=40\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        plots = VGroup()\n",
        "        colors = color_gradient([YELLOW, RED], 3)\n",
        "        for axes, label, graph, color in zip(all_axes, labels, graphs, colors):\n",
        "            label.next_to(axes, RIGHT)\n",
        "            graph.set_stroke(color, 3)\n",
        "            plots.add(VGroup(axes, graph))\n",
        "\n",
        "        # Show initial graph\n",
        "        plot = plots[0]\n",
        "        plot.save_state()\n",
        "        plot.center()\n",
        "        plot.set_height(4)\n",
        "        label = labels[0]\n",
        "        label.save_state()\n",
        "        label.set_height(1.25)\n",
        "        label.next_to(plot.get_corner(UR), DL)\n",
        "        words = Text(\"Normal Distribution (aka Gaussian)\", font_size=60)\n",
        "        words.next_to(plot, UP, MED_LARGE_BUFF)\n",
        "        words.save_state()\n",
        "        normal = words[\"Normal Distribution\"]\n",
        "        gaussian = words[\"(aka Gaussian)\"]\n",
        "        gaussian.set_opacity(0)\n",
        "        normal.set_x(0)\n",
        "        gaussian.set_x(0)\n",
        "\n",
        "        self.add(plot)\n",
        "        self.add(words)\n",
        "        graph_copy = plot[1].copy()\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            plot[1], lambda m, a: m.pointwise_become_partial(\n",
        "                graph_copy, 0.5 - 0.5 * a, 0.5 + 0.5 * a\n",
        "            ),\n",
        "            run_time=2,\n",
        "        ))\n",
        "        self.play(words.animate.restore())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(label),\n",
        "            VShowPassingFlash(\n",
        "                graph_copy.set_stroke(YELLOW, width=10),\n",
        "                time_width=2,\n",
        "                run_time=3,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ask why\n",
        "        question = Text(\"Why this function?\", font_size=60)\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(label.saved_state, RIGHT)\n",
        "        question.next_to(arrow, RIGHT)\n",
        "        self.play(\n",
        "            plot.animate.restore(),\n",
        "            label.animate.restore(),\n",
        "            words.animate.match_width(plot.saved_state).next_to(plot.saved_state, UP, SMALL_BUFF),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(question, lag_ratio=0.1, shift=0.2 * LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        last_plot = plot\n",
        "        last_label = label\n",
        "        for plot, label in zip(plots[1:], labels[1:]):\n",
        "            self.play(\n",
        "                TransformFromCopy(last_plot, plot),\n",
        "                TransformMatchingTex(last_label.copy(), label, run_time=1),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_plot = plot\n",
        "            last_label = label\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight first function\n",
        "        l0 = labels[0]\n",
        "        l0.generate_target()\n",
        "        l0.target.set_height(1.0, about_edge=DL)\n",
        "        l0.target.shift(0.1 * RIGHT)\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(l0),\n",
        "            VGroup(arrow, question).animate.next_to(l0.target, RIGHT, aligned_edge=DOWN),\n",
        "            labels[1:].animate.fade(0.5),\n",
        "            plots[1:].animate.fade(0.5),\n",
        "            FlashAround(l0.target, time_width=1.5),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LastFewVideos(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "\n",
        "        # Images\n",
        "        root = \"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/\"\n",
        "        images = Group(*(\n",
        "            ImageMobject(os.path.join(root, ext))\n",
        "            for ext in [\n",
        "                \"2022/convolutions/discrete/images/EquationThumbnail.png\",\n",
        "                \"2023/clt/main/images/Thumbnail.png\",\n",
        "                \"2023/clt/Thumbnail.jpg\",\n",
        "                \"2023/convolutions2/Thumbnail/Thumbnail2.png\",\n",
        "            ]\n",
        "        ))\n",
        "        titles = VGroup(*(\n",
        "            Text(\"Convolutions (discrete)\"),\n",
        "            Text(\"Central limit theorem\"),\n",
        "            TexText(R\"Why $\\pi$ is in a Gaussian\"),\n",
        "            Text(\"Convolutions (continuous)\"),\n",
        "        ))\n",
        "        titles.scale(1.4)\n",
        "        thumbnails = Group()\n",
        "        for image, title in zip(images, titles):\n",
        "            rect = SurroundingRectangle(image, buff=0)\n",
        "            rect.set_stroke(WHITE, 3)\n",
        "            title.next_to(image, UP, buff=MED_LARGE_BUFF)\n",
        "            thumbnails.add(Group(rect, image, title))\n",
        "\n",
        "        thumbnails.arrange_in_grid(buff=thumbnails[0].get_width() * 0.2)\n",
        "        thumbnails.set_height(FRAME_HEIGHT - 1)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, thumbnails, shift=UP, lag_ratio=0.7, run_time=4))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AddingCopiesOfAVariable(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        expr = Tex(R\"X_1 + X_2 + \\cdots + X_N \\text{ is approximately Gaussian}\")\n",
        "        expr.set_fill(GREY_A)\n",
        "        expr_lhs = expr[R\"X_1 + X_2 + \\cdots + X_N\"][0]\n",
        "        expr.to_edge(UP)\n",
        "        expr_lhs.save_state()\n",
        "        expr_lhs.set_x(0)\n",
        "\n",
        "        self.play(FadeIn(expr_lhs, lag_ratio=0.5, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(expr_lhs),\n",
        "            Write(expr[len(expr_lhs):], run_time=1)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Limit\n",
        "        expr2 = Tex(R\"X_1 + X_2 + \\cdots + X_N \\longrightarrow \\text{Gaussian}\")\n",
        "        expr2.match_style(expr)\n",
        "        expr2.move_to(expr)\n",
        "        lim = Tex(R\"N \\to \\infty\", font_size=24)\n",
        "        lim.next_to(expr2[R\"\\longrightarrow\"], UP, buff=0.1)\n",
        "        lim.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(expr, expr2),\n",
        "            FadeIn(lim, 0.25 * UP, time_span=(1, 2))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class WhyGaussian(InteractiveScene):\n",
        "    def construct(self):\n",
        "        question = TexText(\"What makes $e^{-x^2}$ special?\", font_size=60)\n",
        "        question.to_edge(UP, buff=LARGE_BUFF)\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutConvolution(InteractiveScene):\n",
        "    def construct(self):\n",
        "        text = TexText(\n",
        "            \"Convolution between $e^{-x^2}$ and $e^{-y^2}$\",\n",
        "            t2c={\"x\": BLUE, \"y\": YELLOW},\n",
        "            font_size=60\n",
        "        )\n",
        "        text.to_edge(UP, buff=MED_LARGE_BUFF)\n",
        "        text.set_backstroke(width=2)\n",
        "        self.add(text)\n",
        "\n",
        "\n",
        "class PreviewExplicitCalculation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        goal = Text(\"Goal: Compute a convolution between two Gaussian functions\")\n",
        "        goal.set_width(FRAME_WIDTH - 1)\n",
        "        goal.to_edge(UP)\n",
        "        conv_word = goal[\"convolution\"]\n",
        "        gauss_word = goal[\"Gaussian\"]\n",
        "\n",
        "        self.add(goal)\n",
        "\n",
        "        # Convolution\n",
        "        conv_color = BLUE\n",
        "        tex_kw = dict(\n",
        "            t2c={\"{f}\": BLUE, \"{g}\": TEAL, R\"\\sigma_1\": RED, R\"\\sigma_2\": RED_B},\n",
        "            font_size=42,\n",
        "        )\n",
        "        conv_eq = Tex(R\"[{f} * {g}](s) = \\int_{-\\infty}^\\infty {f}(x){g}(s - x)dx\", **tex_kw)\n",
        "        conv_eq.next_to(goal, DOWN, buff=1.5)\n",
        "        conv_eq.to_edge(LEFT)\n",
        "        conv_arrow = Arrow(conv_word.get_bottom(), conv_eq.get_top() + SMALL_BUFF * UP)\n",
        "        conv_arrow.set_color(conv_color)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FlashAround(conv_word, time_width=1.5, run_time=2.0, color=conv_color),\n",
        "            conv_word.animate.set_color(conv_color),\n",
        "            GrowArrow(conv_arrow),\n",
        "            FadeTransform(conv_word.copy(), conv_eq),\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Gaussian\n",
        "        gauss_color = RED\n",
        "        gaussian1 = Tex(\n",
        "            R\"f(x) = {1 \\over \\sigma_1 \\sqrt{2 \\pi}} e^{-x^2 / 2 \\sigma_1^2}\",\n",
        "            **tex_kw\n",
        "        )\n",
        "        gaussian2 = Tex(\n",
        "            R\"g(y) = {1 \\over \\sigma_2 \\sqrt{2 \\pi}} e^{-y^2 / 2 \\sigma_2^2}\",\n",
        "            **tex_kw\n",
        "        )\n",
        "        gaussian1.match_y(conv_eq)\n",
        "        gaussian1.to_edge(RIGHT)\n",
        "        gaussian2.next_to(gaussian1, DOWN, LARGE_BUFF)\n",
        "        gauss_arrow = Arrow(gauss_word.get_bottom(), gaussian1.get_top() + SMALL_BUFF * UP)\n",
        "        gauss_arrow.set_color(gauss_color)\n",
        "        f_rect = SurroundingRectangle(conv_eq[\"{f}(x)\"], buff=0.05)\n",
        "        g_rect = SurroundingRectangle(conv_eq[\"{g}(s - x)\"], buff=0.05)\n",
        "        f_rect.set_stroke(RED, 5)\n",
        "        g_rect.set_stroke(RED, 5)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(f_rect),\n",
        "            FadeTransform(gauss_word.copy(), gaussian1),\n",
        "            GrowArrow(gauss_arrow),\n",
        "            gauss_word.animate.set_color(gauss_color),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(f_rect, g_rect),\n",
        "            FadeIn(gaussian2, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(g_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Combine\n",
        "        full_expr = Tex(R\"\"\"\n",
        "            \\int_{-\\infty}^\\infty\n",
        "            \\frac{1}{2\\pi \\sigma_1 \\sigma_2}\n",
        "            e^{-x^2 / 2\\sigma_1^2} e^{-(s-x)^2 / 2\\sigma_2^2} \\,dx\n",
        "        \"\"\", **tex_kw)\n",
        "        full_expr.next_to(conv_eq, DOWN, buff=2.0, aligned_edge=LEFT)\n",
        "        full_expr_rect = SurroundingRectangle(full_expr)\n",
        "        full_expr_rect.set_stroke(RED_E, 2)\n",
        "        arrow_kw = dict(stroke_width=2, stroke_color=RED_E)\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(conv_eq, full_expr_rect, **arrow_kw),\n",
        "            Arrow(gaussian1.get_left(), full_expr_rect, **arrow_kw),\n",
        "            Arrow(gaussian2.get_left(), full_expr_rect.get_right(), **arrow_kw),\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformMatchingShapes(conv_eq[9:13].copy(), full_expr[R\"\\int_{-\\infty}^\\infty\"][0]),\n",
        "                TransformMatchingShapes(\n",
        "                    VGroup(*gaussian1[5:13], gaussian2[5:13]).copy(),\n",
        "                    full_expr[R\"\\frac{1}{2\\pi \\sigma_1 \\sigma_2}\"][0]\n",
        "                ),\n",
        "                TransformMatchingShapes(gaussian1[13:].copy(), full_expr[R\"e^{-x^2 / 2\\sigma_1^2}\"][0]),\n",
        "                TransformMatchingShapes(gaussian2[13:].copy(), full_expr[R\"e^{-(s-x)^2 / 2\\sigma_2^2}\"][0]),\n",
        "                TransformMatchingShapes(conv_eq[-2:].copy(), full_expr[R\"dx\"]),\n",
        "            ), run_time=3, lag_ratio=0.1),\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "        )\n",
        "        self.play(ShowCreation(full_expr_rect))\n",
        "        self.add(full_expr)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class NothingWrongWithThat(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        morty = self.teacher\n",
        "        self.remove(self.background)\n",
        "\n",
        "        self.play(\n",
        "            morty.says(\"There's nothing\\nwrong with that!\", mode=\"hooray\"),\n",
        "            self.change_students(\"awe\", \"horrified\", \"confused\", look_at=self.screen),\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            morty.debubble(mode=\"tease\"),\n",
        "            self.change_students(\"pondering\", \"plain\", \"well\")\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\", look_at=3 * UP),\n",
        "            self.change_students(\"well\", \"pondering\", \"tease\", look_at=3 * UR)\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SimpleBellRHS(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(Tex(\"= e^{-x^2}\"))\n",
        "\n",
        "\n",
        "class SimpleBellRHS2(InteractiveScene):\n",
        "    def construct(self):\n",
        "        self.add(Tex(\"= e^{-(s - x)^2}\"))\n",
        "\n",
        "\n",
        "class ConvolutionMeaning(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # x + y = s\n",
        "        kw = dict(t2c={\"{s}\": YELLOW})\n",
        "        words = VGroup(\n",
        "            Tex(R\"[f * g]({s})\", font_size=60, **kw),\n",
        "            Tex(R\"\\longrightarrow\", **kw),\n",
        "            Tex(R\"\\text{How likely is it that } x + y = {s} \\, ?\", **kw),\n",
        "        )\n",
        "        words.arrange(RIGHT, buff=0.5)\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        words[0].save_state()\n",
        "        words[0].set_x(0)\n",
        "        self.play(FadeIn(words[0], 0.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(words[0]),\n",
        "            Write(words[1]),\n",
        "            FadeIn(words[2], RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Mention sqrt(2)\n",
        "        new_rhs = Tex(R\"(\\text{This area}) / \\sqrt{2}\", font_size=60)\n",
        "        new_rhs[R\"\\text{This area}\"].set_color(TEAL)\n",
        "        new_rhs.next_to(words[1], RIGHT)\n",
        "        new_rhs.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            VGroup(*words[:2], new_rhs).animate.set_x(0).set_opacity(1),\n",
        "            FadeOut(words[2], RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotationalSymmetryAnnotations(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add equation\n",
        "        kw = dict(t2c={\"x\": BLUE, \"y\": YELLOW, \"r\": RED})\n",
        "        top_eq = Tex(\"f(x)g(y) = e^{-x^2} e^{-y^2}\", **kw)\n",
        "        top_eq_lhs = top_eq[\"f(x)g(y)\"][0]\n",
        "        top_eq_rhs = top_eq[\"= e^{-x^2} e^{-y^2}\"][0]\n",
        "        top_eq.to_corner(UL)\n",
        "\n",
        "        self.add(top_eq)\n",
        "\n",
        "        # Expand equation\n",
        "        rhs2 = Tex(\"= e^{-(x^2 + y^2)}\", **kw)\n",
        "        rhs3 = Tex(\"= e^{-r^2}\", **kw)\n",
        "\n",
        "        rhs2.next_to(top_eq_rhs, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        rhs3.next_to(rhs2, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        xy_rect = SurroundingRectangle(rhs2[\"x^2 + y^2\"], buff=0.05)\n",
        "        r_rect = SurroundingRectangle(rhs3[\"r^2\"], buff=0.05)\n",
        "        rects = VGroup(xy_rect, r_rect)\n",
        "        rects.set_stroke(RED, 1)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                top_eq_rhs.copy(), rhs2,\n",
        "                path_arc=30 * DEGREES,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(xy_rect))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                rhs2.copy(), rhs3,\n",
        "                key_map={\"x^2 + y^2\": \"r^2\"},\n",
        "                run_time=1\n",
        "            ),\n",
        "            TransformFromCopy(xy_rect, r_rect),\n",
        "        )\n",
        "        self.play(FadeOut(rects))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UniqueCharacterization(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        kw = dict(t2c={\"{x}\": BLUE, \"{y}\": YELLOW})\n",
        "        group = VGroup(\n",
        "            TexText(\"Rotational symmetry of $f({x})f({y})$\", font_size=36, **kw),\n",
        "            Tex(R\"\\Downarrow\"),\n",
        "            Tex(R\"f({x}) = Ae^{-c {x}^2}\", **kw),\n",
        "        )\n",
        "        group.arrange(DOWN)\n",
        "        group.to_corner(UR)\n",
        "\n",
        "        self.add(group[0])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(group[1]),\n",
        "            FadeInFromPoint(group[2], group[0][\"f({x})\"].get_center()),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SliceLineAnnotations(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Line equation\n",
        "        kw = dict(t2c={\"s\": RED})\n",
        "        line_eq = Tex(\"x + y = s\", **kw)\n",
        "        line_eq.to_edge(UP)\n",
        "        s_term = line_eq[\"s\"][0]\n",
        "        decimal_rhs = DecimalNumber(-6, edge_to_fix=LEFT)\n",
        "        decimal_rhs.move_to(s_term, LEFT)\n",
        "        decimal_rhs.shift(0.025 * UP)\n",
        "        s_eq = Tex(\"=\").rotate(90 * DEGREES)\n",
        "        s_eq.next_to(s_term, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(line_eq, decimal_rhs)\n",
        "        self.remove(s_term)\n",
        "        self.play(ChangeDecimalToValue(decimal_rhs, 1), run_time=5 / 1.5)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            decimal_rhs.animate.next_to(s_eq, DOWN, SMALL_BUFF),\n",
        "            Write(s_eq),\n",
        "            FadeIn(s_term, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # What we want\n",
        "        words = Text(\"What we want:\")\n",
        "        words.to_corner(UR)\n",
        "        conv = Tex(\"[f * g](s)\", **kw)\n",
        "        conv.next_to(words, DOWN, MED_LARGE_BUFF)\n",
        "        conv_eq = Tex(\"=\").rotate(90 * DEGREES)\n",
        "        conv_eq.next_to(conv, DOWN)\n",
        "        area = Tex(R\"(\\text{This area}) / \\sqrt{2}\")\n",
        "        area[R\"\\text{This area}\"].set_color(TEAL)\n",
        "        area.next_to(conv_eq, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words, 0.5 * UP),\n",
        "            FadeIn(conv, 0.5 * DOWN),\n",
        "        )\n",
        "        self.play(FlashAround(conv, run_time=2, time_width=1.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(conv_eq),\n",
        "            FadeIn(area, 0.5 * DOWN),\n",
        "        )\n",
        "        for s in [1.5, 0.5, 1.0]:\n",
        "            self.play(ChangeDecimalToValue(decimal_rhs, s))\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                words, conv, conv_eq, area, s_eq, decimal_rhs\n",
        "            )),\n",
        "            line_eq.animate.to_corner(UR),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class YIntegralAnnotations(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        kw = dict(\n",
        "            t2c={\n",
        "                \"{s}\": RED,\n",
        "                \"{y}\": YELLOW,\n",
        "                \"{x}\": BLUE,\n",
        "                R\"\\text{Area}\": TEAL\n",
        "            }\n",
        "        )\n",
        "        integrals = VGroup(\n",
        "            Tex(R\"\\text{Area} = \\int_{\\text{-}\\infty}^\\infty e^{-{x}^2} \\cdot e^{-{y}^2} \\, d{y}\", **kw),\n",
        "            Tex(R\"\\text{Area} = \\int_{\\text{-}\\infty}^\\infty e^{-({s} / \\sqrt{2})^2} \\cdot e^{-{y}^2} \\, d{y}\", **kw),\n",
        "            Tex(R\"\\text{Area} = e^{-({s} / \\sqrt{2})^2} \\int_{\\text{-}\\infty}^\\infty e^{-{y}^2} \\, d{y}\", **kw),\n",
        "            Tex(R\"\\text{Area} = e^{-({s} / \\sqrt{2})^2} \\sqrt{\\pi}\", **kw),\n",
        "        )\n",
        "        for integral in integrals:\n",
        "            integral.to_edge(UP)\n",
        "\n",
        "        x_rect = SurroundingRectangle(integrals[0][\"e^{-{x}^2}\"], buff=0.05)\n",
        "        s_rect1 = SurroundingRectangle(integrals[1][R\"e^{-({s} / \\sqrt{2})^2}\"], buff=0.05)\n",
        "        s_rect2 = SurroundingRectangle(integrals[2][R\"e^{-({s} / \\sqrt{2})^2}\"], buff=0.05)\n",
        "        y_int = integrals[2][R\"\\int_{\\text{-}\\infty}^\\infty e^{-{y}^2} \\, d{y}\"]\n",
        "        y_int_rect = SurroundingRectangle(y_int, buff=0.05)\n",
        "\n",
        "        x_rect.set_stroke(BLUE, 2)\n",
        "        s_rect1.set_stroke(RED, 2)\n",
        "        s_rect2.set_stroke(RED, 2)\n",
        "        y_int_rect.set_stroke(YELLOW, 2)\n",
        "        const_word = Text(\"Constant!\", font_size=36)\n",
        "        const_word.next_to(x_rect, DOWN, buff=MED_SMALL_BUFF, aligned_edge=LEFT)\n",
        "        const_word.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        # Replace x\n",
        "        self.play(Write(integrals[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(x_rect),\n",
        "            FadeIn(const_word, scale=0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(*integrals[:2]),\n",
        "            ReplacementTransform(x_rect, s_rect1),\n",
        "            const_word.animate.match_x(s_rect1).set_anim_args(run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Factor out\n",
        "        self.play(\n",
        "            FadeOut(const_word, 0.5 * DOWN),\n",
        "            VShowPassingFlash(\n",
        "                s_rect1.copy().insert_n_curves(100).set_stroke(width=5),\n",
        "                run_time=2,\n",
        "            ),\n",
        "            ShowCreation(s_rect1, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "        s_rect2.set_stroke(opacity=0)\n",
        "        self.play(\n",
        "            TransformMatchingTex(*integrals[1:3], path_arc=45 * DEGREES),\n",
        "            ReplacementTransform(s_rect1, s_rect2, path_arc=45 * DEGREES),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize separation\n",
        "        s_rect2.set_stroke(RED, 2, 1)\n",
        "        self.play(ShowCreation(s_rect2))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(s_rect2, y_int_rect))\n",
        "        self.wait()\n",
        "\n",
        "        y_int_group = VGroup(y_int_rect, y_int.copy())\n",
        "        y_int.set_opacity(0)\n",
        "        int_eq = Tex(\"=\").rotate(90 * DEGREES)\n",
        "        pi_term = integrals[3][R\"\\sqrt{\\pi}\"]\n",
        "        int_eq.next_to(pi_term, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(*integrals[2:4]),\n",
        "            y_int_group.animate.scale(0.5).next_to(int_eq, DOWN, SMALL_BUFF),\n",
        "            Write(int_eq),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(int_eq, *y_int_group)))\n",
        "        self.wait()\n",
        "\n",
        "        # Area expression\n",
        "        area_eq = Tex(R\"\\text{Area} = e^{-{s}^2 / 2} \\sqrt{\\pi}\", **kw)\n",
        "        area_eq.to_edge(UP)\n",
        "        area_eq.save_state()\n",
        "        twos = area_eq[\"2\"]\n",
        "        twos_copies = twos.copy()\n",
        "        twos[0].become(twos_copies[1])\n",
        "        twos[1].become(twos_copies[0])\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(integrals[3], area_eq)\n",
        "        )\n",
        "        area_eq.restore()\n",
        "        self.wait()\n",
        "\n",
        "        # From area to convolution\n",
        "        conv_eqs = VGroup(\n",
        "            Tex(R\"[f * g]({s}) = \\text{Area} / \\sqrt{2}\", **kw),\n",
        "            Tex(R\"[f * g]({s}) = \\text{Area} / \\sqrt{2} = e^{-{s}^2 / 2} \\sqrt{\\pi} / \\sqrt{2}\", **kw),\n",
        "            Tex(R\"[f * g]({s}) = \\text{Area} / \\sqrt{2} = e^{-{s}^2 / 2} \\sqrt{\\pi \\over 2}\", **kw),\n",
        "        )\n",
        "        conv_eqs[0].next_to(ORIGIN, LEFT, LARGE_BUFF).to_edge(UP)\n",
        "        conv_eqs[1].move_to(area_eq)\n",
        "        conv_eqs[2].move_to(area_eq)\n",
        "\n",
        "        self.play(\n",
        "            Write(conv_eqs[0]),\n",
        "            Transform(area_eq[\"Area\"].copy(), conv_eqs[0][\"Area\"].copy(), remover=True),\n",
        "            area_eq.animate.next_to(ORIGIN, RIGHT, LARGE_BUFF).to_edge(UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(src[tex][-1], conv_eqs[1][tex][-1])\n",
        "                for src, tex in [\n",
        "                    (conv_eqs[0], conv_eqs[0].get_tex()),\n",
        "                    (area_eq, R\"e^{-{s}^2 / 2} \\sqrt{\\pi}\"),\n",
        "                    (conv_eqs[0], R\"/ \\sqrt{2}\"),\n",
        "                ]\n",
        "            )),\n",
        "            Write(conv_eqs[1][\"=\"][1]),\n",
        "            FadeOut(area_eq[R\"\\text{Area} =\"][0]),\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(conv_eqs[1])\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(\n",
        "            *conv_eqs[1:3],\n",
        "            key_map={R\"\\sqrt{\\pi} / \\sqrt{2}\": R\"\\sqrt{\\pi \\over 2}\"},\n",
        "            run_time=1.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OscillatingGraphValue(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add graph\n",
        "        axes = Axes((-3, 3), (0, 2), width=8, height=1.5)\n",
        "        axes.move_to(1.5 * UP)\n",
        "        graph = axes.get_graph(lambda x: np.exp(-x**2 / 2) * math.sqrt(PI))\n",
        "        graph.set_stroke(TEAL, 2)\n",
        "        axes.add(Tex(\"s\").set_color(RED).next_to(axes.x_axis.get_end(), UR, SMALL_BUFF))\n",
        "\n",
        "        self.add(axes, graph)\n",
        "\n",
        "        # Add s tracker\n",
        "        s_tracker = ValueTracker(-3)\n",
        "        get_s = s_tracker.get_value\n",
        "        v_line = always_redraw(lambda: axes.get_v_line_to_graph(get_s(), graph, line_func=Line).set_stroke(WHITE, 1))\n",
        "        dot = GlowDot(radius=0.2, color=WHITE)\n",
        "        dot.add_updater(lambda m: m.move_to(axes.i2gp(get_s(), graph)))\n",
        "        tri = Triangle(start_angle=PI / 2)\n",
        "        tri.set_height(0.05)\n",
        "        tri.set_fill(TEAL, 1)\n",
        "        tri.set_stroke(width=0)\n",
        "        tri.add_updater(lambda m: m.move_to(axes.c2p(get_s(), 0), UP))\n",
        "        label = DecimalNumber(0, font_size=24)\n",
        "        label.add_updater(lambda m: m.set_value(get_s()))\n",
        "        label.add_updater(lambda m: m.next_to(tri, DOWN, SMALL_BUFF))\n",
        "\n",
        "        self.add(v_line, dot, label, tri)\n",
        "\n",
        "        for _ in range(2):\n",
        "            self.play(\n",
        "                s_tracker.animate.set_value(3),\n",
        "                rate_func=there_and_back,\n",
        "                run_time=24\n",
        "            )\n",
        "\n",
        "\n",
        "class ShowGaussianConvolutionsAsEquations(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        axes = VGroup(*(\n",
        "            NumberPlane(\n",
        "                (-3, 3), (0, 2),\n",
        "                width=3, height=1,\n",
        "                background_line_style=dict(stroke_width=1, stroke_color=GREY_D),\n",
        "                faded_line_style=dict(stroke_width=1, stroke_opacity=0.2, stroke_color=GREY_D)\n",
        "            )\n",
        "            for x in range(6)\n",
        "        ))\n",
        "        axes.set_height(1.25)\n",
        "        axes.arrange_in_grid(2, 3, h_buff=0.75, v_buff=3.0)\n",
        "        for ax in axes[2::3]:\n",
        "            ax.shift(0.75 * RIGHT)\n",
        "        axes.center()\n",
        "\n",
        "        stars = Tex(\"*\", font_size=72).replicate(2)\n",
        "        eqs = Tex(\"=\", font_size=72).replicate(2)\n",
        "        stars[0].move_to(axes[0:2])\n",
        "        eqs[0].move_to(axes[1:3])\n",
        "        stars[1].move_to(axes[3:5])\n",
        "        eqs[1].move_to(axes[4:6])\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(stars, eqs)\n",
        "\n",
        "        # Equations\n",
        "        kw = dict(\n",
        "            font_size=30,\n",
        "            t2c={\"x\": BLUE, \"y\": YELLOW, \"{s}\": TEAL, R\"\\sigma\": RED}\n",
        "        )\n",
        "        equations = VGroup(\n",
        "            Tex(R\"e^{-x^2}\", **kw),\n",
        "            Tex(R\"e^{-y^2}\", **kw),\n",
        "            Tex(R\"\\sqrt{\\frac{\\pi}{2}} e^{-{s}^2 / 2}\", **kw),\n",
        "            Tex(R\"\\frac{1}{\\sigma \\sqrt{2\\pi}} e^{-\\frac{1}{2} x^2 / \\sigma^2}\", **kw),\n",
        "            Tex(R\"\\frac{1}{\\sigma \\sqrt{2\\pi}} e^{-\\frac{1}{2} y^2 / \\sigma^2}\", **kw),\n",
        "            Tex(R\"\\frac{1}{\\sqrt{2}\\sigma \\sqrt{2\\pi}} e^{-\\frac{1}{2} {s}^2 / 2 \\sigma^2}\", **kw),\n",
        "        )\n",
        "        normal_annotations = VGroup(\n",
        "            Tex(R\"\\mathcal{N}\\left(0, \\sigma^2\\right)\", **kw),\n",
        "            Tex(R\"\\mathcal{N}\\left(0, \\sigma^2\\right)\", **kw),\n",
        "            Tex(R\"\\mathcal{N}\\left(0, 2\\sigma^2\\right)\", **kw),\n",
        "        )\n",
        "        normal_annotations.scale(1.25)\n",
        "\n",
        "        for eq, ax in zip(equations, axes):\n",
        "            eq.next_to(ax, UP, MED_SMALL_BUFF)\n",
        "        for ann, eq in zip(normal_annotations, equations[3:]):\n",
        "            ann.next_to(eq, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        # Graphs\n",
        "        sigma = 0.35\n",
        "        graphs = VGroup(\n",
        "            axes[0].get_graph(lambda x: np.exp(-x**2)),\n",
        "            axes[1].get_graph(lambda y: np.exp(-y**2)),\n",
        "            axes[2].get_graph(lambda s: np.exp(-s**2 / 2) * math.sqrt(PI / 2)),\n",
        "            axes[3].get_graph(lambda x: gauss_func(x, 0, sigma)),\n",
        "            axes[4].get_graph(lambda y: gauss_func(y, 0, sigma)),\n",
        "            axes[5].get_graph(lambda s: gauss_func(s, 0, math.sqrt(2) * sigma)),\n",
        "        )\n",
        "        colors = [BLUE, YELLOW, TEAL]\n",
        "        for graph, color in zip(graphs, it.cycle(colors)):\n",
        "            graph.set_stroke(color, 2)\n",
        "\n",
        "        # Animations\n",
        "        self.add(equations[:3])\n",
        "        self.add(graphs[:3])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(eq1.copy(), eq2)\n",
        "                for eq1, eq2 in zip(equations[:3], equations[3:])\n",
        "            ), lag_ratio=0.15),\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(graph1, graph2)\n",
        "                for graph1, graph2 in zip(graphs[:3], graphs[3:])\n",
        "            ), lag_ratio=0.15),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, normal_annotations[:2],\n",
        "                shift=0.5 * DOWN,\n",
        "                lag_ratio=0.25,\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(normal_annotations[0].copy(), normal_annotations[2]),\n",
        "            FadeTransform(normal_annotations[1].copy(), normal_annotations[2]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Exercise(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Tex key word args\n",
        "        tex_kw = dict(\n",
        "            t2c={\n",
        "                R\"\\sigma_1\": RED,\n",
        "                R\"\\sigma_2\": RED_B,\n",
        "            }\n",
        "        )\n",
        "\n",
        "        # Set up axes\n",
        "        planes = VGroup(*(\n",
        "            NumberPlane(\n",
        "                (-1, 3), (-1, 3),\n",
        "                background_line_style=dict(stroke_color=GREY_A, stroke_width=1, stroke_opacity=0.5),\n",
        "                faded_line_style=dict(stroke_color=GREY_A, stroke_width=1, stroke_opacity=0.25),\n",
        "                width=5, height=5\n",
        "            )\n",
        "            for x in range(2)\n",
        "        ))\n",
        "        labels = VGroup(*map(Tex, [\"x\", \"y\", \"x'\", \"y'\"]))\n",
        "        labels.scale(0.75)\n",
        "        label_iter = iter(labels)\n",
        "        for plane in planes:\n",
        "            for axis, vect in zip(plane.axes, [RIGHT, UP]):\n",
        "                label = next(label_iter)\n",
        "                label.next_to(axis.get_end(), vect, SMALL_BUFF)\n",
        "                plane.add(label)\n",
        "\n",
        "        planes.arrange(RIGHT, buff=4.0)\n",
        "        planes.set_width(10)\n",
        "        planes.to_edge(LEFT)\n",
        "        planes.set_y(-1.5)\n",
        "\n",
        "        arrow = Arrow(*planes, stroke_width=6, stroke_color=RED, buff=0.5)\n",
        "\n",
        "        self.add(planes)\n",
        "        self.add(arrow)\n",
        "\n",
        "        # Show lines and intersections\n",
        "        lines = VGroup(\n",
        "            Line(planes[0].c2p(-1, 3), planes[0].c2p(3, -1)),\n",
        "            Line(planes[1].c2p(-0.25, 3), planes[1].c2p(2.25, -1)),\n",
        "        )\n",
        "        lines.set_stroke(YELLOW, 2)\n",
        "        intersection_labels = VGroup(*(\n",
        "            Tex(tex, **tex_kw)\n",
        "            for tex in [\n",
        "                \"(s, 0)\",\n",
        "                \"(0, s)\",\n",
        "                R\"(s / \\sigma_1)\",\n",
        "                R\"(s / \\sigma_2)\",\n",
        "            ]\n",
        "        ))\n",
        "        intersection_labels.scale(0.5)\n",
        "        intersection_labels_iter = iter(intersection_labels)\n",
        "        dots = Group()\n",
        "\n",
        "        for plane, line in zip(planes, lines):\n",
        "            for axis in plane.axes:\n",
        "                point = find_intersection(\n",
        "                    line.get_start(), line.get_vector(),\n",
        "                    axis.get_start(), axis.get_vector(),\n",
        "                )\n",
        "                dot = GlowDot(point, color=WHITE)\n",
        "                dots.add(dot)\n",
        "                label = next(intersection_labels_iter)\n",
        "                label.set_backstroke(width=2)\n",
        "                label.next_to(point, DL, buff=SMALL_BUFF)\n",
        "\n",
        "        l2_perp = lines[1].copy().rotate(90 * DEGREES)\n",
        "        l2_perp.shift(planes[1].get_origin() - l2_perp.get_start())\n",
        "        mid_point = find_intersection(\n",
        "            l2_perp.get_start(), l2_perp.get_vector(),\n",
        "            lines[1].get_start(), lines[1].get_vector()\n",
        "        )\n",
        "        d_line = Line(planes[1].get_origin(), mid_point)\n",
        "        d_line.set_stroke(GREEN, 2)\n",
        "        d_label = Tex(\"d\", font_size=36)\n",
        "        d_label.next_to(d_line.get_center(), UL, buff=0.05)\n",
        "        elbow = Elbow()\n",
        "        elbow.rotate(l2_perp.get_angle() + 90 * DEGREES, about_point=ORIGIN)\n",
        "        elbow.set_stroke(width=1)\n",
        "        elbow.shift(mid_point)\n",
        "\n",
        "        self.add(lines)\n",
        "        self.add(dots)\n",
        "        self.add(intersection_labels)\n",
        "        self.add(d_line)\n",
        "        self.add(d_label)\n",
        "        self.add(elbow)\n",
        "\n",
        "        # Equations\n",
        "        d_eq = Tex(R\"d = \\frac{s}{\\sqrt{\\sigma_1^2 + \\sigma_2^2}}\", **tex_kw)\n",
        "        d_eq.scale(0.85)\n",
        "        d_eq.next_to(planes[1], RIGHT, buff=0.35)\n",
        "\n",
        "        xy_eq = Tex(\"x + y = s\")\n",
        "        xy_eq.scale(0.7)\n",
        "        xy_eq.set_backstroke(width=3)\n",
        "        xy_eq.next_to(lines[0].get_center(), UR, SMALL_BUFF)\n",
        "\n",
        "        change_of_coord_eqs = VGroup(\n",
        "            Tex(R\"x' = x / \\sigma_1\", **tex_kw),\n",
        "            Tex(R\"y' = y / \\sigma_2\", **tex_kw),\n",
        "        )\n",
        "        change_of_coord_eqs.arrange(DOWN)\n",
        "        change_of_coord_eqs.scale(0.7)\n",
        "        change_of_coord_eqs.next_to(arrow, UP)\n",
        "\n",
        "        self.add(d_eq)\n",
        "        self.add(xy_eq)\n",
        "        self.add(change_of_coord_eqs)\n",
        "\n",
        "        # Words\n",
        "        tex_kw[\"alignment\"] = \"\"\n",
        "        words = VGroup(\n",
        "            TexText(R\"\"\"\n",
        "                Consider the diagonal slice method for two Gaussians with\\\\\n",
        "                different standard deviations, $\\sigma_1$ and $\\sigma_2$:\\\\\n",
        "                $$\n",
        "                f(x) = \\frac{1}{\\sigma_1 \\sqrt{2\\pi}} e^{-\\frac{1}{2}(x / \\sigma_1)^2}\n",
        "                \\quad \\text{ and } \\quad\n",
        "                g(y) = \\frac{1}{\\sigma_2 \\sqrt{2\\pi}} e^{-\\frac{1}{2}(y / \\sigma_2)^2}\n",
        "                \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\n",
        "                $$\n",
        "                The graph of $f(x)g(y)$ is no longer rotationally symmetric.\\\\\n",
        "                However, it will be if you pass to a new set of coordinates\\\\\n",
        "                $(x', y')$ as illustrated below. Why?\n",
        "            \"\"\", **tex_kw),\n",
        "            TexText(R\"\"\"\n",
        "                The transformatoin of the line $x + y = s$ is illustrated below.\\\\\n",
        "                After the transformation, the area of a the slice of the graph\\\\\n",
        "                over this line is changed by some factor which depends on\\\\\n",
        "                $\\sigma_1$ and $\\sigma_2$, but importantly, not on $s$.\n",
        "                \\\\ \\\\\n",
        "                Explain how to find the distance $d$ in the digram below, and\\\\\n",
        "                how this shows that the area of a slice of $f(x)g(y)$ over the line\\\\\n",
        "                $x + y = s$ is proportional to $e^{-\\frac{1}{2} s^2 / (\\sigma_1^2 + \\sigma_2^2)}$.\n",
        "            \"\"\", **tex_kw),\n",
        "        )\n",
        "        words.arrange(RIGHT, buff=LARGE_BUFF, aligned_edge=UP)\n",
        "        words.set_width(FRAME_WIDTH - 1)\n",
        "        words.to_edge(UP)\n",
        "        v_line = Line(words.get_top(), words.get_bottom())\n",
        "        v_line.set_stroke(GREY_A, 1)\n",
        "        v_line.move_to(midpoint(words[0].get_right(), words[1].get_left()))\n",
        "        words.add(v_line)\n",
        "\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class WhatsTheBigdeal(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # What's the big deal\n",
        "        morty = self.teacher\n",
        "        stds = self.students\n",
        "        self.remove(self.background)\n",
        "\n",
        "        self.play(\n",
        "            stds[0].change(\"pondering\", look_at=self.screen),\n",
        "            stds[1].change(\"maybe\", look_at=self.screen),\n",
        "            stds[2].says(\"What's the\\nbig deal?\", mode=\"dance_3\"),\n",
        "            morty.change(\"guilty\"),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.change_students(\"pondering\", \"sassy\", \"hesitant\", look_at=self.screen),\n",
        "            morty.change(\"plain\"),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "        # Aren't they common\n",
        "        self.play(\n",
        "            stds[2].debubble(mode=\"heistant\"),\n",
        "            stds[1].says(\"What else\\nwould it be?\", mode=\"maybe\", run_time=1),\n",
        "            stds[0].change(\"well\"),\n",
        "        )\n",
        "        self.play(\n",
        "            stds[2].says(\"Normal distributions\\nare very common\\nright?\", mode=\"speaking\", look_at=morty.eyes),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.add(stds[2].bubble, stds[2].bubble.content)\n",
        "        self.wait(3)\n",
        "\n",
        "        # But are they?\n",
        "        common_words = stds[2].bubble.content[\"Normal distributions\\nare very common\"][0].copy()\n",
        "        are_they = Text(\"But are they?\")\n",
        "        are_they.set_color(RED)\n",
        "        are_they.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            stds[0].change(\"pondering\", look_at=self.screen),\n",
        "            stds[1].debubble(),\n",
        "            stds[2].debubble(),\n",
        "            morty.change(\"sassy\"),\n",
        "            FadeIn(are_they, UP),\n",
        "            common_words.animate.next_to(are_they, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(morty.change(\"hesitant\", are_they))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Central limit theorem\n",
        "        clt = Text(\"Central Limit Theorem\")\n",
        "        clt.set_color(YELLOW)\n",
        "        clt.move_to(common_words).to_edge(UP, buff=LARGE_BUFF)\n",
        "        implies = Tex(R\"\\Downarrow\")\n",
        "        implies.next_to(clt, DOWN)\n",
        "\n",
        "        n = len(\"Normaldistributions\")\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            self.change_students(\"pondering\", \"erm\", \"pondering\", look_at=clt),\n",
        "            common_words[:n].animate.next_to(implies, DOWN),\n",
        "            FadeOut(common_words[n:], DOWN),\n",
        "            FadeOut(are_they, DOWN),\n",
        "            Write(clt),\n",
        "            Write(implies)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class AddedBubble(InteractiveScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DL)\n",
        "        self.play(randy.says(\"It follows from \\n the CLT\"))\n",
        "        self.remove(randy)\n",
        "\n",
        "\n",
        "class StepsToProof(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = Text(\"Steps to proving the CLT\", font_size=60)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        underline = Underline(title, buff=-0.05, stretch_factor=1.5)\n",
        "        self.add(title, underline)\n",
        "\n",
        "        # Steps\n",
        "        steps = VGroup(\n",
        "            Text(\"\"\"\n",
        "                Step 1: Show that for all (finite variance) distribution, there exists\n",
        "                some universal shape that this process will approach.\n",
        "            \"\"\", t2s={\"some\": ITALIC}, alignment=\"LEFT\"),\n",
        "            Text(\"\"\"\n",
        "                Step 2: Show that the convolution of two Gaussians is another Gaussian.\n",
        "            \"\"\", alignment=\"LEFT\")\n",
        "        )\n",
        "        steps.set_width(0.9 * FRAME_WIDTH)\n",
        "        steps.set_fill(WHITE)\n",
        "        steps.arrange(DOWN, buff=1.0, aligned_edge=LEFT)\n",
        "        steps.next_to(underline, DOWN, buff=0.75)\n",
        "\n",
        "        steps[0][\"(finite variance)\"].set_opacity(0.7)\n",
        "\n",
        "        # Two steps\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(steps[0][\"Step 1:\"], steps[1][\"Step 2:\"]),\n",
        "            shift=0.5 * UP,\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Step 1\n",
        "        self.play(\n",
        "            FadeIn(steps[0][len(\"Step1:\"):], lag_ratio=0.01, run_time=3),\n",
        "            FadeOut(steps[1][\"Step 2:\"]),\n",
        "        )\n",
        "        self.play(\n",
        "            steps[0][\"some universal shape\"].animate.set_color(TEAL),\n",
        "            lag_ratio=0.1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Step 2\n",
        "        self.play(\n",
        "            FadeIn(steps[1], lag_ratio=0.01, run_time=2),\n",
        "            self.frame.animate.move_to(steps, UP).shift(0.25 * UP)\n",
        "        )\n",
        "        texts = [\"two Gaussians\", \"another Gaussian\"]\n",
        "        for text, color in zip(texts, [YELLOW, TEAL]):\n",
        "            self.play(\n",
        "                steps[1][text].animate.set_color(color),\n",
        "                lag_ratio=0.1,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HerschelMaxwellWords(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        ideas = VGroup(\n",
        "            VGroup(\n",
        "                Text(\"Herschel-Maxwell derivation\", font_size=60),\n",
        "                TexText(\n",
        "                    R\"Rotational symmetry of $f({x})f({y}) \\Rightarrow f({x}) = Ae^{-cx^2}$\",\n",
        "                    t2c={\"{x}\": BLUE, \"{y}\": YELLOW},\n",
        "                    font_size=36,\n",
        "                ),\n",
        "            ).arrange(DOWN),\n",
        "            TexText(\n",
        "                R\"Why $\\pi$ is in this formula\",\n",
        "                font_size=60,\n",
        "                t2c={R\"\\pi\": YELLOW}\n",
        "            )\n",
        "        )\n",
        "        for idea in ideas:\n",
        "            idea.move_to(3.15 * UP)\n",
        "\n",
        "        self.play(FadeIn(ideas[0], 0.5 * UP))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(ideas[1], 0.5 * UP),\n",
        "            FadeOut(ideas[0], 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LinksInDescription(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        self.play(\n",
        "            self.teacher.says(\"\"\"\n",
        "                Links for the\n",
        "                theoretically curious\n",
        "                in the description\n",
        "            \"\"\"),\n",
        "            self.change_students(\n",
        "                \"pondering\", \"hooray\", \"well\",\n",
        "                look_at=self.teacher.eyes\n",
        "            )\n",
        "        )\n",
        "        self.play(self.change_students(\n",
        "            \"pondering\", \"well\", \"tease\",\n",
        "            look_at=4 * DOWN,\n",
        "        ))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class DrawQRCode(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        # self.add(FullScreenRectangle(fill_color=GREY_A))\n",
        "        code = SVGMobject(\"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2023/convolutions2/gauss_example_supplements/images/SubstackQR2.svg\")\n",
        "        code.remove(*code[:2])\n",
        "        code.set_fill(BLACK, 1)\n",
        "        code.set_height(7)\n",
        "        back_rect = SurroundingRectangle(code)\n",
        "        back_rect.set_fill(GREY_A, 1)\n",
        "        back_rect.set_stroke(WHITE, 1)\n",
        "\n",
        "        code.shuffle()\n",
        "        self.play(\n",
        "            FadeIn(back_rect, time_span=(3, 5)),\n",
        "            Write(code, stroke_color=RED_E, stroke_width=2, lag_ratio=0.005, run_time=5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Thumbnail1(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        line_style = dict(stroke_color=GREY_B, stroke_width=1)\n",
        "        faded_line_style = dict(stroke_opacity=0.25, **line_style)\n",
        "        plane = NumberPlane(\n",
        "            (-3, 3), (0, 1, 0.5),\n",
        "            height=1.5, width=4,\n",
        "            background_line_style=line_style,\n",
        "            faded_line_style=faded_line_style,\n",
        "        )\n",
        "        plane.set_width(FRAME_WIDTH)\n",
        "        plane.to_edge(DOWN)\n",
        "\n",
        "        graph = plane.get_graph(lambda x: np.exp(-x**2))\n",
        "        graph.set_stroke(TEAL, 5)\n",
        "\n",
        "        expr = Tex(\"e^{-x^2}\", font_size=120)\n",
        "        expr.next_to(plane.c2p(1.5, 1), DOWN)\n",
        "\n",
        "        question = Text(\"Why this function?\", font_size=90)\n",
        "        question.to_edge(UP)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            question[\"this\"], expr[\"e\"],\n",
        "            stroke_width=10,\n",
        "            stroke_color=YELLOW\n",
        "        )\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(graph)\n",
        "        self.add(question)\n",
        "        self.add(arrow)\n",
        "        self.add(expr)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass"
    ]
}