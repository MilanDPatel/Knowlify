{
    "topic": "demonstrates the concept of a loop in mathematics, specifically the idea of a function that",
    "code": [
        "from __future__ import annotations\n",
        "\n",
        "from manim_imports_ext import *\n",
        "\n",
        "from _2024.inscribed_rect.helpers import *\n",
        "\n",
        "from typing import TYPE_CHECKING\n",
        "\n",
        "if TYPE_CHECKING:\n",
        "    from typing import Callable\n",
        "    from manimlib.typing import Vect3, Vect4\n",
        "\n",
        "\n",
        "class LoopScene(InteractiveScene):\n",
        "    def get_dot_group(\n",
        "        self,\n",
        "        vect_tracker: ValueTracker,\n",
        "        loop_func: Callable[[float], Vect3],\n",
        "        colors=None,\n",
        "        radius: float = 0.05,\n",
        "        glow_factor: float = 1.5,\n",
        "    ):\n",
        "        n = len(vect_tracker.get_value())\n",
        "        if colors is None:\n",
        "            colors = [random_bright_color() for _ in range(n)]\n",
        "\n",
        "        dots = Group(\n",
        "            get_special_dot(color, radius=radius, glow_factor=glow_factor)\n",
        "            for _, color in zip(range(n), it.cycle(colors))\n",
        "        )\n",
        "\n",
        "        def update_dots(dots):\n",
        "            for dot, value in zip(dots, vect_tracker.get_value()):\n",
        "                dot.move_to(loop_func(value))\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "        return dots\n",
        "\n",
        "    def get_movable_pair(\n",
        "        self,\n",
        "        uv_tracker: ValueTracker,\n",
        "        loop_func: Callable[[float], Vect3],\n",
        "        colors=[YELLOW, PINK],\n",
        "        radius: float = 0.05,\n",
        "        glow_factor: float = 1.5,\n",
        "    ):\n",
        "        return self.get_dot_group(uv_tracker, loop_func, colors, radius, glow_factor)\n",
        "\n",
        "    def get_movable_quad(\n",
        "        self,\n",
        "        abcd_tracker: ValueTracker,\n",
        "        loop_func: Callable[[float], Vect3],\n",
        "        colors=[YELLOW, MAROON_B, PINK, RED],\n",
        "        radius: float = 0.05,\n",
        "        glow_factor: float = 1.5,\n",
        "    ):\n",
        "        return self.get_dot_group(abcd_tracker, loop_func, colors, radius, glow_factor)\n",
        "\n",
        "    def get_connecting_line(self, dot_pair, stroke_color=TEAL_B, stroke_width=2):\n",
        "        d1, d2 = dot_pair\n",
        "        if stroke_color is None:\n",
        "            stroke_color = average_color(d1.get_color(), d2.get_color())\n",
        "\n",
        "        line = Line().set_stroke(stroke_color, stroke_width)\n",
        "        line.f_always.put_start_and_end_on(d1.get_center, d2.get_center)\n",
        "        return line\n",
        "\n",
        "    def get_midpoint_dot(self, dot_pair, color=TEAL_B):\n",
        "        dot = dot_pair[0].copy()\n",
        "        dot.f_always.move_to(dot_pair.get_center)\n",
        "        dot.set_color(color)\n",
        "        return dot\n",
        "\n",
        "    def get_dot_polygon(self, dots, stroke_color=BLUE, stroke_width=3):\n",
        "        polygon = Polygon(LEFT, RIGHT)\n",
        "        polygon.set_stroke(stroke_color, stroke_width)\n",
        "        polygon.add_updater(lambda m: m.set_points_as_corners(\n",
        "            [*(d.get_center() for d in dots), dots[0].get_center()]\n",
        "        ))\n",
        "        return polygon\n",
        "\n",
        "    def get_dot_labels(self, dots, label_texs, direction=UL, buff=0):\n",
        "        result = VGroup()\n",
        "        for dot, tex in zip(dots, label_texs):\n",
        "            label = Tex(tex)\n",
        "            label.match_color(dot[0])\n",
        "            label.set_backstroke(BLACK, 3)\n",
        "            label.always.next_to(dot[0], direction, buff=buff)\n",
        "            result.add(label)\n",
        "        return result\n",
        "\n",
        "\n",
        "class StateThePuzzle(LoopScene):\n",
        "    def construct(self):\n",
        "        # Show the loop\n",
        "        loop = get_example_loop(4)\n",
        "        loop.set_height(7)\n",
        "        loop.move_to(2 * RIGHT)\n",
        "        curve_words = Text(\"Closed\\nContinuous\\nCurve\", alignment=\"LEFT\", font_size=72)\n",
        "        curve_words.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(loop),\n",
        "            Write(curve_words, time_span=(3, 5)),\n",
        "            run_time=9\n",
        "        )\n",
        "\n",
        "        # Show four points going to a square\n",
        "        loop.insert_n_curves(50)\n",
        "        loop_func = loop.quick_point_from_proportion\n",
        "        quad_tracker = ValueTracker([0, 0, 0, 0])\n",
        "        dots = self.get_movable_quad(quad_tracker, loop_func, colors=color_gradient([RED, PINK], 4), radius=0.075)\n",
        "        square_params = find_rectangle(loop_func, target_angle=90 * DEG)\n",
        "\n",
        "        polygon = self.get_dot_polygon(dots, stroke_color=YELLOW, stroke_width=5)\n",
        "        inscribed_words = TexText(R\"``Inscribed\\\\Square''\", font_size=72)\n",
        "        inscribed_words.to_edge(LEFT)\n",
        "\n",
        "        self.add(dots)\n",
        "        self.play(quad_tracker.animate.set_value(square_params), run_time=3)\n",
        "        polygon.update()\n",
        "        self.add(polygon, dots)\n",
        "        self.play(ShowCreation(polygon, suspend_mobject_updating=True))\n",
        "        self.play(\n",
        "            Write(inscribed_words),\n",
        "            FadeOut(curve_words, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Alternate squares\n",
        "        new_square_params = [\n",
        "            [0.519, 0.308, 0.277, 0.177],\n",
        "            [0.444, 0.105, 0.877, 0.650],\n",
        "            [0.037, 0.739, 0.468, 0.372],\n",
        "        ]\n",
        "        dots.suspend_updating()\n",
        "        for new_params in new_square_params:\n",
        "            new_dots = dots.copy()\n",
        "            new_dots.set_opacity(0)\n",
        "            for dot, p in zip(new_dots, new_params):\n",
        "                dot.move_to(loop_func(p))\n",
        "\n",
        "            dots.set_opacity(0)\n",
        "            self.play(Transform(dots, new_dots), run_time=2)\n",
        "            dots.set_opacity(1)\n",
        "            self.wait()\n",
        "\n",
        "        # Ask question\n",
        "        title = Text(\"Open Question\", font_size=60)\n",
        "        title.add(Underline(title))\n",
        "        title.set_color(BLUE)\n",
        "        question = Text(\"Do all closed\\ncontinuous curves\\nhave an inscribed\\nsquare?\", alignment=\"LEFT\")\n",
        "        question.next_to(title, DOWN)\n",
        "        question.align_to(title[0], LEFT)\n",
        "        question_group = VGroup(title, question)\n",
        "        question_group.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question_group, UP),\n",
        "            FadeOut(inscribed_words, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ambiently animate to various different loops\n",
        "        def true_find_square(loop_func, trg_angle=90 * DEG, cost_tol=1e-2, max_tries=8):\n",
        "            ic = np.arange(0, 1, 0.25)\n",
        "            min_params = ic\n",
        "            min_cost = np.inf\n",
        "            for x in range(max_tries):\n",
        "                params, cost = find_rectangle(loop_func, target_angle=trg_angle, n_refinements=3, return_cost=True)\n",
        "                if cost < min_cost:\n",
        "                    min_params = params\n",
        "                    min_cost = cost\n",
        "                ic = np.random.random(4)\n",
        "            return min_params\n",
        "\n",
        "        new_loops = [\n",
        "            get_example_loop(1),\n",
        "            get_example_loop(2),\n",
        "            Tex(R\"\\pi\").family_members_with_points()[0],\n",
        "            Tex(R\"\\epsilon\").family_members_with_points()[0],\n",
        "            get_example_loop(1),\n",
        "        ]\n",
        "        og_loop = loop.copy()\n",
        "        for new_loop in new_loops:\n",
        "            new_loop.insert_n_curves(50)\n",
        "            new_loop.match_style(loop)\n",
        "            new_loop.match_height(loop)\n",
        "            new_loop.move_to(loop)\n",
        "\n",
        "        dots.resume_updating()\n",
        "        self.add(dots, polygon)\n",
        "        for new_loop in new_loops:\n",
        "            self.remove(dots, polygon)\n",
        "            self.play(\n",
        "                Transform(loop, new_loop),\n",
        "                # UpdateFromFunc(\n",
        "                #     quad_tracker,\n",
        "                #     lambda m: m.set_value(true_find_square(loop_func))\n",
        "                # ),\n",
        "                run_time=1\n",
        "            )\n",
        "            self.add(dots, polygon)\n",
        "            for _ in range(5):\n",
        "                quad_tracker.set_value(find_rectangle(loop_func, np.random.random(4), target_angle=90 * DEG))\n",
        "                self.wait(0.5)\n",
        "\n",
        "        # Change question to rectangle\n",
        "        square_word = question[\"square\"]\n",
        "        q_mark = question[\"?\"]\n",
        "        rect_word = Text(\"rectangle\")\n",
        "        rect_word.move_to(square_word, LEFT)\n",
        "        rect_word.set_color(BLUE)\n",
        "        red_line = Line(LEFT, RIGHT)\n",
        "        red_line.replace(square_word, 0)\n",
        "        red_line.set_stroke(RED, 8)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title, UP),\n",
        "            ShowCreation(red_line)\n",
        "        )\n",
        "        self.play(\n",
        "            VGroup(square_word, red_line).animate.shift(0.75 * DOWN),\n",
        "            Write(rect_word),\n",
        "            q_mark.animate.next_to(rect_word, RIGHT, SMALL_BUFF, aligned_edge=UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition dots to rectangle\n",
        "        rect_params = find_rectangle(loop_func, target_angle=45 * DEG)\n",
        "        self.play(quad_tracker.animate.set_value(rect_params), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "        dots.suspend_updating()\n",
        "        new_dots = dots.copy()\n",
        "        for dot, p in zip(new_dots, rect_params):\n",
        "            dot.move_to(loop_func(p))\n",
        "        self.play(\n",
        "            Transform(dots, new_dots),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "        dots.resume_updating()\n",
        "\n",
        "        # More ambient transitioning\n",
        "        for new_loop in [og_loop, *new_loops[1:3]]:\n",
        "            self.play(\n",
        "                Transform(loop, new_loop),\n",
        "                UpdateFromFunc(\n",
        "                    quad_tracker,\n",
        "                    lambda m: m.set_value(true_find_square(loop_func, 60 * DEG))\n",
        "                ),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ReframeToPairsOfPoints(LoopScene):\n",
        "    def construct(self):\n",
        "        # Add loop and dots\n",
        "        loop = SVGMobject(\"xmas_tree\").family_members_with_points()[0]\n",
        "        loop.set_stroke(WHITE, 3)\n",
        "        loop.set_fill(opacity=0)\n",
        "        loop.insert_n_curves(100)\n",
        "        loop.set_height(7)\n",
        "        loop.to_edge(RIGHT)\n",
        "        loop_func = loop.quick_point_from_proportion\n",
        "\n",
        "        quad_tracker = ValueTracker(np.arange(0, 1, 0.25))\n",
        "        dots = self.get_movable_quad(quad_tracker, loop_func, radius=0.075)\n",
        "        labels = self.get_dot_labels(dots, \"ABCD\")\n",
        "        labels.set_backstroke(BLACK, 3)\n",
        "        rect_params = find_rectangle(loop_func, target_angle=55 * DEG)\n",
        "        quad_tracker.set_value(rect_params + np.random.uniform(0.2, 0.2, 4))\n",
        "\n",
        "        self.add(quad_tracker, loop, dots, labels)\n",
        "\n",
        "        # Add words\n",
        "        question1 = VGroup(\n",
        "            Text(\"Find four points\"),\n",
        "            Tex(\"(A, B, C, D)\"),\n",
        "            Text(\"That form a rectangle\"),\n",
        "        )\n",
        "        question2 = VGroup(\n",
        "            Text(\"Find two pairs of points\", t2s={\"pairs\": ITALIC}),\n",
        "            Tex(\n",
        "                R\"\\{\\{A, C\\}, \\{B, D\\}\\}\",\n",
        "                t2c={\"A\": YELLOW, \"B\": RED, \"C\": YELLOW, \"D\": RED},\n",
        "            ),\n",
        "            Text(\"With the same midpoint\\nand distance apart\"),\n",
        "        )\n",
        "        for question in question1, question2:\n",
        "            question.arrange(DOWN, buff=0.35)\n",
        "            question.to_corner(UL)\n",
        "\n",
        "        for char, label in zip(\"ABCD\", labels):\n",
        "            question1[1][char].match_style(label)\n",
        "\n",
        "        self.add(question1)\n",
        "\n",
        "        # Move to rectangle\n",
        "        polygon = self.get_dot_polygon(dots)\n",
        "\n",
        "        self.play(quad_tracker.animate.set_value(rect_params), run_time=8)\n",
        "        polygon.update()\n",
        "        self.play(\n",
        "            ShowCreation(polygon, suspend_mobject_updating=True),\n",
        "            loop.animate.set_stroke(width=2, opacity=0.5),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Switch question\n",
        "        line1 = self.get_connecting_line(dots[0::2]).set_stroke(YELLOW)\n",
        "        line2 = self.get_connecting_line(dots[1::2]).set_stroke(RED)\n",
        "        lines = VGroup(line1, line2)\n",
        "        lines.update().suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(polygon),\n",
        "            FadeOut(question1[2], DOWN),\n",
        "            TransformMatchingStrings(question1[0], question2[0], key_map={\"four\": \"two pairs of\"}, mismatch_animation=FadeTransformPieces),\n",
        "            TransformMatchingTex(question1[1], question2[1]),\n",
        "            dots[2].animate.set_color(YELLOW),\n",
        "            dots[1].animate.set_color(RED),\n",
        "            labels[2].animate.set_fill(YELLOW),\n",
        "            labels[1].animate.set_fill(RED),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, lines, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the midpoint\n",
        "        mid_dot1 = self.get_midpoint_dot(dots[0::2])\n",
        "        mid_dot2 = self.get_midpoint_dot(dots[1::2])\n",
        "        mid_dot1.update()\n",
        "        mid_dot2.update()\n",
        "        arrow = Vector(RIGHT)\n",
        "        arrow.match_color(mid_dot1[0])\n",
        "        arrow.next_to(mid_dot1, LEFT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(mid_dot1),\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(question2[2][\"With the same midpoint\"], lag_ratio=0.1)\n",
        "        )\n",
        "        self.play(\n",
        "            FlashAround(question2[2][\"midpoint\"], color=TEAL),\n",
        "            question2[2][\"midpoint\"].animate.set_color(TEAL),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the distance apart\n",
        "        frame = self.frame\n",
        "        new_lines = lines.copy()\n",
        "        new_lines.clear_updaters()\n",
        "        for line in new_lines:\n",
        "            line.rotate(PI / 2 - line.get_angle())\n",
        "        new_lines.arrange(RIGHT, buff=0.5)\n",
        "        new_lines.next_to(loop, LEFT, buff=0.5)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(lines, new_lines),\n",
        "            Write(question2[2][\"and distance apart\"]),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            question2[2][\"distance apart\"].animate.set_color(YELLOW),\n",
        "            FlashUnder(question2[2][\"distance apart\"]),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Clear the loop and such\n",
        "        dots.clear_updaters()\n",
        "        dots[0].f_always.move_to(line1.get_start)\n",
        "        dots[2].f_always.move_to(line1.get_end)\n",
        "        dots[1].f_always.move_to(line2.get_start)\n",
        "        dots[3].f_always.move_to(line2.get_end)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(mid_dot1, arrow, loop, new_lines)),\n",
        "            question2[2].animate.set_opacity(0.25),\n",
        "            line1.animate.scale(0.35).rotate(45 * DEG).shift(UP),\n",
        "            line2.animate.scale(0.90).rotate(-30 * DEG).shift(DOWN),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Match the midpoints\n",
        "        for dot in mid_dot1, mid_dot2:\n",
        "            dot.set_color(WHITE)\n",
        "            dot.scale(0.5)\n",
        "\n",
        "        target_midpoint = midpoint(line1.get_center(), line2.get_center())\n",
        "\n",
        "        self.play(\n",
        "            *map(FadeIn, [mid_dot1, mid_dot2]),\n",
        "            question2[2][\"With the same midpoint\"].animate.set_fill(opacity=1),\n",
        "        )\n",
        "        self.play(\n",
        "            line1.animate.move_to(target_midpoint),\n",
        "            line2.animate.move_to(target_midpoint),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Match the distance\n",
        "        self.play(\n",
        "            line1.animate.set_length(line2.get_length()),\n",
        "            question2[2][\"and distance apart\"].animate.set_opacity(1),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show various rectangles\n",
        "        polygon.update()\n",
        "        self.play(ShowCreation(polygon, suspend_mobject_updating=True))\n",
        "        for line in [line2, line1, line2]:\n",
        "            self.play(Rotate(line, 100 * DEG), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowTheSurface(LoopScene):\n",
        "    def construct(self):\n",
        "        # Axes and plane\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        frame.set_height(6)\n",
        "\n",
        "        # Curve\n",
        "        loop = get_example_loop()\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.play(ShowCreation(loop, run_time=2))\n",
        "\n",
        "        # Pair of points\n",
        "        uv_tracker = ValueTracker([0, 0.5])\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.075)\n",
        "        connecting_line = self.get_connecting_line(dots)\n",
        "        midpoint_dot = self.get_midpoint_dot(dots)\n",
        "\n",
        "        self.add(uv_tracker)\n",
        "        self.add(dots)\n",
        "        self.add(connecting_line)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromFunc(uv_tracker, lambda m: m.set_value(np.random.random(2))),\n",
        "        )\n",
        "        self.add(dots, connecting_line)\n",
        "        self.play(uv_tracker.animate.set_value([0.8, 0.5]), run_time=3)\n",
        "\n",
        "        # Add coordinates\n",
        "        coords = Tex(\"(x, y)\", font_size=36)\n",
        "        coords.set_backstroke(BLACK, 3)\n",
        "        coords.set_fill(WHITE, 1)\n",
        "\n",
        "        midpoint_dot.update()\n",
        "        coords.always.next_to(midpoint_dot, UR, buff=-0.1)\n",
        "\n",
        "        self.play(\n",
        "            Write(coords, suspend_mobject_updating=True),\n",
        "            FadeIn(midpoint_dot, scale=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(plane, lag_ratio=0.01, run_time=2, stroke_width=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the distance\n",
        "        brace = Brace(Line(LEFT, RIGHT).set_width(connecting_line.get_length()), DOWN, buff=SMALL_BUFF)\n",
        "        brace.rotate(connecting_line.get_angle(), about_point=ORIGIN)\n",
        "        brace.shift(connecting_line.get_center())\n",
        "        brace.set_color(GREY_B)\n",
        "        d_label = Tex(\"d\", font_size=36)\n",
        "        d_label.move_to(brace.get_center() + 0.4 * normalize(brace.get_center() - midpoint_dot.get_center()))\n",
        "\n",
        "        self.play(GrowFromCenter(brace), Write(d_label))\n",
        "\n",
        "        # 3d coords into the corner\n",
        "        coords_3d = Tex(\"(x, y, d)\", font_size=36)\n",
        "        coords_3d.next_to(self.frame.get_corner(UR), DL, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(coords[:4], coords_3d[:4]),\n",
        "            TransformFromCopy(d_label, coords_3d[4:6]),\n",
        "            TransformFromCopy(coords[4:], coords_3d[6:]),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Into 3d\n",
        "        z_line = self.get_z_line(dots)\n",
        "        top_dot = self.get_top_dot(z_line)\n",
        "        top_dot.update()\n",
        "        top_dot_coords = coords_3d.copy()\n",
        "        top_dot_coords.unfix_from_frame()\n",
        "        top_dot_coords.rotate(90 * DEG, RIGHT)\n",
        "        top_dot_coords.scale(0.75)\n",
        "        top_dot_coords.next_to(top_dot, OUT + RIGHT, buff=-0.05)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(5, 79, 0, (0.4, 0.01, 1.41), 5.07),\n",
        "            FadeIn(axes),\n",
        "            ReplacementTransform(coords_3d, top_dot_coords),\n",
        "            TransformFromCopy(midpoint_dot, top_dot, suspend_mobject_updating=True),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-21, 84, 0, (0.4, 0.01, 1.41), 5.07),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 18, 0, (0.41, -0.13, 1.34), 4.76),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FlashAround(coords, run_time=2, time_width=1.5))\n",
        "        self.play(\n",
        "            TransformFromCopy(connecting_line, z_line, suspend_mobject_updating=True, time_span=(4, 6)),\n",
        "            frame.animate.reorient(-38, 88, 0, (1.19, -0.11, 1.48), 3.94),\n",
        "            run_time=6,\n",
        "        )\n",
        "        self.play(frame.animate.reorient(-4, 88, 0, (1.19, -0.11, 1.48), 3.94), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        # Show another pair of points\n",
        "        uv_tracker2 = ValueTracker([0.2, 0.4])\n",
        "        dots2 = self.get_movable_pair(uv_tracker2, loop_func, colors=[RED, MAROON_B])\n",
        "        connecting_line2 = self.get_connecting_line(dots2)\n",
        "        z_line2 = self.get_z_line(dots2)\n",
        "        top_dot2 = self.get_top_dot(z_line2)\n",
        "\n",
        "        dot_group1 = Group(dots, connecting_line, midpoint_dot, z_line, top_dot)\n",
        "        dot_group2 = Group(dots2, connecting_line2, z_line2, top_dot2)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(12, 78, 0, (-0.48, 0.08, 1.15), 5.27),\n",
        "            LaggedStartMap(FadeIn, dot_group2),\n",
        "            LaggedStartMap(FadeOut, Group(d_label, brace, coords, top_dot_coords)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(uv_tracker2.animate.set_value([0.1, 0.2]), run_time=8)\n",
        "        self.wait()\n",
        "        nudge = 0.01\n",
        "        for _ in range(3):\n",
        "            self.play(\n",
        "                uv_tracker.animate.increment_value(np.random.uniform(-nudge, nudge, 2)),\n",
        "                uv_tracker2.animate.increment_value(np.random.uniform(-nudge, nudge, 2)),\n",
        "                run_time=2,\n",
        "                rate_func=lambda t: wiggle(t, 7),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show pair collision\n",
        "        # ic = np.random.random(4)\n",
        "        # print(list(ic.round(2)))\n",
        "        rect_params = find_rectangle(\n",
        "            loop_func,\n",
        "            initial_condition=[0.54, 0.59, 0.73, 0.31],\n",
        "            n_refinements=5,\n",
        "            target_angle=64 * DEG\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-18, 67, 0, (0.11, 0.07, 0.75), 4.63),\n",
        "            uv_tracker.animate.set_value(rect_params[0::2]),\n",
        "            uv_tracker2.animate.set_value(rect_params[1::2]),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the rectangle\n",
        "        rect_points = [loop_func(x) for x in rect_params]\n",
        "        rect = Polygon(*rect_points)\n",
        "        rect.set_stroke(YELLOW, 5)\n",
        "        z_group = Group(z_line, z_line2, top_dot, top_dot2)\n",
        "        self.play(\n",
        "            FadeOut(z_group),\n",
        "            FadeOut(axes),\n",
        "            frame.animate.reorient(0, 0, 0, ORIGIN, 4.75),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            loop.animate.set_stroke(width=2)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            FadeIn(z_group),\n",
        "            FadeIn(axes),\n",
        "            frame.animate.reorient(22, 85, 0, (-0.33, 0.45, 1.52), 6.78),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Set them both in motion\n",
        "        self.set_uv_tracker_in_motion(uv_tracker, velocity=(-0.05, 0.1))\n",
        "        self.set_uv_tracker_in_motion(uv_tracker2, velocity=(-0.025, 0.07))\n",
        "        frame.add_ambient_rotation()\n",
        "\n",
        "        for dot in [top_dot, top_dot2]:\n",
        "            tail = TracingTail(dot, time_traced=5, stroke_color=BLUE, stroke_width=(0, 5))\n",
        "            traced_path = TracedPath(dot.get_center, stroke_color=BLUE, stroke_width=1)\n",
        "            dot.paths = VGroup(traced_path, tail)\n",
        "            self.add(dot.paths)\n",
        "        self.wait(30)\n",
        "\n",
        "        # Surface\n",
        "        surface, mesh, surface_func = self.get_surface_info(loop_func, surface_resolution=(301, 301))\n",
        "\n",
        "        top_dot.paths.clear_updaters()\n",
        "        top_dot2.paths.clear_updaters()\n",
        "        self.play(\n",
        "            FadeIn(mesh),\n",
        "            FadeIn(surface),\n",
        "            FadeOut(top_dot.paths),\n",
        "            FadeOut(top_dot2.paths),\n",
        "            frame.animate.reorient(-29, 81, 0, (0.14, 0.39, 2.1), 6.47).set_anim_args(run_time=8),\n",
        "        )\n",
        "        self.wait(15)\n",
        "\n",
        "        # Remove dot groups\n",
        "        self.play(\n",
        "            FadeOut(dot_group1),\n",
        "            FadeOut(dot_group2),\n",
        "        )\n",
        "        uv_tracker.clear_updaters()\n",
        "        uv_tracker2.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        # Show surface cross sections\n",
        "        z_tracker = ValueTracker(surface.get_z(OUT))\n",
        "        top_mesh = mesh.copy()\n",
        "        top_mesh.set_stroke(width=0.5, opacity=0.1)\n",
        "\n",
        "        cross_plane = Square3D()\n",
        "        cross_plane.set_color(WHITE, 0.1)\n",
        "        cross_plane.replace(plane)\n",
        "        cross_plane.f_always.set_z(z_tracker.get_value)\n",
        "\n",
        "        surface.f_always.set_clip_plane(lambda: IN, z_tracker.get_value)\n",
        "        top_mesh.f_always.set_clip_plane(lambda: OUT, lambda: -z_tracker.get_value())\n",
        "\n",
        "        self.play(\n",
        "            surface.animate.set_opacity(1),\n",
        "            mesh.animate.set_stroke(width=0, opacity=0),\n",
        "        )\n",
        "        self.add(top_mesh)\n",
        "        self.play(FadeIn(cross_plane))\n",
        "        self.play(\n",
        "            z_tracker.animate.set_value(0.25),\n",
        "            surface.animate.set_color(BLUE_E, 1),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Add dots and show the intersection point\n",
        "        target_z = surface_func(*rect_params[0::2])[2]\n",
        "        uv_tracker.set_value(rect_params[0::2] + np.random.random(2) * 0.2)\n",
        "        uv_tracker2.set_value(rect_params[1::2] + np.random.random(2) * -0.2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dot_group1),\n",
        "            FadeIn(dot_group2),\n",
        "            surface.animate.set_opacity(0.75)\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value(rect_params[0::2]),\n",
        "            uv_tracker2.animate.set_value(rect_params[1::2]),\n",
        "            FadeOut(z_line2, time_span=(2.5, 3)),\n",
        "            FadeOut(top_dot2, time_span=(2.5, 3)),\n",
        "            frame.animate.reorient(-3, 49, 0, (0.76, 0.62, 0.49), 6.46),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Show the rectangle again\n",
        "        abcd_tracker = ValueTracker(rect_params)\n",
        "        uv_tracker.f_always.set_value(lambda: abcd_tracker.get_value()[0::2])\n",
        "        uv_tracker2.f_always.set_value(lambda: abcd_tracker.get_value()[1::2])\n",
        "\n",
        "        rect = Rectangle()\n",
        "        rect.f_always.set_points_as_corners(lambda: list(map(loop_func, abcd_tracker.get_value())))\n",
        "        rect.always.close_path()\n",
        "\n",
        "        self.add(abcd_tracker)\n",
        "        self.play(\n",
        "            ShowCreation(rect, suspend_mobject_updating=True),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Raise the cross section up to point\n",
        "        self.play(\n",
        "            z_tracker.animate.set_value(target_z),\n",
        "            frame.animate.reorient(-3, 47, 0, (0.27, 0.98, 0.85), 3.80),\n",
        "            top_mesh.animate.set_stroke(opacity=0.01),\n",
        "            run_time=7,\n",
        "        )\n",
        "        # self.wait(15)  # Comment on the intersection\n",
        "        self.wait()\n",
        "\n",
        "        # Animate changing rectangle\n",
        "        traced_path = TracingTail(top_dot, stroke_color=WHITE, time_traced=5)\n",
        "\n",
        "        self.add(traced_path)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-3, 48, 0, (0.15, 0.76, 0.6), 5.26),\n",
        "            run_time=4,\n",
        "        )\n",
        "        z_tracker.f_always.set_value(top_dot.get_z)\n",
        "        self.animate_to_rectangle_with_angle(abcd_tracker, loop_func, 80 * DEGREES, n_samples=10, param_range_per_step=0.02)\n",
        "        z_tracker.clear_updaters()\n",
        "        self.play(frame.animate.reorient(0, 44, 0, (0.02, 0.63, 0.47), 7.67), run_time=5)\n",
        "        self.remove(traced_path)\n",
        "\n",
        "        # Multiple self intersection points\n",
        "        for _ in range(5):\n",
        "            new_rect_params = find_rectangle(\n",
        "                loop_func,\n",
        "                initial_condition=np.random.random(4),\n",
        "                target_angle=np.random.uniform(30 * DEG, 90 * DEG),\n",
        "            )\n",
        "            new_z = get_dist(*map(loop_func, new_rect_params[::2]))\n",
        "            self.play(\n",
        "                abcd_tracker.animate.set_value(new_rect_params),\n",
        "                z_tracker.animate.set_value(new_z),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Raise the ceiling in full\n",
        "        self.play(\n",
        "            frame.animate.reorient(-1, 48, 0, (0.29, 1.22, 1.26), 8.99),\n",
        "            z_tracker.animate.set_value(surface.get_z(OUT)),\n",
        "            FadeOut(rect),\n",
        "            FadeOut(dot_group2),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(abcd_tracker)\n",
        "        uv_tracker.clear_updaters()\n",
        "        self.play(\n",
        "            z_tracker.animate.set_value(0.25),\n",
        "            top_mesh.animate.set_stroke(opacity=0.1),\n",
        "            frame.animate.reorient(-7, 78, 0, (0.31, 1.16, 0.94), 7.21),\n",
        "            run_time=6\n",
        "        )\n",
        "\n",
        "        # Point out what happens near the edge\n",
        "        glow_tracker = ValueTracker(dots[0][0].get_glow_factor())\n",
        "        radius_tracker = ValueTracker(dots[0][0].get_radius())\n",
        "        for dot in [*dots, top_dot]:\n",
        "            for part in dot:\n",
        "                part.f_always.set_glow_factor(glow_tracker.get_value)\n",
        "                part.f_always.set_radius(radius_tracker.get_value)\n",
        "        v = uv_tracker.get_value()[1]\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value([v + 0.01, v]),\n",
        "            glow_tracker.animate.set_value(0.25),\n",
        "            radius_tracker.animate.set_value(0.025),\n",
        "            frame.animate.reorient(-7, 78, 0, (0.1, 1.02, 0.18), 3.80),\n",
        "            FadeOut(midpoint_dot),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(uv_tracker.animate.set_value([0.26, 0.25]), run_time=6)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value([0.25, 0.25]),\n",
        "            frame.animate.reorient(-7, 78, 0, (-0.15, 1.0, -0.07), 2.80),\n",
        "            z_tracker.animate.set_value(0.01),\n",
        "            run_time=7\n",
        "        )\n",
        "        self.play(frame.animate.reorient(2, 70, 0, (0.05, 1.06, 0.05), 4.29), run_time=10)\n",
        "        self.wait()\n",
        "\n",
        "    def get_axes_and_plane(\n",
        "        self,\n",
        "        x_range=(-3, 3),\n",
        "        y_range=(-3, 3),\n",
        "        z_range=(0, 5),\n",
        "        depth=4,\n",
        "    ):\n",
        "        axes = ThreeDAxes(x_range, y_range, z_range)\n",
        "        axes.set_depth(depth, stretch=True, about_edge=IN)\n",
        "        axes.set_stroke(GREY_B, 1)\n",
        "\n",
        "        plane = NumberPlane(x_range, y_range)\n",
        "        plane.background_lines.set_stroke(BLUE, 1, 0.75)\n",
        "        plane.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "        plane.axes.match_style(axes)\n",
        "        plane.set_z_index(-1)\n",
        "        return axes, plane\n",
        "\n",
        "    def get_z_line(self, dot_pair, stroke_color=TEAL_B, stroke_width=2):\n",
        "        z_line = Line(IN, OUT).set_stroke(stroke_color, stroke_width)\n",
        "\n",
        "        def update_z_line(z_line):\n",
        "            point1 = dot_pair[0].get_center()\n",
        "            point2 = dot_pair[1].get_center()\n",
        "            midpoint = mid(point1, point2)\n",
        "            top = midpoint + get_norm(point1 - point2) * OUT\n",
        "            z_line.put_start_and_end_on(midpoint, top)\n",
        "\n",
        "        z_line.add_updater(update_z_line)\n",
        "        z_line.update()\n",
        "        return z_line\n",
        "\n",
        "    def get_top_dot(self, z_line, color=BLUE, radius=0.05, glow_factor=1.0):\n",
        "        top_dot = Group(\n",
        "            TrueDot(radius=radius).make_3d(),\n",
        "            GlowDot(radius=radius * 2, glow_factor=glow_factor)\n",
        "        )\n",
        "        top_dot.set_color(color)\n",
        "        top_dot.f_always.move_to(z_line.get_end)\n",
        "        return top_dot\n",
        "\n",
        "    def set_uv_tracker_in_motion(self, uv_tracker, velocity=(-0.05, 0.1)):\n",
        "        velocity = np.array(velocity)\n",
        "\n",
        "        def update_uv_tracker(uv_tracker, dt):\n",
        "            new_value = uv_tracker.get_value() + dt * velocity\n",
        "            uv_tracker.set_value(new_value % 1)\n",
        "\n",
        "        uv_tracker.add_updater(update_uv_tracker)\n",
        "        return uv_tracker\n",
        "\n",
        "    def animate_to_rectangle_with_angle(\n",
        "        self, abcd_tracker, loop_func, target_angle,\n",
        "        n_samples=5,\n",
        "        run_time=5,\n",
        "        param_range_per_step=0.1,\n",
        "        n_samples_per_range=10,\n",
        "        n_refinements=3,\n",
        "    ):\n",
        "        # Find the sample points\n",
        "        points = list(map(loop_func, abcd_tracker.get_value()))\n",
        "        curr_angle = abs(angle_between_vectors(points[2] - points[0], points[3] - points[1]))\n",
        "        if curr_angle > PI / 2:\n",
        "            curr_angle = PI - curr_angle\n",
        "\n",
        "        rectangle_range = [abcd_tracker.get_value()]\n",
        "        for angle in np.linspace(curr_angle, target_angle, n_samples + 1)[1:]:\n",
        "            rectangle_range.append(find_rectangle(\n",
        "                loop_func=loop_func,\n",
        "                initial_condition=rectangle_range[-1],\n",
        "                target_angle=angle,\n",
        "                initial_param_range=param_range_per_step,\n",
        "                n_samples_per_range=n_samples_per_range,\n",
        "                n_refinements=n_refinements,\n",
        "            ))\n",
        "        rectangle_range = np.array(rectangle_range)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(abcd_tracker, lambda m, a: m.set_value(smooth_index(rectangle_range, a))),\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "    def get_surface_info(\n",
        "        self,\n",
        "        loop_func: Callable[[float], Vect3],\n",
        "        surface_color=BLUE,\n",
        "        surface_opacity=0.25,\n",
        "        surface_resolution=(101, 101),\n",
        "        mesh_color=WHITE,\n",
        "        mesh_stroke_width=0.5,\n",
        "        mesh_stroke_opacity=0.1,\n",
        "        mesh_resolution=(101, 101),\n",
        "    ):\n",
        "        surface_func = get_surface_func(loop_func)\n",
        "\n",
        "        surface = ParametricSurface(\n",
        "            get_half_parametric_func(surface_func),\n",
        "            resolution=surface_resolution,\n",
        "        )\n",
        "        surface.set_color(surface_color, surface_opacity)\n",
        "        surface.always_sort_to_camera(self.camera)\n",
        "\n",
        "        full_surface = ParametricSurface(surface_func)\n",
        "        mesh = SurfaceMesh(full_surface, resolution=mesh_resolution, normal_nudge=0)\n",
        "        mesh.set_stroke(WHITE, mesh_stroke_width, mesh_stroke_opacity)\n",
        "        mesh.deactivate_depth_test()\n",
        "\n",
        "        return surface, mesh, surface_func\n",
        "\n",
        "\n",
        "class ChangeTheSurface(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        # Axes and plane\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        frame.reorient(-45, 83, 0, (0.08, 0.63, 2.3), 8.55)\n",
        "        frame.add_ambient_rotation()\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        # Show loops\n",
        "        example_loops = VGroup(\n",
        "            get_example_loop(1),\n",
        "            get_example_loop(2),\n",
        "            # get_example_loop(3),\n",
        "            SVGMobject(\"gingerbread_outline\")[0]\n",
        "        )\n",
        "        for loop in example_loops:\n",
        "            loop.set_height(5)\n",
        "            loop.set_stroke(WHITE, 4).set_fill(opacity=0)\n",
        "        loop = example_loops[0].copy()\n",
        "\n",
        "        surface = self.get_surface(loop)\n",
        "\n",
        "        def update_surface(surface):\n",
        "            surface.become(self.get_surface(loop))\n",
        "            surface.always_sort_to_camera(self.camera)\n",
        "\n",
        "        self.add(loop)\n",
        "        self.add(surface)\n",
        "\n",
        "        for next_loop in example_loops[1:]:\n",
        "            self.play(\n",
        "                Transform(loop, next_loop),\n",
        "                UpdateFromFunc(surface, update_surface),\n",
        "                run_time=8\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        # Circle and ellipse\n",
        "        circle = Circle(radius=2)\n",
        "        circle.set_stroke(WHITE, 4)\n",
        "\n",
        "        self.play(\n",
        "            Transform(loop, circle),\n",
        "            UpdateFromFunc(surface, update_surface),\n",
        "            run_time=5\n",
        "        )\n",
        "        loop.become(circle)\n",
        "\n",
        "        surface.always_sort_to_camera(self.camera)\n",
        "\n",
        "        # Show all the recangles\n",
        "        x_tracker = ValueTracker(0.125)\n",
        "        get_x = x_tracker.get_value\n",
        "        loop_func = loop.pfp\n",
        "\n",
        "        uv_tracker1 = ValueTracker([0, 0])\n",
        "        uv_tracker2 = ValueTracker([0, 0])\n",
        "        uv_tracker1.add_updater(lambda m: m.set_value([get_x(), get_x() + 0.5]))\n",
        "        uv_tracker2.add_updater(lambda m: m.set_value([0.5 - get_x(), 1.0 - get_x()]))\n",
        "\n",
        "        dots1 = self.get_movable_pair(uv_tracker1, loop_func)\n",
        "        dots2 = self.get_movable_pair(uv_tracker2, loop_func, colors=[RED, MAROON_B])\n",
        "        line1 = self.get_connecting_line(dots1)\n",
        "        line2 = self.get_connecting_line(dots2)\n",
        "        z_line = self.get_z_line(dots1)\n",
        "        top_dot = self.get_top_dot(z_line)\n",
        "        rect = Rectangle()\n",
        "        rect.set_stroke(YELLOW, 3)\n",
        "        rect.f_always.set_points_as_corners(lambda: list(map(loop_func, [\n",
        "            get_x(), 0.5 - get_x(), get_x() + 0.5, 1.0 - get_x(), get_x()\n",
        "        ])))\n",
        "\n",
        "        rect_group = Group(dots1, dots2, line1, line2, z_line, top_dot, rect)\n",
        "\n",
        "        self.add(uv_tracker1, uv_tracker2)\n",
        "        self.play(\n",
        "            FadeIn(rect_group),\n",
        "            frame.animate.reorient(-14, 31, 0, (-0.08, -0.56, 1.19), 8.04),\n",
        "            run_time=3\n",
        "        )\n",
        "        for value in [0.24, 0.01, 0.125]:\n",
        "            self.play(x_tracker.animate.set_value(value), run_time=6)\n",
        "        self.wait()\n",
        "\n",
        "        # Squish into an ellipse\n",
        "        ellipse = circle.copy().stretch(0.5, 1)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-11, 67, 0, (-0.08, -0.56, 1.19), 8.04),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(loop, ellipse),\n",
        "            UpdateFromFunc(surface, update_surface),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(frame.animate.reorient(156, 77, 0, (-0.08, -0.56, 1.19), 8.04), run_time=10)\n",
        "        self.wait(4)\n",
        "\n",
        "        # Move the coordinates again\n",
        "        self.play(frame.animate.reorient(174, 34, 0, (-0.08, -0.56, 1.19), 8.04), run_time=3)\n",
        "        for value in [0.24, 0.01, 0.125]:\n",
        "            self.play(x_tracker.animate.set_value(value), run_time=6)\n",
        "\n",
        "    def get_surface(self, loop, surface_resolution=(301, 301), color=BLUE, opacity=0.5):\n",
        "        # return Square3D().set_z(10)\n",
        "        surface_func = get_surface_func(loop.quick_point_from_proportion)\n",
        "        surface = ParametricSurface(\n",
        "            get_half_parametric_func(surface_func),\n",
        "            resolution=surface_resolution,\n",
        "        )\n",
        "        surface.sort_faces_back_to_front(self.camera.get_location())\n",
        "        surface.set_color(color, opacity)\n",
        "        return surface\n",
        "\n",
        "\n",
        "class ParameterizeTheLoop(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up the loop\n",
        "        loop = get_example_loop(width=5)\n",
        "        loop.insert_n_curves(20)\n",
        "        loop.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        x_tracker = ValueTracker()\n",
        "        get_x = x_tracker.get_value\n",
        "        loop_x_group = self.get_loop_coord_group(loop, get_x)\n",
        "\n",
        "        self.add(loop)\n",
        "        self.add(loop_x_group)\n",
        "\n",
        "        # Set up the unit interval\n",
        "        interval = UnitInterval(width=6)\n",
        "        interval.to_edge(RIGHT)\n",
        "        interval.add_numbers()\n",
        "\n",
        "        x_tip = ArrowTip(angle=-90 * DEG)\n",
        "        x_tip.set_height(0.2)\n",
        "        x_tip.set_color(YELLOW)\n",
        "        x_tip.f_always.move_to(lambda: interval.n2p(get_x()), lambda: DOWN)\n",
        "        int_x_label = DecimalNumber(font_size=24)\n",
        "        int_x_label.set_color(YELLOW)\n",
        "        int_x_label.always.next_to(x_tip, UP, buff=0.15)\n",
        "        int_x_label.f_always.set_value(get_x)\n",
        "\n",
        "        int_x_group = VGroup(x_tip, int_x_label)\n",
        "        self.add(interval)\n",
        "        self.add(int_x_group)\n",
        "\n",
        "        # Animate changing x\n",
        "        self.play(x_tracker.animate.set_value(1), run_time=12, rate_func=there_and_back)\n",
        "        x_tracker.set_value(0)\n",
        "\n",
        "        # Snip the loop\n",
        "        snipped_loop = loop.copy()\n",
        "        sl_points = np.array(loop.get_points())  # Snipped loop points\n",
        "        sl_points[0] += 0.25 * LEFT\n",
        "        sl_points[-1] += 0.25 * UP\n",
        "        snipped_loop.set_points(sl_points)\n",
        "\n",
        "        scissors = SVGMobject(\"scissors\")\n",
        "        scissors.set_color(GREY_B)\n",
        "        scissors.rotate(45 * DEG)\n",
        "        scissors.set_height(0.75)\n",
        "        scissors_shift = np.array([0.7, -0.5, 0])\n",
        "        scissors.move_to(loop.get_start() + scissors_shift)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(loop_x_group),\n",
        "            FadeOut(int_x_group),\n",
        "            FadeIn(scissors)\n",
        "        )\n",
        "        moving_loop = loop.copy()\n",
        "        loop.set_stroke(opacity=0.25)\n",
        "        self.play(\n",
        "            Transform(moving_loop, snipped_loop, time_span=(0.5, 1.5)),\n",
        "            scissors.animate.shift(-2 * scissors_shift),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeOut(scissors))\n",
        "\n",
        "        # Map it onto the unit interval\n",
        "        line = Line(interval.n2p(0), interval.n2p(1))\n",
        "        line.match_style(moving_loop)\n",
        "        self.play(Transform(moving_loop, line, run_time=3, path_arc=-30 * DEG))\n",
        "        self.wait()\n",
        "\n",
        "        # Show coordinate moving around\n",
        "        self.play(\n",
        "            FadeIn(loop_x_group),\n",
        "            FadeIn(int_x_group),\n",
        "            loop.animate.set_stroke(opacity=1),\n",
        "            FadeOut(moving_loop),\n",
        "        )\n",
        "        self.play(x_tracker.animate.set_value(1), run_time=5)\n",
        "        self.wait()\n",
        "        for value in [0, 1, 0]:\n",
        "            x_tracker.set_value(value)\n",
        "            self.wait()\n",
        "\n",
        "        # Glue 0 to 1\n",
        "        circular_interval = Circle(radius=TAU / interval.get_length())\n",
        "        circular_interval.rotate(PI / 2)\n",
        "        circular_interval.match_style(interval)\n",
        "        circle_ticks = VGroup(\n",
        "            Line(1.1 * point, 0.9 * point)\n",
        "            for a in np.linspace(0, 1, 11)\n",
        "            for point in [circular_interval.pfp(a)]\n",
        "        )\n",
        "        circle_numbers = interval.numbers.copy()\n",
        "        for tick, number in zip(circle_ticks, circle_numbers):\n",
        "            number.move_to(1.3 * tick.get_center())\n",
        "        circle_numbers[-1].move_to(0.7 * circle_ticks[-1].get_center())\n",
        "\n",
        "        circular_interval.add(circle_ticks, circle_numbers)\n",
        "        circular_interval.move_to(interval)\n",
        "\n",
        "        interval.save_state()\n",
        "        self.play(\n",
        "            FadeOut(int_x_group),\n",
        "            Transform(interval, circular_interval, run_time=3),\n",
        "        )\n",
        "        self.play(FlashAround(VectorizedPoint(interval.get_start()), run_time=2))\n",
        "        self.wait()\n",
        "        self.play(Restore(interval, run_time=3))\n",
        "\n",
        "        # Add a second point\n",
        "        y_tracker = ValueTracker(0)\n",
        "        get_y = y_tracker.get_value\n",
        "        loop_y_group = self.get_loop_coord_group(loop, get_y, color=PINK, label_direction=UR)\n",
        "        loop_y_group.update()\n",
        "\n",
        "        self.add(loop_y_group)\n",
        "        self.play(\n",
        "            # FadeIn(loop_y_group, time_span=(0, 1)),\n",
        "            x_tracker.animate.set_value(0.15),\n",
        "            y_tracker.animate.set_value(0.25),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Add a second axis\n",
        "        x_axis = interval\n",
        "        y_axis = UnitInterval()\n",
        "        y_axis.set_width(interval.get_length())\n",
        "        y_axis.rotate(90 * DEG)\n",
        "        y_axis.add_numbers(direction=LEFT)\n",
        "\n",
        "        y_axis.move_to(x_axis.n2p(0))\n",
        "        y_axis.shift(0.25 * LEFT)\n",
        "\n",
        "        int_y_group = int_x_group.copy()\n",
        "        int_y_group.clear_updaters()\n",
        "        int_y_group.set_color(PINK)\n",
        "        y_tip, y_dec = int_y_group\n",
        "        y_tip.rotate(-90 * DEG)\n",
        "        y_tip.f_always.move_to(lambda: y_axis.n2p(get_y()), lambda: LEFT)\n",
        "        y_dec.f_always.set_value(get_y)\n",
        "        y_dec.always.next_to(y_tip, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        int_y_group.update()\n",
        "        int_y_group.suspend_updating()\n",
        "        self.play(\n",
        "            FadeIn(y_axis),\n",
        "            VFadeIn(int_x_group),\n",
        "            x_axis.animate.shift(y_axis.n2p(0) - x_axis.n2p(0)),\n",
        "            FadeTransformPieces(loop_y_group.copy(), int_y_group),\n",
        "            run_time=2\n",
        "        )\n",
        "        int_y_group.resume_updating()\n",
        "        self.wait()\n",
        "        self.play(y_tracker.animate.set_value(0.84), run_time=3)\n",
        "        self.play(x_tracker.animate.set_value(0.75), run_time=3)\n",
        "        self.play(y_tracker.animate.set_value(0.65), run_time=3)\n",
        "\n",
        "        # Show in the unit square\n",
        "        axes = Axes((0, 1), (0, 1), width=x_axis.get_length(), height=y_axis.get_length())\n",
        "        axes.shift(x_axis.n2p(0) - axes.c2p(0, 0))\n",
        "        int_y_group.clear_updaters()\n",
        "        int_x_group.clear_updaters()\n",
        "        x_tip, x_dec = int_x_group\n",
        "\n",
        "        square = Square()\n",
        "        square.set_z_index(-1)\n",
        "        square.set_stroke(GREY, 1)\n",
        "        square.set_fill(GREY_E, 0.5)\n",
        "        square.set_width(x_axis.get_length())\n",
        "        square.move_to(x_axis.n2p(0), DL)\n",
        "\n",
        "        square_point = get_special_dot(color=BLUE)\n",
        "        square_point.f_always.move_to(lambda: axes.c2p(get_x(), get_y()))\n",
        "\n",
        "        v_line = Line(DOWN, UP).set_stroke(WHITE, 1)\n",
        "        h_line = Line(LEFT, RIGHT).set_stroke(WHITE, 1)\n",
        "        v_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.c2p(get_x(), 0), axes.c2p(get_x(), get_y())\n",
        "        ))\n",
        "        h_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.c2p(0, get_y()), axes.c2p(get_x(), get_y())\n",
        "        ))\n",
        "        coord_lines = VGroup(v_line, h_line)\n",
        "\n",
        "        coord_label = Tex(R\"(0.00, 0.00)\", font_size=24)\n",
        "        coord_standins = coord_label.make_number_changeable(\"0.00\", replace_all=True)\n",
        "        coord_label.always.next_to(square_point, UR, buff=-0.1)\n",
        "        coord_standins.set_opacity(0)\n",
        "\n",
        "        coord_lines.update()\n",
        "        coord_lines.suspend_updating()\n",
        "        self.play(\n",
        "            FadeIn(square),\n",
        "            ShowCreation(v_line),\n",
        "            ShowCreation(h_line),\n",
        "            y_tip.animate.flip(UP, about_edge=LEFT),\n",
        "            x_tip.animate.flip(RIGHT, about_edge=DOWN),\n",
        "            x_dec.animate.move_to(coord_label[1]),\n",
        "            y_dec.animate.move_to(coord_label[3]),\n",
        "            FadeIn(coord_label),\n",
        "            FadeIn(square_point, scale=0.5),\n",
        "        )\n",
        "        coord_lines.resume_updating()\n",
        "\n",
        "        x_tip.f_always.match_x(lambda: x_axis.n2p(get_x()))\n",
        "        y_tip.f_always.match_y(lambda: y_axis.n2p(get_y()))\n",
        "        x_dec.f_always.set_value(get_x)\n",
        "        y_dec.f_always.set_value(get_y)\n",
        "\n",
        "        coord_label.replace_submobject(1, x_dec)\n",
        "        coord_label.replace_submobject(3, y_dec)\n",
        "\n",
        "        # Move coordinates\n",
        "        xy_tracker = ValueTracker(np.array([get_x(), get_y()]))\n",
        "        x_tracker.f_always.set_value(lambda: xy_tracker.get_value()[0])\n",
        "        y_tracker.f_always.set_value(lambda: xy_tracker.get_value()[1])\n",
        "        self.add(x_tracker, y_tracker)\n",
        "        self.play(xy_tracker.animate.set_value([0.50, get_y()]), run_time=4)\n",
        "        self.play(xy_tracker.animate.set_value([get_x(), 0.20]), run_time=4)\n",
        "        self.play(xy_tracker.animate.set_value([0.05, get_y()]), run_time=4)\n",
        "        np.random.seed(0)\n",
        "        for _ in range(3):\n",
        "            self.play(xy_tracker.animate.set_value(np.random.random(2)), run_time=4)\n",
        "\n",
        "        # Highlight the x=0 and x=1 lines\n",
        "        x_line_color = BLUE\n",
        "        frame = self.frame\n",
        "        left_edge = Line(DOWN, UP)\n",
        "        left_edge.set_stroke(x_line_color, 5)\n",
        "        left_edge.match_height(square)\n",
        "        left_edge.move_to(square, LEFT)\n",
        "        right_edge = left_edge.copy()\n",
        "        right_edge.move_to(square, RIGHT)\n",
        "\n",
        "        left_tips = ArrowTip(angle=90 * DEG).get_grid(3, 1, buff=1.0)\n",
        "        left_tips.move_to(left_edge)\n",
        "        left_tips.set_color(x_line_color)\n",
        "        right_tips = left_tips.copy()\n",
        "        right_tips.move_to(right_edge)\n",
        "\n",
        "        self.play(xy_tracker.animate.set_value([0, 0]), run_time=2)\n",
        "        self.play(\n",
        "            frame.animate.set_height(9),\n",
        "            ShowCreation(left_edge),\n",
        "            xy_tracker.animate.set_value([0, 1]),\n",
        "            run_time=12\n",
        "        )\n",
        "        xy_tracker.set_value([1, 0])\n",
        "        self.play(\n",
        "            ShowCreation(right_edge),\n",
        "            xy_tracker.animate.set_value([1, 1]),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(left_tips),\n",
        "            Write(right_tips),\n",
        "        )\n",
        "\n",
        "        v_arrows = VGroup(VGroup(left_edge, left_tips), VGroup(right_edge, right_tips))\n",
        "\n",
        "        # Highlight y=0 and y=1 lines\n",
        "        y_line_color = GREEN_SCREEN\n",
        "        bottom_edge = Line(LEFT, RIGHT)\n",
        "        bottom_edge.set_stroke(y_line_color, 5)\n",
        "        bottom_edge.match_width(square)\n",
        "        bottom_edge.move_to(square, DOWN)\n",
        "        top_edge = bottom_edge.copy()\n",
        "        top_edge.move_to(square, UP)\n",
        "\n",
        "        bottom_tips = ArrowTip().get_grid(1, 3, buff=1.0)\n",
        "        bottom_tips.move_to(bottom_edge)\n",
        "        bottom_tips.set_color(y_line_color)\n",
        "        top_tips = bottom_tips.copy()\n",
        "        top_tips.move_to(top_edge)\n",
        "\n",
        "        xy_tracker.set_value([0, 0])\n",
        "        self.play(\n",
        "            xy_tracker.animate.set_value([1, 0]),\n",
        "            ShowCreation(bottom_edge),\n",
        "            Write(bottom_tips, time_span=(2, 4)),\n",
        "            run_time=4\n",
        "        )\n",
        "        xy_tracker.set_value([0, 1])\n",
        "        self.play(\n",
        "            xy_tracker.animate.set_value([1, 1]),\n",
        "            ShowCreation(top_edge),\n",
        "            Write(top_tips, time_span=(2, 4)),\n",
        "            run_time=4\n",
        "        )\n",
        "\n",
        "        h_arrows = VGroup(VGroup(bottom_edge, bottom_tips), VGroup(top_edge, top_tips))\n",
        "\n",
        "        # Fold into a torus\n",
        "        def half_torus_func(u, v):\n",
        "            return torus_func(u, 0.5 * v)\n",
        "\n",
        "        surfaces = Group(\n",
        "            TexturedSurface(ParametricSurface(func), \"TorusTexture\")\n",
        "            for func in [square_func, tube_func, half_torus_func, torus_func]\n",
        "        )\n",
        "        for surface in surfaces:\n",
        "            surface.set_shading(0.25, 0.25, 0)\n",
        "            surface.set_opacity(0.75)\n",
        "\n",
        "        target_z = 5\n",
        "        square3d, tube, half_torus, torus = surfaces\n",
        "        square3d.replace(square)\n",
        "\n",
        "        surface = square3d.copy()\n",
        "        surface.replace(square)\n",
        "        surface.set_z(target_z)\n",
        "\n",
        "        tube.set_width(surface.get_width() / PI)\n",
        "        tube.match_height(surface, stretch=True)\n",
        "        tube.move_to(surface, IN)\n",
        "\n",
        "        torus.match_depth(tube)\n",
        "        torus.move_to(tube)\n",
        "        half_torus.match_width(torus)\n",
        "        half_torus.move_to(torus, UP)\n",
        "\n",
        "        cover_rect = SurroundingRectangle(Group(loop, loop_y_group))\n",
        "        cover_rect.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "\n",
        "        self.add(surface)\n",
        "        self.play(\n",
        "            FadeIn(surface, shift=target_z * OUT),\n",
        "            FadeIn(cover_rect),\n",
        "            frame.animate.reorient(-13, 61, 0, (1.52, 1.67, 1.97), 15.41),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(Transform(surface, tube), run_time=3)\n",
        "        self.wait()\n",
        "        self.play(Transform(surface, half_torus, path_arc=PI / 2), run_time=3)\n",
        "        self.play(Transform(surface, torus, path_arc=PI / 2), run_time=3)\n",
        "        self.wait()\n",
        "        self.remove(surface)\n",
        "        self.add(torus)\n",
        "\n",
        "        # Put torus in position above the loop\n",
        "        torus_point = TrueDot(color=BLUE)\n",
        "        torus_point.f_always.move_to(lambda: torus.uv_to_point(get_x(), get_y()))\n",
        "        torus_point.apply_depth_test()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(cover_rect),\n",
        "            loop.animate.set_height(6).next_to(y_axis, LEFT, buff=1.5),\n",
        "            frame.animate.reorient(0, 0, 0, (0.44, 1.84, 0.0), 13.21),\n",
        "            torus.animate.set_height(7).rotate(50 * DEG, LEFT).move_to(6 * UP),\n",
        "            torus.animate.set_height(7).rotate(50 * DEG, LEFT).move_to(6 * UP).match_x(square),\n",
        "            v_arrows.animate.set_opacity(0.25),\n",
        "            h_arrows.animate.set_opacity(0.25),\n",
        "            coord_label.animate.scale(1.5),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        torus_mesh = SurfaceMesh(torus, resolution=(21, 21))\n",
        "        torus_mesh.set_stroke(WHITE, 0.5, 0.5)\n",
        "        self.add(torus_point, torus_mesh, torus)\n",
        "        self.play(\n",
        "            Write(torus_mesh, lag_ratio=0.01, stroke_width=0.5, run_time=1),\n",
        "            FadeIn(torus_point),\n",
        "        )\n",
        "\n",
        "        target_xys = [\n",
        "            [0.13, 0.25],\n",
        "            [0.13, 0.65],\n",
        "            [0.13, 0.35],\n",
        "            [0.97, 0.35],\n",
        "            [0.10, 0.35],\n",
        "        ]\n",
        "        for xy in target_xys:\n",
        "            self.play(xy_tracker.animate.set_value(xy), run_time=4)\n",
        "\n",
        "        # Wiggle the points\n",
        "        for _ in range(3):\n",
        "            self.play(\n",
        "                xy_tracker.animate.increment_value(0.02 * np.random.uniform(-1, 1, 2)),\n",
        "                run_time=2,\n",
        "                rate_func=lambda t: wiggle(t, 7)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Fade back to square\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-0.57, 0.46, 0.0), 10),\n",
        "            FadeOut(torus, UP),\n",
        "            FadeOut(torus_mesh, UP),\n",
        "            FadeOut(torus_point, UP),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show (x, y) -> (y, x) pairs\n",
        "        coord_ghosts = Group()\n",
        "        double_arrows = VGroup()\n",
        "\n",
        "        def get_coord_ghost():\n",
        "            result = Group(square_point, coord_label).copy()\n",
        "            result.clear_updaters()\n",
        "            result.fade(0.25)\n",
        "            coord_ghosts.add(result)\n",
        "            return result\n",
        "\n",
        "        def get_double_arrow():\n",
        "            point1 = axes.c2p(get_x(), get_y())\n",
        "            point2 = axes.c2p(get_y(), get_x())\n",
        "            vect = normalize(point2 - point1)\n",
        "            result = VGroup(\n",
        "                Arrow(point1, point2).shift(0.1 * vect),\n",
        "                Arrow(point2, point1).shift(-0.1 * vect),\n",
        "            )\n",
        "            result.set_stroke(GREY_C)\n",
        "            double_arrows.add(result)\n",
        "            return result\n",
        "\n",
        "        def show_reflection():\n",
        "            x_dot = loop_x_group[0]\n",
        "            y_dot = loop_y_group[0]\n",
        "            loop_x_group.suspend_updating()\n",
        "            loop_y_group.suspend_updating()\n",
        "\n",
        "            self.add(get_coord_ghost())\n",
        "            self.play(\n",
        "                GrowFromPoint(get_double_arrow(), square_point.get_center()),\n",
        "                xy_tracker.animate.set_value([get_y(), get_x()]),\n",
        "                Swap(x_dot, y_dot),\n",
        "                run_time=1\n",
        "            )\n",
        "            self.play(Swap(x_dot, y_dot))\n",
        "            self.wait()\n",
        "            self.add(get_coord_ghost())\n",
        "\n",
        "            loop_x_group.resume_updating().update()\n",
        "            loop_y_group.resume_updating().update()\n",
        "            self.add(loop_x_group, loop_y_group)\n",
        "            loop_x_group.update()\n",
        "            loop_y_group.update()\n",
        "\n",
        "        for xy in [[0.1, 0.9], [0.8, 0.95]]:\n",
        "            show_reflection()\n",
        "            self.play(xy_tracker.animate.set_value(xy))\n",
        "        show_reflection()\n",
        "\n",
        "        # Show fold line\n",
        "        fold_line = Line(axes.c2p(0, 0), axes.c2p(1, 1))\n",
        "        fold_line.set_stroke(Color(\"red\"), 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(fold_line),\n",
        "            *map(FadeOut, [v_line, h_line, coord_label, square_point, x_tip, y_tip]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(coord_ghosts),\n",
        "            FadeOut(double_arrows),\n",
        "            v_arrows.animate.set_opacity(1),\n",
        "            h_arrows.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "        # Fold the square\n",
        "        ul_triangle = Polygon(DL, UL, UR)\n",
        "        dr_triangle = Polygon(DL, DR, UR)\n",
        "        for triangle in [ul_triangle, dr_triangle]:\n",
        "            triangle.replace(square)\n",
        "            triangle.match_style(square)\n",
        "            triangle.set_z_index(-1)\n",
        "            triangle.set_shading(0.25, 0, 0)\n",
        "            self.add(triangle)\n",
        "        self.remove(square)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(ul_triangle, PI, about_point=square.get_center(), axis=UR),\n",
        "            Rotate(v_arrows[0], PI, about_point=square.get_center(), axis=UR),\n",
        "            Rotate(h_arrows[1], PI, about_point=square.get_center(), axis=UR),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.remove(v_arrows)\n",
        "        self.play(h_arrows.animate.set_color(PURPLE))\n",
        "\n",
        "        folded_square = Group(dr_triangle, h_arrows, fold_line).copy()\n",
        "\n",
        "        # Note the diagonal line again\n",
        "        self.play(\n",
        "            FadeIn(square_point),\n",
        "            FadeIn(coord_label),\n",
        "        )\n",
        "        self.play(xy_tracker.animate.set_value([0.9, 0.9]), run_time=2)\n",
        "        self.play(xy_tracker.animate.set_value([0.1, 0.1]), run_time=8)\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on the tricky points (Probably edit out the actual transitions)\n",
        "        self.play(xy_tracker.animate.set_value([0.1, 0]), run_time=2)\n",
        "        self.play(FlashAround(coord_label))\n",
        "        self.wait()\n",
        "        self.play(xy_tracker.animate.set_value([1, 0]), run_time=2)\n",
        "        self.play(xy_tracker.animate.set_value([1, 0.1]))\n",
        "        self.play(FlashAround(coord_label))\n",
        "        self.wait()\n",
        "        self.play(xy_tracker.animate.set_value([0.9, 0]))\n",
        "        self.play(FlashAround(coord_label))\n",
        "        self.wait()\n",
        "        self.play(xy_tracker.animate.set_value([1, 0]))\n",
        "        self.play(xy_tracker.animate.set_value([1, 0.9]), run_time=2)\n",
        "        self.play(FlashAround(coord_label))\n",
        "\n",
        "        # Fade out axes and such\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                loop_x_group[1], loop_y_group[1], coord_label, square_point,\n",
        "                x_axis, y_axis,\n",
        "            ))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the new cut\n",
        "        cut_line = Line(square.get_center(), square.get_corner(DR))\n",
        "        cut_line.set_color(YELLOW)\n",
        "        cut_tips = bottom_tips.copy().set_color(YELLOW)\n",
        "        cut_tips.rotate(-45 * DEGREES)\n",
        "        cut_tips.move_to(cut_line)\n",
        "        cut_arrow1 = VGroup(cut_line, cut_tips)\n",
        "        cut_arrow2 = cut_arrow1.copy()\n",
        "\n",
        "        d_tri = Polygon(LEFT, UP, RIGHT)\n",
        "        d_tri.match_width(square).move_to(square, DOWN)\n",
        "        r_tri = Polygon(DOWN, LEFT, UP)\n",
        "        r_tri.match_height(square).move_to(square, RIGHT)\n",
        "        for tri in d_tri, r_tri:\n",
        "            tri.set_fill(GREY_D, 0.75)\n",
        "            tri.set_stroke(width=0)\n",
        "\n",
        "        fold_line1, fold_line2 = fold_line.replicate(2)\n",
        "        fold_line1.put_start_and_end_on(square.get_corner(DL), square.get_center())\n",
        "        fold_line2.put_start_and_end_on(square.get_center(), square.get_corner(UR))\n",
        "\n",
        "        piece1 = VGroup(d_tri, h_arrows[0], fold_line1).copy()\n",
        "        piece2 = VGroup(r_tri, h_arrows[1], fold_line2).copy()\n",
        "        pieces = VGroup(piece1, piece2)\n",
        "        to_remove = VGroup(h_arrows, fold_line)\n",
        "        old_tris = VGroup(ul_triangle, dr_triangle)\n",
        "\n",
        "        self.add(pieces, old_tris, fold_line)\n",
        "        self.play(\n",
        "            ShowCreation(cut_line),\n",
        "            Write(cut_tips, time_span=(0.5, 1.5)),\n",
        "            FadeIn(pieces),\n",
        "            FadeOut(old_tris),\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.remove(to_remove)\n",
        "        piece1.add(cut_arrow1)\n",
        "        piece2.add(cut_arrow2)\n",
        "        self.add(pieces)\n",
        "        self.play(VGroup(piece1, piece2).animate.space_out_submobjects(1.5).move_to(square))\n",
        "        self.wait()\n",
        "\n",
        "        # Rearrange pieces\n",
        "        pieces.target = pieces.generate_target()\n",
        "        pieces.target[0].rotate(90 * DEGREES)\n",
        "        pieces.target[1].flip()\n",
        "        pieces.target.arrange(RIGHT, buff=0.5)\n",
        "        pieces.target.move_to(square)\n",
        "\n",
        "        self.play(MoveToTarget(pieces), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            piece1.animate.shift(square.get_center() - piece1[0].get_right()),\n",
        "            piece2.animate.shift(square.get_center() - piece2[0].get_left()),\n",
        "        )\n",
        "        self.play(\n",
        "            piece1[1].animate.set_opacity(0),\n",
        "            piece2[1].animate.set_opacity(0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fold into a Mobius strip\n",
        "        custom_squish = bezier([0, 0.05, 0.95, 1])\n",
        "\n",
        "        def smoothed_mobius_func(u, v):\n",
        "            return mobius_strip_func(u, custom_squish(v))\n",
        "\n",
        "        def get_partial_strip(upper_theta=1.0):\n",
        "            result = ParametricSurface(lambda u, v: mobius_strip_func(\n",
        "                u, custom_squish(v) * upper_theta / TAU\n",
        "            ))\n",
        "            result.scale(2, about_point=ORIGIN)\n",
        "            result.shift((0, 4, 4))\n",
        "            return result\n",
        "\n",
        "        surfaces = Group(\n",
        "            TexturedSurface(plain_surface, \"MobiusStripTexture\")\n",
        "            for plain_surface in [\n",
        "                ParametricSurface(square_func),\n",
        "                get_partial_strip(2.0),\n",
        "            ]\n",
        "        )\n",
        "        for surface in surfaces:\n",
        "            surface.set_shading(0.25, 0.25, 0)\n",
        "            surface.set_opacity(0.75)\n",
        "\n",
        "        target_z = 4\n",
        "        square3d, partial_strip = surfaces\n",
        "        square3d.rotate(45 * DEG)\n",
        "        square3d.replace(pieces)\n",
        "        square3d.set_z(target_z)\n",
        "        surface = square3d.copy()\n",
        "\n",
        "        cover_rect.surround(loop, buff=0.2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(cover_rect),\n",
        "            FadeIn(surface, shift=target_z * OUT),\n",
        "            frame.animate.reorient(2, 51, 0, (-0.35, 3.04, 0.42), 15.36),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(surface, partial_strip, run_time=2),\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(surface, lambda m, a: m.set_points(\n",
        "                get_partial_strip(interpolate(2, TAU, smooth(a))).get_points()\n",
        "            )),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 42, 0, (-0.11, 2.48, 0.87), 13.94),\n",
        "            Rotate(surface, PI, axis=RIGHT),\n",
        "            run_time=8\n",
        "        )\n",
        "        mobius_strip = surface\n",
        "\n",
        "        # Reintroduce coordiante plane\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-1.02, 3.21, 0.0), 14.55),\n",
        "            mobius_strip.animate.rotate(40 * DEG, LEFT).move_to(7.5 * UP),\n",
        "            loop.animate.scale(1.25, about_edge=RIGHT),\n",
        "            FadeOut(pieces),\n",
        "            FadeIn(x_axis),\n",
        "            FadeIn(y_axis),\n",
        "            FadeIn(folded_square),\n",
        "            FadeIn(square_point),\n",
        "            FadeIn(coord_label),\n",
        "            FadeIn(loop_x_group[1]),\n",
        "            FadeIn(loop_y_group[1]),\n",
        "        )\n",
        "\n",
        "        # Show a point on the mobius strip\n",
        "        strip_dot = TrueDot(color=BLUE)\n",
        "\n",
        "        def update_strip_dot(dot):\n",
        "            u, v = torus_uv_to_mobius_uv(get_x(), get_y())\n",
        "            strip_dot.move_to(mobius_strip.uv_to_point(u, v))\n",
        "\n",
        "        strip_dot.add_updater(update_strip_dot)\n",
        "\n",
        "        self.play(FadeIn(strip_dot))\n",
        "\n",
        "        xy_values = [\n",
        "            [0.5, 0.25],\n",
        "            [0.9, 0.1],\n",
        "            [0.8, 0.7],\n",
        "            [0.53, 0.12],\n",
        "            [0.0, 0.0],\n",
        "        ]\n",
        "        for xy in xy_values:\n",
        "            self.play(xy_tracker.animate.set_value(xy), run_time=3)\n",
        "\n",
        "        self.play(xy_tracker.animate.set_value([0.99, 0.99]), run_time=8)\n",
        "        self.play(xy_tracker.animate.set_value([0, 0]), run_time=8)\n",
        "\n",
        "        # Map from torus to strip\n",
        "        torus_group = Group(torus_mesh, torus)\n",
        "        torus_group.next_to(square, UP, buff=2)\n",
        "\n",
        "        torus_fold_line = ParametricCurve(lambda t: torus.uv_to_point(t, t), t_range=(0, 1, 0.01))\n",
        "        torus_fold_line.set_stroke(RED, 1, 1)\n",
        "\n",
        "        self.play(\n",
        "            mobius_strip.animate.shift(7 * LEFT),\n",
        "            GrowFromCenter(torus_group),\n",
        "            FadeIn(torus_point),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(torus_fold_line),\n",
        "            xy_tracker.animate.set_value([0.99, 0.99]),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Animate torus squish\n",
        "        squished_torus = TexturedSurface(\n",
        "            ParametricSurface(lambda u, v: mobius_strip_func(*torus_uv_to_mobius_uv(u, v))),\n",
        "            \"TorusTexture\",\n",
        "        )\n",
        "        squished_torus.replace(torus)\n",
        "        squished_torus.rotate(40 * DEG, LEFT)\n",
        "        squished_torus.set_opacity(0)\n",
        "\n",
        "        squished_torus_mesh = SurfaceMesh(squished_torus, resolution=(21, 21))\n",
        "        squished_torus_mesh.match_style(torus_mesh)\n",
        "        squished_torus_mesh.set_stroke(opacity=0.35)\n",
        "        squished_torus_mesh.make_jagged()\n",
        "\n",
        "        new_fold_line = ParametricCurve(lambda t: squished_torus.uv_to_point(t, t), t_range=(0, 0.99, 0.01))\n",
        "\n",
        "        self.play(\n",
        "            Transform(torus, squished_torus),\n",
        "            Transform(torus_mesh, squished_torus_mesh),\n",
        "            torus_fold_line.animate.set_points(new_fold_line.get_points()),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_loop_coord_group(self, loop, get_x, color=YELLOW, font_size=36, dot_to_num_buff=0.075, label_direction=UL):\n",
        "        loop_dot = get_special_dot(color=color)\n",
        "        loop_dot.f_always.move_to(lambda: loop.pfp(get_x()))\n",
        "\n",
        "        loop_x_label = DecimalNumber(font_size=font_size)\n",
        "        loop_x_label.match_color(loop_dot[1])\n",
        "        loop_x_label.set_backstroke(BLACK, 3)\n",
        "        loop_x_label.always.next_to(loop_dot[0], label_direction, buff=dot_to_num_buff)\n",
        "        loop_x_label.f_always.set_value(get_x)\n",
        "\n",
        "        return Group(loop_dot, loop_x_label)\n",
        "\n",
        "\n",
        "class DiscussOrderOfPoints(LoopScene):\n",
        "    def construct(self):\n",
        "        # Add loops\n",
        "        loop = get_example_loop(2)\n",
        "        loop.set_height(6)\n",
        "        loop.to_edge(DOWN, buff=0.25)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        # Dots\n",
        "        uv_tracker = ValueTracker([0.8, 0.4])\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.1)\n",
        "        line = self.get_connecting_line(dots)\n",
        "        mid_dot = self.get_midpoint_dot(dots)\n",
        "        mid_dot.update()\n",
        "\n",
        "        A_label = Tex(\"A\")\n",
        "        B_label = Tex(\"B\")\n",
        "        labels = VGroup(A_label, B_label)\n",
        "        for dot, label in zip(dots, labels):\n",
        "            label.next_to(dot, UL, buff=-0.1)\n",
        "\n",
        "        self.add(dots)\n",
        "        self.add(labels)\n",
        "\n",
        "        dots.clear_updaters()\n",
        "\n",
        "        # Add question\n",
        "        question = TexText(R\"Is $(A, B)$ distinct from $(B, A)$?\", font_size=60)\n",
        "        question.to_edge(UP)\n",
        "        self.play(Write(question))\n",
        "        self.wait()\n",
        "\n",
        "        # Swap points\n",
        "        for _ in range(2):\n",
        "            self.play(\n",
        "                Swap(*dots),\n",
        "                Swap(*labels),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show the same midpoint\n",
        "        midpoint_word = Text(\"Same midpoint\", font_size=36)\n",
        "        midpoint_word.next_to(mid_dot, LEFT, buff=0)\n",
        "        midpoint_word.set_color(TEAL)\n",
        "\n",
        "        dist_word = Text(\"Same distance\", font_size=36)\n",
        "        dist_word.set_color(TEAL)\n",
        "        dist_word.next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "        dist_word.rotate(line.get_angle(), about_point=ORIGIN)\n",
        "        dist_word.shift(mid_dot.get_center())\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(line, suspend_mobject_updating=True),\n",
        "            FadeIn(mid_dot),\n",
        "            FadeIn(midpoint_word, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(Swap(*dots))\n",
        "        self.play(\n",
        "            TransformMatchingStrings(\n",
        "                midpoint_word, dist_word,\n",
        "                key_map={\"midpoint\": \"distance\"},\n",
        "                run_time=1\n",
        "            )\n",
        "        )\n",
        "        self.play(Swap(*dots))\n",
        "        self.play(FadeOut(dist_word))\n",
        "        self.wait()\n",
        "\n",
        "        # Answer\n",
        "        answer = Text(\"It shouldn't be!\")\n",
        "        answer.next_to(question, DOWN)\n",
        "        answer.to_edge(RIGHT)\n",
        "        answer.set_color(RED)\n",
        "\n",
        "        self.play(FadeIn(answer, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show trivial rectangle\n",
        "        frame = self.frame\n",
        "        angle = 60 * DEG\n",
        "        question.fix_in_frame()\n",
        "        answer.fix_in_frame()\n",
        "        pair_group1 = Group(dots, line)\n",
        "        pair_group1.clear_updaters()\n",
        "        pair_group2 = pair_group1.copy()\n",
        "        dots2 = pair_group2[0]\n",
        "        dots2[0].set_color(PINK)\n",
        "        dots2[1].set_color(YELLOW)\n",
        "        pair_group2.rotate(angle, about_point=mid_dot.get_center())\n",
        "\n",
        "        rect = self.get_dot_polygon(\n",
        "            list(it.chain(*zip(dots, dots2)))\n",
        "        )\n",
        "        rect.update()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(loop),\n",
        "            FadeIn(pair_group2),\n",
        "            VFadeIn(rect),\n",
        "            frame.animate.move_to(mid_dot.get_center() + 0.5 * UP).set_height(6)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(pair_group2, -angle, about_point=mid_dot.get_center()),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(pair_group2, -angle, about_point=mid_dot.get_center()),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "\n",
        "class MapTheStripOntoTheSurface(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        # Setup loop and surface\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        loop = SVGMobject(\"gingerbread_outline\")[0]\n",
        "        loop.insert_n_curves(50)\n",
        "        loop.set_height(5)\n",
        "        loop.set_stroke(WHITE, 3)\n",
        "        loop.set_fill(opacity=0)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        surface, mesh, surface_func = self.get_surface_info(loop_func)\n",
        "        surface.set_opacity(0.1)\n",
        "\n",
        "        # Setup a pair of points wandering the surface for a bit\n",
        "        uv_tracker = ValueTracker([0, 0.5])\n",
        "        self.set_uv_tracker_in_motion(uv_tracker)\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.075)\n",
        "        connecting_line = self.get_connecting_line(dots)\n",
        "        z_line = self.get_z_line(dots)\n",
        "        top_dot = self.get_top_dot(z_line)\n",
        "        pair_group = Group(connecting_line, z_line, top_dot)\n",
        "        pair_group.update()\n",
        "\n",
        "        self.add(uv_tracker, dots)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-38, 82, 0, (-0.02, 0.06, 1.73), 8.03),\n",
        "            FadeIn(pair_group),\n",
        "            FadeIn(surface),\n",
        "            Write(mesh, stroke_width=1, lag_ratio=0.001, time_span=(2, 4)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        pair_group.add(dots)\n",
        "        self.add(pair_group)\n",
        "        frame.add_ambient_rotation()\n",
        "        self.wait(20)\n",
        "\n",
        "        # Show Mobius strip\n",
        "        frame.clear_updaters()\n",
        "\n",
        "        strip = ParametricSurface(mobius_strip_func)\n",
        "        strip.set_shading(0.25, 0.25, 0)\n",
        "        strip.set_color(BLUE, 0.35)\n",
        "        edge_parts = VGroup(\n",
        "            ParametricCurve(lambda t: mobius_strip_func(0, t)),\n",
        "            ParametricCurve(lambda t: mobius_strip_func(1, t)),\n",
        "        )\n",
        "        edge = edge_parts[0].copy().append_vectorized_mobject(edge_parts[1])\n",
        "        edge.make_smooth()\n",
        "        edge.set_stroke(Color(\"red\"), 0)\n",
        "\n",
        "        def uv_to_strip_point(u, v):\n",
        "            return strip.uv_to_point(*torus_uv_to_mobius_uv(u, v))\n",
        "\n",
        "        strip_point = get_special_dot(color=TEAL)\n",
        "        strip_point.f_always.move_to(\n",
        "            lambda: uv_to_strip_point(*uv_tracker.get_value())\n",
        "        )\n",
        "\n",
        "        strip_group = Group(strip, edge)\n",
        "        strip_group.set_height(6)\n",
        "        strip_group.next_to(surface, LEFT, buff=3)\n",
        "        strip_group.rotate(10 * DEGREES, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 68, 0, (-3.7, -0.17, 1.95), 9.56),\n",
        "            FadeIn(strip_group),\n",
        "            FadeIn(strip_point),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait(20)\n",
        "\n",
        "        # Show the full mapping\n",
        "        uv_tracker.clear_updaters()\n",
        "        pre_surface = ParametricSurface(\n",
        "            get_half_parametric_func(uv_to_strip_point)\n",
        "        )\n",
        "        pre_surface.match_style(strip)\n",
        "        pre_mesh = SurfaceMesh(\n",
        "            ParametricSurface(uv_to_strip_point),\n",
        "            resolution=mesh.resolution,\n",
        "            normal_nudge=0\n",
        "        )\n",
        "        pre_mesh.set_stroke(WHITE, 0.25, 0.1)\n",
        "\n",
        "        moving_surface = surface.copy()\n",
        "        moving_mesh = mesh.copy()\n",
        "\n",
        "        self.play(FadeOut(strip_point), FadeOut(pair_group))\n",
        "        self.remove(surface, mesh)\n",
        "        self.play(\n",
        "            Transform(moving_surface, pre_surface),\n",
        "            Transform(moving_mesh, pre_mesh),\n",
        "            frame.animate.reorient(-25, 71, 0, (-4.86, 0.35, 1.64), 9.84),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(moving_surface, surface),\n",
        "            ReplacementTransform(moving_mesh, mesh),\n",
        "            frame.animate.reorient(36, 68, 0, (-3.94, 0.76, 0.7), 10.14),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 60, 0, (-3.7, 0.73, 0.64), 10.44),\n",
        "            FadeIn(strip_point),\n",
        "            FadeIn(pair_group),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Trace the edge\n",
        "        u, v = uv_tracker.get_value()\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value([int(2 * u), int(2 * v)]),\n",
        "            loop.animate.set_stroke(opacity=0.2),\n",
        "            run_time=2\n",
        "        )\n",
        "        uv_tracker.set_value([0, 0])\n",
        "        edge.set_stroke(width=3)\n",
        "        loop_copy = loop.copy().set_stroke(opacity=1)\n",
        "        self.play(\n",
        "            ShowCreation(edge),\n",
        "            ShowCreation(loop_copy),\n",
        "            uv_tracker.animate.set_value([0.999, 0.999]),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.remove(loop_copy)\n",
        "        loop.set_stroke(opacity=1)\n",
        "\n",
        "        # Show the mapping with the edge\n",
        "        edge_image = loop.copy().match_style(edge)\n",
        "        moving_edge = edge.copy()\n",
        "\n",
        "        moving_group = Group(moving_surface, moving_mesh, moving_edge)\n",
        "        pre_group = Group(pre_surface, pre_mesh, edge)\n",
        "        post_group = Group(surface, mesh, edge_image)\n",
        "\n",
        "        moving_group.become(pre_group)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(moving_surface),\n",
        "            FadeIn(moving_mesh),\n",
        "            FadeOut(strip_point),\n",
        "            FadeOut(pair_group),\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(moving_group, post_group),\n",
        "            frame.animate.reorient(18, 65, 0, (-3.85, 0.76, 0.85), 10.44),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show another back and forth, but with colliding points\n",
        "        rect_params = find_rectangle(loop_func)\n",
        "        pre_collision_dots, post_collision_dots = coll_dot_groups = Group(\n",
        "            get_special_dot(color, radius=0.075)\n",
        "            for color in [YELLOW, GREEN_SCREEN]\n",
        "        ).replicate(2)\n",
        "        coll_dot_groups.deactivate_depth_test()\n",
        "        for func, dot_group in zip([uv_to_strip_point, surface_func], coll_dot_groups):\n",
        "            for dot, uv in zip(dot_group, [rect_params[0::2], rect_params[1::2]]):\n",
        "                dot.move_to(func(*uv))\n",
        "\n",
        "        moving_dots = pre_collision_dots.copy()\n",
        "\n",
        "        self.play(\n",
        "            Transform(moving_group, pre_group),\n",
        "            frame.animate.reorient(-32, 70, 0, (-3.85, 0.76, 0.85), 10.44),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(FadeIn(pre_collision_dots))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(moving_group, post_group),\n",
        "            Transform(moving_dots, post_collision_dots),\n",
        "            frame.animate.reorient(1, 59, 0, (-4.08, 0.88, 1.17), 9.71),\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "        # Show show rectangle for this collision\n",
        "        uv_tracker1 = uv_tracker\n",
        "        uv_tracker1.set_value(rect_params[0::2])\n",
        "        pair_group1 = pair_group\n",
        "\n",
        "        uv_tracker2 = ValueTracker(rect_params[1::2])\n",
        "        dots2 = self.get_movable_pair(uv_tracker2, loop_func, colors=[RED, MAROON_B])\n",
        "        connecting_line2 = self.get_connecting_line(dots2)\n",
        "        pair_group2 = Group(dots2, connecting_line2)\n",
        "\n",
        "        rectangle = self.get_dot_polygon(Group(dots[0], dots2[0], dots[1], dots2[1]))\n",
        "        rectangle.set_stroke(YELLOW, 5)\n",
        "        dots.update()\n",
        "        dots2.update()\n",
        "        rectangle.update()\n",
        "        rectangle.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(moving_group),\n",
        "            FadeIn(pair_group1),\n",
        "            FadeIn(pair_group2),\n",
        "            mesh.animate.set_stroke(opacity=0.05),\n",
        "            frame.animate.reorient(0, 38, 0, (-2.92, 0.03, 1.12), 6.65),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(rectangle, time_span=(0, 2)),\n",
        "            frame.animate.reorient(36, 68, 0, (-2.89, -0.15, 0.74), 8.11),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "\n",
        "class AmbientRectangleSearch(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        # Setup loop\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        self.add(plane)\n",
        "\n",
        "        loop = get_example_loop(2)\n",
        "        loop.insert_n_curves(50)\n",
        "        loop.set_height(5)\n",
        "        loop.set_stroke(WHITE, 3)\n",
        "        loop.set_fill(opacity=0)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        # Dots\n",
        "        abcd_tracker = ValueTracker(np.random.random(4))\n",
        "        dots = self.get_movable_quad(abcd_tracker, loop_func, radius=0.1)\n",
        "        polygon = self.get_dot_polygon(dots)\n",
        "        polygon.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.add(dots, polygon)\n",
        "\n",
        "        # Various rectangles\n",
        "        for _ in range(20):\n",
        "            rect_params = find_rectangle(\n",
        "                loop_func,\n",
        "                initial_condition=np.random.random(4),\n",
        "                target_angle=np.random.uniform(0, 90 * DEG),\n",
        "            )\n",
        "            self.play(abcd_tracker.animate.set_value(rect_params), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class GenericLoopPair(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        loop = Circle(radius=2.5)\n",
        "        loop.set_stroke(WHITE, 3)\n",
        "        loop.set_fill(opacity=0)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        uv_tracker = ValueTracker([0, 0.5])\n",
        "        # self.set_uv_tracker_in_motion(uv_tracker, velocity=(0.1 * PI / 2, -0.1))\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.075, colors=[YELLOW, YELLOW])\n",
        "        connecting_line = self.get_connecting_line(dots)\n",
        "        connecting_line.set_stroke(YELLOW)\n",
        "        pair_group = Group(dots, connecting_line)\n",
        "\n",
        "        self.add(uv_tracker, pair_group)\n",
        "\n",
        "        # Wait\n",
        "        for _ in range(20):\n",
        "            self.play(uv_tracker.animate.set_value(np.random.random(2)), run_time=2)\n",
        "            self.wait(0.5)\n",
        "\n",
        "\n",
        "class SudaneseBand(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Tranform mobius to Sudanese\n",
        "        frame = self.frame\n",
        "        sudanese_band = self.get_full_surface(sudanese_band_func)\n",
        "        strip = self.get_full_surface(alt_mobius_strip_func)\n",
        "        strip.set_height(6)\n",
        "        og_strip = strip.copy()\n",
        "        sudanese_band.set_height(6)\n",
        "\n",
        "        frame.reorient(28, 75, 0, ORIGIN, 8)\n",
        "        self.add(strip)\n",
        "        self.play(frame.animate.increment_theta(180 * DEG), run_time=12)\n",
        "        self.play(\n",
        "            frame.animate.reorient(99, 102, 0),\n",
        "            Transform(strip, sudanese_band, time_span=(0, 6)),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.wait(30)  # Examine\n",
        "\n",
        "        # Back to strip\n",
        "        self.play(\n",
        "            Transform(strip, og_strip),\n",
        "            run_time=6\n",
        "        )\n",
        "\n",
        "    def get_full_surface(self, surface_func, resolution=(101, 101)):\n",
        "        surface = ParametricSurface(surface_func, resolution=resolution)\n",
        "        surface.set_color(BLUE_E, 1)\n",
        "        surface.set_shading(0.25, 0.25, 0)\n",
        "\n",
        "        mesh = VGroup(\n",
        "            *SurfaceMesh(surface, resolution=(21, 21), normal_nudge=1e-3),\n",
        "            *SurfaceMesh(surface, resolution=(21, 21), normal_nudge=-1e-3),\n",
        "        )\n",
        "        mesh.set_stroke(WHITE, 0.5, 0.2)\n",
        "\n",
        "        edge = VGroup(\n",
        "            ParametricCurve(lambda t: surface_func(0, t), (0, 1, 0.01)),\n",
        "            ParametricCurve(lambda t: surface_func(1, t), (0, 1, 0.01)),\n",
        "        )\n",
        "        edge.set_stroke(Color(\"red\"), 2)\n",
        "        edge.apply_depth_test()\n",
        "\n",
        "        return Group(surface, mesh, edge)\n",
        "\n",
        "\n",
        "class ShowSurfaceReflection(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        # Setup loop and surface\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        self.add(axes, plane)\n",
        "\n",
        "        loop = get_example_loop(2)\n",
        "        loop.insert_n_curves(50)\n",
        "        loop.set_height(5)\n",
        "        loop.set_stroke(WHITE, 3)\n",
        "        loop.set_fill(opacity=0)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        surface, mesh, surface_func = self.get_surface_info(loop_func)\n",
        "        surface.set_opacity(0.1)\n",
        "        surface_group = Group(surface, mesh)\n",
        "\n",
        "        self.add(surface_group)\n",
        "        frame.reorient(-36, 82, 0, (0.09, 1.17, 2.23), 11.39)\n",
        "        self.play(frame.animate.reorient(36, 85, 0, (-0.68, 0.78, 2.39), 11.39), run_time=6)\n",
        "\n",
        "        # Show the reflection\n",
        "        reflection = surface_group.copy()\n",
        "        reflection.stretch(-1, 2, about_point=axes.c2p(0, 0, 0))\n",
        "        ghost_surface = surface_group.copy()\n",
        "        ghost_surface.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(ghost_surface, reflection),\n",
        "            frame.animate.reorient(33, 81, 0, (-0.15, 0.61, 0.29), 14.60),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.add(reflection, surface_group)\n",
        "\n",
        "        # Emphasize the ege\n",
        "        frame.add_ambient_rotation(2 * DEG)\n",
        "        low_edge = loop.copy()\n",
        "        low_edge.set_color(RED)\n",
        "        shift_vect = 0.25 * OUT\n",
        "\n",
        "        self.play(\n",
        "            surface_group.animate.shift(shift_vect),\n",
        "            loop.animate.set_stroke(Color(\"red\")).shift(shift_vect),\n",
        "            low_edge.animate.shift(-shift_vect),\n",
        "            reflection.animate.shift(-shift_vect),\n",
        "            FadeOut(axes),\n",
        "            FadeOut(plane),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(1)\n",
        "        self.play(\n",
        "            FadeOut(loop, shift=-shift_vect),\n",
        "            FadeOut(low_edge, shift=shift_vect),\n",
        "            surface_group.animate.shift(-shift_vect),\n",
        "            reflection.animate.shift(shift_vect),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class ConstructKleinBottle(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add arrow diagram\n",
        "        square = Square()\n",
        "        square.set_fill(GREY_E, 1).set_stroke(BLACK, width=0)\n",
        "        square.set_height(4)\n",
        "\n",
        "        dr_tri = Polygon(DL, DR, UR)\n",
        "        dr_tri.match_style(square)\n",
        "        dr_tri.replace(square)\n",
        "\n",
        "        mobius_diagram = VGroup(\n",
        "            dr_tri,\n",
        "            self.get_tri_arrow(square.get_corner(DL), square.get_corner(DR)),\n",
        "            self.get_tri_arrow(square.get_corner(DR), square.get_corner(UR)),\n",
        "            Line(square.get_corner(DL), square.get_corner(UR)).set_stroke(Color(\"red\"), 3)\n",
        "        )\n",
        "\n",
        "        mobius_label = Text(\"M\u00f6bius Strip\", font_size=60)\n",
        "        mobius_label.next_to(mobius_diagram, UR)\n",
        "        mobius_label.shift(DOWN + 0.25 * RIGHT)\n",
        "        mobius_arrow = Arrow(\n",
        "            mobius_label.get_bottom(),\n",
        "            mobius_diagram.get_center() + 0.5 * DR,\n",
        "            path_arc=-90 * DEG,\n",
        "            thickness=5\n",
        "        )\n",
        "        mobius_arrow.set_z_index(1)\n",
        "\n",
        "        self.add(mobius_diagram)\n",
        "        self.play(\n",
        "            FadeIn(mobius_label),\n",
        "            FadeIn(mobius_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a reflection\n",
        "        reflection = mobius_diagram.copy()\n",
        "        reflection.flip(UR, about_point=square.get_center())\n",
        "        reflection.shift(UL)\n",
        "        reflection[1:3].set_color(PINK)\n",
        "\n",
        "        reflection_label = Text(\"Reflected\\nM\u00f6bius Strip\", font_size=60)\n",
        "        reflection_label.next_to(reflection, LEFT, aligned_edge=DOWN)\n",
        "        reflection_arrow = Arrow(\n",
        "            reflection_label.get_top(),\n",
        "            reflection.get_center() + 0.5 * LEFT + 0.25 * UP,\n",
        "            path_arc=-90 * DEG,\n",
        "            thickness=5\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                TransformMatchingStrings(mobius_label.copy(), reflection_label, run_time=1),\n",
        "                TransformFromCopy(mobius_diagram, reflection),\n",
        "                TransformFromCopy(mobius_arrow, reflection_arrow),\n",
        "                lag_ratio=0.1\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Glue along boundary\n",
        "        glue_label = Text(\"Glue the boundaries\", font_size=36)\n",
        "        glue_label.next_to(ORIGIN, DOWN, SMALL_BUFF)\n",
        "        glue_label.rotate(45 * DEG, about_point=ORIGIN)\n",
        "        glue_label.shift(square.get_center())\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(reflection_arrow),\n",
        "                FadeOut(mobius_arrow),\n",
        "                reflection.animate.shift(DR),\n",
        "                reflection_label.animate.scale(0.75).next_to(square, LEFT, MED_SMALL_BUFF),\n",
        "                mobius_label.animate.scale(0.75).next_to(square, RIGHT, MED_SMALL_BUFF),\n",
        "            ),\n",
        "            FadeIn(glue_label, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(glue_label, reflection_label, mobius_label)),\n",
        "            mobius_diagram[-1].animate.set_stroke(width=0),\n",
        "            reflection[-1].animate.set_stroke(width=0),\n",
        "        )\n",
        "\n",
        "        # Cut along diagonal\n",
        "        teal_arrows = mobius_diagram[1:3]\n",
        "        pink_arrows = reflection[1:3]\n",
        "        yellow_arrows = self.get_tri_arrow(square.get_corner(UL), square.get_corner(DR), color=YELLOW).replicate(2)\n",
        "        ur_tri = Polygon(DR, UR, UL)\n",
        "        dl_tri = Polygon(DR, DL, UL)\n",
        "        for tri in [ur_tri, dl_tri]:\n",
        "            tri.match_style(square)\n",
        "            tri.replace(square)\n",
        "\n",
        "        ur_group = VGroup(ur_tri, teal_arrows[1], pink_arrows[1])\n",
        "        dl_group = VGroup(dl_tri, teal_arrows[0], pink_arrows[0])\n",
        "\n",
        "        self.remove(mobius_diagram, reflection)\n",
        "        self.add(ur_group)\n",
        "        self.add(dl_group)\n",
        "\n",
        "        self.play(*(Write(arrow, stroke_color=YELLOW) for arrow in yellow_arrows))\n",
        "        ur_group.add(yellow_arrows[0])\n",
        "        dl_group.add(yellow_arrows[1])\n",
        "        self.play(VGroup(ur_group, dl_group).animate.space_out_submobjects(3))\n",
        "        self.wait()\n",
        "\n",
        "        # Flip and glue\n",
        "        frame = self.frame\n",
        "        self.play(\n",
        "            dl_group.animate.next_to(ORIGIN, UP, 0.5),\n",
        "            ur_group.animate.flip(UR).next_to(ORIGIN, DOWN, 0.5),\n",
        "            frame.animate.set_height(10),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ur_group.animate.shift(-ur_tri.get_top()),\n",
        "            dl_group.animate.shift(-dl_tri.get_bottom()),\n",
        "        )\n",
        "        self.play(teal_arrows.animate.set_stroke(width=0).set_fill(opacity=0))\n",
        "\n",
        "        # Shear back into square\n",
        "        pre_square = square.copy()\n",
        "        pre_square.apply_matrix(np.matrix([[1, -1], [0, 1]]).T)\n",
        "        pre_square.move_to(VGroup(dl_tri, dr_tri), UP)\n",
        "\n",
        "        trg_yellow_arrows = VGroup(\n",
        "            self.get_tri_arrow(square.get_corner(DR), square.get_corner(DL), color=YELLOW).flip(RIGHT),\n",
        "            self.get_tri_arrow(square.get_corner(UL), square.get_corner(UR), color=YELLOW),\n",
        "        )\n",
        "\n",
        "        self.remove(ur_tri, dl_tri)\n",
        "        self.add(pre_square, pink_arrows, yellow_arrows)\n",
        "        self.play(\n",
        "            Transform(pre_square, square),\n",
        "            Transform(yellow_arrows, trg_yellow_arrows),\n",
        "            pink_arrows[0].animate.move_to(square.get_left()),\n",
        "            pink_arrows[1].animate.move_to(square.get_right()),\n",
        "            frame.animate.set_height(8),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fold into half tube\n",
        "        klein_func = self.get_kelin_bottle_func()\n",
        "        near_smooth = bezier([0, 0.1, 0.9, 1])\n",
        "        surfaces = Group(\n",
        "            TexturedSurface(ParametricSurface(func), \"KleinBottleTexture\")\n",
        "            for func in [\n",
        "                square_func,\n",
        "                tube_func,\n",
        "                lambda u, v: torus_func(u, 0.5 * v),\n",
        "                lambda u, v: klein_func(u, 0.5 * near_smooth(v)),\n",
        "            ]\n",
        "        )\n",
        "        for surface in surfaces:\n",
        "            surface.set_opacity(0.9)\n",
        "            surface.set_shading(0.3, 0.2, 0)\n",
        "        square3d, tube, half_torus, half_klein = surfaces\n",
        "        square3d.replace(square)\n",
        "        square3d.shift(4 * OUT)\n",
        "        moving_surface = square3d.copy()\n",
        "\n",
        "        tube.set_width(square.get_width() / PI)\n",
        "        tube.set_height(square.get_height(), stretch=True)\n",
        "        tube.move_to(square3d)\n",
        "\n",
        "        half_torus.match_depth(tube)\n",
        "        half_torus.move_to(tube)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(moving_surface, shift=square3d.get_z() * OUT),\n",
        "            frame.animate.reorient(0, 56, 0, (0.07, 0.52, 2.39), 11.25),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.play(Transform(moving_surface, tube), run_time=4)\n",
        "        self.wait()\n",
        "        self.play(Transform(moving_surface, half_torus, path_arc=PI / 2), run_time=4)\n",
        "        self.wait()\n",
        "        self.play(Transform(moving_surface, half_klein), run_time=4)\n",
        "\n",
        "        # Transition to full Klein Bottle\n",
        "        klein_diagram = VGroup(pre_square, pink_arrows, yellow_arrows)\n",
        "        v_upper_bound = 0.85\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(moving_surface, lambda m, a: m.match_points(\n",
        "                ParametricSurface(lambda u, v: klein_func(u, interpolate(0.5, 1, a) * near_smooth(v)))\n",
        "            ).set_opacity(interpolate(0.9, 0.75, a))),\n",
        "            klein_diagram.animate.set_x(-5),\n",
        "            frame.animate.reorient(0, 46, 0, (-0.71, -0.11, 1.71), 10.87),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            klein_diagram.animate.next_to(moving_surface, LEFT, buff=2),\n",
        "            frame.animate.reorient(0, 0, 0, (-3.2, 0.03, 0.0), 12.58),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_tri_arrow(self, start, end, color=TEAL, stroke_width=3, tip_width=0.35):\n",
        "        line = Line(start, end)\n",
        "        line.set_stroke(color, stroke_width)\n",
        "        tips = ArrowTip().replicate(3)\n",
        "        tips.set_fill(color)\n",
        "        tips.set_width(tip_width)\n",
        "        tips.rotate(line.get_angle())\n",
        "        for alpha, tip in zip(np.linspace(0.2, 0.8, 3), tips):\n",
        "            tip.move_to(line.pfp(alpha))\n",
        "\n",
        "        return VGroup(line, tips)\n",
        "\n",
        "    def get_kelin_bottle_func(self, width=4, z=4):\n",
        "        # Test kelin func\n",
        "        ref_svg = SVGMobject(\"KleinReference\")[0]\n",
        "        ref_svg.make_smooth(approx=False)\n",
        "        ref_svg.add_line_to(ref_svg.get_start())\n",
        "        ref_svg.set_stroke(WHITE, 3)\n",
        "        ref_svg.set_width(width)\n",
        "        ref_svg.rotate(PI)\n",
        "        ref_svg.set_z(4)\n",
        "        ref_svg.insert_n_curves(100)\n",
        "\n",
        "        # curve_func = get_quick_loop_func(ref_svg)\n",
        "        curve_func = ref_svg.quick_point_from_proportion\n",
        "        radius_func = bezier([1, 1, 0.5, 0.3, 0.3, 0.3, 1.0])\n",
        "        tan_alpha_func = bezier([1, 1, 0, 0, 0, 0, 1, 1])\n",
        "        v_alpha_func = squish_rate_func(smooth, 0.25, 0.75)\n",
        "\n",
        "        def pre_klein_func(u, v):\n",
        "            dv = 1e-2\n",
        "            c_point = curve_func(v)\n",
        "            c_prime = normalize((curve_func(v + dv) - curve_func(v - dv)) / (2 * dv))\n",
        "            tangent_alpha = tan_alpha_func(v)\n",
        "            # tangent = interpolate(c_prime, UP if v < 0.5 else DOWN, tangent_alpha)\n",
        "            tangent = interpolate(c_prime, interpolate(UP, DOWN, v_alpha_func(v)), tangent_alpha)\n",
        "\n",
        "            perp = normalize(cross(tangent, OUT))\n",
        "            radius = radius_func(v)\n",
        "\n",
        "            return c_point + radius * (math.cos(TAU * u) * OUT - math.sin(TAU * u) * perp)\n",
        "\n",
        "        v_upper_bound = 0.85\n",
        "\n",
        "        def true_kelin_func(u, v):\n",
        "            if v <= v_upper_bound:\n",
        "                return pre_klein_func(u, v)\n",
        "            else:\n",
        "                alpha = inverse_interpolate(v_upper_bound, 1, v)\n",
        "                return interpolate(pre_klein_func(u, v_upper_bound), pre_klein_func(1 - u, 0), alpha)\n",
        "\n",
        "        return true_kelin_func\n",
        "\n",
        "\n",
        "class PuzzleOverMobiusDiagram(ConstructKleinBottle):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        triangle = Polygon(DL, DR, UR)\n",
        "        triangle.set_fill(GREY_E, 1)\n",
        "        triangle.set_stroke(WHITE, 0)\n",
        "        triangle.set_height(4)\n",
        "        triangle.to_edge(UP, buff=1)\n",
        "\n",
        "        low_arrow = self.get_tri_arrow(triangle.get_corner(DL), triangle.get_corner(DR), stroke_width=4)\n",
        "        right_arrow = self.get_tri_arrow(triangle.get_corner(DR), triangle.get_corner(UR), stroke_width=4)\n",
        "        edge = Line(triangle.get_corner(DL), triangle.get_corner(UR))\n",
        "        edge.set_stroke(Color(\"red\"), 3)\n",
        "\n",
        "        self.add(triangle, edge, low_arrow, right_arrow)\n",
        "        self.wait()\n",
        "\n",
        "        low_arrow.save_state()\n",
        "        self.play(\n",
        "            triangle.animate.set_opacity(0.25),\n",
        "            edge.animate.set_opacity(0.1),\n",
        "            low_arrow.animate.rotate(90 * DEG).next_to(right_arrow, RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(low_arrow.animate.move_to(right_arrow))\n",
        "        self.play(low_arrow.animate.next_to(right_arrow, RIGHT))\n",
        "        self.play(\n",
        "            Restore(low_arrow),\n",
        "            triangle.animate.set_fill(opacity=1),\n",
        "            edge.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "\n",
        "        # Show the dots\n",
        "        dots = GlowDot(color=BLUE, radius=0.25, glow_factor=1.5).replicate(2)\n",
        "        top_dot = dots[0].copy()\n",
        "        top_dot.move_to(right_arrow.get_top())\n",
        "        for _ in range(3):\n",
        "            dots[0].move_to(low_arrow.get_left())\n",
        "            dots[1].move_to(right_arrow.get_bottom())\n",
        "            self.add(top_dot)\n",
        "            self.wait(1 / 30)\n",
        "            self.remove(top_dot)\n",
        "            self.play(\n",
        "                dots[0].animate.move_to(low_arrow.get_right()),\n",
        "                dots[1].animate.move_to(right_arrow.get_top()),\n",
        "                run_time=3,\n",
        "                rate_func=linear\n",
        "            )\n",
        "\n",
        "\n",
        "class ShowAngleInformation(ShowTheSurface):\n",
        "    def construct(self):\n",
        "        # Setup (fairly heavily copied from above)\n",
        "        frame = self.frame\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        plane.fade(0.5)\n",
        "        frame.set_height(6)\n",
        "        frame.set_x(1)\n",
        "        self.add(plane)\n",
        "\n",
        "        loop = get_example_loop()\n",
        "        loop.set_height(5.5).center()\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        square_params = find_rectangle(loop_func, target_angle=90 * DEG)\n",
        "        uv_tracker = ValueTracker(square_params[0::2])\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.05)\n",
        "        connecting_line = self.get_connecting_line(dots)\n",
        "        connecting_line.update().suspend_updating()\n",
        "        midpoint_dot = self.get_midpoint_dot(dots)\n",
        "        midpoint_dot.update()\n",
        "        pair_group = Group(dots, connecting_line, midpoint_dot)\n",
        "\n",
        "        self.add(pair_group)\n",
        "\n",
        "        # Corner coordinates\n",
        "        corner_coords = Tex(\"(x, y, d)\")\n",
        "        corner_coords.next_to(frame.get_corner(UR), DL)\n",
        "        self.add(corner_coords)\n",
        "\n",
        "        # Add coordinates\n",
        "        coords = Tex(\"(x, y)\")\n",
        "        coords.set_backstroke(BLACK, 5)\n",
        "        coords.set_fill(WHITE, 1)\n",
        "\n",
        "        coords.next_to(midpoint_dot, DR, buff=-0.1)\n",
        "        self.play(\n",
        "            Write(coords),\n",
        "            FlashAround(corner_coords[\"x, y\"], time_width=1.5),\n",
        "            run_time=1.5\n",
        "        )\n",
        "\n",
        "        # Show the distance\n",
        "        brace = Brace(Line(LEFT, RIGHT).set_width(connecting_line.get_length()), DOWN, buff=SMALL_BUFF)\n",
        "        brace.rotate(connecting_line.get_angle() + PI, about_point=ORIGIN)\n",
        "        brace.shift(connecting_line.get_center())\n",
        "        brace.set_fill(GREY, 1)\n",
        "        d_label = Tex(\"d\")\n",
        "        d_label.set_backstroke(BLACK, 5)\n",
        "        d_label.move_to(brace.get_center() + 0.5 * normalize(brace.get_center() - midpoint_dot.get_center()))\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(d_label),\n",
        "            FlashAround(corner_coords[\"d\"], time_width=1.5, run_time=1.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the angle\n",
        "        cross_point = connecting_line.pfp(inverse_interpolate(\n",
        "            connecting_line.get_y(DOWN), connecting_line.get_y(UP), -1\n",
        "        ))\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(4)\n",
        "        h_line.move_to(cross_point + RIGHT)\n",
        "        h_line.set_stroke(WHITE, 2)\n",
        "        arc = Arc(0, connecting_line.get_angle(), radius=0.45, arc_center=cross_point)\n",
        "        theta = Tex(R\"\\theta\")\n",
        "        theta.next_to(arc.pfp(0.5), RIGHT, SMALL_BUFF).shift(SMALL_BUFF * UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            ShowCreation(arc),\n",
        "            Write(theta),\n",
        "        )\n",
        "\n",
        "        # New corner coords\n",
        "        new_corner_coords = Tex(R\"(x, y, d, \\theta)\")\n",
        "        new_corner_coords.move_to(corner_coords, RIGHT)\n",
        "        self.play(\n",
        "            *(\n",
        "                ReplacementTransform(corner_coords[substr], new_corner_coords[substr])\n",
        "                for substr in [\"(x, y, d\", \")\"]\n",
        "            ),\n",
        "            TransformFromCopy(theta, new_corner_coords[R\"\\theta\"]),\n",
        "            Write(new_corner_coords[R\",\"][-1]),\n",
        "        )\n",
        "        self.add(new_corner_coords)\n",
        "        self.wait()\n",
        "\n",
        "        # Show the other pair\n",
        "        uv_tracker2 = ValueTracker(square_params[1::2])\n",
        "        dots2 = self.get_movable_pair(uv_tracker2, loop_func, radius=0.05, colors=[RED, MAROON_B])\n",
        "        connecting_line2 = self.get_connecting_line(dots2)\n",
        "        pair_group2 = Group(dots2, connecting_line2)\n",
        "        midpoint = midpoint_dot.get_center()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                connecting_line.copy().clear_updaters(),\n",
        "                connecting_line2,\n",
        "                path_arc=-90 * DEG,\n",
        "                suspend_mobject_updating=True\n",
        "            ),\n",
        "            Rotate(brace, -90 * DEG, about_point=midpoint),\n",
        "            d_label.animate.rotate(-90 * DEGREES, about_point=midpoint).rotate(90 * DEG),\n",
        "            coords.animate.next_to(midpoint_dot, DL, buff=-0.1),\n",
        "            loop.animate.set_stroke(opacity=0.5)\n",
        "        )\n",
        "        self.play(FadeIn(dots2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the right angle\n",
        "        cross_point2 = connecting_line2.pfp(inverse_interpolate(\n",
        "            connecting_line2.get_start()[1], connecting_line2.get_end()[1], 0\n",
        "        ))\n",
        "        h_line2 = Line(cross_point2, cross_point2 + 2 * RIGHT)\n",
        "        h_line2.match_style(h_line)\n",
        "        arc2 = Arc(0, PI + connecting_line2.get_angle(), radius=0.45, arc_center=cross_point2)\n",
        "        theta_plus = Tex(R\"\\theta + 90^\\circ\", font_size=42)\n",
        "        theta_plus.next_to(arc2.pfp(0.3), UR, buff=SMALL_BUFF)\n",
        "\n",
        "        elbow = Elbow()\n",
        "        elbow.rotate(connecting_line2.get_angle() + 90 * DEG, about_point=ORIGIN)\n",
        "        elbow.shift(midpoint_dot.get_center())\n",
        "        perp_label = Tex(R\"90^\\circ\", font_size=36)\n",
        "        perp_label.next_to(elbow.pfp(0.5), UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(brace),\n",
        "            FadeOut(d_label),\n",
        "            ShowCreation(elbow),\n",
        "            Write(perp_label),\n",
        "        )\n",
        "\n",
        "        # New pair corner label\n",
        "        shift_vect = 0.5 * RIGHT\n",
        "        low_corner_coords = Tex(R\"(x, y, d, \\theta + 90^\\circ)\")\n",
        "        low_corner_coords.next_to(new_corner_coords, DOWN, aligned_edge=RIGHT)\n",
        "        low_corner_coords.shift(shift_vect)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingStrings(new_corner_coords.copy(), low_corner_coords),\n",
        "            new_corner_coords.animate.shift(shift_vect),\n",
        "            frame.animate.shift(shift_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the square\n",
        "        square = self.get_dot_polygon(\n",
        "            list(it.chain(*zip(dots, dots2)))\n",
        "        )\n",
        "        square.update().suspend_updating()\n",
        "        square.set_stroke(YELLOW, 3)\n",
        "        self.play(ShowCreation(square))\n",
        "        self.wait()\n",
        "\n",
        "        # Comment on four dimension\n",
        "\n",
        "\n",
        "class RectanglesOfAllAspectRatios(LoopScene):\n",
        "    def construct(self):\n",
        "        # Loop\n",
        "        loop = self.get_loop()\n",
        "        loop.set_height(6.5)\n",
        "        loop.to_corner(DR)\n",
        "        loop.set_stroke(WHITE, 1).set_fill(opacity=0)\n",
        "        loop_func = get_quick_loop_func(loop)\n",
        "        self.add(loop)\n",
        "\n",
        "        # Dots\n",
        "        angle_tracker = ValueTracker(90 * DEG)\n",
        "        get_angle = angle_tracker.get_value\n",
        "        square_params = find_rectangle(\n",
        "            loop_func,\n",
        "            initial_condition=np.arange(0.5, 1, 0.1),\n",
        "            target_angle=angle_tracker.get_value()\n",
        "        )\n",
        "        abcd_tracker = ValueTracker(square_params)\n",
        "        dots = self.get_movable_quad(abcd_tracker, loop_func, radius=0.075)\n",
        "        rect = self.get_dot_polygon(dots)\n",
        "        rect.set_stroke(YELLOW)\n",
        "\n",
        "        rect_group = Group(abcd_tracker, dots, rect)\n",
        "\n",
        "        self.add(rect_group)\n",
        "\n",
        "        # Show aspect ratio\n",
        "        def get_aspect_ratio():\n",
        "            phi = get_angle() / 2\n",
        "            return math.cot(phi)\n",
        "\n",
        "        sample_rect = Square(side_length=2)\n",
        "        sample_rect_center = 4 * LEFT + DOWN\n",
        "        sample_rect_size_factor = 2.5\n",
        "        sample_rect.set_stroke(YELLOW)\n",
        "\n",
        "        def update_sample_rect(rect):\n",
        "            phi = get_angle() / 2\n",
        "            sf = sample_rect_size_factor\n",
        "            rect.set_shape(sf * math.cos(phi), sf * math.sin(phi))\n",
        "            rect.move_to(sample_rect_center)\n",
        "\n",
        "        sample_rect.add_updater(update_sample_rect)\n",
        "\n",
        "        aspect_ratio_label = TexText(\"Aspect ratio = 1:1\")\n",
        "        aspect_ratio_label.next_to(sample_rect, UP).shift(MED_SMALL_BUFF * LEFT)\n",
        "        ar_label = aspect_ratio_label[\"1:1\"][0]\n",
        "\n",
        "        self.add(aspect_ratio_label[:-3])\n",
        "        self.add(ar_label)\n",
        "        self.add(sample_rect)\n",
        "        self.wait()\n",
        "\n",
        "        # Change angle\n",
        "        def true_find_rect(loop_func, angle, max_tries=10, max_cost=1e-2):\n",
        "            for _ in range(max_tries):\n",
        "                result, cost = find_rectangle(\n",
        "                    loop_func,\n",
        "                    initial_condition=np.random.random(4),\n",
        "                    target_angle=angle,\n",
        "                    n_refinements=4,\n",
        "                    return_cost=True\n",
        "                )\n",
        "                if cost < max_cost:\n",
        "                    return result\n",
        "            return result\n",
        "\n",
        "        aspect_ratio_pairs = self.get_aspect_ratio_pairs()\n",
        "        for tex, ratio in aspect_ratio_pairs:\n",
        "            label = Tex(tex)\n",
        "            label.move_to(ar_label, LEFT)\n",
        "            if ratio < 1:\n",
        "                ratio = 1.0 / ratio\n",
        "            angle_tracker.set_value(2 * math.atan(1.0 / ratio))\n",
        "            abcd_tracker.set_value(true_find_rect(loop_func, get_angle()))\n",
        "            ar_label.set_submobjects(list(label))\n",
        "            self.wait(1 / 3)\n",
        "\n",
        "    def get_loop(self):\n",
        "        return get_example_loop(4)\n",
        "\n",
        "    def get_aspect_ratio_pairs(self):\n",
        "        return [\n",
        "            (\"16 : 9\", 16 / 9),\n",
        "            (\"4 : 3\", 4 / 3),\n",
        "            (\"10 : 1\", 10 / 1),\n",
        "            (R\"\\sqrt{2} : 1\", math.sqrt(2)),\n",
        "            (R\"5 : 2\", 5 / 2),\n",
        "            (R\"\\pi : 1\", math.pi),\n",
        "            (R\"\\varphi : 1\", (1 + math.sqrt(5)) / 2),  # Golden ratio\n",
        "            (R\"e : 1\", math.e),\n",
        "            (\"21 : 9\", 21 / 9),  # Ultrawide\n",
        "            (R\"\\sqrt{3} : 1\", math.sqrt(3)),\n",
        "            (\"3 : 2\", 3 / 2),    # Classic photography\n",
        "            (\"1 : 1\", 1 / 1),    # Square\n",
        "            (R\"2\\pi : 1\", 2 * math.pi),\n",
        "            (\"7 : 5\", 7 / 5),\n",
        "            (R\"\\ln(10) : 1\", math.log(10)),\n",
        "            (\"8 : 5\", 8 / 5),\n",
        "            (\"12 : 5\", 12 / 5),\n",
        "            (R\"\\sqrt{5} : 1\", math.sqrt(5)),\n",
        "            (\"9 : 16\", 9 / 16),  # Portrait 16:9\n",
        "            (\"2 : 3\", 2 / 3),    # Portrait photography\n",
        "            (R\"\\pi : 2\", math.pi / 2),\n",
        "            (\"7 : 3\", 7 / 3),\n",
        "            (R\"2\\sqrt{2} : 1\", 2 * math.sqrt(2)),\n",
        "            (\"15 : 4\", 15 / 4),\n",
        "            (R\"\\sqrt{7} : 1\", math.sqrt(7)),\n",
        "            (\"11 : 4\", 11 / 4),\n",
        "            (R\"e : 2\", math.e / 2),\n",
        "            (\"13 : 5\", 13 / 5),\n",
        "            (\"8 : 3\", 8 / 3),\n",
        "            (R\"\\pi^2 : 9\", math.pi ** 2 / 9)\n",
        "        ]\n",
        "\n",
        "\n",
        "class AllAspectRatioXMaxTree(RectanglesOfAllAspectRatios):\n",
        "    def get_loop(self):\n",
        "        return SVGMobject(\"xmas_tree\").family_members_with_points()[0]\n",
        "\n",
        "    def get_aspect_ratio_pairs(self):\n",
        "        return [\n",
        "            (R\"\\sqrt{10} : 1\", math.sqrt(10)),\n",
        "            (R\"\\pi : \\sqrt{2}\", math.pi / math.sqrt(2)),\n",
        "            (\"17 : 10\", 17 / 10),\n",
        "            (R\"\\ln(2) : 1\", math.log(2)),\n",
        "            (\"14 : 3\", 14 / 3),\n",
        "            (R\"3\\sqrt{3} : 2\", 3 * math.sqrt(3) / 2),\n",
        "            (\"19 : 6\", 19 / 6),\n",
        "            (R\"e^2 : 10\", math.e ** 2 / 10),\n",
        "            (\"25 : 16\", 25 / 16),\n",
        "            (R\"\\varphi^2 : 2\", ((1 + math.sqrt(5)) / 2) ** 2 / 2),\n",
        "            (\"23 : 9\", 23 / 9),\n",
        "            (R\"\\sqrt{6} : 1\", math.sqrt(6)),\n",
        "            (\"18 : 5\", 18 / 5),\n",
        "            (R\"2\\pi : 3\", 2 * math.pi / 3),\n",
        "            (\"16 : 10\", 16 / 10),\n",
        "            (R\"\\sqrt{13} : 2\", math.sqrt(13) / 2),\n",
        "            (\"22 : 7\", 22 / 7),  # Common \u03c0 approximation ratio\n",
        "            (R\"e : \\sqrt{5}\", math.e / math.sqrt(5)),\n",
        "            (\"20 : 11\", 20 / 11),\n",
        "            (R\"\\ln(5) : 1\", math.log(5)),\n",
        "            (\"27 : 16\", 27 / 16),\n",
        "            (R\"3\\varphi : 4\", 3 * ((1 + math.sqrt(5)) / 2) / 4),\n",
        "            (\"24 : 11\", 24 / 11),\n",
        "            (R\"\\sqrt{15} : 2\", math.sqrt(15) / 2),\n",
        "            (\"21 : 13\", 21 / 13),\n",
        "            (R\"5\\pi : 8\", 5 * math.pi / 8),\n",
        "            (\"26 : 15\", 26 / 15),\n",
        "            (R\"\\sqrt{17} : 3\", math.sqrt(17) / 3),\n",
        "            (\"29 : 12\", 29 / 12),\n",
        "            (R\"e\\pi : 10\", math.e * math.pi / 10)\n",
        "        ]\n",
        "\n",
        "\n",
        "class AllAspectRatioPi(RectanglesOfAllAspectRatios):\n",
        "    def get_loop(self):\n",
        "        return Tex(R\"\\pi\").family_members_with_points()[0]\n",
        "\n",
        "\n",
        "class TrackTheAngle(ShowTheSurface):\n",
        "    initial_uv = [0.55, 0.75]\n",
        "    second_uv = [0.6, 0.66]\n",
        "    limiting_uv = [0.659, 0.66]\n",
        "\n",
        "    def construct(self):\n",
        "        # Initial setup\n",
        "        frame = self.frame\n",
        "        frame.set_height(6.5)\n",
        "        frame.set_x(1.5)\n",
        "        loop, pair_group = self.setup_loop()\n",
        "        uv_tracker, dots, connecting_line = pair_group\n",
        "        uv_tracker.set_value(self.initial_uv)\n",
        "        pair_group.update()\n",
        "\n",
        "        self.remove(pair_group)\n",
        "\n",
        "        # Show smoothness\n",
        "        x_tracker = ValueTracker(0.5)\n",
        "        get_x = x_tracker.get_value\n",
        "        dx = 1e-3\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_stroke(TEAL, 4)\n",
        "        line.f_always.put_start_and_end_on(\n",
        "            lambda: loop.quick_point_from_proportion(get_x()),\n",
        "            lambda: loop.quick_point_from_proportion(get_x() + dx)\n",
        "        )\n",
        "        line.always.set_length(3)\n",
        "\n",
        "        self.add(line)\n",
        "        self.play(x_tracker.animate.set_value(0.9), run_time=10)\n",
        "\n",
        "        # Temp\n",
        "        x_tracker.set_value(0)\n",
        "        self.play(x_tracker.animate.set_value(0.99), run_time=25, rate_func=linear)\n",
        "\n",
        "        # Angle label\n",
        "        angle_label = self.get_angle_label(connecting_line)\n",
        "        theta_label = always_redraw(lambda: self.get_theta_label(connecting_line))\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(theta_label, suspend_mobject_updating=True),\n",
        "            VFadeIn(angle_label, suspend_mobject_updating=True),\n",
        "            FadeOut(line),\n",
        "            FadeIn(pair_group),\n",
        "            loop.animate.set_stroke(WHITE, 1, 0.5)\n",
        "        )\n",
        "\n",
        "        # Move points\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value(self.second_uv),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            uv_tracker.animate.set_value(self.limiting_uv),\n",
        "            run_time=15,\n",
        "            rate_func=bezier([0, 0, 1, 1, 1, 1, 1, 1, 1]),\n",
        "        )\n",
        "\n",
        "    def setup_loop(self):\n",
        "        # Setup (fairly heavily copied from above)\n",
        "        axes, plane = self.get_axes_and_plane()\n",
        "        plane.fade(0.5)\n",
        "        self.add(plane)\n",
        "\n",
        "        loop = self.get_loop()\n",
        "        loop.set_height(5.5).center()\n",
        "        loop_func = loop.quick_point_from_proportion\n",
        "        self.add(loop)\n",
        "\n",
        "        uv_tracker = ValueTracker([0, 0.5])\n",
        "        dots = self.get_movable_pair(uv_tracker, loop_func, radius=0.075)\n",
        "        connecting_line = self.get_connecting_line(dots)\n",
        "        connecting_line.always.set_length(20)\n",
        "        pair_group = Group(uv_tracker, dots, connecting_line)\n",
        "        pair_group.update()\n",
        "\n",
        "        self.add(pair_group)\n",
        "\n",
        "        return loop, pair_group\n",
        "\n",
        "    def get_loop(self):\n",
        "        return get_example_loop(4)\n",
        "\n",
        "    def get_angle_label(self, line):\n",
        "        label = Tex(R\"\\theta = 100.0^\\circ\")\n",
        "        label.next_to(self.frame.get_corner(UR), DL)\n",
        "        angle = label.make_number_changeable(\"100.0\", edge_to_fix=RIGHT)\n",
        "        angle.f_always.set_value(lambda: (line.get_angle() % PI) / DEG)\n",
        "        return label\n",
        "\n",
        "    def get_theta_label(self, line):\n",
        "        h_line = Line(ORIGIN, RIGHT)\n",
        "        line_center = line.get_center()\n",
        "        h_line.move_to(line_center, LEFT)\n",
        "        angle = line.get_angle() % PI\n",
        "        arc = Arc(0, angle, radius=0.25, arc_center=line_center)\n",
        "        theta = Tex(R\"\\theta\", font_size=36)\n",
        "        try:\n",
        "            arc_center = arc.pfp(0.5)\n",
        "        except Exception:\n",
        "            arc_center = arc.get_center()\n",
        "        theta.move_to(arc_center + 0.8 * (arc_center - line_center))\n",
        "        return VGroup(h_line, arc, theta)\n",
        "\n",
        "\n",
        "class TrackTheAngleForFractal(TrackTheAngle):\n",
        "    def get_loop(self, n_iters=7):\n",
        "        triangle = Triangle()\n",
        "        triangle.set_height(4)\n",
        "        a, b, c = triangle.get_vertices()\n",
        "        snowflake = VMobject().set_points_as_corners(np.vstack([\n",
        "            self.get_koch_line_points(a, c, n_iters),\n",
        "            self.get_koch_line_points(c, b, n_iters),\n",
        "            self.get_koch_line_points(b, a, n_iters),\n",
        "        ]))\n",
        "        snowflake.set_stroke(WHITE, 1)\n",
        "\n",
        "        return snowflake\n",
        "\n",
        "    def get_koch_line_points(self, start, end, n_iters=7):\n",
        "        \"\"\"\n",
        "        Return points for a Koch snowflake portion,\n",
        "        not including the end\n",
        "        \"\"\"\n",
        "        a, b, c, d = np.linspace(start, end, 4)\n",
        "        tip = b + rotate_vector(c - b, 60 * DEG)\n",
        "        if n_iters == 0:\n",
        "            return np.array([a, b, tip, c])\n",
        "        return np.vstack([\n",
        "            self.get_koch_line_points(a, b, n_iters - 1),\n",
        "            self.get_koch_line_points(b, tip, n_iters - 1),\n",
        "            self.get_koch_line_points(tip, c, n_iters - 1),\n",
        "            self.get_koch_line_points(c, d, n_iters - 1),\n",
        "        ])\n",
        "\n",
        "\n",
        "class KochZoom(TrackTheAngleForFractal):\n",
        "    def construct(self):\n",
        "        snowflake = self.get_loop(9)\n",
        "        self.add(snowflake)\n",
        "        self.play(\n",
        "            self.frame.animate.reorient(0, 0, 0, (-1.12, 1.0, 0.0), 0.23),\n",
        "            rate_func=bezier([0, 0, 1, 1, 1, 1, 1, 1]),\n",
        "            run_time=10\n",
        "        )\n",
        "\n",
        "\n",
        "class MobiusStripsAndKleinBottlesIn4D(ConstructKleinBottle):\n",
        "    def construct(self):\n",
        "        # Add surfaces\n",
        "        four_d = Text(\"A certain\\n4D space\")\n",
        "        cloud = ThoughtBubble(four_d, bulge_radius=0.15)[0][-1]\n",
        "        cloud.add(four_d)\n",
        "        cloud.set_width(4)\n",
        "        cloud.to_edge(RIGHT).shift(2 * DOWN)\n",
        "        self.add(cloud)\n",
        "\n",
        "        strip = ParametricSurface(mobius_strip_func)\n",
        "        strip.rotate(45 * DEG, LEFT)\n",
        "        strip.set_width(3)\n",
        "\n",
        "        bottle = ParametricSurface(self.get_kelin_bottle_func())\n",
        "        bottle.rotate(30 * DEG, LEFT)\n",
        "        bottle.set_height(3)\n",
        "        bottle.always_sort_to_camera(self.camera)\n",
        "\n",
        "        surfaces = Group(strip, bottle)\n",
        "        surfaces.arrange(RIGHT, buff=1.0)\n",
        "        surfaces.set_width(5)\n",
        "        surfaces.to_corner(UR)\n",
        "\n",
        "        for surface in surfaces:\n",
        "            surface.set_color(BLUE_D, 0.5)\n",
        "            surface.set_shading(0.4, 0.3, 0)\n",
        "            mesh = SurfaceMesh(surface, resolution=(11, 51))\n",
        "            mesh.set_stroke(WHITE, 0.5, 0.2)\n",
        "            mesh.deactivate_depth_test()\n",
        "\n",
        "            arrow = Arrow(surface, cloud.get_top(), thickness=5)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(surface),\n",
        "                Write(mesh, stroke_width=0.5, run_time=2),\n",
        "                GrowArrow(arrow),\n",
        "            )\n",
        "\n",
        "\n",
        "class MusicalIntervalsAsPairs(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add piano\n",
        "        piano = Piano()[:39]\n",
        "        piano.center()\n",
        "        piano.set_width(FRAME_WIDTH)\n",
        "        piano.set_shading(0.2, 0.1, 0)\n",
        "\n",
        "        keys = piano[15:27]\n",
        "        key_labels = VGroup(map(Tex, [\n",
        "            R\"C\",\n",
        "            R\"C^{\\#}\",\n",
        "            R\"D\",\n",
        "            R\"D^{\\#}\",\n",
        "            R\"E\",\n",
        "            R\"F\",\n",
        "            R\"F^{\\#}\",\n",
        "            R\"G\",\n",
        "            R\"G^{\\#}\",\n",
        "            R\"A\",\n",
        "            R\"A^{\\#}\",\n",
        "            R\"B\",\n",
        "        ]))\n",
        "        key_labels.scale(0.6)\n",
        "        key_labels.set_stroke(WHITE, 1)\n",
        "        for key, label in zip(keys, key_labels):\n",
        "            label.next_to(key.get_bottom(), UP, buff=0.1)\n",
        "\n",
        "        self.add(piano)\n",
        "\n",
        "        # Highlight random key pairs\n",
        "        random.seed(0)\n",
        "        indices = list(range(12))\n",
        "        keys.save_state()\n",
        "        for _ in range(24):\n",
        "            i, j = random.sample(indices, 2)\n",
        "            keys[i].set_color(TEAL)\n",
        "            keys[j].set_color(TEAL)\n",
        "            self.add(key_labels[i])\n",
        "            self.add(key_labels[j])\n",
        "            self.wait(0.5)\n",
        "            # self.play_notes(i, j, 0.5)  # Only used for screen recording\n",
        "            self.remove(key_labels)\n",
        "            keys.restore()\n",
        "\n",
        "        # Show the circle\n",
        "        circle = Circle(radius=3)\n",
        "        circle.set_stroke(WHITE, 3)\n",
        "        circle.flip(axis=UR)\n",
        "\n",
        "        key_labels.target = key_labels.generate_target()\n",
        "        dots = Group()\n",
        "        for label, alpha in zip(key_labels.target, np.arange(0, 1, 1 / 12)):\n",
        "            point = circle.pfp(alpha)\n",
        "            label.move_to(1.1 * point)\n",
        "            dots.add(GlowDot(point, color=TEAL, radius=0.3))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(piano[:15]),\n",
        "            keys.animate.set_opacity(0.5),\n",
        "            FadeOut(piano[27:]),\n",
        "            VFadeIn(key_labels),\n",
        "        )\n",
        "        self.remove(key_labels)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            LaggedStart(\n",
        "                (FadeTransform(Group(key), dot)\n",
        "                for key, dot in zip(keys, dots)),\n",
        "                lag_ratio=0.1,\n",
        "                group_type=Group,\n",
        "            ),\n",
        "            MoveToTarget(key_labels, lag_ratio=0.01),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Show the random connections again\n",
        "        random.seed(0)\n",
        "        line = Line().set_stroke(TEAL, 3)\n",
        "        self.add(line)\n",
        "\n",
        "        for _ in range(24):\n",
        "            i, j = random.sample(indices, 2)\n",
        "            line.put_start_and_end_on(\n",
        "                dots[i].get_center(),\n",
        "                dots[j].get_center(),\n",
        "            )\n",
        "            self.wait(1 / 3)\n",
        "\n",
        "    def play_notes(self, i, j, duration=0.5, sample_rate=44100):\n",
        "        \"\"\"\n",
        "        Play two notes simultaneously, specified as half steps above middle C.\n",
        "\n",
        "        Parameters:\n",
        "        i (int): Half steps above middle C for first note\n",
        "        j (int): Half steps above middle C for second note\n",
        "        duration (float): Length of time to play in seconds\n",
        "        sample_rate (int): Number of samples per second\n",
        "        \"\"\"\n",
        "        import sounddevice as sd\n",
        "        # Middle C is 261.63 Hz\n",
        "        base_freq = 261.63\n",
        "\n",
        "        # Calculate frequencies using equal temperament formula\n",
        "        freq1 = base_freq * (2 ** (i / 12))\n",
        "        freq2 = base_freq * (2 ** (j / 12))\n",
        "\n",
        "        # Generate time array\n",
        "        t = np.linspace(0, duration, int(sample_rate * duration), False)\n",
        "\n",
        "        # Generate sine waves for each note\n",
        "        note1 = np.sin(2 * np.pi * freq1 * t)\n",
        "        note2 = np.sin(2 * np.pi * freq2 * t)\n",
        "\n",
        "        # Combine notes and normalize\n",
        "        combined = (note1 + note2) / 2\n",
        "\n",
        "        # Play the sound\n",
        "        sd.play(combined, sample_rate)\n",
        "        sd.wait()  # Wait until the sound has finished playing\n"
    ]
}