{
    "topic": "demonstrates the concept of a cycloid, which is a curve that is created by",
    "code": [
        "from manim_imports_ext import *\n",
        "from from_3b1b.old.brachistochrone.curves import *\n",
        "\n",
        "class RollAlongVector(Animation):\n",
        "    CONFIG = {\n",
        "        \"rotation_vector\" : OUT,\n",
        "    }\n",
        "    def __init__(self, mobject, vector, **kwargs):\n",
        "        radius = mobject.get_width()/2\n",
        "        radians = get_norm(vector)/radius\n",
        "        last_alpha = 0\n",
        "        digest_config(self, kwargs, locals())\n",
        "        Animation.__init__(self, mobject, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        d_alpha = alpha - self.last_alpha\n",
        "        self.last_alpha = alpha\n",
        "        self.mobject.rotate(\n",
        "            d_alpha*self.radians, \n",
        "            self.rotation_vector\n",
        "        )\n",
        "        self.mobject.shift(d_alpha*self.vector)\n",
        "\n",
        "\n",
        "class CycloidScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"point_a\"   : 6*LEFT+3*UP,\n",
        "        \"radius\"    : 2,\n",
        "        \"end_theta\" : 2*np.pi\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.generate_cycloid()\n",
        "        self.generate_circle()\n",
        "        self.generate_ceiling()\n",
        "\n",
        "    def grow_parts(self):\n",
        "        self.play(*[\n",
        "            ShowCreation(mob)\n",
        "            for mob in (self.circle, self.ceiling)\n",
        "        ])\n",
        "\n",
        "    def generate_cycloid(self):\n",
        "        self.cycloid = Cycloid(\n",
        "            point_a = self.point_a,\n",
        "            radius = self.radius,\n",
        "            end_theta = self.end_theta\n",
        "        )\n",
        "\n",
        "    def generate_circle(self, **kwargs):\n",
        "        self.circle = Circle(radius = self.radius, **kwargs)\n",
        "        self.circle.shift(self.point_a - self.circle.get_top())\n",
        "        radial_line = Line(\n",
        "            self.circle.get_center(), self.point_a\n",
        "        )\n",
        "        self.circle.add(radial_line)\n",
        "\n",
        "    def generate_ceiling(self):\n",
        "        self.ceiling = Line(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "        self.ceiling.shift(self.cycloid.get_top()[1]*UP)\n",
        "\n",
        "    def draw_cycloid(self, run_time = 3, *anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        self.play(\n",
        "            RollAlongVector(\n",
        "                self.circle,\n",
        "                self.cycloid.get_points()[-1]-self.cycloid.get_points()[0],\n",
        "                **kwargs\n",
        "            ),\n",
        "            ShowCreation(self.cycloid, **kwargs),\n",
        "            *anims\n",
        "        )\n",
        "\n",
        "    def roll_back(self, run_time = 3, *anims, **kwargs):\n",
        "        kwargs[\"run_time\"] = run_time\n",
        "        self.play(\n",
        "            RollAlongVector(\n",
        "                self.circle,\n",
        "                self.cycloid.get_points()[0]-self.cycloid.get_points()[- 1],\n",
        "                rotation_vector = IN,\n",
        "                **kwargs\n",
        "            ),\n",
        "            ShowCreation(\n",
        "                self.cycloid, \n",
        "                rate_func = lambda t : smooth(1-t),\n",
        "                **kwargs\n",
        "            ),\n",
        "            *anims\n",
        "        )\n",
        "        self.generate_cycloid()\n",
        "\n",
        "\n",
        "class IntroduceCycloid(CycloidScene):\n",
        "    def construct(self):\n",
        "        CycloidScene.construct(self)\n",
        "\n",
        "        equation = OldTex([\n",
        "            \"\\\\dfrac{\\\\sin(\\\\theta)}{\\\\sqrt{y}}\",\n",
        "            \"= \\\\text{constant}\"\n",
        "        ])\n",
        "        sin_sqrt, const = equation.split()\n",
        "        new_eq = equation.copy()\n",
        "        new_eq.to_edge(UP, buff = 1.3)\n",
        "        cycloid_word = OldTexText(\"Cycloid\")\n",
        "        arrow = Arrow(2*UP, cycloid_word)\n",
        "        arrow.reverse_points()\n",
        "        q_mark = OldTexText(\"?\")\n",
        "\n",
        "        self.play(*list(map(ShimmerIn, equation.split())))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(equation.shift, 2.2*UP),\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        q_mark.next_to(sin_sqrt)\n",
        "        self.play(ShimmerIn(cycloid_word))\n",
        "        self.wait()\n",
        "        self.grow_parts()\n",
        "        self.draw_cycloid()\n",
        "        self.wait()\n",
        "        extra_terms = [const, arrow, cycloid_word]\n",
        "        self.play(*[\n",
        "            Transform(mob, q_mark)\n",
        "            for mob in extra_terms\n",
        "        ])\n",
        "        self.remove(*extra_terms)\n",
        "        self.roll_back()\n",
        "        q_marks, arrows = self.get_q_marks_and_arrows(sin_sqrt)\n",
        "        self.draw_cycloid(3, \n",
        "            ShowCreation(q_marks),\n",
        "            ShowCreation(arrows)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_q_marks_and_arrows(self, mob, n_marks = 10):\n",
        "        circle = Circle().replace(mob)\n",
        "        q_marks, arrows = result = [Mobject(), Mobject()]\n",
        "        for x in range(n_marks):\n",
        "            index = (x+0.5)*self.cycloid.get_num_points()/n_marks\n",
        "            q_point = self.cycloid.get_points()[index]\n",
        "            vect = q_point-mob.get_center()\n",
        "            start_point = circle.get_boundary_point(vect)\n",
        "            arrow = Arrow(\n",
        "                start_point, q_point,\n",
        "                color = BLUE_E\n",
        "            )\n",
        "\n",
        "            q_marks.add(OldTexText(\"?\").shift(q_point))\n",
        "            arrows.add(arrow)\n",
        "        for mob in result:\n",
        "            mob.ingest_submobjects()\n",
        "        return result\n",
        "\n",
        "\n",
        "class LeviSolution(CycloidScene):\n",
        "    CONFIG = {\n",
        "        \"cycloid_fraction\" : 0.25,\n",
        "    }\n",
        "    def construct(self):\n",
        "        CycloidScene.construct(self)\n",
        "        self.add(self.ceiling)\n",
        "        self.init_points()\n",
        "        methods = [\n",
        "            self.draw_cycloid,\n",
        "            self.roll_into_position,\n",
        "            self.draw_p_and_c,\n",
        "            self.show_pendulum,\n",
        "            self.show_diameter,\n",
        "            self.show_theta,\n",
        "            self.show_similar_triangles,\n",
        "            self.show_sin_thetas,\n",
        "            self.show_y,\n",
        "            self.rearrange,\n",
        "        ]\n",
        "        for method in methods:\n",
        "            method()\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "    def init_points(self):\n",
        "        index = int(self.cycloid_fraction*self.cycloid.get_num_points())\n",
        "        p_point = self.cycloid.get_points()[index]\n",
        "        p_dot = Dot(p_point)\n",
        "        p_label = OldTex(\"P\")\n",
        "        p_label.next_to(p_dot, DOWN+LEFT)\n",
        "        c_point = self.point_a + self.cycloid_fraction*self.radius*2*np.pi*RIGHT\n",
        "        c_dot = Dot(c_point)\n",
        "        c_label = OldTex(\"C\")\n",
        "        c_label.next_to(c_dot, UP)\n",
        "\n",
        "        digest_locals(self)\n",
        "\n",
        "    def roll_into_position(self):\n",
        "        self.play(RollAlongVector(\n",
        "            self.circle,\n",
        "            (1-self.cycloid_fraction)*self.radius*2*np.pi*LEFT,\n",
        "            rotation_vector = IN,\n",
        "            run_time = 2\n",
        "        ))\n",
        "\n",
        "    def draw_p_and_c(self):\n",
        "        radial_line = self.circle.submobjects[0] ##Hacky\n",
        "        self.play(Transform(radial_line, self.p_dot))\n",
        "        self.remove(radial_line)\n",
        "        self.add(self.p_dot)\n",
        "        self.play(ShimmerIn(self.p_label))\n",
        "        self.wait()\n",
        "        self.play(Transform(self.ceiling.copy(), self.c_dot))\n",
        "        self.play(ShimmerIn(self.c_label))\n",
        "\n",
        "    def show_pendulum(self, arc_angle = np.pi, arc_color = GREEN):\n",
        "        words = OldTexText(\": Instantaneous center of rotation\")\n",
        "        words.next_to(self.c_label)\n",
        "        line = Line(self.p_point, self.c_point)\n",
        "        line_angle = line.get_angle()+np.pi\n",
        "        line_length = line.get_length()\n",
        "        line.add(self.p_dot.copy())\n",
        "        line.get_center = lambda : self.c_point\n",
        "        tangent_line = Line(3*LEFT, 3*RIGHT)\n",
        "        tangent_line.rotate(line_angle-np.pi/2)\n",
        "        tangent_line.shift(self.p_point)\n",
        "        tangent_line.set_color(arc_color)\n",
        "        right_angle_symbol = Mobject(\n",
        "            Line(UP, UP+RIGHT),\n",
        "            Line(UP+RIGHT, RIGHT)\n",
        "        )\n",
        "        right_angle_symbol.scale(0.3)\n",
        "        right_angle_symbol.rotate(tangent_line.get_angle()+np.pi)\n",
        "        right_angle_symbol.shift(self.p_point)\n",
        "\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "        pairs = [    \n",
        "            (line_angle, arc_angle/2),\n",
        "            (line_angle+arc_angle/2, -arc_angle),\n",
        "            (line_angle-arc_angle/2, arc_angle/2),\n",
        "        ]\n",
        "        arcs = []\n",
        "        for start, angle in pairs:\n",
        "            arc = Arc(\n",
        "                angle = angle,\n",
        "                radius = line_length,\n",
        "                start_angle = start,\n",
        "                color = GREEN\n",
        "            )\n",
        "            arc.shift(self.c_point)\n",
        "            self.play(\n",
        "                ShowCreation(arc),\n",
        "                ApplyMethod(\n",
        "                    line.rotate, \n",
        "                    angle,\n",
        "                    path_func = path_along_arc(angle)\n",
        "                ),\n",
        "                run_time = 2\n",
        "            )\n",
        "            arcs.append(arc)\n",
        "        self.wait()\n",
        "        self.play(Transform(arcs[1], tangent_line))\n",
        "        self.add(tangent_line)\n",
        "        self.play(ShowCreation(right_angle_symbol))\n",
        "        self.wait()\n",
        "\n",
        "        self.tangent_line = tangent_line\n",
        "        self.right_angle_symbol = right_angle_symbol\n",
        "        self.pc_line = line\n",
        "        self.remove(words, *arcs)\n",
        "\n",
        "    def show_diameter(self):\n",
        "        exceptions = [\n",
        "            self.circle, \n",
        "            self.tangent_line,\n",
        "            self.pc_line,\n",
        "            self.right_angle_symbol\n",
        "        ]\n",
        "        everything = set(self.mobjects).difference(exceptions)\n",
        "        everything_copy = Mobject(*everything).copy()\n",
        "        light_everything = everything_copy.copy()\n",
        "        dark_everything = everything_copy.copy()\n",
        "        dark_everything.fade(0.8)\n",
        "        bottom_point = np.array(self.c_point)\n",
        "        bottom_point += 2*self.radius*DOWN\n",
        "        diameter = Line(bottom_point, self.c_point)\n",
        "        brace = Brace(diameter, RIGHT)\n",
        "        diameter_word = OldTexText(\"Diameter\")\n",
        "        d_mob = OldTex(\"D\")\n",
        "        diameter_word.next_to(brace)\n",
        "        d_mob.next_to(diameter)\n",
        "\n",
        "        self.remove(*everything)\n",
        "        self.play(Transform(everything_copy, dark_everything))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(diameter))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(ShimmerIn(diameter_word))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(mob, d_mob)\n",
        "            for mob in (brace, diameter_word)\n",
        "        ])\n",
        "        self.remove(brace, diameter_word)\n",
        "        self.add(d_mob)\n",
        "        self.play(Transform(everything_copy, light_everything))\n",
        "        self.remove(everything_copy)\n",
        "        self.add(*everything)\n",
        "\n",
        "        self.d_mob = d_mob\n",
        "        self.bottom_point = bottom_point        \n",
        "\n",
        "    def show_theta(self, radius = 1):\n",
        "        arc = Arc(\n",
        "            angle = self.tangent_line.get_angle()-np.pi/2,\n",
        "            radius = radius,\n",
        "            start_angle = np.pi/2\n",
        "        )\n",
        "\n",
        "        theta = OldTex(\"\\\\theta\")\n",
        "        theta.shift(1.5*arc.get_center())\n",
        "        Mobject(arc, theta).shift(self.bottom_point)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            ShimmerIn(theta)\n",
        "        )\n",
        "        self.arc = arc \n",
        "        self.theta = theta\n",
        "\n",
        "    def show_similar_triangles(self):\n",
        "        y_point = np.array(self.p_point)\n",
        "        y_point[1] = self.point_a[1]\n",
        "        new_arc = Arc(\n",
        "            angle = self.tangent_line.get_angle()-np.pi/2,\n",
        "            radius = 0.5,\n",
        "            start_angle = np.pi\n",
        "        )\n",
        "        new_arc.shift(self.c_point)\n",
        "        new_theta = self.theta.copy()\n",
        "        new_theta.next_to(new_arc, LEFT)\n",
        "        new_theta.shift(0.1*DOWN)\n",
        "        kwargs = {\n",
        "            \"stroke_width\" : 2*DEFAULT_STROKE_WIDTH,\n",
        "        }\n",
        "        triangle1 = Polygon(\n",
        "            self.p_point, self.c_point, self.bottom_point,\n",
        "            color = MAROON,\n",
        "            **kwargs\n",
        "        )\n",
        "        triangle2 = Polygon(\n",
        "            y_point, self.p_point, self.c_point,\n",
        "            color = WHITE,\n",
        "            **kwargs\n",
        "        )\n",
        "        y_line = Line(self.p_point, y_point)\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.arc.copy(), new_arc),\n",
        "            Transform(self.theta.copy(), new_theta),\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(triangle1))\n",
        "        self.wait()\n",
        "        self.play(Transform(triangle1, triangle2))\n",
        "        self.play(ApplyMethod(triangle1.set_color, MAROON))\n",
        "        self.wait()\n",
        "        self.remove(triangle1)\n",
        "        self.add(y_line)\n",
        "\n",
        "        self.y_line = y_line\n",
        "\n",
        "    def show_sin_thetas(self):\n",
        "        pc = Line(self.p_point, self.c_point)\n",
        "        mob = Mobject(self.theta, self.d_mob).copy()\n",
        "        mob.ingest_submobjects()\n",
        "        triplets = [\n",
        "            (pc, \"D\\\\sin(\\\\theta)\", 0.5),\n",
        "            (self.y_line, \"D\\\\sin^2(\\\\theta)\", 0.7),\n",
        "        ]\n",
        "        for line, tex, scale in triplets:\n",
        "            trig_mob = OldTex(tex)\n",
        "            trig_mob.set_width(\n",
        "                scale*line.get_length()\n",
        "            )\n",
        "            trig_mob.shift(-1.2*trig_mob.get_top())\n",
        "            trig_mob.rotate(line.get_angle())\n",
        "            trig_mob.shift(line.get_center())\n",
        "            if line is self.y_line:\n",
        "                trig_mob.shift(0.1*UP) \n",
        "\n",
        "            self.play(Transform(mob, trig_mob))\n",
        "            self.add(trig_mob)\n",
        "            self.wait()\n",
        "\n",
        "        self.remove(mob)\n",
        "        self.d_sin_squared_theta = trig_mob\n",
        "\n",
        "\n",
        "    def show_y(self):\n",
        "        y_equals = OldTex([\"y\", \"=\"])\n",
        "        y_equals.shift(2*UP)\n",
        "        y_expression = OldTex([\n",
        "            \"D \", \"\\\\sin\", \"^2\", \"(\\\\theta)\"\n",
        "        ])\n",
        "        y_expression.next_to(y_equals)\n",
        "        y_expression.shift(0.05*UP+0.1*RIGHT)\n",
        "        temp_expr = self.d_sin_squared_theta.copy()\n",
        "        temp_expr.rotate(-np.pi/2)\n",
        "        temp_expr.replace(y_expression)\n",
        "        y_mob = OldTex(\"y\")\n",
        "        y_mob.next_to(self.y_line, RIGHT)\n",
        "        y_mob.shift(0.2*UP)\n",
        "\n",
        "        self.play(\n",
        "            Transform(self.d_sin_squared_theta, temp_expr),\n",
        "            ShimmerIn(y_mob),\n",
        "            ShowCreation(y_equals)\n",
        "        )\n",
        "        self.remove(self.d_sin_squared_theta)\n",
        "        self.add(y_expression)\n",
        "\n",
        "        self.y_equals = y_equals\n",
        "        self.y_expression = y_expression\n",
        "\n",
        "    def rearrange(self):\n",
        "        sqrt_nudge = 0.2*LEFT        \n",
        "        y, equals = self.y_equals.split()\n",
        "        d, sin, squared, theta = self.y_expression.split()\n",
        "        y_sqrt = OldTex(\"\\\\sqrt{\\\\phantom{y}}\")\n",
        "        d_sqrt = y_sqrt.copy()\n",
        "        y_sqrt.shift(y.get_center()+sqrt_nudge)\n",
        "        d_sqrt.shift(d.get_center()+sqrt_nudge)\n",
        "\n",
        "        self.play(\n",
        "            ShimmerIn(y_sqrt),\n",
        "            ShimmerIn(d_sqrt),\n",
        "            ApplyMethod(squared.shift, 4*UP),\n",
        "            ApplyMethod(theta.shift, 1.5* squared.get_width()*LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        y_sqrt.add(y)\n",
        "        d_sqrt.add(d)\n",
        "        sin.add(theta)\n",
        "\n",
        "        sin_over = OldTex(\"\\\\dfrac{\\\\phantom{\\\\sin(\\\\theta)}}{\\\\quad}\")\n",
        "        sin_over.next_to(sin, DOWN, 0.15)\n",
        "        new_eq = equals.copy()\n",
        "        new_eq.next_to(sin_over, LEFT)\n",
        "        one_over = OldTex(\"\\\\dfrac{1}{\\\\quad}\")\n",
        "        one_over.next_to(new_eq, LEFT)\n",
        "        one_over.shift(\n",
        "            (sin_over.get_bottom()[1]-one_over.get_bottom()[1])*UP\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            Transform(equals, new_eq),\n",
        "            ShimmerIn(sin_over),\n",
        "            ShimmerIn(one_over),\n",
        "            ApplyMethod(\n",
        "                d_sqrt.next_to, one_over, DOWN,\n",
        "                path_func = path_along_arc(-np.pi)\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                y_sqrt.next_to, sin_over, DOWN,\n",
        "                path_func = path_along_arc(-np.pi)\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        brace = Brace(d_sqrt, DOWN)\n",
        "        constant = OldTexText(\"Constant\")\n",
        "        constant.next_to(brace, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            ShimmerIn(constant)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class EquationsForCycloid(CycloidScene):\n",
        "    def construct(self):\n",
        "        CycloidScene.construct(self)\n",
        "        equations = OldTex([\n",
        "            \"x(t) = Rt - R\\\\sin(t)\",\n",
        "            \"y(t) = -R + R\\\\cos(t)\"\n",
        "        ])\n",
        "        top, bottom = equations.split()\n",
        "        bottom.next_to(top, DOWN)\n",
        "        equations.center()\n",
        "        equations.to_edge(UP, buff = 1.3)\n",
        "\n",
        "        self.play(ShimmerIn(equations))\n",
        "        self.grow_parts()\n",
        "        self.draw_cycloid(rate_func=linear, run_time = 5)\n",
        "        self.wait()\n",
        "\n",
        "class SlidingObject(CycloidScene, PathSlidingScene):\n",
        "    CONFIG = {\n",
        "        \"show_time\" : False,\n",
        "        \"wait_and_add\" : False\n",
        "    }\n",
        "\n",
        "    args_list = [(True,), (False,)]\n",
        "\n",
        "    @staticmethod\n",
        "    def args_to_string(with_words):\n",
        "        return \"WithWords\" if with_words else \"WithoutWords\"\n",
        "        \n",
        "    @staticmethod\n",
        "    def string_to_args(string):\n",
        "        return string == \"WithWords\"\n",
        "\n",
        "    def construct(self, with_words):\n",
        "        CycloidScene.construct(self)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.scale(RANDY_SCALE_FACTOR)\n",
        "        randy.shift(-randy.get_bottom())\n",
        "        central_randy = randy.copy()\n",
        "        start_randy = self.adjust_mobject_to_index(\n",
        "            randy.copy(), 1, self.cycloid.points\n",
        "        )\n",
        "\n",
        "        if with_words:\n",
        "            words1 = OldTexText(\"Trajectory due to gravity\")\n",
        "            arrow = OldTex(\"\\\\leftrightarrow\")\n",
        "            words2 = OldTexText(\"Trajectory due \\\\emph{constantly} rotating wheel\")\n",
        "            words1.next_to(arrow, LEFT)\n",
        "            words2.next_to(arrow, RIGHT)\n",
        "            words = Mobject(words1, arrow, words2)\n",
        "            words.set_width(FRAME_WIDTH-1)\n",
        "            words.to_edge(UP, buff = 0.2)\n",
        "            words.to_edge(LEFT)\n",
        "\n",
        "        self.play(ShowCreation(self.cycloid.copy()))\n",
        "        self.slide(randy, self.cycloid)\n",
        "        self.add(self.slider)\n",
        "        self.wait()\n",
        "        self.grow_parts()\n",
        "        self.draw_cycloid()\n",
        "        self.wait()\n",
        "        self.play(Transform(self.slider, start_randy))\n",
        "        self.wait()\n",
        "        self.roll_back()\n",
        "        self.wait()\n",
        "        if with_words:\n",
        "            self.play(*list(map(ShimmerIn, [words1, arrow, words2])))\n",
        "        self.wait()\n",
        "        self.remove(self.circle)\n",
        "        start_time = len(self.frames)*self.frame_duration\n",
        "        self.remove(self.slider)        \n",
        "        self.slide(central_randy, self.cycloid)\n",
        "        end_time = len(self.frames)*self.frame_duration\n",
        "        self.play_over_time_range(\n",
        "            start_time,\n",
        "            end_time,\n",
        "            RollAlongVector(\n",
        "                self.circle, \n",
        "                self.cycloid.get_points()[-1]-self.cycloid.get_points()[0],\n",
        "                run_time = end_time-start_time,\n",
        "                rate_func=linear\n",
        "            )\n",
        "        )\n",
        "        self.add(self.circle, self.slider)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class RotateWheel(CycloidScene):\n",
        "    def construct(self):\n",
        "        CycloidScene.construct(self)\n",
        "        self.circle.center()\n",
        "\n",
        "        self.play(Rotating(\n",
        "            self.circle,\n",
        "            axis = OUT,\n",
        "            run_time = 5,\n",
        "            rate_func = smooth\n",
        "        ))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}