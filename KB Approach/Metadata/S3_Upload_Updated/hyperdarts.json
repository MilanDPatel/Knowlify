{
    "topic": "demonstrates the concept of a hyperdart scene, which is a visualization of a d",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "OUTPUT_DIRECTORY = \"hyperdarts\"\n",
        "BROWN_PAPER = \"#958166\"\n",
        "\n",
        "\n",
        "class HyperdartScene(MovingCameraScene):\n",
        "    CONFIG = {\n",
        "        \"square_width\": 6,\n",
        "        \"square_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "            \"fill_color\": BLUE,\n",
        "            \"fill_opacity\": 0.5,\n",
        "        },\n",
        "        \"circle_style\": {\n",
        "            \"fill_color\": RED_E,\n",
        "            \"fill_opacity\": 1,\n",
        "            \"stroke_width\": 0,\n",
        "        },\n",
        "        \"circle_center_dot_radius\": 0.025,\n",
        "        \"default_line_style\": {\n",
        "            \"stroke_width\": 2,\n",
        "            \"stroke_color\": WHITE,\n",
        "        },\n",
        "        \"default_dot_config\": {\n",
        "            \"fill_color\": WHITE,\n",
        "            \"background_stroke_width\": 1,\n",
        "            \"background_stroke_color\": BLACK,\n",
        "            \"radius\": 0.5 * DEFAULT_DOT_RADIUS,\n",
        "        },\n",
        "        \"dart_sound\": \"dart_low\",\n",
        "        \"default_bullseye_shadow_opacity\": 0.35,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        MovingCameraScene.setup(self)\n",
        "        self.square = self.get_square()\n",
        "        self.circle = self.get_circle()\n",
        "        self.circle_center_dot = self.get_circle_center_dot()\n",
        "\n",
        "        self.add(self.square)\n",
        "        self.add(self.circle)\n",
        "        self.add(self.circle_center_dot)\n",
        "\n",
        "    def get_square(self):\n",
        "        return Square(\n",
        "            side_length=self.square_width,\n",
        "            **self.square_style\n",
        "        )\n",
        "\n",
        "    def get_circle(self, square=None):\n",
        "        square = square or self.square\n",
        "        circle = Circle(**self.circle_style)\n",
        "        circle.replace(square)\n",
        "        return circle\n",
        "\n",
        "    def get_circle_center_dot(self, circle=None):\n",
        "        circle = circle or self.circle\n",
        "        return Dot(\n",
        "            circle.get_center(),\n",
        "            radius=self.circle_center_dot_radius,\n",
        "            fill_color=BLACK,\n",
        "        )\n",
        "\n",
        "    def get_number_plane(self):\n",
        "        square = self.square\n",
        "        unit_size = square.get_width() / 2\n",
        "        plane = NumberPlane(\n",
        "            axis_config={\n",
        "                \"unit_size\": unit_size,\n",
        "            }\n",
        "        )\n",
        "        plane.add_coordinates()\n",
        "        plane.shift(square.get_center() - plane.c2p(0, 0))\n",
        "        return plane\n",
        "\n",
        "    def get_random_points(self, n):\n",
        "        square = self.square\n",
        "        points = np.random.uniform(-1, 1, 3 * n).reshape((n, 3))\n",
        "\n",
        "        points[:, 0] *= square.get_width() / 2\n",
        "        points[:, 1] *= square.get_height() / 2\n",
        "        points[:, 2] = 0\n",
        "        points += square.get_center()\n",
        "        return points\n",
        "\n",
        "    def get_random_point(self):\n",
        "        return self.get_random_points(1)[0]\n",
        "\n",
        "    def get_dot(self, point):\n",
        "        return Dot(point, **self.default_dot_config)\n",
        "\n",
        "    # Hit transform rules\n",
        "    def is_inside(self, point, circle=None):\n",
        "        circle = circle or self.circle\n",
        "        return get_norm(point - circle.get_center()) <= circle.get_width() / 2\n",
        "\n",
        "    def get_new_radius(self, point, circle=None):\n",
        "        circle = circle or self.circle\n",
        "        center = circle.get_center()\n",
        "        radius = circle.get_width() / 2\n",
        "        p_dist = get_norm(point - center)\n",
        "        return np.sqrt(radius**2 - p_dist**2)\n",
        "\n",
        "    def get_hit_distance_line(self, point, circle=None):\n",
        "        circle = circle or self.circle\n",
        "\n",
        "        line = Line(\n",
        "            circle.get_center(), point,\n",
        "            **self.default_line_style\n",
        "        )\n",
        "        return line\n",
        "\n",
        "    def get_chord(self, point, circle=None):\n",
        "        circle = circle or self.circle\n",
        "\n",
        "        center = circle.get_center()\n",
        "        p_angle = angle_of_vector(point - center)\n",
        "        chord = Line(DOWN, UP)\n",
        "        new_radius = self.get_new_radius(point, circle)\n",
        "        chord.scale(new_radius)\n",
        "        chord.rotate(p_angle)\n",
        "        chord.move_to(point)\n",
        "        chord.set_style(**self.default_line_style)\n",
        "        return chord\n",
        "\n",
        "    def get_radii_to_chord(self, chord, circle=None):\n",
        "        circle = circle or self.circle\n",
        "\n",
        "        center = circle.get_center()\n",
        "        radii = VGroup(*[\n",
        "            DashedLine(center, point)\n",
        "            for point in chord.get_start_and_end()\n",
        "        ])\n",
        "        radii.set_style(**self.default_line_style)\n",
        "        return radii\n",
        "\n",
        "    def get_all_hit_lines(self, point, circle=None):\n",
        "        h_line = self.get_hit_distance_line(point, circle)\n",
        "        chord = self.get_chord(point, circle)\n",
        "        # radii = self.get_radii_to_chord(chord, circle)\n",
        "\n",
        "        elbow = Elbow(width=0.15)\n",
        "        elbow.set_stroke(WHITE, 2)\n",
        "        elbow.rotate(h_line.get_angle() - PI, about_point=ORIGIN)\n",
        "        elbow.shift(point)\n",
        "\n",
        "        return VGroup(h_line, chord, elbow)\n",
        "\n",
        "    def get_dart(self, length=1.5):\n",
        "        dart = SVGMobject(file_name=\"dart\")\n",
        "        dart.rotate(135 * DEGREES)\n",
        "        dart.set_width(length)\n",
        "        dart.rotate(45 * DEGREES, UP)\n",
        "        dart.rotate(-10 * DEGREES)\n",
        "\n",
        "        dart.set_fill(GREY)\n",
        "        dart.set_sheen(2, UL)\n",
        "        dart.set_stroke(BLACK, 0.5, background=True)\n",
        "        dart.set_stroke(width=0)\n",
        "        return dart\n",
        "\n",
        "    # New circle\n",
        "    def get_new_circle_from_point(self, point, circle=None):\n",
        "        return self.get_new_circle(\n",
        "            self.get_new_radius(point, circle),\n",
        "            circle,\n",
        "        )\n",
        "\n",
        "    def get_new_circle_from_chord(self, chord, circle=None):\n",
        "        return self.get_new_circle(\n",
        "            chord.get_length() / 2,\n",
        "            circle,\n",
        "        )\n",
        "\n",
        "    def get_new_circle(self, new_radius, circle=None):\n",
        "        circle = circle or self.circle\n",
        "        new_circle = self.get_circle()\n",
        "        new_circle.set_width(2 * new_radius)\n",
        "        new_circle.move_to(circle)\n",
        "        return new_circle\n",
        "\n",
        "    # Sound\n",
        "    def add_dart_sound(self, time_offset=0, gain=-20, **kwargs):\n",
        "        self.add_sound(\n",
        "            self.dart_sound,\n",
        "            time_offset=time_offset,\n",
        "            gain=-20,\n",
        "            **kwargs,\n",
        "        )\n",
        "\n",
        "    # Animations\n",
        "    def show_full_hit_process(self, point, pace=\"slow\", with_dart=True):\n",
        "        assert(pace in [\"slow\", \"fast\"])\n",
        "\n",
        "        to_fade = VGroup()\n",
        "\n",
        "        if with_dart:\n",
        "            dart, dot = self.show_hit_with_dart(point)\n",
        "            to_fade.add(dart, dot)\n",
        "        else:\n",
        "            dot = self.show_hit(point)\n",
        "            to_fade.add(dot)\n",
        "\n",
        "        if pace == \"slow\":\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # TODO, automatically act based on hit or miss?\n",
        "\n",
        "        lines = self.show_geometry(point, pace)\n",
        "        chord_and_shadow = self.show_circle_shrink(lines[1], pace=pace)\n",
        "\n",
        "        to_fade.add_to_back(chord_and_shadow, lines)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            run_time=(1 if pace == \"slow\" else 0.5)\n",
        "        )\n",
        "\n",
        "    def show_hits_with_darts(self, points, run_time=0.5, added_anims=None):\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "\n",
        "        darts = VGroup(*[\n",
        "            self.get_dart().move_to(point, DR)\n",
        "            for point in points\n",
        "        ])\n",
        "        dots = VGroup(*[\n",
        "            self.get_dot(point)\n",
        "            for point in points\n",
        "        ])\n",
        "\n",
        "        for dart in darts:\n",
        "            dart.save_state()\n",
        "            dart.set_x(-(FRAME_WIDTH + dart.get_width()) / 2)\n",
        "            dart.rotate(20 * DEGREES)\n",
        "\n",
        "        n_points = len(points)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(\n",
        "                dots,\n",
        "                rate_func=squish_rate_func(linear, 0.5, 1),\n",
        "            ),\n",
        "            LaggedStart(*[\n",
        "                Restore(\n",
        "                    dart,\n",
        "                    path_arc=-20 * DEGREES,\n",
        "                    rate_func=linear,\n",
        "                    run_time=run_time,\n",
        "                )\n",
        "                for dart in darts\n",
        "            ], lag_ratio=(1 / n_points)),\n",
        "            *added_anims,\n",
        "            run_time=run_time\n",
        "        )\n",
        "        for n in range(n_points):\n",
        "            self.add_dart_sound(\n",
        "                time_offset=(-n / (2 * n_points))\n",
        "            )\n",
        "\n",
        "        return darts, dots\n",
        "\n",
        "    def show_hit_with_dart(self, point, run_time=0.25, **kwargs):\n",
        "        darts, dots = self.show_hits_with_darts([point], run_time, **kwargs)\n",
        "        return darts[0], dots[0]\n",
        "\n",
        "    def show_hit(self, point, pace=\"slow\", added_anims=None):\n",
        "        assert(pace in [\"slow\", \"fast\"])\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "\n",
        "        dot = self.get_dot(point)\n",
        "        if pace == \"slow\":\n",
        "            self.play(\n",
        "                FadeInFromLarge(dot, rate_func=rush_into),\n",
        "                *added_anims,\n",
        "                run_time=0.5,\n",
        "            )\n",
        "        elif pace == \"fast\":\n",
        "            self.add(dot)\n",
        "        # self.add_dart_sound()\n",
        "        return dot\n",
        "\n",
        "    def show_geometry(self, point, pace=\"slow\"):\n",
        "        assert(pace in [\"slow\", \"fast\"])\n",
        "\n",
        "        lines = self.get_all_hit_lines(point, self.circle)\n",
        "        h_line, chord, elbow = lines\n",
        "\n",
        "        # Note, note animating radii anymore...does that mess anything up?\n",
        "        if pace == \"slow\":\n",
        "            self.play(\n",
        "                ShowCreation(h_line),\n",
        "                GrowFromCenter(chord),\n",
        "            )\n",
        "            self.play(ShowCreation(elbow))\n",
        "        elif pace == \"fast\":\n",
        "            self.play(\n",
        "                ShowCreation(h_line),\n",
        "                GrowFromCenter(chord),\n",
        "                ShowCreation(elbow),\n",
        "                run_time=0.5\n",
        "            )\n",
        "        # return VGroup(h_line, chord)\n",
        "        return lines\n",
        "\n",
        "    def show_circle_shrink(self, chord, pace=\"slow\", shadow_opacity=None):\n",
        "        circle = self.circle\n",
        "        chord_copy = chord.copy()\n",
        "        new_circle = self.get_new_circle_from_chord(chord)\n",
        "        to_fade = VGroup(chord_copy)\n",
        "\n",
        "        if shadow_opacity is None:\n",
        "            shadow_opacity = self.default_bullseye_shadow_opacity\n",
        "        if shadow_opacity > 0:\n",
        "            shadow = circle.copy()\n",
        "            shadow.set_opacity(shadow_opacity)\n",
        "            to_fade.add_to_back(shadow)\n",
        "            if circle in self.mobjects:\n",
        "                index = self.mobjects.index(circle)\n",
        "                self.mobjects.insert(index, shadow)\n",
        "            else:\n",
        "                self.add(shadow, self.circle_center_dot)\n",
        "\n",
        "        outline = VGroup(*[\n",
        "            VMobject().pointwise_become_partial(new_circle, a, b)\n",
        "            for (a, b) in [(0, 0.5), (0.5, 1)]\n",
        "        ])\n",
        "        outline.rotate(chord.get_angle())\n",
        "        outline.set_fill(opacity=0)\n",
        "        outline.set_stroke(YELLOW, 2)\n",
        "\n",
        "        assert(pace in [\"slow\", \"fast\"])\n",
        "\n",
        "        if pace == \"slow\":\n",
        "            self.play(\n",
        "                chord_copy.move_to, circle.get_center(),\n",
        "                circle.set_opacity, 0.5,\n",
        "            )\n",
        "            self.play(\n",
        "                Rotating(\n",
        "                    chord_copy,\n",
        "                    radians=PI,\n",
        "                ),\n",
        "                ShowCreation(\n",
        "                    outline,\n",
        "                    lag_ratio=0\n",
        "                ),\n",
        "                run_time=1,\n",
        "                rate_func=smooth,\n",
        "            )\n",
        "            self.play(\n",
        "                Transform(circle, new_circle),\n",
        "                FadeOut(outline),\n",
        "            )\n",
        "        elif pace == \"fast\":\n",
        "            outline = new_circle.copy()\n",
        "            outline.set_fill(opacity=0)\n",
        "            outline.set_stroke(YELLOW, 2)\n",
        "            outline.move_to(chord)\n",
        "            outline.generate_target()\n",
        "            outline.target.move_to(circle)\n",
        "            self.play(\n",
        "                chord_copy.move_to, circle,\n",
        "                Transform(circle, new_circle),\n",
        "                # MoveToTarget(\n",
        "                #     outline,\n",
        "                #     remover=True\n",
        "                # )\n",
        "            )\n",
        "            # circle.become(new_circle)\n",
        "            # circle.become(new_circle)\n",
        "            # self.remove(new_circle)\n",
        "        return to_fade\n",
        "\n",
        "    def show_miss(self, point, with_dart=True):\n",
        "        square = self.square\n",
        "        miss = OldTexText(\"Miss!\")\n",
        "        miss.next_to(point, UP)\n",
        "        to_fade = VGroup(miss)\n",
        "\n",
        "        if with_dart:\n",
        "            dart, dot = self.show_hit_with_dart(point)\n",
        "            to_fade.add(dart, dot)\n",
        "        else:\n",
        "            dot = self.show_hit(point)\n",
        "            to_fade.add(dot)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                square.set_color, YELLOW,\n",
        "                rate_func=lambda t: (1 - t),\n",
        "            ),\n",
        "            GrowFromCenter(miss),\n",
        "            run_time=0.25\n",
        "        )\n",
        "        return to_fade\n",
        "\n",
        "    def show_game_over(self):\n",
        "        game_over = OldTexText(\"GAME OVER\")\n",
        "        game_over.set_width(FRAME_WIDTH - 1)\n",
        "        rect = FullScreenFadeRectangle(opacity=0.25)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            FadeInFromLarge(game_over),\n",
        "        )\n",
        "        return VGroup(rect, game_over)\n",
        "\n",
        "\n",
        "# Scenes to overlay on Numerphile\n",
        "\n",
        "class TableOfContents(Scene):\n",
        "    def construct(self):\n",
        "        rect = FullScreenFadeRectangle(opacity=0.75)\n",
        "        self.add(rect)\n",
        "\n",
        "        parts = VGroup(\n",
        "            OldTexText(\"The game\"),\n",
        "            OldTexText(\"The puzzle\"),\n",
        "            OldTexText(\"The micropuzzles\"),\n",
        "            OldTexText(\"The answer\"),\n",
        "        )\n",
        "\n",
        "        parts.scale(1.5)\n",
        "        parts.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        parts.to_edge(LEFT, buff=2)\n",
        "\n",
        "        parts.set_opacity(0.5)\n",
        "        self.add(parts)\n",
        "\n",
        "        for part in parts:\n",
        "            dot = Dot()\n",
        "            dot.next_to(part, LEFT, SMALL_BUFF)\n",
        "            dot.match_style(part)\n",
        "            self.add(dot)\n",
        "\n",
        "        last_part = VMobject()\n",
        "        last_part.save_state()\n",
        "\n",
        "        for part in parts:\n",
        "            part.save_state()\n",
        "            self.play(\n",
        "                part.scale, 1.5, {\"about_edge\": LEFT},\n",
        "                part.set_opacity, 1,\n",
        "                Restore(last_part)\n",
        "            )\n",
        "            self.wait()\n",
        "            last_part = part\n",
        "\n",
        "\n",
        "class ShowGiantBullseye(HyperdartScene):\n",
        "    def construct(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "\n",
        "        self.remove(square, circle)\n",
        "        board = Dartboard()\n",
        "        board.replace(circle)\n",
        "        bullseye = board.bullseye\n",
        "        bullseye_border = bullseye.copy()\n",
        "        bullseye_border.set_fill(opacity=0)\n",
        "        bullseye_border.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.add(board)\n",
        "\n",
        "        # Label\n",
        "        label = OldTexText(\"``\", \"Bullseye\", \"''\")\n",
        "        label.scale(1.5)\n",
        "        label.next_to(square, LEFT, aligned_edge=UP)\n",
        "        label.set_color(RED)\n",
        "        arrow = Arrow(\n",
        "            label.get_bottom(),\n",
        "            bullseye.get_corner(DR)\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(label[1]),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.play(\n",
        "            bullseye.match_width, board,\n",
        "            ApplyMethod(\n",
        "                arrow.scale, 0.4,\n",
        "                {\"about_point\": arrow.get_start()}\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Write(label[::2]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowExampleHit(HyperdartScene):\n",
        "    def construct(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "        circle.set_fill(BROWN_PAPER, opacity=0.95)\n",
        "        old_board = VGroup(square, circle)\n",
        "        self.remove(square)\n",
        "\n",
        "        board = Dartboard()\n",
        "        board.replace(old_board)\n",
        "        self.add(board, circle)\n",
        "\n",
        "        # Show hit\n",
        "        point = 0.75 * UP\n",
        "        dart, dot = self.show_hit_with_dart(point)\n",
        "\n",
        "        # Draw lines (with labels)\n",
        "        lines = self.get_all_hit_lines(point)\n",
        "        h_line, chord, elbow = lines\n",
        "        h_label = OldTex(\"h\")\n",
        "        h_label.next_to(h_line, LEFT, SMALL_BUFF)\n",
        "\n",
        "        chord_word = OldTexText(\"Chord\")\n",
        "        chord_word.next_to(chord.get_center(), UR, SMALL_BUFF)\n",
        "\n",
        "        self.add(h_line, dot)\n",
        "        self.play(ShowCreation(h_line))\n",
        "        self.play(Write(h_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(chord),\n",
        "            ShowCreation(elbow),\n",
        "            Write(chord_word, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show shrinkage\n",
        "        chord_copy = chord.copy()\n",
        "        chord_copy.move_to(ORIGIN)\n",
        "        new_circle = circle.copy()\n",
        "        new_circle.set_fill(RED, 1)\n",
        "        new_circle.match_width(chord_copy)\n",
        "        new_circle.move_to(ORIGIN)\n",
        "\n",
        "        new_diam_word = OldTexText(\"New diameter\")\n",
        "        new_diam_word.next_to(chord_copy, DOWN, SMALL_BUFF)\n",
        "\n",
        "        outline = VGroup(\n",
        "            Arc(start_angle=0, angle=PI),\n",
        "            Arc(start_angle=PI, angle=PI),\n",
        "        )\n",
        "        outline.set_stroke(YELLOW, 3)\n",
        "        outline.set_fill(opacity=0)\n",
        "        outline.replace(new_circle)\n",
        "\n",
        "        self.play(\n",
        "            circle.set_color, GREY_D,\n",
        "            TransformFromCopy(chord, chord_copy),\n",
        "            FadeIn(new_diam_word, UP)\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(chord_copy, PI),\n",
        "            ShowCreation(outline, lag_ratio=0),\n",
        "        )\n",
        "        self.play()\n",
        "\n",
        "        # Show variable hit_point\n",
        "        self.remove(lines)\n",
        "        point_tracker = VectorizedPoint(point)\n",
        "        self.remove(lines, *lines)\n",
        "        lines = always_redraw(\n",
        "            lambda: self.get_all_hit_lines(point_tracker.get_location())\n",
        "        )\n",
        "        dot.add_updater(lambda m: m.move_to(point_tracker))\n",
        "        dart.add_updater(lambda m: m.move_to(point_tracker, DR))\n",
        "        chord_copy.add_updater(\n",
        "            lambda m: m.match_width(lines[1]).move_to(ORIGIN)\n",
        "        )\n",
        "        new_circle.add_updater(lambda m: m.match_width(chord_copy).move_to(ORIGIN))\n",
        "        h_label.add_updater(lambda m: m.next_to(lines[0], LEFT, SMALL_BUFF))\n",
        "\n",
        "        chord_word.add_updater(lambda m: m.next_to(lines[1].get_center(), UR, SMALL_BUFF))\n",
        "        ndw_width = new_diam_word.get_width()\n",
        "        new_diam_word.add_updater(\n",
        "            lambda m: m.set_width(\n",
        "                min(ndw_width, chord_copy.get_width())\n",
        "            ).next_to(chord_copy, DOWN, SMALL_BUFF)\n",
        "        )\n",
        "\n",
        "        self.add(new_circle, chord_copy, lines, h_label, dart, dot, chord_word, new_diam_word)\n",
        "        self.play(\n",
        "            FadeOut(outline),\n",
        "            FadeIn(new_circle)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            point_tracker.shift, 2.1 * UP,\n",
        "            run_time=9,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "        )\n",
        "\n",
        "\n",
        "class QuicklyAnimatedShrinking(HyperdartScene):\n",
        "    def construct(self):\n",
        "        # square = self.square\n",
        "        # circle = self.circle\n",
        "\n",
        "        for x in range(5):\n",
        "            point = self.get_random_point()\n",
        "            while not self.is_inside(point):\n",
        "                point = self.get_random_point()\n",
        "            self.show_full_hit_process(point, pace=\"fast\")\n",
        "        # self.show_game_over()\n",
        "\n",
        "\n",
        "class SimulateRealGame(HyperdartScene):\n",
        "    CONFIG = {\n",
        "        \"circle_style\": {\n",
        "            # \"fill_color\": BROWN_PAPER,\n",
        "        }\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        board = Dartboard()\n",
        "        board.set_opacity(0.5)\n",
        "        self.remove(self.square)\n",
        "        self.square.set_opacity(0)\n",
        "        self.add(board, self.circle)\n",
        "\n",
        "        points = [\n",
        "            0.5 * UP,\n",
        "            2.0 * UP,\n",
        "            1.9 * LEFT + 0.4 * DOWN,\n",
        "        ]\n",
        "\n",
        "        for point in points:\n",
        "            self.show_full_hit_process(point)\n",
        "        self.show_miss(1.8 * DL)\n",
        "        self.show_game_over()\n",
        "\n",
        "\n",
        "class GameOver(HyperdartScene):\n",
        "    def construct(self):\n",
        "        self.clear()\n",
        "        self.show_game_over()\n",
        "\n",
        "\n",
        "class SquareAroundTheDartBoard(HyperdartScene):\n",
        "    def construct(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "        VGroup(square, circle).to_edge(DOWN, MED_SMALL_BUFF)\n",
        "        self.clear()\n",
        "        board = Dartboard()\n",
        "        board.replace(square)\n",
        "\n",
        "        title = OldTexText(\"Square around the dart board\")\n",
        "        title.scale(1.5)\n",
        "        title.next_to(square, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(board)\n",
        "        self.play(FadeInFromDown(title))\n",
        "        self.add(square, board)\n",
        "        self.play(DrawBorderThenFill(square, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ContrastDistributions(HyperdartScene):\n",
        "    def construct(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "        board = Dartboard()\n",
        "        board.replace(circle)\n",
        "\n",
        "        group = VGroup(square, circle, board)\n",
        "        group.to_edge(LEFT)\n",
        "        group.scale(0.8, about_edge=DOWN)\n",
        "\n",
        "        group_copy = group.copy()\n",
        "        square_copy, circle_copy, board_copy = group_copy\n",
        "        group_copy.set_x(-group.get_center()[0])\n",
        "\n",
        "        v_line = DashedLine(FRAME_HEIGHT * UP / 2, FRAME_HEIGHT * DOWN / 2)\n",
        "\n",
        "        left_label = OldTexText(\"Our distribution\\\\\\\\(uniform in the square)\")\n",
        "        left_label.match_x(group)\n",
        "        left_label.to_edge(UP)\n",
        "        right_label = OldTexText(\"More realistic distribution\")\n",
        "        right_label.match_x(group_copy)\n",
        "        right_label.to_edge(UP)\n",
        "\n",
        "        n_points = 2000\n",
        "        left_points = self.get_random_points(n_points)\n",
        "        right_points = np.random.multivariate_normal(\n",
        "            mean=board_copy.get_center(),\n",
        "            cov=0.6 * np.identity(3),\n",
        "            size=n_points\n",
        "        )\n",
        "\n",
        "        left_dots, right_dots = [\n",
        "            VGroup(*[\n",
        "                Dot(p, radius=0.02) for p in points\n",
        "            ])\n",
        "            for points in [left_points, right_points]\n",
        "        ]\n",
        "\n",
        "        left_rect = FullScreenFadeRectangle(opacity=0.75)\n",
        "        left_rect.stretch(0.49, 0, about_edge=LEFT)\n",
        "        right_rect = left_rect.copy()\n",
        "        right_rect.to_edge(RIGHT, buff=0)\n",
        "\n",
        "        self.add(group, board_copy)\n",
        "        self.add(left_label, right_label)\n",
        "        self.add(v_line)\n",
        "        self.add(left_rect)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, right_dots),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(left_rect),\n",
        "            FadeIn(right_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, left_dots),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ChooseXThenYUniformly(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        unit_size = 3\n",
        "        axes = Axes(\n",
        "            x_min=-1.25,\n",
        "            x_max=1.25,\n",
        "            y_min=-1.25,\n",
        "            y_max=1.25,\n",
        "            axis_config={\n",
        "                \"tick_frequency\": 0.25,\n",
        "                \"unit_size\": unit_size,\n",
        "            },\n",
        "        )\n",
        "        numbers = [-1, -0.5, 0.5, 1]\n",
        "        num_config = {\n",
        "            \"num_decimal_places\": 1,\n",
        "            \"background_stroke_width\": 3,\n",
        "        }\n",
        "        axes.x_axis.add_numbers(\n",
        "            *numbers,\n",
        "            **num_config,\n",
        "        )\n",
        "        axes.y_axis.add_numbers(\n",
        "            *numbers,\n",
        "            **num_config,\n",
        "            direction=LEFT,\n",
        "        )\n",
        "\n",
        "        circle = Circle(radius=unit_size)\n",
        "        circle.set_stroke(WHITE, 0)\n",
        "        circle.set_fill(RED, 0.7)\n",
        "\n",
        "        square = Square()\n",
        "        square.replace(circle)\n",
        "        square.set_stroke(GREY_B, 1)\n",
        "        square = DashedVMobject(square, num_dashes=101)\n",
        "\n",
        "        self.add(square, circle)\n",
        "        self.add(axes)\n",
        "\n",
        "        # x and y stuff\n",
        "        x_tracker = ValueTracker(-1)\n",
        "        y_tracker = ValueTracker(-1)\n",
        "\n",
        "        get_x = x_tracker.get_value\n",
        "        get_y = y_tracker.get_value\n",
        "\n",
        "        x_tip = ArrowTip(start_angle=PI / 2, color=BLUE)\n",
        "        y_tip = ArrowTip(start_angle=0, color=YELLOW)\n",
        "        for tip in [x_tip, y_tip]:\n",
        "            tip.scale(0.5)\n",
        "        x_tip.add_updater(lambda m: m.move_to(axes.c2p(get_x(), 0), UP))\n",
        "        y_tip.add_updater(lambda m: m.move_to(axes.c2p(0, get_y()), RIGHT))\n",
        "\n",
        "        x_eq = VGroup(OldTex(\"x = \"), DecimalNumber(0))\n",
        "        x_eq.arrange(RIGHT, SMALL_BUFF)\n",
        "        x_eq[1].match_y(x_eq[0][0][1])\n",
        "        x_eq[1].add_updater(lambda m: m.set_value(get_x()))\n",
        "        x_eq.match_color(x_tip)\n",
        "\n",
        "        y_eq = VGroup(OldTex(\"y = \"), DecimalNumber(0))\n",
        "        y_eq.arrange(RIGHT, SMALL_BUFF)\n",
        "        y_eq[1].match_y(y_eq[0][0][1])\n",
        "        y_eq[1].add_updater(lambda m: m.set_value(get_y()))\n",
        "        y_eq.match_color(y_tip)\n",
        "\n",
        "        eqs = VGroup(x_eq, y_eq)\n",
        "        eqs.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        eqs.to_edge(UR)\n",
        "\n",
        "        self.add(x_tip)\n",
        "        self.add(x_eq)\n",
        "\n",
        "        # Choose x\n",
        "        self.play(\n",
        "            x_tracker.set_value, 1,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            x_tracker.set_value, np.random.random(),\n",
        "            run_time=1,\n",
        "        )\n",
        "\n",
        "        # Choose y\n",
        "        self.play(\n",
        "            FadeIn(y_tip),\n",
        "            FadeIn(y_eq),\n",
        "        )\n",
        "        self.play(\n",
        "            y_tracker.set_value, 1,\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            y_tracker.set_value, np.random.random(),\n",
        "            run_time=1,\n",
        "        )\n",
        "\n",
        "        point = axes.c2p(get_x(), get_y())\n",
        "        dot = Dot(point)\n",
        "        x_line = DashedLine(axes.c2p(0, get_y()), point)\n",
        "        y_line = DashedLine(axes.c2p(get_x(), 0), point)\n",
        "        lines = VGroup(x_line, y_line)\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(*map(ShowCreation, lines))\n",
        "        self.play(DrawBorderThenFill(dot))\n",
        "        self.wait()\n",
        "\n",
        "        points = [\n",
        "            axes.c2p(*np.random.uniform(-1, 1, size=2))\n",
        "            for n in range(2000)\n",
        "        ]\n",
        "        dots = VGroup(*[\n",
        "            Dot(point, radius=0.02)\n",
        "            for point in points\n",
        "        ])\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, dots),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowDistributionOfScores(Scene):\n",
        "    CONFIG = {\n",
        "        \"axes_config\": {\n",
        "            \"x_min\": -1,\n",
        "            \"x_max\": 10,\n",
        "            \"x_axis_config\": {\n",
        "                \"unit_size\": 1.2,\n",
        "                \"tick_frequency\": 1,\n",
        "            },\n",
        "            \"y_min\": 0,\n",
        "            \"y_max\": 100,\n",
        "            \"y_axis_config\": {\n",
        "                \"unit_size\": 0.065,\n",
        "                \"tick_frequency\": 10,\n",
        "                \"include_tip\": False,\n",
        "            },\n",
        "        },\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        # setup scores\n",
        "        n_scores = 10000\n",
        "        scores = np.array([self.get_random_score() for x in range(n_scores)])\n",
        "        index_tracker = ValueTracker(n_scores)\n",
        "\n",
        "        def get_index():\n",
        "            value = np.clip(index_tracker.get_value(), 0, n_scores - 1)\n",
        "            return int(value)\n",
        "\n",
        "        # Setup histogram\n",
        "        bars = self.get_histogram_bars(axes)\n",
        "        bars.add_updater(\n",
        "            lambda b: self.set_histogram_bars(\n",
        "                b, scores[:get_index()], axes\n",
        "            )\n",
        "        )\n",
        "        self.add(bars)\n",
        "\n",
        "        # Add score label\n",
        "        score_label = VGroup(\n",
        "            OldTexText(\"Last score: \"),\n",
        "            Integer(1)\n",
        "        )\n",
        "        score_label.scale(1.5)\n",
        "        score_label.arrange(RIGHT)\n",
        "        score_label[1].align_to(score_label[0][0][-1], DOWN)\n",
        "\n",
        "        score_label[1].add_updater(\n",
        "            lambda m: m.set_value(scores[get_index() - 1])\n",
        "        )\n",
        "        score_label[1].add_updater(\n",
        "            lambda m: m.set_fill(bars[scores[get_index() - 1]].get_fill_color())\n",
        "        )\n",
        "\n",
        "        n_trials_label = VGroup(\n",
        "            OldTexText(\"\\\\# Games: \"),\n",
        "            Integer(0),\n",
        "        )\n",
        "        n_trials_label.scale(1.5)\n",
        "        n_trials_label.arrange(RIGHT, aligned_edge=UP)\n",
        "        n_trials_label[1].add_updater(\n",
        "            lambda m: m.set_value(get_index())\n",
        "        )\n",
        "\n",
        "        n_trials_label.to_corner(UR, buff=LARGE_BUFF)\n",
        "        score_label.next_to(\n",
        "            n_trials_label, DOWN,\n",
        "            buff=LARGE_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "\n",
        "        self.add(score_label)\n",
        "        self.add(n_trials_label)\n",
        "\n",
        "        # Add curr_score_arrow\n",
        "        curr_score_arrow = Arrow(0.25 * UP, ORIGIN, buff=0)\n",
        "        curr_score_arrow.set_stroke(WHITE, 5)\n",
        "        curr_score_arrow.add_updater(\n",
        "            lambda m: m.next_to(bars[scores[get_index() - 1] - 1], UP, SMALL_BUFF)\n",
        "        )\n",
        "        self.add(curr_score_arrow)\n",
        "\n",
        "        # Add mean bar\n",
        "        mean_line = DashedLine(ORIGIN, 4 * UP)\n",
        "        mean_line.set_stroke(YELLOW, 2)\n",
        "\n",
        "        def get_mean():\n",
        "            return np.mean(scores[:get_index()])\n",
        "\n",
        "        mean_line.add_updater(\n",
        "            lambda m: m.move_to(axes.c2p(get_mean(), 0), DOWN)\n",
        "        )\n",
        "        mean_label = VGroup(\n",
        "            OldTexText(\"Mean = \"),\n",
        "            DecimalNumber(num_decimal_places=3),\n",
        "        )\n",
        "        mean_label.arrange(RIGHT)\n",
        "        mean_label.match_color(mean_line)\n",
        "        mean_label.add_updater(lambda m: m.next_to(mean_line, UP, SMALL_BUFF))\n",
        "        mean_label[1].add_updater(lambda m: m.set_value(get_mean()))\n",
        "\n",
        "        # Show many runs\n",
        "        index_tracker.set_value(1)\n",
        "        for value in [10, 100, 1000, 10000]:\n",
        "            anims = [\n",
        "                ApplyMethod(\n",
        "                    index_tracker.set_value, value,\n",
        "                    rate_func=linear,\n",
        "                    run_time=5,\n",
        "                ),\n",
        "            ]\n",
        "            if value == 10:\n",
        "                anims.append(\n",
        "                    FadeIn(\n",
        "                        VGroup(mean_line, mean_label),\n",
        "                        rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "                        run_time=2,\n",
        "                    ),\n",
        "                )\n",
        "            self.play(*anims)\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_axes(self):\n",
        "        axes = Axes(**self.axes_config)\n",
        "        axes.to_corner(DL)\n",
        "\n",
        "        axes.x_axis.add_numbers(*range(1, 12))\n",
        "        axes.y_axis.add_numbers(\n",
        "            *range(20, 120, 20),\n",
        "            unit=\"\\\\%\"\n",
        "        )\n",
        "        x_label = OldTexText(\"Score\")\n",
        "        x_label.next_to(axes.x_axis.get_right(), UR, buff=0.5)\n",
        "        x_label.shift_onto_screen()\n",
        "        axes.x_axis.add(x_label)\n",
        "\n",
        "        y_label = OldTexText(\"Relative proportion\")\n",
        "        y_label.next_to(axes.y_axis.get_top(), RIGHT, buff=0.75)\n",
        "        y_label.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        axes.y_axis.add(y_label)\n",
        "\n",
        "        return axes\n",
        "\n",
        "    def get_histogram_bars(self, axes):\n",
        "        bars = VGroup()\n",
        "        for x in range(1, 10):\n",
        "            bar = Rectangle(width=axes.x_axis.unit_size)\n",
        "            bar.move_to(axes.c2p(x, 0), DOWN)\n",
        "            bar.x = x\n",
        "            bars.add(bar)\n",
        "        bars.set_fill(opacity=0.7)\n",
        "        bars.set_color_by_gradient(BLUE, YELLOW, RED)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "        return bars\n",
        "\n",
        "    def get_relative_proportion_map(self, all_scores):\n",
        "        scores = set(all_scores)\n",
        "        n_scores = len(all_scores)\n",
        "        return dict([\n",
        "            (s, np.sum(all_scores == s) / n_scores)\n",
        "            for s in set(scores)\n",
        "        ])\n",
        "\n",
        "    def set_histogram_bars(self, bars, scores, axes):\n",
        "        prop_map = self.get_relative_proportion_map(scores)\n",
        "        epsilon = 1e-6\n",
        "        for bar in bars:\n",
        "            prop = prop_map.get(bar.x, epsilon)\n",
        "            bar.set_height(\n",
        "                prop * axes.y_axis.unit_size * 100,\n",
        "                stretch=True,\n",
        "                about_edge=DOWN,\n",
        "            )\n",
        "\n",
        "    def get_random_score(self):\n",
        "        score = 1\n",
        "        radius = 1\n",
        "        while True:\n",
        "            point = np.random.uniform(-1, 1, size=2)\n",
        "            hit_radius = get_norm(point)\n",
        "            if hit_radius > radius:\n",
        "                return score\n",
        "            else:\n",
        "                score += 1\n",
        "                radius = np.sqrt(radius**2 - hit_radius**2)\n",
        "\n",
        "\n",
        "class ExactBullseye(HyperdartScene):\n",
        "    def construct(self):\n",
        "        board = Dartboard()\n",
        "        board.replace(self.square)\n",
        "\n",
        "        lines = VGroup(Line(DOWN, UP), Line(LEFT, RIGHT))\n",
        "        lines.set_stroke(WHITE, 1)\n",
        "        lines.replace(self.square)\n",
        "\n",
        "        self.add(board, lines)\n",
        "        dart, dot = self.show_hit_with_dart(0.0037 * DOWN)\n",
        "        self.play(FadeOut(dot))\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        self.play(frame.scale, 0.02, run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowProbabilityForFirstShot(HyperdartScene):\n",
        "    def construct(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "        VGroup(square, circle).to_edge(LEFT)\n",
        "\n",
        "        r_line = DashedLine(circle.get_center(), circle.get_right())\n",
        "        r_label = OldTex(\"r = 1\")\n",
        "        r_label.next_to(r_line, DOWN, SMALL_BUFF)\n",
        "        self.add(r_line, r_label)\n",
        "\n",
        "        points = self.get_random_points(3000)\n",
        "        dots = VGroup(*[Dot(point, radius=0.02) for point in points])\n",
        "        dots.set_fill(WHITE, 0.5)\n",
        "\n",
        "        p_label = OldTex(\"P\", \"(S > 1)\", \"= \")\n",
        "        square_frac = VGroup(\n",
        "            circle.copy().set_height(0.5),\n",
        "            Line(LEFT, RIGHT).set_width(0.7),\n",
        "            square.copy().set_height(0.5).set_stroke(width=0)\n",
        "        )\n",
        "        square_frac.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        result = OldTex(\"=\", \"{\\\\pi \\\\over 4}\")\n",
        "\n",
        "        equation = VGroup(p_label, square_frac, result)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.scale(1.4)\n",
        "        equation.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        brace = Brace(p_label[1], UP, buff=SMALL_BUFF)\n",
        "        brace_label = brace.get_text(\"At least one\\\\\\\\``bullseye''\")\n",
        "\n",
        "        self.add(equation, brace, brace_label)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeInFromLarge, dots),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                circle.copy().set_fill(opacity=0).set_stroke(WHITE, 1),\n",
        "                square_frac[0]\n",
        "            ),\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                square.copy().set_fill(opacity=0),\n",
        "                square_frac[2]\n",
        "            ),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Dar on the line\n",
        "        x = np.random.random()\n",
        "        y = np.sqrt(1 - x**2)\n",
        "        unit = circle.get_width() / 2\n",
        "        point = circle.get_center() + unit * x * RIGHT + unit * y * UP\n",
        "        point += 0.004 * DOWN\n",
        "\n",
        "        frame = self.camera_frame\n",
        "        dart, dot = self.show_hit_with_dart(point)\n",
        "        self.remove(dot)\n",
        "        self.play(\n",
        "            frame.scale, 0.05,\n",
        "            frame.move_to, point,\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "\n",
        "class SamplingFourRandomNumbers(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_terms\": 4,\n",
        "        \"title_tex\": \"P\\\\left(x_0{}^2 + y_0{}^2 + x_1{}^2 + y_1{}^2 < 1\\\\right) = \\\\, ???\",\n",
        "        \"nl_to_nl_buff\": 0.75,\n",
        "        \"to_floor_buff\": 0.5,\n",
        "        \"tip_scale_factor\": 0.75,\n",
        "        \"include_half_labels\": True,\n",
        "        \"include_title\": True,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        texs = [\"x_0\", \"y_0\", \"x_1\", \"y_1\", \"x_2\", \"y_2\"][:self.n_terms]\n",
        "        colors = [BLUE, YELLOW, BLUE_B, YELLOW_B, BLUE_A, YELLOW_A][:self.n_terms]\n",
        "        t2c = dict([(t, c) for t, c in zip(texs, colors)])\n",
        "\n",
        "        # Title\n",
        "        if self.include_title:\n",
        "            title = OldTex(\n",
        "                self.title_tex,\n",
        "                tex_to_color_map=t2c\n",
        "            )\n",
        "            title.scale(1.5)\n",
        "            title.to_edge(UP)\n",
        "\n",
        "            h_line = DashedLine(title.get_left(), title.get_right())\n",
        "            h_line.next_to(title, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "            self.add(title, h_line)\n",
        "\n",
        "        # Number lines\n",
        "        number_lines = VGroup(*[\n",
        "            NumberLine(\n",
        "                x_min=-1,\n",
        "                x_max=1,\n",
        "                tick_frequency=0.25,\n",
        "                unit_size=3,\n",
        "            )\n",
        "            for x in range(self.n_terms)\n",
        "        ])\n",
        "        for line in number_lines:\n",
        "            line.add_numbers(-1, 0, 1)\n",
        "            if self.include_half_labels:\n",
        "                line.add_numbers(\n",
        "                    -0.5, 0.5,\n",
        "                    num_decimal_places=1,\n",
        "                )\n",
        "        number_lines.arrange(DOWN, buff=self.nl_to_nl_buff)\n",
        "        number_lines.to_edge(LEFT, buff=0.5)\n",
        "        number_lines.to_edge(DOWN, buff=self.to_floor_buff)\n",
        "\n",
        "        self.add(number_lines)\n",
        "\n",
        "        # Trackers\n",
        "        trackers = Group(*[ValueTracker(0) for x in range(self.n_terms)])\n",
        "        tips = VGroup(*[\n",
        "            ArrowTip(\n",
        "                start_angle=-PI / 2,\n",
        "                color=color\n",
        "            ).scale(self.tip_scale_factor)\n",
        "            for color in colors\n",
        "        ])\n",
        "        labels = VGroup(*[\n",
        "            OldTex(tex)\n",
        "            for tex in texs\n",
        "        ])\n",
        "\n",
        "        for tip, tracker, line, label in zip(tips, trackers, number_lines, labels):\n",
        "            tip.line = line\n",
        "            tip.tracker = tracker\n",
        "            tip.add_updater(lambda t: t.move_to(\n",
        "                t.line.n2p(t.tracker.get_value()), DOWN\n",
        "            ))\n",
        "\n",
        "            label.tip = tip\n",
        "            label.match_color(tip)\n",
        "            label.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            label.add_updater(lambda l: l.next_to(l.tip, UP, SMALL_BUFF))\n",
        "            # label.add_updater(lambda l: l[1].set_value(l.tip.tracker.get_value()))\n",
        "\n",
        "        self.add(tips, labels)\n",
        "\n",
        "        # Write bit sum\n",
        "        summands = VGroup(*[\n",
        "            OldTex(\"\\\\big(\", \"+0.00\", \"\\\\big)^2\").set_color(color)\n",
        "            for color in colors\n",
        "        ])\n",
        "        summands.arrange(DOWN)\n",
        "        summands.to_edge(RIGHT, buff=3)\n",
        "        for summand, tracker in zip(summands, trackers):\n",
        "            dec = DecimalNumber(include_sign=True)\n",
        "            dec.match_color(summand)\n",
        "            dec.tracker = tracker\n",
        "            dec.add_updater(lambda d: d.set_value(d.tracker.get_value()))\n",
        "            dec.move_to(summand[1])\n",
        "            summand.submobjects[1] = dec\n",
        "\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.set_width(3)\n",
        "        h_line.next_to(summands, DOWN, aligned_edge=RIGHT)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.next_to(h_line.get_left(), UR)\n",
        "        h_line.add(plus)\n",
        "\n",
        "        total = DecimalNumber()\n",
        "        total.scale(1.5)\n",
        "        total.next_to(h_line, DOWN)\n",
        "        total.match_x(summands)\n",
        "        total.add_updater(lambda d: d.set_value(np.sum([\n",
        "            t.get_value()**2 for t in trackers\n",
        "        ])))\n",
        "\n",
        "        VGroup(summands, h_line, total).shift_onto_screen()\n",
        "        self.add(summands, h_line, total)\n",
        "\n",
        "        # < or > 1\n",
        "        lt, gt = signs = VGroup(\n",
        "            OldTex(\"< 1 \\\\quad \\\\checkmark\"),\n",
        "            OldTex(\"\\\\ge 1 \\\\quad\"),\n",
        "        )\n",
        "        for sign in signs:\n",
        "            sign.scale(1.5)\n",
        "            sign.next_to(total, RIGHT, MED_LARGE_BUFF)\n",
        "        lt.set_color(GREEN)\n",
        "        gt.set_color(RED)\n",
        "\n",
        "        def update_signs(signs):\n",
        "            i = int(total.get_value() > 1)\n",
        "            signs[1 - i].set_opacity(0)\n",
        "            signs[i].set_opacity(1)\n",
        "\n",
        "        signs.add_updater(update_signs)\n",
        "\n",
        "        self.add(signs)\n",
        "\n",
        "        # Run simulation\n",
        "        for x in range(9):\n",
        "            trackers.generate_target()\n",
        "            for t in trackers.target:\n",
        "                t.set_value(np.random.uniform(-1, 1))\n",
        "\n",
        "            if x == 8:\n",
        "                for t in trackers.target:\n",
        "                    t.set_value(np.random.uniform(-0.5, 0.5))\n",
        "\n",
        "            self.remove(signs)\n",
        "            self.play(MoveToTarget(trackers))\n",
        "            self.add(signs)\n",
        "            self.wait()\n",
        "\n",
        "        # Less than 0.5\n",
        "        nl = number_lines[0]\n",
        "        line = Line(nl.n2p(-0.5), nl.n2p(0.5))\n",
        "        rect = Rectangle(height=0.25)\n",
        "        rect.set_stroke(width=0)\n",
        "        rect.set_fill(GREEN, 0.5)\n",
        "        rect.match_width(line, stretch=True)\n",
        "        rects = VGroup(*[\n",
        "            rect.copy().move_to(line.n2p(0))\n",
        "            for line in number_lines\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStartMap(GrowFromCenter, rects))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, rects))\n",
        "\n",
        "        # Set one to 0.5\n",
        "        self.play(trackers[0].set_value, 0.9)\n",
        "        self.play(ShowCreationThenFadeAround(summands[0]))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*[\n",
        "            ShowCreationThenFadeAround(summand)\n",
        "            for summand in summands[1:]\n",
        "        ]))\n",
        "        self.play(*[\n",
        "            ApplyMethod(tracker.set_value, 0.1)\n",
        "            for tracker in trackers[1:]\n",
        "        ])\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SamplingTwoRandomNumbers(SamplingFourRandomNumbers):\n",
        "    CONFIG = {\n",
        "        \"n_terms\": 2,\n",
        "        \"title_tex\": \"P\\\\left(x_0{}^2 + y_0{}^2 < 1\\\\right) = \\\\, ???\",\n",
        "        \"nl_to_nl_buff\": 1,\n",
        "        \"to_floor_buff\": 2,\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "\n",
        "class SamplingSixRandomNumbers(SamplingFourRandomNumbers):\n",
        "    CONFIG = {\n",
        "        \"n_terms\": 6,\n",
        "        \"nl_to_nl_buff\": 0.5,\n",
        "        \"include_half_labels\": False,\n",
        "        \"include_title\": False,\n",
        "        \"tip_scale_factor\": 0.5,\n",
        "    }\n",
        "\n",
        "\n",
        "class SamplePointIn3d(SpecialThreeDScene):\n",
        "    def construct(self):\n",
        "        axes = self.axes = self.get_axes()\n",
        "        sphere = self.get_sphere()\n",
        "        sphere.set_fill(BLUE_E, 0.25)\n",
        "        sphere.set_stroke(opacity=0.5)\n",
        "\n",
        "        cube = Cube()\n",
        "        cube.replace(sphere)\n",
        "        cube.set_fill(GREY, 0.2)\n",
        "        cube.set_stroke(WHITE, 1, opacity=0.5)\n",
        "\n",
        "        self.set_camera_orientation(\n",
        "            phi=80 * DEGREES,\n",
        "            theta=-120 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.03)\n",
        "\n",
        "        dot = Sphere()\n",
        "        # dot = Dot()\n",
        "        dot.set_shade_in_3d(True)\n",
        "        dot.set_width(0.1)\n",
        "\n",
        "        dot.move_to(axes.c2p(*np.random.uniform(0, 1, size=3)))\n",
        "        lines = always_redraw(lambda: self.get_lines(dot.get_center()))\n",
        "        labels = always_redraw(lambda: self.get_labels(lines))\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(cube)\n",
        "\n",
        "        for line, label in zip(lines, labels):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeIn(label)\n",
        "            )\n",
        "        self.add(lines, labels)\n",
        "        self.play(GrowFromCenter(dot))\n",
        "        self.play(DrawBorderThenFill(sphere, stroke_width=1))\n",
        "        self.wait(2)\n",
        "\n",
        "        n_points = 3000\n",
        "        points = [\n",
        "            axes.c2p(*np.random.uniform(-1, 1, 3))\n",
        "            for x in range(n_points)\n",
        "        ]\n",
        "        # point_cloud = PMobject().add_points(points)\n",
        "        dots = VGroup(*[\n",
        "            Dot(\n",
        "                point,\n",
        "                radius=0.01,\n",
        "                shade_in_3d=True,\n",
        "            )\n",
        "            for point in points\n",
        "        ])\n",
        "        dots.set_stroke(WHITE, 2)\n",
        "        dots.set_opacity(0.5)\n",
        "        self.play(ShowIncreasingSubsets(dots, run_time=9))\n",
        "        # self.play(ShowCreation(point_cloud, run_time=3))\n",
        "        self.wait(4)\n",
        "        return\n",
        "\n",
        "        for x in range(6):\n",
        "            self.play(\n",
        "                point.move_to,\n",
        "                axes.c2p(*np.random.uniform(-1, 1, size=3))\n",
        "            )\n",
        "            self.wait(2)\n",
        "        self.wait(7)\n",
        "\n",
        "    def get_lines(self, point):\n",
        "        axes = self.axes\n",
        "        x, y, z = axes.p2c(point)\n",
        "        p0 = axes.c2p(0, 0, 0)\n",
        "        p1 = axes.c2p(x, 0, 0)\n",
        "        p2 = axes.c2p(x, y, 0)\n",
        "        p3 = axes.c2p(x, y, z)\n",
        "        x_line = DashedLine(p0, p1, color=GREEN)\n",
        "        y_line = DashedLine(p1, p2, color=RED)\n",
        "        z_line = DashedLine(p2, p3, color=BLUE)\n",
        "        lines = VGroup(x_line, y_line, z_line)\n",
        "        lines.set_shade_in_3d(True)\n",
        "        return lines\n",
        "\n",
        "    def get_labels(self, lines):\n",
        "        x_label = OldTex(\"x\")\n",
        "        y_label = OldTex(\"y\")\n",
        "        z_label = OldTex(\"z\")\n",
        "        result = VGroup(x_label, y_label, z_label)\n",
        "        result.rotate(90 * DEGREES, RIGHT)\n",
        "        result.set_shade_in_3d(True)\n",
        "\n",
        "        x_line, y_line, z_line = lines\n",
        "\n",
        "        x_label.match_color(x_line)\n",
        "        y_label.match_color(y_line)\n",
        "        z_label.match_color(z_line)\n",
        "\n",
        "        x_label.next_to(x_line, IN, SMALL_BUFF)\n",
        "        y_label.next_to(y_line, RIGHT + OUT, SMALL_BUFF)\n",
        "        z_label.next_to(z_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class OverlayToPointIn3d(Scene):\n",
        "    def construct(self):\n",
        "        t2c = {\n",
        "            \"{x}\": GREEN,\n",
        "            \"{y}\": RED,\n",
        "            \"{z}\": BLUE,\n",
        "        }\n",
        "        ineq = OldTex(\n",
        "            \"{x}^2 + {y}^2 + {z}^2 < 1\",\n",
        "            tex_to_color_map=t2c,\n",
        "        )\n",
        "        ineq.scale(1.5)\n",
        "        ineq.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "        ineq.to_edge(UP)\n",
        "\n",
        "        equiv = OldTex(\"\\\\Leftrightarrow\")\n",
        "        equiv.scale(2)\n",
        "        equiv.match_y(ineq)\n",
        "\n",
        "        rhs = OldTexText(\n",
        "            \"$({x}, {y}, {z})$\",\n",
        "            \" lies within a\\\\\\\\sphere with radius 1\"\n",
        "        )\n",
        "        rhs[0][1].set_color(GREEN)\n",
        "        rhs[0][3].set_color(RED)\n",
        "        rhs[0][5].set_color(BLUE)\n",
        "        rhs.scale(1.3)\n",
        "        rhs.next_to(equiv, RIGHT)\n",
        "        rhs.to_edge(UP)\n",
        "\n",
        "        self.add(ineq)\n",
        "        self.wait()\n",
        "        self.play(Write(equiv))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(rhs))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwoDPlusTwoDEqualsFourD(HyperdartScene):\n",
        "    def construct(self):\n",
        "        board = VGroup(*self.mobjects)\n",
        "\n",
        "        unit_size = 1.5\n",
        "        axes = Axes(\n",
        "            x_min=-1.25,\n",
        "            x_max=1.25,\n",
        "            y_min=-1.25,\n",
        "            y_max=1.25,\n",
        "            axis_config={\n",
        "                \"unit_size\": unit_size,\n",
        "                \"tick_frequency\": 0.5,\n",
        "                \"include_tip\": False,\n",
        "            }\n",
        "        )\n",
        "        board.set_height(2 * unit_size)\n",
        "        axes.move_to(board)\n",
        "        axes.set_stroke(width=1)\n",
        "\n",
        "        board.add(axes)\n",
        "        board.to_edge(LEFT)\n",
        "        self.add(board)\n",
        "\n",
        "        # Set up titles\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"x_0\": WHITE,\n",
        "                \"y_0\": WHITE,\n",
        "                \"x_1\": WHITE,\n",
        "                \"y_1\": WHITE,\n",
        "            }\n",
        "        }\n",
        "        title1 = VGroup(\n",
        "            OldTexText(\"First shot\"),\n",
        "            OldTex(\"(x_0, y_0)\", **kw),\n",
        "        )\n",
        "        title2 = VGroup(\n",
        "            OldTexText(\"Second shot\"),\n",
        "            OldTex(\"(x_1, y_1)\", **kw),\n",
        "        )\n",
        "        title3 = VGroup(\n",
        "            OldTexText(\"Point in 4d space\"),\n",
        "            OldTex(\"(x_0, y_0, x_1, y_1)\", **kw)\n",
        "        )\n",
        "        titles = VGroup(title1, title2, title3)\n",
        "        for title in titles:\n",
        "            title.arrange(DOWN)\n",
        "        plus = OldTex(\"+\").scale(2)\n",
        "        equals = OldTex(\"=\").scale(2)\n",
        "\n",
        "        label1 = OldTex(\"(x_0, y_0)\")\n",
        "        label2 = OldTex(\"(x_1, y_1)\")\n",
        "        VGroup(label1, label2).scale(0.8)\n",
        "\n",
        "        title1.next_to(board, UP)\n",
        "\n",
        "        # First hit\n",
        "        point1 = axes.c2p(0.5, 0.7)\n",
        "        dart1, dot1 = self.show_hit_with_dart(point1)\n",
        "        label1.next_to(dot1, UR, buff=0)\n",
        "        self.add(title1, label1)\n",
        "        # lines1 = self.show_geometry(point1, pace=\"fast\")\n",
        "        # chord_and_shadow1 = self.show_circle_shrink(lines1[1], pace=\"fast\")\n",
        "\n",
        "        board_copy = board.copy()\n",
        "        board_copy.next_to(board, RIGHT, buff=LARGE_BUFF)\n",
        "        self.square = board_copy[0]\n",
        "\n",
        "        title2.next_to(board_copy, UP)\n",
        "        plus.move_to(titles[:2])\n",
        "\n",
        "        self.play(ReplacementTransform(board.copy().fade(1), board_copy))\n",
        "        point2 = self.get_random_point()\n",
        "        dart2, dot2 = self.show_hit_with_dart(point2)\n",
        "        label2.next_to(dot2, UR, buff=0)\n",
        "        self.add(plus, title2, label2)\n",
        "        self.wait()\n",
        "\n",
        "        # Set up the other titles\n",
        "        title3.to_edge(RIGHT)\n",
        "        title3.match_y(title2)\n",
        "\n",
        "        equals.move_to(midpoint(title2.get_right(), title3.get_left()))\n",
        "\n",
        "        randy = Randolph(height=2.5)\n",
        "        randy.next_to(title3, DOWN, buff=LARGE_BUFF)\n",
        "        randy.look_at(title3)\n",
        "\n",
        "        kw = {\"path_arc\": -20 * DEGREES}\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                *[\n",
        "                    TransformFromCopy(\n",
        "                        title1[1].get_part_by_tex(tex),\n",
        "                        title3[1].get_part_by_tex(tex),\n",
        "                        **kw\n",
        "                    )\n",
        "                    for tex in [\"(\", \"x_0\", \",\", \"y_0\"]\n",
        "                ],\n",
        "                *[\n",
        "                    TransformFromCopy(\n",
        "                        title2[1].get_part_by_tex(tex),\n",
        "                        title3[1].get_parts_by_tex(tex)[-1],\n",
        "                        **kw\n",
        "                    )\n",
        "                    for tex in [\"x_1\", \",\", \"y_1\", \")\"]\n",
        "                ],\n",
        "                TransformFromCopy(\n",
        "                    title2[1].get_part_by_tex(\",\"),\n",
        "                    title3[1].get_parts_by_tex(\",\")[1],\n",
        "                    **kw\n",
        "                ),\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            Write(equals),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeInFromDown(title3[0]),\n",
        "            FadeIn(randy),\n",
        "        )\n",
        "        self.play(randy.change, \"horrified\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change, \"confused\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExpectedValueComputation(Scene):\n",
        "    def construct(self):\n",
        "        t2c = {\n",
        "            \"0\": MAROON_C,\n",
        "            \"1\": BLUE,\n",
        "            \"2\": GREEN,\n",
        "            \"3\": YELLOW,\n",
        "            \"4\": RED,\n",
        "        }\n",
        "\n",
        "        line1 = OldTex(\n",
        "            \"E[S]\", \"=\",\n",
        "            \"1 \\\\cdot\", \"P(S = 1)\", \"+\",\n",
        "            \"2 \\\\cdot\", \"P(S = 2)\", \"+\",\n",
        "            \"3 \\\\cdot\", \"P(S = 3)\", \"+\",\n",
        "            \"\\\\cdots\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        line2 = OldTex(\n",
        "            \"=&\\\\phantom{-}\",\n",
        "            \"1 \\\\cdot\", \"\\\\big(\", \"P(S > 0)\", \"-\", \"P(S > 1)\", \"\\\\big)\", \"\\\\\\\\&+\",\n",
        "            \"2 \\\\cdot\", \"\\\\big(\", \"P(S > 1)\", \"-\", \"P(S > 2)\", \"\\\\big)\", \"\\\\\\\\&+\",\n",
        "            \"3 \\\\cdot\", \"\\\\big(\", \"P(S > 2)\", \"-\", \"P(S > 3)\", \"\\\\big)\", \"\\\\\\\\&+\",\n",
        "            \"\\\\cdots\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        line2[1:12].align_to(line2[13], LEFT)\n",
        "        line3 = OldTex(\n",
        "            \"=\",\n",
        "            \"P(S > 0)\", \"+\",\n",
        "            \"P(S > 1)\", \"+\",\n",
        "            \"P(S > 2)\", \"+\",\n",
        "            \"P(S > 3)\", \"+\",\n",
        "            \"\\\\cdots\",\n",
        "            tex_to_color_map=t2c,\n",
        "        )\n",
        "\n",
        "        line1.to_corner(UL)\n",
        "        line2.next_to(line1, DOWN, buff=MED_LARGE_BUFF)\n",
        "        line2.align_to(line1[1], LEFT)\n",
        "        line3.next_to(line2, DOWN, buff=MED_LARGE_BUFF)\n",
        "        line3.align_to(line1[1], LEFT)\n",
        "\n",
        "        # Write line 1\n",
        "        self.add(line1[:2])\n",
        "        self.play(Write(line1[2:7]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(line1[7]))\n",
        "        self.play(Write(line1[8:13]))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(line1[13]))\n",
        "        self.play(Write(line1[14:19]))\n",
        "        self.wait()\n",
        "        self.play(Write(line1[19:]))\n",
        "        self.wait()\n",
        "\n",
        "        # line 2 scaffold\n",
        "        kw = {\n",
        "            \"path_arc\": 90 * DEGREES\n",
        "        }\n",
        "        bigs = line2.get_parts_by_tex(\"big\")\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(\n",
        "                    line1.get_part_by_tex(\"=\"),\n",
        "                    line2.get_part_by_tex(\"=\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1.get_parts_by_tex(\"\\\\cdot\"),\n",
        "                    line2.get_parts_by_tex(\"\\\\cdot\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1.get_parts_by_tex(\"+\"),\n",
        "                    line2.get_parts_by_tex(\"+\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1.get_part_by_tex(\"1\"),\n",
        "                    line2.get_part_by_tex(\"1\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1.get_part_by_tex(\"2\"),\n",
        "                    line2.get_part_by_tex(\"2\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1.get_part_by_tex(\"3\"),\n",
        "                    line2.get_part_by_tex(\"3\"),\n",
        "                    **kw\n",
        "                ),\n",
        "                run_time=3,\n",
        "                lag_ratio=0,\n",
        "            ),\n",
        "            LaggedStart(*[\n",
        "                GrowFromCenter(bigs[i:i + 2])\n",
        "                for i in range(0, len(bigs), 2)\n",
        "            ])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Expand out sum\n",
        "        for n in range(3):\n",
        "            i = 6 * n\n",
        "            j = 12 * n\n",
        "\n",
        "            rect1 = SurroundingRectangle(line1[i + 4:i + 7])\n",
        "            rect2 = SurroundingRectangle(line2[j + 4:j + 11])\n",
        "            color = line1[i + 5].get_color()\n",
        "            VGroup(rect1, rect2).set_stroke(color, 2)\n",
        "\n",
        "            self.play(ShowCreation(rect1))\n",
        "            self.play(\n",
        "                TransformFromCopy(\n",
        "                    line1[i + 4:i + 7],\n",
        "                    line2[j + 4:j + 7],\n",
        "                ),\n",
        "                TransformFromCopy(\n",
        "                    line1[i + 4:i + 7],\n",
        "                    line2[j + 8:j + 11],\n",
        "                ),\n",
        "                FadeIn(line2[j + 7]),\n",
        "                ReplacementTransform(rect1, rect2),\n",
        "            )\n",
        "            self.play(FadeOut(rect2))\n",
        "\n",
        "        # Show telescoping\n",
        "        line2.generate_target()\n",
        "        line2.target.set_opacity(0.2)\n",
        "        line2.target[4:7].set_opacity(1)\n",
        "\n",
        "        self.play(MoveToTarget(line2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(line2[0], line3[0]),\n",
        "            TransformFromCopy(line2[4:7], line3[1:4]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        line2.target.set_opacity(0.2)\n",
        "        VGroup(\n",
        "            line2.target[1:4],\n",
        "            line2.target[7:12],\n",
        "            line2.target[12:19],\n",
        "            line2.target[23],\n",
        "        ).set_opacity(1)\n",
        "\n",
        "        self.play(MoveToTarget(line2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(line2[12], line3[4]),\n",
        "            TransformFromCopy(line2[16:19], line3[5:8]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        n = 12\n",
        "        line2.target.set_opacity(0.2)\n",
        "        VGroup(\n",
        "            line2.target[n + 1:n + 4],\n",
        "            line2.target[n + 7:n + 12],\n",
        "            line2.target[n + 12:n + 19],\n",
        "            line2.target[n + 23],\n",
        "        ).set_opacity(1)\n",
        "\n",
        "        self.play(MoveToTarget(line2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(line2[n + 12], line3[8]),\n",
        "            TransformFromCopy(line2[n + 16:n + 19], line3[9:12]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(line3[12:]))\n",
        "        self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(line3, buff=MED_SMALL_BUFF)\n",
        "        rect.set_stroke(WHITE, 2)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class SubtractHistogramParts(ShowDistributionOfScores):\n",
        "    def construct(self):\n",
        "        n_scores = 10000\n",
        "        scores = np.array([self.get_random_score() for x in range(n_scores)])\n",
        "        axes = self.get_axes()\n",
        "        bars = self.get_histogram_bars(axes)\n",
        "        self.set_histogram_bars(bars, scores, axes)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(bars)\n",
        "\n",
        "        # P(S = 2)\n",
        "        p2_arrow = Vector(\n",
        "            0.75 * DOWN,\n",
        "            max_stroke_width_to_length_ratio=10,\n",
        "            max_tip_length_to_length_ratio=0.35,\n",
        "        )\n",
        "        p2_arrow.next_to(bars[1], UP, SMALL_BUFF)\n",
        "        p2_arrow = VGroup(\n",
        "            p2_arrow.copy().set_stroke(BLACK, 9),\n",
        "            p2_arrow,\n",
        "        )\n",
        "\n",
        "        p2_label = OldTex(\"P(S = 2)\")\n",
        "        p2_label.next_to(p2_arrow, UP, SMALL_BUFF)\n",
        "        p2_label.set_color(bars[1].get_fill_color())\n",
        "\n",
        "        self.play(\n",
        "            GrowFromPoint(p2_arrow, p2_arrow.get_top()),\n",
        "            FadeInFromDown(p2_label),\n",
        "            bars[0].set_opacity, 0.1,\n",
        "            bars[2:].set_opacity, 0.1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Culumative probabilities\n",
        "        rhs = OldTex(\"=\", \"P(S > 1)\", \"-\", \"P(S > 2)\")\n",
        "        rhs[1].set_color(YELLOW)\n",
        "        rhs[3].set_color(bars[2].get_fill_color())\n",
        "        rhs[2:].set_opacity(0.2)\n",
        "        rhs.next_to(p2_label, RIGHT)\n",
        "\n",
        "        brace1 = Brace(bars[1:5], UP)[0]\n",
        "        brace1.next_to(rhs[1], DOWN)\n",
        "        brace1.match_color(rhs[1])\n",
        "\n",
        "        rf = 3.5\n",
        "        lf = 1.4\n",
        "        brace1[:2].stretch(rf, 0, about_edge=LEFT)\n",
        "        brace1[0].stretch(1 / rf, 0, about_edge=LEFT)\n",
        "        brace1[4:].stretch(lf, 0, about_edge=RIGHT)\n",
        "        brace1[5:].stretch(1 / lf, 0, about_edge=RIGHT)\n",
        "\n",
        "        brace2 = Brace(bars[2:], UP)\n",
        "        brace2.match_color(rhs[3])\n",
        "        brace2.set_width(10, about_edge=LEFT)\n",
        "        brace2.shift(1.5 * UP)\n",
        "\n",
        "        self.add(brace1, p2_arrow)\n",
        "        self.play(\n",
        "            FadeIn(rhs),\n",
        "            bars[2:].set_opacity, 1,\n",
        "            GrowFromPoint(brace1, rhs[1].get_bottom()),\n",
        "            p2_arrow.set_opacity, 0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rhs[:2].set_opacity, 0.2,\n",
        "            brace1.set_opacity, 0.2,\n",
        "            rhs[2:].set_opacity, 1,\n",
        "            bars[1].set_opacity, 0.1,\n",
        "            GrowFromCenter(brace2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            bars[2:].set_opacity, 0.1,\n",
        "            bars[1].set_opacity, 1,\n",
        "            rhs.set_opacity, 1,\n",
        "            brace1.set_opacity, 1,\n",
        "            p2_arrow.set_opacity, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "        # for i, part in enumerate(brace1):\n",
        "        #     self.add(Integer(i).scale(0.5).move_to(part))\n",
        "\n",
        "\n",
        "class GameWithSpecifiedScore(HyperdartScene):\n",
        "    CONFIG = {\n",
        "        \"score\": 1,\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        board = VGroup(self.square, self.circle, self.circle_center_dot)\n",
        "        board.to_edge(DOWN, buff=0.5)\n",
        "\n",
        "        score_label = VGroup(\n",
        "            OldTexText(\"Score: \"),\n",
        "            Integer(1)\n",
        "        )\n",
        "        score_label.scale(2)\n",
        "        score_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        score_label.to_edge(UP, buff=0.25)\n",
        "\n",
        "        self.add(score_label)\n",
        "\n",
        "        score = 1\n",
        "        pace = \"fast\"\n",
        "        while True:\n",
        "            point = self.get_random_point()\n",
        "            want_to_continue = (score < self.score)\n",
        "            if want_to_continue:\n",
        "                while not self.is_inside(point):\n",
        "                    point = self.get_random_point()\n",
        "\n",
        "                dart, dot = self.show_hit_with_dart(point)\n",
        "                score_label[1].increment_value()\n",
        "                lines = self.show_geometry(point, pace)\n",
        "                chord_and_shadow = self.show_circle_shrink(lines[1], pace=pace)\n",
        "\n",
        "                self.play(\n",
        "                    FadeOut(VGroup(dart, dot, lines, chord_and_shadow)),\n",
        "                    run_time=0.5,\n",
        "                )\n",
        "                score += 1\n",
        "            else:\n",
        "                while self.is_inside(point):\n",
        "                    point = self.get_random_point()\n",
        "                self.show_miss(point)\n",
        "                self.play(ShowCreationThenFadeAround(score_label[1]))\n",
        "                self.wait()\n",
        "                return\n",
        "\n",
        "\n",
        "class Score1Game(GameWithSpecifiedScore):\n",
        "    CONFIG = {\n",
        "        \"score\": 1,\n",
        "    }\n",
        "\n",
        "\n",
        "class Score2Game(GameWithSpecifiedScore):\n",
        "    CONFIG = {\n",
        "        \"score\": 2,\n",
        "    }\n",
        "\n",
        "\n",
        "class Score3Game(GameWithSpecifiedScore):\n",
        "    CONFIG = {\n",
        "        \"score\": 3,\n",
        "    }\n",
        "\n",
        "\n",
        "class Score4Game(GameWithSpecifiedScore):\n",
        "    CONFIG = {\n",
        "        \"score\": 4,\n",
        "    }\n",
        "\n",
        "\n",
        "class HistogramScene(ShowDistributionOfScores):\n",
        "    CONFIG = {\n",
        "        \"n_scores\": 10000,\n",
        "        \"mean_line_height\": 4,\n",
        "    }\n",
        "\n",
        "    def setup(self):\n",
        "        self.scores = np.array([\n",
        "            self.get_random_score()\n",
        "            for x in range(self.n_scores)\n",
        "        ])\n",
        "        self.axes = self.get_axes()\n",
        "        self.bars = self.get_histogram_bars(self.axes)\n",
        "        self.set_histogram_bars(self.bars, self.scores, self.axes)\n",
        "\n",
        "        self.add(self.axes)\n",
        "        self.add(self.bars)\n",
        "\n",
        "    def get_mean_label(self):\n",
        "        mean_line = DashedLine(ORIGIN, self.mean_line_height * UP)\n",
        "        mean_line.set_stroke(YELLOW, 2)\n",
        "\n",
        "        mean = np.mean(self.scores)\n",
        "        mean_line.move_to(self.axes.c2p(mean, 0), DOWN)\n",
        "        mean_label = VGroup(\n",
        "            *TexText(\"E[S]\", \"=\"),\n",
        "            DecimalNumber(mean, num_decimal_places=3),\n",
        "        )\n",
        "        mean_label.arrange(RIGHT)\n",
        "        mean_label.match_color(mean_line)\n",
        "        mean_label.next_to(\n",
        "            mean_line.get_end(), UP, SMALL_BUFF,\n",
        "            index_of_submobject_to_align=0,\n",
        "        )\n",
        "\n",
        "        return VGroup(mean_line, *mean_label)\n",
        "\n",
        "\n",
        "class ExpectedValueFromBars(HistogramScene):\n",
        "    def construct(self):\n",
        "        axes = self.axes\n",
        "        bars = self.bars\n",
        "        mean_label = self.get_mean_label()\n",
        "        mean_label.remove(mean_label[-1])\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"P(S = 1)\", \"\\\\cdot\", \"1\", \"+\",\n",
        "            \"P(S = 2)\", \"\\\\cdot\", \"2\", \"+\",\n",
        "            \"P(S = 3)\", \"\\\\cdot\", \"3\", \"+\",\n",
        "            \"\\\\cdots\"\n",
        "        )\n",
        "        equation.scale(0.9)\n",
        "        equation.next_to(mean_label[-1], RIGHT)\n",
        "        equation.shift(LEFT)\n",
        "\n",
        "        for i in range(3):\n",
        "            equation.set_color_by_tex(\n",
        "                str(i + 1), bars[i].get_fill_color()\n",
        "            )\n",
        "\n",
        "        equation[4:].set_opacity(0.2)\n",
        "\n",
        "        self.add(mean_label)\n",
        "        self.play(\n",
        "            mean_label[1:].shift, LEFT,\n",
        "            FadeIn(equation, LEFT)\n",
        "        )\n",
        "\n",
        "        p_parts = VGroup()\n",
        "        p_part_copies = VGroup()\n",
        "        for i in range(3):\n",
        "            bar = bars[i]\n",
        "            num = axes.x_axis.numbers[i]\n",
        "            p_part = equation[4 * i]\n",
        "            s_part = equation[4 * i + 2]\n",
        "\n",
        "            p_part_copy = p_part.copy()\n",
        "            p_part_copy.set_width(0.8 * bar.get_width())\n",
        "            p_part_copy.next_to(bar, UP, SMALL_BUFF)\n",
        "            p_part_copy.set_opacity(1)\n",
        "\n",
        "            self.remove(mean_label[0])\n",
        "            self.play(\n",
        "                bars[:i + 1].set_opacity, 1,\n",
        "                bars[i + 1:].set_opacity, 0.2,\n",
        "                equation[:4 * (i + 1)].set_opacity, 1,\n",
        "                FadeInFromDown(p_part_copy),\n",
        "                Animation(mean_label[0]),\n",
        "            )\n",
        "            kw = {\n",
        "                \"surrounding_rectangle_config\": {\n",
        "                    \"color\": bar.get_fill_color(),\n",
        "                    \"buff\": 0.5 * SMALL_BUFF,\n",
        "                }\n",
        "            }\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    AnimationGroup(\n",
        "                        ShowCreationThenFadeAround(p_part, **kw),\n",
        "                        ShowCreationThenFadeAround(p_part_copy, **kw),\n",
        "                    ),\n",
        "                    AnimationGroup(\n",
        "                        ShowCreationThenFadeAround(s_part, **kw),\n",
        "                        ShowCreationThenFadeAround(num, **kw),\n",
        "                    ),\n",
        "                    lag_ratio=0.5,\n",
        "                )\n",
        "            )\n",
        "            self.wait()\n",
        "            p_parts.add(p_part)\n",
        "            p_part_copies.add(p_part_copy)\n",
        "\n",
        "        self.add(bars, mean_label)\n",
        "        self.play(\n",
        "            bars.set_opacity, 1,\n",
        "            equation.set_opacity, 1,\n",
        "            FadeOut(p_part_copies)\n",
        "        )\n",
        "\n",
        "        braces = VGroup(*[\n",
        "            Brace(p_part, UP)\n",
        "            for p_part in p_parts\n",
        "        ])\n",
        "        for brace in braces:\n",
        "            brace.add(brace.get_text(\"???\"))\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, braces))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ProbabilitySGtOne(HistogramScene):\n",
        "    def construct(self):\n",
        "        axes = self.axes\n",
        "        bars = self.bars\n",
        "\n",
        "        brace = Brace(bars[1:], UP)\n",
        "        label = brace.get_tex(\"P(S > 1)\")\n",
        "        brace[0][:2].stretch(1.5, 0, about_edge=LEFT)\n",
        "\n",
        "        outlines = bars[1:].copy()\n",
        "        for bar in outlines:\n",
        "            bar.set_stroke(bar.get_fill_color(), 2)\n",
        "            bar.set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromEdge(brace, LEFT),\n",
        "            bars[0].set_opacity, 0.2,\n",
        "            bars[1:].set_opacity, 0.8,\n",
        "            ShowCreationThenFadeOut(outlines),\n",
        "            FadeIn(label, LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        square = Square()\n",
        "        square.set_fill(BLUE, 0.75)\n",
        "        square.set_stroke(WHITE, 1)\n",
        "        square.set_height(0.5)\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.set_fill(RED, 0.75)\n",
        "        circle.set_stroke(WHITE, 1)\n",
        "        circle.set_height(0.5)\n",
        "\n",
        "        bar = Line(LEFT, RIGHT)\n",
        "        bar.set_stroke(WHITE, 3)\n",
        "        bar.set_width(0.5)\n",
        "\n",
        "        geo_frac = VGroup(circle, bar, square)\n",
        "        geo_frac.arrange(DOWN, SMALL_BUFF, buff=SMALL_BUFF)\n",
        "\n",
        "        rhs = VGroup(\n",
        "            OldTex(\"=\"),\n",
        "            geo_frac,\n",
        "            OldTex(\"= \\\\frac{\\\\pi}{4}\")\n",
        "        )\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.next_to(label)\n",
        "\n",
        "        shift_val = 2.05 * LEFT + 0.25 * UP\n",
        "        rhs.shift(shift_val)\n",
        "\n",
        "        self.play(\n",
        "            label.shift, shift_val,\n",
        "            FadeIn(rhs, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # P(S > 2)\n",
        "        new_brace = brace.copy()\n",
        "        new_brace.next_to(\n",
        "            bars[2], UP,\n",
        "            buff=SMALL_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        self.add(new_brace)\n",
        "\n",
        "        new_label = OldTex(\n",
        "            \"P(S > 2)\", \"=\", \"\\\\,???\"\n",
        "        )\n",
        "        new_label.next_to(new_brace[0][2], UP)\n",
        "\n",
        "        self.play(\n",
        "            bars[1].set_opacity, 0.2,\n",
        "            label.set_opacity, 0.5,\n",
        "            rhs.set_opacity, 0.5,\n",
        "            brace.set_opacity, 0.5,\n",
        "            GrowFromEdge(new_brace, LEFT),\n",
        "            ReplacementTransform(\n",
        "                new_label.copy().fade(1).move_to(label, LEFT),\n",
        "                new_label,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        new_rhs = OldTex(\n",
        "            \"{\\\\text{4d ball}\", \" \\\\over\", \" \\\\text{4d cube}}\",\n",
        "            # \"=\",\n",
        "            # \"{\\\\pi^2 / 2\", \"\\\\over\", \"2^4}\"\n",
        "        )\n",
        "        new_rhs[0].set_color(RED)\n",
        "        new_rhs[2].set_color(BLUE)\n",
        "        new_rhs.move_to(new_label[-1], LEFT)\n",
        "        shift_val = 0.75 * LEFT + 0.15 * UP\n",
        "\n",
        "        new_rhs.shift(shift_val)\n",
        "\n",
        "        new_label.generate_target()\n",
        "        new_label.target.shift(shift_val)\n",
        "        new_label.target[-1].set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(new_label),\n",
        "            FadeIn(new_rhs, LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # P(S > 3)\n",
        "        final_brace = brace.copy()\n",
        "        final_brace.set_opacity(1)\n",
        "        final_brace.next_to(\n",
        "            bars[3], UP,\n",
        "            buff=SMALL_BUFF,\n",
        "            aligned_edge=LEFT,\n",
        "        )\n",
        "        self.add(final_brace)\n",
        "\n",
        "        final_label = OldTex(\"P(S > 3)\")\n",
        "        final_label.next_to(final_brace[0][2], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            bars[2].set_opacity, 0.2,\n",
        "            new_label[:-1].set_opacity, 0.5,\n",
        "            new_rhs.set_opacity, 0.5,\n",
        "            new_brace.set_opacity, 0.5,\n",
        "            GrowFromEdge(final_brace, LEFT),\n",
        "            ReplacementTransform(\n",
        "                final_label.copy().fade(1).move_to(new_label, LEFT),\n",
        "                final_label,\n",
        "            ),\n",
        "            axes.x_axis[-1].set_opacity, 0,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VolumsOfNBalls(Scene):\n",
        "    def construct(self):\n",
        "        title, alt_title = [\n",
        "            OldTexText(\n",
        "                \"Volumes of \" + tex + \"-dimensional balls\",\n",
        "                tex_to_color_map={tex: YELLOW},\n",
        "            )\n",
        "            for tex in [\"$N$\", \"$2n$\"]\n",
        "        ]\n",
        "        for mob in [title, alt_title]:\n",
        "            mob.scale(1.5)\n",
        "            mob.to_edge(UP)\n",
        "\n",
        "        formulas = VGroup(*[\n",
        "            OldTex(\n",
        "                tex,\n",
        "                tex_to_color_map={\"R\": WHITE}\n",
        "            )\n",
        "            for tex in [\n",
        "                \"2R\",\n",
        "                \"\\\\pi R^2\",\n",
        "                \"\\\\frac{4}{3} \\\\pi R^3\",\n",
        "                \"\\\\frac{1}{2} \\\\pi^2 R^4\",\n",
        "                \"\\\\frac{8}{15} \\\\pi^2 R^5\",\n",
        "                \"\\\\frac{1}{6} \\\\pi^3 R^6\",\n",
        "                \"\\\\frac{16}{105} \\\\pi^3 R^7\",\n",
        "                \"\\\\frac{1}{24} \\\\pi^4 R^8\",\n",
        "                \"\\\\frac{32}{945} \\\\pi^4 R^9\",\n",
        "                \"\\\\frac{1}{120} \\\\pi^5 R^{10}\",\n",
        "                \"\\\\frac{64}{10{,}395} \\\\pi^5 R^{11}\",\n",
        "                \"\\\\frac{1}{720} \\\\pi^6 R^{12}\",\n",
        "            ]\n",
        "        ])\n",
        "\n",
        "        formulas.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        formulas.scale(0.9)\n",
        "        formulas.to_edge(LEFT)\n",
        "\n",
        "        lines = VGroup()\n",
        "        d_labels = VGroup()\n",
        "        for dim, formula in zip(it.count(1), formulas):\n",
        "            label = VGroup(Integer(dim), OldTex(\"D\"))\n",
        "            label.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "            label[0].set_color(YELLOW)\n",
        "            label.move_to(formula)\n",
        "            label.shift(UP)\n",
        "\n",
        "            line = Line(UP, DOWN)\n",
        "            line.set_stroke(WHITE, 1)\n",
        "            line.next_to(formula, RIGHT, buff=MED_LARGE_BUFF)\n",
        "            line.shift(0.5 * UP)\n",
        "\n",
        "            d_labels.add(label)\n",
        "            lines.add(line)\n",
        "            # coefs.add(formula[0])\n",
        "            formula[0].set_color(BLUE_B)\n",
        "        lines.remove(lines[-1])\n",
        "        line = Line(formulas.get_left(), formulas.get_right())\n",
        "        line.set_stroke(WHITE, 1)\n",
        "        line.next_to(d_labels, DOWN, MED_SMALL_BUFF)\n",
        "        lines.add(line)\n",
        "\n",
        "        chart = VGroup(lines, d_labels, formulas)\n",
        "        chart.save_state()\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(d_labels)\n",
        "        self.add(lines)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeInFromDown, formulas, run_time=3, lag_ratio=0.1))\n",
        "        self.play(chart.to_edge, RIGHT, {\"buff\": MED_SMALL_BUFF}, run_time=5)\n",
        "        self.wait()\n",
        "        self.play(Restore(chart))\n",
        "        self.play(FadeOut(formulas[4:]))\n",
        "\n",
        "        rect1 = SurroundingRectangle(formulas[2][0][-1])\n",
        "        rect2 = SurroundingRectangle(formulas[3][0][-2:])\n",
        "        self.play(ShowCreation(rect1))\n",
        "        self.play(TransformFromCopy(rect1, rect2))\n",
        "        self.play(FadeOut(VGroup(rect1, rect2)))\n",
        "\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(\n",
        "                formulas[i].get_bottom(),\n",
        "                formulas[i + 1].get_bottom(),\n",
        "                path_arc=150 * DEGREES,\n",
        "            )\n",
        "            for i in (1, 2)\n",
        "        ])\n",
        "\n",
        "        for arrow in arrows:\n",
        "            self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            FadeIn(formulas[4:]),\n",
        "        )\n",
        "\n",
        "        # General formula for even dimensions\n",
        "        braces = VGroup(*[\n",
        "            Brace(formula, DOWN)\n",
        "            for formula in formulas[1::2]\n",
        "        ])\n",
        "        gen_form = OldTex(\"{\\\\pi^n \\\\over n!}\", \"R^{2n}\")\n",
        "        gen_form[0].set_color(BLUE_B)\n",
        "        gen_form.scale(1.5)\n",
        "        gen_form.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            formulas[::2].set_opacity, 0.25,\n",
        "            ReplacementTransform(title, alt_title)\n",
        "        )\n",
        "        for brace in braces[:3]:\n",
        "            self.play(GrowFromCenter(brace))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(braces[:3]),\n",
        "            FadeIn(gen_form, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RepeatedSamplesGame(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "# Old scenes, before decision to collaborate with numberphile\n",
        "class IntroduceGame(HyperdartScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 0,\n",
        "        \"square_width\": 5,\n",
        "        \"num_darts_in_initial_flurry\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_flurry_of_points()\n",
        "        self.show_board_dimensions()\n",
        "        self.introduce_bullseye()\n",
        "        self.show_miss_example()\n",
        "        self.show_shrink_rule()\n",
        "\n",
        "    def show_flurry_of_points(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "\n",
        "        title = OldTexText(\"Hyperdarts\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        n = self.num_darts_in_initial_flurry\n",
        "        points = np.random.normal(size=n * 3).reshape((n, 3))\n",
        "        points[:, 2] = 0\n",
        "        points *= 0.75\n",
        "\n",
        "        board = Dartboard()\n",
        "        board.match_width(square)\n",
        "        board.move_to(square)\n",
        "\n",
        "        pre_square = Circle(color=WHITE)\n",
        "        pre_square.replace(square)\n",
        "\n",
        "        self.remove(circle, square)\n",
        "        self.add(board)\n",
        "\n",
        "        darts, dots = self.show_hits_with_darts(\n",
        "            points,\n",
        "            added_anims=[FadeInFromDown(title)]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        def func(p):\n",
        "            theta = angle_of_vector(p) % (TAU / 4)\n",
        "            if theta > TAU / 8:\n",
        "                theta = TAU / 4 - theta\n",
        "            p *= 1 / np.cos(theta)\n",
        "            return p\n",
        "\n",
        "        self.play(\n",
        "            *[\n",
        "                ApplyPointwiseFunction(func, pieces, run_time=1)\n",
        "                for pieces in [*board[:3], *dots]\n",
        "            ],\n",
        "            *[\n",
        "                MaintainPositionRelativeTo(dart, dot)\n",
        "                for dart, dot in zip(darts, dots)\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.flurry_dots = dots\n",
        "        self.darts = darts\n",
        "        self.title = title\n",
        "        self.board = board\n",
        "\n",
        "    def show_board_dimensions(self):\n",
        "        square = self.square\n",
        "\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\"2 ft\").next_to(\n",
        "                square.get_edge_center(vect), vect,\n",
        "            )\n",
        "            for vect in [DOWN, RIGHT]\n",
        "        ])\n",
        "        labels.set_color(YELLOW)\n",
        "\n",
        "        h_line, v_line = lines = VGroup(*[\n",
        "            DashedLine(\n",
        "                square.get_edge_center(v1),\n",
        "                square.get_edge_center(-v1),\n",
        "            ).next_to(label, v2)\n",
        "            for label, v1, v2 in zip(labels, [LEFT, UP], [UP, LEFT])\n",
        "        ])\n",
        "        lines.match_color(labels)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, lines),\n",
        "            LaggedStartMap(FadeInFromDown, labels),\n",
        "            lag_ratio=0.5\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.square_dimensions = VGroup(lines, labels)\n",
        "\n",
        "    def introduce_bullseye(self):\n",
        "        square = self.square\n",
        "        circle = self.circle\n",
        "        board = self.board\n",
        "        circle.save_state()\n",
        "        circle.replace(board[-1])\n",
        "\n",
        "        label = OldTexText(\"Bullseye\")\n",
        "        label.scale(1.5)\n",
        "        label.next_to(square, LEFT, aligned_edge=UP)\n",
        "        label.set_color(RED)\n",
        "        arrow = Arrow(\n",
        "            label.get_bottom(),\n",
        "            circle.get_corner(DR)\n",
        "        )\n",
        "\n",
        "        radius = DashedLine(\n",
        "            square.get_center(),\n",
        "            square.get_left(),\n",
        "            stroke_width=2,\n",
        "        )\n",
        "        radius_label = OldTexText(\"1 ft\")\n",
        "        radius_label.next_to(radius, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(circle, self.square_dimensions)\n",
        "        self.play(\n",
        "            FadeInFromLarge(circle),\n",
        "            FadeInFromDown(label),\n",
        "            ShowCreation(arrow),\n",
        "            LaggedStartMap(FadeOut, self.flurry_dots, run_time=1),\n",
        "            LaggedStartMap(FadeOut, self.darts, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(square, board, arrow, circle)\n",
        "        self.play(\n",
        "            Restore(circle),\n",
        "            ApplyMethod(\n",
        "                arrow.scale, 0.4,\n",
        "                {\"about_point\": arrow.get_start()}\n",
        "            ),\n",
        "        )\n",
        "        self.add(radius, self.circle_center_dot)\n",
        "        self.play(\n",
        "            ShowCreation(radius),\n",
        "            FadeIn(radius_label, RIGHT),\n",
        "            FadeIn(self.circle_center_dot),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(label),\n",
        "            Uncreate(arrow),\n",
        "            FadeOut(board)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        s_lines, s_labels = self.square_dimensions\n",
        "        self.play(\n",
        "            FadeOut(s_lines),\n",
        "            FadeOut(radius),\n",
        "            FadeOut(radius_label),\n",
        "            FadeOut(self.title),\n",
        "        )\n",
        "\n",
        "        self.circle_dimensions = VGroup(\n",
        "            radius, radius_label,\n",
        "        )\n",
        "\n",
        "    def show_miss_example(self):\n",
        "        square = self.square\n",
        "        point = square.get_corner(UL) + 0.5 * DR\n",
        "\n",
        "        miss_word = OldTexText(\"Miss!\")\n",
        "        miss_word.scale(1.5)\n",
        "        miss_word.next_to(point, UP, LARGE_BUFF)\n",
        "\n",
        "        dart, dot = self.show_hit_with_dart(point)\n",
        "        self.play(FadeInFromDown(miss_word))\n",
        "        self.wait()\n",
        "        game_over = self.show_game_over()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *map(FadeOut, [dart, dot, miss_word, game_over])\n",
        "        )\n",
        "\n",
        "    def show_shrink_rule(self):\n",
        "        circle = self.circle\n",
        "        point = 0.5 * circle.point_from_proportion(0.2)\n",
        "\n",
        "        # First example\n",
        "        self.show_full_hit_process(point)\n",
        "        self.wait()\n",
        "\n",
        "        # Close to border\n",
        "        label = OldTexText(\"Bad shot $\\\\Rightarrow$ much shrinkage\")\n",
        "        label.scale(1.5)\n",
        "        label.to_edge(UP)\n",
        "\n",
        "        point = 0.98 * circle.point_from_proportion(3 / 8)\n",
        "        circle.save_state()\n",
        "        self.play(FadeInFromDown(label))\n",
        "        self.show_full_hit_process(point)\n",
        "        self.wait()\n",
        "        self.play(Restore(circle))\n",
        "\n",
        "        # Close to center\n",
        "        new_label = OldTexText(\"Good shot $\\\\Rightarrow$ less shrinkage\")\n",
        "        new_label.scale(1.5)\n",
        "        new_label.to_edge(UP)\n",
        "        point = 0.2 * circle.point_from_proportion(3 / 8)\n",
        "        self.play(\n",
        "            FadeInFromDown(new_label),\n",
        "            FadeOut(label, UP),\n",
        "        )\n",
        "        self.show_full_hit_process(point)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(new_label))\n",
        "\n",
        "        # Play on\n",
        "        for x in range(3):\n",
        "            r1, r2 = np.random.random(size=2)\n",
        "            point = r1 * circle.point_from_proportion(r2)\n",
        "            self.show_full_hit_process(point)\n",
        "        point = circle.get_right() + 0.5 * UR\n",
        "        self.show_miss(point)\n",
        "        self.wait()\n",
        "        self.show_game_over()\n",
        "\n",
        "\n",
        "class ShowScoring(HyperdartScene):\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        self.add_score_counter()\n",
        "\n",
        "    def construct(self):\n",
        "        self.comment_on_score()\n",
        "        self.show_several_hits()\n",
        "\n",
        "    def comment_on_score(self):\n",
        "        score_label = self.score_label\n",
        "        comment = OldTexText(\"\\\\# Bullseyes\")\n",
        "        # rect = SurroundingRectangle(comment)\n",
        "        # rect.set_stroke(width=1)\n",
        "        # comment.add(rect)\n",
        "        comment.set_color(YELLOW)\n",
        "        comment.next_to(score_label, DOWN, LARGE_BUFF)\n",
        "        comment.set_x(midpoint(\n",
        "            self.square.get_left(),\n",
        "            LEFT_SIDE,\n",
        "        )[0])\n",
        "        arrow = Arrow(\n",
        "            comment.get_top(),\n",
        "            score_label[1].get_bottom(),\n",
        "            buff=0.2,\n",
        "        )\n",
        "        arrow.match_color(comment)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(comment),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "\n",
        "    def show_several_hits(self):\n",
        "        points = [UR, DL, 0.5 * UL, 0.5 * DR]\n",
        "        for point in points:\n",
        "            self.show_full_hit_process(point, pace=\"fast\")\n",
        "        self.show_miss(2 * UR)\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def add_score_counter(self):\n",
        "        score = Integer(0)\n",
        "        score_label = VGroup(\n",
        "            OldTexText(\"Score: \"),\n",
        "            score\n",
        "        )\n",
        "        score_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        score_label.scale(1.5)\n",
        "        score_label.to_corner(UL)\n",
        "\n",
        "        self.add(score_label)\n",
        "\n",
        "        self.score = score\n",
        "        self.score_label = score_label\n",
        "\n",
        "    def increment_score(self):\n",
        "        score = self.score\n",
        "        new_score = score.copy()\n",
        "        new_score.increment_value(1)\n",
        "        self.play(\n",
        "            FadeOut(score, UP),\n",
        "            FadeIn(new_score, DOWN),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.remove(new_score)\n",
        "        score.increment_value()\n",
        "        score.move_to(new_score)\n",
        "        self.add(score)\n",
        "\n",
        "    def show_hit(self, point, *args, **kwargs):\n",
        "        result = super().show_hit(point, *args, **kwargs)\n",
        "        if self.is_inside(point):\n",
        "            self.increment_score()\n",
        "        return result\n",
        "\n",
        "    def show_hit_with_dart(self, point, *args, **kwargs):\n",
        "        result = super().show_hit_with_dart(point, *args, **kwargs)\n",
        "        if self.is_inside(point):\n",
        "            self.increment_score()\n",
        "        return result\n",
        "\n",
        "\n",
        "class ShowSeveralRounds(ShowScoring):\n",
        "    CONFIG = {\n",
        "        \"n_rounds\": 5,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        for x in range(self.n_rounds):\n",
        "            self.show_single_round()\n",
        "            self.reset_board()\n",
        "\n",
        "    def show_single_round(self, pace=\"fast\"):\n",
        "        while True:\n",
        "            point = self.get_random_point()\n",
        "            if self.is_inside(point):\n",
        "                self.show_full_hit_process(point, pace=pace)\n",
        "            else:\n",
        "                to_fade = self.show_miss(point)\n",
        "                self.wait(0.5)\n",
        "                self.play(\n",
        "                    ShowCreationThenFadeAround(self.score_label),\n",
        "                    FadeOut(to_fade)\n",
        "                )\n",
        "                return\n",
        "\n",
        "    def reset_board(self):\n",
        "        score = self.score\n",
        "        new_score = score.copy()\n",
        "        new_score.set_value(0)\n",
        "        self.play(\n",
        "            self.circle.match_width, self.square,\n",
        "            FadeOut(score, UP),\n",
        "            FadeIn(new_score, DOWN),\n",
        "        )\n",
        "        score.set_value(0)\n",
        "        self.add(score)\n",
        "        self.remove(new_score)\n",
        "\n",
        "\n",
        "class ShowSeveralRoundsQuickly(ShowSeveralRounds):\n",
        "    CONFIG = {\n",
        "        \"n_rounds\": 15,\n",
        "    }\n",
        "\n",
        "    def show_full_hit_process(self, point, *args, **kwargs):\n",
        "        lines = self.get_all_hit_lines(point)\n",
        "\n",
        "        dart = self.show_hit_with_dart(point)\n",
        "        self.add(lines)\n",
        "        self.score.increment_value(1)\n",
        "        to_fade = self.show_circle_shrink(lines[1], pace=\"fast\")\n",
        "        to_fade.add(*lines, *dart)\n",
        "        self.play(FadeOut(to_fade), run_time=0.5)\n",
        "\n",
        "    def increment_score(self):\n",
        "        pass  # Handled elsewhere\n",
        "\n",
        "\n",
        "class ShowSeveralRoundsVeryQuickly(ShowSeveralRoundsQuickly):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ShowUniformDistribution(HyperdartScene):\n",
        "    CONFIG = {\n",
        "        \"dart_sound\": \"dart_high\",\n",
        "        \"n_points\": 1000,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_random_points()\n",
        "        self.exchange_titles()\n",
        "        self.show_random_points()\n",
        "\n",
        "    def get_square(self):\n",
        "        return super().get_square().to_edge(DOWN)\n",
        "\n",
        "    def add_title(self):\n",
        "        # square = self.square\n",
        "        title = OldTexText(\"All points in the square are equally likely\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        new_title = OldTexText(\"``Uniform distribution'' on the square\")\n",
        "        new_title.scale(1.5)\n",
        "        new_title.to_edge(UP)\n",
        "\n",
        "        self.play(FadeInFromDown(title))\n",
        "\n",
        "        self.title = title\n",
        "        self.new_title = new_title\n",
        "\n",
        "    def show_random_points(self):\n",
        "        points = self.get_random_points(self.n_points)\n",
        "        dots = VGroup(*[\n",
        "            Dot(point, radius=0.02)\n",
        "            for point in points\n",
        "        ])\n",
        "        dots.set_fill(opacity=0.75)\n",
        "\n",
        "        run_time = 5\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeInFromLarge, dots,\n",
        "            run_time=run_time,\n",
        "        ))\n",
        "        for x in range(1000):\n",
        "            self.add_dart_sound(\n",
        "                time_offset=-run_time * np.random.random(),\n",
        "                gain=-10,\n",
        "                gain_to_background=-5,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def exchange_titles(self):\n",
        "        self.play(\n",
        "            FadeInFromDown(self.new_title),\n",
        "            FadeOut(self.title, UP),\n",
        "        )\n",
        "\n",
        "\n",
        "class ExpectedScoreEqualsQMark(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTexText(\n",
        "            \"\\\\textbf{E}[Score] = ???\",\n",
        "            tex_to_color_map={\n",
        "                \"???\": YELLOW,\n",
        "            }\n",
        "        )\n",
        "        aka = OldTexText(\"a.k.a. Long-term average\")\n",
        "        aka.next_to(equation, DOWN)\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(aka, UP))\n",
        "        self.wait()\n",
        "\n"
    ]
}