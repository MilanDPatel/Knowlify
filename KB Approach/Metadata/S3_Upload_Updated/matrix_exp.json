{
    "topic": "demonstrates the mathematical concept of matrix exponential.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "def get_matrix_exponential(matrix, height=1.5, scalar_tex=\"t\", **matrix_config):\n",
        "    elem = matrix[0][0]\n",
        "    if isinstance(elem, str):\n",
        "        mat_class = Matrix\n",
        "    elif isinstance(elem, int) or isinstance(elem, np.int64):\n",
        "        mat_class = IntegerMatrix\n",
        "    else:\n",
        "        mat_class = DecimalMatrix\n",
        "\n",
        "    matrix = mat_class(matrix, **matrix_config)\n",
        "    base = OldTex(\"e\")\n",
        "    base.set_height(0.4 * height)\n",
        "    matrix.set_height(0.6 * height)\n",
        "    matrix.move_to(base.get_corner(UR), DL)\n",
        "    result = VGroup(base, matrix)\n",
        "    if scalar_tex:\n",
        "        scalar = OldTex(scalar_tex)\n",
        "        scalar.set_height(0.7 * base.get_height())\n",
        "        scalar.next_to(matrix, RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "        result.add(scalar)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_vector_field_and_stream_lines(\n",
        "    func, coordinate_system,\n",
        "    magnitude_range=(0.5, 4),\n",
        "    vector_opacity=0.75,\n",
        "    vector_thickness=0.03,\n",
        "    color_by_magnitude=False,\n",
        "    line_color=GREY_A,\n",
        "    line_width=3,\n",
        "    line_opacity=0.75,\n",
        "    sample_freq=5,\n",
        "    n_samples_per_line=10,\n",
        "    arc_len=3,\n",
        "    time_width=0.3,\n",
        "):\n",
        "    vector_field = VectorField(\n",
        "        func, coordinate_system,\n",
        "        magnitude_range=magnitude_range,\n",
        "        vector_config={\n",
        "            \"fill_opacity\": vector_opacity,\n",
        "            \"thickness\": vector_thickness,\n",
        "        }\n",
        "    )\n",
        "    stream_lines = StreamLines(\n",
        "        func, coordinate_system,\n",
        "        step_multiple=1.0 / sample_freq,\n",
        "        n_samples_per_line=n_samples_per_line,\n",
        "        arc_len=arc_len,\n",
        "        magnitude_range=magnitude_range,\n",
        "        color_by_magnitude=color_by_magnitude,\n",
        "        stroke_color=line_color,\n",
        "        stroke_width=line_width,\n",
        "        stroke_opacity=line_opacity,\n",
        "    )\n",
        "    animated_lines = AnimatedStreamLines(\n",
        "        stream_lines,\n",
        "        line_anim_config={\n",
        "            \"time_width\": time_width,\n",
        "        },\n",
        "    )\n",
        "\n",
        "    return vector_field, animated_lines\n",
        "\n",
        "\n",
        "def mat_exp(matrix, N=100):\n",
        "    curr = np.identity(len(matrix))\n",
        "    curr_sum = curr\n",
        "    for n in range(1, N):\n",
        "        curr = np.dot(curr, matrix) / n\n",
        "        curr_sum += curr\n",
        "    return curr_sum\n",
        "\n",
        "\n",
        "def get_1d_equation(r=\"r\"):\n",
        "    return OldTex(\n",
        "        \"{d \\\\over d{t}} x({t}) = {\" + r + \"} \\\\cdot x({t})\",\n",
        "        tex_to_color_map={\n",
        "            \"{t}\": GREY_B,\n",
        "            \"{\" + r + \"}\": BLUE,\n",
        "            \"=\": WHITE,\n",
        "        }\n",
        "    )\n",
        "\n",
        "\n",
        "def get_2d_equation(matrix=[[\"a\", \"b\"], [\"c\", \"d\"]]):\n",
        "    deriv = OldTex(\"d \\\\over dt\", tex_to_color_map={\"t\": GREY_B})\n",
        "    vect = Matrix(\n",
        "        [[\"x(t)\"], [\"y(t)\"]],\n",
        "        bracket_h_buff=SMALL_BUFF,\n",
        "        bracket_v_buff=SMALL_BUFF,\n",
        "        element_to_mobject_config={\n",
        "            \"tex_to_color_map\": {\"t\": GREY_B},\n",
        "            \"isolate\": [\"(\", \")\"]\n",
        "        }\n",
        "    )\n",
        "    deriv.match_height(vect)\n",
        "    equals = OldTex(\"=\")\n",
        "    matrix_mob = Matrix(matrix, h_buff=0.8)\n",
        "    matrix_mob.set_color(TEAL)\n",
        "    matrix_mob.match_height(vect)\n",
        "    equation = VGroup(deriv, vect, equals, matrix_mob, vect.deepcopy())\n",
        "    equation.arrange(RIGHT)\n",
        "    return equation\n",
        "\n",
        "\n",
        "class VideoWrapper(Scene):\n",
        "    title = \"\"\n",
        "\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screen_rect = ScreenRectangle(height=6)\n",
        "        screen_rect.set_stroke(BLUE_D, 1)\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        screen_rect.to_edge(DOWN)\n",
        "        self.add(screen_rect)\n",
        "\n",
        "        title = OldTexText(self.title, font_size=90)\n",
        "        if title.get_width() > screen_rect.get_width():\n",
        "            title.set_width(screen_rect.get_width())\n",
        "        title.next_to(screen_rect, UP)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Video scenes\n",
        "\n",
        "class ArnoldBookClip(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ZoomInOnProblem(Scene):\n",
        "    def construct(self):\n",
        "        # Highlight problem\n",
        "        image = ImageMobject(\"mat_exp_exercise.png\")\n",
        "        image.set_height(FRAME_HEIGHT)\n",
        "\n",
        "        prob_rect = Rectangle(3.25, 0.35)\n",
        "        prob_rect.move_to([-2.5, -2.5, 0])\n",
        "        prob_rect.set_stroke(BLUE, 2)\n",
        "\n",
        "        examples_rect = Rectangle(2.0, 0.8)\n",
        "        examples_rect.move_to([01.8, 2.8, 0.0])\n",
        "        examples_rect.set_stroke(YELLOW, 3)\n",
        "        answer_rect = Rectangle(3.0, 2.0)\n",
        "        answer_rect.move_to(examples_rect, UR)\n",
        "        answer_rect.shift(0.1 * RIGHT)\n",
        "\n",
        "        full_rect = FullScreenRectangle()\n",
        "        full_rect.flip()\n",
        "        full_rect.set_fill(BLACK, opacity=0.6)\n",
        "        full_rect.append_vectorized_mobject(prob_rect)\n",
        "        full_rect2 = full_rect.copy()\n",
        "        full_rect3 = full_rect.copy()\n",
        "        full_rect.append_vectorized_mobject(examples_rect.copy().scale(1e-6))\n",
        "        full_rect2.append_vectorized_mobject(examples_rect)\n",
        "        full_rect3.append_vectorized_mobject(answer_rect)\n",
        "\n",
        "        self.add(image)\n",
        "\n",
        "        # Write problem\n",
        "        problem = OldTexText(\n",
        "            \"Compute the {{matrix}} {{$e^{At}$}}\\\\\\\\if the {{matrix A}} has the form...\"\n",
        "        )\n",
        "        problem.to_corner(UL)\n",
        "        problem.set_stroke(BLACK, 5, background=True)\n",
        "        prob_arrow = Arrow(prob_rect, problem)\n",
        "        prob_arrow.set_fill(BLUE)\n",
        "        mat_underline = Underline(problem.get_part_by_tex(\"matrix\"))\n",
        "        mat_underline.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(prob_rect),\n",
        "            FadeIn(full_rect),\n",
        "            FadeTransform(prob_rect.copy(), problem),\n",
        "            GrowArrow(prob_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        for part in [\"e^{At}\", \"matrix A\"]:\n",
        "            self.play(FlashAround(problem.get_part_by_tex(part), run_time=2, time_width=4))\n",
        "            self.wait()\n",
        "        self.play(ShowCreation(mat_underline))\n",
        "        self.wait()\n",
        "        mat_underline.rotate(PI)\n",
        "        self.play(Uncreate(mat_underline))\n",
        "        self.wait()\n",
        "\n",
        "        # Show inputs\n",
        "        examples_label = OldTexText(\"Various matrices to\\\\\\\\plug in for $A$\", font_size=40)\n",
        "        examples_label.next_to(examples_rect)\n",
        "\n",
        "        lhs = OldTex(\"A = \", font_size=96)\n",
        "        lhs.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        matrices = VGroup(\n",
        "            IntegerMatrix([[1, 0], [0, 2]]),\n",
        "            IntegerMatrix([[0, 1], [0, 0]]),\n",
        "            IntegerMatrix([[0, 1], [-1, 0]]),\n",
        "            IntegerMatrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]]),\n",
        "        )\n",
        "        eq = VGroup(lhs, matrices[-1])\n",
        "        eq.arrange(RIGHT)\n",
        "        eq.next_to(examples_rect, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "        eq.shift_onto_screen()\n",
        "        for matrix in matrices:\n",
        "            matrix.move_to(matrices[-1], LEFT)\n",
        "            matrix.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(\n",
        "            Transform(full_rect, full_rect2)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(examples_rect),\n",
        "            FadeIn(examples_label),\n",
        "            FadeIn(lhs),\n",
        "            FadeIn(matrices[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        for m1, m2 in zip(matrices, matrices[1:]):\n",
        "            self.play(FadeTransform(m1, m2))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class LeadToPhysicsAndQM(Scene):\n",
        "    def construct(self):\n",
        "        de_words = OldTexText(\"Differential\\\\\\\\equations\", font_size=60)\n",
        "        de_words.set_x(-3).to_edge(UP)\n",
        "        mat_exp = get_matrix_exponential([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\n",
        "        mat_exp[1].set_color(TEAL)\n",
        "        mat_exp.next_to(de_words, DOWN, buff=3)\n",
        "\n",
        "        qm_words = OldTexText(\"Quantum\\\\\\\\mechanics\", font_size=60)\n",
        "        qm_words.set_x(3).to_edge(UP)\n",
        "        physics_words = OldTexText(\"Physics\", font_size=60)\n",
        "        physics_words.move_to(qm_words)\n",
        "\n",
        "        qm_exp = OldTex(\"e^{-i \\\\hat{H} t / \\\\hbar}\")\n",
        "        qm_exp.scale(2)\n",
        "        qm_exp.refresh_bounding_box()\n",
        "        qm_exp[0][0].set_height(mat_exp[0].get_height(), about_edge=UR)\n",
        "        qm_exp[0][0].shift(SMALL_BUFF * DOWN)\n",
        "        qm_exp.match_x(qm_words)\n",
        "        qm_exp.align_to(mat_exp, DOWN)\n",
        "        qm_exp[0][3:5].set_color(TEAL)\n",
        "\n",
        "        de_arrow = Arrow(de_words, mat_exp)\n",
        "        qm_arrow = Arrow(qm_words, qm_exp)\n",
        "        top_arrow = Arrow(de_words, qm_words)\n",
        "\n",
        "        self.add(de_words)\n",
        "        self.play(\n",
        "            GrowArrow(de_arrow),\n",
        "            FadeIn(mat_exp, shift=DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(top_arrow),\n",
        "            FadeIn(physics_words, RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(physics_words, UP),\n",
        "            FadeIn(qm_words, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformFromCopy(de_arrow, qm_arrow),\n",
        "            FadeTransform(mat_exp.copy(), qm_exp),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LaterWrapper(VideoWrapper):\n",
        "    title = \"Later...\"\n",
        "\n",
        "\n",
        "class PlanForThisVideo(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        s0, s1, s2 = self.students\n",
        "        self.play(\n",
        "            PiCreatureSays(s0, OldTexText(\"But what\\\\\\\\is $e^{M}$?\"), target_mode=\"raise_left_hand\"),\n",
        "            s1.change(\"erm\", UL),\n",
        "            s2.change(\"pondering\", UL),\n",
        "        )\n",
        "        self.wait()\n",
        "        s0.bubble = None\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                s2, OldTexText(\"And who cares?\"), target_mode=\"sassy\",\n",
        "                bubble_config={\"direction\": LEFT},\n",
        "            ),\n",
        "            s1.change(\"hesitant\", UL),\n",
        "            self.teacher.change(\"guilty\")\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class IntroduceTheComputation(Scene):\n",
        "    def construct(self):\n",
        "        # Matrix in exponent\n",
        "        base = OldTex(\"e\")\n",
        "        base.set_height(1.0)\n",
        "        matrix = IntegerMatrix(\n",
        "            [[3, 1, 4],\n",
        "             [1, 5, 9],\n",
        "             [2, 6, 5]],\n",
        "        )\n",
        "        matrix.move_to(base.get_corner(UR), DL)\n",
        "        matrix_exp = VGroup(base, matrix)\n",
        "        matrix_exp.set_height(2)\n",
        "        matrix_exp.to_corner(UL)\n",
        "        matrix_exp.shift(3 * RIGHT)\n",
        "\n",
        "        randy = Randolph()\n",
        "        randy.set_height(2)\n",
        "        randy.to_corner(DL)\n",
        "\n",
        "        matrix.save_state()\n",
        "        matrix.center()\n",
        "        matrix.set_height(2.5)\n",
        "\n",
        "        self.add(randy)\n",
        "        self.play(\n",
        "            randy.change(\"pondering\", matrix),\n",
        "            Write(matrix.get_brackets()),\n",
        "            ShowIncreasingSubsets(matrix.get_entries()),\n",
        "        )\n",
        "        self.play(\n",
        "            matrix.animate.restore(),\n",
        "            Write(base),\n",
        "            randy.change(\"erm\", base),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        # Question the repeated multiplication implication\n",
        "        rhs = OldTex(\"= e \\\\cdot e \\\\dots e \\\\cdot e\")\n",
        "        rhs.set_height(0.75 * base.get_height())\n",
        "        rhs.next_to(matrix_exp, RIGHT)\n",
        "        rhs.align_to(base, DOWN)\n",
        "        brace = Brace(rhs[0][1:], DOWN)\n",
        "        matrix_copy = matrix.copy()\n",
        "        matrix_copy.scale(0.5)\n",
        "        brace_label = VGroup(\n",
        "            matrix.copy().scale(0.5),\n",
        "            Text(\"times?\")\n",
        "        )\n",
        "        brace_label.arrange(RIGHT)\n",
        "        brace_label.next_to(brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        bubble = randy.get_bubble(\n",
        "            OldTexText(\"I'm sorry,\\\\\\\\what?!\").scale(0.75),\n",
        "            height=2,\n",
        "            width=3,\n",
        "            bubble_type=SpeechBubble,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingParts(\n",
        "                base.copy(), rhs,\n",
        "                path_arc=10 * DEGREES,\n",
        "                lag_ratio=0.01,\n",
        "            ),\n",
        "            GrowFromCenter(brace),\n",
        "            ReplacementTransform(\n",
        "                matrix.copy(), brace_label[0],\n",
        "                path_arc=30 * DEGREES,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.3, 1),\n",
        "            ),\n",
        "            Write(\n",
        "                brace_label[1],\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.5, 1),\n",
        "            ),\n",
        "            randy.change(\"angry\", rhs),\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        false_equation = VGroup(\n",
        "            matrix_exp, rhs, brace, brace_label\n",
        "        )\n",
        "\n",
        "        # This is nonsense.\n",
        "        morty = Mortimer()\n",
        "        morty.refresh_triangulation()\n",
        "        morty.match_height(randy)\n",
        "        morty.to_corner(DR)\n",
        "        morty.set_opacity(0)\n",
        "        false_equation.generate_target()\n",
        "        false_equation.target.scale(0.5)\n",
        "        false_equation.target.next_to(morty, UL)\n",
        "        fe_rect = SurroundingRectangle(false_equation.target)\n",
        "        fe_rect.set_color(GREY_BROWN)\n",
        "        cross = Cross(false_equation.target[1])\n",
        "        cross.insert_n_curves(1)\n",
        "        cross.set_stroke(RED, width=[1, 5, 1])\n",
        "        nonsense = Text(\"This would be nonsense\")\n",
        "        nonsense.match_width(fe_rect)\n",
        "        nonsense.next_to(fe_rect, UP)\n",
        "        nonsense.set_color(RED)\n",
        "\n",
        "        randy.bubble = bubble\n",
        "        self.play(\n",
        "            MoveToTarget(false_equation),\n",
        "            RemovePiCreatureBubble(randy, target_mode=\"hesitant\"),\n",
        "            morty.animate.set_opacity(1).change(\"raise_right_hand\"),\n",
        "            ShowCreation(fe_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            FadeIn(nonsense),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        false_group = VGroup(false_equation, fe_rect, cross, nonsense)\n",
        "\n",
        "        # Show Taylor series\n",
        "        real_equation = OldTex(\n",
        "            \"e^x = x^0 + x^1 + \\\\frac{1}{2} x^2 + \\\\frac{1}{6} x^3 + \\\\cdots + \\\\frac{1}{n!} x^n + \\\\cdots\",\n",
        "            isolate=[\"x\"]\n",
        "        )\n",
        "        xs = real_equation.get_parts_by_tex(\"x\")\n",
        "        xs.set_color(YELLOW)\n",
        "        real_equation.set_width(FRAME_WIDTH - 2.0)\n",
        "        real_equation.to_edge(UP)\n",
        "        real_rhs = real_equation[3:]\n",
        "\n",
        "        real_label = Text(\"Real number\", color=YELLOW, font_size=24)\n",
        "        # real_label.next_to(xs[0], DOWN, buff=0.8)\n",
        "        # real_label.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        # real_arrow = Arrow(real_label, xs[0], buff=0.1, fill_color=GREY_B, thickness=0.025)\n",
        "        real_label.to_corner(UL, buff=MED_SMALL_BUFF)\n",
        "        real_arrow = Arrow(real_label, real_equation[1], buff=0.1)\n",
        "\n",
        "        taylor_brace = Brace(real_rhs, DOWN)\n",
        "        taylor_label = taylor_brace.get_text(\"Taylor series\")\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(base, real_equation[0]),\n",
        "            FadeTransform(matrix.copy(), real_equation[1]),\n",
        "            FadeIn(real_label, UR),\n",
        "            GrowArrow(real_arrow),\n",
        "            randy.change(\"thinking\", real_label),\n",
        "            morty.animate.look_at(real_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(real_equation[2], lag_ratio=0.2),\n",
        "            FadeTransformPieces(xs[:1].copy(), xs[1:], path_arc=20 * DEGREES),\n",
        "            LaggedStart(*(\n",
        "                FadeIn(part)\n",
        "                for part in real_equation[4:]\n",
        "                if part not in xs\n",
        "            )),\n",
        "            randy.change(\"pondering\", real_equation),\n",
        "            morty.change(\"pondering\", real_equation),\n",
        "        )\n",
        "        self.add(real_equation)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            false_group.animate.scale(0.7).to_edge(DOWN),\n",
        "            GrowFromCenter(taylor_brace),\n",
        "            FadeIn(taylor_label, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Taylor series example\n",
        "        ex_rhs = OldTex(\n",
        "            \"\"\"\n",
        "            {2}^0 +\n",
        "            {2}^1 +\n",
        "            { {2}^2 \\\\over 2} +\n",
        "            { {2}^3 \\\\over 6} +\n",
        "            { {2}^4 \\\\over 24} +\n",
        "            { {2}^5 \\\\over 120} +\n",
        "            { {2}^6 \\\\over 720} +\n",
        "            { {2}^7 \\\\over 5040} +\n",
        "            \\\\cdots\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\"{2}\": YELLOW, \"+\": WHITE},\n",
        "        )\n",
        "        ex_rhs.next_to(real_equation[3:], DOWN, buff=0.75)\n",
        "\n",
        "        ex_parts = VGroup(*(\n",
        "            ex_rhs[i:j] for i, j in [\n",
        "                (0, 2),\n",
        "                (3, 5),\n",
        "                (6, 8),\n",
        "                (9, 11),\n",
        "                (12, 14),\n",
        "                (15, 17),\n",
        "                (18, 20),\n",
        "                (21, 23),\n",
        "                (24, 25),\n",
        "            ]\n",
        "        ))\n",
        "        term_brace = Brace(ex_parts[0], DOWN)\n",
        "        frac = OldTex(\"1\", font_size=36)\n",
        "        frac.next_to(term_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        rects = VGroup(*(\n",
        "            Rectangle(height=2**n / math.factorial(n), width=1)\n",
        "            for n in range(11)\n",
        "        ))\n",
        "        rects.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "        rects.set_fill(opacity=1)\n",
        "        rects.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        rects.set_width(7)\n",
        "        rects.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(taylor_brace, term_brace),\n",
        "            FadeTransform(real_equation[3:].copy(), ex_rhs),\n",
        "            FadeOut(false_group, shift=DOWN),\n",
        "            FadeOut(taylor_label, shift=DOWN),\n",
        "            FadeIn(frac),\n",
        "        )\n",
        "        term_values = VGroup()\n",
        "        for n in range(11):\n",
        "            rect = rects[n]\n",
        "            fact = math.factorial(n)\n",
        "            ex_part = ex_parts[min(n, len(ex_parts) - 1)]\n",
        "            value = DecimalNumber(2**n / fact)\n",
        "            value.set_color(GREY_A)\n",
        "            max_width = 0.6 * rect.get_width()\n",
        "            if value.get_width() > max_width:\n",
        "                value.set_width(max_width)\n",
        "            value.next_to(rects[n], UP, SMALL_BUFF)\n",
        "            new_brace = Brace(ex_part, DOWN)\n",
        "            if fact == 1:\n",
        "                new_frac = OldTex(f\"{2**n}\", font_size=36)\n",
        "            else:\n",
        "                new_frac = OldTex(f\"{2**n} / {fact}\", font_size=36)\n",
        "            new_frac.next_to(new_brace, DOWN, SMALL_BUFF)\n",
        "            self.play(\n",
        "                term_brace.animate.become(new_brace),\n",
        "                FadeTransform(frac, new_frac),\n",
        "            )\n",
        "            frac = new_frac\n",
        "            rect.save_state()\n",
        "            rect.stretch(0, 1, about_edge=DOWN)\n",
        "            rect.set_opacity(0)\n",
        "            value.set_value(0)\n",
        "            self.play(\n",
        "                Restore(rect),\n",
        "                ChangeDecimalToValue(value, 2**n / math.factorial(n)),\n",
        "                UpdateFromAlphaFunc(value, lambda m, a: m.next_to(rect, UP, SMALL_BUFF).set_opacity(a)),\n",
        "                randy.animate.look_at(rect),\n",
        "                morty.animate.look_at(rect),\n",
        "            )\n",
        "            term_values.add(value)\n",
        "        self.play(FadeOut(frac))\n",
        "\n",
        "        new_brace = Brace(ex_rhs, DOWN)\n",
        "        sum_value = DecimalNumber(math.exp(2), num_decimal_places=4, font_size=36)\n",
        "        sum_value.next_to(new_brace, DOWN)\n",
        "        self.play(\n",
        "            term_brace.animate.become(new_brace),\n",
        "            randy.change(\"thinking\", sum_value),\n",
        "            morty.change(\"tease\", sum_value),\n",
        "            *(FadeTransform(dec.copy().set_opacity(0), sum_value) for dec in term_values)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        lhs = OldTex(\"e \\\\cdot e =\")\n",
        "        lhs.match_height(real_equation[0])\n",
        "        lhs.next_to(ex_rhs, LEFT)\n",
        "        self.play(Write(lhs))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        # Increment input\n",
        "        twos = ex_rhs.get_parts_by_tex(\"{2}\")\n",
        "        threes = VGroup(*(\n",
        "            OldTex(\"3\").set_color(YELLOW).replace(two)\n",
        "            for two in twos\n",
        "        ))\n",
        "        new_lhs = OldTex(\"e \\\\cdot e \\\\cdot e = \")\n",
        "        new_lhs.match_height(lhs)\n",
        "        new_lhs[0].space_out_submobjects(0.8)\n",
        "        new_lhs[0][-1].shift(SMALL_BUFF * RIGHT)\n",
        "        new_lhs.move_to(lhs, RIGHT)\n",
        "\n",
        "        anims = []\n",
        "        unit_height = 0.7 * rects[0].get_height()\n",
        "        for n, rect, value_mob in zip(it.count(0), rects, term_values):\n",
        "            rect.generate_target()\n",
        "            new_value = 3**n / math.factorial(n)\n",
        "            rect.target.set_height(unit_height * new_value, stretch=True, about_edge=DOWN)\n",
        "            value_mob.rect = rect\n",
        "            anims += [\n",
        "                MoveToTarget(rect),\n",
        "                ChangeDecimalToValue(value_mob, new_value),\n",
        "                UpdateFromFunc(value_mob, lambda m: m.next_to(m.rect, UP, SMALL_BUFF))\n",
        "            ]\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(twos, 0.5 * UP),\n",
        "            FadeIn(threes, 0.5 * UP),\n",
        "        )\n",
        "        twos.set_opacity(0)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(sum_value, math.exp(3)),\n",
        "            *anims,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lhs, 0.5 * UP),\n",
        "            FadeIn(new_lhs, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Isolate polynomial\n",
        "        real_lhs = VGroup(real_equation[:3], real_label, real_arrow)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(\n",
        "                *new_lhs, *threes, *ex_rhs,\n",
        "                term_brace, sum_value,\n",
        "                *rects, *term_values,\n",
        "            )),\n",
        "            real_lhs.animate.set_opacity(0.2),\n",
        "            randy.change(\"erm\", real_equation),\n",
        "            morty.change(\"thinking\", real_equation),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        # Alternate inputs\n",
        "        rhs_tex = \"X^0 + X^1 + \\\\frac{1}{2} X^2 + \\\\frac{1}{6} X^3 + \\\\cdots + \\\\frac{1}{n!} X^n + \\\\cdots\"\n",
        "        pii_rhs = OldTex(\n",
        "            rhs_tex.replace(\"X\", \"(\\\\pi i)\"),\n",
        "            tex_to_color_map={\"(\\\\pi i)\": BLUE},\n",
        "        )\n",
        "        pii_rhs.match_width(real_rhs)\n",
        "\n",
        "        mat_tex = \"\\\\left[ \\\\begin{array}{ccc} 3 & 1 & 4 \\\\\\\\ 1 & 5 & 9 \\\\\\\\ 2 & 6 & 5 \\\\end{array} \\\\right]\"\n",
        "        mat_rhs = OldTex(\n",
        "            rhs_tex.replace(\"X\", mat_tex),\n",
        "            tex_to_color_map={mat_tex: TEAL},\n",
        "        )\n",
        "        mat_rhs.scale(0.5)\n",
        "\n",
        "        pii_rhs.next_to(real_rhs, DOWN, buff=0.7)\n",
        "        mat_rhs.next_to(pii_rhs, DOWN, buff=0.7)\n",
        "\n",
        "        self.play(FlashAround(real_rhs))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\", pii_rhs),\n",
        "            FadeTransformPieces(real_rhs.copy(), pii_rhs),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            FadeTransformPieces(real_rhs.copy(), mat_rhs),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change(\"maybe\", mat_rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        why = Text(\"Why?\", font_size=36)\n",
        "        why.next_to(randy, UP, aligned_edge=LEFT)\n",
        "        self.play(\n",
        "            randy.change(\"confused\", mat_rhs.get_corner(UL)),\n",
        "            Write(why),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        reassurance = VGroup(\n",
        "            Text(\"I know it looks complicated.\", font_size=24),\n",
        "            Text(\"Don't panic.\", font_size=24),\n",
        "        )\n",
        "        reassurance.arrange(DOWN)\n",
        "        reassurance.next_to(morty, LEFT, aligned_edge=UP)\n",
        "        reassurance.set_color(GREY_A)\n",
        "\n",
        "        for words in reassurance:\n",
        "            self.play(FadeIn(words))\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        # Describe exp\n",
        "        to_right_group = VGroup(real_lhs, real_rhs, mat_rhs, pii_rhs)\n",
        "        to_right_group.generate_target()\n",
        "        to_right_group.target.to_edge(RIGHT, buff=SMALL_BUFF)\n",
        "        to_right_group.target[2].to_edge(RIGHT, buff=SMALL_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(to_right_group),\n",
        "            FadeOut(why),\n",
        "            FadeOut(reassurance),\n",
        "            randy.change(\"pondering\", mat_rhs),\n",
        "            morty.change(\"tease\"),\n",
        "        )\n",
        "\n",
        "        pii_lhs = OldTex(\"\\\\text{exp}\\\\left(\\\\pi i \\\\right) = \")[0]\n",
        "        pii_lhs.next_to(pii_rhs, LEFT)\n",
        "        mat_lhs = OldTex(\"\\\\text{exp}\\\\left(\" + mat_tex + \"\\\\right) = \")[0]\n",
        "        mat_lhs.match_height(mat_rhs)\n",
        "        mat_lhs[:3].match_height(pii_lhs[:3])\n",
        "        mat_lhs[:3].next_to(mat_lhs[3:5], LEFT, SMALL_BUFF)\n",
        "        mat_lhs.next_to(mat_rhs, LEFT)\n",
        "\n",
        "        pii_lhs_pi_part = pii_lhs[4:6]\n",
        "        pii_lhs_pi_part.set_color(BLUE)\n",
        "        mat_lhs_mat_part = mat_lhs[5:18]\n",
        "        mat_lhs_mat_part.set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pii_lhs),\n",
        "            randy.change(\"thinking\", pii_lhs),\n",
        "            randy.change(\"tease\", pii_lhs),\n",
        "        )\n",
        "        self.play(FadeIn(mat_lhs))\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FlashAround(pii_lhs[:3]),\n",
        "                FlashAround(mat_lhs[:3]),\n",
        "                lag_ratio=0.3,\n",
        "                run_time=2\n",
        "            ),\n",
        "            randy.change(\"raise_left_hand\", pii_lhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to e^x notation\n",
        "        crosses = VGroup(*(\n",
        "            Cross(lhs[:3], stroke_width=[0, 3, 3, 3, 0]).scale(1.3)\n",
        "            for lhs in [pii_lhs, mat_lhs]\n",
        "        ))\n",
        "        bases = VGroup()\n",
        "        powers = VGroup()\n",
        "        equals = VGroup()\n",
        "        for part, lhs in (pii_lhs_pi_part, pii_lhs), (mat_lhs_mat_part, mat_lhs):\n",
        "            power = part.copy()\n",
        "            part.set_opacity(0)\n",
        "            self.add(power)\n",
        "            base = OldTex(\"e\", font_size=60)\n",
        "            equal = OldTex(\":=\")\n",
        "            power.generate_target()\n",
        "            if power.target.get_height() > 0.7:\n",
        "                power.target.set_height(0.7)\n",
        "            power.target.next_to(base, UR, buff=0.05)\n",
        "            group = VGroup(base, power.target, equal)\n",
        "            equal.next_to(group[:2], RIGHT, MED_SMALL_BUFF)\n",
        "            equal.match_y(base)\n",
        "            if lhs is mat_lhs:\n",
        "                equal.shift(0.1 * UP)\n",
        "            group.shift(lhs.get_right() - equal.get_right())\n",
        "            bases.add(base)\n",
        "            powers.add(power)\n",
        "            equals.add(equal)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(crosses),\n",
        "            randy.change(\"hesitant\", crosses),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(real_lhs.animate.set_opacity(1))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(pii_lhs),\n",
        "            FadeOut(mat_lhs),\n",
        "            FadeOut(crosses),\n",
        "            *(MoveToTarget(power) for power in powers),\n",
        "            *(TransformFromCopy(real_equation[0], base) for base in bases),\n",
        "            Write(equals),\n",
        "            randy.change(\"sassy\", powers),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Theorem vs. definition\n",
        "        real_part = VGroup(real_lhs, real_rhs)\n",
        "        pii_part = VGroup(bases[0], powers[0], equals[0], pii_rhs)\n",
        "        mat_part = VGroup(bases[1], powers[1], equals[1], mat_rhs)\n",
        "        def_parts = VGroup(pii_part, mat_part)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(randy, DOWN),\n",
        "            FadeOut(morty, DOWN),\n",
        "            real_part.animate.set_x(0).shift(DOWN),\n",
        "            def_parts.animate.set_x(0).to_edge(DOWN),\n",
        "        )\n",
        "\n",
        "        real_rect = SurroundingRectangle(real_part)\n",
        "        real_rect.set_stroke(YELLOW, 2)\n",
        "        theorem_label = Text(\"Theorem\")\n",
        "        theorem_label.next_to(real_rect, UP)\n",
        "\n",
        "        def_rect = SurroundingRectangle(def_parts)\n",
        "        def_rect.set_stroke(BLUE, 2)\n",
        "        def_label = Text(\"Definition\")\n",
        "        def_label.next_to(def_rect, UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(real_rect),\n",
        "            FadeIn(theorem_label, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(def_rect),\n",
        "            FadeIn(def_label, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Abuse?  Or the beauty of discovery...\n",
        "        randy2 = Randolph()\n",
        "        randy2.set_height(1.5)\n",
        "        randy2.next_to(def_rect, UP, SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(randy2.change, \"angry\", mat_rhs),\n",
        "            UpdateFromAlphaFunc(randy2, lambda m, a: m.set_opacity(a)),\n",
        "        )\n",
        "        self.play(Blink(randy2))\n",
        "\n",
        "        discovery_label = Text(\"Discovery\")\n",
        "        discovery_label.move_to(theorem_label, DOWN)\n",
        "        invention_label = Text(\"Invention\")\n",
        "        invention_label.move_to(def_label, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(theorem_label, UP),\n",
        "            FadeIn(discovery_label, UP),\n",
        "            randy2.change(\"hesitant\", theorem_label),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(def_label, UP),\n",
        "            FadeIn(invention_label, UP),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Isolate matrix right hand side\n",
        "        to_fade = VGroup(\n",
        "            randy2, discovery_label, invention_label,\n",
        "            real_rect, def_rect,\n",
        "            real_arrow, real_label, real_part, pii_part,\n",
        "            bases, powers, equals,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            mat_rhs.animate.set_width(FRAME_WIDTH - 1).center().to_edge(UP),\n",
        "            LaggedStartMap(FadeOut, to_fade),\n",
        "            FadeIn(VGroup(randy, morty), run_time=2, rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "\n",
        "        # Matrix powers\n",
        "        mat = mat_rhs[4]\n",
        "        mat_brace = Brace(VGroup(mat, mat_rhs[5][0]), DOWN, buff=SMALL_BUFF)\n",
        "        matrix = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\n",
        "        matrix_square = np.dot(matrix, matrix)\n",
        "        result = IntegerMatrix(matrix_square, h_buff=1.3, v_buff=0.7)\n",
        "        result.match_height(mat)\n",
        "        square_eq = VGroup(mat.copy(), mat.copy(), OldTex(\"=\"), result)\n",
        "        square_eq.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        square_eq.next_to(mat_brace, DOWN)\n",
        "\n",
        "        self.play(GrowFromCenter(mat_brace))\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(mat, square_eq[0], path_arc=45 * DEGREES),\n",
        "                TransformFromCopy(mat, square_eq[1]),\n",
        "                Write(square_eq[2]),\n",
        "                Write(result.brackets),\n",
        "            ),\n",
        "            randy.change(\"pondering\", square_eq),\n",
        "        )\n",
        "        self.show_mat_mult(matrix, matrix, square_eq[0][2:11], square_eq[1][2:11], result.elements)\n",
        "\n",
        "        # Show matrix cubed\n",
        "        mat_brace.generate_target()\n",
        "        mat_brace.target.next_to(mat_rhs[6], DOWN, SMALL_BUFF)\n",
        "\n",
        "        mat_squared = result\n",
        "        mat_cubed = IntegerMatrix(\n",
        "            np.dot(matrix, matrix_square),\n",
        "            h_buff=1.8, v_buff=0.7,\n",
        "            element_alignment_corner=ORIGIN,\n",
        "        )\n",
        "        mat_cubed.match_height(mat)\n",
        "        cube_eq = VGroup(\n",
        "            VGroup(mat.copy(), mat.copy(), mat.copy()).arrange(RIGHT, buff=SMALL_BUFF),\n",
        "            OldTex(\"=\").rotate(90 * DEGREES),\n",
        "            VGroup(mat.copy(), mat_squared.deepcopy()).arrange(RIGHT, buff=SMALL_BUFF),\n",
        "            OldTex(\"=\").rotate(90 * DEGREES),\n",
        "            mat_cubed\n",
        "        )\n",
        "        cube_eq.arrange(DOWN)\n",
        "        cube_eq.next_to(mat_brace.target, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(mat_brace),\n",
        "            ReplacementTransform(square_eq[0], cube_eq[0][1]),\n",
        "            ReplacementTransform(square_eq[1], cube_eq[0][2]),\n",
        "            ReplacementTransform(square_eq[2], cube_eq[1]),\n",
        "            ReplacementTransform(square_eq[3], cube_eq[2][1]),\n",
        "            randy.change(\"happy\", cube_eq),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeIn(cube_eq[0][0]),\n",
        "                FadeIn(cube_eq[2][0]),\n",
        "                FadeIn(cube_eq[3]),\n",
        "                FadeIn(cube_eq[4].brackets),\n",
        "            ),\n",
        "            randy.change(\"tease\", cube_eq),\n",
        "        )\n",
        "        self.show_mat_mult(\n",
        "            matrix, matrix_square,\n",
        "            cube_eq[2][0][2:11],\n",
        "            cube_eq[2][1].get_entries(),\n",
        "            cube_eq[4].get_entries(),\n",
        "            0.1, 0.1,\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        # Scaling\n",
        "        example_matrix = Matrix([\n",
        "            [\"a\", \"b\", \"c\"],\n",
        "            [\"d\", \"e\", \"f\"],\n",
        "            [\"g\", \"h\", \"i\"],\n",
        "        ])\n",
        "        example_scaled_matrix = Matrix([\n",
        "            [\"a / n!\", \"b / n!\", \"c / n!\"],\n",
        "            [\"d / n!\", \"e / n!\", \"f / n!\"],\n",
        "            [\"g / n!\", \"h / n!\", \"i / n!\"],\n",
        "        ])\n",
        "        factor = OldTex(\"1 \\\\over n!\")\n",
        "        factor.scale(1.5)\n",
        "        factor.next_to(example_matrix, LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(mat_brace, *cube_eq[:-1])),\n",
        "            FadeIn(factor),\n",
        "            FadeTransformPieces(cube_eq[-1], example_matrix),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(*factor, *example_matrix),\n",
        "                example_scaled_matrix,\n",
        "            ),\n",
        "            randy.change(\"pondering\", example_scaled_matrix),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Adding\n",
        "        mat1 = np.array([[2, 7, 1], [8, 2, 8], [1, 8, 2]])\n",
        "        mat2 = np.array([[8, 4, 5], [9, 0, 4], [5, 2, 3]])\n",
        "\n",
        "        sum_eq = VGroup(\n",
        "            IntegerMatrix(mat1),\n",
        "            OldTex(\"+\"),\n",
        "            IntegerMatrix(mat2),\n",
        "            OldTex(\"=\"),\n",
        "            Matrix(\n",
        "                np.array([\n",
        "                    f\"{m1} + {m2}\"\n",
        "                    for m1, m2 in zip(mat1.flatten(), mat2.flatten())\n",
        "                ]).reshape((3, 3)),\n",
        "                h_buff=1.8,\n",
        "            )\n",
        "        )\n",
        "        sum_eq.set_height(1.5)\n",
        "        sum_eq.arrange(RIGHT)\n",
        "        sum_eq.center()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(example_scaled_matrix, UP),\n",
        "            FadeIn(sum_eq[:-1], UP),\n",
        "            FadeIn(sum_eq[-1].brackets, UP),\n",
        "            morty.change(\"raise_right_hand\", sum_eq),\n",
        "            randy.change(\"thinking\", sum_eq),\n",
        "        )\n",
        "\n",
        "        last_rects = VGroup()\n",
        "        for e1, e2, e3 in zip(sum_eq[0].elements, sum_eq[2].elements, sum_eq[4].elements):\n",
        "            rects = VGroup(SurroundingRectangle(e1), SurroundingRectangle(e2))\n",
        "            self.add(e3, rects)\n",
        "            self.play(FadeOut(last_rects), run_time=0.2)\n",
        "            self.wait(0.1)\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "\n",
        "        # Ask about infinity\n",
        "        bubble = randy.get_bubble(OldTexText(\"But...going\\\\\\\\to $\\\\infty$?\"))\n",
        "        bubble.shift(SMALL_BUFF * RIGHT)\n",
        "        self.play(\n",
        "            Write(bubble),\n",
        "            Write(bubble.content),\n",
        "            FadeOut(sum_eq, UP),\n",
        "            randy.change(\"sassy\", mat_rhs),\n",
        "            morty.change(\"guilty\", randy.eyes),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(bubble),\n",
        "            bubble.content.animate.next_to(randy, RIGHT, aligned_edge=UP),\n",
        "            randy.change(\"pondering\", mat_rhs),\n",
        "            morty.change(\"pondering\", mat_rhs),\n",
        "        )\n",
        "\n",
        "        # Replace matrix\n",
        "        pi_mat_tex = \"\"\n",
        "        pi_mat_tex = \"\\\\left[ \\\\begin{array}{cc} 0 & -\\\\pi \\\\\\\\ \\\\pi & 0 \\\\end{array} \\\\right]\"\n",
        "        pi_mat_rhs = OldTex(\n",
        "            rhs_tex.replace(\"X\", pi_mat_tex),\n",
        "            tex_to_color_map={pi_mat_tex: BLUE},\n",
        "        )\n",
        "        pi_mat_rhs.match_width(mat_rhs)\n",
        "        pi_mat_rhs.move_to(mat_rhs)\n",
        "\n",
        "        pi_mat = pi_mat_rhs.get_part_by_tex(pi_mat_tex).copy()\n",
        "        pi_mat.scale(1.5)\n",
        "        pi_mat.next_to(morty, UL)\n",
        "\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            FadeIn(pi_mat, UP)\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            FadeTransformPieces(mat_rhs, pi_mat_rhs),\n",
        "            Transform(\n",
        "                VGroup(pi_mat),\n",
        "                pi_mat_rhs.get_parts_by_tex(pi_mat_tex),\n",
        "                remover=True,\n",
        "            ),\n",
        "            morty.change(\"tease\"),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show various partial sum values\n",
        "        matrix = np.array([[0, -np.pi], [np.pi, 0]])\n",
        "        curr_matrix = np.identity(2)\n",
        "        curr_sum = np.identity(2)\n",
        "        curr_sum_mob = IntegerMatrix(curr_matrix)\n",
        "        curr_sum_mob.set_height(1.5)\n",
        "        mat_parts = pi_mat_rhs.get_parts_by_tex(pi_mat_tex)\n",
        "\n",
        "        brace = Brace(mat_parts[0], DOWN)\n",
        "        brace.stretch(1.1, 0, about_edge=LEFT)\n",
        "        curr_sum_mob.next_to(brace, DOWN)\n",
        "        curr_sum_mob.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeTransform(mat_parts[0].copy(), curr_sum_mob),\n",
        "            randy.change(\"erm\", curr_sum_mob),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        last_n_label = VMobject()\n",
        "        partial_sum_mobs = [curr_sum_mob]\n",
        "        for n in range(1, 18):\n",
        "            if n < 5:\n",
        "                new_brace = Brace(mat_parts[:n + 1])\n",
        "                new_brace.set_width(new_brace.get_width() + 0.2, about_edge=LEFT)\n",
        "                brace.generate_target()\n",
        "                brace.target.become(new_brace)\n",
        "                anims = [\n",
        "                    MoveToTarget(brace),\n",
        "                ]\n",
        "            else:\n",
        "                n_label = OldTex(f\"n = {n}\", font_size=24)\n",
        "                n_label.next_to(brace.get_corner(DR), DL, SMALL_BUFF)\n",
        "                anims = [\n",
        "                    FadeIn(n_label),\n",
        "                    FadeOut(last_n_label),\n",
        "                ]\n",
        "                last_n_label = n_label\n",
        "\n",
        "            curr_matrix = np.dot(curr_matrix, matrix) / n\n",
        "            curr_sum += curr_matrix\n",
        "            nd = min(n + 1, 4)\n",
        "            if n < 2:\n",
        "                h_buff = 1.3\n",
        "            else:\n",
        "                sample = DecimalMatrix(curr_sum[0], num_decimal_places=nd)\n",
        "                sample.replace(curr_sum_mob.get_entries()[0], 1)\n",
        "                h_buff = 1.3 * sample.get_width()\n",
        "            new_sum_mob = DecimalMatrix(\n",
        "                curr_sum,\n",
        "                element_alignment_corner=RIGHT,\n",
        "                element_to_mobject_config={\n",
        "                    \"num_decimal_places\": nd,\n",
        "                    \"font_size\": 36,\n",
        "                },\n",
        "                h_buff=h_buff,\n",
        "            )\n",
        "            new_sum_mob.match_height(curr_sum_mob)\n",
        "            new_sum_mob.next_to(brace.target, DOWN)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(curr_sum_mob),\n",
        "                FadeIn(new_sum_mob),\n",
        "                randy.animate.look_at(new_sum_mob),\n",
        "                *anims,\n",
        "                run_time=(1 if n < 5 else 1 / 60)\n",
        "            )\n",
        "            self.wait()\n",
        "            curr_sum_mob = new_sum_mob\n",
        "            partial_sum_mobs.append(new_sum_mob)\n",
        "        self.play(\n",
        "            FadeOut(last_n_label),\n",
        "            randy.change(\"confused\", curr_sum_mob),\n",
        "        )\n",
        "\n",
        "        # Ask why\n",
        "        why = Text(\"Why?\")\n",
        "        why.move_to(bubble.content, UL)\n",
        "        epii = OldTex(\"e^{\\\\pi i} = -1\")\n",
        "        epii.next_to(morty, UL)\n",
        "        later_text = Text(\"...but that comes later\", font_size=24)\n",
        "        later_text.set_color(GREY_A)\n",
        "        later_text.next_to(epii, DOWN, aligned_edge=RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            randy.change(\"maybe\"),\n",
        "            FadeIn(why, UP),\n",
        "            FadeOut(bubble.content, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\"),\n",
        "            FadeIn(epii, UP),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(\n",
        "            Write(later_text, run_time=1),\n",
        "            randy.change(\"hesitant\", morty.eyes)\n",
        "        )\n",
        "\n",
        "        # Show partial sums\n",
        "        new_mat_rhs = OldTex(\n",
        "            rhs_tex.replace(\"X\", mat_tex),\n",
        "            tex_to_color_map={mat_tex: TEAL},\n",
        "            isolate=[\"+\"]\n",
        "        )\n",
        "        new_mat_rhs.replace(mat_rhs)\n",
        "        self.play(\n",
        "            FadeOut(pi_mat_rhs),\n",
        "            FadeIn(new_mat_rhs),\n",
        "            FadeOut(new_sum_mob, DOWN),\n",
        "            brace.animate.become(Brace(new_mat_rhs, DOWN)),\n",
        "            LaggedStartMap(\n",
        "                FadeOut, VGroup(\n",
        "                    why, epii, later_text,\n",
        "                ),\n",
        "                shift=DOWN,\n",
        "            ),\n",
        "            randy.change(\"pondering\", new_mat_rhs),\n",
        "            morty.change(\"pondering\", new_mat_rhs),\n",
        "        )\n",
        "\n",
        "        matrix = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])\n",
        "        partial_sum_mobs = VGroup()\n",
        "        curr_matrix = np.identity(3)\n",
        "        partial_sum = np.array(curr_matrix)\n",
        "        for n in range(50):\n",
        "            psm = DecimalMatrix(\n",
        "                partial_sum,\n",
        "                element_to_mobject_config={\"num_decimal_places\": 2},\n",
        "                element_alignment_corner=ORIGIN,\n",
        "                h_buff=1.5 * DecimalNumber(partial_sum[0, 0]).get_width(),\n",
        "                v_buff=1.0,\n",
        "            )\n",
        "            psm.next_to(brace, DOWN, MED_LARGE_BUFF)\n",
        "            partial_sum_mobs.add(psm)\n",
        "            curr_matrix = np.dot(curr_matrix, matrix) / (n + 1)\n",
        "            partial_sum += curr_matrix\n",
        "\n",
        "        new_mat_rhs[2:].set_opacity(0.1)\n",
        "        self.add(partial_sum_mobs[0])\n",
        "        self.wait(0.5)\n",
        "        for n, k in zip(it.count(1), [5, 9, 13, 19, 21]):\n",
        "            self.remove(partial_sum_mobs[n - 1])\n",
        "            self.add(partial_sum_mobs[n])\n",
        "            new_mat_rhs[:k].set_opacity(1)\n",
        "            self.wait(0.5)\n",
        "        brace.become(Brace(new_mat_rhs, DOWN))\n",
        "        n_label = VGroup(OldTex(\"n = \"), Integer(n))\n",
        "        n_label[1].set_height(n_label[0].get_height() * 1.2)\n",
        "        n_label.arrange(RIGHT, SMALL_BUFF)\n",
        "        n_label.set_color(GREY_B)\n",
        "        n_label.next_to(brace.get_corner(DR), DL, SMALL_BUFF)\n",
        "        self.add(n_label)\n",
        "        for n in range(6, 50):\n",
        "            self.remove(partial_sum_mobs[n - 1])\n",
        "            self.add(partial_sum_mobs[n])\n",
        "            n_label[1].set_value(n)\n",
        "            n_label[1].set_color(GREY_B)\n",
        "            n_label[1].next_to(n_label[0], RIGHT, SMALL_BUFF)\n",
        "            self.wait(0.1)\n",
        "        self.play(\n",
        "            randy.change(\"erm\"),\n",
        "            morty.change(\"tease\"),\n",
        "            # LaggedStartMap(\n",
        "            #     FadeOut, VGroup(brace, n_label, partial_sum_mobs[n]),\n",
        "            #     shift=DOWN,\n",
        "            # )\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    def show_mat_mult(self, m1, m2, m1_terms, m2_terms, rhs_terms, per_term=0.1, between_terms=0.35):\n",
        "        dim = m1.shape[0]\n",
        "        m1_color = m1_terms[0].get_fill_color()\n",
        "        m2_color = m2_terms[0].get_fill_color()\n",
        "        for n in range(dim * dim):\n",
        "            i = n // dim\n",
        "            j = n % dim\n",
        "            row = m1_terms[dim * i:dim * i + dim]\n",
        "            col = m2_terms[j::dim]\n",
        "            row_rect = SurroundingRectangle(row, buff=0.05)\n",
        "            col_rect = SurroundingRectangle(col, buff=0.05)\n",
        "            row_rect.set_stroke(YELLOW, 2)\n",
        "            col_rect.set_stroke(YELLOW, 2)\n",
        "            right_elem = Integer(0, edge_to_fix=ORIGIN)\n",
        "            right_elem.replace(rhs_terms[n], dim_to_match=1)\n",
        "            right_elem.set_value(0)\n",
        "\n",
        "            self.add(row_rect, col_rect, right_elem)\n",
        "            for k in range(dim):\n",
        "                self.wait(per_term)\n",
        "                right_elem.increment_value(m1[i, k] * m2[k, j])\n",
        "                right_elem.scale(rhs_terms[0][0].get_height() / right_elem[-1].get_height())\n",
        "                row[k].set_color(YELLOW)\n",
        "                col[k].set_color(YELLOW)\n",
        "            self.remove(right_elem)\n",
        "            self.add(rhs_terms[n])\n",
        "            self.wait(between_terms)\n",
        "            m1_terms.set_color(m1_color)\n",
        "            m2_terms.set_color(m2_color)\n",
        "            self.remove(row_rect, col_rect)\n",
        "\n",
        "\n",
        "class ShowHigherMatrixPowers(IntroduceTheComputation):\n",
        "    matrix = [[3, 1, 4], [1, 5, 9], [2, 6, 5]]\n",
        "    per_term = 0.1\n",
        "    between_terms = 0.1\n",
        "    N_powers = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # Show many matrix powers\n",
        "        def get_mat_mob(matrix):\n",
        "            term = Integer(matrix[0, 0])\n",
        "            return IntegerMatrix(\n",
        "                matrix,\n",
        "                h_buff=max(0.8 + 0.3 * len(term), 1.0)\n",
        "            )\n",
        "\n",
        "        N = self.N_powers\n",
        "        matrix = np.matrix(self.matrix)\n",
        "        matrix_powers = [np.identity(len(matrix)), matrix]\n",
        "        for x in range(N):\n",
        "            matrix_powers.append(np.dot(matrix, matrix_powers[-1]))\n",
        "\n",
        "        mat_mobs = [get_mat_mob(mat) for mat in matrix_powers]\n",
        "        for mob in mat_mobs:\n",
        "            mob.set_height(1)\n",
        "        mat_mobs[1].set_color(TEAL)\n",
        "\n",
        "        equation = VGroup(\n",
        "            mat_mobs[1].deepcopy(),\n",
        "            Integer(2, font_size=18),\n",
        "            OldTex(\"=\"),\n",
        "            mat_mobs[1].deepcopy(),\n",
        "            mat_mobs[1].deepcopy(),\n",
        "            OldTex(\"=\"),\n",
        "            mat_mobs[2].deepcopy()\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_edge(LEFT)\n",
        "        equation[1].set_y(equation[0].get_top()[1])\n",
        "        equation[0].set_x(equation[1].get_left()[0] - SMALL_BUFF, RIGHT)\n",
        "        self.add(equation)\n",
        "\n",
        "        exp = equation[1]\n",
        "        m1, m2, eq, rhs = equation[-4:]\n",
        "        self.remove(*rhs.get_entries())\n",
        "        for n in range(3, N):\n",
        "            self.show_mat_mult(\n",
        "                matrix_powers[1], matrix_powers[n - 2],\n",
        "                m1.get_entries(), m2.get_entries(), rhs.get_entries(),\n",
        "                between_terms=self.between_terms,\n",
        "                per_term=self.per_term\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            rhs.generate_target()\n",
        "            eq.generate_target()\n",
        "            rhs.target.move_to(m2, LEFT)\n",
        "            eq.target.next_to(rhs.target, RIGHT)\n",
        "            new_rhs = mat_mobs[n].deepcopy()\n",
        "            new_rhs.next_to(eq.target, RIGHT)\n",
        "            new_exp = Integer(n)\n",
        "            new_exp.replace(exp, dim_to_match=1)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(rhs, path_arc=PI / 2),\n",
        "                MoveToTarget(eq),\n",
        "                FadeOut(m2, DOWN),\n",
        "                FadeIn(new_rhs.get_brackets()),\n",
        "                FadeIn(new_exp, 0.5 * DOWN),\n",
        "                FadeOut(exp, 0.5 * DOWN),\n",
        "            )\n",
        "            m2, rhs = rhs, new_rhs\n",
        "            exp = new_exp\n",
        "\n",
        "\n",
        "class Show90DegreePowers(ShowHigherMatrixPowers):\n",
        "    matrix = [[0, -1], [1, 0]]\n",
        "    per_term = 0.0\n",
        "    between_terms = 0.2\n",
        "    N_powers = 16\n",
        "\n",
        "\n",
        "class WhyTortureMatrices(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play_student_changes(\n",
        "            \"maybe\", \"confused\", \"erm\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        q_marks = VGroup()\n",
        "        for student in self.students:\n",
        "            marks = OldTex(\"???\")\n",
        "            marks.next_to(student, UP)\n",
        "            q_marks.add(marks)\n",
        "        self.play(FadeIn(q_marks, 0.25 * UP, lag_ratio=0.1, run_time=2))\n",
        "        self.wait(2)\n",
        "        self.student_says(\n",
        "            OldTexText(\"Why...would you\\\\\\\\ever want\\\\\\\\to do that?\"),\n",
        "            index=2,\n",
        "            added_anims=[FadeOut(q_marks)],\n",
        "        )\n",
        "        self.play(\n",
        "            self.change_students(\"confused\", \"pondering\", \"raise_left_hand\", look_at=self.screen),\n",
        "            self.teacher.change(\"tease\", self.screen)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(self.students[0].change(\"erm\"))\n",
        "        self.wait(7)\n",
        "\n",
        "\n",
        "class DefinitionFirstVsLast(Scene):\n",
        "    show_love_and_quantum = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup objects\n",
        "        top_title = Text(\"Textbook progression\")\n",
        "        low_title = Text(\"Discovery progression\")\n",
        "\n",
        "        top_prog = VGroup(\n",
        "            OldTexText(\"Definition\", color=BLUE),\n",
        "            OldTexText(\"Theorem\"),\n",
        "            OldTexText(\"Proof\"),\n",
        "            OldTexText(\"Examples\"),\n",
        "        )\n",
        "        low_prog = VGroup(\n",
        "            OldTexText(\"Specific\\n\\nproblem\"),\n",
        "            OldTexText(\"General\\n\\nproblems\"),\n",
        "            OldTexText(\"Helpful\\n\\nconstructs\"),\n",
        "            OldTexText(\"Definition\", color=BLUE),\n",
        "        )\n",
        "        progs = VGroup(top_prog, low_prog)\n",
        "        for progression in progs:\n",
        "            progression.arrange(RIGHT, buff=1.2)\n",
        "        progs.arrange(DOWN, buff=3)\n",
        "        progs.set_width(FRAME_WIDTH - 2)\n",
        "\n",
        "        for progression in progs:\n",
        "            arrows = VGroup()\n",
        "            for m1, m2 in zip(progression[:-1], progression[1:]):\n",
        "                arrows.add(Arrow(m1, m2))\n",
        "            progression.arrows = arrows\n",
        "\n",
        "        top_dots = OldTex(\"\\\\dots\", font_size=72)\n",
        "        top_dots.next_to(top_prog.arrows[0], RIGHT)\n",
        "        low_dots = top_dots.copy()\n",
        "        low_dots.next_to(low_prog.arrows[-1], LEFT)\n",
        "\n",
        "        top_rect = SurroundingRectangle(top_prog, buff=MED_SMALL_BUFF)\n",
        "        top_rect.set_stroke(TEAL, 2)\n",
        "        top_title.next_to(top_rect, UP)\n",
        "        top_title.match_color(top_rect)\n",
        "        low_rect = SurroundingRectangle(low_prog, buff=MED_SMALL_BUFF)\n",
        "        low_rect.set_stroke(YELLOW, 2)\n",
        "        low_title.next_to(low_rect, UP)\n",
        "        low_title.match_color(low_rect)\n",
        "        versus = Text(\"vs.\")\n",
        "\n",
        "        # Show progressions\n",
        "        self.add(top_prog[0])\n",
        "        self.play(\n",
        "            GrowArrow(top_prog.arrows[0]),\n",
        "            FadeIn(top_dots, 0.2 * RIGHT, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        kw = {\"path_arc\": -90 * DEGREES}\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                TransformFromCopy(top_prog[0], low_prog[-1], **kw),\n",
        "                TransformFromCopy(top_prog.arrows[0], low_prog.arrows[-1], **kw),\n",
        "                TransformFromCopy(top_dots, low_dots, **kw),\n",
        "            ),\n",
        "            Write(versus)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(top_rect),\n",
        "            FadeIn(top_title, 0.25 * UP)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(top_dots),\n",
        "            FadeIn(top_prog[1]),\n",
        "        )\n",
        "        for arrow, term in zip(top_prog.arrows[1:], top_prog[2:]):\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                FadeIn(term, shift=0.25 * RIGHT),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(low_rect),\n",
        "            FadeIn(low_title, 0.25 * UP),\n",
        "            versus.animate.move_to(midpoint(low_title.get_top(), top_rect.get_bottom())),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(low_prog[0]))\n",
        "        self.play(\n",
        "            GrowArrow(low_prog.arrows[0]),\n",
        "            FadeIn(low_prog[1], shift=0.25 * RIGHT),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(low_prog.arrows[1]),\n",
        "            FadeIn(low_prog[2], shift=0.25 * RIGHT),\n",
        "            FadeOut(low_dots),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight specific example\n",
        "        full_rect = FullScreenRectangle()\n",
        "        full_rect.set_fill(BLACK, opacity=0.75)\n",
        "        sp, gp, hc = low_prog[:3].copy()\n",
        "        self.add(full_rect, sp)\n",
        "        self.play(FadeIn(full_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Go to general\n",
        "        if not self.show_love_and_quantum:\n",
        "            self.play(FadeIn(gp))\n",
        "            self.play(FlashAround(gp, color=BLUE, run_time=2))\n",
        "            self.wait()\n",
        "            return\n",
        "\n",
        "        # Love and quantum\n",
        "        love = SVGMobject(\"hearts\")\n",
        "        love.set_height(1)\n",
        "        love.set_fill(RED, 1)\n",
        "        love.set_stroke(MAROON_B, 1)\n",
        "\n",
        "        quantum = OldTex(\"|\\\\psi\\\\rangle\")\n",
        "        quantum.set_color(BLUE)\n",
        "        quantum.match_height(love)\n",
        "        group = VGroup(quantum, love)\n",
        "        group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        group.next_to(sp, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        love.save_state()\n",
        "        love.match_x(sp)\n",
        "        self.play(Write(love))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(love),\n",
        "            FadeIn(quantum, 0.5 * LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            love.animate.center().scale(1.5),\n",
        "            FadeOut(quantum),\n",
        "            FadeOut(sp),\n",
        "            full_rect.animate.set_fill(opacity=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DefinitionFirstVsLastGP(DefinitionFirstVsLast):\n",
        "    show_love_and_quantum = False\n",
        "\n",
        "\n",
        "class RomeoAndJuliet(Scene):\n",
        "    def construct(self):\n",
        "        # Add Romeo and Juliet\n",
        "        romeo, juliet = lovers = self.get_romeo_and_juliet()\n",
        "        lovers.set_height(2)\n",
        "        lovers.arrange(LEFT, buff=1)\n",
        "        lovers.move_to(0.5 * DOWN)\n",
        "\n",
        "        self.add(*lovers)\n",
        "        self.make_romeo_and_juliet_dynamic(romeo, juliet)\n",
        "        romeo.love_tracker.set_value(1.5)\n",
        "        juliet.love_tracker.set_value(1.5)\n",
        "        get_romeo_juilet_name_labels(lovers)\n",
        "\n",
        "        for creature in lovers:\n",
        "            self.play(\n",
        "                creature.love_tracker.animate.set_value(2.5),\n",
        "                Write(creature.name_label, run_time=1),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Add their scales\n",
        "        juliet_scale = self.get_love_scale(juliet, LEFT, \"x\", BLUE_B)\n",
        "        romeo_scale = self.get_love_scale(romeo, RIGHT, \"y\", BLUE)\n",
        "        scales = [juliet_scale, romeo_scale]\n",
        "\n",
        "        scale_labels = VGroup(\n",
        "            OldTexText(\"Juliet's love for Romeo\", font_size=30),\n",
        "            OldTexText(\"Romeo's love for Juliet\", font_size=30),\n",
        "        )\n",
        "        scale_arrows = VGroup()\n",
        "        for scale, label in zip(scales, scale_labels):\n",
        "            var = scale[2][0][0]\n",
        "            label.next_to(var, UP, buff=0.7)\n",
        "            arrow = Arrow(var, label, buff=0.1, thickness=0.025)\n",
        "            scale_arrows.add(arrow)\n",
        "            label.set_color(var.get_fill_color())\n",
        "\n",
        "        for lover, scale, arrow, label, final_love in zip(reversed(lovers), scales, scale_arrows, scale_labels, [1, -1]):\n",
        "            self.add(scale)\n",
        "            self.play(FlashAround(scale[2][0][0]))\n",
        "            self.play(\n",
        "                lover.love_tracker.animate.set_value(5),\n",
        "                GrowArrow(arrow),\n",
        "                FadeIn(label, 0.5 * UP),\n",
        "            )\n",
        "            self.play(lover.love_tracker.animate.set_value(final_love), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        # Juliet's rule\n",
        "        frame = self.camera.frame\n",
        "        equations = VGroup(\n",
        "            OldTex(\"{dx \\\\over dt} {{=}} -{{y(t)}}\"),\n",
        "            OldTex(\"{dy \\\\over dt} {{=}} {{x(t)}}\"),\n",
        "        )\n",
        "        juliet_eq, romeo_eq = equations\n",
        "        juliet_eq.next_to(scale_labels[0], UR)\n",
        "        juliet_eq.shift(0.5 * UP)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.move_to(0.7 * UP),\n",
        "            Write(equations[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(juliet_eq[0]))\n",
        "        self.wait()\n",
        "        y_rect = SurroundingRectangle(juliet_eq.get_parts_by_tex(\"y(t)\"), buff=0.05)\n",
        "        y_rect_copy = y_rect.copy()\n",
        "        y_rect_copy.replace(romeo.scale_mob.dot, stretch=True)\n",
        "        self.play(FadeIn(y_rect))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(y_rect, y_rect_copy))\n",
        "        y_rect_copy.add_updater(lambda m: m.move_to(romeo.scale_mob.dot))\n",
        "        self.wait()\n",
        "        self.play(romeo.love_tracker.animate.set_value(-3))\n",
        "\n",
        "        big_arrow = Arrow(\n",
        "            juliet.scale_mob.number_line.get_bottom(),\n",
        "            juliet.scale_mob.number_line.get_top(),\n",
        "        )\n",
        "        big_arrow.set_color(GREEN)\n",
        "        big_arrow.next_to(juliet.scale_mob.number_line, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(big_arrow),\n",
        "            ApplyMethod(juliet.love_tracker.set_value, 5, run_time=3, rate_func=linear),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(romeo.love_tracker.animate.set_value(5))\n",
        "        self.play(\n",
        "            big_arrow.animate.rotate(PI).set_color(RED),\n",
        "            path_arc=PI,\n",
        "            run_time=0.5,\n",
        "        )\n",
        "        self.play(juliet.love_tracker.animate.set_value(-5), rate_func=linear, run_time=5)\n",
        "        self.play(FadeOut(y_rect), FadeOut(y_rect_copy))\n",
        "\n",
        "        # Romeo's rule\n",
        "        romeo_eq.next_to(scale_labels[1], UL)\n",
        "        romeo_eq.shift(0.5 * UP)\n",
        "        self.play(\n",
        "            juliet_eq.animate.to_edge(LEFT),\n",
        "            FadeOut(big_arrow),\n",
        "        )\n",
        "        self.play(FadeIn(romeo_eq, UP))\n",
        "        self.wait()\n",
        "\n",
        "        dy_rect = SurroundingRectangle(romeo_eq.get_part_by_tex(\"dy\"))\n",
        "        x_rect = SurroundingRectangle(romeo_eq.get_part_by_tex(\"x(t)\"), buff=0.05)\n",
        "        x_rect_copy = x_rect.copy()\n",
        "        x_rect_copy.replace(juliet.scale_mob.dot, stretch=True)\n",
        "        self.play(ShowCreation(dy_rect))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(dy_rect, x_rect))\n",
        "        self.play(TransformFromCopy(x_rect, x_rect_copy))\n",
        "        self.wait()\n",
        "\n",
        "        big_arrow.next_to(romeo.scale_mob.number_line, RIGHT)\n",
        "        self.play(FadeIn(big_arrow), LaggedStartMap(FadeOut, VGroup(dy_rect, x_rect)))\n",
        "        self.play(romeo.love_tracker.animate.set_value(-3), run_time=4, rate_func=linear)\n",
        "        x_rect_copy.add_updater(lambda m: m.move_to(juliet.scale_mob.dot))\n",
        "        juliet.love_tracker.set_value(5)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            big_arrow.animate.rotate(PI).set_color(GREEN),\n",
        "            path_arc=PI,\n",
        "            run_time=0.5,\n",
        "        )\n",
        "        self.play(romeo.love_tracker.animate.set_value(5), rate_func=linear, run_time=5)\n",
        "        self.play(FadeOut(x_rect_copy))\n",
        "        self.wait()\n",
        "\n",
        "        # Show constant change\n",
        "        left_arrow = Arrow(UP, DOWN)\n",
        "        left_arrow.character = juliet\n",
        "        left_arrow.get_rate = lambda: -romeo.love_tracker.get_value()\n",
        "\n",
        "        right_arrow = Arrow(DOWN, UP)\n",
        "        right_arrow.character = romeo\n",
        "        right_arrow.get_rate = lambda: juliet.love_tracker.get_value()\n",
        "\n",
        "        def update_arrow(arrow):\n",
        "            nl = arrow.character.scale.number_line\n",
        "            rate = arrow.get_rate()\n",
        "            if rate == 0:\n",
        "                rate = 1e-6\n",
        "            arrow.put_start_and_end_on(nl.n2p(0), nl.n2p(rate))\n",
        "            arrow.next_to(nl, np.sign(nl.get_center()[0]) * RIGHT)\n",
        "            if rate > 0:\n",
        "                arrow.set_color(GREEN)\n",
        "            else:\n",
        "                arrow.set_color(RED)\n",
        "\n",
        "        left_arrow.add_updater(update_arrow)\n",
        "        right_arrow.add_updater(update_arrow)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(left_arrow),\n",
        "            ApplyMethod(big_arrow.scale, 0, remover=True, run_time=3),\n",
        "            ApplyMethod(juliet.love_tracker.set_value, 0, run_time=3),\n",
        "        )\n",
        "\n",
        "        ps_point = Point(5 * UP)\n",
        "        curr_time = self.time\n",
        "        ps_point.add_updater(lambda m: m.move_to([\n",
        "            -5 * np.sin(0.5 * (self.time - curr_time)),\n",
        "            5 * np.cos(0.5 * (self.time - curr_time)),\n",
        "            0,\n",
        "        ]))\n",
        "        juliet.love_tracker.add_updater(lambda m: m.set_value(ps_point.get_location()[0]))\n",
        "        romeo.love_tracker.add_updater(lambda m: m.set_value(ps_point.get_location()[1]))\n",
        "        self.add(ps_point)\n",
        "        self.add(right_arrow)\n",
        "\n",
        "        self.play(\n",
        "            equations.animate.arrange(RIGHT, buff=LARGE_BUFF).to_edge(UP, buff=0),\n",
        "            run_time=2,\n",
        "        )\n",
        "        # Just let this play out for a long time while other animations are played on top\n",
        "        self.wait(5 * TAU)\n",
        "\n",
        "    def get_romeo_and_juliet(self):\n",
        "        romeo = PiCreature(color=BLUE_E, flip_at_start=True)\n",
        "        juliet = PiCreature(color=BLUE_B)\n",
        "        return VGroup(romeo, juliet)\n",
        "\n",
        "    def make_romeo_and_juliet_dynamic(self, romeo, juliet):\n",
        "        cutoff_values = [-5, -3, -1, 0, 1, 3, 5]\n",
        "        modes = [\"angry\", \"sassy\", \"hesitant\", \"plain\", \"happy\", \"hooray\", \"surprised\"]\n",
        "        self.make_character_dynamic(romeo, juliet, cutoff_values, modes)\n",
        "        self.make_character_dynamic(juliet, romeo, cutoff_values, modes)\n",
        "\n",
        "    def get_romeo_juilet_name_labels(self, lovers, font_size=36, spacing=1.2, buff=MED_SMALL_BUFF):\n",
        "        name_labels = VGroup(*(\n",
        "            Text(name, font_size=font_size)\n",
        "            for name in [\"Romeo\", \"Juliet\"]\n",
        "        ))\n",
        "        for label, creature in zip(name_labels, lovers):\n",
        "            label.next_to(creature, DOWN, buff)\n",
        "            creature.name_label = label\n",
        "        name_labels.space_out_submobjects(spacing)\n",
        "        return name_labels\n",
        "\n",
        "    def make_character_dynamic(self, pi_creature, lover, cutoff_values, modes):\n",
        "        height = pi_creature.get_height()\n",
        "        bottom = pi_creature.get_bottom()\n",
        "        copies = [\n",
        "            pi_creature.deepcopy().change(mode).set_height(height).move_to(bottom, DOWN)\n",
        "            for mode in modes\n",
        "        ]\n",
        "        pi_creature.love_tracker = ValueTracker()\n",
        "\n",
        "        def update_func(pi):\n",
        "            love = pi.love_tracker.get_value()\n",
        "\n",
        "            if love < cutoff_values[0]:\n",
        "                pi.become(copies[0])\n",
        "            elif love >= cutoff_values[-1]:\n",
        "                pi.become(copies[-1])\n",
        "            else:\n",
        "                i = 1\n",
        "                while cutoff_values[i] < love:\n",
        "                    i += 1\n",
        "                copy1 = copies[i - 1]\n",
        "                copy2 = copies[i]\n",
        "\n",
        "                alpha = inverse_interpolate(cutoff_values[i - 1], cutoff_values[i], love)\n",
        "                s_alpha = squish_rate_func(smooth, 0.25, 0.75)(alpha)\n",
        "\n",
        "                # if s_alpha > 0:\n",
        "                copy1.align_data_and_family(copy2)\n",
        "                pi.align_data_and_family(copy1)\n",
        "                pi.align_data_and_family(copy2)\n",
        "                fam = pi.family_members_with_points()\n",
        "                f1 = copy1.family_members_with_points()\n",
        "                f2 = copy2.family_members_with_points()\n",
        "                for sm, sm1, sm2 in zip(fam, f1, f2):\n",
        "                    sm.interpolate(sm1, sm2, s_alpha)\n",
        "\n",
        "            pi.look_at(lover.get_top())\n",
        "            if love < cutoff_values[1]:\n",
        "                # Look away from the lover\n",
        "                pi.look_at(2 * pi.eyes.get_center() - lover.eyes.get_center() + DOWN)\n",
        "\n",
        "            return pi\n",
        "\n",
        "        pi_creature.add_updater(update_func)\n",
        "\n",
        "        def update_eyes(heart_eyes):\n",
        "            love = pi_creature.love_tracker.get_value()\n",
        "            l_alpha = np.clip(\n",
        "                inverse_interpolate(cutoff_values[-1] - 0.5, cutoff_values[-1], love),\n",
        "                0, 1\n",
        "            )\n",
        "            pi_creature.eyes.set_opacity(1 - l_alpha)\n",
        "            heart_eyes.set_opacity(l_alpha)\n",
        "            # heart_eyes.move_to(pi_creature.eyes)\n",
        "            heart_eyes.match_x(pi_creature.mouth)\n",
        "\n",
        "        heart_eyes = self.get_heart_eyes(pi_creature)\n",
        "        heart_eyes.add_updater(update_eyes)\n",
        "        pi_creature.heart_eyes = heart_eyes\n",
        "        self.add(heart_eyes)\n",
        "        return pi_creature\n",
        "\n",
        "    def get_heart_eyes(self, creature):\n",
        "        hearts = VGroup()\n",
        "        for eye in creature.eyes:\n",
        "            heart = SVGMobject(\"hearts\")\n",
        "            heart.set_fill(RED)\n",
        "            heart.match_width(eye)\n",
        "            heart.move_to(eye)\n",
        "            heart.scale(1.25)\n",
        "            heart.set_stroke(BLACK, 1)\n",
        "            hearts.add(heart)\n",
        "        hearts.set_opacity(0)\n",
        "        return hearts\n",
        "\n",
        "    def get_love_scale(self, creature, direction, var_name, color):\n",
        "        number_line = NumberLine((-5, 5))\n",
        "        number_line.rotate(90 * DEGREES)\n",
        "        number_line.set_height(1.5 * creature.get_height())\n",
        "        number_line.next_to(creature, direction, buff=MED_LARGE_BUFF)\n",
        "        number_line.add_numbers(\n",
        "            range(-4, 6, 2),\n",
        "            font_size=18,\n",
        "            color=GREY_B,\n",
        "            buff=0.1,\n",
        "            direction=LEFT,\n",
        "        )\n",
        "\n",
        "        dot = Dot(color=color)\n",
        "        dot.add_updater(lambda m: m.move_to(number_line.n2p(creature.love_tracker.get_value())))\n",
        "\n",
        "        label = VGroup(OldTex(var_name, \"=\", font_size=36), DecimalNumber(font_size=24))\n",
        "        label.set_color(color)\n",
        "        label[0].shift(label[1].get_left() + SMALL_BUFF * LEFT - label[0][1].get_right())\n",
        "        label.next_to(number_line, UP)\n",
        "        label[1].add_updater(lambda m: m.set_value(creature.love_tracker.get_value()).set_color(color))\n",
        "\n",
        "        result = VGroup(number_line, dot, label)\n",
        "        result.set_stroke(background=True)\n",
        "        result.number_line = number_line\n",
        "        result.dot = dot\n",
        "        result.label = label\n",
        "        creature.scale_mob = result\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class DiscussSystem(Scene):\n",
        "    def construct(self):\n",
        "        # Setup equations\n",
        "        equations = VGroup(\n",
        "            OldTex(\"{dx \\\\over dt} {{=}} -{{y(t)}}\"),\n",
        "            OldTex(\"{dy \\\\over dt} {{=}} {{x(t)}}\"),\n",
        "        )\n",
        "        equations.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        equations.to_edge(UP, buff=1.5)\n",
        "\n",
        "        eq_rect = SurroundingRectangle(equations, stroke_width=2, buff=0.25)\n",
        "        sys_label = Text(\"System of differential equations\")\n",
        "        sys_label.next_to(eq_rect, UP)\n",
        "\n",
        "        self.add(equations)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(sys_label, 0.5 * UP),\n",
        "            ShowCreation(eq_rect),\n",
        "        )\n",
        "        style = {\"color\": BLUE, \"time_width\": 3, \"run_time\": 2}\n",
        "        self.play(LaggedStart(\n",
        "            FlashAround(sys_label.get_part_by_text(\"differential\"), **style),\n",
        "            FlashAround(equations[0].get_part_by_tex(\"dx\"), **style),\n",
        "            FlashAround(equations[1].get_part_by_tex(\"dy\"), **style),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask for explicit solutions\n",
        "        solutions = VGroup(\n",
        "            OldTex(\"x(t) {{=}} (\\\\text{expression with } t)\"),\n",
        "            OldTex(\"y(t) {{=}} (\\\\text{expression with } t)\"),\n",
        "        )\n",
        "        for solution in solutions:\n",
        "            solution.set_color_by_tex(\"expression\", GREY_B)\n",
        "        solutions.arrange(DOWN, buff=0.5)\n",
        "        solutions.move_to(equations)\n",
        "        solutions.set_x(3)\n",
        "\n",
        "        self.play(\n",
        "            sys_label.animate.match_width(eq_rect).to_edge(LEFT),\n",
        "            VGroup(equations, eq_rect).animate.to_edge(LEFT),\n",
        "            LaggedStartMap(FadeIn, solutions, shift=0.5 * UP, lag_ratio=0.3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a guess\n",
        "        guess_rhss = VGroup(\n",
        "            OldTex(\"\\\\cos(t)\", color=GREY_B)[0],\n",
        "            OldTex(\"\\\\sin(t)\", color=GREY_B)[0],\n",
        "        )\n",
        "        temp_rhss = VGroup()\n",
        "        for rhs, solution in zip(guess_rhss, solutions):\n",
        "            temp_rhss.add(solution[2])\n",
        "            rhs.move_to(solution[2], LEFT)\n",
        "\n",
        "        bubble = ThoughtBubble(height=4, width=4)\n",
        "        bubble.flip()\n",
        "        bubble.set_fill(opacity=0)\n",
        "        bubble[:3].rotate(30 * DEGREES, about_point=bubble[3].get_center() + 0.2 * RIGHT)\n",
        "        bubble.shift(solutions.get_left() + 0.7 * LEFT - bubble[3].get_left())\n",
        "\n",
        "        self.remove(temp_rhss)\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            *(\n",
        "                TransformMatchingShapes(temp_rhs.copy(), guess_rhs)\n",
        "                for temp_rhs, guess_rhs in zip(temp_rhss, guess_rhss)\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Not enough!\n",
        "        not_enough = Text(\"Not enough!\", font_size=40)\n",
        "        not_enough.next_to(bubble[3].get_corner(UR), DR)\n",
        "        not_enough.set_color(RED)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, not_enough, run_time=1, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.remove(guess_rhss)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(*bubble, *not_enough)),\n",
        "            *(\n",
        "                TransformMatchingShapes(guess_rhs.copy(), temp_rhs)\n",
        "                for temp_rhs, guess_rhs in zip(temp_rhss, guess_rhss)\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Initial condition\n",
        "        solutions.generate_target()\n",
        "        initial_conditions = VGroup(\n",
        "            OldTex(\"x(0) = x_0\"),\n",
        "            OldTex(\"y(0) = y_0\"),\n",
        "        )\n",
        "        full_requirement = VGroup(*solutions.target, *initial_conditions)\n",
        "        full_requirement.arrange(DOWN, buff=0.25, aligned_edge=LEFT)\n",
        "        full_requirement.scale(0.8)\n",
        "        full_requirement.move_to(solutions)\n",
        "        full_requirement.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(solutions),\n",
        "            LaggedStartMap(FadeIn, initial_conditions, shift=0.1 * UP, lag_ratio=0.3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        ic_label = Text(\"Initial condition\", font_size=30)\n",
        "        ic_label.set_color(BLUE)\n",
        "        ic_label.next_to(initial_conditions, RIGHT, buff=1.0)\n",
        "        ic_arrows = VGroup(*(\n",
        "            Arrow(ic_label.get_left(), eq.get_right(), buff=0.1, fill_color=BLUE, thickness=0.025)\n",
        "            for eq in initial_conditions\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(ic_label),\n",
        "            LaggedStartMap(GrowArrow, ic_arrows, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MoreGeneralSystem(Scene):\n",
        "    def construct(self):\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"x\": RED,\n",
        "                \"y\": GREEN,\n",
        "                \"z\": BLUE,\n",
        "                \"{t}\": GREY_B,\n",
        "            }\n",
        "        }\n",
        "        equations = VGroup(\n",
        "            OldTex(\"{dx \\\\over d{t} } = a\\\\cdot x({t}) + b\\\\cdot y({t}) + c\\\\cdot z({t})\", **kw),\n",
        "            OldTex(\"{dy \\\\over d{t} } = d\\\\cdot x({t}) + e\\\\cdot y({t}) + f\\\\cdot z({t})\", **kw),\n",
        "            OldTex(\"{dz \\\\over d{t} } = g\\\\cdot x({t}) + h\\\\cdot y({t}) + i\\\\cdot z({t})\", **kw),\n",
        "        )\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "        self.add(equations)\n",
        "        self.play(LaggedStartMap(FadeIn, equations, shift=UP, lag_ratio=0.5, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class HowExampleLeadsToMatrixExponents(Scene):\n",
        "    def construct(self):\n",
        "        # Screen\n",
        "        self.add(FullScreenRectangle())\n",
        "        screen = ScreenRectangle()\n",
        "        screen.set_height(3)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.set_stroke(BLUE_B, 2)\n",
        "        screen.to_edge(LEFT)\n",
        "        self.add(screen)\n",
        "\n",
        "        # Mat exp\n",
        "        mat_exp = get_matrix_exponential(\n",
        "            [[\"a\", \"b\"], [\"c\", \"d\"]],\n",
        "            height=2,\n",
        "            h_buff=0.95, v_buff=0.75\n",
        "        )\n",
        "        mat_exp.set_x(FRAME_WIDTH / 4)\n",
        "\n",
        "        def get_arrow():\n",
        "            return Arrow(screen, mat_exp[0])\n",
        "\n",
        "        arrow = get_arrow()\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(mat_exp, RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # New screen\n",
        "        screen2 = screen.copy()\n",
        "        screen2.set_stroke(GREY_BROWN, 2)\n",
        "        screen2.to_corner(DR)\n",
        "\n",
        "        mat_exp.generate_target()\n",
        "        mat_exp.target.to_edge(UP)\n",
        "        mat_exp.target.match_x(screen2)\n",
        "        double_arrow = VGroup(\n",
        "            Arrow(mat_exp.target, screen2),\n",
        "            Arrow(screen2, mat_exp.target),\n",
        "        )\n",
        "        for mob in double_arrow:\n",
        "            mob.scale(0.9, about_point=mob.get_end())\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(mat_exp),\n",
        "            GrowFromCenter(double_arrow),\n",
        "            arrow.animate.become(Arrow(screen, screen2)),\n",
        "            FadeIn(screen2, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RomeoJulietVectorSpace(RomeoAndJuliet):\n",
        "    def construct(self):\n",
        "        # Set up Romeo and Juliet\n",
        "        romeo, juliet = lovers = self.get_romeo_and_juliet()\n",
        "        lovers.set_height(2.0)\n",
        "        lovers.arrange(LEFT, buff=3)\n",
        "        name_labels = self.get_romeo_juilet_name_labels(lovers, font_size=36, spacing=1.1)\n",
        "        self.make_romeo_and_juliet_dynamic(*lovers)\n",
        "\n",
        "        self.add(*lovers)\n",
        "        self.add(*name_labels)\n",
        "\n",
        "        # Scales\n",
        "        juliet_scale = self.get_love_scale(juliet, LEFT, \"x\", BLUE_B)\n",
        "        romeo_scale = self.get_love_scale(romeo, RIGHT, \"y\", BLUE)\n",
        "        scales = [juliet_scale, romeo_scale]\n",
        "        self.add(*scales)\n",
        "\n",
        "        # Animate in\n",
        "        psp_tracker = Point()\n",
        "\n",
        "        def get_psp():\n",
        "            # Get phase space point\n",
        "            return psp_tracker.get_location()\n",
        "\n",
        "        juliet.love_tracker.add_updater(lambda m: m.set_value(get_psp()[0]))\n",
        "        romeo.love_tracker.add_updater(lambda m: m.set_value(get_psp()[1]))\n",
        "        self.add(romeo.love_tracker, juliet.love_tracker)\n",
        "\n",
        "        psp_tracker.move_to([1, -3, 0])\n",
        "        self.play(\n",
        "            Rotate(psp_tracker, 90 * DEGREES, about_point=ORIGIN, run_time=3, rate_func=linear)\n",
        "        )\n",
        "\n",
        "        # Transition to axes\n",
        "        axes = Axes(\n",
        "            x_range=(-5, 5),\n",
        "            y_range=(-5, 5),\n",
        "            height=7,\n",
        "            width=7,\n",
        "            axis_config={\n",
        "                \"include_tip\": False,\n",
        "                \"numbers_to_exclude\": [],\n",
        "            }\n",
        "        )\n",
        "        axes.set_x(-3)\n",
        "\n",
        "        for axis in axes:\n",
        "            axis.add_numbers(range(-4, 6, 2), color=GREY_B)\n",
        "            axis.numbers[2].set_opacity(0)\n",
        "\n",
        "        for pi in lovers:\n",
        "            pi.clear_updaters()\n",
        "            pi.generate_target()\n",
        "            pi.target.set_height(0.75)\n",
        "            pi.name_label.generate_target()\n",
        "            pi.name_label.target.scale(0.5)\n",
        "            group = VGroup(pi.target, pi.name_label.target)\n",
        "            group.arrange(DOWN, buff=SMALL_BUFF)\n",
        "            pi.target_group = group\n",
        "            pi.scale_mob[2].clear_updaters()\n",
        "            self.add(*pi.scale_mob)\n",
        "        juliet.target_group.next_to(axes.x_axis.get_end(), RIGHT)\n",
        "        romeo.target_group.next_to(axes.y_axis.get_corner(UR), RIGHT)\n",
        "        romeo.target_group.shift_onto_screen(buff=MED_SMALL_BUFF)\n",
        "        romeo.target.flip()\n",
        "        juliet.target.flip()\n",
        "        juliet.target.make_eye_contact(romeo.target)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            juliet.scale_mob.number_line.animate.become(axes.x_axis),\n",
        "            FadeOut(juliet.scale_mob.label),\n",
        "            MoveToTarget(juliet),\n",
        "            MoveToTarget(juliet.name_label),\n",
        "            romeo.scale_mob.number_line.animate.become(axes.y_axis),\n",
        "            FadeOut(romeo.scale_mob.label),\n",
        "            MoveToTarget(romeo),\n",
        "            MoveToTarget(romeo.name_label),\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.add(*romeo.scale_mob[:2], *juliet.scale_mob[:2])\n",
        "\n",
        "        # Reset pi creatures\n",
        "        self.remove(lovers)\n",
        "        self.remove(romeo.heart_eyes)\n",
        "        self.remove(juliet.heart_eyes)\n",
        "        new_lovers = self.get_romeo_and_juliet()\n",
        "        for new_pi, pi in zip(new_lovers, lovers):\n",
        "            new_pi.flip()\n",
        "            new_pi.replace(pi)\n",
        "            new_pi.scale_mob = pi.scale_mob\n",
        "        lovers = new_lovers\n",
        "        romeo, juliet = new_lovers\n",
        "        self.add(romeo, juliet)\n",
        "        self.make_romeo_and_juliet_dynamic(romeo, juliet)\n",
        "        juliet.love_tracker.add_updater(lambda m: m.set_value(get_psp()[0]))\n",
        "        romeo.love_tracker.add_updater(lambda m: m.set_value(get_psp()[1]))\n",
        "        self.add(romeo.love_tracker, juliet.love_tracker)\n",
        "\n",
        "        # h_line and v_line\n",
        "        ps_dot = Dot(color=BLUE)\n",
        "        ps_dot.add_updater(lambda m: m.move_to(axes.c2p(*get_psp()[:2])))\n",
        "        v_line = Line().set_stroke(BLUE_D, 2)\n",
        "        h_line = Line().set_stroke(BLUE_B, 2)\n",
        "        v_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.x_axis.n2p(get_psp()[0]),\n",
        "            axes.c2p(*get_psp()[:2]),\n",
        "        ))\n",
        "        h_line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.y_axis.n2p(get_psp()[1]),\n",
        "            axes.c2p(*get_psp()[:2]),\n",
        "        ))\n",
        "        x_dec = DecimalNumber(0, font_size=24)\n",
        "        x_dec.next_to(h_line, UP, SMALL_BUFF)\n",
        "        y_dec = DecimalNumber(0, font_size=24)\n",
        "        y_dec.next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        romeo.scale_mob.dot.clear_updaters()\n",
        "        juliet.scale_mob.dot.clear_updaters()\n",
        "        self.play(\n",
        "            ShowCreation(h_line.copy().clear_updaters(), remover=True),\n",
        "            ShowCreation(v_line.copy().clear_updaters(), remover=True),\n",
        "            ReplacementTransform(romeo.scale_mob.dot, ps_dot),\n",
        "            ReplacementTransform(juliet.scale_mob.dot, ps_dot),\n",
        "            ChangeDecimalToValue(x_dec, get_psp()[0]),\n",
        "            VFadeIn(x_dec),\n",
        "            ChangeDecimalToValue(y_dec, get_psp()[1]),\n",
        "            VFadeIn(y_dec),\n",
        "        )\n",
        "        self.add(h_line, v_line, ps_dot)\n",
        "\n",
        "        # Add coordinates\n",
        "        equation = VGroup(\n",
        "            Matrix([[\"x\"], [\"y\"]], bracket_h_buff=SMALL_BUFF),\n",
        "            OldTex(\"=\"),\n",
        "            DecimalMatrix(\n",
        "                np.reshape(get_psp()[:2], (2, 1)),\n",
        "                element_to_mobject_config={\n",
        "                    \"num_decimal_places\": 2,\n",
        "                    \"font_size\": 36,\n",
        "                    \"include_sign\": True,\n",
        "                }\n",
        "            ),\n",
        "        )\n",
        "        equation[0].match_height(equation[2])\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_corner(UR)\n",
        "        equation.shift(MED_SMALL_BUFF * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(equation[:2]),\n",
        "            FadeIn(equation[2].get_brackets()),\n",
        "            TransformFromCopy(x_dec, equation[2].get_entries()[0]),\n",
        "            TransformFromCopy(y_dec, equation[2].get_entries()[1]),\n",
        "        )\n",
        "        equation[2].get_entries()[0].add_updater(lambda m: m.set_value(get_psp()[0]))\n",
        "        equation[2].get_entries()[1].add_updater(lambda m: m.set_value(get_psp()[1]))\n",
        "\n",
        "        self.play(FadeOut(x_dec), FadeOut(y_dec))\n",
        "\n",
        "        # Play around in state space\n",
        "        self.play(psp_tracker.move_to, [3, -2, 0], path_arc=120 * DEGREES, run_time=3)\n",
        "        self.wait()\n",
        "        self.play(psp_tracker.move_to, [-5, -2, 0], path_arc=0 * DEGREES, run_time=3, rate_func=there_and_back)\n",
        "        self.wait()\n",
        "        self.play(psp_tracker.move_to, [3, 5, 0], path_arc=0 * DEGREES, run_time=3, rate_func=there_and_back)\n",
        "        self.wait()\n",
        "        self.play(psp_tracker.move_to, [5, 3, 0], path_arc=-120 * DEGREES, run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Arrow vs. dot\n",
        "        arrow = Arrow(axes.get_origin(), ps_dot.get_center(), buff=0, fill_color=BLUE)\n",
        "        arrow.set_stroke(BLACK, 2, background=True)\n",
        "        arrow_outline = arrow.copy()\n",
        "        arrow_outline.set_fill(opacity=0)\n",
        "        arrow_outline.set_stroke(YELLOW, 1)\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(arrow),\n",
        "            FadeOut(ps_dot),\n",
        "            ShowPassingFlash(arrow_outline, run_time=1, time_width=0.5),\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(ps_dot),\n",
        "            FadeOut(arrow),\n",
        "            FlashAround(ps_dot, buff=0.05),\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FlashAround(equation))\n",
        "        self.play(psp_tracker.move_to, [4, 3, 0], run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Function of time\n",
        "        new_lhs = Matrix([[\"x(t)\"], [\"y(t)\"]])\n",
        "        new_lhs.match_height(equation[0])\n",
        "        new_lhs.move_to(equation[0], RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransformPieces(equation[0], new_lhs),\n",
        "        )\n",
        "        self.remove(equation[0])\n",
        "        self.add(new_lhs)\n",
        "        equation.replace_submobject(0, new_lhs)\n",
        "\n",
        "        # Initialize rotation\n",
        "        curr_time = self.time\n",
        "        curr_psp = get_psp()\n",
        "        psp_tracker.add_updater(lambda m: m.move_to(np.dot(\n",
        "            curr_psp,\n",
        "            np.transpose(rotation_about_z(0.25 * (self.time - curr_time))),\n",
        "        )))\n",
        "        self.wait(5)\n",
        "\n",
        "        # Rate of change\n",
        "        deriv_lhs = Matrix([[\"x'(t)\"], [\"y'(t)\"]], bracket_h_buff=SMALL_BUFF)\n",
        "        deriv_lhs.match_height(equation[0])\n",
        "        deriv_lhs.move_to(equation[0])\n",
        "        deriv_lhs.set_color(RED_B)\n",
        "        deriv_label = Text(\"Rate of change\", font_size=24)\n",
        "        deriv_label.match_width(deriv_lhs)\n",
        "        deriv_label.match_color(deriv_lhs)\n",
        "        deriv_label.next_to(deriv_lhs, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(deriv_lhs),\n",
        "            Write(deriv_label, run_time=1),\n",
        "            equation.animate.shift(2.0 * deriv_lhs.get_height() * DOWN)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        deriv_vect = Arrow(fill_color=RED_B)\n",
        "        deriv_vect.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                axes.get_origin(),\n",
        "                axes.c2p(-0.5 * get_psp()[1], 0.5 * get_psp()[0])\n",
        "            ).shift(\n",
        "                ps_dot.get_center() - axes.get_origin()\n",
        "            )\n",
        "        )\n",
        "        pre_vect = Arrow(LEFT, RIGHT)\n",
        "        pre_vect.replace(deriv_label, dim_to_match=0)\n",
        "        pre_vect.set_fill(RED_B, 0)\n",
        "        moving_vect = pre_vect.copy()\n",
        "        deriv_vect.set_opacity(0)\n",
        "        self.add(deriv_vect)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                moving_vect,\n",
        "                lambda m, a: m.interpolate(pre_vect, deriv_vect, a).set_fill(opacity=a),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        deriv_vect.set_fill(opacity=1)\n",
        "        self.add(deriv_vect, ps_dot)\n",
        "        self.wait(8)\n",
        "\n",
        "        # Show equation\n",
        "        rhs = VGroup(\n",
        "            OldTex(\"=\"),\n",
        "            Matrix([[\"-y(t)\"], [\"x(t)\"]], bracket_h_buff=SMALL_BUFF)\n",
        "        )\n",
        "        rhs.match_height(deriv_lhs)\n",
        "        rhs.arrange(RIGHT)\n",
        "        rhs.next_to(deriv_lhs, RIGHT)\n",
        "\n",
        "        self.play(FadeIn(rhs))\n",
        "        self.wait()\n",
        "        for i in range(2):\n",
        "            self.play(FlashAround(\n",
        "                VGroup(deriv_lhs.get_entries()[i], rhs[1].get_entries()[i]),\n",
        "                run_time=3,\n",
        "                time_width=4,\n",
        "            ))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Write with a matrix\n",
        "        deriv_lhs.generate_target()\n",
        "        new_eq = VGroup(\n",
        "            deriv_lhs.target,\n",
        "            OldTex(\"=\"),\n",
        "            IntegerMatrix([[0, -1], [1, 0]], bracket_v_buff=MED_LARGE_BUFF),\n",
        "            Matrix([[\"x(t)\"], [\"y(t)\"]], bracket_h_buff=SMALL_BUFF),\n",
        "        )\n",
        "        new_eq[2].match_height(new_eq[0])\n",
        "        new_eq[3].match_height(new_eq[0])\n",
        "        new_eq.arrange(RIGHT)\n",
        "        new_eq.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(deriv_lhs),\n",
        "            MaintainPositionRelativeTo(deriv_label, deriv_lhs),\n",
        "            ReplacementTransform(rhs[0], new_eq[1]),\n",
        "            ReplacementTransform(rhs[1].get_brackets(), new_eq[3].get_brackets()),\n",
        "            FadeIn(new_eq[2], scale=2),\n",
        "            FadeTransform(rhs[1].get_entries()[1], new_eq[3].get_entries()[0]),\n",
        "            FadeTransform(rhs[1].get_entries()[0], new_eq[3].get_entries()[1]),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        row_rect = SurroundingRectangle(new_eq[2].get_entries()[:2], buff=SMALL_BUFF)\n",
        "        col_rect = SurroundingRectangle(new_eq[3].get_entries(), buff=SMALL_BUFF)\n",
        "        both_rects = VGroup(row_rect, col_rect)\n",
        "        both_rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(*map(ShowCreation, both_rects))\n",
        "        self.wait(3)\n",
        "        self.play(row_rect.animate.move_to(new_eq[2].get_entries()[2:4]))\n",
        "        self.wait(3)\n",
        "        self.play(FadeOut(both_rects))\n",
        "\n",
        "        # Write general form\n",
        "        general_form = OldTex(\n",
        "            \"{d \\\\over dt}\",\n",
        "            \"\\\\vec{\\\\textbf{v} }\",\n",
        "            \"(t)\",\n",
        "            \"=\",\n",
        "            \"\\\\textbf{M}\",\n",
        "            \"\\\\vec{\\\\textbf{v} }\",\n",
        "            \"(t)\",\n",
        "        )\n",
        "        general_form.set_color_by_tex(\"d \\\\over dt\", RED_B)\n",
        "        general_form.set_color_by_tex(\"\\\\textbf{v}\", GREY_B)\n",
        "        general_form.scale(1.2)\n",
        "        general_form.next_to(new_eq, DOWN, LARGE_BUFF)\n",
        "        general_form.shift(0.5 * RIGHT)\n",
        "        gf_rect = SurroundingRectangle(general_form, buff=MED_SMALL_BUFF)\n",
        "        gf_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        equation.clear_updaters()\n",
        "        self.play(\n",
        "            FadeIn(general_form),\n",
        "            FadeOut(equation),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(gf_rect))\n",
        "        self.wait(4 * TAU)\n",
        "\n",
        "        # Fade all else out\n",
        "        self.play(FadeOut(VGroup(gf_rect, general_form, new_eq, deriv_lhs, deriv_label)))\n",
        "        self.wait(4 * TAU)\n",
        "        print(self.num_plays)\n",
        "\n",
        "\n",
        "class From2DTo1D(Scene):\n",
        "    show_solution = False\n",
        "\n",
        "    def construct(self):\n",
        "        # (Setup vector equation)\n",
        "        equation = get_2d_equation()\n",
        "        equation.center()\n",
        "        equation.to_edge(UP, buff=1.0)\n",
        "        deriv, vect_sym, equals, matrix_mob, vect_sym2 = equation\n",
        "\n",
        "        vect_sym.save_state()\n",
        "\n",
        "        # (Setup plane)\n",
        "        plane = NumberPlane(\n",
        "            x_range=(-4, 4),\n",
        "            y_range=(-2, 2),\n",
        "            height=4,\n",
        "            width=8,\n",
        "        )\n",
        "        plane.to_edge(DOWN)\n",
        "\n",
        "        point = Point(plane.c2p(2, 0.5))\n",
        "        vector = Arrow(plane.get_origin(), point.get_location(), buff=0)\n",
        "        vector.set_color(YELLOW)\n",
        "\n",
        "        # Show vector\n",
        "        vect_sym.set_x(0)\n",
        "        static_vect_sym = vect_sym.deepcopy()\n",
        "        for entry in static_vect_sym.get_entries():\n",
        "            entry[1:].set_opacity(0)\n",
        "            entry[:1].move_to(entry)\n",
        "        static_vect_sym.get_brackets().space_out_submobjects(0.7)\n",
        "        vector.save_state()\n",
        "        vector.put_start_and_end_on(\n",
        "            static_vect_sym.get_corner(DL),\n",
        "            static_vect_sym.get_corner(UR),\n",
        "        )\n",
        "        vector.set_opacity(0)\n",
        "\n",
        "        self.add(plane, static_vect_sym)\n",
        "        self.play(Restore(vector))\n",
        "        self.wait()\n",
        "\n",
        "        # Changing with time\n",
        "        matrix = np.array([[0.5, -3], [1, -0.5]])\n",
        "\n",
        "        def func(x, y):\n",
        "            return 0.2 * np.dot([x, y], matrix.T)\n",
        "\n",
        "        move_points_along_vector_field(point, func, plane)\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(), point.get_location(),\n",
        "        ))\n",
        "        deriv_vector = Vector(fill_color=RED, thickness=0.03)\n",
        "        deriv_vector.add_updater(\n",
        "            lambda m: m.put_start_and_end_on(\n",
        "                plane.get_origin(),\n",
        "                plane.c2p(*func(*plane.p2c(point.get_location()))),\n",
        "            ).shift(vector.get_vector())\n",
        "        )\n",
        "\n",
        "        self.add(point)\n",
        "        self.play(ReplacementTransform(static_vect_sym, vect_sym))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show matrix equation\n",
        "        deriv_underline = Underline(VGroup(deriv, vect_sym.saved_state))\n",
        "        deriv_underline.set_stroke(RED, 3)\n",
        "        alt_line = deriv_underline.deepcopy()\n",
        "\n",
        "        self.play(\n",
        "            Restore(vect_sym),\n",
        "            FadeIn(deriv),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(deriv_underline),\n",
        "        )\n",
        "        self.play(\n",
        "            VFadeIn(deriv_vector, rate_func=squish_rate_func(smooth, 0.8, 1.0)),\n",
        "            UpdateFromAlphaFunc(\n",
        "                alt_line,\n",
        "                lambda m, a: m.put_start_and_end_on(\n",
        "                    interpolate(deriv_underline.get_start(), deriv_vector.get_start(), a),\n",
        "                    interpolate(deriv_underline.get_end(), deriv_vector.get_end(), a),\n",
        "                ),\n",
        "                remover=True,\n",
        "            ),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, equation[2:4], shift=RIGHT, lag_ratio=0.3),\n",
        "            TransformFromCopy(\n",
        "                equation[1], equation[4], path_arc=-45 * DEGREES,\n",
        "                run_time=2,\n",
        "                rate_func=squish_rate_func(smooth, 0.3, 1.0)\n",
        "            )\n",
        "        )\n",
        "        self.wait(8)\n",
        "\n",
        "        # Highlight equation\n",
        "        deriv_rect = SurroundingRectangle(equation[:2])\n",
        "        deriv_rect.set_stroke(RED, 2)\n",
        "        rhs_rect = SurroundingRectangle(equation[-1])\n",
        "        rhs_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(deriv_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(deriv_rect, rhs_rect, path_arc=-45 * DEGREES))\n",
        "\n",
        "        # Draw vector field\n",
        "        vector_field = VectorField(\n",
        "            func, plane,\n",
        "            magnitude_range=(0, 1.2),\n",
        "            opacity=0.5,\n",
        "            vector_config={\"thickness\": 0.02}\n",
        "        )\n",
        "        vector_field.sort(lambda p: get_norm(p - plane.get_origin()))\n",
        "\n",
        "        self.add(vector_field, deriv_vector, vector)\n",
        "        VGroup(vector, deriv_vector).set_stroke(BLACK, 5, background=True)\n",
        "        self.play(\n",
        "            FadeOut(rhs_rect),\n",
        "            LaggedStartMap(GrowArrow, vector_field, lag_ratio=0)\n",
        "        )\n",
        "        self.wait(14)\n",
        "\n",
        "        # flow_lines = AnimatedStreamLines(StreamLines(func, plane, step_multiple=0.25))\n",
        "        # self.add(flow_lines)\n",
        "        # self.wait(4)\n",
        "        # self.play(VFadeOut(flow_lines))\n",
        "\n",
        "        # self.wait(10)\n",
        "\n",
        "        # Show solution\n",
        "        equation.add(deriv_underline)\n",
        "        mat_exp = get_matrix_exponential(\n",
        "            [[\"a\", \"b\"], [\"c\", \"d\"]],\n",
        "            h_buff=0.75,\n",
        "            v_buff=0.75,\n",
        "        )\n",
        "        mat_exp[1].set_color(TEAL)\n",
        "        if self.show_solution:\n",
        "            equation.generate_target()\n",
        "            equation.target.to_edge(LEFT)\n",
        "            implies = OldTex(\"\\\\Rightarrow\")\n",
        "            implies.next_to(equation.target, RIGHT)\n",
        "            solution = VGroup(\n",
        "                equation[1].copy(),\n",
        "                OldTex(\"=\"),\n",
        "                mat_exp,\n",
        "                Matrix(\n",
        "                    [[\"x(0)\"], [\"y(0)\"]],\n",
        "                    bracket_h_buff=SMALL_BUFF,\n",
        "                    bracket_v_buff=SMALL_BUFF,\n",
        "                )\n",
        "            )\n",
        "            solution[2].match_height(solution[0])\n",
        "            solution[3].match_height(solution[0])\n",
        "            solution.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "            solution.next_to(implies, RIGHT, MED_LARGE_BUFF)\n",
        "            solution.align_to(equation[1], DOWN)\n",
        "            solution_rect = SurroundingRectangle(solution, buff=MED_SMALL_BUFF)\n",
        "\n",
        "            self.play(\n",
        "                MoveToTarget(equation),\n",
        "            )\n",
        "            self.play(LaggedStart(\n",
        "                Write(implies),\n",
        "                ShowCreation(solution_rect),\n",
        "                TransformFromCopy(equation[4], solution[0], path_arc=30 * DEGREES),\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.play(LaggedStart(\n",
        "                TransformFromCopy(equation[3], solution[2][1]),\n",
        "                FadeIn(solution[2][0]),\n",
        "                FadeIn(solution[2][2]),\n",
        "                FadeIn(solution[1]),\n",
        "                FadeIn(solution[3]),\n",
        "                lag_ratio=0.1,\n",
        "            ))\n",
        "            self.wait(10)\n",
        "            return\n",
        "        else:\n",
        "            # Show relation with matrix exp\n",
        "            mat_exp.move_to(equation[0], DOWN)\n",
        "            mat_exp.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "            equation.generate_target()\n",
        "            equation.target.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "            arrow1 = Arrow(equation.target.get_corner(UR), mat_exp.get_corner(UL), path_arc=-45 * DEGREES)\n",
        "            arrow2 = Arrow(mat_exp.get_corner(DL), equation.target.get_corner(DR), path_arc=-45 * DEGREES)\n",
        "            arrow1.shift(0.2 * RIGHT)\n",
        "\n",
        "            self.play(MoveToTarget(equation))\n",
        "            self.play(\n",
        "                FadeIn(mat_exp[0::2]),\n",
        "                TransformFromCopy(equation[3], mat_exp[1]),\n",
        "                Write(arrow1, run_time=1),\n",
        "            )\n",
        "            self.wait(4)\n",
        "            self.play(Write(arrow2, run_time=2))\n",
        "            self.wait(4)\n",
        "\n",
        "            normal_exp = OldTex(\"e^{rt}\")[0]\n",
        "            normal_exp.set_height(1.0)\n",
        "            normal_exp[1].set_color(BLUE)\n",
        "            normal_exp.move_to(mat_exp)\n",
        "            self.play(\n",
        "                FadeTransformPieces(mat_exp, normal_exp),\n",
        "                FadeOut(VGroup(arrow1, arrow2))\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "        # Transition to 1D\n",
        "        max_x = 50\n",
        "        mult = 50\n",
        "        number_line = NumberLine((0, max_x), width=max_x)\n",
        "        number_line.add_numbers()\n",
        "        number_line.move_to(plane)\n",
        "        number_line.to_edge(LEFT)\n",
        "        nl = number_line\n",
        "        nl2 = NumberLine((0, mult * max_x, mult), width=max_x)\n",
        "        nl2.add_numbers()\n",
        "        nl2.set_width(nl.get_width() * mult)\n",
        "        nl2.shift(nl.n2p(0) - nl2.n2p(0))\n",
        "        nl2.set_opacity(0)\n",
        "        nl.add(nl2)\n",
        "\n",
        "        new_equation = OldTex(\n",
        "            \"{d \\\\over dt}\", \"x(t)\", \"=\", \"r \\\\cdot \", \"x(t)\",\n",
        "        )\n",
        "        new_equation[0][3].set_color(GREY_B)\n",
        "        new_equation[1][2].set_color(GREY_B)\n",
        "        new_equation[4][2].set_color(GREY_B)\n",
        "        new_equation[3][0].set_color(BLUE)\n",
        "        new_equation.match_height(equation)\n",
        "        new_equation.move_to(equation)\n",
        "\n",
        "        self.remove(point)\n",
        "        vector.clear_updaters()\n",
        "        deriv_vector.clear_updaters()\n",
        "\n",
        "        self.remove(vector_field)\n",
        "        plane.add(vector_field)\n",
        "        self.add(number_line, deriv_vector, vector)\n",
        "        self.play(\n",
        "            normal_exp.animate.scale(0.5).to_corner(UR),\n",
        "            # Plane to number line\n",
        "            vector.animate.put_start_and_end_on(nl.n2p(0), nl.n2p(1)),\n",
        "            deriv_vector.animate.put_start_and_end_on(nl.n2p(1), nl.n2p(1.5)),\n",
        "            plane.animate.shift(nl.n2p(0) - plane.get_origin()).set_opacity(0),\n",
        "            FadeIn(number_line, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "            # Equation\n",
        "            TransformMatchingShapes(equation[0], new_equation[0]),\n",
        "            Transform(equation[1].get_entries()[0], new_equation[1]),\n",
        "            FadeTransform(equation[2], new_equation[2]),\n",
        "            FadeTransform(equation[3], new_equation[3]),\n",
        "            FadeTransform(equation[4].get_entries()[0], new_equation[4]),\n",
        "            FadeOut(equation[1].get_brackets()),\n",
        "            FadeOut(equation[1].get_entries()[1]),\n",
        "            FadeOut(equation[4].get_brackets()),\n",
        "            FadeOut(equation[4].get_entries()[1]),\n",
        "            FadeOut(deriv_underline),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        vt = ValueTracker(1)\n",
        "        vt.add_updater(lambda m, dt: m.increment_value(0.2 * dt * m.get_value()))\n",
        "\n",
        "        vector.add_updater(lambda m: m.put_start_and_end_on(nl.n2p(0), nl.n2p(vt.get_value())))\n",
        "        deriv_vector.add_updater(lambda m: m.set_width(0.5 * vector.get_width()).move_to(vector.get_right(), LEFT))\n",
        "\n",
        "        self.add(vt)\n",
        "        self.wait(11)\n",
        "        self.play(\n",
        "            number_line.animate.scale(0.3, about_point=nl.n2p(0)),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        number_line.generate_target()\n",
        "        number_line.target.scale(0.1, about_point=nl.n2p(0)),\n",
        "        number_line.target[-1].set_opacity(1)\n",
        "        self.play(\n",
        "            MoveToTarget(number_line)\n",
        "        )\n",
        "        self.wait(11)\n",
        "        self.play(number_line.animate.scale(0.2, about_point=nl.n2p(0)))\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class SchroedingersEquationIntro(Scene):\n",
        "    def construct(self):\n",
        "        # Show equation\n",
        "        title = Text(\"Schr\u00f6dinger equation\", font_size=72)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        t2c = {\n",
        "            \"|\\\\psi \\\\rangle\": BLUE,\n",
        "            \"{H}\": GREY_A,\n",
        "            \"=\": WHITE,\n",
        "            \"i\\\\hbar\": WHITE,\n",
        "        }\n",
        "        original_equation = OldTex(\n",
        "            \"i\\\\hbar \\\\frac{\\\\partial}{\\\\partial t} |\\\\psi \\\\rangle = {H} |\\\\psi \\\\rangle\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        equation = OldTex(\n",
        "            \"\\\\frac{\\\\partial}{\\\\partial t} |\\\\psi \\\\rangle = \\\\frac{1}{i\\\\hbar} {H} |\\\\psi \\\\rangle\",\n",
        "            tex_to_color_map=t2c\n",
        "        )\n",
        "        VGroup(original_equation, equation).scale(1.5)\n",
        "\n",
        "        psis = original_equation.get_parts_by_tex(\"\\\\psi\")\n",
        "        state_label = OldTexText(\"State of a system \\\\\\\\ as a vector\", font_size=36)\n",
        "        state_label.next_to(psis, DOWN, buff=1.5)\n",
        "        state_label.shift(0.5 * RIGHT)\n",
        "        state_arrows = VGroup(*(Arrow(state_label, psi) for psi in psis))\n",
        "        state_label.match_color(psis[0])\n",
        "        state_arrows.match_color(psis[0])\n",
        "        psis.set_color(WHITE)\n",
        "\n",
        "        randy = Randolph(height=2.0, color=BLUE_C)\n",
        "        randy.to_corner(DL)\n",
        "        randy.set_opacity(0)\n",
        "\n",
        "        self.play(Write(original_equation, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.animate.set_opacity(1).change(\"horrified\", original_equation)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change(\"pondering\", state_label),\n",
        "            psis.animate.match_color(state_label),\n",
        "            FadeIn(state_label, 0.25 * DOWN),\n",
        "            *map(GrowArrow, state_arrows),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(original_equation[1:4], equation[0:3]),\n",
        "            Write(equation[3]),\n",
        "            ReplacementTransform(original_equation[0], equation[4], path_arc=90 * DEGREES),\n",
        "            ReplacementTransform(original_equation[4:], equation[5:]),\n",
        "            state_arrows.animate.become(\n",
        "                VGroup(*(Arrow(state_label, psi) for psi in equation.get_parts_by_tex(\"\\\\psi\")))\n",
        "            ),\n",
        "            randy.change(\"hesitant\", equation)\n",
        "        )\n",
        "        self.play(FlashAround(equation[0], time_width=2, run_time=2))\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        mat_rect = SurroundingRectangle(equation[3:6], buff=0.05, color=TEAL)\n",
        "        mat_label = Text(\"A certain matrix\", font_size=36)\n",
        "        mat_label.next_to(mat_rect, UP)\n",
        "        mat_label.match_color(mat_rect)\n",
        "        self.play(\n",
        "            ShowCreation(mat_rect),\n",
        "            FadeIn(mat_label, 0.25 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(randy.change(\"confused\", equation))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Complicating factors\n",
        "        psi_words = OldTexText(\n",
        "            \"Often this is a function.\\\\\\\\\",\n",
        "            \"(But whatever functions are really\\\\\\\\just infinite-dimensional vectors)\"\n",
        "        )\n",
        "        psi_words[0].match_width(psi_words[1], about_edge=DOWN)\n",
        "        psi_words[1].shift(0.1 * DOWN)\n",
        "        psi_words.scale(0.75)\n",
        "        psi_words.move_to(state_label, UP)\n",
        "        psi_words[0].set_color(RED)\n",
        "        psi_words[1].set_color(RED_D)\n",
        "\n",
        "        mat_line = Line(LEFT, RIGHT)\n",
        "        mat_line.set_stroke(RED, 5)\n",
        "        mat_line.replace(mat_label.get_part_by_text(\"matrix\"), dim_to_match=0)\n",
        "\n",
        "        operator_word = Text(\"operator\", font_size=36)\n",
        "        operator_word.next_to(mat_label, UP, buff=SMALL_BUFF)\n",
        "        operator_word.align_to(mat_line, LEFT)\n",
        "        operator_word.set_color(RED)\n",
        "\n",
        "        complex_valued = Text(\"Complex-valued\", font_size=30)\n",
        "        complex_valued.set_color(RED)\n",
        "        complex_valued.next_to(equation, RIGHT)\n",
        "        complex_valued.to_edge(RIGHT)\n",
        "        cv_arrow = Arrow(complex_valued, equation, fill_color=RED)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(state_label),\n",
        "            FadeIn(psi_words),\n",
        "            ShowCreation(mat_line),\n",
        "            Write(operator_word, run_time=1),\n",
        "            GrowArrow(cv_arrow),\n",
        "            FadeIn(complex_valued),\n",
        "            randy.change(\"horrified\", equation),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleDerivativeOfExp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        eq = OldTex(\n",
        "            \"{d \\\\over dt}\", \"e^{rt}\", \"=\", \"r\", \"e^{rt}\",\n",
        "        )\n",
        "        eq.set_color_by_tex(\"r\", TEAL, substring=False)\n",
        "        for part in eq.get_parts_by_tex(\"e^{rt}\"):\n",
        "            part[1].set_color(TEAL)\n",
        "\n",
        "        s0, s1, s2 = self.students\n",
        "        morty = self.teacher\n",
        "        bubble = s2.get_bubble(eq)\n",
        "\n",
        "        self.play(\n",
        "            s2.change(\"pondering\", eq),\n",
        "            FadeIn(bubble, lag_ratio=0.2),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                s0.change(\"hesitant\", eq),\n",
        "                s1.change(\"erm\", eq),\n",
        "                morty.change(\"tease\"),\n",
        "            ),\n",
        "            Write(eq[:2])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(*eq.get_parts_by_tex(\"e^{rt}\"), path_arc=45 * DEGREES),\n",
        "            Write(eq.get_part_by_tex(\"=\")),\n",
        "            *(\n",
        "                pi.animate.look_at(eq[4])\n",
        "                for pi in self.pi_creatures\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(eq[4][1].copy(), eq[3][0], path_arc=90 * DEGREES)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                s0.change(\"thinking\"),\n",
        "                s1.change(\"tease\"),\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        rect = ScreenRectangle(height=3.5)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        rect.set_stroke(BLUE_B, 2)\n",
        "        rect.to_corner(UR)\n",
        "        self.play(\n",
        "            morty.change(\"raise_right_hand\", rect),\n",
        "            self.change_students(\"pondering\", \"pondering\", \"pondering\", look_at=rect),\n",
        "            FadeIn(rect, UP)\n",
        "        )\n",
        "        self.wait(10)\n",
        "\n",
        "\n",
        "class ETitleCard(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"A brief review of $e$\\\\\\\\and exponentials\")\n",
        "        title.scale(2)\n",
        "        self.add(title)\n",
        "\n",
        "\n",
        "class GraphAndHistoryOfExponential(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        axes = Axes(\n",
        "            x_range=(0, 23, 1),\n",
        "            y_range=(0, 320, 10),\n",
        "            height=160,\n",
        "            width=13,\n",
        "            axis_config={\"include_tip\": False}\n",
        "        )\n",
        "        axes.y_axis.add(*(axes.y_axis.get_tick(x, size=0.05) for x in range(20)))\n",
        "        axes.to_corner(DL)\n",
        "        r = 0.25\n",
        "        exp_graph = axes.get_graph(lambda t: np.exp(r * t))\n",
        "        exp_graph.set_stroke([BLUE_E, BLUE, YELLOW])\n",
        "        graph_template = exp_graph.copy()\n",
        "        graph_template.set_stroke(width=0)\n",
        "        axes.add(graph_template)\n",
        "\n",
        "        equation = self.get_equation()\n",
        "        solution = OldTex(\"x({t}) = e^{r{t} }\", tex_to_color_map={\"{t}\": GREY_B, \"r\": BLUE})\n",
        "        solution.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(axes.get_x_axis_label(\"t\"))\n",
        "        self.add(axes.get_y_axis_label(\"x\"))\n",
        "        self.add(equation)\n",
        "\n",
        "        curr_time = self.time\n",
        "        exp_graph.add_updater(lambda m: m.pointwise_become_partial(\n",
        "            graph_template, 0, (self.time - curr_time) / 20,\n",
        "        ))\n",
        "        dot = Dot(color=BLUE_B, radius=0.04)\n",
        "        dot.add_updater(lambda d: d.move_to(exp_graph.get_end()))\n",
        "        vect = Arrow(DOWN, UP, fill_color=YELLOW, thickness=0.025)\n",
        "        vect.add_updater(lambda v: v.put_start_and_end_on(\n",
        "            axes.get_origin(),\n",
        "            axes.y_axis.get_projection(exp_graph.get_end()),\n",
        "        ))\n",
        "        h_line = always_redraw(lambda: DashedLine(\n",
        "            vect.get_end(), dot.get_left(),\n",
        "            stroke_width=1,\n",
        "            stroke_color=GREY_B,\n",
        "        ))\n",
        "        v_line = always_redraw(lambda: DashedLine(\n",
        "            axes.x_axis.get_projection(dot.get_bottom()),\n",
        "            dot.get_bottom(),\n",
        "            stroke_width=1,\n",
        "            stroke_color=GREY_B,\n",
        "        ))\n",
        "\n",
        "        def stretch_axes(factor):\n",
        "            axes.generate_target(use_deepcopy=True)\n",
        "            axes.target.stretch(factor, 1, about_point=axes.get_origin()),\n",
        "            axes.target.x_axis.stretch(1 / factor, 1, about_point=axes.get_origin()),\n",
        "            self.play(MoveToTarget(axes))\n",
        "\n",
        "        self.add(exp_graph, dot, vect, h_line, v_line)\n",
        "        # equation.scale(2, about_edge=UP)###\n",
        "        self.wait(2)\n",
        "\n",
        "        # Highlight equation parts\n",
        "        index = equation.index_of_part_by_tex(\"=\")\n",
        "        lhs = equation[:index]\n",
        "        rhs = equation[index + 1:]\n",
        "\n",
        "        for part in (rhs, lhs):\n",
        "            self.play(FlashAround(part, time_width=3, run_time=2))\n",
        "            self.wait()\n",
        "        # self.wait(4)\n",
        "\n",
        "        stretch_axes(0.2)\n",
        "\n",
        "        self.wait(6)\n",
        "        stretch_axes(0.23)\n",
        "        self.wait(4)\n",
        "\n",
        "        exp_graph.clear_updaters()\n",
        "        exp_graph.become(graph_template)\n",
        "        exp_graph.set_stroke(width=3)\n",
        "        self.add(exp_graph)\n",
        "        self.play(FadeOut(vect), FadeOut(dot))\n",
        "        self.wait()\n",
        "\n",
        "        # Write exponential growth\n",
        "        words = Text(\"Exponential growth\")\n",
        "        words.next_to(axes.c2p(0, 0), UR, buff=0)\n",
        "        original_words = words.deepcopy()\n",
        "        original_words.set_opacity(0)\n",
        "\n",
        "        def func(p):\n",
        "            t, x = axes.p2c(p)\n",
        "            angle = axes.angle_of_tangent(t, exp_graph)\n",
        "            vect = rotate_vector(RIGHT, angle + PI / 2)\n",
        "            graph_point = axes.input_to_graph_point(t, exp_graph)\n",
        "            y = (axes.y_axis.get_projection(p) - axes.get_origin())[1]\n",
        "            return graph_point + y * vect\n",
        "\n",
        "        fill_tracker = ValueTracker(0)\n",
        "        words.add_updater(lambda m: m.become(original_words).set_fill(opacity=fill_tracker.get_value()).apply_function(func))\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            ApplyMethod(original_words.next_to, axes.c2p(14, 0), UP, SMALL_BUFF, run_time=2),\n",
        "            fill_tracker.animate.set_value(1),\n",
        "        )\n",
        "        self.remove(original_words, fill_tracker)\n",
        "        words.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        # Introduce 2.71828\n",
        "        solution_with_number = OldTex(\n",
        "            \"{d \\\\over dt}\",\n",
        "            \"(2.71828...)^{\", \"r\", \"t\", \"}\",\n",
        "            \"=\",\n",
        "            \"r\", \"\\\\cdot\",\n",
        "            \"(2.71828...)^{\", \"r\", \"t\", \"}\",\n",
        "            tex_to_color_map={\n",
        "                \"2.71828...\": TEAL,\n",
        "            }\n",
        "        )\n",
        "        solution_with_e = OldTex(\n",
        "            \"{d \\\\over dt}\",\n",
        "            \"{e}^{\", \"r\", \"t\", \"}\",\n",
        "            \"=\",\n",
        "            \"r\", \"\\\\cdot\",\n",
        "            \"{e}^{\", \"r\", \"t\", \"}\",\n",
        "            tex_to_color_map={\n",
        "                \"{e}\": TEAL,\n",
        "            }\n",
        "        )\n",
        "        for eq in solution_with_number, solution_with_e:\n",
        "            eq.set_color_by_tex(\"r\", BLUE, substring=False)\n",
        "            eq.set_color_by_tex(\"t\", GREY_B, substring=False)\n",
        "            eq.next_to(equation, DOWN, buff=MED_LARGE_BUFF)\n",
        "        lhs = solution_with_number[:6]\n",
        "        lhs.save_state()\n",
        "        lhs.match_x(equation)\n",
        "\n",
        "        self.play(FadeIn(lhs[1:], DOWN))\n",
        "        self.wait()\n",
        "        self.play(Write(lhs[0]))\n",
        "\n",
        "        dot1 = Dot(radius=0.05, color=RED)\n",
        "        dot2 = dot1.copy()\n",
        "        for sec_dot in dot1, dot2:\n",
        "            sec_dot.x_tracker = ValueTracker(15)\n",
        "            sec_dot.add_updater(lambda d: d.move_to(axes.input_to_graph_point(\n",
        "                d.x_tracker.get_value(), exp_graph\n",
        "            )))\n",
        "        line = Line(LEFT, RIGHT, stroke_color=GREY_A, stroke_width=2)\n",
        "        line.add_updater(lambda l: l.put_start_and_end_on(\n",
        "            dot1.get_center(), dot2.get_center()\n",
        "        ).set_length(10))\n",
        "\n",
        "        dot2.x_tracker.set_value(17)\n",
        "        dot1.x_tracker.set_value(15)\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeIn(dot1),\n",
        "            FadeIn(dot2),\n",
        "            FadeIn(line),\n",
        "        )\n",
        "        self.play(\n",
        "            dot2.x_tracker.animate.set_value(15 + 1e-6),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            dot1.x_tracker.animate.set_value(18),\n",
        "            dot2.x_tracker.animate.set_value(18 + 1e-6),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(dot1),\n",
        "            FadeOut(dot2),\n",
        "            FadeOut(line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Restore(lhs))\n",
        "        self.play(\n",
        "            FadeIn(solution_with_number[6]),\n",
        "            TransformFromCopy(lhs[1:], solution_with_number[8:], path_arc=30 * DEGREES),\n",
        "        )\n",
        "        self.play(TransformFromCopy(\n",
        "            solution_with_number[12], solution_with_number[7],\n",
        "            path_arc=-90 * DEGREES,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Historical letters\n",
        "        correspondants = Group()\n",
        "        for name1, name2, letter, year in [(\"Leibniz\", \"Huygens\", \"b\", \"1690\"), (\"Euler\", \"Goldbach\", \"e\", \"1731\")]:\n",
        "            im1 = ImageMobject(name1, height=2.5)\n",
        "            im2 = ImageMobject(name2, height=2.5)\n",
        "\n",
        "            lines = VGroup(*(Line(LEFT, RIGHT) for x in range(11)))\n",
        "            lines.set_width(1.6)\n",
        "            lines.arrange(DOWN, buff=0.2)\n",
        "            lines.set_stroke(GREY_A, 2)\n",
        "            lines[-1].stretch(0.5, 0, about_edge=LEFT)\n",
        "\n",
        "            eq = OldTex(letter, \"= 2.71828\\\\dots\")\n",
        "            eq[0].scale(1.5, about_edge=RIGHT)\n",
        "            eq[0].align_to(eq[1], DOWN)\n",
        "            eq.set_color(TEAL)\n",
        "            eq.match_width(lines)\n",
        "            eq.move_to(lines[5])\n",
        "            lines.remove(*lines[4:7])\n",
        "            lines.add(eq)\n",
        "            box = SurroundingRectangle(lines, buff=0.25)\n",
        "            box.set_stroke(GREY_C, 2)\n",
        "            note = VGroup(box, lines)\n",
        "            note.match_height(im1)\n",
        "\n",
        "            group = Group()\n",
        "            arrow = Vector(0.5 * RIGHT, fill_color=GREY_A)\n",
        "            group.add(im1, arrow, note, arrow.copy(), im2)\n",
        "            group.arrange(RIGHT)\n",
        "            note.align_to(im1, UP)\n",
        "            group.next_to(solution_with_number, DOWN, buff=LARGE_BUFF)\n",
        "\n",
        "            for im, name, index in [(im1, name1, 0), (im2, name2, 4)]:\n",
        "                name_label = Text(name, font_size=24)\n",
        "                name_label.set_color(GREY_A)\n",
        "                name_label.next_to(im, DOWN)\n",
        "                rect = SurroundingRectangle(im, buff=0, stroke_color=GREY_A, stroke_width=1)\n",
        "                group.replace_submobject(index, Group(im, rect, name_label))\n",
        "\n",
        "            date = Text(year, font_size=24)\n",
        "            date.next_to(box, UP)\n",
        "            note.add(date)\n",
        "            group.eq = eq\n",
        "            group.eq.set_opacity(0)\n",
        "\n",
        "            correspondants.add(group)\n",
        "\n",
        "        b_group, e_group = correspondants\n",
        "        self.play(LaggedStartMap(FadeIn, b_group, shift=0.5 * UP, lag_ratio=0.2, run_time=1))\n",
        "        b_group.eq.set_fill(opacity=1)\n",
        "        self.play(Write(b_group.eq, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, b_group, shift=0.5 * UP),\n",
        "            LaggedStartMap(FadeIn, e_group, shift=0.5 * UP),\n",
        "        )\n",
        "        e_group.eq.set_fill(opacity=1)\n",
        "        self.play(Write(e_group.eq, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Euler's book\n",
        "        e_usage = e_group.eq.copy()\n",
        "        book = ImageMobject(\"Introductio_in_Analysin_infinitorum\")\n",
        "        book.match_width(e_group[0][0])\n",
        "        book.move_to(e_group[2][0])\n",
        "        date = Text(\"1748\", font_size=24)\n",
        "        date.next_to(book, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, e_group[2:], shift=0.5 * RIGHT),\n",
        "            FadeIn(book),\n",
        "            FadeIn(date),\n",
        "            e_usage.animate.scale(1.4).next_to(book, RIGHT, aligned_edge=UP).shift(0.25 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pi_eq = OldTex(\"\\\\pi = 3.1415\\\\dots\", fill_color=GREEN, font_size=36)\n",
        "        func_eq = OldTex(\"f(x)\", font_size=36)\n",
        "        pi_eq.next_to(e_usage, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        func_eq.next_to(pi_eq, DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(Write(pi_eq, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(Write(func_eq, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Final notation\n",
        "        self.play(FadeTransformPieces(solution_with_number, solution_with_e))\n",
        "        self.wait()\n",
        "\n",
        "    def get_equation(self, r=\"r\"):\n",
        "        return get_1d_equation(r).to_edge(UP)\n",
        "\n",
        "\n",
        "class BernoullisThoughts(Scene):\n",
        "    def construct(self):\n",
        "        im = ImageMobject(\"Jacob_Bernoulli\", height=4)\n",
        "        name = Text(\"Jacob Bernoulli\")\n",
        "        name.match_width(im)\n",
        "        name.next_to(im, DOWN, SMALL_BUFF)\n",
        "        jacob = Group(im, name)\n",
        "        jacob.to_corner(DR)\n",
        "\n",
        "        bubble = ThoughtBubble(height=3.5, width=5)\n",
        "        bubble.pin_to(jacob)\n",
        "        bubble.shift(0.25 * RIGHT + 0.75 * DOWN)\n",
        "\n",
        "        dollars = Text(\"$$$\")\n",
        "        dollars.set_height(1)\n",
        "        dollars.set_color(GREEN)\n",
        "        dollars.move_to(bubble.get_bubble_center())\n",
        "\n",
        "        dollar = dollars[0].copy()\n",
        "        continuous_money = VGroup(*(\n",
        "            dollar.copy().shift(smooth(x) * RIGHT * 2.0 + np.exp(smooth(x) - 1) * UP)\n",
        "            for x in np.linspace(0, 1, 300)\n",
        "        ))\n",
        "        continuous_money.set_fill(opacity=0.1)\n",
        "        continuous_money.center()\n",
        "        continuous_money.move_to(dollars)\n",
        "\n",
        "        self.play(FadeIn(jacob, shift=RIGHT))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(dollars)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(continuous_money)\n",
        "        self.play(\n",
        "            FadeOut(dollars),\n",
        "            Write(continuous_money, stroke_color=GREEN, stroke_width=1, run_time=3),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(continuous_money, lag_ratio=0.01),\n",
        "            FadeIn(dollars)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        limit = OldTex(\"\\\\left(1 + \\\\frac{r}{n}\\\\right)^{nt}\")\n",
        "        limit.move_to(bubble.get_bubble_center())\n",
        "        limit.scale(1.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(dollars),\n",
        "            FadeIn(limit),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CompoundInterestPopulationAndEpidemic(Scene):\n",
        "    def construct(self):\n",
        "        N = 16000\n",
        "        points = 2 * np.random.random((N, 3)) - 1\n",
        "        points[:, 2] = 0\n",
        "        points = points[[get_norm(p) < 1 for p in points]]\n",
        "        points *= 2 * FRAME_WIDTH\n",
        "        points = np.array(list(sorted(\n",
        "            points, key=lambda p: get_norm(p) + 0.5 * random.random()\n",
        "        )))\n",
        "\n",
        "        dollar = OldTex(\"\\\\$\")\n",
        "        dollar.set_fill(GREEN)\n",
        "        person = SVGMobject(\"person\")\n",
        "        person.set_fill(GREY_B, 1)\n",
        "        virus = SVGMobject(\"virus\")\n",
        "        virus.set_fill([RED, RED_D])\n",
        "        virus.remove(virus[1:])\n",
        "        virus[0].set_points(virus[0].get_subpaths()[0])\n",
        "        templates = [dollar, person, virus]\n",
        "        mob_height = 0.25\n",
        "\n",
        "        for mob in templates:\n",
        "            mob.set_stroke(BLACK, 1, background=True)\n",
        "            mob.set_height(mob_height)\n",
        "\n",
        "        dollars, people, viruses = groups = [\n",
        "            VGroup(*(mob.copy().move_to(point) for point in points))\n",
        "            for mob in templates\n",
        "        ]\n",
        "\n",
        "        dollars.set_submobjects(dollars[:20])\n",
        "        people.set_submobjects(people[:500])\n",
        "\n",
        "        start_time = self.time\n",
        "\n",
        "        def get_n():\n",
        "            time = self.time - start_time\n",
        "            return int(math.exp(0.75 * time))\n",
        "\n",
        "        def update_group(group):\n",
        "            group.set_opacity(0)\n",
        "            group[:get_n()].set_opacity(0.9)\n",
        "\n",
        "        def update_height(group, alpha):\n",
        "            for mob in group:\n",
        "                mob.set_height(max(alpha * mob_height, 1e-4))\n",
        "\n",
        "        for group in groups:\n",
        "            group.add_updater(update_group)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(2)\n",
        "        frame.add_updater(lambda m, dt: m.set_height(m.get_height() * (1 + 0.2 * dt)))\n",
        "        self.add(frame)\n",
        "\n",
        "        self.add(dollars)\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(people, update_height),\n",
        "            UpdateFromAlphaFunc(dollars, update_height, rate_func=lambda t: smooth(1 - t), remover=True),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(viruses, update_height),\n",
        "            UpdateFromAlphaFunc(people, update_height, rate_func=lambda t: smooth(1 - t), remover=True),\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class CovidPlot(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class Compare1DTo2DEquations(Scene):\n",
        "    def construct(self):\n",
        "        eq1d = get_1d_equation()\n",
        "        eq2d = get_2d_equation()\n",
        "        eq1d.match_height(eq2d)\n",
        "\n",
        "        equations = VGroup(eq1d, eq2d)\n",
        "        equations.arrange(DOWN, buff=2.0)\n",
        "        equations.to_edge(LEFT, buff=1.0)\n",
        "\n",
        "        solutions = VGroup(\n",
        "            OldTex(\"e^{rt}\", tex_to_color_map={\"r\": BLUE}),\n",
        "            get_matrix_exponential(\n",
        "                [[\"a\", \"b\"], [\"c\", \"d\"]],\n",
        "                h_buff=0.75,\n",
        "                v_buff=0.5,\n",
        "                bracket_h_buff=0.25,\n",
        "            )\n",
        "        )\n",
        "        solutions[1][1].set_color(TEAL)\n",
        "        solutions[0].scale(2)\n",
        "        arrows = VGroup()\n",
        "        for eq, sol in zip(equations, solutions):\n",
        "            sol.next_to(eq[-1], RIGHT, index_of_submobject_to_align=0)\n",
        "            sol.set_x(4)\n",
        "            arrows.add(Arrow(eq, sol[0], buff=0.5))\n",
        "\n",
        "        sol0, sol1 = solutions\n",
        "        sol0.save_state()\n",
        "        sol0.center()\n",
        "        self.add(sol0)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(sol0),\n",
        "            TransformFromCopy(Arrow(eq1d, sol0, fill_opacity=0), arrows[0]),\n",
        "            FadeIn(eq1d),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            TransformMatchingShapes(sol0.copy(), sol1, fade_transform_mismatches=True),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(*arrows),\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(m1.copy(), m2)\n",
        "                for m1, m2 in zip(\n",
        "                    [eq1d[:2], eq1d[2:5], eq1d[5], eq1d[6], eq1d[7:]],\n",
        "                    eq2d\n",
        "                )\n",
        "            ), lag_ratio=0.05)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EVideoWrapper(VideoWrapper):\n",
        "    title = \"Video on $e^x$\"\n",
        "\n",
        "\n",
        "class ManyExponentialForms(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class EBaseMisconception(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR)\n",
        "        self.add(randy)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, OldTexText(\"This function is\\\\\\\\about about $e$\", tex_to_color_map={\"$e$\": BLUE}),\n",
        "                target_mode=\"thinking\",\n",
        "                bubble_config={\"height\": 3, \"width\": 4},\n",
        "            )\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait(2)\n",
        "        self.play(randy.change(\"tease\"))\n",
        "        self.play(Blink(randy))\n",
        "        cross = Cross(randy.bubble.content, stroke_width=[0, 5, 5, 5, 0])\n",
        "        for line in cross:\n",
        "            line.insert_n_curves(10)\n",
        "        cross.scale(1.25)\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            randy.change(\"guilty\")\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class OneFinalPoint(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"One final point\\\\\\\\about one-dimension\"),\n",
        "            bubble_config={\"height\": 3, \"width\": 4},\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"hesitant\", \"tease\",\n",
        "            added_anims=[self.teacher.animate.look_at(self.students[2])]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class ManySolutionsDependingOnInitialCondition(VideoWrapper):\n",
        "    def construct(self):\n",
        "        # Setup graphs and equations\n",
        "        axes = Axes(\n",
        "            x_range=(0, 12),\n",
        "            y_range=(0, 10),\n",
        "            width=12,\n",
        "            height=6,\n",
        "        )\n",
        "        axes.add(axes.get_x_axis_label(\"t\"))\n",
        "        axes.add(axes.get_y_axis_label(\"x\"))\n",
        "        axes.x_axis.add_numbers()\n",
        "        equation = get_1d_equation(\"0.3\").to_edge(UP)\n",
        "\n",
        "        def get_graph(x0, r=0.3):\n",
        "            return axes.get_graph(lambda t: np.exp(r * t) * x0)\n",
        "\n",
        "        step = 0.05\n",
        "        graphs = VGroup(*(\n",
        "            get_graph(x0)\n",
        "            for x0 in np.arange(step, axes.y_range[1], step)\n",
        "        ))\n",
        "        graphs.set_submobject_colors_by_gradient(BLUE_E, BLUE, TEAL, YELLOW)\n",
        "        graphs.set_stroke(width=1)\n",
        "        graph = get_graph(1)\n",
        "        graph.set_color(BLUE)\n",
        "\n",
        "        solution = OldTex(\n",
        "            \"x({t}) = e^{0.3 {t} } \\\\cdot x_0\",\n",
        "            tex_to_color_map={\"{t}\": GREY_B, \"0.3\": BLUE, \"=\": WHITE},\n",
        "        )\n",
        "        solution.next_to(equation, DOWN, LARGE_BUFF)\n",
        "        solution.shift(0.25 * RIGHT)\n",
        "        solution[-1][1:].set_fill(MAROON_B)\n",
        "\n",
        "        group = VGroup(solution, equation)\n",
        "        group.set_stroke(BLACK, 5, background=True)\n",
        "        group.shift(2 * LEFT)\n",
        "\n",
        "        labels = VGroup(\n",
        "            Text(\"Differential equation\", font_size=30),\n",
        "            Text(\"Solution\", font_size=30),\n",
        "        )\n",
        "        labels.set_stroke(BLACK, 5, background=True)\n",
        "        arrows = VGroup()\n",
        "        for label, eq in zip(labels, [equation, solution[:-1]]):\n",
        "            label.next_to(eq, RIGHT, buff=1.5)\n",
        "            label.align_to(labels[0], LEFT)\n",
        "            arrows.add(Arrow(label, eq))\n",
        "\n",
        "        eq_label, sol_label = labels\n",
        "        eq_arrow, sol_arrow = arrows\n",
        "\n",
        "        # Show many possible representations\n",
        "        alt_rhs = OldTex(\n",
        "            \"&= 2^{(0.4328\\\\dots) t }\\\\\\\\\",\n",
        "            \"&= 3^{(0.2730\\\\dots) t }\\\\\\\\\",\n",
        "            \"&= 4^{(0.2164\\\\dots) t }\\\\\\\\\",\n",
        "            \"&= 5^{(0.1864\\\\dots) t }\\\\\\\\\",\n",
        "        )\n",
        "        alt_rhs.next_to(solution.get_part_by_tex(\"=\"), DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        alt_rhs.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        choice_words = Text(\"This is a choice!\", color=YELLOW, font_size=24)\n",
        "        choice_words.next_to(solution[:-1], RIGHT, MED_LARGE_BUFF)\n",
        "        choice_words.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(solution[:-1])\n",
        "\n",
        "        self.play(ShowCreation(graph, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(FlashAround(solution.get_part_by_tex(\"e\"), time_width=2, buff=0.05, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeIn, alt_rhs, shift=0.5 * DOWN, lag_ratio=0.6, run_time=5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            alt_rhs.animate.set_opacity(0.4),\n",
        "            FlashAround(solution[4:-1]),\n",
        "            Write(choice_words, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(solution[:3].copy(), equation[2:5]),  # x(t)\n",
        "            FadeTransform(solution[:3].copy(), equation[7:10]),  # x(t)\n",
        "            FadeTransform(solution[3].copy(), equation[5]),  # =\n",
        "            FadeIn(equation[:2]),\n",
        "            FadeOut(choice_words),\n",
        "        )\n",
        "        self.play(FadeTransform(solution[5].copy(), equation[6]))  # r\n",
        "        self.wait()\n",
        "        self.play(alt_rhs.animate.set_opacity(1.0))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, alt_rhs, shift=DOWN))\n",
        "        for label, arrow in zip(labels, arrows):\n",
        "            self.play(\n",
        "                FadeIn(label, 0.5 * RIGHT),\n",
        "                GrowArrow(arrow),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Just one solution\n",
        "        one = Text(\"One\", font_size=30)\n",
        "        many = Text(\"out of many\", font_size=30)\n",
        "        one.move_to(sol_label.get_corner(UL), LEFT)\n",
        "        sol_label.generate_target()\n",
        "        group = VGroup(\n",
        "            VGroup(one, sol_label.target).arrange(RIGHT, buff=MED_SMALL_BUFF, aligned_edge=DOWN),\n",
        "            many\n",
        "        )\n",
        "        group.arrange(DOWN, buff=0.15)\n",
        "        group.move_to(sol_label, LEFT)\n",
        "\n",
        "        dot = Dot().scale(2 / 3)\n",
        "        dot.move_to(axes.c2p(0, 0))\n",
        "\n",
        "        self.add(graphs, graph, equation, solution[:-1], arrows, labels, one, many)\n",
        "        self.play(\n",
        "            MoveToTarget(sol_label, rate_func=squish_rate_func(smooth, 0, 0.5)),\n",
        "            FadeIn(one),\n",
        "            FadeIn(many),\n",
        "            ShowIncreasingSubsets(graphs),\n",
        "            dot.animate.move_to(axes.c2p(0, 10)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sol_label = VGroup(one, sol_label, many)\n",
        "\n",
        "        # Initial conditions\n",
        "        ic_label = Text(\"Initial conditions\")\n",
        "        ic_label.rotate(90 * DEGREES)\n",
        "        ic_label.next_to(axes.y_axis, LEFT)\n",
        "\n",
        "        x0_tracker = ValueTracker(1)\n",
        "        get_x0 = x0_tracker.get_value\n",
        "        x0_label = VGroup(\n",
        "            OldTex(\"x_0 = \", font_size=36),\n",
        "            DecimalNumber(1, font_size=36),\n",
        "        )\n",
        "        x0_label.set_color(MAROON_B)\n",
        "        x0_label[1].match_height(x0_label[0])\n",
        "        x0_label[1].next_to(x0_label[0][0][2], RIGHT, SMALL_BUFF)\n",
        "        x0_label.add_updater(lambda m: m[1].set_value(get_x0()).set_color(MAROON_B))\n",
        "        sv = x0_label.get_width() + MED_SMALL_BUFF\n",
        "        x0_label.add_updater(lambda m: m.move_to(axes.c2p(0, get_x0()), LEFT).shift(sv * LEFT))\n",
        "\n",
        "        self.play(\n",
        "            Write(ic_label),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            dot.animate.move_to(axes.c2p(0, 1)),\n",
        "            graphs.animate.set_stroke(opacity=0.5),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        graph.add_updater(lambda g: g.match_points(get_graph(get_x0())))\n",
        "        dot.add_updater(lambda d: d.move_to(axes.c2p(0, get_x0())))\n",
        "\n",
        "        rect = BackgroundRectangle(x0_label)\n",
        "        rect.set_fill(BLACK, 1)\n",
        "        self.add(x0_label, rect, ic_label)\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            FadeOut(ic_label),\n",
        "            self.camera.frame.animate.shift(0.6 * LEFT)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            x0_tracker.animate.set_value(0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        for x in [5, 9]:\n",
        "            self.play(\n",
        "                x0_tracker.animate.set_value(x),\n",
        "                run_time=5\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                x0_tracker.animate.set_value(1),\n",
        "                run_time=3,\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Show general solution\n",
        "        new_sol_label = Text(\"General solution\", font_size=36)\n",
        "        new_sol_label.move_to(sol_label, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(x0_label[0][0][:2], solution[-1]),\n",
        "            sol_arrow.animate.become(Arrow(sol_label, solution))\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(sol_label),\n",
        "            FadeIn(new_sol_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rhs = solution[4:].copy()\n",
        "        rhs_rect = SurroundingRectangle(rhs, stroke_width=2)\n",
        "        rhs.generate_target()\n",
        "        index = equation.index_of_part(equation.get_parts_by_tex(\"x\")[1])\n",
        "        rhs.target.move_to(equation[index], LEFT)\n",
        "        rhs.target.shift(0.05 * UP)\n",
        "\n",
        "        self.play(ShowCreation(rhs_rect))\n",
        "        self.play(\n",
        "            MoveToTarget(rhs),\n",
        "            MaintainPositionRelativeTo(rhs_rect, rhs),\n",
        "            FadeOut(equation[index:]),\n",
        "            FadeOut(eq_arrow),\n",
        "            FadeOut(eq_label),\n",
        "        )\n",
        "        self.play(FadeOut(rhs_rect))\n",
        "        self.wait()\n",
        "        self.play(x0_tracker.animate.set_value(2.5), run_time=2)\n",
        "        self.play(x0_tracker.animate.set_value(0.5), run_time=2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(rhs),\n",
        "            FadeIn(equation[index:]),\n",
        "            FadeIn(eq_arrow),\n",
        "            FadeIn(eq_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize solution vs action\n",
        "        exp_rect = SurroundingRectangle(solution[4:7], buff=0.05, stroke_width=2)\n",
        "\n",
        "        words1 = Text(\"Don't think of this\\n\\n as a solution\", font_size=30)\n",
        "        words2 = Text(\n",
        "            \"It's something which\\n\\nacts on an initial condition\\n\\nto give a solution\",\n",
        "            t2s={\"acts\": ITALIC},\n",
        "            t2c={\"acts\": YELLOW, \"initial condition\": MAROON_B},\n",
        "            font_size=30\n",
        "        )\n",
        "        for words in [words1, words2]:\n",
        "            words.next_to(exp_rect, DOWN, MED_LARGE_BUFF)\n",
        "            words.set_stroke(BLACK, 5, background=True)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(exp_rect),\n",
        "            Write(words1, run_time=1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            FadeOut(words1),\n",
        "            FadeIn(words2),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ExoticExponentsWithEBase(Scene):\n",
        "    def construct(self):\n",
        "        # Write exotic exponents\n",
        "        exps = VGroup(\n",
        "            OldTex(\"e\", \"^{it}\"),\n",
        "            get_matrix_exponential([[3, 1], [4, 1]]),\n",
        "            OldTex(\"e\", \"^{((i + j + k) / \\\\sqrt{3})t}\"),\n",
        "            OldTex(\"e\", \"^{\\\\left(\\\\frac{\\\\partial}{\\\\partial x}\\\\right)t}\"),\n",
        "        )\n",
        "        for i in (0, 2, 3):\n",
        "            exps[i][0].scale(1.25)\n",
        "            exps[i][0].move_to(exps[i][1:].get_corner(DL), UR)\n",
        "        exps[1].scale(exps[0][0].get_height() / exps[1][0].get_height())\n",
        "        exps.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        labels = VGroup(\n",
        "            Text(\"Complex numbers\", font_size=30),\n",
        "            Text(\"Matrices\", font_size=30),\n",
        "            Text(\"Quaternions\", font_size=30),\n",
        "            Text(\"Operators\", font_size=30),\n",
        "        )\n",
        "        labels.set_submobject_colors_by_gradient(BLUE_B, BLUE_C)\n",
        "        for label, exp in zip(labels, exps):\n",
        "            label.move_to(exp, DL)\n",
        "            label.align_to(labels[0], LEFT)\n",
        "        labels.set_x(-2)\n",
        "\n",
        "        exps.set_x(labels.get_right()[0] + 3)\n",
        "\n",
        "        arrow = Arrow(labels.get_corner(UL), labels.get_corner(DL), buff=0)\n",
        "        arrow.shift(0.5 * LEFT)\n",
        "        arrow.set_color(TEAL)\n",
        "        exotic_label = OldTexText(\"More\\\\\\\\exotic\\\\\\\\exponents\", alignment=\"\")\n",
        "        exotic_label.next_to(arrow, LEFT)\n",
        "        VGroup(arrow, exotic_label).set_opacity(0)\n",
        "\n",
        "        e_mobs = VGroup()\n",
        "        for label, exp in zip(labels, exps):\n",
        "            e_mobs.add(exp[0])\n",
        "            self.play(\n",
        "                FadeIn(label),\n",
        "                FadeIn(exp[0]),\n",
        "                GrowFromPoint(exp[1:], exp[0].get_center()),\n",
        "                exotic_label.animate.set_opacity(1),\n",
        "                arrow.animate.set_opacity(1),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            FlashAround(e, buff=0.05, time_width=3, run_time=2)\n",
        "            for e in e_mobs\n",
        "        ), lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Analytic number theory exception\n",
        "        zeta = OldTex(\"\\\\sum_{n = 1}^\\\\infty \\\\frac{1}{n^s}\")\n",
        "        zeta.move_to(exps[0], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(exps[0]),\n",
        "            FadeIn(zeta),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(zeta),\n",
        "            FadeIn(exps[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Other bases\n",
        "        n_mob_groups = VGroup()\n",
        "        for n in [\"2\", \"5\", \"\\\\pi\", \"1{,}729\"]:\n",
        "            n_mobs = VGroup()\n",
        "            for e_mob in e_mobs:\n",
        "                n_mob = OldTex(n)\n",
        "                n_mob.match_height(e_mob)\n",
        "                n_mob.scale(1.2)\n",
        "                n_mob.move_to(e_mob, UR)\n",
        "                n_mob.shift(0.025 * DL)\n",
        "                n_mobs.add(n_mob)\n",
        "            n_mob_groups.add(n_mobs)\n",
        "        for color, group in zip([YELLOW, GREEN_B, RED, MAROON_B], n_mob_groups):\n",
        "            group.set_color(color)\n",
        "        last_group = e_mobs\n",
        "        for group in [*n_mob_groups, e_mobs]:\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeOut, last_group, lag_ratio=0.2),\n",
        "                LaggedStartMap(FadeIn, group, lag_ratio=0.2),\n",
        "                run_time=1.5,\n",
        "            )\n",
        "            self.wait()\n",
        "            last_group = group\n",
        "\n",
        "        # Show which equations are solved.\n",
        "        equations = VGroup(\n",
        "            OldTex(\"\\\\frac{dz}{dt}(t) = i \\\\cdot z(t)\"),\n",
        "            get_2d_equation([[\"3\", \"1\"], [\"4\", \"1\"]]),\n",
        "            OldTex(\"\\\\frac{dq}{dt}(t) = \\\\frac{i + j + k}{ \\\\sqrt{3} } \\\\cdot q(t)\"),\n",
        "            OldTex(\"{\\\\partial \\\\over \\\\partial t}f(x, t) = {\\\\partial \\\\over \\\\partial x}f(x, t)\"),\n",
        "        )\n",
        "        for eq, exp in zip(equations, exps):\n",
        "            eq.match_height(exp)\n",
        "            eq.move_to(exp, DL)\n",
        "            eq.align_to(equations[0], LEFT)\n",
        "\n",
        "        equations.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(arrow, 3 * LEFT),\n",
        "            FadeOut(exotic_label, 3 * LEFT),\n",
        "            VGroup(labels, exps).animate.to_edge(LEFT),\n",
        "            LaggedStartMap(FadeIn, equations, run_time=3, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            VGroup(\n",
        "                labels[0], labels[2:],\n",
        "                exps[0], exps[2:],\n",
        "                equations[0], equations[2:]\n",
        "            ).animate.set_opacity(0.3),\n",
        "            equations[1].animate.scale(1.5, about_edge=RIGHT),\n",
        "            exps[1].animate.scale(1.5),\n",
        "            labels[1].animate.scale(1.5, about_edge=LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TryToDefineExp(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"background_color\": BLACK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Try to define {{$e^{M}$}} to\\\\\\\\make sure this is true!\",\n",
        "        )\n",
        "        words[1][1].set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            PiCreatureSays(self.teacher, words, target_mode=\"surprised\"),\n",
        "            self.change_students(\"pondering\", \"thinking\", \"pondering\"),\n",
        "        )\n",
        "        for pi in self.students:\n",
        "            for eye in pi.eyes:\n",
        "                eye.refresh_bounding_box()\n",
        "        self.look_at(4 * UP + 2 * RIGHT)\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class SolutionsToMatrixEquation(From2DTo1D):\n",
        "    show_solution = True\n",
        "\n",
        "\n",
        "class SolutionToRomeoJuliet(Scene):\n",
        "    def construct(self):\n",
        "        mat_exp = get_matrix_exponential(\n",
        "            [[\"0\", \"-1\"], [\"1\", \"0\"]],\n",
        "            h_buff=1.0,\n",
        "        )\n",
        "        solution = VGroup(\n",
        "            Matrix(\n",
        "                [[\"x(t)\"], [\"y(t)\"]],\n",
        "                bracket_h_buff=SMALL_BUFF,\n",
        "                bracket_v_buff=SMALL_BUFF,\n",
        "            ),\n",
        "            OldTex(\"=\"),\n",
        "            mat_exp,\n",
        "            Matrix(\n",
        "                [[\"x(0)\"], [\"y(0)\"]],\n",
        "                bracket_h_buff=SMALL_BUFF,\n",
        "                bracket_v_buff=SMALL_BUFF,\n",
        "            )\n",
        "        )\n",
        "        solution[2].match_height(solution[0])\n",
        "        solution[3].match_height(solution[0])\n",
        "        solution.arrange(RIGHT)\n",
        "\n",
        "        self.add(solution)\n",
        "        self.wait()\n",
        "        rect = SurroundingRectangle(mat_exp, buff=0.1)\n",
        "        rect_copy = rect.copy()\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(rect.animate.become(SurroundingRectangle(solution[-1], color=BLUE)))\n",
        "        self.wait()\n",
        "        rot_question = Text(\"Rotation?\")\n",
        "        rot_question.next_to(rect_copy, DOWN)\n",
        "        rot_question.set_color(YELLOW)\n",
        "        self.play(\n",
        "            rect.animate.become(rect_copy),\n",
        "            Write(rot_question)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotMatrixStill(Scene):\n",
        "    def construct(self):\n",
        "        mat = IntegerMatrix([[0, -1], [1, 0]])\n",
        "        br = BackgroundRectangle(mat, buff=SMALL_BUFF)\n",
        "        br.set_fill(BLACK, 1)\n",
        "        self.add(br, mat)\n",
        "\n",
        "\n",
        "class ExpRotMatrixComputation(Scene):\n",
        "    def construct(self):\n",
        "        # Plug Mt into series\n",
        "        mat_exp = get_matrix_exponential([[0, -1], [1, 0]])\n",
        "        mat_exp.to_corner(UL)\n",
        "        mat_exp[1].set_color(TEAL)\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"e^X\", \":=\", \"X^0 + X^1 + \\\\frac{1}{2} X^2 + \\\\frac{1}{6} X^3 + \\\\cdots + \\\\frac{1}{n!} X^n + \\\\cdots\",\n",
        "            isolate=[\"X\", \"+\"],\n",
        "        )\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.to_edge(UP)\n",
        "        self.add(equation)\n",
        "\n",
        "        rhs_tex = \"{t}^0 X^0 + {t}^1 X^1 + \\\\frac{1}{2} {t}^2 X^2 + \\\\frac{1}{6} {t}^3 X^3 + \\\\cdots + \\\\frac{1}{n!} {t}^n X^n + \\\\cdots\"\n",
        "        mat_tex = \"\\\\left[ \\\\begin{array}{cc} 0 & -1 \\\\\\\\ 1 & 0 \\\\end{array} \\\\right]\"\n",
        "        mat_rhs = OldTex(\n",
        "            rhs_tex.replace(\"X\", mat_tex),\n",
        "            tex_to_color_map={mat_tex: TEAL},\n",
        "            isolate=[\"{t}\", \"+\"],\n",
        "        )\n",
        "        mat_rhs.scale(0.5)\n",
        "        mat_equals = OldTex(\"=\")\n",
        "\n",
        "        mat_exp.match_height(mat_rhs)\n",
        "        mat_equation = VGroup(mat_exp, mat_equals, mat_rhs)\n",
        "        mat_equation.arrange(RIGHT)\n",
        "        mat_exp.align_to(mat_rhs, DOWN)\n",
        "        mat_equation.set_width(FRAME_WIDTH - 1)\n",
        "        mat_equation.next_to(equation, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            FadeTransform(equation[:2].copy(), mat_equation[0]),\n",
        "            FadeTransform(equation[2].copy(), mat_equation[1]),\n",
        "            *(\n",
        "                FadeTransform(equation[i].copy(), mat_equation[2][j])\n",
        "                for i, j in zip(\n",
        "                    # Christ...\n",
        "                    [3, 4, 3, 4, 5, 6, 7, 6, 7, 8, 9, 10, 11, 10, 11, 12, 13, 14, 15, 14, 15, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23],\n",
        "                    it.count()\n",
        "                )\n",
        "            ),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.02\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show first few powers\n",
        "        new_eq = mat_equation.copy()\n",
        "        new_eq.shift(1.5 * DOWN)\n",
        "\n",
        "        kw = {\"bracket_h_buff\": 0.25}\n",
        "        m0 = IntegerMatrix([[1, 0], [0, 1]], **kw)\n",
        "        m1 = IntegerMatrix([[0, -1], [1, 0]], **kw)\n",
        "        m2 = IntegerMatrix([[-1, 0], [0, -1]], **kw)\n",
        "        m3 = IntegerMatrix([[0, 1], [-1, 0]], **kw)\n",
        "        mat_powers = VGroup(m0, m1, m2, m3)\n",
        "        mat_powers.set_submobject_colors_by_gradient(BLUE, GREEN, RED)\n",
        "\n",
        "        indices = [2, 7, 13, 19]\n",
        "        for mat_power, index in zip(mat_powers, indices):\n",
        "            mat_power.replace(new_eq[2][index], dim_to_match=0)\n",
        "            mat_power.source = mat_equation[2][index:index + 2]\n",
        "            new_eq[2][index: index + 2].set_opacity(0)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(mat_equation[0], new_eq[0]),\n",
        "            TransformFromCopy(mat_equation[1], new_eq[1]),\n",
        "            *(\n",
        "                TransformFromCopy(mat_equation[2][i], new_eq[2][i])\n",
        "                for i in range(21)\n",
        "                if i not in indices and i - 1 not in indices\n",
        "            ),\n",
        "            lag_ratio=0.01\n",
        "        ))\n",
        "\n",
        "        rect = SurroundingRectangle(mat_powers[0].source, buff=0.05)\n",
        "        rect.set_stroke(width=0)\n",
        "        for mat_power in mat_powers:\n",
        "            self.play(rect.animate.become(SurroundingRectangle(mat_power.source, buff=0.05)), run_time=0.5)\n",
        "            self.play(FadeTransform(mat_power.source.copy(), mat_power))\n",
        "            self.wait(0.5)\n",
        "        self.wait()\n",
        "        self.play(rect.animate.move_to(mat_equation[2][27:29]))\n",
        "\n",
        "        # Show cycling pattern\n",
        "        rows = VGroup()\n",
        "        for i in range(2):\n",
        "            row = VGroup()\n",
        "            for j in range(4):\n",
        "                mat_power_copy = mat_powers[j].deepcopy()\n",
        "                power = str(4 * (i + 1) + j)\n",
        "                coef = OldTex(\"+\\\\frac{1}{\" + power + \"!} t^{\" + power + \"}\")\n",
        "                coef.match_height(mat_equation[2][10])\n",
        "                coef.next_to(mat_power_copy, LEFT, SMALL_BUFF)\n",
        "                row.add(coef, mat_power_copy)\n",
        "            row.shift(1.1 * (i + 1) * DOWN)\n",
        "            rows.add(row)\n",
        "        dots = OldTex(\"+ \\\\cdots\", font_size=24)\n",
        "        dots.next_to(rows, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        for row in rows:\n",
        "            for coef, mp in zip(row[0::2], row[1::2]):\n",
        "                new_rect = SurroundingRectangle(mp, buff=0.05)\n",
        "                self.add(coef, mp, new_rect)\n",
        "                self.wait(0.5)\n",
        "                self.remove(new_rect)\n",
        "        self.play(Write(dots))\n",
        "        self.wait()\n",
        "\n",
        "        # Setup for new rhs\n",
        "        lhs = mat_equation[:2]\n",
        "        self.play(\n",
        "            lhs.animate.scale(2).to_corner(UL).shift(DOWN),\n",
        "            FadeOut(VGroup(mat_equation[2], rect, equation))\n",
        "        )\n",
        "\n",
        "        # Show massive rhs\n",
        "        rhs = Matrix(\n",
        "            [\n",
        "                [\n",
        "                    \"1 - \\\\frac{t^2}{2!} + \\\\frac{t^4}{4!} - \\\\frac{t^6}{6!} + \\\\cdots\",\n",
        "                    \"-t + \\\\frac{t^3}{3!} - \\\\frac{t^5}{5!} + \\\\frac{t^7}{7!} - \\\\cdots\",\n",
        "                ],\n",
        "                [\n",
        "                    \"t - \\\\frac{t^3}{3!} + \\\\frac{t^5}{5!} - \\\\frac{t^7}{7!} + \\\\cdots\",\n",
        "                    \"1 - \\\\frac{t^2}{2!} + \\\\frac{t^4}{4!} - \\\\frac{t^6}{6!} + \\\\cdots\",\n",
        "                ],\n",
        "            ],\n",
        "            h_buff=6,\n",
        "            v_buff=2,\n",
        "        )\n",
        "        rhs.set_width(10)\n",
        "        rhs.next_to(lhs, RIGHT)\n",
        "\n",
        "        power_entry_rects = VGroup(*(VGroup() for x in range(4)))\n",
        "        for group in [mat_powers, rows[0][1::2], rows[1][1::2]]:\n",
        "            for mat_power in group:\n",
        "                for i, entry in enumerate(mat_power.get_entries()):\n",
        "                    rect = SurroundingRectangle(entry, buff=0.05)\n",
        "                    rect.set_stroke(YELLOW, 2)\n",
        "                    power_entry_rects[i].add(rect)\n",
        "\n",
        "        self.play(Write(rhs.get_brackets()))\n",
        "\n",
        "        last_per = power_entry_rects[0].copy()\n",
        "        last_per.set_opacity(0)\n",
        "        last_rect = VMobject()\n",
        "        for entry, per in zip(rhs.get_entries(), power_entry_rects):\n",
        "            rect = VGroup(SurroundingRectangle(entry, stroke_width=1))\n",
        "            self.play(\n",
        "                ReplacementTransform(last_per, per),\n",
        "                FadeIn(entry),\n",
        "                FadeIn(rect),\n",
        "                FadeOut(last_rect),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_per = per\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_per), FadeOut(last_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Show collapse to trig functions\n",
        "        low_terms = VGroup(new_eq[2][:21], mat_powers, rows, dots)\n",
        "\n",
        "        new_lhs = lhs.copy()\n",
        "        new_lhs.next_to(rhs, DOWN, LARGE_BUFF)\n",
        "        new_lhs.align_to(lhs, LEFT)\n",
        "        final_result = Matrix(\n",
        "            [[\"\\\\cos(t)\", \"-\\\\sin(t)\"], [\"\\\\sin(t)\", \"\\\\cos(t)\"]],\n",
        "            h_buff=2.0\n",
        "        )\n",
        "        final_result.next_to(new_lhs, RIGHT)\n",
        "\n",
        "        anims = []\n",
        "        colors = [BLUE_B, BLUE_D, BLUE_D, BLUE_B]\n",
        "        for color, entry1, entry2 in zip(colors, rhs.get_entries(), final_result.get_entries()):\n",
        "            anims.append(entry1.animate.set_color(color))\n",
        "            entry2.set_color(color)\n",
        "\n",
        "        self.play(\n",
        "            *anims,\n",
        "            FadeOut(low_terms, shift=2 * DOWN),\n",
        "            ReplacementTransform(new_eq[:2], new_lhs),\n",
        "            TransformFromCopy(rhs.get_brackets(), final_result.get_brackets()),\n",
        "        )\n",
        "        self.wait()\n",
        "        last_rects = VGroup()\n",
        "        for entry1, entry2 in zip(rhs.get_entries(), final_result.get_entries()):\n",
        "            rect1 = SurroundingRectangle(entry1, stroke_width=1)\n",
        "            rect2 = SurroundingRectangle(entry2, stroke_width=1)\n",
        "            self.play(\n",
        "                FadeIn(rect1),\n",
        "                FadeIn(rect2),\n",
        "                FadeIn(entry2),\n",
        "                FadeOut(last_rects),\n",
        "            )\n",
        "            last_rects = VGroup(rect1, rect2)\n",
        "        self.play(FadeOut(last_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask question\n",
        "        question = OldTexText(\"What transformation\\\\\\\\is this?\")\n",
        "        question.next_to(final_result, RIGHT, buff=1.5)\n",
        "        question.shift_onto_screen()\n",
        "        arrow = Arrow(question, final_result, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(question, shift=0.5 * RIGHT),\n",
        "            GrowArrow(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight result\n",
        "        high_eq = VGroup(lhs, rhs)\n",
        "        low_eq = VGroup(new_lhs, final_result)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(high_eq, UP),\n",
        "            FadeOut(VGroup(question, arrow)),\n",
        "            low_eq.animate.center().to_edge(UP),\n",
        "            lag_ratio=0.05\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThatsHorrifying(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            OldTexText(\"You want us to\\\\\\\\do what?\"),\n",
        "            index=2,\n",
        "            target_mode=\"pleading\",\n",
        "            added_anims=[LaggedStart(\n",
        "                self.students[0].change(\"tired\"),\n",
        "                self.students[1].change(\"horrified\"),\n",
        "                self.teacher.change(\"guilty\"),\n",
        "                lag_ratio=0.5\n",
        "            )]\n",
        "        )\n",
        "        for pi in self.pi_creatures:\n",
        "            for eye in pi.eyes:\n",
        "                # Why?\n",
        "                eye.refresh_bounding_box()\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(2)\n",
        "        self.teacher_says(\n",
        "            \"Just wait\",\n",
        "            bubble_config={\"height\": 3, \"width\": 3.5},\n",
        "            target_mode=\"tease\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"thinking\", \"hesitant\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class LinearAlgebraWrapper(VideoWrapper):\n",
        "    title = \"Matrices as linear transformations\"\n",
        "\n",
        "\n",
        "class HowBasisVectorMultiplicationPullsOutColumns(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        plane = NumberPlane()\n",
        "        plane.scale(2.5)\n",
        "        plane.shift(1.5 * DOWN)\n",
        "        b_plane = plane.copy()\n",
        "        b_plane.set_color(GREY_B)\n",
        "        plane.add_coordinate_labels()\n",
        "        self.add(b_plane, plane)\n",
        "\n",
        "        matrix = Matrix(\n",
        "            [[\"a\", \"b\"], [\"c\", \"d\"]],\n",
        "            h_buff=0.8,\n",
        "        )\n",
        "        matrix.to_corner(UL)\n",
        "        matrix.to_edge(LEFT, buff=MED_SMALL_BUFF)\n",
        "        matrix.add_to_back(BackgroundRectangle(matrix))\n",
        "        self.add(matrix)\n",
        "\n",
        "        basis_vectors = VGroup(\n",
        "            Arrow(plane.get_origin(), plane.c2p(1, 0), buff=0, fill_color=GREEN),\n",
        "            Arrow(plane.get_origin(), plane.c2p(0, 1), buff=0, fill_color=RED),\n",
        "        )\n",
        "        bhb = 0.2\n",
        "        basis_labels = VGroup(\n",
        "            Matrix([[\"1\"], [\"0\"]], bracket_h_buff=bhb),\n",
        "            Matrix([[\"0\"], [\"1\"]], bracket_h_buff=bhb),\n",
        "        )\n",
        "        for vector, label, direction in zip(basis_vectors, basis_labels, [UR, RIGHT]):\n",
        "            label.scale(0.7)\n",
        "            label.match_color(vector)\n",
        "            label.add_to_back(BackgroundRectangle(label))\n",
        "            label.next_to(vector.get_end(), direction)\n",
        "\n",
        "        # Show products\n",
        "        basis_label_copies = basis_labels.deepcopy()\n",
        "        rhss = VGroup(\n",
        "            Matrix([[\"a\"], [\"c\"]], bracket_h_buff=bhb),\n",
        "            Matrix([[\"b\"], [\"d\"]], bracket_h_buff=bhb),\n",
        "        )\n",
        "        colors = [GREEN, RED]\n",
        "\n",
        "        def show_basis_product(index, matrix):\n",
        "            basis_label_copies[index].match_height(matrix)\n",
        "            basis_label_copies[index].next_to(matrix, RIGHT, SMALL_BUFF),\n",
        "            equals = OldTex(\"=\")\n",
        "            equals.next_to(basis_label_copies[index], RIGHT, SMALL_BUFF)\n",
        "            rhss[index].next_to(equals, RIGHT, SMALL_BUFF)\n",
        "            rhss[index].set_color(colors[index])\n",
        "            rhs_br = BackgroundRectangle(rhss[index])\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(basis_labels[index], RIGHT),\n",
        "                GrowArrow(basis_vectors[index]),\n",
        "                FadeIn(basis_label_copies[index]),\n",
        "                FadeIn(equals),\n",
        "                FadeIn(rhs_br),\n",
        "                FadeIn(rhss[index].get_brackets()),\n",
        "            )\n",
        "            rect_kw = {\"stroke_width\": 2, \"buff\": 0.1}\n",
        "            row_rects = [\n",
        "                SurroundingRectangle(row, **rect_kw)\n",
        "                for row in matrix.get_rows()\n",
        "            ]\n",
        "            col_rect = SurroundingRectangle(basis_label_copies[index].get_entries(), **rect_kw)\n",
        "            col_rect.set_stroke(opacity=0)\n",
        "            last_row_rect = VMobject()\n",
        "            for e1, e2, row_rect in zip(matrix.get_columns()[index], rhss[index].get_entries(), row_rects):\n",
        "                self.play(\n",
        "                    col_rect.animate.set_stroke(opacity=1),\n",
        "                    FadeIn(row_rect),\n",
        "                    FadeOut(last_row_rect),\n",
        "                    e1.animate.set_color(colors[index]),\n",
        "                    FadeIn(e2),\n",
        "                )\n",
        "                last_row_rect = row_rect\n",
        "            self.play(FadeOut(last_row_rect), FadeOut(col_rect))\n",
        "            rhss[index].add_to_back(rhs_br)\n",
        "            rhss[index].add(equals)\n",
        "\n",
        "        low_matrix = matrix.deepcopy()\n",
        "        show_basis_product(0, matrix)\n",
        "        self.wait()\n",
        "        self.play(low_matrix.animate.shift(2.5 * DOWN))\n",
        "        show_basis_product(1, low_matrix)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ColumnsToBasisVectors(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ReadColumnsOfRotationMatrix(Scene):\n",
        "    show_exponent = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        plane = NumberPlane(faded_line_ratio=0)\n",
        "        plane.scale(3.0)\n",
        "        plane.shift(1.5 * DOWN)\n",
        "        b_plane = plane.copy()\n",
        "        b_plane.set_color(GREY_B)\n",
        "        b_plane.set_stroke(opacity=0.5)\n",
        "\n",
        "        angle = 50 * DEGREES\n",
        "        plane2 = plane.copy().apply_matrix([\n",
        "            [math.cos(angle), 0],\n",
        "            [math.sin(angle), 1],\n",
        "        ], about_point=plane.get_origin())\n",
        "        plane3 = plane.copy().apply_matrix([\n",
        "            [math.cos(angle), -math.sin(angle)],\n",
        "            [math.sin(angle), math.cos(angle)],\n",
        "        ], about_point=plane.get_origin())\n",
        "        coords = plane.deepcopy().add_coordinate_labels((-2, -1, 1, 2), (-1, 1))\n",
        "        self.add(b_plane, plane, coords)\n",
        "\n",
        "        equation = VGroup(\n",
        "            get_matrix_exponential([[0, -1], [1, 0]]),\n",
        "            OldTex(\"=\"),\n",
        "            Matrix(\n",
        "                [[\"\\\\cos(t)\", \"-\\\\sin(t)\"], [\"\\\\sin(t)\", \"\\\\cos(t)\"]],\n",
        "                h_buff=2.0\n",
        "            )\n",
        "        )\n",
        "        exp, eq, matrix = equation\n",
        "        exp[1].set_color(TEAL)\n",
        "        exp[1].add_background_rectangle()\n",
        "        matrix.add_background_rectangle()\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.set_width(6)\n",
        "        equation.to_corner(UL)\n",
        "\n",
        "        if not self.show_exponent:\n",
        "            equation.remove(*equation[:2])\n",
        "            equation.set_height(1.5)\n",
        "            equation.to_corner(UL)\n",
        "\n",
        "        self.add(equation)\n",
        "\n",
        "        basis_vectors = VGroup(\n",
        "            Arrow(plane.get_origin(), plane.c2p(1, 0), buff=0, fill_color=GREEN),\n",
        "            Arrow(plane.get_origin(), plane.c2p(0, 1), buff=0, fill_color=RED),\n",
        "        )\n",
        "        basis_shadows = basis_vectors.copy()\n",
        "        basis_shadows.set_fill(opacity=0.5)\n",
        "        self.add(basis_shadows, basis_vectors)\n",
        "\n",
        "        self.play(FlashAround(matrix.get_columns()[0], color=GREEN))\n",
        "        self.wait()\n",
        "\n",
        "        # Show action on basis vectors\n",
        "        rot_b0, rot_b1 = rot_basis_vectors = basis_vectors.copy()\n",
        "        for rot_b in rot_basis_vectors:\n",
        "            rot_b.rotate(angle, about_point=plane.get_origin())\n",
        "\n",
        "        rbl0, rbl1 = rot_basis_labels = VGroup(\n",
        "            Matrix([[\"\\\\cos(t)\"], [\"\\\\sin(t)\"]]),\n",
        "            Matrix([[\"-\\\\sin(t)\"], [\"\\\\cos(t)\"]]),\n",
        "        )\n",
        "        for label, color, rot_b, direction in zip(rot_basis_labels, [GREEN, RED], rot_basis_vectors, [UR, LEFT]):\n",
        "            label.set_color(color)\n",
        "            label.scale(0.7)\n",
        "            label.next_to(rot_b.get_end(), direction, SMALL_BUFF)\n",
        "            label.add_background_rectangle()\n",
        "\n",
        "        arcs = VGroup(\n",
        "            Arc(0, angle, arc_center=plane.get_origin(), radius=0.5),\n",
        "            Arc(PI / 2, angle, arc_center=plane.get_origin(), radius=0.5),\n",
        "        )\n",
        "        arcs.set_stroke(WHITE, 2)\n",
        "        arc_label = OldTexText(\"$t$\", \" \")\n",
        "        arc_label.next_to(arcs[0], RIGHT, SMALL_BUFF)\n",
        "        arc_label.shift(SMALL_BUFF * UP)\n",
        "\n",
        "        h_line = DashedLine(plane.get_origin(), plane.c2p(math.cos(angle), 0))\n",
        "        v_line = DashedLine(plane.c2p(math.cos(angle), 0), plane.c2p(math.cos(angle), math.sin(angle)))\n",
        "        cos_label = matrix.get_entries()[0].copy().next_to(h_line, DOWN, SMALL_BUFF)\n",
        "        sin_label = matrix.get_entries()[2].copy().next_to(v_line, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(matrix[0], rbl0[0]),  # Background rectangles\n",
        "            TransformFromCopy(matrix.get_brackets(), rbl0.get_brackets()),\n",
        "            TransformFromCopy(matrix.get_columns()[0], rbl0.get_entries()),\n",
        "            Transform(plane, plane2, path_arc=angle),\n",
        "            Transform(basis_vectors[0], rot_b0, path_arc=angle),\n",
        "            Animation(matrix.get_columns()[1]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        rects = VGroup(*(\n",
        "            SurroundingRectangle(entry, color=WHITE, stroke_width=2, buff=0.05)\n",
        "            for entry in rbl0.get_entries()\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            FadeIn(rects[0]),\n",
        "            FadeIn(cos_label),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(v_line),\n",
        "            FadeOut(rects[0]),\n",
        "            FadeIn(rects[1]),\n",
        "            FadeIn(sin_label),\n",
        "        )\n",
        "        self.play(FadeOut(rects[1]))\n",
        "        self.wait()\n",
        "        self.play(FlashAround(matrix.get_columns()[1], color=RED))\n",
        "        self.play(\n",
        "            TransformFromCopy(matrix[0], rbl1[0]),  # Background rectangles\n",
        "            TransformFromCopy(matrix.get_brackets(), rbl1.get_brackets()),\n",
        "            TransformFromCopy(matrix.get_columns()[1], rbl1.get_entries()),\n",
        "            Transform(plane, plane3, path_arc=angle),\n",
        "            Transform(basis_vectors[1], rot_b1, path_arc=angle),\n",
        "            Animation(matrix.get_columns()[0]),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(arc_label),\n",
        "            *map(ShowCreation, arcs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ReadColumnsOfRotationMatrixWithExp(ReadColumnsOfRotationMatrix):\n",
        "    show_exponent = True\n",
        "\n",
        "\n",
        "class AnalyzeRomeoAndJulietSpace(RomeoJulietVectorSpace):\n",
        "    def construct(self):\n",
        "        # Add axes\n",
        "        axes = self.get_romeo_juliet_axes()\n",
        "        ps_dot = axes.ps_dot\n",
        "        ps_dot.set_opacity(0)\n",
        "        ps_dot.move_to(axes.c2p(4, 3))\n",
        "\n",
        "        ps_arrow = self.get_ps_arrow(axes, add_shadow=True)\n",
        "        ps_arrow.update()\n",
        "        self.add(ps_arrow)\n",
        "\n",
        "        # Add equation\n",
        "        matrix = [[\"0\", \"-1\"], [\"1\", \"0\"]]\n",
        "        equation = get_2d_equation(matrix)\n",
        "        equation.to_corner(UR)\n",
        "\n",
        "        implies = OldTex(\"\\\\Downarrow\", font_size=72)\n",
        "        implies.next_to(equation, DOWN, buff=0.3)\n",
        "\n",
        "        initial_condition = Matrix([[\"x_0\"], [\"y_0\"]], bracket_h_buff=0.1)\n",
        "        initial_condition.match_height(equation)\n",
        "        initial_condition.set_color(BLUE_B)\n",
        "        ic_source = initial_condition.copy()\n",
        "        ic_source.scale(0.5)\n",
        "        ic_source.next_to(ps_arrow.get_end(), RIGHT, SMALL_BUFF)\n",
        "\n",
        "        mat_exp = get_matrix_exponential(matrix, h_buff=0.8)\n",
        "        solution = VGroup(equation[1].copy(), OldTex(\"=\"), mat_exp, initial_condition)\n",
        "        solution[2][1].set_color(TEAL)\n",
        "        solution.arrange(RIGHT)\n",
        "        solution.scale(0.8)\n",
        "        solution.next_to(implies, DOWN, buff=0.3)\n",
        "\n",
        "        rot_matrix = Matrix(\n",
        "            [[\"\\\\cos(t)\", \"-\\\\sin(t)\"], [\"\\\\sin(t)\", \"\\\\cos(t)\"]],\n",
        "            bracket_h_buff=0.2,\n",
        "            h_buff=2.0\n",
        "        )\n",
        "        for entry in rot_matrix.get_entries():\n",
        "            entry[0][-2].set_color(GREY_B)\n",
        "        rot_matrix.match_height(solution[0])\n",
        "        solution2 = solution.deepcopy()\n",
        "        solution2.replace_submobject(2, rot_matrix)\n",
        "        solution2.arrange(RIGHT)\n",
        "        solution2.next_to(solution, DOWN, buff=0.7)\n",
        "\n",
        "        rot_matrix_brace = Brace(rot_matrix, DOWN)\n",
        "        rot_label = OldTexText(\"Rotate by angle $t$\")\n",
        "        rot_label.next_to(rot_matrix_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(FlashAround(equation, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(implies),\n",
        "            TransformFromCopy(equation[1], solution[0], path_arc=-20 * DEGREES),\n",
        "            TransformFromCopy(equation[2], solution[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(mat_exp[0]),\n",
        "            TransformFromCopy(equation[3], mat_exp[1]),\n",
        "        )\n",
        "        self.play(Write(mat_exp[2]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(ic_source),\n",
        "            FlashAround(ic_source),\n",
        "        )\n",
        "        self.play(TransformFromCopy(ic_source, initial_condition))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            *(\n",
        "                TransformFromCopy(solution[i], solution2[i])\n",
        "                for i in [0, 1, 3]\n",
        "            ),\n",
        "            FadeTransform(mat_exp.copy(), rot_matrix)\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(rot_matrix_brace),\n",
        "            FadeIn(rot_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Rotate vector\n",
        "        start_angle = ps_arrow.get_angle()\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def get_arc():\n",
        "            curr_time = get_t()\n",
        "            arc = ParametricCurve(\n",
        "                lambda s: axes.c2p(*tuple((1 + 0.2 * s) * np.array([\n",
        "                    math.cos(start_angle + s * curr_time),\n",
        "                    math.sin(start_angle + s * curr_time),\n",
        "                ]))),\n",
        "                t_range=(0, 1, 0.01)\n",
        "            )\n",
        "            arc.set_stroke(WHITE, 2)\n",
        "            return arc\n",
        "\n",
        "        arc = always_redraw(get_arc)\n",
        "        t_label = VGroup(OldTex(\"t = \", font_size=30), DecimalNumber(font_size=24))\n",
        "        t_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        def update_t_label(label):\n",
        "            point = arc.pfp(0.5)\n",
        "            label[1].set_value(get_t())\n",
        "            label.set_stroke(BLACK, 5, background=True)\n",
        "            label.set_opacity(min(2 * get_t(), 1))\n",
        "            if get_t() < 3.65:\n",
        "                target_point = point + 0.75 * (point - axes.get_origin())\n",
        "                label.shift(target_point - label[1].get_center())\n",
        "\n",
        "        t_label.add_updater(update_t_label)\n",
        "\n",
        "        curr_xy = np.array(axes.p2c(ps_dot.get_center()))\n",
        "\n",
        "        def update_ps_dot(dot):\n",
        "            rot_M = np.array(rotation_matrix_transpose(get_t(), OUT))[:2, :2]\n",
        "            new_xy = np.dot(curr_xy, rot_M)\n",
        "            dot.move_to(axes.c2p(*new_xy))\n",
        "\n",
        "        ps_dot.add_updater(update_ps_dot)\n",
        "\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(0.5 * dt))\n",
        "        self.add(arc, t_label, t_tracker, ps_dot)\n",
        "        self.play(VFadeIn(t_label))\n",
        "        self.wait(16 * PI - 1)\n",
        "\n",
        "    def get_romeo_juliet_axes(self, height=5):\n",
        "        # Largely copied from RomeoJulietVectorSpace\n",
        "        romeo, juliet = lovers = self.get_romeo_and_juliet()\n",
        "        axes = Axes(\n",
        "            x_range=(-5, 5),\n",
        "            y_range=(-5, 5),\n",
        "            height=height,\n",
        "            width=height,\n",
        "            axis_config={\n",
        "                \"include_tip\": False,\n",
        "                \"numbers_to_exclude\": [],\n",
        "            }\n",
        "        )\n",
        "        axes.to_edge(LEFT)\n",
        "\n",
        "        for axis in axes:\n",
        "            axis.add_numbers(range(-4, 6, 2), color=GREY_A, font_size=12)\n",
        "            axis.numbers[2].set_opacity(0)\n",
        "\n",
        "        lovers.set_height(0.5)\n",
        "        lovers.flip()\n",
        "        juliet.next_to(axes.x_axis.get_end(), RIGHT)\n",
        "        romeo.next_to(axes.y_axis.get_end(), UP)\n",
        "\n",
        "        ps_dot = Dot(radius=0.04, fill_color=BLUE)\n",
        "        ps_dot.move_to(axes.c2p(3, 1))\n",
        "\n",
        "        def get_xy():\n",
        "            # Get phase space point\n",
        "            return axes.p2c(ps_dot.get_center())\n",
        "\n",
        "        self.make_romeo_and_juliet_dynamic(romeo, juliet)\n",
        "        juliet.love_tracker.add_updater(lambda m: m.set_value(get_xy()[0]))\n",
        "        romeo.love_tracker.add_updater(lambda m: m.set_value(get_xy()[1]))\n",
        "        self.add(romeo.love_tracker, juliet.love_tracker)\n",
        "\n",
        "        name_labels = self.get_romeo_juilet_name_labels(lovers, font_size=12, spacing=1.0, buff=0.05)\n",
        "\n",
        "        axes.lovers = lovers\n",
        "        axes.name_labels = name_labels\n",
        "        axes.ps_dot = ps_dot\n",
        "        axes.add(lovers, name_labels, ps_dot)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(*lovers)\n",
        "        self.add(*(pi.heart_eyes for pi in lovers))\n",
        "\n",
        "        return axes\n",
        "\n",
        "    def get_ps_arrow(self, axes, color=BLUE, add_shadow=False):\n",
        "        arrow = Arrow(\n",
        "            LEFT, RIGHT,\n",
        "            fill_color=color,\n",
        "            thickness=0.04\n",
        "        )\n",
        "        arrow.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            axes.get_origin(), axes.ps_dot.get_center(),\n",
        "        ))\n",
        "\n",
        "        if add_shadow:\n",
        "            ps_arrow_shadow = arrow.copy()\n",
        "            ps_arrow_shadow.clear_updaters()\n",
        "            ps_arrow_shadow.set_fill(BLUE, 0.5)\n",
        "            self.add(ps_arrow_shadow)\n",
        "        return arrow\n",
        "\n",
        "\n",
        "class GeometricReasoningForRomeoJuliet(AnalyzeRomeoAndJulietSpace):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        axes = self.get_romeo_juliet_axes()\n",
        "        ps_dot = axes.ps_dot\n",
        "        ps_dot.set_opacity(0)\n",
        "        ps_dot.move_to(axes.c2p(4, 3))\n",
        "\n",
        "        ps_arrow = self.get_ps_arrow(axes)\n",
        "        self.add(ps_arrow)\n",
        "\n",
        "        matrix = [[\"0\", \"-1\"], [\"1\", \"0\"]]\n",
        "        equation = get_2d_equation(matrix)\n",
        "        ddt, xy1, eq, mat, xy2 = equation\n",
        "        equation.to_corner(UR)\n",
        "        self.add(equation)\n",
        "\n",
        "        # Show 90 degree rotation\n",
        "        mat_brace = Brace(mat, DOWN, buff=SMALL_BUFF)\n",
        "        mat_label = mat_brace.get_text(\"90-degree rotation matrix\", font_size=30)\n",
        "        mat_label.set_color(TEAL)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(mat_brace),\n",
        "            Write(mat_label, run_time=1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Spiral around to various points\n",
        "        curve = VMobject()\n",
        "        curve.set_points_smoothly(\n",
        "            [\n",
        "                axes.c2p(x, y)\n",
        "                for x, y in [(4, 3), (0, 2), (0, -1), (-3, -4), (-3, 2), (3, 1)]\n",
        "            ],\n",
        "            true_smooth=True\n",
        "        )\n",
        "        self.play(MoveAlongPath(ps_dot, curve, run_time=5))\n",
        "        self.wait()\n",
        "\n",
        "        # Rate of change\n",
        "        deriv_vect = ps_arrow.copy()\n",
        "        deriv_vect.clear_updaters()\n",
        "        deriv_vect.set_color(RED)\n",
        "        deriv_vect.shift(ps_arrow.get_vector())\n",
        "\n",
        "        deriv_rect = SurroundingRectangle(VGroup(ddt, xy1))\n",
        "        deriv_rect.set_stroke(RED, 2)\n",
        "\n",
        "        d_line = DashedLine(ps_arrow.get_start(), ps_arrow.get_end())\n",
        "        d_line.shift(ps_arrow.get_vector())\n",
        "        d_line.set_stroke(WHITE, 1)\n",
        "\n",
        "        arc = Arc(\n",
        "            start_angle=ps_arrow.get_angle(),\n",
        "            angle=90 * DEGREES,\n",
        "            arc_center=ps_arrow.get_end(),\n",
        "            radius=0.25\n",
        "        )\n",
        "        elbow = VMobject()\n",
        "        elbow.set_points_as_corners([RIGHT, UR, UP])\n",
        "        elbow.scale(0.25, about_point=ORIGIN)\n",
        "        elbow.rotate(ps_arrow.get_angle(), about_point=ORIGIN)\n",
        "        elbow.shift(ps_arrow.get_end())\n",
        "        VGroup(elbow, arc).set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(ps_arrow, deriv_vect, path_arc=30 * DEGREES),\n",
        "            ShowCreation(deriv_rect),\n",
        "        )\n",
        "        self.add(d_line, deriv_vect)\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Rotate(deriv_vect, 90 * DEGREES, about_point=ps_arrow.get_end()),\n",
        "            run_time=2,\n",
        "            rate_func=rush_into,\n",
        "        )\n",
        "        self.remove(arc)\n",
        "        self.add(elbow)\n",
        "        self.wait()\n",
        "\n",
        "        # Show rotation\n",
        "        ps_arrow.clear_updaters()\n",
        "        ps_dot.add_updater(lambda m: m.move_to(ps_arrow.get_end()))\n",
        "        rot_group = VGroup(ps_arrow, d_line, elbow, deriv_vect)\n",
        "        circle = Circle(radius=ps_arrow.get_length())\n",
        "        circle.set_stroke(GREY, 1)\n",
        "        circle.move_to(axes.get_origin())\n",
        "\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                rot_group,\n",
        "                angle=TAU - ps_arrow.get_angle(),\n",
        "                about_point=axes.get_origin(),\n",
        "                run_time=6,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            FadeIn(circle),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show matching length\n",
        "        self.play(\n",
        "            deriv_vect.animate.put_start_and_end_on(ps_arrow.get_start(), ps_arrow.get_end()).shift(0.2 * UP),\n",
        "            run_time=3,\n",
        "            rate_func=there_and_back_with_pause,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show one radian of arc\n",
        "        arc = Arc(\n",
        "            0, 1,\n",
        "            radius=circle.radius,\n",
        "            arc_center=axes.get_origin(),\n",
        "        )\n",
        "        arc.set_stroke(YELLOW, 3)\n",
        "        sector = Sector(\n",
        "            start_angle=0,\n",
        "            angle=1,\n",
        "            outer_radius=circle.radius,\n",
        "        )\n",
        "        sector.shift(axes.get_origin())\n",
        "        sector.set_stroke(width=0)\n",
        "        sector.set_fill(GREY_D, 1)\n",
        "\n",
        "        t_label = VGroup(OldTex(\"t = \", font_size=30), DecimalNumber(0, font_size=20))\n",
        "        t_label.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        t_label.next_to(arc.pfp(0.5), UR, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(rot_group, 1, about_point=axes.get_origin()),\n",
        "            ShowCreation(arc),\n",
        "            ChangeDecimalToValue(t_label[1], 1.0),\n",
        "            VFadeIn(t_label),\n",
        "            run_time=2,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.add(sector, axes, ps_arrow, arc)\n",
        "        self.play(FadeIn(sector))\n",
        "        self.wait()\n",
        "\n",
        "        radius = Line(axes.get_origin(), arc.get_start())\n",
        "        radius.set_stroke(RED, 5)\n",
        "        self.play(ShowCreation(radius))\n",
        "        self.play(Rotate(radius, -PI / 2, about_point=radius.get_end()))\n",
        "        radius.rotate(PI)\n",
        "        self.play(radius.animate.match_points(arc))\n",
        "        self.play(FadeOut(radius))\n",
        "        self.wait()\n",
        "\n",
        "        # One radian per unit time\n",
        "        self.play(\n",
        "            t_label.animate.shift(UP).scale(2),\n",
        "        )\n",
        "        t_label[1].data[\"font_size\"] *= 2\n",
        "        for x in range(5):\n",
        "            VGroup(sector, arc).rotate(1, about_point=axes.get_origin())\n",
        "            self.play(\n",
        "                Rotate(rot_group, 1, about_point=axes.get_origin()),\n",
        "                ChangeDecimalToValue(t_label[1], t_label[1].get_value() + 1),\n",
        "                run_time=2,\n",
        "                rate_func=linear,\n",
        "            )\n",
        "        self.play(\n",
        "            FadeOut(VGroup(sector, arc)),\n",
        "            Rotate(rot_group, TAU - 6, about_point=axes.get_origin()),\n",
        "            ChangeDecimalToValue(t_label[1], TAU),\n",
        "            run_time=2 * (TAU - 6),\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        t_label[1].set_value(0)\n",
        "        self.play(\n",
        "            Rotate(rot_group, PI, about_point=axes.get_origin()),\n",
        "            ChangeDecimalToValue(t_label[1], PI),\n",
        "            run_time=2 * PI,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class Show90DegreeRotation(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane()\n",
        "        plane.scale(2.5)\n",
        "        back_plane = plane.deepcopy()\n",
        "        back_plane.set_stroke(color=GREY, opacity=0.5)\n",
        "        back_plane.add_coordinate_labels()\n",
        "\n",
        "        vects = VGroup(\n",
        "            Arrow(plane.get_origin(), plane.c2p(1, 0), fill_color=GREEN, buff=0, thickness=0.075),\n",
        "            Arrow(plane.get_origin(), plane.c2p(0, 1), fill_color=RED, buff=0, thickness=0.075),\n",
        "        )\n",
        "        plane.add(*vects)\n",
        "        plane.set_stroke(background=True)\n",
        "\n",
        "        self.add(back_plane, plane)\n",
        "        self.wait()\n",
        "        self.play(Rotate(plane, 90 * DEGREES, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Show90DegreeRotationColumnByColumn(Scene):\n",
        "    def construct(self):\n",
        "        plane = NumberPlane()\n",
        "        plane.scale(2.5)\n",
        "        back_plane = plane.deepcopy()\n",
        "        back_plane.set_stroke(color=GREY, opacity=0.5)\n",
        "        back_plane.add_coordinate_labels()\n",
        "\n",
        "        plane2 = plane.copy()\n",
        "        plane3 = plane.copy()\n",
        "        plane2.apply_matrix([[0, 0], [1, 1]])\n",
        "        plane3.apply_matrix([[0, -1], [1, 0]])\n",
        "\n",
        "        vects = VGroup(\n",
        "            Arrow(plane.get_origin(), plane.c2p(1, 0), fill_color=GREEN, buff=0, thickness=0.075),\n",
        "            Arrow(plane.get_origin(), plane.c2p(0, 1), fill_color=RED, buff=0, thickness=0.075),\n",
        "        )\n",
        "\n",
        "        self.add(back_plane, plane, *vects)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(plane, plane2, path_arc=90 * DEGREES),\n",
        "            Rotate(vects[0], 90 * DEGREES, about_point=plane.get_origin()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(plane, plane3, path_arc=90 * DEGREES),\n",
        "            Rotate(vects[1], 90 * DEGREES, about_point=plane.get_origin()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arc = Arc(5 * DEGREES, 80 * DEGREES, buff=0.1, radius=1.5)\n",
        "        arc.set_stroke(width=3)\n",
        "        arc.add_tip(width=0.15, length=0.15)\n",
        "        arc2 = arc.copy().rotate(PI, about_point=ORIGIN)\n",
        "        arcs = VGroup(arc, arc2)\n",
        "        arcs.set_color(GREY_B)\n",
        "        self.play(*map(ShowCreation, arcs))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DistanceOverTimeEquation(Scene):\n",
        "    def construct(self):\n",
        "        equation = OldTex(\n",
        "            \"{\\\\text{Distance}\", \" \\\\over\", \" \\\\text{Time} }\", \"=\", \"\\\\text{Radius}\",\n",
        "        )\n",
        "        # equation[:3].set_color(RED_B)\n",
        "        equation.add(SurroundingRectangle(equation[:3], color=RED, stroke_width=1))\n",
        "        equation[4].set_color(BLUE)\n",
        "        self.play(FadeIn(equation, UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExplicitSolution(Scene):\n",
        "    def construct(self):\n",
        "        kw = {\"tex_to_color_map\": {\n",
        "            \"x_0\": BLUE_D,\n",
        "            \"y_0\": BLUE_B,\n",
        "            \"{t}\": GREY_B,\n",
        "\n",
        "        }}\n",
        "        solutions = VGroup(\n",
        "            OldTex(\"x({t}) = \\\\cos(t) x_0 - \\\\sin(t) y_0\", **kw),\n",
        "            OldTex(\"y({t}) = \\\\sin(t) x_0 + \\\\cos(t) y_0\", **kw),\n",
        "        )\n",
        "        solutions.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        for solution in solutions:\n",
        "            self.play(Write(solution))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwoDifferetViewsWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = VGroup(*(ScreenRectangle() for x in range(2)))\n",
        "        screens.arrange(RIGHT)\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens[0].set_stroke(BLUE, 2)\n",
        "        screens[1].set_stroke(GREY_BROWN, 2)\n",
        "        self.add(screens)\n",
        "\n",
        "        titles = VGroup(\n",
        "            Text(\"Geometric\"),\n",
        "            Text(\"Analytic\"),\n",
        "        )\n",
        "        for title, screen in zip(titles, screens):\n",
        "            title.next_to(screen, UP)\n",
        "            title.align_to(titles[0], UP)\n",
        "            self.play(Write(title))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EulersFormulaWrapper(VideoWrapper):\n",
        "    title = \"Video on $e^{it}$\"\n",
        "\n",
        "\n",
        "class ImaginaryExponent(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class ComplexEquation(Scene):\n",
        "    def construct(self):\n",
        "        # Equation\n",
        "        equation = OldTex(\n",
        "            \"\"\"\n",
        "            \\\\frac{d}{d{t} } \\\\Big[ x(t) + {i}y(t)\\\\Big] =\n",
        "            {i} \\\\cdot \\\\Big[ x(t) + {i}y(t) \\\\Big]\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"x\": BLUE_B,\n",
        "                \"y\": BLUE_D,\n",
        "                \"{t}\": GREY_B,\n",
        "                \"=\": WHITE,\n",
        "                \"\\\\cdot\": WHITE,\n",
        "                \"{i}\": RED,\n",
        "            }\n",
        "        )\n",
        "        equation.move_to(2 * UP)\n",
        "\n",
        "        braces = VGroup(*(\n",
        "            Brace(equation[i:j], UP, buff=SMALL_BUFF)\n",
        "            for i, j in [(2, 8), (11, 17)]\n",
        "        ))\n",
        "        braces.set_fill(GREY_A, 1)\n",
        "        for brace in braces:\n",
        "            brace.zt = OldTex(\"z(t)\", tex_to_color_map={\"z\": BLUE, \"t\": GREY_B})\n",
        "            brace.zt.next_to(brace, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(\n",
        "            *(GrowFromCenter(b) for b in braces),\n",
        "            *(FadeIn(b.zt, 0.25 * UP) for b in braces)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show romeo and juilet\n",
        "        x_part = equation.get_part_by_tex(\"x\")\n",
        "        y_part = equation.get_part_by_tex(\"y\")\n",
        "\n",
        "        juliet_label = OldTexText(\"Juliet's love\", font_size=30)\n",
        "        juliet_label.next_to(x_part, DOWN, LARGE_BUFF)\n",
        "        romeo_label = OldTexText(\"Romeo's love\", font_size=30)\n",
        "        romeo_label.next_to(y_part, DOWN, LARGE_BUFF)\n",
        "        juliet_label.align_to(romeo_label, DOWN)\n",
        "        VGroup(juliet_label, romeo_label).space_out_submobjects(1.5)\n",
        "\n",
        "        juliet_arrow = Arrow(x_part, juliet_label, buff=0.1, fill_color=BLUE_B)\n",
        "        romeo_arrow = Arrow(y_part, romeo_label, buff=0.1, fill_color=BLUE_D)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(juliet_arrow),\n",
        "            FadeIn(juliet_label),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(romeo_arrow),\n",
        "            FadeIn(romeo_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Describe i\n",
        "        i_part = equation.get_parts_by_tex(\"{i}\")[1]\n",
        "        i_label = OldTexText(\"90-degree rotation\", font_size=30)\n",
        "        i_label.set_color(RED)\n",
        "        i_label.next_to(romeo_label, RIGHT, MED_LARGE_BUFF, aligned_edge=DOWN)\n",
        "        i_arrow = Arrow(i_part, i_label, fill_color=RED)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(i_arrow),\n",
        "            FadeIn(i_label, DR),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        all_labels = VGroup(romeo_label, juliet_label, i_label)\n",
        "\n",
        "        # Show solution\n",
        "        solution = OldTex(\n",
        "            \"z(t) = e^{it} z_0\",\n",
        "            tex_to_color_map={\n",
        "                \"i\": RED,\n",
        "                \"t\": GREY_B,\n",
        "                \"z\": BLUE,\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        solution.scale(1.5)\n",
        "        solution.next_to(all_labels, DOWN, LARGE_BUFF)\n",
        "        solution[8:].set_color(BLUE_D)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(braces[0].zt, solution[:4]),\n",
        "            Write(solution[4]),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(solution[5]),\n",
        "            TransformFromCopy(equation[9], solution[6]),\n",
        "            Write(solution[7]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(solution[8:], 0.1 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class JulietChidingRomeo(Scene):\n",
        "    def construct(self):\n",
        "        juliet = PiCreature(color=BLUE_B)\n",
        "        romeo = PiCreature(color=BLUE_D)\n",
        "        romeo.flip()\n",
        "        pis = VGroup(juliet, romeo)\n",
        "        pis.set_height(2)\n",
        "        pis.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        pis.to_edge(DOWN)\n",
        "        romeo.make_eye_contact(juliet)\n",
        "\n",
        "        self.add(pis)\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                juliet, OldTexText(\"It just seems like \\\\\\\\ your feelings aren't \\\\\\\\ real\"),\n",
        "                bubble_config={\"height\": 2.5, \"width\": 3.5},\n",
        "                target_mode=\"sassy\",\n",
        "            ),\n",
        "            romeo.change(\"guilty\"),\n",
        "        )\n",
        "        for x in range(2):\n",
        "            self.play(Blink(juliet))\n",
        "            self.play(Blink(romeo))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class General90DegreeRotationExponents(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        exps = VGroup(\n",
        "            get_matrix_exponential([[\"0\", \"-1\"], [\"1\", \"0\"]]),\n",
        "            OldTex(\"e^{it}\", tex_to_color_map={\"i\": RED}),\n",
        "            OldTex(\n",
        "                \"e^{(ai + bj + ck)t}\",\n",
        "                tex_to_color_map={\n",
        "                    \"i\": RED,\n",
        "                    \"j\": GREEN,\n",
        "                    \"k\": BLUE,\n",
        "                }\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"e^{i \\\\sigma_x t}, \\\\quad \",\n",
        "                \"e^{i \\\\sigma_y t}, \\\\quad \",\n",
        "                \"e^{i \\\\sigma_z t}\",\n",
        "                tex_to_color_map={\n",
        "                    \"\\\\sigma_x\": RED,\n",
        "                    \"\\\\sigma_y\": GREEN,\n",
        "                    \"\\\\sigma_z\": BLUE,\n",
        "                }\n",
        "            ),\n",
        "        )\n",
        "        exps[0][1].set_color(TEAL)\n",
        "        exps[0].scale(0.5)\n",
        "\n",
        "        exps.arrange(DOWN, buff=1.5, aligned_edge=LEFT)\n",
        "\n",
        "        labels = VGroup(\n",
        "            OldTexText(\"$90^\\\\circ$ rotation matrix\"),\n",
        "            OldTexText(\"Imaginary numbers\"),\n",
        "            OldTexText(\"Quaternions\"),\n",
        "            OldTexText(\"Pauli matrices\"),\n",
        "        )\n",
        "        for label, exp in zip(labels, exps):\n",
        "            label.scale(0.75)\n",
        "            label.next_to(exp, LEFT, LARGE_BUFF, aligned_edge=DOWN)\n",
        "            label.align_to(labels[0], LEFT)\n",
        "\n",
        "        VGroup(exps, labels).to_edge(LEFT)\n",
        "\n",
        "        quat_note = OldTex(\"(a^2 + b^2 + c^2 = 1)\", font_size=24)\n",
        "        quat_note.next_to(exps[2], DOWN, aligned_edge=LEFT)\n",
        "        exps[2].add(quat_note)\n",
        "\n",
        "        for exp, label in zip(exps, labels):\n",
        "            self.play(\n",
        "                FadeIn(exp),\n",
        "                FadeIn(label),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotationIn3dPlane(Scene):\n",
        "    def construct(self):\n",
        "        # Axes and frame\n",
        "        axes = ThreeDAxes()\n",
        "        axes.set_stroke(width=2)\n",
        "        axes.set_flat_stroke(False)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.set_height(2.0 * FRAME_HEIGHT)\n",
        "        frame.reorient(-40, 70)\n",
        "        frame.add_updater(lambda f, dt: f.increment_theta(0.03 * dt))\n",
        "\n",
        "        self.add(axes, frame)\n",
        "\n",
        "        # Plane\n",
        "        plane = Surface()\n",
        "        plane.replace(VGroup(axes.x_axis, axes.y_axis), stretch=True)\n",
        "        plane.set_color(GREY_C, opacity=0.75)\n",
        "        plane.set_gloss(1)\n",
        "        grid = NumberPlane((-6, 6), (-5, 5), faded_line_ratio=0)\n",
        "\n",
        "        radius = 3\n",
        "        p_vect = Vector(radius * RIGHT, fill_color=BLUE)\n",
        "        v_vect = p_vect.copy()\n",
        "        arc = Arc(0, PI / 2, radius=radius / 4)\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(WHITE, 2)\n",
        "        randy = Randolph(mode=\"pondering\")\n",
        "        randy.set_gloss(0.7)\n",
        "        rot_group = Group(plane, grid, p_vect, v_vect, arc, circle, randy)\n",
        "\n",
        "        normal = OUT\n",
        "        for angle, axis in [(30 * DEGREES, RIGHT), (20 * DEGREES, UP)]:\n",
        "            rot_group.rotate(angle, axis)\n",
        "            normal = rotate_vector(normal, angle, axis)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(plane),\n",
        "            FadeIn(randy),\n",
        "        )\n",
        "        self.play(GrowArrow(p_vect))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            Rotate(v_vect, PI / 2, axis=normal, about_point=axes.get_origin()),\n",
        "            Rotate(randy, PI / 2, axis=normal, about_point=axes.get_origin()),\n",
        "            UpdateFromAlphaFunc(v_vect, lambda m, a: m.set_fill(interpolate_color(BLUE, RED, a))),\n",
        "            ShowCreation(arc),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            v_vect.animate.shift(p_vect.get_end() - v_vect.get_start()),\n",
        "            FadeOut(arc),\n",
        "            FadeOut(randy),\n",
        "        )\n",
        "        rot_group = VGroup(grid, p_vect, v_vect)\n",
        "        rot_group.set_stroke(background=True)\n",
        "        self.add(circle, rot_group)\n",
        "        self.play(\n",
        "            FadeIn(circle),\n",
        "            Rotate(\n",
        "                rot_group,\n",
        "                2 * TAU,\n",
        "                axis=normal,\n",
        "                about_point=axes.get_origin(),\n",
        "                run_time=4 * TAU,\n",
        "                rate_func=linear,\n",
        "            ),\n",
        "            VFadeIn(grid),\n",
        "        )\n",
        "\n",
        "\n",
        "class StoryForAnotherTime(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"The full story\\\\\\\\takes more time.\"),\n",
        "            bubble_config={\"height\": 3, \"width\": 3.5},\n",
        "            added_anims=[self.change_students(\"confused\", \"erm\", \"hesitant\", look_at=self.screen)]\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class SchrodingerSum(Scene):\n",
        "    def construct(self):\n",
        "        # Add title\n",
        "        equation_label = VGroup(\n",
        "            OldTexText(\"Schr\u00f6dinger equation:\"),\n",
        "            OldTex(\n",
        "                \"{i} \\\\hbar \\\\frac{\\\\partial}{\\\\partial t} |\\\\psi(t)\\\\rangle = \\\\hat{H} |\\\\psi(t)\\\\rangle\",\n",
        "                tex_to_color_map={\n",
        "                    \"|\\\\psi(t)\\\\rangle\": BLUE,\n",
        "                    \"{i}\": WHITE,\n",
        "                    \"\\\\frac{\\\\partial}{\\\\partial t}\": GREY_A,\n",
        "                },\n",
        "                font_size=36\n",
        "            )\n",
        "        )\n",
        "        equation_label.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        equation_label.set_width(FRAME_WIDTH - 1)\n",
        "        equation_label.to_edge(UP)\n",
        "        i_part = equation_label[1].get_part_by_tex(\"{i}\")\n",
        "        self.add(equation_label)\n",
        "\n",
        "        # Axes\n",
        "        x_range = np.array([-5, 5, 1])\n",
        "        y_range = np.array([-1, 1, 0.5])\n",
        "        axes = ThreeDAxes(\n",
        "            x_range=x_range,\n",
        "            y_range=y_range,\n",
        "            z_range=y_range,\n",
        "            height=1.25,\n",
        "            depth=1.25,\n",
        "            width=4,\n",
        "            axis_config={\"include_tip\": False, \"tick_size\": 0.05},\n",
        "        )\n",
        "        # plane = ComplexPlane(y_range, y_range)\n",
        "        # plane.rotate(PI / 2, DOWN)\n",
        "        # plane.match_depth(axes)\n",
        "        # axes.add(plane)\n",
        "        # axes.y_axis.set_opacity(0)\n",
        "        # axes.z_axis.set_opacity(0)\n",
        "\n",
        "        lil_axes = VGroup(*(axes.deepcopy() for x in range(3)))\n",
        "        lil_axes.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        lil_axes.to_corner(DL)\n",
        "        brace = Brace(lil_axes, RIGHT, buff=MED_LARGE_BUFF)\n",
        "        axes.scale(2)\n",
        "        axes.next_to(brace, RIGHT)\n",
        "\n",
        "        for ax in [axes, *lil_axes]:\n",
        "            ax.rotate(-30 * DEGREES, UP)\n",
        "            ax.rotate(10 * DEGREES, RIGHT)\n",
        "            ax.set_flat_stroke(False)\n",
        "\n",
        "        # Graphs\n",
        "        def func0(x, t):\n",
        "            magnitude = np.exp(-x * x / 2)\n",
        "            phase = np.exp(complex(0, 0.5 * t))\n",
        "            return magnitude * phase\n",
        "\n",
        "        def func1(x, t):\n",
        "            magnitude = np.exp(-x * x / 2) * 2 * x\n",
        "            magnitude *= 1 / math.sqrt(2)\n",
        "            phase = np.exp(complex(0, 1.5 * t))\n",
        "            return magnitude * phase\n",
        "\n",
        "        def func2(x, t):\n",
        "            magnitude = -1 * np.exp(-x * x / 2) * (2 - 4 * x * x)\n",
        "            magnitude *= 1 / math.sqrt(8)\n",
        "            phase = np.exp(complex(0, 2.5 * t))\n",
        "            return magnitude * phase\n",
        "\n",
        "        def comb_func(x, t):\n",
        "            return (func0(x, t) + func1(x, t) + func2(x, t)) / 3\n",
        "\n",
        "        def to_xyz(func, x):\n",
        "            z = func(x, get_t())\n",
        "            return (x, z.real, z.imag)\n",
        "\n",
        "        t_tracker = ValueTracker()\n",
        "        t_tracker.add_updater(lambda m, dt: m.increment_value(dt))\n",
        "        self.add(t_tracker)\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def get_graph(axes, func, color):\n",
        "            fade_tracker = ValueTracker(1)\n",
        "            result = VGroup()\n",
        "            graph = always_redraw(lambda: ParametricCurve(\n",
        "                lambda x: axes.c2p(*to_xyz(func, x)),\n",
        "                t_range=x_range[:2],\n",
        "                color=color,\n",
        "                stroke_opacity=fade_tracker.get_value(),\n",
        "                flat_stroke=False,\n",
        "            ))\n",
        "            result.add(graph)\n",
        "            for x in np.linspace(0, 1, 100):\n",
        "                line = Line(stroke_color=color, stroke_width=2)\n",
        "                line.x = x\n",
        "                line.axes = axes\n",
        "                line.graph = graph\n",
        "                line.fade_tracker = fade_tracker\n",
        "                line.add_updater(lambda m: m.set_points_as_corners([\n",
        "                    m.axes.x_axis.pfp(m.x),\n",
        "                    m.graph.pfp(m.x),\n",
        "                ]).set_opacity(0.5 * m.fade_tracker.get_value()))\n",
        "                result.add(line)\n",
        "            result.fade_tracker = fade_tracker\n",
        "            return result\n",
        "\n",
        "        graph0, graph1, graph2, comb_graph = graphs = [\n",
        "            get_graph(axes, func, color)\n",
        "            for axes, func, color in zip(\n",
        "                [*lil_axes, axes],\n",
        "                [func0, func1, func2, comb_func],\n",
        "                [BLUE, TEAL, GREEN, YELLOW]\n",
        "            )\n",
        "        ]\n",
        "\n",
        "        lil_axes[1].save_state()\n",
        "        lil_axes[1].scale(2)\n",
        "        lil_axes[1].move_to(DOWN)\n",
        "\n",
        "        self.add(lil_axes[1], graph1)\n",
        "        self.wait(10)\n",
        "        self.add(*graphs)\n",
        "        self.play(\n",
        "            FadeIn(lil_axes[::2]),\n",
        "            FadeIn(axes),\n",
        "            Restore(lil_axes[1]),\n",
        "            GrowFromCenter(brace),\n",
        "            *(\n",
        "                UpdateFromAlphaFunc(g.fade_tracker, lambda m, a: m.set_value(a))\n",
        "                for g in (*graphs[::2], comb_graph)\n",
        "            )\n",
        "        )\n",
        "        self.wait(15)\n",
        "        self.play(\n",
        "            FlashAround(i_part, color=RED),\n",
        "            i_part.animate.set_color(RED)\n",
        "        )\n",
        "        self.wait(30)\n",
        "\n",
        "\n",
        "class BasicVectorFieldIdea(Scene):\n",
        "    matrix = [[-1.5, -1], [3, 0.5]]\n",
        "\n",
        "    def construct(self):\n",
        "        # Equation\n",
        "        v_tex = \"\\\\vec{\\\\textbf{v} }(t)\"\n",
        "        equation = OldTex(\n",
        "            \"{d \\\\over dt}\", v_tex, \"=\", \"M\", v_tex,\n",
        "            tex_to_color_map={\n",
        "                \"M\": GREY_A,\n",
        "                v_tex: YELLOW,\n",
        "            }\n",
        "        )\n",
        "        equation.set_height(1.5)\n",
        "        equation.to_corner(UL, buff=0.25)\n",
        "\n",
        "        background_rect = SurroundingRectangle(equation, buff=SMALL_BUFF)\n",
        "        background_rect.set_fill(BLACK, opacity=0.9).set_stroke(WHITE, 2)\n",
        "\n",
        "        # Plane and field\n",
        "        matrix = np.array(self.matrix)\n",
        "\n",
        "        def func(x, y):\n",
        "            return 0.15 * np.dot(matrix.T, [x, y])\n",
        "\n",
        "        plane = NumberPlane()\n",
        "        vector_field = VectorField(\n",
        "            func, plane,\n",
        "            magnitude_range=(0, 2),\n",
        "            vector_config={\"thickness\": 0.025}\n",
        "        )\n",
        "        dots = VGroup(*(\n",
        "            Dot(v.get_start(), radius=0.02, fill_color=YELLOW)\n",
        "            for v in vector_field\n",
        "        ))\n",
        "\n",
        "        # Velocity and position\n",
        "        vel_rect = SurroundingRectangle(equation[:2], stroke_color=RED)\n",
        "        pos_rect = SurroundingRectangle(equation[4], stroke_color=YELLOW)\n",
        "        pos_rect.match_height(vel_rect, stretch=True)\n",
        "        pos_rect.match_y(vel_rect)\n",
        "\n",
        "        vel_words = Text(\"Velocity\", color=RED)\n",
        "        vel_words.next_to(vel_rect, DOWN)\n",
        "        vel_words.shift_onto_screen(buff=0.2)\n",
        "        pos_words = Text(\"Position\", color=YELLOW)\n",
        "        pos_words.next_to(pos_rect, DOWN)\n",
        "\n",
        "        for word in vel_words, pos_words:\n",
        "            word.add_background_rectangle()\n",
        "\n",
        "        self.add(plane, background_rect, equation)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(vel_rect),\n",
        "            FadeIn(vel_words, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(pos_rect),\n",
        "            FadeIn(pos_words, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        term_labels = VGroup(vel_rect, vel_words, pos_rect, pos_words)\n",
        "\n",
        "        foreground = [background_rect, equation, term_labels]\n",
        "        self.add(dots, *foreground)\n",
        "        self.play(LaggedStartMap(GrowFromCenter, dots))\n",
        "        self.add(dots, vector_field, *foreground)\n",
        "        self.play(LaggedStartMap(GrowArrow, vector_field, lag_ratio=0.01))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(dots),\n",
        "            FadeOut(term_labels),\n",
        "            vector_field.animate.set_opacity(0.25)\n",
        "        )\n",
        "\n",
        "        # Show Mv being attached to v\n",
        "        index = 326\n",
        "        lil_vect = vector_field[index]\n",
        "        coords = plane.p2c(lil_vect.get_start())\n",
        "\n",
        "        dot = Dot(color=YELLOW, radius=0.05)\n",
        "        dot.move_to(plane.c2p(*coords))\n",
        "        dot_label = OldTex(\"\\\\vec{\\\\textbf{v}}\", color=YELLOW)\n",
        "        dot_label.next_to(dot, UR, SMALL_BUFF)\n",
        "\n",
        "        vector = Arrow(plane.get_origin(), dot.get_center(), buff=0)\n",
        "        vector.set_fill(YELLOW, opacity=1)\n",
        "        vector.set_stroke(BLACK, 0.5)\n",
        "\n",
        "        Mv = Arrow(plane.get_origin(), plane.c2p(*3 * func(*coords)), buff=0)\n",
        "        Mv.set_fill(RED, 1)\n",
        "        Mv_label = OldTex(\"M\", \"\\\\vec{\\\\textbf{v}}\")\n",
        "        Mv_label[0].set_color(GREY_B)\n",
        "        Mv_label.next_to(Mv.get_end(), DOWN)\n",
        "        attached_Mv = lil_vect.copy().set_opacity(1)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromPoint(dot, equation[-1].get_center()),\n",
        "            FadeTransform(equation[-1][0].copy(), dot_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(vector),\n",
        "            ReplacementTransform(vector.copy().set_opacity(0), Mv, path_arc=-45 * DEGREES),\n",
        "            FadeTransform(equation[3:5].copy(), Mv_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(Mv, attached_Mv)\n",
        "        )\n",
        "        self.remove(attached_Mv)\n",
        "        lil_vect.set_opacity(1)\n",
        "        self.wait()\n",
        "\n",
        "        for x in range(100):\n",
        "            index += 1\n",
        "            lil_vect = vector_field[index]\n",
        "            coords = plane.p2c(lil_vect.get_start())\n",
        "            vector.put_start_and_end_on(plane.get_origin(), plane.c2p(*coords))\n",
        "            Mv.put_start_and_end_on(plane.get_origin(), plane.c2p(*3 * func(*coords)))\n",
        "            Mv_label.next_to(Mv.get_end(), DOWN)\n",
        "            dot.move_to(vector.get_end())\n",
        "            dot_label.next_to(dot, UR, SMALL_BUFF)\n",
        "            lil_vect.set_opacity(1)\n",
        "\n",
        "            if x < 20:\n",
        "                self.wait(0.25)\n",
        "            else:\n",
        "                self.wait(0.1)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(Mv_label, dot_label, Mv, vector, dot)),\n",
        "            vector_field.animate.set_opacity(1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show example initial condition evolving\n",
        "        def get_flow_lines(step_multiple, arc_len):\n",
        "            return StreamLines(\n",
        "                func, plane,\n",
        "                step_multiple=step_multiple,\n",
        "                magnitude_range=(0, 2),\n",
        "                color_by_magnitude=False,\n",
        "                stroke_color=GREY_A,\n",
        "                stroke_width=2,\n",
        "                stroke_opacity=1,\n",
        "                arc_len=arc_len,\n",
        "            )\n",
        "\n",
        "        dot = Dot()\n",
        "        vect = Vector()\n",
        "        vect.set_color(RED)\n",
        "\n",
        "        def update_vect(vect):\n",
        "            coords = plane.p2c(dot.get_center())\n",
        "            end = plane.c2p(*func(*coords))\n",
        "            vect.put_start_and_end_on(plane.get_origin(), end)\n",
        "            vect.shift(dot.get_center() - plane.get_origin())\n",
        "\n",
        "        vect.add_updater(update_vect)\n",
        "\n",
        "        flow_line = get_flow_lines(4, 20)[10]\n",
        "        flow_line.insert_n_curves(100)\n",
        "        flow_line.set_stroke(width=3)\n",
        "        dot.move_to(flow_line.get_start())\n",
        "\n",
        "        self.add(flow_line, vect, dot)\n",
        "        self.play(\n",
        "            MoveAlongPath(dot, flow_line, run_time=10, rate_func=linear),\n",
        "            ShowCreation(flow_line, run_time=10, rate_func=linear),\n",
        "            VFadeIn(dot),\n",
        "            VFadeIn(vect),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(flow_line, dot, vect)))\n",
        "        self.wait()\n",
        "\n",
        "        # Show exponential solution\n",
        "        solution = OldTex(\n",
        "            v_tex, \"=\", \"e^{M t}\", \"\\\\vec{\\\\textbf{v} }(0)\"\n",
        "        )\n",
        "\n",
        "        solution[0].set_color(YELLOW)\n",
        "        solution[2][1].set_color(GREY_B)\n",
        "        solution.match_width(equation)\n",
        "        solution.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        new_br = SurroundingRectangle(VGroup(equation, solution), buff=MED_SMALL_BUFF)\n",
        "        new_br.match_style(background_rect)\n",
        "\n",
        "        self.play(\n",
        "            Transform(background_rect, new_br),\n",
        "            FadeIn(solution, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        foreground = VGroup(background_rect, equation, solution)\n",
        "        self.play(FadeOut(foreground))\n",
        "\n",
        "        # Show flow of all initial conditions\n",
        "        initial_points = np.array([\n",
        "            plane.c2p(x, y)\n",
        "            for x in np.arange(-16, 16, 0.5)\n",
        "            for y in np.arange(-6, 6, 0.5)\n",
        "        ])\n",
        "        dots = DotCloud(initial_points)\n",
        "        dots.set_radius(0.06)\n",
        "        dots.set_color(WHITE)\n",
        "        initial_points = np.array(dots.get_points())\n",
        "\n",
        "        self.add(dots)\n",
        "        self.play(vector_field.animate.set_opacity(0.75))\n",
        "\n",
        "        time_tracker = ValueTracker()\n",
        "\n",
        "        def update_dots(dots):\n",
        "            time = time_tracker.get_value()\n",
        "            transformation = np.identity(3)\n",
        "            transformation[:2, :2] = mat_exp(0.15 * matrix * time)\n",
        "            dots.set_points(np.dot(initial_points, transformation))\n",
        "\n",
        "        streaks = Group()\n",
        "\n",
        "        def update_streaks(streaks):\n",
        "            dc = dots.copy()\n",
        "            dc.clear_updaters()\n",
        "            dc.set_opacity(0.25)\n",
        "            dc.set_radius(0.01)\n",
        "            streaks.add(dc)\n",
        "\n",
        "        dots.add_updater(update_dots)\n",
        "        streaks.add_updater(update_streaks)\n",
        "\n",
        "        self.add(plane, vector_field, streaks, dots)\n",
        "        self.play(time_tracker.animate.set_value(3), run_time=6, rate_func=linear)\n",
        "\n",
        "        # Flow\n",
        "        # animated_flow = AnimatedStreamLines(get_flow_lines(0.25, 3))\n",
        "\n",
        "\n",
        "class DefineVectorFieldWithHyperbolicFlow(BasicVectorFieldIdea):\n",
        "    matrix = np.array([[0.0, 1.0], [1.0, 0.0]]) / 0.45\n",
        "\n",
        "\n",
        "class MoreShakesperianRomeoJuliet(RomeoAndJuliet):\n",
        "    def construct(self):\n",
        "        # Add plane/vector field\n",
        "        plane = NumberPlane((-5, 5), (-5, 5), faded_line_ratio=0)\n",
        "        plane.set_height(5)\n",
        "        plane.to_corner(DL)\n",
        "        self.add(plane)\n",
        "\n",
        "        def func0(x, y):\n",
        "            return (x, y)\n",
        "\n",
        "        def func1(x, y):\n",
        "            return (-y, x)\n",
        "\n",
        "        def func2(x, y):\n",
        "            return (y, x)\n",
        "\n",
        "        vector_fields = VGroup(*(\n",
        "            VectorField(\n",
        "                func, plane,\n",
        "                step_multiple=1,\n",
        "                magnitude_range=(0, 8),\n",
        "                vector_config={\"thickness\": 0.025},\n",
        "                length_func=lambda norm: 0.9 * sigmoid(norm)\n",
        "            )\n",
        "            for func in [func0, func1, func2]\n",
        "        ))\n",
        "\n",
        "        # Put differential equation above it\n",
        "        equations = VGroup(\n",
        "            get_2d_equation([[\"0\", \"-1\"], [\"+1\", \"0\"]]),\n",
        "            get_2d_equation([[\"0\", \"+1\"], [\"+1\", \"0\"]]),\n",
        "        )\n",
        "        equations.to_corner(UL)\n",
        "\n",
        "        m1 = equations[0][3]\n",
        "        m2 = equations[1][3]\n",
        "\n",
        "        self.add(equations[0])\n",
        "        vector_fields[0].set_opacity(0)\n",
        "        vf = vector_fields[0]\n",
        "        self.play(Transform(vf, vector_fields[1]))\n",
        "        self.wait()\n",
        "\n",
        "        # Add Romeo and Juliet\n",
        "        romeo, juliet = lovers = self.get_romeo_and_juliet()\n",
        "        lovers.set_height(2)\n",
        "        lovers.arrange(LEFT, buff=0.5)\n",
        "        lovers.to_corner(DR, buff=1.5)\n",
        "        self.make_romeo_and_juliet_dynamic(romeo, juliet)\n",
        "\n",
        "        scales = VGroup(\n",
        "            self.get_love_scale(romeo, RIGHT, \"y\", BLUE_D),\n",
        "            self.get_love_scale(juliet, LEFT, \"x\", BLUE_B),\n",
        "        )\n",
        "\n",
        "        x0, y0 = (5, 5)\n",
        "        ps_point = Dot(color=BLUE_B)\n",
        "        ps_point.move_to(plane.c2p(x0, y0))\n",
        "        romeo.love_tracker.add_updater(lambda m: m.set_value(plane.p2c(ps_point.get_center())[0]))\n",
        "        juliet.love_tracker.add_updater(lambda m: m.set_value(plane.p2c(ps_point.get_center())[1]))\n",
        "\n",
        "        self.add(*lovers, scales, self.get_romeo_juilet_name_labels(lovers))\n",
        "        self.add(*(pi.love_tracker for pi in lovers))\n",
        "        self.add(*(pi.heart_eyes for pi in lovers))\n",
        "        self.add(ps_point)\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to alternate field\n",
        "        self.play(\n",
        "            Transform(vf, vector_fields[2]),\n",
        "            FadeOut(m1, UP),\n",
        "            FadeIn(m2, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        last_rect = VMobject()\n",
        "        for row in m2.get_rows():\n",
        "            rect = SurroundingRectangle(row)\n",
        "            self.play(FadeIn(rect), FadeOut(last_rect))\n",
        "            self.wait()\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_rect))\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(vf, run_time=6, rate_func=linear))\n",
        "\n",
        "        # Show flow\n",
        "        def get_flow_line(x0, y0):\n",
        "            line = ParametricCurve(\n",
        "                lambda t: plane.c2p(\n",
        "                    math.cosh(t) * x0 + math.sinh(t) * y0,\n",
        "                    math.sinh(t) * x0 + math.cosh(t) * y0,\n",
        "                ),\n",
        "                t_range=(0, 4),\n",
        "            )\n",
        "            line.set_stroke(WHITE, 3)\n",
        "            return line\n",
        "\n",
        "        def move_along_line(line, run_time=8):\n",
        "            self.add(line, ps_point)\n",
        "            self.play(\n",
        "                MoveAlongPath(ps_point, line.copy()),\n",
        "                ShowCreation(line),\n",
        "                rate_func=linear,\n",
        "                run_time=run_time,\n",
        "            )\n",
        "\n",
        "        line1 = get_flow_line(4, -3)\n",
        "        # line2 = get_flow_line(-3, 4)\n",
        "        line3 = get_flow_line(-4, 3)\n",
        "\n",
        "        # move_along_line(line1)\n",
        "        # self.wait()\n",
        "\n",
        "        ps_point.move_to(line1.get_start())\n",
        "        self.remove(line1)\n",
        "        low_vects = VGroup()\n",
        "        mid_vects = VGroup()\n",
        "        high_vects = VGroup()\n",
        "        for vector in vf:\n",
        "            x, y = plane.p2c(vector.get_start())\n",
        "            if x + y < -1e-6:\n",
        "                low_vects.add(vector)\n",
        "            elif -1e-6 < x + y < 1e-6:\n",
        "                mid_vects.add(vector)\n",
        "            else:\n",
        "                high_vects.add(vector)\n",
        "\n",
        "        low_vects.set_opacity(0.1)\n",
        "        mid_vects.set_opacity(0.5)\n",
        "        self.wait()\n",
        "        move_along_line(line1)\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(line1)\n",
        "        ps_point.move_to(line3)\n",
        "        low_vects.set_opacity(1)\n",
        "        high_vects.set_opacity(0.1)\n",
        "        move_along_line(line3)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class NotAllThatRomanticLabel(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Not all that\\n\\n romantic!\")\n",
        "        arrow = Vector(LEFT)\n",
        "        arrow.next_to(text, LEFT)\n",
        "        text.set_color(RED)\n",
        "        arrow.set_color(RED)\n",
        "\n",
        "        self.add(text)\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TransitionWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = VGroup(*(ScreenRectangle() for x in range(2)))\n",
        "        screens.set_width(0.4 * FRAME_WIDTH)\n",
        "        screens[0].to_edge(LEFT)\n",
        "        screens[1].to_edge(RIGHT)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens[0].set_stroke(BLUE, 2)\n",
        "        screens[1].set_stroke(GREY_BROWN, 2)\n",
        "        self.add(screens)\n",
        "\n",
        "        arrow = Arrow(*screens)\n",
        "        exp = OldTex(\"e^{Mt}\")\n",
        "        exp.next_to(arrow, UP)\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Time: $0$\"),\n",
        "            OldTexText(\"Time: $t$\"),\n",
        "        )\n",
        "        for screen, title in zip(screens, titles):\n",
        "            title.next_to(screen, UP)\n",
        "            screen.add(title)\n",
        "\n",
        "        vf_words = OldTexText(\"Vector field defined by $\\\\vec{\\\\textbf{v} } \\\\rightarrow M\\\\vec{\\\\textbf{v} }$\")\n",
        "        vf_words.match_width(screens[0])\n",
        "        vf_words.next_to(screens[0], DOWN)\n",
        "        self.add(vf_words)\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(exp))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DerivativeOfExpMt(Scene):\n",
        "    def construct(self):\n",
        "        # For all tex\n",
        "        v0_tex = \"\\\\vec{\\\\textbf{v} }_0\"\n",
        "        kw = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"M\": GREY_B,\n",
        "                \"{t}\": YELLOW,\n",
        "                v0_tex: BLUE,\n",
        "                \"=\": WHITE,\n",
        "                \"\\\\cdots\": WHITE,\n",
        "                \"+\": WHITE,\n",
        "                \"\\\\left(\": WHITE,\n",
        "                \"\\\\right)\": WHITE,\n",
        "            }\n",
        "        }\n",
        "\n",
        "        # Show claim\n",
        "        solution = OldTex(\"\\\\vec{\\\\textbf{v} }({t}) = e^{M {t} } \" + v0_tex, **kw)\n",
        "        equation = OldTex(\"{d \\\\over dt} \\\\vec{\\\\textbf{v} }({t}) = M \\\\vec{\\\\textbf{v} }({t})\", **kw)\n",
        "        arrow = Vector(1.5 * RIGHT)\n",
        "        top_line = VGroup(solution, arrow, equation)\n",
        "        top_line.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        top_line.set_width(FRAME_WIDTH - 1)\n",
        "\n",
        "        solves = Text(\"Solves(?)\", font_size=24)\n",
        "        solves.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(solution)\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            FadeIn(equation, RIGHT),\n",
        "            FadeIn(solves, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow.add(solves)\n",
        "\n",
        "        # Try it...\n",
        "\n",
        "        # Show calculations...\n",
        "        tex_expressions = [\n",
        "            \"\"\"\n",
        "            e^{ {t}M } v_0 =\n",
        "            \\\\left( {t}^0 M^0 +\n",
        "            {t}^1 M^1 +\n",
        "            { {t}^2 \\\\over 2} M^2 +\n",
        "            { {t}^3 \\\\over 6} M^3 +\n",
        "            \\\\cdots +\n",
        "            { {t}^n \\\\over n!} M^n +\n",
        "            \\\\cdots\n",
        "            \\\\right) v_0\n",
        "            \"\"\",\n",
        "            \"\"\"\n",
        "            e^{ {t}M } v_0 =\n",
        "            {t}^0 M^0 v_0 +\n",
        "            {t}^1 M^1 v_0 +\n",
        "            { {t}^2 \\\\over 2} M^2 v_0 +\n",
        "            { {t}^3 \\\\over 6} M^3 v_0 +\n",
        "            \\\\cdots +\n",
        "            { {t}^n \\\\over n!} M^n v_0 +\n",
        "            \\\\cdots\n",
        "            \"\"\",\n",
        "            \"\"\"\n",
        "            {d \\\\over dt}\n",
        "            e^{ {t}M } v_0 =\n",
        "            0 +\n",
        "            1 \\\\cdot {t}^0 M^1 v_0 +\n",
        "            {2 {t}^1 \\\\over 2} M^2 v_0 +\n",
        "            {3 {t}^2 \\\\over 6} M^3 v_0 +\n",
        "            \\\\cdots +\n",
        "            {n {t}^{n - 1} \\\\over n!} M^n v_0 +\n",
        "            \\\\cdots\n",
        "            \"\"\",\n",
        "            \"\"\"\n",
        "            {d \\\\over dt}\n",
        "            e^{ {t}M } v_0 =\n",
        "            0 +\n",
        "            1 \\\\cdot {t}^0 M^1 v_0 +\n",
        "            {t}^1 M^2 v_0 +\n",
        "            { {t}^2 \\\\over 2} M^3 v_0 +\n",
        "            \\\\cdots +\n",
        "            { {t}^{n - 1} \\\\over (n - 1)!} M^n v_0 +\n",
        "            \\\\cdots\n",
        "            \"\"\",\n",
        "            \"\"\"\n",
        "            {d \\\\over dt}\n",
        "            e^{ {t}M } v_0 =\n",
        "            M \\\\left(\n",
        "            {t}^0 M^0 v_0 +\n",
        "            {t}^1 M^1 v_0 +\n",
        "            { {t}^2 \\\\over 2} M^2 v_0 +\n",
        "            \\\\cdots +\n",
        "            { {t}^{n - 1} \\\\over (n - 1)!} M^{n - 1} v_0 +\n",
        "            \\\\cdots\n",
        "            \\\\right)\n",
        "            \"\"\",\n",
        "            \"\"\"\n",
        "            {d \\\\over dt}\n",
        "            e^{ {t}M } v_0 =\n",
        "            M \\\\left( e^{ {t}M } v_0  \\\\right)\n",
        "            \"\"\"\n",
        "        ]\n",
        "\n",
        "        lines = VGroup(*(\n",
        "            OldTex(tex.replace(\"v_0\", v0_tex), **kw)\n",
        "            for tex in tex_expressions\n",
        "        ))\n",
        "        lines.set_width(FRAME_WIDTH - 1)\n",
        "        max_height = 1.0\n",
        "        for line in lines:\n",
        "            line.set_width(FRAME_WIDTH - 2)\n",
        "            if line.get_height() > max_height:\n",
        "                line.set_height(max_height)\n",
        "            line.center()\n",
        "\n",
        "        def match_lines(l1, l2):\n",
        "            eq_centers = [eq.get_part_by_tex(\"=\").get_center() for eq in (l1, l2)]\n",
        "            l1.shift(eq_centers[1] - eq_centers[0])\n",
        "\n",
        "        # Line 0\n",
        "        self.play(top_line.animate.set_width(6).to_edge(UP))\n",
        "        lines[0].set_y(1)\n",
        "        self.play(TransformMatchingTex(solution[4:].copy(), lines[0]), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # 0 -> 1\n",
        "        match_lines(lines[1], lines[0])\n",
        "        lines[1].set_y(-1)\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                VGroup(*(\n",
        "                    sm\n",
        "                    for sm in lines[0][5:]\n",
        "                    if sm.get_tex() not in [\"\\\\left(\", \"\\\\right)\"]\n",
        "                )).copy(),\n",
        "                lines[1][5:]\n",
        "            ),\n",
        "            TransformFromCopy(lines[0][:5], lines[1][:5])\n",
        "        )\n",
        "        self.play(\n",
        "            lines[1].animate.set_y(1),\n",
        "            FadeOut(lines[0], UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 1 -> 2 -> 3\n",
        "        match_lines(lines[2], lines[1])\n",
        "        match_lines(lines[3], lines[2])\n",
        "        lines[2:4].set_y(-1)\n",
        "        self.play(FadeIn(lines[2], DOWN))\n",
        "\n",
        "        l1_indices, l2_indices, l3_indices = [\n",
        "            [\n",
        "                lines[i].index_of_part(part)\n",
        "                for part in it.chain(lines[i].get_parts_by_tex(\"=\"), lines[i].get_parts_by_tex(\"+\"))\n",
        "            ]\n",
        "            for i in (1, 2, 3)\n",
        "        ]\n",
        "\n",
        "        last_rects = VMobject()\n",
        "        for l1i, l1j, l2i, l2j in zip(l1_indices, l1_indices[1:], l2_indices, l2_indices[1:]):\n",
        "            if l1i is l1_indices[4]:\n",
        "                continue\n",
        "            r1 = SurroundingRectangle(lines[1][l1i + 1:l1j])\n",
        "            r2 = SurroundingRectangle(lines[2][l2i + 1:l2j])\n",
        "            rects = VGroup(r1, r2)\n",
        "            self.play(FadeIn(rects), FadeOut(last_rects))\n",
        "            self.wait(0.5)\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "        self.play(\n",
        "            lines[2].animate.set_y(1),\n",
        "            FadeOut(lines[1]),\n",
        "            FadeIn(lines[3]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        last_rects = VMobject()\n",
        "        for l2i, l2j, l3i, l3j in zip(l2_indices, l2_indices[1:], l3_indices, l3_indices[1:]):\n",
        "            # Such terrible style...please no on look\n",
        "            if l2i in [l2_indices[0], l2_indices[1], l2_indices[4]]:\n",
        "                continue\n",
        "            r2 = SurroundingRectangle(lines[2][l2i + 1:l2j])\n",
        "            r3 = SurroundingRectangle(lines[3][l3i + 1:l3j])\n",
        "            rects = VGroup(r2, r3)\n",
        "            self.play(FadeIn(rects), FadeOut(last_rects))\n",
        "            self.wait(0.5)\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "        self.wait()\n",
        "\n",
        "        # 3 -> 4\n",
        "        match_lines(lines[4], lines[3])\n",
        "        lines[4].set_y(-1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(lines[1], DOWN),\n",
        "            FadeOut(lines[2], DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            FlashUnder(sm, time_width=2, run_time=1)\n",
        "            for sm in lines[3].get_parts_by_tex(\"M\")[1:]\n",
        "        ), lag_ratio=0.2))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingTex(lines[3][:5], lines[4][:5]),\n",
        "            FadeTransform(lines[3][5:], lines[4][7:34]),\n",
        "            FadeIn(lines[4].get_part_by_tex(\"\\\\left(\")),\n",
        "            FadeIn(lines[4].get_part_by_tex(\"\\\\right)\")),\n",
        "            TransformFromCopy(\n",
        "                lines[3].get_parts_by_tex(\"M\")[1:],\n",
        "                VGroup(lines[4][5]),\n",
        "                path_arc=-45 * DEGREES,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 4 -> 5\n",
        "        match_lines(lines[5], lines[4])\n",
        "        lines[5].set_y(-3)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(lines[4][:7], lines[5][:7]),\n",
        "            TransformFromCopy(lines[4][34], lines[5][11]),\n",
        "            FadeTransform(lines[4][7:34].copy(), lines[5][7:11], stretch=False),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TryIt(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DR)\n",
        "\n",
        "        self.add(morty)\n",
        "\n",
        "        self.play(PiCreatureSays(morty, \"Try it!\", target_mode=\"surprised\", run_time=1))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "        self.remove(morty.bubble, morty.bubble.content)\n",
        "        self.play(PiCreatureSays(morty, \"Brace yourself now...\", target_mode=\"hesitant\"))\n",
        "        morty.look(ORIGIN)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class TracePropertyAndComputation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        trace_eq = OldTex(\n",
        "            \"\\\\text{Det}\\\\left(e^{Mt}\\\\right) = e^{\\\\text{Tr}(M) t}\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Det}\": GREEN_D,\n",
        "                \"\\\\text{Tr}\": RED_B,\n",
        "            }\n",
        "        )\n",
        "        trace_eq.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_right_hand\", trace_eq),\n",
        "            FadeIn(trace_eq, 0.5 * UP),\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"pondering\", look_at=trace_eq)\n",
        "        self.wait(2)\n",
        "\n",
        "        text = OldTexText(\"Diagonalization $\\\\rightarrow$ Easier computation\")\n",
        "        text.move_to(self.hold_up_spot, DOWN)\n",
        "        text.shift_onto_screen()\n",
        "\n",
        "        self.play(\n",
        "            trace_eq.animate.shift(UP),\n",
        "            FadeIn(text, 0.5 * UP),\n",
        "            self.change_students(\"erm\", \"tease\", \"maybe\"),\n",
        "        )\n",
        "        for pi in self.pi_creatures:  # Why?\n",
        "            pi.eyes[0].refresh_bounding_box()\n",
        "            pi.eyes[1].refresh_bounding_box()\n",
        "        self.look_at(text)\n",
        "        self.wait(3)\n",
        "\n",
        "        topics = VGroup(trace_eq, text)\n",
        "\n",
        "        exp_deriv = OldTex(\"e\", \"{d \\\\over dx}\")\n",
        "        exp_deriv[0].scale(2)\n",
        "        exp_deriv[1].move_to(exp_deriv[0].get_corner(UR), DL)\n",
        "        exp_deriv.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(exp_deriv, scale=2),\n",
        "            topics.animate.scale(0.5).to_corner(UL),\n",
        "            self.teacher.change(\"tease\", exp_deriv),\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"sassy\", \"angry\")\n",
        "        self.wait(6)\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass\n",
        "\n",
        "\n",
        "# GENERIC flow scenes\n",
        "\n",
        "\n",
        "class ExponentialPhaseFlow(Scene):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"color_by_magnitude\": False,\n",
        "            \"magnitude_range\": (0.5, 5),\n",
        "            \"arc_len\": 5,\n",
        "        },\n",
        "        \"plane_config\": {\n",
        "            \"x_range\": [-4, 4],\n",
        "            \"y_range\": [-2, 2],\n",
        "            \"height\": 8,\n",
        "            \"width\": 16,\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [1, 0],\n",
        "            [0, 1],\n",
        "        ],\n",
        "        \"label_height\": 3,\n",
        "        \"run_time\": 30,\n",
        "        \"slow_factor\": 0.25,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        mr = np.array(self.field_config[\"magnitude_range\"])\n",
        "        self.field_config[\"magnitude_range\"] = self.slow_factor * mr\n",
        "        plane = NumberPlane(**self.plane_config)\n",
        "        plane.add_coordinate_labels()\n",
        "\n",
        "        vector_field, animated_lines = get_vector_field_and_stream_lines(\n",
        "            self.func, plane,\n",
        "            **self.field_config,\n",
        "        )\n",
        "\n",
        "        box = Square()\n",
        "        box.replace(Line(plane.c2p(-1, -1), plane.c2p(1, 1)), stretch=True)\n",
        "        box.set_stroke(GREY_A, 1)\n",
        "        box.set_fill(BLUE_E, 0.8)\n",
        "        move_points_along_vector_field(box, self.func, plane)\n",
        "\n",
        "        basis_vectors = VGroup(\n",
        "            Vector(RIGHT, fill_color=GREEN),\n",
        "            Vector(UP, fill_color=RED),\n",
        "        )\n",
        "        basis_vectors[0].add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(),\n",
        "            box.pfp(7 / 8)\n",
        "        ))\n",
        "        basis_vectors[1].add_updater(lambda m: m.put_start_and_end_on(\n",
        "            plane.get_origin(),\n",
        "            box.pfp(1 / 8)\n",
        "        ))\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(vector_field)\n",
        "        self.add(animated_lines)\n",
        "        self.add(box)\n",
        "        self.add(*basis_vectors)\n",
        "        self.wait(self.run_time)\n",
        "\n",
        "    def func(self, x, y):\n",
        "        return self.slow_factor * np.dot([x, y], np.transpose(self.matrix))\n",
        "\n",
        "    def get_label(self):\n",
        "        exponential = get_matrix_exponential(self.matrix)\n",
        "        changing_t = DecimalNumber(0, color=YELLOW)\n",
        "        changing_t.match_height(exponential[2])\n",
        "        changing_t.move_to(exponential[2], DL)\n",
        "        exponential.replace_submobject(2, changing_t)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        rhs = DecimalMatrix(\n",
        "            np.zeros((2, 2)),\n",
        "            element_to_mobject_config={\"num_decimal_places\": 3},\n",
        "            h_buff=1.8,\n",
        "        )\n",
        "        rhs.match_height(exponential)\n",
        "\n",
        "        equation = VGroup(\n",
        "            exponential,\n",
        "            equals,\n",
        "            rhs,\n",
        "        )\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.to_corner(UL)\n",
        "\n",
        "\n",
        "class ExponentialEvaluationWithTime(Scene):\n",
        "    flow_scene_class = ExponentialPhaseFlow\n",
        "\n",
        "    def construct(self):\n",
        "        flow_scene_attrs = merge_dicts_recursively(\n",
        "            ExponentialPhaseFlow.CONFIG,\n",
        "            self.flow_scene_class.CONFIG,\n",
        "        )\n",
        "        matrix = np.array(flow_scene_attrs[\"matrix\"])\n",
        "        slow_factor = flow_scene_attrs[\"slow_factor\"]\n",
        "\n",
        "        def get_t():\n",
        "            return slow_factor * self.time\n",
        "\n",
        "        exponential = get_matrix_exponential(matrix)\n",
        "        dot = OldTex(\"\\\\cdot\")\n",
        "        dot.move_to(exponential[2], LEFT)\n",
        "        changing_t = DecimalNumber(0)\n",
        "        changing_t.match_height(exponential[2])\n",
        "        changing_t.next_to(dot, RIGHT, SMALL_BUFF)\n",
        "        changing_t.align_to(exponential[1], DOWN)\n",
        "        changing_t.add_updater(lambda m: m.set_value(get_t()).set_color(YELLOW))\n",
        "        lhs = VGroup(*exponential[:2], dot, changing_t)\n",
        "\n",
        "        equals = OldTex(\"=\")\n",
        "        rhs = DecimalMatrix(\n",
        "            np.zeros((2, 2)),\n",
        "            element_to_mobject_config={\"num_decimal_places\": 2},\n",
        "            element_alignment_corner=ORIGIN,\n",
        "            h_buff=2.0,\n",
        "        )\n",
        "        for mob in rhs.get_entries():\n",
        "            mob.edge_to_fix = ORIGIN\n",
        "\n",
        "        rhs.match_height(lhs)\n",
        "\n",
        "        def update_rhs(rhs):\n",
        "            result = mat_exp(matrix * get_t())\n",
        "            for mob, value in zip(rhs.get_entries(), result.flatten()):\n",
        "                mob.set_value(value)\n",
        "            return rhs\n",
        "\n",
        "        rhs.add_updater(update_rhs)\n",
        "\n",
        "        equation = VGroup(lhs, equals, rhs)\n",
        "        equation.arrange(RIGHT)\n",
        "        equation.center()\n",
        "\n",
        "        self.add(equation)\n",
        "        self.wait(flow_scene_attrs[\"run_time\"])\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class CircularPhaseFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"magnitude_range\": (0.5, 8),\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [0, -1],\n",
        "            [1, 0],\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class CircularFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = CircularPhaseFlow\n",
        "\n",
        "\n",
        "class EllipticalPhaseFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"magnitude_range\": (0.5, 8),\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [0.5, -3],\n",
        "            [1, -0.5],\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class EllipticalFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = EllipticalPhaseFlow\n",
        "\n",
        "\n",
        "class HyperbolicPhaseFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"sample_freq\": 8,\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [1, 0],\n",
        "            [0, -1],\n",
        "        ]\n",
        "    }\n",
        "\n",
        "\n",
        "class HyperbolicFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = HyperbolicPhaseFlow\n",
        "\n",
        "\n",
        "class ShearPhaseFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"sample_freq\": 2,\n",
        "            \"magnitude_range\": (0.5, 8),\n",
        "        },\n",
        "        \"plane_config\": {\n",
        "            \"x_range\": [-8, 8],\n",
        "            \"y_range\": [-4, 4],\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [1, 1],\n",
        "            [0, 1],\n",
        "        ],\n",
        "        \"slow_factor\": 0.1,\n",
        "    }\n",
        "\n",
        "\n",
        "class ShearFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = ShearPhaseFlow\n",
        "\n",
        "\n",
        "class HyperbolicTrigFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"field_config\": {\n",
        "            \"sample_freq\": 2,\n",
        "            \"magnitude_range\": (0.5, 7),\n",
        "        },\n",
        "        \"plane_config\": {\n",
        "            \"x_range\": [-8, 8],\n",
        "            \"y_range\": [-4, 4],\n",
        "        },\n",
        "        \"matrix\": [\n",
        "            [0, 1],\n",
        "            [1, 0],\n",
        "        ],\n",
        "        \"slow_factor\": 0.1,\n",
        "    }\n",
        "\n",
        "\n",
        "class HyperbolicTrigFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = HyperbolicTrigFlow\n",
        "\n",
        "\n",
        "class DampedRotationPhaseFlow(ExponentialPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"matrix\": [\n",
        "            [-1, -1],\n",
        "            [1, 0],\n",
        "        ],\n",
        "    }\n",
        "\n",
        "\n",
        "class DampedRotationFlowEvaluation(ExponentialEvaluationWithTime):\n",
        "    flow_scene_class = DampedRotationPhaseFlow\n",
        "\n",
        "\n",
        "class FrameForFlow(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle(fill_color=GREY_D))\n",
        "        screen_rect = ScreenRectangle()\n",
        "        screen_rect.set_height(5.5)\n",
        "        screen_rect.set_stroke(WHITE, 3)\n",
        "        screen_rect.set_fill(BLACK, 1)\n",
        "        screen_rect.to_edge(DOWN)\n",
        "        self.add(screen_rect)\n",
        "\n",
        "\n",
        "class ThumbnailBackdrop(DampedRotationPhaseFlow):\n",
        "    CONFIG = {\n",
        "        \"run_time\": 10,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "\n",
        "        for mob in self.mobjects:\n",
        "            if isinstance(mob, Square) or isinstance(mob, Arrow):\n",
        "                self.remove(mob)\n",
        "            if isinstance(mob, NumberPlane):\n",
        "                self.remove(mob.coordinate_labels)\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        im = ImageMobject(\"ExpMatThumbnailBackdrop\")\n",
        "        im.set_height(FRAME_HEIGHT)\n",
        "        im.set_opacity(0.7)\n",
        "        self.add(im)\n",
        "\n",
        "        # rect = FullScreenFadeRectangle()\n",
        "        # rect.set_fill(opacity=0.3)\n",
        "        # self.add(rect)\n",
        "\n",
        "        exp = get_matrix_exponential([[-1, -1], [1, 0]], scalar_tex=\"\")\n",
        "        exp.set_height(5)\n",
        "        exp.set_stroke(BLACK, 50, opacity=0.5, background=True)\n",
        "\n",
        "        fuzz = VGroup()\n",
        "        N = 100\n",
        "        for w in np.linspace(150, 0, N):\n",
        "            ec = exp.copy()\n",
        "            ec.set_stroke(BLUE_E, width=w, opacity=(1 / N))\n",
        "            ec.set_fill(opacity=0)\n",
        "            fuzz.add(ec)\n",
        "\n",
        "        self.add(fuzz, exp)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "# Older\n",
        "\n",
        "class LetsSumUp(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Let's review\",\n",
        "            added_anims=[self.change_students(\"thinking\", \"pondering\", \"thinking\")]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class PrerequisitesWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        title = Text(\"Helpful background knowledge\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        screens = VGroup(*(ScreenRectangle() for x in range(2)))\n",
        "        screens.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.move_to(DOWN)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.set_stroke(WHITE, 2)\n",
        "\n",
        "        topics = VGroup(\n",
        "            OldTexText(\"Basics of $e^x$\"),\n",
        "            OldTexText(\"How matrices act\\\\\\\\as transformations\"),\n",
        "        )\n",
        "        for topic, screen in zip(topics, screens):\n",
        "            topic.next_to(screen, UP)\n",
        "            topic.set_color(WHITE)\n",
        "\n",
        "        for topic, screen in zip(topics, screens):\n",
        "            sc = screen.copy()\n",
        "            sc.set_fill(opacity=0)\n",
        "            sc.set_stroke(width=3)\n",
        "            self.play(\n",
        "                FadeIn(topic, 0.5 * UP),\n",
        "                FadeIn(screen),\n",
        "                VShowPassingFlash(sc, time_width=1.0, run_time=1.5),\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class SchroedingersComplicatingFactors(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class OldComputationCode(Scene):\n",
        "    def construct(self):\n",
        "        # Taylor series example\n",
        "        ex_rhs = OldTex(\n",
        "            \"\"\"\n",
        "            {2}^0 +\n",
        "            {2}^1 +\n",
        "            { {2}^2 \\\\over 2} +\n",
        "            { {2}^3 \\\\over 6} +\n",
        "            { {2}^4 \\\\over 24} +\n",
        "            { {2}^5 \\\\over 120} +\n",
        "            { {2}^6 \\\\over 720} +\n",
        "            { {2}^7 \\\\over 5040} +\n",
        "            \\\\cdots\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\"{2}\": YELLOW, \"+\": WHITE},\n",
        "        )\n",
        "        ex_rhs.next_to(real_equation[3:], DOWN, buff=0.75)\n",
        "\n",
        "        ex_parts = VGroup(*(\n",
        "            ex_rhs[i:j] for i, j in [\n",
        "                (0, 2),\n",
        "                (3, 5),\n",
        "                (6, 8),\n",
        "                (9, 11),\n",
        "                (12, 14),\n",
        "                (15, 17),\n",
        "                (18, 20),\n",
        "                (21, 23),\n",
        "                (24, 25),\n",
        "            ]\n",
        "        ))\n",
        "        term_brace = Brace(ex_parts[0], DOWN)\n",
        "        frac = OldTex(\"1\", font_size=36)\n",
        "        frac.next_to(term_brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        rects = VGroup(*(\n",
        "            Rectangle(height=2**n / math.factorial(n), width=1)\n",
        "            for n in range(11)\n",
        "        ))\n",
        "        rects.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "        rects.set_fill(opacity=1)\n",
        "        rects.set_submobject_colors_by_gradient(BLUE, GREEN)\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        rects.set_width(7)\n",
        "        rects.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(taylor_brace, term_brace),\n",
        "            FadeTransform(real_equation[3:].copy(), ex_rhs),\n",
        "            FadeOut(false_group, shift=DOWN),\n",
        "            FadeOut(taylor_label, shift=DOWN),\n",
        "            FadeIn(frac),\n",
        "        )\n",
        "        term_values = VGroup()\n",
        "        for n in range(11):\n",
        "            rect = rects[n]\n",
        "            fact = math.factorial(n)\n",
        "            ex_part = ex_parts[min(n, len(ex_parts) - 1)]\n",
        "            value = DecimalNumber(2**n / fact)\n",
        "            value.set_color(GREY_A)\n",
        "            max_width = 0.6 * rect.get_width()\n",
        "            if value.get_width() > max_width:\n",
        "                value.set_width(max_width)\n",
        "            value.next_to(rects[n], UP, SMALL_BUFF)\n",
        "            new_brace = Brace(ex_part, DOWN)\n",
        "            if fact == 1:\n",
        "                new_frac = OldTex(f\"{2**n}\", font_size=36)\n",
        "            else:\n",
        "                new_frac = OldTex(f\"{2**n} / {fact}\", font_size=36)\n",
        "            new_frac.next_to(new_brace, DOWN, SMALL_BUFF)\n",
        "            self.play(\n",
        "                term_brace.animate.become(new_brace),\n",
        "                FadeTransform(frac, new_frac),\n",
        "            )\n",
        "            frac = new_frac\n",
        "            rect.save_state()\n",
        "            rect.stretch(0, 1, about_edge=DOWN)\n",
        "            rect.set_opacity(0)\n",
        "            value.set_value(0)\n",
        "            self.play(\n",
        "                Restore(rect),\n",
        "                ChangeDecimalToValue(value, 2**n / math.factorial(n)),\n",
        "                UpdateFromAlphaFunc(value, lambda m, a: m.next_to(rect, UP, SMALL_BUFF).set_opacity(a)),\n",
        "                randy.animate.look_at(rect),\n",
        "                morty.animate.look_at(rect),\n",
        "            )\n",
        "            term_values.add(value)\n",
        "        self.play(FadeOut(frac))\n",
        "\n",
        "        new_brace = Brace(ex_rhs, DOWN)\n",
        "        sum_value = DecimalNumber(math.exp(2), num_decimal_places=4, font_size=36)\n",
        "        sum_value.next_to(new_brace, DOWN)\n",
        "        self.play(\n",
        "            term_brace.animate.become(new_brace),\n",
        "            randy.change(\"thinking\", sum_value),\n",
        "            morty.change(\"tease\", sum_value),\n",
        "            *(FadeTransform(dec.copy().set_opacity(0), sum_value) for dec in term_values)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        lhs = OldTex(\"e \\\\cdot e =\")\n",
        "        lhs.match_height(real_equation[0])\n",
        "        lhs.next_to(ex_rhs, LEFT)\n",
        "        self.play(Write(lhs))\n",
        "        self.play(Blink(morty))\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "        # Increment input\n",
        "        twos = ex_rhs.get_parts_by_tex(\"{2}\")\n",
        "        threes = VGroup(*(\n",
        "            OldTex(\"3\").set_color(YELLOW).replace(two)\n",
        "            for two in twos\n",
        "        ))\n",
        "        new_lhs = OldTex(\"e \\\\cdot e \\\\cdot e = \")\n",
        "        new_lhs.match_height(lhs)\n",
        "        new_lhs[0].space_out_submobjects(0.8)\n",
        "        new_lhs[0][-1].shift(SMALL_BUFF * RIGHT)\n",
        "        new_lhs.move_to(lhs, RIGHT)\n",
        "\n",
        "        anims = []\n",
        "        unit_height = 0.7 * rects[0].get_height()\n",
        "        for n, rect, value_mob in zip(it.count(0), rects, term_values):\n",
        "            rect.generate_target()\n",
        "            new_value = 3**n / math.factorial(n)\n",
        "            rect.target.set_height(unit_height * new_value, stretch=True, about_edge=DOWN)\n",
        "            value_mob.rect = rect\n",
        "            anims += [\n",
        "                MoveToTarget(rect),\n",
        "                ChangeDecimalToValue(value_mob, new_value),\n",
        "                UpdateFromFunc(value_mob, lambda m: m.next_to(m.rect, UP, SMALL_BUFF))\n",
        "            ]\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(twos, 0.5 * UP),\n",
        "            FadeIn(threes, 0.5 * UP),\n",
        "        )\n",
        "        twos.set_opacity(0)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(sum_value, math.exp(3)),\n",
        "            *anims,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(lhs, 0.5 * UP),\n",
        "            FadeIn(new_lhs, 0.5 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PreviewVisualizationWrapper(Scene):\n",
        "    def construct(self):\n",
        "        background = FullScreenFadeRectangle(fill_color=GREY_E, fill_opacity=1)\n",
        "        self.add(background)\n",
        "\n",
        "        screen = ScreenRectangle(height=6)\n",
        "        screen.set_fill(BLACK, 1)\n",
        "        screen.set_stroke(GREY_A, 3)\n",
        "        screen.to_edge(DOWN)\n",
        "        self.add(screen)\n",
        "\n",
        "        titles = VGroup(\n",
        "            Text(\"How to think about matrix exponentiation\"),\n",
        "            Text(\n",
        "                \"How to visualize matrix exponentiation\",\n",
        "                t2s={\"visualize\": ITALIC},\n",
        "            ),\n",
        "            Text(\"What problems matrix exponentiation solves?\"),\n",
        "        )\n",
        "        for title in titles:\n",
        "            title.next_to(screen, UP)\n",
        "            title.get_parts_by_text(\"matrix exponentiation\").set_color(TEAL)\n",
        "\n",
        "        self.play(FadeIn(titles[0], 0.5 * UP))\n",
        "        self.wait(2)\n",
        "        self.play(*(\n",
        "            FadeTransform(\n",
        "                titles[0].get_parts_by_text(w1),\n",
        "                titles[1].get_parts_by_text(w2),\n",
        "            )\n",
        "            for w1, w2 in [\n",
        "                (\"How to\", \"How to\"),\n",
        "                (\"think about\", \"visualize\"),\n",
        "                (\"matrix exponentiation\", \"matrix exponentiation\"),\n",
        "            ]\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            *(\n",
        "                FadeTransform(\n",
        "                    titles[1].get_parts_by_text(w1),\n",
        "                    titles[2].get_parts_by_text(w2),\n",
        "                )\n",
        "                for w1, w2 in [\n",
        "                    (\"How to visualize\", \"What problems\"),\n",
        "                    (\"matrix exponentiation\", \"matrix exponentiation\"),\n",
        "                ]\n",
        "            ),\n",
        "            FadeIn(titles[2].get_parts_by_text(\"solves?\"))\n",
        "        )\n",
        "        self.wait(2)\n"
    ]
}