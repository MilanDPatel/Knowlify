{
    "topic": "demonstrates the concept of a beam splitter, which is a device used in laser",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class BeamSplitter(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add laser device\n",
        "        frame = self.frame\n",
        "        light_source = self.camera.light_source\n",
        "        light_source.move_to([-8, 5, 1])\n",
        "        pointer = self.get_laser_pointer()\n",
        "        pointer.to_edge(LEFT)\n",
        "        beam = self.get_beam(pointer.get_right(), pointer.get_right() + 1000 * RIGHT)\n",
        "        pointer.set_z_index(2)\n",
        "\n",
        "        theta_tracker = ValueTracker(90 * DEG)\n",
        "        pointer.curr_angle = 90 * DEG\n",
        "\n",
        "        def set_theta(target_angle, run_time=2):\n",
        "            curr_angle = theta_tracker.get_value()\n",
        "            return AnimationGroup(\n",
        "                theta_tracker.animate.set_value(target_angle),\n",
        "                Rotate(pointer, curr_angle - target_angle, axis=RIGHT),\n",
        "                run_time=run_time\n",
        "            )\n",
        "\n",
        "        frame.reorient(-121, 76, 0, (-3.29, -0.25, -0.34), 4.80)\n",
        "        self.add(pointer)\n",
        "        self.play(ShowCreation(beam, rate_func=lambda t: t**10))\n",
        "\n",
        "        # Set up linear vector field\n",
        "        wave = self.get_wave(theta_tracker, start_point=pointer.get_right(), max_x=200)\n",
        "\n",
        "        self.add(theta_tracker)\n",
        "        self.play(VFadeIn(wave))\n",
        "        self.play(\n",
        "            frame.animate.reorient(-57, 74, 0, (-3.29, -0.18, -0.18), 4.80),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "        # Add sample vector\n",
        "        amplitude = wave.amplitude\n",
        "        sample_point = pointer.get_right() + 3 * RIGHT\n",
        "\n",
        "        corner_plane, h_plane, v_plane, plane_in_situ = planes = VGroup(\n",
        "            NumberPlane((-1, 1), (-1, 1))\n",
        "            for _ in range(4)\n",
        "        )\n",
        "        for plane in planes:\n",
        "            plane.axes.set_stroke(WHITE, 2, 0.5)\n",
        "            plane.background_lines.set_stroke(opacity=0.5)\n",
        "            plane.faded_lines.set_stroke(opacity=0.25)\n",
        "\n",
        "        plane_in_situ.scale(amplitude)\n",
        "        plane_in_situ.rotate(90 * DEG, RIGHT).rotate(90 * DEG, IN)\n",
        "        plane_in_situ.move_to(sample_point)\n",
        "\n",
        "        fixed_planes = planes[:3]\n",
        "        fixed_planes.fix_in_frame()\n",
        "        fixed_planes.scale(1.25)\n",
        "        fixed_planes.arrange(RIGHT, buff=1.0)\n",
        "        fixed_planes.to_corner(UL)\n",
        "\n",
        "        corner_vector = Vector(RIGHT, thickness=3, fill_color=BLUE)\n",
        "        corner_vector.plane = corner_plane\n",
        "        corner_vector.wave = wave\n",
        "        corner_vector.force_unit = False\n",
        "        corner_vector.fix_in_frame()\n",
        "\n",
        "        def update_corner_vect(vect, vertical=False, horizontal=False):\n",
        "            coords = vect.wave.axes.p2c(sample_point)\n",
        "            output = vect.wave.func(np.array([coords]))[0]\n",
        "            x = np.dot(output, DOWN) / amplitude if not vertical else 0\n",
        "            y = np.dot(output, OUT) / amplitude if not horizontal else 0\n",
        "            if vect.force_unit:\n",
        "                theta = theta_tracker.get_value()\n",
        "                x /= math.cos(theta) or 1\n",
        "                y /= math.sin(theta) or 1\n",
        "            vect.put_start_and_end_on(vect.plane.c2p(0, 0), vect.plane.c2p(x, y))\n",
        "            return vect\n",
        "\n",
        "        corner_vector.add_updater(update_corner_vect)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(plane_in_situ),\n",
        "            TransformFromCopy(plane_in_situ, corner_plane, run_time=2)\n",
        "        )\n",
        "        self.play(VFadeIn(corner_vector))\n",
        "        self.play(frame.animate.reorient(-80, 79, 0, (-3.36, 0.1, -0.46), 4.80), run_time=12)\n",
        "\n",
        "        # Add beam splitter\n",
        "        split_point_dist = 6\n",
        "        split_point = pointer.get_right() + split_point_dist * RIGHT\n",
        "        splitter = Cube()\n",
        "        splitter.set_color(WHITE)\n",
        "        splitter.set_opacity(0.25)\n",
        "        splitter.rotate(45 * DEG)\n",
        "        splitter.set_height(0.5)\n",
        "        splitter.move_to(split_point)\n",
        "\n",
        "        top_axes, low_axies = split_axes = VGroup(ThreeDAxes(), ThreeDAxes())\n",
        "        split_axes.move_to(split_point)\n",
        "        for axes, sgn in zip(split_axes, [1, -1]):\n",
        "            axes.rotate(sgn * 45 * DEG)\n",
        "\n",
        "        short_wave = self.get_wave(theta_tracker, pointer.get_right(), max_x=split_point_dist, stroke_opacity=0.5)\n",
        "        short_wave.time = wave.time\n",
        "        corner_vector.wave = short_wave\n",
        "        top_wave = self.get_wave(theta_tracker, split_point, refraction_angle=45 * DEG, project_horizontal=True, stroke_opacity=0.25)\n",
        "        low_wave = self.get_wave(theta_tracker, split_point, refraction_angle=-45 * DEG, project_vertical=True, stroke_opacity=0.25)\n",
        "\n",
        "        short_beam = self.get_beam(pointer.get_right(), split_point)\n",
        "        top_beam = self.get_beam(split_point, split_point + 20 * UR / math.sqrt(2))\n",
        "        low_beam = self.get_beam(split_point, split_point + 20 * DR / math.sqrt(2))\n",
        "        top_beam.f_always.set_stroke(opacity=lambda: math.cos(theta_tracker.get_value()))\n",
        "        low_beam.f_always.set_stroke(opacity=lambda: math.sin(theta_tracker.get_value()))\n",
        "        top_beam.suspend_updating()\n",
        "        low_beam.suspend_updating()\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(splitter),\n",
        "            FadeOut(wave),\n",
        "            FadeIn(short_wave),\n",
        "            FadeIn(top_wave),\n",
        "            FadeIn(low_wave),\n",
        "            FadeOut(beam),\n",
        "            FadeIn(short_beam),\n",
        "            FadeIn(top_beam),\n",
        "            FadeIn(low_beam),\n",
        "            plane_in_situ.animate.fade(0.5),\n",
        "            frame.animate.reorient(-76, 62, 0, (-2.7, 0.08, -0.8), 6.22).set_anim_args(run_time=4)\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Show rotation of the beam\n",
        "        top_beam.resume_updating()\n",
        "        low_beam.resume_updating()\n",
        "\n",
        "        polarization_line = DashedLine(LEFT, RIGHT)\n",
        "        polarization_line.set_stroke(WHITE, 1)\n",
        "        polarization_line.fix_in_frame()\n",
        "        polarization_line.add_updater(lambda m: m.set_angle(theta_tracker.get_value()))\n",
        "        polarization_line.add_updater(lambda m: m.move_to(corner_plane))\n",
        "\n",
        "        rot_arrows = VGroup(\n",
        "            Arrow(RIGHT, LEFT, path_arc=PI),\n",
        "            Arrow(LEFT, RIGHT, path_arc=PI),\n",
        "        )\n",
        "        rot_arrows.scale(0.5)\n",
        "        rot_arrows.rotate(90 * DEG, RIGHT)\n",
        "        rot_arrows.rotate(90 * DEG, OUT)\n",
        "        rot_arrows.move_to(pointer.get_right() + 0.5 * RIGHT)\n",
        "\n",
        "        self.add(polarization_line, corner_vector)\n",
        "        self.play(Write(rot_arrows, lag_ratio=0, run_time=1))\n",
        "        self.play(set_theta(0, run_time=3))\n",
        "        self.play(FadeOut(rot_arrows))\n",
        "        self.play(frame.animate.reorient(-90, 82, 0, (-1.73, 0.07, 1.0), 8.00), run_time=6)\n",
        "\n",
        "        self.play(set_theta(60 * DEG, run_time=4))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Express sample vector as a sum\n",
        "        eq, plus = signs = VGroup(Tex(R\"=\"), Tex(R\"+\"))\n",
        "        signs.scale(1.5)\n",
        "        signs.fix_in_frame()\n",
        "        for sign, plane1, plane2 in zip(signs, fixed_planes, fixed_planes[1:]):\n",
        "            sign.move_to(midpoint(plane1.get_right(), plane2.get_left()))\n",
        "\n",
        "        coords = VGroup(DecimalNumber(0, unit=R\"\\times\"), DecimalNumber(0, unit=R\"\\times\"))  # Stopped using these, maybe later?\n",
        "        coords.fix_in_frame()\n",
        "        coords.scale(0.75)\n",
        "        for coord, plane in zip(coords, fixed_planes[1:]):\n",
        "            coord.next_to(plane, LEFT, SMALL_BUFF)\n",
        "        coords[0].add_updater(lambda m: m.set_value(math.sin(theta_tracker.get_value())))\n",
        "        coords[1].add_updater(lambda m: m.set_value(math.cos(theta_tracker.get_value())))\n",
        "\n",
        "        h_vect, soft_h_vect, v_vect, soft_v_vect = corner_vector.replicate(4).clear_updaters()\n",
        "\n",
        "        h_vect.plane = h_plane\n",
        "        v_vect.plane = v_plane\n",
        "        soft_h_vect.plane = corner_plane\n",
        "        soft_v_vect.plane = corner_plane\n",
        "\n",
        "        VGroup(soft_h_vect, soft_v_vect).set_fill(opacity=0.5)\n",
        "        h_vect.add_updater(lambda m: update_corner_vect(m, horizontal=True))\n",
        "        soft_h_vect.add_updater(lambda m: update_corner_vect(m, horizontal=True))\n",
        "        v_vect.add_updater(lambda m: update_corner_vect(m, vertical=True))\n",
        "        soft_v_vect.add_updater(lambda m: update_corner_vect(m, vertical=True))\n",
        "\n",
        "        for plane in h_plane, v_plane:\n",
        "            plane.save_state()\n",
        "            plane.move_to(corner_plane)\n",
        "            plane.set_stroke(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(h_plane),\n",
        "            VFadeIn(v_plane),\n",
        "            VFadeIn(soft_h_vect),\n",
        "            VFadeIn(soft_v_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(h_plane, path_arc=30 * DEG),\n",
        "            VFadeIn(h_vect),\n",
        "            Write(eq),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(v_plane, path_arc=30 * DEG),\n",
        "            VFadeIn(v_vect),\n",
        "            Write(plus),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Do some rotations\n",
        "        curr_angle = 60 * DEG\n",
        "        for target_angle in [90 * DEG, 0, 60 * DEG]:\n",
        "            self.play(set_theta(target_angle))\n",
        "            self.wait(3)\n",
        "\n",
        "        # Add the angle, and sine/cosine terms\n",
        "        arc = always_redraw(lambda: Arc(\n",
        "            0, theta_tracker.get_value(), radius=0.5, arc_center=corner_plane.get_center(),\n",
        "        ).fix_in_frame())\n",
        "        theta_label = Tex(R\"\\theta\")\n",
        "        theta_label.fix_in_frame()\n",
        "        theta_label_height = theta_label.get_height()\n",
        "\n",
        "        def update_theta_label(theta_label):\n",
        "            point = arc.pfp(0.25)\n",
        "            direction = rotate_vector(RIGHT, 0.5 * theta_tracker.get_value())\n",
        "            height = min(arc.get_height(), theta_label_height)\n",
        "            theta_label.set_height(height)\n",
        "            theta_label.next_to(point, direction, SMALL_BUFF)\n",
        "\n",
        "        theta_label.add_updater(update_theta_label)\n",
        "\n",
        "        movers = VGroup(h_plane, plus, v_plane)\n",
        "        for mob in movers:\n",
        "            mob.generate_target()\n",
        "\n",
        "        cos_term = Tex(R\"\\cos(\\theta) \\, \\cdot \").fix_in_frame()\n",
        "        sin_term = Tex(R\"\\sin(\\theta) \\, \\cdot \").fix_in_frame()\n",
        "        rhs = VGroup(cos_term, h_plane.target, plus.target, sin_term, v_plane.target)\n",
        "        rhs.arrange(RIGHT, buff=0.25)\n",
        "        rhs.next_to(eq, RIGHT, 0.25)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(arc),\n",
        "            Write(theta_label),\n",
        "        )\n",
        "        h_vect.force_unit = True\n",
        "        v_vect.force_unit = True\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, movers),\n",
        "            LaggedStartMap(FadeIn, VGroup(cos_term, sin_term)),\n",
        "            FadeTransform(theta_label.copy().clear_updaters(), cos_term[R\"\\theta\"][0], time_span=(0.25, 1.25)),\n",
        "            FadeTransform(theta_label.copy().clear_updaters(), sin_term[R\"\\theta\"][0], time_span=(0.5, 1.5)),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Put each part in context\n",
        "        sin_part = VGroup(sin_term, v_plane)\n",
        "        cos_part = VGroup(cos_term, h_plane)\n",
        "\n",
        "        self.play(\n",
        "            sin_part.animate.scale(0.5).rotate(5 * DEG).rotate(45 * DEGREES, UP).shift(3 * DOWN),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            cos_part.animate.scale(0.5).rotate(-5 * DEG).rotate(45 * DEGREES, DOWN).shift(3 * DOWN + 2 * LEFT),\n",
        "            rate_func=there_and_back_with_pause,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # More rotation!\n",
        "        for target_angle in [80 * DEG, 10 * DEG, 60 * DEG]:\n",
        "            self.play(set_theta(target_angle))\n",
        "            self.wait()\n",
        "\n",
        "        # Energy is proportional to amlpitude squared\n",
        "        e_expr = Tex(R\"E = k \\cdot (\\text{Amplitude})^2\", font_size=36)\n",
        "        e_expr.fix_in_frame()\n",
        "        e_expr.next_to(corner_plane, DOWN, aligned_edge=LEFT)\n",
        "        amp_brace = LineBrace(polarization_line.copy().scale(0.5, about_edge=UR), buff=SMALL_BUFF)\n",
        "        amp_brace.fix_in_frame()\n",
        "        one_label = amp_brace.get_tex(\"1\").fix_in_frame()\n",
        "        VGroup(amp_brace, one_label).set_fill(WHITE)\n",
        "\n",
        "        self.play(\n",
        "            Write(e_expr),\n",
        "            frame.animate.reorient(-77, 80, 0, (-1.83, 2.76, 0.89), 8.00),\n",
        "        )\n",
        "        self.wait(5)\n",
        "        self.play(\n",
        "            GrowFromCenter(amp_brace),\n",
        "            Write(one_label),\n",
        "            VFadeOut(soft_h_vect),\n",
        "            VFadeOut(soft_v_vect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Numbers of the 60 degree example\n",
        "        eq_60 = Tex(R\"= 60^\\circ\")\n",
        "\n",
        "        # A lot of lingering\n",
        "\n",
        "        # Add photo sensors\n",
        "\n",
        "        # Turn down power\n",
        "\n",
        "    def get_laser_pointer(self):\n",
        "        box = Prism(0.75, 0.25, 0.25)\n",
        "        box.set_color(GREY_D)\n",
        "        box.set_shading(0.5, 0.5, 0)\n",
        "\n",
        "        cone = ParametricSurface(\n",
        "            lambda u, v: np.array([\n",
        "                u,\n",
        "                u * math.cos(-TAU * v),\n",
        "                u * math.sin(TAU * v),\n",
        "            ])\n",
        "        )\n",
        "        cone.stretch(5, 0)\n",
        "        cone.set_width(0.25)\n",
        "        cone.move_to(box.get_right())\n",
        "        cone.set_color(GREY)\n",
        "\n",
        "        return Group(box, cone)\n",
        "\n",
        "    def get_beam(\n",
        "        self,\n",
        "        start,\n",
        "        end,\n",
        "        color=GREEN_SCREEN,\n",
        "        stroke_width=2,\n",
        "        opacity=1.0,\n",
        "        anti_alias_width=25,\n",
        "    ):\n",
        "        beam = Line(start, end)\n",
        "        beam.set_stroke(color, stroke_width, opacity)\n",
        "        beam.set_anti_alias_width(anti_alias_width)\n",
        "        return beam\n",
        "\n",
        "    def get_wave(\n",
        "        self,\n",
        "        theta_tracker,\n",
        "        start_point=ORIGIN,\n",
        "        max_x=20,\n",
        "        refraction_angle=0 * DEG,\n",
        "        wave_number=4.0,\n",
        "        freq=0.5,\n",
        "        amplitude=0.25,  # Maybe replace with an amplitude tracker?\n",
        "        color=BLUE,\n",
        "        stroke_opacity=0.5,\n",
        "        vector_density=0.1,\n",
        "        max_vect_len=1.0,\n",
        "        project_vertical=False,\n",
        "        project_horizontal=False,\n",
        "    ):\n",
        "        axes = ThreeDAxes()\n",
        "        axes.rotate(refraction_angle)\n",
        "        axes.move_to(start_point)\n",
        "\n",
        "        def field_func(points, time):\n",
        "            theta = theta_tracker.get_value()\n",
        "            magnitudes = amplitude * np.cos(wave_number * points[:, 0] - TAU * freq * time)\n",
        "            result = np.zeros_like(points)\n",
        "            if not project_vertical:\n",
        "                result[:, 1] = -math.cos(theta) * magnitudes\n",
        "            if not project_horizontal:\n",
        "                result[:, 2] = math.sin(theta) * magnitudes\n",
        "            return result\n",
        "\n",
        "        density = 0.1\n",
        "        sample_coords = np.arange(0, max_x, density)[:, np.newaxis] * RIGHT\n",
        "        wave = TimeVaryingVectorField(\n",
        "            field_func,\n",
        "            axes,\n",
        "            sample_coords=sample_coords,\n",
        "            max_vect_len=max_vect_len,\n",
        "            color=color,\n",
        "            stroke_opacity=stroke_opacity\n",
        "        )\n",
        "        wave.amplitude = amplitude\n",
        "        wave.axes = axes\n",
        "        return wave\n"
    ]
}