{
    "topic": "The mathematical concept being demonstrated is the counting of numbers in binary representation. The code creates a hand image",
    "code": [
        "#!/usr/bin/env python\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import itertools as it\n",
        "from copy import deepcopy\n",
        "import sys\n",
        "\n",
        "\n",
        "from animation import *\n",
        "from mobject import *\n",
        "from constants import *\n",
        "from mobject.region import  *\n",
        "from scene.scene import Scene, SceneFromVideo\n",
        "from script_wrapper import command_line_create_scene\n",
        "from functools import reduce\n",
        "\n",
        "MOVIE_PREFIX = \"counting_in_binary/\"\n",
        "\n",
        "COUNT_TO_FRAME_NUM = {\n",
        "    0 : 0,\n",
        "    1 : 53,\n",
        "    2 : 84,\n",
        "    3 : 128,\n",
        "    4 : 169,\n",
        "    5 : 208,\n",
        "    6 : 238,\n",
        "    7 : 281,\n",
        "    8 : 331,\n",
        "    9 : 365,\n",
        "    10 : 395,\n",
        "    11 : 435,\n",
        "    12 : 475,\n",
        "    13 : 518,\n",
        "    14 : 556,\n",
        "    15 : 595,\n",
        "    16 : 636,\n",
        "    17 : 676,\n",
        "    18 : 709,\n",
        "    19 : 753,\n",
        "    20 : 790,\n",
        "    21 : 835,\n",
        "    22 : 869,\n",
        "    23 : 903,\n",
        "    24 : 950,\n",
        "    25 : 988,\n",
        "    26 : 1027,\n",
        "    27 : 1065,\n",
        "    28 : 1104,\n",
        "    29 : 1145,\n",
        "    30 : 1181,\n",
        "    31 : 1224,\n",
        "    32 : 1239,\n",
        "}\n",
        "\n",
        "class Hand(ImageMobject):\n",
        "    def __init__(self, num, **kwargs):\n",
        "        Mobject2D.__init__(self, **kwargs)\n",
        "        path = os.path.join(\n",
        "            VIDEO_DIR, MOVIE_PREFIX, \"images\", \"Hand%d.png\"%num\n",
        "        )\n",
        "        invert = False\n",
        "        if self.read_in_cached_attrs(path, invert):\n",
        "            return\n",
        "        ImageMobject.__init__(self, path, invert)\n",
        "        center = self.get_center()\n",
        "        self.center()\n",
        "        self.rotate(np.pi, axis = RIGHT+UP)\n",
        "        self.sort_points(lambda p : np.log(complex(*p[:2])).imag)\n",
        "        self.rotate(np.pi, axis = RIGHT+UP)\n",
        "        self.shift(center)\n",
        "        self.cache_attrs(path, invert = False)\n",
        "\n",
        "\n",
        "class EdgeDetection(SceneFromVideo):\n",
        "    args_list = [\n",
        "        (\"CountingInBinary.m4v\", 35, 70),\n",
        "        (\"CountingInBinary.m4v\", 0, 100),\n",
        "        (\"CountingInBinary.m4v\", 10, 50),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(filename, t1, t2):\n",
        "        return \"-\".join([filename.split(\".\")[0], str(t1), str(t2)])\n",
        "\n",
        "    def construct(self, filename, t1, t2):\n",
        "        path = os.path.join(VIDEO_DIR, filename)\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        self.apply_gaussian_blur()\n",
        "        self.apply_edge_detection(t1, t2)\n",
        "\n",
        "class BufferedCounting(SceneFromVideo):\n",
        "    def construct(self):\n",
        "        path = os.path.join(VIDEO_DIR, \"CountingInBinary.m4v\")\n",
        "        time_range = (3, 42)\n",
        "        SceneFromVideo.construct(self, path, time_range = time_range)\n",
        "        self.buffer_pixels(spreads = (3, 2))\n",
        "        # self.make_all_black_or_white()\n",
        "\n",
        "    def buffer_pixels(self, spreads = (2, 2)):\n",
        "        ksize = (5, 5)\n",
        "        sigmaX = 10\n",
        "        threshold1 = 35\n",
        "        threshold2 = 70\n",
        "\n",
        "        matrices = [\n",
        "            thick_diagonal(dim, spread)\n",
        "            for dim, spread in zip(self.shape, spreads)\n",
        "        ]\n",
        "        for frame, index in zip(self.frames, it.count()):\n",
        "            print(index + \"of\" + len(self.frames))\n",
        "            blurred = cv2.GaussianBlur(frame, ksize, sigmaX)\n",
        "            edged = cv2.Canny(blurred, threshold1, threshold2)\n",
        "            buffed = reduce(np.dot, [matrices[0], edged, matrices[1]])\n",
        "            for i in range(3):\n",
        "                self.frames[index][:,:,i] = buffed\n",
        "\n",
        "\n",
        "    def make_all_black_or_white(self):\n",
        "        self.frames = [\n",
        "            255*(frame != 0).astype('uint8')\n",
        "            for frame in self.frames\n",
        "        ]\n",
        "\n",
        "class ClearLeftSide(SceneFromVideo):\n",
        "    args_list = [\n",
        "        (\"BufferedCounting\",),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(scenename):\n",
        "        return scenename\n",
        "\n",
        "    def construct(self, scenename):\n",
        "        path = os.path.join(VIDEO_DIR, MOVIE_PREFIX, scenename + \".mp4\")\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        self.set_color_region_over_time_range(\n",
        "            Region(lambda x, y : x < -1, shape = self.shape)\n",
        "        )\n",
        "\n",
        "\n",
        "\n",
        "class DraggedPixels(SceneFromVideo):\n",
        "    args_list = [\n",
        "        (\"BufferedCounting\",),\n",
        "        (\"CountingWithLeftClear\",),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(*args):\n",
        "        return args[0]\n",
        "\n",
        "    def construct(self, video):\n",
        "        path = os.path.join(VIDEO_DIR, MOVIE_PREFIX, video+\".mp4\")\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        self.drag_pixels()\n",
        "\n",
        "    def drag_pixels(self, num_frames_to_drag_over = 5):\n",
        "        for index in range(len(self.frames)-1, 0, -1):\n",
        "            self.frames[index] = np.max([\n",
        "                self.frames[k]\n",
        "                for k in range(\n",
        "                    max(index-num_frames_to_drag_over, 0),\n",
        "                    index\n",
        "                )\n",
        "            ], axis = 0)\n",
        "\n",
        "\n",
        "class SaveEachNumber(SceneFromVideo):\n",
        "    def construct(self):\n",
        "        path = os.path.join(VIDEO_DIR, MOVIE_PREFIX, \"ClearLeftSideBufferedCounting.mp4\")\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        for count in COUNT_TO_FRAME_NUM:\n",
        "            path = os.path.join(\n",
        "                VIDEO_DIR, MOVIE_PREFIX, \"images\",\n",
        "                \"Hand%d.png\"%count\n",
        "            )\n",
        "            Image.fromarray(self.frames[COUNT_TO_FRAME_NUM[count]]).save(path)\n",
        "\n",
        "class ShowCounting(SceneFromVideo):\n",
        "    args_list = [\n",
        "        (\"CountingWithLeftClear\",),\n",
        "        (\"ClearLeftSideBufferedCounting\",),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(filename):\n",
        "        return filename\n",
        "\n",
        "    def construct(self, filename):\n",
        "        path = os.path.join(VIDEO_DIR, MOVIE_PREFIX, filename + \".mp4\")\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        total_time = len(self.frames)*self.frame_duration\n",
        "        for count in range(32):\n",
        "            print(count)\n",
        "            mob = OldTex(str(count)).scale(1.5)\n",
        "            mob.shift(0.3*LEFT).to_edge(UP, buff = 0.1)\n",
        "            index_range = list(range(\n",
        "                max(COUNT_TO_FRAME_NUM[count]-10, 0),\n",
        "                COUNT_TO_FRAME_NUM[count+1]-10))\n",
        "            for index in index_range:\n",
        "                self.frames[index] = disp.paint_mobject(\n",
        "                    mob, self.frames[index]\n",
        "                )\n",
        "\n",
        "class ShowFrameNum(SceneFromVideo):\n",
        "    args_list = [\n",
        "        (\"ClearLeftSideBufferedCounting\",),\n",
        "    ]\n",
        "    @staticmethod\n",
        "    def args_to_string(filename):\n",
        "        return filename\n",
        "\n",
        "    def construct(self, filename):\n",
        "        path = os.path.join(VIDEO_DIR, MOVIE_PREFIX, filename+\".mp4\")\n",
        "        SceneFromVideo.construct(self, path)\n",
        "        for frame, count in zip(self.frames, it.count()):\n",
        "            print(count + \"of\" + len(self.frames))\n",
        "            mob = Mobject(*[\n",
        "                OldTex(char).shift(0.3*x*RIGHT)\n",
        "                for char, x, in zip(str(count), it.count())\n",
        "            ])\n",
        "            self.frames[count] = disp.paint_mobject(\n",
        "                mob.to_corner(UP+LEFT),\n",
        "                frame\n",
        "            )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    command_line_create_scene(MOVIE_PREFIX)\n"
    ]
}