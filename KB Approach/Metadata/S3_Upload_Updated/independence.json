{
    "topic": "demonstrates the concept of a quiz with multiple-choice questions. The user can select",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "from tqdm import tqdm as ProgressDisplay\n",
        "import scipy\n",
        "\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "def get_binomial_distribution(n, p):\n",
        "    return lambda k : choose(n, k)*(p**(k))*((1-p)**(n-k))\n",
        "\n",
        "def get_quiz(*questions):\n",
        "    q_mobs = VGroup(*list(map(TexText, [\n",
        "        \"%d. %s\"%(i+1, question)\n",
        "        for i, question in enumerate(questions)\n",
        "    ])))\n",
        "    q_mobs.arrange(\n",
        "        DOWN, \n",
        "        buff = MED_LARGE_BUFF,\n",
        "        aligned_edge = LEFT, \n",
        "    )\n",
        "    content = VGroup(\n",
        "        OldTexText(\"Quiz\").scale(1.5),\n",
        "        Line(q_mobs.get_left(), q_mobs.get_right()),\n",
        "        q_mobs\n",
        "    )\n",
        "    content.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "    rect = SurroundingRectangle(content, buff = MED_LARGE_BUFF)\n",
        "    rect.shift(MED_SMALL_BUFF*DOWN)\n",
        "    rect.set_color(WHITE)\n",
        "    quiz = VGroup(rect, content)\n",
        "    quiz.questions = q_mobs\n",
        "    quiz.scale(0.7)\n",
        "    return quiz\n",
        "\n",
        "\n",
        "def get_slot_group(\n",
        "    bool_list, \n",
        "    buff = MED_LARGE_BUFF, \n",
        "    include_qs = True,\n",
        "    min_bool_list_len = 3,\n",
        "    ):\n",
        "    if len(bool_list) < min_bool_list_len:\n",
        "        bool_list += [None]*(min_bool_list_len - len(bool_list))\n",
        "    n = len(bool_list)\n",
        "\n",
        "    lines = VGroup(*[\n",
        "        Line(ORIGIN, MED_LARGE_BUFF*RIGHT)\n",
        "        for x in range(n)\n",
        "    ])\n",
        "    lines.arrange(RIGHT, buff = buff)\n",
        "    if include_qs:\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\"Q%d\"%d) for d in range(1, n+1)\n",
        "        ])\n",
        "    else:\n",
        "        labels = VGroup(*[VectorizedPoint() for d in range(n)])\n",
        "    for label, line in zip(labels, lines):\n",
        "        label.scale(0.7)\n",
        "        label.next_to(line, DOWN, SMALL_BUFF)\n",
        "    slot_group = VGroup()\n",
        "    slot_group.lines = lines\n",
        "    slot_group.labels = labels\n",
        "    slot_group.content = VGroup()\n",
        "    slot_group.digest_mobject_attrs()\n",
        "    slot_group.to_edge(RIGHT)\n",
        "    slot_group.bool_list = bool_list\n",
        "\n",
        "    total_height = FRAME_Y_RADIUS\n",
        "    base = 2.3\n",
        "\n",
        "    for i, line in enumerate(lines):\n",
        "        if i >= len(bool_list) or bool_list[i] is None:\n",
        "            mob = VectorizedPoint()\n",
        "        elif bool_list[i]:\n",
        "            mob = OldTex(\"\\\\checkmark\")\n",
        "            mob.set_color(GREEN)\n",
        "            slot_group.shift(total_height*DOWN / (base**(i+1)))\n",
        "        else:\n",
        "            mob = OldTex(\"\\\\times\")\n",
        "            mob.set_color(RED)\n",
        "            slot_group.shift(total_height*UP / (base**(i+1)))\n",
        "        mob.next_to(line, UP, SMALL_BUFF)\n",
        "        slot_group.content.add(mob)\n",
        "    return slot_group\n",
        "\n",
        "def get_probability_of_slot_group(bool_list, conditioned_list = None):\n",
        "    filler_tex = \"Fi\"*max(len(bool_list), 3)\n",
        "    if conditioned_list is None:\n",
        "        result = OldTex(\"P(\", filler_tex, \")\")\n",
        "    else:\n",
        "        result = OldTex(\"P(\", filler_tex, \"|\", filler_tex, \")\")\n",
        "    fillers = result.get_parts_by_tex(filler_tex)\n",
        "    for filler, bl in zip(fillers, [bool_list, conditioned_list]):\n",
        "        slot_group = get_slot_group(\n",
        "            bl, buff = SMALL_BUFF, include_qs = False,\n",
        "        )\n",
        "        slot_group.replace(filler, dim_to_match = 0)\n",
        "        slot_group.shift(0.5*SMALL_BUFF*DOWN)\n",
        "        index = result.index_of_part(filler)\n",
        "        result.submobjects[index] = slot_group\n",
        "    return result\n",
        "\n",
        "\n",
        "#########\n",
        "\n",
        "class IndependenceOpeningQuote(OpeningQuote):\n",
        "    CONFIG = {\n",
        "        \"quote\" : [\n",
        "            \"Far better an \", \"approximate\", \n",
        "            \" answer to the \", \" right question\",\n",
        "            \", which is often vague, than an \", \"exact\",\n",
        "            \" answer to the \", \"wrong question\", \".\"\n",
        "        ],\n",
        "        \"highlighted_quote_terms\" : {\n",
        "            \"approximate\" : GREEN,\n",
        "            \"right\" : GREEN,\n",
        "            \"exact\" : RED,\n",
        "            \"wrong\" : RED,\n",
        "        },\n",
        "        \"author\" : \"John Tukey\",\n",
        "        \"quote_arg_separator\" : \"\",\n",
        "    }\n",
        "\n",
        "class DangerInProbability(Scene):\n",
        "    def construct(self):\n",
        "        warning = self.get_warning_sign()\n",
        "        probability = OldTexText(\"Probability\")\n",
        "        probability.scale(2)\n",
        "\n",
        "        self.play(Write(warning, run_time = 1))\n",
        "        self.play(\n",
        "            warning.next_to, probability, UP, LARGE_BUFF,\n",
        "            LaggedStartMap(FadeIn, probability)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_warning_sign(self):\n",
        "        triangle = RegularPolygon(n = 3, start_angle = np.pi/2)\n",
        "        triangle.set_stroke(RED, 12)\n",
        "        triangle.set_height(2)\n",
        "        bang = OldTexText(\"!\")\n",
        "        bang.set_height(0.6*triangle.get_height())\n",
        "        bang.move_to(interpolate(\n",
        "            triangle.get_bottom(),\n",
        "            triangle.get_top(),\n",
        "            0.4,\n",
        "        ))\n",
        "        triangle.add(bang)\n",
        "        return triangle\n",
        "\n",
        "class MeaningOfIndependence(SampleSpaceScene):\n",
        "    CONFIG = {\n",
        "        \"sample_space_config\" : {\n",
        "            \"height\" : 4,\n",
        "            \"width\" : 4,\n",
        "        }\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_labeled_space()\n",
        "        self.align_conditionals()\n",
        "        self.relabel()\n",
        "        self.assume_independence()\n",
        "        self.no_independence()    \n",
        "\n",
        "    def add_labeled_space(self):\n",
        "        self.add_sample_space(**self.sample_space_config)\n",
        "        self.sample_space.shift(2*LEFT)\n",
        "        self.sample_space.divide_horizontally(0.3)\n",
        "        self.sample_space[0].divide_vertically(\n",
        "            0.9, colors = [BLUE_D, GREEN_C]\n",
        "        )\n",
        "        self.sample_space[1].divide_vertically(\n",
        "            0.5, colors = [BLUE_E, GREEN_E]\n",
        "        )\n",
        "        side_braces_and_labels = self.sample_space.get_side_braces_and_labels(\n",
        "            [\"P(A)\", \"P(\\\\overline A)\"]\n",
        "        )\n",
        "        top_braces_and_labels, bottom_braces_and_labels = [\n",
        "            part.get_subdivision_braces_and_labels(\n",
        "                part.vertical_parts,\n",
        "                labels = [\"P(B | %s)\"%s, \"P(\\\\overline B | %s)\"%s],\n",
        "                direction = vect\n",
        "            )\n",
        "            for part, s, vect in zip(\n",
        "                self.sample_space.horizontal_parts, \n",
        "                [\"A\", \"\\\\overline A\"], \n",
        "                [UP, DOWN],\n",
        "            )\n",
        "        ]\n",
        "        braces_and_labels_groups = VGroup(\n",
        "            side_braces_and_labels,\n",
        "            top_braces_and_labels,\n",
        "            bottom_braces_and_labels,\n",
        "        )\n",
        "\n",
        "        self.add(self.sample_space)\n",
        "        self.play(Write(braces_and_labels_groups, run_time = 4))\n",
        "\n",
        "    def align_conditionals(self):\n",
        "        line = Line(*[\n",
        "            interpolate(\n",
        "                self.sample_space.get_corner(vect+LEFT),\n",
        "                self.sample_space.get_corner(vect+RIGHT),\n",
        "                0.7\n",
        "            )\n",
        "            for vect in (UP, DOWN)\n",
        "        ])\n",
        "        line.set_stroke(RED, 8)\n",
        "        word = OldTexText(\"Independence\")\n",
        "        word.scale(1.5)\n",
        "        word.next_to(self.sample_space, RIGHT, buff = LARGE_BUFF)\n",
        "        word.set_color(RED)\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            self.get_top_conditional_change_anims(0.7),\n",
        "            self.get_bottom_conditional_change_anims(0.7)\n",
        "        ))\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(word, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.independence_word = word\n",
        "        self.independence_line = line\n",
        "\n",
        "    def relabel(self):\n",
        "        old_labels = self.sample_space[0].vertical_parts.labels\n",
        "        ignored_braces, new_top_labels = self.sample_space[0].get_top_braces_and_labels(\n",
        "            [\"P(B)\", \"P(\\\\overline B)\"]\n",
        "        )\n",
        "        equation = OldTex(\n",
        "            \"P(B | A) = P(B)\"\n",
        "        )\n",
        "        equation.scale(1.5)\n",
        "        equation.move_to(self.independence_word)\n",
        "\n",
        "        self.play(\n",
        "            Transform(old_labels, new_top_labels),\n",
        "            FadeOut(self.sample_space[1].vertical_parts.labels),\n",
        "            FadeOut(self.sample_space[1].vertical_parts.braces),\n",
        "        )\n",
        "        self.play(\n",
        "            self.independence_word.next_to, equation, UP, MED_LARGE_BUFF,\n",
        "            Write(equation)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "\n",
        "    def assume_independence(self):\n",
        "        everything = VGroup(*self.get_top_level_mobjects())\n",
        "        morty = Mortimer()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        bubble = ThoughtBubble(direction = RIGHT)\n",
        "        bubble.pin_to(morty)\n",
        "        bubble.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(morty),\n",
        "            everything.scale, 0.5,\n",
        "            everything.move_to, bubble.get_bubble_center(),\n",
        "        )\n",
        "        self.play(\n",
        "            morty.change, \"hooray\", everything,\n",
        "            ShowCreation(bubble)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        self.morty = morty\n",
        "\n",
        "    def no_independence(self):\n",
        "        for part in self.sample_space.horizontal_parts:\n",
        "            part.vertical_parts.labels = None\n",
        "        self.play(*it.chain(\n",
        "            self.get_top_conditional_change_anims(0.9),\n",
        "            self.get_bottom_conditional_change_anims(0.5),\n",
        "            [\n",
        "                self.independence_word.fade, 0.7,\n",
        "                self.equation.fade, 0.7,\n",
        "                self.morty.change, \"confused\", self.sample_space,\n",
        "                FadeOut(self.independence_line)\n",
        "            ]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class IntroduceBinomial(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 8,\n",
        "        \"p\" : 0.7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.add_bar_chart()\n",
        "        self.add_p_slider()\n",
        "        self.write_independence_assumption()\n",
        "        self.play_with_p_value(0.2, 0.5)\n",
        "        self.cross_out_assumption()\n",
        "        self.play_with_p_value(0.8, 0.4)\n",
        "        self.shift_weight_to_tails()\n",
        "\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Binomial distribution\")\n",
        "        title.scale(1.3)\n",
        "        title.to_edge(RIGHT)\n",
        "        title.shift(2*UP)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"P(X=\", \"k\", \")=\", \n",
        "            \"{n \\\\choose k}\", \n",
        "            \"p\", \"^k\",\n",
        "            \"(1-\", \"p\", \")\", \"^{n-\", \"k}\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        formula.set_color_by_tex(\"k\", BLUE)\n",
        "        formula.set_color_by_tex(\"p\", YELLOW)\n",
        "        choose_part = formula.get_part_by_tex(\"choose\")\n",
        "        choose_part.set_color(WHITE)\n",
        "        choose_part[-2].set_color(BLUE)\n",
        "        formula.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.formula = formula\n",
        "        self.title = title\n",
        "        self.add(title, formula)\n",
        "\n",
        "    def add_bar_chart(self):\n",
        "        n, p = self.n, self.p\n",
        "        dist = get_binomial_distribution(n, p)\n",
        "        chart = BarChart(\n",
        "            [dist(k) for k in range(n+1)],\n",
        "            bar_names = list(range(n+1)),\n",
        "        )\n",
        "        chart.to_edge(LEFT)\n",
        "        self.bar_chart = chart\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(*it.chain(*chart)), \n",
        "            run_time = 2\n",
        "        ))\n",
        "\n",
        "    def add_p_slider(self):\n",
        "        interval = UnitInterval(color = GREY_B)\n",
        "        interval.set_width(4)\n",
        "        interval.next_to(\n",
        "            VGroup(self.bar_chart.x_axis, self.bar_chart.y_axis), \n",
        "            UP, MED_LARGE_BUFF\n",
        "        )\n",
        "        interval.add_numbers(0, 1)\n",
        "        triangle = RegularPolygon(\n",
        "            n=3, start_angle = -np.pi/2,\n",
        "            stroke_width = 0,\n",
        "            fill_color = YELLOW,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        triangle.set_height(0.25)\n",
        "        triangle.move_to(interval.number_to_point(self.p), DOWN)\n",
        "        label = OldTex(\"p\")\n",
        "        label.next_to(triangle, UP, SMALL_BUFF)\n",
        "        label.set_color(triangle.get_color())\n",
        "\n",
        "        self.p_slider = VGroup(interval, triangle, label)\n",
        "        self.play(Write(self.p_slider, run_time = 1))\n",
        "\n",
        "    def play_with_p_value(self, *values):\n",
        "        for value in values:\n",
        "            self.change_p(value)\n",
        "            self.wait()\n",
        "\n",
        "    def write_independence_assumption(self):\n",
        "        assumption = OldTexText(\"Independence assumption\")\n",
        "        assumption.scale(1.2)\n",
        "        assumption.next_to(self.formula, DOWN, MED_LARGE_BUFF, LEFT)\n",
        "        assumption.set_color(GREEN_C)\n",
        "\n",
        "        self.play(Write(assumption, run_time = 2))\n",
        "        self.wait()\n",
        "\n",
        "        self.assumption = assumption\n",
        "\n",
        "    def cross_out_assumption(self):\n",
        "        cross = Cross(self.assumption)\n",
        "        cross.set_color(GREY)\n",
        "        self.bar_chart.save_state()\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(self.bar_chart.fade, 0.7)\n",
        "        self.wait(2)\n",
        "        self.play(self.bar_chart.restore)\n",
        "\n",
        "    def shift_weight_to_tails(self):\n",
        "        chart = self.bar_chart\n",
        "        chart_copy = chart.copy()\n",
        "        dist = get_binomial_distribution(self.n, self.p)\n",
        "        values = np.array(list(map(dist, list(range(self.n+1)))))\n",
        "        values += 0.1\n",
        "        values /= sum(values)\n",
        "\n",
        "        old_bars = chart.bars\n",
        "        old_bars.generate_target()\n",
        "        new_bars = chart_copy.bars\n",
        "        for bars, vect in (old_bars.target, LEFT), (new_bars, RIGHT):\n",
        "            for bar in bars:\n",
        "                corner = bar.get_corner(DOWN+vect)\n",
        "                bar.stretch(0.5, 0)\n",
        "                bar.move_to(corner, DOWN+vect)\n",
        "        old_bars.target.set_color(RED)\n",
        "        old_bars.target.fade()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(old_bars),\n",
        "            ReplacementTransform(\n",
        "                old_bars.copy().set_fill(opacity = 0),\n",
        "                new_bars\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            chart_copy.change_bar_values, values\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "    #####\n",
        "\n",
        "    def change_p(self, p):\n",
        "        interval, triangle, p_label = self.p_slider\n",
        "        alt_dist = get_binomial_distribution(self.n, p)\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                self.bar_chart.change_bar_values,\n",
        "                [alt_dist(k) for k in range(self.n+1)],\n",
        "            ),\n",
        "            triangle.move_to, interval.number_to_point(p), DOWN,\n",
        "            MaintainPositionRelativeTo(p_label, triangle)\n",
        "        )\n",
        "        self.p = p\n",
        "\n",
        "class IntroduceQuiz(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.add_quiz()\n",
        "        self.ask_about_probabilities()\n",
        "        self.show_distribution()\n",
        "        self.show_single_question_probability()\n",
        "\n",
        "    def add_quiz(self):\n",
        "        quiz = self.get_example_quiz()\n",
        "        quiz.next_to(self.randy, UP+RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(quiz),\n",
        "            self.randy.change, \"pondering\", quiz\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.quiz = quiz\n",
        "\n",
        "    def ask_about_probabilities(self):\n",
        "        probabilities, abbreviated_probabilities = [\n",
        "            VGroup(*[\n",
        "                OldTex(\n",
        "                    \"P(\", s_tex, \"=\", str(score), \")\", rhs\n",
        "                ).set_color_by_tex_to_color_map({\n",
        "                    str(score) : YELLOW,\n",
        "                    \"text\" : GREEN,\n",
        "                })\n",
        "                for score in range(4)\n",
        "            ])\n",
        "            for s_tex, rhs in [\n",
        "                (\"\\\\text{Score}\", \"= \\\\, ???\"),\n",
        "                (\"\\\\text{S}\", \"\")\n",
        "            ]\n",
        "        ]\n",
        "        for group in probabilities, abbreviated_probabilities:\n",
        "            group.arrange(\n",
        "                DOWN, \n",
        "                buff = MED_LARGE_BUFF,\n",
        "                aligned_edge = LEFT\n",
        "            )\n",
        "            group.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, probabilities, run_time = 3),\n",
        "            self.quiz.set_height, 0.7*self.randy.get_height(),\n",
        "            self.quiz.next_to, self.randy, RIGHT,\n",
        "            self.randy.change, \"confused\", probabilities\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.probabilities = probabilities\n",
        "        self.abbreviated_probabilities = abbreviated_probabilities\n",
        "\n",
        "    def show_distribution(self):\n",
        "        dist = get_binomial_distribution(3, 0.7)\n",
        "        values = list(map(dist, list(range(4))))\n",
        "        chart = BarChart(\n",
        "            values, \n",
        "            width = 7,\n",
        "            bar_names = list(range(4))\n",
        "        )\n",
        "        chart.to_edge(RIGHT)\n",
        "        for short_p, bar in zip(self.abbreviated_probabilities, chart.bars):\n",
        "            short_p.set_width(1.75*bar.get_width())\n",
        "            short_p.next_to(bar, UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, VGroup(\n",
        "                *[m for m in chart if m is not chart.bars]\n",
        "            )),\n",
        "        )\n",
        "        self.play(*[\n",
        "            ReplacementTransform(\n",
        "                bar.copy().stretch_to_fit_height(0).move_to(bar.get_bottom()),\n",
        "                bar\n",
        "            )\n",
        "            for bar in chart.bars\n",
        "        ])\n",
        "        self.play(*[\n",
        "            ReplacementTransform(p.copy(), short_p)\n",
        "            for p, short_p in zip(\n",
        "                self.probabilities,\n",
        "                self.abbreviated_probabilities,\n",
        "            )\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.bar_chart = chart\n",
        "\n",
        "    def show_single_question_probability(self):\n",
        "        prob = OldTex(\n",
        "            \"P(\", \"\\\\text{Can answer a given question}\", \")\",\n",
        "            \"= 0.8\"\n",
        "        )\n",
        "        prob.to_corner(UP+RIGHT)\n",
        "        prob.set_color_by_tex(\"text\", GREEN)\n",
        "        rect = SurroundingRectangle(prob, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(prob),\n",
        "            self.randy.change, \"happy\", prob\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "        self.single_question_probability = VGroup(\n",
        "            prob, rect\n",
        "        )\n",
        "\n",
        "\n",
        "    ######\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        randy = Randolph()\n",
        "        randy.scale(0.7)\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        self.randy = randy\n",
        "        return randy\n",
        "\n",
        "    def get_example_quiz(self):\n",
        "        return get_quiz(\n",
        "            \"Define ``Brachistochrone'' \",\n",
        "            \"Define ``Tautochrone'' \",\n",
        "            \"Define ``Cycloid'' \",\n",
        "        )\n",
        "\n",
        "class BreakDownQuestionPatterns(IntroduceQuiz):\n",
        "    def construct(self):\n",
        "        self.add_parts_from_last_scene()\n",
        "        self.break_down_possibilities()\n",
        "        self.count_patterns()\n",
        "\n",
        "    def add_parts_from_last_scene(self):\n",
        "        self.force_skipping()\n",
        "        IntroduceQuiz.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        chart_group = VGroup(\n",
        "            self.bar_chart,\n",
        "            self.abbreviated_probabilities\n",
        "        )\n",
        "        self.play(\n",
        "            self.single_question_probability.scale, 0.8,\n",
        "            self.single_question_probability.to_corner, UP+LEFT,\n",
        "            chart_group.scale, 0.7, chart_group.get_top(),\n",
        "            chart_group.to_edge, LEFT,\n",
        "            FadeOut(self.probabilities)\n",
        "        )\n",
        "\n",
        "    def break_down_possibilities(self):\n",
        "        slot_group_groups = VGroup(*[VGroup() for x in range(4)])\n",
        "        bool_lists = [[]]\n",
        "        while bool_lists:\n",
        "            bool_list = bool_lists.pop()\n",
        "            slot_group = self.get_slot_group(bool_list)\n",
        "            slot_group_groups[len(bool_list)].add(slot_group)\n",
        "            if len(bool_list) < 3:\n",
        "                bool_lists += [\n",
        "                    list(bool_list) + [True],\n",
        "                    list(bool_list) + [False],\n",
        "                ]\n",
        "\n",
        "        group_group = slot_group_groups[0]\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(Write(group_group, run_time = 1))\n",
        "        self.wait()\n",
        "        for new_group_group in slot_group_groups[1:]:\n",
        "            self.play(Transform(group_group, new_group_group))\n",
        "            self.wait(2)\n",
        "\n",
        "        self.slot_groups = slot_group_groups[-1]\n",
        "\n",
        "    def count_patterns(self):\n",
        "        brace = Brace(self.slot_groups, LEFT)\n",
        "        count = OldTex(\"2^3 = 8\")\n",
        "        count.next_to(brace, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(count)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #######\n",
        "\n",
        "    def get_slot_group(self, bool_list):\n",
        "        return get_slot_group(bool_list, include_qs = len(bool_list) < 3)\n",
        "\n",
        "class AssociatePatternsWithScores(BreakDownQuestionPatterns):\n",
        "    CONFIG = {\n",
        "        \"score_group_scale_val\" : 0.8,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_slot_groups()\n",
        "        self.show_score_groups()\n",
        "        self.think_about_binomial_patterns()\n",
        "\n",
        "    def add_slot_groups(self):\n",
        "        self.slot_groups = VGroup(*list(map(\n",
        "            self.get_slot_group,\n",
        "            it.product(*[[True, False]]*3)\n",
        "        )))\n",
        "        self.add(self.slot_groups)\n",
        "        self.remove(self.randy)\n",
        "\n",
        "    def show_score_groups(self):\n",
        "        score_groups = [VGroup() for x in range(4)]\n",
        "        scores = VGroup()\n",
        "        full_score_groups = VGroup()\n",
        "\n",
        "        for slot_group in self.slot_groups:\n",
        "            score_groups[sum(slot_group.bool_list)].add(slot_group)\n",
        "        for i, score_group in enumerate(score_groups):\n",
        "            score = OldTexText(\"Score\", \"=\", str(i))\n",
        "            score.set_color_by_tex(\"Score\", GREEN)\n",
        "            scores.add(score)\n",
        "            score_group.organized = score_group.deepcopy()\n",
        "            score_group.organized.arrange(UP, buff = SMALL_BUFF)\n",
        "            score_group.organized.scale(self.score_group_scale_val)\n",
        "            brace = Brace(score_group.organized, LEFT)\n",
        "            score.next_to(brace, LEFT)\n",
        "            score.add(brace)\n",
        "            full_score_groups.add(VGroup(score, score_group.organized))\n",
        "        full_score_groups.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = RIGHT\n",
        "        )\n",
        "        full_score_groups.to_edge(LEFT)\n",
        "\n",
        "        for score, score_group in zip(scores, score_groups):\n",
        "            score_group.save_state()\n",
        "            self.play(score_group.next_to, score_group, LEFT, MED_LARGE_BUFF)\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    score_group.copy(), score_group.organized\n",
        "                ),\n",
        "                LaggedStartMap(FadeIn, score, run_time = 1)\n",
        "            )\n",
        "            self.play(score_group.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def think_about_binomial_patterns(self):\n",
        "        triangle = PascalsTriangle(\n",
        "            nrows = 5,\n",
        "            height = 3,\n",
        "            width = 3,\n",
        "        )\n",
        "        triangle.to_edge(UP+RIGHT)\n",
        "        row = VGroup(*[\n",
        "            triangle.coords_to_mobs[3][k]\n",
        "            for k in range(4)\n",
        "        ])\n",
        "        self.randy.center().to_edge(DOWN)\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.add_content(triangle)\n",
        "        bubble.resize_to_content()\n",
        "        triangle.shift(SMALL_BUFF*(3*UP + RIGHT))\n",
        "        bubble.add(triangle)\n",
        "        bubble.next_to(self.randy, UP+RIGHT, SMALL_BUFF)\n",
        "        bubble.remove(triangle)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.slot_groups),\n",
        "            FadeIn(self.randy),\n",
        "            FadeIn(bubble)\n",
        "        )\n",
        "        self.play(\n",
        "            self.randy.change, \"pondering\",\n",
        "            LaggedStartMap(FadeIn, triangle, run_time = 4),\n",
        "        )\n",
        "        self.play(row.set_color, YELLOW)\n",
        "        self.wait(4)\n",
        "\n",
        "class BeforeCounting(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        triangle = PascalsTriangle(nrows = 7)\n",
        "        triangle.set_height(4)\n",
        "        triangle.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        prob = get_probability_of_slot_group([True, True, False])\n",
        "        prob.to_edge(UP)\n",
        "        brace = Brace(prob, DOWN)\n",
        "        q_marks = brace.get_text(\"???\")\n",
        "\n",
        "        self.teacher.change_mode(\"raise_right_hand\")\n",
        "        self.add(triangle)\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.play(\n",
        "            triangle.scale, 0.5,\n",
        "            triangle.to_corner, UP+RIGHT,\n",
        "            self.teacher.change_mode, \"sassy\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.play(Write(prob))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            LaggedStartMap(FadeIn, q_marks)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "class TemptingButWrongCalculation(BreakDownQuestionPatterns):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.write_simple_product()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Tempting$\\\\dots$\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def write_simple_product(self):\n",
        "        lhs = OldTex(\"P\\\\big(\", \"Filler Blah\", \"\\\\big)\", \"= \")\n",
        "        lhs.next_to(ORIGIN, UP+LEFT)\n",
        "        p_of = lhs.get_part_by_tex(\"P\\\\big(\")\n",
        "        filler = lhs.get_part_by_tex(\"Filler\")\n",
        "        rp = lhs.get_part_by_tex(\"\\\\big)\")\n",
        "        slot_group = self.get_slot_group([True, True, False])\n",
        "        slot_group.replace(filler, dim_to_match = 0)\n",
        "        lhs.submobjects.remove(filler)\n",
        "\n",
        "        rhs = VGroup(*[\n",
        "            OldTex(\"P(\", \"\\\\checkmark\" if b else \"\\\\times\", \")\")\n",
        "            for b in slot_group.bool_list\n",
        "        ])\n",
        "        rhs.arrange(RIGHT, SMALL_BUFF)\n",
        "        rhs.next_to(lhs, RIGHT, SMALL_BUFF)\n",
        "        for part, b in zip(rhs, slot_group.bool_list):\n",
        "            part.set_color_by_tex_to_color_map({\n",
        "                \"checkmark\" : GREEN,\n",
        "                \"times\" : RED,\n",
        "            })\n",
        "            brace = Brace(part, UP)\n",
        "            if b:\n",
        "                value = OldTex(\"(0.8)\")\n",
        "            else:\n",
        "                value = OldTex(\"(0.2)\")\n",
        "            value.set_color(part[1].get_color())\n",
        "            value.next_to(brace, UP)\n",
        "            part.brace = brace\n",
        "            part.value = value\n",
        "\n",
        "        question = OldTexText(\"What about correlations?\")\n",
        "        question.next_to(rhs, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(lhs),\n",
        "            ShowCreation(slot_group.lines),\n",
        "            LaggedStartMap(FadeIn, slot_group.content, run_time = 3),\n",
        "            self.randy.change, \"pondering\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for part, mob in zip(rhs, slot_group.content):\n",
        "            self.play(*[\n",
        "                ReplacementTransform(\n",
        "                    mob.copy(), subpart,\n",
        "                    path_arc = np.pi/6\n",
        "                )\n",
        "                for subpart, mob in zip(part, [\n",
        "                    p_of, mob, rp\n",
        "                ])\n",
        "            ])\n",
        "            self.play(GrowFromCenter(part.brace))\n",
        "            self.play(FadeIn(part.value))\n",
        "            self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            self.randy.change, \"confused\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.question = question\n",
        "        self.rhs = rhs\n",
        "\n",
        "class ThousandPossibleQuizzes(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_quiz_rows\" : 25,\n",
        "        \"n_quiz_cols\" : 40,\n",
        "        \"n_movers\" : 100,\n",
        "        # \"n_quiz_rows\" : 5,\n",
        "        # \"n_quiz_cols\" : 8,\n",
        "        # \"n_movers\" : 4,\n",
        "        \"quizzes_height\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.draw_all_quizzes()\n",
        "        self.show_division_by_first_question()\n",
        "        self.ask_about_second_question()\n",
        "        self.show_uncorrelated_division_by_second()\n",
        "        self.increase_second_correct_slice()\n",
        "        self.second_division_among_first_wrong()\n",
        "        self.show_that_second_is_still_80()\n",
        "        self.emphasize_disproportionate_divide()\n",
        "        self.show_third_question_results()\n",
        "\n",
        "    def draw_all_quizzes(self):\n",
        "        quizzes = self.get_thousand_quizzes()\n",
        "        title = OldTexText(\"$1{,}000$ possible quizzes\")\n",
        "        title.scale(1.5)\n",
        "        title.next_to(quizzes, UP)\n",
        "        full_quizzes = VGroup(\n",
        "            get_quiz(\n",
        "                \"Define ``Brachistochrone''\",\n",
        "                \"Define ``Tautochrone''\",\n",
        "                \"Define ``Cycloid''\",\n",
        "            ),\n",
        "            get_quiz(\n",
        "                \"Define $\\\\dfrac{df}{dx}$\",\n",
        "                \"Define $\\\\displaystyle \\\\lim_{h \\\\to 0} f(h)$\",\n",
        "                \"Prove $\\\\dfrac{d(x^2)}{dx} = 2x$ \",\n",
        "            ),\n",
        "            get_quiz(\n",
        "                \"Find all primes $p$ \\\\\\\\ where $p+2$ is prime.\",\n",
        "                \"Find all primes $p$ \\\\\\\\ where $2^{p}-1$ is prime.\",\n",
        "                \"Solve $\\\\zeta(s) = 0$\",\n",
        "            ),\n",
        "        )\n",
        "        full_quizzes.arrange(RIGHT)\n",
        "        target_quizzes = VGroup(*quizzes[:len(full_quizzes)])\n",
        "\n",
        "        for quiz in full_quizzes:\n",
        "            self.play(FadeIn(quiz, run_time = 3, lag_ratio = 0.5))\n",
        "        self.play(\n",
        "            Transform(full_quizzes, target_quizzes),\n",
        "            FadeIn(title)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, quizzes, \n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.2,\n",
        "            ),\n",
        "            Animation(full_quizzes, remover = True)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.quizzes = quizzes\n",
        "        self.title = title\n",
        "\n",
        "    def show_division_by_first_question(self):\n",
        "        n = int(0.8*len(self.quizzes))\n",
        "        top_split = VGroup(*self.quizzes[:n])\n",
        "        bottom_split = VGroup(*self.quizzes[n:])\n",
        "        for split, color, vect in (top_split, GREEN, UP), (bottom_split, RED, DOWN):\n",
        "            split.sort(lambda p : p[0])\n",
        "            split.generate_target()\n",
        "            split.target.shift(MED_LARGE_BUFF*vect)\n",
        "            for quiz in split.target:\n",
        "                quiz[0].set_color(color)\n",
        "\n",
        "        labels = VGroup()\n",
        "        for num, b, split in (800, True, top_split), (200, False, bottom_split):\n",
        "            label = VGroup(\n",
        "                OldTex(str(num)),\n",
        "                get_slot_group([b], buff = SMALL_BUFF, include_qs = False)\n",
        "            )\n",
        "            label.arrange(DOWN)\n",
        "            label.next_to(split.target, LEFT, buff = LARGE_BUFF)\n",
        "            labels.add(label)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.title),\n",
        "            MoveToTarget(top_split),\n",
        "            MoveToTarget(bottom_split),\n",
        "        )\n",
        "        for label in labels:\n",
        "            self.play(FadeIn(label))\n",
        "            self.wait()\n",
        "\n",
        "        self.splits = VGroup(top_split, bottom_split)\n",
        "        self.q1_split_labels = labels\n",
        "\n",
        "    def ask_about_second_question(self):\n",
        "        top_split = self.splits[0]\n",
        "        sg1, sg2 = slot_groups = VGroup(*[\n",
        "            get_slot_group(\n",
        "                [True, b], \n",
        "                include_qs = False,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            for b in (True, False)\n",
        "        ])\n",
        "        question = VGroup(\n",
        "            OldTexText(\"Where are\"), sg1,\n",
        "            OldTexText(\"and\"), sg2, OldTexText(\"?\"),\n",
        "        )\n",
        "        question.arrange(RIGHT, aligned_edge = DOWN)\n",
        "        question[-1].next_to(question[-2], RIGHT, SMALL_BUFF)\n",
        "        question.next_to(top_split, UP, MED_LARGE_BUFF)\n",
        "        slot_groups.shift(SMALL_BUFF*DOWN)\n",
        "        little_rects = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                VGroup(sg.lines[1], sg.content[1])\n",
        "            )\n",
        "            for sg in slot_groups\n",
        "        ])\n",
        "        big_rect = SurroundingRectangle(top_split)\n",
        "\n",
        "        self.play(Write(question))\n",
        "        self.play(ShowCreation(little_rects))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(little_rects))\n",
        "        self.play(ShowCreation(big_rect))\n",
        "        self.play(\n",
        "            FadeOut(big_rect),\n",
        "            FadeOut(question),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_uncorrelated_division_by_second(self):\n",
        "        top_split = self.splits[0]\n",
        "        top_label = self.q1_split_labels[0]\n",
        "        n = int(0.8*len(top_split))\n",
        "        left_split = VGroup(*top_split[:n])\n",
        "        right_split = VGroup(*top_split[n:])\n",
        "        for split, color in (left_split, GREEN_E), (right_split, RED_E):\n",
        "            split.generate_target()\n",
        "            for quiz in split.target:\n",
        "                quiz[1].set_color(color)\n",
        "        left_split.target.shift(LEFT)\n",
        "\n",
        "        left_label = VGroup(\n",
        "            OldTex(\"(0.8)\", \"800 =\", \"640\"),\n",
        "            get_slot_group([True, True], buff = SMALL_BUFF, include_qs = False)\n",
        "        )\n",
        "        left_label.arrange(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        left_label.next_to(left_split.target, UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(left_split),\n",
        "            MaintainPositionRelativeTo(top_label, left_split),\n",
        "            MoveToTarget(right_split),\n",
        "        )\n",
        "        self.play(FadeIn(left_label))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, left_split,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back,\n",
        "            lag_ratio = 0.2,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.top_left_label = left_label\n",
        "        self.top_splits = VGroup(left_split, right_split)\n",
        "\n",
        "    def increase_second_correct_slice(self):\n",
        "        left_split, right_split = self.top_splits\n",
        "        left_label = self.top_left_label\n",
        "        left_label_equation = left_label[0]\n",
        "        movers = VGroup(*right_split[:self.n_movers])\n",
        "        movers.generate_target()\n",
        "        for quiz in movers.target:\n",
        "            quiz[1].set_color(left_split[0][1].get_color())\n",
        "        movers.target.shift(LEFT)\n",
        "\n",
        "        new_equation = OldTex(\"(0.925)\", \"800 =\", \"740\")\n",
        "        for i in 0, 2:\n",
        "            new_equation[i].set_color(YELLOW)\n",
        "        new_equation.move_to(left_label_equation)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                movers, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            Transform(left_label_equation, new_equation)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Indicate(left_label_equation[0]))\n",
        "        self.wait()\n",
        "\n",
        "        left_split.add(*movers)\n",
        "        right_split.remove(*movers)\n",
        "        self.top_left_split = left_split\n",
        "        self.top_right_split = right_split\n",
        "        self.top_movers = movers\n",
        "        self.top_equation = left_label_equation\n",
        "\n",
        "    def second_division_among_first_wrong(self):\n",
        "        top_label, bottom_label = self.q1_split_labels\n",
        "        top_split, bottom_split = self.splits\n",
        "        top_left_label = self.top_left_label\n",
        "        top_group = VGroup(top_split, top_left_label, top_label)\n",
        "\n",
        "        n = int(0.8*len(bottom_split))\n",
        "        left_split = VGroup(*bottom_split[:n])\n",
        "        right_split = VGroup(*bottom_split[n:])\n",
        "        for split, color in (left_split, GREEN_E), (right_split, RED_E):\n",
        "            split.generate_target()\n",
        "            for quiz in split.target:\n",
        "                quiz[1].set_color(color)\n",
        "        left_split.target.shift(LEFT)\n",
        "\n",
        "        movers = VGroup(*left_split[-self.n_movers:])\n",
        "        movers.generate_target()\n",
        "        for quiz in movers.target:\n",
        "            quiz[1].set_color(right_split.target[0][1].get_color())\n",
        "\n",
        "        equation = OldTex(\"(0.8)\", \"200 = \", \"160\")\n",
        "        slot_group = get_slot_group([False, True], buff = SMALL_BUFF, include_qs = False)\n",
        "        label = VGroup(equation, slot_group)\n",
        "        label.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        label.next_to(left_split.target, UP, SMALL_BUFF, LEFT)\n",
        "        alt_equation = OldTex(\"(0.3)\", \"200 = \", \"60\")\n",
        "        for i in 0, 2:\n",
        "            alt_equation[i].set_color(YELLOW)\n",
        "        alt_equation.move_to(equation)\n",
        "\n",
        "        self.play(top_group.to_edge, UP, SMALL_BUFF)\n",
        "        self.play(\n",
        "            bottom_label.shift, LEFT,\n",
        "            *list(map(MoveToTarget, [left_split, right_split]))\n",
        "        )\n",
        "        self.play(FadeIn(label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveToTarget(\n",
        "                movers, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3,\n",
        "            ),\n",
        "            Transform(equation, alt_equation)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        left_split.remove(*movers)\n",
        "        right_split.add(*movers)\n",
        "        self.bottom_left_split = left_split\n",
        "        self.bottom_right_split = right_split\n",
        "        self.bottom_movers = movers\n",
        "        self.bottom_equation = equation\n",
        "        self.bottom_left_label = label\n",
        "\n",
        "    def show_that_second_is_still_80(self):\n",
        "        second_right = VGroup(\n",
        "            self.bottom_left_split, self.top_left_split\n",
        "        )\n",
        "        second_wrong = VGroup(\n",
        "            self.bottom_right_split, self.top_right_split\n",
        "        )\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(mob, buff = SMALL_BUFF)\n",
        "            for mob in second_right\n",
        "        ])\n",
        "\n",
        "        num1 = self.top_equation[-1].copy()\n",
        "        num2 = self.bottom_equation[-1].copy()\n",
        "\n",
        "        equation = OldTex(\"740\", \"+\", \"60\", \"=\", \"800\")\n",
        "        for tex in \"740\", \"60\":\n",
        "            equation.set_color_by_tex(tex, YELLOW)\n",
        "        slot_group = get_slot_group([True, True])\n",
        "        slot_group.content[0].set_fill(BLACK, 0)\n",
        "        label = VGroup(equation, slot_group)\n",
        "        label.arrange(DOWN)\n",
        "        label.next_to(self.quizzes, LEFT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.q1_split_labels),\n",
        "            ShowCreation(rects)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(slot_group),\n",
        "            Transform(\n",
        "                num1, equation[0],\n",
        "                rate_func = squish_rate_func(smooth, 0, 0.7),\n",
        "            ),\n",
        "            Transform(\n",
        "                num2, equation[2],\n",
        "                rate_func = squish_rate_func(smooth, 0.3, 1),\n",
        "            ),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.play(\n",
        "            Write(equation),\n",
        "            *list(map(Animation, [num1, num2]))\n",
        "        )\n",
        "        self.remove(num1, num2)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(rects))\n",
        "\n",
        "    def emphasize_disproportionate_divide(self):\n",
        "        top_movers = self.top_movers\n",
        "        bottom_movers = self.bottom_movers\n",
        "        both_movers = VGroup(top_movers, bottom_movers)\n",
        "        both_movers.save_state()\n",
        "\n",
        "        top_movers.target = bottom_movers.copy().shift(LEFT)\n",
        "        bottom_movers.target = top_movers.copy().shift(RIGHT)\n",
        "        for quiz in top_movers.target:\n",
        "            quiz[0].set_color(RED)\n",
        "        for quiz in bottom_movers.target:\n",
        "            quiz[0].set_color(GREEN)\n",
        "\n",
        "        line = Line(UP, DOWN, color = YELLOW)\n",
        "        line.set_height(self.quizzes.get_height())\n",
        "        line.next_to(bottom_movers.target, LEFT, MED_LARGE_BUFF, UP)\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.play(*list(map(MoveToTarget, both_movers)))\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(FadeOut(line))\n",
        "        self.wait()\n",
        "        self.play(both_movers.restore)\n",
        "        self.wait()\n",
        "\n",
        "    def show_third_question_results(self):\n",
        "        all_splits = VGroup(\n",
        "            self.top_left_split, self.top_right_split,\n",
        "            self.bottom_left_split, self.bottom_right_split\n",
        "        )\n",
        "        proportions = [0.9, 0.8, 0.8, 0.4]\n",
        "        for split, prop in zip(all_splits, proportions):\n",
        "            n = int(prop*len(split))\n",
        "            split.sort(lambda p : -p[1])\n",
        "            split.generate_target()\n",
        "            top_part = VGroup(*split.target[:n])\n",
        "            top_part.shift(MED_SMALL_BUFF*UP)\n",
        "            bottom_part = VGroup(*split.target[n:])\n",
        "            bottom_part.shift(MED_SMALL_BUFF*DOWN)\n",
        "            for quiz in top_part:\n",
        "                quiz[-1].set_color(GREEN)\n",
        "            for quiz in bottom_part:\n",
        "                quiz[-1].set_color(RED)\n",
        "\n",
        "        split = self.top_left_split\n",
        "        n_all_right = int(proportions[0]*len(split))\n",
        "        all_right = VGroup(*split[:n_all_right])\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(self.top_left_label),\n",
        "            FadeOut(self.bottom_left_label),\n",
        "        )\n",
        "        for split in all_splits:\n",
        "            self.play(MoveToTarget(split))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, all_right,\n",
        "            lambda m : (m.set_color, YELLOW),\n",
        "            rate_func = there_and_back,\n",
        "            lag_ratio = 0.2,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def get_thousand_quizzes(self):\n",
        "        rows = VGroup()\n",
        "        for x in range(self.n_quiz_rows):\n",
        "            quiz = VGroup(*[\n",
        "                Rectangle(\n",
        "                    height = SMALL_BUFF,\n",
        "                    width = 0.5*SMALL_BUFF\n",
        "                )\n",
        "                for x in range(3)\n",
        "            ])\n",
        "            quiz.arrange(RIGHT, buff = 0)\n",
        "            quiz.set_stroke(width = 0)\n",
        "            quiz.set_fill(GREY_B, 1)\n",
        "            row = VGroup(*[quiz.copy() for y in range(self.n_quiz_cols)])\n",
        "            row.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            rows.add(row)\n",
        "\n",
        "        rows.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        quizzes = VGroup(*it.chain(*rows))\n",
        "        quizzes.set_height(self.quizzes_height)\n",
        "        quizzes.to_edge(RIGHT)\n",
        "        quizzes.shift(MED_LARGE_BUFF*DOWN)\n",
        "        return quizzes\n",
        "\n",
        "class ExampleConditional(Scene):\n",
        "    def construct(self):\n",
        "        prob = get_probability_of_slot_group(\n",
        "            [True, True], [True]\n",
        "        )\n",
        "        rhs = OldTex(\"=\", \"0.925\", \">\", \"0.8\")\n",
        "        rhs.set_color_by_tex(\"0.925\", YELLOW)\n",
        "        rhs.next_to(prob, RIGHT)\n",
        "        expression = VGroup(prob, rhs)\n",
        "        expression.set_width(FRAME_WIDTH - 1)\n",
        "        expression.center().to_edge(DOWN)\n",
        "\n",
        "        self.play(Write(expression))\n",
        "        self.wait()\n",
        "\n",
        "class HarderQuizzes(Scene):\n",
        "    def construct(self):\n",
        "        quizzes = VGroup(\n",
        "            get_quiz(\n",
        "                \"Find all primes $p$ \\\\\\\\ where $p+2$ is prime.\",\n",
        "                \"Find all primes $p$ \\\\\\\\ where $2^{p}-1$ is prime.\",\n",
        "                \"Solve $\\\\zeta(s) = 0$\",\n",
        "            ),\n",
        "            get_quiz(\n",
        "                \"Find $S$ such that \\\\\\\\ $\\\\#\\\\mathds{N} < \\\\#S < \\\\#\\\\mathcal{P}(\\\\mathds{N})$\",\n",
        "                \"Describe ``forcing''\",\n",
        "                \"Prove from ZFC that $S \\\\notin S$.\",\n",
        "            ),\n",
        "        )\n",
        "        quizzes.arrange(RIGHT)\n",
        "        quizzes.to_edge(DOWN)\n",
        "        crosses = VGroup(*[\n",
        "            Cross(quiz.questions[0])\n",
        "            for quiz in quizzes\n",
        "        ])\n",
        "\n",
        "        for quiz in quizzes:\n",
        "            self.play(FadeIn(quiz))\n",
        "        self.wait()\n",
        "        for cross in crosses:\n",
        "            self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "class WritePSecond(Scene):\n",
        "    def construct(self):\n",
        "        prob = get_probability_of_slot_group([None, True, None])\n",
        "        rhs = OldTex(\"= 0.8\")\n",
        "        rhs.next_to(prob, RIGHT)\n",
        "        prob.add(rhs)\n",
        "        prob.set_width(FRAME_WIDTH - 1)\n",
        "        prob.center().to_edge(DOWN)\n",
        "        self.play(Write(prob))\n",
        "\n",
        "class SubmitToTemptation(TemptingButWrongCalculation):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "        TemptingButWrongCalculation.construct(self)\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "        title = self.title\n",
        "        question = self.question\n",
        "        title.generate_target()\n",
        "        title.target.scale(1./1.5)\n",
        "        new_words = OldTexText(\"and\", \"okay\", \"assuming independence.\")\n",
        "        new_words.set_color_by_tex(\"okay\", GREEN)\n",
        "        new_words.next_to(title.target, RIGHT)\n",
        "        VGroup(title.target, new_words).center().to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(title),\n",
        "            FadeOut(question)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(new_words, run_time = 2),\n",
        "            self.randy.change, \"hooray\"\n",
        "        )\n",
        "        for part in self.rhs:\n",
        "            self.play(Indicate(part.value))\n",
        "        self.wait()\n",
        "\n",
        "class AccurateProductRule(SampleSpaceScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.setup_terms()\n",
        "        self.add_sample_space()\n",
        "        self.wait()\n",
        "        self.show_first_division()\n",
        "        self.show_second_division()\n",
        "        self.move_to_third_dimension()\n",
        "        self.show_final_probability()\n",
        "        self.show_confusion()\n",
        "\n",
        "    def setup_terms(self):\n",
        "        filler_tex = \"Filler\"\n",
        "        lhs = OldTex(\"P(\", filler_tex, \")\", \"=\")\n",
        "        p1 = OldTex(\"P(\", filler_tex, \")\")\n",
        "        p2 = OldTex(\"P(\", filler_tex, \"|\", filler_tex, \")\")\n",
        "        p3 = OldTex(\"P(\", filler_tex, \"|\", filler_tex, \")\")\n",
        "        terms = VGroup(lhs, p1, p2, p3)\n",
        "        terms.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        terms.to_edge(UP, buff = LARGE_BUFF)\n",
        "\n",
        "        kwargs = {\"buff\" : SMALL_BUFF, \"include_qs\" : False}\n",
        "        slot_group_lists = [\n",
        "            [get_slot_group([True, True, False], **kwargs)],\n",
        "            [get_slot_group([True], **kwargs)],\n",
        "            [\n",
        "                get_slot_group([True, True], **kwargs),\n",
        "                get_slot_group([True], **kwargs),\n",
        "            ],\n",
        "            [\n",
        "                get_slot_group([True, True, False], **kwargs),\n",
        "                get_slot_group([True, True], **kwargs),\n",
        "            ],\n",
        "        ]\n",
        "        for term, slot_group_list in zip(terms, slot_group_lists):\n",
        "            parts = term.get_parts_by_tex(filler_tex)\n",
        "            for part, slot_group in zip(parts, slot_group_list):\n",
        "                slot_group.replace(part, dim_to_match = 0)\n",
        "                term.submobjects[term.index_of_part(part)] = slot_group\n",
        "        # terms[2][1].content[0].set_fill(BLACK, 0)\n",
        "        # VGroup(*terms[3][1].content[:2]).set_fill(BLACK, 0)\n",
        "\n",
        "        value_texs = [\"0.8\", \">0.8\", \"<0.2\"]\n",
        "        for term, tex in zip(terms[1:], value_texs):\n",
        "            term.value = OldTex(tex)\n",
        "            term.value.next_to(term, UP)\n",
        "\n",
        "        self.terms = terms\n",
        "        self.add(terms[0])\n",
        "\n",
        "    def add_sample_space(self):\n",
        "        SampleSpaceScene.add_sample_space(self, height = 4, width = 5)\n",
        "        self.sample_space.to_edge(DOWN)\n",
        "\n",
        "    def show_first_division(self):\n",
        "        space = self.sample_space\n",
        "        space.divide_horizontally(\n",
        "            [0.8], colors = [GREEN_E, RED_E]\n",
        "        )\n",
        "        space.horizontal_parts.fade(0.1)\n",
        "        top_label = self.terms[1].copy()\n",
        "        bottom_label = top_label.copy()\n",
        "        slot_group = get_slot_group([False], buff = SMALL_BUFF, include_qs = False)\n",
        "        slot_group.replace(bottom_label[1])\n",
        "        Transform(bottom_label[1], slot_group).update(1)\n",
        "        braces_and_labels = space.get_side_braces_and_labels(\n",
        "            [top_label, bottom_label]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(space.horizontal_parts),\n",
        "            FadeIn(braces_and_labels)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            top_label.copy(), self.terms[1]\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(self.terms[1].value))\n",
        "        self.wait()\n",
        "\n",
        "        space.add(braces_and_labels)\n",
        "        self.top_part = space.horizontal_parts[0]\n",
        "\n",
        "    def show_second_division(self):\n",
        "        space = self.sample_space\n",
        "        top_part = self.top_part\n",
        "        green_red_mix = average_color(GREEN_E, RED_E)\n",
        "        top_part.divide_vertically(\n",
        "            [0.9], colors = [GREEN_E, green_red_mix]\n",
        "        )\n",
        "        label = self.terms[2].deepcopy()\n",
        "        braces_and_labels = top_part.get_top_braces_and_labels(\n",
        "            labels = [label]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(top_part.vertical_parts),\n",
        "            FadeIn(braces_and_labels)\n",
        "        )\n",
        "        self.play(ReplacementTransform(\n",
        "            label.copy(), self.terms[2]\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(self.terms[2].value))\n",
        "        self.wait()\n",
        "\n",
        "        space.add(braces_and_labels)\n",
        "        self.top_left_part = top_part.vertical_parts[0]\n",
        "\n",
        "    def move_to_third_dimension(self):\n",
        "        space = self.sample_space\n",
        "        part = self.top_left_part\n",
        "        cubes = VGroup(\n",
        "            Cube(fill_color = RED_E),\n",
        "            Cube(fill_color = GREEN_E),\n",
        "        )\n",
        "        cubes.set_fill(opacity = 0)\n",
        "        cubes.stretch_to_fit_width(part.get_width())\n",
        "        cubes.stretch_to_fit_height(part.get_height())\n",
        "        cubes[1].move_to(part, IN)\n",
        "        cubes[0].stretch(0.2, 2)\n",
        "        cubes[0].move_to(cubes[1].get_edge_center(OUT), IN)\n",
        "        space.add(cubes)\n",
        "\n",
        "        self.play(\n",
        "            space.rotate, 0.9*np.pi/2, LEFT,\n",
        "            space.rotate, np.pi/12, UP,\n",
        "            space.to_corner, DOWN+RIGHT, LARGE_BUFF\n",
        "        )\n",
        "        space.remove(cubes)\n",
        "        self.play(\n",
        "            cubes[0].set_fill, None, 1,\n",
        "            cubes[0].set_stroke, WHITE, 1,\n",
        "            cubes[1].set_fill, None, 0.5,\n",
        "            cubes[1].set_stroke, WHITE, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.cubes = cubes\n",
        "\n",
        "    def show_final_probability(self):\n",
        "        cube = self.cubes[0]\n",
        "        face = cube[2]\n",
        "        points = face.get_anchors()\n",
        "        line = Line(points[2], points[3])\n",
        "        line.set_stroke(YELLOW, 8)\n",
        "        brace = Brace(line, LEFT)\n",
        "        label = self.terms[3].copy()\n",
        "        label.next_to(brace, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            label.copy(), self.terms[3]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "    def show_confusion(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"confused\", self.terms)\n",
        "        self.play(randy.look_at, self.cubes)\n",
        "        self.play(Blink(randy))\n",
        "        self.play(randy.look_at, self.terms)\n",
        "        self.wait()\n",
        "\n",
        "class ShowAllEightConditionals(Scene):\n",
        "    def construct(self):\n",
        "        self.show_all_conditionals()\n",
        "        self.suggest_independence()\n",
        "\n",
        "    def show_all_conditionals(self):\n",
        "        equations = VGroup()\n",
        "        filler_tex = \"Filler\"\n",
        "        for bool_list in it.product(*[[True, False]]*3):\n",
        "            equation = OldTex(\n",
        "                \"P(\", filler_tex, \")\", \"=\",\n",
        "                \"P(\", filler_tex, \")\",\n",
        "                \"P(\", filler_tex, \"|\", filler_tex, \")\",\n",
        "                \"P(\", filler_tex, \"|\", filler_tex, \")\",\n",
        "            )\n",
        "            sub_bool_lists = [\n",
        "                bool_list[:n] for n in (3, 1, 2, 1, 3, 2)\n",
        "            ]\n",
        "            parts = equation.get_parts_by_tex(filler_tex)\n",
        "            for part, sub_list in zip(parts, sub_bool_lists):\n",
        "                slot_group = get_slot_group(\n",
        "                    sub_list, \n",
        "                    buff = SMALL_BUFF,\n",
        "                    include_qs = False\n",
        "                )\n",
        "                slot_group.replace(part, dim_to_match = 0)\n",
        "                index = equation.index_of_part(part)\n",
        "                equation.submobjects[index] = slot_group\n",
        "            equations.add(equation)\n",
        "        equations.arrange(DOWN)\n",
        "\n",
        "        rect = SurroundingRectangle(\n",
        "            VGroup(*equations[0][7:], *equations[-1][7:]),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "        rect.shift(0.5*SMALL_BUFF*RIGHT)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, equations,\n",
        "            run_time = 5,\n",
        "            lag_ratio = 0.3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(rect, run_time = 2))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "    def suggest_independence(self):\n",
        "        full_screen_rect = FullScreenFadeRectangle()\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(full_screen_rect),\n",
        "            FadeIn(randy)\n",
        "        )\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"Let's just assume \\\\\\\\ independence.\",\n",
        "            target_mode = \"shruggie\"\n",
        "        ))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class ShowIndependenceSymbolically(Scene):\n",
        "    def construct(self):\n",
        "        filler_tex = \"Filler\"\n",
        "        rhs = OldTex(\"=\", \"0.8\")\n",
        "        rhs.set_color_by_tex(\"0.8\", YELLOW)\n",
        "        rhs.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        lhs = OldTex(\"P(\", filler_tex, \"|\", filler_tex, \")\")\n",
        "        lhs.next_to(rhs, LEFT)\n",
        "        VGroup(lhs, rhs).scale(1.5)\n",
        "        for part in lhs.get_parts_by_tex(filler_tex):\n",
        "            slot_group = get_slot_group(\n",
        "                [True, True, True],\n",
        "                buff = SMALL_BUFF,\n",
        "                include_qs = False,\n",
        "            )\n",
        "            slot_group.replace(part, dim_to_match = 0)\n",
        "            lhs.submobjects[lhs.index_of_part(part)] = slot_group\n",
        "        VGroup(*lhs[1].content[:2]).set_fill(BLACK, 0)\n",
        "        condition = lhs[3]\n",
        "        condition.content[2].set_fill(BLACK, 0)\n",
        "        bool_lists = [\n",
        "            [False], [True, False], [False, True], [True],\n",
        "        ]\n",
        "        arrow = Arrow(UP, DOWN)\n",
        "        arrow.next_to(condition, UP)\n",
        "        arrow.set_color(RED)\n",
        "        words = OldTexText(\"Doesn't matter\")\n",
        "        words.set_color(RED)\n",
        "        words.next_to(arrow, UP)\n",
        "\n",
        "        self.add(rhs, lhs, arrow, words)\n",
        "        self.wait()\n",
        "        for bool_list in bool_lists:\n",
        "            slot_group = get_slot_group(bool_list, SMALL_BUFF, False)\n",
        "            slot_group.replace(condition)\n",
        "            slot_group.move_to(condition, DOWN)\n",
        "            self.play(Transform(condition, slot_group))\n",
        "            self.wait()\n",
        "            \n",
        "class ComputeProbabilityOfOneWrong(Scene):\n",
        "    CONFIG = {\n",
        "        \"score\" : 2,\n",
        "        \"final_result_rhs_tex\" : [\n",
        "            \"3\", \"(0.8)\", \"^2\", \"(0.2)\", \"=\", \"0.384\",\n",
        "        ],\n",
        "        \"default_bool\" : True,\n",
        "        \"default_p\" : \"0.8\",\n",
        "        \"default_q\" : \"0.2\",\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_all_three_patterns()\n",
        "        self.show_final_result()\n",
        "\n",
        "    def show_all_three_patterns(self):\n",
        "        probabilities = VGroup()\n",
        "        point_8s = VGroup()\n",
        "        point_2s = VGroup()\n",
        "        for i in reversed(list(range(3))):\n",
        "            bool_list = [self.default_bool]*3\n",
        "            bool_list[i] = not self.default_bool\n",
        "            probs = [\"(%s)\"%self.default_p]*3\n",
        "            probs[i] = \"(%s)\"%self.default_q\n",
        "            lhs = get_probability_of_slot_group(bool_list)\n",
        "            rhs = OldTex(\"=\", *probs)\n",
        "            rhs.set_color_by_tex(\"0.8\", GREEN)\n",
        "            rhs.set_color_by_tex(\"0.2\", RED)\n",
        "            point_8s.add(*rhs.get_parts_by_tex(\"0.8\"))\n",
        "            point_2s.add(*rhs.get_parts_by_tex(\"0.2\"))\n",
        "            rhs.next_to(lhs, RIGHT)\n",
        "            probabilities.add(VGroup(lhs, rhs))\n",
        "        probabilities.arrange(DOWN, buff = LARGE_BUFF)\n",
        "        probabilities.center()\n",
        "\n",
        "        self.play(Write(probabilities[0]))\n",
        "        self.wait(2)\n",
        "        for i in range(2):\n",
        "            self.play(ReplacementTransform(\n",
        "                probabilities[i].copy(),\n",
        "                probabilities[i+1]\n",
        "            ))\n",
        "        self.wait()\n",
        "        for group in point_8s, point_2s:\n",
        "            self.play(LaggedStartMap(\n",
        "                Indicate, group,\n",
        "                rate_func = there_and_back,\n",
        "                lag_ratio = 0.7\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "    def show_final_result(self):\n",
        "        result = OldTex(\n",
        "            \"P(\", \"\\\\text{Score} = %s\"%self.score, \")\", \"=\",\n",
        "            *self.final_result_rhs_tex\n",
        "        )\n",
        "        result.set_color_by_tex_to_color_map({\n",
        "            \"0.8\" : GREEN,\n",
        "            \"0.2\" : RED,\n",
        "            \"Score\" : YELLOW,\n",
        "        })\n",
        "        result[-1].set_color(YELLOW)\n",
        "        result.set_color_by_tex(\"0.8\", GREEN)\n",
        "        result.set_color_by_tex(\"0.2\", RED)\n",
        "        result.to_edge(UP)\n",
        "\n",
        "        self.play(Write(result))\n",
        "        self.wait()\n",
        "\n",
        "class ComputeProbabilityOfOneRight(ComputeProbabilityOfOneWrong):\n",
        "    CONFIG = {\n",
        "        \"score\" : 1,\n",
        "        \"final_result_rhs_tex\" : [\n",
        "            \"3\", \"(0.8)\", \"(0.2)\", \"^2\", \"=\", \"0.096\",\n",
        "        ],\n",
        "        \"default_bool\" : False,\n",
        "        \"default_p\" : \"0.2\",\n",
        "        \"default_q\" : \"0.8\",\n",
        "    }\n",
        "\n",
        "class ShowFullDistribution(Scene):\n",
        "    def construct(self):\n",
        "        self.add_scores_one_and_two()\n",
        "        self.add_scores_zero_and_three()\n",
        "        self.show_bar_chart()\n",
        "        self.compare_to_binomial_pattern()\n",
        "        self.show_alternate_values_of_p()\n",
        "\n",
        "    def add_scores_one_and_two(self):\n",
        "        scores = VGroup(\n",
        "            OldTex(\n",
        "                \"P(\", \"\\\\text{Score} = 0\", \")\",\n",
        "                \"=\", \"(0.2)\", \"^3\",\n",
        "                \"=\", \"0.008\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"P(\", \"\\\\text{Score} = 1\", \")\",\n",
        "                \"=\", \"3\", \"(0.8)\", \"(0.2)\", \"^2\", \n",
        "                \"=\", \"0.096\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"P(\", \"\\\\text{Score} = 2\", \")\",\n",
        "                \"=\", \"3\", \"(0.8)\", \"^2\", \"(0.2)\",\n",
        "                \"=\", \"0.384\",\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"P(\", \"\\\\text{Score} = 3\", \")\",\n",
        "                \"=\", \"(0.8)\", \"^3\",\n",
        "                \"=\", \"0.512\",\n",
        "            ),\n",
        "        )\n",
        "        scores.arrange(\n",
        "            DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        scores.shift(MED_LARGE_BUFF*UP)\n",
        "        scores.to_edge(LEFT)\n",
        "        for score in scores:\n",
        "            score.set_color_by_tex_to_color_map({\n",
        "                \"0.8\" : GREEN,\n",
        "                \"0.2\" : RED,\n",
        "            })\n",
        "            score[-1].set_color(YELLOW)\n",
        "\n",
        "        self.add(*scores[1:3])\n",
        "        self.scores = scores\n",
        "\n",
        "    def add_scores_zero_and_three(self):\n",
        "        self.p_slot_groups = VGroup()\n",
        "\n",
        "        self.wait()\n",
        "        self.add_edge_score(0, UP, False)\n",
        "        self.add_edge_score(3, DOWN, True)\n",
        "\n",
        "    def add_edge_score(self, index, vect, q_bool):\n",
        "        score = self.scores[index]\n",
        "        prob = VGroup(*score[:3])\n",
        "        brace = Brace(prob, vect)\n",
        "        p_slot_group = get_probability_of_slot_group([q_bool]*3)\n",
        "        p_slot_group.next_to(brace, vect)\n",
        "        group = VGroup(*it.chain(p_slot_group, brace, score))\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, group,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.7,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.p_slot_groups.add(brace, p_slot_group)\n",
        "\n",
        "    def show_bar_chart(self):\n",
        "        p_terms = VGroup()\n",
        "        to_fade = VGroup(self.p_slot_groups)\n",
        "        value_mobs = VGroup()\n",
        "        for score in self.scores:\n",
        "            p_terms.add(VGroup(*score[:3]))\n",
        "            to_fade.add(VGroup(*score[3:-1]))\n",
        "            value_mobs.add(score[-1])\n",
        "        dist = get_binomial_distribution(3, 0.8)\n",
        "        values = list(map(dist, list(range(4))))\n",
        "        chart = BarChart(\n",
        "            values, bar_names = list(range(4)),\n",
        "        )\n",
        "        chart.shift(DOWN)\n",
        "\n",
        "        new_p_terms = VGroup(*[\n",
        "            OldTex(\"P(\", \"S=%d\"%k, \")\")\n",
        "            for k in range(4)\n",
        "        ])\n",
        "        for term, bar in zip(new_p_terms, chart.bars):\n",
        "            term[1].set_color(YELLOW)\n",
        "            term.set_width(1.5*bar.get_width())\n",
        "            term.next_to(bar, UP)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                value_mobs, chart.bars,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, VGroup(*it.chain(*[\n",
        "                submob \n",
        "                for submob in chart\n",
        "                if submob is not chart.bars\n",
        "            ]))),\n",
        "            Transform(p_terms, new_p_terms),\n",
        "            FadeOut(to_fade),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        chart.bar_top_labels = p_terms\n",
        "        chart.add(p_terms)\n",
        "        self.bar_chart = chart\n",
        "\n",
        "    def compare_to_binomial_pattern(self):\n",
        "        dist = get_binomial_distribution(3, 0.5)\n",
        "        values = list(map(dist, list(range(4))))\n",
        "        alt_chart = BarChart(values)\n",
        "        alt_chart.move_to(self.bar_chart)\n",
        "        bars = alt_chart.bars\n",
        "        bars.set_fill(GREY, opacity = 0.5)\n",
        "        vect = 4*UP\n",
        "        bars.shift(vect)\n",
        "        nums = VGroup(*list(map(Tex, list(map(str, [1, 3, 3, 1])))))\n",
        "        for num, bar in zip(nums, bars):\n",
        "            num.next_to(bar, UP)\n",
        "        bars_copy = bars.copy()\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, bars),\n",
        "            LaggedStartMap(FadeIn, nums),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(bars_copy.shift, -vect)\n",
        "        self.play(ReplacementTransform(\n",
        "            bars_copy, self.bar_chart.bars\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            VGroup(self.bar_chart, bars, nums).to_edge, LEFT\n",
        "        )\n",
        "\n",
        "        self.alt_bars = bars\n",
        "        self.alt_bars_labels = nums\n",
        "\n",
        "    def show_alternate_values_of_p(self):\n",
        "        new_prob = OldTex(\n",
        "            \"P(\", \"\\\\text{Correct}\", \")\", \"=\", \"0.8\"\n",
        "        )\n",
        "        new_prob.set_color_by_tex(\"Correct\", GREEN)\n",
        "        new_prob.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "        new_prob.to_edge(UP)\n",
        "\n",
        "        alt_ps = 0.5, 0.65, 0.25\n",
        "        alt_rhss = VGroup()\n",
        "        alt_charts = VGroup()\n",
        "        for p in alt_ps:\n",
        "            rhs = OldTex(str(p))\n",
        "            rhs.set_color(YELLOW)\n",
        "            rhs.move_to(new_prob[-1])\n",
        "            alt_rhss.add(rhs)\n",
        "\n",
        "            dist = get_binomial_distribution(3, p)\n",
        "            values = list(map(dist, list(range(4))))\n",
        "            chart = self.bar_chart.copy()\n",
        "            chart.change_bar_values(values)\n",
        "            for label, bar in zip(chart.bar_top_labels, chart.bars):\n",
        "                label.next_to(bar, UP)\n",
        "            alt_charts.add(chart)\n",
        "\n",
        "        self.play(FadeIn(new_prob))\n",
        "        self.play(Transform(new_prob[-1], alt_rhss[0]))\n",
        "        point_5_probs = self.show_point_5_probs(new_prob)\n",
        "        self.wait()\n",
        "        self.play(Transform(self.bar_chart, alt_charts[0]))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(point_5_probs))\n",
        "        for rhs, chart in list(zip(alt_rhss, alt_charts))[1:]:\n",
        "            self.play(Transform(new_prob[-1], rhs))\n",
        "            self.play(Transform(self.bar_chart, chart))\n",
        "            self.wait(2)\n",
        "\n",
        "    def show_point_5_probs(self, mob):\n",
        "        probs = VGroup()\n",
        "        last = mob\n",
        "        for k in range(4):\n",
        "            buff = MED_LARGE_BUFF\n",
        "            for indices in it.combinations(list(range(3)), k):\n",
        "                bool_list = np.array([False]*3)\n",
        "                bool_list[list(indices)] = True\n",
        "                prob = get_probability_of_slot_group(bool_list)\n",
        "                rhs = OldTex(\"= (0.5)^3\")\n",
        "                rhs.next_to(prob, RIGHT)\n",
        "                prob.add(rhs)\n",
        "                prob.scale(0.9)\n",
        "                prob.next_to(last, DOWN, buff)\n",
        "                probs.add(prob)\n",
        "                last = prob\n",
        "                buff = SMALL_BUFF\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, probs))\n",
        "        self.wait()\n",
        "        return probs\n",
        "\n",
        "class ProbablyWrong(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Probably wrong!\",\n",
        "            run_time = 1,\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"angry\"]*3,\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ShowTrueDistribution(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.remove(self.randy)\n",
        "        self.add_title()\n",
        "        self.show_distributions()\n",
        "        self.show_emotion()\n",
        "        self.imagine_score_0()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.get_angry()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"P(\", \"\\\\text{Correct}\", \")\", \"=\", \"0.65\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_color_by_tex(\"Correct\", GREEN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_distributions(self):\n",
        "        dist = get_binomial_distribution(3, 0.65)\n",
        "        values = np.array(list(map(dist, list(range(4)))))\n",
        "        alt_values = values + [0.2, 0, 0, 0.2]\n",
        "        alt_values /= sum(alt_values)\n",
        "        chart = BarChart(values, bar_names = list(range(4)))\n",
        "        bars = chart.bars\n",
        "        old_bars = bars.copy()\n",
        "        arrows = VGroup()\n",
        "        for bar, old_bar in zip(bars, old_bars):\n",
        "            for mob, vect in (bar, RIGHT), (old_bar, LEFT):\n",
        "                mob.generate_target()\n",
        "                mob.target.do_about_point(\n",
        "                    mob.get_corner(DOWN+vect),\n",
        "                    mob.target.stretch, 0.5, 0\n",
        "                )\n",
        "            old_bar.target.set_color(average_color(RED_E, BLACK))\n",
        "            old_bar.target.set_stroke(width = 0)\n",
        "            arrow = Arrow(ORIGIN, UP, buff = 0, color = GREEN)\n",
        "            arrow.move_to(bar.get_bottom())\n",
        "            arrow.shift(3*UP)\n",
        "            arrows.add(arrow)\n",
        "        for arrow in arrows[1:3]:\n",
        "            arrow.rotate(np.pi)\n",
        "            arrow.set_color(RED)\n",
        "        arrows.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        self.add(chart)\n",
        "        self.play(*list(map(MoveToTarget, it.chain(bars, old_bars))))\n",
        "        self.play(\n",
        "            chart.change_bar_values, alt_values,\n",
        "            *list(map(ShowCreation, arrows))\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.bar_chart = chart\n",
        "        self.old_bars = old_bars\n",
        "\n",
        "    def show_emotion(self):\n",
        "        randy = self.randy\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"sad\")\n",
        "        self.play(Blink(randy))\n",
        "\n",
        "    def imagine_score_0(self):\n",
        "        prob_rect = SurroundingRectangle(self.title[-1])\n",
        "        bar_rect = SurroundingRectangle(VGroup(\n",
        "            self.bar_chart.bars[0], self.old_bars[0],\n",
        "            self.bar_chart.bar_labels[0],\n",
        "        ))\n",
        "\n",
        "        self.play(ShowCreation(prob_rect))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            prob_rect, bar_rect\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(bar_rect))\n",
        "\n",
        "    def get_angry(self):\n",
        "        randy = self.randy\n",
        "\n",
        "        self.play(randy.change, \"angry\")\n",
        "        self.wait(2)\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, \"It's not representative!\",\n",
        "            target_mode = \"pleading\",\n",
        "            bubble_config = {\"fill_opacity\" : 1}\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "    #####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.randy = Randolph()\n",
        "        self.randy.to_corner(DOWN+LEFT)\n",
        "        return self.randy\n",
        "\n",
        "class TeacherAssessingLiklihoodOfZero(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.fade_other_students()\n",
        "        self.show_independence_probability()\n",
        "        self.teacher_reacts()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTex(\"P(\", \"\\\\text{Correct}\", \")\", \"=\", \"0.65\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_color_by_tex(\"Correct\", GREEN)\n",
        "        q_mark = OldTex(\"?\")\n",
        "        q_mark.next_to(title[-2], UP, SMALL_BUFF)\n",
        "        title.add(q_mark)\n",
        "\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def fade_other_students(self):\n",
        "        for student in self.students[0::2]:\n",
        "            student.fade(0.7)\n",
        "            self.pi_creatures.remove(student)\n",
        "\n",
        "    def show_independence_probability(self):\n",
        "        prob = get_probability_of_slot_group(3*[False])\n",
        "        rhs = OldTex(\"=\", \"(0.35)\", \"^3\", \"\\\\approx 4.3\\\\%\")\n",
        "        rhs.set_color_by_tex(\"0.35\", RED)\n",
        "        rhs.next_to(prob, RIGHT)\n",
        "        prob.add(rhs)\n",
        "        prob.next_to(self.teacher, UP+LEFT)\n",
        "        words = OldTexText(\"Assuming independence\")\n",
        "        words.next_to(prob, UP)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeIn(words),\n",
        "            Write(prob)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ind_group = VGroup(prob, words)\n",
        "\n",
        "    def teacher_reacts(self):\n",
        "        ind_group = self.ind_group\n",
        "        box = SurroundingRectangle(ind_group)\n",
        "        box.set_stroke(WHITE, 0)\n",
        "        ind_group.add(box)\n",
        "        ind_group.generate_target()\n",
        "        ind_group.target.scale(0.7)\n",
        "        ind_group.target.to_corner(UP+RIGHT, MED_SMALL_BUFF)\n",
        "        ind_group.target[-1].set_stroke(WHITE, 2)\n",
        "\n",
        "        randy = self.students[1]\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"Highly unlikely\",\n",
        "            target_mode = \"sassy\",\n",
        "            added_anims = [MoveToTarget(ind_group)],\n",
        "            run_time = 2,\n",
        "        )\n",
        "        self.play(randy.change, \"sad\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode = \"guilty\",\n",
        "            ),\n",
        "            PiCreatureSays(randy, \"Wait!\", target_mode = \"surprised\"),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.wait(1)\n",
        "\n",
        "class CorrelationsWith35Percent(ThousandPossibleQuizzes):\n",
        "    def construct(self):\n",
        "        self.add_top_calculation()\n",
        "        self.show_first_split()\n",
        "        self.show_second_split()\n",
        "        self.show_third_split()\n",
        "        self.comment_on_final_size()\n",
        "\n",
        "    def add_top_calculation(self):\n",
        "        equation = VGroup(\n",
        "            get_probability_of_slot_group(3*[False]),\n",
        "            OldTex(\"=\"),\n",
        "            get_probability_of_slot_group([False]),\n",
        "            get_probability_of_slot_group(2*[False], [False]),\n",
        "            get_probability_of_slot_group(3*[False], 2*[False]),\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.equation = equation\n",
        "\n",
        "    def show_first_split(self):\n",
        "        quizzes = self.get_thousand_quizzes()\n",
        "        n = int(0.65*len(quizzes))\n",
        "        top_part = VGroup(*quizzes[:n])\n",
        "        bottom_part = VGroup(*quizzes[n:])\n",
        "        parts = [top_part, bottom_part]\n",
        "        for part, color in zip(parts, [GREEN, RED]):\n",
        "            part.generate_target()\n",
        "            for quiz in part.target:\n",
        "                quiz[0].set_color(color)\n",
        "        top_part.target.shift(UP)\n",
        "        brace = Brace(bottom_part, LEFT)\n",
        "        prop = OldTex(\"0.35\")\n",
        "        prop.next_to(brace, LEFT)\n",
        "\n",
        "        term = self.equation[2]\n",
        "        term_brace = Brace(term, DOWN)\n",
        "\n",
        "        self.add(quizzes)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace), \n",
        "            FadeIn(prop),\n",
        "            *list(map(MoveToTarget, parts))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            top_part.fade, 0.8,\n",
        "            Transform(brace, term_brace),\n",
        "            prop.next_to, term_brace, DOWN,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.quizzes = bottom_part\n",
        "        self.quizzes.sort(lambda p : p[0])\n",
        "\n",
        "    def show_second_split(self):\n",
        "        n = int(0.45*len(self.quizzes))\n",
        "        left_part = VGroup(*self.quizzes[:n])\n",
        "        right_part = VGroup(*self.quizzes[n:])\n",
        "        parts = [left_part, right_part]\n",
        "        for part, color in zip(parts, [GREEN, RED_E]):\n",
        "            part.generate_target()\n",
        "            for quiz in part.target:\n",
        "                quiz[1].set_color(color)\n",
        "        left_part.target.shift(LEFT)\n",
        "        brace = Brace(right_part, UP)\n",
        "        prop = OldTex(\">0.35\")\n",
        "        prop.next_to(brace, UP)\n",
        "\n",
        "        term = self.equation[3]\n",
        "        term_brace = Brace(term, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(prop),\n",
        "            *list(map(MoveToTarget, parts))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(brace, term_brace),\n",
        "            prop.next_to, term_brace, DOWN\n",
        "        )\n",
        "        self.play(left_part.fade, 0.8)\n",
        "\n",
        "        self.quizzes = right_part\n",
        "        self.quizzes.sort(lambda p : -p[1])\n",
        "\n",
        "    def show_third_split(self):\n",
        "        quizzes = self.quizzes\n",
        "        n = int(0.22*len(quizzes))\n",
        "        top_part = VGroup(*quizzes[:n])\n",
        "        bottom_part = VGroup(*quizzes[n:])\n",
        "        parts = [top_part, bottom_part]\n",
        "        for part, color in zip(parts, [GREEN, RED_B]):\n",
        "            part.generate_target()\n",
        "            for quiz in part.target:\n",
        "                quiz[2].set_color(color)\n",
        "        top_part.target.shift(0.5*UP)\n",
        "        brace = Brace(bottom_part, LEFT)\n",
        "        prop = OldTex(\"\\\\gg 0.35\")\n",
        "        prop.next_to(brace, LEFT)\n",
        "\n",
        "        term = self.equation[4]\n",
        "        term_brace = Brace(term, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace), \n",
        "            FadeIn(prop),\n",
        "            *list(map(MoveToTarget, parts))\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(brace, term_brace),\n",
        "            prop.next_to, term_brace, DOWN,\n",
        "        )\n",
        "        self.play(top_part.fade, 0.8)\n",
        "        self.wait()\n",
        "\n",
        "        self.quizzes = bottom_part\n",
        "\n",
        "    def comment_on_final_size(self):\n",
        "        rect = SurroundingRectangle(self.quizzes)\n",
        "        words = OldTexText(\n",
        "            \"Much more than \", \"$(0.35)^3 \\\\approx 4.3\\\\%$\"\n",
        "        )\n",
        "        words.next_to(rect, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            FadeIn(words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class WeighingIndependenceAssumption(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.randy\n",
        "\n",
        "        title = OldTexText(\"Independence\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "        formula = OldTex(\n",
        "            \"P(\", \"A\", \"B\", \")\", \"=\"\n",
        "            \"P(\", \"A\", \")\", \"P(\", \"B\", \")\"\n",
        "        )\n",
        "        formula.set_color_by_tex(\"A\", BLUE)\n",
        "        formula.set_color_by_tex(\"B\", GREEN)\n",
        "\n",
        "        clean = OldTexText(\"Clean\")\n",
        "        clean.next_to(formula, UP)\n",
        "        VGroup(clean, formula).next_to(randy, UP+LEFT)\n",
        "        clean.save_state()\n",
        "        clean.shift(2*(DOWN+RIGHT))\n",
        "        clean.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            randy.change, \"raise_left_hand\", clean,\n",
        "            clean.restore\n",
        "        )\n",
        "        self.play(Write(formula))\n",
        "        self.play(\n",
        "            randy.change, \"raise_right_hand\",\n",
        "            randy.look, UP+RIGHT,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.randy = Randolph().to_edge(DOWN)\n",
        "        return self.randy\n",
        "\n",
        "class NameBinomial(Scene):\n",
        "    CONFIG = {\n",
        "        \"flip_indices\" : [0, 2, 4, 5, 6, 7],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.name_distribution()\n",
        "        self.add_quiz_questions()\n",
        "        self.change_to_gender()\n",
        "        self.change_bar_chart_for_gender_example()\n",
        "        self.point_out_example_input()\n",
        "        self.write_probability_of_girl()\n",
        "        self.think_through_probabilities()\n",
        "\n",
        "    def name_distribution(self):\n",
        "        ns = [3, 10]\n",
        "        p = 0.65\n",
        "        charts = VGroup()\n",
        "        for n in ns:\n",
        "            dist = get_binomial_distribution(n, p)\n",
        "            values = list(map(dist, list(range(n+1))))\n",
        "            chart = BarChart(values, bar_names = list(range(n+1)))\n",
        "            chart.to_edge(LEFT)\n",
        "            charts.add(chart)\n",
        "\n",
        "        probability = OldTex(\n",
        "            \"P(\", \"\\\\checkmark\", \")\", \"=\", str(p)\n",
        "        )\n",
        "        probability.set_color_by_tex(\"checkmark\", GREEN)\n",
        "        probability.move_to(charts, UP)\n",
        "\n",
        "        title = OldTexText(\"``Binomial distribution''\")\n",
        "        title.next_to(charts, UP)\n",
        "        title.to_edge(UP)\n",
        "        formula = OldTex(\n",
        "            \"P(X=\", \"k\", \")=\", \n",
        "            \"{n \\\\choose k}\", \n",
        "            \"p\", \"^k\",\n",
        "            \"(1-\", \"p\", \")\", \"^{n-\", \"k}\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        formula.set_color_by_tex(\"p\", YELLOW)\n",
        "        formula.set_color_by_tex(\"k\", GREEN)\n",
        "        choose_part = formula.get_part_by_tex(\"choose\")\n",
        "        choose_part.set_color(WHITE)\n",
        "        choose_part[-2].set_color(GREEN)\n",
        "        formula.to_corner(UP+RIGHT)\n",
        "\n",
        "        self.add(charts[0], probability)\n",
        "        self.wait()\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(*charts))\n",
        "        self.play(Write(formula))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            formula.scale, 0.7,\n",
        "            formula.next_to, charts, DOWN,\n",
        "        )\n",
        "\n",
        "        self.chart = charts[1]\n",
        "        self.probability = probability\n",
        "        self.title = title\n",
        "        self.formula = formula\n",
        "\n",
        "    def add_quiz_questions(self):\n",
        "        n = 10\n",
        "        checkmarks = VGroup(*[\n",
        "            OldTex(\"\\\\checkmark\").set_color(GREEN)\n",
        "            for x in range(n)\n",
        "        ])\n",
        "        checkmarks.arrange(DOWN, buff = 0.3)\n",
        "        crosses = VGroup()\n",
        "        arrows = VGroup()\n",
        "        for checkmark in checkmarks:\n",
        "            cross = OldTex(\"\\\\times\")\n",
        "            cross.set_color(RED)\n",
        "            cross.next_to(checkmark, RIGHT, LARGE_BUFF)\n",
        "            crosses.add(cross)\n",
        "            arrow = Arrow(\n",
        "                checkmark, cross,\n",
        "                tip_length = 0.15,\n",
        "                color = WHITE\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "        full_group = VGroup(checkmarks, crosses, arrows)\n",
        "        full_group.center().to_corner(UP + RIGHT, buff = MED_LARGE_BUFF)\n",
        "        flip_indices = self.flip_indices\n",
        "        flipped_arrows, faded_crosses, full_checks = [\n",
        "            VGroup(*[group[i] for i in flip_indices])\n",
        "            for group in (arrows, crosses, checkmarks)\n",
        "        ]\n",
        "        faded_checkmarks = VGroup(*[m for m in checkmarks if m not in full_checks])\n",
        "\n",
        "        self.play(*[\n",
        "            LaggedStartMap(\n",
        "                Write, mob,\n",
        "                run_time = 3,\n",
        "                lag_ratio = 0.3\n",
        "            )\n",
        "            for mob in full_group\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                Rotate, flipped_arrows,\n",
        "                angle = np.pi,\n",
        "                in_place = True,\n",
        "                run_time = 2,\n",
        "                lag_ratio = 0.5\n",
        "            ),\n",
        "            faded_crosses.set_fill, None, 0.5,\n",
        "            faded_checkmarks.set_fill, None, 0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.checkmarks = checkmarks\n",
        "        self.crosses = crosses\n",
        "        self.arrows = arrows\n",
        "\n",
        "    def change_to_gender(self):\n",
        "        flip_indices = self.flip_indices\n",
        "        male = self.get_male()\n",
        "        female = self.get_female()\n",
        "\n",
        "        girls, boys = [\n",
        "            VGroup(*[\n",
        "                template.copy().move_to(mob)\n",
        "                for mob in group\n",
        "            ])\n",
        "            for template, group in [\n",
        "                (female, self.checkmarks), (male, self.crosses)\n",
        "            ]\n",
        "        ]\n",
        "        for i in range(len(boys)):\n",
        "            mob = boys[i] if i in flip_indices else girls[i]\n",
        "            mob.set_fill(opacity = 0.5)\n",
        "\n",
        "        brace = Brace(girls, LEFT)\n",
        "        words = brace.get_text(\"$n$ children\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(words)\n",
        "        )\n",
        "        for m1, m2 in (self.crosses, boys), (self.checkmarks, girls):\n",
        "            self.play(ReplacementTransform(\n",
        "                m1, m2,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        self.boys = boys\n",
        "        self.girls = girls\n",
        "        self.children_brace = brace\n",
        "        self.n_children_words = words\n",
        "\n",
        "    def change_bar_chart_for_gender_example(self):\n",
        "        checkmark = self.probability.get_part_by_tex(\"checkmark\")\n",
        "        p_mob = self.probability[-1]\n",
        "\n",
        "        female = self.get_female()\n",
        "        female.move_to(checkmark)\n",
        "        new_p_mob = OldTex(\"0.49\")\n",
        "        new_p_mob.move_to(p_mob, LEFT)\n",
        "\n",
        "        dist = get_binomial_distribution(10, 0.49)\n",
        "        values = list(map(dist, list(range(11))))\n",
        "\n",
        "        self.play(\n",
        "            Transform(checkmark, female),\n",
        "            Transform(p_mob, new_p_mob),\n",
        "        )\n",
        "        self.play(self.chart.change_bar_values, values)\n",
        "        self.wait()\n",
        "\n",
        "    def point_out_example_input(self):\n",
        "        boy_girl_groups = VGroup(*[\n",
        "            VGroup(boy, girl)\n",
        "            for boy, girl in zip(self.boys, self.girls)\n",
        "        ])\n",
        "        girl_rects = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                boy_girl_groups[i], \n",
        "                color = MAROON_B,\n",
        "                buff = SMALL_BUFF,\n",
        "            )\n",
        "            for i in sorted(self.flip_indices)\n",
        "        ])\n",
        "\n",
        "        chart = self.chart\n",
        "        n_girls = len(girl_rects)\n",
        "        chart_rect = SurroundingRectangle(\n",
        "            VGroup(chart.bars[n_girls], chart.bar_labels[n_girls]),\n",
        "            buff = SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        prob = OldTex(\n",
        "            \"P(\", \"\\\\# \\\\text{Girls}\", \"=\", \"6\", \")\"\n",
        "        )\n",
        "        prob.set_color_by_tex(\"Girls\", MAROON_B)\n",
        "        arrow = Arrow(UP, ORIGIN, tip_length = 0.15)\n",
        "        arrow.set_color(MAROON_B)\n",
        "        arrow.next_to(prob, DOWN)\n",
        "        prob.add(arrow)\n",
        "        prob.next_to(chart_rect, UP)\n",
        "        girls = VGroup(*[self.girls[i] for i in self.flip_indices])\n",
        "\n",
        "\n",
        "        self.play(ShowCreation(chart_rect))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreation, girl_rects,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(Write(prob))\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, girls,\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.3,\n",
        "            rate_func = there_and_back\n",
        "        ))\n",
        "        self.play(FadeOut(prob))\n",
        "        self.wait()\n",
        "\n",
        "        self.chart_rect = chart_rect\n",
        "        self.girl_rects = girl_rects\n",
        "\n",
        "    def write_probability_of_girl(self):\n",
        "        probability = self.probability\n",
        "        probability_copies = VGroup(*[\n",
        "            probability.copy().scale(0.7).next_to(\n",
        "                girl, LEFT, MED_LARGE_BUFF\n",
        "            )\n",
        "            for girl in self.girls\n",
        "        ])\n",
        "\n",
        "        self.play(FocusOn(probability))\n",
        "        self.play(Indicate(probability[-1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                VGroup(probability.copy()), probability_copies\n",
        "            ),\n",
        "            FadeOut(self.children_brace),\n",
        "            FadeOut(self.n_children_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.probability_copies = probability_copies\n",
        "\n",
        "    def think_through_probabilities(self):\n",
        "        randy = Randolph().scale(0.5)\n",
        "        randy.next_to(self.probability_copies, LEFT, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(randy.change, \"pondering\")\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "    ##\n",
        "\n",
        "    def get_male(self):\n",
        "        return OldTex(\"\\\\male\").scale(1.3).set_color(BLUE)\n",
        "\n",
        "    def get_female(self):\n",
        "        return OldTex(\"\\\\female\").scale(1.3).set_color(MAROON_B)\n",
        "\n",
        "class CycleThroughPatterns(NameBinomial):\n",
        "    CONFIG = {\n",
        "        \"n_patterns_shown\" : 100,\n",
        "        \"pattern_scale_value\" : 2.7,\n",
        "        \"n\" : 10,\n",
        "        \"k\" : 6,\n",
        "    }\n",
        "    def construct(self):\n",
        "        n = self.n\n",
        "        k = self.k\n",
        "        question = OldTexText(\n",
        "            \"How many patterns have \\\\\\\\ %d \"%k, \n",
        "            \"$\\\\female$\",\n",
        "            \" and %d \"%(n-k),\n",
        "            \"$\\\\male$\",\n",
        "            \"?\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        question.set_color_by_tex(\"male\", BLUE)\n",
        "        question.set_color_by_tex(\"female\", MAROON_B)\n",
        "        question.set_width(FRAME_WIDTH - 1)\n",
        "        question.to_edge(UP, buff = LARGE_BUFF)\n",
        "        self.add(question)\n",
        "\n",
        "        all_combinations = list(it.combinations(list(range(n)), k))\n",
        "        shown_combinations = all_combinations[:self.n_patterns_shown]\n",
        "        patterns = VGroup(*[\n",
        "            self.get_pattern(indicies)\n",
        "            for indicies in shown_combinations\n",
        "        ])\n",
        "        patterns.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        pattern = patterns[0]\n",
        "        self.add(pattern)\n",
        "        for new_pattern in ProgressDisplay(patterns[1:]):\n",
        "            self.play(*[\n",
        "                Transform(\n",
        "                    getattr(pattern, attr),\n",
        "                    getattr(new_pattern, attr),\n",
        "                    path_arc = np.pi\n",
        "                )\n",
        "                for attr in (\"boys\", \"girls\")\n",
        "            ])\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_pattern(self, indices):\n",
        "        pattern = VGroup()\n",
        "        pattern.boys = VGroup()\n",
        "        pattern.girls = VGroup()\n",
        "        for i in range(self.n):\n",
        "            if i in indices:\n",
        "                mob = self.get_female()  \n",
        "                pattern.girls.add(mob)\n",
        "            else:\n",
        "                mob = self.get_male()\n",
        "                pattern.boys.add(mob)\n",
        "            mob.shift(i*MED_LARGE_BUFF*RIGHT)\n",
        "            pattern.add(mob)\n",
        "        pattern.scale(self.pattern_scale_value)\n",
        "        pattern.to_edge(LEFT)\n",
        "        return pattern\n",
        "\n",
        "class Compute6of10GirlsProbability(CycleThroughPatterns):\n",
        "    def construct(self):\n",
        "        self.show_combinations()\n",
        "        self.write_n_choose_k()\n",
        "\n",
        "    def show_combinations(self):\n",
        "        pattern_rect = ScreenRectangle(height = 4)\n",
        "        pattern_rect.center()\n",
        "        pattern_rect.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(pattern_rect)\n",
        "        self.wait(5)\n",
        "\n",
        "        self.pattern_rect = pattern_rect\n",
        "\n",
        "    def write_n_choose_k(self):\n",
        "        brace = Brace(self.pattern_rect, DOWN)\n",
        "        ten_choose_six = brace.get_tex(\"{10 \\\\choose 6}\")\n",
        "        see_chapter_one = OldTexText(\"(See chapter 1)\")\n",
        "        see_chapter_one.next_to(ten_choose_six, DOWN)\n",
        "        see_chapter_one.set_color(GREEN)\n",
        "        computation = OldTex(\n",
        "            \"=\\\\frac{%s}{%s}\"%(\n",
        "                 \"\\\\cdot \".join(map(str, list(range(10, 4, -1)))),\n",
        "                 \"\\\\cdot \".join(map(str, list(range(1, 7)))),\n",
        "            )\n",
        "        )\n",
        "        computation.move_to(ten_choose_six, UP)\n",
        "        rhs = OldTex(\"=\", \"210\")\n",
        "        rhs.next_to(computation, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(see_chapter_one),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.play(Write(ten_choose_six))\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ten_choose_six.next_to, computation.copy(), LEFT,\n",
        "            Write(VGroup(computation, rhs))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ten_choose_six = ten_choose_six\n",
        "        self.rhs = rhs\n",
        "\n",
        "class ProbabilityOfAGivenBoyGirlPattern(CycleThroughPatterns):\n",
        "    def construct(self):\n",
        "        self.write_total_count()\n",
        "        self.write_example_probability()\n",
        "        self.write_total_probability()\n",
        "\n",
        "    def write_total_count(self):\n",
        "        count = OldTexText(\n",
        "            \"${10 \\\\choose 6}$\", \" $= 210$\",\n",
        "            \"total patterns.\"\n",
        "        )\n",
        "        count.to_edge(UP)\n",
        "        self.add(count)\n",
        "\n",
        "        self.count = count\n",
        "\n",
        "    def write_example_probability(self):\n",
        "        prob = OldTex(\"P\\\\big(\", \"O \"*15, \"\\\\big)\", \"=\")\n",
        "        indices = [1, 2, 4, 6, 8, 9]\n",
        "        pattern = self.get_pattern(indices)\n",
        "        pattern.replace(prob[1], dim_to_match = 0)\n",
        "        prob.submobjects[1] = pattern\n",
        "        prob.next_to(self.count, DOWN, LARGE_BUFF)\n",
        "\n",
        "        gp = OldTex(\"P(\\\\female)\")\n",
        "        gp[2].set_color(MAROON_B)\n",
        "        bp = OldTex(\"P(\\\\male)\")\n",
        "        bp[2].set_color(BLUE)\n",
        "        gp_num = OldTex(\"(0.49)\").set_color(MAROON_B)\n",
        "        bp_num = OldTex(\"(0.51)\").set_color(BLUE)\n",
        "        gp_nums = VGroup()\n",
        "        bp_nums = VGroup()\n",
        "        factored = VGroup()\n",
        "        factored_in_nums = VGroup()\n",
        "        for i in range(10):\n",
        "            if i in indices:\n",
        "                num_mob = gp_num.copy()\n",
        "                gp_nums.add(num_mob)\n",
        "                p_mob = gp.copy()\n",
        "            else:\n",
        "                num_mob = bp_num.copy()\n",
        "                bp_nums.add(num_mob)\n",
        "                p_mob = bp.copy()\n",
        "            factored_in_nums.add(num_mob)\n",
        "            factored.add(p_mob)\n",
        "        for group in factored, factored_in_nums:\n",
        "            group.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            group.next_to(prob, DOWN, MED_LARGE_BUFF)\n",
        "        gp_nums.save_state()\n",
        "        bp_nums.save_state()\n",
        "\n",
        "        final_probability = OldTex(\n",
        "            \"(0.49)^6\", \"(0.51)^4\"\n",
        "        )\n",
        "        final_probability.set_color_by_tex(\"0.49\", MAROON_B)\n",
        "        final_probability.set_color_by_tex(\"0.51\", BLUE)\n",
        "        final_probability.next_to(factored_in_nums, DOWN, LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(prob))\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            pattern.copy(), factored,\n",
        "            run_time = 1.5,\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(\n",
        "            factored, factored_in_nums,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        for group, tex in (gp_nums, \"0.49\"), (bp_nums, \"0.51\"):\n",
        "            part = final_probability.get_part_by_tex(tex)\n",
        "            self.play(group.shift, MED_LARGE_BUFF*DOWN)\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    group.copy(), VGroup(VGroup(*part[:-1]))\n",
        "                ),\n",
        "                Write(part[-1])\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(group.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.final_probability = final_probability\n",
        "\n",
        "    def write_total_probability(self):\n",
        "        ten_choose_six = self.count[0].copy()\n",
        "        ten_choose_six.generate_target()\n",
        "        ten_choose_six.target.move_to(self.final_probability)\n",
        "        p_tex = OldTex(\"P(\", \"\\\\text{6 Girls}\", \")\", \"=\")\n",
        "        p_tex.set_color_by_tex(\"Girls\", MAROON_B)\n",
        "        p_tex.next_to(ten_choose_six.target, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(p_tex, run_time = 2),\n",
        "            self.final_probability.next_to, \n",
        "            ten_choose_six.target, RIGHT\n",
        "        )\n",
        "        self.play(MoveToTarget(ten_choose_six))\n",
        "        self.wait()\n",
        "\n",
        "class CycleThroughPatternsForThree(CycleThroughPatterns):\n",
        "    CONFIG = {\n",
        "        \"k\" : 3,\n",
        "        \"n_patterns_shown\" : 20,\n",
        "    }\n",
        "\n",
        "class GeneralBinomialDistributionValues(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 10,\n",
        "        \"alt_n\" : 8,\n",
        "        \"p\" : 0.49,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_chart()\n",
        "        self.show_a_few_values()\n",
        "        self.compare_to_pascal_row()\n",
        "        self.mention_center_concentration()\n",
        "        self.generalize()\n",
        "        self.play_with_p_value()\n",
        "\n",
        "    def add_chart(self):\n",
        "        dist = get_binomial_distribution(self.n, self.p)\n",
        "        values = list(map(dist, list(range(self.n+1))))\n",
        "        chart = BarChart(\n",
        "            values,\n",
        "            bar_names = list(range(self.n+1))\n",
        "        )\n",
        "        chart.to_edge(LEFT)\n",
        "\n",
        "        full_probability = self.get_probability_expression(\n",
        "            \"10\", \"k\", \"(0.49)\", \"(0.51)\"\n",
        "        )\n",
        "        full_probability.next_to(chart, UP, aligned_edge = LEFT)\n",
        "\n",
        "        self.add(chart)\n",
        "\n",
        "        self.chart = chart\n",
        "        self.full_probability = full_probability\n",
        "\n",
        "    def show_a_few_values(self):\n",
        "        chart = self.chart\n",
        "        probabilities = VGroup()\n",
        "        for i, bar in enumerate(chart.bars):\n",
        "            prob = self.get_probability_expression(\n",
        "                \"10\", str(i), \"(0.49)\", \"(0.51)\",\n",
        "                full = False\n",
        "            )\n",
        "            arrow = Arrow(\n",
        "                UP, DOWN, \n",
        "                color = WHITE,\n",
        "                tip_length = 0.15\n",
        "            )\n",
        "            arrow.next_to(bar, UP, SMALL_BUFF)\n",
        "            prob.next_to(arrow, UP, SMALL_BUFF)\n",
        "            ##\n",
        "            prob.shift(LEFT)\n",
        "            prob.shift_onto_screen()\n",
        "            prob.shift(RIGHT)\n",
        "            ##\n",
        "            prob.add(arrow)            \n",
        "            probabilities.add(prob)\n",
        "        shown_prob = probabilities[6].copy()\n",
        "\n",
        "        self.play(FadeIn(shown_prob))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, self.full_probability,\n",
        "            run_time = 4,\n",
        "            lag_ratio = 0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        last_k = 6\n",
        "        for k in 3, 8, 5, 9, 6:\n",
        "            self.play(Transform(\n",
        "                shown_prob, probabilities[k],\n",
        "                path_arc = -np.pi/6 if k > last_k else np.pi/6\n",
        "            ))\n",
        "            self.wait(2)\n",
        "            last_k = k\n",
        "\n",
        "        self.shown_prob = shown_prob\n",
        "\n",
        "    def compare_to_pascal_row(self):\n",
        "        triangle = PascalsTriangle(nrows = 11)\n",
        "        triangle.set_width(6)\n",
        "        triangle.to_corner(UP+RIGHT)\n",
        "        last_row = VGroup(*[\n",
        "            triangle.coords_to_mobs[10][k]\n",
        "            for k in range(11)\n",
        "        ])\n",
        "        ten_choose_ks = VGroup()\n",
        "        for k, mob in enumerate(last_row):\n",
        "            ten_choose_k = OldTex(\"10 \\\\choose %s\"%k)\n",
        "            ten_choose_k.scale(0.5)\n",
        "            ten_choose_k.stretch(0.8, 0)\n",
        "            ten_choose_k.next_to(mob, DOWN)\n",
        "            ten_choose_ks.add(ten_choose_k)\n",
        "        ten_choose_ks.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, triangle),\n",
        "            FadeOut(self.shown_prob)\n",
        "        )\n",
        "        self.play(\n",
        "            last_row.set_color_by_gradient, BLUE, YELLOW,\n",
        "            Write(ten_choose_ks, run_time = 2)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ApplyWave(self.chart.bars, direction = UP))\n",
        "        self.play(FocusOn(last_row))\n",
        "        self.play(LaggedStartMap(\n",
        "            ApplyMethod, last_row,\n",
        "            lambda m : (m.scale, 1.2),\n",
        "            rate_func = there_and_back,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.pascals_triangle = triangle\n",
        "        self.ten_choose_ks = ten_choose_ks\n",
        "\n",
        "    def mention_center_concentration(self):\n",
        "        bars = self.chart.bars\n",
        "        bars.generate_target()\n",
        "        bars.save_state()\n",
        "        bars.target.arrange(UP, buff = 0)\n",
        "        bars.target.stretch_to_fit_height(self.chart.height)\n",
        "        bars.target.move_to(\n",
        "            self.chart.x_axis.point_from_proportion(0.05),\n",
        "            DOWN\n",
        "        )\n",
        "        brace = Brace(VGroup(*bars.target[4:7]), RIGHT)\n",
        "        words = brace.get_text(\"Most probability \\\\\\\\ in middle values\")\n",
        "\n",
        "        self.play(MoveToTarget(bars))\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(words)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            bars.restore,\n",
        "            *list(map(FadeOut, [\n",
        "                brace, words, \n",
        "                self.pascals_triangle,\n",
        "                self.ten_choose_ks\n",
        "            ]))\n",
        "        )\n",
        "\n",
        "    def generalize(self):\n",
        "        alt_n = self.alt_n\n",
        "        dist = get_binomial_distribution(alt_n, self.p)\n",
        "        values = list(map(dist, list(range(alt_n + 1))))\n",
        "        alt_chart = BarChart(\n",
        "            values, bar_names = list(range(alt_n + 1))\n",
        "        )\n",
        "        alt_chart.move_to(self.chart)\n",
        "\n",
        "        alt_probs = [\n",
        "            self.get_probability_expression(\"n\", \"k\", \"(0.49)\", \"(0.51)\"),\n",
        "            self.get_probability_expression(\"n\", \"k\", \"p\", \"(1-p)\"),\n",
        "        ]\n",
        "        for prob in alt_probs:\n",
        "            prob.move_to(self.full_probability)\n",
        "\n",
        "        self.play(FocusOn(\n",
        "            self.full_probability.get_part_by_tex(\"choose\")\n",
        "        ))\n",
        "        self.play(\n",
        "            ReplacementTransform(self.chart, alt_chart),\n",
        "            Transform(self.full_probability, alt_probs[0])\n",
        "        )\n",
        "        self.chart = alt_chart\n",
        "        self.wait(2)\n",
        "        self.play(Transform(self.full_probability, alt_probs[1]))\n",
        "        self.wait()\n",
        "\n",
        "    def play_with_p_value(self):\n",
        "        p = self.p\n",
        "        interval = UnitInterval(color = WHITE)\n",
        "        interval.set_width(5)\n",
        "        interval.next_to(self.full_probability, DOWN, LARGE_BUFF)\n",
        "        interval.add_numbers(0, 0.5, 1)\n",
        "        triangle = RegularPolygon(\n",
        "            n=3, start_angle = -np.pi/2,\n",
        "            fill_color = MAROON_B,\n",
        "            fill_opacity = 1,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        triangle.set_height(0.25)\n",
        "        triangle.move_to(interval.number_to_point(p), DOWN)\n",
        "        p_mob = OldTex(\"p\")\n",
        "        p_mob.set_color(MAROON_B)\n",
        "        p_mob.next_to(triangle, UP, SMALL_BUFF)\n",
        "        triangle.add(p_mob)\n",
        "\n",
        "        new_p_values = [0.8, 0.4, 0.2, 0.9, 0.97, 0.6]\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(interval),\n",
        "            Write(triangle, run_time = 1)\n",
        "        )\n",
        "        self.wait()\n",
        "        for new_p in new_p_values:\n",
        "            p = new_p\n",
        "            dist = get_binomial_distribution(self.alt_n, p)\n",
        "            values = list(map(dist, list(range(self.alt_n + 1))))\n",
        "            self.play(\n",
        "                self.chart.change_bar_values, values,\n",
        "                triangle.move_to, interval.number_to_point(p), DOWN\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "    #######\n",
        "\n",
        "    def get_probability_expression(\n",
        "        self, n = \"n\", k = \"k\", p = \"p\", q = \"(1-p)\",\n",
        "        full = True\n",
        "        ):\n",
        "        args = []\n",
        "        if full:\n",
        "            args += [\"P(\", \"\\\\# \\\\text{Girls}\", \"=\", k, \")\", \"=\"]\n",
        "        args += [\n",
        "            \"{%s \\\\choose %s}\"%(n, k),\n",
        "            p, \"^%s\"%k,\n",
        "            q, \"^{%s\"%n, \"-\", \"%s}\"%k,\n",
        "        ]\n",
        "        result = OldTex(*args, arg_separator = \"\")\n",
        "        color_map = {\n",
        "            \"Girls\" : MAROON_B,\n",
        "            n : WHITE,\n",
        "            k : YELLOW,\n",
        "            p : MAROON_B,\n",
        "            q : BLUE,\n",
        "        }\n",
        "        result.set_color_by_tex_to_color_map(color_map)\n",
        "        choose_part = result.get_part_by_tex(\"choose\")\n",
        "        choose_part.set_color(WHITE)\n",
        "        VGroup(*choose_part[1:1+len(n)]).set_color(color_map[n])\n",
        "        VGroup(*choose_part[-1-len(k):-1]).set_color(color_map[k])\n",
        "        return result\n",
        "\n",
        "class PointOutSimplicityOfFormula(TeacherStudentsScene, GeneralBinomialDistributionValues):\n",
        "    def construct(self):\n",
        "        prob = self.get_probability_expression(full = False)\n",
        "        corner = self.teacher.get_corner(UP+LEFT)\n",
        "        prob.next_to(corner, UP, MED_LARGE_BUFF)\n",
        "        prob.save_state()\n",
        "        prob.move_to(corner)\n",
        "        prob.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            prob.restore,\n",
        "            self.teacher.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = prob\n",
        "        )\n",
        "        self.wait()\n",
        "        self.student_says(\n",
        "            \"Simpler than I feared\",\n",
        "            target_mode = \"hooray\",\n",
        "            index = 0,\n",
        "            added_anims = [prob.to_corner, UP+RIGHT]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.teacher_says(\"Due to \\\\\\\\ independence\")\n",
        "        self.wait(2)\n",
        "\n",
        "class CorrectForDependence(NameBinomial):\n",
        "    CONFIG = {\n",
        "        \"flip_indices\" : [3, 6, 8],\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.force_skipping()\n",
        "        self.name_distribution()\n",
        "        self.add_quiz_questions()\n",
        "        self.revert_to_original_skipping_status()\n",
        "\n",
        "    def construct(self):\n",
        "        self.mention_dependence()\n",
        "        self.show_tendency_to_align()\n",
        "        self.adjust_chart()\n",
        "\n",
        "    def mention_dependence(self):\n",
        "        brace = Brace(self.checkmarks, LEFT)\n",
        "        words = brace.get_text(\"What if there's \\\\\\\\ correlation?\")\n",
        "        formula = self.formula\n",
        "        cross = Cross(formula)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "    def show_tendency_to_align(self):\n",
        "        checkmarks = self.checkmarks\n",
        "        arrows = self.arrows\n",
        "        crosses = self.crosses\n",
        "        groups = [\n",
        "            VGroup(*trip)\n",
        "            for trip in zip(checkmarks, arrows, crosses)\n",
        "        ]\n",
        "        top_rect = SurroundingRectangle(groups[0])\n",
        "        top_rect.set_color(GREEN)\n",
        "        indices_to_follow = [1, 4, 5, 7]\n",
        "\n",
        "        self.play(ShowCreation(top_rect))\n",
        "        self.play(*self.get_arrow_flip_anims([0]))\n",
        "        self.wait()\n",
        "        self.play(*self.get_arrow_flip_anims(indices_to_follow))\n",
        "        self.play(FocusOn(self.chart.bars))\n",
        "\n",
        "    def adjust_chart(self):\n",
        "        chart = self.chart\n",
        "        bars = chart.bars\n",
        "        old_bars = bars.copy()\n",
        "        old_bars.generate_target()\n",
        "        bars.generate_target()\n",
        "        for group, vect in (old_bars, LEFT), (bars, RIGHT):\n",
        "            for bar in group.target:\n",
        "                side = bar.get_edge_center(vect)\n",
        "                bar.stretch(0.5, 0)\n",
        "                bar.move_to(side, vect)\n",
        "        for bar in old_bars.target:\n",
        "            bar.set_color(average_color(RED_E, BLACK))\n",
        "\n",
        "        dist = get_binomial_distribution(10, 0.65)\n",
        "        values = np.array(list(map(dist, list(range(11)))))\n",
        "        alt_values = values + 0.1\n",
        "        alt_values[0] -= 0.06\n",
        "        alt_values[1] -= 0.03\n",
        "        alt_values /= sum(alt_values)\n",
        "        arrows = VGroup()\n",
        "        arrow_template = Arrow(\n",
        "            0.5*UP, ORIGIN, buff = 0, \n",
        "            tip_length = 0.15,\n",
        "            color = WHITE\n",
        "        )\n",
        "        for value, alt_value, bar in zip(values, alt_values, bars):\n",
        "            arrow = arrow_template.copy()\n",
        "            if value < alt_value:\n",
        "                arrow.rotate(np.pi, about_point = ORIGIN)\n",
        "            arrow.next_to(bar, UP)\n",
        "            arrows.add(arrow)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(old_bars),\n",
        "            MoveToTarget(bars),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShowCreation, arrows)))\n",
        "        self.play(chart.change_bar_values, alt_values)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_arrow_flip_anims(self, indices):\n",
        "        checkmarks, arrows, crosses = movers = [\n",
        "            VGroup(*[\n",
        "                group[i]\n",
        "                for i in range(len(group))\n",
        "                if i in indices\n",
        "            ])\n",
        "            for group in (self.checkmarks, self.arrows, self.crosses)\n",
        "        ]\n",
        "        for arrow in arrows:\n",
        "            arrow.target = arrow.deepcopy()\n",
        "            arrow.target.rotate(np.pi)\n",
        "        for group in checkmarks, crosses:\n",
        "            for mob, arrow in zip(group, arrows):\n",
        "                mob.generate_target()\n",
        "                c = mob.get_center()\n",
        "                start, end = arrow.target.get_start_and_end()\n",
        "                to_end = get_norm(c - end)\n",
        "                to_start = get_norm(c - start)\n",
        "                if to_end < to_start:\n",
        "                    mob.target.set_fill(opacity = 1)\n",
        "                else:\n",
        "                    mob.target.set_fill(opacity = 0.5)\n",
        "        for checkmark in checkmarks:\n",
        "            checkmark.target.scale(1.2)\n",
        "\n",
        "        kwargs = {\"path_arc\" : np.pi}\n",
        "        if len(indices) > 1:\n",
        "            kwargs.update({\"run_time\" : 2})\n",
        "        return [\n",
        "            LaggedStartMap(\n",
        "                MoveToTarget, mover,\n",
        "                **kwargs\n",
        "            )\n",
        "            for mover in movers\n",
        "        ]\n",
        "\n",
        "class ButWhatsTheAnswer(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"But what's the \\\\\\\\ actual answer?\",\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait()\n",
        "        self.play(self.teacher.change, \"pondering\")\n",
        "        self.wait(3)\n",
        "\n",
        "class PermuteQuizQuestions(Scene):\n",
        "    def construct(self):\n",
        "        quiz = get_quiz(\n",
        "            \"Define ``Brachistochrone''\",\n",
        "            \"Define ``Tautochrone''\",\n",
        "            \"Define ``Cycloid''\",\n",
        "        )\n",
        "        questions = [\n",
        "            VGroup(*q[2:])\n",
        "            for q in quiz.questions\n",
        "        ]\n",
        "        colors = [BLUE, GREEN, RED]\n",
        "        for color, question in zip(colors, questions):\n",
        "            question.set_color(color)\n",
        "        quiz.scale(2)\n",
        "\n",
        "        self.add(quiz)\n",
        "        self.wait()\n",
        "        for m1, m2 in it.combinations(questions, 2):\n",
        "            self.play(\n",
        "                m1.move_to, m2, LEFT,\n",
        "                m2.move_to, m1, LEFT,\n",
        "                path_arc = np.pi\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "class AssumeOrderDoesntMatter(Scene):\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.add_title()\n",
        "        self.show_equality()\n",
        "        self.mention_correlation()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.coming_soon()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\n",
        "            \"Softer simplifying assumption: \" +\\\n",
        "            \"Order doesn't matter\"\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.add(title)\n",
        "        self.title = title\n",
        "\n",
        "    def show_equality(self):\n",
        "        n = 3\n",
        "        prob_groups = VGroup(*[\n",
        "            VGroup(*list(map(\n",
        "                get_probability_of_slot_group,\n",
        "                [t for t in it.product(*[[True, False]]*n) if sum(t) == k]\n",
        "            )))\n",
        "            for k in range(n+1)\n",
        "        ])\n",
        "        for prob_group in prob_groups:\n",
        "            for prob in prob_group[:-1]:\n",
        "                equals = OldTex(\"=\")\n",
        "                equals.next_to(prob, RIGHT)\n",
        "                prob.add(equals)\n",
        "            prob_group.arrange(RIGHT)\n",
        "            max_width = FRAME_WIDTH - 1\n",
        "            if prob_group.get_width() > max_width:\n",
        "                prob_group.set_width(max_width)\n",
        "        prob_groups.arrange(DOWN, buff = 0.7)\n",
        "        prob_groups.next_to(self.title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            prob_groups[1],\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(\n",
        "            VGroup(prob_groups[0], *prob_groups[2:]),\n",
        "            run_time = 3,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.prob_groups = prob_groups\n",
        "\n",
        "    def mention_correlation(self):\n",
        "        assumption_group = VGroup(*self.get_top_level_mobjects())\n",
        "        question = OldTexText(\n",
        "            \"But what is \", \"``correlation''\", \"?\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        question.set_color(BLUE)\n",
        "        question.to_edge(UP)\n",
        "        bottom = question.get_bottom()\n",
        "\n",
        "        self.play(\n",
        "            Write(question),\n",
        "            assumption_group.next_to, bottom, DOWN, LARGE_BUFF\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.assumption_group = assumption_group\n",
        "        self.question = question\n",
        "\n",
        "    def coming_soon(self):\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, self.assumption_group,\n",
        "                lambda m : (m.shift, FRAME_HEIGHT*DOWN),\n",
        "                remover = True,\n",
        "            ),\n",
        "            ApplyMethod(\n",
        "                self.question.center,\n",
        "                rate_func = squish_rate_func(smooth, 0.5, 1),\n",
        "                run_time = 2\n",
        "            )\n",
        "        )\n",
        "\n",
        "        part = self.question.get_part_by_tex(\"correlation\")\n",
        "        brace = Brace(part, UP)\n",
        "        words = brace.get_text(\"Coming soon!\")\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            part.set_color, YELLOW\n",
        "        )\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class FormulaCanBeRediscovered(PointOutSimplicityOfFormula):\n",
        "    def construct(self):\n",
        "        prob = self.get_probability_expression(full = False)\n",
        "        corner = self.teacher.get_corner(UP+LEFT)\n",
        "        prob.next_to(corner, UP, MED_LARGE_BUFF)\n",
        "        brace = Brace(prob, UP)\n",
        "        rediscover = brace.get_text(\"Rediscover\")\n",
        "\n",
        "        self.play(\n",
        "            Write(prob),\n",
        "            self.teacher.change, \"hesitant\", prob\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(rediscover, run_time = 1)\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class CompareTwoSituations(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        randy = self.randy\n",
        "        top_left, top_right = screens = [\n",
        "            ScreenRectangle(height = 3).to_corner(vect)\n",
        "            for vect in (UP+LEFT, UP+RIGHT)\n",
        "        ]\n",
        "        arrow = DoubleArrow(*screens, buff = SMALL_BUFF)\n",
        "        arrow.set_color(BLUE)\n",
        "\n",
        "        for screen, s in zip(screens, [\"left\", \"right\"]):\n",
        "            self.play(\n",
        "                randy.change, \"raise_%s_hand\"%s, screen,\n",
        "                ShowCreation(screen)\n",
        "            )\n",
        "            self.wait(3)\n",
        "        self.play(\n",
        "            randy.change, \"pondering\", arrow,\n",
        "            ShowCreation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def create_pi_creature(self):\n",
        "        self.randy = Randolph().to_edge(DOWN)\n",
        "        return self.randy\n",
        "\n",
        "class SkepticalOfDistributions(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"chart_height\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_binomial()\n",
        "        self.show_alternate_distributions()\n",
        "        self.emphasize_underweighted_tails()\n",
        "\n",
        "    def show_binomial(self):\n",
        "        binomial = self.get_binomial()\n",
        "        binomial.next_to(self.teacher.get_corner(UP+LEFT), UP)\n",
        "        title = OldTexText(\"Probable scores\")\n",
        "        title.scale(0.85)\n",
        "        title.next_to(binomial.bars, UP, 1.5*LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(title, run_time = 1),\n",
        "            FadeIn(binomial, run_time = 1, lag_ratio = 0.5),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        for values in binomial.values_list:\n",
        "            self.play(binomial.change_bar_values, values)\n",
        "            self.wait()\n",
        "        self.student_says(\n",
        "            \"Is that valid?\", target_mode = \"sassy\",\n",
        "            index = 0,\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(self.teacher.change, \"guilty\")\n",
        "        self.wait()\n",
        "\n",
        "        binomial.add(title)\n",
        "        self.binomial = binomial\n",
        "\n",
        "    def show_alternate_distributions(self):\n",
        "        poisson = self.get_poisson()\n",
        "        VGroup(poisson, poisson.title).next_to(\n",
        "            self.students, UP, LARGE_BUFF\n",
        "        ).shift(RIGHT)\n",
        "        gaussian = self.get_gaussian()\n",
        "        VGroup(gaussian, gaussian.title).next_to(\n",
        "            poisson, RIGHT, LARGE_BUFF\n",
        "        )\n",
        "\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(poisson, lag_ratio = 0.5),\n",
        "            RemovePiCreatureBubble(self.students[0]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            self.binomial.scale, 0.5,\n",
        "            self.binomial.to_corner, UP+LEFT,\n",
        "        )\n",
        "        self.play(Write(poisson.title, run_time = 1))\n",
        "        self.play(FadeIn(gaussian, lag_ratio = 0.5))\n",
        "        self.play(Write(gaussian.title, run_time = 1))\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            *[\"sassy\"]*3,\n",
        "            added_anims = [self.teacher.change, \"plain\"]\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.poisson = poisson\n",
        "        self.gaussian = gaussian\n",
        "\n",
        "    def emphasize_underweighted_tails(self):\n",
        "        poisson_arrows = VGroup()\n",
        "        arrow_template = Arrow(\n",
        "            ORIGIN, UP, color = GREEN,\n",
        "            tip_length = 0.15\n",
        "        )\n",
        "        for bar in self.poisson.bars[-4:]:\n",
        "            arrow = arrow_template.copy()\n",
        "            arrow.next_to(bar, UP, SMALL_BUFF)\n",
        "            poisson_arrows.add(arrow)\n",
        "\n",
        "        gaussian_arrows = VGroup()\n",
        "        for prop in 0.2, 0.8:\n",
        "            point = self.gaussian[0][0].point_from_proportion(prop)\n",
        "            arrow = arrow_template.copy()\n",
        "            arrow.next_to(point, UP, SMALL_BUFF)\n",
        "            gaussian_arrows.add(arrow)\n",
        "\n",
        "        for arrows in poisson_arrows, gaussian_arrows:\n",
        "            self.play(\n",
        "                ShowCreation(\n",
        "                    arrows, \n",
        "                    lag_ratio = 0.5,\n",
        "                    run_time = 2\n",
        "                ),\n",
        "                *[\n",
        "                    ApplyMethod(pi.change, \"thinking\", arrows)\n",
        "                    for pi in self.pi_creatures\n",
        "                ]\n",
        "            )\n",
        "            self.wait()\n",
        "        self.wait(2)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_binomial(self):\n",
        "        k_range = list(range(11))\n",
        "        dists = [\n",
        "            get_binomial_distribution(10, p)\n",
        "            for p in (0.2, 0.8, 0.5)\n",
        "        ]\n",
        "        values_list = [\n",
        "            list(map(dist, k_range))\n",
        "            for dist in dists\n",
        "        ]\n",
        "        chart = BarChart(\n",
        "            values = values_list[-1],\n",
        "            bar_names = k_range\n",
        "        )\n",
        "        chart.set_height(self.chart_height)\n",
        "        chart.values_list = values_list\n",
        "        return chart\n",
        "\n",
        "    def get_poisson(self):\n",
        "        k_range = list(range(11))\n",
        "        L = 2\n",
        "        values = [\n",
        "            np.exp(-L) * (L**k) / (scipy.special.gamma(k+1))\n",
        "            for k in k_range\n",
        "        ]\n",
        "        chart = BarChart(\n",
        "            values = values,\n",
        "            bar_names = k_range,\n",
        "            bar_colors = [RED, YELLOW]\n",
        "        )\n",
        "        chart.set_height(self.chart_height)\n",
        "        title = OldTexText(\n",
        "            \"Poisson distribution \\\\\\\\\",\n",
        "            \"$e^{-\\\\lambda}\\\\frac{\\\\lambda^k}{k!}$\"\n",
        "        )\n",
        "        title.scale(0.75)\n",
        "        title.move_to(chart, UP)\n",
        "        title.shift(MED_SMALL_BUFF*RIGHT)\n",
        "        title[0].shift(SMALL_BUFF*UP)\n",
        "        chart.title = title\n",
        "\n",
        "        return chart\n",
        "\n",
        "    def get_gaussian(self):\n",
        "        axes = VGroup(self.binomial.x_axis, self.binomial.y_axis).copy()\n",
        "        graph = FunctionGraph(\n",
        "            lambda x : 5*np.exp(-x**2),\n",
        "            mark_paths_closed = True,\n",
        "            fill_color = BLUE_E,\n",
        "            fill_opacity = 1,\n",
        "            stroke_color = BLUE,\n",
        "        )\n",
        "        graph.set_width(axes.get_width())\n",
        "        graph.move_to(axes[0], DOWN)\n",
        "\n",
        "        title = OldTexText(\n",
        "            \"Gaussian distribution \\\\\\\\ \",\n",
        "            \"$\\\\frac{1}{\\\\sqrt{2\\\\pi \\\\sigma^2}} e^{-\\\\frac{(x-\\\\mu)^2}{2\\\\sigma^2}}$\"\n",
        "        )\n",
        "        title.scale(0.75)\n",
        "        title.move_to(axes, UP)\n",
        "        title.shift(MED_SMALL_BUFF*RIGHT)\n",
        "        title[0].shift(SMALL_BUFF*UP)\n",
        "        result = VGroup(axes, graph)\n",
        "        result.title = title\n",
        "\n",
        "        return result\n",
        "\n",
        "class IndependencePatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali Yahya\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"James Park\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Karan Bhargava\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Markus Persson\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Corey Ogburn\",\n",
        "            \"Ed Kellett\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Amir Fayazi\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"Michael McGuffin\",\n",
        "            \"John Haley\",\n",
        "            \"Mourits de Beer\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Tomohiro Furusawa\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Mark Govea\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"Nils Schneider\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Vecht\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ],\n",
        "    }\n",
        "\n",
        "class Thumbnail(DangerInProbability):\n",
        "    def construct(self):\n",
        "        n, p = 15, 0.5\n",
        "        dist = get_binomial_distribution(n, p)\n",
        "        values = np.array(list(map(dist, list(range(n+1)))))\n",
        "        values *= 2\n",
        "        chart = BarChart(\n",
        "            values = values,\n",
        "            label_y_axis = False,\n",
        "            width = FRAME_WIDTH - 3,\n",
        "            height = 1.5*FRAME_Y_RADIUS\n",
        "        )\n",
        "        chart.to_edge(DOWN)\n",
        "        self.add(chart)\n",
        "\n",
        "\n",
        "        warning = self.get_warning_sign()\n",
        "        warning.set_height(2)\n",
        "        warning.to_edge(UP)\n",
        "        self.add(warning)\n",
        "\n",
        "\n",
        "        words = OldTexText(\"Independence\")\n",
        "        words.scale(2.5)\n",
        "        words.next_to(warning, DOWN)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}