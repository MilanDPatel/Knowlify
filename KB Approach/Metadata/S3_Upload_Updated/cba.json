{
    "topic": "demonstrates the concept of layers of abstraction in computer science, specifically in the context of",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class EnumerableSaveScene(Scene):\n",
        "    def setup(self):\n",
        "        self.save_count = 0\n",
        "\n",
        "    def save_enumerated_image(self):\n",
        "        file_path = self.file_writer.get_image_file_path()\n",
        "        file_path = file_path.replace(\n",
        "            \".png\", \"{:02}.png\".format(self.save_count)\n",
        "        )\n",
        "        self.update_frame(ignore_skipping=True)\n",
        "        image = self.get_image()\n",
        "        image.save(file_path)\n",
        "        self.save_count += 1\n",
        "\n",
        "\n",
        "class LayersOfAbstraction(EnumerableSaveScene):\n",
        "    def construct(self):\n",
        "        self.save_count = 0\n",
        "        # self.add_title()\n",
        "        self.show_layers()\n",
        "        self.show_pairwise_relations()\n",
        "        self.circle_certain_pairs()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Layers of abstraction\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_width(FRAME_WIDTH)\n",
        "        line.next_to(title, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(title, line)\n",
        "\n",
        "    def show_layers(self):\n",
        "        layers = self.layers = self.get_layers()\n",
        "        for layer in layers:\n",
        "            self.add(layer[0])\n",
        "\n",
        "        self.save_enumerated_image()\n",
        "        for layer in layers:\n",
        "            self.add(layer)\n",
        "            self.save_enumerated_image()\n",
        "\n",
        "    def show_pairwise_relations(self):\n",
        "        p1, p2 = [l.get_left() for l in self.layers[2:4]]\n",
        "        down_arrow = Arrow(p2, p1, path_arc=PI)\n",
        "        down_words = OldTexText(\"``For example''\")\n",
        "        down_words.scale(0.8)\n",
        "        down_words.next_to(down_arrow, LEFT)\n",
        "        up_arrow = Arrow(p1, p2, path_arc=-PI)\n",
        "        up_words = OldTexText(\"``In general''\")\n",
        "        up_words.scale(0.8)\n",
        "        up_words.next_to(up_arrow, LEFT)\n",
        "\n",
        "        VGroup(up_words, down_words).set_color(YELLOW)\n",
        "\n",
        "        self.add(down_arrow, down_words)\n",
        "        self.save_enumerated_image()\n",
        "        self.remove(down_arrow, down_words)\n",
        "        self.add(up_arrow, up_words)\n",
        "        self.save_enumerated_image()\n",
        "        self.remove(up_arrow, up_words)\n",
        "\n",
        "    def circle_certain_pairs(self):\n",
        "        layers = self.layers\n",
        "\n",
        "        for l1, l2 in zip(layers, layers[1:]):\n",
        "            group = VGroup(l1, l2)\n",
        "            group.save_state()\n",
        "            layers.save_state()\n",
        "            layers.fade(0.75)\n",
        "            rect = SurroundingRectangle(group)\n",
        "            rect.set_stroke(YELLOW, 5)\n",
        "            group.restore()\n",
        "            self.add(rect)\n",
        "            self.save_enumerated_image()\n",
        "            self.remove(rect)\n",
        "            layers.restore()\n",
        "\n",
        "    #\n",
        "\n",
        "    def get_layers(self):\n",
        "        layers = VGroup(*[\n",
        "            VGroup(Rectangle(height=1, width=5))\n",
        "            for x in range(6)\n",
        "        ])\n",
        "        layers.arrange(UP, buff=0)\n",
        "        layers.set_stroke(GREY, 2)\n",
        "        layers.set_sheen(1, UL)\n",
        "\n",
        "        # Layer 0: Quantities\n",
        "        triangle = Triangle().set_height(0.25)\n",
        "        tri_dots = VGroup(*[Dot(v) for v in triangle.get_vertices()])\n",
        "        dots_rect = VGroup(*[Dot() for x in range(12)])\n",
        "        dots_rect.arrange_in_grid(3, 4, buff=SMALL_BUFF)\n",
        "        for i, color in enumerate([RED, GREEN, BLUE]):\n",
        "            dots_rect[i::4].set_color(color)\n",
        "        pi_chart = VGroup(*[\n",
        "            Sector(start_angle=a, angle=TAU / 3)\n",
        "            for a in np.arange(0, TAU, TAU / 3)\n",
        "        ])\n",
        "        pi_chart.set_fill(opacity=0)\n",
        "        pi_chart.set_stroke(WHITE, 2)\n",
        "        pi_chart[0].set_fill(BLUE, 1)\n",
        "        pi_chart.rotate(PI / 3)\n",
        "        pi_chart.match_height(dots_rect)\n",
        "        quantities = VGroup(tri_dots, dots_rect, pi_chart)\n",
        "        quantities.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        # Layer 1: Numbers\n",
        "        numbers = VGroup(\n",
        "            OldTex(\"3\"),\n",
        "            OldTex(\"3 \\\\times 4\"),\n",
        "            OldTex(\"1 / 3\"),\n",
        "        )\n",
        "        for number, quantity in zip(numbers, quantities):\n",
        "            number.move_to(quantity)\n",
        "\n",
        "        # Layer 2: Algebra\n",
        "        algebra = VGroup(\n",
        "            OldTex(\"x^2 - 1 = (x + 1)(x - 1)\")\n",
        "        )\n",
        "        algebra.set_width(layers.get_width() - MED_LARGE_BUFF)\n",
        "\n",
        "        # Layer 3: Functions\n",
        "        functions = VGroup(\n",
        "            OldTex(\"f(x) = 0\"),\n",
        "            OldTex(\"\\\\frac{df}{dx}\"),\n",
        "        )\n",
        "        functions.set_height(layers[0].get_height() - 2 * SMALL_BUFF)\n",
        "        functions.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        # functions.match_width(algebra)\n",
        "\n",
        "        # Layer 4: Vector space\n",
        "        t2c_map = {\n",
        "            \"\\\\textbf{v}\": YELLOW,\n",
        "            \"\\\\textbf{w}\": PINK,\n",
        "        }\n",
        "        vector_spaces = VGroup(\n",
        "            OldTex(\n",
        "                \"\\\\textbf{v} + \\\\textbf{w} =\"\n",
        "                \"\\\\textbf{w} + \\\\textbf{v}\",\n",
        "                tex_to_color_map=t2c_map,\n",
        "            ),\n",
        "            OldTex(\n",
        "                \"s(\\\\textbf{v} + \\\\textbf{w}) =\"\n",
        "                \"s\\\\textbf{v} + s\\\\textbf{w}\",\n",
        "                tex_to_color_map=t2c_map,\n",
        "            ),\n",
        "        )\n",
        "        vector_spaces.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        vector_spaces.set_height(layers[0].get_height() - MED_LARGE_BUFF)\n",
        "        v, w = vectors = VGroup(\n",
        "            Vector([2, 1, 0], color=YELLOW),\n",
        "            Vector([1, 2, 0], color=PINK),\n",
        "        )\n",
        "        vectors.add(DashedLine(v.get_end(), v.get_end() + w.get_vector()))\n",
        "        vectors.add(DashedLine(w.get_end(), w.get_end() + v.get_vector()))\n",
        "        vectors.match_height(vector_spaces)\n",
        "        vectors.next_to(vector_spaces, RIGHT)\n",
        "        vectors.set_stroke(width=2)\n",
        "        # vector_spaces.add(vectors)\n",
        "\n",
        "        inner_product = OldTex(\n",
        "            \"\\\\langle f, g \\\\rangle =\"\n",
        "            \"\\\\int f(x)g(x)dx\"\n",
        "        )\n",
        "        inner_product.match_height(vector_spaces)\n",
        "        inner_product.next_to(vector_spaces, RIGHT)\n",
        "        vector_spaces.add(inner_product)\n",
        "\n",
        "        # Layer 5: Categories\n",
        "        dots = VGroup(Dot(UP), Dot(UR), Dot(RIGHT))\n",
        "        arrows = VGroup(\n",
        "            Arrow(dots[0], dots[1], buff=SMALL_BUFF),\n",
        "            Arrow(dots[1], dots[2], buff=SMALL_BUFF),\n",
        "            Arrow(dots[0], dots[2], buff=SMALL_BUFF),\n",
        "        )\n",
        "        arrows.set_stroke(width=2)\n",
        "        arrow_labels = VGroup(\n",
        "            OldTex(\"m_1\").next_to(arrows[0], UP, SMALL_BUFF),\n",
        "            OldTex(\"m_2\").next_to(arrows[1], RIGHT, SMALL_BUFF),\n",
        "            OldTex(\"m_2 \\\\circ m_1\").rotate(-45 * DEGREES).move_to(\n",
        "                arrows[2]\n",
        "            ).shift(MED_SMALL_BUFF * DL)\n",
        "        )\n",
        "        categories = VGroup(dots, arrows, arrow_labels)\n",
        "        categories.set_height(layers[0].get_height() - MED_SMALL_BUFF)\n",
        "\n",
        "        # Put it all together\n",
        "        all_content = [\n",
        "            quantities, numbers, algebra,\n",
        "            functions, vector_spaces, categories,\n",
        "        ]\n",
        "\n",
        "        for layer, content in zip(layers, all_content):\n",
        "            content.move_to(layer)\n",
        "            layer.add(content)\n",
        "            layer.content = content\n",
        "\n",
        "        layer_titles = VGroup(*map(TexText, [\n",
        "            \"Quantities\",\n",
        "            \"Numbers\",\n",
        "            \"Algebra\",\n",
        "            \"Functions\",\n",
        "            \"Vector spaces\",\n",
        "            \"Categories\",\n",
        "        ]))\n",
        "        for layer, title in zip(layers, layer_titles):\n",
        "            title.next_to(layer, RIGHT)\n",
        "            layer.add(title)\n",
        "            layer.title = title\n",
        "        layers.titles = layer_titles\n",
        "\n",
        "        layers.center()\n",
        "        layers.to_edge(DOWN)\n",
        "        layers.shift(0.5 * RIGHT)\n",
        "        return layers\n",
        "\n",
        "\n",
        "class DifferenceOfSquares(Scene):\n",
        "    def construct(self):\n",
        "        squares = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Square()\n",
        "                for x in range(8)\n",
        "            ]).arrange(RIGHT, buff=0)\n",
        "            for y in range(8)\n",
        "        ]).arrange(DOWN, buff=0)\n",
        "        squares.set_height(4)\n",
        "        squares.set_stroke(BLUE, 3)\n",
        "        squares.set_fill(BLUE, 0.5)\n",
        "\n",
        "        last_row_parts = VGroup()\n",
        "        for row in squares[-3:]:\n",
        "            row[-3:].set_color(RED)\n",
        "            row[:-3].set_color(BLUE_B)\n",
        "            last_row_parts.add(row[:-3])\n",
        "        squares.to_edge(LEFT)\n",
        "\n",
        "        arrow = Vector(RIGHT, color=WHITE)\n",
        "        arrow.shift(1.5 * LEFT)\n",
        "        squares.next_to(arrow, LEFT)\n",
        "\n",
        "        new_squares = squares[:-3].copy()\n",
        "        new_squares.next_to(arrow, RIGHT)\n",
        "        new_squares.align_to(squares, UP)\n",
        "\n",
        "        x1 = OldTex(\"x\").set_color(BLUE)\n",
        "        x2 = x1.copy()\n",
        "        x1.next_to(squares, UP)\n",
        "        x2.next_to(squares, LEFT)\n",
        "        y1 = OldTex(\"y\").set_color(RED)\n",
        "        y2 = y1.copy()\n",
        "        y1.next_to(squares[-2], RIGHT)\n",
        "        y2.next_to(squares[-1][-2], DOWN)\n",
        "\n",
        "        xpy = OldTex(\"x\", \"+\", \"y\")\n",
        "        xmy = OldTex(\"x\", \"-\", \"y\")\n",
        "        for mob in xpy, xmy:\n",
        "            mob[0].set_color(BLUE)\n",
        "            mob[2].set_color(RED)\n",
        "        xpy.next_to(new_squares, UP)\n",
        "        # xmy.rotate(90 * DEGREES)\n",
        "        xmy.next_to(new_squares, RIGHT)\n",
        "        xmy.to_edge(RIGHT)\n",
        "\n",
        "        self.add(squares, x1, x2, y1, y2)\n",
        "        self.play(\n",
        "            ReplacementTransform(\n",
        "                squares[:-3].copy().set_fill(opacity=0),\n",
        "                new_squares\n",
        "            ),\n",
        "            ShowCreation(arrow),\n",
        "            lag_ratio=0,\n",
        "        )\n",
        "        last_row_parts = last_row_parts.copy()\n",
        "        last_row_parts.save_state()\n",
        "        last_row_parts.set_fill(opacity=0)\n",
        "        self.play(\n",
        "            last_row_parts.restore,\n",
        "            last_row_parts.rotate, -90 * DEGREES,\n",
        "            last_row_parts.next_to, new_squares, RIGHT, {\"buff\": 0},\n",
        "            lag_ratio=0,\n",
        "        )\n",
        "        self.play(Write(xmy), Write(xpy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Lightbulbs(EnumerableSaveScene):\n",
        "    def construct(self):\n",
        "        dots = VGroup(*[Dot() for x in range(4)])\n",
        "        dots.set_height(0.5)\n",
        "        dots.arrange(RIGHT, buff=2)\n",
        "        dots.set_fill(opacity=0)\n",
        "        dots.set_stroke(width=2, color=WHITE)\n",
        "        dot_radius = dots[0].get_width() / 2\n",
        "\n",
        "        connections = VGroup()\n",
        "        for d1, d2 in it.product(dots, dots):\n",
        "            line = Line(\n",
        "                d1.get_center(),\n",
        "                d2.get_center(),\n",
        "                path_arc=30 * DEGREES,\n",
        "                buff=dot_radius,\n",
        "                color=YELLOW,\n",
        "            )\n",
        "            connections.add(line)\n",
        "\n",
        "        lower_dots = dots[:3].copy()\n",
        "        lower_dots.next_to(dots, DOWN, buff=2)\n",
        "        lower_lines = VGroup(*[\n",
        "            Line(d.get_center(), ld.get_center(), buff=dot_radius)\n",
        "            for d, ld in it.product(dots, lower_dots[1:])\n",
        "        ])\n",
        "        lower_lines.match_style(connections)\n",
        "\n",
        "        top_dot = dots[0].copy()\n",
        "        top_dot.next_to(dots, UP, buff=2)\n",
        "\n",
        "        top_lines = VGroup(*[\n",
        "            Line(d.get_center(), top_dot.get_center(), buff=dot_radius)\n",
        "            for d in dots\n",
        "        ])\n",
        "        top_lines.match_style(connections)\n",
        "\n",
        "        self.add(dots)\n",
        "        self.add(top_dot)\n",
        "        self.save_enumerated_image()\n",
        "        dots.set_fill(YELLOW, 1)\n",
        "        self.save_enumerated_image()\n",
        "        self.add(connections)\n",
        "        self.save_enumerated_image()\n",
        "        self.add(lower_dots)\n",
        "        self.add(lower_lines)\n",
        "        lower_dots[1:].set_fill(YELLOW, 1)\n",
        "        self.save_enumerated_image()\n",
        "\n",
        "        self.add(top_lines)\n",
        "        connections.set_stroke(width=1)\n",
        "        lower_lines.set_stroke(width=1)\n",
        "        top_dot.set_fill(YELLOW, 1)\n",
        "        self.save_enumerated_image()\n",
        "\n",
        "        self.remove(connections)\n",
        "        self.remove(top_lines)\n",
        "        self.remove(lower_lines)\n",
        "        dots.set_fill(opacity=0)\n",
        "        lower_dots.set_fill(opacity=0)\n",
        "\n",
        "\n",
        "class LayersOfLightbulbs(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 1,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        layers = VGroup()\n",
        "        for x in range(6):\n",
        "            n_dots = 5 + (x % 2)\n",
        "            dots = VGroup(*[Dot() for x in range(n_dots)])\n",
        "            dots.scale(2)\n",
        "            dots.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "            dots.set_stroke(WHITE, 2)\n",
        "            for dot in dots:\n",
        "                dot.set_fill(YELLOW, np.random.random())\n",
        "            layers.add(dots)\n",
        "\n",
        "        layers.arrange(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        lines = VGroup()\n",
        "        for l1, l2 in zip(layers, layers[1:]):\n",
        "            for d1, d2 in it.product(l1, l2):\n",
        "                color = interpolate_color(\n",
        "                    YELLOW, GREEN, np.random.random()\n",
        "                )\n",
        "                line = Line(\n",
        "                    d1.get_center(),\n",
        "                    d2.get_center(),\n",
        "                    buff=(d1.get_width() / 2),\n",
        "                    color=color,\n",
        "                    stroke_width=2 * np.random.random(),\n",
        "                )\n",
        "                lines.add(line)\n",
        "\n",
        "        self.add(layers, lines)\n",
        "\n",
        "\n",
        "class Test(Scene):\n",
        "    def construct(self):\n",
        "        # self.play_all_student_changes(\"hooray\")\n",
        "        # self.teacher.change(\"raise_right_hand\")\n",
        "        # self.look_at(3 * UP)\n",
        "        randy = Randolph()\n",
        "        randy.change(\"pondering\")\n",
        "        randy.set_height(6)\n",
        "        randy.look(RIGHT)\n",
        "        self.add(randy)\n",
        "        # eq = OldTex(\"143\", \"=\", \"11 \\\\cdot 13\")\n",
        "        # eq[0].set_color(YELLOW)\n",
        "        # eq.scale(0.7)\n",
        "        # self.add(eq)\n"
    ]
}