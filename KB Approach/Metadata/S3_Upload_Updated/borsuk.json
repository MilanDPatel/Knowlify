{
    "topic": "demonstrates the concept of a necklace made up of interconnected jewels. The",
    "code": [
        "from manim_imports_ext import *\n",
        "from functools import reduce\n",
        "\n",
        "class Jewel(VMobject):\n",
        "    CONFIG = {\n",
        "        \"color\" : WHITE,\n",
        "        \"fill_opacity\" : 0.75,\n",
        "        \"stroke_width\" : 0,\n",
        "        \"height\" : 0.5,\n",
        "        \"num_equator_points\" : 5,\n",
        "        \"sun_vect\" : OUT+LEFT+UP,\n",
        "    }\n",
        "    def init_points(self):\n",
        "        for vect in OUT, IN:\n",
        "            compass_vects = list(compass_directions(self.num_equator_points))\n",
        "            if vect is IN:\n",
        "                compass_vects.reverse()\n",
        "            for vect_pair in adjacent_pairs(compass_vects):\n",
        "                self.add(Polygon(vect, *vect_pair))\n",
        "        self.set_height(self.height)\n",
        "        self.rotate(-np.pi/2-np.pi/24, RIGHT)        \n",
        "        self.rotate(-np.pi/12, UP)\n",
        "        self.submobjects.sort(\n",
        "            key=lambda m: -m1.get_center()[2]\n",
        "        )\n",
        "        return self\n",
        "\n",
        "class Necklace(VMobject):\n",
        "    CONFIG = {\n",
        "        \"width\" : FRAME_WIDTH - 1,\n",
        "        \"jewel_buff\" : MED_SMALL_BUFF,\n",
        "        \"chain_color\" : GREY,\n",
        "        \"default_colors\" : [(4, BLUE), (6, WHITE), (4, GREEN)]\n",
        "    }\n",
        "    def __init__(self, *colors, **kwargs):\n",
        "        digest_config(self, kwargs, locals())\n",
        "        if len(colors) == 0:\n",
        "            self.colors = self.get_default_colors()\n",
        "        VMobject.__init__(self, **kwargs)\n",
        "\n",
        "    def get_default_colors(self):\n",
        "        result = list(it.chain(*[\n",
        "            num*[color]\n",
        "            for num, color in self.default_colors\n",
        "        ]))\n",
        "        random.shuffle(result)\n",
        "        return result\n",
        "\n",
        "    def init_points(self):\n",
        "        jewels = VGroup(*[\n",
        "            Jewel(color = color)\n",
        "            for color in self.colors\n",
        "        ])\n",
        "        jewels.arrange(buff = self.jewel_buff)\n",
        "        jewels.set_width(self.width)\n",
        "        jewels.center()\n",
        "        j_to_j_dist = (jewels[1].get_center()-jewels[0].get_center())[0]\n",
        "\n",
        "        chain = Line(\n",
        "            jewels[0].get_center() + j_to_j_dist*LEFT/2, \n",
        "            jewels[-1].get_center() + j_to_j_dist*RIGHT/2, \n",
        "            color = self.chain_color,\n",
        "        )\n",
        "        self.add(chain, *jewels)\n",
        "        self.chain = chain\n",
        "        self.jewels = jewels\n",
        "\n",
        "################\n",
        "\n",
        "class FromPreviousTopologyVideo(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(FRAME_HEIGHT-2)\n",
        "        title = OldTexText(\"From original ``Who cares about topology'' video\")\n",
        "        title.to_edge(UP)\n",
        "        rect.next_to(title, DOWN)\n",
        "\n",
        "        self.add(title)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "class CheckOutMathologer(PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"logo_height\" : 1.5,\n",
        "        \"screen_height\" : 5,\n",
        "        \"channel_name\" : \"Mathologer\",\n",
        "        \"logo_file\" : \"mathologer_logo\",\n",
        "        \"logo_color\" : None,\n",
        "    }\n",
        "    def construct(self):\n",
        "        logo = self.get_logo()\n",
        "        name = OldTexText(self.channel_name)\n",
        "        name.next_to(logo, RIGHT)\n",
        "\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(self.screen_height)\n",
        "        rect.next_to(logo, DOWN)\n",
        "        rect.to_edge(LEFT)\n",
        "\n",
        "        self.play(\n",
        "            self.get_logo_intro_animation(logo),\n",
        "            self.pi_creature.change_mode, \"hooray\",\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            Write(name)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"happy\")\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_logo(self):\n",
        "        logo = ImageMobject(self.logo_file)\n",
        "        logo.set_height(self.logo_height)\n",
        "        logo.to_corner(UP+LEFT)\n",
        "        if self.logo_color is not None:\n",
        "            logo.set_color(self.logo_color)\n",
        "            logo.stroke_width = 1\n",
        "        return logo\n",
        "\n",
        "    def get_logo_intro_animation(self, logo):\n",
        "        logo.save_state()\n",
        "        logo.shift(DOWN)\n",
        "        logo.set_color(BLACK)\n",
        "        return ApplyMethod(logo.restore)\n",
        "\n",
        "class IntroduceStolenNecklaceProblem(ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"jewel_colors\" : [BLUE, GREEN, WHITE, RED],\n",
        "        \"num_per_jewel\" : [8, 10, 4, 6],\n",
        "        \"num_shuffles\" : 1,\n",
        "        \"necklace_center\" : UP,\n",
        "        \"random_seed\" : 2,\n",
        "        \"forced_binary_choices\" : (0, 1, 0, 1, 0),\n",
        "    }\n",
        "    def construct(self):\n",
        "        random.seed(self.random_seed)\n",
        "        self.add_thieves()\n",
        "        self.write_title()\n",
        "        self.introduce_necklace()\n",
        "        self.divvy_by_cutting_all()\n",
        "        self.divvy_with_n_cuts()\n",
        "        self.shuffle_jewels(self.necklace.jewels)\n",
        "        self.divvy_with_n_cuts()\n",
        "\n",
        "    def add_thieves(self):\n",
        "        thieves = VGroup(\n",
        "            Randolph(),\n",
        "            Mortimer()\n",
        "        )\n",
        "        thieves.arrange(RIGHT, buff = 4*LARGE_BUFF)\n",
        "        thieves.to_edge(DOWN)\n",
        "        thieves[0].make_eye_contact(thieves[1])\n",
        "\n",
        "        self.add(thieves)\n",
        "        self.thieves = thieves\n",
        "\n",
        "    def write_title(self):\n",
        "        title = OldTexText(\"Stolen necklace problem\")\n",
        "        title.to_edge(UP)\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, title)\n",
        "                for pi in self.thieves\n",
        "            ]\n",
        "        )\n",
        "        self.title = title\n",
        "\n",
        "    def introduce_necklace(self):\n",
        "        necklace = self.get_necklace()\n",
        "        jewels = necklace.jewels\n",
        "        jewel_types = self.get_jewels_organized_by_type(jewels)\n",
        "\n",
        "        enumeration_labels = VGroup()\n",
        "        for jewel_type in jewel_types:\n",
        "            num_mob = OldTex(str(len(jewel_type)))\n",
        "            jewel_copy = jewel_type[0].copy().scale(2)\n",
        "            jewel_copy.next_to(num_mob)\n",
        "            label = VGroup(num_mob, jewel_copy)\n",
        "            enumeration_labels.add(label)\n",
        "        enumeration_labels.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        enumeration_labels.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                necklace,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 3\n",
        "            ),\n",
        "            *it.chain(*[\n",
        "                [pi.change_mode, \"conniving\", pi.look_at, necklace]\n",
        "                for pi in self.thieves\n",
        "            ])\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(\n",
        "                jewel.rotate, np.pi/6, UP, \n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "            for jewel in jewels\n",
        "        ])\n",
        "        self.play(Blink(self.thieves[0]))\n",
        "        for jewel_type in jewel_types:\n",
        "            self.play(\n",
        "                jewel_type.shift, 0.2*UP,\n",
        "                rate_func = wiggle\n",
        "            )\n",
        "        self.wait()\n",
        "        for x in range(self.num_shuffles):\n",
        "            self.shuffle_jewels(jewels)\n",
        "        self.play(FadeOut(self.title))\n",
        "        for jewel_type, label in zip(jewel_types, enumeration_labels):\n",
        "            jewel_type.submobjects.sort(\n",
        "                key=lambda m: m1.get\n",
        "            )\n",
        "            jewel_type.save_state()\n",
        "            jewel_type.generate_target()\n",
        "            jewel_type.target.arrange()\n",
        "            jewel_type.target.scale(2)\n",
        "            jewel_type.target.move_to(2*UP)\n",
        "            self.play(\n",
        "                MoveToTarget(jewel_type), \n",
        "                Write(label)\n",
        "            )\n",
        "            self.play(jewel_type.restore)\n",
        "        self.play(Blink(self.thieves[1]))\n",
        "\n",
        "        self.enumeration_labels = enumeration_labels\n",
        "        self.jewel_types = jewel_types\n",
        "\n",
        "    def divvy_by_cutting_all(self):\n",
        "        enumeration_labels = self.enumeration_labels\n",
        "        necklace = self.necklace\n",
        "        jewel_types = self.jewel_types\n",
        "        thieves = self.thieves\n",
        "\n",
        "        both_half_labels = VGroup()\n",
        "        for thief, vect in zip(self.thieves, [LEFT, RIGHT]):\n",
        "            half_labels = VGroup()\n",
        "            for label in enumeration_labels:\n",
        "                tex, jewel = label\n",
        "                num = int(tex.get_tex())\n",
        "                half_label = VGroup(\n",
        "                    OldTex(str(num/2)),\n",
        "                    jewel.copy()\n",
        "                )\n",
        "                half_label.arrange()\n",
        "                half_labels.add(half_label)\n",
        "            half_labels.arrange(DOWN)\n",
        "            half_labels.set_height(thief.get_height())\n",
        "            half_labels.next_to(\n",
        "                thief, vect, \n",
        "                buff = MED_LARGE_BUFF,\n",
        "                aligned_edge = DOWN\n",
        "            )\n",
        "            both_half_labels.add(half_labels)\n",
        "\n",
        "        for half_labels in both_half_labels:\n",
        "            self.play(ReplacementTransform(\n",
        "                enumeration_labels.copy(), \n",
        "                half_labels\n",
        "            ))\n",
        "        self.play(*[ApplyMethod(pi.change_mode, \"pondering\") for pi in thieves])\n",
        "        self.wait()\n",
        "\n",
        "        for type_index, jewel_type in enumerate(jewel_types):\n",
        "            jewel_type.save_state()\n",
        "            jewel_type_copy = jewel_type.copy()\n",
        "            n_jewels = len(jewel_type)\n",
        "            halves = [\n",
        "                VGroup(*jewel_type_copy[:n_jewels/2]),\n",
        "                VGroup(*jewel_type_copy[n_jewels/2:]),\n",
        "            ]\n",
        "            for half, thief, vect in zip(halves, thieves, [RIGHT, LEFT]):\n",
        "                half.arrange(DOWN)\n",
        "                half.next_to(\n",
        "                    thief, vect, \n",
        "                    buff = SMALL_BUFF + type_index*half.get_width(),\n",
        "                    aligned_edge = DOWN\n",
        "                )\n",
        "            self.play(\n",
        "                Transform(jewel_type, jewel_type_copy),\n",
        "                *[\n",
        "                    ApplyMethod(thief.look_at, jewel_type_copy)\n",
        "                    for thief in thieves\n",
        "                ]\n",
        "            )\n",
        "        self.play(*it.chain(*[\n",
        "            [thief.change_mode, \"happy\", thief.look_at, necklace]\n",
        "            for thief in thieves\n",
        "        ]))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            jewel_type.restore\n",
        "            for jewel_type in jewel_types\n",
        "        ])\n",
        "        self.play(*it.chain(*[\n",
        "            [thief.change_mode, \"confused\", thief.look_at, necklace]\n",
        "            for thief in thieves\n",
        "        ]))\n",
        "\n",
        "    def divvy_with_n_cuts(\n",
        "        self, \n",
        "        with_thieves = True, \n",
        "        highlight_groups = True,\n",
        "        show_matching_after_divvying = True,\n",
        "        ):\n",
        "        necklace = self.necklace\n",
        "        jewel_types = self.jewel_types\n",
        "        jewels = sorted(\n",
        "            necklace.jewels, \n",
        "            lambda m1, m2 : cmp(m1.get_center()[0], m2.get_center()[0])\n",
        "        )\n",
        "        slice_indices, binary_choices = self.find_slice_indices(jewels, jewel_types)\n",
        "        subgroups = [\n",
        "            VGroup(*jewels[i1:i2])\n",
        "            for i1, i2 in zip(slice_indices, slice_indices[1:])\n",
        "        ]\n",
        "        buff = (jewels[1].get_left()[0]-jewels[0].get_right()[0])/2\n",
        "        v_lines = VGroup(*[\n",
        "            DashedLine(UP, DOWN).next_to(group, RIGHT, buff = buff)\n",
        "            for group in subgroups[:-1]\n",
        "        ])\n",
        "        strand_groups = [VGroup(), VGroup()]\n",
        "        for group, choice in zip(subgroups, binary_choices):\n",
        "            strand = Line(\n",
        "                group[0].get_center(), group[-1].get_center(),\n",
        "                color = necklace.chain.get_color()\n",
        "            )\n",
        "            strand.add(*group)\n",
        "            strand_groups[choice].add(strand)\n",
        "            self.add(strand)\n",
        "\n",
        "        self.play(ShowCreation(v_lines))\n",
        "        self.play(\n",
        "            FadeOut(necklace.chain),\n",
        "            *it.chain(*[\n",
        "                list(map(Animation, group))\n",
        "                for group in strand_groups\n",
        "            ])\n",
        "        )\n",
        "        for group in strand_groups:\n",
        "            group.save_state()\n",
        "        self.play(\n",
        "            strand_groups[0].shift, UP/2.,\n",
        "            strand_groups[1].shift, DOWN/2.,\n",
        "        )\n",
        "        if with_thieves:\n",
        "            self.play(*it.chain(*[\n",
        "                [thief.change_mode, \"happy\", thief.look_at, self.necklace]\n",
        "                for thief in self.thieves\n",
        "            ]))\n",
        "            self.play(Blink(self.thieves[1]))\n",
        "        else:\n",
        "            self.wait()\n",
        "\n",
        "        if highlight_groups:\n",
        "            for group in strand_groups:\n",
        "                box = Rectangle(\n",
        "                    width = group.get_width()+2*SMALL_BUFF,\n",
        "                    height = group.get_height()+2*SMALL_BUFF,\n",
        "                    stroke_width = 0,\n",
        "                    fill_color = YELLOW,\n",
        "                    fill_opacity = 0.3,\n",
        "                )\n",
        "                box.move_to(group)\n",
        "                self.play(FadeIn(box))\n",
        "                self.wait()\n",
        "                self.play(FadeOut(box))\n",
        "\n",
        "        self.wait()\n",
        "        if show_matching_after_divvying:\n",
        "            for jewel_type in jewel_types:\n",
        "                self.play(\n",
        "                    *[\n",
        "                        ApplyMethod(jewel.scale, 1.5)\n",
        "                        for jewel in jewel_type\n",
        "                    ],\n",
        "                    rate_func = there_and_back,\n",
        "                    run_time = 2\n",
        "                )\n",
        "            self.wait()\n",
        "        self.play(\n",
        "            FadeOut(v_lines),\n",
        "            FadeIn(necklace.chain),\n",
        "            *[\n",
        "                group.restore for group in strand_groups\n",
        "            ]\n",
        "        )\n",
        "        self.remove(*strand_groups)\n",
        "        self.add(necklace)\n",
        "\n",
        "    ########\n",
        "\n",
        "    def get_necklace(self, **kwargs):\n",
        "        colors = reduce(op.add, [\n",
        "            num*[color]\n",
        "            for num, color in zip(self.num_per_jewel, self.jewel_colors)\n",
        "        ])\n",
        "        self.necklace = Necklace(*colors, **kwargs)\n",
        "        self.necklace.shift(self.necklace_center)\n",
        "        return self.necklace\n",
        "\n",
        "    def get_jewels_organized_by_type(self, jewels):\n",
        "        return [\n",
        "            VGroup(*[m for m in jewels if m.get_color() == color])\n",
        "            for color in map(Color, self.jewel_colors)\n",
        "        ]\n",
        "\n",
        "    def shuffle_jewels(self, jewels, run_time = 2, path_arc = np.pi/2, **kwargs):\n",
        "        shuffled_indices = list(range(len(jewels)))\n",
        "        random.shuffle(shuffled_indices)\n",
        "        target_group = VGroup(*[\n",
        "            jewel.copy().move_to(jewels[shuffled_indices[i]])\n",
        "            for i, jewel in enumerate(jewels)\n",
        "        ])\n",
        "        self.play(Transform(\n",
        "            jewels, target_group,\n",
        "            run_time = run_time,            \n",
        "            path_arc = path_arc,\n",
        "            **kwargs\n",
        "        ))\n",
        "\n",
        "    def find_slice_indices(self, jewels, jewel_types):\n",
        "\n",
        "        def jewel_to_type_number(jewel):\n",
        "            for i, jewel_type in enumerate(jewel_types):\n",
        "                if jewel in jewel_type:\n",
        "                    return i\n",
        "            raise Exception(\"Not in any jewel_types\")\n",
        "        type_numbers = list(map(jewel_to_type_number, jewels))\n",
        "\n",
        "        n_types = len(jewel_types)\n",
        "        for slice_indices in it.combinations(list(range(1, len(jewels))), n_types):\n",
        "            slice_indices = [0] + list(slice_indices) + [len(jewels)]\n",
        "            if self.forced_binary_choices is not None:\n",
        "                all_binary_choices = [self.forced_binary_choices]\n",
        "            else:\n",
        "                all_binary_choices = it.product(*[list(range(2))]*(n_types+1))\n",
        "            for binary_choices in all_binary_choices:\n",
        "                subsets = [\n",
        "                    type_numbers[i1:i2]\n",
        "                    for i1, i2 in zip(slice_indices, slice_indices[1:])\n",
        "                ]\n",
        "                left_sets, right_sets = [\n",
        "                    [\n",
        "                        subset\n",
        "                        for subset, index in zip(subsets, binary_choices)\n",
        "                        if index == target_index\n",
        "                    ]\n",
        "                    for target_index in range(2)\n",
        "                ]\n",
        "                flat_left_set = np.array(list(it.chain(*left_sets)))\n",
        "                flat_right_set = np.array(list(it.chain(*right_sets)))\n",
        "\n",
        "\n",
        "                match_array = [\n",
        "                    sum(flat_left_set == n) == sum(flat_right_set == n)\n",
        "                    for n in range(n_types)\n",
        "                ]\n",
        "                if np.all(match_array):\n",
        "                    return slice_indices, binary_choices\n",
        "        raise Exception(\"No fair division found\")\n",
        "\n",
        "class ThingToProve(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        arrow = Arrow(UP, DOWN)\n",
        "        top_words = OldTexText(\"$n$ jewel types\")\n",
        "        top_words.next_to(arrow, UP)\n",
        "        bottom_words = OldTexText(\"\"\"\n",
        "            Fair division possible\n",
        "            with $n$ cuts\n",
        "        \"\"\")\n",
        "        bottom_words.next_to(arrow, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(top_words, run_time = 2),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(\n",
        "            Write(bottom_words, run_time = 2),\n",
        "            self.pi_creature.change_mode, \"pondering\"\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class FiveJewelCase(IntroduceStolenNecklaceProblem):\n",
        "    CONFIG = {\n",
        "        \"jewel_colors\" : [BLUE, GREEN, WHITE, RED, YELLOW],\n",
        "        \"num_per_jewel\" : [6, 4, 4, 2, 8],\n",
        "        \"forced_binary_choices\" : (0, 1, 0, 1, 0, 1),\n",
        "    }\n",
        "    def construct(self):\n",
        "        random.seed(self.random_seed)\n",
        "        self.add(self.get_necklace())\n",
        "        jewels = self.necklace.jewels\n",
        "        self.shuffle_jewels(jewels, run_time = 0)\n",
        "        self.jewel_types = self.get_jewels_organized_by_type(jewels)     \n",
        "        self.add_title()\n",
        "        self.add_thieves()\n",
        "        for thief in self.thieves:\n",
        "            ApplyMethod(thief.change_mode, \"pondering\").update(1)\n",
        "            thief.look_at(self.necklace)\n",
        "        self.divvy_with_n_cuts()\n",
        "\n",
        "    def add_title(self):\n",
        "        n_cuts = len(self.jewel_colors)\n",
        "        title = OldTexText(\n",
        "            \"%d jewel types, %d cuts\"%(n_cuts, n_cuts)\n",
        "        )\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "class SixJewelCase(FiveJewelCase):\n",
        "    CONFIG = {\n",
        "        \"jewel_colors\" : [BLUE, GREEN, WHITE, RED, YELLOW, MAROON_B],\n",
        "        \"num_per_jewel\" : [6, 4, 4, 2, 2, 6],\n",
        "        \"forced_binary_choices\" : (0, 1, 0, 1, 0, 1, 0),\n",
        "    }\n",
        "\n",
        "class DiscussApplicability(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Minimize sharding,\n",
        "            allocate resources evenly\n",
        "        \"\"\")\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class ThreeJewelCase(FiveJewelCase):\n",
        "    CONFIG = {\n",
        "        \"jewel_colors\" : [BLUE, GREEN, WHITE],\n",
        "        \"num_per_jewel\" : [6, 4, 8],\n",
        "        \"forced_binary_choices\" : (0, 1, 0, 1),\n",
        "    }\n",
        "\n",
        "class RepeatedShuffling(IntroduceStolenNecklaceProblem):\n",
        "    CONFIG = {\n",
        "        \"num_shuffles\" : 5,\n",
        "        \"random_seed\" : 3,\n",
        "        \"show_matching_after_divvying\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        random.seed(self.random_seed)\n",
        "        self.add(self.get_necklace())\n",
        "        jewels = self.necklace.jewels\n",
        "        self.jewel_types = self.get_jewels_organized_by_type(jewels)     \n",
        "        self.add_thieves()\n",
        "        for thief in self.thieves:\n",
        "            ApplyMethod(thief.change_mode, \"pondering\").update(1)\n",
        "            thief.look_at(self.necklace)\n",
        "\n",
        "        for x in range(self.num_shuffles):\n",
        "            self.shuffle_jewels(jewels)\n",
        "            self.divvy_with_n_cuts(\n",
        "                show_matching_after_divvying = False\n",
        "            )\n",
        "\n",
        "class NowForTheTopology(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Now for the \\\\\\\\ topology\")\n",
        "        self.play_student_changes(*[\"hooray\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "class ExternallyAnimatedScene(Scene):\n",
        "    def construct(self):\n",
        "        raise Exception(\"Don't actually run this class.\")\n",
        "\n",
        "class SphereOntoPlaneIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class DiscontinuousSphereOntoPlaneIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class WriteWords(Scene):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"\",\n",
        "        \"color\" : WHITE,\n",
        "    }\n",
        "    def construct(self):\n",
        "        words = OldTexText(self.words)\n",
        "        words.set_color(self.color)\n",
        "        words.set_width(FRAME_WIDTH-1)\n",
        "        words.to_edge(DOWN)\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "\n",
        "class WriteNotAllowed(WriteWords):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"Not allowed\",\n",
        "        \"color\" : RED,\n",
        "    }\n",
        "\n",
        "class NonAntipodalCollisionIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AntipodalCollisionIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class WriteBorsukUlam(WriteWords):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"Borsuk-Ulam Theorem\",\n",
        "    }\n",
        "\n",
        "class WriteAntipodal(WriteWords):\n",
        "    CONFIG = {\n",
        "        \"words\" : \"``Antipodal''\",\n",
        "        \"color\" : MAROON_B,\n",
        "    }\n",
        "\n",
        "class ProjectOntoEquatorIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ProjectOntoEquatorWithPolesIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ProjectAntipodalNonCollisionIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ShearThenProjectnOntoEquatorPolesMissIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ShearThenProjectnOntoEquatorAntipodalCollisionIn3D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ClassicExample(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"The classic example...\")\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class AntipodalEarthPoints(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class RotatingEarth(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class TemperaturePressurePlane(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"x_axis_label\" : \"Temperature\",\n",
        "        \"y_axis_label\" : \"Pressure\",\n",
        "        \"graph_origin\" : 2.5*DOWN + 2*LEFT,\n",
        "        \"corner_square_width\" : 4,\n",
        "        \"example_point_coords\" : (2, 5),\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.draw_arrow()\n",
        "        self.add_example_coordinates()\n",
        "        self.wander_continuously()\n",
        "\n",
        "    def draw_arrow(self):\n",
        "        square = Square(\n",
        "            side_length = self.corner_square_width,\n",
        "            stroke_color = WHITE,\n",
        "            stroke_width = 0,\n",
        "        )\n",
        "        square.to_corner(UP+LEFT, buff = 0)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            square.get_right(), \n",
        "            self.coords_to_point(*self.example_point_coords)\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "\n",
        "    def add_example_coordinates(self):\n",
        "        dot = Dot(self.coords_to_point(*self.example_point_coords))\n",
        "        dot.set_color(YELLOW)\n",
        "        tex = OldTex(\"(25^\\\\circ\\\\text{C}, 101 \\\\text{ kPa})\")\n",
        "        tex.next_to(dot, UP+RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(dot))\n",
        "        self.play(Write(tex))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(tex))\n",
        "\n",
        "    def wander_continuously(self):\n",
        "        path = VMobject().set_points_smoothly([\n",
        "            ORIGIN, 2*UP+RIGHT, 2*DOWN+RIGHT,\n",
        "            5*RIGHT, 4*RIGHT+UP, 3*RIGHT+2*DOWN,\n",
        "            DOWN+LEFT, 2*RIGHT\n",
        "        ])\n",
        "        point = self.coords_to_point(*self.example_point_coords)\n",
        "        path.shift(point)\n",
        "\n",
        "        path.set_color(GREEN)\n",
        "\n",
        "        self.play(ShowCreation(path, run_time = 10, rate_func=linear))\n",
        "        self.wait()\n",
        "\n",
        "class AlternateSphereSquishing(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AlternateAntipodalCollision(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AskWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"But...why?\")\n",
        "        self.play_student_changes(\"pondering\", None, \"thinking\")\n",
        "        self.play(self.get_teacher().change_mode, \"happy\")\n",
        "        self.wait(3)\n",
        "\n",
        "class PointOutVSauce(CheckOutMathologer):\n",
        "    CONFIG = {\n",
        "        \"channel_name\" : \"\",\n",
        "        \"logo_file\" : \"Vsauce_logo\",\n",
        "        \"logo_height\" : 1,\n",
        "        \"logo_color\" : GREY,\n",
        "    }\n",
        "    def get_logo(self):\n",
        "        logo = SVGMobject(file_name = self.logo_file)\n",
        "        logo.set_height(self.logo_height)\n",
        "        logo.to_corner(UP+LEFT)\n",
        "        logo.set_stroke(width = 0)\n",
        "        logo.set_fill(GREEN)\n",
        "        logo.sort()\n",
        "        return logo\n",
        "\n",
        "    def get_logo_intro_animation(self, logo):\n",
        "        return DrawBorderThenFill(\n",
        "            logo,\n",
        "            run_time = 2,\n",
        "        )\n",
        "\n",
        "class WalkEquatorPostTransform(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"graph_origin\" : 2.5*DOWN + 2*LEFT,\n",
        "        \"curved_arrow_color\" : WHITE,\n",
        "        \"curved_arrow_radius\" : 3,\n",
        "        \"num_great_arcs\" : 10,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        self.add_curved_arrow()\n",
        "        self.great_arc_images = self.get_great_arc_images()\n",
        "\n",
        "        self.walk_equator()\n",
        "        self.walk_tilted_equator()\n",
        "        self.draw_transverse_curve()\n",
        "        self.walk_transverse_curve()\n",
        "\n",
        "    def add_curved_arrow(self):\n",
        "        arc = Arc(\n",
        "            start_angle = 2*np.pi/3, angle = -np.pi/2, \n",
        "            radius = self.curved_arrow_radius,\n",
        "            color = self.curved_arrow_color\n",
        "        )\n",
        "        arc.add_tip()\n",
        "        arc.move_to(self.coords_to_point(0, 7))\n",
        "\n",
        "        self.add(arc)\n",
        "\n",
        "    def walk_equator(self):\n",
        "        equator = self.great_arc_images[0]\n",
        "        dots = VGroup(Dot(), Dot())\n",
        "        dots.set_color(MAROON_B)\n",
        "        dot_movement = self.get_arc_walk_dot_movement(equator, dots)\n",
        "        dot_movement.update(0)\n",
        "\n",
        "        self.play(ShowCreation(equator, run_time = 3))\n",
        "        self.play(FadeIn(dots[0]))\n",
        "        dots[1].set_fill(opacity = 0)\n",
        "        self.play(dot_movement)\n",
        "        self.play(dots[1].set_fill, None, 1)\n",
        "        self.play(dot_movement)\n",
        "        self.play(dot_movement)\n",
        "\n",
        "        proportion = equator.collision_point_proportion\n",
        "        self.play(self.get_arc_walk_dot_movement(\n",
        "            equator, dots,\n",
        "            rate_func = lambda t : 2*proportion*smooth(t)\n",
        "        ))\n",
        "        v_line = DashedLine(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        v_line.shift(dots.get_center()[0]*RIGHT)\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(v_line))\n",
        "\n",
        "        dots.save_state()\n",
        "        equator.save_state()\n",
        "        self.play(\n",
        "            equator.fade,\n",
        "            dots.fade\n",
        "        )\n",
        "\n",
        "        self.first_dots = dots\n",
        "\n",
        "    def walk_tilted_equator(self):\n",
        "        equator = self.great_arc_images[0]\n",
        "        tilted_eq = self.great_arc_images[1]\n",
        "\n",
        "        dots = VGroup(Dot(), Dot())\n",
        "        dots.set_color(MAROON_B)\n",
        "        dot_movement = self.get_arc_walk_dot_movement(tilted_eq, dots)\n",
        "        dot_movement.update(0)\n",
        "\n",
        "        self.play(ReplacementTransform(equator.copy(), tilted_eq))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(dots))\n",
        "        self.play(dot_movement)\n",
        "\n",
        "        proportion = tilted_eq.collision_point_proportion\n",
        "        self.play(self.get_arc_walk_dot_movement(\n",
        "            tilted_eq, dots,\n",
        "            rate_func = lambda t : 2*proportion*smooth(t)\n",
        "        ))\n",
        "        v_line = DashedLine(FRAME_Y_RADIUS*UP, FRAME_Y_RADIUS*DOWN)\n",
        "        v_line.shift(dots.get_center()[0]*RIGHT)\n",
        "        self.play(ShowCreation(v_line))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(v_line))\n",
        "        self.play(*list(map(FadeOut, [tilted_eq, dots])))\n",
        "\n",
        "    def draw_transverse_curve(self):\n",
        "        transverse_curve = self.get_transverse_curve(self.great_arc_images)\n",
        "        dots = self.first_dots\n",
        "        equator = self.great_arc_images[0]\n",
        "\n",
        "        self.play(dots.restore)\n",
        "        equator.restore()\n",
        "        self.great_arc_images.fade()\n",
        "\n",
        "        target_arcs = list(self.great_arc_images[1:])\n",
        "        target_dots = []\n",
        "        for arc in target_arcs:\n",
        "            new_dots = dots.copy()\n",
        "            for dot, point in zip(new_dots, arc.x_collision_points):\n",
        "                dot.move_to(point)\n",
        "            target_dots.append(new_dots)\n",
        "\n",
        "        alt_eq = equator.copy()\n",
        "        alt_eq.set_points(list(reversed(alt_eq.get_points())))\n",
        "        alt_dots = dots.copy()\n",
        "        alt_dots.submobjects.reverse()\n",
        "        target_arcs += [alt_eq, alt_eq.copy()]\n",
        "        target_dots += [alt_dots, alt_dots.copy()]\n",
        "\n",
        "        equator_transform = Succession(*[\n",
        "            Transform(equator, arc, rate_func=linear)\n",
        "            for arc in target_arcs\n",
        "        ])\n",
        "        dots_transform = Succession(*[\n",
        "            Transform(dots, target, rate_func=linear)\n",
        "            for target in target_dots\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(transverse_curve, lag_ratio = 0),\n",
        "            equator_transform,\n",
        "            dots_transform,\n",
        "            run_time = 10,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def walk_transverse_curve(self):\n",
        "        transverse_curve = self.get_transverse_curve(self.great_arc_images)\n",
        "        dots = self.first_dots\n",
        "\n",
        "        def dot_update(dots, alpha):\n",
        "            for dot, curve in zip(dots, transverse_curve):\n",
        "                dot.move_to(curve.point_from_proportion(alpha))\n",
        "            return dots\n",
        "\n",
        "        for x in range(2):\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(dots, dot_update),\n",
        "                run_time = 4\n",
        "            )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(dots, dot_update),\n",
        "            run_time = 4,\n",
        "            rate_func = lambda t : 0.455*smooth(t)\n",
        "        )\n",
        "        self.play(\n",
        "            dots.set_color, YELLOW,\n",
        "            dots.scale, 1.2,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #######\n",
        "\n",
        "    def get_arc_walk_dot_movement(self, arc, dots, **kwargs):\n",
        "        def dot_update(dots, alpha):\n",
        "            dots[0].move_to(arc.point_from_proportion(0.5*alpha))\n",
        "            dots[1].move_to(arc.point_from_proportion(0.5+0.5*alpha))\n",
        "            return dots\n",
        "        if \"run_time\" not in kwargs:\n",
        "            kwargs[\"run_time\"] = 5\n",
        "        return UpdateFromAlphaFunc(dots, dot_update, **kwargs)\n",
        "\n",
        "    def sphere_to_plane(self, point):\n",
        "        x, y, z = point\n",
        "        return np.array([\n",
        "            x - 2*x*z + y + 1,\n",
        "            y+0.5*y*np.cos(z*np.pi),\n",
        "            0\n",
        "        ])\n",
        "\n",
        "    def sphere_point(self, portion_around_equator, equator_tilt = 0):\n",
        "        theta = portion_around_equator*2*np.pi\n",
        "        point = np.cos(theta)*RIGHT + np.sin(theta)*UP\n",
        "        phi = equator_tilt*np.pi\n",
        "        return rotate_vector(point, phi, RIGHT)\n",
        "\n",
        "    def get_great_arc_images(self):\n",
        "        curves = VGroup(*[\n",
        "            ParametricCurve(\n",
        "                lambda t : self.sphere_point(t, s)\n",
        "            ).apply_function(self.sphere_to_plane)\n",
        "            for s in np.arange(0, 1, 1./self.num_great_arcs)\n",
        "            # for s in [0]\n",
        "        ])\n",
        "        curves.set_color(YELLOW)\n",
        "        curves[0].set_color(RED)\n",
        "        for curve in curves:\n",
        "            antipodal_x_diff = lambda x : \\\n",
        "                curve.point_from_proportion(x+0.5)[0]-\\\n",
        "                curve.point_from_proportion(x)[0]\n",
        "            last_x = 0                \n",
        "            last_sign = np.sign(antipodal_x_diff(last_x))\n",
        "            for x in np.linspace(0, 0.5, 100):\n",
        "                sign = np.sign(antipodal_x_diff(x))\n",
        "                if sign != last_sign:\n",
        "                    mean = np.mean([last_x, x])\n",
        "                    curve.x_collision_points = [\n",
        "                        curve.point_from_proportion(mean),\n",
        "                        curve.point_from_proportion(mean+0.5),\n",
        "                    ]\n",
        "                    curve.collision_point_proportion = mean\n",
        "                    break\n",
        "                last_x = x\n",
        "                last_sign = sign\n",
        "        return curves\n",
        "\n",
        "    def get_transverse_curve(self, gerat_arc_images):\n",
        "        points = list(it.chain(*[\n",
        "            [\n",
        "                curve.x_collision_points[i]\n",
        "                for curve in gerat_arc_images\n",
        "            ]\n",
        "            for i in (0, 1)\n",
        "        ]))\n",
        "        full_curve = VMobject(close_new_points = True)\n",
        "        full_curve.set_points_smoothly(points + [points[0]])\n",
        "        full_curve.set_color(MAROON_B)\n",
        "        first_half = full_curve.copy().pointwise_become_partial(\n",
        "            full_curve, 0, 0.5\n",
        "        )\n",
        "        second_half = first_half.copy().rotate(np.pi, RIGHT)\n",
        "        broken_curve = VGroup(first_half, second_half)\n",
        "        return broken_curve\n",
        "\n",
        "class WalkAroundEquatorPreimage(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class WalkTiltedEquatorPreimage(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class FormLoopTransverseToEquator(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class AntipodalWalkAroundTransverseLoop(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class MentionGenerality(TeacherStudentsScene, ThreeDScene):\n",
        "    def construct(self):\n",
        "        necklace = Necklace(width = FRAME_X_RADIUS)\n",
        "        necklace.shift(2*UP)\n",
        "        necklace.to_edge(RIGHT)\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        arrow.scale(2)\n",
        "        arrow.next_to(necklace, LEFT)\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(arrow, UP)\n",
        "        arrow.add(q_marks)\n",
        "\n",
        "        formula = OldTex(\"f(\\\\textbf{x}) = f(-\\\\textbf{x})\")\n",
        "        formula.next_to(self.get_students(), UP, buff = LARGE_BUFF)\n",
        "        formula.to_edge(LEFT, buff = LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change_mode, \"raise_right_hand\",\n",
        "            self.teacher.look_at, arrow\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(necklace, run_time = 2, lag_ratio = 0.5),\n",
        "            Write(arrow),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, arrow)\n",
        "                for pi in self.get_pi_creatures()\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"erm\", \"confused\")\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.look_at, arrow)\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.play(Write(formula))\n",
        "        self.wait(3)\n",
        "\n",
        "class SimpleSphere(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class PointsIn3D(Scene):\n",
        "    CONFIG = {\n",
        "        # \"colors\" : [RED, GREEN, BLUE],\n",
        "        \"colors\" : color_gradient([GREEN, BLUE], 3),\n",
        "    }\n",
        "    def construct(self):\n",
        "        sphere_def = OldTexText(\n",
        "            \"\\\\doublespacing Sphere in 3D: All\", \"$(x_1, x_2, x_3)$\\\\\\\\\", \n",
        "            \"such that\", \"$x_1^2 + x_2^2 + x_3^2 = 1$\",\n",
        "            alignment = \"\",\n",
        "        )\n",
        "        sphere_def.next_to(ORIGIN, DOWN)\n",
        "        for index, subindex_list in (1, [1, 2, 4, 5, 7, 8]), (3, [0, 2, 4, 6, 8, 10]):\n",
        "            colors = np.repeat(self.colors, 2)\n",
        "            for subindex, color in zip(subindex_list, colors):\n",
        "                sphere_def[index][subindex].set_color(color)\n",
        "\n",
        "        point_ex = OldTexText(\n",
        "            \"For example, \", \n",
        "            \"(\", \"0.41\", \", \", \"-0.58\", \", \", \"0.71\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        for index, color in zip([2, 4, 6], self.colors):\n",
        "            point_ex[index].set_color(color)\n",
        "        point_ex.scale(0.8)\n",
        "        point_ex.next_to(\n",
        "            sphere_def[1], UP+RIGHT,\n",
        "            buff = 1.5*LARGE_BUFF\n",
        "        )\n",
        "        point_ex.shift_onto_screen()\n",
        "        arrow = Arrow(sphere_def[1].get_top(), point_ex.get_bottom())\n",
        "\n",
        "        self.play(Write(sphere_def[1]))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(point_ex))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Animation(sphere_def[1].copy(), remover = True),\n",
        "            Write(sphere_def),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class AntipodalPairToBeGivenCoordinates(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class WritePointCoordinates(Scene):\n",
        "    CONFIG = {\n",
        "        \"colors\" : color_gradient([GREEN, BLUE], 3),\n",
        "        \"corner\" : DOWN+RIGHT,\n",
        "    }\n",
        "    def construct(self):\n",
        "        coords = self.get_coords()\n",
        "        arrow = Arrow(\n",
        "            -self.corner, self.corner, \n",
        "            stroke_width = 8,\n",
        "            color = MAROON_B\n",
        "        )\n",
        "        x_component = self.corner[0]*RIGHT\n",
        "        y_component = self.corner[1]*UP\n",
        "        arrow.next_to(\n",
        "            coords.get_edge_center(y_component), \n",
        "            y_component, \n",
        "            aligned_edge = -x_component,\n",
        "            buff = MED_SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        group = VGroup(coords, arrow)\n",
        "        group.scale(2)        \n",
        "        group.to_corner(self.corner)\n",
        "\n",
        "\n",
        "        self.play(FadeIn(coords))\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def get_coords(self):\n",
        "        coords = OldTex(\n",
        "            \"(\", \"0.41\", \", \", \"-0.58\", \", \", \"0.71\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        for index, color in zip([1, 3, 5], self.colors):\n",
        "            coords[index].set_color(color)\n",
        "        return coords\n",
        "\n",
        "class WriteAntipodalCoordinates(WritePointCoordinates):\n",
        "    CONFIG = {\n",
        "        \"corner\" : UP+LEFT,\n",
        "        \"sign_color\" : RED,\n",
        "    }\n",
        "\n",
        "    def get_coords(self):\n",
        "        coords = OldTex(\n",
        "            \"(\", \"-\", \"0.41\", \", \", \"+\", \"0.58\", \", \", \"-\", \"0.71\", \")\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        for index, color in zip([2, 5, 8], self.colors):\n",
        "            coords[index].set_color(color)\n",
        "            coords[index-1].set_color(self.sign_color)\n",
        "        return coords\n",
        "\n",
        "class GeneralizeBorsukUlam(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_dims\" : 3,\n",
        "        \"boundary_colors\" : [GREEN_B, BLUE],\n",
        "        \"output_boundary_color\" : [MAROON_B, YELLOW],\n",
        "        \"negative_color\" : RED,\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.colors = color_gradient(self.boundary_colors, self.n_dims)\n",
        "\n",
        "    def construct(self):\n",
        "        sphere_set = self.get_sphere_set()\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        f = OldTex(\"f\")\n",
        "        output_space = self.get_output_space()\n",
        "        equation = self.get_equation()\n",
        "\n",
        "        sphere_set.to_corner(UP+LEFT)\n",
        "        arrow.next_to(sphere_set, RIGHT)\n",
        "        f.next_to(arrow, UP)\n",
        "        output_space.next_to(arrow, RIGHT)\n",
        "        equation.next_to(sphere_set, DOWN, buff = LARGE_BUFF)\n",
        "        equation.to_edge(RIGHT)\n",
        "        lhs = VGroup(*equation[:2])\n",
        "        eq = equation[2]\n",
        "        rhs = VGroup(*equation[3:])\n",
        "\n",
        "        self.play(FadeIn(sphere_set))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(f)\n",
        "        )\n",
        "        self.play(Write(output_space))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(lhs))\n",
        "        self.play(\n",
        "            ReplacementTransform(lhs.copy(), rhs),\n",
        "            Write(eq)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_condition(self):\n",
        "        squares = list(map(Tex, [\n",
        "            \"x_%d^2\"%d\n",
        "            for d in range(1, 1+self.n_dims)\n",
        "        ]))\n",
        "        for square, color in zip(squares, self.colors):\n",
        "            square[0].set_color(color)\n",
        "            square[-1].set_color(color)\n",
        "        plusses = [Tex(\"+\") for x in range(self.n_dims-1)]\n",
        "        plusses += [Tex(\"=1\")]\n",
        "        condition = VGroup(*it.chain(*list(zip(squares, plusses))))\n",
        "        condition.arrange(RIGHT)\n",
        "\n",
        "        return condition\n",
        "\n",
        "    def get_tuple(self):\n",
        "        mid_parts = list(it.chain(*[\n",
        "            [\"x_%d\"%d, \",\"]\n",
        "            for d in range(1, self.n_dims)\n",
        "        ]))\n",
        "        tup = OldTex(*[\"(\"] + mid_parts + [\"x_%d\"%self.n_dims, \")\"])\n",
        "        for index, color in zip(it.count(1, 2), self.colors):\n",
        "            tup[index].set_color(color)\n",
        "\n",
        "        return tup\n",
        "\n",
        "    def get_negative_tuple(self):\n",
        "        mid_parts = list(it.chain(*[\n",
        "            [\"-\", \"x_%d\"%d, \",\"]\n",
        "            for d in range(1, self.n_dims)\n",
        "        ]))\n",
        "        tup = OldTex(*[\"(\"] + mid_parts + [\"-\", \"x_%d\"%self.n_dims, \")\"])\n",
        "        for index, color in zip(it.count(1, 3), self.colors):\n",
        "            tup[index].set_color(self.negative_color)\n",
        "            tup[index+1].set_color(color)\n",
        "\n",
        "        return tup\n",
        "\n",
        "    def get_output_space(self):\n",
        "        return OldTexText(\"%dD space\"%(self.n_dims-1))\n",
        "        # n_dims = self.n_dims-1\n",
        "        # colors = color_gradient(self.output_boundary_color, n_dims)\n",
        "        # mid_parts = list(it.chain(*[\n",
        "        #     [\"y_%d\"%d, \",\"]\n",
        "        #     for d in range(1, n_dims)\n",
        "        # ]))\n",
        "        # tup = OldTex(*[\"(\"] + mid_parts + [\"y_%d\"%n_dims, \")\"])\n",
        "        # for index, color in zip(it.count(1, 2), colors):\n",
        "        #     tup[index].set_color(color)\n",
        "\n",
        "        # return tup\n",
        "\n",
        "    def get_equation(self):\n",
        "        tup = self.get_tuple()\n",
        "        neg_tup = self.get_negative_tuple()\n",
        "        f1, f2 = [Tex(\"f\") for x in range(2)]\n",
        "        equals = OldTex(\"=\")\n",
        "        equation = VGroup(f1, tup, equals, f2, neg_tup)\n",
        "        equation.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "\n",
        "        return equation\n",
        "\n",
        "    def get_sphere_set(self):\n",
        "        tup = self.get_tuple()\n",
        "        such_that = OldTexText(\"such that\")\n",
        "        such_that.next_to(tup, RIGHT)\n",
        "        condition = self.get_condition()\n",
        "        condition.next_to(\n",
        "            tup, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        group = VGroup(tup, such_that, condition)\n",
        "        l_brace = Brace(group, LEFT)\n",
        "        r_brace = Brace(group, RIGHT)\n",
        "        group.add(l_brace, r_brace)\n",
        "\n",
        "        return group\n",
        "\n",
        "# class FiveDBorsukUlam(GeneralizeBorsukUlam):\n",
        "#     CONFIG = {\n",
        "#         \"n_dims\" : 5,\n",
        "#     }\n",
        "\n",
        "class MentionMakingNecklaceProblemContinuous(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Translate this into\n",
        "            a continuous problem.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\"confused\", \"pondering\", \"erm\")\n",
        "        self.wait(3)\n",
        "\n",
        "class MakeTwoJewelCaseContinuous(IntroduceStolenNecklaceProblem):\n",
        "    CONFIG = {\n",
        "        \"jewel_colors\" : [BLUE, GREEN],\n",
        "        \"num_per_jewel\" : [8, 10],\n",
        "        \"random_seed\" : 2,\n",
        "        \"forced_binary_choices\" : (0, 1, 0),\n",
        "        \"show_matching_after_divvying\" : True,\n",
        "        \"necklace_center\" : ORIGIN,\n",
        "        \"necklace_width\" : FRAME_WIDTH - 3,\n",
        "        \"random_seed\" : 0,\n",
        "        \"num_continuous_division_searches\" : 4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        random.seed(self.random_seed)\n",
        "        self.introduce_necklace()\n",
        "        self.divvy_with_n_cuts()\n",
        "        self.identify_necklace_with_unit_interval()\n",
        "        self.color_necklace()\n",
        "        self.find_continuous_fair_division()\n",
        "        self.show_continuous_fair_division()\n",
        "        self.set_color_continuous_groups()\n",
        "        self.mention_equivalence_to_discrete_case()\n",
        "        self.shift_divide_off_tick_marks()\n",
        "\n",
        "    def introduce_necklace(self):\n",
        "        self.get_necklace(\n",
        "            width = self.necklace_width,\n",
        "        )\n",
        "        self.play(FadeIn(\n",
        "            self.necklace,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.shuffle_jewels(self.necklace.jewels)\n",
        "        jewel_types = self.get_jewels_organized_by_type(\n",
        "            self.necklace.jewels\n",
        "        )\n",
        "        self.wait()\n",
        "        self.count_jewel_types(jewel_types)\n",
        "        self.wait()\n",
        "\n",
        "        self.jewel_types = jewel_types\n",
        "\n",
        "    def count_jewel_types(self, jewel_types):\n",
        "        enumeration_labels = VGroup()\n",
        "        for jewel_type in jewel_types:\n",
        "            num_mob = OldTex(str(len(jewel_type)))\n",
        "            jewel_copy = jewel_type[0].copy()\n",
        "            # jewel_copy.set_height(num_mob.get_height())\n",
        "            jewel_copy.next_to(num_mob)\n",
        "            label = VGroup(num_mob, jewel_copy)\n",
        "            enumeration_labels.add(label)\n",
        "        enumeration_labels.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        enumeration_labels.to_edge(UP)\n",
        "\n",
        "        for jewel_type, label in zip(jewel_types, enumeration_labels):\n",
        "            jewel_type.sort()\n",
        "         \n",
        "            jewel_type.save_state()\n",
        "            jewel_type.generate_target()\n",
        "            jewel_type.target.arrange()\n",
        "            jewel_type.target.move_to(2*UP)\n",
        "            self.play(\n",
        "                MoveToTarget(jewel_type), \n",
        "                Write(label)\n",
        "            )\n",
        "            self.play(jewel_type.restore)\n",
        "\n",
        "    def divvy_with_n_cuts(self):\n",
        "        IntroduceStolenNecklaceProblem.divvy_with_n_cuts(\n",
        "            self, \n",
        "            with_thieves = False, \n",
        "            highlight_groups = False,\n",
        "            show_matching_after_divvying = True,\n",
        "        )\n",
        "\n",
        "    def identify_necklace_with_unit_interval(self):\n",
        "        interval = UnitInterval(\n",
        "            tick_frequency = 1./sum(self.num_per_jewel),\n",
        "            tick_size = 0.2,\n",
        "            big_tick_numbers = [],\n",
        "        )\n",
        "        interval.stretch_to_fit_width(self.necklace.get_width())\n",
        "        interval.move_to(self.necklace)\n",
        "        tick_marks = interval.tick_marks\n",
        "        tick_marks.set_stroke(WHITE, width = 2)\n",
        "\n",
        "        brace = Brace(interval)\n",
        "        brace_text = brace.get_text(\"Length = 1\")\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(interval.tick_marks),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.tick_marks = interval.tick_marks\n",
        "        self.length_brace = VGroup(brace, brace_text)\n",
        "\n",
        "    def color_necklace(self):\n",
        "        example_index = len(self.necklace.jewels)/2\n",
        "        jewels = self.necklace.jewels\n",
        "        chain = self.necklace.chain\n",
        "        self.remove(self.necklace)\n",
        "        self.add(chain, jewels)\n",
        "\n",
        "        jewels.submobjects.sort(\n",
        "            key=lambda m: m.get_center()[0]\n",
        "        )\n",
        "        remaining_indices = list(range(len(jewels)))\n",
        "        remaining_indices.remove(example_index)\n",
        "\n",
        "        example_segment = self.color_necklace_by_indices(example_index)\n",
        "        remaining_segments = self.color_necklace_by_indices(*remaining_indices)\n",
        "        self.remove(chain)\n",
        "        segments = VGroup(example_segment[0], *remaining_segments)\n",
        "        segments.submobjects.sort(\n",
        "            key=lambda m: m.get_center()[0]\n",
        "        )\n",
        "        segment_types = VGroup(*[\n",
        "            VGroup(*[m for m in segments if m.get_color() == Color(color)])\n",
        "            for color in self.jewel_colors\n",
        "        ])\n",
        "\n",
        "        for group in segment_types:\n",
        "            length_tex = OldTex(\"\\\\frac{%d}{%d}\"%(\n",
        "                len(group),\n",
        "                len(jewels)\n",
        "             ))\n",
        "            length_tex.next_to(group, UP)\n",
        "            length_tex.shift(UP)\n",
        "            self.play(\n",
        "                group.shift, UP,\n",
        "                Write(length_tex, run_time = 1),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                group.shift, DOWN,\n",
        "                FadeOut(length_tex)\n",
        "            )\n",
        "        self.play(FadeOut(self.length_brace))\n",
        "\n",
        "        self.segments = segments\n",
        "\n",
        "    def color_necklace_by_indices(self, *indices):\n",
        "        chain = self.necklace.chain\n",
        "        jewels = VGroup(*[\n",
        "            self.necklace.jewels[i]\n",
        "            for i in indices\n",
        "        ])\n",
        "        n_jewels = len(self.necklace.jewels)\n",
        "\n",
        "        segments = VGroup(*[\n",
        "            Line(\n",
        "                chain.point_from_proportion(index/float(n_jewels)),\n",
        "                chain.point_from_proportion((index+1)/float(n_jewels)),\n",
        "                color = jewel.get_color()\n",
        "            )\n",
        "            for index, jewel in zip(indices, jewels)\n",
        "        ])\n",
        "        for jewel in jewels:\n",
        "            jewel.save_state()\n",
        "\n",
        "        self.play(jewels.shift, jewels.get_height()*UP)\n",
        "        self.play(ReplacementTransform(\n",
        "            jewels, segments,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "        return segments\n",
        "\n",
        "    def find_continuous_fair_division(self):\n",
        "        chain = self.necklace.chain\n",
        "        n_jewels = len(self.necklace.jewels)\n",
        "\n",
        "        slice_indices, ignore = self.find_slice_indices(\n",
        "            self.necklace.jewels,\n",
        "            self.jewel_types\n",
        "        )\n",
        "        cut_proportions = [\n",
        "            sorted([random.random(), random.random()])\n",
        "            for x in range(self.num_continuous_division_searches)\n",
        "        ]\n",
        "        cut_proportions.append([\n",
        "            float(i)/n_jewels\n",
        "            for i in slice_indices[1:-1]\n",
        "        ])\n",
        "        cut_points = [\n",
        "            list(map(chain.point_from_proportion, pair))\n",
        "            for pair in cut_proportions\n",
        "        ]\n",
        "        v_lines = VGroup(*[DashedLine(UP, DOWN) for x in range(2)])\n",
        "\n",
        "        for line, point in zip(v_lines, cut_points[0]):\n",
        "            line.move_to(point)\n",
        "\n",
        "        self.play(ShowCreation(v_lines))\n",
        "        self.wait()\n",
        "        for target_points in cut_points[1:]:\n",
        "            self.play(*[\n",
        "                ApplyMethod(line.move_to, point)\n",
        "                for line, point in zip(v_lines, target_points)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "        self.slice_indices = slice_indices\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def show_continuous_fair_division(self):\n",
        "        slice_indices = self.slice_indices\n",
        "\n",
        "        groups = [\n",
        "            VGroup(\n",
        "                VGroup(*self.segments[i1:i2]),\n",
        "                VGroup(*self.tick_marks[i1:i2]),\n",
        "            )\n",
        "            for i1, i2 in zip(slice_indices, slice_indices[1:])\n",
        "        ]\n",
        "        groups[-1].add(self.tick_marks[-1])\n",
        "        vects = [[UP, DOWN][i] for i in self.forced_binary_choices]\n",
        "\n",
        "        self.play(*[\n",
        "            ApplyMethod(group.shift, 0.5*vect)\n",
        "            for group, vect in zip(groups, vects)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.groups = groups\n",
        "\n",
        "    def set_color_continuous_groups(self):\n",
        "        top_group = VGroup(self.groups[0], self.groups[2])\n",
        "        bottom_group = self.groups[1]\n",
        "        boxes = VGroup()\n",
        "        for group in top_group, bottom_group:\n",
        "            box = Rectangle(\n",
        "                width = FRAME_WIDTH-2,\n",
        "                height = group.get_height()+SMALL_BUFF,\n",
        "                stroke_width = 0,\n",
        "                fill_color = WHITE,\n",
        "                fill_opacity = 0.25,\n",
        "            )\n",
        "            box.shift(group.get_center()[1]*UP)\n",
        "            boxes.add(box)\n",
        "\n",
        "        weight_description = VGroup(*[\n",
        "            VGroup(\n",
        "                OldTex(\"\\\\frac{%d}{%d}\"%(\n",
        "                    len(jewel_type)/2, len(self.segments)\n",
        "                )),\n",
        "                Jewel(color = jewel_type[0].get_color())\n",
        "            ).arrange()\n",
        "            for jewel_type in self.jewel_types\n",
        "        ])\n",
        "        weight_description.arrange(buff = LARGE_BUFF)\n",
        "        weight_description.next_to(boxes, UP, aligned_edge = LEFT)\n",
        "\n",
        "        self.play(FadeIn(boxes))\n",
        "        self.play(Write(weight_description))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_color_box = boxes\n",
        "        self.weight_description = weight_description\n",
        "\n",
        "    def mention_equivalence_to_discrete_case(self):\n",
        "        morty = Mortimer()\n",
        "        morty.flip()\n",
        "        morty.to_edge(DOWN)\n",
        "        morty.shift(LEFT)\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \n",
        "            \"\"\"This is equivalent to\n",
        "            the discrete case. \"\"\",\n",
        "            bubble_config = {\n",
        "                \"height\" : 3, \n",
        "                \"direction\" : LEFT,\n",
        "            }\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            morty, morty.bubble, morty.bubble.content\n",
        "        ])))\n",
        "        \n",
        "    def shift_divide_off_tick_marks(self):\n",
        "        groups = self.groups\n",
        "        slice_indices = self.slice_indices\n",
        "        v_lines = self.v_lines\n",
        "\n",
        "        left_segment = groups[1][0][0]\n",
        "        left_tick = groups[1][1][0]\n",
        "        right_segment = groups[-1][0][0]\n",
        "        right_tick = groups[-1][1][0]\n",
        "\n",
        "        segment_width = left_segment.get_width()\n",
        "\n",
        "        for mob in left_segment, right_segment:\n",
        "            mob.parts = VGroup(\n",
        "                mob.copy().pointwise_become_partial(mob, 0, 0.5),\n",
        "                mob.copy().pointwise_become_partial(mob, 0.5, 1),\n",
        "            )\n",
        "            self.remove(mob)\n",
        "            self.add(mob.parts)\n",
        "        restorers = [left_segment.parts, left_tick, right_segment.parts, right_tick]\n",
        "        for mob in restorers:\n",
        "            mob.save_state()\n",
        "\n",
        "        emerald_segments = VGroup(*[\n",
        "            segment\n",
        "            for segment in list(groups[0][0])+list(groups[2][0])\n",
        "            if segment.get_color() == Color(self.jewel_colors[1])\n",
        "            if segment is not right_segment\n",
        "        ])\n",
        "        emerald_segments.add(\n",
        "            left_segment.parts[0],\n",
        "            right_segment.parts[1],\n",
        "        )\n",
        "        emerald_segments.sort()\n",
        "\n",
        "        self.play(v_lines.shift, segment_width*RIGHT/2)\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, vect)\n",
        "            for mob, vect in [\n",
        "                (left_segment.parts[0], UP),\n",
        "                (left_tick, UP),\n",
        "                (right_segment.parts[0], DOWN),\n",
        "                (right_tick, DOWN),\n",
        "            ]\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        words = OldTexText(\"Cut part way through segment\")\n",
        "        words.to_edge(RIGHT)\n",
        "        words.shift(2*UP)\n",
        "        arrow1 = Arrow(words.get_bottom(), left_segment.parts[0].get_right())\n",
        "        arrow2 = Arrow(words.get_bottom(), right_segment.parts[1].get_left())\n",
        "        VGroup(words, arrow1, arrow2).set_color(RED)\n",
        "\n",
        "        self.play(Write(words), ShowCreation(arrow1))\n",
        "        self.wait()\n",
        "\n",
        "        emerald_segments.save_state()\n",
        "        emerald_segments.generate_target()\n",
        "        emerald_segments.target.arrange()\n",
        "        emerald_segments.target.move_to(2*DOWN)\n",
        "        brace = Brace(emerald_segments.target, DOWN)\n",
        "        label = VGroup(\n",
        "            OldTex(\"5\\\\left( 1/18 \\\\right)\"),\n",
        "            Jewel(color = self.jewel_colors[1])\n",
        "        ).arrange()\n",
        "        label.next_to(brace, DOWN)\n",
        "        self.play(MoveToTarget(emerald_segments))\n",
        "        self.play(GrowFromCenter(brace))\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "        broken_pair = VGroup(*emerald_segments[2:4])\n",
        "        broken_pair.save_state()\n",
        "        self.play(broken_pair.shift, 0.5*UP)\n",
        "        vect = broken_pair[1].get_left()-broken_pair[1].get_right()\n",
        "        self.play(\n",
        "            broken_pair[0].shift, -vect/2,\n",
        "            broken_pair[1].shift, vect/2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(broken_pair.space_out_submobjects)\n",
        "        self.play(broken_pair.restore)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            emerald_segments.restore,\n",
        "            *list(map(FadeOut, [brace, label]))\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(arrow2))\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [words, arrow1, arrow2])))\n",
        "\n",
        "        for line in v_lines:\n",
        "            self.play(line.shift, segment_width*LEFT/2)\n",
        "        self.play(*[mob.restore for mob in restorers])\n",
        "        self.remove(left_segment.parts, right_segment.parts)\n",
        "        self.add(left_segment, right_segment)\n",
        "\n",
        "class ThinkAboutTheChoices(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Think about the choices\n",
        "            behind a division...\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = FRAME_X_RADIUS*RIGHT+FRAME_Y_RADIUS*DOWN\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class ChoicesInNecklaceCutting(ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"num_continuous_division_searches\" : 4,\n",
        "        \"denoms\" : [6, 3, 2],\n",
        "        \"necklace_center\" : DOWN,\n",
        "        \"thief_box_offset\" : 1.2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_necklace()\n",
        "        self.choose_places_to_cut()\n",
        "        self.show_three_numbers_adding_to_one()\n",
        "        self.make_binary_choice()\n",
        "\n",
        "    def add_necklace(self):\n",
        "        width, colors, num_per_color = [\n",
        "            MakeTwoJewelCaseContinuous.CONFIG[key]\n",
        "            for key in [\n",
        "                \"necklace_width\", \"jewel_colors\", \"num_per_jewel\"\n",
        "            ]\n",
        "        ]\n",
        "        color_list = list(it.chain(*[\n",
        "            num*[color] \n",
        "            for num, color in zip(num_per_color, colors)\n",
        "        ]))\n",
        "        random.shuffle(color_list)\n",
        "\n",
        "        interval = UnitInterval(\n",
        "            tick_frequency = 1./sum(num_per_color),\n",
        "            tick_size = 0.2,\n",
        "            big_tick_numbers = [],\n",
        "        )\n",
        "        interval.stretch_to_fit_width(width)\n",
        "        interval.shift(self.necklace_center)\n",
        "        tick_marks = interval.tick_marks\n",
        "        tick_marks.set_stroke(WHITE, width = 2)\n",
        "\n",
        "        segments = VGroup()\n",
        "        for l_tick, r_tick, color in zip(tick_marks, tick_marks[1:], color_list):\n",
        "            segment = Line(\n",
        "                l_tick.get_center(),\n",
        "                r_tick.get_center(),\n",
        "                color = color\n",
        "            )\n",
        "            segments.add(segment)\n",
        "\n",
        "        self.necklace = VGroup(segments, tick_marks)\n",
        "        self.add(self.necklace)\n",
        "\n",
        "        self.interval = interval        \n",
        "\n",
        "    def choose_places_to_cut(self):\n",
        "        v_lines = VGroup(*[DashedLine(UP, DOWN) for x in range(2)])\n",
        "        final_num_pair = np.cumsum([1./d for d in self.denoms[:2]])\n",
        "\n",
        "        num_pairs = [\n",
        "            sorted([random.random(), random.random()])\n",
        "            for x in range(self.num_continuous_division_searches)\n",
        "        ] + [final_num_pair]\n",
        "\n",
        "        point_pairs = [\n",
        "            list(map(self.interval.number_to_point, num_pair))\n",
        "            for num_pair in num_pairs\n",
        "        ]\n",
        "        \n",
        "        for line, point in zip(v_lines, point_pairs[0]):\n",
        "            line.move_to(point)\n",
        "        self.play(ShowCreation(v_lines))\n",
        "        for point_pair in point_pairs[1:]:\n",
        "            self.wait()\n",
        "            self.play(*[\n",
        "                ApplyMethod(line.move_to, point)\n",
        "                for line, point in zip(v_lines, point_pair)\n",
        "            ])\n",
        "        self.wait()\n",
        "\n",
        "        self.division_points = list(it.chain(\n",
        "            [self.interval.get_left()],\n",
        "            point_pairs[-1],\n",
        "            [self.interval.get_right()]\n",
        "        ))\n",
        "\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def show_three_numbers_adding_to_one(self):\n",
        "        points = self.division_points\n",
        "        braces = [\n",
        "            Brace(Line(p1+SMALL_BUFF*RIGHT/2, p2+SMALL_BUFF*LEFT/2))\n",
        "            for p1, p2 in zip(points, points[1:])\n",
        "        ]\n",
        "        for char, denom, brace in zip(\"abc\", self.denoms, braces):\n",
        "            brace.label = brace.get_text(\"$%s$\"%char)\n",
        "            brace.concrete_label = brace.get_text(\"$\\\\frac{1}{%d}$\"%denom)\n",
        "            VGroup(\n",
        "                brace.label,\n",
        "                brace.concrete_label\n",
        "            ).set_color(YELLOW)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"1) Choose\", \"$a$, $b$, $c$\", \"so that\", \"$a+b+c = 1$\"\n",
        "        )\n",
        "        words[1].set_color(YELLOW)\n",
        "        words[3].set_color(YELLOW)\n",
        "        words.to_corner(UP+LEFT)\n",
        "\n",
        "        self.play(*it.chain(*[\n",
        "            [GrowFromCenter(brace), Write(brace.label)]\n",
        "            for brace in braces\n",
        "        ]))\n",
        "        self.play(Write(words))\n",
        "        self.wait(2)\n",
        "        self.play(*[\n",
        "            ReplacementTransform(brace.label, brace.concrete_label)\n",
        "            for brace in braces\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.wiggle_v_lines()\n",
        "        self.wait()\n",
        "        self.transition_to_alt_config(denoms = [3, 3, 3])\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, list(braces) + [\n",
        "            brace.concrete_label for brace in braces\n",
        "        ])))\n",
        "\n",
        "        self.choice_one_words = words\n",
        "\n",
        "    def make_binary_choice(self):\n",
        "        groups = self.get_groups()\n",
        "        boxes, labels = self.get_boxes_and_labels()\n",
        "        arrow_pairs, curr_arrows = self.get_choice_arrow_pairs(groups)\n",
        "        words = OldTexText(\"2) Make a binary choice for each segment\")\n",
        "        words.next_to(\n",
        "            self.choice_one_words, DOWN, \n",
        "            buff = MED_LARGE_BUFF, \n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.play(*list(map(FadeIn, [boxes, labels])))\n",
        "        for binary_choices in it.product(*[[0, 1]]*3):\n",
        "            self.play(*[\n",
        "                ApplyMethod(group.move_to, group.target_points[choice])\n",
        "                for group, choice in zip(groups, binary_choices)\n",
        "            ] + [\n",
        "                Transform(\n",
        "                    curr_arrow, arrow_pair[choice],\n",
        "                    path_arc = np.pi\n",
        "                )\n",
        "                for curr_arrow, arrow_pair, choice in zip(\n",
        "                    curr_arrows, arrow_pairs, binary_choices\n",
        "                )\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_groups(self, indices = None):\n",
        "        segments, tick_marks = self.necklace\n",
        "        if indices is None:\n",
        "            n_segments = len(segments)\n",
        "            indices = [0, n_segments/6, n_segments/2, n_segments]\n",
        "\n",
        "        groups = [\n",
        "            VGroup(\n",
        "                VGroup(*segments[i1:i2]),\n",
        "                VGroup(*tick_marks[i1:i2]),\n",
        "            )\n",
        "            for i1, i2 in zip(indices, indices[1:])\n",
        "        ]\n",
        "        for group, index in zip(groups, indices[1:]):\n",
        "            group[1].add(tick_marks[index].copy())\n",
        "        groups[-1][1].add(tick_marks[-1])\n",
        "\n",
        "        for group in groups:\n",
        "            group.target_points = [\n",
        "                group.get_center() + self.thief_box_offset*vect\n",
        "                for vect in (UP, DOWN)\n",
        "            ]\n",
        "\n",
        "        return groups\n",
        "\n",
        "    def get_boxes_and_labels(self):\n",
        "        box = Rectangle(\n",
        "            height = self.necklace.get_height()+SMALL_BUFF,\n",
        "            width = self.necklace.get_width()+2*SMALL_BUFF,\n",
        "            stroke_width = 0,\n",
        "            fill_color = WHITE,\n",
        "            fill_opacity = 0.25\n",
        "        )\n",
        "        box.move_to(self.necklace)\n",
        "\n",
        "        boxes = VGroup(*[\n",
        "            box.copy().shift(self.thief_box_offset*vect)\n",
        "            for vect in (UP, DOWN)\n",
        "        ])\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"Thief %d\"%(i+1)\n",
        "            ).next_to(box, UP, aligned_edge = RIGHT)\n",
        "            for i, box in enumerate(boxes)\n",
        "        ])\n",
        "        return boxes, labels\n",
        "\n",
        "    def get_choice_arrow_pairs(self, groups):\n",
        "        arrow = OldTex(\"\\\\uparrow\")\n",
        "        arrow_pairs = [\n",
        "            [arrow.copy(), arrow.copy().rotate(np.pi)]\n",
        "            for group in groups\n",
        "        ]\n",
        "        pre_arrow_points = [\n",
        "            VectorizedPoint(group.get_center())\n",
        "            for group in groups\n",
        "        ]\n",
        "        for point, arrow_pair in zip(pre_arrow_points, arrow_pairs):\n",
        "            for arrow, color in zip(arrow_pair, [GREEN, RED]):\n",
        "                arrow.set_color(color)\n",
        "                arrow.move_to(point.get_center())\n",
        "        return arrow_pairs, pre_arrow_points\n",
        "\n",
        "    def wiggle_v_lines(self):\n",
        "        self.play(\n",
        "            *it.chain(*[\n",
        "                [\n",
        "                    line.rotate, np.pi/12, vect,\n",
        "                    line.set_color, RED\n",
        "                ]\n",
        "                for line, vect in zip(self.v_lines, [OUT, IN])\n",
        "            ]),\n",
        "            rate_func = wiggle\n",
        "        )\n",
        "\n",
        "class CompareThisToSphereChoice(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            Compare this to choosing\n",
        "            a point on the sphere.\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = FRAME_X_RADIUS*RIGHT+FRAME_Y_RADIUS*DOWN\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "class SimpleRotatingSphereWithPoint(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class ChoicesForSpherePoint(GeneralizeBorsukUlam):\n",
        "    def construct(self):\n",
        "        self.add_sphere_set()\n",
        "        self.initialize_words()\n",
        "        self.play(Write(self.choice_one_words))\n",
        "        self.wait()\n",
        "        self.show_example_choices()\n",
        "        self.show_binary_choices()\n",
        "\n",
        "    def get_tuple(self):\n",
        "        tup = OldTex(\"(x, y, z)\")\n",
        "        for i, color in zip([1, 3, 5], self.colors):\n",
        "            tup[i].set_color(color)\n",
        "        return tup\n",
        "\n",
        "    def get_condition(self):\n",
        "        condition = OldTex(\"x^2+y^2+z^2 = 1\")\n",
        "        for i, color in zip([0, 3, 6], self.colors):\n",
        "            VGroup(*condition[i:i+2]).set_color(color)\n",
        "        return condition\n",
        "\n",
        "    def add_sphere_set(self):\n",
        "        sphere_set = self.get_sphere_set()\n",
        "        sphere_set.scale(0.7)\n",
        "        sphere_set.to_edge(RIGHT)\n",
        "        sphere_set.shift(UP)\n",
        "\n",
        "        self.add(sphere_set)\n",
        "        self.sphere_set = sphere_set\n",
        "\n",
        "    def initialize_words(self):\n",
        "        choice_one_words = OldTexText(\n",
        "            \"1) Choose\", \"$x^2$, $y^2$, $z^2$\",\n",
        "            \"so that\", \"$x^2+y^2+z^2 = 1$\"\n",
        "        )\n",
        "        for i in 1, 3:\n",
        "            for j, color in zip([0, 3, 6], self.colors):\n",
        "                VGroup(*choice_one_words[i][j:j+2]).set_color(color)\n",
        "        choice_one_words.to_corner(UP+LEFT)\n",
        "\n",
        "        choice_two_words = OldTexText(\n",
        "            \"2) Make a binary choice for each one\"\n",
        "        )\n",
        "        choice_two_words.next_to(\n",
        "            choice_one_words, DOWN, \n",
        "            buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "\n",
        "        self.choice_one_words = choice_one_words\n",
        "        self.choice_two_words = choice_two_words\n",
        "\n",
        "    def show_example_choices(self):\n",
        "        choices = VGroup(*[\n",
        "            OldTex(*tex).set_color(color)\n",
        "            for color, tex in zip(self.colors, [\n",
        "                (\"x\", \"^2 = \", \"1/6\"),\n",
        "                (\"y\", \"^2 = \", \"1/3\"),\n",
        "                (\"z\", \"^2 = \", \"1/2\"),\n",
        "            ])\n",
        "        ])\n",
        "        choices.arrange(\n",
        "            DOWN, \n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        choices.set_height(FRAME_Y_RADIUS)\n",
        "        choices.to_edge(LEFT)\n",
        "        choices.shift(DOWN)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            choices,\n",
        "            run_time = 2,\n",
        "            lag_ratio = 0.5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.choices = choices\n",
        "\n",
        "    def show_binary_choices(self):\n",
        "        for choice in self.choices:\n",
        "            var_tex = choice.expression_parts[0]\n",
        "            frac_tex = choice.expression_parts[2]\n",
        "            sqrts = VGroup(*[\n",
        "                OldTex(\n",
        "                    var_tex + \"=\" + sign + \\\n",
        "                    \"\\\\sqrt{%s}\"%frac_tex)\n",
        "                for sign in [\"+\", \"-\"]\n",
        "            ])\n",
        "            for sqrt in sqrts:\n",
        "                sqrt.scale(0.6)\n",
        "            sqrts.arrange(DOWN)\n",
        "            sqrts.next_to(choice, RIGHT, buff = LARGE_BUFF)\n",
        "            sqrts.set_color(choice.get_color())\n",
        "\n",
        "            arrows = VGroup(*[\n",
        "                Arrow(\n",
        "                    choice.get_right(), sqrt.get_left(), \n",
        "                    color = WHITE,\n",
        "                    tip_length = 0.1,\n",
        "                    buff = SMALL_BUFF\n",
        "                )\n",
        "                for sqrt in sqrts\n",
        "            ])\n",
        "\n",
        "            self.play(ShowCreation(arrows))\n",
        "            self.play(FadeIn(sqrts, lag_ratio = 0.5))\n",
        "        self.play(Write(self.choice_two_words))\n",
        "        self.wait()\n",
        "\n",
        "class NecklaceDivisionSphereAssociation(ChoicesInNecklaceCutting):\n",
        "    CONFIG = {\n",
        "        \"xyz_colors\" : color_gradient([GREEN_B, BLUE], 3),\n",
        "        \"necklace_center\" : DOWN,\n",
        "        \"thief_box_offset\" : 1.6,\n",
        "        \"denoms\" : [6, 3, 2],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_necklace()\n",
        "        self.add_sphere_point_label()\n",
        "        self.choose_places_to_cut()\n",
        "        self.add_braces()\n",
        "        self.add_boxes_and_labels()\n",
        "        self.show_binary_choice_association()\n",
        "        self.ask_about_antipodal_pairs()\n",
        "\n",
        "    def add_sphere_point_label(self):\n",
        "        label = OldTexText(\n",
        "            \"$(x, y, z)$\",\n",
        "            \"such that\",\n",
        "            \"$x^2 + y^2 + z^2 = 1$\"\n",
        "        )\n",
        "        for i, j_list in (0, [1, 3, 5]), (2, [0, 3, 6]):\n",
        "            for j, color in zip(j_list, self.xyz_colors):\n",
        "                label[i][j].set_color(color)\n",
        "        label.to_corner(UP+RIGHT)\n",
        "\n",
        "        ghost_sphere_point = VectorizedPoint()\n",
        "        ghost_sphere_point.to_corner(UP+LEFT, buff = LARGE_BUFF)\n",
        "        ghost_sphere_point.shift(2*RIGHT)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            label.get_left(), ghost_sphere_point,\n",
        "            color = WHITE\n",
        "        )\n",
        "\n",
        "        self.add(label, arrow)\n",
        "\n",
        "        self.sphere_point_label = label\n",
        "\n",
        "    def add_braces(self):\n",
        "        points = self.division_points\n",
        "        braces = [\n",
        "            Brace(\n",
        "                Line(p1+SMALL_BUFF*RIGHT/2, p2+SMALL_BUFF*LEFT/2),\n",
        "                UP\n",
        "            )\n",
        "            for p1, p2 in zip(points, points[1:])\n",
        "        ]\n",
        "        for char, brace, color, denom in zip(\"xyz\", braces, self.xyz_colors, self.denoms):\n",
        "            brace.label = brace.get_text(\n",
        "                \"$%s^2$\"%char, \"$= 1/%d$\"%denom,\n",
        "                buff = SMALL_BUFF\n",
        "            )\n",
        "            brace.label.set_color(color)\n",
        "            if brace.label.get_right()[0] > brace.get_right()[0]:\n",
        "                brace.label.next_to(\n",
        "                    brace, UP, buff = SMALL_BUFF,\n",
        "                    aligned_edge = RIGHT\n",
        "                )\n",
        "\n",
        "        self.play(*it.chain(\n",
        "            list(map(GrowFromCenter, braces)),\n",
        "            [Write(brace.label) for brace in braces]\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.braces = braces\n",
        "\n",
        "    def add_boxes_and_labels(self):\n",
        "        boxes, labels = self.get_boxes_and_labels()\n",
        "        self.play(*list(map(FadeIn, [boxes, labels])))\n",
        "        self.wait()\n",
        "\n",
        "    def show_binary_choice_association(self):\n",
        "        groups = self.get_groups()\n",
        "        self.swapping_anims = []\n",
        "        final_choices = [1, 0, 1]\n",
        "        quads = list(zip(self.braces, self.denoms, groups, final_choices))\n",
        "        for brace, denom, group, final_choice in quads:\n",
        "            char = brace.label.args[0][1]\n",
        "            choices = [\n",
        "                OldTex(\n",
        "                    char, \"=\", sign, \"\\\\sqrt{\\\\frac{1}{%d}}\"%denom\n",
        "                )\n",
        "                for sign in (\"+\", \"-\")\n",
        "            ]\n",
        "            for choice, color in zip(choices, [GREEN, RED]):\n",
        "                # choice[0].set_color(brace.label.get_color())\n",
        "                choice[2].set_color(color)\n",
        "                choice.scale(0.8)\n",
        "                choice.move_to(group)\n",
        "                if choice.get_width() > 0.8*group.get_width():\n",
        "                    choice.next_to(group.get_right(), LEFT, buff = MED_SMALL_BUFF)\n",
        "            original_choices = [m.copy() for m in choices]\n",
        "\n",
        "            self.play(\n",
        "                ReplacementTransform(\n",
        "                    VGroup(brace.label[0], brace, brace.label[1]), \n",
        "                    choices[0]\n",
        "                ),\n",
        "                group.move_to, group.target_points[0]\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                Transform(*choices),\n",
        "                group.move_to, group.target_points[1]\n",
        "            )\n",
        "            self.wait()\n",
        "            if final_choice == 0:\n",
        "                self.play(\n",
        "                    Transform(choices[0], original_choices[0]),\n",
        "                    group.move_to, group.target_points[0]\n",
        "                )\n",
        "            self.swapping_anims += [\n",
        "                Transform(choices[0], original_choices[1-final_choice]),\n",
        "                group.move_to, group.target_points[1-final_choice]\n",
        "            ]\n",
        "\n",
        "    def ask_about_antipodal_pairs(self):\n",
        "        question = OldTexText(\"What do antipodal points signify?\")\n",
        "        question.move_to(self.sphere_point_label, LEFT)\n",
        "        question.set_color(MAROON_B)\n",
        "        antipodal_tex = OldTex(\n",
        "            \"(x, y, z) \\\\rightarrow (-x, -y, -z)\"\n",
        "        )\n",
        "        antipodal_tex.next_to(question, DOWN, aligned_edge = LEFT)\n",
        "\n",
        "        self.play(FadeOut(self.sphere_point_label))\n",
        "        self.play(FadeIn(question))\n",
        "        self.wait()\n",
        "        self.play(Write(antipodal_tex))\n",
        "        self.wait()\n",
        "        self.wiggle_v_lines()\n",
        "        self.wait()\n",
        "        self.play(*self.swapping_anims)\n",
        "        self.wait()\n",
        "\n",
        "class SimpleRotatingSphereWithAntipodes(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class TotalLengthOfEachJewelEquals(NecklaceDivisionSphereAssociation, ThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 1,\n",
        "        \"thief_box_offset\" : 1.2,\n",
        "    }\n",
        "    def construct(self):\n",
        "        random.seed(self.random_seed)\n",
        "        self.add_necklace()\n",
        "        self.add_boxes_and_labels()\n",
        "        self.find_fair_division()\n",
        "        self.demonstrate_fair_division()\n",
        "        self.perform_antipodal_swap()\n",
        "\n",
        "    def find_fair_division(self):\n",
        "        segments, tick_marks = self.necklace\n",
        "        segments.sort()\n",
        "        segment_colors = [\n",
        "            segment.get_color()\n",
        "            for segment in segments\n",
        "        ]\n",
        "        indices = self.get_fair_division_indices(segment_colors)\n",
        "        groups = self.get_groups(\n",
        "            [0] + list(np.array(indices)+1) + [len(segments)]\n",
        "        )\n",
        "        self.add(*groups)\n",
        "        binary_choice = [0, 1, 0]\n",
        "\n",
        "        v_lines = VGroup(*[DashedLine(UP, DOWN) for x in range(2)])\n",
        "        v_lines.move_to(self.necklace)\n",
        "        self.play(ShowCreation(v_lines))\n",
        "        self.play(*[\n",
        "            ApplyMethod(line.move_to, segments[index].get_right())\n",
        "            for line, index in zip(v_lines, indices)\n",
        "        ])\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(group.move_to, group.target_points[choice])\n",
        "            for group, choice in zip(groups, binary_choice)\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.groups = groups\n",
        "        self.v_lines = v_lines\n",
        "\n",
        "    def get_fair_division_indices(self, colors):\n",
        "        colors = np.array(list(colors))\n",
        "        color_types = list(map(Color, set([c.get_hex_l() for c in colors])))\n",
        "        type_to_count = dict([\n",
        "            (color, sum(colors == color))\n",
        "            for color in color_types\n",
        "        ])\n",
        "        for i1, i2 in it.combinations(list(range(1, len(colors)-1)), 2):\n",
        "            bools = [\n",
        "                sum(colors[i1:i2] == color) == type_to_count[color]/2\n",
        "                for color in color_types\n",
        "            ]\n",
        "            if np.all(bools):\n",
        "                return i1, i2\n",
        "        raise Exception(\"No fair division found\")\n",
        "\n",
        "    def demonstrate_fair_division(self):\n",
        "        segments, tick_marks = self.necklace\n",
        "        color_types = list(map(Color, set([\n",
        "            segment.get_color().get_hex_l()\n",
        "            for segment in segments\n",
        "        ])))\n",
        "        top_segments = VGroup(*it.chain(\n",
        "            self.groups[0][0],\n",
        "            self.groups[2][0],\n",
        "        ))\n",
        "        bottom_segments = self.groups[1][0]\n",
        "        for color in color_types:\n",
        "            monochrome_groups = [\n",
        "                VGroup(*[segment for segment in segment_group if segment.get_color() == color])\n",
        "                for segment_group in (top_segments, bottom_segments)\n",
        "            ]\n",
        "            labels = VGroup()\n",
        "            for i, group in enumerate(monochrome_groups):\n",
        "                group.save_state()\n",
        "                group.generate_target()\n",
        "                group.target.arrange(buff = SMALL_BUFF)\n",
        "                brace = Brace(group.target, UP)\n",
        "                label = VGroup(\n",
        "                    OldTexText(\"Thief %d\"%(i+1)),\n",
        "                    Jewel(color = group[0].get_color())\n",
        "                )\n",
        "                label.arrange()\n",
        "                label.next_to(brace, UP)\n",
        "                full_group = VGroup(group.target, brace, label)\n",
        "                vect = LEFT if i == 0 else RIGHT\n",
        "                full_group.next_to(ORIGIN, vect, buff = MED_LARGE_BUFF)\n",
        "                full_group.to_edge(UP)\n",
        "                labels.add(VGroup(brace, label))\n",
        "            equals = OldTex(\"=\")\n",
        "            equals.next_to(monochrome_groups[0].target, RIGHT)\n",
        "            labels[-1].add(equals)\n",
        "\n",
        "            for group, label in zip(monochrome_groups, labels):\n",
        "                self.play(\n",
        "                    MoveToTarget(group),\n",
        "                    FadeIn(label),\n",
        "                )\n",
        "                self.wait()\n",
        "            self.play(\n",
        "                FadeOut(labels),\n",
        "                *[group.restore for group in monochrome_groups]\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "    def perform_antipodal_swap(self):\n",
        "        binary_choices_list = [(1, 0, 1), (0, 1, 0)]\n",
        "        for binary_choices in binary_choices_list:\n",
        "            self.play(*[\n",
        "                ApplyMethod(\n",
        "                    group.move_to,\n",
        "                    group.target_points[choice]\n",
        "                )\n",
        "                for group, choice in zip(self.groups, binary_choices)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "class ExclaimBorsukUlam(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Borsuk-Ulam!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play(*[\n",
        "            ApplyMethod(pi.change_mode, \"hooray\")\n",
        "            for pi in self.get_pi_creatures()\n",
        "        ])\n",
        "        self.wait(3)\n",
        "\n",
        "class ShowFunctionDiagram(TotalLengthOfEachJewelEquals, ReconfigurableScene):\n",
        "    CONFIG = {\n",
        "        \"necklace_center\" : ORIGIN,\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "        \"thief_box_offset\" : 0.3,\n",
        "        \"make_up_fair_division_indices\" : False,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.add_necklace()\n",
        "        self.add_number_pair()\n",
        "        self.swap_necklace_allocation()\n",
        "        self.add_sphere_arrow()\n",
        "\n",
        "    def add_necklace(self):\n",
        "        random.seed(self.random_seed)\n",
        "        ChoicesInNecklaceCutting.add_necklace(self)\n",
        "        self.necklace.set_width(FRAME_X_RADIUS-1)\n",
        "        self.necklace.to_edge(UP, buff = LARGE_BUFF)\n",
        "        self.necklace.to_edge(LEFT, buff = SMALL_BUFF)\n",
        "        self.add(self.necklace)\n",
        "\n",
        "        self.find_fair_division()\n",
        "\n",
        "    def add_number_pair(self):\n",
        "        plane_classes = [\n",
        "            JewelPairPlane(\n",
        "                skip_animations = True, \n",
        "                thief_number = x\n",
        "            )\n",
        "            for x in (1, 2)\n",
        "        ]\n",
        "        t1_plane, t2_plane = planes = VGroup(*[\n",
        "            VGroup(*plane_class.get_top_level_mobjects())\n",
        "            for plane_class in plane_classes\n",
        "        ])\n",
        "        planes.set_width(FRAME_X_RADIUS)\n",
        "        planes.to_edge(RIGHT)\n",
        "        self.example_coords = plane_classes[0].example_coords[0]\n",
        "\n",
        "        arrow = Arrow(\n",
        "            self.necklace.get_corner(DOWN+RIGHT), \n",
        "            self.example_coords,\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(ShowCreation(arrow))\n",
        "        self.play(Write(t1_plane), Animation(arrow))\n",
        "        self.wait()\n",
        "        clean_state = VGroup(*self.mobjects).family_members_with_points()\n",
        "        self.clear()\n",
        "        self.add(*clean_state)\n",
        "        self.transition_to_alt_config(\n",
        "            make_up_fair_division_indices = True\n",
        "        )\n",
        "        self.wait()\n",
        "        t1_plane.save_state()\n",
        "        self.play(\n",
        "            Transform(*planes, path_arc = np.pi),\n",
        "            Animation(arrow)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ApplyMethod(t1_plane.restore, path_arc = np.pi),\n",
        "            Animation(arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def swap_necklace_allocation(self):\n",
        "        for choices in [(1, 0, 1), (0, 1, 0)]:\n",
        "            self.play(*[\n",
        "                ApplyMethod(group.move_to, group.target_points[i])\n",
        "                for group, i in zip(self.groups, choices)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "    def add_sphere_arrow(self):\n",
        "        up_down_arrow = OldTex(\"\\\\updownarrow\")\n",
        "        up_down_arrow.scale(1.5)\n",
        "        up_down_arrow.set_color(YELLOW)\n",
        "        up_down_arrow.next_to(self.necklace, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        to_plane_arrow = Arrow(\n",
        "            up_down_arrow.get_bottom() + DOWN+RIGHT,\n",
        "            self.example_coords,\n",
        "            color = YELLOW\n",
        "        )\n",
        "\n",
        "        self.play(Write(up_down_arrow))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(to_plane_arrow))\n",
        "        self.wait()\n",
        "\n",
        "    def get_fair_division_indices(self, *args):\n",
        "        if self.make_up_fair_division_indices:\n",
        "            return [9, 14]\n",
        "        else:\n",
        "            return TotalLengthOfEachJewelEquals.get_fair_division_indices(self, *args)\n",
        "\n",
        "class JewelPairPlane(GraphScene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "        \"x_labeled_nums\" : [],\n",
        "        \"y_labeled_nums\" : [],\n",
        "        \"thief_number\" : 1,\n",
        "        \"colors\" : [BLUE, GREEN],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_axes()\n",
        "        point = self.coords_to_point(4, 5)\n",
        "        dot = Dot(point, color = WHITE)\n",
        "        coord_pair = OldTex(\n",
        "            \"\\\\big(\", \n",
        "            \"\\\\text{Thief %d }\"%self.thief_number, \"X\", \",\", \n",
        "            \"\\\\text{Thief %d }\"%self.thief_number, \"X\", \n",
        "            \"\\\\big)\"\n",
        "        )\n",
        "        # coord_pair.scale(1.5)\n",
        "        to_replace = [coord_pair[i] for i in [2, 5]]\n",
        "        for mob, color in zip(to_replace, self.colors):\n",
        "            jewel = Jewel(color = color)\n",
        "            jewel.replace(mob)\n",
        "            coord_pair.remove(mob)\n",
        "            coord_pair.add(jewel)\n",
        "        coord_pair.next_to(dot, UP+RIGHT, buff = 0)\n",
        "\n",
        "        self.example_coords = VGroup(dot, coord_pair)\n",
        "        self.add(self.example_coords)\n",
        "\n",
        "class WhatThisMappingActuallyLooksLikeWords(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"What this mapping actually looks like\")\n",
        "        words.set_width(FRAME_WIDTH-1)\n",
        "        words.to_edge(DOWN)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class WhatAboutGeneralCase(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            What about when\n",
        "            there's more than 2 jewels?\n",
        "        \"\"\")\n",
        "        self.play_student_changes(\"confused\", None, \"sassy\")\n",
        "        self.wait()\n",
        "        self.play(self.get_teacher().change_mode, \"thinking\")\n",
        "        self.wait()\n",
        "        self.teacher_says(\n",
        "            \"\"\"Use Borsuk-Ulam for\n",
        "            higher-dimensional spheres \"\"\", \n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.wait(2)\n",
        "\n",
        "class Simple3DSpace(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "class FourDBorsukUlam(GeneralizeBorsukUlam, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"n_dims\" : 4,\n",
        "        \"use_morty\" : False,\n",
        "    }\n",
        "    def setup(self):\n",
        "        GeneralizeBorsukUlam.setup(self)\n",
        "        PiCreatureScene.setup(self)\n",
        "        self.pi_creature.to_corner(DOWN+LEFT, buff = MED_SMALL_BUFF)\n",
        "\n",
        "    def construct(self):\n",
        "        sphere_set = self.get_sphere_set()\n",
        "        arrow = Arrow(LEFT, RIGHT)\n",
        "        f = OldTex(\"f\")\n",
        "        output_space = self.get_output_space()\n",
        "        equation = self.get_equation()\n",
        "\n",
        "        sphere_set.to_corner(UP+LEFT)\n",
        "        arrow.next_to(sphere_set, RIGHT)\n",
        "        f.next_to(arrow, UP)\n",
        "        output_space.next_to(arrow, RIGHT)\n",
        "        equation.next_to(sphere_set, DOWN, buff = LARGE_BUFF)\n",
        "        equation.to_edge(RIGHT)\n",
        "        lhs = VGroup(*equation[:2])\n",
        "        eq = equation[2]\n",
        "        rhs = VGroup(*equation[3:])\n",
        "\n",
        "        brace = Brace(Line(ORIGIN, 5*RIGHT))\n",
        "        brace.to_edge(RIGHT)\n",
        "        brace_text = brace.get_text(\"Triplets of numbers\")\n",
        "        brace_text.shift_onto_screen()\n",
        "\n",
        "        self.play(FadeIn(sphere_set))\n",
        "        self.change_mode(\"confused\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(f)\n",
        "        )\n",
        "        self.play(Write(output_space))\n",
        "        self.wait()\n",
        "        self.change_mode(\"maybe\")\n",
        "        self.wait(2)\n",
        "        self.change_mode(\"pondering\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_text)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [brace, brace_text])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(lhs),\n",
        "            self.pi_creature.change_mode, \"raise_right_hand\"\n",
        "        )\n",
        "        self.play(\n",
        "            ReplacementTransform(lhs.copy(), rhs),\n",
        "            Write(eq)\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_sphere_set(self):\n",
        "        sphere_set = GeneralizeBorsukUlam.get_sphere_set(self)\n",
        "        brace = Brace(sphere_set)\n",
        "        text = brace.get_text(\"Hypersphere in 4D\")\n",
        "        sphere_set.add(brace, text)\n",
        "        return sphere_set\n",
        "\n",
        "class CircleToSphereToQMarks(Scene):\n",
        "    def construct(self):\n",
        "        pi_groups = VGroup()\n",
        "        modes = [\"happy\", \"pondering\", \"pleading\"]\n",
        "        shapes = [\n",
        "            Circle(color = BLUE, radius = 0.5), \n",
        "            VectorizedPoint(), \n",
        "            OldTex(\"???\")\n",
        "        ]\n",
        "        for d, mode, shape in zip(it.count(2), modes, shapes):\n",
        "            randy = Randolph(mode = mode)\n",
        "            randy.scale(0.7)\n",
        "            bubble = randy.get_bubble(\n",
        "                height = 3, width = 4,\n",
        "                direction = LEFT\n",
        "            )\n",
        "            bubble.pin_to(randy)\n",
        "            bubble.position_mobject_inside(shape)\n",
        "            title = OldTexText(\"%dD\"%d)\n",
        "            title.next_to(randy, UP)\n",
        "            arrow = Arrow(LEFT, RIGHT)\n",
        "            arrow.next_to(randy.get_corner(UP+RIGHT))\n",
        "            pi_groups.add(VGroup(\n",
        "                randy, bubble, shape, title, arrow\n",
        "            ))\n",
        "\n",
        "        pi_groups[-1].remove(pi_groups[-1][-1])\n",
        "        pi_groups.arrange(buff = -1)\n",
        "        for mob in pi_groups:\n",
        "            self.play(FadeIn(mob))\n",
        "        self.wait(2)\n",
        "        self.play(pi_groups[-1][0].change_mode, \"thinking\")\n",
        "        self.wait(2)\n",
        "\n",
        "class BorsukPatreonThanks(PatreonThanks):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Ali  Yahya\",\n",
        "            \"Meshal  Alshammari\",\n",
        "            \"CrypticSwarm    \",\n",
        "            \"Ankit   Agarwal\",\n",
        "            \"Yu  Jun\",\n",
        "            \"Shelby  Doolittle\",\n",
        "            \"Dave    Nicponski\",\n",
        "            \"Damion  Kistler\",\n",
        "            \"Juan    Benet\",\n",
        "            \"Othman  Alikhan\",\n",
        "            \"Justin Helps\",\n",
        "            \"Markus  Persson\",\n",
        "            \"Dan Buchoff\",\n",
        "            \"Derek   Dai\",\n",
        "            \"Joseph  John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Guido   Gambardella\",\n",
        "            \"Jerry   Ling\",\n",
        "            \"Mark    Govea\",\n",
        "            \"Vecht\",\n",
        "            \"Jonathan    Eppele\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish    Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Kirk    Werklund\",\n",
        "            \"Ripta   Pasay\",\n",
        "            \"Felipe  Diniz\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class MortyLookingAtRectangle(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.to_corner(DOWN+RIGHT)\n",
        "        url = OldTexText(\"www.thegreatcoursesplus.com/3blue1brown\")\n",
        "        url.scale(0.75)\n",
        "        url.to_corner(UP+LEFT)\n",
        "        rect = Rectangle(height = 9, width = 16)\n",
        "        rect.set_height(5)\n",
        "        rect.next_to(url, DOWN)\n",
        "        rect.shift_onto_screen()\n",
        "        url.save_state()\n",
        "        url.next_to(morty.get_corner(UP+LEFT), UP)\n",
        "        url.shift_onto_screen()\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(\n",
        "            morty.change_mode, \"raise_right_hand\",\n",
        "            morty.look_at, url,\n",
        "        )\n",
        "        self.play(Write(url))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            url.restore,\n",
        "            morty.change_mode, \"happy\"\n",
        "        )\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        for mode in [\"pondering\", \"hooray\", \"happy\", \"pondering\", \"happy\"]:\n",
        "            self.play(morty.change_mode, mode)\n",
        "            self.wait(2)\n",
        "            self.play(Blink(morty))\n",
        "            self.wait(2)\n",
        "\n",
        "class RotatingThreeDSphereProjection(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "    }\n",
        "    def construct(self):\n",
        "        sphere = VGroup(*[\n",
        "            Circle(radius = np.sin(t)).shift(np.cos(t)*OUT)\n",
        "            for t in np.linspace(0, np.pi, 20)\n",
        "        ])\n",
        "        sphere.set_stroke(BLUE, width = 2)\n",
        "        # sphere.set_fill(BLUE, opacity = 0.1)\n",
        "\n",
        "        self.play(Rotating(\n",
        "            sphere, axis = RIGHT+OUT,\n",
        "            run_time = 10\n",
        "        ))\n",
        "        self.repeat_frames(4)\n",
        "\n",
        "class FourDSphereProjectTo4D(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class Test(Scene):\n",
        "    CONFIG = {\n",
        "        \"camera_class\" : ThreeDCamera,\n",
        "    }\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        necklace = Necklace()\n",
        "        necklace.insert_n_curves(20)\n",
        "        # necklace.apply_function(\n",
        "        #     lambda (x, y, z) : x*RIGHT + (y + 0.1*x**2)*UP\n",
        "        # )\n",
        "        necklace.set_width(randy.get_width() + 1)\n",
        "        necklace.move_to(randy)\n",
        "\n",
        "        self.add(randy, necklace)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}