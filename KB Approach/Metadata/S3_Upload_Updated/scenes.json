{
    "topic": "The mathematical concept being demonstrated is the probability of a word given its pattern and the prior distribution over words",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2022.wordle.simulations import *\n",
        "\n",
        "\n",
        "# Scene types\n",
        "\n",
        "\n",
        "class WordleScene(Scene):\n",
        "    n_letters = 5\n",
        "    grid_height = 6\n",
        "    font_to_square_height = 65\n",
        "    grid_center = ORIGIN\n",
        "    secret_word = None\n",
        "    color_map = {\n",
        "        0: \"#797C7E\",  # GREY\n",
        "        1: \"#C6B566\",  # YELLOW\n",
        "        2: GREEN_D,  # GREEN\n",
        "    }\n",
        "    uniform_prior = False\n",
        "    wordle_based_prior = False\n",
        "    freq_prior = True\n",
        "    reveal_run_time = 2\n",
        "    reveal_lag_ratio = 0.5\n",
        "\n",
        "    CONFIG = {\"random_seed\": None}\n",
        "\n",
        "    def setup(self):\n",
        "        self.all_words = self.get_word_list()\n",
        "        self.priors = self.get_priors()\n",
        "        if self.secret_word is None:\n",
        "            s_words = get_word_list(short=True)\n",
        "            self.secret_word = random.choice(s_words)\n",
        "        self.guesses = []\n",
        "        self.patterns = []\n",
        "        self.possibilities = self.get_initial_possibilities()\n",
        "\n",
        "        self.add_grid()\n",
        "\n",
        "    def get_word_list(self):\n",
        "        return get_word_list()\n",
        "\n",
        "    def get_initial_possibilities(self):\n",
        "        return get_word_list()\n",
        "\n",
        "    def get_priors(self):\n",
        "        words = self.all_words\n",
        "        if self.uniform_prior:\n",
        "            return dict((w, 1) for w in words)\n",
        "        elif self.wordle_based_prior:\n",
        "            return get_true_wordle_prior()\n",
        "        else:\n",
        "            return get_frequency_based_priors()\n",
        "\n",
        "    def get_pattern(self, guess):\n",
        "        return get_pattern(guess, self.secret_word)\n",
        "\n",
        "    def get_current_entropy(self):\n",
        "        weights = get_weights(self.possibilities, self.priors)\n",
        "        return entropy_of_distributions(weights)\n",
        "\n",
        "    ##\n",
        "\n",
        "    def add_grid(self):\n",
        "        buff = 0.1\n",
        "        row = Square(side_length=1).get_grid(1, self.n_letters, buff=buff)\n",
        "        grid = row.get_grid(6, 1, buff=buff)\n",
        "        grid.set_height(self.grid_height)\n",
        "        grid.move_to(self.grid_center)\n",
        "        grid.set_stroke(WHITE, 2)\n",
        "        grid.words = VGroup()\n",
        "        grid.pending_word = VGroup()\n",
        "        grid.add(grid.words, grid.pending_word)\n",
        "        grid.pending_pattern = None\n",
        "        grid.add_updater(lambda m: m)\n",
        "        self.grid = grid\n",
        "        self.add(grid)\n",
        "\n",
        "    def get_curr_row(self):\n",
        "        return self.grid[len(self.grid.words)]\n",
        "\n",
        "    def get_curr_square(self):\n",
        "        row = self.get_curr_row()\n",
        "        return row[len(self.grid.pending_word)]\n",
        "\n",
        "    def add_letter(self, letter):\n",
        "        grid = self.grid\n",
        "        if len(grid.pending_word) == len(grid[0]):\n",
        "            return\n",
        "\n",
        "        letter_mob = self.get_letter_in_square(letter, self.get_curr_square())\n",
        "        grid.pending_word.add(letter_mob)\n",
        "\n",
        "    def get_letter_in_square(self, letter, square):\n",
        "        font_size = self.font_to_square_height * square.get_height()\n",
        "        letter_mob = Text(letter.upper(), font=\"Consolas\", font_size=font_size)\n",
        "        letter_mob.move_to(square)\n",
        "        return letter_mob\n",
        "\n",
        "    def delete_letter(self):\n",
        "        if len(self.grid.pending_word) == 0:\n",
        "            return\n",
        "        letter_mob = self.grid.pending_word[-1]\n",
        "        self.grid.pending_word.remove(letter_mob)\n",
        "\n",
        "    def add_word(self, word, wait_time_per_letter=0.1):\n",
        "        for letter in word:\n",
        "            self.add_letter(letter)\n",
        "            self.wait(\n",
        "                wait_time_per_letter,\n",
        "                ignore_presenter_mode=True\n",
        "            )\n",
        "\n",
        "    def pending_word_as_string(self):\n",
        "        return \"\".join(\n",
        "            t.text.lower()\n",
        "            for t in self.grid.pending_word\n",
        "        )\n",
        "\n",
        "    def is_valid_guess(self):\n",
        "        guess = self.pending_word_as_string()\n",
        "        return guess in self.all_words\n",
        "\n",
        "    def reveal_pattern(self, pattern=None, animate=True):\n",
        "        grid = self.grid\n",
        "        guess = self.pending_word_as_string()\n",
        "\n",
        "        if not self.is_valid_guess():\n",
        "            self.shake_word_out()\n",
        "            return False\n",
        "\n",
        "        if pattern is None:\n",
        "            pattern = self.get_pattern(guess)\n",
        "            if pattern is None:\n",
        "                return False\n",
        "\n",
        "        self.show_pattern(pattern, animate=animate)\n",
        "\n",
        "        self.guesses.append(guess)\n",
        "        self.patterns.append(pattern)\n",
        "        grid.words.add(grid.pending_word.copy())\n",
        "        grid.pending_word.set_submobjects([])\n",
        "        grid.pending_pattern = None\n",
        "        self.refresh_possibilities(guess, pattern)\n",
        "\n",
        "        # Win condition\n",
        "        if self.has_won():\n",
        "            self.win_animation()\n",
        "\n",
        "        return True\n",
        "\n",
        "    def refresh_possibilities(self, guess, pattern):\n",
        "        self.possibilities = get_possible_words(\n",
        "            guess, pattern, self.possibilities\n",
        "        )\n",
        "\n",
        "    def shake_word_out(self):\n",
        "        row = self.get_curr_row()\n",
        "        c = row.get_center().copy()\n",
        "        func = bezier([0, 0, 1, 1, -1, -1, 0, 0])\n",
        "        self.play(UpdateFromAlphaFunc(\n",
        "            VGroup(row, self.grid.pending_word),\n",
        "            lambda m, a: m.move_to(c + func(a) * RIGHT),\n",
        "            run_time=0.5,\n",
        "        ))\n",
        "        self.grid.pending_word.set_submobjects([])\n",
        "\n",
        "    def show_pattern(self, pattern, animate=False, added_anims=[]):\n",
        "        row = self.get_curr_row()\n",
        "        colors = self.get_colors(pattern)\n",
        "        if animate:\n",
        "            self.animate_color_change(row, self.grid.pending_word, colors, added_anims)\n",
        "        else:\n",
        "            self.set_row_colors(row, colors)\n",
        "\n",
        "        self.grid.pending_pattern = pattern\n",
        "\n",
        "    def set_row_colors(self, row, colors):\n",
        "        for square, color in zip(row, colors):\n",
        "            square.set_fill(color, 1)\n",
        "\n",
        "    def animate_color_change(self, row, word, colors, added_anims=[]):\n",
        "        colors.extend((len(row) - len(colors)) * [self.color_map[0]])\n",
        "        for square, color in zip(row, colors):\n",
        "            square.future_color = color\n",
        "\n",
        "        def alpha_func(mob, alpha):\n",
        "            if not hasattr(mob, 'initial_height'):\n",
        "                mob.initial_height = mob.get_height()\n",
        "            mob.set_height(\n",
        "                mob.initial_height * max(abs(interpolate(1, -1, alpha)), 1e-6),\n",
        "                stretch=True\n",
        "            )\n",
        "            if isinstance(mob, Square) and alpha > 0.5:\n",
        "                mob.set_fill(mob.future_color, 1)\n",
        "\n",
        "        mobjects = self.mobjects\n",
        "        self.play(\n",
        "            *(\n",
        "                LaggedStart(\n",
        "                    *(\n",
        "                        UpdateFromAlphaFunc(sm, alpha_func)\n",
        "                        for sm in mob\n",
        "                    ),\n",
        "                    lag_ratio=self.reveal_lag_ratio,\n",
        "                    run_time=self.reveal_run_time,\n",
        "                )\n",
        "                for mob in (row, word)\n",
        "            ),\n",
        "            *added_anims\n",
        "        )\n",
        "        self.clear()\n",
        "        self.add(*mobjects)\n",
        "\n",
        "    def get_colors(self, pattern):\n",
        "        return [self.color_map[key] for key in pattern_to_int_list(pattern)]\n",
        "\n",
        "    def win_animation(self):\n",
        "        grid = self.grid\n",
        "        row = grid[len(grid.words) - 1]\n",
        "        letters = grid.words[-1]\n",
        "        mover = VGroup(*(\n",
        "            VGroup(square, letter)\n",
        "            for square, letter in zip(row, letters)\n",
        "        ))\n",
        "        y = row.get_y()\n",
        "        bf = bezier([0, 0, 1, 1, -1, -1, 0, 0])\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                UpdateFromAlphaFunc(sm, lambda m, a: m.set_y(y + 0.2 * bf(a)))\n",
        "                for sm in mover\n",
        "            ), lag_ratio=0.1, run_time=1.5),\n",
        "            LaggedStart(*(\n",
        "                Flash(letter, line_length=0.1, flash_radius=0.4)\n",
        "                for letter in letters\n",
        "            ), lag_ratio=0.3, run_time=1.5),\n",
        "        )\n",
        "\n",
        "    def has_won(self):\n",
        "        return len(self.patterns) > 0 and self.patterns[-1] == 3**5 - 1\n",
        "\n",
        "    @staticmethod\n",
        "    def get_grid_of_words(all_words, n_rows, n_cols, dots_index=-5, sort_key=None, font_size=24):\n",
        "        if sort_key:\n",
        "            all_words = list(sorted(all_words, key=sort_key))\n",
        "        subset = all_words[:n_rows * n_cols]\n",
        "        show_ellipsis = len(subset) < len(all_words)\n",
        "\n",
        "        if show_ellipsis:\n",
        "            subset[dots_index] = \"...\" if n_cols == 1 else \".....\"\n",
        "            subset[dots_index + 1:] = all_words[dots_index + 1:]\n",
        "\n",
        "        full_string = \"\"\n",
        "        for i, word in zip(it.count(1), subset):\n",
        "            full_string += str(word)\n",
        "            if i % n_cols == 0:\n",
        "                full_string += \" \\n\"\n",
        "            else:\n",
        "                full_string += \"  \"\n",
        "\n",
        "        full_text_mob = Text(full_string, font=\"Consolas\", font_size=font_size)\n",
        "\n",
        "        result = VGroup()\n",
        "        for word in subset:\n",
        "            part = full_text_mob.get_part_by_text(word)\n",
        "            part.text = word\n",
        "            result.add(part)\n",
        "\n",
        "        if show_ellipsis and n_cols == 1:\n",
        "            result[dots_index].rotate(PI / 2)\n",
        "            result[dots_index].next_to(result[dots_index - 1], DOWN, SMALL_BUFF)\n",
        "            result[dots_index + 1:].next_to(result[dots_index], DOWN, SMALL_BUFF)\n",
        "        result.set_color(GREY_A)\n",
        "        result.words = subset\n",
        "\n",
        "        return result\n",
        "\n",
        "    @staticmethod\n",
        "    def patterns_to_squares(patterns, color_map=None):\n",
        "        if color_map is None:\n",
        "            color_map = WordleScene.color_map\n",
        "        row = Square().get_grid(1, 5, buff=SMALL_BUFF)\n",
        "        rows = row.get_grid(len(patterns), 1, buff=SMALL_BUFF)\n",
        "        rows.set_stroke(WHITE, 1)\n",
        "        for pattern, row in zip(patterns, rows):\n",
        "            for square, key in zip(row, pattern_to_int_list(pattern)):\n",
        "                square.set_fill(color_map[key], 1)\n",
        "        return rows\n",
        "\n",
        "    # Interactive parts\n",
        "    def on_key_press(self, symbol, modifiers):\n",
        "        try:\n",
        "            char = chr(symbol)\n",
        "        except OverflowError:\n",
        "            log.warning(\"The value of the pressed key is too large.\")\n",
        "            return\n",
        "\n",
        "        is_letter = (ord('a') <= ord(char) <= ord('z'))\n",
        "\n",
        "        if is_letter:\n",
        "            self.add_letter(char)\n",
        "        elif symbol == 65288:  # Delete\n",
        "            self.delete_letter()\n",
        "        elif symbol == 65293:  # Enter\n",
        "            self.reveal_pattern()\n",
        "\n",
        "        if char == 'q' and modifiers == 1:\n",
        "            self.delete_letter()\n",
        "            self.quit_interaction = True\n",
        "\n",
        "        if not is_letter:\n",
        "            super().on_key_press(symbol, modifiers)\n",
        "\n",
        "\n",
        "class WordleSceneWithAnalysis(WordleScene):\n",
        "    grid_center = [-1.75, 1, 0]\n",
        "    grid_height = 4.5\n",
        "    look_two_ahead = False\n",
        "    show_prior = True\n",
        "    n_top_picks = 13\n",
        "    entropy_color = TEAL_C\n",
        "    prior_color = BLUE_C\n",
        "    weight_to_prob = 3.0\n",
        "    pre_computed_first_guesses = []\n",
        "\n",
        "    def setup(self):\n",
        "        self.wait_to_proceed = True\n",
        "        super().setup()\n",
        "        self.show_possible_words()\n",
        "        self.add_count_title()\n",
        "        self.add_guess_value_grid_title()\n",
        "        self.init_guess_value_grid()\n",
        "        self.info_labels = VGroup()\n",
        "        self.add(self.info_labels)\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_guess_values()\n",
        "\n",
        "    def add_guess_value_grid_title(self):\n",
        "        titles = VGroup(\n",
        "            Text(\"Top picks\"),\n",
        "            Text(\"E[Info.]\", color=self.entropy_color),\n",
        "        )\n",
        "        if self.look_two_ahead:\n",
        "            titles.add(OldTexText(\"E[Info$_2$]\", color=self.entropy_color)[0])\n",
        "        if self.show_prior:\n",
        "            titles.add(OldTex(\"p(\\\\text{word})\", color=self.prior_color))\n",
        "\n",
        "        titles.scale(0.7)\n",
        "        titles.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        titles.set_max_width(5)\n",
        "        low_y = titles[0][0].get_bottom()[1]\n",
        "\n",
        "        for title in titles:\n",
        "            first = title.family_members_with_points()[0]\n",
        "            title.shift((low_y - first.get_bottom()[1]) * UP)\n",
        "            underline = Underline(title)\n",
        "            underline.match_y(first.get_bottom() + 0.025 * DOWN)\n",
        "            underline.set_stroke(WHITE, 2)\n",
        "            underline.scale(1.1)\n",
        "            title.add_to_back(underline)\n",
        "            title.set_backstroke()\n",
        "            underline.set_stroke(GREY_C, 2)\n",
        "\n",
        "        titles.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        titles.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(titles)\n",
        "        self.guess_value_grid_titles = titles\n",
        "\n",
        "    def add_count_title(self):\n",
        "        title = VGroup(\n",
        "            Text(\"# Possibilities\"),\n",
        "            Text(\"/\"),\n",
        "            Text(\"Uncertainty\", color=self.entropy_color),\n",
        "        )\n",
        "        title.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        title.match_width(self.count_label).scale(1.1)\n",
        "        title.next_to(self.count_label, UP, buff=MED_LARGE_BUFF)\n",
        "        self.count_title = title\n",
        "        self.add(title)\n",
        "\n",
        "    def init_guess_value_grid(self):\n",
        "        titles = self.guess_value_grid_titles\n",
        "        line = Line().match_width(titles)\n",
        "        line.set_stroke(GREY_C, 1)\n",
        "        lines = line.get_grid(self.n_top_picks, 1, buff=0.5)\n",
        "        lines.next_to(titles, DOWN, buff=0.75)\n",
        "\n",
        "        self.guess_value_grid_lines = lines\n",
        "        self.guess_value_grid = VGroup()\n",
        "\n",
        "    def get_count_label(self):\n",
        "        score = len(self.grid.words)\n",
        "        label = VGroup(\n",
        "            Integer(len(self.possibilities), edge_to_fix=UR),\n",
        "            Text(\"Pos,\"),\n",
        "            DecimalNumber(self.get_current_entropy(), edge_to_fix=UR, color=self.entropy_color),\n",
        "            Text(\"Bits\", color=self.entropy_color),\n",
        "        )\n",
        "        label.arrange(\n",
        "            RIGHT,\n",
        "            buff=MED_SMALL_BUFF,\n",
        "            aligned_edge=UP,\n",
        "        )\n",
        "        label.scale(0.6)\n",
        "        label.next_to(self.grid[score], LEFT)\n",
        "        return label\n",
        "\n",
        "    def reveal_pattern(self, pattern=None, animate=True):\n",
        "        is_valid_guess = self.is_valid_guess()\n",
        "        if is_valid_guess:\n",
        "            self.isolate_guessed_row()\n",
        "\n",
        "        did_fill = super().reveal_pattern(pattern, animate)\n",
        "        if not did_fill:\n",
        "            return False\n",
        "\n",
        "        if self.presenter_mode:\n",
        "            while self.wait_to_proceed:\n",
        "                self.update_frame(1 / self.camera.frame_rate)\n",
        "            self.wait_to_proceed = True\n",
        "\n",
        "        if is_valid_guess and not self.has_won():\n",
        "            self.show_possible_words()\n",
        "            self.wait()\n",
        "            self.show_guess_values()\n",
        "        if self.has_won():\n",
        "            self.play(\n",
        "                FadeOut(self.guess_value_grid, RIGHT),\n",
        "                FadeOut(self.guess_value_grid_titles, RIGHT),\n",
        "            )\n",
        "\n",
        "    def show_pattern(self, pattern, *args, **kwargs):\n",
        "        guess = self.pending_word_as_string()\n",
        "        new_possibilities = get_possible_words(\n",
        "            guess, pattern, self.possibilities\n",
        "        )\n",
        "        for word_mob, word, bar in zip(self.shown_words, self.shown_words.words, self.prob_bars):\n",
        "            if word not in new_possibilities and word != \"...\":\n",
        "                word_mob.set_fill(RED, 0.5)\n",
        "                bar.set_opacity(0.2)\n",
        "        self.show_pattern_information(guess, pattern, new_possibilities)\n",
        "        super().show_pattern(pattern, *args, **kwargs)\n",
        "\n",
        "    def show_pattern_information(self, guess, pattern, new_possibilities):\n",
        "        # Put bits label next to pattern\n",
        "        weights = get_weights(self.possibilities, self.priors)\n",
        "        prob = sum(\n",
        "            weight for word, weight in zip(self.possibilities, weights)\n",
        "            if word in new_possibilities\n",
        "        )\n",
        "        info = -math.log2(prob)\n",
        "\n",
        "        ref = self.count_label[2:]\n",
        "        info_label = VGroup(\n",
        "            DecimalNumber(info),\n",
        "            Text(\"Bits\")\n",
        "        )\n",
        "        info_label.set_color(RED)\n",
        "        info_label.arrange(RIGHT)\n",
        "        info_label.match_height(ref)\n",
        "        info_label.next_to(self.get_curr_row(), RIGHT, buff=MED_SMALL_BUFF)\n",
        "        info_label.match_y(ref)\n",
        "        self.info_labels.add(info_label)\n",
        "\n",
        "    def isolate_guessed_row(self):\n",
        "        guess = self.pending_word_as_string()\n",
        "        rows = self.guess_value_grid\n",
        "        row_words = [row[0].text for row in rows]\n",
        "\n",
        "        if guess in row_words:\n",
        "            row = rows[row_words.index(guess)]\n",
        "            rows.set_opacity(0.2)\n",
        "            row[:-1].set_fill(YELLOW, 1)\n",
        "        else:\n",
        "            new_row = self.get_guess_value_row(\n",
        "                self.guess_value_grid_lines[0], guess,\n",
        "            )\n",
        "            rows.shift(DOWN)\n",
        "            rows.add(new_row)\n",
        "\n",
        "    def get_shown_words(self, font_size=24):\n",
        "        return self.get_grid_of_words(\n",
        "            self.possibilities,\n",
        "            n_rows=20 - 2 * len(self.grid.words),\n",
        "            n_cols=1\n",
        "        )\n",
        "\n",
        "    def get_probability_bars(self, shown_words, max_width=1.0):\n",
        "        mobs = shown_words\n",
        "        words = shown_words.words\n",
        "        probs = [self.priors.get(w, 0) for w in words]  # Unnormalized\n",
        "        height = mobs[0].get_height() * 0.7\n",
        "        bars = VGroup(*(\n",
        "            Rectangle(\n",
        "                width=prob * max_width,\n",
        "                height=height,\n",
        "                fill_color=self.prior_color,\n",
        "                fill_opacity=0.7,\n",
        "                stroke_width=0.5 * (prob > 0),\n",
        "                stroke_color=self.prior_color\n",
        "            )\n",
        "            for prob in probs\n",
        "        ))\n",
        "        for bar, mob in zip(bars, mobs):\n",
        "            bar.next_to(mob, RIGHT, SMALL_BUFF)\n",
        "            bar.align_to(bars[0], LEFT)\n",
        "\n",
        "        # if not self.show_prior:\n",
        "        #     bars.set_opacity(0)\n",
        "\n",
        "        return bars\n",
        "\n",
        "    def show_possible_words(self):\n",
        "        shown_words = self.get_shown_words()\n",
        "        count_label = self.get_count_label()\n",
        "        shown_words.next_to(count_label[:2], DOWN, buff=0.35)\n",
        "        prob_bars = self.get_probability_bars(shown_words)\n",
        "\n",
        "        if len(self.grid.words) > 0:\n",
        "            # Set up label transition\n",
        "            prev_count_label = self.count_label\n",
        "            count_label.shift(\n",
        "                (prev_count_label[1].get_right() - count_label[1].get_right())[0] * RIGHT\n",
        "            )\n",
        "\n",
        "            num_rate_func = squish_rate_func(rush_into, 0.3, 1)\n",
        "\n",
        "            def update_moving_count_label(label, alpha):\n",
        "                for i in (0, 2):\n",
        "                    label[i].set_value(interpolate(\n",
        "                        prev_count_label[i].get_value(),\n",
        "                        count_label[i].get_value(),\n",
        "                        num_rate_func(alpha),\n",
        "                    ))\n",
        "                label.set_y(interpolate(\n",
        "                    prev_count_label.get_y(),\n",
        "                    count_label.get_y(),\n",
        "                    alpha\n",
        "                ))\n",
        "                return label\n",
        "\n",
        "            label_transition = UpdateFromAlphaFunc(\n",
        "                prev_count_label.copy(),\n",
        "                update_moving_count_label,\n",
        "                remover=True\n",
        "            )\n",
        "\n",
        "            # Set up word transition\n",
        "            prev_words = self.shown_words\n",
        "            for shown_word, s_word in zip(shown_words, shown_words.words):\n",
        "                shown_word.save_state()\n",
        "                if s_word in prev_words.words:\n",
        "                    index = prev_words.words.index(s_word)\n",
        "                    shown_word.move_to(prev_words[index])\n",
        "                    prev_words[index].set_opacity(0)\n",
        "                    self.prob_bars[index].set_opacity(0)\n",
        "                elif \"...\" in prev_words.words:\n",
        "                    shown_word.move_to(prev_words[prev_words.words.index(\"...\")])\n",
        "                    shown_word.set_opacity(0)\n",
        "                else:\n",
        "                    shown_word.set_opacity(0)\n",
        "\n",
        "            prev_words.generate_target()\n",
        "            for i, word in enumerate(prev_words.words):\n",
        "                if word not in shown_words.words:\n",
        "                    fader = prev_words.target[i]\n",
        "                    fader.set_opacity(0)\n",
        "                    fader.shift(LEFT)\n",
        "\n",
        "            # Set up bar transitions\n",
        "            for bar, s_word, word in zip(prob_bars, shown_words, shown_words.words):\n",
        "                bar.save_state()\n",
        "                if word not in prev_words.words:\n",
        "                    bar.set_opacity(0)\n",
        "                bar.match_y(s_word)\n",
        "                bar.align_to(bar.saved_state, LEFT)\n",
        "\n",
        "            # Carry out animations\n",
        "            self.play(\n",
        "                FadeOut(self.prob_bars, run_time=0.25),\n",
        "                FadeOut(self.guess_value_grid, RIGHT),\n",
        "                label_transition,\n",
        "                MoveToTarget(prev_words, run_time=0.5),\n",
        "                LaggedStartMap(Restore, shown_words, run_time=1),\n",
        "                LaggedStartMap(Restore, prob_bars, run_time=1),\n",
        "                run_time=1,\n",
        "            )\n",
        "            self.add(count_label)\n",
        "            self.remove(prev_words)\n",
        "            shown_words.set_opacity(1)\n",
        "\n",
        "        self.add(count_label)\n",
        "        self.add(shown_words)\n",
        "        self.add(prob_bars)\n",
        "        self.count_label = count_label\n",
        "        self.shown_words = shown_words\n",
        "        self.prob_bars = prob_bars\n",
        "\n",
        "    def show_guess_values(self):\n",
        "        self.guess_value_grid = self.get_guess_value_grid()\n",
        "        self.play(ShowIncreasingSubsets(self.guess_value_grid))\n",
        "\n",
        "    def get_guess_value_grid(self, font_size=36):\n",
        "        if self.pre_computed_first_guesses and len(self.grid.words) == 0:\n",
        "            guesses = self.pre_computed_first_guesses\n",
        "            top_indices = np.arange(len(guesses))\n",
        "        else:\n",
        "            guesses = self.all_words\n",
        "            expected_scores = get_expected_scores(\n",
        "                guesses,\n",
        "                self.possibilities,\n",
        "                self.priors,\n",
        "                look_two_ahead=self.look_two_ahead\n",
        "            )\n",
        "            top_indices = np.argsort(expected_scores)[:self.n_top_picks]\n",
        "\n",
        "        guess_values_array = get_guess_values_array(\n",
        "            guesses,\n",
        "            self.possibilities,\n",
        "            self.priors,\n",
        "            look_two_ahead=self.look_two_ahead,\n",
        "        )\n",
        "        top_words = np.array(guesses)[top_indices]\n",
        "        top_guess_value_parts = guess_values_array[:, top_indices]\n",
        "\n",
        "        lines = self.get_guess_value_grid_lines()\n",
        "        guess_value_grid = VGroup(*(\n",
        "            self.get_guess_value_row(line, word, *values)\n",
        "            for line, word, values in zip(\n",
        "                lines, top_words, top_guess_value_parts.T\n",
        "            )\n",
        "        ))\n",
        "        for value, row in zip(guess_values_array.sum(0)[top_indices], guess_value_grid):\n",
        "            if value == 0:\n",
        "                row.set_opacity(0)\n",
        "\n",
        "        guess_value_grid.set_stroke(background=True)\n",
        "        return guess_value_grid\n",
        "\n",
        "    def get_guess_value_row(self, line, word,\n",
        "                            entropy=None,\n",
        "                            entropy2=None,\n",
        "                            probability=None,\n",
        "                            font_size=36):\n",
        "        titles = self.guess_value_grid_titles\n",
        "        row = VGroup()\n",
        "\n",
        "        # Word\n",
        "        word_mob = Text(str(word), font=\"Consolas\", font_size=font_size)\n",
        "        index = np.argmin([c.get_height() for c in word_mob])\n",
        "        aligner = word_mob[index]\n",
        "        word_mob.shift(line.get_center() - aligner.get_bottom() + 0.5 * SMALL_BUFF * UP)\n",
        "        word_mob.match_x(titles[0])\n",
        "        row.add(word_mob)\n",
        "\n",
        "        # Entropy\n",
        "        if entropy is None:\n",
        "            weights = get_weights(self.possibilities, self.priors)\n",
        "            entropy = get_entropies([word], self.possibilities, weights)[0]\n",
        "        dec_kw = dict(num_decimal_places=2, font_size=font_size)\n",
        "        row.add(DecimalNumber(entropy, color=self.entropy_color, **dec_kw))\n",
        "\n",
        "        # Second entropy\n",
        "        if self.look_two_ahead:\n",
        "            if entropy2 is None:\n",
        "                entropy2 = get_average_second_step_entropies(\n",
        "                    [word], self.all_words, self.possibilities, self.priors\n",
        "                )\n",
        "            row.add(DecimalNumber(entropy2, color=self.entropy_color, **dec_kw))\n",
        "\n",
        "        # Prior\n",
        "        if self.show_prior:\n",
        "            if probability is None:\n",
        "                if word in self.possibilities:\n",
        "                    weights = get_weights(self.possibilities, self.priors)\n",
        "                    probability = weights[self.possibilities.index(word)]\n",
        "                else:\n",
        "                    probability = 0\n",
        "            dec_kw['num_decimal_places'] = 5\n",
        "            # Dividing out by the weight given to prob in scores\n",
        "            row.add(DecimalNumber(probability, color=self.prior_color, **dec_kw))\n",
        "\n",
        "        for mob, title in zip(row, titles):\n",
        "            if mob is not word_mob:\n",
        "                mob.match_y(aligner, DOWN)\n",
        "            mob.match_x(title)\n",
        "\n",
        "        row.add(line)\n",
        "        return row\n",
        "\n",
        "    def get_guess_value_grid_lines(self):\n",
        "        titles = self.guess_value_grid_titles\n",
        "        line = Line().match_width(titles)\n",
        "        line.set_stroke(GREY_C, 1)\n",
        "        lines = line.get_grid(self.n_top_picks, 1, buff=0.5)\n",
        "        lines.next_to(titles, DOWN, buff=0.75)\n",
        "        return lines\n",
        "\n",
        "    def get_column_of_numbers(self, values, row_refs, col_ref, num_decimal_places=2, font_size=36):\n",
        "        mobs = VGroup(*(\n",
        "            DecimalNumber(\n",
        "                value,\n",
        "                num_decimal_places=num_decimal_places,\n",
        "                font_size=font_size\n",
        "            )\n",
        "            for value in values\n",
        "        ))\n",
        "        for row_ref, mob in zip(row_refs, mobs):\n",
        "            mob.match_x(col_ref)\n",
        "            mob.match_y(row_ref)\n",
        "        return mobs\n",
        "\n",
        "    def on_key_press(self, symbol, modifiers):\n",
        "        if chr(symbol) == \" \":\n",
        "            self.wait_to_proceed = False\n",
        "        super().on_key_press(symbol, modifiers)\n",
        "\n",
        "\n",
        "class WordleDistributions(WordleScene):\n",
        "    grid_center = [-4.5, -0.5, 0]\n",
        "    grid_height = 5\n",
        "    bar_style = dict(\n",
        "        fill_color=TEAL_D,\n",
        "        fill_opacity=0.8,\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=0.1,\n",
        "    )\n",
        "    show_fraction_in_p_label = True\n",
        "\n",
        "    def get_axes(self,\n",
        "                 x_max=3**5 / 2, y_max=0.1,\n",
        "                 width=7.5,\n",
        "                 height=6):\n",
        "        axes = Axes(\n",
        "            (0, x_max),\n",
        "            (0, y_max, y_max / 5),\n",
        "            height=height,\n",
        "            width=width,\n",
        "            x_axis_config={\n",
        "                \"tick_size\": 0,\n",
        "            }\n",
        "        )\n",
        "        axes.next_to(self.grid, RIGHT, LARGE_BUFF, aligned_edge=DOWN)\n",
        "        # y_label = OldTex(\"p(\\\\text{Pattern})\", font_size=24)\n",
        "        # y_label.next_to(axes.y_axis.get_top(), UR, buff=SMALL_BUFF)\n",
        "        # axes.y_axis.add(y_label)\n",
        "        axes.y_axis.add_numbers(num_decimal_places=2)\n",
        "\n",
        "        x_label = Text(\"Pattern\", font_size=24)\n",
        "        x_label.next_to(axes.x_axis.get_right(), DR, MED_SMALL_BUFF)\n",
        "        x_label.shift_onto_screen()\n",
        "        axes.x_axis.add(x_label)\n",
        "\n",
        "        self.axes = axes\n",
        "        return axes\n",
        "\n",
        "    def get_total_words_label(self, font_size=36):\n",
        "        label = VGroup(\n",
        "            Integer(len(self.all_words), font_size=font_size, edge_to_fix=UR),\n",
        "            Text(\"Total words\", font_size=font_size)\n",
        "        )\n",
        "        label.arrange(RIGHT, aligned_edge=UP)\n",
        "        label.match_x(self.grid)\n",
        "        label.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        return label\n",
        "\n",
        "    def get_dynamic_match_label(self, font_size=36):\n",
        "        label = VGroup(\n",
        "            Integer(len(self.possibilities), font_size=font_size, edge_to_fix=UR),\n",
        "            Text(\"Possible matches\", font_size=font_size)\n",
        "        )\n",
        "        label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        label.set_max_width(self.grid.get_width())\n",
        "        label.next_to(self.grid, UP)\n",
        "\n",
        "        def update_label(label):\n",
        "            word = self.pending_word_as_string()\n",
        "            if self.grid.pending_pattern is None or not self.is_valid_guess():\n",
        "                label.set_opacity(0)\n",
        "            else:\n",
        "                buckets = get_word_buckets(word, self.possibilities)\n",
        "                bucket_size = len(buckets[self.grid.pending_pattern])\n",
        "                label[0].set_value(bucket_size)\n",
        "                label[0].next_to(label[1], LEFT, submobject_to_align=label[0][-1])\n",
        "                label.set_opacity(1)\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "\n",
        "        return label\n",
        "\n",
        "    def get_bars(self, axes, values):\n",
        "        x_unit = axes.x_axis.unit_size\n",
        "        y_unit = axes.y_axis.unit_size\n",
        "        bars = Rectangle(width=x_unit, **self.bar_style).replicate(3**5)\n",
        "\n",
        "        for x, bar, value in zip(it.count(), bars, values):\n",
        "            bar.set_height(value * y_unit, stretch=True)\n",
        "            bar.move_to(axes.c2p(x, 0), DL)\n",
        "        return bars\n",
        "\n",
        "    def get_distribution_bars(self, axes, guess):\n",
        "        distribution = get_pattern_distributions(\n",
        "            [guess], self.possibilities,\n",
        "            get_weights(self.possibilities, self.priors)\n",
        "        )[0]\n",
        "        buckets = get_word_buckets(guess, self.possibilities)\n",
        "        pattern_indices = np.argsort(distribution)[::-1]\n",
        "\n",
        "        bars = self.get_bars(axes, distribution[pattern_indices])\n",
        "        bars.patterns = pattern_indices\n",
        "\n",
        "        for i, bar in enumerate(bars):\n",
        "            bar.prob = distribution[pattern_indices[i]]\n",
        "            bar.count = len(buckets[pattern_indices[i]])\n",
        "        return bars\n",
        "\n",
        "    def get_bar_indicator(self, bars, pattern_index):\n",
        "        pattern_index_tracker = ValueTracker(pattern_index)\n",
        "\n",
        "        def get_pattern_index():\n",
        "            return int(pattern_index_tracker.get_value())\n",
        "\n",
        "        def get_pattern():\n",
        "            return bars.patterns[get_pattern_index()]\n",
        "\n",
        "        tri = ArrowTip(angle=PI / 2)\n",
        "        tri.set_height(0.1)\n",
        "        tri.add_updater(lambda m: m.next_to(bars[get_pattern_index()], DOWN, buff=0))\n",
        "\n",
        "        row = self.get_curr_row()\n",
        "        row_copy = row.copy()\n",
        "        row_copy.scale(0.25)\n",
        "        row_copy.add_updater(lambda m: m.next_to(tri, DOWN, SMALL_BUFF))\n",
        "\n",
        "        bars.add_updater(lambda m: m.set_opacity(0.35))\n",
        "        bars.add_updater(lambda m: m[get_pattern_index()].set_opacity(1))\n",
        "        self.grid.add_updater(lambda m: self.show_pattern(get_pattern()))\n",
        "        self.add(self.grid)\n",
        "        row_copy.add_updater(lambda m: m.match_style(row).set_stroke(width=0.1))\n",
        "\n",
        "        self.mouse_drag_point.move_to(tri)\n",
        "        pattern_index_tracker.add_updater(lambda m: m.set_value(\n",
        "            clip(self.axes.x_axis.p2n(self.mouse_drag_point.get_center()), 0, 3**5)\n",
        "        ))\n",
        "\n",
        "        indicator = Group(tri, row_copy)\n",
        "\n",
        "        def get_bar():\n",
        "            value = pattern_index_tracker.get_value()\n",
        "            index = int(clip(value, 0, 3**5 - 1))\n",
        "            return bars[index]\n",
        "\n",
        "        return indicator, pattern_index_tracker, get_bar\n",
        "\n",
        "    def get_dynamic_bar_label(self, tex, font_size=36):\n",
        "        row_copy = self.get_curr_row().copy()\n",
        "        row_copy.scale(0.25)\n",
        "        ndp = len(tex[-1].split(\".\")[1])\n",
        "        dec = DecimalNumber(0, num_decimal_places=ndp, font_size=font_size)\n",
        "        result = VGroup(*Tex(*tex, font_size=font_size))\n",
        "        row_copy.replace(result[1], dim_to_match=0)\n",
        "        dec.replace(result[-1])\n",
        "        result.replace_submobject(1, row_copy)\n",
        "\n",
        "        result.remove(result[-1])\n",
        "        result.add(dec)\n",
        "\n",
        "        result.add_updater(lambda m: m[1].match_style(self.get_curr_row()).set_stroke(WHITE, 0.1))\n",
        "        return result\n",
        "\n",
        "    def get_p_label(self, get_bar, max_y=1):\n",
        "        poss_string = \"{:,}\".format(len(self.possibilities)).replace(\",\", \"{,}\")\n",
        "        strs = [\"p\\\\left(\", \"00000\", \"\\\\right)\", \"=\"]\n",
        "        if self.show_fraction_in_p_label:\n",
        "            strs.extend([\"{\" + poss_string, \"\\\\over \", poss_string + \"}\", \"=\", ])\n",
        "        strs.append(\"0.0000\")\n",
        "        p_label = self.get_dynamic_bar_label(strs)\n",
        "\n",
        "        if self.show_fraction_in_p_label:\n",
        "            num = Integer(edge_to_fix=DOWN, font_size=36)\n",
        "            num.move_to(p_label[4], DOWN)\n",
        "            p_label.replace_submobject(4, num)\n",
        "\n",
        "        def update_label(label):\n",
        "            label[4].set_value(int(get_bar().count))\n",
        "            label[-1].set_value(get_bar().prob)\n",
        "            label.next_to(get_bar(), UR, SMALL_BUFF)\n",
        "            label.set_y(min(max_y, label.get_y()))\n",
        "            label.shift_onto_screen(buff=1.0)\n",
        "\n",
        "        p_label.add_updater(update_label)\n",
        "        return p_label\n",
        "\n",
        "    def get_information_label(self, p_label, get_bar):\n",
        "        info_label = self.get_dynamic_bar_label(\n",
        "            (\n",
        "                \"I\\\\left(\", \"00000\", \"\\\\right)\", \"=\",\n",
        "                \"\\\\log_2\\\\left(1 / p)\", \"=\",\n",
        "                \"0.00\"\n",
        "            ),\n",
        "        )\n",
        "        info_label.add_updater(lambda m: m[-1].set_value(-safe_log2(get_bar().prob)))\n",
        "        info_label.add_updater(lambda m: m.next_to(p_label, UP, aligned_edge=LEFT))\n",
        "        info_label.add_updater(lambda m: m.shift_onto_screen())\n",
        "        return info_label\n",
        "\n",
        "    def get_entropy_label(self, font_size=36):\n",
        "        guess = self.pending_word_as_string()\n",
        "        if self.is_valid_guess():\n",
        "            entropy = get_entropies(\n",
        "                [guess],\n",
        "                self.possibilities,\n",
        "                get_weights(self.possibilities, self.priors)\n",
        "            )[0]\n",
        "        else:\n",
        "            entropy = 0\n",
        "\n",
        "        lhs = OldTex(\n",
        "            \"E[I] = \\\\sum_x \",\n",
        "            \"p(x) \\\\cdot \\\\log_2(1 / p(x))\", \"=\",\n",
        "            tex_to_color_map={\"I\": BLUE},\n",
        "            font_size=font_size,\n",
        "        )\n",
        "        value = DecimalNumber(entropy, font_size=font_size)\n",
        "        value.next_to(lhs[-1], RIGHT)\n",
        "        result = VGroup(lhs, value)\n",
        "        result.move_to(self.axes, UR)\n",
        "        result.to_edge(UP)\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_grid_of_matches(self, n_rows=20, n_cols=9):\n",
        "        if self.grid.pending_pattern is not None:\n",
        "            buckets = get_word_buckets(\n",
        "                self.pending_word_as_string(),\n",
        "                self.possibilities\n",
        "            )\n",
        "            words = buckets[self.grid.pending_pattern]\n",
        "        else:\n",
        "            words = self.possibilities\n",
        "        word_mobs = self.get_grid_of_words(words, n_rows, n_cols)\n",
        "        word_mobs.move_to(midpoint(self.grid.get_right(), RIGHT_SIDE))\n",
        "        return word_mobs\n",
        "\n",
        "    # Animations\n",
        "\n",
        "    def add_distribution(self, axes):\n",
        "        pass\n",
        "\n",
        "\n",
        "class ExternalPatternEntry(WordleSceneWithAnalysis):\n",
        "    # uniform_prior = True\n",
        "    # wordle_based_prior = True\n",
        "\n",
        "    def setup(self):\n",
        "        self.pending_pattern = []\n",
        "        super().setup()\n",
        "\n",
        "    def get_pattern(self, guess):\n",
        "        if len(self.pending_pattern) == 5:\n",
        "            return pattern_from_string(self.pending_pattern)\n",
        "        return None\n",
        "\n",
        "    def reveal_pattern(self, *args, **kwargs):\n",
        "        super().reveal_pattern(*args, **kwargs)\n",
        "        self.pending_pattern = []\n",
        "\n",
        "    # Interactive parts\n",
        "    def on_key_press(self, symbol, modifiers):\n",
        "        char = chr(symbol)\n",
        "        if '0' <= char <= '2' and len(self.pending_pattern) < 5:\n",
        "            square = self.get_curr_row()[len(self.pending_pattern)]\n",
        "            square.set_fill(self.color_map[int(char)], 1)\n",
        "            self.pending_pattern.append(char)\n",
        "        super().on_key_press(symbol, modifiers)\n",
        "\n",
        "\n",
        "class TitleCardScene(WordleScene):\n",
        "    grid_height = 7\n",
        "    words = [\"three\", \"blues\", \"wonts\"]\n",
        "    secret_word = \"brown\"\n",
        "    reveal_run_time = 1\n",
        "    reveal_lag_ratio = 0.2\n",
        "\n",
        "    def construct(self):\n",
        "        for guess in self.words:\n",
        "            for letter in guess:\n",
        "                self.add_letter(letter)\n",
        "                self.wait(0.05 + random.random() * 0.15)\n",
        "            self.reveal_pattern()\n",
        "            self.wait(0.25)\n",
        "        self.wait()\n",
        "\n",
        "    def is_valid_guess(self):\n",
        "        # Everyone's a winner!\n",
        "        return True\n",
        "\n",
        "    def refresh_possibilities(self, guess, pattern):\n",
        "        pass\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "\n",
        "class LessonTitleCard(Scene):\n",
        "    def construct(self):\n",
        "        title = VGroup(\n",
        "            Text(\"Lesson today:\", font_size=40),\n",
        "            Text(\"Information theory\", color=TEAL),\n",
        "        )\n",
        "        title.arrange(DOWN)\n",
        "        title.scale(1.5)\n",
        "        title.center()\n",
        "        title[1].add(\n",
        "            Underline(title[1], buff=-0.05).set_stroke(GREY, 2)\n",
        "        )\n",
        "\n",
        "        self.add(title[0])\n",
        "        self.play(Write(title[1], run_time=1))\n",
        "        self.wait()\n",
        "        self.play(title.animate.scale(1 / 1.5).to_edge(UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DrawPhone(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.center().to_edge(DOWN)\n",
        "\n",
        "        phone = SVGMobject(\"wordle-phone\")\n",
        "        phone.set_height(5)\n",
        "        phone.next_to(morty.get_corner(UR), RIGHT)\n",
        "        phone.shift(UP)\n",
        "        phone.set_fill(opacity=0)\n",
        "        phone.set_stroke(WHITE, 0)\n",
        "\n",
        "        bubble = ThoughtBubble(height=4, width=4, direction=RIGHT)\n",
        "        bubble.next_to(morty, UL, buff=0)\n",
        "        bubble.add_content(WordleScene.patterns_to_squares(\n",
        "            list(map(pattern_from_string, [\"00102\", \"00110\", \"22222\"]))\n",
        "        ))\n",
        "        bubble.content.scale(0.7)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.add(phone)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                morty.change(\"thinking\", phone),\n",
        "                ShowCreation(bubble),\n",
        "                FadeIn(bubble.content, lag_ratio=0.1)\n",
        "            ),\n",
        "            Write(phone, run_time=3, lag_ratio=0.01),\n",
        "        )\n",
        "        self.play(\n",
        "            Blink(morty),\n",
        "            FadeOut(phone),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskWhatWorldeIs(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"What is Wordle?\",\n",
        "            index=0,\n",
        "            target_mode=\"raise_left_hand\",\n",
        "            added_anims=[\n",
        "                self.teacher.change(\"tease\")\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"raise_left_hand\", \"hesitant\", \"happy\",\n",
        "            look_at=self.students[0].bubble,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class IntroduceGame(WordleScene):\n",
        "    secret_word = \"brown\"\n",
        "    grid_center = 3.5 * LEFT\n",
        "\n",
        "    def construct(self):\n",
        "        # Secret\n",
        "        grid = self.grid\n",
        "        row_copy = self.get_curr_row().copy()\n",
        "        secret = VGroup(\n",
        "            Text(\"Secret word\"),\n",
        "            Vector(0.5 * DOWN),\n",
        "            row_copy,\n",
        "        )\n",
        "        secret[2].match_width(secret[0])\n",
        "        secret.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        secret.next_to(grid, RIGHT, buff=2.0, aligned_edge=UP)\n",
        "\n",
        "        word_list = random.sample(get_word_list(short=True), 100)\n",
        "        word_list.append(\"?????\")\n",
        "        words = VGroup(*(Text(word, font=\"Consolas\") for word in word_list))\n",
        "        words.set_height(row_copy.get_height() * 0.7)\n",
        "        words[-1].set_color(RED)\n",
        "\n",
        "        for word in words:\n",
        "            for char, square in zip(word, row_copy):\n",
        "                char.move_to(square)\n",
        "\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(secret[0]),\n",
        "            ShowCreation(secret[1]),\n",
        "            TransformFromCopy(grid[0], secret[2])\n",
        "        )\n",
        "        self.play(\n",
        "            ShowSubmobjectsOneByOne(words, run_time=10, rate_func=linear),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.row_copy = row_copy\n",
        "        self.q_marks = words[-1]\n",
        "\n",
        "        # Guesses\n",
        "        numbers = VGroup(*(Integer(i) for i in range(1, 7)))\n",
        "        for number, row in zip(numbers, grid):\n",
        "            number.next_to(row, LEFT)\n",
        "\n",
        "        self.play(FadeIn(numbers, lag_ratio=0.1))\n",
        "\n",
        "        guesses = [\"three\", \"blues\", \"one\", \"onnne\", \"wonky\", \"brown\"]\n",
        "        if not self.presenter_mode:\n",
        "            for guess in guesses:\n",
        "                self.add_word(guess)\n",
        "                self.reveal_pattern()\n",
        "        else:\n",
        "            self.wait(note=f\"Type {guesses}\")\n",
        "\n",
        "        # Show word lists\n",
        "        all_words = get_word_list()\n",
        "        answers = get_word_list(short=True)\n",
        "\n",
        "        titles = VGroup(\n",
        "            VGroup(Text(\"Allowed guesses\"), Integer(len(all_words))),\n",
        "            VGroup(Text(\"Possible answers\"), Integer(len(answers))),\n",
        "        )\n",
        "        for title in titles:\n",
        "            title.arrange(DOWN)\n",
        "\n",
        "        titles.scale(0.8)\n",
        "        titles.arrange(RIGHT, buff=1.5, aligned_edge=UP)\n",
        "        titles[1][1].match_y(titles[0][1])\n",
        "        titles.to_corner(UR)\n",
        "        titles.to_edge(RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        word_columns = VGroup(\n",
        "            self.get_grid_of_words(all_words, 20, 5),\n",
        "            self.get_grid_of_words(answers, 20, 1),\n",
        "        )\n",
        "        word_columns[1].set_color(GREEN)\n",
        "        for column, title in zip(word_columns, titles):\n",
        "            column.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        grid.add(numbers)\n",
        "        self.play(\n",
        "            FadeOut(secret),\n",
        "            FadeOut(self.q_marks),\n",
        "            grid.animate.scale(0.7, about_edge=LEFT),\n",
        "            Write(titles[0][0], run_time=1),\n",
        "        )\n",
        "        self.play(\n",
        "            CountInFrom(titles[0][1], 0),\n",
        "            ShowIncreasingSubsets(word_columns[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(titles[1][0]),\n",
        "            CountInFrom(titles[1][1], 0),\n",
        "            ShowIncreasingSubsets(word_columns[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Try not to use wordle_words\n",
        "        frame = self.camera.frame\n",
        "        answer_rect = SurroundingRectangle(VGroup(titles[1], word_columns[1]))\n",
        "        answer_rect.set_stroke(TEAL, 3)\n",
        "        avoid = OldTexText(\"Let's try to avoid\\\\\\\\using this\")\n",
        "        avoid.next_to(answer_rect, RIGHT)\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.next_to(avoid, DOWN, MED_LARGE_BUFF)\n",
        "        morty.change(\"hesitant\", answer_rect)\n",
        "        morty.save_state()\n",
        "        morty.change(\"plain\").set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.match_x(word_columns, LEFT).shift(LEFT),\n",
        "            ShowCreation(answer_rect),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(avoid),\n",
        "            Restore(morty),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Common but not in wordle list\n",
        "        priors = get_frequency_based_priors()\n",
        "        not_in_answers = set(all_words).difference(answers)\n",
        "        sorted_by_freq = list(sorted(not_in_answers, key=lambda w: priors[w]))\n",
        "        n = 15\n",
        "        most_common = self.get_grid_of_words(sorted_by_freq[-n:], n, 1)\n",
        "        most_common.set_color(BLUE)\n",
        "        most_common.move_to(morty.get_corner(UR), DOWN).shift(MED_SMALL_BUFF * UP)\n",
        "\n",
        "        non_s_most_common = self.get_grid_of_words(\n",
        "            list(filter(lambda w: w[-1] != 's', sorted_by_freq))[-n:], n, 1\n",
        "        )\n",
        "        non_s_most_common.match_style(most_common)\n",
        "        non_s_most_common.replace(most_common)\n",
        "\n",
        "        label = Text(\"Not in wordle list\", font_size=36)\n",
        "        label.next_to(most_common, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(avoid, DOWN),\n",
        "            morty.change(\"raise_LEFT_hand\", most_common),\n",
        "            ShowIncreasingSubsets(most_common),\n",
        "        )\n",
        "        self.play(FadeIn(label))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            morty.change(\"pondering\", most_common),\n",
        "            LaggedStartMap(FadeOut, most_common, shift=RIGHT),\n",
        "            LaggedStartMap(FadeIn, non_s_most_common, shift=RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_pattern(self, *args, **kwargs):\n",
        "        guess = self.pending_word_as_string()\n",
        "        letters = self.grid.pending_word.copy()\n",
        "        for letter, q_mark in zip(letters, self.q_marks):\n",
        "            letter.replace(q_mark, dim_to_match=1)\n",
        "\n",
        "        added_anims = []\n",
        "        if guess == self.secret_word:\n",
        "            added_anims.append(LaggedStart(\n",
        "                *(\n",
        "                    square.animate.set_fill(GREEN, 1)\n",
        "                    for square in self.row_copy\n",
        "                ),\n",
        "                lag_ratio=0.7,\n",
        "                run_time=2\n",
        "            ))\n",
        "            added_anims.append(LaggedStart(\n",
        "                *(\n",
        "                    Transform(q_mark, letter)\n",
        "                    for q_mark, letter in zip(self.q_marks, letters)\n",
        "                ),\n",
        "                lag_ratio=0.7,\n",
        "                run_time=2\n",
        "            ))\n",
        "        super().show_pattern(*args, added_anims=added_anims, **kwargs)\n",
        "\n",
        "\n",
        "class InitialDemo(ExternalPatternEntry):\n",
        "    secret_word = \"elder\"\n",
        "    pre_computed_first_guesses = [\n",
        "        \"crane\", \"slane\", \"slate\", \"salet\", \"trace\",\n",
        "        \"reast\", \"crate\", \"toile\", \"torse\", \"carse\",\n",
        "        \"carle\", \"trone\", \"carte\", \"roast\",\n",
        "    ]\n",
        "    # wordle_based_prior = True\n",
        "\n",
        "\n",
        "class ShowTonsOfWords(Scene):\n",
        "    def construct(self):\n",
        "        words = get_word_list()\n",
        "        n_rows = 18\n",
        "        n_cols = 15\n",
        "        N = n_rows * n_cols\n",
        "        grids = VGroup(*(\n",
        "            WordleScene.get_grid_of_words(words[N * k:N * (k + 1)], n_rows, n_cols)\n",
        "            for k in range(5)\n",
        "        ))\n",
        "        grids.set_width(FRAME_WIDTH - 3)\n",
        "        grids.arrange(DOWN, buff=0.8 * SMALL_BUFF)\n",
        "        grids.to_edge(UP)\n",
        "        self.add(grids)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.play(frame.animate.move_to(grids, DOWN), run_time=15)\n",
        "\n",
        "\n",
        "class FinalPerformanceFrame(VideoWrapper):\n",
        "    title = \"Final performance\"\n",
        "    animate_boundary = False\n",
        "\n",
        "\n",
        "class FirstThoughtsTitleCard(TitleCardScene):\n",
        "    n_letters = 5\n",
        "    words = [\"first\", \"naive\", \"ideas\"]\n",
        "    secret_word = \"start\"\n",
        "\n",
        "\n",
        "class ChoosingBasedOnLetterFrequencies(IntroduceGame):\n",
        "    def construct(self):\n",
        "        # Reconfigure grid to be flat\n",
        "        grid = self.grid\n",
        "        grid.set_submobjects([VGroup(*it.chain(*grid))])\n",
        "        grid.add(grid.pending_word)\n",
        "        self.add(grid)\n",
        "\n",
        "        # Data on right\n",
        "        letters_and_frequencies = [\n",
        "            (\"E\", 13),\n",
        "            (\"T\", 9.1),\n",
        "            (\"A\", 8.2),\n",
        "            (\"O\", 7.5),\n",
        "            (\"I\", 7),\n",
        "            (\"N\", 6.7),\n",
        "            (\"S\", 6.3),\n",
        "            (\"H\", 6.1),\n",
        "            (\"R\", 6),\n",
        "            (\"D\", 4.3),\n",
        "            (\"L\", 4),\n",
        "            (\"U\", 2.8),\n",
        "            (\"C\", 2.8),\n",
        "            (\"M\", 2.5),\n",
        "            (\"W\", 2.4),\n",
        "            (\"F\", 2.2),\n",
        "            (\"G\", 2.0),\n",
        "            (\"Y\", 2.0),\n",
        "        ]\n",
        "        freq_data = VGroup(*(\n",
        "            VGroup(\n",
        "                Text(letter, font=\"Consolas\"),\n",
        "                Rectangle(\n",
        "                    height=0.25, width=0.2 * freq,\n",
        "                    stroke_width=0,\n",
        "                    fill_color=(BLUE if letter in \"AEIOUY\" else GREY_B),\n",
        "                    fill_opacity=1,\n",
        "                ),\n",
        "                DecimalNumber(freq, num_decimal_places=1, font_size=24, unit=\"\\\\%\")\n",
        "            ).arrange(RIGHT)\n",
        "            for letter, freq in letters_and_frequencies\n",
        "        ))\n",
        "        freq_data.arrange(DOWN, aligned_edge=LEFT)\n",
        "        freq_data.set_height(FRAME_HEIGHT - 1)\n",
        "        freq_data.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        self.freq_data = freq_data\n",
        "        for row, lf in zip(freq_data, letters_and_frequencies):\n",
        "            letter = lf[0]\n",
        "            row.letter = letter\n",
        "            row.rect = SurroundingRectangle(row, buff=SMALL_BUFF)\n",
        "            row.rect.set_stroke(YELLOW, 0)\n",
        "            row.add(row.rect)\n",
        "        freq_data.add_updater(lambda m: m)\n",
        "        self.add(freq_data)\n",
        "\n",
        "    def add_letter(self, letter):\n",
        "        super().add_letter(letter)\n",
        "        self.update_freq_data_highlights()\n",
        "\n",
        "    def delete_letter(self):\n",
        "        super().delete_letter()\n",
        "        self.update_freq_data_highlights()\n",
        "\n",
        "    def update_freq_data_highlights(self):\n",
        "        word = self.pending_word_as_string()\n",
        "        for row in self.freq_data:\n",
        "            if row.letter.lower() in word.lower():\n",
        "                row.set_opacity(1)\n",
        "                row.rect.set_fill(opacity=0)\n",
        "                row.rect.set_stroke(width=2)\n",
        "            else:\n",
        "                row.set_opacity(0.5)\n",
        "                row.rect.set_fill(opacity=0)\n",
        "                row.rect.set_stroke(width=0)\n",
        "\n",
        "\n",
        "class ExampleGridColors(WordleScene):\n",
        "    grid_center = ChoosingBasedOnLetterFrequencies.grid_center\n",
        "    secret_word = \"baker\"\n",
        "\n",
        "    def construct(self):\n",
        "        self.wait(3)\n",
        "\n",
        "        grid = self.grid\n",
        "        for guess in [\"other\", \"nails\"]:\n",
        "            self.add_word(guess, 0)\n",
        "            self.reveal_pattern()\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for color in [BLACK, self.color_map[0]]:\n",
        "            grid.generate_target()\n",
        "            grid.target[:2].set_fill(color, 1),\n",
        "            self.play(\n",
        "                MoveToTarget(grid),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class PreviewGamePlay(WordleSceneWithAnalysis):\n",
        "    n_games = 10\n",
        "    pre_computed_first_guesses = [\n",
        "        \"tares\", \"lares\", \"rates\", \"rales\", \"tears\",\n",
        "        \"tales\", \"salet\", \"teras\", \"arles\", \"nares\",\n",
        "        \"soare\", \"saner\", \"reals\"\n",
        "    ]\n",
        "\n",
        "    def construct(self):\n",
        "        self.show_guess_values()\n",
        "        self.initial_guess_value_grid = self.guess_value_grid\n",
        "        for x in range(self.n_games):\n",
        "            self.clear()\n",
        "            self.setup()\n",
        "            self.secret_word = random.choice(get_word_list(short=True))\n",
        "            self.guess_value_grid = self.initial_guess_value_grid\n",
        "            self.add(self.guess_value_grid)\n",
        "            while not self.has_won():\n",
        "                guess = self.guess_value_grid[0][0].text\n",
        "                self.add_word(guess)\n",
        "                self.wait(0.5)\n",
        "                self.reveal_pattern()\n",
        "\n",
        "\n",
        "class UlteriorMotiveWrapper(VideoWrapper):\n",
        "    title = \"Ulterior motive: Lesson on entropy\"\n",
        "\n",
        "\n",
        "class IntroduceDistribution(WordleDistributions):\n",
        "    secret_word = \"brown\"\n",
        "    uniform_prior = True\n",
        "    n_word_rows = 20\n",
        "    n_bars_to_analyze = 3\n",
        "\n",
        "    def construct(self):\n",
        "        # Total labels\n",
        "        total_label = self.get_total_words_label()\n",
        "        self.add(total_label)\n",
        "\n",
        "        # Show an example guess\n",
        "        guess = \"weary\"\n",
        "        match_label = self.get_dynamic_match_label()\n",
        "        word_grid = self.get_grid_of_matches(n_rows=self.n_word_rows)\n",
        "\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(ShowIncreasingSubsets(word_grid, run_time=3))\n",
        "        self.wait(note=f\"Write {guess}, (but don't submit)\")\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            self.add_word(guess)\n",
        "\n",
        "        # Show several possible patterns, with corresponding matches\n",
        "        pattern_strs = [\"20100\", \"01000\"]\n",
        "        prob_label = VGroup()\n",
        "        for i, pattern_str in enumerate(pattern_strs):\n",
        "            pattern = pattern_from_string(pattern_str)\n",
        "            self.remove(match_label)\n",
        "            self.show_pattern(pattern, animate=True)\n",
        "            self.play(FadeOut(word_grid), FadeOut(prob_label))\n",
        "            word_grid = self.get_grid_of_matches(n_rows=self.n_word_rows)\n",
        "            self.add(match_label)\n",
        "            match_label.update()\n",
        "            self.play(\n",
        "                CountInFrom(match_label[0], 0),\n",
        "                ShowIncreasingSubsets(word_grid, run_time=2)\n",
        "            )\n",
        "            self.wait(note=f\"Pattern {i} / {len(pattern_strs)}\")\n",
        "\n",
        "            num = match_label[0].get_value()\n",
        "            denom = total_label[0].get_value()\n",
        "            prob_label = self.get_dynamic_bar_label((\n",
        "                \"p\\\\left(\", \"0000\", \"\\\\right)\", \"=\",\n",
        "                \"{\" + \"{:,}\".format(num).replace(\",\", \"{,}\"), \"\\\\over \",\n",
        "                \"{:,}\".format(denom).replace(\",\", \"{,}\") + \"}\", \"=\",\n",
        "                \"0.0000\",\n",
        "            ))\n",
        "            prob_label[-1].set_value(num / denom)\n",
        "            prob_label.next_to(word_grid, UP)\n",
        "            prob_label.clear_updaters()\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    FadeTransform(match_label[0].copy().clear_updaters(), prob_label[4], remover=True),\n",
        "                    FadeTransform(total_label[0].copy().clear_updaters(), prob_label[6], remover=True),\n",
        "                    lag_ratio=0.5,\n",
        "                ),\n",
        "                FadeIn(VGroup(*prob_label[:4], prob_label[5], prob_label[7:])),\n",
        "            )\n",
        "            self.add(prob_label)\n",
        "            self.wait()\n",
        "\n",
        "        # Show distribution\n",
        "        axes = self.get_axes(y_max=0.15)\n",
        "        bars = self.get_distribution_bars(axes, guess)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(word_grid),\n",
        "            FadeOut(prob_label),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            Write(axes),\n",
        "            ShowIncreasingSubsets(bars),\n",
        "            lag_ratio=0.5\n",
        "        ))\n",
        "        self.add(bars)\n",
        "        self.wait()\n",
        "\n",
        "        index = 20\n",
        "        bar_indicator, x_tracker, get_bar = self.get_bar_indicator(bars, index)\n",
        "        p_label = self.get_p_label(get_bar)\n",
        "\n",
        "        self.add(bar_indicator, x_tracker)\n",
        "        self.add(p_label)\n",
        "        self.add(match_label)\n",
        "        for x in range(self.n_bars_to_analyze):\n",
        "            self.wait(note=f\"Play around with probability {x} / {self.n_bars_to_analyze}\")\n",
        "            word_grid = self.get_grid_of_matches(n_rows=12, n_cols=5)\n",
        "            word_grid.next_to(p_label, UP, LARGE_BUFF)\n",
        "            self.play(ShowIncreasingSubsets(word_grid))\n",
        "            self.wait()\n",
        "            self.remove(word_grid)\n",
        "\n",
        "        # Describe aim for expected information\n",
        "        want = Text(\"What we want:\")\n",
        "        standin = OldTex(\n",
        "            \"E[\\\\text{Information}] = \\\\sum_{x} p(x) \\\\cdot (\\\\text{Something})\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Something}\": GREY_B,\n",
        "                \"\\\\text{Information}\": BLUE,\n",
        "            },\n",
        "            font_size=36,\n",
        "        )\n",
        "        group = VGroup(want, standin)\n",
        "        group.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        group.to_corner(UR)\n",
        "\n",
        "        self.play(FadeIn(want))\n",
        "        self.play(Write(standin))\n",
        "        self.wait(note=\"Discuss adding up over all patterns\")\n",
        "\n",
        "        # Define information\n",
        "        info_label = self.get_information_label(p_label, get_bar)\n",
        "        il_copy = info_label.copy().clear_updaters()\n",
        "        self.play(FadeIn(il_copy, UP, remover=True))\n",
        "        self.add(info_label)\n",
        "        self.wait(note=\"Give intuitions on values of I\")\n",
        "\n",
        "        # Define entropy\n",
        "        entropy_definition = self.get_entropy_label()\n",
        "        brace = Brace(entropy_definition, DOWN, buff=SMALL_BUFF)\n",
        "        ent_label = OldTexText(\"Entropy, $H$\")\n",
        "        ent_label.set_color(BLUE)\n",
        "        ent_label.next_to(brace, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(entropy_definition, UP),\n",
        "            FadeOut(standin, UP),\n",
        "            FadeOut(want, UP),\n",
        "        )\n",
        "        self.wait(note=\"Drag tracker through full distributinon\")\n",
        "        self.wait()\n",
        "        self.play(x_tracker.animate.set_value(10), run_time=3)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(ent_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show an alternate word\n",
        "        self.remove(bar_indicator, x_tracker, p_label, info_label, bars, match_label)\n",
        "        entropy_definition[-1].set_opacity(0)\n",
        "        self.grid.clear_updaters()\n",
        "        self.grid.add_updater(lambda m: m)\n",
        "        self.get_curr_row().set_fill(BLACK, 0)\n",
        "        self.grid.pending_pattern = None\n",
        "        self.wait(note=\"Delete word, write \\\"saner\\\", but don't enter!\")\n",
        "\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            for x in range(5):\n",
        "                self.delete_letter()\n",
        "            self.add_word('saner')\n",
        "\n",
        "        guess = self.pending_word_as_string()\n",
        "        bars = self.get_distribution_bars(axes, guess)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(bars, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        trackers = self.add_trackers(bars, index=20)\n",
        "        self.wait(note=\"Play around more with distribiution\")\n",
        "\n",
        "        self.recalculate_entropy(entropy_definition, guess, trackers[0])\n",
        "        self.wait()\n",
        "\n",
        "        # Examples of good entropy\n",
        "        self.remove(*trackers)\n",
        "        bars.set_opacity(0.7)\n",
        "        self.grid.clear_updaters()\n",
        "        self.grid.add_updater(lambda m: m)\n",
        "        self.grid.pending_word.set_submobjects([])\n",
        "        self.add_word(\"?????\")\n",
        "        self.get_curr_row().set_fill(BLACK, 0)\n",
        "\n",
        "        eqs = VGroup(\n",
        "            OldTex(\"E[I] = \\\\log_2\\\\left({1 \\\\over 1 / 3^5}\\\\right) = \\\\log_2(3^5) \\\\approx 7.92\"),\n",
        "            OldTex(\"E[I] = \\\\log_2\\\\left({1 \\\\over 1 / 16}\\\\right) = \\\\log_2(16) = 4.00\"),\n",
        "            OldTex(\"E[I] = \\\\log_2\\\\left({1 \\\\over 1 / 64}\\\\right) = \\\\log_2(64) = 6.00\"),\n",
        "        )\n",
        "        eqs.scale(0.7)\n",
        "        for eq in eqs:\n",
        "            eq.next_to(ent_label, DOWN, LARGE_BUFF)\n",
        "\n",
        "        prev_values = [bar.prob for bar in bars]\n",
        "\n",
        "        last_eq = VGroup()\n",
        "        ent_rhs = entropy_definition[-1]\n",
        "        for eq, x in zip(eqs, [3**5, 16, 64]):\n",
        "            values = [1 / x] * x + [0] * (3**5 - x)\n",
        "            self.set_bars_to_values(bars, values, ent_rhs, added_anims=[FadeOut(last_eq)])\n",
        "            self.wait()\n",
        "            self.play(FadeIn(eq, UP))\n",
        "            last_eq = eq\n",
        "            self.wait()\n",
        "\n",
        "        self.grid.pending_word.set_submobjects([])\n",
        "        self.add_word(guess, wait_time_per_letter=0)\n",
        "        self.set_bars_to_values(bars, prev_values, ent_rhs, added_anims=[FadeOut(last_eq)])\n",
        "        self.wait()\n",
        "\n",
        "        # Show the second guess\n",
        "        true_pattern = self.get_pattern(guess)\n",
        "        self.show_pattern(true_pattern, animate=True)\n",
        "        trackers[0].set_value(list(bars.patterns).index(true_pattern))\n",
        "        match_label.update()\n",
        "        self.play(FadeIn(match_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                match_label[0].copy().move_to,\n",
        "                total_label[0], UR,\n",
        "                remover=True,\n",
        "            ),\n",
        "            FadeOut(total_label[0], UP)\n",
        "        )\n",
        "        total_label[0].set_value(match_label[0].get_value())\n",
        "        self.add(total_label)\n",
        "        self.wait()\n",
        "\n",
        "        faders = [axes, bars, match_label]\n",
        "        for fader in faders:\n",
        "            fader.clear_updaters()\n",
        "        self.play(\n",
        "            LaggedStart(*map(FadeOut, faders)),\n",
        "            FadeOut(entropy_definition[-1]),\n",
        "        )\n",
        "        self.grid.clear_updaters()\n",
        "        self.reveal_pattern(animate=False)\n",
        "        next_guess = \"wordy\"\n",
        "        self.wait(note=f\"Type in \\\"{next_guess}\\\"\")\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            self.add_word(next_guess)\n",
        "\n",
        "        # Show new distribution\n",
        "        guess = self.pending_word_as_string()\n",
        "        axes = self.get_axes(y_max=1, x_max=50)\n",
        "        bars = self.get_distribution_bars(axes, guess)\n",
        "        self.play(\n",
        "            FadeIn(axes),\n",
        "            FadeIn(bars, lag_ratio=0.1, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.remove(match_label)\n",
        "        trackers = self.add_trackers(bars)\n",
        "        self.wait(note=\"Play around with distribution\")\n",
        "        trackers[0].clear_updaters()\n",
        "        self.play(trackers[0].animate.set_value(10), run_time=3)\n",
        "        self.play(trackers[0].animate.set_value(0), run_time=5)\n",
        "\n",
        "        self.recalculate_entropy(entropy_definition, guess)\n",
        "\n",
        "        # Other second guesses\n",
        "        self.grid.clear_updaters()\n",
        "        self.get_curr_row().set_fill(BLACK, 0)\n",
        "        self.pending_pattern = None\n",
        "        entropy_definition[1].set_opacity(0)\n",
        "        self.remove(bars, *trackers)\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            words = get_word_list()\n",
        "            for guess in random.sample(words, 15):\n",
        "                for x in range(5):\n",
        "                    self.delete_letter()\n",
        "                self.add_word(guess, wait_time_per_letter=0)\n",
        "                bars = self.get_distribution_bars(axes, guess)\n",
        "                self.add(bars)\n",
        "                self.play(FadeIn(bars, lag_ratio=0.1, run_time=2))\n",
        "                self.recalculate_entropy(entropy_definition, guess)\n",
        "                self.wait()\n",
        "                self.remove(bars)\n",
        "        else:\n",
        "            guess = \"print\"\n",
        "            self.wait(note=f\"Write \\\"{guess}\\\"\")\n",
        "            trackers = self.add_trackers(bars)\n",
        "            self.wait(note=\"Play around with distribution\")\n",
        "\n",
        "    def set_bars_to_values(self, bars, values, ent_rhs, run_time=3, added_anims=[]):\n",
        "        y_unit = self.axes.y_axis.unit_size\n",
        "        bars.generate_target()\n",
        "        bar_template = bars[0].copy()\n",
        "        entropy = entropy_of_distributions(np.array(values))\n",
        "        for bar, value in zip(bars.target, values):\n",
        "            target = bar_template.copy()\n",
        "            target.set_height(\n",
        "                y_unit * value,\n",
        "                stretch=True,\n",
        "                about_edge=DOWN\n",
        "            )\n",
        "            target.move_to(bar, DOWN)\n",
        "            bar.become(target)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(bars, run_time=run_time),\n",
        "            ChangeDecimalToValue(ent_rhs, entropy, run_time=run_time),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "    def recalculate_entropy(self, entropy_definition, guess, x_tracker=None):\n",
        "        dec = entropy_definition[-1]\n",
        "        dec.set_value(\n",
        "            get_entropies(\n",
        "                [guess], self.possibilities,\n",
        "                get_weights(self.possibilities, self.priors)\n",
        "            )[0]\n",
        "        )\n",
        "        dec.set_opacity(1)\n",
        "        dec.next_to(entropy_definition[-2][-1])\n",
        "        anims = [CountInFrom(dec, 0)]\n",
        "        run_time = 1\n",
        "        if x_tracker is not None:\n",
        "            x_tracker.suspend_updating()\n",
        "            anims.append(UpdateFromAlphaFunc(\n",
        "                x_tracker, lambda m, a: m.set_value(a * 200),\n",
        "                run_time=5,\n",
        "            ))\n",
        "            run_time = 3\n",
        "        self.play(*anims, run_time=run_time)\n",
        "        self.wait()\n",
        "\n",
        "    def add_trackers(self, bars, index=1):\n",
        "        bar_indicator, x_tracker, get_bar = self.get_bar_indicator(bars, index)\n",
        "        p_label = self.get_p_label(get_bar, max_y=1)\n",
        "        info_label = self.get_information_label(p_label, get_bar)\n",
        "        match_label = self.get_dynamic_match_label()\n",
        "        trackers = [x_tracker, bar_indicator, p_label, info_label, match_label]\n",
        "        self.add(*trackers)\n",
        "        return trackers\n",
        "\n",
        "\n",
        "class ButTheyreNotEquallyLikely(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        morty = Mortimer()\n",
        "        pis = VGroup(randy, morty)\n",
        "        pis.arrange(RIGHT, buff=2)\n",
        "        pis.to_edge(DOWN)\n",
        "        randy.make_eye_contact(morty)\n",
        "\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                randy, OldTexText(\"But they're \\\\emph{not}\\\\\\\\equally likely!\"),\n",
        "                target_mode=\"angry\",\n",
        "            ),\n",
        "            morty.change(\"guilty\", randy.eyes),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            PiCreatureSays(\n",
        "                morty, OldTexText(\"To warm up, let's\\\\\\\\assume they are.\"),\n",
        "                target_mode=\"speaking\",\n",
        "            ),\n",
        "            RemovePiCreatureBubble(randy),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class KeyIdea(Scene):\n",
        "    def construct(self):\n",
        "        title = Text(\"Key idea\", font_size=72)\n",
        "        title.to_edge(UP, LARGE_BUFF)\n",
        "        title.add(Underline(title, buff=-SMALL_BUFF, stroke_width=0.5).scale(1.5))\n",
        "        title.set_color(YELLOW)\n",
        "        idea = OldTexText(\"Informative\", \" $\\\\Leftrightarrow$\", \" Unlikely\", font_size=72)\n",
        "        self.add(title)\n",
        "        idea[0].save_state()\n",
        "        idea[0].center()\n",
        "        self.play(FadeIn(idea[0]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(idea[0]),\n",
        "            FadeIn(idea[1], RIGHT),\n",
        "            FadeIn(idea[2], 2 * RIGHT)\n",
        "        )\n",
        "        self.play(FlashAround(idea, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExpectedMatchesInsert(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"\\\\sum_{x} p(x) \\\\big(\\\\text{\\\\# Matches}\\\\big)\",\n",
        "            tex_to_color_map={\"\\\\text{\\\\# Matches}\": GREEN}\n",
        "        )\n",
        "        cross = Cross(tex).scale(1.25)\n",
        "        self.play(Write(tex))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class InformationTheoryTitleCard(TitleCardScene):\n",
        "    n_letters = 6\n",
        "    words = [\"inform\", \"ation-\", \"theory\", \"basics\"]\n",
        "\n",
        "\n",
        "class DescribeBit(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Standard unit of\\\\\\\\information: The bit\",\n",
        "            tex_to_color_map={\"The bit\": YELLOW}\n",
        "        )\n",
        "        words.next_to(self.teacher.get_corner(UL), UP, MED_LARGE_BUFF)\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change(\"raise_left_hand\"),\n",
        "            FadeIn(words, UP)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            \"happy\", \"pondering\", \"thinking\",\n",
        "            look_at=words\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        formula = OldTex(\"I = -\\\\log_2(p)\", tex_to_color_map={\"I\": YELLOW})\n",
        "        formula.next_to(self.teacher.get_corner(UL), UP)\n",
        "\n",
        "        self.play(\n",
        "            words.animate.to_edge(UP),\n",
        "            FadeIn(formula, UP),\n",
        "            self.teacher.change(\"raise_right_hand\", formula),\n",
        "            self.students[0].change(\"erm\", formula),\n",
        "            self.students[1].change(\"confused\", formula),\n",
        "            self.students[2].change(\"pondering\", formula),\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class DefineInformation(Scene):\n",
        "    def construct(self):\n",
        "        # Spaces\n",
        "        pre_space = Square(side_length=3)\n",
        "        pre_space.set_stroke(WHITE, 2)\n",
        "        pre_space.set_fill(BLUE, 0.7)\n",
        "\n",
        "        post_space = self.get_post_space(pre_space, 1)\n",
        "        arrow = Vector(2 * RIGHT)\n",
        "        group = VGroup(pre_space, arrow, post_space)\n",
        "        group.arrange(RIGHT)\n",
        "\n",
        "        # Labels\n",
        "        kw = dict(font_size=36)\n",
        "        pre_label = Text(\"Space of possibilities\", **kw)\n",
        "        pre_label.next_to(pre_space, UP, SMALL_BUFF)\n",
        "        obs_label = Text(\"Observation\", **kw)\n",
        "        obs_label.next_to(arrow, UP)\n",
        "        post_labels = self.get_post_space_labels(post_space, **kw)\n",
        "\n",
        "        # 1 bit (has an s)\n",
        "        self.add(pre_space)\n",
        "        self.add(pre_label)\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(obs_label, lag_ratio=0.1),\n",
        "            FadeTransform(pre_space.copy().set_fill(opacity=0), post_space),\n",
        "            FadeIn(post_labels[1], 3 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(post_labels[0], run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Show all words\n",
        "        n_rows = 25\n",
        "        n_cols = 8\n",
        "        all_words = get_word_list()\n",
        "        words_sample = random.sample(all_words, n_rows * n_cols)\n",
        "        word_grid = WordleScene.get_grid_of_words(words_sample, n_rows, n_cols)\n",
        "        word_grid.replace(pre_space, dim_to_match=1)\n",
        "        word_grid.scale(0.95)\n",
        "        word_grid.shuffle()\n",
        "        for word in word_grid:\n",
        "            word.save_state()\n",
        "        word_grid.scale(2)\n",
        "        word_grid.set_opacity(0)\n",
        "\n",
        "        self.play(LaggedStartMap(Restore, word_grid, lag_ratio=0.02, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        word_grid.save_state()\n",
        "        word_grid.generate_target()\n",
        "        for word in word_grid.target:\n",
        "            if 's' not in word.text:\n",
        "                word.set_opacity(0.1)\n",
        "\n",
        "        has_s = OldTexText(\"Has an `s'\", font_size=24)\n",
        "        has_s.next_to(arrow, DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(word_grid),\n",
        "            FadeIn(has_s, 0.5 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 2 bits (has a t)\n",
        "        frame = self.camera.frame\n",
        "        mini_group1 = self.get_mini_group(pre_space, arrow, post_space, post_labels)\n",
        "        mini_group1.target.to_edge(UP, buff=0.25)\n",
        "        post_space2 = self.get_post_space(pre_space, 2).move_to(post_space)\n",
        "        post_labels2 = self.get_post_space_labels(post_space2, **kw)\n",
        "        has_t = OldTexText(\"Has a `t'\", font_size=24)\n",
        "        has_t.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(mini_group1),\n",
        "            FadeOut(has_s),\n",
        "            Restore(word_grid),\n",
        "            FadeOut(post_space),\n",
        "            FadeOut(post_labels),\n",
        "            frame.animate.move_to(2 * RIGHT)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeTransform(pre_space.copy(), post_space2),\n",
        "            FadeIn(post_labels2, shift=3 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "        word_grid.generate_target()\n",
        "        for word in word_grid.target:\n",
        "            if 't' not in word.text:\n",
        "                word.set_opacity(0.1)\n",
        "        self.play(\n",
        "            FadeIn(has_t, 0.5 * DOWN),\n",
        "            MoveToTarget(word_grid),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(has_t)\n",
        "        word_grid.restore()\n",
        "\n",
        "        # 3 through 5 bits\n",
        "        last_posts = VGroup(post_space2, post_labels2)\n",
        "        mini_groups = VGroup(mini_group1)\n",
        "        for n in range(3, 7):\n",
        "            new_mini = self.get_mini_group(pre_space, arrow, *last_posts)\n",
        "            new_mini.target.next_to(mini_groups, DOWN, buff=0.5)\n",
        "            new_post_space = self.get_post_space(pre_space, n)\n",
        "            new_post_space.move_to(post_space)\n",
        "            new_post_labels = self.get_post_space_labels(new_post_space, **kw)\n",
        "\n",
        "            self.play(LaggedStart(\n",
        "                MoveToTarget(new_mini),\n",
        "                AnimationGroup(\n",
        "                    FadeOut(last_posts),\n",
        "                    FadeIn(new_post_space),\n",
        "                    FadeIn(new_post_labels),\n",
        "                ),\n",
        "                lag_ratio=0.5\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "            mini_groups.add(new_mini)\n",
        "            last_posts = VGroup(new_post_space, new_post_labels)\n",
        "\n",
        "        # Show formula\n",
        "        group = VGroup(pre_space, pre_label, word_grid, arrow, obs_label, *last_posts)\n",
        "\n",
        "        kw = dict(tex_to_color_map={\"I\": YELLOW})\n",
        "        formulas = VGroup(\n",
        "            OldTex(\"\\\\left( \\\\frac{1}{2} \\\\right)^I = p\", **kw),\n",
        "            OldTex(\"2^I = \\\\frac{1}{p}\", **kw),\n",
        "            OldTex(\"I = \\\\log_2\\\\left(\\\\frac{1}{p}\\\\right)\", **kw),\n",
        "            OldTex(\"I = -\\\\log_2(p)\", **kw)\n",
        "        )\n",
        "        formulas[:3].arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        formulas[:3].to_edge(UP)\n",
        "        formulas[1:3].match_y(formulas[0][-1][0])\n",
        "        formulas[3].next_to(formulas[2], DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        formulas[0].save_state()\n",
        "        formulas[0].move_to(formulas[1])\n",
        "        self.play(\n",
        "            FadeIn(formulas[0]),\n",
        "            group.animate.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(formulas[0]))\n",
        "        for i in (0, 1, 2):\n",
        "            self.play(TransformMatchingShapes(formulas[i].copy(), formulas[i + 1]))\n",
        "            self.wait()\n",
        "\n",
        "        rhs_rect = SurroundingRectangle(formulas[3])\n",
        "        rhs_rect.set_stroke(YELLOW, 2)\n",
        "        self.play(ShowCreation(rhs_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask why?\n",
        "        randy = Randolph(\"confused\", height=1.5)\n",
        "        randy.next_to(formulas[2], DL, MED_LARGE_BUFF)\n",
        "        randy.look_at(rhs_rect)\n",
        "        randy.save_state()\n",
        "        randy.change(\"plain\")\n",
        "        randy.set_opacity(0)\n",
        "\n",
        "        self.play(Restore(randy))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(randy.change(\"maybe\"))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Readibility\n",
        "        expr = OldTex(\n",
        "            \"20 \\\\text{ bits} \\\\Leftrightarrow p \\\\approx 0.00000095\",\n",
        "            tex_to_color_map={\"\\\\text{bits}\": YELLOW}\n",
        "        )\n",
        "        expr.next_to(group, UP, buff=0.75)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(randy),\n",
        "            FadeOut(formulas[3]),\n",
        "            FadeOut(rhs_rect),\n",
        "            Write(expr),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Additive\n",
        "        group = group[:-2]\n",
        "        self.play(\n",
        "            FadeOut(expr),\n",
        "            FadeOut(last_posts),\n",
        "            group.animate.scale(0.7, about_edge=DL),\n",
        "            FadeOut(mini_groups, RIGHT),\n",
        "            frame.animate.move_to(RIGHT),\n",
        "        )\n",
        "\n",
        "        ps1 = self.get_post_space(pre_space, 2)\n",
        "        ps2 = self.get_post_space(pre_space, 5)\n",
        "        ps2.set_stroke(width=1)\n",
        "        ps2.add(ps1.copy().fade(0.5))\n",
        "        arrow2 = arrow.copy()\n",
        "        ps1.next_to(arrow, RIGHT)\n",
        "        arrow2.next_to(ps1, RIGHT)\n",
        "        ps2.next_to(arrow2, RIGHT)\n",
        "\n",
        "        ps1.label = self.get_post_space_labels(ps1, font_size=24)\n",
        "        ps2.label = self.get_post_space_labels(\n",
        "            self.get_post_space(pre_space, 3).replace(ps2),\n",
        "            font_size=24\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(pre_space.copy().set_opacity(0), ps1),\n",
        "            FadeIn(ps1.label, 2 * RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(ps1.copy().set_opacity(0), ps2),\n",
        "            FadeIn(ps2.label, 2 * RIGHT),\n",
        "            ShowCreation(arrow2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        brace = Brace(VGroup(ps1.label, ps2.label), UP)\n",
        "        b_label = brace.get_text(\"5 bits\").set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(b_label, 0.2 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_post_space(self, pre_space, n_bits):\n",
        "        n_rows = 2**((n_bits // 2))\n",
        "        n_cols = 2**((n_bits // 2) + n_bits % 2)\n",
        "        result = pre_space.get_grid(n_rows, n_cols, buff=0)\n",
        "        result.replace(pre_space, stretch=True)\n",
        "        result[:-1].set_fill(opacity=0)\n",
        "        return result\n",
        "\n",
        "    def get_post_space_labels(self, post_space, **kw):\n",
        "        n_bits = int(math.log2(len(post_space)))\n",
        "        top_label = OldTexText(\"Information = \", f\"${n_bits}$ bits\", **kw)\n",
        "        if n_bits == 1:\n",
        "            top_label[-1][-1].set_opacity(0)\n",
        "        top_label.next_to(post_space, UP, buff=0.15)\n",
        "        top_label.set_color(YELLOW)\n",
        "        bottom_label = OldTexText(f\"$p = {{1 \\\\over {2**n_bits}}}$\", **kw)\n",
        "        bottom_label.next_to(post_space, DOWN, SMALL_BUFF)\n",
        "        return VGroup(top_label, bottom_label)\n",
        "\n",
        "    def get_mini_group(self, pre_space, arrow, post_space, post_labels):\n",
        "        mini_group = VGroup(pre_space, arrow, post_space, post_labels[0]).copy()\n",
        "        mini_group.generate_target()\n",
        "        mini_group.target.scale(0.25)\n",
        "        mini_group.target[-1][0].set_opacity(0)\n",
        "        mini_group.target[-1][1].scale(3, about_edge=DOWN)\n",
        "        mini_group.target[-1][1].match_x(mini_group.target[2])\n",
        "        mini_group.target.next_to(post_space, RIGHT, buff=2.0)\n",
        "        mini_group[::2].set_fill(opacity=0)\n",
        "        mini_group.target[::2].set_stroke(width=1)\n",
        "        return mini_group\n",
        "\n",
        "\n",
        "class AskForFormulaForI(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"I = ???\",\n",
        "            tex_to_color_map={\"I\": YELLOW},\n",
        "            font_size=72,\n",
        "        )\n",
        "        tex.to_edge(UP)\n",
        "        self.play(Write(tex))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MinusLogExpression(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\n",
        "            \"I = -\\\\log_2(p)\",\n",
        "            tex_to_color_map={\"I\": YELLOW},\n",
        "            font_size=60,\n",
        "        )\n",
        "        self.play(FadeIn(tex, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowPatternInformationExamples(WordleDistributions):\n",
        "    def construct(self):\n",
        "        grid = self.grid\n",
        "        guess = \"wordy\"\n",
        "        self.add_word(guess)\n",
        "\n",
        "        axes = self.get_axes()\n",
        "        bars = self.get_distribution_bars(axes, guess)\n",
        "\n",
        "        index = 20\n",
        "        bar_indicator, x_tracker, get_bar = self.get_bar_indicator(bars, index)\n",
        "        p_label = self.get_p_label(get_bar)\n",
        "        I_label = self.get_information_label(p_label, get_bar)\n",
        "\n",
        "        I_label.scale(1.75)\n",
        "        I_label.add_updater(lambda m: m.next_to(grid, UR, buff=LARGE_BUFF).shift(0.5 * DOWN))\n",
        "        self.add(I_label)\n",
        "\n",
        "        randy = Randolph(height=2.0)\n",
        "        randy.flip()\n",
        "        randy.to_corner(DR)\n",
        "\n",
        "        self.play(PiCreatureSays(\n",
        "            randy, OldTexText(\"I thought this\\\\\\\\was a word game\"),\n",
        "            bubble_config={\"width\": 4, \"height\": 3},\n",
        "            target_mode=\"pleading\"\n",
        "        ))\n",
        "\n",
        "        x_tracker.clear_updaters()\n",
        "        x_tracker.set_value(0)\n",
        "        self.play(\n",
        "            x_tracker.animate.set_value(120),\n",
        "            run_time=20,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TwentyBitOverlay(Scene):\n",
        "    def construct(self):\n",
        "        eq = OldTex(\"20 \\\\text{ bits} \\\\Leftrightarrow 0.00000095\")\n",
        "        eq.scale(1.5)\n",
        "        self.play(Write(eq))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AddingBitsObservationOverlay(Scene):\n",
        "    def construct(self):\n",
        "        mystery = Square(side_length=0.5).get_grid(1, 5, buff=SMALL_BUFF)\n",
        "        mystery.set_stroke(WHITE, 1)\n",
        "        for box in mystery:\n",
        "            char = Text(\"?\", font=\"Consolas\")\n",
        "            char.set_height(0.7 * box.get_height())\n",
        "            char.move_to(box)\n",
        "            box.add(char)\n",
        "\n",
        "        # Delete...\n",
        "        phase1_strs = [list(\"?????\") for x in range(5)]\n",
        "        phase2_strs = [list(\"s????\") for x in range(4)]\n",
        "        for i, s in enumerate(phase1_strs):\n",
        "            s[i] = \"t\"\n",
        "        for i, s in enumerate(phase2_strs):\n",
        "            s[i + 1] = \"t\"\n",
        "        kw = dict(\n",
        "            font=\"Consolas\",\n",
        "            t2c={\"t\": RED, \"s\": YELLOW},\n",
        "        )\n",
        "        phase1 = VGroup(*(Text(\"\".join(s), **kw) for s in phase1_strs))\n",
        "        phase2 = VGroup(*(Text(\"\".join(s), **kw) for s in phase2_strs))\n",
        "        for phase in [phase1, phase2]:\n",
        "            phase.arrange(DOWN, buff=SMALL_BUFF)\n",
        "\n",
        "        phases = VGroup(mystery, phase1, phase2)\n",
        "        phases.arrange(RIGHT, buff=2.0)\n",
        "        phases.to_edge(UP)\n",
        "\n",
        "        # Arrange observations\n",
        "        mystery.set_x(-4).to_edge(UP, buff=LARGE_BUFF)\n",
        "        arrows = Arrow(LEFT, RIGHT).set_width(3).replicate(2)\n",
        "        arrows.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        arrows.next_to(mystery, RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        obss = VGroup(\n",
        "            OldTexText(\"Has a `t'\"),\n",
        "            OldTexText(\"Starts with `s'\"),\n",
        "        )\n",
        "        obss.scale(0.85)\n",
        "        bits_labels = VGroup(\n",
        "            Text(\"2 bits\"),\n",
        "            Text(\"3 more bits\"),\n",
        "        )\n",
        "        bits_labels.scale(0.75)\n",
        "        for obs, bl, arrow in zip(obss, bits_labels, arrows):\n",
        "            obs.next_to(arrow, UP)\n",
        "            bl.next_to(arrow, DOWN)\n",
        "            bl.set_color(YELLOW)\n",
        "\n",
        "        self.add(mystery)\n",
        "        for arrow, bl, obs in zip(arrows, bits_labels, obss):\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                Write(obs),\n",
        "                run_time=1\n",
        "            )\n",
        "            self.play(FadeIn(bl, 0.25 * DOWN))\n",
        "            self.wait()\n",
        "\n",
        "        long_arrow = Arrow(arrows[0].get_start(), arrows[1].get_end(), buff=0)\n",
        "        full_bits_label = Text(\"5 bits\")\n",
        "        full_bits_label.match_style(bits_labels[0])\n",
        "        full_bits_label.next_to(long_arrow, DOWN)\n",
        "\n",
        "        self.play(bits_labels.animate.to_edge(UP, buff=SMALL_BUFF))\n",
        "        self.play(\n",
        "            FadeTransform(arrows[0], long_arrow),\n",
        "            FadeTransform(arrows[1], long_arrow),\n",
        "            Write(full_bits_label, run_time=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ExpectedInformationLabel(Scene):\n",
        "    def construct(self):\n",
        "        eq = OldTex(\n",
        "            \"E[\\\\text{Information}] = \",\n",
        "            \"\\\\sum_x p(x) \\\\cdot \\\\text{Information}(x)\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Information}\": YELLOW,\n",
        "            },\n",
        "            font_size=60\n",
        "        )\n",
        "        eq.to_edge(UP)\n",
        "        self.play(Write(eq))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LookTwoAheadWrapper(VideoWrapper):\n",
        "    title = \"Later...\"\n",
        "\n",
        "\n",
        "class AskAboutPhysicsRelation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        physics = self.get_physics_entropy_image()\n",
        "        physics.next_to(self.students[2], UL)\n",
        "        physics.to_edge(UP)\n",
        "\n",
        "        self.student_says(\n",
        "            OldTexText(\"What does this have\\\\\\\\to do with thermodynamics?\"),\n",
        "            target_mode=\"raise_right_hand\",\n",
        "            index=2,\n",
        "            bubble_config=dict(width=5, height=3, direction=LEFT),\n",
        "        )\n",
        "        self.play(self.teacher.change(\"tease\"))\n",
        "        self.play(\n",
        "            self.students[0].change(\"pondering\", physics),\n",
        "            self.students[1].change(\"pondering\", physics),\n",
        "            self.students[2].change(\"raise_left_hand\", physics),\n",
        "            Write(physics),\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "    def get_physics_entropy_image(self):\n",
        "        dots = Dot().get_grid(14, 10)\n",
        "        dots.set_height(3)\n",
        "        n = len(dots)\n",
        "        dots[:n // 2].set_color(RED)\n",
        "        dots[n // 2:].set_color(BLUE)\n",
        "\n",
        "        dots_copy = dots.deepcopy()\n",
        "        dots_copy.set_color(RED)\n",
        "        VGroup(*random.sample(list(dots_copy), n // 2)).set_color(BLUE)\n",
        "\n",
        "        pair = VGroup(dots, dots_copy)\n",
        "        pair.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        rects = VGroup(*map(SurroundingRectangle, pair))\n",
        "        rects.set_stroke(WHITE, 1)\n",
        "        labels = VGroup(\n",
        "            Text(\"Low entropy\"),\n",
        "            Text(\"High entropy\"),\n",
        "        )\n",
        "        labels.scale(0.75)\n",
        "        for label, rect in zip(labels, rects):\n",
        "            label.next_to(rect, UP)\n",
        "\n",
        "        return VGroup(labels, rects, pair)\n",
        "\n",
        "\n",
        "class ContrastWearyAndSlate(WordleScene):\n",
        "    def construct(self):\n",
        "        grid = self.grid\n",
        "        grid.set_height(4)\n",
        "        grid.move_to(FRAME_WIDTH * LEFT / 4)\n",
        "        self.add_word(\"weary\", wait_time_per_letter=0)\n",
        "        grid1 = grid.deepcopy()\n",
        "        self.add(grid1)\n",
        "        for x in range(5):\n",
        "            self.delete_letter()\n",
        "        grid.move_to(FRAME_WIDTH * RIGHT / 4)\n",
        "        self.add_word(\"slate\", wait_time_per_letter=0)\n",
        "        grid2 = grid\n",
        "\n",
        "        grids = VGroup(grid1, grid2)\n",
        "        grids.to_edge(DOWN)\n",
        "\n",
        "        # Entropy\n",
        "        EI_label = OldTex(\n",
        "            \"E[I]\", \"= \", \"\\\\sum_{x} p(x) \\\\log_2\\\\big(1 / p(x) \\\\big)\",\n",
        "            tex_to_color_map={\"I\": BLUE},\n",
        "            font_size=36,\n",
        "        )\n",
        "        EI_label.to_edge(UP)\n",
        "        EI_rect = SurroundingRectangle(EI_label)\n",
        "        EI_rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        values = VGroup(\n",
        "            DecimalNumber(4.90, unit=\"\\\\text{ bits}\"),\n",
        "            DecimalNumber(5.87, unit=\"\\\\text{ bits}\"),\n",
        "        )\n",
        "        arrows = VGroup()\n",
        "        for value, grid in zip(values, grids):\n",
        "            value[4:].shift(SMALL_BUFF * RIGHT)\n",
        "            value.next_to(grid, UP)\n",
        "            arrows.add(Arrow(EI_rect, value))\n",
        "\n",
        "        self.add(EI_label)\n",
        "        self.add(EI_rect)\n",
        "\n",
        "        for arrow, value in zip(arrows, values):\n",
        "            self.play(\n",
        "                ShowCreation(arrow),\n",
        "                CountInFrom(value)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VonNeumannPhrase(Scene):\n",
        "    text = \"You should call \\n it entropy!\"\n",
        "\n",
        "    def construct(self):\n",
        "        label = Text(self.text)\n",
        "        label.set_backstroke(width=8)\n",
        "        for word in self.text.split():\n",
        "            self.add(label.get_part_by_text(word))\n",
        "            self.wait(0.1)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VonNeumannPhrase2(VonNeumannPhrase):\n",
        "    text = \"Nobody knows what \\n entropy really is.\"\n",
        "\n",
        "\n",
        "class MaximumInsert(Scene):\n",
        "    def construct(self):\n",
        "        text = OldTexText(\"Maximum possible\\\\\\\\\", \"expected information\")\n",
        "        arrow = Arrow(text.get_top(), text.get_top() + UR)\n",
        "        arrow.shift(RIGHT)\n",
        "        VGroup(text, arrow).set_color(YELLOW)\n",
        "        self.play(\n",
        "            Write(text),\n",
        "            ShowCreation(arrow),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowEntropyCalculations(IntroduceDistribution):\n",
        "    grid_height = 3.5\n",
        "    grid_center = [-5.0, -1.0, 0]\n",
        "    CONFIG = {\"random_seed\": 0}\n",
        "    n_words = 100\n",
        "\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        grid = self.grid\n",
        "\n",
        "        kw = dict(x_max=150, width=8.5, height=6.5)\n",
        "        axes = self.get_axes(y_max=0.2, **kw)\n",
        "        axes.to_edge(RIGHT, buff=0.1)\n",
        "        axes.to_edge(UP, buff=0.5)\n",
        "        y_label = OldTex(\"p\", font_size=24)\n",
        "        y_label.next_to(axes.y_axis.n2p(0.2), RIGHT)\n",
        "        axes.y_axis.add(y_label)\n",
        "        self.add(axes)\n",
        "\n",
        "        # old_axes = self.get_axes(y_max=0.4, **kw)\n",
        "        # old_axes.next_to(axes, DOWN, buff=0.8)\n",
        "        # y_label = OldTex(\"p \\\\cdot \\\\log_2(1/p)\", font_size=24)\n",
        "        # y_label.next_to(old_axes.y_axis.n2p(0.4), RIGHT, MED_SMALL_BUFF)\n",
        "        # old_axes.y_axis.add(y_label)\n",
        "        # self.add(old_axes)\n",
        "\n",
        "        # Formula\n",
        "        ent_formula = self.get_entropy_label()\n",
        "        ent_formula.scale(1.2)\n",
        "        ent_formula.move_to(axes, UR)\n",
        "        ent_formula.shift(DOWN)\n",
        "        ent_formula.shift_onto_screen()\n",
        "        ent_rhs = ent_formula[1]\n",
        "        self.add(ent_formula)\n",
        "        n = 3**5\n",
        "\n",
        "        # Bang on through\n",
        "        words = list(random.sample(self.all_words, self.n_words))\n",
        "        words = [\"maths\", \"weary\", \"other\", \"tares\", \"kayak\"] + words\n",
        "\n",
        "        for word in words:\n",
        "            low_bars = self.get_distribution_bars(axes, word)\n",
        "            self.add(low_bars)\n",
        "\n",
        "            dist = np.array([bar.prob for bar in low_bars])\n",
        "            ent_summands = -np.log2(dist, where=dist > 1e-10) * dist\n",
        "            # high_bars = self.get_bars(old_axes, ent_summands)\n",
        "            # high_bars.add_updater(lambda m: m.match_style(low_bars))\n",
        "            # self.add(high_bars)\n",
        "\n",
        "            self.add_word(word, wait_time_per_letter=0)\n",
        "            trackers = self.add_trackers(low_bars, index=0)\n",
        "            x_tracker, bar_indicator, p_label, info_label, match_label = trackers\n",
        "            p_label.add_updater(lambda m: m.move_to(axes, DL).shift([2, 1, 0]))\n",
        "            self.remove(info_label)\n",
        "            self.remove(match_label)\n",
        "\n",
        "            # Highlight answer\n",
        "            arrow = OldTex(\"\\\\rightarrow\")\n",
        "            pw = grid.pending_word.copy()\n",
        "            pw.generate_target()\n",
        "            pw.arrange(RIGHT, buff=0.05)\n",
        "            rhs = ent_rhs.copy()\n",
        "            rhs.set_value(sum(ent_summands))\n",
        "            group = VGroup(pw, arrow, rhs)\n",
        "            group.set_color(BLUE)\n",
        "            group.arrange(RIGHT)\n",
        "            group.match_width(grid)\n",
        "            group.next_to(grid, UP, LARGE_BUFF)\n",
        "\n",
        "            self.add(group)\n",
        "\n",
        "            # Show calculation\n",
        "            x_tracker.suspend_updating()\n",
        "            n = list(dist).index(0) + 1\n",
        "            self.play(\n",
        "                UpdateFromAlphaFunc(\n",
        "                    x_tracker, lambda m, a: m.set_value(int(a * (n - 1))),\n",
        "                ),\n",
        "                UpdateFromAlphaFunc(\n",
        "                    ent_rhs, lambda m, a: m.set_value(sum(ent_summands[:int(a * n)]))\n",
        "                ),\n",
        "                rate_func=linear,\n",
        "                run_time=4 * n / 3**5,\n",
        "            )\n",
        "            self.wait()\n",
        "            # x_tracker.resume_updating()\n",
        "            # self.embed()\n",
        "            self.remove(group)\n",
        "\n",
        "            # Clear\n",
        "            self.remove(*trackers, low_bars, pw, arrow, rhs)\n",
        "            ent_rhs.set_value(0)\n",
        "            grid.pending_word.set_submobjects([])\n",
        "            grid.clear_updaters()\n",
        "            grid.add_updater(lambda m: m)\n",
        "            self.get_curr_row().set_fill(BLACK, 0)\n",
        "\n",
        "\n",
        "class WrapperForEntropyCalculation(VideoWrapper):\n",
        "    title = \"Search for maximum entropy\"\n",
        "\n",
        "\n",
        "class AltWrapperForEntropyCalculation(VideoWrapper):\n",
        "    title = \"Refined entropy calculation\"\n",
        "    animate_boundary = False\n",
        "\n",
        "\n",
        "class UniformPriorExample(WordleSceneWithAnalysis):\n",
        "    uniform_prior = True\n",
        "    show_prior = False\n",
        "    weight_to_prob = 0  # TODO\n",
        "    pre_computed_first_guesses = [\n",
        "        \"tares\", \"lares\", \"rales\", \"rates\", \"teras\",\n",
        "        \"nares\", \"soare\", \"tales\", \"reais\", \"tears\",\n",
        "        \"arles\", \"tores\", \"salet\",\n",
        "    ]\n",
        "\n",
        "\n",
        "class MentionUsingWordFrequencies(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"Next step: Integrate\\\\\\\\word frequency data\"),\n",
        "            added_anims=[self.change_students(\"hooray\", \"happy\", \"tease\")]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(self.students[1].change(\"pondering\"))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class V2TitleCard(TitleCardScene):\n",
        "    n_letters = 6\n",
        "    words = [\"how-to\", \"prefer\", \"common\", \"words\"]\n",
        "    secret_word = \"priors\"\n",
        "\n",
        "\n",
        "class HowThePriorWorks(Scene):\n",
        "    def construct(self):\n",
        "        # Prepare columns\n",
        "        all_words = get_word_list()\n",
        "        freq_map = get_word_frequencies()\n",
        "        sorted_words = list(sorted(all_words, key=lambda w: -freq_map[w]))\n",
        "\n",
        "        col1, col2 = cols = [\n",
        "            WordleScene.get_grid_of_words(\n",
        "                word_list, 25, 1, dots_index=-12\n",
        "            )\n",
        "            for word_list in (random.sample(all_words, 100), sorted_words)\n",
        "        ]\n",
        "        for col in cols:\n",
        "            col.set_height(6)\n",
        "            col.set_x(-1)\n",
        "            col.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        bars1, bars2 = [\n",
        "            self.get_freq_bars(col, freq_map, max_width=width, exp=exp)\n",
        "            for col, width, exp in zip(cols, (1, 2), (0.3, 1))\n",
        "        ]\n",
        "\n",
        "        group1 = VGroup(col1, bars1)\n",
        "        group2 = VGroup(col2, bars2)\n",
        "\n",
        "        col1_title = VGroup(\n",
        "            Text(\"Relative frequencies of all words\"),\n",
        "            Text(\"From the Google Books English n-gram public dataset\", font_size=24, color=GREY_B),\n",
        "        )\n",
        "        col1_title.arrange(DOWN)\n",
        "        col1_title.set_height(1)\n",
        "        col1_title.next_to(col1, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        # Introduce frequencies\n",
        "        for bar in bars1:\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 0, about_edge=LEFT)\n",
        "            bar.set_stroke(width=0)\n",
        "\n",
        "        self.wait()\n",
        "        self.add(col1)\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, bars1),\n",
        "            FadeIn(col1_title, 0.5 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        arrow = Vector(2 * RIGHT, stroke_width=5)\n",
        "        arrow.set_x(0).match_y(col1)\n",
        "        arrow_label = Text(\"Sort\", font_size=36)\n",
        "        arrow_label.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            Write(arrow_label),\n",
        "            group1.animate.next_to(arrow, LEFT)\n",
        "        )\n",
        "        group2.next_to(arrow, RIGHT, buff=LARGE_BUFF)\n",
        "        self.play(LaggedStart(*(\n",
        "            FadeInFromPoint(VGroup(word, bar), col1.get_center())\n",
        "            for word, bar in zip(col2, bars2)\n",
        "        ), lag_ratio=0.1, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Word play\n",
        "        numbers = VGroup(\n",
        "            *(Integer(i + 1) for i in range(13))\n",
        "        )\n",
        "        numbers.match_height(col2[0])\n",
        "        for number, word in zip(numbers, col2):\n",
        "            number.next_to(word, LEFT, SMALL_BUFF, aligned_edge=UP)\n",
        "            number.word = word\n",
        "            number.add_updater(lambda m: m.match_style(m.word))\n",
        "\n",
        "        rect = SurroundingRectangle(col2[:13], buff=0.05)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.replace(col2[7], stretch=True).set_opacity(0),\n",
        "            col2[7].animate.set_color(YELLOW),\n",
        "            ShowIncreasingSubsets(numbers),\n",
        "            run_time=0.5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(rect)\n",
        "        for i in [0, 1, 2, 8, 7, 6, 3, 4, (9, 10, 11, 12)]:\n",
        "            col2.set_color(GREY_A)\n",
        "            for j in listify(i):\n",
        "                col2[j].set_color(YELLOW)\n",
        "            self.wait(0.5)\n",
        "        self.play(col2.animate.set_color(GREY_A))\n",
        "\n",
        "        # Don't care about relative frequencies\n",
        "        comp_words = [\"which\", \"braid\"]\n",
        "        which_group, braid_group = comp = VGroup(*(\n",
        "            VGroup(\n",
        "                Text(word, font=\"Consolas\"),\n",
        "                Vector(RIGHT),\n",
        "                DecimalNumber(freq_map[word], num_decimal_places=6)\n",
        "            ).arrange(RIGHT)\n",
        "            for word in comp_words\n",
        "        ))\n",
        "        comp.arrange(DOWN, buff=2.0)\n",
        "        comp.to_edge(LEFT)\n",
        "\n",
        "        percentages = DecimalNumber(99.9, num_decimal_places=1, unit=\"\\\\%\").replicate(2)\n",
        "        rhss = VGroup()\n",
        "        for per, group in zip(percentages, comp):\n",
        "            rhs = group[2]\n",
        "            rhss.add(rhs)\n",
        "            per.move_to(rhs, LEFT)\n",
        "            rhs.generate_target()\n",
        "            rhs.target.scale(0.8)\n",
        "            rhs.target.set_color(GREY_B)\n",
        "            rhs.target.next_to(per, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(arrow),\n",
        "            FadeOut(arrow_label),\n",
        "            FadeOut(group1),\n",
        "            FadeTransform(col2[0].copy(), which_group[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(which_group[1]),\n",
        "            CountInFrom(which_group[2], 0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeTransform(which_group[:2].copy(), braid_group[:2]))\n",
        "        self.play(CountInFrom(braid_group[2], 0, run_time=0.5))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(percentages, 0.75 * DOWN),\n",
        "            *map(MoveToTarget, rhss),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Sigmoid\n",
        "        axes = Axes((-10, 10), (0, 2, 0.25), width=12, height=6)\n",
        "        axes.y_axis.add_numbers(np.arange(0.25, 2.25, 0.25), num_decimal_places=2, font_size=18)\n",
        "        axes.center()\n",
        "\n",
        "        col3 = WordleScene.get_grid_of_words(sorted_words, 25, 4, dots_index=-50)\n",
        "        col3.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        col3.generate_target()\n",
        "        col3.target.rotate(-90 * DEGREES)\n",
        "        col3.target.match_width(axes.x_axis)\n",
        "        col3.target.next_to(axes.x_axis, DOWN, buff=0)\n",
        "\n",
        "        col2_words = [w.text for w in col2]\n",
        "        col3.match_width(col2)\n",
        "        for word in col3:\n",
        "            if word.text in col2_words:\n",
        "                word.move_to(col2[col2_words.index(word.text)])\n",
        "            else:\n",
        "                word.rotate(-90 * DEGREES)\n",
        "                word.move_to(col2[col2_words.index('...')])\n",
        "                word.scale(0)\n",
        "                word.set_opacity(0)\n",
        "\n",
        "        self.remove(col2),\n",
        "        self.play(LaggedStart(\n",
        "            FadeOut(VGroup(comp, percentages), 2 * LEFT),\n",
        "            FadeOut(numbers),\n",
        "            FadeOut(bars2),\n",
        "            FadeOut(col1_title, UP),\n",
        "            MoveToTarget(col3),\n",
        "            Write(axes),\n",
        "            FadeOut(col2[col2_words.index(\"...\")]),\n",
        "            run_time=5,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        graph = axes.get_graph(sigmoid)\n",
        "        graph.set_stroke(BLUE, 3)\n",
        "        graph_label = OldTex(\"\\\\sigma(x) = {1 \\\\over 1 + e^{-x} }\")\n",
        "        graph_label.next_to(graph.get_end(), UL)\n",
        "\n",
        "        self.play(ShowCreation(graph))\n",
        "        self.play(Write(graph_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Lines to graph\n",
        "        lines = Line().replicate(len(col3))\n",
        "        lines.set_stroke(BLUE_B, 1.0)\n",
        "\n",
        "        def update_lines(lines):\n",
        "            for line, word in zip(lines, col3):\n",
        "                line.put_start_and_end_on(\n",
        "                    word.get_top(),\n",
        "                    axes.input_to_graph_point(axes.x_axis.p2n(word.get_center()), graph),\n",
        "                )\n",
        "\n",
        "        lines.add_updater(update_lines)\n",
        "        self.play(ShowCreation(lines, lag_ratio=0.05, run_time=5))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(col3.animate.scale(2.0, about_edge=UP), run_time=3)\n",
        "        self.play(col3.animate.scale(0.25, about_edge=UP), run_time=3)\n",
        "        self.play(col3.animate.scale(2.0, about_edge=UP), run_time=3)\n",
        "        self.wait()\n",
        "        for vect in [RIGHT, 2 * LEFT, RIGHT]:\n",
        "            self.play(col3.animate.shift(vect), run_time=2)\n",
        "        lines.clear_updaters()\n",
        "        self.wait()\n",
        "\n",
        "        # Show window of words\n",
        "        n_shown = 15\n",
        "        col4 = WordleScene.get_grid_of_words(\n",
        "            sorted_words[3000:3000 + n_shown], 20, 1\n",
        "        )\n",
        "        dots = Text(\"...\", font=\"Consolas\", font_size=24).rotate(90 * DEGREES)\n",
        "        col4.add_to_back(dots.copy().next_to(col4, UP))\n",
        "        col4.add(dots.copy().next_to(col4, DOWN))\n",
        "        col4.set_height(6)\n",
        "        col4.to_corner(UL)\n",
        "        col4.shift(RIGHT)\n",
        "\n",
        "        numbers = VGroup(*(Integer(n) for n in range(3000, 3000 + n_shown)))\n",
        "        numbers.set_height(col4[1].get_height())\n",
        "        for number, word in zip(numbers, col4[1:]):\n",
        "            number.next_to(word, LEFT, MED_SMALL_BUFF, aligned_edge=UP)\n",
        "            number.match_style(word)\n",
        "            number.align_to(numbers[0], LEFT)\n",
        "            word.add(number)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(col4))\n",
        "        self.wait()\n",
        "\n",
        "    def get_freq_bars(self, words, freq_map, max_width=2, exp=1):\n",
        "        freqs = [freq_map.get(w.text, 0)**exp for w in words]  # Smoothed out a bit\n",
        "        max_freq = max(freqs)\n",
        "        bars = VGroup()\n",
        "        height = np.mean([w.get_height() for w in words]) * 0.8\n",
        "        for word, freq in zip(words, freqs):\n",
        "            bar = Rectangle(\n",
        "                height=height,\n",
        "                width=max_width * freq / max_freq,\n",
        "                stroke_color=WHITE,\n",
        "                stroke_width=1,\n",
        "                fill_color=BLUE,\n",
        "                fill_opacity=1,\n",
        "            )\n",
        "            bar.next_to(word, RIGHT, SMALL_BUFF)\n",
        "            if word.text not in freq_map:\n",
        "                bar.set_opacity(0)\n",
        "            bars.add(bar)\n",
        "        return bars\n",
        "\n",
        "\n",
        "class ShowWordLikelihoods(Scene):\n",
        "    title = \"How likely is each word\\\\\\\\to be an answer?\"\n",
        "    n_shown = 20\n",
        "\n",
        "    def construct(self):\n",
        "        all_words = get_word_list()\n",
        "        n = self.n_shown\n",
        "        words = random.sample(all_words, n)\n",
        "        word_mobs = WordleScene.get_grid_of_words(words, 2, n // 2)\n",
        "        word_mobs[n // 2:].next_to(word_mobs[:n // 2], DOWN, buff=2.0)\n",
        "        word_mobs.set_width(FRAME_WIDTH - 2)\n",
        "        word_mobs.to_edge(DOWN)\n",
        "        self.add(word_mobs)\n",
        "\n",
        "        title = OldTexText(self.title)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        freq_prior = get_frequency_based_priors()\n",
        "        true_prior = get_true_wordle_prior()\n",
        "        bars = VGroup()\n",
        "        decs = VGroup()\n",
        "        for word in word_mobs:\n",
        "            fp = freq_prior[word.text]\n",
        "            tp = true_prior[word.text]\n",
        "            p = (0.7 * tp + 0.3 * fp)\n",
        "            bar = Rectangle(0.5, 1.5 * p)\n",
        "            bar.set_stroke(WHITE, 1)\n",
        "            bar.set_fill(BLUE, 1)\n",
        "            bar.next_to(word, UP, SMALL_BUFF)\n",
        "            dec = DecimalNumber(100 * p, unit=\"\\\\%\")\n",
        "            dec.scale(0.5)\n",
        "            dec.bar = bar\n",
        "            dec.add_updater(lambda m: m.next_to(m.bar, UP, SMALL_BUFF))\n",
        "            dec.next_to(bar, UP)\n",
        "\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 1, about_edge=DOWN)\n",
        "            bar.set_opacity(0)\n",
        "            decs.add(dec)\n",
        "            bars.add(bar)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, bars, lag_ratio=0.01),\n",
        "            LaggedStartMap(CountInFrom, decs, lag_ratio=0.01),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.bars = bars\n",
        "        self.decs = decs\n",
        "        self.word_mobs = word_mobs\n",
        "\n",
        "\n",
        "class SidewaysWordProbabilities(Scene):\n",
        "    CONFIG = {\"random_seed\": 5}\n",
        "\n",
        "    def construct(self):\n",
        "        # Blatant copy-paste-and-modify from scene above...\n",
        "        all_words = get_word_list()\n",
        "        n = 15\n",
        "        words = random.sample(all_words, n)\n",
        "        word_mobs = WordleScene.get_grid_of_words(words, 15, 1)\n",
        "        word_mobs.arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        word_mobs.set_height(FRAME_HEIGHT - 1)\n",
        "        word_mobs.to_edge(LEFT)\n",
        "        self.add(word_mobs)\n",
        "\n",
        "        freq_prior = get_frequency_based_priors()\n",
        "        true_prior = get_true_wordle_prior()\n",
        "        bars = VGroup()\n",
        "        decs = VGroup()\n",
        "        for word in word_mobs:\n",
        "            fp = freq_prior[word.text]\n",
        "            tp = true_prior[word.text]\n",
        "            p = (0.7 * tp + 0.3 * fp)\n",
        "            bar = Rectangle(1.5 * p, 0.2)\n",
        "            bar.set_stroke(WHITE, 1)\n",
        "            bar.set_fill(BLUE, 1)\n",
        "            bar.next_to(word, RIGHT, MED_SMALL_BUFF)\n",
        "            dec = DecimalNumber(100 * p, unit=\"\\\\%\", num_decimal_places=0)\n",
        "            dec.scale(0.5)\n",
        "            dec.bar = bar\n",
        "            dec.add_updater(lambda m: m.next_to(m.bar, RIGHT, SMALL_BUFF))\n",
        "\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 0, about_edge=LEFT)\n",
        "            bar.set_opacity(0)\n",
        "            decs.add(dec)\n",
        "            bars.add(bar)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(Restore, bars, lag_ratio=0.01),\n",
        "            LaggedStartMap(CountInFrom, decs, lag_ratio=0.01),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DistributionOverWord(ShowWordLikelihoods):\n",
        "    CONFIG = {\"random_seed\": 2}\n",
        "\n",
        "\n",
        "class LookThroughWindowsOfWords(Scene):\n",
        "    def construct(self):\n",
        "        # Copied from previous scene\n",
        "        priors = get_frequency_based_priors()\n",
        "        sorted_words = sorted(get_word_list(), key=lambda w: -priors[w])\n",
        "\n",
        "        base = 2880\n",
        "        group_size = 20\n",
        "        n_groups = 3\n",
        "        col4 = VGroup(*(\n",
        "            WordleScene.get_grid_of_words(\n",
        "                sorted_words[base + n * group_size:base + (n + 1) * group_size],\n",
        "                group_size, 1\n",
        "            )\n",
        "            for n in range(n_groups)\n",
        "        ))\n",
        "        col4.arrange(DOWN, buff=0.1)\n",
        "        col4 = VGroup(*it.chain(*col4))\n",
        "        col4.center().to_edge(UP)\n",
        "\n",
        "        numbers = VGroup(*(Integer(n) for n in range(base, base + n_groups * group_size)))\n",
        "        numbers.set_height(col4[1].get_height())\n",
        "        for number, word in zip(numbers, col4[1:]):\n",
        "            number.next_to(word, LEFT, MED_SMALL_BUFF, aligned_edge=UP)\n",
        "            number.match_style(word)\n",
        "            number.align_to(numbers[0], LEFT)\n",
        "            number.align_to(word[np.argmin([c.get_height() for c in word])], DOWN)\n",
        "            word.add(number)\n",
        "\n",
        "        self.add(col4)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        self.play(frame.animate.align_to(col4, DOWN), run_time=20)\n",
        "\n",
        "\n",
        "class EntropyOfWordDistributionExample(WordleScene):\n",
        "    grid_height = 4\n",
        "    grid_center = 4.5 * LEFT\n",
        "    secret_word = \"graph\"\n",
        "    wordle_based_prior = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Try first two guesses\n",
        "        grid = self.grid\n",
        "        guesses = [\"other\", \"nails\"]\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            self.add_word(\"other\")\n",
        "            self.reveal_pattern()\n",
        "            self.add_word(\"nails\")\n",
        "            self.reveal_pattern()\n",
        "        else:\n",
        "            self.wait()\n",
        "            self.wait(\"Enter \\\"{}\\\" then \\\"{}\\\"\".format(*guesses))\n",
        "\n",
        "        # Add match label\n",
        "        match_label = VGroup(Integer(4, edge_to_fix=RIGHT), Text(\"Matches\"))\n",
        "        match_label.scale(0.75)\n",
        "        match_label.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        match_label.next_to(grid, UP)\n",
        "        self.add(match_label)\n",
        "\n",
        "        # Show words\n",
        "        s_words = get_word_list(short=True)\n",
        "        col1 = self.get_grid_of_words(\n",
        "            sorted(list(set(self.possibilities).intersection(s_words))),\n",
        "            4, 1\n",
        "        )\n",
        "        col1.scale(1.5)\n",
        "        col1.next_to(grid, RIGHT, buff=1)\n",
        "        bars1 = VGroup(*(\n",
        "            self.get_prob_bar(word, 0.25)\n",
        "            for word in col1\n",
        "        ))\n",
        "        for bar in bars1:\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 0, about_edge=LEFT)\n",
        "            bar.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(col1),\n",
        "            CountInFrom(match_label[0], 0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(Restore, bars1))\n",
        "        self.wait()\n",
        "\n",
        "        # Ask about entropy\n",
        "        brace = Brace(bars1, RIGHT)\n",
        "        question = Text(\"What is the\\nentropy?\", font_size=36)\n",
        "        question.next_to(brace, RIGHT)\n",
        "\n",
        "        formula = OldTex(\n",
        "            \"H &=\",\n",
        "            \"\\\\sum_x p(x) \\\\cdot\", \"\\\\log_2\\\\big(1 / p(x) \\\\big)\\\\\\\\\",\n",
        "            font_size=36,\n",
        "        )\n",
        "        formula.next_to(brace, RIGHT, submobject_to_align=formula[0])\n",
        "\n",
        "        info_box = SurroundingRectangle(formula[2], buff=SMALL_BUFF)\n",
        "        info_box.set_stroke(TEAL, 2)\n",
        "        info_label = Text(\"Information\", font_size=36)\n",
        "        info_label.next_to(info_box, UP)\n",
        "        info_label.match_color(info_box)\n",
        "        info_value = OldTex(\"\\\\log_2(4)\", \"=\", \"2\", font_size=36)\n",
        "        info_value[1].rotate(PI / 2)\n",
        "        info_value.arrange(DOWN, SMALL_BUFF)\n",
        "        info_value.next_to(info_box, DOWN)\n",
        "        alt_lhs = formula[0].copy().next_to(info_value[-1], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(question),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(formula, lag_ratio=0.1),\n",
        "            question.animate.shift(2 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(info_box),\n",
        "            Write(info_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(FadeIn(info_value[0]))\n",
        "        self.wait()\n",
        "        self.play(Write(info_value[1:]))\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(formula[0], alt_lhs))\n",
        "        self.wait()\n",
        "\n",
        "        # Introduce remaining words\n",
        "        col2 = self.get_grid_of_words(\n",
        "            sorted(self.possibilities), 16, 1\n",
        "        )\n",
        "        col2.match_width(col1)\n",
        "        col2.move_to(col1, LEFT)\n",
        "        col2.save_state()\n",
        "        col1_words = [w.text for w in col1]\n",
        "        for word in col2:\n",
        "            if word.text in col1_words:\n",
        "                word.move_to(col1[col1_words.index(word.text)])\n",
        "            else:\n",
        "                word.move_to(col1)\n",
        "                word.set_opacity(0)\n",
        "\n",
        "        pre_bars2, bars2 = [\n",
        "            VGroup(*(\n",
        "                self.get_prob_bar(\n",
        "                    word,\n",
        "                    0.246 * self.priors[word.text] + 0.001,\n",
        "                    num_decimal_places=3,\n",
        "                )\n",
        "                for word in group\n",
        "            ))\n",
        "            for group in (col2, col2.saved_state)\n",
        "        ]\n",
        "\n",
        "        new_brace = Brace(bars2, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeTransform(col1, col2),\n",
        "            FadeTransform(bars1, pre_bars2),\n",
        "            LaggedStart(*map(FadeOut, [alt_lhs, info_value, info_label, info_box]))\n",
        "        )\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(match_label[0], 16, run_time=1),\n",
        "            Restore(col2, run_time=2),\n",
        "            ReplacementTransform(pre_bars2, bars2, run_time=2),\n",
        "            Transform(brace, new_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pass the time by entering the various words\n",
        "        shuffled_col2 = list(col2)\n",
        "        random.shuffle(shuffled_col2)\n",
        "        for word in shuffled_col2:\n",
        "            if word.text in [w.text for w in col1]:\n",
        "                continue\n",
        "            word.set_color(YELLOW)\n",
        "            for letter in word.text:\n",
        "                self.add_letter(letter)\n",
        "                self.wait(random.random() * 0.2)\n",
        "            self.wait(0.5)\n",
        "            for x in range(5):\n",
        "                self.delete_letter()\n",
        "                self.wait(0.1)\n",
        "            word.set_color(WHITE)\n",
        "\n",
        "        shuffled_col2 = list(col2)\n",
        "        random.shuffle(shuffled_col2)\n",
        "        for word in shuffled_col2:\n",
        "            if word.text not in [w.text for w in col1]:\n",
        "                continue\n",
        "            rect = SurroundingRectangle(word)\n",
        "            rect.set_color(GREEN)\n",
        "            self.add(rect)\n",
        "            word.set_color(GREEN)\n",
        "            for letter in word.text:\n",
        "                self.add_letter(letter)\n",
        "                self.wait(random.random() * 0.2)\n",
        "            self.wait(0.5)\n",
        "            for x in range(5):\n",
        "                self.delete_letter()\n",
        "                self.wait(0.1)\n",
        "            word.set_color(WHITE)\n",
        "            self.remove(rect)\n",
        "\n",
        "        # Proposed answer\n",
        "        rhs1 = OldTex(\"= \\\\log_2(16) = 4?\", font_size=36)\n",
        "        rhs1.next_to(formula[1], DOWN, aligned_edge=LEFT)\n",
        "        cross = Cross(rhs1).set_stroke(RED, 6)\n",
        "        rhs2 = OldTex(\n",
        "            \"= &4 \\\\big(0.247 \\\\cdot \\\\log_2(1/0.247)\\\\big) \\\\\\\\\",\n",
        "            \"+ &12 \\\\big(0.001 \\\\cdot \\\\log_2(1/0.001)\\\\big)\\\\\\\\ \",\n",
        "            \"= &2.11\",\n",
        "            font_size=30,\n",
        "        )\n",
        "        rhs2.next_to(rhs1, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(Write(rhs1))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            Write(rhs2),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        rect = SurroundingRectangle(rhs2[-1])\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.wait()\n",
        "\n",
        "    def get_prob_bar(self, word, prob, num_decimal_places=2, height=0.15, width_mult=8.0):\n",
        "        bar = Rectangle(\n",
        "            height=height,\n",
        "            width=width_mult * prob,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "            fill_color=BLUE,\n",
        "        )\n",
        "        bar.next_to(word, RIGHT, MED_SMALL_BUFF)\n",
        "        label = DecimalNumber(prob, font_size=24, num_decimal_places=num_decimal_places)\n",
        "        label.next_to(bar, RIGHT, SMALL_BUFF)\n",
        "        bar.add(label)\n",
        "        bar.label = label\n",
        "        bar.set_opacity(word[0].get_fill_opacity())\n",
        "        return bar\n",
        "\n",
        "    def seek_good_examples(self):\n",
        "        words = get_word_list()\n",
        "        swords = get_word_list(short=True)\n",
        "        for answer in swords:\n",
        "            poss = list(words)\n",
        "            for guess in [\"other\", \"nails\"]:\n",
        "                poss = get_possible_words(\n",
        "                    guess,\n",
        "                    get_pattern(guess, answer),\n",
        "                    poss,\n",
        "                )\n",
        "            n = len(set(poss).intersection(swords))\n",
        "            m = len(poss)\n",
        "            if n == 4 and m in (16, 32, 64):\n",
        "                print(answer, n, len(poss))\n",
        "\n",
        "\n",
        "class WhatMakesWordleNice(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            OldTexText(\"This is what makes wordle\\\\\\\\such a nice example\"),\n",
        "            added_anims=[self.change_students(\n",
        "                \"pondering\", \"thinking\", \"erm\",\n",
        "                look_at=ORIGIN,\n",
        "            )]\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class TwoInterpretationsWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = ScreenRectangle().get_grid(1, 2, buff=MED_LARGE_BUFF)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.set_stroke(WHITE, 1)\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.move_to(DOWN)\n",
        "\n",
        "        title = Text(\"Two applications of entropy\", font_size=60)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        screen_titles = VGroup(\n",
        "            Text(\"Expected information from guess\"),\n",
        "            Text(\"Remaining uncertainty\"),\n",
        "        )\n",
        "        screen_titles.scale(0.8)\n",
        "        for screen, word in zip(screens, screen_titles):\n",
        "            word.next_to(screen, UP)\n",
        "\n",
        "        screen_titles[0].set_color(BLUE)\n",
        "        screen_titles[1].set_color(TEAL)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(screens)\n",
        "        self.wait()\n",
        "        for word in screen_titles:\n",
        "            self.play(Write(word, run_time=1))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class IntroduceDistributionFreqPrior(IntroduceDistribution):\n",
        "    n_word_rows = 1\n",
        "    uniform_prior = False\n",
        "    show_fraction_in_p_label = False\n",
        "\n",
        "\n",
        "class FreqPriorExample(WordleSceneWithAnalysis):\n",
        "    pre_computed_first_guesses = [\n",
        "        \"tares\", \"lares\", \"rates\", \"rales\", \"tears\",\n",
        "        \"tales\", \"salet\", \"teras\", \"arles\", \"nares\",\n",
        "        \"soare\", \"saner\", \"reals\"\n",
        "    ]\n",
        "\n",
        "\n",
        "class ConstrastResultsWrapper(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        screens = Rectangle(4, 3).replicate(2)\n",
        "        screens.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        screens.set_width(FRAME_WIDTH - 1)\n",
        "        screens.set_stroke(WHITE, 1)\n",
        "        screens.set_fill(BLACK, 1)\n",
        "        screens.move_to(DOWN)\n",
        "        self.add(screens)\n",
        "\n",
        "\n",
        "class WordlePriorExample(WordleSceneWithAnalysis):\n",
        "    secret_word = \"thump\"\n",
        "    wordle_based_prior = True\n",
        "    pre_computed_first_guesses = [\n",
        "        \"soare\", \"raise\", \"roate\", \"raile\", \"reast\",\n",
        "        \"slate\", \"crate\", \"irate\", \"trace\", \"salet\",\n",
        "        \"arise\", \"orate\", \"stare\"\n",
        "    ]\n",
        "\n",
        "\n",
        "class HowToCombineEntropyAndProbability(FreqPriorExample):\n",
        "    secret_word = \"words\"\n",
        "\n",
        "    def construct(self):\n",
        "        super().construct()\n",
        "        # Put in first three\n",
        "        guesses = [\"favor\", \"ideal\", \"scores\"]\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            for guess in guesses:\n",
        "                self.add_word(guess)\n",
        "                self.reveal_pattern()\n",
        "        else:\n",
        "            self.wait(note=f\"Enter{guesses}, discuss\")\n",
        "\n",
        "        # Fade lower grid\n",
        "        rows = self.guess_value_grid\n",
        "\n",
        "        self.wait()\n",
        "        self.play(rows[:2].animate.set_opacity(0.3))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rows[:2].animate.set_opacity(1),\n",
        "            rows[2:].animate.set_opacity(0.3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rows[1].animate.set_opacity(0.3),\n",
        "            rows[2].animate.set_opacity(1),\n",
        "            rows[3:].animate.set_opacity(0.3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Expected score\n",
        "        es_eq = OldTex(\n",
        "            \"E[\\\\text{Score}] = 0.58 \\\\cdot {4} +\",\n",
        "            \"(1 - 0.58)\", \" \\\\cdot \\\\big({4} + f(1.44 - 1.27)\\\\big)\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\text{Score}\": YELLOW,\n",
        "                \"{4}\": YELLOW,\n",
        "                \"0.58\": self.prior_color,\n",
        "                \"1.44\": self.entropy_color,\n",
        "                \"1.27\": self.entropy_color,\n",
        "                \"=\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        es_eq.next_to(self.grid, DOWN, LARGE_BUFF)\n",
        "        es_eq.to_edge(RIGHT)\n",
        "\n",
        "        left_part = es_eq[:11]\n",
        "        left_part.save_state()\n",
        "        left_part.align_to(self.grid, LEFT)\n",
        "\n",
        "        q_marks = OldTex(\"???\")\n",
        "        q_marks.next_to(es_eq.get_part_by_tex(\"=\"), RIGHT)\n",
        "\n",
        "        if not self.presenter_mode or self.skip_animations:\n",
        "            self.add_word(\"words\")\n",
        "        else:\n",
        "            self.wait(note=\"Enter \\\"words\\\"\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(es_eq[:4]),\n",
        "            FadeIn(q_marks)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FlashAround(rows[0][2], run_time=3))\n",
        "        self.play(\n",
        "            FadeTransform(rows[0][2].copy(), es_eq.get_part_by_tex(\"0.58\")),\n",
        "            FadeIn(es_eq.slice_by_tex(\"\\\\cdot\", \"(1 -\")),\n",
        "            q_marks.animate.next_to(es_eq[:8], RIGHT, aligned_edge=UP)\n",
        "        )\n",
        "        self.remove(es_eq)\n",
        "        self.add(es_eq[:8])\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(es_eq[8:11]),\n",
        "            q_marks.animate.next_to(es_eq[10], RIGHT),\n",
        "            FadeOut(rows[3:])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(left_part),\n",
        "            FadeTransform(q_marks, es_eq[11:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FirstThoughtsOnCombination(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer(height=2)\n",
        "        morty.flip()\n",
        "        morty.to_corner(DL)\n",
        "\n",
        "        example = VGroup(\n",
        "            Text(\"dorms\", font=\"Consolas\"),\n",
        "            DecimalNumber(1.08, color=TEAL),\n",
        "            DecimalNumber(0.31, color=BLUE),\n",
        "        )\n",
        "        word, n1, n2 = example\n",
        "        example.arrange(RIGHT, buff=1.5)\n",
        "        example[0].shift(0.5 * RIGHT)\n",
        "        example.to_corner(UR)\n",
        "        example.shift(DOWN)\n",
        "\n",
        "        example_titles = VGroup(\n",
        "            OldTex(\"E[\\\\text{Info.}]\", color=TEAL),\n",
        "            OldTex(\"p(\\\\text{word})\", color=BLUE),\n",
        "        )\n",
        "        for title, ex in zip(example_titles, example[1:]):\n",
        "            title.next_to(ex, UP, MED_LARGE_BUFF)\n",
        "            title.add(Underline(title, buff=-0.05).set_stroke(GREY, 1))\n",
        "\n",
        "        self.add(example_titles)\n",
        "        self.add(example)\n",
        "        self.add(morty)\n",
        "\n",
        "        self.play(PiCreatureBubbleIntroduction(\n",
        "            morty,\n",
        "            OldTexText(\"How should I measure\\\\\\\\guess quality?\", font_size=36),\n",
        "            look_at=example,\n",
        "            target_mode=\"pondering\",\n",
        "            bubble_type=ThoughtBubble,\n",
        "            bubble_config={\"width\": 4, \"height\": 3},\n",
        "        ))\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        attempt = example.copy()\n",
        "        attempt.generate_target()\n",
        "        arrow = OldTex(\"\\\\rightarrow\")\n",
        "        plus = OldTex(\"+\")\n",
        "        group = VGroup(\n",
        "            attempt.target[0],\n",
        "            arrow,\n",
        "            attempt.target[1],\n",
        "            plus,\n",
        "            attempt.target[2],\n",
        "        )\n",
        "        group.arrange(RIGHT, buff=0.2)\n",
        "        group.next_to(example, DOWN, buff=2)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(attempt),\n",
        "            morty.change(\"shruggie\", attempt),\n",
        "            FadeIn(arrow), FadeIn(plus),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "\n",
        "        cross = Cross(group)\n",
        "        cross.insert_n_curves(100)\n",
        "        better_words = OldTexText(\"We can do\\\\\\\\better!\")\n",
        "        better_words.next_to(cross, DOWN)\n",
        "        better_words.set_color(RED)\n",
        "\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(\n",
        "            Write(better_words, run_time=1),\n",
        "            morty.change(\"pondering\", cross),\n",
        "        )\n",
        "        self.play(Blink(morty))\n",
        "        self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class EntropyToScoreData(Scene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = Axes(\n",
        "            (0, 13), (0, 6),\n",
        "            height=6,\n",
        "            width=10,\n",
        "        )\n",
        "        axes.x_axis.add_numbers()\n",
        "        axes.y_axis.add_numbers()\n",
        "        x_label = Text(\"Entropy\", font_size=24)\n",
        "        x_label.next_to(axes.x_axis, UR, SMALL_BUFF)\n",
        "        x_label.shift_onto_screen()\n",
        "        y_label = Text(\"Score\", font_size=24)\n",
        "        y_label.next_to(axes.y_axis, UR)\n",
        "        y_label.shift_onto_screen()\n",
        "        axes.add(x_label, y_label)\n",
        "        self.add(axes)\n",
        "        self.wait()\n",
        "        self.wait()\n",
        "\n",
        "        # Data\n",
        "        with open(ENT_SCORE_PAIRS_FILE) as fp:\n",
        "            data = np.array(json.load(fp))\n",
        "\n",
        "        dots = DotCloud([\n",
        "            axes.c2p(*pair)\n",
        "            for pair in data\n",
        "        ])\n",
        "        dots.set_radius(0.05)\n",
        "        dots.set_color(BLUE)\n",
        "        dots.set_opacity(0.02)\n",
        "\n",
        "        dots.add_updater(lambda m: m)\n",
        "        self.play(ShowCreation(dots, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Window\n",
        "        window = FullScreenRectangle().replicate(2)\n",
        "        window.arrange(RIGHT, buff=3 * dots.radius)\n",
        "        window.set_fill(BLACK, 0.7)\n",
        "\n",
        "        window.set_x(axes.c2p(8.65, 0)[0])\n",
        "        self.add(dots, window, axes)\n",
        "        self.wait()\n",
        "        for x in (0, 1, 2):\n",
        "            self.play(\n",
        "                window.animate.set_x(axes.c2p(x, 0)[0])\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.play(FadeOut(window))\n",
        "        self.wait()\n",
        "\n",
        "        # Buckets\n",
        "        bucket_size = 0.25\n",
        "        buckets = dict()\n",
        "        bucket_xs = np.arange(0, axes.x_range[1], bucket_size)\n",
        "        bars = VGroup()\n",
        "        for x in bucket_xs:\n",
        "            indices = (x < data[:, 0]) & (data[:, 0] <= x + bucket_size)\n",
        "            buckets[x] = data[indices, 1]\n",
        "            y = data[indices, 1].mean()\n",
        "            if not indices.any():\n",
        "                continue\n",
        "            bar = Rectangle(\n",
        "                width=axes.x_axis.unit_size * bucket_size,\n",
        "                height=axes.y_axis.unit_size * y\n",
        "            )\n",
        "            bar.set_stroke(WHITE, 1)\n",
        "            bar.move_to(axes.c2p(x, 0), DL)\n",
        "            bar.set_fill(TEAL, 0.5)\n",
        "            bars.add(bar)\n",
        "\n",
        "        self.play(FadeIn(bars, lag_ratio=0.1, run_time=2))\n",
        "        self.wait()\n",
        "        bars.save_state()\n",
        "        self.play(\n",
        "            bars[:4].animate.fade(0.7),\n",
        "            bars[5:].animate.fade(0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(bars))\n",
        "        self.play(\n",
        "            bars[:16].animate.fade(0.7),\n",
        "            bars[17:].animate.fade(0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Restore(bars))\n",
        "\n",
        "        # Model\n",
        "        curve = axes.get_graph(\n",
        "            lambda x: 1 + 0.56 * math.log(x + 1) + 0.08 * x,\n",
        "        )\n",
        "        curve.set_stroke(YELLOW, 2)\n",
        "        self.play(ShowCreation(curve, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LookTwoStepsAhead(WordleSceneWithAnalysis):\n",
        "    look_two_ahead = True\n",
        "    wordle_based_prior = True\n",
        "    pre_computed_first_guesses = [\n",
        "        \"slate\", \"salet\", \"slane\", \"reast\", \"trace\",\n",
        "        \"carse\", \"crate\", \"torse\", \"carle\", \"carte\",\n",
        "        \"toile\", \"crane\", \"least\", \"saint\", \"crine\",\n",
        "        \"roast\",\n",
        "    ]\n",
        "\n",
        "\n",
        "class HowLookTwoAheadWorks(Scene):\n",
        "    prob_color = BLUE_D\n",
        "    entropy_color = TEAL\n",
        "    first_guess = \"tares\"\n",
        "    n_shown_trials = 240\n",
        "    transition_time = 1\n",
        "\n",
        "    def get_priors(self):\n",
        "        return get_frequency_based_priors()\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        all_words = get_word_list()\n",
        "        possibilities = get_word_list()\n",
        "        priors = self.get_priors()\n",
        "\n",
        "        # Show first guess\n",
        "        guess1 = self.get_word_mob(self.first_guess)\n",
        "        guess1.to_edge(LEFT)\n",
        "        pattern_array1 = self.get_pattern_array(guess1, possibilities, priors)\n",
        "        prob_bars1 = self.get_prob_bars(pattern_array1.pattern_mobs)\n",
        "\n",
        "        self.add(guess1)\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                pattern_array1.connecting_lines,\n",
        "                lag_ratio=0.1\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, pattern_array1.pattern_mobs,\n",
        "                shift=0.2 * RIGHT,\n",
        "                lag_ratio=0.1,\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(Write(pattern_array1.dot_parts))\n",
        "        self.wait()\n",
        "        for bar in prob_bars1:\n",
        "            bar.save_state()\n",
        "            bar.stretch(0, 0, about_edge=LEFT)\n",
        "            bar.set_opacity(0)\n",
        "        self.play(LaggedStartMap(Restore, prob_bars1))\n",
        "        self.wait()\n",
        "\n",
        "        # Reminder on entropy\n",
        "        H_eq = OldTex(\n",
        "            \"E[I] = \\\\sum_{x} p(x) \\\\cdot \\\\log_2\\\\big((1 / p(x)\\\\big)\",\n",
        "            font_size=36\n",
        "        )\n",
        "        H_eq.next_to(prob_bars1, RIGHT)\n",
        "\n",
        "        info_labels = VGroup(*(\n",
        "            self.get_info_label(bar)\n",
        "            for bar in prob_bars1\n",
        "        ))\n",
        "\n",
        "        self.play(Write(H_eq))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(info_labels[0], lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, info_labels[1:], lag_ratio=0.5),\n",
        "            H_eq.animate.scale(0.7).to_edge(DOWN),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        H_label = self.get_entropy_label(guess1, pattern_array1.distribution)\n",
        "        self.play(FadeTransform(H_eq, H_label))\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(FadeOut, info_labels), run_time=1)\n",
        "\n",
        "        # Show example second guess\n",
        "        word_buckets = get_word_buckets(guess1.text, possibilities)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        second_guesses = VGroup()\n",
        "        second_ents = VGroup()\n",
        "        for i, bar in enumerate(prob_bars1):\n",
        "            pattern = pattern_array1.pattern_mobs[i].pattern\n",
        "            bucket = word_buckets[pattern]\n",
        "            optimal_word = optimal_guess(all_words, bucket, priors)\n",
        "            shown_words = random.sample(all_words, self.n_shown_trials)\n",
        "            shown_words.append(optimal_word)\n",
        "            for j, shown_word in enumerate(shown_words):\n",
        "                guess2 = self.get_word_mob(shown_word)\n",
        "                guess2.set_width(0.7)\n",
        "                guess2.match_y(bar)\n",
        "                guess2.set_x(0, LEFT)\n",
        "                arrow = Arrow(bar.label, guess2, stroke_width=3, buff=SMALL_BUFF)\n",
        "                pattern_array2 = self.get_pattern_array(guess2, bucket, priors, n_shown=25)\n",
        "                prob_bars2 = self.get_prob_bars(pattern_array2.pattern_mobs, width_scalar=5)\n",
        "                h2_label = self.get_entropy_label(guess2, pattern_array2.distribution)\n",
        "\n",
        "                group = VGroup(\n",
        "                    arrow, guess2, h2_label, pattern_array2, prob_bars2,\n",
        "                )\n",
        "                self.add(group, second_ents)\n",
        "                self.wait(1 / self.camera.frame_rate, ignore_presenter_mode=True)\n",
        "                if i in (0, 1) and j == 0:\n",
        "                    self.wait(self.transition_time)\n",
        "                self.remove(group)\n",
        "            self.add(*group, second_ents)\n",
        "            self.wait()\n",
        "\n",
        "            # Consolidate\n",
        "            arrow, guess2, h2_label, pattern_array2, prob_bars2 = group\n",
        "            for line in pattern_array2.connecting_lines:\n",
        "                line.reverse_points()\n",
        "            h2_label.generate_target()\n",
        "            h2_label.target.scale(0.8)\n",
        "            h2_label.target.next_to(guess2, RIGHT)\n",
        "            guess2.set_color(YELLOW)\n",
        "            self.add(pattern_array2.connecting_lines, second_ents)\n",
        "            self.play(\n",
        "                MoveToTarget(h2_label),\n",
        "                Uncreate(pattern_array2.connecting_lines, lag_ratio=0.01),\n",
        "                LaggedStartMap(FadeOut, pattern_array2.pattern_mobs),\n",
        "                LaggedStartMap(FadeOut, pattern_array2.dot_parts),\n",
        "                LaggedStartMap(FadeOut, prob_bars2, scale=0.25),\n",
        "                run_time=self.transition_time\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "            second_guesses.add(guess2)\n",
        "            second_ents.add(h2_label)\n",
        "\n",
        "        # Show weighted sum\n",
        "        brace = Brace(VGroup(second_ents, pattern_array1), RIGHT)\n",
        "        label = brace.get_text(\"Compute a\\nweighted average\", buff=MED_SMALL_BUFF)\n",
        "\n",
        "        sum_parts = VGroup()\n",
        "        for bar, h_label in zip(prob_bars1, second_ents):\n",
        "            d0 = DecimalNumber(bar.prob, num_decimal_places=3)\n",
        "            d1 = h_label[1].copy()\n",
        "            d0.match_height(d1)\n",
        "            group = VGroup(d0, OldTex(\"\\\\cdot\", font_size=24), d1)\n",
        "            group.generate_target()\n",
        "            group.target.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            group.target.next_to(brace, RIGHT)\n",
        "            group.target.match_y(bar)\n",
        "            sum_parts.add(group)\n",
        "            for part in group[:2]:\n",
        "                part.move_to(bar.label)\n",
        "                part.set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(label)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, sum_parts, run_time=2),\n",
        "            label.animate.scale(0.7).to_edge(DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_word_mob(self, word):\n",
        "        return Text(word, font=\"Consolas\", font_size=36)\n",
        "\n",
        "    def get_pattern_array(self, word, possibilities, priors, n_shown=15):\n",
        "        weights = get_weights(possibilities, priors)\n",
        "        dist = get_pattern_distributions([word.text], possibilities, weights)[0]\n",
        "        indices = np.argsort(dist)[::-1]\n",
        "        patterns = np.arange(3**5)[indices]\n",
        "        patterns = patterns[:n_shown]  # Only show non-zero possibilities\n",
        "\n",
        "        top_parts = VGroup(*(self.get_pattern_mob(p) for p in patterns[:n_shown]))\n",
        "        dot_parts = OldTex(\"\\\\vdots\\\\\\\\\", \"\\\\le 3^5 \\\\text{ patterns}\\\\\\\\\", \"\\\\vdots\")\n",
        "\n",
        "        for prob, row in zip(dist[indices][:n_shown], top_parts):\n",
        "            row.prob = prob\n",
        "\n",
        "        stack = VGroup(*top_parts, *dot_parts)\n",
        "        dot_parts.match_width(stack[0])\n",
        "        stack.arrange(DOWN, buff=SMALL_BUFF)\n",
        "        stack.set_max_height(FRAME_HEIGHT - 1)\n",
        "        stack.next_to(word, RIGHT, buff=1.5)\n",
        "        # stack.set_y(0)\n",
        "        stack.shift_onto_screen(buff=MED_LARGE_BUFF)\n",
        "\n",
        "        pattern_mobs = top_parts\n",
        "        connecting_lines = VGroup(*(\n",
        "            self.get_connecting_line(word, row)\n",
        "            for row in pattern_mobs\n",
        "        ))\n",
        "\n",
        "        result = VGroup(pattern_mobs, dot_parts, connecting_lines)\n",
        "        result.pattern_mobs = pattern_mobs\n",
        "        result.dot_parts = dot_parts\n",
        "        result.connecting_lines = connecting_lines\n",
        "        result.distribution = dist\n",
        "\n",
        "        return result\n",
        "\n",
        "    def get_pattern_mob(self, pattern, width=1.5):\n",
        "        result = Square().replicate(5)\n",
        "        result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        result.set_stroke(WHITE, width=0.5)\n",
        "        for square, n in zip(result, pattern_to_int_list(pattern)):\n",
        "            square.set_fill(WordleScene.color_map[n], 1)\n",
        "        result.set_width(width)\n",
        "        result.pattern = pattern\n",
        "        return result\n",
        "\n",
        "    def get_connecting_line(self, mob1, mob2):\n",
        "        diff = mob2.get_left()[0] - mob1.get_right()[0]\n",
        "        return CubicBezier(\n",
        "            mob1.get_right() + SMALL_BUFF * RIGHT,\n",
        "            mob1.get_right() + RIGHT * diff / 2,\n",
        "            mob2.get_left() + LEFT * diff / 2,\n",
        "            mob2.get_left() + SMALL_BUFF * LEFT,\n",
        "            stroke_color=WHITE,\n",
        "            stroke_width=1,\n",
        "        )\n",
        "\n",
        "    def get_prob_bars(self, pattern_mobs, width_scalar=10):\n",
        "        result = VGroup()\n",
        "        for pattern_mob in pattern_mobs:\n",
        "            bar = Rectangle(\n",
        "                width=width_scalar * pattern_mob.prob,\n",
        "                height=pattern_mob.get_height(),\n",
        "                fill_color=self.prob_color,\n",
        "                fill_opacity=1,\n",
        "                stroke_width=0.5,\n",
        "                stroke_color=WHITE,\n",
        "            )\n",
        "            bar.next_to(pattern_mob, RIGHT, buff=SMALL_BUFF)\n",
        "            label = DecimalNumber(100 * pattern_mob.prob, num_decimal_places=1, unit=\"\\\\%\")\n",
        "            # label = DecimalNumber(pattern_mob.prob, num_decimal_places=3)\n",
        "            label.set_height(bar.get_height() * 0.6)\n",
        "            label.next_to(bar, RIGHT, SMALL_BUFF)\n",
        "            bar.label = label\n",
        "            bar.add(label)\n",
        "            bar.prob = pattern_mob.prob\n",
        "            result.add(bar)\n",
        "        return result\n",
        "\n",
        "    def get_entropy_label(self, word_mob, distribution):\n",
        "        ent2 = entropy_of_distributions(distribution)\n",
        "        kw = dict(font_size=24)\n",
        "        h_label = VGroup(OldTex(f\"E[I] = \", **kw), DecimalNumber(ent2, **kw))\n",
        "        h_label.set_color(self.entropy_color)\n",
        "        h_label.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=UP)\n",
        "        h_label.move_to(word_mob)\n",
        "        h_label.shift(0.5 * DOWN)\n",
        "        h_label.set_backstroke(width=8)\n",
        "        return h_label\n",
        "\n",
        "    def get_info_label(self, bar):\n",
        "        result = VGroup(\n",
        "            # DecimalNumber(bar.prob, num_decimal_places=3),\n",
        "            OldTex(\"\\\\log_2\\\\big( 1 / \"),\n",
        "            DecimalNumber(bar.prob, num_decimal_places=3),\n",
        "            OldTex(\"\\\\big) = \"),\n",
        "            # DecimalNumber(-bar.prob * math.log2(bar.prob), num_decimal_places=3)\n",
        "            DecimalNumber(-math.log2(bar.prob), num_decimal_places=3)\n",
        "        )\n",
        "        result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        result.set_height(bar.get_height())\n",
        "        result.match_y(bar)\n",
        "        result.set_x(0, LEFT)\n",
        "        arrow = Arrow(bar.label.get_right(), result, stroke_width=2, buff=SMALL_BUFF)\n",
        "        result.add_to_back(arrow)\n",
        "        return result\n",
        "\n",
        "\n",
        "class BestDoubleEntropies(Scene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "        # Facts on theoretical possibilities:\n",
        "        # Best two-step entropy is slane: 5.7702 + 4.2435 = 10.014\n",
        "        # Given the start, with log2(2315) = 11.177 bits of entropy,\n",
        "        # this means an average uncertainty after two guesses of 1.163.\n",
        "        # This is akin to being down to 2.239 words\n",
        "        # In that case, there's a 1/2.239 = 0.4466 chance of getting it in 3\n",
        "        # Otherwise, 0.5534 chance of requiring at least 4\n",
        "        #\n",
        "        # Assuming best case scenarios, that out of the 2315 answers, you get:\n",
        "        # - 1 in 1\n",
        "        # - 273 in 2 with your encoded second guesses\n",
        "        # - Of the remaining 2041, you get 0.4466 * 2041 = 912 in 3\n",
        "        # - Of the remaining 1,129, all are in 4\n",
        "        # Average: (1 + 2 * 273 + 3 * 912 + 4 * 1129) / 2315 = 3.368\n",
        "        #\n",
        "        # But actually, number of 2's is (at most) 150, so we could update to:\n",
        "        # Average: (1 + 2 * 150 + 3 * 967 + 4 * 1197) / 2315 = 3.451\n",
        "        # More general formula\n",
        "        # p3 = 1 / 2**(np.log2(2315) - 10.014)\n",
        "        # (1 + 2 * n + 3 * p3 * (2315 - n - 1) + 4 * (1 - p3) * (2315 - n - 1)) / 2315\n",
        "        #\n",
        "        # Analyzing crane games, it looks like indeed, the average uncertainty\n",
        "        # at the third step is 1.2229, just slightly higher than the 1.163 above.\n",
        "        # In fact, for 'crane' the average shoudl be 11.177 - 9.9685 = 1.208\n",
        "        #\n",
        "        # game_data = json.load(open(\"/Users/grant/Dropbox/3Blue1Brown/data/wordle/crane_with_wordle_prior.json\"))\n",
        "        # games = game_data[\"game_results\"]\n",
        "        # reductions = [g['reductions'] for g in games]\n",
        "        # step3_state = [red[1] if len(red) > 1 else 1 for red in reductions]\n",
        "        # step3_bits = [math.log2(x) for x in step3_state]\n",
        "        # np.mean(step3_bits)\n",
        "        # Out: 1.2229\n",
        "\n",
        "\n",
        "class TripleComparisonFrame(Scene):\n",
        "    def construct(self):\n",
        "        self.add(FullScreenRectangle())\n",
        "        squares = Square().replicate(3)\n",
        "        squares.stretch(0.9, 0)\n",
        "        squares.arrange(RIGHT, buff=0.1)\n",
        "        squares.set_width(FRAME_WIDTH - 0.5)\n",
        "        squares.set_stroke(WHITE, 2)\n",
        "        squares.set_fill(BLACK, 1)\n",
        "        squares.to_edge(DOWN, buff=1.5)\n",
        "        self.add(squares)\n",
        "\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"V1: Just maximize\\\\\\\\entropy\"),\n",
        "            OldTexText(\"V2: Incorporate word\\\\\\\\frequency data\"),\n",
        "            OldTexText(\"V3: Use true wordle list\\\\\\\\(plus 1 or 2 other tricks)\"),\n",
        "        )\n",
        "        titles.scale(0.75)\n",
        "        for title, square in zip(titles, squares):\n",
        "            title.next_to(square, UP)\n",
        "\n",
        "        self.add(titles)\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class InformationLimit(WordleScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        grid = self.grid\n",
        "        grid.set_height(4)\n",
        "\n",
        "        title = Text(\"Is there a fundamental limit?\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        line.set_width(12)\n",
        "        line.set_stroke(WHITE, 1)\n",
        "        line.next_to(title, DOWN, buff=SMALL_BUFF)\n",
        "        self.add(title, line)\n",
        "\n",
        "        # Show wordle list\n",
        "        kw = dict(font_size=36)\n",
        "        left_title = Text(\"2,315 words, equally likely\", **kw)\n",
        "        left_title.next_to(line, DOWN, buff=0.75)\n",
        "        left_title.to_edge(LEFT)\n",
        "        words = get_word_list(short=True)\n",
        "        word_mobs = self.get_grid_of_words(words, 18, 1, dots_index=-7)\n",
        "        word_mobs.set_height(5.5)\n",
        "        word_mobs.next_to(left_title, DOWN, aligned_edge=LEFT)\n",
        "        brace = Brace(word_mobs, RIGHT)\n",
        "        brace_label = VGroup(\n",
        "            OldTex(\"\\\\log_2(2{,}315)\", \"=\", \"11.17 \\\\text{ bits}\", **kw),\n",
        "            Text(\"of uncertainty\", **kw)\n",
        "        )\n",
        "        brace_label[0][1].rotate(PI / 2)\n",
        "        brace_label[0].arrange(DOWN, buff=MED_SMALL_BUFF)\n",
        "        brace_label.arrange(DOWN, aligned_edge=LEFT)\n",
        "        brace_label.set_color(TEAL)\n",
        "        brace_label[0][:2].set_color(WHITE)\n",
        "        brace_label.next_to(brace, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        group = VGroup(word_mobs, left_title, brace_label)\n",
        "        grid.next_to(group, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(left_title),\n",
        "            FadeIn(word_mobs, lag_ratio=0.1, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(brace_label, 0.25 * RIGHT)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Brute for search\n",
        "        all_words = get_word_list()\n",
        "        sample = random.sample(all_words, 180)\n",
        "        for word in sorted(sample):\n",
        "            self.add_word(word, wait_time_per_letter=0)\n",
        "            self.reveal_pattern(animate=False)\n",
        "            self.add_word(random.choice(all_words), wait_time_per_letter=0)\n",
        "            self.reveal_pattern(animate=False)\n",
        "            self.wait(1 / 30)\n",
        "            grid.words.set_submobjects([])\n",
        "            grid.pending_word.set_submobjects([])\n",
        "            grid.set_fill(BLACK, 0)\n",
        "        self.add_word(\"slane\", wait_time_per_letter=0)\n",
        "\n",
        "        # Two step entropy\n",
        "        s_title = OldTexText(\n",
        "            \"Maximum expected information\\\\\\\\\",\n",
        "            \"after first two guesses:\",\n",
        "            **kw\n",
        "        )\n",
        "        s_title.match_y(left_title)\n",
        "        s_title.to_edge(RIGHT)\n",
        "\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(\n",
        "                grid[i].get_right(),\n",
        "                grid[i + 1].get_right(),\n",
        "                buff=0,\n",
        "                path_arc=-(PI + 0.1),\n",
        "                width_to_tip_len=0.005\n",
        "            )\n",
        "            for i in (0, 1)\n",
        "        ))\n",
        "        for arrow in arrows:\n",
        "            arrow.shift(0.1 * RIGHT)\n",
        "        arrows.space_out_submobjects(1.2)\n",
        "\n",
        "        EI_labels = VGroup(\n",
        "            OldTex(\"E[I_1] = 5.77\", **kw),\n",
        "            OldTex(\"E[I_2] = 4.24\", **kw),\n",
        "        )\n",
        "        EI_labels.set_color(BLUE)\n",
        "        for label, arrow in zip(EI_labels, arrows):\n",
        "            label.next_to(arrow, RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        EI2_arrow = Vector(DR)\n",
        "        EI2_arrow.next_to(EI_labels[1].get_bottom(), DR, buff=SMALL_BUFF)\n",
        "\n",
        "        total_brace = Brace(EI_labels, RIGHT)\n",
        "        total_label = OldTexText(\"10.01 bits\", **kw)\n",
        "        total_label.set_color(BLUE)\n",
        "        total_label.next_to(total_brace, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Write(s_title),\n",
        "            ShowCreation(arrows),\n",
        "        )\n",
        "        self.play(LaggedStart(*(\n",
        "            FadeIn(EI_label, 0.25 * RIGHT)\n",
        "            for EI_label in EI_labels\n",
        "        )), lag_ratio=0.5)\n",
        "        self.play(\n",
        "            GrowFromCenter(total_brace),\n",
        "            FadeIn(total_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(EI2_arrow))\n",
        "        self.play(FadeOut(EI2_arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight third spot\n",
        "        row3 = grid[2].copy()\n",
        "        row3.set_stroke(RED, 3)\n",
        "\n",
        "        self.play(\n",
        "            grid.animate.fade(0.75),\n",
        "            FadeIn(row3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Best case words\n",
        "        best_case_words = Text(\n",
        "            \"Best case scenario:\\n\"\n",
        "            \"Down to ~1.16 bits of\\n\"\n",
        "            \"uncertainty, on average\",\n",
        "            **kw\n",
        "        )\n",
        "        best_case_words.get_part_by_text(\"~\").match_y(\n",
        "            best_case_words.get_part_by_text(\"1.16\")\n",
        "        )\n",
        "        best_case_words.next_to(grid[2], DR, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(best_case_words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"scroll_time\": 30,\n",
        "    }\n",
        "\n",
        "\n",
        "# Distribution animations\n",
        "\n",
        "class ShowScoreDistribution(Scene):\n",
        "    data_file = \"crane_with_wordle_prior.json\"\n",
        "    axes_config = dict(\n",
        "        x_range=(0, 9),\n",
        "        y_range=(0, 1, 0.1),\n",
        "        width=8,\n",
        "        height=6,\n",
        "    )\n",
        "    weighted_sample = False\n",
        "    bar_count_font_size = 30\n",
        "\n",
        "    def construct(self):\n",
        "        axes = self.get_axes()\n",
        "        self.add(axes)\n",
        "\n",
        "        with open(os.path.join(DATA_DIR, \"simulation_results\", self.data_file)) as fp:\n",
        "            game_data = json.load(fp)\n",
        "        games = game_data[\"game_results\"]\n",
        "        scores = [game[\"score\"] for game in games]\n",
        "\n",
        "        bars = self.get_bars(axes, scores[:0])\n",
        "\n",
        "        mean_label = VGroup(\n",
        "            Text(\"Average score: \"),\n",
        "            DecimalNumber(np.mean(scores), num_decimal_places=3)\n",
        "        )\n",
        "        mean_label.arrange(RIGHT, aligned_edge=UP)\n",
        "        mean_label.move_to(axes, UP)\n",
        "        self.add(mean_label)\n",
        "\n",
        "        grid = WordleScene.patterns_to_squares(6 * [0])\n",
        "        grid.set_fill(BLACK, 0)\n",
        "        grid.set_width(axes.get_width() / 4)\n",
        "        grid.move_to(axes, RIGHT)\n",
        "        grid.shift(0.5 * DOWN)\n",
        "        grid.words = VGroup()\n",
        "        grid.add(grid.words)\n",
        "        self.add(grid)\n",
        "\n",
        "        score_label = VGroup(\n",
        "            Text(\"Score: \"),\n",
        "            Integer(0, edge_to_fix=LEFT),\n",
        "        )\n",
        "        score_label.scale(0.75)\n",
        "        score_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        score_label.next_to(grid, UP, aligned_edge=LEFT)\n",
        "        self.add(score_label)\n",
        "\n",
        "        answer_label = VGroup(\n",
        "            Text(\"Answer: \"),\n",
        "            Text(games[0][\"answer\"], font=\"Consolas\")\n",
        "        )\n",
        "        answer_label.match_height(score_label)\n",
        "        answer_label.arrange(RIGHT)\n",
        "        answer_label.next_to(score_label, UP, aligned_edge=LEFT)\n",
        "        self.add(answer_label)\n",
        "\n",
        "        def a2n(alpha):\n",
        "            return integer_interpolate(0, len(scores), alpha)[0]\n",
        "\n",
        "        def update_bars(bars, alpha):\n",
        "            bars.set_submobjects(self.get_bars(axes, scores[:a2n(alpha) + 1]))\n",
        "\n",
        "        def update_mean_label(label, alpha):\n",
        "            label[1].set_value(np.mean(scores[:a2n(alpha) + 1]))\n",
        "\n",
        "        def update_grid(grid, alpha):\n",
        "            game = games[a2n(alpha)]\n",
        "            patterns = game[\"patterns\"]\n",
        "            patterns.append(3**5 - 1)\n",
        "            grid.set_fill(BLACK, 0)\n",
        "            for pattern, row in zip(patterns, grid):\n",
        "                for square, key in zip(row, pattern_to_int_list(pattern)):\n",
        "                    square.set_fill(WordleScene.color_map[key], 1)\n",
        "            try:\n",
        "                grid.words.set_submobjects([\n",
        "                    Text(guess.upper(), font=\"Consolas\")\n",
        "                    for guess in (*game[\"guesses\"], game[\"answer\"])\n",
        "                ])\n",
        "            except Exception:\n",
        "                return\n",
        "            for word, row in zip(grid.words, grid):\n",
        "                word.set_height(row.get_height() * 0.6)\n",
        "                for char, square in zip(word, row):\n",
        "                    char.move_to(square)\n",
        "\n",
        "        def update_score_label(score_label, alpha):\n",
        "            score = games[a2n(alpha)][\"score\"]\n",
        "            score_label[1].set_value(score)\n",
        "\n",
        "        def update_answer_label(answer_label, alpha):\n",
        "            answer = games[a2n(alpha)][\"answer\"]\n",
        "            new_text = Text(answer, font=\"Consolas\")\n",
        "            new_text.scale(0.75)\n",
        "            new_text.move_to(answer_label[1], LEFT)\n",
        "            low_y = new_text[np.argmin([c.get_height() for c in new_text])].get_bottom()[1]\n",
        "            new_text.shift((answer_label[0].get_bottom()[1] - low_y) * UP)\n",
        "            answer_label.replace_submobject(1, new_text)\n",
        "            return answer_label\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(bars, update_bars),\n",
        "            UpdateFromAlphaFunc(mean_label, update_mean_label),\n",
        "            UpdateFromAlphaFunc(grid, update_grid),\n",
        "            UpdateFromAlphaFunc(score_label, update_score_label),\n",
        "            UpdateFromAlphaFunc(answer_label, update_answer_label),\n",
        "            run_time=20,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        update_bars(bars, 1)\n",
        "        self.wait()\n",
        "        self.remove(grid, score_label, answer_label)\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = Axes(**self.axes_config)\n",
        "        x_axis, y_axis = axes.x_axis, axes.y_axis\n",
        "        y_axis.add_numbers(num_decimal_places=1)\n",
        "        x_axis.add_numbers()\n",
        "        x_axis.numbers.shift(x_axis.unit_size * LEFT / 2)\n",
        "        x_label = Text(\"Score\", font_size=24)\n",
        "        x_label.next_to(x_axis.get_end(), RIGHT)\n",
        "        x_axis.add(x_label)\n",
        "        return axes\n",
        "\n",
        "    def get_bars(self, axes, scores):\n",
        "        scores = np.array(scores)\n",
        "        buckets = np.array([\n",
        "            (scores == n + 1).sum()\n",
        "            for n in np.arange(*axes.x_range)\n",
        "        ])\n",
        "        props = buckets / buckets.sum()\n",
        "        bars = VGroup(*(\n",
        "            self.get_bar(axes, n + 1, prop)\n",
        "            for n, prop in enumerate(props)\n",
        "        ))\n",
        "        colors = color_gradient([BLUE, YELLOW, RED], 8)\n",
        "        for bar, color in zip(bars, colors):\n",
        "            bar.set_fill(color, 1)\n",
        "        bars.set_stroke(WHITE, 1)\n",
        "        for bar, count in zip(bars, buckets):\n",
        "            bar.add(self.get_bar_count(bar, count))\n",
        "        return VGroup(bars)\n",
        "\n",
        "    def get_bar(self, axes, score, proportion):\n",
        "        bar = Rectangle(\n",
        "            width=axes.x_axis.unit_size,\n",
        "            height=axes.y_axis.unit_size * proportion,\n",
        "        )\n",
        "        bar.set_fill(BLUE, 1)\n",
        "        bar.set_stroke(WHITE, 1)\n",
        "        bar.move_to(axes.c2p(score, 0), DR)\n",
        "        return bar\n",
        "\n",
        "    def get_bar_count(self, bar, count):\n",
        "        result = Integer(count, font_size=self.bar_count_font_size)\n",
        "        result.set_max_width(bar.get_width() * 0.8)\n",
        "        result.next_to(bar, UP, SMALL_BUFF)\n",
        "        if count == 0:\n",
        "            result.set_opacity(0)\n",
        "        return result\n",
        "\n",
        "\n",
        "class SimulatedGamesUniformPriorDist(ShowScoreDistribution):\n",
        "    data_file = \"tares_with_uniform_prior.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesFreqBasedPriorDist(ShowScoreDistribution):\n",
        "    data_file = \"tares_with_freq_prior.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesWordleBasedPriorDist(ShowScoreDistribution):\n",
        "    data_file = \"soare_with_wordle_prior.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesWordleBasedPriorCraneStartDist(ShowScoreDistribution):\n",
        "    data_file = \"crane_with_wordle_prior.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesCraneHardModeDist(ShowScoreDistribution):\n",
        "    data_file = \"crane_hard_mode.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesWordleBasedPriorExcludeSeenWordsDist(ShowScoreDistribution):\n",
        "    data_file = \"crane_with_wordle_prior_exclude_seen.json\"\n",
        "\n",
        "\n",
        "class SimulatedGamesFreqBasedPriorExcludeSeenWordsDist(ShowScoreDistribution):\n",
        "    data_file = \"tares_with_freq_prior_exclude_seen.json\"\n",
        "\n",
        "\n",
        "class ThinV1Stats(SimulatedGamesUniformPriorDist):\n",
        "    axes_config = dict(\n",
        "        x_range=(0, 8),\n",
        "        y_range=(0, 1, 0.1),\n",
        "        width=5,\n",
        "        height=6,\n",
        "    )\n",
        "    bar_count_font_size = 24\n",
        "\n",
        "\n",
        "class ThinV2Stats(SimulatedGamesFreqBasedPriorDist):\n",
        "    axes_config = ThinV1Stats.axes_config\n",
        "    bar_count_font_size = 24\n",
        "\n",
        "\n",
        "class ThinV3Stats(SimulatedGamesWordleBasedPriorCraneStartDist):\n",
        "    axes_config = ThinV1Stats.axes_config\n",
        "    bar_count_font_size = 24\n",
        "\n",
        "\n",
        "class GenericWrapper(VideoWrapper):\n",
        "    pass\n",
        "\n",
        "\n",
        "# Thumbnail\n",
        "\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        # Grid\n",
        "        answer = \"aging\"\n",
        "        guesses = [\"crane\", \"tousy\", answer]\n",
        "        patterns = [get_pattern(guess, answer) for guess in guesses]\n",
        "\n",
        "        rows = WordleScene.patterns_to_squares(\n",
        "            patterns, color_map=[GREY_D, YELLOW, GREEN_E]\n",
        "        )\n",
        "        rows.set_stroke(width=0)\n",
        "        rows.set_width(0.5 * FRAME_WIDTH)\n",
        "        rows.to_edge(DOWN, buff=1.0)\n",
        "        rows.set_gloss(0.4)\n",
        "        self.add(rows)\n",
        "\n",
        "        # Words in grid (probbaly don't include)\n",
        "        words = VGroup()\n",
        "        for guess, row in zip(guesses, rows):\n",
        "            word = Text(guess.upper(), font=\"Consolas\")\n",
        "            word.set_height(0.6 * row.get_height())\n",
        "            for char, square in zip(word, row):\n",
        "                char.move_to(square)\n",
        "            words.add(word)\n",
        "        # self.add(words)\n",
        "\n",
        "        # Title\n",
        "        title = Text(\n",
        "            \"Best opener: CRANE\",\n",
        "            font_size=100,\n",
        "            font=\"Consolas\",\n",
        "            t2c={\"crane\": GREEN}\n",
        "        )\n",
        "        title.to_edge(UP, buff=0.75)\n",
        "        self.add(title)\n",
        "\n",
        "        self.rows = rows\n",
        "        self.title = title\n"
    ]
}