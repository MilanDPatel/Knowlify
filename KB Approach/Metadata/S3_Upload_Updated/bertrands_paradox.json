{
    "topic": "demonstrates the concept of a fraction.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class RandomChordScene(Scene):\n",
        "    title = \"\"\n",
        "    radius = 3.5\n",
        "    n_samples = 1000\n",
        "    long_color = BLUE\n",
        "    short_color = WHITE\n",
        "    chord_width = 0.5\n",
        "    chord_opacity = 0.35\n",
        "    run_time = 20\n",
        "    include_triangle = True\n",
        "\n",
        "    def construct(self):\n",
        "        circle = self.circle = Circle(radius=self.radius)\n",
        "        circle.set_stroke(GREY_B, 3)\n",
        "        circle.to_edge(LEFT)\n",
        "\n",
        "        chords = self.get_chords(circle)\n",
        "        flash_chords = chords.copy()\n",
        "        flash_chords.set_stroke(width=3, opacity=1)\n",
        "        indicators = Group(*map(self.get_method_indicator, chords))\n",
        "\n",
        "        title = Text(self.title)\n",
        "        title.set_x(FRAME_WIDTH / 4).to_edge(UP)\n",
        "\n",
        "        triangle = self.get_triangle(circle)\n",
        "\n",
        "        if not self.include_triangle:\n",
        "            triangle.set_opacity(0)\n",
        "\n",
        "        self.add(circle, title, triangle)\n",
        "\n",
        "        for s, rt in (slice(0, 16), 8), (slice(18, None), self.run_time):\n",
        "            fraction = self.get_fraction([c.long for c in chords[s]])\n",
        "            fraction.match_x(title)\n",
        "            fraction.match_y(circle)\n",
        "            self.add(fraction)\n",
        "            self.remove(triangle)\n",
        "            self.play(\n",
        "                ShowIncreasingSubsets(chords[s]),\n",
        "                ShowSubmobjectsOneByOne(flash_chords[s]),\n",
        "                ShowSubmobjectsOneByOne(indicators[s]),\n",
        "                Animation(triangle),\n",
        "                fraction.alpha_update,\n",
        "                rate_func=linear,\n",
        "                run_time=rt,\n",
        "            )\n",
        "            self.remove(flash_chords)\n",
        "            self.remove(indicators)\n",
        "            self.remove(fraction)\n",
        "        self.add(fraction)\n",
        "        self.wait()\n",
        "\n",
        "    def get_fraction(self, data):\n",
        "        tex = OldTex(\n",
        "            \"{100\", \"\\\\over \", \"100\", \"+\", \"100}\", \"= \", \"0.500\"\n",
        "        )\n",
        "        nl1 = Integer(100, edge_to_fix=ORIGIN)  # Number of long chords\n",
        "        nl2 = Integer(100, edge_to_fix=RIGHT)\n",
        "        ns = Integer(100, edge_to_fix=LEFT)  # Number of short chords\n",
        "        ratio = DecimalNumber(0, num_decimal_places=4)\n",
        "        fraction = VGroup(\n",
        "            nl1.move_to(tex[0]),\n",
        "            tex[1],\n",
        "            nl2.move_to(tex[2]),\n",
        "            tex[3],\n",
        "            ns.move_to(tex[4]),\n",
        "            tex[5],\n",
        "            ratio.move_to(tex[6], LEFT),\n",
        "        )\n",
        "\n",
        "        def update_fraction(frac, alpha):\n",
        "            subdata = data[:int(np.floor(alpha * len(data)))]\n",
        "            n_long = sum(subdata)\n",
        "            n_short = len(subdata) - n_long\n",
        "            frac[0].set_value(n_long)\n",
        "            frac[0].set_color(self.long_color)\n",
        "            frac[2].set_value(n_long)\n",
        "            frac[2].set_color(self.long_color)\n",
        "            frac[4].set_value(n_short)\n",
        "            frac[4].set_color(self.short_color)\n",
        "\n",
        "            if len(subdata) == 0:\n",
        "                frac[-2:].set_opacity(0)\n",
        "            else:\n",
        "                frac[-2:].set_opacity(1)\n",
        "                frac[6].set_value(n_long / len(subdata))\n",
        "            return frac\n",
        "\n",
        "        fraction.alpha_update = UpdateFromAlphaFunc(\n",
        "            fraction, update_fraction\n",
        "        )\n",
        "        return fraction\n",
        "\n",
        "    def get_chords(self, circle, chord_generator=None):\n",
        "        if chord_generator is None:\n",
        "            chord_generator = self.get_random_chord\n",
        "        tri_len = np.sqrt(3) * circle.get_width() / 2\n",
        "        chords = VGroup(*(\n",
        "            chord_generator(circle)\n",
        "            for x in range(self.n_samples)\n",
        "        ))\n",
        "        for chord in chords:\n",
        "            chord.long = (chord.get_length() > tri_len)\n",
        "            chord.set_color(\n",
        "                self.long_color if chord.long else self.short_color\n",
        "            )\n",
        "        chords.set_stroke(\n",
        "            width=self.chord_width,\n",
        "            opacity=self.chord_opacity\n",
        "        )\n",
        "        return chords\n",
        "\n",
        "    def get_triangle(self, circle):\n",
        "        verts = [circle.pfp(a) for a in np.arange(0, 1, 1 / 3)]\n",
        "        triangle = Polygon(*verts)\n",
        "        triangle.rotate(-PI / 6, about_point=circle.get_center())\n",
        "        triangle.set_stroke(RED, 2, 1)\n",
        "        return triangle\n",
        "\n",
        "    def get_random_chord(self, circle):\n",
        "        return NotImplemented\n",
        "\n",
        "    def get_method_indicator(self, chord):\n",
        "        return NotImplemented\n",
        "\n",
        "\n",
        "class PairOfPoints(RandomChordScene):\n",
        "    title = \"Random pair of circle points\"\n",
        "\n",
        "    @staticmethod\n",
        "    def get_random_chord(circle):\n",
        "        return Line(\n",
        "            circle.pfp(random.random()),\n",
        "            circle.pfp(random.random()),\n",
        "        )\n",
        "\n",
        "    @staticmethod\n",
        "    def get_method_indicator(chord):\n",
        "        dots = DotCloud([\n",
        "            chord.get_start(),\n",
        "            chord.get_end(),\n",
        "        ])\n",
        "        dots.set_glow_factor(2)\n",
        "        dots.set_radius(0.25)\n",
        "        dots.set_color(YELLOW)\n",
        "        return dots\n",
        "\n",
        "\n",
        "class CenterPoint(RandomChordScene):\n",
        "    title = \"Random point in circle\"\n",
        "\n",
        "    @staticmethod\n",
        "    def get_random_chord(circle):\n",
        "        x = y = 1\n",
        "        while x * x + y * y > 1:\n",
        "            x = random.uniform(-1, 1)\n",
        "            y = random.uniform(-1, 1)\n",
        "        return CenterPoint.chord_from_xy(x, y, circle)\n",
        "\n",
        "    @staticmethod\n",
        "    def chord_from_xy(x, y, circle):\n",
        "        n2 = x * x + y * y\n",
        "        temp_x = math.sqrt(n2)\n",
        "        temp_y = math.sqrt(1 - n2)\n",
        "        line = Line(\n",
        "            [temp_x, -temp_y, 0],\n",
        "            [temp_x, temp_y, 0],\n",
        "        )\n",
        "        line.rotate(angle_of_vector([x, y, 0]), about_point=ORIGIN)\n",
        "        line.scale(circle.get_width() / 2, about_point=ORIGIN)\n",
        "        line.shift(circle.get_center())\n",
        "        return line\n",
        "\n",
        "    @staticmethod\n",
        "    def get_method_indicator(chord):\n",
        "        dots = DotCloud([chord.get_center()])\n",
        "        dots.set_glow_factor(2)\n",
        "        dots.set_radius(0.25)\n",
        "        dots.set_color(YELLOW)\n",
        "        return dots\n",
        "\n",
        "\n",
        "class RadialPoint(CenterPoint):\n",
        "    title = \"Random point along radial line\"\n",
        "\n",
        "    @staticmethod\n",
        "    def get_random_chord(circle):\n",
        "        angle = random.uniform(0, TAU)\n",
        "        dist = random.uniform(0, 1)\n",
        "        return CenterPoint.chord_from_xy(\n",
        "            dist * math.cos(angle),\n",
        "            dist * math.sin(angle),\n",
        "            circle\n",
        "        )\n",
        "\n",
        "    @staticmethod\n",
        "    def get_method_indicator(chord):\n",
        "        dot = super().get_method_indicator(chord)\n",
        "        line = Line(self.circle.get_center(), dot.get_center())\n",
        "        line.set_length(self.radius, about_point=line.get_start())\n",
        "        line.set_stroke(YELLOW, 1)\n",
        "        return Group(dot, line)\n",
        "\n",
        "\n",
        "class CompareFirstTwoMethods(RandomChordScene):\n",
        "    chord_width = 0.1\n",
        "    chord_opacity = 0.8\n",
        "\n",
        "    def construct(self):\n",
        "        circles = Circle().get_grid(1, 2, buff=1)\n",
        "        circles.set_height(5)\n",
        "        circles.to_edge(DOWN, buff=LARGE_BUFF)\n",
        "        circles.set_stroke(GREY_B, 3)\n",
        "\n",
        "        titles = VGroup(\n",
        "            Text(\"Choose a pair of points\"),\n",
        "            Text(\"Chose a center point\"),\n",
        "        )\n",
        "        for title, circle in zip(titles, circles):\n",
        "            title.next_to(circle, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        chord_groups = VGroup(\n",
        "            self.get_chords(circles[0], PairOfPoints.get_random_chord),\n",
        "            self.get_chords(circles[1], CenterPoint.get_random_chord),\n",
        "        )\n",
        "        flash_chord_groups = chord_groups.copy()\n",
        "        flash_chord_groups.set_stroke(width=3, opacity=1)\n",
        "        indicator_groups = Group(\n",
        "            Group(*(PairOfPoints.get_method_indicator(c) for c in chord_groups[0])),\n",
        "            Group(*(CenterPoint.get_method_indicator(c) for c in chord_groups[1])),\n",
        "        )\n",
        "\n",
        "        self.add(circles, titles)\n",
        "\n",
        "        self.play(\n",
        "            *map(ShowIncreasingSubsets, chord_groups),\n",
        "            *map(ShowSubmobjectsOneByOne, flash_chord_groups),\n",
        "            *map(ShowSubmobjectsOneByOne, indicator_groups),\n",
        "            rate_func=linear,\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.play(\n",
        "            *map(FadeOut, (\n",
        "                flash_chord_groups[0][-1],\n",
        "                flash_chord_groups[1][-1],\n",
        "                indicator_groups[0][-1],\n",
        "                indicator_groups[1][-1],\n",
        "            )),\n",
        "        )\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SparseWords(Scene):\n",
        "    def construct(self):\n",
        "        words = Text(\"Sparser in the middle\")\n",
        "        words.to_edge(DOWN, buff=MED_LARGE_BUFF)\n",
        "        arrow = Arrow(\n",
        "            words.get_top(),\n",
        "            [3.5, -0.5, 0],\n",
        "        )\n",
        "        arrow.set_color(YELLOW)\n",
        "        words.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(words, run_time=1),\n",
        "            ShowCreation(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PortionOfRadialLineInTriangle(Scene):\n",
        "    def construct(self):\n",
        "        # Circle and triangle\n",
        "        circle = Circle(radius=3.5)\n",
        "        circle.set_stroke(GREY_B, 4)\n",
        "        circle.rotate(-PI / 6)\n",
        "        triangle = Polygon(*(\n",
        "            circle.pfp(a) for a in np.arange(0, 1, 1 / 3)\n",
        "        ))\n",
        "        triangle.set_stroke(GREEN, 2)\n",
        "        center_dot = Dot(circle.get_center().copy(), radius=0.04)\n",
        "        center_dot.set_fill(GREY_C, 1)\n",
        "\n",
        "        self.add(circle, center_dot, triangle)\n",
        "\n",
        "        # Radial line\n",
        "        radial_line = Line(circle.get_center().copy(), circle.pfp(1 / 6))\n",
        "        radial_line.set_stroke(WHITE, 2)\n",
        "        elbow = Elbow()\n",
        "        elbow.rotate(PI + radial_line.get_angle(), about_point=ORIGIN)\n",
        "        elbow.shift(radial_line.pfp(0.5) - ORIGIN)\n",
        "        elbow.match_style(radial_line)\n",
        "        half_line = radial_line.copy()\n",
        "        half_line.pointwise_become_partial(radial_line, 0, 0.5)\n",
        "        half_line.set_stroke(RED, 2)\n",
        "        half_label = OldTex(\"\\\\frac{1}{2}\", font_size=30)\n",
        "        half_label.next_to(half_line.get_center(), DR, SMALL_BUFF)\n",
        "        half_label.set_color(RED)\n",
        "\n",
        "        self.play(ShowCreation(radial_line))\n",
        "        self.play(ShowCreation(elbow))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(half_line),\n",
        "            FadeIn(half_label, 0.2 * DOWN),\n",
        "        )\n",
        "\n",
        "        # Show sample chords along line\n",
        "        dot = TrueDot()\n",
        "        dot.set_glow_factor(5)\n",
        "        dot.set_radius(0.5)\n",
        "        dot.set_color(YELLOW)\n",
        "        dot.move_to(radial_line.pfp(0.1))\n",
        "        circle.rotate(PI / 6)\n",
        "\n",
        "        def get_chord():\n",
        "            p = dot.get_center().copy()\n",
        "            p /= (circle.get_width() / 2)\n",
        "            chord = CenterPoint.chord_from_xy(p[0], p[1], circle)\n",
        "            chord.set_stroke(BLUE, 4)\n",
        "            return chord\n",
        "\n",
        "        chord = always_redraw(get_chord)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dot),\n",
        "            GrowFromCenter(chord)\n",
        "        )\n",
        "        self.wait()\n",
        "        for alpha in (0.5, 0.01, 0.4):\n",
        "            self.play(\n",
        "                dot.animate.move_to(radial_line.pfp(alpha)),\n",
        "                run_time=4,\n",
        "            )\n",
        "\n",
        "        self.add(dot)\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class RandomPointsFromVariousSpaces(Scene):\n",
        "    def construct(self):\n",
        "        # Interval\n",
        "        interval = UnitInterval()\n",
        "        interval.add_numbers()\n",
        "        top_words = OldTexText(\"Choose a random$^{*}$ \", \"number between 0 and 1\")\n",
        "        top_words.to_edge(UP)\n",
        "        subwords = OldTexText(\n",
        "            \"($^{*}$Implicitly: According to a \\\\emph{uniform} distribution)\",\n",
        "            color=GREY_A,\n",
        "            tex_to_color_map={\"\\\\emph{uniform}\": YELLOW},\n",
        "            font_size=36\n",
        "        )\n",
        "        subwords.next_to(top_words, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        dots = DotCloud([\n",
        "            interval.n2p(random.random())\n",
        "            for x in range(100)\n",
        "        ])\n",
        "        dots.set_radius(0.5)\n",
        "        dots.set_glow_factor(10)\n",
        "        dots.set_color(YELLOW)\n",
        "        dots.add_updater(lambda m: m)\n",
        "        turn_animation_into_updater(\n",
        "            ShowCreation(dots, rate_func=linear, run_time=10)\n",
        "        )\n",
        "\n",
        "        self.add(interval, dots)\n",
        "        self.play(Write(top_words, run_time=1))\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(subwords, 0.5 * DOWN))\n",
        "        self.wait(6)\n",
        "\n",
        "        # Circle\n",
        "        circle = Circle()\n",
        "        circle.set_stroke(BLUE, 2)\n",
        "        circle.set_height(5)\n",
        "        circle.next_to(subwords, DOWN, buff=MED_LARGE_BUFF)\n",
        "        dots.clear_updaters()\n",
        "        dots.generate_target(use_deepcopy=True)\n",
        "        dots.target.set_points([\n",
        "            circle.pfp(interval.p2n(p))\n",
        "            for p in dots.get_points()\n",
        "        ])\n",
        "        dots.target.set_radius(0)\n",
        "\n",
        "        circle_words = Text(\"point on a circle\")\n",
        "        circle_words.move_to(top_words[1], UL)\n",
        "        circle_words.set_color(BLUE)\n",
        "        top_words[0].generate_target()\n",
        "        VGroup(top_words[0].target, circle_words).set_x(0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(dots, run_time=1),\n",
        "            TransformFromCopy(\n",
        "                Line(interval.n2p(0), interval.n2p(1)).set_stroke(GREY_B, 1),\n",
        "                circle,\n",
        "                run_time=1,\n",
        "            ),\n",
        "            FadeOut(interval),\n",
        "            FadeOut(top_words[1], UP),\n",
        "            FadeIn(circle_words, UP),\n",
        "            MoveToTarget(top_words[0]),\n",
        "        )\n",
        "\n",
        "        dots.set_points([\n",
        "            circle.pfp(random.random())\n",
        "            for x in range(25)\n",
        "        ])\n",
        "        dots.set_radius(0.5)\n",
        "        dots.set_glow_factor(5)\n",
        "        dots.add_updater(lambda m: m)\n",
        "        self.add(dots)\n",
        "        self.play(ShowCreation(dots, rate_func=linear, run_time=2))\n",
        "\n",
        "        # Sphere\n",
        "        sphere_words = Text(\"point on a sphere\")\n",
        "        sphere_words.move_to(circle_words, LEFT)\n",
        "        sphere_words.set_color(BLUE)\n",
        "\n",
        "        sphere = Sphere()\n",
        "        sphere.set_color(BLUE_D)\n",
        "        sphere.set_opacity(0.5)\n",
        "        sphere.set_shadow(0.5)\n",
        "        sphere.set_gloss(0.5)\n",
        "        sphere.set_reflectiveness(0.5)\n",
        "        sphere.replace(circle)\n",
        "        sphere.rotate(0.05 * PI)\n",
        "        sphere.rotate(0.4 * PI, LEFT)\n",
        "        sphere.sort_faces_back_to_front()\n",
        "\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(WHITE, 1, 0.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(dots),\n",
        "            FadeOut(circle, run_time=2),\n",
        "            ShowCreation(sphere, run_time=2),\n",
        "            ShowCreation(mesh, lag_ratio=0.1, run_time=2),\n",
        "            FadeOut(circle_words, UP),\n",
        "            FadeIn(sphere_words, UP),\n",
        "        )\n",
        "\n",
        "        dots.set_points([\n",
        "            random.choice(sphere.get_points())\n",
        "            for x in range(100)\n",
        "        ])\n",
        "        dots.set_radius(0.25)\n",
        "        self.play(ShowCreation(dots, run_time=10, rate_func=linear))\n",
        "\n",
        "        # Ambiguity\n",
        "        underline = Underline(\n",
        "            subwords.get_part_by_tex(\"uniform\"),\n",
        "            buff=0\n",
        "        )\n",
        "        underline.set_stroke(YELLOW, width=[0, 2, 2, 2, 0])\n",
        "        underline.scale(1.25)\n",
        "        underline.insert_n_curves(50)\n",
        "        question = Text(\"Is this well-defined?\")\n",
        "        question.to_edge(RIGHT).shift(UP)\n",
        "        arrow = Arrow(underline, question, buff=0.1)\n",
        "        arrow.set_color(YELLOW)\n",
        "\n",
        "        turn_animation_into_updater(\n",
        "            ShowCreation(dots, run_time=10, rate_func=lambda t: 0.5 + 0.5 * t),\n",
        "        )\n",
        "\n",
        "        dots.clear_updaters()\n",
        "        dots.set_points(dots.get_points()[12:16])\n",
        "        dots.set_radius(0.5)\n",
        "        dots.add_updater(lambda m: m)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(underline),\n",
        "            ShowCreation(arrow),\n",
        "            FadeIn(question, shift=0.5 * DR),\n",
        "            ShowCreation(dots, run_time=4, rate_func=linear)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CoinFlips(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\": 2,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        n_rows = 15\n",
        "        n_cols = 40\n",
        "        heads = [bool(random.randint(0, 1)) for x in range(n_rows * n_cols)]\n",
        "        coins = VGroup(*(self.get_coin(h) for h in heads))\n",
        "        coins.arrange_in_grid(n_rows, n_cols, buff=SMALL_BUFF)\n",
        "        coins.set_width(FRAME_WIDTH - 0.5)\n",
        "        coins.to_edge(DOWN)\n",
        "\n",
        "        eq = OldTex(\n",
        "            \"{\\\\# \\\\text{Heads} \\\\over \\\\# \\\\text{Flips}} = \",\n",
        "            \"{Num \\\\over Den}\", \"=\", \"0.500\",\n",
        "            isolate={\"Num\", \"Den\", \"\\\\# \\\\text{Heads}\"}\n",
        "        )\n",
        "        eq.set_color_by_tex(\"Heads\", RED)\n",
        "        num = Integer(100, edge_to_fix=ORIGIN)\n",
        "        den = Integer(100, edge_to_fix=ORIGIN)\n",
        "        dec = DecimalNumber(0.5, num_decimal_places=3, edge_to_fix=LEFT)\n",
        "        num_i = eq.index_of_part_by_tex(\"Num\")\n",
        "        den_i = eq.index_of_part_by_tex(\"Den\")\n",
        "        dec_i = eq.index_of_part_by_tex(\"0.500\")\n",
        "        num.replace(eq[num_i], dim_to_match=1)\n",
        "        den.replace(eq[den_i], dim_to_match=1)\n",
        "        dec.replace(eq[dec_i], dim_to_match=1)\n",
        "        eq.replace_submobject(num_i, num)\n",
        "        eq.replace_submobject(den_i, den)\n",
        "        eq.replace_submobject(dec_i, dec)\n",
        "        eq.to_edge(UP)\n",
        "\n",
        "        def update_eq(eq, alpha):\n",
        "            n_flips = max(int(alpha * len(heads)), 1)\n",
        "            n_heads = sum(heads[:n_flips])\n",
        "            num.set_value(n_heads).set_color(RED)\n",
        "            den.set_value(n_flips)\n",
        "            dec.set_value(n_heads / n_flips)\n",
        "            return eq\n",
        "\n",
        "        for sm in eq:\n",
        "            sm.add_updater(lambda m: m)\n",
        "\n",
        "        words = OldTexText(\"What does\\\\\\\\this approach?\", font_size=36)\n",
        "        words.to_corner(UR)\n",
        "        arrow = Arrow(words, dec)\n",
        "        VGroup(words, arrow).set_color(YELLOW)\n",
        "\n",
        "        self.add(coins, *eq)\n",
        "        srf = squish_rate_func(smooth, 0.3, 0.4)\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(coins, rate_func=linear),\n",
        "            UpdateFromAlphaFunc(Mobject(), update_eq, rate_func=linear),\n",
        "            Write(words, rate_func=srf),\n",
        "            ShowCreation(arrow, rate_func=srf),\n",
        "            run_time=18\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "    def get_coin(self, heads=True, radius=0.25):\n",
        "        circle = Dot(radius=radius)\n",
        "        circle.set_fill(RED_E if heads else BLUE_E)\n",
        "        circle.set_stroke(WHITE, 0.5, 0.5)\n",
        "        symbol = OldTex(\"H\" if heads else \"T\")\n",
        "        symbol.set_height(radius)\n",
        "        symbol.move_to(circle)\n",
        "        return VGroup(circle, symbol)\n",
        "\n",
        "\n",
        "class ChordsInSpaceWithCircle(RandomChordScene):\n",
        "    def construct(self):\n",
        "        # Introduce chords\n",
        "        n_lines = 500\n",
        "        big_circle = Circle(radius=FRAME_WIDTH + FRAME_HEIGHT)\n",
        "        lines = VGroup(*(\n",
        "            RadialPoint.get_random_chord(big_circle)\n",
        "            for x in range(n_lines)\n",
        "        ))\n",
        "        lines.set_stroke(WHITE, 0.5, 0.5)\n",
        "\n",
        "        circle = Circle(radius=2)\n",
        "        circle.set_stroke(WHITE, 2)\n",
        "\n",
        "        triangle = Polygon(*(circle.pfp(a) for a in np.arange(0, 1, 1 / 3)))\n",
        "        triangle.rotate(-PI / 6, about_point=circle.get_center())\n",
        "        triangle.set_stroke(YELLOW, 3)\n",
        "        triangle = VGroup(\n",
        "            triangle.copy().set_stroke(BLACK, 8),\n",
        "            triangle.copy(),\n",
        "        )\n",
        "\n",
        "        self.play(Write(lines, lag_ratio=(1 / n_lines), run_time=6))\n",
        "        self.wait()\n",
        "\n",
        "        def get_chords():\n",
        "            return VGroup(*(\n",
        "                self.line_to_chord(line, circle)\n",
        "                for line in lines\n",
        "            ))\n",
        "\n",
        "        chords = get_chords()\n",
        "        chords.save_state(RED)\n",
        "        chords.set_stroke(WHITE, 1)\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            VFadeIn(chords),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(triangle, lag_ratio=0))\n",
        "        circle.add(triangle)\n",
        "        self.wait()\n",
        "\n",
        "        # Show colors\n",
        "        key = OldTexText(\n",
        "            \"Blue $\\\\Rightarrow$ Chord > \\\\text{Triangle side}\\\\\\\\\"\n",
        "            \"Red $\\\\Rightarrow$ Chord < \\\\text{Triangle side}\\\\\\\\\",\n",
        "            tex_to_color_map={\n",
        "                \"Blue\": BLUE,\n",
        "                \"Red\": RED,\n",
        "            }\n",
        "        )\n",
        "        key.to_edge(UP)\n",
        "        key.set_backstroke(width=5)\n",
        "        key[len(key) // 2:].align_to(key[:len(key) // 2], RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            Restore(chords),\n",
        "            FadeIn(key),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Move around\n",
        "        chords.add_updater(lambda m: m.become(get_chords()))\n",
        "        self.add(chords, circle)\n",
        "        self.play(circle.animate.to_edge(RIGHT), run_time=6)\n",
        "        self.play(circle.animate.to_edge(LEFT), run_time=6)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            circle.animate.set_height(7, about_edge=LEFT),\n",
        "            FadeOut(key, rate_func=squish_rate_func(smooth, 0, 0.5)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(circle.animate.set_height(4, about_edge=RIGHT), run_time=4)\n",
        "\n",
        "        # Show center point method\n",
        "        big_circle = Circle(radius=3.25)\n",
        "        big_circle.set_stroke(GREY_B, 2)\n",
        "        big_circle.to_edge(DOWN)\n",
        "\n",
        "        title = Text(\"Random center point method\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        chords.clear_updaters()\n",
        "        self.play(\n",
        "            FadeOut(chords),\n",
        "            FadeOut(lines),\n",
        "            FadeIn(big_circle),\n",
        "            FadeIn(title),\n",
        "            circle.animate.set_height(0.5).to_corner(DR),\n",
        "        )\n",
        "        triangle.set_stroke(width=2)\n",
        "\n",
        "        n_lines = 1000\n",
        "        lines.become(VGroup(*(\n",
        "            CenterPoint.get_random_chord(big_circle)\n",
        "            for x in range(n_lines)\n",
        "        )))\n",
        "        lines.set_stroke(WHITE, self.chord_width, self.chord_opacity)\n",
        "        flash_lines = lines.copy()\n",
        "        flash_lines.set_stroke(width=3, opacity=1)\n",
        "        indicators = Group(*map(CenterPoint.get_method_indicator, lines))\n",
        "\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(lines),\n",
        "            ShowSubmobjectsOneByOne(flash_lines),\n",
        "            ShowSubmobjectsOneByOne(indicators),\n",
        "            rate_func=linear,\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(indicators[-1]),\n",
        "            FadeOut(flash_lines[-1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Put circle back inside\n",
        "        self.play(\n",
        "            circle.animate.set_height(2).move_to(big_circle),\n",
        "            run_time=1\n",
        "        )\n",
        "        chords.become(get_chords().set_stroke(opacity=0.7))\n",
        "        self.add(chords, circle)\n",
        "        self.play(VFadeIn(chords))\n",
        "        self.wait()\n",
        "        chords.add_updater(lambda m: m.become(get_chords().set_stroke(opacity=0.7)))\n",
        "        self.play(\n",
        "            circle.animate.move_to(big_circle, RIGHT),\n",
        "            run_time=10,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def line_to_chord(self, line, circle, stroke_width=1):\n",
        "        r = circle.get_radius()\n",
        "        tangent = normalize(line.get_vector())\n",
        "        normal = rotate_vector(tangent, PI / 2)\n",
        "        center = circle.get_center()\n",
        "        d1 = np.dot(line.get_start() - center, normal)\n",
        "        if d1 > r:\n",
        "            return VectorizedPoint(center + r * normal)\n",
        "        d2 = np.sqrt(r**2 - d1**2)\n",
        "        chord = Line(\n",
        "            center + d1 * normal - d2 * tangent,\n",
        "            center + d1 * normal + d2 * tangent,\n",
        "        )\n",
        "        chord.set_stroke(\n",
        "            (BLUE if chord.get_length() > math.sqrt(3) * r else RED),\n",
        "            width=stroke_width,\n",
        "        )\n",
        "        return chord\n",
        "\n",
        "\n",
        "class TransitiveSymmetries(Scene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius=3)\n",
        "        circle.set_stroke(GREY_B, 2)\n",
        "        circle.rotate(PI / 2)\n",
        "\n",
        "        dots = DotCloud([circle.pfp(a) for a in np.linspace(0, 1, 49)])\n",
        "        dots.set_glow_factor(5)\n",
        "        dots.set_radius(0.5)\n",
        "        dots.set_color(WHITE)\n",
        "        dots.set_opacity(0.5)\n",
        "\n",
        "        dot = dots.copy()\n",
        "        dot.set_points([dots.get_points()[0]])\n",
        "        dot.set_color(YELLOW)\n",
        "        dot.set_opacity(1)\n",
        "\n",
        "        top_words = Text(\"By acting on any one point...\")\n",
        "        top_words.match_x(dot)\n",
        "        top_words.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        low_words = Text(\"...you can map\\nto any other\")\n",
        "        low_words.to_edge(RIGHT).shift(2 * DOWN)\n",
        "\n",
        "        self.add(circle, top_words, dot)\n",
        "        dots.add_updater(lambda m: m)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                Group(circle, dot), TAU,\n",
        "                about_point=circle.get_center(),\n",
        "            ),\n",
        "            ShowCreation(\n",
        "                dots,\n",
        "                rate_func=lambda a: smooth(a * (1 - 1 / 48) + 1 / 48)\n",
        "            ),\n",
        "            Write(low_words, rate_func=squish_rate_func(smooth, 0.3, 0.5)),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "\n",
        "class NonTransitive(Scene):\n",
        "    def construct(self):\n",
        "        circle = Circle(radius=3)\n",
        "        circle.set_stroke(GREY_B, 2)\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Rotational symmetries do \\\\emph{not} act\\\\\\\\\"\n",
        "            \"transitively on the space of all chords\",\n",
        "            tex_to_color_map={\"\\\\emph{not}\": RED},\n",
        "        )\n",
        "        words.to_edge(UP, MED_SMALL_BUFF)\n",
        "        circle.next_to(words, DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        chord1 = Line(circle.pfp(0.4), circle.pfp(0.5))\n",
        "        chord1.set_stroke(RED, 3)\n",
        "        chord1_shadow = chord1.copy().set_stroke(opacity=0.5)\n",
        "        chord2 = Line(circle.pfp(0.8), circle.pfp(0.25))\n",
        "        chord2.set_stroke(BLUE, 3)\n",
        "\n",
        "        left_words = Text(\"No action on\\nthis chord...\")\n",
        "        right_words = Text(\"...will ever map\\nto this chord.\")\n",
        "        left_words.to_edge(LEFT).shift(UP)\n",
        "        right_words.to_edge(RIGHT).shift(DOWN)\n",
        "\n",
        "        left_arrow = Arrow(left_words, chord1.get_center(), buff=0.1)\n",
        "        right_arrow = Arrow(right_words.get_left(), chord2.get_center(), buff=0.1)\n",
        "\n",
        "        VGroup(left_words, left_arrow).set_color(RED)\n",
        "        VGroup(right_words, right_arrow).set_color(BLUE)\n",
        "\n",
        "        chords = VGroup(*(\n",
        "            RadialPoint.get_random_chord(circle)\n",
        "            for x in range(100)\n",
        "        ))\n",
        "        chords.set_stroke(WHITE, 1, 0.5)\n",
        "\n",
        "        group = VGroup(circle, chords)\n",
        "\n",
        "        self.add(words)\n",
        "        self.play(\n",
        "            Rotate(group, TAU, about_point=circle.get_center(), run_time=6)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(chord1_shadow, chord1)\n",
        "        self.play(\n",
        "            FadeOut(chords),\n",
        "            ShowCreation(chord1_shadow),\n",
        "            ShowCreation(chord1),\n",
        "            FadeIn(left_words),\n",
        "            ShowCreation(left_arrow),\n",
        "        )\n",
        "        group = VGroup(circle, chord1)\n",
        "        self.add(group, left_arrow)\n",
        "        self.play(\n",
        "            Rotate(\n",
        "                group, TAU,\n",
        "                about_point=circle.get_center(),\n",
        "            ),\n",
        "            FadeIn(\n",
        "                VGroup(right_words, right_arrow, chord2),\n",
        "                rate_func=squish_rate_func(smooth, 0.3, 0.4),\n",
        "            ),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class RandomSpherePoint(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        frame.reorient(-20, 70)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(0.015 * dt))\n",
        "\n",
        "        grid = NumberPlane(\n",
        "            (-6, 6), (-4, 4),\n",
        "            background_line_style={\n",
        "                \"stroke_color\": GREY_B,\n",
        "                \"stroke_width\": 1,\n",
        "                \"stroke_opacity\": 0.5,\n",
        "            },\n",
        "            axis_config={\n",
        "                \"stroke_width\": 1,\n",
        "            }\n",
        "        )\n",
        "        grid.scale(2)\n",
        "        plane = Rectangle()\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.set_gloss(0.5)\n",
        "        plane.set_fill(GREY_C, 0.5)\n",
        "        plane.replace(grid, stretch=True)\n",
        "        plane.add(grid)\n",
        "        plane.shift(2 * IN)\n",
        "        self.add(plane)\n",
        "\n",
        "        sphere_radius = 2\n",
        "        sphere = Sphere(radius=sphere_radius)\n",
        "        sphere.set_color(BLUE_E)\n",
        "        sphere.set_opacity(1.0)\n",
        "        sphere.move_to(1.5 * OUT)\n",
        "\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(width=0.5, opacity=0.5)\n",
        "        mesh.apply_depth_test()\n",
        "        mesh_shadow = mesh.copy().set_stroke(opacity=0.1)\n",
        "        mesh_shadow.deactivate_depth_test()\n",
        "\n",
        "        sphere = Group(sphere, mesh, mesh_shadow)\n",
        "        self.add(*sphere)\n",
        "\n",
        "        # Random point\n",
        "        words = OldTexText(\"Choose a random$^{*}$\\\\\\\\point on a sphere\")\n",
        "        words.fix_in_frame()\n",
        "        words.to_corner(UL)\n",
        "\n",
        "        technicality = OldTexText(\n",
        "            \"$^{*}$From a distribution that's\\\\\\\\\",\n",
        "            \"invariant under rotational symmetries.\",\n",
        "            font_size=30\n",
        "        )\n",
        "        technicality[1].set_color(YELLOW)\n",
        "        technicality.fix_in_frame()\n",
        "        technicality.to_corner(UR)\n",
        "        technicality.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "\n",
        "        def random_sphere_point():\n",
        "            p = [1, 1, 1]\n",
        "            while get_norm(p) > 1:\n",
        "                p = np.random.uniform(-1, 1, 3)\n",
        "            p = sphere_radius * normalize(p)\n",
        "            return p + sphere.get_center()\n",
        "\n",
        "        dot = TrueDot()\n",
        "        dot.set_radius(0.5)\n",
        "        dot.set_color(YELLOW)\n",
        "        dot.set_glow_factor(5)\n",
        "        dot.move_to(random_sphere_point())\n",
        "\n",
        "        self.add(words)\n",
        "        dot.set_radius(0)\n",
        "        self.play(dot.animate.set_radius(0.5))\n",
        "\n",
        "        for x in range(11):\n",
        "            dot.move_to(random_sphere_point())\n",
        "            dot.set_opacity(random.choice([0.25, 1.0]))\n",
        "            if x == 5:\n",
        "                self.play(FadeIn(technicality), run_time=0.5)\n",
        "            else:\n",
        "                self.wait(0.5)\n",
        "        self.play(FadeOut(dot))\n",
        "\n",
        "        # Little patch\n",
        "        band = sphere[0].copy()\n",
        "        band.pointwise_become_partial(sphere[0], 0.7, 0.8)\n",
        "        patch = band.copy()\n",
        "        patch.pointwise_become_partial(band, 0.7, 0.75, axis=0)\n",
        "        patch.set_color(TEAL)\n",
        "        patch.set_opacity(0.8)\n",
        "        patch.deactivate_depth_test()\n",
        "\n",
        "        dot.move_to(patch)\n",
        "\n",
        "        def show_dots_in_patch(n=2000):\n",
        "            dots = DotCloud([\n",
        "                random_sphere_point()\n",
        "                for x in range(n)\n",
        "            ])\n",
        "            dots.set_color(WHITE)\n",
        "            dots.set_radius(0.02)\n",
        "            dots.set_glow_factor(1)\n",
        "            dots.set_opacity([\n",
        "                0.25 if point[1] > 0 else 1.0\n",
        "                for point in dots.get_points()\n",
        "            ])\n",
        "            dots.add_updater(lambda m: m)\n",
        "            self.play(ShowCreation(dots, run_time=6, rate_func=linear))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(dots))\n",
        "\n",
        "        self.play(GrowFromCenter(patch))\n",
        "        self.wait()\n",
        "        show_dots_in_patch()\n",
        "        self.wait()\n",
        "\n",
        "        # patch_copy = patch.copy()\n",
        "        self.play(*(\n",
        "            Rotate(\n",
        "                sm, PI / 3, axis=OUT + RIGHT,\n",
        "                about_point=sphere.get_center(),\n",
        "                run_time=2,\n",
        "            )\n",
        "            for sm in (*sphere, patch)\n",
        "        ))\n",
        "        show_dots_in_patch()\n",
        "        self.wait()\n",
        "\n",
        "        # Embed\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class CorrectionInsert(Scene):\n",
        "    def construct(self):\n",
        "        # Words\n",
        "        title = OldTexText(\"Looking for an unambiguous ``uniform'' distribution?\")\n",
        "        title.to_edge(UP, buff=0.25)\n",
        "        kw = dict(\n",
        "            # font_size=36,\n",
        "            # color=GREY_A,\n",
        "            t2c={\"compact\": YELLOW, \"transitively\": BLUE},\n",
        "            t2s={\"compact\": ITALIC},\n",
        "        )\n",
        "        conditions = VGroup(\n",
        "            Text(\"1) Find a symmetry which acts transitively\", **kw),\n",
        "            Text(\"2) The space must be compact\", **kw),\n",
        "        )\n",
        "        conditions.arrange(DOWN, aligned_edge=LEFT)\n",
        "        conditions.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        conditions.to_edge(UP)\n",
        "\n",
        "        # Add shapes\n",
        "        radius = 1.5\n",
        "\n",
        "        interval = UnitInterval(width=4)\n",
        "        interval.add_numbers([0, 0.5, 1.0], num_decimal_places=1)\n",
        "\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(GREY_B, 2)\n",
        "\n",
        "        sphere = Sphere(radius=radius)\n",
        "        sphere.set_color(BLUE_D, 1)\n",
        "        sphere.set_opacity(0.5)\n",
        "        mesh = SurfaceMesh(sphere)\n",
        "        mesh.set_stroke(width=0.5)\n",
        "        mesh_shadow = mesh.copy().set_stroke(opacity=0.35)\n",
        "        sphere_group = Group(mesh_shadow, sphere, mesh)\n",
        "        sphere_group.rotate(80 * DEGREES, LEFT)\n",
        "        sphere_group.rotate(2.5 * DEGREES, OUT)\n",
        "        sphere.sort_faces_back_to_front()\n",
        "\n",
        "        shapes = Group(interval, circle, sphere_group)\n",
        "        shapes.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        shapes.set_y(-1)\n",
        "\n",
        "        # Dots\n",
        "        interval_dots = DotCloud([interval.pfp(random.random()) for n in range(100)])\n",
        "        circle_dots = DotCloud([circle.pfp(random.random()) for n in range(100)])\n",
        "        sphere_dots = DotCloud([\n",
        "            sphere.pfp(math.acos(random.random()) / PI)\n",
        "            for n in range(300)\n",
        "        ])\n",
        "\n",
        "        all_dots = Group(interval_dots, circle_dots, sphere_dots)\n",
        "        for dots in all_dots:\n",
        "            dots.set_glow_factor(5)\n",
        "            dots.set_radius(0.1)\n",
        "            dots.set_color(YELLOW)\n",
        "            dots.add_updater(lambda m: m)\n",
        "        sphere_dots.set_opacity(np.random.choice([1, 0.2], sphere_dots.get_num_points()))\n",
        "        circle_dots.set_radius(0.15)\n",
        "\n",
        "        # Animations\n",
        "        self.add(conditions[0])\n",
        "        self.add(shapes)\n",
        "        self.add(*dots)\n",
        "\n",
        "        self.play(*(ShowCreation(dots, rate_func=linear, run_time=15) for dots in all_dots))\n",
        "        self.wait(4)\n",
        "        self.play(Write(conditions[1][:2]))\n",
        "        self.wait(2)\n",
        "        self.play(Write(conditions[1][2:]))\n",
        "        self.wait()\n",
        "\n",
        "        # Compact\n",
        "        rects = Rectangle(height=4.75, width=6).get_grid(1, 2, buff=0.5)\n",
        "        rects.set_stroke(GREY, 1)\n",
        "        rects.to_edge(DOWN)\n",
        "\n",
        "        rect_titles = VGroup(Text(\"Compact\"), Text(\"Not compact\"))\n",
        "        for rt, r, color in zip(rect_titles, rects, [YELLOW, RED]):\n",
        "            rt.scale(0.7)\n",
        "            rt.next_to(r, UP, buff=SMALL_BUFF)\n",
        "            rt.set_color(color)\n",
        "\n",
        "        compact_spaces = Group(\n",
        "            Group(interval, interval_dots),\n",
        "            Group(circle, circle_dots),\n",
        "            Group(*sphere_group, sphere_dots)\n",
        "        )\n",
        "        compact_spaces.generate_target()\n",
        "        compact_spaces.target.arrange(DOWN)\n",
        "        compact_spaces.target.set_height(0.9 * rects[0].get_height())\n",
        "        compact_spaces.target.move_to(rects[0])\n",
        "\n",
        "        movers = []\n",
        "        for cs, cst in zip(compact_spaces, compact_spaces.target):\n",
        "            for m, mt in zip(cs, cst):\n",
        "                m.generate_target()\n",
        "                m.target.replace(mt)\n",
        "                movers.append(m)\n",
        "\n",
        "        self.play(\n",
        "            *map(MoveToTarget, movers),\n",
        "            *map(ShowCreation, rects),\n",
        "            *map(FadeIn, rect_titles),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Non-compact\n",
        "        reals = NumberLine((-5, 5), include_tip=True)\n",
        "        reals.ticks.remove(reals.ticks[0])\n",
        "        reals.add(reals.copy().flip())\n",
        "        reals.add_numbers(font_size=20)\n",
        "        reals.set_width(0.9 * rects[1].get_width())\n",
        "        reals.next_to(rects[1].get_top(), DOWN, buff=LARGE_BUFF)\n",
        "        reals_label = Text(\"Real number line\", font_size=30)\n",
        "        reals_label.next_to(reals, UP, SMALL_BUFF)\n",
        "\n",
        "        plane = Square(4)\n",
        "        plane.set_stroke(width=0)\n",
        "        plane.set_fill(GREY_D, 1)\n",
        "        plane.set_gloss(0.5)\n",
        "        plane.set_reflectiveness(0.4)\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(v, 2 * v, stroke_width=2)\n",
        "            for v in compass_directions(8)\n",
        "        ))\n",
        "        group = VGroup(plane, arrows)\n",
        "        group.rotate(80 * DEGREES, LEFT)\n",
        "        group.set_width(4.5)\n",
        "        group.next_to(reals, DOWN, buff=1.5)\n",
        "        group.shift(0.25 * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(reals),\n",
        "            FadeIn(reals_label),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(plane),\n",
        "            *map(ShowCreation, arrows),\n",
        "        )\n",
        "        self.wait(3)\n"
    ]
}