{
    "topic": "The mathematical concept being demonstrated is the equation for a driven harmonic oscillator, which describes the motion",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.laplace.integration import get_complex_graph\n",
        "from _2025.laplace.exponentials import SPlane\n",
        "from _2025.laplace.exponentials import get_exp_graph_icon\n",
        "\n",
        "\n",
        "class DrivenHarmonicOscillatorEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        colors = color_gradient([TEAL, RED], 3, interp_by_hsl=True)\n",
        "        equation = Tex(\n",
        "            R\"m x''(t) + \\mu x'(t) + k x(t) = F_0 \\cos(\\omega t)\",\n",
        "            t2c={\n",
        "                \"x(t)\": colors[0],\n",
        "                \"x'(t)\": colors[1],\n",
        "                \"x''(t)\": colors[2],\n",
        "                R\"\\omega\": PINK,\n",
        "            }\n",
        "        )\n",
        "        self.add(equation)\n",
        "\n",
        "\n",
        "class SimpleCosGraph(InteractiveScene):\n",
        "    rotation_frequency = TAU / 4\n",
        "\n",
        "    def construct(self):\n",
        "        # Show graph\n",
        "        def get_t():\n",
        "            return self.time\n",
        "\n",
        "        t_max = 20\n",
        "        axes = Axes((0, t_max), (-1, 1), x_axis_config=dict(unit_size=0.6))\n",
        "        axes.scale(1.25).to_edge(LEFT)\n",
        "\n",
        "        x_axis = axes.x_axis\n",
        "\n",
        "        x_axis.add(VGroup(\n",
        "            Tex(tex, font_size=20).next_to(x_axis.n2p(n), DOWN)\n",
        "            for n, tex in zip(it.count(1, 2), self.get_pi_frac_texs())\n",
        "        ))\n",
        "\n",
        "        def cos_func(t):\n",
        "            return np.cos(self.rotation_frequency * t)\n",
        "\n",
        "        graph = axes.get_graph(cos_func)\n",
        "        graph.set_stroke(TEAL, 3)\n",
        "        graph_ghost = graph.copy()\n",
        "        graph_ghost.set_stroke(opacity=0.5)\n",
        "        shown_graph = graph.copy()\n",
        "        shown_graph.add_updater(lambda m: m.pointwise_become_partial(graph, 0, get_t() / t_max))\n",
        "\n",
        "        output_dot = Group(TrueDot(), GlowDot()).set_color(YELLOW)\n",
        "        output_dot.add_updater(lambda m: m.move_to(axes.y_axis.n2p(cos_func(get_t()))))\n",
        "\n",
        "        h_line = Line()\n",
        "        h_line.set_stroke(WHITE, 1)\n",
        "        h_line.f_always.put_start_and_end_on(output_dot.get_center, shown_graph.get_end)\n",
        "\n",
        "        cos_label = Tex(R\"\\cos(t)\", font_size=60)\n",
        "        cos_label.to_edge(UP)\n",
        "\n",
        "        self.add(axes, graph_ghost, output_dot, shown_graph, h_line)\n",
        "        self.wait(10)\n",
        "        self.play(FadeOut(x_axis))\n",
        "        self.wait(14)\n",
        "\n",
        "    def get_pi_frac_texs(self):\n",
        "        return [\n",
        "            R\"\\pi / 2\", R\"\\pi\", R\"3 \\pi / 2\", R\"2\\pi\",\n",
        "            R\"5\\pi / 2\", R\"3\\pi\", R\"7 \\pi / 2\", R\"4\\pi\",\n",
        "            R\"9\\pi / 2\", R\"5\\pi\",\n",
        "        ]\n",
        "\n",
        "\n",
        "class BreakUpCosineTex(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show sum\n",
        "        pure_cos = Tex(R\"\\cos(t)\", font_size=72)\n",
        "        pure_cos.to_edge(UP)\n",
        "        tex_pieces = [R\"\\cos(t)\", \"=\", R\"\\frac{1}{2}\", \"e^{+it}\", \"{+}\", R\"{1 \\over 2}\", \"e^{-it}\"]\n",
        "        sum_tex = Tex(\" \".join(tex_pieces), t2c={\"+i\": YELLOW, \"-i\": YELLOW})\n",
        "        sum_tex.to_edge(UP, buff=MED_SMALL_BUFF).shift(0.5 * RIGHT)\n",
        "        cos, equals, half1, eit, plus, half2, enit = pieces = VGroup(\n",
        "            sum_tex[tex][0] for tex in remove_list_redundancies(tex_pieces)\n",
        "        )\n",
        "\n",
        "        self.add(pure_cos)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeTransform(pure_cos, cos),\n",
        "            Write(pieces[1:])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Fade parts\n",
        "        pieces.generate_target()\n",
        "        pieces.target.set_fill(opacity=0.35)\n",
        "        pieces.target[3].set_fill(opacity=1)\n",
        "        pieces.target.space_out_submobjects(1.2)\n",
        "        self.play(MoveToTarget(pieces))\n",
        "        self.wait()\n",
        "        self.play(VGroup(plus, enit).animate.set_fill(opacity=1))\n",
        "        self.wait()\n",
        "        self.play(pieces.animate.set_fill(opacity=1))\n",
        "        self.play(pieces.animate.space_out_submobjects(1 / 1.2))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TranslateToNewLanguage(InteractiveScene):\n",
        "    graph_resolution = (301, 301)\n",
        "    show_integral = True\n",
        "    label_config = dict(\n",
        "        font_size=72,\n",
        "        t2c={\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "    )\n",
        "\n",
        "    def construct(self):\n",
        "        # Set up a functions\n",
        "        full_s_samples = self.get_s_samples()\n",
        "        func_s_samples = [\n",
        "            complex(-2, 2),\n",
        "            complex(-2, -2),\n",
        "            complex(0, 1),  # Changed\n",
        "            complex(-1, 0),\n",
        "            complex(0, -1),  # Changed\n",
        "        ]\n",
        "        func_weights = [-1, -1, 1j, 2, -1j]\n",
        "\n",
        "        def func(t):\n",
        "            return sum([\n",
        "                (weight * np.exp(complex(0.1 * s.real, s.imag) * t)).real\n",
        "                for s, weight in zip(func_s_samples, func_weights)\n",
        "            ])\n",
        "\n",
        "        # Graph\n",
        "        axes, graph, graph_label = self.get_graph_group(func)\n",
        "\n",
        "        # Show the S-plane pieces\n",
        "        frame = self.frame\n",
        "        frame.set_y(0.5)\n",
        "        s_plane, exp_pieces, s_plane_name = self.get_s_plane_and_exp_pieces(full_s_samples)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(axes),\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(graph_label),\n",
        "            FadeIn(s_plane_name, lag_ratio=0.1),\n",
        "            LaggedStartMap(FadeIn, exp_pieces, lag_ratio=0.1),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Narrow down specific pieces\n",
        "        exp_pieces.save_state()\n",
        "        exp_pieces.generate_target()\n",
        "        key_pieces = VGroup()\n",
        "        for piece, s_sample in zip(exp_pieces.target, full_s_samples):\n",
        "            if s_sample not in func_s_samples:\n",
        "                piece.fade(0.7)\n",
        "            else:\n",
        "                key_pieces.add(piece)\n",
        "\n",
        "        weight_labels = VGroup(\n",
        "            Tex(Rf\"\\times {w}\", font_size=24).next_to(piece.get_top(), DOWN, SMALL_BUFF)\n",
        "            for w, piece in zip([R\"\\minus 1\", R\"\\minus 1\", R\"\\minus i\", \"2\", \"i\"], key_pieces)\n",
        "        )\n",
        "        self.play(\n",
        "            MoveToTarget(exp_pieces),\n",
        "            LaggedStartMap(FadeIn, weight_labels),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            (Transform(graph.copy(), piece[-1].copy().insert_n_curves(100), remover=True)\n",
        "            for piece in key_pieces),\n",
        "            lag_ratio=0.1,\n",
        "            group_type=Group,\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Reveal plane\n",
        "        frame = self.frame\n",
        "        arrow, fancy_L, Fs_label = self.get_arrow_to_Fs(graph_label)\n",
        "        Fs_label.save_state()\n",
        "        Fs_label.become(graph_label)\n",
        "\n",
        "        def Func(s):\n",
        "            result = sum([\n",
        "                np.divide(w, (s - s0))\n",
        "                for s0, w in zip(func_s_samples, func_weights)\n",
        "            ])\n",
        "            return min(100, result)\n",
        "\n",
        "        lt_graph = get_complex_graph(s_plane, Func, resolution=self.graph_resolution, face_sort_direction=DOWN)\n",
        "        lt_graph.stretch(0.25, 2, about_point=s_plane.n2p(0))\n",
        "        lt_graph.save_state()\n",
        "        lt_graph.stretch(0, 2, about_point=s_plane.n2p(0))\n",
        "        lt_graph.set_opacity(0)\n",
        "\n",
        "        exp_pieces.target = exp_pieces.saved_state.copy()\n",
        "        for piece in exp_pieces.target:\n",
        "            piece.scale(0.35)\n",
        "\n",
        "        self.add(exp_pieces, lt_graph, graph_label, arrow, Fs_label, Point(), weight_labels)\n",
        "        self.play(\n",
        "            FadeOut(s_plane_name),\n",
        "            GrowArrow(arrow),\n",
        "            Write(fancy_L),\n",
        "            Restore(Fs_label, time_span=(1, 2), path_arc=-10 * DEG),\n",
        "            FadeIn(s_plane),\n",
        "            MoveToTarget(exp_pieces, lag_ratio=1e-3),\n",
        "            FadeOut(weight_labels),\n",
        "            Restore(lt_graph, time_span=(1.5, 3)),\n",
        "            frame.animate.reorient(70, 86, 0, (-4.94, -2.45, 3.51), 19.43),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Show interal and continuation\n",
        "        if self.show_integral:\n",
        "            # For an insertion\n",
        "            integral = Tex(R\"= \\int^\\infty_0 f({t})e^{\\minus{s}{t}}d{t}\", t2c=self.label_config[\"t2c\"])\n",
        "            integral.fix_in_frame()\n",
        "            integral.next_to(Fs_label, RIGHT)\n",
        "            integral.set_backstroke(BLACK, 5)\n",
        "            rect = BackgroundRectangle(VGroup(Fs_label, integral))\n",
        "            rect.set_fill(BLACK, 0.8)\n",
        "            rect.scale(2, about_edge=DL)\n",
        "            rect.shift(0.25 * DOWN)\n",
        "\n",
        "            graph_copy = lt_graph[0].copy()\n",
        "            graph_copy.set_clip_plane(RIGHT, -s_plane.get_left()[0])\n",
        "            graph_copy.fade(0.5)\n",
        "\n",
        "            self.add(rect, Fs_label, integral)\n",
        "            self.play(\n",
        "                FadeIn(rect),\n",
        "                Write(integral, run_time=1)\n",
        "            )\n",
        "            self.wait()\n",
        "            lt_graph.set_clip_plane(RIGHT, s_plane.get_left()[0])\n",
        "            self.play(\n",
        "                frame.animate.reorient(-10, 85, 0, (-2.18, 0.45, 3.12), 11.52),\n",
        "                lt_graph.animate.set_clip_plane(RIGHT, -s_plane.n2p(0)[0]),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.play(\n",
        "                frame.animate.reorient(33, 85, 0, (-1.81, 0.13, 2.44), 12.25),\n",
        "                run_time=6\n",
        "            )\n",
        "            self.wait()\n",
        "            self.add(graph_copy, rect, Fs_label, integral)\n",
        "            self.play(\n",
        "                FadeOut(rect),\n",
        "                ShowCreation(graph_copy),\n",
        "                frame.animate.reorient(-2, 67, 0, (-0.95, -0.06, 1.91), 9.45),\n",
        "                run_time=8\n",
        "            )\n",
        "\n",
        "            # Show key exponentials below poles\n",
        "            for piece in key_pieces:\n",
        "                piece.set_height(1)\n",
        "            self.add(key_pieces, graph_copy, graph)\n",
        "            self.play(\n",
        "                frame.animate.reorient(0, 0, 0, (-1.23, 1.49, 1.9), 9.36),\n",
        "                FadeIn(key_pieces),\n",
        "                exp_pieces.animate.fade(0.5),\n",
        "                run_time=3,\n",
        "            )\n",
        "\n",
        "        # Reorient\n",
        "        self.play(frame.animate.reorient(-39, 90, 0, (-1.37, 1.1, 4.12), 10.93), run_time=15)\n",
        "        self.play(frame.animate.reorient(0, 0, 0, (-2.13, 0.07, 2.2), 9.79), run_time=10)\n",
        "        self.play(frame.animate.reorient(84, 87, 0, (-4.22, -3.48, 5.26), 22.43), run_time=10)\n",
        "\n",
        "        # Poles as lines\n",
        "        pole_lines = VGroup(\n",
        "            Line(s_plane.n2p(s), s_plane.n2p(s) + 20 * OUT)\n",
        "            for s in func_s_samples\n",
        "        )\n",
        "        pole_lines.set_stroke(WHITE, 3)\n",
        "\n",
        "        key_pieces.target = key_pieces.generate_target()\n",
        "        target_rects = VGroup()\n",
        "        for piece in key_pieces.target:\n",
        "            piece.set_height(1.2)\n",
        "            target_rect = piece[0].copy()\n",
        "            target_rect.set_fill(opacity=0)\n",
        "            target_rects.add(target_rect)\n",
        "\n",
        "        self.add(pole_lines, key_pieces, lt_graph)\n",
        "        self.play(\n",
        "            ShowCreation(pole_lines, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-0.98, 0.82, 0.0), 10.00),\n",
        "            lt_graph[0].animate.set_opacity(0.2),\n",
        "            lt_graph[1].animate.set_opacity(0.05),\n",
        "            pole_lines.animate.stretch(0, 2, about_edge=IN),\n",
        "            MoveToTarget(key_pieces),\n",
        "            FadeIn(weight_labels),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shift things down\n",
        "        top_rect = FullScreenRectangle()\n",
        "        top_rect.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "        top_rect.set_height(2.5, about_edge=UP, stretch=True)\n",
        "        top_rect.fix_in_frame()\n",
        "\n",
        "        h_line = DashedLine(top_rect.get_corner(DL), top_rect.get_corner(DR))\n",
        "        h_line.set_stroke(WHITE, 1)\n",
        "        h_line.fix_in_frame()\n",
        "\n",
        "        top_rect.save_state()\n",
        "        top_rect.stretch(0, 1, about_edge=UP)\n",
        "\n",
        "        self.play(\n",
        "            Restore(top_rect),\n",
        "            ShowCreation(h_line, time_span=(1, 2)),\n",
        "            VGroup(axes, graph).animate.shift(2 * DOWN),\n",
        "            VGroup(graph_label, arrow, fancy_L, Fs_label).animate.shift(3 * DOWN),\n",
        "            frame.animate.reorient(-17, 90, 0, (-2.86, 1.57, 3.14), 10.95),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(frame.animate.reorient(39, 92, 0, (-4.35, 0.64, 3.03), 14.99), run_time=20)\n",
        "\n",
        "    def get_graph_group(self, func, func_tex=R\"f({t})\"):\n",
        "        # axes = Axes((0, 7), (-4, 4), width=0.5 * FRAME_WIDTH - 1, height=5)\n",
        "        axes = Axes((0, 8), (-1, 6, 0.5), width=0.3 * FRAME_WIDTH - 1, height=7)\n",
        "        axes.to_edge(LEFT).shift(0.5 * DOWN)\n",
        "        graph = axes.get_graph(func)\n",
        "        graph.set_stroke(BLUE, 5)\n",
        "        graph.set_scale_stroke_with_zoom(True)\n",
        "        axes.set_scale_stroke_with_zoom(True)\n",
        "        graph_label = Tex(func_tex, **self.label_config)\n",
        "        graph_label.move_to(axes).to_edge(UP, buff=LARGE_BUFF)\n",
        "\n",
        "        graph_group = VGroup(axes, graph, graph_label)\n",
        "        graph_group.fix_in_frame()\n",
        "        return graph_group\n",
        "\n",
        "    def get_s_samples(self):\n",
        "        return [complex(a, b) for a in range(-2, 3) for b in range(-2, 3)]\n",
        "\n",
        "    def get_s_plane_and_exp_pieces(self, s_samples):\n",
        "        s_plane = ComplexPlane((-3, 3), (-3, 3))\n",
        "        s_plane.set_height(7.5)\n",
        "        s_plane.move_to(3.75 * RIGHT)\n",
        "        s_plane.set_z_index(-1)\n",
        "\n",
        "        exp_pieces = VGroup(\n",
        "            self.get_exp_graph(s).move_to(s_plane.n2p(s))\n",
        "            for s in s_samples\n",
        "        )\n",
        "        s_plane_name = Text(\"S-plane\", font_size=72)\n",
        "        s_plane_name.next_to(exp_pieces, UP, MED_SMALL_BUFF)\n",
        "        return s_plane, exp_pieces, s_plane_name\n",
        "\n",
        "    def get_arrow_to_Fs(self, graph_label):\n",
        "        arrow = Vector(2 * RIGHT, thickness=5, fill_color=WHITE)\n",
        "        arrow.fix_in_frame()\n",
        "        arrow.next_to(graph_label, RIGHT, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        fancy_L = Tex(R\"\\mathcal{L}\", font_size=60)\n",
        "        fancy_L.next_to(arrow, UP, buff=0)\n",
        "        fancy_L.fix_in_frame()\n",
        "\n",
        "        Fs_label = Tex(R\"F({s})\", **self.label_config)\n",
        "        Fs_label.next_to(arrow, RIGHT, MED_LARGE_BUFF)\n",
        "        Fs_label.fix_in_frame()\n",
        "        Fs_label.set_z_index(1)\n",
        "        Fs_label.set_backstroke(BLACK, 5)\n",
        "\n",
        "        return VGroup(arrow, fancy_L, Fs_label)\n",
        "\n",
        "    def get_exp_graph(self, s, **kwargs):\n",
        "        return get_exp_graph_icon(s, **kwargs)\n",
        "\n",
        "\n",
        "class TranslateDifferentialEquation(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Translate the equations\n",
        "        colors = color_gradient([TEAL, RED], 3, interp_by_hsl=True)\n",
        "        t2c = {\n",
        "            R\"{s}\": YELLOW,\n",
        "            R\"x(t)\": colors[0],\n",
        "            R\"x'(t)\": colors[1],\n",
        "            R\"x''(t)\": colors[2],\n",
        "        }\n",
        "        kw = dict(t2c=t2c, font_size=30)\n",
        "        lhs = Tex(R\"m x''(t) + \\mu x'(t) + k x(t) = \\cos(\\omega t)\", **kw)\n",
        "        rhs1 = Tex(R\"m {s}^2 X({s}) + \\mu {s} X({s}) + k X({s}) = \\frac{{s}}{({s}^2 + \\omega^2)}\", **kw)\n",
        "        rhs2 = Tex(R\"X({s}) \\left( m {s}^2 + \\mu {s} + k \\right) = \\frac{{s}}{({s}^2 + \\omega^2)}\", **kw)\n",
        "        rhs3 = Tex(R\"X({s}) = \\frac{{s}}{\\left({s}^2 + \\omega^2\\right) \\left( m {s}^2 + \\mu {s} + k \\right)}\", **kw)\n",
        "\n",
        "        for sign, term in zip([-1, 1, 1, 1], [lhs, rhs1, rhs2, rhs3]):\n",
        "            term.set_x(sign * FRAME_WIDTH / 4)\n",
        "            term.set_y(3.25)\n",
        "            term.scale(2)\n",
        "            term.set_x(0)\n",
        "            term.set_y(-sign * 2)\n",
        "\n",
        "        arrow = Arrow(lhs, rhs1, thickness=6, buff=0.5)\n",
        "\n",
        "        ode_word = Text(\"Differential Equation\")\n",
        "        algebra_word = Text(\"Algebra\")\n",
        "        ode_word.next_to(lhs, DOWN)\n",
        "        algebra_word.next_to(rhs1, DOWN)\n",
        "\n",
        "        VGroup(ode_word, algebra_word).set_opacity(0)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(lhs, lag_ratio=0.1),\n",
        "            FadeIn(ode_word, lag_ratio=0.1),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                lhs.copy(),\n",
        "                rhs1,\n",
        "                path_arc=-30 * DEG,\n",
        "                lag_ratio=1e-2,\n",
        "                key_map={R\"\\cos(\\omega t)\": R\"\\frac{{s}}{({s}^2 + \\omega^2)}\"}\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(algebra_word, 0.5 * DOWN),\n",
        "            TransformMatchingTex(rhs1, rhs2, path_arc=-30 * DEG),\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                rhs2,\n",
        "                rhs3,\n",
        "                path_arc=-10 * DEG,\n",
        "                matched_keys=[R\"\\left( m {s}^2 \\mu s + k \\right)\", R\"X({s})\"]\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DesiredMachine(InteractiveScene):\n",
        "    show_ode = True\n",
        "\n",
        "    def construct(self):\n",
        "        # Add machine\n",
        "        machine = self.get_machine()\n",
        "        machine.rotate(90 * DEG)\n",
        "        machine.center()\n",
        "        fancy_L = Tex(R\"\\mathcal{L}\", font_size=120)\n",
        "        fancy_L.move_to(machine)\n",
        "        machine.set_z_index(1)\n",
        "        fancy_L.set_z_index(1)\n",
        "\n",
        "        self.add(machine, fancy_L)\n",
        "\n",
        "        # Pump in a function\n",
        "        t2c = {\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "        in_func = Tex(R\"x({t})\", t2c=t2c, font_size=90)\n",
        "        in_func[re.compile(\"s_.\")].set_color(YELLOW)\n",
        "        in_func.next_to(machine, UP, MED_LARGE_BUFF)\n",
        "        in_func_ghost = in_func.copy().set_fill(opacity=0.5)\n",
        "\n",
        "        self.play(Write(in_func))\n",
        "        self.wait()\n",
        "        self.add(in_func_ghost)\n",
        "        self.play(\n",
        "            FadeOutToPoint(in_func, machine.get_bottom(), lag_ratio=0.025)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pump in a differential equation\n",
        "        if show_ode:\n",
        "            ode = Tex(R\"m x''({t}) + \\mu x'({t}) + k x(t) = F_0 \\cos(\\omega{t})\", t2c=t2c, font_size=60)\n",
        "            ode.next_to(machine, UP, MED_LARGE_BUFF)\n",
        "            ode_ghost = ode.copy().set_fill(opacity=0.5)\n",
        "\n",
        "            self.play(\n",
        "                in_func_ghost.animate.to_edge(UP, buff=MED_SMALL_BUFF),\n",
        "                FadeIn(ode, lag_ratio=0.1),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.add(ode_ghost)\n",
        "            self.play(LaggedStart(\n",
        "                (FadeOutToPoint(piece, machine.get_top() + 0.5 * DOWN, path_arc=arc)\n",
        "                for piece, arc in zip(ode, np.linspace(-70 * DEG, 70 * DEG, len(ode)))),\n",
        "                lag_ratio=0.05,\n",
        "                run_time=2\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "        # Result\n",
        "        out_func = Tex(R\"x({t}) = c_1 e^{s_1 {t}} + c_2 e^{s_2 {t}} + c_3 e^{s_3 {t}} + c_4 e^{s_4 {t}}\", t2c=t2c, font_size=72)\n",
        "        # out_func = Tex(R\"x({t}) = \\sum_{n=1}^N c_n e^{s_n {t}}\", t2c=t2c, font_size=72)\n",
        "        s_parts = out_func[re.compile(\"s_.\")]\n",
        "        c_parts = out_func[re.compile(\"c_.\")]\n",
        "        s_parts.set_color(YELLOW)\n",
        "        c_parts.set_color(GREY_A)\n",
        "        out_func.next_to(machine, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            (FadeInFromPoint(piece, machine.get_bottom() + 0.5 * UP, path_arc=arc)\n",
        "            for piece, arc in zip(out_func, np.linspace(-70 * DEG, 70 * DEG, len(out_func)))),\n",
        "            lag_ratio=0.05,\n",
        "            run_time=2\n",
        "        ))\n",
        "\n",
        "        # Make way for Laplace Transform words\n",
        "        if False:\n",
        "            # For an insert\n",
        "            text = Text(\"Laplace Transform\", font_size=72)\n",
        "            machine.set_z_index(0)\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    FadeOut(in_func_ghost, UP),\n",
        "                    FadeOut(ode_ghost, 2 * UP),\n",
        "                    FadeOut(out_func, DOWN),\n",
        "                    FadeTransform(fancy_L[0], text[0]),\n",
        "                    FadeIn(text[1:], lag_ratio=0.1),\n",
        "                    run_time=2,\n",
        "                    lag_ratio=0.2\n",
        "                ),\n",
        "                FadeOut(machine, scale=3, run_time=2)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Highlight s and c\n",
        "        s_rects = VGroup(SurroundingRectangle(part, buff=0.05) for part in s_parts)\n",
        "        c_rects = VGroup(SurroundingRectangle(part, buff=0.05) for part in c_parts)\n",
        "        s_rects.set_stroke(YELLOW, 2)\n",
        "        c_rects.set_stroke(WHITE, 2)\n",
        "\n",
        "        s_part_copies = s_parts.copy()\n",
        "        c_part_copies = c_parts.copy()\n",
        "\n",
        "        self.add(s_part_copies)\n",
        "        self.play(\n",
        "            Write(s_rects),\n",
        "            out_func.animate.set_opacity(0.75),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(s_rects, c_rects, lag_ratio=0.1),\n",
        "            FadeOut(s_part_copies),\n",
        "            FadeIn(c_part_copies),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(c_rects), out_func.animate.set_fill(opacity=1))\n",
        "        self.remove(c_part_copies)\n",
        "\n",
        "        # Ask about exponential pieces\n",
        "        mobs = Group(*self.mobjects)\n",
        "        randy = Randolph()\n",
        "        randy.move_to(5 * LEFT + 3 * DOWN, DL)\n",
        "        randy.look_at(out_func),\n",
        "        exp_piece = Tex(R\"e^{{s}{t}}\", t2c=t2c, font_size=90)\n",
        "        exp_piece.next_to(randy, UR, LARGE_BUFF).shift(0.5 * DOWN)\n",
        "        exp_piece.insert_submobject(2, VectorizedPoint(exp_piece[2].get_right()))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, mobs, run_time=2),\n",
        "            TransformFromCopy(out_func[\"e^{s_1 {t}}\"][0], exp_piece, run_time=2),\n",
        "            VFadeIn(randy, time_span=(0.5, 2.0)),\n",
        "            randy.change(\"confused\", exp_piece).set_anim_args(run_time=2),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        for mode in [\"pondering\", \"thinking\", \"tease\"]:\n",
        "            self.play(randy.change(mode, exp_piece))\n",
        "            self.play(Blink(randy))\n",
        "            self.wait(2)\n",
        "\n",
        "    def get_machine(self, width=1.5, height=2, color=GREY_D):\n",
        "        square = Rectangle(width, height)\n",
        "        in_tri = ArrowTip().set_height(0.5 * height)\n",
        "        in_tri.stretch(2, 1)\n",
        "        out_tri = in_tri.copy().rotate(PI)\n",
        "        in_tri.move_to(square.get_left())\n",
        "        out_tri.move_to(square.get_right())\n",
        "        machine = Union(square, in_tri, out_tri)\n",
        "        machine.set_fill(color, 1)\n",
        "        machine.set_stroke(WHITE, 2)\n",
        "        return machine\n",
        "\n",
        "\n",
        "class ExpDeriv(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        t2c = {\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "        lhs, rhs = terms = VGroup(\n",
        "            Tex(tex, t2c=t2c, font_size=90)\n",
        "            for tex in [R\"e^{{s}{t}}\", R\"{s} e^{{s}{t}}\"]\n",
        "        )\n",
        "        terms.arrange(RIGHT, buff=4)\n",
        "\n",
        "        arrows = VGroup(\n",
        "            Arrow(\n",
        "                lhs.get_corner(sign * UP + RIGHT),\n",
        "                rhs.get_corner(sign * UP + LEFT),\n",
        "                path_arc=-sign * 75 * DEG,\n",
        "                thickness=4\n",
        "            )\n",
        "            for sign in [1, -1]\n",
        "        )\n",
        "        arrows.set_fill(border_width=2)\n",
        "        arrows[1].shift(0.25 * DOWN)\n",
        "        arrow_labels = VGroup(\n",
        "            Tex(tex, t2c=t2c, font_size=60).next_to(arrow, vect)\n",
        "            for arrow, tex, vect in zip(arrows, [\"d / d{t}\", R\"\\times {s}\"], [UP, DOWN])\n",
        "        )\n",
        "        self.add(terms[0])\n",
        "        self.play(\n",
        "            TransformFromCopy(terms[0].copy(), terms[1][1:], path_arc=-75 * DEG),\n",
        "            Write(arrows[0], time_span=(0.5, 1.5)),\n",
        "            FadeIn(arrow_labels[0], lag_ratio=0.1),\n",
        "            run_time=1.5,\n",
        "        )\n",
        "        self.play(FadeTransform(terms[1][2].copy(), terms[1][0], path_arc=90 * DEG, run_time=0.75))\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(*arrows),\n",
        "            TransformFromCopy(*arrow_labels),\n",
        "        ))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class IntroduceTransform(SPlane):\n",
        "    long_ambient_graph_display = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Write \"Laplace Transform\"\n",
        "        text = Text(\"Laplace Transform\", font_size=72)\n",
        "        laplace_word = text[\"Laplace\"][0]\n",
        "        transform_word = text[\"Transform\"][0]\n",
        "        laplace_transform_word = VGroup(laplace_word, transform_word)\n",
        "        transform_word_rect = SurroundingRectangle(transform_word, buff=SMALL_BUFF)\n",
        "        randy = Randolph().flip()\n",
        "        randy.next_to(laplace_transform_word, DR)\n",
        "        q_marks = Tex(R\"???\", font_size=72).space_out_submobjects(1.5)\n",
        "        q_marks.next_to(transform_word_rect, UP)\n",
        "        q_marks.set_color(YELLOW)\n",
        "\n",
        "        self.add(laplace_transform_word)\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            VFadeIn(randy),\n",
        "            randy.change(\"confused\", transform_word),\n",
        "            ShowCreation(transform_word_rect),\n",
        "            laplace_word.animate.set_opacity(0.5),\n",
        "            LaggedStartMap(FadeIn, q_marks, shift=0.5 * UP, lag_ratio=0.25),\n",
        "            lag_ratio=0.1\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show a function with an arrow\n",
        "        t2c = {\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "        name_group = VGroup(laplace_transform_word, transform_word_rect, q_marks)\n",
        "        name_group.target = name_group.generate_target(use_deepcopy=True)\n",
        "        name_group.target[2].set_fill(opacity=0).move_to(transform_word_rect)\n",
        "        name_group.target.scale(0.5).to_edge(UP)\n",
        "        name_group.target[1].set_stroke(width=0)\n",
        "\n",
        "        mapsto = Tex(R\"\\xmapsto{\\qquad}\", additional_preamble=R\"\\usepackage{mathtools}\")\n",
        "        mapsto.rotate(-90 * DEG)\n",
        "        mapsto.set_fill(border_width=2)\n",
        "\n",
        "        t_mob, _, ft_mob = func_group = VGroup(Tex(R\"{t}\", t2c=t2c), mapsto, Tex(R\"f({t})\", t2c=t2c))\n",
        "        func_group.arrange(DOWN)\n",
        "        func_name = Text(\"function\")\n",
        "        func_name.next_to(mapsto, LEFT, SMALL_BUFF)\n",
        "\n",
        "        mapsto.save_state()\n",
        "        mapsto.stretch(0, 1, about_edge=UP).set_fill(opacity=0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(name_group),\n",
        "            randy.change(\"pondering\", func_group),\n",
        "            FadeIn(func_name, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(mapsto),\n",
        "            FadeIn(t_mob, 0.1 * UP)\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            TransformFromCopy(t_mob, ft_mob[2], path_arc=45 * DEG, run_time=1),\n",
        "            FadeTransform(func_name[0].copy(), ft_mob[0], path_arc=45 * DEG, run_time=1),\n",
        "            Write(ft_mob[1::2]),\n",
        "            lag_ratio=0.25,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show the meta-notion\n",
        "        func_group.generate_target()\n",
        "        func_group.target.arrange(DOWN)\n",
        "        func_group.target.move_to(4 * LEFT)\n",
        "\n",
        "        braces = VGroup(\n",
        "            Brace(func_group.target, direction, SMALL_BUFF).scale(1.25, about_point=func_group.target.get_center())\n",
        "            for direction in [LEFT, RIGHT]\n",
        "        )\n",
        "        braces.save_state()\n",
        "        braces.set_opacity(0)\n",
        "        for brace in braces:\n",
        "            brace.replace(func_group, dim_to_match=1)\n",
        "\n",
        "        short_func_name = Tex(R\"f\")\n",
        "        short_func_name.next_to(func_group.target[1], LEFT, buff=0)\n",
        "\n",
        "        right_arrow = Vector(3 * RIGHT, thickness=6)\n",
        "        right_arrow.next_to(braces.saved_state, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(func_group),\n",
        "            Restore(braces),\n",
        "            LaggedStart(\n",
        "                [FadeTransform(func_name[0], short_func_name)] + [\n",
        "                    char.animate.set_opacity(0).replace(short_func_name)\n",
        "                    for char in func_name[1:]\n",
        "                ],\n",
        "                lag_ratio=0.02,\n",
        "                remover=True\n",
        "            ),\n",
        "            GrowArrow(right_arrow),\n",
        "            lag_ratio=0.05\n",
        "        ))\n",
        "        self.play(transform_word.animate.scale(1.5).next_to(right_arrow, UP))\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Show output function\n",
        "        f_group = VGroup(braces, t_mob, short_func_name, mapsto, ft_mob)\n",
        "        F_braces, s_mob, F_mob, right_mapsto, Fs_mob = F_group = VGroup(\n",
        "            braces.copy(),\n",
        "            Tex(R\"{s}\", t2c=t2c),\n",
        "            Tex(R\"F\"),\n",
        "            mapsto.copy(),\n",
        "            Tex(R\"F({s})\", t2c=t2c),\n",
        "        )\n",
        "        for mob1, mob2 in zip(f_group, F_group):\n",
        "            mob2.move_to(mob1)\n",
        "        F_group[2].shift(SMALL_BUFF * LEFT)\n",
        "\n",
        "        F_group.next_to(right_arrow, RIGHT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(*pair, path_arc=-60 * DEG)\n",
        "                for pair in zip(f_group, F_group)),\n",
        "                lag_ratio=0.025,\n",
        "                # run_time=1.5\n",
        "                run_time=8\n",
        "            ),\n",
        "            randy.change(\"tease\").scale(0.75).to_corner(DR),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Talk through parts\n",
        "        rect = SurroundingRectangle(F_group[-1][\"F\"], buff=0.05)\n",
        "        rect.set_stroke(RED, 3)\n",
        "        vect = Vector(0.5 * UP, thickness=4)\n",
        "        vect.set_color(RED)\n",
        "        vect.next_to(rect, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(laplace_word.animate.set_fill(opacity=1).scale(1.5).next_to(transform_word, UP, MED_SMALL_BUFF, LEFT))\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            GrowArrow(vect),\n",
        "            randy.change(\"pondering\", rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(f_group[-1][0], buff=0.05),\n",
        "            MaintainPositionRelativeTo(vect, rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            rect.animate.surround(f_group[1], buff=0.05).set_anim_args(path_arc=-90 * DEG),\n",
        "            vect.animate.rotate(PI).next_to(f_group[1], UP, SMALL_BUFF).set_anim_args(path_arc=-90 * DEG),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(F_group[1], buff=0.05).set_anim_args(path_arc=-90 * DEG),\n",
        "            MaintainPositionRelativeTo(vect, rect),\n",
        "            randy.animate.look_at(F_group),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(vect), FadeOut(rect))\n",
        "\n",
        "        # Show Laplace Transform expression\n",
        "        lt_def = Tex(R\"\\int^\\infty_0 f({t}) e^{\\minus {s}{t}} d{t}\", t2c=t2c)\n",
        "        lt_def.move_to(Fs_mob, LEFT)\n",
        "        new_interior = VGroup(s_mob, F_mob, right_mapsto, lt_def)\n",
        "        F_braces.generate_target()\n",
        "        F_braces.target.set_height(new_interior.get_height() + MED_LARGE_BUFF, stretch=True)\n",
        "        F_braces.target.match_y(right_arrow)\n",
        "        F_braces.target[1].next_to(new_interior, RIGHT).match_y(F_braces.target[0])\n",
        "\n",
        "        q_marks = Tex(R\"???\").set_color(YELLOW)\n",
        "        q_marks.next_to(randy, UP, SMALL_BUFF).shift(0.25 * RIGHT + 0.5 * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(Fs_mob),\n",
        "            Write(lt_def),\n",
        "            randy.change(\"pleading\").scale(0.75, about_edge=DR),\n",
        "            FadeIn(q_marks, 0.1 * UP, lag_ratio=0.1),\n",
        "            MoveToTarget(F_braces),\n",
        "            new_interior[:3].animate.match_x(lt_def).shift(0.1 * UP),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Discuss expression\n",
        "        rect = SurroundingRectangle(lt_def)\n",
        "        rect.set_stroke(YELLOW, 2)\n",
        "\n",
        "        s_vect = Vector(0.25 * DOWN)\n",
        "        s_vect.set_fill(YELLOW)\n",
        "        s_vect.next_to(lt_def[\"{s}\"][0], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            randy.change('confused')\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(rect, s_vect.copy().match_style(rect)),\n",
        "            FadeIn(s_vect, time_span=(0.75, 1)),\n",
        "        )\n",
        "        self.play(\n",
        "            randy.change(\"pondering\", s_vect),\n",
        "            FadeOut(q_marks),\n",
        "            FadeOut(rect),\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "        # Show F(s) left hand side\n",
        "        F_lhs = Tex(R\"F({s}) = \", t2c=t2c)\n",
        "        F_lhs.move_to(lt_def, LEFT)\n",
        "\n",
        "        right_shift = F_lhs.get_width() * RIGHT\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(s_mob, F_lhs[\"{s}\"][0]),\n",
        "            TransformFromCopy(F_mob, F_lhs[\"F\"][0]),\n",
        "            Write(F_lhs[re.compile(r\"\\(|\\)|=\")]),\n",
        "            lt_def.animate.shift(right_shift),\n",
        "            MaintainPositionRelativeTo(s_vect, lt_def),\n",
        "            F_braces[1].animate.shift(right_shift),\n",
        "            new_interior[:3].animate.shift(right_shift + 0.1 * UP),\n",
        "            randy.animate.shift(0.5 * DOWN),\n",
        "            self.frame.animate.shift(0.5 * DOWN),\n",
        "        )\n",
        "\n",
        "        # Reference the naming convention\n",
        "        F_rect = SurroundingRectangle(F_lhs[0], buff=0.05)\n",
        "        F_rect.set_stroke(RED, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(F_rect),\n",
        "            s_vect.animate.next_to(F_rect, UP, SMALL_BUFF).set_color(RED)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            F_rect.animate.surround(ft_mob[0], buff=0.05),\n",
        "            s_vect.animate.next_to(ft_mob[0], UP, SMALL_BUFF),\n",
        "            randy.animate.look_at(ft_mob)\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(F_rect), FadeOut(s_vect))\n",
        "\n",
        "        # Clear the board\n",
        "        lt_group = VGroup(F_lhs, lt_def)\n",
        "\n",
        "        self.remove(lt_group)\n",
        "        everything = Group(*self.get_mobjects())\n",
        "        everything.sort(lambda p: np.dot(p, UL))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, everything, shift=0.1 * DOWN, lag_ratio=0.1),\n",
        "            lt_group.animate.center().set_height(2),\n",
        "            self.frame.animate.to_default_state(),\n",
        "            run_time=2,\n",
        "        )\n",
        "\n",
        "        # Highlight inner part\n",
        "        outer_part = VGroup(lt_def[R\"\\int^\\infty_0\"][0], lt_def[R\"d{t}\"][0])\n",
        "        inner_part = lt_def[R\"f({t}) e^{\\minus {s}{t}}\"][0]\n",
        "\n",
        "        rect = SurroundingRectangle(inner_part, buff=SMALL_BUFF)\n",
        "        outer_rects = VGroup(SurroundingRectangle(piece, buff=SMALL_BUFF) for piece in outer_part)\n",
        "        VGroup(rect, outer_rects).set_stroke(RED, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            outer_part.animate.set_fill(opacity=0.2),\n",
        "            F_lhs.animate.set_fill(opacity=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            # TransformFromCopy(rect.replicate(2), outer_rects),\n",
        "            rect.animate.surround(outer_part, buff=SMALL_BUFF),\n",
        "            outer_part.animate.set_fill(opacity=1),\n",
        "            inner_part.animate.set_fill(opacity=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Put at the top\n",
        "        lt_group = VGroup(F_lhs, outer_part, inner_part)\n",
        "        lt_group.target = lt_group.generate_target()\n",
        "        lt_group.target.set_height(1.2).to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        lt_group.target[:2].set_fill(opacity=0.2)\n",
        "        lt_group.target[2].set_fill(opacity=1)\n",
        "\n",
        "        lt_group.target.set_fill(opacity=1)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(lt_group),\n",
        "            # rect.animate.surround(lt_group.target[2]).set_stroke(width=1),\n",
        "            rect.animate.surround(lt_group.target).set_stroke(width=0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            rect.animate.surround(lt_def[\"s\"][0], buff=0.05).set_stroke(YELLOW)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show s as a complex number\n",
        "        plane = ComplexPlane((-3, 3), (-3, 3))\n",
        "        plane.next_to(lt_group, DOWN)\n",
        "        plane.add_coordinate_labels(font_size=16)\n",
        "\n",
        "        s_dot = Group(TrueDot(), GlowDot()).set_color(YELLOW)\n",
        "        s_dot.move_to(plane.n2p(2 + 1j))\n",
        "        s_label = Tex(R\"s\").set_color(YELLOW)\n",
        "        s_label.always.next_to(s_dot[0], UR, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            Write(plane, lag_ratio=1e-2),\n",
        "            TransformFromCopy(lt_def[\"s\"][0], s_label),\n",
        "            FadeInFromPoint(s_dot, rect.get_center()),\n",
        "            FadeOut(rect),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Wander\n",
        "        final_z = -2 + 1j\n",
        "        n_iterations = 12\n",
        "        for n in range(12):\n",
        "            z = complex(*np.random.uniform(-3, 3, 2))\n",
        "            if n == n_iterations - 1:\n",
        "                z = final_z\n",
        "            self.play(s_dot.animate.move_to(plane.n2p(z)).set_anim_args(path_arc=45 * DEG))\n",
        "            self.wait()\n",
        "\n",
        "        # Plug in cos(t)\n",
        "        lt_def.refresh_bounding_box()\n",
        "        lt_of_cos = Tex(lt_def.get_tex().replace(\"f({t})\", R\"\\cos({t})\"), t2c=t2c)\n",
        "        lt_of_cos.move_to(lt_def, LEFT)\n",
        "        cos_lt_group = VGroup(\n",
        "            F_lhs,\n",
        "            VGroup(lt_of_cos[R\"\\int^\\infty_0\"][0], lt_of_cos[R\"d{t}\"][0]),\n",
        "            lt_of_cos[R\"\\cos({t}) e^{\\minus {s}{t}}\"][0]\n",
        "        )\n",
        "        cos_lt_group[1].set_fill(opacity=0.2)\n",
        "\n",
        "        imag_circles = VGroup(\n",
        "            Dot(plane.n2p(z)).set_stroke(YELLOW, 1).set_fill(opacity=0.25)\n",
        "            for z in [1j, -1j]\n",
        "        )\n",
        "\n",
        "        f_term = lt_def[\"f\"][-1]\n",
        "        cos_term = lt_of_cos[R\"\\cos\"][0]\n",
        "        f_rect = SurroundingRectangle(f_term, buff=0.05)\n",
        "        f_rect.set_stroke(PINK, 2)\n",
        "\n",
        "        self.play(ShowCreation(f_rect))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                lt_def,\n",
        "                lt_of_cos,\n",
        "                matched_pairs=[(f_term, cos_term)],\n",
        "                run_time=1\n",
        "            ),\n",
        "            f_rect.animate.surround(cos_term, buff=0.05),\n",
        "            F_lhs.animate.shift((lt_of_cos.get_width() - lt_def.get_width()) * 0.5 * LEFT),\n",
        "            *map(ShowCreation, imag_circles),\n",
        "        )\n",
        "        self.play(FadeOut(f_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Create the graph\n",
        "        frame = self.frame\n",
        "        frame.to_default_state()\n",
        "        cos_lt_group.fix_in_frame()\n",
        "        self.add(cos_lt_group)\n",
        "\n",
        "        graph = get_complex_graph(\n",
        "            plane,\n",
        "            lambda s: s / (s**2 + 1),\n",
        "            resolution=(501, 501),\n",
        "            mesh_resolution=(31, 31)\n",
        "        )\n",
        "        graph.stretch(0.25, 2, about_point=plane.n2p(0))\n",
        "\n",
        "        # Show the graph\n",
        "        self.play(\n",
        "            cos_lt_group.animate.to_edge(LEFT, buff=MED_SMALL_BUFF).set_fill(opacity=1),\n",
        "            ShowCreation(graph[0]),\n",
        "            Write(graph[1], stroke_width=1, time_span=(2, 4)),\n",
        "            frame.animate.reorient(-28, 74, 0, OUT, 8.37),\n",
        "            run_time=4,\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        frame.add_ambient_rotation()\n",
        "        for z in [1j, -1j]:\n",
        "            self.play(s_dot.animate.move_to(plane.n2p(z)), run_time=2)\n",
        "            self.wait(2)\n",
        "\n",
        "        # Long ambient graph rotation (one branch here)\n",
        "        if self.long_ambient_graph_display:\n",
        "            self.remove(cos_lt_group)\n",
        "            self.wait(19)\n",
        "            self.add(imag_circles, graph)\n",
        "            self.play(FadeOut(graph), FadeOut(imag_circles))\n",
        "            frame.clear_updaters()\n",
        "            s_plane = plane\n",
        "            s_plane.save_state()\n",
        "            s_plane.set_height(3.5)\n",
        "            s_plane.to_corner(UR, buff=MED_SMALL_BUFF).shift(LEFT)\n",
        "            s_plane.background_lines.set_stroke(BLUE, 1, 1)\n",
        "            s_plane.target = s_plane.copy()\n",
        "\n",
        "            s_dot.target = s_dot.generate_target()\n",
        "            s_dot.target.move_to(s_plane.n2p(0.2 + 2j))\n",
        "\n",
        "            s_plane.restore()\n",
        "            self.play(\n",
        "                frame.animate.to_default_state(),\n",
        "                MoveToTarget(s_plane),\n",
        "                MoveToTarget(s_dot),\n",
        "                run_time=2\n",
        "            )\n",
        "\n",
        "        # Remove graphs\n",
        "        self.remove(plane, graph, s_dot, s_label, imag_circles)\n",
        "        frame.to_default_state()\n",
        "        frame.clear_updaters()\n",
        "\n",
        "        # Ignore the integral\n",
        "        interior = cos_lt_group[2]\n",
        "        interior_rect = SurroundingRectangle(interior, buff=0.05)\n",
        "        interior_rect.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.add(interior)\n",
        "        self.play(\n",
        "            ShowCreation(interior_rect),\n",
        "            cos_lt_group[:2].animate.set_fill(opacity=0.2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Replace break down cos(t) with exponentials\n",
        "        arrow = Vector(DOWN)\n",
        "        arrow.match_color(interior_rect)\n",
        "        arrow.next_to(interior_rect, DOWN, SMALL_BUFF)\n",
        "        expanded = Tex(\n",
        "            R\"\\frac{1}{2} \\left(e^{i{t}} + e^{\\minus i{t}} \\right) e^{\\minus{s}{t}}\",\n",
        "            t2c={\"i\": WHITE, \"-i\": WHITE, **t2c},\n",
        "        )\n",
        "        expanded.next_to(arrow, DOWN, MED_LARGE_BUFF)\n",
        "        expanded_brace = Brace(expanded, UP, SMALL_BUFF)\n",
        "        expanded_brace.set_color(TEAL)\n",
        "\n",
        "        index = -4\n",
        "        self.play(\n",
        "            FadeTransform(interior[:index].copy(), expanded[:index]),\n",
        "            TransformFromCopy(interior[index:], expanded[index:]),\n",
        "            GrowArrow(arrow),\n",
        "            FadeInFromPoint(expanded_brace, arrow.get_start()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Focus on just part\n",
        "        eit, est = pair = VGroup(expanded[\"e^{i{t}}\"][0], expanded[R\"e^{\\minus{s}{t}}\"][0])\n",
        "        pair_rects = VGroup(SurroundingRectangle(p, buff=0.05) for p in pair)\n",
        "        pair_rects.set_stroke(BLUE, 2)\n",
        "        pair_copy = pair.copy()\n",
        "\n",
        "        self.add(pair_copy),\n",
        "        self.play(\n",
        "            expanded.animate.set_fill(opacity=0.5),\n",
        "            ShowCreation(pair_rects, lag_ratio=0.5)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Combine\n",
        "        combined_term = Tex(R\"e^{(i - {s}){t}}\", t2c=t2c)\n",
        "        combined_term.next_to(pair, DOWN, LARGE_BUFF)\n",
        "        comb_arrows = VGroup(Arrow(p, combined_term, buff=0.25, thickness=2) for p in pair)\n",
        "        comb_arrows.set_fill(BLUE)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(pair.copy(), combined_term),\n",
        "            *map(GrowArrow, comb_arrows),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pull up s-plane and output plane\n",
        "        s_plane = plane\n",
        "        s_plane.set_height(3.5)\n",
        "        s_plane.to_corner(UR, buff=MED_SMALL_BUFF).shift(LEFT)\n",
        "        s_plane.background_lines.set_stroke(BLUE, 1, 1)\n",
        "\n",
        "        s_tracker = ComplexValueTracker(0.2 + 2j)\n",
        "        t_tracker = ValueTracker(0)\n",
        "        get_s = s_tracker.get_value\n",
        "        get_t = t_tracker.get_value\n",
        "\n",
        "        def get_ims():\n",
        "            return 1j - get_s()\n",
        "\n",
        "        s_dot.add_updater(lambda m: m.move_to(s_plane.n2p(get_s())))\n",
        "\n",
        "        exp_plane = self.get_exp_plane()\n",
        "        exp_plane.set_height(3.5)\n",
        "        exp_plane.next_to(s_plane, DOWN, MED_LARGE_BUFF)\n",
        "        output_label = self.get_output_dot_and_label(\n",
        "            exp_plane,\n",
        "            get_s=get_ims,\n",
        "            get_t=get_t,\n",
        "            s_tex=\"(i - {s})\"\n",
        "        )\n",
        "        output_path = self.get_output_path(exp_plane, get_t, get_ims)\n",
        "\n",
        "        self.play(FadeIn(s_plane), FadeIn(s_dot), FadeIn(s_label))\n",
        "        self.play(\n",
        "            FadeIn(exp_plane),\n",
        "            FadeTransform(combined_term.copy(), output_label[1]),\n",
        "            FadeIn(output_label[0]),\n",
        "        )\n",
        "        self.add(output_path)\n",
        "        self.play(t_tracker.animate.set_value(2 * TAU), rate_func=linear, run_time=10)\n",
        "        self.play(s_tracker.animate.increment_value(-0.3), rate_func=there_and_back, run_time=4)\n",
        "        self.play(s_tracker.animate.set_value(0.2), run_time=4)\n",
        "        self.play(s_tracker.animate.set_value(1j), run_time=4)\n",
        "        self.wait()\n",
        "\n",
        "        # Let t play\n",
        "        eq_i_rhs = Tex(R\"= i\")\n",
        "        eq_i_rhs.next_to(s_label, RIGHT, SMALL_BUFF).shift(0.04 * UP)\n",
        "        self.play(Write(eq_i_rhs), run_time=1)\n",
        "\n",
        "        t_tracker.set_value(0)\n",
        "        self.play(t_tracker.animate.set_value(20), run_time=20, rate_func=linear)\n",
        "\n",
        "        # Show s = i\n",
        "        down_arrow = Vector(0.75 * DOWN)\n",
        "        down_arrow.next_to(combined_term, DOWN, SMALL_BUFF)\n",
        "        arrow_label = Tex(R\"{s} = i\", font_size=24, t2c=t2c)\n",
        "        arrow_label.next_to(down_arrow, RIGHT, buff=0)\n",
        "        const = Tex(R\"e^{0{t}}\", t2c=t2c)\n",
        "        const.next_to(down_arrow, DOWN, SMALL_BUFF)\n",
        "        eq_1 = Tex(R\"= 1\")\n",
        "        eq_1.next_to(const, RIGHT, SMALL_BUFF, aligned_edge=DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(down_arrow),\n",
        "            FadeIn(arrow_label),\n",
        "            FadeIn(const, DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(eq_1, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "        # Move around s\n",
        "        s_tracker.clear_updaters()\n",
        "        t_tracker.set_value(100)\n",
        "        output_label.clear_updaters()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(eq_i_rhs),\n",
        "            FadeOut(output_label),\n",
        "        )\n",
        "\n",
        "        self.play()\n",
        "        for _ in range(6):\n",
        "            self.play(\n",
        "                s_tracker.animate.set_value(complex(random.uniform(-0.1, 0.5), random.uniform(-3, 3))),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(s_tracker.animate.set_value(1j), run_time=2)\n",
        "        self.remove(output_path)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        # State the goal\n",
        "        big_rect = SurroundingRectangle(expanded[:-4])\n",
        "        big_rect.set_stroke(BLUE, 2)\n",
        "        goal = Text(\"Goal:\\nReveal these terms\", alignment=\"LEFT\")\n",
        "        goal.next_to(big_rect, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(pair_rects, VGroup(big_rect)),\n",
        "            LaggedStartMap(FadeOut, VGroup(comb_arrows, combined_term, down_arrow, arrow_label, const, eq_1)),\n",
        "            FadeOut(Group(exp_plane, s_plane, s_label, s_dot)),\n",
        "            expanded.animate.set_fill(opacity=1),\n",
        "        )\n",
        "        self.play(FadeIn(goal, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(goal),\n",
        "            big_rect.animate.surround(expanded),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight the integral again\n",
        "        self.add(expanded)\n",
        "        self.remove(pair_copy)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, VGroup(interior_rect, arrow, expanded_brace, expanded, big_rect)),\n",
        "            cos_lt_group.animate.set_fill(opacity=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleToComplex(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add key expressions\n",
        "        t2c = {\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "        terms = VGroup(\n",
        "            Tex(R\"f({t}) = 1\", t2c=t2c),\n",
        "            Tex(R\"f({t}) = e^{at}\", t2c=t2c),\n",
        "            Tex(R\"f({t}) = \\sum_{n=1}^N c_n e^{s_n {t}}\", t2c=t2c),\n",
        "        )\n",
        "        terms.scale(1.5)\n",
        "        terms.arrange(DOWN, buff=1.5)\n",
        "        arrows = VGroup(\n",
        "            Arrow(*pair, buff=0.25, thickness=5)\n",
        "            for pair in zip(terms, terms[1:])\n",
        "        )\n",
        "        terms[2].shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.add(terms[0])\n",
        "        for arrow, term1, term2 in zip(arrows, terms, terms[1:]):\n",
        "            self.play(\n",
        "                TransformMatchingTex(\n",
        "                    term1.copy(),\n",
        "                    term2,\n",
        "                    key_map={\"1\": \"e^{at}\", \"a\": \"s_n\"}\n",
        "                ),\n",
        "                GrowArrow(arrow),\n",
        "                run_time=1\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Set up Laplace Transforms\n",
        "        lt_left_x = terms.get_x(RIGHT) + 3\n",
        "        lt_arrows = VGroup(\n",
        "            Arrow(\n",
        "                term.get_right(),\n",
        "                lt_left_x * RIGHT + term.get_y() * UP,\n",
        "                buff=0.5,\n",
        "                thickness=6\n",
        "            )\n",
        "            for term in terms\n",
        "        )\n",
        "        lt_arrows.set_color(GREY_A)\n",
        "        lt_arrow_labels = VGroup(\n",
        "            Tex(R\"\\mathcal{L}\").next_to(arrow, UP, buff=0)\n",
        "            for arrow in lt_arrows\n",
        "        )\n",
        "        lt_integrals = VGroup(\n",
        "            Tex(\n",
        "                R\"\\int^\\infty_0 \" + tex + R\"\\cdot e^{\\minus{s}{t}}d{t}\",\n",
        "                t2c=t2c\n",
        "            )\n",
        "            for tex in [\"1\", \"e^{a{t}}\", R\"\\sum_{n=1}^N c_n e^{s_n {t}}\"]\n",
        "        )\n",
        "        lt_rhss = VGroup(\n",
        "            Tex(R\"= \\frac{1}{{s}}\", t2c=t2c),\n",
        "            Tex(R\"= \\frac{1}{{s} - a}\", t2c=t2c),\n",
        "            Tex(R\"= \\sum_{n=1}^N \\frac{c_n}{{s} - s_n}\", t2c=t2c),\n",
        "        )\n",
        "        for integral, arrow, rhs in zip(lt_integrals, lt_arrows, lt_rhss):\n",
        "            integral.next_to(arrow, RIGHT)\n",
        "            rhs.scale(1.25)\n",
        "            rhs.next_to(integral, RIGHT)\n",
        "\n",
        "        # Show laplace transforms\n",
        "        frame = self.frame\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                GrowArrow(lt_arrows[0]),\n",
        "                Write(lt_arrow_labels[0]),\n",
        "                FadeIn(lt_integrals[0], RIGHT),\n",
        "                lag_ratio=0.3\n",
        "            ),\n",
        "            terms[1:].animate.set_fill(opacity=0.1),\n",
        "            arrows.animate.set_fill(opacity=0.1),\n",
        "            frame.animate.set_x(4),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(lt_rhss[0]))\n",
        "        self.wait()\n",
        "        for index in [1, 2]:\n",
        "            self.play(\n",
        "                arrows[index - 1].animate.set_fill(opacity=1),\n",
        "                terms[index].animate.set_fill(opacity=1),\n",
        "            )\n",
        "            self.play(\n",
        "                LaggedStart(\n",
        "                    GrowArrow(lt_arrows[index]),\n",
        "                    Write(lt_arrow_labels[index]),\n",
        "                    FadeIn(lt_integrals[index], RIGHT),\n",
        "                    lag_ratio=0.3\n",
        "                ),\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(Write(lt_rhss[index]))\n",
        "            self.wait()\n",
        "        self.play(frame.reorient(0, 0, 0, (5.5, 0.04, 0.0), 10), run_time=2)\n",
        "\n",
        "\n",
        "class SetSToMinus1(InteractiveScene):\n",
        "    def construct(self):\n",
        "        eq = Tex(R\"\\frac{1}{\\minus 1} = \\minus 1\")\n",
        "        eq[R\"\\minus 1\"][0].set_color(YELLOW)\n",
        "        self.play(Write(eq))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RealExtension(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show limited domain\n",
        "        axes = Axes((-1, 10), (-1, 5), width=FRAME_WIDTH - 1, height=6)\n",
        "        self.add(axes)\n",
        "\n",
        "        def func(x):\n",
        "            decay = math.exp(-0.05 * (x + 1))\n",
        "            poly = -0.003 * x**3 - 0.2 * (0.15 * x)**2 + 0.2 * x\n",
        "            return (decay + 0.5) * (math.cos(1.0 * x) + 1.5) + poly\n",
        "\n",
        "        limited_domain = (2, 6)\n",
        "\n",
        "        partial_graph = axes.get_graph(func, x_range=limited_domain)\n",
        "        partial_graph.set_stroke(BLUE, 5)\n",
        "        f_label = Tex(R\"f(x)\")\n",
        "        f_label.next_to(partial_graph.get_end(), UL)\n",
        "\n",
        "        limited_domain_line = Line(\n",
        "            axes.c2p(limited_domain[0], 0),\n",
        "            axes.c2p(limited_domain[1], 0),\n",
        "        )\n",
        "        limited_domain_line.set_stroke(BLUE, 5)\n",
        "        limited_domain_words = Text(\"Limited Domain\")\n",
        "        limited_domain_words.next_to(limited_domain_line, UP, SMALL_BUFF)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.play(\n",
        "            ShowCreation(partial_graph),\n",
        "            Write(f_label)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(limited_domain_line),\n",
        "            FadeIn(limited_domain_words, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(TransformFromCopy(limited_domain_line, partial_graph))\n",
        "        self.wait()\n",
        "\n",
        "        # Extend the graph\n",
        "        points = partial_graph.get_anchors()\n",
        "\n",
        "        def get_extension(nudge_size=0):\n",
        "            pre_xs = np.arange(1, -2, -1)\n",
        "            post_xs = np.arange(7, 11)\n",
        "            result = VGroup(\n",
        "                self.get_extension(axes, points[3::-1], pre_xs, func, nudge_size=nudge_size),\n",
        "                self.get_extension(axes, points[-4:], post_xs, func, nudge_size=nudge_size),\n",
        "            )\n",
        "            result[0].set_clip_plane(LEFT, axes.c2p(limited_domain[0], 0)[0])\n",
        "            result[1].set_clip_plane(RIGHT, -axes.c2p(limited_domain[1], 0)[0])\n",
        "            return result\n",
        "\n",
        "        extension = get_extension()\n",
        "        self.play(ShowCreation(extension, lag_ratio=0, run_time=4))\n",
        "\n",
        "        # Change around\n",
        "        extension.save_state()\n",
        "        for n in range(5):\n",
        "            new_extension = get_extension(nudge_size=3)\n",
        "            self.play(extension.animate.become(new_extension), run_time=1)\n",
        "        self.play(Restore(extension))\n",
        "\n",
        "        # Show a derivative\n",
        "        x_tracker = ValueTracker(limited_domain[0])\n",
        "        tan_line = always_redraw(lambda : axes.get_tangent_line(\n",
        "            x_tracker.get_value(), partial_graph, length=2\n",
        "        ).set_stroke(WHITE, 3))\n",
        "\n",
        "        self.play(GrowFromCenter(tan_line, suspend_mobject_updating=True))\n",
        "        self.play(x_tracker.animate.set_value(limited_domain[1]), run_time=5)\n",
        "        self.play(FadeOut(tan_line, suspend_mobject_updating=True))\n",
        "\n",
        "        # Wiggly spaghetti\n",
        "        def tweaked_func(x):\n",
        "            x0, x1 = limited_domain\n",
        "            if x < x0:\n",
        "                return func(x) + 0.5 * (x - x0)**2\n",
        "            elif x < x1:\n",
        "                return func(x)\n",
        "            else:\n",
        "                return func(x) - 0.5 * (x - x1)**2\n",
        "\n",
        "        full_graph = axes.get_graph(func)\n",
        "        modifed_graph = axes.get_graph(tweaked_func)\n",
        "\n",
        "        group = VGroup(full_graph, modifed_graph)\n",
        "        group.set_stroke(RED, 5)\n",
        "        group.set_z_index(-1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(extension),\n",
        "            FadeIn(full_graph),\n",
        "        )\n",
        "        self.play(\n",
        "            full_graph.animate.become(modifed_graph),\n",
        "            rate_func=lambda t: wiggle(t, 5),\n",
        "            run_time=8\n",
        "        )\n",
        "\n",
        "    def get_extension(self, axes, pre_start, xs, func, nudge_size=0, stroke_width=5, stroke_color=RED):\n",
        "        ys = np.array([func(x) + (nudge_size * (random.random() - 0.5)) for x in xs])\n",
        "        new_points = axes.c2p(xs, ys)\n",
        "\n",
        "        result = VMobject()\n",
        "        result.set_points_smoothly([*pre_start, *new_points], approx=False)\n",
        "        result.insert_n_curves(100)\n",
        "\n",
        "        result.set_stroke(stroke_color, stroke_width)\n",
        "        result.set_z_index(-1)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ComplexExtension(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up input and output planes\n",
        "        input_plane, output_plane = planes = VGroup(\n",
        "            ComplexPlane((-3, 3), (-3, 3))\n",
        "            for n in range(2)\n",
        "        )\n",
        "        planes.set_height(5)\n",
        "        planes.arrange(RIGHT, buff=1.5)\n",
        "        for plane in planes:\n",
        "            plane.axes.set_stroke(WHITE, 1, 1)\n",
        "            plane.background_lines.set_stroke(BLUE, 1, 0.5)\n",
        "            plane.faded_lines.set_stroke(BLUE, 0.5, 0.25)\n",
        "\n",
        "        self.add(planes)\n",
        "\n",
        "        # Set up limited domain\n",
        "        domain = self.get_rect_group(2, 1, input_plane, 0.2 + 0.2j)\n",
        "        domain.set_z_index(2)\n",
        "        self.add(domain)\n",
        "\n",
        "        # Show a mapping\n",
        "        def func(z):\n",
        "            return -0.05j * z**3\n",
        "\n",
        "        def point_func(points):\n",
        "            return np.array([\n",
        "                output_plane.n2p(func(input_plane.p2n(p)))\n",
        "                for p in points\n",
        "            ])\n",
        "\n",
        "        mapped_domain = domain.copy().apply_points_function(point_func, about_edge=None)\n",
        "        mapped_domain.set_z_index(2)\n",
        "\n",
        "        arrow = Arrow(\n",
        "            domain.get_top(),\n",
        "            mapped_domain.get_top(),\n",
        "            path_arc=-90 * DEG,\n",
        "            fill_color=TEAL,\n",
        "            thickness=5\n",
        "        )\n",
        "        arrow.set_z_index(1)\n",
        "        func_label = Tex(R\"f(z)\")\n",
        "        func_label.next_to(arrow, UP, SMALL_BUFF)\n",
        "        func_label.set_backstroke()\n",
        "\n",
        "        self.play(\n",
        "            Write(arrow, time_span=(0, 1)),\n",
        "            Write(func_label, time_span=(0.5, 1.5)),\n",
        "            ReplacementTransform(\n",
        "                domain.copy().set_fill(opacity=0),\n",
        "                mapped_domain,\n",
        "                path_arc=-90 * DEG,\n",
        "                run_time=3\n",
        "            )\n",
        "        )\n",
        "\n",
        "        # Show the extension\n",
        "        dark_red = interpolate_color(RED_E, BLACK, 0.5)\n",
        "        extension = self.get_extended_domain(input_plane, domain, 4, 2, corner_value=-1, color=dark_red)\n",
        "        mapped_extension = extension.copy().apply_points_function(point_func, about_edge=None)\n",
        "\n",
        "        self.play(Write(extension, run_time=1, lag_ratio=1e-2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(extension.copy().set_fill(opacity=0), mapped_extension, path_arc=-90 * DEG),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Two possibilities\n",
        "        frame = self.frame\n",
        "        possibilities = VGroup(\n",
        "            Text(\"1) There is no such extension\", font_size=72),\n",
        "            Text(\"2) There is only one extension\", font_size=72),\n",
        "        )\n",
        "        possibilities.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        possibilities.next_to(planes, UP, buff=LARGE_BUFF)\n",
        "        only_one = possibilities[1][\"only one\"][0]\n",
        "        underline = Underline(only_one, buff=-SMALL_BUFF).set_stroke(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(possibilities[0][:2]),\n",
        "            Write(possibilities[1][:2]),\n",
        "            frame.animate.reorient(0, 0, 0, (0, 1.5, 0.0), 9).set_anim_args(time_span=(0, 1)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(possibilities[0][2:], lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(possibilities[1][2:], lag_ratio=0.1))\n",
        "        self.play(\n",
        "            ShowCreation(underline),\n",
        "            only_one.animate.set_fill(YELLOW)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Analytic continuation\n",
        "        ac_words = Text(\"Analytic Continuation\", font_size=72)\n",
        "        ac_words.next_to(output_plane, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        darkest_red = interpolate_color(RED_E, BLACK, 0.9)\n",
        "        big_domain = self.get_extended_domain(input_plane, extension, 6, 6, corner_value=-3 - 3j, color=darkest_red)\n",
        "        big_domain.set_stroke(WHITE, 0.5, 0.1)\n",
        "        big_domain.set_fill(dark_red, 0.5)\n",
        "        mapped_big_domain = big_domain.copy().apply_points_function(point_func, about_edge=None)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(possibilities, lag_ratio=0.05),\n",
        "            FadeOut(underline),\n",
        "            Write(ac_words, time_span=(0.5, 2.)),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(mapped_big_domain, lag_ratio=5e-2, stroke_color=RED, stroke_width=0.5),\n",
        "            Write(big_domain, lag_ratio=5e-2, stroke_color=RED, stroke_width=0.5),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_extended_domain(self, plane, domain, width, height, corner_value, color=RED_E):\n",
        "        extension = self.get_rect_group(width, height, plane, corner_value=corner_value, color=color)\n",
        "\n",
        "        min_x = domain.get_x(LEFT)\n",
        "        max_x = domain.get_x(RIGHT)\n",
        "        min_y = domain.get_y(DOWN)\n",
        "        max_y = domain.get_y(UP)\n",
        "        to_remove = list()\n",
        "        for square in extension:\n",
        "            if (min_x < square.get_x() < max_x) and (min_y < square.get_y() < max_y):\n",
        "                to_remove.append(square)\n",
        "        extension.remove(*to_remove)\n",
        "        extension.sort(lambda p: get_norm(p - domain.get_center()))\n",
        "        return extension\n",
        "\n",
        "    def get_rect_group(self, width, height, plane, corner_value=0, square_density=5, color=BLUE_E):\n",
        "        square = Square(side_length=plane.x_axis.get_unit_size() / square_density)\n",
        "        square.set_stroke(WHITE, 0.5)\n",
        "        square.set_fill(color, 1)\n",
        "        square.insert_n_curves(20)\n",
        "        grid = square.get_grid(square_density * height, square_density * width, buff=0)\n",
        "        grid.move_to(plane.n2p(corner_value), DL)\n",
        "        return grid\n",
        "\n",
        "        rect = Rectangle(width, height)\n",
        "        rect.set_width(width * plane.x_axis.get_unit_size())\n",
        "        rect.move_to(plane.n2p(corner_value), DL)\n",
        "        rect.set_stroke(color, 2)\n",
        "        rect.set_fill(color, 1)\n",
        "        rect.insert_n_curves(200)\n",
        "\n",
        "        rect_lines = VGroup(\n",
        "            Line(DOWN, UP).get_grid(1, width * line_density + 1, buff=SMALL_BUFF),\n",
        "            Line(LEFT, RIGHT).get_grid(height * line_density + 1, 1, buff=SMALL_BUFF),\n",
        "        )\n",
        "        for group in rect_lines:\n",
        "            group.replace(rect, stretch=True)\n",
        "            group.set_stroke(WHITE, 1, 0.5)\n",
        "            for line in group:\n",
        "                line.insert_n_curves(20)\n",
        "\n",
        "        return VGroup(rect, rect_lines)\n",
        "\n",
        "\n",
        "class WriteFPrimeExists(InteractiveScene):\n",
        "    def construct(self):\n",
        "        words = TexText(\"$f'(z)$ Exists\")\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ZetaFunctionPlot(InteractiveScene):\n",
        "    # resolution = (51, 51)\n",
        "    resolution = (1001, 1001)  # Probably takes like an hour to compute\n",
        "\n",
        "    def construct(self):\n",
        "        # Planes\n",
        "        x_max = 25\n",
        "        s_plane = ComplexPlane((-x_max, x_max), (-x_max, x_max), faded_line_ratio=5)\n",
        "        s_plane.set_height(40)\n",
        "        s_plane.add_coordinate_labels(font_size=16)\n",
        "\n",
        "        partial_plane = ComplexPlane((1, x_max), (-x_max, x_max))\n",
        "        partial_plane.shift(s_plane.n2p(0) - partial_plane.n2p(0))\n",
        "\n",
        "        self.add(s_plane)\n",
        "\n",
        "        # True function\n",
        "        import mpmath as mp\n",
        "\n",
        "        def zeta_log_deriv(s):\n",
        "            epsilon = 1e-4\n",
        "            if s == 1:\n",
        "                return 1 / epsilon\n",
        "            out = mp.zeta(s)\n",
        "            if abs(out) < 1e-3:\n",
        "                return 1 / epsilon\n",
        "            out_prime = (mp.zeta(s + epsilon) - out) / epsilon\n",
        "            # return mp.zeta(s, derivative=1) / out\n",
        "            return out_prime / out\n",
        "\n",
        "        graph = get_complex_graph(\n",
        "            s_plane,\n",
        "            zeta_log_deriv,\n",
        "            resolution=self.resolution,\n",
        "        )\n",
        "        graph.set_clip_plane(RIGHT, -1)\n",
        "        graph.set_opacity(0.6)\n",
        "\n",
        "        self.add(graph)\n",
        "\n",
        "        # Panning\n",
        "        frame = self.frame\n",
        "        frame.reorient(24, 82, 0, (0.39, 0.58, 0.49), 4.02)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-14, 79, 0, (-0.62, -0.08, 1.41), 8.12),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.play(\n",
        "            graph.animate.set_clip_plane(RIGHT, x_max),\n",
        "            frame.animate.reorient(-13, 80, 0, (-0.28, -0.01, 2.17), 12.57),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(32, 81, 0, (-0.98, -2.23, 5.19), 32.31),\n",
        "            run_time=20\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(91, 84, 0, (-0.25, -1.54, 7.01), 32.31),\n",
        "            run_time=15,\n",
        "        )\n",
        "\n",
        "\n",
        "class WriteZetaPrimeFact(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        formula = Tex(\n",
        "            R\"\\frac{\\zeta'({s})}{\\zeta({s})} = \\sum_{spacer} \\sum_{k=1}^\\infty \\frac{1}{k} \\frac{1}{p^{s}}\",\n",
        "            t2c={\"{s}\": YELLOW}\n",
        "        )\n",
        "        spacer = formula[\"spacer\"][0]\n",
        "        p_prime = TexText(\"$p$ prime\")\n",
        "        p_prime.replace(spacer)\n",
        "        p_prime.scale(0.8, about_edge=UP)\n",
        "        formula.remove(*spacer)\n",
        "        formula.add(*p_prime)\n",
        "        formula.sort()\n",
        "\n",
        "        formula.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.play(Write(formula))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimpleExpToPole(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        t2c = {\"{t}\": BLUE, \"{s}\": YELLOW}\n",
        "        kw = dict(t2c=t2c, font_size=72)\n",
        "        lhs, arrow, rhs = group = VGroup(\n",
        "            Tex(R\"e^{a{t}}\", **kw),\n",
        "            Vector(1.5 * RIGHT, thickness=5),\n",
        "            Tex(R\"{1 \\over {s} - a}\", **kw)\n",
        "        )\n",
        "        group.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        group.to_edge(UP, MED_LARGE_BUFF)\n",
        "        fancy_L = Tex(R\"\\mathcal{L}\")\n",
        "        fancy_L.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(lhs))\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(fancy_L),\n",
        "            run_time=1,\n",
        "        )\n",
        "        self.play(\n",
        "            Write(rhs[:-1]),\n",
        "            TransformFromCopy(lhs[\"a\"], rhs[\"a\"])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Linearity(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        t2c = {\"f\": GREEN, \"g\": BLUE, R\"\\mathcal{L}\": GREY_A, R\"\\big\\{\": WHITE, R\"\\big\\}\": WHITE, \"a\": GREEN_A, \"b\": BLUE_A}\n",
        "        lhs = Tex(R\"\\mathcal{L}\\big\\{a \\cdot f(t) + b \\cdot g(t) \\big\\}\", t2c=t2c)\n",
        "        rhs = Tex(R\"a \\cdot \\mathcal{L} \\big\\{ f(t) \\big\\} + b \\cdot \\mathcal{L} \\big\\{ g(t) \\big\\}\", t2c=t2c)\n",
        "        arrow = Vector(RIGHT, thickness=4)\n",
        "        group = VGroup(lhs, arrow, rhs)\n",
        "        group.arrange(RIGHT)\n",
        "\n",
        "        self.add(lhs)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            LaggedStart(\n",
        "                AnimationGroup(*(\n",
        "                    TransformFromCopy(lhs[tex][0], rhs[tex][0], path_arc=45 * DEG)\n",
        "                    for tex in [R\"\\mathcal{L}\", R\"\\big\\{\", R\"a \\cdot\", \"f(t)\", R\"\\big\\}\"]\n",
        "                )),\n",
        "                AnimationGroup(*(\n",
        "                    TransformFromCopy(lhs[tex][0], rhs[tex][-1], path_arc=-45 * DEG)\n",
        "                    for tex in [\"+\", R\"\\mathcal{L}\", R\"\\big\\{\", R\"b \\cdot\", \"g(t)\", R\"\\big\\}\"]\n",
        "                )),\n",
        "                lag_ratio=0.75,\n",
        "                run_time=3\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LaplaceTransformOfCosineSymbolically(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add defining integral\n",
        "        frame = self.frame\n",
        "        t2c = {\n",
        "            \"{t}\": BLUE,\n",
        "            \"{s}\": YELLOW,\n",
        "            R\"\\omega\": PINK,\n",
        "            R\"int^\\infty_0\": WHITE,\n",
        "        }\n",
        "        key_strings = [\n",
        "            R\"int^\\infty_0\",\n",
        "            R\"e^{\\minus{s}{t}} d{t}\",\n",
        "            \"+\",\n",
        "            R\"\\frac{1}{2}\",\n",
        "            R\"e^{i{t}}\",\n",
        "            R\"e^{\\minus i{t}}\",\n",
        "        ]\n",
        "        kw = dict(isolate=key_strings, t2c=t2c)\n",
        "\n",
        "        cos_t = Tex(R\"\\cos({t})\", **kw)\n",
        "        cos_t.to_corner(UL, buff=LARGE_BUFF)\n",
        "        arrow = Vector(1.5 * RIGHT)\n",
        "        arrow.next_to(cos_t)\n",
        "        fancy_L = Tex(R\"\\mathcal{L}\")\n",
        "        fancy_L.next_to(arrow, UP, SMALL_BUFF)\n",
        "\n",
        "        def lt_string(interior):\n",
        "            return Rf\"\\int^\\infty_0 \" + interior + R\"e^{\\minus{s}{t}} d{t}\"\n",
        "\n",
        "        lt_def = Tex(lt_string(R\"\\cos({t})\"), **kw)\n",
        "        lt_def.next_to(arrow, RIGHT)\n",
        "\n",
        "        self.add(cos_t)\n",
        "        self.play(LaggedStart(\n",
        "            GrowArrow(arrow),\n",
        "            Write(fancy_L),\n",
        "            Write(lt_def[R\"\\int^\\infty_0\"]),\n",
        "            TransformFromCopy(cos_t, lt_def[R\"\\cos({t})\"][0], path_arc=45 * DEG),\n",
        "            Write(lt_def[R\"e^{\\minus{s}{t}} d{t}\"]),\n",
        "            lag_ratio=0.2,\n",
        "        ))\n",
        "\n",
        "        # Split up into exponential parts\n",
        "        spilt_cos_str = R\"\\left( \\frac{1}{2} e^{i{t}} + \\frac{1}{2} e^{\\minus i{t}} \\right)\"\n",
        "        split_inside = Tex(\"=\" + lt_string(spilt_cos_str), **kw)\n",
        "        split_inside.next_to(lt_def, RIGHT)\n",
        "\n",
        "        cos_rect = SurroundingRectangle(lt_def[R\"\\cos({t})\"])\n",
        "        cos_rect.set_stroke(TEAL, 2)\n",
        "\n",
        "        self.play(ShowCreation(cos_rect))\n",
        "        self.play(\n",
        "            TransformMatchingTex(\n",
        "                lt_def.copy(),\n",
        "                split_inside,\n",
        "                key_map={R\"\\cos({t})\": spilt_cos_str},\n",
        "                path_arc=30 * DEG,\n",
        "                mismatch_animation=FadeTransform,\n",
        "            ),\n",
        "            cos_rect.animate.surround(split_inside[spilt_cos_str]).set_anim_args(path_arc=30 * DEG),\n",
        "            run_time=1.5\n",
        "        )\n",
        "        self.play(FadeOut(cos_rect))\n",
        "        self.wait()\n",
        "        self.add(split_inside)\n",
        "\n",
        "        # Rect growth\n",
        "        self.play(cos_rect.animate.surround(split_inside[1:]).set_stroke(width=5))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(cos_rect))\n",
        "\n",
        "        # Linearity\n",
        "        split_tex = \" \".join([\n",
        "            R\"\\frac{1}{2}\", lt_string(R\"e^{i{t}}\"), R\"\\, + \\,\",\n",
        "            R\"\\frac{1}{2}\", lt_string(R\"e^{\\minus i{t}}\"),\n",
        "        ])\n",
        "        split_outside = Tex(split_tex, **kw)\n",
        "        side_eq = Tex(R\"=\", font_size=72).rotate(90 * DEG)\n",
        "        side_eq.next_to(split_inside, DOWN, MED_LARGE_BUFF)\n",
        "        split_outside.next_to(side_eq, DOWN, MED_LARGE_BUFF)\n",
        "        split_outside.shift_onto_screen()\n",
        "\n",
        "        srcs = VGroup()\n",
        "        trgs = VGroup()\n",
        "        for tex in key_strings:\n",
        "            src = split_inside[tex]\n",
        "            trg = split_outside[tex]\n",
        "            if tex is key_strings[0]:\n",
        "                src = VGroup(part[:3] for part in src)\n",
        "                trg = VGroup(part[:3] for part in trg)\n",
        "            srcs.add(src)\n",
        "            trgs.add(trg)\n",
        "\n",
        "        self.play(\n",
        "            Write(side_eq),\n",
        "            LaggedStart(\n",
        "                (TransformFromCopy(*pair)\n",
        "                for pair in zip(srcs[:3], trgs[:3])),\n",
        "                lag_ratio=0.01,\n",
        "                run_time=2\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(srcs[3][0], trgs[3][0]),\n",
        "            TransformFromCopy(srcs[4][0], trgs[4][0])\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(srcs[3][1], trgs[3][1]),\n",
        "            TransformFromCopy(srcs[5][0], trgs[5][0])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Collapse to poles\n",
        "        exp_transform_parts = VGroup(\n",
        "            split_outside[lt_string(R\"e^{i{t}}\")],\n",
        "            split_outside[lt_string(R\"e^{\\minus i{t}}\")],\n",
        "        )\n",
        "        pole_strings = [R\"\\frac{1}{{s} - i}\", R\"\\frac{1}{{s} \\, + \\, i}\"]\n",
        "        half_string = R\"\\frac{1}{2}\"\n",
        "        pole_sum = Tex(\n",
        "            R\" \\, \".join([half_string, pole_strings[0], \"+\", half_string, pole_strings[1]]),\n",
        "            **kw\n",
        "        )\n",
        "        pole_sum.scale(1.25)\n",
        "        pole_sum.move_to(split_outside).shift(0.2 * LEFT)\n",
        "\n",
        "        split_inside_rect = SurroundingRectangle(split_inside[spilt_cos_str])\n",
        "        exp_transform_rects = VGroup(\n",
        "            SurroundingRectangle(part, buff=SMALL_BUFF)\n",
        "            for part in exp_transform_parts\n",
        "        )\n",
        "        pole_rects = VGroup(\n",
        "            SurroundingRectangle(pole_sum[tex], buff=SMALL_BUFF)\n",
        "            for tex in pole_strings\n",
        "        )\n",
        "\n",
        "        VGroup(split_inside_rect, exp_transform_rects, pole_rects).set_stroke(TEAL, 2)\n",
        "\n",
        "        self.play(ShowCreation(split_inside_rect))\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(*(\n",
        "            TransformFromCopy(split_inside_rect, rect)\n",
        "            for rect in exp_transform_rects\n",
        "        )))\n",
        "        self.play(FadeOut(split_inside_rect))\n",
        "        self.wait()\n",
        "        for i, tex in enumerate([R\"e^{i{t}}\", R\"e^{\\minus i{t}}\"]):\n",
        "            self.play(\n",
        "                ReplacementTransform(exp_transform_rects[i], pole_rects[i]),\n",
        "                ReplacementTransform(split_outside[half_string][i], pole_sum[half_string][i]),\n",
        "                FadeTransform(split_outside[lt_string(tex)], pole_sum[pole_strings[i]]),\n",
        "                Transform(split_outside[\"+\"][0], pole_sum[\"+\"][0])\n",
        "            )\n",
        "            self.play(FadeOut(pole_rects[i]))\n",
        "        self.remove(split_outside)\n",
        "        self.add(pole_sum)\n",
        "        self.play(pole_sum.animate.match_x(side_eq))\n",
        "\n",
        "        # Read it as \"pole at i\", etc.\n",
        "        pole_rects = VGroup(\n",
        "            SurroundingRectangle(pole_sum[tex], buff=SMALL_BUFF)\n",
        "            for tex in pole_strings\n",
        "        )\n",
        "        pole_rects.set_stroke(YELLOW, 2)\n",
        "        pole_words = VGroup(\n",
        "            TexText(Rf\"Pole at \\\\ $s = {value}$\", font_size=60, t2c={\"Pole at\": YELLOW, \"s\": YELLOW})\n",
        "            for value in [\"i\", \"-i\"]\n",
        "        )\n",
        "\n",
        "        last_group = VGroup()\n",
        "        for word, rect in zip(pole_words, pole_rects):\n",
        "            word.next_to(rect, DOWN, MED_LARGE_BUFF)\n",
        "            self.play(\n",
        "                FadeIn(word, lag_ratio=0.1),\n",
        "                ShowCreation(rect),\n",
        "                FadeOut(last_group)\n",
        "            )\n",
        "            self.wait()\n",
        "            last_group = VGroup(word, rect)\n",
        "\n",
        "        self.play(FadeOut(last_group))\n",
        "\n",
        "        # Add an omega\n",
        "        old_group = VGroup(cos_t, lt_def, split_inside, pole_sum)\n",
        "        new_group = VGroup(\n",
        "            Tex(R\"\\cos(\\omega{t})\", **kw),\n",
        "            Tex(lt_string(R\"\\cos(\\omega{t})\"), **kw),\n",
        "            Tex(\"=\" + lt_string(R\"\\left(\\frac{1}{2} e^{i\\omega{t}} + \\frac{1}{2}e^{\\minus i \\omega {t}} \\right)\"), **kw),\n",
        "            Tex(R\" \\, \".join([\n",
        "                half_string, R\"\\frac{1}{{s} - \\omega i}\", \"+\",\n",
        "                half_string, R\"\\frac{1}{{s} \\, + \\, \\omega i}\",\n",
        "            ]), **kw)\n",
        "        )\n",
        "        for new, old in zip(new_group, old_group):\n",
        "            new.match_width(old)\n",
        "            new.move_to(old)\n",
        "\n",
        "        omegas = VGroup()\n",
        "        for new in new_group:\n",
        "            omegas.add(*new[R\"\\omega\"])\n",
        "\n",
        "        omega_copies = omegas.copy()\n",
        "        omegas.set_fill(opacity=0)\n",
        "        omegas[0].set_fill(opacity=1)\n",
        "\n",
        "        cos_omega = new_group[0]\n",
        "        cos_omega.scale(1.25, about_edge=RIGHT)\n",
        "        cos_omega_rect = SurroundingRectangle(cos_omega)\n",
        "        cos_omega_rect.set_stroke(PINK, 2)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(cos_omega_rect),\n",
        "            TransformMatchingTex(cos_t, cos_omega),\n",
        "            run_time=1\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                (TransformMatchingTex(old, new)\n",
        "                for new, old in zip(new_group[1:], old_group[1:])),\n",
        "                lag_ratio=0.05,\n",
        "                run_time=1\n",
        "            ),\n",
        "            TransformFromCopy(\n",
        "                omegas[0].replicate(len(omega_copies) - 1),\n",
        "                omega_copies[1:],\n",
        "                path_arc=30 * DEG,\n",
        "                lag_ratio=0.1,\n",
        "                run_time=2\n",
        "            ),\n",
        "        )\n",
        "        self.remove(omega_copies)\n",
        "        omegas.set_fill(opacity=1)\n",
        "        self.add(new_group)\n",
        "        self.play(FadeOut(cos_omega_rect))\n",
        "        self.wait()\n",
        "\n",
        "        # Simplify fraction\n",
        "        lower_arrow = Tex(R\"\\longleftarrow\", font_size=60)\n",
        "        lower_arrow.next_to(pole_sum, LEFT)\n",
        "\n",
        "        transform_kw = dict(\n",
        "            matched_keys=[\n",
        "                R\"{s}^2 \\,+\\, \\omega^2\",\n",
        "                R\"{s} \\,+\\, \\omega i\",\n",
        "                R\"{s} - \\omega i\",\n",
        "                R\"\\over\",\n",
        "            ],\n",
        "            key_map={\n",
        "                R\"({s} - \\omega i)({s} + \\omega i)\": R\"{s}^2 \\,+\\, \\omega^2\"\n",
        "            }\n",
        "        )\n",
        "\n",
        "        steps = VGroup(\n",
        "            Tex(R\"\"\"\n",
        "                \\frac{1}{2}\\left(\n",
        "                {{s} \\,+\\, \\omega i \\over ({s} - \\omega i)({s} + \\omega i)} +\n",
        "                {{s} - \\omega i \\over ({s} - \\omega i)({s} + \\omega i)}\n",
        "                \\right)\n",
        "            \"\"\", **kw),\n",
        "            Tex(R\"\"\"\n",
        "                \\frac{1}{2}\\left(\n",
        "                {{s} \\,+\\, \\omega i \\over {s}^2 \\,+\\, \\omega^2} +\n",
        "                {{s} - \\omega i \\over {s}^2 \\,+\\, \\omega^2}\n",
        "                \\right)\n",
        "            \"\"\", **kw),\n",
        "            Tex(R\"\"\"\n",
        "                \\frac{1}{2} {{s} \\,+\\, \\omega i \\,+\\, {s} - \\omega i \\over {s}^2 \\,+\\, \\omega^2}\n",
        "            \"\"\", **kw),\n",
        "            Tex(R\"\"\"\n",
        "                \\frac{1}{2} {2{s} \\over {s}^2 \\,+\\, \\omega^2}\n",
        "            \"\"\", **kw),\n",
        "            Tex(R\"{{s} \\over {s}^2 \\,+\\, \\omega^2}\", **kw),\n",
        "        )\n",
        "        for step in steps:\n",
        "            step.next_to(lower_arrow, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            Write(lower_arrow),\n",
        "            FadeTransform(pole_sum.copy(), steps[0]),\n",
        "            frame.animate.set_height(8.5, about_edge=DR),\n",
        "            run_time=2\n",
        "        )\n",
        "        for step1, step2 in zip(steps, steps[1:]):\n",
        "            self.play(\n",
        "                TransformMatchingTex(step1, step2, **transform_kw)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Circle answer\n",
        "        answer = steps[-1]\n",
        "        answer.target = answer.generate_target()\n",
        "        answer.target.scale(1.5, about_edge=RIGHT)\n",
        "        answer_rect = SurroundingRectangle(answer.target)\n",
        "        answer_rect.set_stroke(TEAL, 3)\n",
        "        self.play(\n",
        "            ShowCreation(answer_rect),\n",
        "            MoveToTarget(answer)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight direct equality\n",
        "        lt_def, int_of_expanded, imag_result = new_group[-3:]\n",
        "\n",
        "        direct_equals = Tex(R\"=\", font_size=90)\n",
        "        direct_equals.rotate(90 * DEG)\n",
        "        direct_equals.next_to(lt_def, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        to_fade = VGroup(int_of_expanded, side_eq, imag_result)\n",
        "\n",
        "        self.play(\n",
        "            lower_arrow.animate.set_fill(opacity=0),\n",
        "            to_fade.animate.set_fill(opacity=0.2),\n",
        "            answer_rect.animate.surround(VGroup(lt_def, answer)),\n",
        "            Write(direct_equals),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            lower_arrow.animate.set_fill(opacity=1).rotate(PI).set_anim_args(path_arc=PI),\n",
        "            answer_rect.animate.surround(VGroup(answer, imag_result)),\n",
        "            imag_result.animate.set_fill(opacity=1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SimplePolesOverImaginaryLine(InteractiveScene):\n",
        "    def construct(self):\n",
        "        s_plane = ComplexPlane((-5, 5), (-5, 5))\n",
        "        s_plane.add_coordinate_labels()\n",
        "        omega = 2\n",
        "        graph = get_complex_graph(\n",
        "            s_plane,\n",
        "            lambda s: (s**2) / (s**2 + omega**2 + 1e-6),\n",
        "            resolution=(301, 301)\n",
        "        )\n",
        "        graph[0].sort_faces_back_to_front(DOWN)\n",
        "        graph[1].set_clip_plane(OUT, 0)\n",
        "        self.add(s_plane, graph)\n",
        "\n",
        "        # Pan\n",
        "        frame = self.frame\n",
        "        frame.reorient(-57, 78, 0, (-1.28, 0.48, 0.92), 9.65)\n",
        "        self.play(frame.animate.reorient(59, 78, 0, (-0.31, -0.1, 0.87), 10.53), run_time=12)\n",
        "\n",
        "\n",
        "class IntegrationByParts(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        t2c = {\"{s}\": YELLOW, \"{t}\": BLUE, R\"\\omega\": PINK}\n",
        "        steps = VGroup(\n",
        "            Tex(R\"X = \\int^\\infty_0 \\cos(\\omega{t}) e^{\\minus {s}{t}}d{t}\", t2c=t2c),\n",
        "            Tex(R\"X = \\left[\\frac{1}{\\omega} \\sin(\\omega{t}) e^{\\minus {s}{t}} \\right]_0^\\infty - \\int^\\infty_0 \\frac{1}{\\omega} \\sin(\\omega {t}) \\left(\\minus {s} e^{\\minus{s}{t}} \\right) d{t}\", t2c=t2c),\n",
        "            Tex(R\"X = \\frac{s}{\\omega} \\int^\\infty_0 \\sin(\\omega{t}) e^{\\minus{s}{t}} d{t}\", t2c=t2c),\n",
        "            Tex(R\"X = \\frac{s}{\\omega} \\left(\\left[\\frac{\\minus 1}{\\omega} \\cos(\\omega{t}) e^{\\minus {s}{t}} \\right]_0^\\infty - \\int^\\infty_0 \\frac{\\minus 1}{\\omega} \\cos(\\omega{t}) \\left(\\minus {s} e^{\\minus{s}{t}} \\right) d{t} \\right)\", t2c=t2c),\n",
        "            Tex(R\"X = \\frac{s}{\\omega} \\left(\\frac{1}{\\omega} - \\frac{s}{\\omega} \\int^\\infty_0 \\cos(\\omega{t}) e^{\\minus{s}{t}} d{t} \\right)\", t2c=t2c),\n",
        "            Tex(R\"X = \\frac{s}{\\omega^2} \\left(1 - {s} X \\right)\", t2c=t2c),\n",
        "            Tex(R\"X\\left(\\omega^2 + {s}^2 \\right) = {s}\", t2c=t2c),\n",
        "            Tex(R\"X = \\frac{s}{\\omega^2 + {s}^2}\", t2c=t2c),\n",
        "        )\n",
        "        steps.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        steps.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        randy = Randolph(mode=\"raise_left_hand\")\n",
        "        randy.to_edge(DOWN)\n",
        "        steps[0].save_state()\n",
        "        steps[0].next_to(randy, UL, MED_LARGE_BUFF)\n",
        "        randy.look_at(steps[0])\n",
        "\n",
        "        ibp = Tex(R\"\\int u \\, dv = uv - \\int v \\, du\", t2c={\"u\": RED, \"v\": PINK})\n",
        "        ibp.next_to(randy, UR, MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(randy, steps[0])\n",
        "        self.play(Blink(randy))\n",
        "        self.play(\n",
        "            randy.change(\"raise_right_hand\", ibp),\n",
        "            FadeIn(ibp, UP)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            self.frame.animate.set_height(steps.get_height() + 3, about_edge=LEFT),\n",
        "            Restore(steps[0]),\n",
        "            Write(steps[1:], run_time=2),\n",
        "            randy.change(\"pondering\", 5 * UL).shift(6 * RIGHT + 2 * DOWN),\n",
        "            ibp.animate.shift(6 * RIGHT + 3 * DOWN),\n",
        "        )\n",
        "        self.play(randy.animate.look_at(steps[-1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AlternateBreakDown(TranslateToNewLanguage):\n",
        "    def construct(self):\n",
        "        # Set up\n",
        "        axes, graph, graph_label = self.get_graph_group(\n",
        "            lambda t: 0.35 * t**2,\n",
        "            func_tex=R\"f({t}) = {t}^2\"\n",
        "        )\n",
        "        graph_label.set_backstroke(BLACK, 8)\n",
        "        s_samples = self.get_s_samples()\n",
        "        s_plane, exp_pieces, s_plane_name = self.get_s_plane_and_exp_pieces(s_samples)\n",
        "        arrow, fancy_L, Fs_label = self.get_arrow_to_Fs(graph_label)\n",
        "\n",
        "        self.add(axes, graph, graph_label)\n",
        "        self.add(exp_pieces)\n",
        "\n",
        "        # Note equal to a sum\n",
        "        ne = Tex(R\"\\ne\", font_size=96)\n",
        "        ne.next_to(graph_label, RIGHT, MED_LARGE_BUFF)\n",
        "        ne.set_color(RED)\n",
        "        sum_tex = Tex(\n",
        "            R\"\\sum_{n=1}^N c_n e^{s_n t}\",\n",
        "            t2c={\"s_n\": YELLOW, \"c_n\": GREY_A},\n",
        "            font_size=72,\n",
        "        )\n",
        "        sum_tex.next_to(ne, RIGHT)\n",
        "        ne_rhs = VGroup(ne, sum_tex)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(ne, scale=2),\n",
        "            Write(sum_tex),\n",
        "            exp_pieces.animate.scale(0.7, about_edge=DR),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show transform\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(graph_label[4:]),\n",
        "                graph_label[:4].animate.next_to(arrow, LEFT),\n",
        "                GrowArrow(arrow),\n",
        "                Write(fancy_L),\n",
        "                TransformFromCopy(graph_label, Fs_label, path_arc=20 * DEG),\n",
        "                lag_ratio=0.05\n",
        "            ),\n",
        "            FadeOut(ne_rhs, DOWN, scale=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show integral\n",
        "        inv_lt = Tex(\n",
        "            R\"f({t}) = \\frac{1}{2\\pi i} \\int_\\gamma F({s}) e^{{s}{t}} d{s}\",\n",
        "            t2c=self.label_config[\"t2c\"]\n",
        "        )\n",
        "        inv_lt.next_to(arrow, DOWN, LARGE_BUFF)\n",
        "\n",
        "        s_plane.replace(exp_pieces)\n",
        "        s_plane.add_coordinate_labels(font_size=12)\n",
        "        line = Line(s_plane.get_bottom(), s_plane.get_top())\n",
        "        line.shift(RIGHT)\n",
        "        line.set_stroke(YELLOW, 2)\n",
        "        line.insert_n_curves(20)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(graph_label[:4], inv_lt[:4]),\n",
        "            TransformFromCopy(Fs_label, inv_lt[\"F({s})\"][0]),\n",
        "            Write(inv_lt[4:]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(s_plane),\n",
        "            LaggedStartMap(FadeOut, exp_pieces, scale=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            VShowPassingFlash(line.copy()),\n",
        "            ShowCreation(line),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()"
    ]
}