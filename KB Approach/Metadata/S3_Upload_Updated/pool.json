{
    "topic": "demonstrates the concept of reflections in a pool table. The animation shows how the ball",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "class PoolTableReflections(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add  table\n",
        "        table = ImageMobject(\"pool_table\")\n",
        "        table.set_height(4.0)\n",
        "        buff = 0.475\n",
        "\n",
        "        ball = TrueDot(radius=0.1)\n",
        "        ball.set_color(GREY_A)\n",
        "        ball.set_shading(1, 1, 1)\n",
        "        ball.move_to(table)\n",
        "\n",
        "        self.add(table, ball)\n",
        "\n",
        "        # Show inner table\n",
        "        frame = self.frame\n",
        "        frame.set_height(6)\n",
        "\n",
        "        irt = Rectangle(  # Inner rect template\n",
        "            width=table.get_width() - 2 * buff,\n",
        "            height=table.get_height() - 2 * buff,\n",
        "        )\n",
        "        irt.move_to(table)\n",
        "        inner_rect = VMobject()\n",
        "        inner_rect.start_new_path(irt.get_right())\n",
        "        for corner in [UR, UL, DL, DR]:\n",
        "            inner_rect.add_line_to(irt.get_corner(corner))\n",
        "        inner_rect.add_line_to(irt.get_right())\n",
        "        inner_rect.set_stroke(RED, 3)\n",
        "        inner_rect.insert_n_curves(20)\n",
        "\n",
        "        self.play(ball.animate.move_to(inner_rect.get_start()))\n",
        "        self.play(\n",
        "            ShowCreation(inner_rect, run_time=4),\n",
        "            UpdateFromFunc(ball, lambda m: m.move_to(inner_rect.get_end()))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show reflections\n",
        "        table_group1 = Group(table, inner_rect, ball)\n",
        "        new_origin = inner_rect.get_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(8).move_to(new_origin),\n",
        "            table.animate.set_opacity(0.5),\n",
        "            ball.animate.shift(DL)\n",
        "        )\n",
        "        table_group2 = table_group1.copy()\n",
        "        table_group2[2].set_opacity(0.5)\n",
        "        table_group2[0].set_opacity(0.1)\n",
        "        self.play(\n",
        "            Rotate(table_group2, axis=UP, about_point=inner_rect.get_right()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        table_group3 = table_group2.copy()\n",
        "        self.play(\n",
        "            Rotate(table_group3, axis=LEFT, about_point=table_group2[1].get_top()),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        def get_reflection(point, dims=[0]):\n",
        "            vect = point - new_origin\n",
        "            for dim in dims:\n",
        "                vect[dim] *= -1\n",
        "            return new_origin + vect\n",
        "\n",
        "        table_group2[2].add_updater(lambda m: m.move_to(get_reflection(ball.get_center())))\n",
        "        table_group3[2].add_updater(lambda m: m.move_to(get_reflection(ball.get_center(), dims=[0, 1])))\n",
        "\n",
        "        # Move ball around\n",
        "        kw = dict(rate_func=there_and_back, run_time=4)\n",
        "        self.play(ball.animate.shift(2 * UP), **kw)\n",
        "        self.play(ball.animate.shift(2 * LEFT), **kw)\n",
        "        self.wait()\n",
        "\n",
        "        # Show a trajectory\n",
        "        def line_to_trajectory(line, n_reflections=2):\n",
        "            p0 = find_intersection(\n",
        "                line.get_start(), line.get_vector(),\n",
        "                new_origin, DOWN,\n",
        "            )\n",
        "            p1 = find_intersection(\n",
        "                line.get_start(), line.get_vector(),\n",
        "                new_origin, RIGHT,\n",
        "            )\n",
        "\n",
        "            trajectory = VMobject()\n",
        "            if n_reflections == 1:\n",
        "                trajectory.set_points_as_corners([\n",
        "                    line.get_start(),\n",
        "                    p1,\n",
        "                    get_reflection(line.get_end(), [1])\n",
        "                ])\n",
        "            else:\n",
        "                trajectory.set_points_as_corners([\n",
        "                    line.get_start(), p0,\n",
        "                    get_reflection(p1),\n",
        "                    get_reflection(line.get_end(), [0, 1])\n",
        "                ])\n",
        "            trajectory.match_style(line)\n",
        "            trajectory.insert_n_curves(100)\n",
        "\n",
        "            return trajectory\n",
        "\n",
        "        ur_corner = table_group3[1].get_corner(UR)\n",
        "        straight_line = Line(ball.get_center(), ur_corner)\n",
        "        straight_line.set_stroke(YELLOW, 2)\n",
        "        traj_one_ref = line_to_trajectory(straight_line, 1)\n",
        "        trajectory = line_to_trajectory(straight_line)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(trajectory),\n",
        "            UpdateFromFunc(ball, lambda m: m.move_to(trajectory.get_end())),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(trajectory, traj_one_ref),\n",
        "            trajectory.animate.set_stroke(opacity=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveAlongPath(ball, trajectory),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(traj_one_ref, straight_line),\n",
        "            traj_one_ref.animate.set_stroke(opacity=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            MoveAlongPath(ball, trajectory),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(traj_one_ref),\n",
        "            trajectory.animate.set_stroke(opacity=1)\n",
        "        )\n",
        "\n",
        "        # Alternate line\n",
        "        alt_line = Line(straight_line.get_start(), straight_line.get_end() + 2 * DOWN)\n",
        "        alt_line.match_style(straight_line)\n",
        "\n",
        "        self.play(\n",
        "            Transform(straight_line, alt_line),\n",
        "            UpdateFromFunc(trajectory, lambda m: m.become(\n",
        "                line_to_trajectory(straight_line)\n",
        "            )),\n",
        "            UpdateFromFunc(trajectory, lambda m: m.become(\n",
        "                line_to_trajectory(straight_line)\n",
        "            )),\n",
        "            UpdateFromFunc(ball, lambda m: m.move_to(trajectory.get_end())),\n",
        "            run_time=4,\n",
        "            rate_func=there_and_back\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*map(FadeOut, [straight_line, trajectory]))\n",
        "\n",
        "        # Diamond points\n",
        "        vect1 = np.array([0.1, 0.315, 0.])\n",
        "        vect2 = np.array([0.309, 0.1, 0.])\n",
        "        low_diamond_points = np.linspace(\n",
        "            inner_rect.get_corner(DL) + vect1 * [-1, -1, 0],\n",
        "            inner_rect.get_corner(DR) + vect1 * [1, -1, 0],\n",
        "            9,\n",
        "        )\n",
        "        side_diamond_points = np.linspace(\n",
        "            inner_rect.get_corner(DR) + vect2 * [1, -1, 0],\n",
        "            inner_rect.get_corner(UR) + vect2,\n",
        "            5,\n",
        "        )\n",
        "\n",
        "        low_dots = GlowDots(low_diamond_points, radius=0.1)\n",
        "        side_dots = GlowDots(side_diamond_points, radius=0.1)\n",
        "\n",
        "        low_labels = VGroup(*(\n",
        "            Integer(value, font_size=24).next_to(point, DOWN)\n",
        "            for value, point in zip(\n",
        "                range(80, -10, -10),\n",
        "                low_diamond_points,\n",
        "            )\n",
        "        ))\n",
        "        side_labels = VGroup(*(\n",
        "            Integer(value, font_size=24).next_to(point, RIGHT)\n",
        "            for value, point in zip(\n",
        "                range(90, 0, -20),\n",
        "                side_diamond_points,\n",
        "            )\n",
        "        ))\n",
        "\n",
        "        low_nl = NumberLine((0, 80))\n",
        "        low_nl.put_start_and_end_on(low_diamond_points[-1], low_diamond_points[0])\n",
        "\n",
        "        side_nl = NumberLine((10, 90))\n",
        "        side_nl.put_start_and_end_on(side_diamond_points[-1], side_diamond_points[0])\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(low_dots, lag_ratio=0.5),\n",
        "            FadeIn(low_labels, lag_ratio=0.5),\n",
        "            frame.animate.set_height(10),\n",
        "            *(\n",
        "                tg[1].animate.set_stroke(width=1)\n",
        "                for tg in [table_group1, table_group2, table_group3]\n",
        "            ),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(side_dots, lag_ratio=0.5),\n",
        "            FadeIn(side_labels, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the trick lines\n",
        "        def get_diamond_line(x, y, length=25):\n",
        "            line = Line(low_nl.n2p(x), side_nl.n2p(y))\n",
        "            line.scale(length / line.get_length(), about_point=line.get_start())\n",
        "            line.set_stroke(YELLOW, 2)\n",
        "            return line\n",
        "\n",
        "        def n_to_lines(n):\n",
        "            return VGroup(*(\n",
        "                get_diamond_line(x, n - x)\n",
        "                for x in range(70, 0, -10)\n",
        "            )).set_stroke(YELLOW)\n",
        "\n",
        "        lines = n_to_lines(80)\n",
        "        trajs = VGroup()\n",
        "        for line in lines:\n",
        "            traj = line_to_trajectory(line)\n",
        "            traj.line = line\n",
        "            traj.add_updater(lambda t: t.become(line_to_trajectory(\n",
        "                t.line\n",
        "            )).set_color(BLUE))\n",
        "            trajs.add(traj)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, lines, lag_ratio=0.75, run_time=4))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_height(14, about_edge=DL),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        trajs.suspend_updating()\n",
        "        for n in range(len(lines)):\n",
        "            self.play(\n",
        "                lines[:n].animate.set_stroke(opacity=0.2),\n",
        "                lines[n].animate.set_stroke(opacity=1),\n",
        "                lines[n + 1:].animate.set_stroke(opacity=0.2),\n",
        "                FadeIn(trajs[n]),\n",
        "                trajs[:n].animate.set_stroke(opacity=0.2),\n",
        "                run_time=0.5,\n",
        "            )\n",
        "        self.play(\n",
        "            lines.animate.set_stroke(opacity=1),\n",
        "            trajs.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "        trajs.resume_updating()\n",
        "        self.wait()\n",
        "\n",
        "        # Show just one line\n",
        "        line = lines[-1]\n",
        "        traj = trajs[-1]\n",
        "\n",
        "        self.play(\n",
        "            lines[:-1].animate.set_stroke(opacity=0.15),\n",
        "            trajs[:-1].animate.set_stroke(opacity=0.15),\n",
        "            frame.animate.set_height(12, about_edge=DL).move_to(new_origin),\n",
        "        )\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                line, lambda m, a: m.set_points(get_diamond_line(\n",
        "                    interpolate(10, 70, there_and_back(a)),\n",
        "                    interpolate(70, 10, there_and_back(a)),\n",
        "                ).get_points()),\n",
        "            ),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            lines.animate.set_stroke(opacity=1),\n",
        "            trajs.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "\n",
        "        # Transition between different n\n",
        "        for n in [70, 60, 90, 100, 80]:\n",
        "            self.play(\n",
        "                Transform(lines, n_to_lines(n)),\n",
        "                run_time=3\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Show outward rays from the corner\n",
        "        def get_clean_lines(point):\n",
        "            result = VGroup(*(\n",
        "                Line(p, point)\n",
        "                for p in low_diamond_points[1:-1]\n",
        "            ))\n",
        "            result.set_stroke(YELLOW, 2)\n",
        "            return result\n",
        "\n",
        "        lines.save_state()\n",
        "        for point in [ur_corner, ur_corner + DOWN, ur_corner, ur_corner + 2 * LEFT, ur_corner]:\n",
        "            self.play(\n",
        "                Transform(lines, get_clean_lines(point)),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "        self.play(Restore(lines))\n",
        "        self.wait()\n"
    ]
}