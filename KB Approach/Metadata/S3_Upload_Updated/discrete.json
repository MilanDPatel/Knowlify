{
    "topic": "demonstrates the concept of a histogram, where a set of data is represented graph",
    "code": [
        "from __future__ import annotations\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from _2022.borwein.main import *\n",
        "import scipy.signal\n",
        "\n",
        "\n",
        "def get_die_faces(**kwargs):\n",
        "    result = VGroup(*(DieFace(n, **kwargs) for n in range(1, 7)))\n",
        "    result.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "    return result\n",
        "\n",
        "\n",
        "def get_aligned_pairs(group1, group2, n):\n",
        "    return VGroup(*(\n",
        "        VGroup(m1, m2)\n",
        "        for m1 in group1\n",
        "        for m2 in group2\n",
        "        if m1.index + m2.index == n\n",
        "    ))\n",
        "\n",
        "\n",
        "def get_pair_rects(pairs, together=True, buff=SMALL_BUFF, corner_radius=0.1):\n",
        "    if together:\n",
        "        return VGroup(*(\n",
        "            SurroundingRectangle(pair, buff=buff).round_corners(corner_radius)\n",
        "            for pair in pairs\n",
        "        ))\n",
        "    else:\n",
        "        return VGroup(*(\n",
        "            VGroup(*(\n",
        "                SurroundingRectangle(m, buff=buff).round_corners(corner_radius)\n",
        "                for m in pair\n",
        "            ))\n",
        "            for pair in pairs\n",
        "        ))\n",
        "\n",
        "\n",
        "def get_row_shift(top_row, low_row, n):\n",
        "    min_index = low_row[0].index\n",
        "    max_index = top_row[-1].index\n",
        "    max_sum = min_index + max_index\n",
        "    if n <= max_sum:\n",
        "        x_shift = top_row[n - 2 * min_index].get_x() - low_row[0].get_x()\n",
        "    else:\n",
        "        x_shift = top_row[-1].get_x() - low_row[n - max_sum].get_x()\n",
        "    return low_row.animate.shift(x_shift * RIGHT)\n",
        "\n",
        "\n",
        "def dist_to_bars(dist, bar_width=0.5, height=2.0, bar_colors=(BLUE_D, GREEN_D)):\n",
        "    bars = Rectangle(width=bar_width).get_grid(1, len(dist), buff=0)\n",
        "    bars.set_color_by_gradient(*bar_colors)\n",
        "    bars.set_fill(opacity=1)\n",
        "    bars.set_stroke(WHITE, 1)\n",
        "    for bar, value, index in zip(bars, dist, it.count()):\n",
        "        bar.set_height(value, stretch=True, about_edge=DOWN)\n",
        "        bar.index = index\n",
        "    bars.set_height(height, stretch=True)\n",
        "    bars.center()\n",
        "    return bars\n",
        "\n",
        "\n",
        "def get_bar_dividing_lines(bars):\n",
        "    v_lines = VGroup()\n",
        "    for bar in bars:\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(GREY_C, 1, 0.75)\n",
        "        v_line.set_x(bar.get_left()[0])\n",
        "        v_line.set_y(0)\n",
        "        v_lines.add(v_line)\n",
        "    v_lines.add(v_lines[-1].copy().set_x(bars.get_right()[0]))\n",
        "    return v_lines\n",
        "\n",
        "\n",
        "def add_labels_to_bars(bars, dist, width_ratio=0.7, **number_config):\n",
        "    labels = VGroup(*(DecimalNumber(x, **number_config) for x in dist))\n",
        "    labels.set_max_width(width_ratio * bars[0].get_width())\n",
        "    for label, bar in zip(labels, bars):\n",
        "        label.next_to(bar, UP, SMALL_BUFF)\n",
        "        bar.value_label = label\n",
        "        bar.push_self_into_submobjects()\n",
        "        bar.add(label)\n",
        "    return bars\n",
        "\n",
        "\n",
        "def prod(values):\n",
        "    return reduce(op.mul, values, 1)\n",
        "\n",
        "\n",
        "def get_lagrange_polynomial(data):\n",
        "    def poly(x):\n",
        "        return sum(\n",
        "            y0 * prod(\n",
        "                (x - x1) for x1, y1 in data if x1 != x0\n",
        "            ) / prod(\n",
        "                (x0 - x1) for x1, y1 in data if x1 != x0\n",
        "            )\n",
        "            for x0, y0 in data\n",
        "        )\n",
        "\n",
        "    return poly\n",
        "\n",
        "\n",
        "def kinked_function(x):\n",
        "    if x < -2:\n",
        "        return 0\n",
        "    elif x < -1:\n",
        "        return -x - 2\n",
        "    elif x < 1:\n",
        "        return x\n",
        "    elif x < 2:\n",
        "        return -x + 2\n",
        "    else:\n",
        "        return 0\n",
        "\n",
        "\n",
        "# Introduction\n",
        "\n",
        "class WaysToCombine(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Functions\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(WHITE, 2)\n",
        "\n",
        "        axes1, axes2, axes3 = all_axes = VGroup(*(\n",
        "            Axes((-3, 3), (-1, 1), height=2.0, width=FRAME_WIDTH * 0.5 - 1)\n",
        "            for x in range(3)\n",
        "        ))\n",
        "        all_axes.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        all_axes.set_height(FRAME_HEIGHT - 1)\n",
        "        all_axes.move_to(midpoint(ORIGIN, RIGHT_SIDE))\n",
        "\n",
        "        def f(x):\n",
        "            return kinked_function(x)\n",
        "\n",
        "        def g(x):\n",
        "            return np.exp(-0.5 * x**2)\n",
        "\n",
        "        f_graph = axes1.get_graph(f).set_stroke(BLUE, 2)\n",
        "        g_graph = axes2.get_graph(g).set_stroke(YELLOW, 2)\n",
        "        sum_graph = axes3.get_graph(lambda x: f(x) + g(x)).set_stroke(TEAL, 2)\n",
        "        prod_graph = axes3.get_graph(lambda x: f(x) * g(x)).set_stroke(TEAL, 2)\n",
        "        x_samples = np.linspace(*axes1.x_range[:2], 100)\n",
        "        f_samples = list(map(f, x_samples))\n",
        "        g_samples = list(map(g, x_samples))\n",
        "        conv_samples = np.convolve(f_samples, g_samples, mode='same')\n",
        "        conv_samples *= 0.1  # Artificially scale down\n",
        "        conv_points = axes3.c2p(x_samples, conv_samples)\n",
        "        conv_graph = VMobject().set_points_smoothly(conv_points)\n",
        "        conv_graph.set_stroke(TEAL, 2)\n",
        "\n",
        "        kw = dict(font_size=30, tex_to_color_map={\"f\": BLUE, \"g\": YELLOW})\n",
        "        f_label = Tex(\"f(x)\", **kw).move_to(axes1.get_corner(UL), UL)\n",
        "        g_label = Tex(\"g(x)\", **kw).move_to(axes2.get_corner(UL), UL)\n",
        "        sum_label = Tex(\"[f + g](x)\", **kw).move_to(axes3.get_corner(UL), UL)\n",
        "        prod_label = Tex(R\"[f \\cdot g](x)\", **kw).move_to(axes3.get_corner(UL), UL)\n",
        "        conv_label = Tex(R\"[f * g](x)\", **kw).move_to(axes3.get_corner(UL), UL)\n",
        "        graph_labels = VGroup(f_label, g_label, sum_label, prod_label, conv_label)\n",
        "\n",
        "        # Sequences\n",
        "        seq1 = np.array([1, 2, 3, 4])\n",
        "        seq2 = np.array([5, 6, 7, 8])\n",
        "        kw = dict(\n",
        "            font_size=48,\n",
        "            tex_to_color_map={\"a\": BLUE, \"b\": YELLOW},\n",
        "            isolate=[\",\", \"[\", \"]\"]\n",
        "        )\n",
        "        seq1_tex, seq2_tex, sum_seq, prod_seq, conv_seq = seqs = VGroup(\n",
        "            OldTex(f\"a = {list(seq1)}\", **kw),\n",
        "            OldTex(f\"b = {list(seq2)}\", **kw),\n",
        "            OldTex(f\"a + b = {list(seq1 + seq2)}\", **kw),\n",
        "            OldTex(Rf\"a \\cdot b = {list(seq1 * seq2)}\", **kw),\n",
        "            OldTex(Rf\"a * b = {list(np.convolve(seq1, seq2))}\", **kw),\n",
        "        )\n",
        "        seqs.move_to(midpoint(ORIGIN, LEFT_SIDE))\n",
        "        seq1_tex.match_y(axes1)\n",
        "        seq2_tex.match_y(axes2)\n",
        "        for seq in seqs[2:]:\n",
        "            seq.match_y(axes3)\n",
        "\n",
        "        # Operation labels\n",
        "        op_labels = VGroup()\n",
        "        left_op_labels = VGroup(*map(Text, [\"Addition\", \"Multiplication\", \"Convolution\"]))\n",
        "        left_op_labels.set_color(TEAL)\n",
        "        for left_op_label, seq, graph_label in zip(left_op_labels, seqs[2:], graph_labels[2:]):\n",
        "            left_op_label.next_to(seq, UP, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "            right_op_label = left_op_label.copy().scale(0.7)\n",
        "            right_op_label.next_to(graph_label, UP, aligned_edge=LEFT)\n",
        "            op_labels.add(VGroup(left_op_label, right_op_label))\n",
        "\n",
        "        # Introduce\n",
        "        kw = dict(lag_ratio=0.7)\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, seqs[:2], **kw),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(v_line),\n",
        "            LaggedStartMap(FadeIn, all_axes[:2], **kw),\n",
        "            LaggedStartMap(ShowCreation, VGroup(f_graph, g_graph), **kw),\n",
        "            LaggedStartMap(FadeIn, graph_labels[:2], **kw),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Ways to combine?\n",
        "        all_boxes = VGroup(*(SurroundingRectangle(m[2:]) for m in seqs[:3]))\n",
        "        all_boxes.set_stroke(width=2)\n",
        "        boxes = all_boxes[:2]\n",
        "        boxes[0].set_color(BLUE)\n",
        "        boxes[1].set_color(YELLOW)\n",
        "        mystery_box = all_boxes[2]\n",
        "        mystery_box.set_color(GREEN)\n",
        "        q_marks = Text(\"????\")\n",
        "        q_marks.space_out_submobjects(1.5)\n",
        "        q_marks.move_to(mystery_box)\n",
        "        box_arrows = VGroup(*(\n",
        "            Arrow(box.get_right(), mystery_box.get_corner(UR), path_arc=-PI / 3)\n",
        "            for box in boxes\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            *map(Write, box_arrows),\n",
        "            FadeIn(boxes),\n",
        "            *(\n",
        "                Transform(\n",
        "                    box.copy().set_stroke(width=0, opacity=0),\n",
        "                    mystery_box.copy(),\n",
        "                    path_arc=-PI / 3,\n",
        "                    remover=True\n",
        "                )\n",
        "                for box in boxes\n",
        "            )\n",
        "        )\n",
        "        self.add(mystery_box)\n",
        "        comb_graph = sum_graph.copy()\n",
        "        self.play(\n",
        "            Write(q_marks),\n",
        "            ReplacementTransform(axes1.copy(), axes3),\n",
        "            Transform(axes2.copy(), axes3.copy(), remover=True),\n",
        "            ReplacementTransform(f_graph.copy(), comb_graph),\n",
        "            Transform(g_graph.copy(), comb_graph.copy(), remover=True),\n",
        "        )\n",
        "        self.play(Transform(comb_graph, prod_graph))\n",
        "        self.play(Transform(comb_graph, conv_graph))\n",
        "        self.play(LaggedStartMap(FadeOut, VGroup(\n",
        "            *boxes, *box_arrows, mystery_box, q_marks, comb_graph\n",
        "        )))\n",
        "\n",
        "        # Sums and products\n",
        "        tuples = [\n",
        "            (sum_seq, sum_label, axes3, sum_graph, op_labels[0]),\n",
        "            (prod_seq, prod_label, axes3, prod_graph, op_labels[1])\n",
        "        ]\n",
        "        for seq, label, axes, graph, op_label in tuples:\n",
        "            self.play(LaggedStart(\n",
        "                TransformMatchingShapes(\n",
        "                    VGroup(*seq1_tex[:2], *seq2_tex[:2]).copy(),\n",
        "                    seq[:4]\n",
        "                ),\n",
        "                TransformMatchingShapes(graph_labels[:2].copy(), label),\n",
        "                FadeIn(op_label, DOWN)\n",
        "            ))\n",
        "            self.add(axes)\n",
        "            # Go point by point\n",
        "            value_rects = VGroup(*(\n",
        "                VGroup(*map(SurroundingRectangle, s[-8::2]))\n",
        "                for s in [seq1_tex, seq2_tex, seq]\n",
        "            ))\n",
        "            dots = Group(*(GlowDot(color=WHITE) for x in range(3)))\n",
        "            self.play(\n",
        "                *map(FadeIn, [seq[4], seq[-1]]),\n",
        "                *(\n",
        "                    VFadeInThenOut(rects, lag_ratio=0.5)\n",
        "                    for rects in value_rects\n",
        "                ),\n",
        "                LaggedStart(*(\n",
        "                    FadeIn(seq[n:n + 2 if n < 11 else n + 1])\n",
        "                    for n in range(5, 12, 2)\n",
        "                ), lag_ratio=0.5),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.play(\n",
        "                ShowCreation(graph, rate_func=linear),\n",
        "                UpdateFromFunc(dots[2], lambda m: m.move_to(graph.get_end())),\n",
        "                *(\n",
        "                    UpdateFromAlphaFunc(dot, lambda d, a: d.set_opacity(min(10 * a * (1 - a), 1)))\n",
        "                    for dot in dots\n",
        "                ),\n",
        "                *(\n",
        "                    MoveAlongPath(dot, graph)\n",
        "                    for dot, graph in zip(dots, [f_graph, g_graph])\n",
        "                ),\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(*map(FadeOut, [seq, label, graph, op_label]))\n",
        "\n",
        "        # Convolutions\n",
        "        self.play(LaggedStart(\n",
        "            TransformMatchingShapes(\n",
        "                VGroup(*seq1_tex[:2], *seq2_tex[:2]).copy(),\n",
        "                conv_seq[:4],\n",
        "            ),\n",
        "            FadeIn(op_labels[2][0], DOWN),\n",
        "            TransformMatchingShapes(graph_labels[:2].copy(), conv_label),\n",
        "            FadeIn(op_labels[2][1], DOWN),\n",
        "        ))\n",
        "        self.play(FadeIn(conv_seq[4:], lag_ratio=0.2, run_time=2))\n",
        "\n",
        "        # Hint at computation\n",
        "        nums1 = seq1_tex[3::2]\n",
        "        nums2 = seq2_tex[3::2]\n",
        "        for mobs in nums1, nums2:\n",
        "            for i, mob in enumerate(mobs):\n",
        "                mob.index = i\n",
        "        nums3 = conv_seq[5::2]\n",
        "\n",
        "        nums1.set_color(BLUE)\n",
        "        nums2.set_color(YELLOW)\n",
        "\n",
        "        last_group = VGroup()\n",
        "        for n, num3 in enumerate(nums3):\n",
        "            rect = SurroundingRectangle(num3, buff=SMALL_BUFF)\n",
        "            rect.set_stroke(TEAL, 2)\n",
        "            rect.round_corners()\n",
        "            pairs = get_aligned_pairs(nums1, nums2, n)\n",
        "            lines = VGroup(*(Line(m1, m2) for m1, m2 in pairs))\n",
        "            lines.set_stroke(TEAL, 2)\n",
        "\n",
        "            group = VGroup(rect, lines)\n",
        "            self.play(FadeIn(group), FadeOut(last_group), run_time=0.25)\n",
        "            self.wait(0.25)\n",
        "            last_group = group\n",
        "        self.play(FadeOut(last_group, run_time=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Conv graph\n",
        "        self.play(ShowCreation(conv_graph, run_time=3))\n",
        "        self.wait()\n",
        "        self.play(MoveAlongPath(GlowDot(color=WHITE), conv_graph, run_time=5, remover=True))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Probabilities\n",
        "\n",
        "\n",
        "class DiceExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Start showing grid\n",
        "        blue_dice = get_die_faces(fill_color=BLUE_E, dot_color=WHITE)\n",
        "        red_dice = get_die_faces(fill_color=RED_E, dot_color=WHITE)\n",
        "        VGroup(blue_dice, red_dice).arrange(DOWN, buff=LARGE_BUFF)\n",
        "        grid = Square().get_grid(6, 6, buff=0)\n",
        "        grid.set_height(6)\n",
        "        grid.to_edge(LEFT, buff=2.0)\n",
        "        grid.shift(0.5 * DOWN)\n",
        "        grid.set_stroke(WHITE, 1)\n",
        "\n",
        "        blue_dice.save_state()\n",
        "        red_dice.save_state()\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            FadeIn(blue_dice, lag_ratio=0.1, shift=0.25 * UP, run_time=2, rate_func=overshoot),\n",
        "            FadeIn(red_dice, lag_ratio=0.1, shift=0.25 * UP, run_time=2, rate_func=overshoot),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(grid, run_time=2, stroke_color=YELLOW, stroke_width=4),\n",
        "            *(\n",
        "                die.animate.set_width(0.6 * square.get_width()).next_to(square, UP, SMALL_BUFF)\n",
        "                for die, square in zip(blue_dice, grid[:6])\n",
        "            ),\n",
        "            *(\n",
        "                die.animate.set_width(0.6 * square.get_width()).next_to(square, LEFT, SMALL_BUFF)\n",
        "                for die, square in zip(red_dice, grid[0::6])\n",
        "            ),\n",
        "        )\n",
        "\n",
        "        # Add all mini dice\n",
        "        mini_dice = VGroup()\n",
        "        for n, square in enumerate(grid):\n",
        "            j, i = n // 6, n % 6\n",
        "            blue = blue_dice[i].copy()\n",
        "            red = red_dice[j].copy()\n",
        "            blue.sum = i + j + 2\n",
        "            red.sum = i + j + 2\n",
        "            blue.generate_target()\n",
        "            red.generate_target()\n",
        "            group = VGroup(blue.target, red.target)\n",
        "            group.set_stroke(width=1)\n",
        "            group.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "            group.set_width(square.get_width() * 0.8)\n",
        "            group.move_to(square)\n",
        "            mini_dice.add(blue, red)\n",
        "\n",
        "        combinations_label = VGroup(\n",
        "            OldTex(\"6^2 = \"), Integer(36), Text(\"Combinations\")\n",
        "        )\n",
        "        combinations_label.arrange(RIGHT, aligned_edge=DOWN)\n",
        "        combinations_label.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, mini_dice, lag_ratio=0.02, run_time=2),\n",
        "            FadeIn(combinations_label[0]),\n",
        "            CountInFrom(combinations_label[1], 1, run_time=2),\n",
        "            VFadeIn(combinations_label[1]),\n",
        "            FadeIn(combinations_label[2], 0),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Go Through diagonals\n",
        "        last_prob_label = VMobject()\n",
        "        for n in range(2, 13):\n",
        "            to_fade = VGroup()\n",
        "            to_highlight = VGroup()\n",
        "            for die in mini_dice:\n",
        "                if die.sum == n:\n",
        "                    to_highlight.add(die)\n",
        "                else:\n",
        "                    to_fade.add(die)\n",
        "            pairs = VGroup(*(VGroup(m1, m2) for m1, m2 in zip(to_highlight[::2], to_highlight[1::2])))\n",
        "            num = len(pairs)\n",
        "            prob_label = self.get_p_sum_expr(n, Rf\"\\frac{{{num}}}{{36}}\")\n",
        "            prob_label.next_to(combinations_label, UP, buff=1.5)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(prob_label, UP),\n",
        "                FadeOut(last_prob_label, UP),\n",
        "                to_highlight.animate.set_opacity(1),\n",
        "                to_fade.animate.set_opacity(0.2),\n",
        "                blue_dice.animate.set_opacity(0.5),\n",
        "                red_dice.animate.set_opacity(0.5),\n",
        "            )\n",
        "            if n <= 4:\n",
        "                self.play(\n",
        "                    LaggedStart(*(\n",
        "                        FlashAround(pair.copy(), remover=True, time_width=1, run_time=1.5)\n",
        "                        for pair in pairs\n",
        "                    ), lag_ratio=0.2),\n",
        "                )\n",
        "                self.wait()\n",
        "            last_prob_label = prob_label\n",
        "            self.wait()\n",
        "\n",
        "        # Reset\n",
        "        self.play(\n",
        "            FadeOut(grid),\n",
        "            FadeOut(mini_dice, lag_ratio=0.01),\n",
        "            FadeOut(combinations_label, RIGHT),\n",
        "            FadeOut(prob_label, RIGHT),\n",
        "            blue_dice.animate.restore(),\n",
        "            red_dice.animate.restore(),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Slide rows across\n",
        "        self.play(\n",
        "            Rotate(red_dice, PI),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        last_prob_label = VMobject()\n",
        "        last_rects = VMobject()\n",
        "        for n in range(2, 13):\n",
        "            pairs = self.get_aligned_pairs(blue_dice, red_dice, n)\n",
        "            prob_label = self.get_p_sum_expr(n, Rf\"\\frac{{{len(pairs)}}}{{36}}\")\n",
        "            prob_label.to_edge(UP)\n",
        "\n",
        "            self.play(\n",
        "                self.get_dice_shift(blue_dice, red_dice, n),\n",
        "                FadeOut(last_rects, run_time=0.5)\n",
        "            )\n",
        "            rects = get_pair_rects(pairs)\n",
        "            self.play(\n",
        "                FadeOut(last_prob_label, UP),\n",
        "                FadeIn(prob_label, UP),\n",
        "                LaggedStartMap(ShowCreation, rects, lag_ratio=0.2),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            last_prob_label = prob_label\n",
        "            last_rects = rects\n",
        "\n",
        "        # Realign\n",
        "        self.play(\n",
        "            FadeOut(last_rects),\n",
        "            FadeOut(last_prob_label, UP),\n",
        "            red_dice.animate.next_to(blue_dice, DOWN, buff=1.5),\n",
        "        )\n",
        "\n",
        "        # Show implicit probabilities, and alternates\n",
        "        all_dice = VGroup(*blue_dice, *red_dice)\n",
        "        sixths = VGroup(*(\n",
        "            OldTex(\"1 / 6\", font_size=36).next_to(die, UP, SMALL_BUFF)\n",
        "            for die in all_dice\n",
        "        ))\n",
        "        sixths.set_stroke(WHITE, 0)\n",
        "        blue_probs, red_probs = [\n",
        "            np.random.uniform(0, 1, 6)\n",
        "            for x in range(2)\n",
        "        ]\n",
        "        for probs in blue_probs, red_probs:\n",
        "            probs[:] = (probs / probs.sum()).round(2)\n",
        "            probs[-1] = 1.0 - probs[:-1].sum()  # Ensure it's a valid distribution\n",
        "\n",
        "        new_prob_labels = VGroup()\n",
        "        all_dice.generate_target()\n",
        "        for die, prob in zip(all_dice.target, (*blue_probs, *red_probs)):\n",
        "            label = DecimalNumber(prob, font_size=36)\n",
        "            label.next_to(die, UP, SMALL_BUFF)\n",
        "            die.set_opacity(prob / (2 / 6))\n",
        "            new_prob_labels.add(label)\n",
        "\n",
        "        question = Text(\"Non-uniform probabilities?\")\n",
        "        question.to_edge(UP)\n",
        "\n",
        "        self.play(LaggedStartMap(Write, sixths, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(question, run_time=1),\n",
        "            FadeOut(sixths, 0.25 * UP, lag_ratio=0.03, run_time=4),\n",
        "            FadeIn(new_prob_labels, 0.25 * UP, lag_ratio=0.03, run_time=4),\n",
        "            MoveToTarget(all_dice, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for die, prob_label in zip(all_dice, new_prob_labels):\n",
        "            die.prob_label = prob_label\n",
        "            die.prob = prob_label.get_value()\n",
        "            die.add(prob_label)\n",
        "\n",
        "        # March!\n",
        "        last_rects = VMobject()\n",
        "        last_prob_label = question\n",
        "        n = 2\n",
        "        while n < 13:\n",
        "            pairs = self.get_aligned_pairs(blue_dice, red_dice, n)\n",
        "            prob_label = self.get_p_sum_expr(n, rhs=\" \")\n",
        "            rhs = self.get_conv_rhs(pairs, prob_label)\n",
        "            VGroup(prob_label, rhs).center().to_edge(UP)\n",
        "\n",
        "            self.play(\n",
        "                self.get_dice_shift(blue_dice, red_dice, n),\n",
        "                FadeOut(last_rects, run_time=0.5),\n",
        "                FadeOut(last_prob_label, 0.5 * UP),\n",
        "                FadeIn(prob_label, 0.5 * UP),\n",
        "            )\n",
        "            rects = self.get_pair_rects(pairs)\n",
        "            self.play(FadeIn(rects, lag_ratio=0.2))\n",
        "            self.play(TransformMatchingShapes(\n",
        "                VGroup(*(\n",
        "                    VGroup(blue.prob_label, red.prob_label)\n",
        "                    for blue, red in pairs\n",
        "                )).copy(),\n",
        "                rhs\n",
        "            ))\n",
        "            self.wait()\n",
        "\n",
        "            if n == 4 and isinstance(blue_dice[0].prob_label, DecimalNumber):\n",
        "                # Make more general\n",
        "                blue_labels = VGroup(*(OldTex(f\"a_{{{i}}}\", font_size=42) for i in range(1, 7)))\n",
        "                red_labels = VGroup(*(OldTex(f\"b_{{{i}}}\", font_size=42) for i in range(1, 7)))\n",
        "                blue_labels.set_color(BLUE)\n",
        "                red_labels.set_color(RED)\n",
        "                old_prob_labels = VGroup()\n",
        "                for die, label in zip(all_dice, (*blue_labels, *red_labels)):\n",
        "                    label.next_to(die[0], UP, SMALL_BUFF)\n",
        "                    die.remove(die.prob_label)\n",
        "                    old_prob_labels.add(die.prob_label)\n",
        "                    die.prob_label = label\n",
        "                    die.add(label)\n",
        "                self.play(\n",
        "                    FadeIn(VGroup(*blue_labels, *red_labels), shift=0.25 * UP, lag_ratio=0.04),\n",
        "                    FadeOut(old_prob_labels, shift=0.25 * UP, lag_ratio=0.04),\n",
        "                    FadeOut(rhs, time_span=(0, 1)),\n",
        "                    run_time=4\n",
        "                )\n",
        "            else:\n",
        "                n += 1\n",
        "\n",
        "            last_prob_label = VGroup(prob_label, rhs)\n",
        "            last_rects = rects\n",
        "\n",
        "        # Show all formulas\n",
        "        n_range = list(range(2, 13))\n",
        "        lhss = VGroup(*(self.get_p_sum_expr(n) for n in n_range))\n",
        "        pairss = VGroup(*(self.get_aligned_pairs(blue_dice, red_dice, n) for n in n_range))\n",
        "        rhss = VGroup(*(self.get_conv_rhs(pairs, lhs) for pairs, lhs in zip(pairss, lhss)))\n",
        "        prob_labels = VGroup()\n",
        "        for lhs, rhs in zip(lhss, rhss):\n",
        "            prob_labels.add(VGroup(lhs, rhs))\n",
        "        prob_labels.arrange(DOWN, aligned_edge=LEFT)\n",
        "        prob_labels.set_height(FRAME_HEIGHT - 1)\n",
        "        prob_labels.to_edge(LEFT)\n",
        "\n",
        "        dice = VGroup(blue_dice, red_dice)\n",
        "        dice.generate_target()\n",
        "        dice.target[1].rotate(PI)\n",
        "        for m in dice.target[1]:\n",
        "            m.prob_label.rotate(PI)\n",
        "            m.prob_label.next_to(m, UP, SMALL_BUFF)\n",
        "        dice.target.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        dice.target.set_width(5)\n",
        "        dice.target.to_edge(RIGHT)\n",
        "        dice.target.to_corner(DR)\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, prob_labels[:-1], lag_ratio=0.2, run_time=2),\n",
        "            FadeTransform(last_prob_label, prob_labels[-1], time_span=(0.5, 2.0)),\n",
        "            MoveToTarget(dice, path_arc=PI / 2),\n",
        "            FadeOut(last_rects),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name convolution\n",
        "        a_rect = SurroundingRectangle(VGroup(*(die.prob_label for die in blue_dice)))\n",
        "        b_rect = SurroundingRectangle(VGroup(*(die.prob_label for die in red_dice)))\n",
        "        rhs_rects = VGroup(*(SurroundingRectangle(rhs) for rhs in rhss))\n",
        "        VGroup(a_rect, b_rect, *rhs_rects).set_stroke(YELLOW, 2)\n",
        "\n",
        "        conv_name = OldTexText(\n",
        "            R\"Convolution of \", \"$(a_i)$\", \" and \", \"$(b_i)$\",\n",
        "            tex_to_color_map={\"$(a_i)$\": BLUE, \"$(b_i)$\": RED}\n",
        "        )\n",
        "        conv_eq = Tex(\n",
        "            R\"(a * b)_n = \\sum_{\\substack{i, j \\\\ i + j = n}} a_i \\cdot b_j\",\n",
        "            isolate=[\"a_i\", \"*\", \"b_j\", \"(a * b)_n\"]\n",
        "        )\n",
        "        conv_label = VGroup(conv_name, conv_eq)\n",
        "        conv_label.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        conv_label.scale(0.9)\n",
        "        conv_label.to_corner(UR)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenFadeOut,\n",
        "                VGroup(a_rect, b_rect),\n",
        "                lag_ratio=0.5,\n",
        "                run_time=3,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                FadeIn,\n",
        "                conv_name[1:5:2],\n",
        "                shift=UP,\n",
        "                lag_ratio=0.5,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(conv_name[0:4:2], lag_ratio=0.1))\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenFadeOut,\n",
        "            rhs_rects,\n",
        "            lag_ratio=0.1,\n",
        "            run_time=5\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Show grid again\n",
        "        diagonals = VGroup()\n",
        "        plusses = VGroup()\n",
        "        rhss.save_state()\n",
        "        for n, rhs in zip(it.count(2), rhss):\n",
        "            diag = VGroup()\n",
        "            for i in range(0, len(rhs), 4):\n",
        "                diag.add(rhs[i:i + 3])\n",
        "                if i > 0:\n",
        "                    plusses.add(rhs[i - 1])\n",
        "            diagonals.add(diag)\n",
        "\n",
        "        diagonals.generate_target()\n",
        "        for k, square in enumerate(grid):\n",
        "            i = k // 6\n",
        "            j = k % 6\n",
        "            i2 = j if (i + j <= 5) else 5 - i\n",
        "            diagonals.target[i + j][i2].move_to(square)\n",
        "\n",
        "        blue_dice.save_state()\n",
        "        blue_dice.generate_target()\n",
        "        red_dice.save_state()\n",
        "        red_dice.generate_target()\n",
        "        for dice, squares, vect in (blue_dice, grid[:6], UP), (red_dice, grid[::6], LEFT):\n",
        "            dice.save_state()\n",
        "            dice.generate_target()\n",
        "            for die, square in zip(dice.target, squares):\n",
        "                die.scale(0.75)\n",
        "                die.next_to(square, vect, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            plusses.animate.set_opacity(0),\n",
        "            FadeOut(lhss, LEFT, run_time=0.5, lag_ratio=0.01),\n",
        "            MoveToTarget(diagonals),\n",
        "            MoveToTarget(blue_dice),\n",
        "            MoveToTarget(red_dice),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeIn(grid, lag_ratio=0.01))\n",
        "        self.add(diagonals)\n",
        "        self.wait()\n",
        "        for n in range(len(diagonals)):\n",
        "            diagonals.generate_target()\n",
        "            diagonals.target.set_opacity(0.2)\n",
        "            diagonals.target[n].set_opacity(1)\n",
        "            self.play(MoveToTarget(diagonals))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Restore(blue_dice),\n",
        "            Restore(red_dice),\n",
        "            diagonals.animate.set_opacity(1)\n",
        "        )\n",
        "        self.remove(diagonals)\n",
        "        self.play(\n",
        "            FadeOut(grid),\n",
        "            Restore(rhss),\n",
        "            FadeIn(lhss, time_span=(1, 2), lag_ratio=0.01),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write equation\n",
        "        self.wait(2)\n",
        "        self.play(FadeIn(conv_eq, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight example\n",
        "        n = 4\n",
        "        pairs = self.get_aligned_pairs(blue_dice, red_dice, n + 2)\n",
        "        pair_rects = get_pair_rects(pairs, together=False)\n",
        "\n",
        "        self.play(\n",
        "            prob_labels[:n].animate.set_opacity(0.35),\n",
        "            prob_labels[n + 1:].animate.set_opacity(0.35),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowSubmobjectsOneByOne(pair_rects, remover=True, rate_func=linear, run_time=3))\n",
        "        self.wait()\n",
        "\n",
        "        # Alternate formula notation\n",
        "        alt_rhs = OldTex(R\"\\sum_{i = 1}^6 a_i \\cdot b_{n - i}\")\n",
        "        alt_rhs.scale(0.9)\n",
        "        alt_rhs.move_to(conv_eq[7], LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(alt_rhs, 0.5 * DOWN),\n",
        "            conv_eq[7:].animate.shift(1.5 * DOWN).set_opacity(0.5),\n",
        "            dice.animate.to_edge(DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_p_sum_expr(self, n, rhs=\" \"):\n",
        "        raw_expr = Tex(\n",
        "            fR\"P\\big(O + O = {n}\\big) = \\, {rhs}\",\n",
        "            isolate=(\"O\", str(n), \"=\", rhs)\n",
        "        )\n",
        "        for index, color in zip([2, 4], [BLUE_E, RED_E]):\n",
        "            square = DieFace(1, fill_color=color, stroke_width=1)[0]\n",
        "            square.replace(raw_expr[index])\n",
        "            square.match_y(raw_expr[3])\n",
        "            raw_expr.replace_submobject(index, square)\n",
        "        return raw_expr\n",
        "\n",
        "    def get_dice_shift(self, top_dice, low_dice, n):\n",
        "        return get_row_shift(top_dice, low_dice, n)\n",
        "\n",
        "    def get_aligned_pairs(self, top_dice, low_dice, n):\n",
        "        return get_aligned_pairs(top_dice, low_dice, n)\n",
        "\n",
        "    def get_pair_rects(self, pairs, together=True):\n",
        "        return get_pair_rects(pairs, together)\n",
        "\n",
        "    def get_conv_rhs(self, pairs, prob_label):\n",
        "        rhs = VGroup()\n",
        "        for (blue, red) in pairs:\n",
        "            rhs.add(blue.prob_label.copy().set_color(BLUE))\n",
        "            rhs.add(OldTex(R\"\\cdot\"))\n",
        "            rhs.add(red.prob_label.copy().set_color(RED))\n",
        "            rhs.add(OldTex(\"+\"))\n",
        "        rhs.remove(rhs[-1])\n",
        "        rhs.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        rhs.next_to(prob_label, RIGHT, buff=0.2)\n",
        "        return rhs\n",
        "\n",
        "\n",
        "class SimpleExample(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Question\n",
        "        question = Text(\"What is\")\n",
        "        conv = Tex(\"(1, 2, 3) * (4, 5, 6)\")\n",
        "        group = VGroup(question, conv)\n",
        "        group.arrange(DOWN)\n",
        "        group.to_edge(UP)\n",
        "\n",
        "        self.play(Write(question, run_time=1.5), FadeIn(conv, 0.5 * DOWN, time_span=(0.5, 1.5)))\n",
        "        self.wait()\n",
        "\n",
        "        # Blocks\n",
        "        top_row = Square(side_length=0.75).get_grid(1, 3, buff=0)\n",
        "        top_row.set_stroke(GREY_B, 2)\n",
        "        top_row.set_fill(GREY_E, 1)\n",
        "        low_row = top_row.copy()\n",
        "        for row, values in (top_row, range(1, 4)), (low_row, range(4, 7)):\n",
        "            for index, value, square in zip(it.count(), values, row):\n",
        "                value_label = Integer(value)\n",
        "                value_label.move_to(square)\n",
        "                square.value_label = value_label\n",
        "                square.add(value_label)\n",
        "                square.value = value\n",
        "                square.index = index\n",
        "\n",
        "        VGroup(top_row, low_row).arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            TransformMatchingShapes(conv[1:6:2].copy(), top_row),\n",
        "            TransformMatchingShapes(conv[9:14:2].copy(), low_row),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Labels\n",
        "        self.add_block_labels(top_row, \"a\", BLUE)\n",
        "        self.add_block_labels(low_row, \"b\", RED)\n",
        "\n",
        "        # Set up position\n",
        "        top_row.generate_target()\n",
        "        low_row.generate_target()\n",
        "        low_row.target.rotate(PI)\n",
        "        for square in low_row.target:\n",
        "            square.value_label.rotate(PI)\n",
        "            square.label.rotate(PI)\n",
        "        top_row.target.center()\n",
        "        low_row.target.next_to(top_row.target, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        conv_result = np.convolve([1, 2, 3], [4, 5, 6])\n",
        "        rhs_args = [\"=\", R\"\\big(\"]\n",
        "        for k in conv_result:\n",
        "            rhs_args.append(str(k))\n",
        "            rhs_args.append(\",\")\n",
        "        rhs_args[-1] = R\"\\big)\"\n",
        "        rhs = OldTex(*rhs_args)\n",
        "        rhs[1:].set_color(YELLOW)\n",
        "        conv.generate_target()\n",
        "        group = VGroup(conv.target, rhs)\n",
        "        group.arrange(RIGHT, buff=0.2)\n",
        "        group.next_to(top_row, UP, buff=2),\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            MoveToTarget(top_row),\n",
        "            MoveToTarget(low_row, path_arc=PI),\n",
        "            MoveToTarget(conv),\n",
        "            Write(VGroup(*rhs[:2], rhs[-1])),\n",
        "            FadeOut(question, UP),\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # March!\n",
        "        c_labels = VGroup()\n",
        "        for n in range(len(conv_result)):\n",
        "            self.play(get_row_shift(top_row, low_row, n))\n",
        "\n",
        "            pairs = get_aligned_pairs(top_row, low_row, n)\n",
        "            label_pairs = VGroup(*(\n",
        "                VGroup(m1.value_label, m2.value_label)\n",
        "                for m1, m2 in pairs\n",
        "            ))\n",
        "            new_label_pairs = label_pairs.copy()\n",
        "            expr = VGroup()\n",
        "            symbols = VGroup()\n",
        "            for label_pair in new_label_pairs:\n",
        "                label_pair.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "                label_pair.next_to(expr, RIGHT, SMALL_BUFF)\n",
        "                dot = OldTex(R\"\\dot\")\n",
        "                dot.move_to(label_pair)\n",
        "                plus = OldTex(\"+\")\n",
        "                plus.next_to(label_pair, RIGHT, SMALL_BUFF)\n",
        "                expr.add(*label_pair, dot, plus)\n",
        "                symbols.add(dot, plus)\n",
        "            symbols[-1].scale(0, about_point=symbols[-2].get_right())\n",
        "            expr.next_to(label_pairs, UP, LARGE_BUFF)\n",
        "            c_label = OldTex(f\"c_{n}\", font_size=30, color=YELLOW).next_to(rhs[2 * n + 2], UP)\n",
        "\n",
        "            rects = VGroup(*(\n",
        "                SurroundingRectangle(lp, buff=0.2).set_stroke(YELLOW, 1).round_corners()\n",
        "                for lp in label_pairs\n",
        "            ))\n",
        "            self.play(FadeIn(rects, lag_ratio=0.5))\n",
        "            self.play(\n",
        "                LaggedStart(*(\n",
        "                    TransformFromCopy(lp, nlp)\n",
        "                    for lp, nlp in zip(label_pairs, new_label_pairs)\n",
        "                ), lag_ratio=0.5),\n",
        "                Write(symbols),\n",
        "            )\n",
        "            self.wait()\n",
        "            anims = [\n",
        "                FadeTransform(expr.copy(), rhs[2 * n + 2]),\n",
        "                c_labels.animate.set_opacity(0.35),\n",
        "                FadeIn(c_label)\n",
        "            ]\n",
        "            if n < 4:\n",
        "                anims.append(Write(rhs[2 * n + 3]))\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            self.play(FadeOut(expr), FadeOut(rects))\n",
        "\n",
        "            c_labels.add(c_label)\n",
        "        self.play(FadeOut(c_labels))\n",
        "\n",
        "        # Grid of values\n",
        "        equation = VGroup(conv, rhs)\n",
        "        values1 = VGroup(*(block.value_label for block in top_row)).copy()\n",
        "        values2 = VGroup(*(block.value_label for block in low_row)).copy()\n",
        "\n",
        "        grid = Square(side_length=1.0).get_grid(3, 3, buff=0)\n",
        "        grid.set_stroke(WHITE, 2)\n",
        "        grid.set_fill(GREY_E, 1.0)\n",
        "        grid.move_to(DL)\n",
        "\n",
        "        self.play(\n",
        "            Write(grid, time_span=(0.5, 2.0)),\n",
        "            LaggedStart(\n",
        "                *(\n",
        "                    value.animate.next_to(square, UP, buff=0.2)\n",
        "                    for value, square in zip(values1, grid[:3])\n",
        "                ),\n",
        "                *(\n",
        "                    value.animate.next_to(square, LEFT, buff=0.2)\n",
        "                    for value, square in zip(values2, grid[0::3])\n",
        "                ),\n",
        "                run_time=2\n",
        "            ),\n",
        "            *(\n",
        "                MaintainPositionRelativeTo(block, value)\n",
        "                for row, values in [(top_row, values1), (low_row, values2)]\n",
        "                for block, value in zip(row, values)\n",
        "            ),\n",
        "            VFadeOut(top_row),\n",
        "            VFadeOut(low_row),\n",
        "            equation.animate.center().to_edge(UP)\n",
        "        )\n",
        "\n",
        "        # Products\n",
        "        products = VGroup()\n",
        "        diag_groups = VGroup().replicate(5)\n",
        "        for n, square in enumerate(grid):\n",
        "            i, j = n // 3, n % 3\n",
        "            v1 = values1[j]\n",
        "            v2 = values2[i]\n",
        "            product = Integer(v1.get_value() * v2.get_value())\n",
        "            product.match_height(v1)\n",
        "            product.move_to(square)\n",
        "            product.factors = (v1, v2)\n",
        "            square.product = product\n",
        "            products.add(product)\n",
        "            diag_groups[i + j].add(product)\n",
        "\n",
        "        products.set_color(GREEN)\n",
        "\n",
        "        self.play(LaggedStart(*(\n",
        "            ReplacementTransform(factor.copy(), product)\n",
        "            for product in products\n",
        "            for factor in product.factors\n",
        "        ), lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        # Circle diagonals\n",
        "        products.rotate(PI / 4)\n",
        "        ovals = VGroup()\n",
        "        radius = 0.3\n",
        "        for diag in diag_groups:\n",
        "            oval = SurroundingRectangle(diag, buff=0.19)\n",
        "            oval.set_width(2 * radius, stretch=True)\n",
        "            oval.set_stroke(YELLOW, 2)\n",
        "            oval.round_corners(radius=radius)\n",
        "            ovals.add(oval)\n",
        "        VGroup(products, ovals).rotate(-PI / 4)\n",
        "        ovals[0].become(Circle(radius=radius).match_style(ovals[0]).move_to(products[0]))\n",
        "\n",
        "        arrows = VGroup(*(\n",
        "            Vector(0.5 * UP).next_to(part, DOWN)\n",
        "            for part in rhs[2::2]\n",
        "        ))\n",
        "        arrows.set_color(YELLOW)\n",
        "\n",
        "        curr_arrow = arrows[0].copy()\n",
        "        curr_arrow.shift(0.5 * DOWN).set_opacity(0)\n",
        "        for n, oval, arrow in zip(it.count(), ovals, arrows):\n",
        "            self.play(\n",
        "                ShowCreation(oval),\n",
        "                ovals[:n].animate.set_stroke(opacity=0.25),\n",
        "                Transform(curr_arrow, arrow)\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(ovals.animate.set_stroke(opacity=0.25), FadeOut(curr_arrow))\n",
        "        self.wait()\n",
        "\n",
        "        grid_group = VGroup(grid, values1, values2, products, ovals)\n",
        "\n",
        "        # Show polynomial\n",
        "        polynomial_eq = Tex(\n",
        "            R\"\\left(1 + 2x + 3x^2\\right)\\left(4 + 5x + 6x^2\\right)\"\n",
        "            R\"={4} + {13}x + {28}x^2 + {27}x^3 + {18}x^4\",\n",
        "            tex_to_color_map=dict(\n",
        "                (f\"{{{n}}}\", YELLOW)\n",
        "                for n in conv_result\n",
        "            )\n",
        "        )\n",
        "        polynomial_eq.next_to(equation, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(polynomial_eq, DOWN),\n",
        "            grid_group.animate.center().to_edge(DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Replace terms\n",
        "        self.play(grid_group.animate.set_height(4.5, about_edge=DOWN))\n",
        "\n",
        "        for i, value in zip((*range(3), *range(3)), (*values1, *values2)):\n",
        "            tex = [\"\", \"x\", \"x^2\"][i]\n",
        "            value.target = Tex(f\"{value.get_value()}{tex}\")\n",
        "            value.target.scale(value.get_height() / value.target[0].get_height())\n",
        "            value.target.move_to(value, DOWN)\n",
        "        values2[1].target.align_to(values2[0].target, RIGHT)\n",
        "        values2[2].target.align_to(values2[0].target, RIGHT)\n",
        "        for n, diag_group in enumerate(diag_groups):\n",
        "            tex = [\"\", \"x\", \"x^2\", \"x^3\", \"x^4\"][n]\n",
        "            for product in diag_group:\n",
        "                product.target = Tex(f\"{product.get_value()}{tex}\")\n",
        "                product.target.match_style(product)\n",
        "                product.target.scale(0.9)\n",
        "                product.target.move_to(product)\n",
        "\n",
        "        eq_values1 = VGroup(polynomial_eq[1], polynomial_eq[3:5], polynomial_eq[6:9])\n",
        "        eq_values2 = VGroup(polynomial_eq[11], polynomial_eq[13:15], polynomial_eq[16:19])\n",
        "\n",
        "        for values, eq_values in [(values1, eq_values1), (values2, eq_values2)]:\n",
        "            self.play(\n",
        "                LaggedStart(*(TransformMatchingShapes(ev.copy(), v.target) for ev, v in zip(eq_values, values))),\n",
        "                LaggedStart(*(FadeTransform(v, v.target[0]) for v in values)),\n",
        "            )\n",
        "        self.wait()\n",
        "        old_rects = VGroup()\n",
        "        for n, prod in enumerate(products):\n",
        "            new_rects = VGroup(\n",
        "                SurroundingRectangle(values1[n % 3].target),\n",
        "                SurroundingRectangle(values2[n // 3].target),\n",
        "            )\n",
        "            new_rects.set_stroke(GREEN, 2)\n",
        "            self.play(\n",
        "                FadeIn(new_rects),\n",
        "                FadeOut(old_rects),\n",
        "                FadeTransform(prod, prod.target[:len(prod)]),\n",
        "                FadeIn(prod.target[len(prod):], scale=2),\n",
        "                FlashAround(prod.target, time_width=1),\n",
        "                run_time=1.0\n",
        "            )\n",
        "            old_rects = new_rects\n",
        "        self.play(FadeOut(old_rects))\n",
        "\n",
        "        # Show diagonals again\n",
        "        arrows = VGroup(*(\n",
        "            Vector(0.5 * UP).next_to(polynomial_eq.select_part(f\"{{{n}}}\"), DOWN, buff=SMALL_BUFF)\n",
        "            for n in conv_result\n",
        "        ))\n",
        "        arrows.set_color(YELLOW)\n",
        "\n",
        "        curr_arrow = arrows[0].copy().shift(DOWN).set_opacity(0)\n",
        "        for n, oval, arrow in zip(it.count(), ovals, arrows):\n",
        "            self.play(\n",
        "                oval.animate.set_stroke(opacity=1),\n",
        "                Transform(curr_arrow, arrow),\n",
        "                ovals[:n].animate.set_stroke(opacity=0.25),\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            FadeOut(curr_arrow),\n",
        "            ovals.animate.set_stroke(opacity=0.5)\n",
        "        )\n",
        "\n",
        "    def add_block_labels(self, blocks, letter, color=BLUE, font_size=30):\n",
        "        labels = VGroup()\n",
        "        for n, square in enumerate(blocks):\n",
        "            label = OldTex(f\"{letter}_{{{n}}}\", font_size=font_size)\n",
        "            label.set_color(color)\n",
        "            label.next_to(square, UP, SMALL_BUFF)\n",
        "            square.label = label\n",
        "            square.add(label)\n",
        "            labels.add(label)\n",
        "        return labels\n",
        "\n",
        "\n",
        "class MovingAverageExample(InteractiveScene):\n",
        "    dist1 = [*5 * [0.1], *5 * [1], *5 * [0.1], *5 * [1], *5 * [0.1]]\n",
        "    dist2 = 5 * [0.2]\n",
        "    march_anim_run_time = 1.0\n",
        "    always_preview_result = True\n",
        "\n",
        "    def construct(self):\n",
        "        # All bars\n",
        "        self.camera.frame.scale(1.01)\n",
        "        dist1 = np.array(self.dist1)\n",
        "        dist2 = np.array(self.dist2)\n",
        "        conv_dist = np.convolve(dist1, dist2)\n",
        "\n",
        "        top_bars = dist_to_bars(dist1, height=1.5, bar_colors=(BLUE_D, TEAL_D))\n",
        "        low_bars = dist_to_bars(dist2, height=1.5, bar_colors=(RED_D, GOLD_E))\n",
        "        conv_bars = dist_to_bars(conv_dist, height=1.5, bar_colors=(GREEN_D, YELLOW_E))\n",
        "\n",
        "        top_bars.center().to_edge(UP)\n",
        "        low_bars.stretch(max(dist2), 1, about_edge=DOWN)\n",
        "        low_bars.arrange(LEFT, aligned_edge=DOWN, buff=0)\n",
        "        low_bars.next_to(top_bars, DOWN, buff=1.2, aligned_edge=LEFT)\n",
        "        conv_bars.match_x(top_bars)\n",
        "        conv_bars.to_edge(DOWN, LARGE_BUFF)\n",
        "        v_lines = get_bar_dividing_lines(conv_bars)\n",
        "\n",
        "        add_labels_to_bars(top_bars, dist1, num_decimal_places=1, width_ratio=0.4)\n",
        "        add_labels_to_bars(low_bars, dist2, num_decimal_places=1, width_ratio=0.4)\n",
        "        add_labels_to_bars(conv_bars, conv_dist, num_decimal_places=2)\n",
        "\n",
        "        self.add(v_lines)\n",
        "        self.play(FadeIn(top_bars, lag_ratio=0.1, run_time=2))\n",
        "        self.play(FadeIn(low_bars))\n",
        "\n",
        "        lb_rect = SurroundingRectangle(low_bars)\n",
        "        lb_rect.round_corners().set_stroke(YELLOW, 2)\n",
        "        sum_label = Tex(R\"\\sum_i y_i = 1\")\n",
        "        sum_label.set_color(YELLOW)\n",
        "        sum_label.next_to(lb_rect)\n",
        "        self.play(ShowCreation(lb_rect))\n",
        "        self.play(Write(sum_label, run_time=1))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(lb_rect), FadeOut(sum_label))\n",
        "\n",
        "        # March!\n",
        "        last_rects = VGroup()\n",
        "        for n, conv_bar in enumerate(conv_bars):\n",
        "            rect = conv_bar[0]\n",
        "            value = conv_bar[1]\n",
        "\n",
        "            rect.save_state()\n",
        "            rect.stretch(0, 1, about_edge=DOWN)\n",
        "            rect.set_opacity(0)\n",
        "\n",
        "            self.play(\n",
        "                get_row_shift(top_bars, low_bars, n),\n",
        "                FadeOut(last_rects),\n",
        "                run_time=self.march_anim_run_time,\n",
        "            )\n",
        "\n",
        "            pairs = get_aligned_pairs(top_bars, low_bars, n)\n",
        "            label_pairs = VGroup(*(VGroup(m1.value_label, m2.value_label) for m1, m2 in pairs))\n",
        "            rects = VGroup(*(\n",
        "                SurroundingRectangle(lp, buff=0.05).set_stroke(YELLOW, 2).round_corners()\n",
        "                for lp in label_pairs\n",
        "            ))\n",
        "            rects.set_stroke(YELLOW, 2)\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(rects, lag_ratio=0.5),\n",
        "                conv_bars[:n].animate.set_opacity(0.5),\n",
        "                run_time=self.march_anim_run_time,\n",
        "            )\n",
        "\n",
        "            self.play(\n",
        "                *(\n",
        "                    FadeTransform(label.copy(), value)\n",
        "                    for lp in label_pairs\n",
        "                    for label in lp\n",
        "                ),\n",
        "                Restore(rect),\n",
        "                run_time=self.march_anim_run_time,\n",
        "            )\n",
        "\n",
        "            if self.always_preview_result:\n",
        "                self.add(conv_bars)\n",
        "                conv_bars.set_opacity(0.5)\n",
        "                conv_bar.set_opacity(1)\n",
        "\n",
        "            self.wait(0.5)\n",
        "\n",
        "            last_rects = rects\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(last_rects),\n",
        "            conv_bars.animate.set_opacity(1),\n",
        "        )\n",
        "\n",
        "\n",
        "class MovingAverageFast(MovingAverageExample):\n",
        "    march_anim_run_time = 0\n",
        "\n",
        "\n",
        "class AltMovingAverage(MovingAverageExample):\n",
        "    dist2 = [0.1, 0.2, 0.4, 0.2, 0.1]\n",
        "\n",
        "\n",
        "class AltMovingAverageFast(AltMovingAverage):\n",
        "    march_anim_run_time = 0\n",
        "\n",
        "\n",
        "class MovingAverageFast2(AltMovingAverageFast):\n",
        "    always_preview_result = True\n",
        "\n",
        "\n",
        "class CompareSizes(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Show them all!\n",
        "        int_arr1 = [3, 1, 4, 1, 5, 9]\n",
        "        int_arr2 = [5, 7, 7]\n",
        "        conv_arr = np.convolve(int_arr1, int_arr2)\n",
        "\n",
        "        arrays = VGroup()\n",
        "        for arr in (int_arr1, int_arr2, conv_arr):\n",
        "            squares = Square().get_grid(1, len(arr), buff=0)\n",
        "            squares.set_height(0.7)\n",
        "            squares.set_stroke(WHITE, 1)\n",
        "            squares.set_fill(GREY_E, 1)\n",
        "            for square, elem in zip(squares, arr):\n",
        "                int_mob = Integer(elem).move_to(square)\n",
        "                square.add(int_mob)\n",
        "            arrays.add(squares)\n",
        "\n",
        "        top_arr, low_arr, conv_arr = arrays\n",
        "\n",
        "        arrays.arrange(DOWN, buff=1.0)\n",
        "        arrays[:2].shift(UP)\n",
        "        VGroup(*(square[0] for square in arrays[2])).set_opacity(0)\n",
        "\n",
        "        self.add(*arrays)\n",
        "\n",
        "        # Length labels\n",
        "        braces = VGroup(*(Brace(arr, vect, buff=SMALL_BUFF) for arr, vect in zip(arrays, [UP, DOWN, DOWN])))\n",
        "        brace_labels = VGroup(*(brace.get_tex(tex, buff=SMALL_BUFF) for brace, tex in zip(braces, [\"n\", \"m\", \"n + m - 1\"])))\n",
        "        braces[1].add_updater(lambda m: m.match_x(arrays[1]))\n",
        "        brace_labels[1].add_updater(lambda m: m.match_x(arrays[1]))\n",
        "\n",
        "        self.add(braces, brace_labels)\n",
        "\n",
        "        # Flip\n",
        "        self.remove(low_arr)\n",
        "        fake_arr = low_arr.deepcopy()\n",
        "        fake_arr.generate_target(use_deepcopy=True)\n",
        "        fake_arr.target.rotate(PI)\n",
        "        for square in fake_arr.target:\n",
        "            square[0].rotate(PI)\n",
        "        self.play(MoveToTarget(fake_arr, path_arc=PI, lag_ratio=0.01))\n",
        "        self.remove(fake_arr)\n",
        "        low_arr.rotate(PI)\n",
        "        for square in low_arr:\n",
        "            square[0].rotate(PI)\n",
        "\n",
        "        # March!\n",
        "        for arr in (top_arr, low_arr):\n",
        "            for index, square in enumerate(arr):\n",
        "                square.index = index\n",
        "\n",
        "        for n in range(len(conv_arr)):\n",
        "            self.play(\n",
        "                get_row_shift(top_arr, low_arr, n),\n",
        "                run_time=0.5\n",
        "            )\n",
        "            pairs = get_aligned_pairs(top_arr, low_arr, n)\n",
        "            rects = VGroup(*(\n",
        "                SurroundingRectangle(pair, buff=-0.05)\n",
        "                for pair in pairs\n",
        "            ))\n",
        "            self.add(rects)\n",
        "            conv_arr[n].set_opacity(1)\n",
        "            self.play(ShowIncreasingSubsets(rects, int_func=np.ceil), run_time=0.5)\n",
        "            self.wait(0.25)\n",
        "            self.remove(rects)\n",
        "\n",
        "        # Truncate\n",
        "        brace = braces[2]\n",
        "        brace_label = brace_labels[2]\n",
        "\n",
        "        small_brace = Brace(conv_arr[2:-2], DOWN, buff=SMALL_BUFF)\n",
        "        small_brace_label = small_brace.get_text(\"Only consider full overlaps\")\n",
        "\n",
        "        mid_brace = Brace(conv_arr[1:-1], DOWN, buff=SMALL_BUFF)\n",
        "        mid_brace_label = mid_brace.get_text(\"Match biggest input size\")\n",
        "\n",
        "        self.play(\n",
        "            Transform(brace, small_brace),\n",
        "            FadeTransform(brace_label, small_brace_label),\n",
        "            conv_arr[:2].animate.set_opacity(0.25),\n",
        "            conv_arr[-2:].animate.set_opacity(0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(brace, mid_brace),\n",
        "            FadeTransform(small_brace_label, mid_brace_label),\n",
        "            conv_arr[1].animate.set_opacity(1),\n",
        "            conv_arr[-2].animate.set_opacity(1),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# Image processing\n",
        "\n",
        "\n",
        "class ImageConvolution(InteractiveScene):\n",
        "    image_name = \"MarioSmall\"\n",
        "    image_height = 6.0\n",
        "    kernel_tex = None\n",
        "    scalar_conv = False\n",
        "    pixel_stroke_width = 1.0\n",
        "    pixel_stroke_opacity = 1.0\n",
        "    kernel_decimal_places = 2\n",
        "    kernel_color = BLUE\n",
        "    grayscale = False\n",
        "\n",
        "    def setup(self):\n",
        "        super().setup()\n",
        "        # Set up the pixel grids\n",
        "        pixels = self.get_pixel_value_array() / 255.0\n",
        "        kernel = self.get_kernel()\n",
        "        if self.scalar_conv:\n",
        "            conv = scipy.signal.convolve(pixels.mean(2), kernel, mode='same')\n",
        "        else:\n",
        "            conv = scipy.signal.convolve(pixels, np.expand_dims(kernel, 2), mode='same')\n",
        "\n",
        "        conv = np.clip(conv, -1, 1)\n",
        "\n",
        "        pixel_array = self.get_pixel_array(pixels)\n",
        "        kernel_array = self.get_kernel_array(kernel, pixel_array, tex=self.kernel_tex)\n",
        "        conv_array = self.get_pixel_array(conv)\n",
        "        conv_array.set_fill(opacity=0)\n",
        "\n",
        "        VGroup(pixel_array, conv_array).arrange(RIGHT, buff=2.0)\n",
        "        kernel_array.move_to(pixel_array[0])\n",
        "\n",
        "        self.add(pixel_array)\n",
        "        self.add(conv_array)\n",
        "        self.add(kernel_array)\n",
        "\n",
        "        # Set up index tracker\n",
        "        index_tracker = ValueTracker(0)\n",
        "\n",
        "        def get_index():\n",
        "            return int(clip(index_tracker.get_value(), 0, len(pixel_array) - 1))\n",
        "\n",
        "        kernel_array.add_updater(lambda m: m.move_to(pixel_array[get_index()]))\n",
        "        conv_array.add_updater(lambda m: m.set_fill(opacity=0))\n",
        "        conv_array.add_updater(lambda m: m[:get_index() + 1].set_fill(opacity=1))\n",
        "\n",
        "        right_rect = conv_array[0].copy()\n",
        "        right_rect.set_fill(opacity=0)\n",
        "        right_rect.set_stroke(self.kernel_color, 4, opacity=1)\n",
        "        right_rect.add_updater(lambda m: m.move_to(conv_array[get_index()]))\n",
        "        self.add(right_rect)\n",
        "\n",
        "        self.index_tracker = index_tracker\n",
        "        self.pixel_array = pixel_array\n",
        "        self.kernel_array = kernel_array\n",
        "        self.conv_array = conv_array\n",
        "        self.right_rect = right_rect\n",
        "\n",
        "    def get_pixel_value_array(self):\n",
        "        im_path = get_full_raster_image_path(self.image_name)\n",
        "        image = Image.open(im_path)\n",
        "        return np.array(image)[:, :, :3]\n",
        "\n",
        "    def get_pixel_array(self, array: np.ndarray):\n",
        "        height, width = array.shape[:2]\n",
        "\n",
        "        pixel_array = Square().get_grid(height, width, buff=0)\n",
        "        for pixel, value in zip(pixel_array, it.chain(*array)):\n",
        "            if value.size == 3:\n",
        "                # Value is rgb valued\n",
        "                rgb = np.abs(value).clip(0, 1)\n",
        "                if self.grayscale:\n",
        "                    rgb[:] = rgb.mean()\n",
        "            else:\n",
        "                # Treat as scalar, color red for negative green for positive\n",
        "                rgb = [max(-value, 0), max(value, 0), max(value, 0)]\n",
        "            pixel.set_fill(rgb_to_color(rgb), 1.0)\n",
        "        pixel_array.set_height(self.image_height)\n",
        "        pixel_array.set_max_width(5.75)\n",
        "        pixel_array.set_stroke(WHITE, self.pixel_stroke_width, self.pixel_stroke_opacity)\n",
        "\n",
        "        return pixel_array\n",
        "\n",
        "    def get_kernel_array(self, kernel: np.ndarray, pixel_array: VGroup, tex=None):\n",
        "        kernel_array = VGroup()\n",
        "        values = VGroup()\n",
        "        for row in kernel:\n",
        "            for x in row:\n",
        "                square = pixel_array[0].copy()\n",
        "                square.set_fill(BLACK, 0)\n",
        "                square.set_stroke(self.kernel_color, 2, opacity=1)\n",
        "                if tex:\n",
        "                    value = OldTex(tex)\n",
        "                else:\n",
        "                    value = DecimalNumber(x, num_decimal_places=self.kernel_decimal_places)\n",
        "                value.set_width(square.get_width() * 0.7)\n",
        "                value.set_backstroke(BLACK, 3)\n",
        "                value.move_to(square)\n",
        "                values.add(value)\n",
        "                square.add(value)\n",
        "                kernel_array.add(square)\n",
        "        for value in values:\n",
        "            value.set_height(values[0].get_height())\n",
        "        kernel_array.reverse_submobjects()\n",
        "        kernel_array.arrange_in_grid(*kernel.shape, buff=0)\n",
        "        kernel_array.move_to(pixel_array[0])\n",
        "        return kernel_array\n",
        "\n",
        "    def get_kernel(self):\n",
        "        return np.ones((3, 3)) / 9\n",
        "\n",
        "    # Setup combing and zooming\n",
        "    def set_index(self, value, run_time=8, rate_func=linear):\n",
        "        self.play(\n",
        "            self.index_tracker.animate.set_value(value),\n",
        "            run_time=run_time,\n",
        "            rate_func=rate_func\n",
        "        )\n",
        "\n",
        "    def zoom_to_kernel(self, run_time=2):\n",
        "        ka = self.kernel_array\n",
        "        self.play(\n",
        "            self.camera.frame.animate.set_height(1.5 * ka.get_height()).move_to(ka),\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "    def zoom_to_new_pixel(self, run_time=4):\n",
        "        ka = self.kernel_array\n",
        "        ca = self.conv_array\n",
        "        frame = self.camera.frame\n",
        "        curr_center = frame.get_center().copy()\n",
        "        index = int(self.index_tracker.get_value())\n",
        "        new_center = ca[index].get_center()\n",
        "        center_func = bezier([curr_center, curr_center, new_center, new_center])\n",
        "\n",
        "        target_height = 1.5 * ka.get_height()\n",
        "        height_func = bezier([\n",
        "            frame.get_height(), frame.get_height(), FRAME_HEIGHT,\n",
        "            target_height, target_height,\n",
        "        ])\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(frame, lambda m, a: m.set_height(height_func(a)).move_to(center_func(a))),\n",
        "            run_time=run_time,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "\n",
        "    def reset_frame(self, run_time=2):\n",
        "        self.play(\n",
        "            self.camera.frame.animate.to_default_state(),\n",
        "            run_time=run_time\n",
        "        )\n",
        "\n",
        "    def show_pixel_sum(self, tex=None, convert_to_vect=True, row_len=9):\n",
        "        # Setup sum\n",
        "        ka = self.kernel_array\n",
        "        pa = self.pixel_array\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        rgb_vects = VGroup()\n",
        "        lil_pixels = VGroup()\n",
        "        expr = VGroup()\n",
        "\n",
        "        ka_copy = VGroup()\n",
        "        stroke_width = 2 * FRAME_HEIGHT / frame.get_height()\n",
        "\n",
        "        lil_height = 1.0\n",
        "        for square in ka:\n",
        "            ka_copy.add(square.copy().set_stroke(TEAL, stroke_width))\n",
        "            sc = square.get_center()\n",
        "            pixel = pa[np.argmin([get_norm(p.get_center() - sc) for p in pa])]\n",
        "            color = pixel.get_fill_color()\n",
        "            rgb = color_to_rgb(color)\n",
        "            rgb_vect = DecimalMatrix(rgb.reshape((3, 1)), num_decimal_places=2)\n",
        "            rgb_vect.set_height(lil_height)\n",
        "            rgb_vect.set_color(color)\n",
        "            if get_norm(rgb) < 0.1:\n",
        "                rgb_vect.set_color(WHITE)\n",
        "            rgb_vects.add(rgb_vect)\n",
        "\n",
        "            lil_pixel = pixel.copy()\n",
        "            lil_pixel.match_width(rgb_vect)\n",
        "            lil_pixel.set_stroke(WHITE, stroke_width)\n",
        "            lil_pixels.add(lil_pixel)\n",
        "\n",
        "            if tex:\n",
        "                lil_coef = OldTex(tex, font_size=36)\n",
        "            else:\n",
        "                lil_coef = square[0].copy()\n",
        "                lil_coef.set_height(lil_height * 0.5)\n",
        "            expr.add(lil_coef, lil_pixel, OldTex(\"+\", font_size=48))\n",
        "\n",
        "        expr[-1].scale(0, about_edge=LEFT)  # Stray plus\n",
        "        rows = VGroup(*(\n",
        "            expr[n:n + 3 * row_len]\n",
        "            for n in range(0, len(expr), 3 * row_len)\n",
        "        ))\n",
        "        for row in rows:\n",
        "            row.arrange(RIGHT, buff=0.2)\n",
        "        rows.arrange(DOWN, buff=0.4, aligned_edge=LEFT)\n",
        "\n",
        "        expr.set_max_width(FRAME_WIDTH - 1)\n",
        "        expr.to_edge(UP)\n",
        "        expr.fix_in_frame()\n",
        "\n",
        "        for vect, pixel in zip(rgb_vects, lil_pixels):\n",
        "            vect.move_to(pixel)\n",
        "            vect.set_max_width(pixel.get_width())\n",
        "        rgb_vects.fix_in_frame()\n",
        "\n",
        "        # Reveal top\n",
        "        top_bar = FullScreenRectangle().set_fill(BLACK, 1)\n",
        "        top_bar.set_height(rgb_vects.get_height() + 0.5, stretch=True, about_edge=UP)\n",
        "        top_bar.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.scale(1.2, about_edge=DOWN),\n",
        "            FadeIn(top_bar, 2 * DOWN),\n",
        "        )\n",
        "\n",
        "        # Show sum\n",
        "        for n in range(len(ka_copy)):\n",
        "            self.remove(*ka_copy)\n",
        "            self.add(ka_copy[n])\n",
        "            self.add(expr[:3 * n + 2])\n",
        "            self.wait(0.25)\n",
        "        self.remove(*ka_copy)\n",
        "        if convert_to_vect:\n",
        "            self.play(LaggedStart(*(\n",
        "                Transform(lil_pixel, rgb_vect)\n",
        "                for lil_pixel, rgb_vect in zip(lil_pixels, rgb_vects)\n",
        "            )))\n",
        "        self.wait()\n",
        "        result = VGroup(top_bar, expr)\n",
        "        return result\n",
        "\n",
        "\n",
        "class BoxBlurMario(ImageConvolution):\n",
        "    kernel_tex = \"1 / 9\"\n",
        "    image_name = \"MarioSmall\"\n",
        "    pixel_stroke_opacity = 0.5\n",
        "    stops = (131, 360)\n",
        "    final_run_time = 8\n",
        "\n",
        "    def construct(self):\n",
        "        # March\n",
        "        for index in self.stops:\n",
        "            self.set_index(index)\n",
        "            self.zoom_to_kernel()\n",
        "            if index == self.stops[0]:\n",
        "                top_bar = self.show_pixel_sum(tex=R\"\\frac{1}{9}\")\n",
        "            self.wait()\n",
        "            self.zoom_to_new_pixel(run_time=8)\n",
        "            self.wait()\n",
        "            if index == self.stops[0]:\n",
        "                self.play(FadeOut(top_bar))\n",
        "            self.reset_frame()\n",
        "        self.set_index(len(self.pixel_array) - 1, run_time=self.final_run_time)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class BoxBlurCat(BoxBlurMario):\n",
        "    image_name = \"PixelArtCat\"\n",
        "    stops = ()\n",
        "    final_run_time = 20\n",
        "\n",
        "\n",
        "class GaussianBluMario(ImageConvolution):\n",
        "    kernel_decimal_places = 3\n",
        "    focus_index = 256\n",
        "    final_run_time = 10\n",
        "\n",
        "    def construct(self):\n",
        "        # March!\n",
        "        self.set_index(self.focus_index)\n",
        "        self.wait()\n",
        "        self.zoom_to_kernel()\n",
        "        self.wait()\n",
        "\n",
        "        # Gauss surface\n",
        "        kernel_array = self.kernel_array\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        gaussian = ParametricSurface(\n",
        "            lambda u, v: [u, v, np.exp(-(u**2) - v**2)],\n",
        "            u_range=(-3, 3),\n",
        "            v_range=(-3, 3),\n",
        "            resolution=(101, 101),\n",
        "        )\n",
        "        gaussian.set_color(BLUE, 0.8)\n",
        "        gaussian.match_width(kernel_array)\n",
        "        gaussian.stretch(2, 2)\n",
        "        gaussian.add_updater(lambda m: m.move_to(kernel_array, IN))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(gaussian),\n",
        "            frame.animate.reorient(10, 70),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "        top_bar = self.show_pixel_sum(convert_to_vect=False)\n",
        "        self.wait()\n",
        "        self.zoom_to_new_pixel()\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.set_height(8).reorient(0, 60).move_to(ORIGIN),\n",
        "            FadeOut(top_bar, time_span=(0, 1)),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # More walking\n",
        "        self.set_index(len(self.pixel_array), run_time=self.final_run_time)\n",
        "        self.wait()\n",
        "\n",
        "    def get_kernel(self):\n",
        "        # Oh good, hard coded, I hope you feel happy with yourself.\n",
        "        return np.array([\n",
        "            [0.00296902, 0.0133062, 0.0219382, 0.0133062, .00296902],\n",
        "            [0.0133062, 0.0596343, 0.0983203, 0.0596343, 0.0133062],\n",
        "            [0.0219382, 0.0983203, 0.162103, 0.0983203, 0.0219382],\n",
        "            [0.0133062, 0.0596343, 0.0983203, 0.0596343, 0.0133062],\n",
        "            [0.00296902, 0.0133062, 0.0219382, 0.0133062, 0.00296902],\n",
        "        ])\n",
        "\n",
        "\n",
        "class GaussianBlurCat(GaussianBluMario):\n",
        "    image_name = \"PixelArtCat\"\n",
        "    focus_index = 254\n",
        "\n",
        "    def construct(self):\n",
        "        for arr in self.pixel_array, self.conv_array:\n",
        "            arr.set_stroke(width=0.5, opacity=0.5)\n",
        "        super().construct()\n",
        "\n",
        "\n",
        "class GaussianBlurCatNoPause(GaussianBlurCat):\n",
        "    stops = ()\n",
        "    focus_index = 0\n",
        "    final_run_time = 30\n",
        "\n",
        "\n",
        "class SobelFilter1(ImageConvolution):\n",
        "    scalar_conv = True\n",
        "    image_name = \"BitRandy\"\n",
        "    pixel_stroke_width = 1\n",
        "    pixel_stroke_opacity = 0.2\n",
        "    kernel_color = YELLOW\n",
        "    stops = (194, 400, 801)\n",
        "    grayscale = True\n",
        "\n",
        "    def construct(self):\n",
        "        self.zoom_to_kernel()\n",
        "        # Show kernel\n",
        "        kernel = self.kernel_array\n",
        "        kernel.generate_target()\n",
        "        for square in kernel.target:\n",
        "            v = square[0].get_value()\n",
        "            square.set_fill(\n",
        "                rgb_to_color([2 * max(-v, 0), 2 * max(v, 0), 2 * max(v, 0)]),\n",
        "                opacity=0.5,\n",
        "                recurse=False\n",
        "            )\n",
        "            square.set_stroke(WHITE, 1, recurse=False)\n",
        "        self.play(MoveToTarget(kernel))\n",
        "        self.wait()\n",
        "        self.reset_frame()\n",
        "\n",
        "        # Example walking\n",
        "        for index in self.stops:\n",
        "            self.set_index(index)\n",
        "            self.zoom_to_kernel()\n",
        "            self.play(*(\n",
        "                square.animate.set_fill(opacity=0, recurse=False)\n",
        "                for square in kernel\n",
        "            ), rate_func=there_and_back_with_pause, run_time=3)\n",
        "            self.add(kernel)\n",
        "            self.wait()\n",
        "            self.zoom_to_new_pixel()\n",
        "            self.wait()\n",
        "            self.reset_frame()\n",
        "        self.set_index(len(self.pixel_array) - 1, run_time=20)\n",
        "\n",
        "    def get_kernel(self):\n",
        "        return np.array([\n",
        "            [-0.25, 0, 0.25],\n",
        "            [-0.5, 0, 0.5],\n",
        "            [-0.25, 0, 0.25],\n",
        "        ])\n",
        "\n",
        "\n",
        "class SobelFilter2(SobelFilter1):\n",
        "    stops = ()\n",
        "\n",
        "    def get_kernel(self):\n",
        "        return super().get_kernel().T\n",
        "\n",
        "\n",
        "class SobelFilterCat(SobelFilter1):\n",
        "    scalar_conv = True\n",
        "    image_name = \"PixelArtCat\"\n",
        "    pixel_stroke_width = 1\n",
        "    pixel_stroke_opacity = 0.2\n",
        "    kernel_color = WHITE\n",
        "    stops = ()\n",
        "    grayscale = False\n",
        "\n",
        "\n",
        "class SobelFilterKirby(SobelFilter1):\n",
        "    image_name = \"KirbySmall\"\n",
        "    grayscale = False\n",
        "\n",
        "\n",
        "class SharpenFilter(ImageConvolution):\n",
        "    image_name = \"KirbySmall\"\n",
        "    kernel_decimal_places = 1\n",
        "    grayscale = False\n",
        "\n",
        "    def construct(self):\n",
        "        for arr in self.pixel_array, self.conv_array:\n",
        "            arr.set_stroke(WHITE, 0.25, 0.5)\n",
        "        for square in self.kernel_array:\n",
        "            square[0].scale(0.6)\n",
        "        self.set_index(len(self.pixel_array) - 1, run_time=20)\n",
        "\n",
        "    def get_kernel(self):\n",
        "        return np.array([\n",
        "            [0.0, 0.0, -0.25, 0.0, 0.0],\n",
        "            [0.0, -0.25, -0.5, -0.25, 0.0],\n",
        "            [-0.25, -0.5, 5.0, -0.5, -0.25],\n",
        "            [0.0, -0.25, -0.5, -0.25, 0.0],\n",
        "            [0.0, 0.0, -0.25, 0.0, 0.0],\n",
        "        ])\n",
        "\n",
        "\n",
        "# Convolution theorem\n",
        "\n",
        "\n",
        "class ContrastConvolutionToMultiplication(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up divide\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.set_stroke(GREY, 2)\n",
        "\n",
        "        kw = dict(font_size=60)\n",
        "        conv_name = Text(\"Convolution\", **kw)\n",
        "        mult_name = Text(\"Multiplication\", **kw)\n",
        "        conv_name.set_x(-FRAME_WIDTH / 4).to_edge(UP)\n",
        "        mult_name.set_x(FRAME_WIDTH / 4).to_edge(UP)\n",
        "\n",
        "        self.add(v_line)\n",
        "        self.add(conv_name)\n",
        "        self.add(mult_name)\n",
        "\n",
        "        # Set up arrays\n",
        "        arr1 = np.arange(1, 6)\n",
        "        arr2 = np.arange(6, 11)\n",
        "        conv = np.convolve(arr1, arr2)\n",
        "        prod = arr1 * arr2\n",
        "        quart = FRAME_WIDTH / 4\n",
        "\n",
        "        left_arrays, right_arrays = (\n",
        "            VGroup(*(\n",
        "                self.get_array_mobject(arr, color)\n",
        "                for arr, color in [(arr1, BLUE), (arr2, YELLOW)]\n",
        "            )).arrange(DOWN, buff=1.0).move_to(vect * quart + UP)\n",
        "            for vect in [LEFT, RIGHT]\n",
        "        )\n",
        "\n",
        "        conv_array = self.get_array_mobject(conv, color=TEAL)\n",
        "        prod_array = self.get_array_mobject(prod, color=TEAL)\n",
        "        conv_array.next_to(left_arrays, DOWN, buff=1.5)\n",
        "        prod_array.next_to(right_arrays, DOWN, buff=1.5)\n",
        "\n",
        "        self.add(left_arrays)\n",
        "        self.add(right_arrays)\n",
        "\n",
        "        # Show convolution\n",
        "        top_arr = left_arrays[0]\n",
        "        low_arr = left_arrays[1]\n",
        "        low_arr.generate_target()\n",
        "        low_arr.target.rotate(PI, about_point=low_arr.elements[0].get_center())\n",
        "        for elem in low_arr.target[1:-1]:\n",
        "            elem.rotate(PI)\n",
        "        low_arr.target[2:-2:2].set_y(low_arr[1].get_y(DOWN))\n",
        "        self.play(\n",
        "            FadeIn(VGroup(conv_array[0], conv_array[-1])),\n",
        "            MoveToTarget(low_arr, path_arc=PI),\n",
        "        )\n",
        "        for n, elem in enumerate(conv_array.elements):\n",
        "            pairs = get_aligned_pairs(top_arr.elements, low_arr.elements, n)\n",
        "\n",
        "            self.play(\n",
        "                get_row_shift(top_arr.elements, low_arr.elements, n),\n",
        "                MaintainPositionRelativeTo(low_arr[::2], low_arr.elements),\n",
        "                run_time=0.25\n",
        "            )\n",
        "\n",
        "            lines = VGroup(*(Line(m1, m2, buff=0.1) for m1, m2 in pairs))\n",
        "            lines.set_stroke(TEAL, 1)\n",
        "\n",
        "            self.add(lines, elem)\n",
        "\n",
        "            tally = 0\n",
        "            for (m1, m2), line in zip(pairs, lines):\n",
        "                tally += m1.get_value() * m2.get_value()\n",
        "                lines.set_stroke(width=1)\n",
        "                line.set_stroke(width=4)\n",
        "                elem.set_value(tally)\n",
        "                self.wait(0.25)\n",
        "            self.wait(0.25)\n",
        "            self.remove(lines)\n",
        "            self.add(conv_array[2 * n + 2])\n",
        "        self.wait()\n",
        "\n",
        "        # Show multiplication\n",
        "        low_arr = right_arrays[0]\n",
        "        top_arr = right_arrays[1]\n",
        "        lines = VGroup(*(\n",
        "            Line(e1, e2, buff=0.1)\n",
        "            for e1, e2 in zip(top_arr.elements, low_arr.elements)\n",
        "        ))\n",
        "        lines.set_stroke(TEAL, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(VGroup(prod_array[0], prod_array[-1])),\n",
        "            FadeIn(lines),\n",
        "        )\n",
        "        for n, elem in enumerate(prod_array.elements):\n",
        "            lines.set_stroke(width=1)\n",
        "            lines[n].set_stroke(width=4)\n",
        "            self.add(elem)\n",
        "            self.add(prod_array[2 * n + 2])\n",
        "            self.wait(0.5)\n",
        "        self.play(FadeOut(lines))\n",
        "\n",
        "    def get_array_mobject(self, array, color=WHITE, font_size=48):\n",
        "        kw = dict(font_size=font_size)\n",
        "        result = VGroup(OldTex(\"[\", **kw))\n",
        "        commas = VGroup()\n",
        "        elements = VGroup()\n",
        "        for index, elem in enumerate(array):\n",
        "            int_mob = Integer(elem, **kw)\n",
        "            int_mob.index = index\n",
        "            elements.add(int_mob)\n",
        "            result.add(int_mob)\n",
        "            comma = OldTex(\",\", **kw)\n",
        "            commas.add(comma)\n",
        "            result.add(comma)\n",
        "        result.remove(commas[-1])\n",
        "        commas.remove(commas[-1])\n",
        "        result.add(OldTex(\"]\", **kw))\n",
        "        result.arrange(RIGHT, buff=0.1)\n",
        "        commas.set_y(result[1].get_y(DOWN))\n",
        "\n",
        "        elements.set_color(color)\n",
        "        result.elements = elements\n",
        "        result.commas = commas\n",
        "\n",
        "        return result\n",
        "\n",
        "\n",
        "class BigPolynomials(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Initialize grid\n",
        "        N = 8\n",
        "        height = 6.5\n",
        "        grid = Square().get_grid(N, N, height=height, buff=0, group_by_rows=True)\n",
        "        grid.set_stroke(WHITE, 1)\n",
        "        grid.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        grid.shift(2 * LEFT)\n",
        "        for i, row in enumerate(grid):\n",
        "            if i == N - 2:\n",
        "                for j, square in enumerate(row):\n",
        "                    if j == N - 2:\n",
        "                        self.replace_square(square, OldTex(R\"\\ddots\"))\n",
        "                    else:\n",
        "                        self.replace_square(square, OldTex(R\"\\vdots\"))\n",
        "            else:\n",
        "                self.replace_square(row[N - 2], OldTex(R\"\\cdots\"))\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        # Polynomial terms\n",
        "        a_terms, b_terms = all_terms = [\n",
        "            VGroup(*(\n",
        "                Tex(RF\"{letter}_{{{n}}} x^{{{n}}}\", font_size=24)\n",
        "                for n in (*range(N - 1), 99)\n",
        "            ))\n",
        "            for letter in [\"a\", \"b\"]\n",
        "        ]\n",
        "        for terms in all_terms:\n",
        "            terms[0].remove(*terms[0][-2:])\n",
        "            terms[1].remove(*terms[1][-1:])\n",
        "\n",
        "        for terms, group, vect in [(a_terms, grid[0], UP), (b_terms, grid, LEFT)]:\n",
        "            for term, square in zip(terms, group):\n",
        "                term.next_to(square, vect, SMALL_BUFF)\n",
        "\n",
        "        a_terms[-2].become(OldTex(R\"\\cdots\", font_size=24).move_to(a_terms[-2]).shift(0.02 * DOWN))\n",
        "        b_terms[-2].become(OldTex(R\"\\vdots\", font_size=24).move_to(b_terms[-2]))\n",
        "\n",
        "        a_terms.set_color(BLUE_C)\n",
        "        b_terms.set_color(TEAL_C)\n",
        "\n",
        "        self.add(a_terms)\n",
        "        self.add(b_terms)\n",
        "\n",
        "        # Plusses\n",
        "        for terms, vect in (a_terms, RIGHT), (b_terms, DOWN):\n",
        "            terms.plusses = VGroup()\n",
        "            for t1, t2 in zip(terms, terms[1:]):\n",
        "                plus = OldTex(\"+\", font_size=24).match_color(terms)\n",
        "                plus.move_to(midpoint(t1.get_corner(vect), t2.get_corner(-vect)))\n",
        "                terms.plusses.add(plus)\n",
        "            self.add(terms.plusses)\n",
        "\n",
        "        # Product terms\n",
        "        prod_terms = VGroup()\n",
        "        diags = VGroup(*(VGroup() for n in range(11)))\n",
        "\n",
        "        for i, row in enumerate(grid):\n",
        "            pre_b = b_terms[i][:2]\n",
        "            if i == N - 2:\n",
        "                continue\n",
        "            if i == N - 1:\n",
        "                i = 99\n",
        "            for j, square in enumerate(row):\n",
        "                pre_a = a_terms[j][:2]\n",
        "                if j == N - 2:\n",
        "                    continue\n",
        "                if j == N - 1:\n",
        "                    j = 99\n",
        "                term = OldTex(f\"a_{{{j}}}\", f\"b_{{{i}}}\", f\"x^{{{i + j}}}\", font_size=20)\n",
        "                if i + j == 0:\n",
        "                    term[2].remove(*term[2][:-2])\n",
        "                elif i + j == 1:\n",
        "                    term[2].remove(term[2][:-2])\n",
        "                term[0].match_color(a_terms)\n",
        "                term[1].match_color(b_terms)\n",
        "                term.set_max_width(0.9 * square.get_width())\n",
        "                term.pre_a = pre_a\n",
        "                term.pre_b = pre_b\n",
        "                term.move_to(square)\n",
        "                prod_terms.add(term)\n",
        "\n",
        "                if i + j < len(diags):\n",
        "                    diags[i + j].add(term)\n",
        "\n",
        "        # Animate\n",
        "        a_label = Text(\"100 terms\", font_size=30)\n",
        "        a_label.next_to(a_terms, UP)\n",
        "        b_label = Text(\"100 terms\", font_size=30)\n",
        "        b_label.next_to(b_terms, UP, MED_LARGE_BUFF, aligned_edge=RIGHT)\n",
        "        product_count = OldTexText(R\"$100 \\times 100 = 10{,}000$ \\\\ products\", font_size=60)\n",
        "        product_count.move_to(midpoint(grid.get_right(), RIGHT_SIDE))\n",
        "\n",
        "        self.play(\n",
        "            FlashAround(a_terms, run_time=2, time_width=2),\n",
        "            FadeIn(a_label)\n",
        "        )\n",
        "        self.play(\n",
        "            FlashAround(b_terms, run_time=2, time_width=2),\n",
        "            FadeIn(b_label),\n",
        "            FadeOut(a_label)\n",
        "        )\n",
        "        self.play(FadeOut(b_label))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                AnimationGroup(\n",
        "                    TransformFromCopy(term.pre_a, term[0]),\n",
        "                    TransformFromCopy(term.pre_b, term[1]),\n",
        "                    FadeIn(term[2], rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "                )\n",
        "                for term in prod_terms\n",
        "            ), lag_ratio=0.1, run_time=5),\n",
        "            Write(product_count),\n",
        "        )\n",
        "        self.add(prod_terms)\n",
        "\n",
        "        # Group along diagonals\n",
        "        self.play(prod_terms.animate.set_opacity(0.2))\n",
        "        for n in range(len(diags)):\n",
        "            diags.generate_target()\n",
        "            diags.target.set_opacity(0.2)\n",
        "            diags.target[n].set_opacity(1.0)\n",
        "            self.play(MoveToTarget(diags))\n",
        "        self.wait()\n",
        "\n",
        "    def replace_square(self, square, mob):\n",
        "        mob.move_to(square)\n",
        "        mob.set_max_width(square.get_width() / 2)\n",
        "        mob.set_max_height(square.get_width() / 2)\n",
        "        square.set_opacity(0)\n",
        "        square.add(mob)\n",
        "\n",
        "\n",
        "class FunctionToCoefficientCommutativeDiagram(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes1, axes2, axes3 = all_axes = VGroup(*(\n",
        "            Axes((-3, 3), (-2, 4), width=6, height=4)\n",
        "            for x in range(3)\n",
        "        ))\n",
        "\n",
        "        all_axes.arrange(RIGHT, buff=1.0)\n",
        "        axes3.shift(4 * RIGHT)\n",
        "        all_axes.set_width(FRAME_WIDTH - 1)\n",
        "        all_axes.move_to(UP)\n",
        "\n",
        "        # Graphs\n",
        "        def p1(x):\n",
        "            return 0.2 * (x + 3) * x * (x - 2)\n",
        "\n",
        "        def p2(x):\n",
        "            return -0.1 * (x + 2) * (x - 2) * (x - 3)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            axes1.get_graph(p1).set_stroke(BLUE),\n",
        "            axes2.get_graph(p2).set_stroke(TEAL),\n",
        "            axes3.get_graph(lambda x: p1(x) * p2(x)).set_stroke(YELLOW),\n",
        "        )\n",
        "        graphs.set_stroke(width=2)\n",
        "\n",
        "        kw = dict(font_size=30)\n",
        "        graph_labels = VGroup(*(\n",
        "            Tex(tex, **kw).next_to(axes.get_top(), RIGHT, aligned_edge=UP)\n",
        "            for tex, axes in zip([\"f(x)\", \"g(x)\", R\"f(x) \\cdot g(x)\"], all_axes)\n",
        "        ))\n",
        "\n",
        "        # Coefficients\n",
        "        a_labels, b_labels, conv_label = coef_labels = VGroup(\n",
        "            Tex(R\"(a_0, a_1, \\dots, a_n)\", **kw),\n",
        "            Tex(R\"(b_0, b_1, \\dots, b_m)\", **kw),\n",
        "            VGroup(\n",
        "                Tex(\"c_0 = a_0 b_0\", **kw),\n",
        "                Tex(\"c_1 = a_0 b_1 + a_1 b_0\", **kw),\n",
        "                Tex(\"c_2 = a_0 b_2 + a_1 b_1 + a_2 b_0\", **kw),\n",
        "                Tex(\"c_3 = a_0 b_3 + a_1 b_2 + a_2 b_1 + a_3 b_0\", **kw),\n",
        "                Tex(R\"\\vdots\", **kw),\n",
        "            ).arrange(DOWN, aligned_edge=LEFT).scale(0.85)\n",
        "        )\n",
        "        v_arrows = VGroup()\n",
        "        for labels, graph, axes in zip(coef_labels, graphs, all_axes):\n",
        "            arrow = Vector(0.8 * DOWN)\n",
        "            arrow.next_to(axes, DOWN)\n",
        "            v_arrows.add(arrow)\n",
        "            labels.next_to(arrow, DOWN)\n",
        "            labels.match_color(graph)\n",
        "\n",
        "            arrow_label = Text(\"Coefficients\", font_size=24)\n",
        "            arrow_label.next_to(arrow, RIGHT, buff=0.2)\n",
        "            arrow.add(arrow_label)\n",
        "\n",
        "        conv_label.to_edge(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        # Operations\n",
        "        mult_arrow = Arrow(axes2, axes3, buff=0.1, stroke_width=6)\n",
        "        mult_arrow_label = Text(\"Multiplication\", font_size=30)\n",
        "        mult_arrow_label.next_to(mult_arrow, UP, SMALL_BUFF)\n",
        "        mult_arrow = VGroup(mult_arrow, mult_arrow_label)\n",
        "        mult_arrow.set_color(RED)\n",
        "\n",
        "        coef_rect = SurroundingRectangle(coef_labels[:2])\n",
        "        coef_rect.set_stroke(GREY, 2)\n",
        "        conv_arrow = Arrow(coef_rect, conv_label[0], buff=0.3, stroke_width=6)\n",
        "        conv_arrow_label = Text(\"Convolution\", font_size=30)\n",
        "        conv_arrow_label.next_to(conv_arrow, DOWN, SMALL_BUFF)\n",
        "        conv_arrow = VGroup(conv_arrow, conv_arrow_label)\n",
        "        conv_arrow.set_color(RED)\n",
        "\n",
        "        # Animations\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, graphs[:2]),\n",
        "            LaggedStartMap(FadeIn, graph_labels[:2]),\n",
        "            LaggedStartMap(FadeIn, all_axes[:2]),\n",
        "        )\n",
        "        self.play(LaggedStart(\n",
        "            Write(mult_arrow, run_time=1),\n",
        "            TransformFromCopy(graphs[0], graphs[2].copy(), remover=True),\n",
        "            TransformFromCopy(graphs[1], graphs[2]),\n",
        "            TransformFromCopy(all_axes[0], all_axes[2].copy(), remover=True),\n",
        "            TransformFromCopy(all_axes[1], all_axes[2]),\n",
        "            TransformFromCopy(graph_labels[0], graph_labels[2][:5]),\n",
        "            TransformFromCopy(graph_labels[1], graph_labels[2][5:]),\n",
        "        ), lag_ratio=0.2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(Write, v_arrows[:2], lag_ratio=0.7),\n",
        "            LaggedStartMap(FadeIn, coef_labels[:2], shift=DOWN, lag_ratio=0.7),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(coef_rect), FadeIn(conv_arrow))\n",
        "        self.play(\n",
        "            FadeTransformPieces(a_labels.copy(), conv_label),\n",
        "            FadeTransformPieces(b_labels.copy(), conv_label),\n",
        "        )\n",
        "\n",
        "        # Pointwise product\n",
        "        all_dots = Group(*(\n",
        "            Group(*(\n",
        "                GlowDot(axes.i2gp(x, graph), radius=0.1, glow_factor=0.8, color=WHITE)\n",
        "                for x in range(-3, 4)\n",
        "            ))\n",
        "            for axes, graph in zip(all_axes, graphs)\n",
        "        ))\n",
        "        all_circles = VGroup(*(\n",
        "            VGroup(*(\n",
        "                Circle(radius=0.1).set_stroke(YELLOW, 2).move_to(dot)\n",
        "                for dot in dots\n",
        "            ))\n",
        "            for dots in all_dots\n",
        "        ))\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, all_dots[0], scale=0.5, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, all_dots[1], scale=0.5, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowSubmobjectsOneByOne(all_circles[0]),\n",
        "            ShowSubmobjectsOneByOne(all_circles[1]),\n",
        "            ShowSubmobjectsOneByOne(all_circles[2]),\n",
        "            ShowIncreasingSubsets(all_dots[2]),\n",
        "            run_time=4,\n",
        "            rate_func=linear,\n",
        "        )\n",
        "        self.remove(all_circles)\n",
        "        self.wait()\n",
        "        self.play(Write(v_arrows[2]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class DataPointsToPolynomial(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = Axes((-1, 10), (-3, 3), width=FRAME_WIDTH - 2, height=4)\n",
        "        kw = dict(font_size=30)\n",
        "        axes.add(OldTex(\"x\", **kw).next_to(axes.x_axis.get_end(), DR, buff=0.2))\n",
        "        axes.add(OldTex(\"y\", **kw).next_to(axes.y_axis.get_end(), LEFT, MED_SMALL_BUFF))\n",
        "\n",
        "        self.add(axes)\n",
        "\n",
        "        # Graphs and data points\n",
        "        y_values = [3, 1, 2, -3, -1, 2, 0, 0, 1]\n",
        "        data = list(enumerate(y_values))\n",
        "        dots = Group(*(\n",
        "            GlowDot(axes.c2p(x, y), glow_factor=0.8, radius=0.1)\n",
        "            for x, y in data\n",
        "        ))\n",
        "        dots.set_color(TEAL)\n",
        "        circles = VGroup(*(\n",
        "            Circle(radius=0.075).set_stroke(YELLOW, 2).move_to(dot)\n",
        "            for dot in dots\n",
        "        ))\n",
        "\n",
        "        graphs = VGroup(*(\n",
        "            axes.get_graph(get_lagrange_polynomial(data[:n]))\n",
        "            for n in range(1, len(data) + 1)\n",
        "        ))\n",
        "        graphs.set_stroke(BLUE, 2)\n",
        "\n",
        "        # Increasing polynomials\n",
        "        poly_tex = OldTex(\n",
        "            \"a_0\", \"+\", \"a_1 x\", \"+\", *it.chain(*(\n",
        "                (f\"a_{n} x^{n}\", \"+\")\n",
        "                for n in range(2, len(data) - 1)\n",
        "            ))\n",
        "        )\n",
        "        poly_tex.to_corner(UR)\n",
        "\n",
        "        graph = graphs[1].copy()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, dots[:2], lag_ratio=0.7, run_time=1),\n",
        "            LaggedStartMap(ShowCreationThenFadeOut, circles[:2], lag_ratio=0.2, run_time=1),\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(graph),\n",
        "            FadeIn(poly_tex[:3])\n",
        "        )\n",
        "        self.wait()\n",
        "        for n in range(2, len(data) - 1):\n",
        "            self.play(\n",
        "                ShowCreationThenFadeOut(circles[n], run_time=1.5),\n",
        "                FadeIn(dots[n]),\n",
        "                Transform(graph, graphs[n]),\n",
        "                FadeIn(poly_tex[2 * n - 1:2 * n + 1], time_span=(0, 1), lag_ratio=0.1),\n",
        "                run_time=2\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class PolynomialSystem(InteractiveScene):\n",
        "    N = 8\n",
        "\n",
        "    def construct(self):\n",
        "        # Setup polynomials\n",
        "        frame = self.camera.frame\n",
        "        N = self.N\n",
        "        coefs = VGroup(*(Tex(Rf\"c_{{{n}}}\") for n in range(N)))\n",
        "        coefs.set_submobject_colors_by_gradient(BLUE, TEAL)\n",
        "        x_powers = VGroup(*(Tex(Rf\"x^{{{n}}}\") for n in range(N)))\n",
        "        poly_x = self.get_polynomial(coefs, x_powers)\n",
        "\n",
        "        top_lhs = Tex(\"h(x) = \")\n",
        "        top_lhs.next_to(poly_x[0][0], LEFT, buff=0.1)\n",
        "        top_eq = VGroup(top_lhs, poly_x)\n",
        "        top_eq.center()\n",
        "\n",
        "        fg = Tex(R\"f(x) \\cdot g(x)\")\n",
        "        eq = Tex(\"=\")\n",
        "        eq.rotate(PI / 2)\n",
        "        eq.next_to(top_lhs[:4], UP)\n",
        "        fg.next_to(eq, UP).shift_onto_screen()\n",
        "\n",
        "        self.add(top_eq)\n",
        "\n",
        "        # Suppose you don't know coefficients\n",
        "        words = Text(\"Suppose these are a mystery\")\n",
        "        words.next_to(poly_x, UP, buff=2.0)\n",
        "        arrows = VGroup(*(\n",
        "            Arrow(\n",
        "                interpolate(\n",
        "                    words.get_corner(DL) + 0.5 * RIGHT,\n",
        "                    words.get_corner(DR) + 0.5 * LEFT,\n",
        "                    n / (N - 1)),\n",
        "                coef,\n",
        "                color=coef.get_color(),\n",
        "            )\n",
        "            for n, coef in enumerate(poly_x.coefs)\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(words, lag_ratio=0.1),\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "            LaggedStart(*(\n",
        "                FlashAround(coef, time_width=1)\n",
        "                for coef in poly_x.coefs\n",
        "            ), lag_ratio=0.1, run_time=3)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(eq),\n",
        "            FadeIn(fg, 0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Sweep away\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(words, UP),\n",
        "                FadeOut(arrows, 2 * UP, lag_ratio=0.05),\n",
        "                FadeOut(fg, UP),\n",
        "                FadeOut(eq, 1.5 * UP),\n",
        "                top_eq.animate.to_edge(UP)\n",
        "            ),\n",
        "            frame.animate.set_height(11, about_edge=UR),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Set up the large system\n",
        "        lhss = VGroup(*(Tex(f\"h({n})=\") for n in range(N)))\n",
        "        rhss = VGroup(*(\n",
        "            self.get_polynomial(\n",
        "                coefs.copy(),\n",
        "                # VGroup(*(Integer(x**n) for n in range(N)))\n",
        "                VGroup(*(Tex(f\"{x}^{{{n}}}\") for n in range(N)))\n",
        "            )\n",
        "            for x in range(N)\n",
        "        ))\n",
        "        equations = VGroup()\n",
        "        for lhs, rhs in zip(lhss, rhss):\n",
        "            lhs.next_to(rhs[0][0], LEFT, 0.1)\n",
        "            equations.add(VGroup(lhs, rhs))\n",
        "        equations.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        equations.next_to(top_eq, DOWN, aligned_edge=LEFT, buff=1.5)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                FadeTransform(top_eq.copy(), eq)\n",
        "                for eq in equations\n",
        "            ), lag_ratio=0.02, run_time=3),\n",
        "        )\n",
        "\n",
        "        # Suppose you _do_ know h(0), h(1), h(2), etc.\n",
        "        words2 = Text(\"But suppose\\nyou do know\\nthese\", t2s={\"do\": ITALIC})\n",
        "        words2.set_color(YELLOW)\n",
        "        words2.move_to(midpoint(equations.get_left(), frame.get_left()))\n",
        "        words2.align_to(equations, UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(words2),\n",
        "            LaggedStart(*(FlashAround(lhs[:4], time_width=1.5) for lhs in lhss), run_time=5, lag_ratio=0.1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Trow out the inputs\n",
        "        inputs = VGroup(*(lhs[2] for lhs in lhss))\n",
        "        inputs.save_state()\n",
        "        consts = VGroup(*(\n",
        "            power\n",
        "            for eq in rhss\n",
        "            for power in eq.powers\n",
        "        ))\n",
        "        boxes = VGroup(*(VGroup(SurroundingRectangle(const, buff=0)) for const in consts))\n",
        "        boxes.set_stroke(RED, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(words2, LEFT, rate_func=running_start),\n",
        "            inputs.animate.set_color(RED).shift(2 * LEFT).set_anim_args(run_time=1.5, lag_ratio=0.2, path_arc=PI / 2),\n",
        "            Transform(consts, boxes, lag_ratio=0.01, run_time=3),\n",
        "        )\n",
        "        self.play(FadeOut(inputs, LEFT, lag_ratio=0.2, rate_func=running_start))\n",
        "        inputs.restore()\n",
        "        inputs.set_opacity(0)\n",
        "        self.add(lhss)\n",
        "\n",
        "        # Add roots of unity\n",
        "        kw = dict(tex_to_color_map={R\"\\omega\": YELLOW})\n",
        "        omega_def = OldTex(\n",
        "            Rf\"\"\"\n",
        "            \\text{{Let }} \\omega = e^{{2\\pi i / {N}}} \\qquad\n",
        "            \\text{{Notice }} \\omega^{{{N}}} = 1\n",
        "            \"\"\",\n",
        "            font_size=60,\n",
        "            **kw\n",
        "        )\n",
        "        omega_def.next_to(lhss, UP, buff=1.5, aligned_edge=LEFT)\n",
        "\n",
        "        all_omega_powers = [\n",
        "            VGroup(*(\n",
        "                Tex(Rf\"\\omega^{{{(k * n) % N}}}\", **kw)\n",
        "                for n in range(N)\n",
        "            ))\n",
        "            for k in range(0, N)\n",
        "        ]\n",
        "        new_rhss = VGroup(*(\n",
        "            self.get_polynomial(coefs.copy(), omega_powers)\n",
        "            for omega_powers in all_omega_powers\n",
        "        ))\n",
        "\n",
        "        new_lhss = VGroup(\n",
        "            *(Tex(Rf\"h(\\omega^{n}) = \") for n in range(N))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(13, about_edge=DR),\n",
        "            FadeIn(omega_def),\n",
        "            top_eq.animate.shift(1.75 * UP),\n",
        "        )\n",
        "        for old_lhs, old_rhs, new_lhs, new_rhs in zip(lhss, rhss, new_lhss, new_rhss):\n",
        "            new_lhs.move_to(old_lhs, LEFT)\n",
        "            new_rhs.next_to(new_lhs, RIGHT, buff=0.1)\n",
        "            new_lhs[2].set_color(YELLOW)\n",
        "            self.play(\n",
        "                FadeTransformPieces(old_lhs, new_lhs),\n",
        "                FadeTransformPieces(old_rhs, new_rhs),\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        # Label as DFT\n",
        "        brace = Brace(new_lhss, LEFT)\n",
        "        kw = dict(font_size=60)\n",
        "        label = OldTexText(R\"Discrete\\\\Fourier\\\\Transform\", alignment=R\"\\raggedright\", isolate=list(\"DFT\"), **kw)\n",
        "        label.next_to(brace, LEFT)\n",
        "\n",
        "        sub_label = OldTexText(\"of $(c_i)$\", **kw)[0]\n",
        "        sub_label[2:].set_color(BLUE)\n",
        "        sub_label.next_to(label, DOWN, MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        self.play(GrowFromCenter(brace), FadeIn(label))\n",
        "        self.play(Write(sub_label))\n",
        "        self.wait()\n",
        "\n",
        "        # Show redundancy\n",
        "        last_rects = VGroup()\n",
        "        for n in range(N):\n",
        "            tex = Rf\"\\omega^{{{n}}}\"\n",
        "            rects = VGroup()\n",
        "            for rhs in new_rhss:\n",
        "                for power in rhs.powers[1:]:\n",
        "                    if power.get_tex() == tex:\n",
        "                        rects.add(SurroundingRectangle(power))\n",
        "            rects.set_stroke(RED, 3)\n",
        "            self.play(FadeIn(rects), FadeOut(last_rects))\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "\n",
        "        # Set up two arrays\n",
        "        pre_h_list = VGroup(*(lhs[:5] for lhs in new_lhss))\n",
        "        h_list = pre_h_list.copy()\n",
        "        h_list.next_to(new_lhss, LEFT, buff=2.0)\n",
        "        h_rect = SurroundingRectangle(h_list, buff=0.25)\n",
        "        h_rect.set_stroke(WHITE, 1)\n",
        "        h_rect.set_fill(GREY_E, 1)\n",
        "\n",
        "        c_list = poly_x.coefs.copy()\n",
        "        for c, h in zip(c_list, h_list):\n",
        "            c.scale(1.25)\n",
        "            c.move_to(h)\n",
        "\n",
        "        c_rect = h_rect.copy()\n",
        "        c_rect.shift(5 * LEFT)\n",
        "        c_list.move_to(c_rect)\n",
        "\n",
        "        short_label = OldTexText(\"DFT\", isolate=list(\"DFT\"))\n",
        "        short_label.next_to(h_rect, UP, buff=0.5).shift(sub_label.get_width() * LEFT / 2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(c_rect),\n",
        "            TransformFromCopy(new_rhss[0].coefs, c_list, path_arc=-PI / 3)\n",
        "        )\n",
        "        self.play(\n",
        "            TransformMatchingTex(label, short_label),\n",
        "            sub_label.animate.scale(48 / 60).next_to(short_label, RIGHT),\n",
        "            FadeInFromPoint(h_rect, pre_h_list.get_center()),\n",
        "            TransformFromCopy(pre_h_list, h_list),\n",
        "        )\n",
        "\n",
        "        # Indicate fast back and forth\n",
        "        top_arrow = Arrow(c_rect, h_rect).shift(2 * UP)\n",
        "        low_arrow = Arrow(h_rect, c_rect).shift(2 * DOWN)\n",
        "\n",
        "        for arrow in (top_arrow, low_arrow):\n",
        "            fft_label = Text(\"FFT\")\n",
        "            fft_label.next_to(arrow, UP)\n",
        "            run_time = OldTex(R\"\\mathcal{O}\\big(N\\log(N)\\big)\")\n",
        "            run_time.next_to(arrow, DOWN)\n",
        "            arrow.fft_label = fft_label\n",
        "            arrow.run_time = run_time\n",
        "\n",
        "            self.play(\n",
        "                GrowArrow(arrow),\n",
        "                FadeIn(fft_label, arrow.get_vector())\n",
        "            )\n",
        "            self.play(FadeIn(run_time, 0.5 * DOWN))\n",
        "            self.wait()\n",
        "\n",
        "    def get_polynomial(self, coefs, powers, buff=0.1):\n",
        "        result = VGroup()\n",
        "        result.plusses = VGroup()\n",
        "        result.dots = VGroup()\n",
        "        for coef, power in zip(coefs, powers):\n",
        "            if power is powers[0]:\n",
        "                power.scale(0, about_edge=LEFT)\n",
        "            plus = OldTex(\"+\")  # Font size?\n",
        "            result.add(coef)\n",
        "            if isinstance(power, Integer):\n",
        "                dot = OldTex(R\"\\cdot\")\n",
        "            else:\n",
        "                dot = VGroup(VectorizedPoint())\n",
        "            result.dots.add(dot)\n",
        "            result.add(dot)\n",
        "            result.add(power, plus)\n",
        "            result.plusses.add(plus)\n",
        "        result.remove(result[-1])  # Stray plus\n",
        "        result.arrange(RIGHT, buff=buff)\n",
        "        for mob in result:\n",
        "            mob.shift(mob[0].get_y(DOWN) * DOWN)\n",
        "        for coef, dot in zip(coefs, result.dots):\n",
        "            if not isinstance(dot, Tex):\n",
        "                coef.shift(buff * RIGHT)\n",
        "        result.dots.set_y(result.get_y())\n",
        "        result.coefs = coefs\n",
        "        result.powers = powers\n",
        "        return result\n",
        "\n",
        "\n",
        "class RootsOfUnity(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add plane\n",
        "        plane = ComplexPlane((-2, 2), (-2, 2))\n",
        "        plane.scale(2.0 / 1.5)\n",
        "        plane.to_corner(UL)\n",
        "        plane.add_coordinate_labels([1, 1j], font_size=24)\n",
        "\n",
        "        circle = Circle(radius=plane.x_axis.get_unit_size())\n",
        "        circle.move_to(plane.n2p(0))\n",
        "        circle.set_stroke(YELLOW, 2)\n",
        "\n",
        "        N = 8\n",
        "        roots = [np.exp(TAU * 1j * k / N) for k in range(N)]\n",
        "        root_dots = Group(*(GlowDot(plane.n2p(root)) for root in roots))\n",
        "        root_lines = VGroup(*(Line(plane.n2p(0), d.get_center()) for d in root_dots))\n",
        "        root_lines.set_stroke(YELLOW, 1)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(root_lines[0], root_dots[0])\n",
        "        self.play(\n",
        "            ShowCreation(circle),\n",
        "            Rotate(Group(root_lines[0], root_dots[0]), TAU, about_point=plane.n2p(0)),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show powers\n",
        "        kw = dict(tex_to_color_map={R\"\\omega\": YELLOW}, font_size=36)\n",
        "        max_power = 3 * N\n",
        "        powers = VGroup(*(\n",
        "            OldTex(Rf\"\\omega^{{{k}}}\", **kw)\n",
        "            for k in range(max_power)\n",
        "        ))\n",
        "        powers.set_backstroke(BLACK, 3)\n",
        "        for power, line in zip(powers, it.cycle(root_lines)):\n",
        "            vect = line.get_vector()\n",
        "            vect += UP if line.get_vector()[1] > -0.1 else DOWN\n",
        "            vect += RIGHT if line.get_vector()[0] > -0.1 else LEFT\n",
        "            power.next_to(line.get_end(), normalize(vect), buff=SMALL_BUFF)\n",
        "\n",
        "        shown_powers = VGroup(powers[0])\n",
        "        moving_power = powers[0].copy()\n",
        "        for k in range(max_power - 1):\n",
        "            shown_powers.generate_target()\n",
        "            shown_powers.target.set_opacity(0.8)\n",
        "            if k > N - 1:\n",
        "                shown_powers.target[(k + 1) % N].set_opacity(0)\n",
        "\n",
        "            kw = dict(path_arc=TAU / N)\n",
        "            self.play(\n",
        "                Transform(moving_power, powers[k + 1], **kw),\n",
        "                Transform(root_lines[k % N].copy(), root_lines[(k + 1) % N], remover=True, **kw),\n",
        "                Transform(root_dots[k % N].copy(), root_dots[(k + 1) % N], remover=True, **kw),\n",
        "                MoveToTarget(shown_powers, **kw),\n",
        "            )\n",
        "            self.add(root_lines[:k + 2], root_dots[:k + 2])\n",
        "            if k < N - 1:\n",
        "                shown_powers.add(powers[k + 1])\n",
        "        self.play(\n",
        "            FadeOut(moving_power),\n",
        "            powers[:N].animate.set_opacity(1)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AlgorithmOutline(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = Text(\"Fast(?) convolution algorithm\")\n",
        "        title.to_edge(UP, buff=0.35)\n",
        "        title.set_backstroke(BLACK, 3)\n",
        "        underline = Underline(title, buff=-0.05).scale(1.5)\n",
        "        underline.insert_n_curves(20)\n",
        "        underline.set_stroke(GREY, (0, 3, 3, 3, 0))\n",
        "        self.add(underline, title)\n",
        "\n",
        "        # Arrays\n",
        "        t2c = {\n",
        "            tex: BLUE\n",
        "            for tex in [R\"\\textbf{a}\", \"a_0\", \"a_1\", \"a_2\", \"a_{n - 1}\"]\n",
        "        }\n",
        "        t2c.update({\n",
        "            tex: TEAL\n",
        "            for tex in [R\"\\textbf{b}\", \"b_0\", \"b_1\", \"b_2\", \"b_{m - 1}\"]\n",
        "        })\n",
        "        tex_kw = dict(tex_to_color_map=t2c, font_size=36)\n",
        "        lists = VGroup(\n",
        "            Tex(R\"\\textbf{a} = [a_0, a_1, a_2, \\dots, a_{n - 1}]\", **tex_kw),\n",
        "            Tex(R\"\\textbf{b} = [b_0, b_1, b_2, \\dots, b_{m - 1}]\", **tex_kw),\n",
        "            Tex(R\"\"\"\\textbf{a} * \\textbf{b} = \\left[\\begin{array}{l}\n",
        "                    a_0 b_0, \\\\\n",
        "                    a_0 b_1 + a_1 b_0, \\\\\n",
        "                    a_0 b_2 + a_1 b_1  + a_2 b_0, \\\\\n",
        "                    \\quad \\vdots \\\\\n",
        "                    a_{n - 1} b_{m - 1}\n",
        "            \\end{array}\\right]\"\"\", **tex_kw),\n",
        "        )\n",
        "        lists.arrange(DOWN, buff=1.7, aligned_edge=LEFT)\n",
        "        lists.next_to(underline, DOWN, LARGE_BUFF)\n",
        "        lists.to_edge(LEFT)\n",
        "        lists[2][4:].scale(0.7, about_edge=LEFT)\n",
        "        lists[2].refresh_bounding_box()\n",
        "        lists[2].to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        conv_rect = SurroundingRectangle(lists[2], buff=SMALL_BUFF)\n",
        "        conv_rect.set_stroke(YELLOW, 2)\n",
        "        q_marks = Text(\"???\", color=YELLOW)\n",
        "        q_marks.next_to(conv_rect, RIGHT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(lists[:2])\n",
        "        self.play(ShowCreation(underline))\n",
        "        self.play(\n",
        "            TransformMatchingShapes(VGroup(*lists[0], *lists[1]).copy(), lists[2]),\n",
        "            FadeIn(conv_rect),\n",
        "            FadeIn(q_marks),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show polynomials\n",
        "        polys = VGroup(\n",
        "            Tex(R\"f(x) = a_0 + a_1 x + a_2 x^2 + \\cdots + a_{n - 1}x^{n - 1}\", **tex_kw),\n",
        "            Tex(R\"g(x) = b_0 + b_1 x + b_2 x^2 + \\cdots + b_{m - 1}x^{m - 1}\", **tex_kw),\n",
        "        )\n",
        "        for poly, listy in zip(polys, lists):\n",
        "            poly.next_to(listy, DOWN, aligned_edge=LEFT)\n",
        "\n",
        "        axes = VGroup(*(\n",
        "            Axes((-3, 3), (-2, 2), width=5, height=1.5)\n",
        "            for x in range(3)\n",
        "        ))\n",
        "        axes.to_edge(RIGHT)\n",
        "        axes[0].match_y(polys[0])\n",
        "        axes[1].match_y(polys[1])\n",
        "        axes[2].move_to(2 * axes[1].get_origin() - axes[0].get_origin())\n",
        "\n",
        "        def f(x):\n",
        "            return 0.2 * (x + 3) * (x + 1) * (x - 2)\n",
        "\n",
        "        def g(x):\n",
        "            return 0.1 * (x + 2) * (x + 0) * (x - 3.25)\n",
        "\n",
        "        graphs = VGroup(\n",
        "            axes[0].get_graph(f, color=BLUE),\n",
        "            axes[1].get_graph(g, color=TEAL),\n",
        "            axes[2].get_graph(lambda x: f(x) * g(x), color=YELLOW),\n",
        "        )\n",
        "        graphs.set_stroke(width=2)\n",
        "\n",
        "        label_kw = dict(font_size=24)\n",
        "        graph_labels = VGroup(\n",
        "            Tex(\"f(x)\", **label_kw).move_to(axes[0], UL),\n",
        "            Tex(\"g(x)\", **label_kw).move_to(axes[1], UL),\n",
        "            Tex(R\"f(x) \\cdot g(x)\", **label_kw).move_to(axes[2], UL),\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*(\n",
        "                TransformFromCopy(listy.copy(), poly)\n",
        "                for listy, poly in zip(lists, polys)\n",
        "            )),\n",
        "            LaggedStartMap(FadeIn, axes[:2]),\n",
        "            LaggedStartMap(ShowCreation, graphs[:2]),\n",
        "            LaggedStartMap(FadeIn, graph_labels[:2]),\n",
        "            lag_ratio=0.5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show samples\n",
        "        x_samples = np.arange(-3, 3.5, 0.5)\n",
        "        f_points, g_points, fg_points = all_points = [\n",
        "            [ax.i2gp(x, graph) for x in x_samples]\n",
        "            for ax, graph in zip(axes, graphs)\n",
        "        ]\n",
        "\n",
        "        f_dots, g_dots, fg_dots = all_dots = Group(*(\n",
        "            Group(*(GlowDot(point, color=WHITE, glow_factor=0.8, radius=0.07) for point in points))\n",
        "            for points in all_points\n",
        "        ))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(f_dots, lag_ratio=0.7),\n",
        "            FadeIn(g_dots, lag_ratio=0.7),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(axes[1], axes[2]),\n",
        "            TransformMatchingShapes(graph_labels[:2].copy(), graph_labels[2]),\n",
        "            LaggedStart(*(\n",
        "                Transform(Group(fd, gd).copy(), Group(fgd), remover=True)\n",
        "                for fd, gd, fgd in zip(*all_dots)\n",
        "            ), lag_ratio=0.5, run_time=5)\n",
        "        )\n",
        "        self.add(fg_dots)\n",
        "        self.play(ShowCreation(graphs[2], run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Show arrow\n",
        "        final_arrow = Arrow(graph_labels[2], conv_rect.get_corner(UR), path_arc=PI / 5)\n",
        "        final_arrow.set_color(RED)\n",
        "\n",
        "        self.play(Write(final_arrow))\n",
        "        self.wait()\n",
        "\n",
        "        # Erase graphs\n",
        "        crosses = VGroup(*map(Cross, axes[:2]))\n",
        "        for cross in crosses:\n",
        "            cross.insert_n_curves(20)\n",
        "            cross.set_stroke(RED, (0, 10, 10, 10, 0))\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, crosses, lag_ratio=0.5, run_time=2),\n",
        "            polys[0].animate.scale(0.5, about_edge=DL),\n",
        "            polys[1].animate.scale(0.5, about_edge=DL),\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                final_arrow, axes[2], graph_labels[2], fg_dots, graphs[2], q_marks,\n",
        "            ))\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, Group(\n",
        "                axes[0], graphs[0], graph_labels[0], f_dots, crosses[0],\n",
        "                axes[1], graphs[1], graph_labels[1], g_dots, crosses[1],\n",
        "            ), shift=0.2 * RIGHT)\n",
        "        )\n",
        "\n",
        "        # Show FFTs\n",
        "        t2c = {\n",
        "            tex: RED\n",
        "            for tex in [R\"\\hat{\\textbf{a}}\", R\"\\hat{a}_0\", R\"\\hat{a}_1\", R\"\\hat{a}_2\", R\"\\hat{a}_{m + n - 1}\"]\n",
        "        }\n",
        "        t2c.update({\n",
        "            tex: MAROON_C\n",
        "            for tex in [R\"\\hat{\\textbf{b}}\", R\"\\hat{b}_0\", R\"\\hat{b}_1\", R\"\\hat{b}_2\", R\"\\hat{b}_{m + n - 1}\"]\n",
        "        })\n",
        "        fft_kw = dict(tex_to_color_map=t2c, font_size=36, isolate=[\"=\"])\n",
        "        fft_lists = VGroup(\n",
        "            Tex(R\"\\hat{\\textbf{a}} = [\\hat{a}_0, \\hat{a}_1, \\hat{a}_2, \\dots, \\hat{a}_{m + n - 1}]\", **fft_kw),\n",
        "            Tex(R\"\\hat{\\textbf{b}} = [\\hat{b}_0, \\hat{b}_1, \\hat{b}_2, \\dots, \\hat{b}_{m + n - 1}]\", **fft_kw),\n",
        "            Tex(R\"\"\"\\hat{\\textbf{a}} \\cdot \\hat{\\textbf{b}} = [\n",
        "                    \\hat{a}_0 \\hat{b}_0,\n",
        "                    \\hat{a}_1 \\hat{b}_1,\n",
        "                    \\hat{a}_2 \\hat{b}_2,\n",
        "                    \\dots,\n",
        "            ]\"\"\", **fft_kw),\n",
        "        )\n",
        "        for fft_list in fft_lists:\n",
        "            fft_list.shift(-fft_list.select_part(\"=\").get_center())\n",
        "        fft_lists.to_edge(RIGHT)\n",
        "\n",
        "        arrows = VGroup()\n",
        "        arrow_labels = VGroup()\n",
        "        for orig_list, fft_list, n in zip(lists, fft_lists, it.count()):\n",
        "            fft_list.match_y(orig_list)\n",
        "            arrow = Arrow(orig_list, fft_list, buff=0.3)\n",
        "            arrow.label = Text(\"Inverse FFT\" if n == 2 else \"FFT\", font_size=36)\n",
        "            arrow.label.next_to(arrow, UP)\n",
        "            arrow_labels.add(arrow.label)\n",
        "            arrows.add(arrow)\n",
        "        arrows[2].rotate(PI)\n",
        "\n",
        "        mult_arrow = Vector(2 * DOWN).move_to(VGroup(fft_lists[1], fft_lists[2]).get_center())\n",
        "        mult_arrow.label = Text(\"Multiply\\n(pointwise)\", font_size=36)\n",
        "        mult_arrow.label.next_to(mult_arrow, RIGHT)\n",
        "\n",
        "        kw = dict(lag_ratio=0.75, run_time=2)\n",
        "        self.play(\n",
        "            title[:4].animate.match_x(title[4:7], RIGHT),\n",
        "            FadeOut(title[4:7], 0.1 * DOWN, lag_ratio=0.1),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, fft_lists[:2], shift=1.5 * RIGHT, **kw),\n",
        "            LaggedStartMap(GrowArrow, arrows[:2], **kw),\n",
        "            LaggedStartMap(FadeIn, arrow_labels[:2], shift=0.5 * RIGHT, **kw),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(LaggedStart(\n",
        "            polys[0].animate.scale(1.5, about_edge=DL),\n",
        "            polys[1].animate.scale(1.5, about_edge=DL),\n",
        "            lag_ratio=0.5,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(fft_lists[2], DOWN),\n",
        "            GrowArrow(mult_arrow),\n",
        "            FadeIn(mult_arrow.label, 0.5 * DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowArrow(arrows[2]),\n",
        "            FadeIn(arrow_labels[2], shift=LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "# TODO\n",
        "class FourierCoefficients(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Axes\n",
        "        axes = Axes((0, 1, 0.1), (0, 2), width=8, height=4)\n",
        "        axes.add_coordinate_labels(font_size=24, num_decimal_places=1)\n",
        "        axes.to_edge(DOWN)\n",
        "        self.add(axes)\n",
        "\n",
        "        def f(x):\n",
        "            return max(np.exp(-x**2) + math.cos(2 * PI * x) - 0.2 * math.sin(4 * PI * x), 0.25)\n",
        "\n",
        "        graph = axes.get_graph(f)\n",
        "        graph.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.add(graph)\n",
        "\n",
        "        # Coefficients\n",
        "        exp = R\"{\\left(e^{2\\pi i \\cdot t}\\right)}\"\n",
        "        kw = dict(tex_to_color_map={\n",
        "            \"{x}\": BLUE,\n",
        "            exp: TEAL,\n",
        "        })\n",
        "        equations = VGroup(\n",
        "            Tex(R\"f(x) = c_0 + c_1 {x} + c_2 {x}^2 + c_3 {x}^3 + \\dots\", **kw),\n",
        "            Tex(Rf\"f(t) = c_0 + c_1 {exp} + c_2 {exp}^2 + c_3 {exp}^3 + \\dots\", **kw),\n",
        "            Tex(Rf\"f(t) = \\cdots + c_{{-1}} {exp}^{{-1}} + c_0 + c_1 {exp} + c_2 {exp}^2 + \\dots\", **kw),\n",
        "            # Tex(R\"f(t) = \\cdots + \\hat f(-1) e^{-2\\pi i t} + \\hat f(0) + \\hat f(1) e^{2\\pi i t} + \\hat f(2) e^{2\\pi i \\cdot 2t} + \\dots\"),\n",
        "        )\n",
        "\n",
        "        equations = VGroup\n",
        "\n",
        "        last = VMobject()\n",
        "        last.move_to(FRAME_HEIGHT * UP / 2)\n",
        "        for equation in equations:\n",
        "            equation.next_to(last, DOWN, MED_LARGE_BUFF)\n",
        "            self.play(FadeIn(equation, DOWN))\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                FadeOut(last, UP),\n",
        "                equation.animate.to_edge(UP)\n",
        "            )\n",
        "            last = equation\n",
        "\n",
        "\n",
        "class EndScreen(PatreonEndScreen):\n",
        "    pass\n"
    ]
}