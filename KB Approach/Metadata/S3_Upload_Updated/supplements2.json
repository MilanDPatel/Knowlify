{
    "topic": "The mathematical concept being demonstrated is the calculation of the angle deviation for Venus's parallax",
    "code": [
        "import pandas as pd\n",
        "import gzip\n",
        "from matplotlib import colormaps\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from _2025.cosmic_distance.planets import *\n",
        "\n",
        "\n",
        "class StatsToVenus(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        title = TexText(R\"Nearest distance to Venus $\\approx$ 39,000,000 km $\\approx 6{,}200 \\times R_E$\")\n",
        "        title.to_edge(UP)\n",
        "        title.set_backstroke(BLACK, 3)\n",
        "\n",
        "        self.play(Write(title[\"Nearest distance to Venus \"]))\n",
        "        self.wait()\n",
        "        self.play(Write(title[R\"$\\approx$ 39,000,000 km\"]))\n",
        "        self.wait()\n",
        "        self.play(Write(title[R\"$\\approx 6{,}200 \\times R_E$\"]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AngleDeviationForVenusParallax(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        title = TexText(R\"Angle deviation $ = 2 \\tan^{-1}(1 / 6200) \\approx$ 1 arc-minute = $\\displaystyle \\frac{1}{60} \\cdot 1^\\circ$\")\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SunInTheSky(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add pictures\n",
        "        frame = self.frame\n",
        "        base_path = self.file_writer.get_output_file_rootname().parent.parent\n",
        "        pure_sun = ImageMobject(str(Path(base_path, 'Paul Animations/6. Transit Of Venus/New Transit of Venus scenes/JustSunBackgroundRemoved.png')))\n",
        "        clean_sun = ImageMobject(str(Path(base_path, 'Paul Animations/6. Transit Of Venus/New Transit of Venus scenes/JustSun.tif')))\n",
        "        sky_image = ImageMobject(str(Path(base_path, 'supplements/SunAndThumb.jpg')))\n",
        "        sky_image.set_height(FRAME_HEIGHT)\n",
        "        for sun in pure_sun, clean_sun:\n",
        "            sun.set_height(0.23)\n",
        "            sun.move_to([-0.63, 1.36, 0.])\n",
        "\n",
        "        # Add angle measure\n",
        "        sun_arc_minutes = 32\n",
        "        sun_disk = Circle(radius=0.086)\n",
        "        sun_disk.move_to(pure_sun.get_center() + 0.0055 * RIGHT + 0.002 * UP)\n",
        "\n",
        "        protractor = NumberLine([0, 60 * 10])\n",
        "        protractor.rotate(90 * DEG)\n",
        "        protractor.scale(sun_disk.get_height() / protractor.get_unit_size() / sun_arc_minutes)\n",
        "        protractor.next_to(sun_disk, RIGHT, buff=0.15, aligned_edge=DOWN)\n",
        "\n",
        "        protractor.ticks.align_to(protractor.get_center(), RIGHT)\n",
        "        protractor.ticks.set_width(0.005, about_edge=RIGHT, stretch=True)\n",
        "        protractor.ticks[::60].set_width(0.02, about_edge=RIGHT, stretch=True)\n",
        "\n",
        "        deg_labels = VGroup(\n",
        "            Tex(Rf\"{n}^\\circ\", font_size=2).next_to(protractor.n2p(60 * n), RIGHT, buff=0.01)\n",
        "            for n in range(5)\n",
        "        )\n",
        "        protractor.add(deg_labels)\n",
        "\n",
        "        # Zoom in\n",
        "        self.add(sky_image)\n",
        "        self.add(clean_sun)\n",
        "        self.add(protractor)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(1.75 * pure_sun.get_height()).move_to(pure_sun).shift([0.1, 0.08, 0]),\n",
        "            FadeIn(protractor, time_span=(2.5, 3.5)),\n",
        "            FadeIn(pure_sun, time_span=(3, 4)),\n",
        "            FadeIn(clean_sun, time_span=(4, 5)),\n",
        "            FadeOut(sky_image, time_span=(3, 4)),\n",
        "            run_time=5,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show height of sun\n",
        "        sun_label = Text(f\"{sun_arc_minutes} arc-minutes\").scale(1 / 24)\n",
        "        sun_label.set_color(YELLOW)\n",
        "        point = protractor.n2p(sun_arc_minutes)\n",
        "        sun_label.next_to(point, RIGHT, buff=0.01)\n",
        "\n",
        "        dash_length = 0.0025\n",
        "        dashed_line = DashedLine(point, point + 2 * sun_disk.get_width() * LEFT, dash_length=dash_length)\n",
        "        dashed_line.set_stroke(YELLOW, 2)\n",
        "        dashed_lines = VGroup(\n",
        "            dashed_line.copy().align_to(protractor.n2p(0), DOWN),\n",
        "            dashed_line,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(sun_label),\n",
        "            ShowCreation(dashed_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Zoom into Venus\n",
        "        venus = Dot(radius=0.25 * protractor.get_unit_size()).set_fill(BLACK)\n",
        "        venus.set_stroke(BLACK, 2)\n",
        "        venus.set_anti_alias_width(6)\n",
        "        venus.move_to(sun_disk)\n",
        "        venus.align_to(protractor.n2p(8), DOWN)\n",
        "\n",
        "        venus_line = dashed_lines[0].copy()\n",
        "        venus_line.set_stroke(TEAL)\n",
        "        venus_line.match_y(venus)\n",
        "\n",
        "        venus.save_state()\n",
        "        venus.shift(0.5 * sun_disk.get_width() * LEFT)\n",
        "        self.play(\n",
        "            Restore(venus),\n",
        "            frame.animate.reorient(0, 0, 0, (-0.5, 1.37, 0.0), 0.29),\n",
        "            FadeIn(venus_line, time_span=(3, 4)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Shift up and down\n",
        "        labels = VGroup(\n",
        "            Text(\"Northern Hemisphere\\nObservation\"),\n",
        "            Text(\"Sourthern Hemisphere\\nObservation\"),\n",
        "        )\n",
        "        labels.scale(1 / 36)\n",
        "        labels.next_to(venus, UP, buff=protractor.get_unit_size())\n",
        "        labels.set_fill(BLACK)\n",
        "        shift_value = 0.5 * protractor.get_unit_size() * DOWN\n",
        "        labels[1].shift(shift_value)\n",
        "\n",
        "        self.play(FadeIn(labels[0]))\n",
        "        for n in range(4):\n",
        "            index = n % 2\n",
        "            sign = -(2 * index - 1)\n",
        "\n",
        "            self.play(\n",
        "                FadeOut(labels[index]),\n",
        "                FadeIn(labels[1 - index]),\n",
        "                VGroup(venus, venus_line).animate.shift(sign * shift_value)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Have lines go over appropriate parts of the disk (7 plays)\n",
        "        prop1 = 312.9 / 360\n",
        "        prop2 = prop1 + 3 / 360\n",
        "        p1 = sun_disk.pfp(prop1)\n",
        "        p2 = sun_disk.pfp(prop2)\n",
        "        lines = VGroup(\n",
        "            DashedLine(point + 0.675 * sun_disk.get_width() * RIGHT, [protractor.n2p(0)[0], point[1], 0], dash_length=0.5 * dash_length).set_stroke(TEAL, 1)\n",
        "            for point in [p1, p2]\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(pure_sun),\n",
        "            FadeOut(clean_sun),\n",
        "            FadeOut(venus_line),\n",
        "            FadeOut(venus),\n",
        "            FadeOut(labels),\n",
        "            FadeIn(lines),\n",
        "            sun_label.animate.scale(0.5, about_edge=LEFT),\n",
        "            deg_labels[0].animate.scale(0.5, about_edge=LEFT),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ShowDuration(InteractiveScene):\n",
        "    max_time = 4 * 3600 + 20 * 20 + 35\n",
        "    run_time = 12\n",
        "    clock_color = BLACK\n",
        "\n",
        "    def construct(self):\n",
        "        # Increment clock\n",
        "        clock = VGroup(\n",
        "            Integer(0, min_total_width=2),\n",
        "            Text(\"h\"),\n",
        "            Integer(0, min_total_width=2),\n",
        "            Text(\"m\"),\n",
        "            Integer(0, min_total_width=2),\n",
        "            Text(\"s\"),\n",
        "        )\n",
        "        clock.arrange(RIGHT, buff=SMALL_BUFF, aligned_edge=DOWN)\n",
        "        clock[1::2].shift(0.5 * SMALL_BUFF * LEFT)\n",
        "\n",
        "        clock.set_fill(self.clock_color)\n",
        "        self.add(clock)\n",
        "\n",
        "        time_tracker = ValueTracker()\n",
        "\n",
        "        def update_clock(clock):\n",
        "            time = int(time_tracker.get_value())  # In seconds\n",
        "            clock[4].set_value(time % 60)  # Seconds\n",
        "            clock[2].set_value((time // 60) % 60)  # Minutes\n",
        "            clock[0].set_value((time // 3600))  # Minutes\n",
        "\n",
        "        clock.add_updater(update_clock)\n",
        "        self.play(time_tracker.animate.set_value(self.max_time), rate_func=linear, run_time=self.run_time)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LongerDuration(ShowDuration):\n",
        "    max_time = 4 * 3600 + 20 * 20 + 35\n",
        "    run_time = 12\n",
        "\n",
        "\n",
        "class SevenHourMarker(InteractiveScene):\n",
        "    def construct(self):\n",
        "        brace = Brace(Line(2 * LEFT, 2 * RIGHT))\n",
        "        label = Tex(R\"\\sim 7 \\text{ hours}\")\n",
        "        label[0].next_to(label[1], LEFT, buff=0.025)\n",
        "        label.next_to(brace, DOWN)\n",
        "        VGroup(brace, label).set_fill(BLACK)\n",
        "\n",
        "        self.play(GrowFromCenter(brace), Write(label))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VenusTransitTimeline(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        frame = self.frame\n",
        "        timeline = NumberLine(\n",
        "            (1500, 2000, 10),\n",
        "            tick_size=0.05,\n",
        "            longer_tick_multiple=2,\n",
        "            big_tick_spacing=100,\n",
        "            unit_size=1 / 25\n",
        "        )\n",
        "        numbers =timeline.add_numbers(\n",
        "            range(1500, 2050, 50),\n",
        "            group_with_commas=False,\n",
        "            font_size=20,\n",
        "            buff=0.15\n",
        "        )\n",
        "\n",
        "        self.add(timeline)\n",
        "\n",
        "        # Show 1761\n",
        "        years = [1761, 1769, 1874]\n",
        "        dots = Group(\n",
        "            GlowDot(timeline.n2p(year)).set_color(YELLOW)\n",
        "            for year in years\n",
        "        )\n",
        "        arrow = Vector(0.65 * UP, thickness=2)\n",
        "        arrow.set_color(YELLOW)\n",
        "        arrow.next_to(dots[0], DOWN, buff=-SMALL_BUFF)\n",
        "        year_label = Text(str(years[0]), font_size=24)\n",
        "        year_label.set_color(YELLOW)\n",
        "        year_label.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            Write(year_label),\n",
        "            FadeIn(dots[0], UP),\n",
        "            frame.animate.set_height(6).move_to(dots[0].get_center() + 0.5 * UP).set_anim_args(run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Next\n",
        "        next_arrows = VGroup(\n",
        "            Arrow(d1.get_center(), d2.get_center(), path_arc=angle, buff=0.05)\n",
        "            for d1, d2, angle in zip(dots, dots[1:], [-PI, -90 * DEG])\n",
        "        )\n",
        "        next_labels = VGroup(\n",
        "            Text(f\"+{n} years\", font_size=16).next_to(na, UP, SMALL_BUFF)\n",
        "            for na, n in zip(next_arrows, [8, 105])\n",
        "        )\n",
        "\n",
        "        for na, label, d1, d2 in zip(next_arrows, next_labels, dots, dots[1:]):\n",
        "            self.play(\n",
        "                FadeIn(na),\n",
        "                FadeIn(label, lag_ratio=0.1),\n",
        "                TransformFromCopy(d1, d2, path_arc=-90 * DEG),\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class Count20Minutes(ShowDuration):\n",
        "    max_time = 20 * 60\n",
        "    run_time = 20\n",
        "    clock_color = WHITE\n",
        "\n",
        "\n",
        "class Antidisk(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        rect = FullScreenRectangle()\n",
        "        disk = Dot(radius=3)\n",
        "        rect = Exclusion(rect, disk)\n",
        "        rect.set_fill(GREEN_SCREEN, 1)\n",
        "        rect.set_stroke(width=0)\n",
        "        self.add(rect)\n",
        "\n",
        "\n",
        "class LabelIo(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        im = ImageMobject('/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/cosmic_distance/supplements2/JovianSystem.png')\n",
        "        im.set_height(FRAME_HEIGHT)\n",
        "        # self.add(im)\n",
        "        # self.add(NumberPlane().fade(0.25))\n",
        "\n",
        "        # Ellipse\n",
        "        orbit = Circle()\n",
        "        orbit.set_shape(2.75, 0.7)\n",
        "        orbit.scale(2)  # For new edit\n",
        "        orbit.rotate(10 * DEG)\n",
        "        point = Point()\n",
        "        point.move_to(orbit.get_start())\n",
        "\n",
        "        label = Text(\"Io\", font_size=36)\n",
        "        buff = 0.05\n",
        "\n",
        "        def update_label(label):\n",
        "            coords = point.get_center()\n",
        "            dist = get_norm(coords)\n",
        "            label.move_to((dist + buff) * coords / dist)\n",
        "            return label\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "\n",
        "        self.add(label)\n",
        "        for _ in range(3):\n",
        "            self.play(\n",
        "                MoveAlongPath(point, orbit, run_time=7, rate_func=linear),\n",
        "            )\n",
        "\n",
        "\n",
        "class TwoAU(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        braces = VGroup(\n",
        "            Brace(Line(ORIGIN, 3 * RIGHT), UP),\n",
        "            Brace(Line(3 * LEFT, ORIGIN), UP),\n",
        "        )\n",
        "        labels = VGroup(brace.get_text(\"A.U.\") for brace in braces)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, labels, shift=0.25 * UP, lag_ratio=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SpeedOfLightFrame(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        # title = Text(\"Real-time\\ndepiction\\nof the\\nspeed of\\nlight\", alignment=\"LEFT\", font_size=60)\n",
        "        title = Text(\"The speed\\nof light in\\nreal time\", alignment=\"LEFT\", font_size=60)\n",
        "        title.to_edge(LEFT, buff=0.25)\n",
        "\n",
        "        h_lines = Line(LEFT, RIGHT).set_width(11).replicate(2)\n",
        "        h_lines.arrange(DOWN, buff=FRAME_HEIGHT / 3)\n",
        "        h_lines.to_edge(RIGHT, buff=0)\n",
        "        v_line = Line(UP, DOWN).set_height(FRAME_HEIGHT)\n",
        "        v_line.move_to(h_lines, LEFT)\n",
        "\n",
        "        lines = VGroup(v_line, h_lines)\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.add(title)\n",
        "        self.add(lines)\n",
        "\n",
        "\n",
        "    def old(self):\n",
        "        h_line = Line(LEFT, RIGHT).set_width(FRAME_WIDTH)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        h_line2 = h_line.copy()\n",
        "        h_line2.set_y(-1)\n",
        "        VGroup(h_line, h_line2).set_stroke(WHITE, 2)\n",
        "\n",
        "        self.add(title, h_line, h_line2)\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class CompareLightSpeedEstimates(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        words = VGroup(\n",
        "            TexText(\"Huygens' Estimate: 212,000 km/s\"),\n",
        "            TexText(\"True speed: 299,792 km/s\"),\n",
        "        )\n",
        "        words.arrange(DOWN, aligned_edge=RIGHT)\n",
        "        words.to_corner(UL)\n",
        "        for word in words:\n",
        "            self.play(Write(word))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class DemonstrateAnArcSecond(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add circle\n",
        "        frame = self.frame\n",
        "        frame.set_height(90)\n",
        "        frame.set_field_of_view(10 * DEG)\n",
        "        radius = 35\n",
        "\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(WHITE, 2)\n",
        "\n",
        "        frame = self.frame\n",
        "        deg_height = radius * DEG\n",
        "        zero_point = circle.get_right()\n",
        "\n",
        "        # Add degree tick marks\n",
        "        deg_ticks = VGroup(\n",
        "            self.get_tick_mark(circle, n * DEG, 1, max_aparent_length=1)\n",
        "            for n in range(360)\n",
        "        )\n",
        "        deg10_ticks = VGroup(\n",
        "            self.get_tick_mark(circle, n * DEG, 2.5, max_aparent_length=1)\n",
        "            for n in range(0, 360, 10)\n",
        "        )\n",
        "        deg30_labels = VGroup(\n",
        "            self.get_tick_label(tick, number)\n",
        "            for tick, number in zip(deg10_ticks[0::3], range(0, 360, 30))\n",
        "        )\n",
        "        deg10_labels = VGroup(\n",
        "            self.get_tick_label(tick, number, visibility_range=(60, 30))\n",
        "            for tick, number in zip(\n",
        "                [*deg10_ticks[-2:], *deg10_ticks[1:3]],\n",
        "                [340, 350, 10, 20]\n",
        "            )\n",
        "        )\n",
        "        deg_labels = VGroup(\n",
        "            self.get_tick_label(tick, number, visibility_range=(12, 6))\n",
        "            for tick, number in zip(deg_ticks[1:10], range(1, 10))\n",
        "        )\n",
        "\n",
        "        self.add(circle, deg_ticks, deg10_ticks)\n",
        "        self.add(deg30_labels, deg10_labels, deg_labels)\n",
        "\n",
        "        # Add arc minute labels\n",
        "        arc_minute_ticks = VGroup(\n",
        "            self.get_tick_mark(circle, n * DEG / 60, 2.5e-2, max_aparent_length=0.75)\n",
        "            for n in range(0, 60)\n",
        "        )\n",
        "        arc_minute_labels = VGroup(\n",
        "            self.get_tick_label(\n",
        "                tick,\n",
        "                number,\n",
        "                unit=\"arc-minutes\",\n",
        "                frame_prop=0.025,\n",
        "                visibility_range=(0.35 * deg_height, 0.15 * deg_height),\n",
        "            )\n",
        "            for tick, number in zip(arc_minute_ticks[1:20], range(1, 20))\n",
        "        )\n",
        "\n",
        "        self.add(arc_minute_ticks)\n",
        "        self.add(arc_minute_labels)\n",
        "\n",
        "        # Add arc second labels\n",
        "        arc_second_ticks = VGroup(\n",
        "            self.get_tick_mark(circle, n * DEG / 60 / 60, 3.5e-4, max_aparent_length=0.5)\n",
        "            for n in range(0, 60)\n",
        "        )\n",
        "        arc_second_ticks.rotate(0.25 * DEG, about_point=zero_point)\n",
        "\n",
        "        am_height = deg_height / 60\n",
        "        arc_second_labels = VGroup(\n",
        "            self.get_tick_label(\n",
        "                tick,\n",
        "                number,\n",
        "                unit=\"arc-seconds\",\n",
        "                frame_prop=0.025,\n",
        "                visibility_range=(0.35 * am_height, 0.15 * am_height),\n",
        "                font_size=0.1\n",
        "            )\n",
        "            for tick, number in zip(arc_second_ticks[1:20], range(1, 20))\n",
        "        )\n",
        "\n",
        "        self.add(arc_second_ticks)\n",
        "        self.add(arc_second_labels)\n",
        "\n",
        "        # Zoom in to one degree\n",
        "        sun = get_sun(radius=(16 / 60) * deg_height, big_glow_ratio=2)\n",
        "        sun.shift(zero_point - sun[0].get_bottom())\n",
        "        sun.shift(0.5 * deg_height * LEFT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_height(1.5 * deg_height).move_to(circle.pfp(0.5 * DEG / TAU)),\n",
        "            run_time=8\n",
        "        )\n",
        "        self.wait(2)\n",
        "        if False:\n",
        "            # For insertion\n",
        "            sun[0].always_sort_to_camera(self.camera)\n",
        "            self.play(FadeIn(sun, 0.1 * LEFT))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(sun))\n",
        "\n",
        "\n",
        "        # Zoom in to arc seconds\n",
        "        self.play(\n",
        "            frame.animate.set_height(1.5 * deg_height / 60).move_to(circle.pfp(0.5 * DEG / TAU / 60)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        op_tracker = ValueTracker(0)\n",
        "        arc_second_labels.add_updater(lambda m: m.set_opacity(op_tracker.get_value()))\n",
        "        self.play(\n",
        "            VGroup(circle, arc_minute_ticks, arc_second_ticks).animate.scale(20, about_point=zero_point),\n",
        "            op_tracker.animate.set_value(1).set_anim_args(time_span=(1, 3)),\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def get_tick_mark(\n",
        "        self,\n",
        "        circle,\n",
        "        angle,\n",
        "        tick_length,\n",
        "        max_aparent_length=0.5,\n",
        "        stroke_color=WHITE,\n",
        "        stroke_width=2\n",
        "    ):\n",
        "        tick = Line(ORIGIN, tick_length * RIGHT)\n",
        "        tick.move_to(circle.get_right())\n",
        "        tick.rotate(angle, about_point=circle.get_center())\n",
        "        tick.set_stroke(WHITE, stroke_width)\n",
        "\n",
        "        frame_prop = max_aparent_length / FRAME_WIDTH\n",
        "        tick.add_updater(lambda m: m.set_length(\n",
        "            min(frame_prop * self.frame.get_width(), tick_length)\n",
        "        ))\n",
        "\n",
        "        return tick\n",
        "\n",
        "    def get_tick_label(\n",
        "        self,\n",
        "        tick,\n",
        "        number,\n",
        "        unit=R\"^\\circ\",\n",
        "        buff_ratio=0.5,\n",
        "        font_size=360,\n",
        "        visibility_range=(1000, 900),\n",
        "        frame_prop=0.05,\n",
        "    ):\n",
        "        label = Integer(number, unit=unit, font_size=font_size)\n",
        "        if not unit.startswith(\"^\"):\n",
        "            label[-1].shift(0.5 * label[0].get_width() * RIGHT)\n",
        "            if number == 1:\n",
        "                label[-1][-1].scale(0, about_edge=LEFT)\n",
        "\n",
        "        direction = normalize(tick.get_vector())\n",
        "        direction[abs(direction) < 0.2] = 0\n",
        "\n",
        "        label_height = label.get_height()\n",
        "\n",
        "        def update_label(label):\n",
        "            frame_height = self.frame.get_height()\n",
        "\n",
        "            # Opacity\n",
        "            opacity = clip(inverse_interpolate(*visibility_range, frame_height), 0, 1)\n",
        "            label.set_opacity(opacity)\n",
        "\n",
        "            # Max height\n",
        "            height = min(frame_prop * frame_height, label_height)\n",
        "            label.set_height(height)\n",
        "\n",
        "            # Location\n",
        "            buff = buff_ratio * label[0].get_width()\n",
        "            label.next_to(tick.get_end(), direction, buff=buff)\n",
        "            return label\n",
        "\n",
        "        label.add_updater(update_label)\n",
        "\n",
        "        return label\n",
        "\n",
        "\n",
        "class ArcMinuteLabels(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        brace = Brace(Line(3 * DOWN, 3 * UP), LEFT)\n",
        "        am_label = brace.get_text(\"60 arc-minutes\")\n",
        "        as_label = Text(\"60 arc-seconds\", t2s={\"seconds\": ITALIC})\n",
        "        as_label[\"seconds\"].set_color(YELLOW)\n",
        "        as_label.move_to(am_label, RIGHT)\n",
        "\n",
        "        for label in [am_label, as_label]:\n",
        "            self.clear()\n",
        "            self.play(\n",
        "                GrowFromCenter(brace),\n",
        "                FadeIn(label, scale=3, shift=1 * LEFT)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class ConnectingLine(InteractiveScene):\n",
        "    def construct(self):\n",
        "        line = Line(2 * UP, 2 * DOWN)\n",
        "        line.set_stroke(GREEN, 8)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(line.animate.set_stroke(width=0), run_time=2)\n",
        "\n",
        "\n",
        "class LightYearLabel(InteractiveScene):\n",
        "    def construct(self):\n",
        "        label = Text(\"4.25 Light years\")\n",
        "        self.play(Write(label))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(label))\n",
        "\n",
        "\n",
        "class CompareTwoStars(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Set up two stars\n",
        "        frame = self.frame\n",
        "        stars = Group(\n",
        "            GlowDot(UR, color=WHITE, radius=0.2),\n",
        "            GlowDot(DR, color=WHITE, radius=0.8),\n",
        "        )\n",
        "        randy = Randolph(mode=\"pondering\", height=1)\n",
        "        randy.shift(4 * LEFT - randy.eyes[1].get_center())\n",
        "        randy.look_at(stars[0])\n",
        "\n",
        "        frame.reorient(-88, 87, 0, (-4.0, -0.0, 0.0), 0.19)\n",
        "        self.add(stars)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.to_default_state(),\n",
        "            FadeIn(randy, time_span=(1, 2)),\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # Show observation lines\n",
        "        lines = always_redraw(lambda: VGroup(\n",
        "            DashedLine(randy.eyes[1].get_right(), stars[0].get_center()),\n",
        "            DashedLine(randy.eyes[1].get_right(), stars[1].get_center()),\n",
        "        ).set_stroke(WHITE, 1))\n",
        "\n",
        "        self.play(*map(ShowCreation, lines))\n",
        "        self.add(lines)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            stars[0].animate.shift(lines[0].get_vector()).scale(4),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class InverseSquareLaw(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Initial area\n",
        "        frame = self.frame\n",
        "        frame.reorient(43, 75, 0)\n",
        "\n",
        "        light = GlowDot(color=WHITE, radius=0.5)\n",
        "        axes = ThreeDAxes()\n",
        "        axes.set_stroke(width=1)\n",
        "        self.add(axes)\n",
        "\n",
        "        sphere = Sphere(radius=2)\n",
        "        sphere.set_color(WHITE, 0.25)\n",
        "        sphere.always_sort_to_camera(self.camera)\n",
        "        mesh = SurfaceMesh(sphere, resolution=(41, 21))\n",
        "        mesh.set_stroke(WHITE, 1, 0.25)\n",
        "\n",
        "        self.add(light)\n",
        "\n",
        "        # Show eminating light\n",
        "        big_sphere = sphere.copy().pointwise_become_partial(sphere, 0.5, 1)\n",
        "        theta, phi = frame.get_euler_angles()[:2]\n",
        "        big_sphere.rotate(phi, UP, about_point=ORIGIN)\n",
        "        big_sphere.rotate(theta, IN, about_point=ORIGIN)\n",
        "        big_sphere.always_sort_to_camera(self.camera)\n",
        "        big_sphere.scale(3, about_point=ORIGIN)\n",
        "\n",
        "        radiation, op_tracker = self.beaming_effect(big_sphere, opacity_range=(0.15, 0), n_components=20, speed=0.5)\n",
        "\n",
        "        op_tracker.set_value(0)\n",
        "        self.add(radiation)\n",
        "        self.play(op_tracker.animate.set_value(1), run_time=2)\n",
        "        self.wait(6)\n",
        "        self.add(sphere, mesh, radiation)\n",
        "        self.play(\n",
        "            op_tracker.animate.set_value(0),\n",
        "            FadeIn(sphere),\n",
        "            FadeIn(mesh),\n",
        "        )\n",
        "        self.remove(radiation)\n",
        "        self.wait()\n",
        "\n",
        "        # Show patch\n",
        "        patch = ParametricSurface(\n",
        "            lambda u, v: sphere.uv_func(u, v),\n",
        "            u_range=(0 * DEG, 9 * DEG),\n",
        "            v_range=(90 * DEG, 99 * DEG),\n",
        "        )\n",
        "        patch.set_color(WHITE)\n",
        "\n",
        "        beam, op_tracker = self.beaming_effect(patch)\n",
        "\n",
        "        op_tracker.set_value(0)\n",
        "        self.add(beam, sphere, mesh)\n",
        "        self.play(\n",
        "            op_tracker.animate.set_value(1),\n",
        "            sphere.animate.set_opacity(0.1),\n",
        "            mesh.animate.set_stroke(opacity=0.1),\n",
        "            FadeIn(patch),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(frame.animate.reorient(72, 75, 0, (-0.12, -0.13, 0.0), 8), run_time=10)\n",
        "\n",
        "        # Compare to full sphere\n",
        "        sphere_highlight = sphere.copy()\n",
        "        sphere_highlight.scale(1.01)\n",
        "        sphere_highlight.set_color(BLUE, 0.2)\n",
        "\n",
        "        self.play(ShowCreation(sphere_highlight, run_time=2))\n",
        "        self.play(FadeOut(sphere_highlight))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Grow the sphere\n",
        "        patch.target = patch.generate_target()\n",
        "        patch.target.scale(2, about_point=ORIGIN)\n",
        "\n",
        "        division = VGroup(\n",
        "            ParametricCurve(lambda t: 2 * sphere.uv_func(t, 94.5 * DEG), t_range=(0 * DEG, 9 * DEG, DEG)),\n",
        "            ParametricCurve(lambda t: 2 * sphere.uv_func(4.5 * DEG, t), t_range=(90 * DEG, 99 * DEG, DEG)),\n",
        "        )\n",
        "        division.set_stroke(GREY_C, 1)\n",
        "\n",
        "        sphere_group = Group(sphere, mesh)\n",
        "        ghost_sphere = sphere_group.copy()\n",
        "        ghost_sphere[0].set_opacity(0.05)\n",
        "        ghost_sphere[1].set_stroke(opacity=0.05)\n",
        "        ghost_sphere.scale(0.999)\n",
        "\n",
        "        self.add(ghost_sphere)\n",
        "        self.play(\n",
        "            sphere_group.animate.scale(2),\n",
        "            MoveToTarget(patch),\n",
        "            frame.animate.reorient(65, 78, 0, ORIGIN, 8).set_anim_args(run_time=3),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(FadeIn(division))\n",
        "        self.wait(6)\n",
        "\n",
        "        self.play(\n",
        "            patch.animate.scale(0.5, about_edge=IN + DOWN).set_opacity(0.5),\n",
        "            FadeOut(division),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(103, 78, 0, (-0.0, 0.0, 0.0), 8.00),\n",
        "            run_time=18,\n",
        "        )\n",
        "\n",
        "    def beaming_effect(self, piece, n_components=20, speed=0.5, opacity_range=(0.5, 0.25)):\n",
        "        pieces = piece.replicate(n_components)\n",
        "        d_alpha_range = np.arange(0, 1, 1.0 / n_components)\n",
        "        radius = get_norm(piece.get_right())\n",
        "\n",
        "        master_opacity_tracker = ValueTracker(1)\n",
        "\n",
        "        def update_pieces(pieces):\n",
        "            beam_time = radius / speed\n",
        "            alpha = self.time / beam_time\n",
        "\n",
        "            for subpiece, d_alpha in zip(pieces, d_alpha_range):\n",
        "                sub_alpha = (alpha + d_alpha) % 1\n",
        "                subpiece.become(piece)\n",
        "                pre_opacity = interpolate(*opacity_range, sub_alpha)\n",
        "                subpiece.set_opacity(pre_opacity * master_opacity_tracker.get_value())\n",
        "                subpiece.scale(0.99 * sub_alpha, about_point=ORIGIN)\n",
        "\n",
        "            pieces.sort(get_norm)\n",
        "\n",
        "            return pieces\n",
        "\n",
        "        pieces.add_updater(update_pieces)\n",
        "        return pieces, master_opacity_tracker\n",
        "\n",
        "\n",
        "class WriteInverseSquareLaw(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        eq = Tex(R\"\\text{Apparent brightness} = \\text{const} \\cdot {\\text{Absolute brightness} \\over (\\text{distance})^2}\")\n",
        "        eq.to_edge(UP)\n",
        "        eq.set_color(GREY_B)\n",
        "\n",
        "        self.add(eq)\n",
        "        self.wait()\n",
        "        words = [\"Apparent brightness\", \"Absolute brightness\", \"distance\"]\n",
        "        colors = [YELLOW, WHITE, BLUE]\n",
        "        for text, color in zip(words, colors):\n",
        "            part = eq[text][0]\n",
        "            self.play(\n",
        "                FlashAround(part, color=color, buff=0.1),\n",
        "                part.animate.set_color(color)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class MeasuringNearbyStars(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add the sun\n",
        "        frame = self.frame\n",
        "        sun = GlowDot(color=WHITE, radius=0.1)\n",
        "        sun.center()\n",
        "        self.add(sun)\n",
        "\n",
        "        frame.reorient(--270, 63, 0)\n",
        "        dtheta_tracker = ValueTracker(5 * DEG)\n",
        "        frame.add_updater(lambda m, dt: m.increment_theta(dtheta_tracker.get_value() * dt))\n",
        "        self.add(frame)\n",
        "\n",
        "        # Add the stars\n",
        "        n_stars = 10000\n",
        "        n_shown_stars = 1000\n",
        "        data_file = '/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/cosmic_distance/Data/HYG_Data.gz'\n",
        "        full_stellar_data, df = self.read_hyg_data(data_file)\n",
        "\n",
        "        random.shuffle(full_stellar_data)\n",
        "        stellar_data = full_stellar_data[:n_stars]\n",
        "        abs_mags = stellar_data[:, 0]\n",
        "        color_index = stellar_data[:, 1]\n",
        "        rgbas = self.color_index_to_rgb(color_index)\n",
        "\n",
        "        opacities = np.ones(n_stars)\n",
        "        opacities[n_shown_stars:] = 0\n",
        "        rgbas[n_shown_stars:, 3] = 0\n",
        "\n",
        "        star_points = np.random.uniform(-1, 1, (n_stars, 3))\n",
        "        distances = np.random.uniform(0.5, 36, n_stars)**0.5\n",
        "        star_points *= (distances / np.linalg.norm(star_points, axis=1))[:, np.newaxis]\n",
        "        stars = GlowDots(star_points, color=WHITE)\n",
        "\n",
        "        radii = 0.1 * (abs_mags.max() - abs_mags) / (abs_mags.max() - abs_mags.min())\n",
        "        stars.set_radii(radii)\n",
        "        stars.set_opacity(opacities)\n",
        "\n",
        "        self.add(stars)\n",
        "\n",
        "        # Show distances to various stars\n",
        "        last_group = VGroup()\n",
        "        for n in range(10):\n",
        "            line = Line(ORIGIN, random.choice(star_points))\n",
        "            line.set_stroke(BLUE, 2)\n",
        "            label = DecimalNumber(line.get_length() * 10, num_decimal_places=2, unit=\"L.Y.\", font_size=24)\n",
        "            label[-1].shift(SMALL_BUFF * RIGHT)\n",
        "            label.set_color(BLUE)\n",
        "            label.rotate(frame.get_phi(), RIGHT)\n",
        "            label.rotate(frame.get_theta() + 2 * DEG, OUT)\n",
        "            vect = normalize(np.cross(line.get_end(), frame.get_implied_camera_location()))\n",
        "            label.next_to(line.pfp(0.33), vect, SMALL_BUFF)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeIn(label, shift=0.25 * OUT),\n",
        "                FadeOut(last_group),\n",
        "            )\n",
        "            self.wait()\n",
        "            last_group = VGroup(line, label)\n",
        "        self.play(FadeOut(last_group))\n",
        "\n",
        "        # Show the colors\n",
        "        self.play(stars.animate.set_rgba_array(rgbas))\n",
        "        self.wait(4)\n",
        "\n",
        "        # Compile into a H.R. plot\n",
        "        axes = Axes((0, 1, 0.1), (0, 1, 0.1), width=6, height=6)\n",
        "\n",
        "        x_axis_label = Text(\"Color\", font_size=36)\n",
        "        x_axis_label.next_to(axes.x_axis, DOWN, SMALL_BUFF)\n",
        "        y_axis_label = Text(\"Absolute\\nbrightness\", font_size=36)\n",
        "        y_axis_label.next_to(axes.y_axis, LEFT, SMALL_BUFF)\n",
        "\n",
        "        rand_x = np.random.random(n_stars)\n",
        "        rand_y = np.random.random(n_stars)\n",
        "        random_points = axes.c2p(rand_x, rand_y)\n",
        "\n",
        "        color_alphas = inverse_interpolate(color_index.min(), color_index.max(), color_index)\n",
        "        mag_alphas = inverse_interpolate(abs_mags.max(), abs_mags.min(), abs_mags)\n",
        "\n",
        "        sorted_by_color = axes.c2p(color_alphas, rand_y)\n",
        "        fully_sorted = axes.c2p(color_alphas, mag_alphas)\n",
        "\n",
        "        new_radii = 0.5 * (radii + 0.05) / 1.5\n",
        "\n",
        "        self.play(dtheta_tracker.animate.set_value(0))\n",
        "        self.play(\n",
        "            FadeIn(axes),\n",
        "            frame.animate.to_default_state(),\n",
        "            stars.animate.set_points(random_points).set_radii(new_radii).set_glow_factor(0).make_3d().set_opacity(0.5),\n",
        "            FadeOut(sun),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            stars.animate.set_points(sorted_by_color).set_anim_args(run_time=5, path_arc=30 * DEG),\n",
        "            Write(x_axis_label, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            stars.animate.set_points(fully_sorted).set_anim_args(run_time=5).set_opacity(0.25),\n",
        "            Write(y_axis_label, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Circle the main sequence\n",
        "        ms_circle = Circle().set_stroke(YELLOW, 2)\n",
        "        ms_circle.set_shape(4.5, 1)\n",
        "        ms_circle.rotate(-35 * DEG)\n",
        "        ms_circle.move_to(axes.c2p(0.3, 0.35))\n",
        "\n",
        "        ms_label = Text(\"Main sequence\", font_size=30)\n",
        "        ms_label.next_to(ms_circle.pfp(0.1), RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 0, 0, (-0.75, -1.45, 0.0), 5.71).set_anim_args(run_time=3),\n",
        "            ShowCreation(ms_circle),\n",
        "            Write(ms_label)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name the diagram\n",
        "        name = Text(\"Hertzsprung\u2013Russell diagram\")\n",
        "        name.center().to_edge(UP)\n",
        "        name.fix_in_frame()\n",
        "\n",
        "        self.play(\n",
        "            Write(name),\n",
        "            frame.animate.reorient(0, 0, 0, 0.5 * UP, 9),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Move around an example star\n",
        "        example_star = TrueDot().make_3d()\n",
        "        glow = self.get_glow(example_star)\n",
        "\n",
        "        def update_example_star(star):\n",
        "            color_alpha, mag = axes.p2c(star.get_center())\n",
        "            bv_index = interpolate(color_index.min(), color_index.max(), color_alpha)\n",
        "            star.set_rgba_array(self.color_index_to_rgb(np.array([bv_index])))\n",
        "            star.set_radius(0.25 * mag)\n",
        "\n",
        "        example_star.add_updater(update_example_star)\n",
        "        example_star.move_to(axes.c2p(0.5, 0.5))\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(ms_label),\n",
        "            FadeOut(ms_circle),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            stars.animate.set_opacity(0.02),\n",
        "            FadeIn(example_star),\n",
        "            FadeIn(glow),\n",
        "        )\n",
        "        for x in [-2.5, 0]:\n",
        "            self.play(example_star.animate.set_x(x), run_time=1.5)\n",
        "\n",
        "        for y in [2, 0]:\n",
        "            self.play(example_star.animate.set_y(y), run_time=2)\n",
        "        self.wait()\n",
        "\n",
        "        # Place into the main sequence\n",
        "        opacities = stars.get_opacities().copy()\n",
        "        ur_values = np.dot(stars.get_points(), np.array([[1, 1.2, 0]]).T).flatten()\n",
        "        in_ms = ur_values < -1.3\n",
        "        opacities[in_ms] = 0.2\n",
        "\n",
        "        ms_arrow = Arrow(UL, DR).rotate(10 * DEG)\n",
        "        ms_arrow.set_color(GREY_B)\n",
        "        ms_arrow.move_to(axes.c2p(0.25, 0.25))\n",
        "\n",
        "        self.play(\n",
        "            stars.animate.set_opacity(opacities),\n",
        "            ShowCreationThenFadeOut(ms_circle),\n",
        "            FadeIn(ms_label),\n",
        "            example_star.animate.move_to(axes.c2p(0.1, 0.5)),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(GrowArrow(ms_arrow))\n",
        "        self.wait()\n",
        "        opacities[in_ms] = 0.025\n",
        "\n",
        "        # Show radiation and shifting down\n",
        "        self.play(stars.animate.set_opacity(opacities).set_anim_args(run_time=1))\n",
        "        self.wait(6)\n",
        "        self.play(\n",
        "            example_star.animate.move_to(axes.c2p(0.5, 0.2)).set_anim_args(run_time=15),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Return full diagram\n",
        "        self.play(\n",
        "            FadeOut(ms_arrow),\n",
        "            FadeOut(ms_label),\n",
        "            FadeOut(example_star),\n",
        "            FadeOut(glows),\n",
        "            stars.animate.set_opacity(0.25),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Scan through color regions\n",
        "        color_x_tracker = ValueTracker(0)\n",
        "        opacities = stars.get_opacities().copy()\n",
        "\n",
        "        def update_opacities(stars):\n",
        "            mid_x = color_x_tracker.get_value()\n",
        "            xs = stars.get_points()[:, 0]\n",
        "            opacities[:] = 0.25 * np.exp(-15 * (xs - mid_x)**2) + 0.01\n",
        "            stars.set_opacity(opacities)\n",
        "\n",
        "        stars.add_updater(update_opacities)\n",
        "        self.wait()\n",
        "        for x in [-2.5, 1.5, 0]:\n",
        "            self.play(color_x_tracker.animate.set_value(x), run_time=5)\n",
        "        self.wait()\n",
        "\n",
        "        stars.clear_updaters()\n",
        "        self.play(stars.animate.set_opacity(0.25))\n",
        "        self.wait()\n",
        "\n",
        "        # Highlight other regions\n",
        "\n",
        "    def read_hyg_data(self, file_path):\n",
        "        \"\"\"\n",
        "        Read HYG Database from a gzipped file into a numpy array\n",
        "\n",
        "        Parameters:\n",
        "        file_path (str): Path to the HYG_Data.gz file\n",
        "\n",
        "        Returns:\n",
        "        numpy.ndarray: Array containing the stellar data\n",
        "        pd.DataFrame: Original dataframe for reference if needed\n",
        "        \"\"\"\n",
        "        # Read the gzipped CSV file\n",
        "        with gzip.open(file_path, 'rt') as f:\n",
        "            # Read into pandas first since the file is CSV formatted\n",
        "            df = pd.read_csv(f)\n",
        "\n",
        "        # For the H-R diagram, we primarily need:\n",
        "        # - Color index (B-V)\n",
        "        # - Absolute magnitude\n",
        "        # Essential columns for H-R diagram\n",
        "        essential_cols = ['absmag', 'ci']\n",
        "\n",
        "        # Create numpy array from essential columns\n",
        "        stellar_data = df[essential_cols].to_numpy()\n",
        "\n",
        "        # Remove any rows with NaN values\n",
        "        stellar_data = stellar_data[~np.isnan(stellar_data).any(axis=1)]\n",
        "\n",
        "        return stellar_data, df\n",
        "\n",
        "    def color_index_to_rgb(self, bv_index):\n",
        "        alpha = inverse_interpolate(-0.2, 2.9, bv_index)\n",
        "        red = \"#FF0000\"\n",
        "        cmap = get_colormap_from_colors([\"#0000FF\", BLUE, WHITE, YELLOW, ORANGE, RED, * 4 * [red]])\n",
        "        return cmap(alpha)\n",
        "\n",
        "    def get_glow(self, star):\n",
        "        glows = GlowDot().replicate(2)\n",
        "\n",
        "        def update_glows(glows):\n",
        "            for dot, delta_t in zip(glows, [0, 1]):\n",
        "                alpha = (self.time + delta_t) % 2\n",
        "                if alpha < 1:\n",
        "                    dot.set_opacity(1)\n",
        "                    dot.set_radius(interpolate(1, 8, alpha) * star.get_radius())\n",
        "                else:\n",
        "                    dot.set_opacity(interpolate(1, 0, alpha - 1))\n",
        "                dot.set_color(star.get_color())\n",
        "                dot.move_to(star)\n",
        "\n",
        "        glows.add_updater(update_glows)\n",
        "        return glows\n",
        "\n",
        "\n",
        "class WriteHarvardComputer(InteractiveScene):\n",
        "    def construct(self):\n",
        "        words = Text(\"Harvard Computers\", font_size=72)\n",
        "        words.set_backstroke(BLACK, 8)\n",
        "        words.to_corner(UL)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class LineToDistantStar(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add Galaxy\n",
        "        path = os.path.join(self.file_writer.get_output_file_rootname().parent, \"GalaxyStill.png\")\n",
        "        galaxy = ImageMobject(path)\n",
        "        galaxy.set_height(FRAME_HEIGHT)\n",
        "        galaxy.center()\n",
        "        self.add(galaxy)\n",
        "\n",
        "        # Draw line\n",
        "        sun_point = (-0.08, -0.74, 0.0)\n",
        "        star_point = (0.6, 1.54, 0.0)\n",
        "        line = Line(sun_point, star_point)\n",
        "        line.set_stroke(TEAL, 4)\n",
        "        line_label = TexText(R\"$\\sim$60,000 Light Years\", font_size=36)\n",
        "        line_label.next_to(line.get_center(), RIGHT)\n",
        "        line_label.set_color(TEAL)\n",
        "        line_label.set_backstroke(BLACK, 3)\n",
        "\n",
        "        star = GlowDot(star_point, color=WHITE)\n",
        "        star.f_always.set_radius(lambda: 0.1 * (2 + math.sin(self.time)))\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            FadeIn(line_label, lag_ratio=0.1, time_span=(1, 3)),\n",
        "            galaxy.animate.set_opacity(0.75),\n",
        "            FadeIn(star),\n",
        "            run_time=3,\n",
        "        )\n",
        "        self.wait(12)\n",
        "\n",
        "\n",
        "class SolarSpectrum(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Get data\n",
        "        data_file = '/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/cosmic_distance/Data/solar_spectrum.csv'\n",
        "        self.spectral_cmap = colormaps.get_cmap(\"Spectral\")\n",
        "        data = np.loadtxt(data_file, delimiter=',')\n",
        "\n",
        "        wavelength = self.bucket_data(data[:, 0])\n",
        "        avg_intensity = self.bucket_data(data[:, 1:4].mean(1))\n",
        "\n",
        "        # Add axes\n",
        "        axes = Axes((0, 2400, 100), (0, 1, 0.1), height=6, width=11)\n",
        "        axes.to_corner(UL)\n",
        "\n",
        "        x_label = Text(\"Wavelength (nm)\", font_size=36)\n",
        "        x_label.next_to(axes.x_axis.get_end(), UR, buff=SMALL_BUFF)\n",
        "        x_label.shift_onto_screen(buff=SMALL_BUFF)\n",
        "        x_coords = VGroup(\n",
        "            Integer(n, font_size=24).next_to(axes.x_axis.n2p(n), DOWN, MED_SMALL_BUFF)\n",
        "            for n in range(0, 2800, 400)\n",
        "        )\n",
        "        x_label.set_z_index(1)\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(x_label)\n",
        "        self.add(x_coords)\n",
        "\n",
        "        # Add lines\n",
        "        lines = self.get_spectral_lines(axes, wavelength, avg_intensity)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            (Write(line, stroke_color=WHITE, stroke_width=0.1)\n",
        "            for line in lines),\n",
        "            lag_ratio=0.005,\n",
        "            run_time=5\n",
        "        ))\n",
        "\n",
        "        # Show the lump\n",
        "        def func(wavelen):\n",
        "            # Not even the right formula...\n",
        "            T = 1\n",
        "            c = 1\n",
        "            h = 1\n",
        "            freq = c / (wavelen / 2400)\n",
        "            return (2 * h * freq**5) / (c**2) / (np.exp(h * freq / T) - 1)\n",
        "\n",
        "        lump = axes.get_graph(func, x_range=(1e-3, 2400, 12))\n",
        "        lump.set_height(1 * axes.y_axis.get_length(), about_edge=DOWN, stretch=True)\n",
        "\n",
        "        self.play(VShowPassingFlash(lump, run_time=4, time_width=1.5))\n",
        "\n",
        "        # Expand\n",
        "        origin = axes.c2p(0, 0)\n",
        "        self.play(\n",
        "            lines.animate.stretch(2, 0, about_point=origin).set_stroke(width=1),\n",
        "            axes.x_axis.animate.stretch(2, 0, about_point=origin),\n",
        "            *(\n",
        "                coord.animate.stretch(2, 0, about_point=origin).stretch(0.5, 0)\n",
        "                for coord in x_coords\n",
        "            ),\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        # Highlight gaps\n",
        "        gap_points = np.array([\n",
        "            (-3.77, -1.1, 0.0),\n",
        "            (-2.96, 1.09, 0.0),\n",
        "            (-2.58, 2.51, 0.0),\n",
        "            (-1.74, 3.0, 0.0),\n",
        "        ])\n",
        "        arrows = VGroup(\n",
        "            Vector(0.5 * DOWN, thickness=2).set_color(WHITE).move_to(point, DOWN)\n",
        "            for point in gap_points\n",
        "        )\n",
        "\n",
        "        self.play(LaggedStartMap(GrowArrow, arrows, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "\n",
        "        # Show hydrogen spectrum\n",
        "        spectral_wavelengths = np.array([\n",
        "            122, 103, 97,  # Lyman\n",
        "            656, 486, 430, 410,  # Balmer\n",
        "            1875, 1282, 1094,  # Paschen\n",
        "        ])\n",
        "        spectral_lines = self.get_spectral_lines(axes, spectral_wavelengths, np.ones_like(spectral_wavelengths), stroke_width=3)\n",
        "        for line in spectral_lines:\n",
        "            line.set_stroke(interpolate_color(line.get_color(), WHITE, 0.25), width=2)\n",
        "        # spectral_lines.set_height(6, about_edge=DOWN, stretch=True)\n",
        "\n",
        "        hyd_words = Text(\"Spectral lines for Hydrogen\", font_size=72)\n",
        "        hyd_words.next_to(spectral_lines, UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, spectral_lines),\n",
        "            FadeOut(arrows),\n",
        "            lines.animate.set_stroke(opacity=0.2),\n",
        "            self.frame.animate.reorient(0, 0, 0, (3.42, 0.49, 0.0), 12.00).set_anim_args(run_time=2),\n",
        "            Write(hyd_words, run_time=3),\n",
        "            x_label.animate.set_x(12.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show red shift\n",
        "        shift_value = 0.25 * RIGHT\n",
        "        new_lines = spectral_lines.copy()\n",
        "        new_lines.shift(shift_value)\n",
        "\n",
        "        arrow = Vector(5 * RIGHT, thickness=10)\n",
        "        arrow.move_to(hyd_words, DOWN)\n",
        "\n",
        "        self.play(FadeOut(hyd_words), lines.animate.set_stroke(opacity=0.1))\n",
        "        self.play(\n",
        "            GrowArrow(arrow),\n",
        "            TransformFromCopy(spectral_lines, new_lines),\n",
        "            spectral_lines.animate.set_stroke(width=1, opacity=0.5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Measure the shift\n",
        "        brace = Brace(VGroup(spectral_lines[3], new_lines[3]), UP, SMALL_BUFF)\n",
        "        self.play(GrowFromCenter(brace), FadeOut(arrow))\n",
        "        self.play(\n",
        "            brace.animate.stretch(3, 0, about_edge=LEFT),\n",
        "            new_lines.animate.shift(2 * shift_value),\n",
        "            rate_func=there_and_back,\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "    def bucket_data(self, arr, bucket_size=10):  # TODO, change\n",
        "        full_size = len(arr) - (len(arr) % bucket_size)\n",
        "        compressed = arr[:full_size].reshape((full_size // bucket_size, bucket_size)).min(1)\n",
        "        return compressed\n",
        "\n",
        "    def color_alpha_to_color(self, alpha):\n",
        "        rgb = np.array(self.spectral_cmap(1 - alpha)[:3])\n",
        "        brown = np.array([0.55, 0.27, 0.07])\n",
        "        grey = np.array([0.15, 0.15, 0.15])\n",
        "        if alpha > 1:\n",
        "            factor = (np.exp(2 * (1 - alpha)) + 0.2) / 1.2\n",
        "            rgb = interpolate(grey, rgb, factor)\n",
        "        elif alpha < 0:\n",
        "            rgb = interpolate(brown, rgb, np.exp(5 * alpha))\n",
        "        return Color(rgb=rgb)\n",
        "\n",
        "    def get_spectral_lines(self, axes, wavelengths, intensities, stroke_width=1):\n",
        "        color_alpha = inverse_interpolate(380, 780, wavelengths)\n",
        "        rel_intensities = intensities / intensities.max()\n",
        "        return VGroup(\n",
        "            Line(\n",
        "                axes.c2p(lam, 0),\n",
        "                axes.c2p(lam, y),\n",
        "                stroke_color=self.color_alpha_to_color(ca),\n",
        "                stroke_width=stroke_width\n",
        "            )\n",
        "            for lam, y, ca in zip(wavelengths, rel_intensities, color_alpha)\n",
        "        )\n",
        "\n",
        "\n",
        "class LeavittLabel(InteractiveScene):\n",
        "    def construct(self):\n",
        "        text = TexText(R\"From Leavitt's\\\\1912 Paper\")\n",
        "        text.to_corner(UL)\n",
        "        self.play(Write(text))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GalaxyFarFarAway(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        words = Text(\"A Galaxy Far\\n Far Away\", font_size=120)\n",
        "        words.set_color(YELLOW)\n",
        "        words.set_backstroke(BLACK, 5)\n",
        "        self.add(words)\n",
        "\n",
        "        self.frame.reorient(0, 60, 0)\n",
        "        self.play(words.animate.shift(20 * UP), run_time=5)\n",
        "\n",
        "\n",
        "class GalacticSurveyData(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Gather data\n",
        "        frame = self.frame\n",
        "        data_file = '/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2025/cosmic_distance/Data/galactic_data.csv'\n",
        "        # Columns are 'objID, ra, dec, redshift, distance_mpc'\n",
        "        data = np.loadtxt(data_file, delimiter=',', skiprows=2)\n",
        "        right_ascension = data[:, 1]\n",
        "        declination = data[:, 2]\n",
        "        distance = data[:, 4]\n",
        "\n",
        "        cos_ra = np.cos(right_ascension * DEG)\n",
        "        sin_ra = np.sin(right_ascension * DEG)\n",
        "        cos_dec = np.cos(90 * DEG - declination * DEG)\n",
        "        sin_dec = np.sin(90 * DEG - declination * DEG)\n",
        "\n",
        "        cartesian = np.array([cos_dec * sin_ra, sin_dec * sin_ra, cos_ra]).T\n",
        "        cartesian *= distance[:, np.newaxis]\n",
        "\n",
        "        # Add dots\n",
        "        dots = DotCloud(cartesian)\n",
        "        dots.get_width()\n",
        "        dots.get_height()\n",
        "        dots.set_color(WHITE)\n",
        "        dots.set_glow_factor(0.5)\n",
        "\n",
        "        dots.clear_updaters()\n",
        "        radii = np.random.random(len(distance))**2\n",
        "        rad_factor = ValueTracker(0.003)\n",
        "        dots.f_always.set_radii(lambda: max((rad_factor.get_value() * frame.get_height()**0.9), 0.1) * radii)\n",
        "\n",
        "        self.add(dots)\n",
        "\n",
        "        # Zoom out\n",
        "        # frame.rleorient(-30, 146, 0, (1.89, 0.98, -10.17), 10.71)\n",
        "        height_tracker = ValueTracker(10)\n",
        "        angle_tracker = ValueTracker(np.array([-30, 146, 0]))\n",
        "        center_tracker = ValueTracker(np.array([1.89, 0.98, -10.17]))\n",
        "\n",
        "        frame.reorient(-22, 151, 0, (0.73, 0.79, -2.36), 13.45)\n",
        "        self.play(\n",
        "            frame.animate.reorient(-12, 129, 0, (-18.76, 7.73, -104.01), 439.75),\n",
        "            rad_factor.animate.set_value(0.0025),\n",
        "            run_time=12\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            frame.animate.reorient(-115, 86, 0, ORIGIN, 1200),\n",
        "            rad_factor.animate.set_value(0.002),\n",
        "            run_time=10\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(107, 87, 0),\n",
        "            run_time=15,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(17, 100, 0, (-69.76, -40.26, -81.8), 186.35),\n",
        "            rad_factor.animate.set_value(0.003),\n",
        "            run_time=10,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-84, 85, 0, ORIGIN, 1100),\n",
        "            rad_factor.animate.set_value(0.002),\n",
        "            run_time=10,\n",
        "        )\n",
        "\n",
        "\n",
        "class RungsUpToGalaxies(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Test\n",
        "        rungs = VGroup(\n",
        "            Text(\"Distance to the sun\"),\n",
        "            Text(\"Stellar parallax\"),\n",
        "            Text(\"Main sequence fitting\"),\n",
        "            Text(\"Cepheid periods\"),\n",
        "            Text(\"Red shift\"),\n",
        "        )\n",
        "        rungs.arrange(UP, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        rungs.to_edge(LEFT)\n",
        "\n",
        "        self.add(rungs)\n",
        "        for n in [0, 1, 2, 4, 3, 4]:\n",
        "            rungs.target = rungs.generate_target()\n",
        "            for k, rung in enumerate(rungs.target):\n",
        "                if n == k:\n",
        "                    height, opacity = (0.5, 1)\n",
        "                else:\n",
        "                    height, opacity = (0.3, 0.35)\n",
        "                rung.set_height(height, about_edge=LEFT)\n",
        "                rung.set_opacity(opacity)\n",
        "            self.play(MoveToTarget(rungs))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class WriteLeGentil(InteractiveScene):\n",
        "    def construct(self):\n",
        "        name = Text(\"Guillaume Le Gentil\", font_size=72)\n",
        "        name.to_corner(UL)\n",
        "        name.set_backstroke(BLACK, 3)\n",
        "        self.play(Write(name, stroke_color=WHITE))\n",
        "        self.wait()"
    ]
}