{
    "topic": "The mathematical concept being demonstrated is the Brachistochrone problem, which is a classic problem",
    "code": [
        "import numpy as np\n",
        "import itertools as it\n",
        "\n",
        "from manim_imports_ext import *\n",
        "from from_3b1b.old.brachistochrone.curves import Cycloid\n",
        "\n",
        "class PhysicalIntuition(Scene):\n",
        "    def construct(self):\n",
        "        n_terms = 4\n",
        "        def func(xxx_todo_changeme):\n",
        "            (x, y, ignore) = xxx_todo_changeme\n",
        "            z = complex(x, y)                                    \n",
        "            if (np.abs(x%1 - 0.5)<0.01 and y < 0.01) or np.abs(z)<0.01:\n",
        "                return ORIGIN\n",
        "            out_z = 1./(2*np.tan(np.pi*z)*(z**2))\n",
        "            return out_z.real*RIGHT - out_z.imag*UP\n",
        "        arrows = Mobject(*[\n",
        "            Arrow(ORIGIN, np.sqrt(2)*point)\n",
        "            for point in compass_directions(4, RIGHT+UP)\n",
        "        ])\n",
        "        arrows.set_color(YELLOW)\n",
        "        arrows.ingest_submobjects()\n",
        "        all_arrows = Mobject(*[\n",
        "            arrows.copy().scale(0.3/(x)).shift(x*RIGHT)\n",
        "            for x in range(1, n_terms+2)\n",
        "        ])\n",
        "        terms = OldTex([\n",
        "            \"\\\\dfrac{1}{%d^2} + \"%(x+1)\n",
        "            for x in range(n_terms)\n",
        "        ]+[\"\\\\cdots\"])\n",
        "        terms.shift(2*UP)\n",
        "        plane = NumberPlane(color = BLUE_E)\n",
        "        axes = Mobject(NumberLine(), NumberLine().rotate(np.pi/2))\n",
        "        axes.set_color(WHITE)\n",
        "\n",
        "        for term in terms.split():\n",
        "            self.play(ShimmerIn(term, run_time = 0.5))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(plane), ShowCreation(axes))\n",
        "        self.play(*[\n",
        "            Transform(*pair)\n",
        "            for pair in zip(terms.split(), all_arrows.split())\n",
        "        ])\n",
        "        self.play(PhaseFlow(\n",
        "            func, plane,\n",
        "            run_time = 5,\n",
        "            virtual_time = 8\n",
        "        ))\n",
        "\n",
        "\n",
        "\n",
        "class TimeLine(Scene):\n",
        "    def construct(self):\n",
        "        dated_events = [\n",
        "            {\n",
        "                \"date\" : 1696, \n",
        "                \"text\": \"Johann Bernoulli poses Brachistochrone problem\",\n",
        "                \"picture\" : \"Johann_Bernoulli2\"\n",
        "            },\n",
        "            {\n",
        "                \"date\" : 1662, \n",
        "                \"text\" : \"Fermat states his principle of least time\",\n",
        "                \"picture\" : \"Pierre_de_Fermat\"\n",
        "            }\n",
        "        ]\n",
        "        speical_dates = [2016] + [\n",
        "            obj[\"date\"] for obj in dated_events\n",
        "        ]\n",
        "        centuries = list(range(1600, 2100, 100))\n",
        "        timeline = NumberLine(\n",
        "            numerical_radius = 300,\n",
        "            number_at_center = 1800,\n",
        "            unit_length_to_spatial_width = FRAME_X_RADIUS/100,\n",
        "            tick_frequency = 10,\n",
        "            big_tick_numbers = centuries\n",
        "        )\n",
        "        timeline.add_numbers(*centuries)\n",
        "        centers = [\n",
        "            Point(timeline.number_to_point(year))\n",
        "            for year in speical_dates\n",
        "        ]\n",
        "        timeline.add(*centers)\n",
        "        timeline.shift(-centers[0].get_center())\n",
        "\n",
        "        self.add(timeline)\n",
        "        self.wait()\n",
        "        run_times = iter([3, 1])\n",
        "        for point, event in zip(centers[1:], dated_events):\n",
        "            self.play(ApplyMethod(\n",
        "                timeline.shift, -point.get_center(), \n",
        "                run_time = next(run_times)\n",
        "            ))\n",
        "            picture = ImageMobject(event[\"picture\"], invert = False)\n",
        "            picture.set_width(2)\n",
        "            picture.to_corner(UP+RIGHT)\n",
        "            event_mob = OldTexText(event[\"text\"])\n",
        "            event_mob.shift(2*LEFT+2*UP)\n",
        "            date_mob = OldTex(str(event[\"date\"]))\n",
        "            date_mob.scale(0.5)\n",
        "            date_mob.shift(0.6*UP)\n",
        "            line = Line(event_mob.get_bottom(), 0.2*UP)\n",
        "            self.play(\n",
        "                ShimmerIn(event_mob),\n",
        "                ShowCreation(line),\n",
        "                ShimmerIn(date_mob)\n",
        "            )\n",
        "            self.play(FadeIn(picture))\n",
        "            self.wait(3)\n",
        "            self.play(*list(map(FadeOut, [event_mob, date_mob, line, picture])))\n",
        "\n",
        "\n",
        "class StayedUpAllNight(Scene):\n",
        "    def construct(self):\n",
        "        clock = Circle(radius = 2, color = WHITE)\n",
        "        clock.add(Dot(ORIGIN))\n",
        "        ticks = Mobject(*[\n",
        "            Line(1.8*vect, 2*vect, color = GREY)\n",
        "            for vect in compass_directions(12)\n",
        "        ])\n",
        "        clock.add(ticks)\n",
        "        hour_hand = Line(ORIGIN, UP)\n",
        "        minute_hand = Line(ORIGIN, 1.5*UP)\n",
        "        clock.add(hour_hand, minute_hand)\n",
        "        clock.to_corner(UP+RIGHT)\n",
        "        hour_hand.get_center = lambda : clock.get_center()\n",
        "        minute_hand.get_center = lambda : clock.get_center()\n",
        " \n",
        "        solution = ImageMobject(\n",
        "            \"Newton_brachistochrone_solution2\",\n",
        "            use_cache = False\n",
        "        )\n",
        "        solution.stroke_width = 3\n",
        "        solution.set_color(GREY)\n",
        "        solution.set_width(5)\n",
        "        solution.to_corner(UP+RIGHT)\n",
        "        newton = ImageMobject(\"Old_Newton\", invert = False)\n",
        "        newton.scale(0.8)\n",
        "        phil_trans = OldTexText(\"Philosophical Transactions\")\n",
        "        rect = Rectangle(height = 6, width = 4.5, color = WHITE)\n",
        "        rect.to_corner(UP+RIGHT)\n",
        "        rect.shift(DOWN)\n",
        "        phil_trans.set_width(0.8*rect.get_width())\n",
        "        phil_trans.next_to(Point(rect.get_top()), DOWN)\n",
        "        new_solution = solution.copy()\n",
        "        new_solution.set_width(phil_trans.get_width())\n",
        "        new_solution.next_to(phil_trans, DOWN, buff = 1)\n",
        "        not_newton = OldTexText(\"-Totally not by Newton\")\n",
        "        not_newton.set_width(2.5)\n",
        "        not_newton.next_to(new_solution, DOWN, aligned_edge = RIGHT)\n",
        "        phil_trans.add(rect)\n",
        "\n",
        "        newton_complaint = OldTexText([\n",
        "            \"``I do not love to be\",\n",
        "            \" \\\\emph{dunned} \",\n",
        "            \"and teased by foreigners''\"\n",
        "        ], size = \"\\\\small\")\n",
        "        newton_complaint.to_edge(UP, buff = 0.2)\n",
        "        dunned = newton_complaint.split()[1]\n",
        "        dunned.set_color()\n",
        "        dunned_def = OldTexText(\"(old timey term for making \\\\\\\\ demands on someone)\")\n",
        "        dunned_def.scale(0.7)\n",
        "        dunned_def.next_to(phil_trans, LEFT)\n",
        "        dunned_def.shift(2*UP)\n",
        "        dunned_arrow = Arrow(dunned_def, dunned)\n",
        "\n",
        "        johann = ImageMobject(\"Johann_Bernoulli2\", invert = False)\n",
        "        johann.scale(0.4)\n",
        "        johann.to_edge(LEFT)\n",
        "        johann.shift(DOWN)\n",
        "        johann_quote = OldTexText(\"``I recognize the lion by his claw''\")\n",
        "        johann_quote.next_to(johann, UP, aligned_edge = LEFT)\n",
        "\n",
        "        self.play(ApplyMethod(newton.to_edge, LEFT))\n",
        "        self.play(ShowCreation(clock))\n",
        "        kwargs = {\n",
        "            \"axis\" : OUT,\n",
        "            \"rate_func\" : smooth\n",
        "        }\n",
        "        self.play(\n",
        "            Rotating(hour_hand, radians = -2*np.pi, **kwargs),\n",
        "            Rotating(minute_hand, radians = -12*2*np.pi, **kwargs),\n",
        "            run_time = 5\n",
        "        )\n",
        "        self.wait()\n",
        "        self.clear()\n",
        "        self.add(newton)\n",
        "        clock.ingest_submobjects()\n",
        "        self.play(Transform(clock, solution))\n",
        "        self.remove(clock)\n",
        "        self.add(solution)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(phil_trans),\n",
        "            Transform(solution, new_solution)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(not_newton))\n",
        "        phil_trans.add(solution, not_newton)\n",
        "        self.wait()\n",
        "        self.play(*list(map(ShimmerIn, newton_complaint.split())))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShimmerIn(dunned_def),\n",
        "            ShowCreation(dunned_arrow)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.remove(dunned_def, dunned_arrow)\n",
        "        self.play(FadeOut(newton_complaint))\n",
        "        self.remove(newton_complaint)\n",
        "        self.play(\n",
        "            FadeOut(newton),\n",
        "            GrowFromCenter(johann)\n",
        "        )\n",
        "        self.remove(newton)        \n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(johann_quote))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ThetaTGraph(Scene):\n",
        "    def construct(self):\n",
        "        t_axis = NumberLine()\n",
        "        theta_axis = NumberLine().rotate(np.pi/2)\n",
        "        theta_mob = OldTex(\"\\\\theta(t)\")\n",
        "        t_mob = OldTex(\"t\")\n",
        "        theta_mob.next_to(theta_axis, RIGHT)\n",
        "        theta_mob.to_edge(UP)\n",
        "        t_mob.next_to(t_axis, UP)\n",
        "        t_mob.to_edge(RIGHT)\n",
        "        graph = ParametricCurve(\n",
        "            lambda t : 4*t*RIGHT + 2*smooth(t)*UP\n",
        "        )\n",
        "        line = Line(graph.get_points()[0], graph.get_points()[-1], color = WHITE)\n",
        "        q_mark = OldTexText(\"?\")\n",
        "        q_mark.next_to(Point(graph.get_center()), LEFT)\n",
        "        stars = Stars(color = BLACK)\n",
        "        stars.scale(0.1).shift(q_mark.get_center())\n",
        "\n",
        "\n",
        "        squiggle = ParametricCurve(\n",
        "            lambda t : t*RIGHT + 0.2*t*(5-t)*(np.sin(t)**2)*UP,\n",
        "            start = 0,\n",
        "            end = 5\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(t_axis),\n",
        "            ShowCreation(theta_axis),\n",
        "            ShimmerIn(theta_mob),\n",
        "            ShimmerIn(t_mob)\n",
        "        )\n",
        "        self.play(\n",
        "            ShimmerIn(q_mark),\n",
        "            ShowCreation(graph)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(q_mark, stars),\n",
        "            Transform(graph, line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(graph, squiggle))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SolutionsToTheBrachistochrone(Scene):\n",
        "    def construct(self):\n",
        "        r_range = np.arange(0.5, 2, 0.25)\n",
        "        cycloids = Mobject(*[\n",
        "            Cycloid(radius = r, end_theta=2*np.pi)\n",
        "            for r in r_range\n",
        "        ])\n",
        "        lower_left = 2*DOWN+6*LEFT\n",
        "        lines = Mobject(*[\n",
        "            Line(\n",
        "                lower_left, \n",
        "                lower_left+5*r*np.cos(np.arctan(r))*RIGHT+2*r*np.sin(np.arctan(r))*UP\n",
        "            )\n",
        "            for r in r_range\n",
        "        ])\n",
        "        nl = NumberLine(big_tick_numbers = [])\n",
        "        x_axis = nl.copy().shift(3*UP)\n",
        "        y_axis = nl.copy().rotate(np.pi/2).shift(6*LEFT)\n",
        "        t_axis = nl.copy().shift(2*DOWN)\n",
        "        x_label = OldTex(\"x\")\n",
        "        x_label.next_to(x_axis, DOWN)\n",
        "        x_label.to_edge(RIGHT)\n",
        "        y_label = OldTex(\"y\")\n",
        "        y_label.next_to(y_axis, RIGHT)\n",
        "        y_label.shift(2*DOWN)\n",
        "        t_label = OldTex(\"t\")\n",
        "        t_label.next_to(t_axis, UP)\n",
        "        t_label.to_edge(RIGHT)\n",
        "        theta_label = OldTex(\"\\\\theta\")\n",
        "        theta_label.next_to(y_axis, RIGHT)\n",
        "        theta_label.to_edge(UP)\n",
        "        words = OldTexText(\"Boundary conditions?\")\n",
        "        words.next_to(lines, RIGHT)\n",
        "        words.shift(2*UP)\n",
        "\n",
        "        self.play(ShowCreation(x_axis), ShimmerIn(x_label))\n",
        "        self.play(ShowCreation(y_axis), ShimmerIn(y_label))\n",
        "        self.play(ShowCreation(cycloids))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(cycloids, lines),\n",
        "            Transform(x_axis, t_axis),\n",
        "            Transform(x_label, t_label),\n",
        "            Transform(y_label, theta_label),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class VideoLayout(Scene):\n",
        "    def construct(self):\n",
        "        left, right = 5*LEFT, 5*RIGHT\n",
        "        top_words = OldTexText(\"The next 15 minutes of your life:\")\n",
        "        top_words.to_edge(UP)\n",
        "        line = Line(left, right, color = BLUE_D)\n",
        "        for a in np.arange(0, 4./3, 1./3):\n",
        "            vect = interpolate(left, right, a)\n",
        "            line.add_line(vect+0.2*DOWN, vect+0.2*UP)\n",
        "        left_brace = Brace(\n",
        "            Mobject(\n",
        "                Point(left), \n",
        "                Point(interpolate(left, right, 2./3))\n",
        "            ),\n",
        "            DOWN\n",
        "        )\n",
        "        right_brace = Brace(\n",
        "            Mobject(\n",
        "                Point(interpolate(left, right, 2./3)),\n",
        "                Point(right)\n",
        "            ),\n",
        "            UP\n",
        "        )\n",
        "        left_brace.words = list(map(TexText, [\n",
        "            \"Problem statement\", \n",
        "            \"History\",\n",
        "            \"Johann Bernoulli's cleverness\"\n",
        "        ]))\n",
        "        curr = left_brace\n",
        "        right_brace.words = list(map(TexText, [\n",
        "            \"Challenge\",\n",
        "            \"Mark Levi's cleverness\",            \n",
        "        ]))\n",
        "        for brace in left_brace, right_brace:\n",
        "            curr = brace\n",
        "            direction = DOWN if brace is left_brace else UP\n",
        "            for word in brace.words:\n",
        "                word.next_to(curr, direction)\n",
        "                curr = word\n",
        "        right_brace.words.reverse()\n",
        "\n",
        "        self.play(ShimmerIn(top_words))\n",
        "        self.play(ShowCreation(line))\n",
        "        for brace in left_brace, right_brace:\n",
        "            self.play(GrowFromCenter(brace))\n",
        "            self.wait()\n",
        "            for word in brace.words:\n",
        "                self.play(ShimmerIn(word))\n",
        "                self.wait()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class ShortestPathProblem(Scene):\n",
        "    def construct(self):\n",
        "        point_a, point_b = 3*LEFT, 3*RIGHT\n",
        "        dots = []\n",
        "        for point, char in [(point_a, \"A\"), (point_b, \"B\")]:\n",
        "            dot = Dot(point)\n",
        "            letter = OldTex(char)\n",
        "            letter.next_to(dot, UP+LEFT)\n",
        "            dot.add(letter)\n",
        "            dots.append(dot)\n",
        "\n",
        "        path = ParametricCurve(\n",
        "            lambda t : (t/2 + np.cos(t))*RIGHT + np.sin(t)*UP,\n",
        "            start = -2*np.pi,\n",
        "            end = 2*np.pi\n",
        "        )\n",
        "        path.scale(6/(2*np.pi))\n",
        "        path.shift(point_a - path.get_points()[0])\n",
        "        path.set_color(RED)\n",
        "        line = Line(point_a, point_b)\n",
        "        words = OldTexText(\"Shortest path from $A$ to $B$\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            ShimmerIn(words),\n",
        "            *list(map(GrowFromCenter, dots))\n",
        "        )\n",
        "        self.play(ShowCreation(path))\n",
        "        self.play(Transform(\n",
        "            path, line,\n",
        "            path_func = path_along_arc(np.pi)\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MathBetterThanTalking(Scene):\n",
        "    def construct(self):\n",
        "        mathy = Mathematician()\n",
        "        mathy.to_corner(DOWN+LEFT)\n",
        "        bubble = ThoughtBubble()\n",
        "        bubble.pin_to(mathy)\n",
        "        bubble.write(\"Math $>$ Talking about math\")\n",
        "\n",
        "        self.add(mathy)\n",
        "        self.play(ShowCreation(bubble))\n",
        "        self.play(ShimmerIn(bubble.content))\n",
        "        self.wait()\n",
        "        self.play(ApplyMethod(\n",
        "            mathy.blink, \n",
        "            rate_func = squish_rate_func(there_and_back, 0.4, 0.6)\n",
        "        ))\n",
        "\n",
        "\n",
        "class DetailsOfProofBox(Scene):\n",
        "    def construct(self):\n",
        "        rect = Rectangle(height = 4, width = 6, color = WHITE)\n",
        "        words = OldTexText(\"Details of proof\")\n",
        "        words.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            ShimmerIn(words)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "\n",
        "class TalkedAboutSnellsLaw(Scene):\n",
        "    def construct(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_corner(DOWN+LEFT)\n",
        "        morty = Mortimer()\n",
        "        morty.to_edge(DOWN+RIGHT)\n",
        "        randy.bubble = SpeechBubble().pin_to(randy)\n",
        "        morty.bubble = SpeechBubble().pin_to(morty)\n",
        "\n",
        "        phrases = [\n",
        "            \"Let's talk about Snell's law\",\n",
        "            \"I love Snell's law\",\n",
        "            \"It's like running from \\\\\\\\ a beach into the ocean\",\n",
        "            \"It's like two constant \\\\\\\\ tension springs\",\n",
        "        ]\n",
        "\n",
        "        self.add(randy, morty)\n",
        "        talkers = it.cycle([randy, morty])\n",
        "        for talker, phrase in zip(talkers, phrases):\n",
        "            talker.bubble.write(phrase)\n",
        "            self.play(\n",
        "                FadeIn(talker.bubble),\n",
        "                ShimmerIn(talker.bubble.content)\n",
        "            )\n",
        "            self.play(ApplyMethod(\n",
        "                talker.blink, \n",
        "                rate_func = squish_rate_func(there_and_back)\n",
        "            ))\n",
        "            self.wait()\n",
        "            self.remove(talker.bubble, talker.bubble.content)\n",
        "\n",
        "\n",
        "class YetAnotherMarkLevi(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"Yet another bit of Mark Levi cleverness\")\n",
        "        words.to_edge(UP)\n",
        "        levi = ImageMobject(\"Mark_Levi\", invert = False)\n",
        "        levi.set_width(6)\n",
        "        levi.show()\n",
        "\n",
        "        self.add(levi)\n",
        "        self.play(ShimmerIn(words))\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}