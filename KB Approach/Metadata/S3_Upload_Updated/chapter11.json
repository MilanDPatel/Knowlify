{
    "topic": "The mathematical concept being demonstrated is the definition and explanation of vectors.",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2016.eola.chapter1 import plane_wave_homotopy\n",
        "from _2016.eola.chapter3 import ColumnsToBasisVectors\n",
        "from _2016.eola.chapter5 import NameDeterminant, Blob\n",
        "from _2016.eola.chapter9 import get_small_bubble\n",
        "from _2016.eola.chapter10 import ExampleTranformationScene\n",
        "\n",
        "class Student(PiCreature):\n",
        "    CONFIG = {\n",
        "        \"name\" : \"Student\"\n",
        "    }\n",
        "    def get_name(self):\n",
        "        text = OldTexText(self.name)\n",
        "        text.add_background_rectangle()\n",
        "        text.next_to(self, DOWN)\n",
        "        return text\n",
        "\n",
        "class PhysicsStudent(Student):\n",
        "    CONFIG = {\n",
        "        \"color\" : PINK,\n",
        "        \"name\" : \"Physics student\"\n",
        "    }\n",
        "\n",
        "class CSStudent(Student):\n",
        "    CONFIG = {\n",
        "        \"color\" : PURPLE_E,\n",
        "        \"flip_at_start\" : True,\n",
        "        \"name\" : \"CS Student\"\n",
        "    } \n",
        "\n",
        "class OpeningQuote(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"``Such\",\n",
        "            \"axioms,\", \n",
        "            \"together with other unmotivated definitions,\", \n",
        "            \"serve mathematicians mainly by making it\",\n",
        "            \"difficult for the uninitiated\",\n",
        "            \"to master their subject, thereby elevating its authority.''\",\n",
        "            enforce_new_line_structure = False,\n",
        "            alignment = \"\",\n",
        "        )\n",
        "        words.set_color_by_tex(\"axioms,\", BLUE)\n",
        "        words.set_color_by_tex(\"difficult for the uninitiated\", RED)\n",
        "        words.set_width(FRAME_WIDTH - 2)\n",
        "        words.to_edge(UP)\n",
        "        author = OldTexText(\"-Vladmir Arnold\")\n",
        "        author.set_color(YELLOW)\n",
        "        author.next_to(words, DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(words, run_time = 8))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(author))\n",
        "        self.wait(3)\n",
        "\n",
        "class RevisitOriginalQuestion(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Let's revisit \", \"\\\\\\\\ an old question\")\n",
        "        self.random_blink()\n",
        "        question = OldTexText(\"What are \", \"vectors\", \"?\", arg_separator = \"\")\n",
        "        question.set_color_by_tex(\"vectors\", YELLOW)\n",
        "        self.teacher_says(\n",
        "            question,\n",
        "            added_anims = [\n",
        "                ApplyMethod(self.get_students()[i].change_mode, mode)\n",
        "                for i, mode in enumerate([\n",
        "                    \"pondering\", \"raise_right_hand\", \"erm\"\n",
        "                ])\n",
        "            ]\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "\n",
        "class WhatIsA2DVector(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"v_coords\" : [1, 2],\n",
        "        \"show_basis_vectors\" : False,\n",
        "        \"include_background_plane\" : False,\n",
        "        \"foreground_plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_HEIGHT,\n",
        "            \"secondary_line_ratio\" : 1\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.plane.fade()\n",
        "        self.introduce_vector_and_space()\n",
        "        self.bring_in_students()\n",
        "\n",
        "    def introduce_vector_and_space(self):\n",
        "        v = Vector(self.v_coords)\n",
        "        coords = Matrix(self.v_coords)\n",
        "        coords.add_to_back(BackgroundRectangle(coords))\n",
        "        coords.next_to(v.get_end(), RIGHT)\n",
        "\n",
        "        two_d_vector = OldTexText(\n",
        "            \"``Two-dimensional \", \"vector\", \"''\", \n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        two_d_vector.set_color_by_tex(\"vector\", YELLOW)\n",
        "        two_d_vector.add_background_rectangle()\n",
        "        two_d_vector.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            Write(two_d_vector),\n",
        "            ShowCreation(v),\n",
        "            Write(coords),\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "        self.v, self.coords = v, coords\n",
        "\n",
        "    def bring_in_students(self):\n",
        "        everything = self.get_mobjects()\n",
        "        v, coords = self.v, self.coords\n",
        "        physics_student = PhysicsStudent()\n",
        "        cs_student = CSStudent()\n",
        "        students = [physics_student, cs_student]\n",
        "        for student, vect in zip(students, [LEFT, RIGHT]):\n",
        "            student.change_mode(\"confused\")\n",
        "            student.to_corner(DOWN+vect, buff = MED_LARGE_BUFF)\n",
        "            student.look_at(v)\n",
        "            student.bubble = get_small_bubble(\n",
        "                student, height = 4, width = 4,\n",
        "            )\n",
        "        self.play(*list(map(FadeIn, students)))\n",
        "        self.play(Blink(physics_student))\n",
        "        self.wait()\n",
        "        for student, vect in zip(students, [RIGHT, LEFT]):\n",
        "            for mob in v, coords:\n",
        "                mob.target = mob.copy()\n",
        "                mob.target.scale(0.7)\n",
        "            arrow = OldTex(\"\\\\Rightarrow\")\n",
        "            group = VGroup(v.target, arrow, coords.target)\n",
        "            group.arrange(vect)\n",
        "            student.bubble.add_content(group)\n",
        "            student.v, student.coords = v.copy(), coords.copy()\n",
        "            student.arrow = arrow\n",
        "\n",
        "            self.play(\n",
        "                student.change_mode, \"pondering\",\n",
        "                ShowCreation(student.bubble),\n",
        "                Write(arrow),\n",
        "                Transform(student.v, v.target),\n",
        "                Transform(student.coords, coords.target),\n",
        "            )\n",
        "            self.play(Blink(student))\n",
        "            self.wait()\n",
        "        anims = []\n",
        "        for student in students:\n",
        "            v, coords = student.v, student.coords\n",
        "            v.target = v.copy()\n",
        "            coords.target = coords.copy()\n",
        "            group = VGroup(v.target, coords.target)\n",
        "            group.arrange(DOWN)\n",
        "            group.set_height(coords.get_height())\n",
        "            group.next_to(student.arrow, RIGHT)\n",
        "            student.q_marks = OldTex(\"???\")\n",
        "            student.q_marks.set_color_by_gradient(BLUE, YELLOW)\n",
        "            student.q_marks.next_to(student.arrow, LEFT)\n",
        "            anims += [\n",
        "                Write(student.q_marks),\n",
        "                MoveToTarget(v),\n",
        "                MoveToTarget(coords),\n",
        "                student.change_mode, \"erm\",\n",
        "                student.look_at, student.bubble\n",
        "            ]\n",
        "        cs_student.v.save_state()\n",
        "        cs_student.coords.save_state()\n",
        "        self.play(*anims)\n",
        "        for student in students:\n",
        "            self.play(Blink(student))\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeOut, everything + [\n",
        "                physics_student.bubble,\n",
        "                physics_student.v,\n",
        "                physics_student.coords,\n",
        "                physics_student.arrow,\n",
        "                physics_student.q_marks,\n",
        "                cs_student.q_marks,\n",
        "            ])),\n",
        "            [ApplyMethod(s.change_mode, \"plain\") for s in students],\n",
        "            list(map(Animation, [cs_student.bubble, cs_student.arrow])),\n",
        "            [mob.restore for mob in (cs_student.v, cs_student.coords)],\n",
        "        ))\n",
        "        bubble = cs_student.get_bubble(SpeechBubble, width = 4, height = 3)\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "        bubble.next_to(cs_student, UP+LEFT)\n",
        "        bubble.write(\"Consider higher \\\\\\\\ dimensions\")\n",
        "        self.play(\n",
        "            cs_student.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.play(Blink(physics_student))\n",
        "        self.wait()\n",
        "\n",
        "class HigherDimensionalVectorsNumerically(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"4D vector\", \n",
        "            \"5D vector\", \n",
        "            \"100D vector\", \n",
        "        ])))\n",
        "        words.arrange(RIGHT, buff = LARGE_BUFF*2)\n",
        "        words.to_edge(UP)\n",
        "        vectors = VGroup(*list(map(Matrix, [\n",
        "            [3, 1, 4, 1],\n",
        "            [5, 9, 2, 6, 5],\n",
        "            [3, 5, 8, \"\\\\vdots\", 0, 8, 6]\n",
        "        ])))\n",
        "        colors = [YELLOW, MAROON_B, GREEN]\n",
        "        for word, vector, color in zip(words, vectors, colors):\n",
        "            vector.shift(word.get_center()[0]*RIGHT)\n",
        "            word.set_color(color)\n",
        "            vector.set_color(color)\n",
        "\n",
        "        for word in words:\n",
        "            self.play(FadeIn(word))\n",
        "        self.play(Write(vectors))\n",
        "        self.wait()\n",
        "        for index, dim, direction in (0, 4, RIGHT), (2, 100, LEFT):\n",
        "            v = vectors[index]\n",
        "            v.target = v.copy()\n",
        "            brace = Brace(v, direction)\n",
        "            brace.move_to(v)\n",
        "            v.target.next_to(brace, -direction)\n",
        "            text = brace.get_text(\"%d numbers\"%dim)            \n",
        "            self.play(\n",
        "                MoveToTarget(v),\n",
        "                GrowFromCenter(brace),\n",
        "                Write(text)\n",
        "            )\n",
        "            entries = v.get_entries()\n",
        "            num_entries = len(list(entries))\n",
        "            self.play(*[\n",
        "                Transform(\n",
        "                    entries[i],\n",
        "                    entries[i].copy().scale(1.2).set_color(WHITE),\n",
        "                    rate_func = squish_rate_func(\n",
        "                        there_and_back, \n",
        "                        i/(2.*num_entries), \n",
        "                        i/(2.*num_entries)+0.5\n",
        "                    ),\n",
        "                    run_time = 2                    \n",
        "                )\n",
        "                for i in range(num_entries)\n",
        "            ])\n",
        "            self.wait()\n",
        "\n",
        "class HyperCube(VMobject):\n",
        "    CONFIG = {\n",
        "        \"color\" : BLUE_C,\n",
        "        \"color2\" : BLUE_D, \n",
        "        \"dims\" : 4,\n",
        "    }\n",
        "    def init_points(self):\n",
        "        corners = np.array(list(map(np.array, it.product(*[(-1, 1)]*self.dims))))\n",
        "        def project(four_d_array):\n",
        "            result = four_d_array[:3]\n",
        "            w = four_d_array[self.dims-1]\n",
        "            scalar = interpolate(0.8, 1.2 ,(w+1)/2.)\n",
        "            return scalar*result\n",
        "        for a1, a2 in it.combinations(corners, 2):\n",
        "            if sum(a1==a2) != self.dims-1:\n",
        "                continue\n",
        "            self.add(Line(project(a1), project(a2)))\n",
        "        self.pose_at_angle()\n",
        "        self.set_color_by_gradient(self.color, self.color2)\n",
        "\n",
        "class AskAbout4DPhysicsStudent(Scene):\n",
        "    def construct(self):\n",
        "        physy = PhysicsStudent().to_edge(DOWN).shift(2*LEFT)\n",
        "        compy = CSStudent().to_edge(DOWN).shift(2*RIGHT)\n",
        "        for pi1, pi2 in (physy, compy), (compy, physy):\n",
        "            pi1.look_at(pi2.eyes)\n",
        "        physy.bubble = physy.get_bubble(SpeechBubble, width = 5, height = 4.5)\n",
        "\n",
        "        line = Line(LEFT, RIGHT, color = BLUE_B)\n",
        "        square = Square(color = BLUE_C)\n",
        "        square.scale(0.5)\n",
        "        cube = HyperCube(color = BLUE_D, dims = 3)\n",
        "        hyper_cube = HyperCube()\n",
        "        thought_mobs = []\n",
        "        for i, mob in enumerate([line, square, cube, hyper_cube]):\n",
        "            mob.set_height(2)            \n",
        "            tex = OldTex(\"%dD\"%(i+1))\n",
        "            tex.next_to(mob, UP)\n",
        "            group = VGroup(mob, tex)\n",
        "            thought_mobs.append(group)\n",
        "            group.shift(\n",
        "                physy.bubble.get_top() -\\\n",
        "                tex.get_top() + MED_SMALL_BUFF*DOWN\n",
        "            )\n",
        "        line.shift(DOWN)\n",
        "        curr_mob = thought_mobs[0]\n",
        "\n",
        "        self.add(compy, physy)\n",
        "        self.play(\n",
        "            compy.change_mode, \"confused\",\n",
        "            physy.change_mode, \"hooray\",\n",
        "            ShowCreation(physy.bubble),\n",
        "            Write(curr_mob, run_time = 1),\n",
        "        )\n",
        "        self.play(Blink(compy))\n",
        "        for i, mob in enumerate(thought_mobs[1:]):\n",
        "            self.play(Transform(curr_mob, mob))\n",
        "            self.remove(curr_mob)\n",
        "            curr_mob = mob\n",
        "            self.add(curr_mob)\n",
        "            if i%2 == 1:\n",
        "                self.play(Blink(physy))\n",
        "            else:\n",
        "                self.wait()\n",
        "        self.play(Blink(compy))\n",
        "        self.wait()\n",
        "\n",
        "class ManyCoordinateSystems(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"v_coords\" : [2, 1],\n",
        "        \"include_background_plane\" : False,\n",
        "        \"foreground_plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_WIDTH,\n",
        "            \"secondary_line_ratio\" : 1\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.title = OldTexText(\"Many possible coordinate systems\")\n",
        "        self.title.add_background_rectangle()\n",
        "        self.title.to_edge(UP)\n",
        "        self.add_foreground_mobject(self.title)\n",
        "        self.v = Vector(self.v_coords)\n",
        "        self.play(ShowCreation(self.v))\n",
        "        self.add_foreground_mobject(self.v)\n",
        "\n",
        "        t_matrices = [\n",
        "            [[0.5, 0.5], [-0.5, 0.5]],\n",
        "            [[1, -1], [-3, -1]],\n",
        "            [[-1, 2], [-0.5, -1]],\n",
        "        ]\n",
        "        movers = [self.plane, self.i_hat, self.j_hat]\n",
        "        for mover in movers:\n",
        "            mover.save_state()\n",
        "        for t_matrix in t_matrices:\n",
        "            self.animate_coordinates()\n",
        "            self.play(*it.chain(\n",
        "                list(map(FadeOut, movers)),\n",
        "                list(map(Animation, self.foreground_mobjects))\n",
        "            ))\n",
        "            for mover in movers:\n",
        "                mover.restore()\n",
        "            self.apply_transposed_matrix(t_matrix, run_time = 0)\n",
        "            self.play(*it.chain(\n",
        "                list(map(FadeIn, movers)),\n",
        "                list(map(Animation, self.foreground_mobjects))\n",
        "            ))\n",
        "        self.animate_coordinates()\n",
        "\n",
        "\n",
        "    def animate_coordinates(self):\n",
        "        self.i_hat.save_state()\n",
        "        self.j_hat.save_state()\n",
        "        cob_matrix = np.array([\n",
        "            self.i_hat.get_end()[:2],\n",
        "            self.j_hat.get_end()[:2]\n",
        "        ]).T\n",
        "        inv_cob = np.linalg.inv(cob_matrix)\n",
        "        coords = np.dot(inv_cob, self.v_coords)\n",
        "        array = Matrix(list(map(DecimalNumber, coords)))\n",
        "        array.get_entries()[0].set_color(X_COLOR)\n",
        "        array.get_entries()[1].set_color(Y_COLOR)\n",
        "        array.add_to_back(BackgroundRectangle(array))\n",
        "        for entry in array.get_entries():\n",
        "            entry.add_to_back(BackgroundRectangle(entry))\n",
        "        array.next_to(self.title, DOWN)\n",
        "\n",
        "        self.i_hat.target = self.i_hat.copy().scale(coords[0])\n",
        "        self.j_hat.target = self.j_hat.copy().scale(coords[1])\n",
        "        coord1, coord2 = array.get_entries().copy()\n",
        "        for coord, vect in (coord1, self.i_hat), (coord2, self.j_hat):\n",
        "            coord.target = coord.copy().next_to(\n",
        "                vect.target.get_end()/2, \n",
        "                rotate_vector(vect.get_end(), -np.pi/2)\n",
        "            )\n",
        "\n",
        "        self.play(Write(array, run_time = 1))\n",
        "        self.wait()\n",
        "        self.play(*list(map(MoveToTarget, [self.i_hat, coord1])))\n",
        "        self.play(*list(map(MoveToTarget, [self.j_hat, coord2])))\n",
        "        self.play(VGroup(self.j_hat, coord2).shift, self.i_hat.get_end())\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            self.i_hat.restore,\n",
        "            self.j_hat.restore,\n",
        "            *list(map(FadeOut, [array, coord1, coord2]))\n",
        "        )\n",
        "\n",
        "class DeterminantAndEigenvectorDontCare(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"t_matrix\" : [[3, 1], [1, 2]],\n",
        "        \"include_background_plane\" : False,\n",
        "        \"show_basis_vectors\" : False,\n",
        "        \"foreground_plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_HEIGHT,\n",
        "            \"secondary_line_ratio\" : 1\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Determinant\", \n",
        "            \"and\", \n",
        "            \"eigenvectors\", \n",
        "            \"don't \\\\\\\\ care about the coordinate system\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Determinant\", YELLOW)\n",
        "        words.set_color_by_tex(\"eigenvectors\", MAROON_B)\n",
        "        words.add_background_rectangle()\n",
        "        words.to_edge(UP)\n",
        "        dark_yellow = Color(rgb = interpolate(\n",
        "            color_to_rgb(YELLOW),\n",
        "            color_to_rgb(BLACK),\n",
        "            0.5\n",
        "        ))\n",
        "\n",
        "        blob = Blob(\n",
        "            stroke_color = YELLOW,\n",
        "            fill_color = dark_yellow,\n",
        "            fill_opacity = 1,\n",
        "        )\n",
        "        blob.shift(2*LEFT+UP)\n",
        "        det_label = OldTex(\"A\")\n",
        "        det_label = VGroup(\n",
        "            VectorizedPoint(det_label.get_left()).set_color(WHITE),\n",
        "            det_label\n",
        "        )\n",
        "        det_label_target = OldTex(\"\\\\det(M)\\\\cdot\", \"A\")\n",
        "        det_label.move_to(blob)\n",
        "\n",
        "        eigenvectors = VGroup(*self.get_eigenvectors())\n",
        "\n",
        "        self.add_foreground_mobject(words)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(blob),\n",
        "            Write(det_label)\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(\n",
        "                eigenvectors,\n",
        "                run_time = 2,\n",
        "            ),\n",
        "            Animation(words)\n",
        "        )\n",
        "        self.wait()\n",
        "        \n",
        "        self.add_transformable_mobject(blob)\n",
        "        self.add_moving_mobject(det_label, det_label_target)\n",
        "        for vector in eigenvectors:\n",
        "            self.add_vector(vector, animate = False)\n",
        "        self.remove(self.plane)\n",
        "        non_plane_mobs = self.get_mobjects()\n",
        "        self.add(self.plane, *non_plane_mobs)\n",
        "        \n",
        "        cob_matrices = [\n",
        "            None,\n",
        "            [[1, -1], [-3, -1]],\n",
        "            [[-1, 2], [-0.5, -1]],\n",
        "        ] \n",
        "        def special_rate_func(t):\n",
        "            if t < 0.3:\n",
        "                return smooth(t/0.3)\n",
        "            if t > 0.7:\n",
        "                return smooth((1-t)/0.3)\n",
        "            return 1\n",
        "        for cob_matrix in cob_matrices:\n",
        "            if cob_matrix is not None:\n",
        "                self.play(\n",
        "                    FadeOut(self.plane),\n",
        "                    *list(map(Animation, non_plane_mobs))\n",
        "                )\n",
        "                transform = self.get_matrix_transformation(cob_matrix)\n",
        "                self.plane.apply_function(transform)\n",
        "                self.play(\n",
        "                    FadeIn(self.plane),\n",
        "                    *list(map(Animation, non_plane_mobs))\n",
        "                )\n",
        "                self.wait()\n",
        "            self.apply_transposed_matrix(\n",
        "                self.t_matrix,\n",
        "                rate_func = special_rate_func,\n",
        "                run_time = 8\n",
        "            )\n",
        "\n",
        "\n",
        "        \n",
        "\n",
        "    def get_eigenvectors(self):\n",
        "        vals, (eig_matrix) = np.linalg.eig(self.t_matrix.T)\n",
        "        v1, v2 = eig_matrix.T\n",
        "        result = []\n",
        "        for v in v1, v2:\n",
        "            vectors = VGroup(*[\n",
        "                Vector(u*x*v)\n",
        "                for x in range(7, 0, -1)\n",
        "                for u in [-1, 1]\n",
        "            ])\n",
        "            vectors.set_color_by_gradient(MAROON_A, MAROON_C)\n",
        "            result += list(vectors)\n",
        "        return result\n",
        "\n",
        "class WhatIsSpace(Scene):\n",
        "    def construct(self):\n",
        "        physy = PhysicsStudent()\n",
        "        compy = CSStudent()\n",
        "        physy.to_edge(DOWN).shift(4*LEFT)\n",
        "        compy.to_edge(DOWN).shift(4*RIGHT)\n",
        "        physy.make_eye_contact(compy)\n",
        "\n",
        "        physy.bubble = get_small_bubble(physy)\n",
        "        vector = Vector([1, 2])\n",
        "        physy.bubble.add_content(vector)\n",
        "        compy.bubble = compy.get_bubble(SpeechBubble, width = 6, height = 4)\n",
        "        compy.bubble.set_fill(BLACK, opacity = 1)\n",
        "        compy.bubble.write(\"What exactly do\\\\\\\\ you mean by ``space''?\")\n",
        "\n",
        "        self.add(compy, physy)\n",
        "        self.play(\n",
        "            physy.change_mode, \"pondering\",\n",
        "            ShowCreation(physy.bubble),\n",
        "            ShowCreation(vector)\n",
        "        )\n",
        "        self.play(\n",
        "            compy.change_mode, \"sassy\",\n",
        "            ShowCreation(compy.bubble),\n",
        "            Write(compy.bubble.content)\n",
        "        )\n",
        "        self.play(Blink(physy))\n",
        "        self.wait()\n",
        "        self.play(Blink(compy))\n",
        "        self.wait()\n",
        "\n",
        "class OtherVectorishThings(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"There are other\\\\\\\\\",\n",
        "            \"vectorish\",\n",
        "            \"things...\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"vectorish\", YELLOW)\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"raise_right_hand\", \"erm\"\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "        words = OldTexText(\"...like\", \"functions\")\n",
        "        words.set_color_by_tex(\"functions\", PINK)\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink(2)\n",
        "        self.teacher_thinks(\"\")\n",
        "        self.zoom_in_on_thought_bubble(self.get_teacher().bubble)\n",
        "\n",
        "class FunctionGraphScene(Scene):\n",
        "    CONFIG = {\n",
        "        \"graph_colors\" : [RED, YELLOW, PINK],\n",
        "        \"default_functions\" : [\n",
        "            lambda x : (x**3 - 9*x)/20.,\n",
        "            lambda x : -(x**2)/8.+1\n",
        "        ],\n",
        "        \"default_names\" : [\"f\", \"g\", \"h\"],\n",
        "        \"x_min\" : -4,\n",
        "        \"x_max\" : 4,\n",
        "        \"line_to_line_buff\" : 0.03\n",
        "    }\n",
        "    def setup(self):\n",
        "        self.axes = Axes(\n",
        "            x_min = self.x_min,\n",
        "            x_max = self.x_max,\n",
        "        )\n",
        "        self.add(self.axes)\n",
        "        self.graphs = []\n",
        "\n",
        "    def get_function_graph(self, func = None, animate = True, \n",
        "                           add = True, **kwargs):\n",
        "        index = len(self.graphs)\n",
        "        if func is None:\n",
        "            func = self.default_functions[\n",
        "                index%len(self.default_functions)\n",
        "            ]\n",
        "        default_color = self.graph_colors[index%len(self.graph_colors)]\n",
        "        kwargs[\"color\"] = kwargs.get(\"color\", default_color)\n",
        "        kwargs[\"x_min\"] = kwargs.get(\"x_min\", self.x_min)\n",
        "        kwargs[\"x_max\"] = kwargs.get(\"x_max\", self.x_max)\n",
        "        graph = FunctionGraph(func, **kwargs)\n",
        "        if animate:\n",
        "            self.play(ShowCreation(graph))\n",
        "        if add:\n",
        "            self.add(graph)\n",
        "        self.graphs.append(graph)\n",
        "        return graph\n",
        "\n",
        "    def get_index(self, function_graph):\n",
        "        if function_graph not in self.graphs:\n",
        "            self.graphs.append(function_graph)\n",
        "        return self.graphs.index(function_graph)\n",
        "\n",
        "    def get_output_lines(self, function_graph, num_steps = None, nudge = True):\n",
        "        index = self.get_index(function_graph)\n",
        "        num_steps = num_steps or function_graph.num_steps\n",
        "        lines = VGroup()\n",
        "        nudge_size = index*self.line_to_line_buff\n",
        "        x_min, x_max = function_graph.x_min, function_graph.x_max\n",
        "        for x in np.linspace(x_min, x_max, num_steps):\n",
        "            if nudge:\n",
        "                x += nudge_size\n",
        "            y = function_graph.function(x)\n",
        "            lines.add(Line(x*RIGHT, x*RIGHT+y*UP))\n",
        "        lines.set_color(function_graph.get_color())\n",
        "        return lines\n",
        "\n",
        "    def add_lines(self, output_lines):\n",
        "        self.play(ShowCreation(\n",
        "            output_lines,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        ))\n",
        "\n",
        "\n",
        "    def label_graph(self, function_graph, name = None, animate = True):\n",
        "        index = self.get_index(function_graph)\n",
        "        name = name or self.default_names[index%len(self.default_names)]\n",
        "        label = OldTex(\"%s(x)\"%name)\n",
        "        label.next_to(function_graph.point_from_proportion(1), RIGHT)\n",
        "        label.shift_onto_screen()\n",
        "        label.set_color(function_graph.get_color())\n",
        "        if animate:\n",
        "            self.play(Write(label))\n",
        "        else:\n",
        "            self.add(label)\n",
        "        return label\n",
        "\n",
        "class AddTwoFunctions(FunctionGraphScene):\n",
        "    def construct(self):\n",
        "        f_graph = self.get_function_graph()\n",
        "        g_graph = self.get_function_graph()\n",
        "        def sum_func(x):\n",
        "            return f_graph.get_function()(x)+g_graph.get_function()(x)\n",
        "        sum_graph = self.get_function_graph(sum_func, animate = False)\n",
        "        self.remove(sum_graph)\n",
        "        f_label = self.label_graph(f_graph)\n",
        "        g_label = self.label_graph(g_graph)\n",
        "\n",
        "        f_lines = self.get_output_lines(f_graph)\n",
        "        g_lines = self.get_output_lines(g_graph)\n",
        "        sum_lines = self.get_output_lines(sum_graph, nudge = False)\n",
        "\n",
        "        curr_x_point = f_lines[0].get_start()\n",
        "        sum_def = self.get_sum_definition(DecimalNumber(curr_x_point[0]))\n",
        "        # sum_def.set_width(FRAME_X_RADIUS-1)\n",
        "        sum_def.to_corner(UP+LEFT)\n",
        "        arrow = Arrow(sum_def[2].get_bottom(), curr_x_point, color = WHITE)        \n",
        "        prefix = sum_def[0]\n",
        "        suffix = VGroup(*sum_def[1:])\n",
        "        rect = BackgroundRectangle(sum_def)\n",
        "        brace = Brace(prefix)\n",
        "        brace.add(brace.get_text(\"New function\").shift_onto_screen())\n",
        "\n",
        "        self.play(\n",
        "            Write(prefix, run_time = 2),\n",
        "            FadeIn(brace)\n",
        "        )\n",
        "        self.wait()        \n",
        "        for lines in f_lines, g_lines:\n",
        "            self.add_lines(lines)\n",
        "        self.play(*list(map(FadeOut, [f_graph, g_graph])))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(brace))\n",
        "        fg_group = VGroup(*list(f_label)+list(g_label))\n",
        "        self.play(\n",
        "            FadeIn(rect),\n",
        "            Animation(prefix),\n",
        "            Transform(fg_group, suffix),\n",
        "        )\n",
        "        self.remove(prefix, fg_group)\n",
        "        self.add(sum_def)\n",
        "        self.play(ShowCreation(arrow))\n",
        "\n",
        "        self.show_line_addition(f_lines[0], g_lines[0], sum_lines[0])\n",
        "        self.wait()\n",
        "\n",
        "        curr_x_point = f_lines[1].get_start()\n",
        "        new_sum_def = self.get_sum_definition(DecimalNumber(curr_x_point[0]))\n",
        "        new_sum_def.to_corner(UP+LEFT)\n",
        "        new_arrow = Arrow(sum_def[2].get_bottom(), curr_x_point, color = WHITE)\n",
        "        self.play(\n",
        "            Transform(sum_def, new_sum_def),\n",
        "            Transform(arrow, new_arrow),\n",
        "        )\n",
        "        self.show_line_addition(f_lines[1], g_lines[1], sum_lines[1])\n",
        "        self.wait()\n",
        "\n",
        "        final_sum_def = self.get_sum_definition(OldTex(\"x\"))\n",
        "        final_sum_def.to_corner(UP+LEFT)\n",
        "        self.play(\n",
        "            FadeOut(rect),\n",
        "            Transform(sum_def, final_sum_def),\n",
        "            FadeOut(arrow)\n",
        "        )\n",
        "        self.show_line_addition(*it.starmap(VGroup, [\n",
        "            f_lines[2:], g_lines[2:], sum_lines[2:]\n",
        "        ]))\n",
        "        self.play(ShowCreation(sum_graph))\n",
        "\n",
        "    def get_sum_definition(self, input_mob):\n",
        "        result = VGroup(*it.chain(\n",
        "            OldTex(\"(f+g)\", \"(\"), \n",
        "            [input_mob.copy()],\n",
        "            OldTex(\")\", \"=\", \"f(\"),\n",
        "            [input_mob.copy()],\n",
        "            OldTex(\")\", \"+\", \"g(\"),\n",
        "            [input_mob.copy()],\n",
        "            OldTex(\")\")\n",
        "        ))\n",
        "        result.arrange()\n",
        "        result[0].set_color(self.graph_colors[2])\n",
        "        VGroup(result[5], result[7]).set_color(self.graph_colors[0])\n",
        "        VGroup(result[9], result[11]).set_color(self.graph_colors[1])\n",
        "        return result\n",
        "\n",
        "\n",
        "    def show_line_addition(self, f_lines, g_lines, sum_lines):\n",
        "        g_lines.target = g_lines.copy()\n",
        "        dots = VGroup()\n",
        "        dots.target = VGroup()\n",
        "        for f_line, g_line in zip(f_lines, g_lines.target):\n",
        "            align_perfectly = f_line.get_end()[1]*g_line.get_end()[1] > 0\n",
        "            dot = Dot(g_line.get_end(), radius = 0.07)\n",
        "            g_line.shift(f_line.get_end()-g_line.get_start())\n",
        "            dot.target = Dot(g_line.get_end())            \n",
        "            if not align_perfectly:\n",
        "                g_line.shift(self.line_to_line_buff*RIGHT)\n",
        "            dots.add(dot)\n",
        "            dots.target.add(dot.target)\n",
        "        for group in dots, dots.target:\n",
        "            group.set_color(sum_lines[0].get_color())\n",
        "        self.play(ShowCreation(dots))\n",
        "        if len(list(g_lines)) == 1:\n",
        "            kwargs = {}\n",
        "        else:\n",
        "            kwargs = {\n",
        "                \"lag_ratio\" : 0.5,\n",
        "                \"run_time\" : 3\n",
        "            }\n",
        "        self.play(*[\n",
        "            MoveToTarget(mob, **kwargs)\n",
        "            for mob in (g_lines, dots)\n",
        "        ])\n",
        "        # self.play(\n",
        "        #     *[mob.fade for mob in g_lines, f_lines]+[\n",
        "        #     Animation(dots)\n",
        "        # ])\n",
        "        self.wait()\n",
        "\n",
        "class AddVectorsCoordinateByCoordinate(Scene):\n",
        "    def construct(self):\n",
        "        v1 = Matrix([\"x_1\", \"y_1\", \"z_1\"])\n",
        "        v2 = Matrix([\"x_2\", \"y_2\", \"z_2\"])\n",
        "        v_sum =  Matrix([\"x_1 + x_2\", \"y_1 + y_2\", \"z_1 + z_2\"])\n",
        "        for v in v1, v2, v_sum:\n",
        "            v.get_entries()[0].set_color(X_COLOR)\n",
        "            v.get_entries()[1].set_color(Y_COLOR)\n",
        "            v.get_entries()[2].set_color(Z_COLOR)\n",
        "        plus, equals = OldTex(\"+=\")\n",
        "        VGroup(v1, plus, v2, equals, v_sum).arrange()\n",
        "\n",
        "        self.add(v1, plus, v2)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(v_sum.get_brackets())\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(v1.get_entries().copy(), v_sum.get_entries()),\n",
        "            Transform(v2.get_entries().copy(), v_sum.get_entries()),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ScaleFunction(FunctionGraphScene):\n",
        "    def construct(self):\n",
        "        graph = self.get_function_graph(\n",
        "            lambda x : self.default_functions[0](x),\n",
        "            animate = False\n",
        "        )\n",
        "        scaled_graph = self.get_function_graph(\n",
        "            lambda x : graph.get_function()(x)*2,\n",
        "            animate = False, add = False\n",
        "        )\n",
        "        graph_lines = self.get_output_lines(graph)\n",
        "        scaled_lines = self.get_output_lines(scaled_graph, nudge = False)\n",
        "\n",
        "        f_label = self.label_graph(graph, \"f\", animate = False)\n",
        "        two_f_label = self.label_graph(scaled_graph, \"(2f)\", animate = False)\n",
        "        self.remove(two_f_label)\n",
        "\n",
        "        title = OldTex(\"(2f)\", \"(x) = 2\", \"f\", \"(x)\")\n",
        "        title.set_color_by_tex(\"(2f)\", scaled_graph.get_color())\n",
        "        title.set_color_by_tex(\"f\", graph.get_color())\n",
        "        title.next_to(ORIGIN, LEFT, buff = MED_SMALL_BUFF)\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        self.add_lines(graph_lines)\n",
        "        self.wait()\n",
        "        self.play(Transform(graph_lines, scaled_lines))\n",
        "        self.play(ShowCreation(scaled_graph))\n",
        "        self.play(Write(two_f_label))\n",
        "        self.play(FadeOut(graph_lines))\n",
        "        self.wait()\n",
        "\n",
        "class ScaleVectorByCoordinates(Scene):\n",
        "    def construct(self):\n",
        "        two, dot, equals = OldTex(\"2 \\\\cdot =\")\n",
        "        v1 = Matrix(list(\"xyz\"))\n",
        "        v1.get_entries().set_color_by_gradient(X_COLOR, Y_COLOR, Z_COLOR)\n",
        "        v2 = v1.copy()\n",
        "        two_targets = VGroup(*[\n",
        "            two.copy().next_to(entry, LEFT)\n",
        "            for entry in v2.get_entries()\n",
        "        ])\n",
        "        v2.get_brackets()[0].next_to(two_targets, LEFT)\n",
        "        v2.add(two_targets)\n",
        "        VGroup(two, dot, v1, equals, v2).arrange()\n",
        "\n",
        "        self.add(two, dot, v1)\n",
        "        self.play(\n",
        "            Write(equals),\n",
        "            Write(v2.get_brackets())\n",
        "        )\n",
        "        self.play(\n",
        "            Transform(two.copy(), two_targets),\n",
        "            Transform(v1.get_entries().copy(), v2.get_entries())\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class ShowSlopes(Animation):\n",
        "    CONFIG = {\n",
        "        \"line_color\" : YELLOW,\n",
        "        \"dx\" : 0.01,\n",
        "        \"rate_func\" : None,\n",
        "        \"run_time\" : 5\n",
        "    }\n",
        "    def __init__(self, graph, **kwargs):\n",
        "        digest_config(self, kwargs, locals())\n",
        "        line = Line(LEFT, RIGHT, color = self.line_color)\n",
        "        line.save_state()\n",
        "        Animation.__init__(self, line, **kwargs)\n",
        "\n",
        "    def interpolate_mobject(self, alpha):\n",
        "        f = self.graph.point_from_proportion        \n",
        "        low, high = list(map(f, np.clip([alpha-self.dx, alpha+self.dx], 0, 1)))\n",
        "        slope = (high[1]-low[1])/(high[0]-low[0])\n",
        "        self.mobject.restore()\n",
        "        self.mobject.rotate(np.arctan(slope))\n",
        "        self.mobject.move_to(f(alpha))\n",
        "\n",
        "class FromVectorsToFunctions(VectorScene):\n",
        "    def construct(self):\n",
        "        self.show_vector_addition_and_scaling()\n",
        "        self.bring_in_functions()\n",
        "        self.show_derivative()\n",
        "\n",
        "    def show_vector_addition_and_scaling(self):\n",
        "        self.plane = self.add_plane()\n",
        "        self.plane.fade()\n",
        "        words1 = OldTexText(\"Vector\", \"addition\")\n",
        "        words2 = OldTexText(\"Vector\", \"scaling\")\n",
        "        for words in words1, words2:\n",
        "            words.add_background_rectangle()\n",
        "            words.next_to(ORIGIN, RIGHT).to_edge(UP)\n",
        "        self.add(words1)\n",
        "\n",
        "        v = self.add_vector([2, -1], color = MAROON_B)\n",
        "        w = self.add_vector([3, 2], color = YELLOW)\n",
        "        w.save_state()\n",
        "        self.play(w.shift, v.get_end())\n",
        "        vw_sum = self.add_vector(w.get_end(), color = PINK)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(words1, words2),\n",
        "            FadeOut(vw_sum),\n",
        "            w.restore\n",
        "        )\n",
        "        self.add(\n",
        "            v.copy().fade(),\n",
        "            w.copy().fade()\n",
        "        )\n",
        "        self.play(v.scale, 2)\n",
        "        self.play(w.scale, -0.5)\n",
        "        self.wait()\n",
        "\n",
        "    def bring_in_functions(self):\n",
        "        everything = VGroup(*self.get_mobjects())\n",
        "        axes = Axes()\n",
        "        axes.shift(FRAME_WIDTH*LEFT)\n",
        "\n",
        "        fg_scene_config = FunctionGraphScene.CONFIG\n",
        "        graph = FunctionGraph(fg_scene_config[\"default_functions\"][0])\n",
        "        graph.set_color(MAROON_B)\n",
        "        func_tex = OldTex(\"\\\\frac{1}{9}x^3 - x\")\n",
        "        func_tex.set_color(graph.get_color())\n",
        "        func_tex.shift(5.5*RIGHT+2*UP)\n",
        "\n",
        "        words = VGroup(*[\n",
        "            OldTexText(words).add_background_rectangle()\n",
        "            for words in [\n",
        "                \"Linear transformations\",\n",
        "                \"Null space\",\n",
        "                \"Dot products\",\n",
        "                \"Eigen-everything\",\n",
        "            ]\n",
        "        ])\n",
        "        words.set_color_by_gradient(BLUE_B, BLUE_D)\n",
        "        words.arrange(DOWN, aligned_edge = LEFT)\n",
        "        words.to_corner(UP+LEFT)\n",
        "        self.play(FadeIn(\n",
        "            words,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            ApplyMethod(mob.shift, FRAME_WIDTH*RIGHT)\n",
        "            for mob in (axes, everything)\n",
        "        ] + [Animation(words)]\n",
        "        )\n",
        "        self.play(ShowCreation(graph), Animation(words))\n",
        "        self.play(Write(func_tex, run_time = 2))\n",
        "        self.wait(2)\n",
        "\n",
        "        top_word = words[0]\n",
        "        words.remove(top_word)\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            top_word.shift, top_word.get_center()[0]*LEFT\n",
        "        )\n",
        "        self.wait()\n",
        "        self.func_tex = func_tex\n",
        "        self.graph = graph\n",
        "\n",
        "    def show_derivative(self):\n",
        "        func_tex, graph = self.func_tex, self.graph\n",
        "        new_graph = FunctionGraph(lambda x : (x**2)/3.-1)\n",
        "        new_graph.set_color(YELLOW)\n",
        "\n",
        "        func_tex.generate_target()\n",
        "        lp, rp = parens = OldTex(\"()\")\n",
        "        parens.set_height(func_tex.get_height())\n",
        "        L, equals = OldTex(\"L=\")\n",
        "        deriv = OldTex(\"\\\\frac{d}{dx}\")\n",
        "        new_func = OldTex(\"\\\\frac{1}{3}x^2 - 1\")\n",
        "        new_func.set_color(YELLOW)\n",
        "        group = VGroup(\n",
        "            L, lp, func_tex.target, rp,\n",
        "            equals, new_func\n",
        "        )\n",
        "        group.arrange()\n",
        "        group.shift(2*UP).to_edge(LEFT, buff = MED_LARGE_BUFF)\n",
        "        rect = BackgroundRectangle(group)\n",
        "        group.add_to_back(rect)\n",
        "        deriv.move_to(L, aligned_edge = RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(func_tex),\n",
        "            *list(map(Write, [L, lp, rp, equals, new_func]))\n",
        "        )\n",
        "        self.remove(func_tex)\n",
        "        self.add(func_tex.target)\n",
        "        self.wait()\n",
        "        faded_graph = graph.copy().fade()\n",
        "        self.add(faded_graph)\n",
        "        self.play(\n",
        "            Transform(graph, new_graph, run_time = 2),\n",
        "            Animation(group)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Transform(L, deriv))\n",
        "        self.play(ShowSlopes(faded_graph))\n",
        "        self.wait()\n",
        "\n",
        "class TransformationsAndOperators(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\"\"\"\n",
        "            Are these the same\n",
        "            as ``linear operators''?\n",
        "        \"\"\", index = 0)\n",
        "        self.random_blink()\n",
        "        teacher = self.get_teacher()\n",
        "        bubble = teacher.get_bubble(SpeechBubble, height = 2, width = 2)\n",
        "        bubble.set_fill(BLACK, opacity = 1)\n",
        "        bubble.write(\"Yup!\")\n",
        "        self.play(\n",
        "            teacher.change_mode, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content, run_time = 1)\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "\n",
        "class ManyFunctions(FunctionGraphScene):\n",
        "    def construct(self):\n",
        "        randy = Randolph().to_corner(DOWN+LEFT)\n",
        "        self.add(randy)\n",
        "        for i in range(100):\n",
        "            if i < 3:\n",
        "                run_time = 1\n",
        "                self.wait()\n",
        "            elif i < 10:\n",
        "                run_time = 0.4\n",
        "            else:\n",
        "                run_time = 0.2\n",
        "            added_anims = []\n",
        "            if i == 3:\n",
        "                added_anims = [randy.change_mode, \"confused\"]\n",
        "            if i == 10:\n",
        "                added_anims = [randy.change_mode, \"pleading\"]\n",
        "            self.add_random_function(\n",
        "                run_time = run_time,\n",
        "                added_anims = added_anims\n",
        "            )\n",
        "\n",
        "    def add_random_function(self, run_time = 1, added_anims = []):\n",
        "        coefs = np.random.randint(-3, 3, np.random.randint(3, 8))\n",
        "        def func(x):\n",
        "            return sum([c*x**(i) for i, c, in enumerate(coefs)])\n",
        "        graph = self.get_function_graph(func, animate = False)\n",
        "        if graph.get_height() > FRAME_HEIGHT:\n",
        "            graph.stretch_to_fit_height(FRAME_HEIGHT)\n",
        "            graph.shift(graph.point_from_proportion(0.5)[1]*DOWN)\n",
        "            graph.shift(interpolate(-3, 3, random.random())*UP)\n",
        "        graph.set_color(random_bright_color())\n",
        "        self.play(\n",
        "            ShowCreation(graph, run_time = run_time),\n",
        "            *added_anims\n",
        "        )\n",
        "\n",
        "class WhatDoesLinearMean(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"\"\"\n",
        "            What does it mean for\n",
        "            a transformation of functions\n",
        "            to be \"\"\", \"linear\", \"?\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"linear\", BLUE)\n",
        "        self.student_says(words)\n",
        "        self.play_student_changes(\"pondering\")\n",
        "        self.random_blink(4)\n",
        "\n",
        "class FormalDefinitionOfLinear(LinearTransformationScene):\n",
        "    CONFIG = {\n",
        "        \"show_basis_vectors\" : False,\n",
        "        \"include_background_plane\" : False,\n",
        "        \"t_matrix\" : [[1, 1], [-0.5, 1]],\n",
        "        \"w_coords\" : [1, 1],\n",
        "        \"v_coords\" : [1, -2],        \n",
        "        \"foreground_plane_kwargs\" : {\n",
        "            \"x_radius\" : FRAME_WIDTH,\n",
        "            \"y_radius\" : FRAME_HEIGHT,\n",
        "            \"secondary_line_ratio\" : 1\n",
        "        },\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.plane.fade()\n",
        "        self.write_properties()\n",
        "        self.show_additive_property()\n",
        "        self.show_scaling_property()\n",
        "        self.add_words()\n",
        "\n",
        "    def write_properties(self):\n",
        "        title = OldTexText(\n",
        "            \"Formal definition of linearity\"\n",
        "        )\n",
        "        title.add_background_rectangle()\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        v_tex, w_tex = [\"\\\\vec{\\\\textbf{%s}}\"%s for s in \"vw\"]\n",
        "        tex_sets = [\n",
        "            [\n",
        "                (\"\\\\text{Additivity: }\",),\n",
        "                (\"L(\", v_tex, \"+\", w_tex, \")\"),\n",
        "                (\"=\", \"L(\", v_tex, \")\", \"+\", \"L(\", w_tex, \")\"),\n",
        "            ],\n",
        "            [\n",
        "                (\"\\\\text{Scaling: }\",),\n",
        "                (\"L(\", \"c\", v_tex, \")\"),\n",
        "                (\"=\", \"c\", \"L(\", v_tex, \")\"),\n",
        "            ],\n",
        "        ]\n",
        "        properties = VGroup()\n",
        "        for tex_set in tex_sets:\n",
        "            words = VGroup(*it.starmap(Tex, tex_set))\n",
        "            for word in words:\n",
        "                word.set_color_by_tex(v_tex, YELLOW)\n",
        "                word.set_color_by_tex(w_tex, MAROON_B)\n",
        "                word.set_color_by_tex(\"c\", GREEN)\n",
        "            words.arrange()\n",
        "            words.lhs = words[1]\n",
        "            words.rhs = words[2]\n",
        "            words.add_to_back(BackgroundRectangle(words))\n",
        "            # words.scale(0.8)\n",
        "            properties.add(words)\n",
        "        properties.arrange(DOWN, aligned_edge = LEFT, buff = MED_SMALL_BUFF)\n",
        "        properties.next_to(h_line, DOWN, buff = MED_LARGE_BUFF).to_edge(LEFT)\n",
        "\n",
        "        self.play(Write(title), ShowCreation(h_line))\n",
        "        self.wait()\n",
        "        for words in properties:\n",
        "            self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.add_foreground_mobject(title, h_line, *properties)\n",
        "        self.additivity, self.scaling = properties\n",
        "\n",
        "    def show_additive_property(self):\n",
        "        self.plane.save_state()\n",
        "\n",
        "        v = self.add_vector(self.v_coords)\n",
        "        v_label = self.add_transformable_label(v, \"v\", direction = \"right\")\n",
        "        w = self.add_vector(self.w_coords, color = MAROON_B)\n",
        "        w_label = self.add_transformable_label(w, \"w\", direction = \"left\")\n",
        "        w_group = VGroup(w, w_label)\n",
        "        w_group.save_state()\n",
        "        self.play(w_group.shift, v.get_end())\n",
        "        vw_sum = self.add_vector(w.get_end(), color = PINK)\n",
        "        v_label_copy, w_label_copy = v_label.copy(), w_label.copy()\n",
        "        v_label_copy.generate_target()\n",
        "        w_label_copy.generate_target()\n",
        "        plus = OldTex(\"+\")\n",
        "        vw_label = VGroup(v_label_copy.target, plus, w_label_copy.target)\n",
        "        vw_label.arrange()\n",
        "        vw_label.next_to(vw_sum.get_end(), RIGHT)\n",
        "        self.play(\n",
        "            MoveToTarget(v_label_copy),\n",
        "            MoveToTarget(w_label_copy),\n",
        "            Write(plus)\n",
        "        )\n",
        "        vw_label_copy = vw_label.copy()\n",
        "        vw_label = VGroup(\n",
        "            VectorizedPoint(vw_label.get_left()),\n",
        "            vw_label,\n",
        "            VectorizedPoint(vw_label.get_right()),\n",
        "        )\n",
        "        self.remove(v_label_copy, w_label_copy, plus)\n",
        "        self.add(vw_label)\n",
        "        self.play(\n",
        "            w_group.restore,\n",
        "        )\n",
        "        vw_label.target = VGroup(\n",
        "            OldTex(\"L(\").scale(0.8),\n",
        "            vw_label_copy,\n",
        "            OldTex(\")\").scale(0.8),\n",
        "        )\n",
        "        vw_label.target.arrange()\n",
        "        for mob in vw_label, vw_label.target:\n",
        "            mob.add_to_back(BackgroundRectangle(mob))\n",
        "\n",
        "        transform = self.get_matrix_transformation(self.t_matrix)\n",
        "        point = transform(vw_sum.get_end())\n",
        "        vw_label.target.next_to(point, UP)\n",
        "        self.apply_transposed_matrix(\n",
        "            self.t_matrix, \n",
        "            added_anims = [MoveToTarget(vw_label)]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(w_group.shift, v.get_end())\n",
        "        v_label_copy, w_label_copy = v_label.copy(), w_label.copy()\n",
        "        v_label_copy.generate_target()\n",
        "        w_label_copy.generate_target()\n",
        "        equals, plus = OldTex(\"=+\")\n",
        "        rhs = VGroup(\n",
        "            equals, v_label_copy.target,\n",
        "            plus, w_label_copy.target\n",
        "        )\n",
        "        rhs.arrange()\n",
        "        rhs.next_to(vw_label, RIGHT)\n",
        "        rect = BackgroundRectangle(rhs)\n",
        "        self.play(*it.chain(\n",
        "            list(map(Write, [rect, equals, plus])),\n",
        "            list(map(MoveToTarget, [v_label_copy, w_label_copy])),\n",
        "        ))\n",
        "        to_fade = [self.plane, v, v_label, w_group, vw_label, vw_sum]\n",
        "        to_fade += self.get_mobjects_from_last_animation()\n",
        "\n",
        "        self.wait()\n",
        "        self.play(*it.chain(\n",
        "            list(map(FadeOut, to_fade)),\n",
        "            list(map(Animation, self.foreground_mobjects))\n",
        "        ))\n",
        "        self.plane.restore()\n",
        "        self.play(FadeIn(self.plane), *list(map(Animation, self.foreground_mobjects)))\n",
        "        self.transformable_mobjects = []\n",
        "        self.moving_vectors = []        \n",
        "        self.transformable_labels = []\n",
        "        self.moving_mobjects = []\n",
        "        self.add_transformable_mobject(self.plane)\n",
        "        self.add(*self.foreground_mobjects)\n",
        "\n",
        "    def show_scaling_property(self):\n",
        "        v = self.add_vector([1, -1])\n",
        "        v_label = self.add_transformable_label(v, \"v\")\n",
        "        scaled_v = v.copy().scale(2)\n",
        "        scaled_v_label = OldTex(\"c\\\\vec{\\\\textbf{v}}\")\n",
        "        scaled_v_label.set_color(YELLOW)\n",
        "        scaled_v_label[0].set_color(GREEN)\n",
        "        scaled_v_label.next_to(scaled_v.get_end(), RIGHT)\n",
        "        scaled_v_label.add_background_rectangle()\n",
        "        v_copy, v_label_copy = v.copy(), v_label.copy()\n",
        "        self.play(\n",
        "            Transform(v_copy, scaled_v),\n",
        "            Transform(v_label_copy, scaled_v_label),\n",
        "        )\n",
        "        self.remove(v_copy, v_label_copy)\n",
        "        self.add(scaled_v_label)\n",
        "        self.add_vector(scaled_v, animate = False)\n",
        "        self.wait()\n",
        "\n",
        "        transform = self.get_matrix_transformation(self.t_matrix)\n",
        "        point = transform(scaled_v.get_end())\n",
        "        scaled_v_label.target = OldTex(\"L(\", \"c\", \"\\\\vec{\\\\textbf{v}}\", \")\")\n",
        "        scaled_v_label.target.set_color_by_tex(\"c\", GREEN)\n",
        "        scaled_v_label.target.set_color_by_tex(\"\\\\vec{\\\\textbf{v}}\", YELLOW)\n",
        "        scaled_v_label.target.scale(0.8)\n",
        "        scaled_v_label.target.next_to(point, RIGHT)\n",
        "        scaled_v_label.target.add_background_rectangle()\n",
        "\n",
        "        self.apply_transposed_matrix(\n",
        "            self.t_matrix, \n",
        "            added_anims = [MoveToTarget(scaled_v_label)]\n",
        "        )\n",
        "        self.wait()\n",
        "        scaled_v = v.copy().scale(2)\n",
        "        rhs = OldTex(\"=\", \"c\", \"L(\", \"\\\\vec{\\\\textbf{v}}\", \")\")\n",
        "        rhs.set_color_by_tex(\"c\", GREEN)\n",
        "        rhs.set_color_by_tex(\"\\\\vec{\\\\textbf{v}}\", YELLOW)\n",
        "        rhs.add_background_rectangle()\n",
        "        rhs.scale(0.8)\n",
        "        rhs.next_to(scaled_v_label, RIGHT)\n",
        "        v_copy = v.copy()\n",
        "        self.add(v_copy)\n",
        "        self.play(Transform(v, scaled_v))\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "        faders = [\n",
        "            scaled_v_label, scaled_v, v_copy, \n",
        "            v, rhs\n",
        "        ] + self.transformable_labels + self.moving_vectors\n",
        "        self.play(*list(map(FadeOut, faders)))\n",
        "\n",
        "    def add_words(self):\n",
        "        randy = Randolph().shift(LEFT).to_edge(DOWN)\n",
        "        bubble = randy.get_bubble(SpeechBubble, width = 6, height = 4)\n",
        "        bubble.set_fill(BLACK, opacity = 0.8)\n",
        "        bubble.shift(0.5*DOWN)\n",
        "        VGroup(randy, bubble).to_edge(RIGHT, buff = 0)\n",
        "        words = OldTexText(\n",
        "            \"Linear transformations\\\\\\\\\",\n",
        "            \"preserve\",\n",
        "            \"addition and \\\\\\\\ scalar multiplication\",\n",
        "        )\n",
        "        words.scale(0.9)\n",
        "        words.set_color_by_tex(\"preserve\", YELLOW)\n",
        "        bubble.add_content(words)\n",
        "\n",
        "        self.play(FadeIn(randy))\n",
        "        self.play(\n",
        "            ShowCreation(bubble),            \n",
        "            Write(words),\n",
        "            randy.change_mode, \"speaking\",\n",
        "        )\n",
        "        self.play(Blink(randy))\n",
        "        self.wait()\n",
        "\n",
        "class CalcStudentsKnowThatDerivIsLinear(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"\"\"Calc students subconsciously\n",
        "            know that\"\"\",\n",
        "            \"$\\\\dfrac{d}{dx}$\",\n",
        "            \"is linear\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"$\\\\dfrac{d}{dx}$\", BLUE)\n",
        "        self.teacher_says(words)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"confused\", \"erm\"\n",
        "        )\n",
        "        self.random_blink(3)\n",
        "\n",
        "class DerivativeIsLinear(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.prepare_text()\n",
        "        self.show_additivity()\n",
        "        self.show_scaling()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Derivative is linear\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "    def prepare_text(self):\n",
        "        v_tex, w_tex = [\"\\\\vec{\\\\textbf{%s}}\"%s for s in \"vw\"]\n",
        "        additivity = OldTex(\n",
        "            \"L(\", v_tex, \"+\", w_tex, \")\", \"=\",\n",
        "            \"L(\", v_tex, \")+L(\", w_tex, \")\"\n",
        "        )\n",
        "        scaling = OldTex(\n",
        "            \"L(\", \"c\", v_tex, \")=\", \"c\", \"L(\", v_tex, \")\"\n",
        "        )\n",
        "        for text in additivity, scaling:\n",
        "            text.set_color_by_tex(v_tex, YELLOW)\n",
        "            text.set_color_by_tex(w_tex, MAROON_B)\n",
        "            text.set_color_by_tex(\"c\", GREEN)\n",
        "\n",
        "        deriv_tex = \"\\\\dfrac{d}{dx}\"\n",
        "        deriv_additivity = OldTex(\n",
        "            deriv_tex, \"(\", \"x^3\", \"+\", \"x^2\", \")\", \"=\",\n",
        "            deriv_tex, \"(\", \"x^3\", \")\", \"+\", \n",
        "            deriv_tex, \"(\", \"x^2\", \")\"\n",
        "        )\n",
        "        deriv_scaling = OldTex(\n",
        "            deriv_tex, \"(\", \"4\", \"x^3\", \")\", \"=\",\n",
        "            \"4\", deriv_tex, \"(\", \"x^3\", \")\"\n",
        "        )\n",
        "        for text in deriv_additivity, deriv_scaling:\n",
        "            text.set_color_by_tex(\"x^3\", YELLOW)\n",
        "            text.set_color_by_tex(\"x^2\", MAROON_B)\n",
        "            text.set_color_by_tex(\"4\", GREEN)\n",
        "\n",
        "        self.additivity = additivity\n",
        "        self.scaling = scaling\n",
        "        self.deriv_additivity = deriv_additivity\n",
        "        self.deriv_scaling = deriv_scaling\n",
        "\n",
        "    def show_additivity(self):\n",
        "        general, deriv = self.additivity, self.deriv_additivity\n",
        "        group = VGroup(general, deriv )\n",
        "        group.arrange(DOWN, buff = 1.5)\n",
        "\n",
        "        inner_sum = VGroup(*deriv[2:2+3])\n",
        "        outer_sum_deriv = VGroup(deriv[0], deriv[1], deriv[5])\n",
        "        inner_func1 = deriv[9]\n",
        "        outer_deriv1 = VGroup(deriv[7], deriv[8], deriv[10])\n",
        "        plus = deriv[11]\n",
        "        inner_func2 = deriv[14]\n",
        "        outer_deriv2 = VGroup(deriv[12], deriv[13], deriv[15])\n",
        "\n",
        "        self.play(FadeIn(group))\n",
        "        self.wait()\n",
        "        self.point_out(inner_sum)\n",
        "        self.point_out(outer_sum_deriv)\n",
        "        self.wait()\n",
        "        self.point_out(outer_deriv1, outer_deriv2)        \n",
        "        self.point_out(inner_func1, inner_func2)\n",
        "        self.point_out(plus)\n",
        "        self.wait()\n",
        "        self.play(FadeOut(group))\n",
        "\n",
        "    def show_scaling(self):\n",
        "        general, deriv = self.scaling, self.deriv_scaling\n",
        "        group = VGroup(general, deriv)\n",
        "        group.arrange(DOWN, buff = 1.5)\n",
        "\n",
        "        inner_scaling = VGroup(*deriv[2:4])\n",
        "        lhs_deriv = VGroup(deriv[0], deriv[1], deriv[4])\n",
        "        rhs_deriv = VGroup(*deriv[7:])\n",
        "        outer_scaling = deriv[6]\n",
        "\n",
        "        self.play(FadeIn(group))\n",
        "        self.wait()\n",
        "        self.point_out(inner_scaling)\n",
        "        self.point_out(lhs_deriv)\n",
        "        self.wait()\n",
        "        self.point_out(rhs_deriv)\n",
        "        self.point_out(outer_scaling)\n",
        "        self.wait()\n",
        "\n",
        "    def point_out(self, *terms):\n",
        "        anims = []\n",
        "        for term in terms:\n",
        "            anims += [\n",
        "                term.scale, 1.2,\n",
        "                term.set_color, RED,\n",
        "            ]\n",
        "        self.play(\n",
        "            *anims,\n",
        "            run_time = 1,\n",
        "            rate_func = there_and_back\n",
        "        )\n",
        "\n",
        "class ProposeDerivativeAsMatrix(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            Let's describe the\n",
        "            derivative with \n",
        "            a matrix\n",
        "            \"\"\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.play_student_changes(\"pondering\", \"confused\", \"erm\")\n",
        "        self.random_blink(3)\n",
        "\n",
        "class PolynomialsHaveArbitrarilyLargeDegree(Scene):\n",
        "    def construct(self):\n",
        "        polys = VGroup(*list(map(Tex, [\n",
        "            \"x^{300} + 9x^2\",\n",
        "            \"4x^{4{,}000{,}000{,}000} + 1\",\n",
        "            \"3x^{\\\\left(10^{100}\\\\right)}\",\n",
        "            \"\\\\vdots\"\n",
        "        ])))\n",
        "        polys.set_color_by_gradient(BLUE_B, BLUE_D)\n",
        "        polys.arrange(DOWN, buff = MED_LARGE_BUFF)\n",
        "        polys.scale(1.3)\n",
        "\n",
        "        arrow = OldTex(\"\\\\Rightarrow\").scale(1.5)\n",
        "\n",
        "        brace = Brace(\n",
        "            Line(UP, DOWN).scale(FRAME_Y_RADIUS).shift(FRAME_X_RADIUS*RIGHT),\n",
        "            LEFT\n",
        "        )\n",
        "        words = OldTexText(\"Infinitely many\")\n",
        "        words.scale(1.5)\n",
        "        words.next_to(brace, LEFT)\n",
        "        arrow.next_to(words, LEFT)\n",
        "        polys.next_to(arrow, LEFT)\n",
        "\n",
        "        self.play(Write(polys))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(arrow),\n",
        "            Write(words),\n",
        "            GrowFromCenter(brace)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class GeneneralPolynomialCoordinates(Scene):\n",
        "    def construct(self):\n",
        "        poly = OldTex(\n",
        "            \"a_n\", \"x^n\", \"+\",\n",
        "            \"a_{n-1}\", \"x^{n-1}\", \"+\",\n",
        "            \"\\\\cdots\",\n",
        "            \"a_1\", \"x\", \"+\",             \n",
        "            \"a_0\", \n",
        "        )\n",
        "        poly.set_color_by_tex(\"a_n\", YELLOW)\n",
        "        poly.set_color_by_tex(\"a_{n-1}\", MAROON_B)\n",
        "        poly.set_color_by_tex(\"a_1\", RED)\n",
        "        poly.set_color_by_tex(\"a_0\", GREEN)\n",
        "        poly.scale(1.3)\n",
        "\n",
        "        array = Matrix(\n",
        "            [\"a_0\", \"a_1\", \"\\\\vdots\", \"a_{n-1}\", \"a_n\", \"0\", \"\\\\vdots\"]\n",
        "        )\n",
        "        array.get_entries()[0].set_color(GREEN)\n",
        "        array.get_entries()[1].set_color(RED)\n",
        "        array.get_entries()[3].set_color(MAROON_B)\n",
        "        array.get_entries()[4].set_color(YELLOW)\n",
        "        array.scale(1.2)\n",
        "\n",
        "        equals = OldTex(\"=\").scale(1.3)\n",
        "        group = VGroup(poly, equals, array)\n",
        "        group.arrange()\n",
        "        group.to_edge(RIGHT)\n",
        "\n",
        "        pre_entries = VGroup(\n",
        "            poly[-1], poly[-4], poly[-5], \n",
        "            poly[3], poly[0], \n",
        "            VectorizedPoint(poly.get_left()),\n",
        "            VectorizedPoint(poly.get_left()),\n",
        "        )\n",
        "\n",
        "        self.add(poly, equals, array.get_brackets())\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(pre_entries.copy(), array.get_entries())\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class SimplePolynomialCoordinates(Scene):\n",
        "    def construct(self):\n",
        "        matrix = Matrix([\"5\", \"3\", \"1\", \"0\", \"\\\\vdots\"])\n",
        "        matrix.to_edge(LEFT)\n",
        "        self.play(Write(matrix))\n",
        "        self.wait()\n",
        "\n",
        "class IntroducePolynomialSpace(Scene):\n",
        "    def construct(self):\n",
        "        self.add_title()\n",
        "        self.show_polynomial_cloud()\n",
        "        self.split_individual_polynomial()\n",
        "        self.list_basis_functions()\n",
        "        self.show_example_coordinates()\n",
        "        self.derivative_as_matrix()\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Our current space: \", \"All polynomials\")\n",
        "        title.to_edge(UP)\n",
        "        title[1].set_color(BLUE)\n",
        "        self.play(Write(title))\n",
        "        self.wait()\n",
        "        self.title = title\n",
        "\n",
        "    def show_polynomial_cloud(self):\n",
        "        cloud = ThoughtBubble()[-1]\n",
        "        cloud.stretch_to_fit_height(6)\n",
        "        cloud.center()\n",
        "        \n",
        "\n",
        "        polys = VGroup(\n",
        "            OldTex(\"x^2\", \"+\", \"3\", \"x\", \"+\", \"5\"),\n",
        "            OldTex(\"4x^7-5x^2\"),\n",
        "            OldTex(\"x^{100}+2x^{99}+3x^{98}\"),\n",
        "            OldTex(\"3x-7\"),\n",
        "            OldTex(\"x^{1{,}000{,}000{,}000}+1\"),\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "        )\n",
        "        polys.set_color_by_gradient(BLUE_B, BLUE_D)\n",
        "        polys.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        polys.next_to(cloud.get_top(), DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(cloud))\n",
        "        for poly in polys:\n",
        "            self.play(Write(poly), run_time = 1)\n",
        "        self.wait()\n",
        "        self.poly1, self.poly2 = polys[0], polys[1]\n",
        "        polys.remove(self.poly1)\n",
        "        self.play(\n",
        "            FadeOut(cloud),\n",
        "            FadeOut(polys),\n",
        "            self.poly1.next_to, ORIGIN, LEFT,\n",
        "            self.poly1.set_color, WHITE\n",
        "        )\n",
        "\n",
        "    def split_individual_polynomial(self):\n",
        "        leading_coef = OldTex(\"1\")\n",
        "        leading_coef.next_to(self.poly1[0], LEFT, aligned_edge = DOWN)\n",
        "        self.poly1.add_to_back(leading_coef)\n",
        "        one = OldTex(\"\\\\cdot\", \"1\")\n",
        "        one.next_to(self.poly1[-1], RIGHT, aligned_edge = DOWN)\n",
        "        self.poly1.add(one)\n",
        "        for mob in leading_coef, one:\n",
        "            mob.set_color(BLACK)\n",
        "\n",
        "        brace = Brace(self.poly1)\n",
        "        brace.text = brace.get_text(\"Already written as \\\\\\\\ a linear combination\")\n",
        "\n",
        "        index_to_color = {\n",
        "            0 : WHITE,\n",
        "            1 : Z_COLOR,\n",
        "            4 : Y_COLOR,\n",
        "            7 : X_COLOR,\n",
        "        }\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace.text),\n",
        "            *[\n",
        "                ApplyMethod(self.poly1[index].set_color, color)\n",
        "                for index, color in list(index_to_color.items())\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "        self.brace = brace\n",
        "\n",
        "    def list_basis_functions(self):\n",
        "        title = OldTexText(\"Basis functions\")\n",
        "        title.next_to(self.title, DOWN, buff = MED_SMALL_BUFF)\n",
        "        title.to_edge(RIGHT)\n",
        "        h_line = Line(ORIGIN, RIGHT).scale(title.get_width())\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        x_cubed = OldTex(\"x^3\")\n",
        "        x_cubed.set_color(MAROON_B)\n",
        "        x_cubed.to_corner(DOWN+RIGHT).shift(2*(DOWN+RIGHT))\n",
        "        basis_group = VGroup(\n",
        "            self.poly1[7][1],\n",
        "            self.poly1[4],\n",
        "            self.poly1[1],\n",
        "            x_cubed\n",
        "        ).copy()\n",
        "        basis_group.generate_target()\n",
        "        basis_group.target.arrange(\n",
        "            DOWN, buff = 0.75*LARGE_BUFF, aligned_edge = LEFT\n",
        "        )\n",
        "        basis_group.target.to_edge(RIGHT, buff = MED_LARGE_BUFF)\n",
        "        dots = OldTex(\"\\\\vdots\")\n",
        "        dots.next_to(basis_group.target, DOWN, buff = MED_SMALL_BUFF, aligned_edge = LEFT)\n",
        "\n",
        "        basis_functions = [\n",
        "            OldTex(\"b_%d(x)\"%i, \"=\")\n",
        "            for i in range(len(list(basis_group)))\n",
        "        ]\n",
        "        for basis_func, term in zip(basis_functions, basis_group.target):\n",
        "            basis_func.set_color(term.get_color())\n",
        "            basis_func.next_to(term, LEFT)\n",
        "        for i in 2, 3:\n",
        "            basis_functions[i].shift(SMALL_BUFF*DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(title),\n",
        "            ShowCreation(h_line),\n",
        "            MoveToTarget(basis_group),\n",
        "            Write(dots)\n",
        "        )\n",
        "        for basis_func in basis_functions:\n",
        "            self.play(Write(basis_func, run_time = 1))\n",
        "        self.play(Write(dots))\n",
        "        self.wait()\n",
        "        self.basis = basis_group\n",
        "        self.basis_functions = basis_functions\n",
        "\n",
        "    def show_example_coordinates(self):\n",
        "        coords = Matrix([\"5\", \"3\", \"1\", \"0\", \"0\", \"\\\\vdots\"])\n",
        "        for i, color in enumerate([X_COLOR, Y_COLOR, Z_COLOR]):\n",
        "            coords[i].set_color(color)\n",
        "        self.poly1.generate_target()\n",
        "        equals = OldTex(\"=\").next_to(coords, LEFT)\n",
        "        self.poly1.target.next_to(equals, LEFT)\n",
        "        entries = coords.get_entries()\n",
        "        entries.save_state()\n",
        "        entries.set_fill(opacity = 0)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(self.poly1),\n",
        "            Write(equals),\n",
        "            FadeOut(self.brace),\n",
        "            FadeOut(self.brace.text)\n",
        "        )\n",
        "        for entry, index in zip(entries, [6, 3, 0]):\n",
        "            entry.move_to(self.poly1[index])\n",
        "        self.play(Write(coords.get_brackets()))\n",
        "        self.play(\n",
        "            entries.restore,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        )\n",
        "        self.wait()\n",
        "        target = self.poly1.copy()\n",
        "        terms = [\n",
        "            VGroup(*target[6:8]),\n",
        "            VGroup(target[5], *target[3:5]),\n",
        "            VGroup(target[2], *target[0:2]),\n",
        "        ]\n",
        "        target[5].next_to(target[3], LEFT)\n",
        "        target[2].next_to(target[0], LEFT)\n",
        "        more_terms = [\n",
        "            OldTex(\"+0\", \"x^3\").set_color_by_tex(\"x^3\", MAROON_B),\n",
        "            OldTex(\"+0\", \"x^4\").set_color_by_tex(\"x^4\", YELLOW),\n",
        "            OldTex(\"\\\\vdots\")\n",
        "        ]        \n",
        "        for entry, term in zip(entries, terms+more_terms):\n",
        "            term.next_to(entry, LEFT, buff = LARGE_BUFF)\n",
        "        more_terms[-1].shift(MED_SMALL_BUFF*LEFT)\n",
        "\n",
        "        self.play(Transform(self.poly1, target))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(\n",
        "            VGroup(*more_terms), \n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(*list(map(FadeOut, [self.poly1]+more_terms)))\n",
        "        self.poly2.next_to(equals, LEFT)\n",
        "        self.poly2.shift(MED_SMALL_BUFF*UP)\n",
        "        self.poly2.set_color(WHITE)\n",
        "        self.poly2[0].set_color(TEAL)\n",
        "        VGroup(*self.poly2[3:5]).set_color(Z_COLOR)\n",
        "        new_coords = Matrix([\"0\", \"0\", \"-5\", \"0\", \"0\", \"0\", \"0\", \"4\", \"\\\\vdots\"])\n",
        "        new_coords.get_entries()[2].set_color(Z_COLOR)\n",
        "        new_coords.get_entries()[7].set_color(TEAL)\n",
        "        new_coords.set_height(6)\n",
        "        new_coords.move_to(coords, aligned_edge = LEFT)\n",
        "        self.play(\n",
        "            Write(self.poly2),\n",
        "            Transform(coords, new_coords)\n",
        "        )\n",
        "        self.wait()\n",
        "        for i, mob in (2, VGroup(*self.poly2[3:5])), (7, self.poly2[0]):\n",
        "            self.play(\n",
        "                new_coords.get_entries()[i].scale, 1.3,\n",
        "                mob.scale, 1.3,\n",
        "                rate_func = there_and_back\n",
        "            )\n",
        "            self.remove(*self.get_mobjects_from_last_animation())\n",
        "            self.add(self.poly2)\n",
        "            self.wait()\n",
        "        self.play(*list(map(FadeOut, [self.poly2, coords, equals])))\n",
        "\n",
        "    def derivative_as_matrix(self):\n",
        "        matrix = Matrix([\n",
        "            [\n",
        "                str(j) if j == i+1 else \"0\" \n",
        "                for j in range(4)\n",
        "            ] + [\"\\\\cdots\"]\n",
        "            for i in range(4)\n",
        "        ] + [\n",
        "            [\"\\\\vdots\"]*4 + [\"\\\\ddots\"]\n",
        "        ])\n",
        "        matrix.shift(2*LEFT)\n",
        "        diag_entries = VGroup(*[\n",
        "            matrix.get_mob_matrix()[i, i+1]\n",
        "            for i in range(3)\n",
        "        ])\n",
        "        ##Horrible\n",
        "        last_col = VGroup(*matrix.get_mob_matrix()[:,-1])\n",
        "        last_col_top = last_col.get_top()\n",
        "        last_col.arrange(DOWN, buff = 0.83)\n",
        "        last_col.move_to(last_col_top, aligned_edge = UP+RIGHT)\n",
        "        ##End horrible\n",
        "        matrix.set_column_colors(X_COLOR, Y_COLOR, Z_COLOR, MAROON_B)\n",
        "\n",
        "        deriv = OldTex(\"\\\\dfrac{d}{dx}\")\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.next_to(matrix, LEFT)\n",
        "        deriv.next_to(equals, LEFT)\n",
        "\n",
        "        self.play(FadeIn(deriv), FadeIn(equals))\n",
        "        self.play(Write(matrix))\n",
        "        self.wait()\n",
        "        diag_entries.save_state()\n",
        "        diag_entries.generate_target()\n",
        "        diag_entries.target.scale(1.2)\n",
        "        diag_entries.target.set_color(YELLOW)\n",
        "        for anim in MoveToTarget(diag_entries), diag_entries.restore:\n",
        "            self.play(\n",
        "                anim,\n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 1.5,\n",
        "            )\n",
        "        self.wait()\n",
        "        matrix.generate_target()\n",
        "        matrix.target.to_corner(DOWN+LEFT).shift(0.25*UP)\n",
        "        deriv.generate_target()\n",
        "        deriv.target.next_to(\n",
        "            matrix.target, UP, \n",
        "            buff = MED_SMALL_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        deriv.target.shift(0.25*RIGHT)\n",
        "        self.play(\n",
        "            FadeOut(equals),\n",
        "            *list(map(MoveToTarget, [matrix, deriv]))\n",
        "        )\n",
        "\n",
        "        poly = OldTex(\n",
        "            \"(\", \"1\", \"x^3\", \"+\",\n",
        "            \"5\", \"x^2\", \"+\",\n",
        "            \"4\", \"x\", \"+\",\n",
        "            \"5\", \")\"\n",
        "        )\n",
        "        coefs = VGroup(*np.array(poly)[[10, 7, 4, 1]])\n",
        "        VGroup(*poly[1:3]).set_color(MAROON_B)\n",
        "        VGroup(*poly[4:6]).set_color(Z_COLOR)\n",
        "        VGroup(*poly[7:9]).set_color(Y_COLOR)\n",
        "        VGroup(*poly[10:11]).set_color(X_COLOR)\n",
        "        poly.next_to(deriv)\n",
        "        self.play(FadeIn(poly))\n",
        "\n",
        "        array = Matrix(list(coefs.copy()) + [Tex(\"\\\\vdots\")])\n",
        "        array.next_to(matrix, RIGHT)\n",
        "        self.play(Write(array.get_brackets()))\n",
        "        to_remove = []\n",
        "        for coef, entry in zip(coefs, array.get_entries()):\n",
        "            self.play(Transform(coef.copy(), entry))\n",
        "            to_remove += self.get_mobjects_from_last_animation()\n",
        "        self.play(Write(array.get_entries()[-1]))\n",
        "        to_remove += self.get_mobjects_from_last_animation()        \n",
        "        self.remove(*to_remove)\n",
        "        self.add(array)\n",
        "\n",
        "        eq1, eq2 = OldTex(\"=\"), OldTex(\"=\")\n",
        "        eq1.next_to(poly)\n",
        "        eq2.next_to(array)\n",
        "        \n",
        "        poly_result = OldTex(\n",
        "            \"3\", \"x^2\", \"+\",\n",
        "            \"10\", \"x\", \"+\",\n",
        "            \"4\"\n",
        "        )\n",
        "        poly_result.next_to(eq1)\n",
        "        brace = Brace(poly_result, buff = 0)\n",
        "\n",
        "        self.play(*list(map(Write, [eq1, eq2, brace])))\n",
        "\n",
        "        result_coefs = VGroup(*np.array(poly_result)[[6, 3, 0]])\n",
        "        VGroup(*poly_result[0:2]).set_color(MAROON_B)\n",
        "        VGroup(*poly_result[3:5]).set_color(Z_COLOR)\n",
        "        VGroup(*poly_result[6:]).set_color(Y_COLOR)\n",
        "        result_terms = [\n",
        "            VGroup(*poly_result[6:]),\n",
        "            VGroup(*poly_result[3:6]),\n",
        "            VGroup(*poly_result[0:3]),\n",
        "        ]\n",
        "        relevant_entries = VGroup(*array.get_entries()[1:4])\n",
        "        dots = [Tex(\"\\\\cdot\") for x in range(3)]\n",
        "        result_entries = []\n",
        "        for entry, diag_entry, dot in zip(relevant_entries, diag_entries, dots):\n",
        "            entry.generate_target()\n",
        "            diag_entry.generate_target()\n",
        "            group = VGroup(diag_entry.target, dot, entry.target)\n",
        "            group.arrange()\n",
        "            result_entries.append(group)\n",
        "        result_array = Matrix(\n",
        "            result_entries + [\n",
        "                OldTex(\"0\"),\n",
        "                OldTex(\"\\\\vdots\")\n",
        "            ]\n",
        "        )\n",
        "        result_array.next_to(eq2)\n",
        "\n",
        "        rects = [\n",
        "            Rectangle(\n",
        "                color = YELLOW\n",
        "            ).replace(\n",
        "                VGroup(*matrix.get_mob_matrix()[i,:]),\n",
        "                stretch = True\n",
        "            ).stretch_in_place(1.1, 0).stretch_in_place(1.3, 1)\n",
        "            for i in range(3)\n",
        "        ]\n",
        "        vert_rect = Rectangle(color = YELLOW)\n",
        "        vert_rect.replace(array.get_entries(), stretch = True)\n",
        "        vert_rect.stretch_in_place(1.1, 1)\n",
        "        vert_rect.stretch_in_place(1.5, 0)\n",
        "        tuples = list(zip(\n",
        "            relevant_entries,\n",
        "            diag_entries,\n",
        "            result_entries,\n",
        "            rects,\n",
        "            result_terms,\n",
        "            coefs[1:]\n",
        "        ))\n",
        "        self.play(Write(result_array.get_brackets()))\n",
        "        for entry, diag_entry, result_entry, rect, result_term, coef in tuples:\n",
        "            self.play(FadeIn(rect), FadeIn(vert_rect))\n",
        "            self.wait()\n",
        "            self.play(\n",
        "                entry.scale, 1.2,\n",
        "                diag_entry.scale, 1.2,\n",
        "            )\n",
        "            diag_entry_target, dot, entry_target = result_entry\n",
        "            self.play(\n",
        "                Transform(entry.copy(), entry_target),\n",
        "                Transform(diag_entry.copy(), diag_entry_target),\n",
        "                entry.scale, 1/1.2,\n",
        "                diag_entry.scale, 1/1.2,\n",
        "                Write(dot)\n",
        "            )\n",
        "            self.wait()\n",
        "            self.play(Transform(coef.copy(), VGroup(result_term)))\n",
        "            self.wait()\n",
        "            self.play(FadeOut(rect), FadeOut(vert_rect))\n",
        "        self.play(*list(map(Write, result_array.get_entries()[3:])))\n",
        "        self.wait()\n",
        "\n",
        "class MatrixVectorMultiplicationAndDerivative(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        mv_mult = VGroup(\n",
        "            Matrix([[3, 1], [0, 2]]).set_column_colors(X_COLOR, Y_COLOR),\n",
        "            Matrix([\"x\", \"y\"]).set_column_colors(YELLOW)\n",
        "        )\n",
        "        mv_mult.arrange()\n",
        "        mv_mult.scale(0.75)\n",
        "        arrow = OldTex(\"\\\\Leftrightarrow\")\n",
        "        deriv = OldTex(\"\\\\dfrac{df}{dx}\")\n",
        "        group = VGroup(mv_mult, arrow, deriv)\n",
        "        group.arrange(buff = MED_SMALL_BUFF)\n",
        "        arrow.set_color(BLACK)\n",
        "\n",
        "        teacher = self.get_teacher()\n",
        "        bubble = teacher.get_bubble(SpeechBubble, height = 4)\n",
        "        bubble.add_content(group)\n",
        "\n",
        "        self.play(\n",
        "            teacher.change_mode, \"speaking\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(group)\n",
        "        )\n",
        "        self.random_blink()\n",
        "        group.generate_target()        \n",
        "        group.target.scale(0.8)\n",
        "        words = OldTexText(\"Linear transformations\")\n",
        "        h_line = Line(ORIGIN, RIGHT).scale(words.get_width())\n",
        "        h_line.next_to(words, DOWN)\n",
        "        group.target.next_to(h_line, DOWN, buff = MED_SMALL_BUFF)\n",
        "        group.target[1].set_color(WHITE)\n",
        "        new_group = VGroup(words, h_line, group.target)\n",
        "        bubble.add_content(new_group)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(group),\n",
        "            ShowCreation(h_line),\n",
        "            Write(words),\n",
        "            self.get_teacher().change_mode, \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "class CompareTermsInLinearAlgebraToFunction(Scene):\n",
        "    def construct(self):\n",
        "        l_title = OldTexText(\"Linear algebra \\\\\\\\ concepts\")\n",
        "        r_title = OldTexText(\"Alternate names when \\\\\\\\ applied to functions\")\n",
        "        for title, vect in (l_title, LEFT), (r_title, RIGHT):\n",
        "            title.to_edge(UP)\n",
        "            title.shift(vect*FRAME_X_RADIUS/2)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.shift(\n",
        "            VGroup(l_title, r_title).get_bottom()[1]*UP + SMALL_BUFF*DOWN\n",
        "        )\n",
        "        v_line = Line(UP, DOWN).scale(FRAME_Y_RADIUS)\n",
        "        VGroup(h_line, v_line).set_color(BLUE)\n",
        "\n",
        "        self.add(l_title, r_title)\n",
        "        self.play(*list(map(ShowCreation, [h_line, v_line])))\n",
        "        self.wait()\n",
        "\n",
        "        lin_alg_concepts = VGroup(*list(map(TexText, [\n",
        "            \"Linear transformations\",\n",
        "            \"Dot products\",\n",
        "            \"Eigenvectors\",\n",
        "        ])))\n",
        "        function_concepts = VGroup(*list(map(TexText, [\n",
        "            \"Linear operators\",\n",
        "            \"Inner products\",\n",
        "            \"Eigenfunctions\",\n",
        "        ])))\n",
        "        for concepts, vect in (lin_alg_concepts, LEFT), (function_concepts, RIGHT):\n",
        "            concepts.arrange(DOWN, buff = MED_LARGE_BUFF, aligned_edge = LEFT)\n",
        "            concepts.next_to(h_line, DOWN, buff = LARGE_BUFF)\n",
        "            concepts.shift(vect*FRAME_X_RADIUS/2)\n",
        "            concepts.set_color_by_gradient(YELLOW_B, YELLOW_C)\n",
        "\n",
        "            for concept in concepts:\n",
        "                self.play(Write(concept, run_time = 1))\n",
        "            self.wait()\n",
        "\n",
        "class BackToTheQuestion(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            Wait...so how does\n",
        "            this relate to what vectors \n",
        "            really are?\n",
        "            \"\"\",\n",
        "            target_mode = \"confused\"\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            There are many different\n",
        "            vector-ish things\n",
        "            \"\"\"\n",
        "        )\n",
        "        self.random_blink(2)\n",
        "\n",
        "class YouAsAMathematician(Scene):\n",
        "    def construct(self):\n",
        "        mathy = Mathematician()\n",
        "        mathy.to_corner(DOWN+LEFT)\n",
        "        words = OldTexText(\"You as a mathematician\")\n",
        "        words.shift(2*UP)\n",
        "        arrow = Arrow(words.get_bottom(), mathy.get_corner(UP+RIGHT))\n",
        "        bubble = mathy.get_bubble()\n",
        "\n",
        "        equations = self.get_content()\n",
        "        bubble.add_content(equations)\n",
        "\n",
        "        self.add(mathy)\n",
        "        self.play(Write(words, run_time = 2))\n",
        "        self.play(\n",
        "            ShowCreation(arrow),\n",
        "            mathy.change_mode, \"wave_1\",\n",
        "            mathy.look, OUT\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(words),\n",
        "            FadeOut(arrow),\n",
        "            mathy.change_mode, \"pondering\",\n",
        "            ShowCreation(bubble),\n",
        "        )\n",
        "        self.play(Write(equations))\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "        bubble.write(\"Does this make any sense \\\\\\\\ for functions too?\")\n",
        "        self.play(\n",
        "            equations.next_to, mathy.eyes, RIGHT, 2*LARGE_BUFF,\n",
        "            mathy.change_mode, \"confused\",\n",
        "            mathy.look, RIGHT,\n",
        "            Write(bubble.content)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Blink(mathy))\n",
        "\n",
        "    def get_content(self):\n",
        "        v_tex = \"\\\\vec{\\\\textbf{v}}\"\n",
        "        eigen_equation = OldTex(\"A\", v_tex, \"=\", \"\\\\lambda\", v_tex)\n",
        "        v_ne_zero = OldTex(v_tex, \"\\\\ne \\\\vec{\\\\textbf{0}}\")\n",
        "        det_equation = OldTex(\"\\\\det(A-\", \"\\\\lambda\", \"I)=0\")\n",
        "        arrow = OldTex(\"\\\\Rightarrow\")\n",
        "\n",
        "        for tex in eigen_equation, v_ne_zero, det_equation:\n",
        "            tex.set_color_by_tex(v_tex, YELLOW)\n",
        "            tex.set_color_by_tex(\"\\\\lambda\", MAROON_B)\n",
        "\n",
        "        lhs = VGroup(eigen_equation, v_ne_zero)\n",
        "        lhs.arrange(DOWN)\n",
        "        group = VGroup(lhs, arrow, det_equation)\n",
        "        group.arrange(buff = MED_SMALL_BUFF)\n",
        "        return group\n",
        "\n",
        "class ShowVectorSpaces(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Vector spaces\")\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "\n",
        "        v_lines = [\n",
        "            Line(\n",
        "                h_line.get_center(), FRAME_Y_RADIUS*DOWN\n",
        "            ).shift(vect*FRAME_X_RADIUS/3.)\n",
        "            for vect in (LEFT, RIGHT)\n",
        "        ]\n",
        "        vectors = self.get_vectors()\n",
        "        vectors.shift(LEFT*FRAME_X_RADIUS*(2./3))\n",
        "        arrays = self.get_arrays()\n",
        "        functions = self.get_functions()\n",
        "        functions.shift(RIGHT*FRAME_X_RADIUS*(2./3))\n",
        "\n",
        "        self.add(h_line, *v_lines)\n",
        "        self.play(ShowCreation(\n",
        "            vectors,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.play(Write(arrays))\n",
        "        self.play(Write(functions))\n",
        "        self.wait()\n",
        "        self.play(Write(title))\n",
        "\n",
        "    def get_vectors(self, n_vectors = 10):\n",
        "        vectors = VGroup(*[\n",
        "            Vector(RIGHT).scale(scalar).rotate(angle)\n",
        "            for scalar, angle in zip(\n",
        "                2*np.random.random(n_vectors)+0.5,\n",
        "                np.linspace(0, 6, n_vectors)\n",
        "            )\n",
        "        ])\n",
        "        vectors.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "        return vectors\n",
        "\n",
        "    def get_arrays(self):\n",
        "        arrays = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Matrix(np.random.randint(-9, 9, 2))\n",
        "                for x in range(4)\n",
        "            ])\n",
        "            for x in range(3)\n",
        "        ])\n",
        "        for subgroup in arrays:\n",
        "            subgroup.arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "        arrays.arrange(RIGHT)\n",
        "        arrays.scale(0.7)\n",
        "        arrays.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "        return arrays\n",
        "\n",
        "    def get_functions(self):\n",
        "        axes = Axes()\n",
        "        axes.scale(0.3)\n",
        "        functions = VGroup(*[\n",
        "            FunctionGraph(func, x_min = -4, x_max = 4)\n",
        "            for func in [\n",
        "                lambda x : x**3 - 9*x,\n",
        "                lambda x : x**3 - 4*x,\n",
        "                lambda x : x**2 - 1,\n",
        "            ]\n",
        "        ])\n",
        "        functions.stretch_to_fit_width(FRAME_X_RADIUS/2.)\n",
        "        functions.stretch_to_fit_height(6)\n",
        "        functions.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "        functions.center()\n",
        "        return VGroup(axes, functions)\n",
        "\n",
        "class ToolsOfLinearAlgebra(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(*list(map(TexText, [\n",
        "            \"Linear transformations\",\n",
        "            \"Null space\",\n",
        "            \"Eigenvectors\",\n",
        "            \"Dot products\",\n",
        "            \"$\\\\vdots$\"\n",
        "        ])))\n",
        "        words.arrange(DOWN, aligned_edge = LEFT, buff = MED_SMALL_BUFF)\n",
        "        words[-1].next_to(words[-2], DOWN)\n",
        "        self.play(FadeIn(\n",
        "            words,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "class MathematicianSpeakingToAll(Scene):\n",
        "    def construct(self):\n",
        "        mathy = Mathematician().to_corner(DOWN+LEFT)\n",
        "        others = VGroup(*[\n",
        "            Randolph().flip().set_color(color)\n",
        "            for color in (BLUE_D, GREEN_E, GOLD_E, BLUE_C)\n",
        "        ])\n",
        "        others.arrange()\n",
        "        others.scale(0.8)\n",
        "        others.to_corner(DOWN+RIGHT)\n",
        "\n",
        "        bubble = mathy.get_bubble(SpeechBubble)\n",
        "        bubble.write(\"\"\"\n",
        "            I don't want to think\n",
        "            about all y'all's crazy\n",
        "            vector spaces\n",
        "        \"\"\")\n",
        "\n",
        "        self.add(mathy, others)\n",
        "        self.play(\n",
        "            ShowCreation(bubble),\n",
        "            Write(bubble.content),\n",
        "            mathy.change_mode, \"sassy\",\n",
        "            mathy.look_at, others\n",
        "        )\n",
        "        self.play(Blink(others[3]))\n",
        "        self.wait()\n",
        "        thought_bubble = mathy.get_bubble(ThoughtBubble)\n",
        "        self.play(\n",
        "            FadeOut(bubble.content),\n",
        "            Transform(bubble, thought_bubble),\n",
        "            mathy.change_mode, \"speaking\",\n",
        "            mathy.look_at, bubble,\n",
        "            *[ApplyMethod(pi.look_at, bubble) for pi in others]\n",
        "        )\n",
        "\n",
        "        vect = -bubble.get_bubble_center()\n",
        "        def func(point):\n",
        "            centered = point+vect\n",
        "            return 10*centered/get_norm(centered)\n",
        "        self.play(*[\n",
        "            ApplyPointwiseFunction(func, mob)\n",
        "            for mob in self.get_mobjects()\n",
        "        ])\n",
        "\n",
        "class ListAxioms(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Rules for vectors addition and scaling\")\n",
        "        title.to_edge(UP)\n",
        "        h_line = Line(LEFT, RIGHT).scale(FRAME_X_RADIUS)\n",
        "        h_line.next_to(title, DOWN)\n",
        "        self.add(title, h_line)\n",
        "\n",
        "        u_tex, v_tex, w_tex = [\"\\\\vec{\\\\textbf{%s}}\"%s for s in \"uvw\"]\n",
        "        axioms = VGroup(*it.starmap(Tex, [\n",
        "            (\n",
        "                \"1. \\\\,\", \n",
        "                u_tex, \"+\", \"(\", v_tex, \"+\", w_tex, \")=(\", \n",
        "                u_tex, \"+\", v_tex, \")+\", w_tex\n",
        "            ),\n",
        "            (   \"2. \\\\,\", \n",
        "                v_tex, \"+\", w_tex, \"=\", w_tex, \"+\", v_tex\n",
        "            ),\n",
        "            (\n",
        "                \"3. \\\\,\", \n",
        "                \"\\\\text{There is a vector }\", \"\\\\textbf{0}\",\n",
        "                \"\\\\text{ such that }\", \"\\\\textbf{0}+\", v_tex,\n",
        "                \"=\", v_tex, \"\\\\text{ for all }\", v_tex\n",
        "            ),\n",
        "            (\n",
        "                \"4. \\\\,\", \n",
        "                \"\\\\text{For every vector }\", v_tex, \n",
        "                \"\\\\text{ there is a vector }\", \"-\", v_tex,\n",
        "                \"\\\\text{ so that }\", v_tex, \"+\", \"(-\", v_tex, \")=\\\\textbf{0}\"\n",
        "            ),\n",
        "            (   \"5. \\\\,\", \n",
        "                \"a\", \"(\", \"b\", v_tex, \")=(\", \"a\", \"b\", \")\", v_tex\n",
        "            ),\n",
        "            (  \n",
        "                \"6. \\\\,\", \n",
        "                \"1\", v_tex, \"=\", v_tex\n",
        "            ),\n",
        "            (\n",
        "                \"7. \\\\,\", \n",
        "                \"a\", \"(\", v_tex, \"+\", w_tex, \")\", \"=\", \n",
        "                \"a\", v_tex, \"+\", \"a\", w_tex\n",
        "            ),\n",
        "            (\n",
        "                \"8. \\\\,\", \n",
        "                \"(\", \"a\", \"+\", \"b\", \")\", v_tex, \"=\",\n",
        "                \"a\", v_tex, \"+\", \"b\", v_tex\n",
        "            ),\n",
        "        ]))\n",
        "        tex_color_pairs = [\n",
        "            (v_tex, YELLOW),\n",
        "            (w_tex, MAROON_B),\n",
        "            (u_tex, PINK),\n",
        "            (\"a\", BLUE),\n",
        "            (\"b\", GREEN)\n",
        "\n",
        "        ]\n",
        "        for axiom in axioms:\n",
        "            for tex, color in tex_color_pairs:\n",
        "                axiom.set_color_by_tex(tex, color)\n",
        "        axioms.arrange(\n",
        "            DOWN, buff = MED_LARGE_BUFF,\n",
        "            aligned_edge = LEFT\n",
        "        )\n",
        "        axioms.set_width(FRAME_WIDTH-1)\n",
        "        axioms.next_to(h_line, DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            axioms,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 5\n",
        "        ))\n",
        "        self.wait()\n",
        "        axioms_word = OldTexText(\"``Axioms''\")\n",
        "        axioms_word.set_color(YELLOW)\n",
        "        axioms_word.scale(2)\n",
        "        axioms_word.shift(FRAME_X_RADIUS*RIGHT/2, FRAME_Y_RADIUS*DOWN/2)\n",
        "        self.play(Write(axioms_word, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "class AxiomsAreInterface(Scene):\n",
        "    def construct(self):\n",
        "        mathy = Mathematician().to_edge(LEFT)\n",
        "        mathy.change_mode(\"pondering\")\n",
        "        others = [\n",
        "            Randolph().flip().set_color(color)\n",
        "            for color in (BLUE_D, GREEN_E, GOLD_E, BLUE_C)\n",
        "        ]\n",
        "        others = VGroup(\n",
        "            VGroup(*others[:2]),\n",
        "            VGroup(*others[2:]),\n",
        "        )\n",
        "        for group in others:\n",
        "            group.arrange(RIGHT)\n",
        "        others.arrange(DOWN)\n",
        "        others.scale(0.8)\n",
        "        others.to_edge(RIGHT)\n",
        "        VGroup(mathy, others).to_edge(DOWN)\n",
        "        double_arrow = DoubleArrow(mathy, others)\n",
        "\n",
        "        axioms, are, rules_of_nature = words = OldTexText(\n",
        "            \"Axioms\", \"are\", \"rules of nature\"\n",
        "        )\n",
        "        words.to_edge(UP)\n",
        "        axioms.set_color(YELLOW)\n",
        "        an_interface = OldTexText(\"an interface\")\n",
        "        an_interface.next_to(rules_of_nature, DOWN)\n",
        "        red_line = Line(\n",
        "            rules_of_nature.get_left(),\n",
        "            rules_of_nature.get_right(),\n",
        "            color = RED\n",
        "        )\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(red_line))\n",
        "        self.play(Transform(\n",
        "            rules_of_nature.copy(),\n",
        "            an_interface\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(mathy))\n",
        "        self.play(\n",
        "            ShowCreation(double_arrow),\n",
        "            FadeIn(others, lag_ratio = 0.5, run_time = 2)\n",
        "        )\n",
        "        self.play(axioms.copy().next_to, double_arrow, UP)\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "class VectorSpaceOfPiCreatures(Scene):\n",
        "    def construct(self):\n",
        "        creatures = self.add_creatures()\n",
        "        self.show_sum(creatures)\n",
        "\n",
        "    def add_creatures(self):\n",
        "        creatures = VGroup(*[\n",
        "            VGroup(*[\n",
        "                PiCreature()\n",
        "                for x in range(4)\n",
        "            ]).arrange(RIGHT, buff = 1.5)\n",
        "            for y in range(4)\n",
        "        ]).arrange(DOWN, buff = 1.5)\n",
        "        creatures = VGroup(*it.chain(*creatures))\n",
        "        creatures.set_height(FRAME_HEIGHT-1)\n",
        "        for pi in creatures:\n",
        "            pi.change_mode(random.choice([\n",
        "                \"pondering\", \"pondering\",\n",
        "                \"happy\", \"happy\", \"happy\",\n",
        "                \"confused\", \n",
        "                \"angry\", \"erm\", \"sassy\", \"hooray\", \n",
        "                \"speaking\", \"tired\", \n",
        "                \"plain\", \"plain\"\n",
        "            ]))\n",
        "            if random.random() < 0.5:\n",
        "                pi.flip()\n",
        "            pi.shift(0.5*(random.random()-0.5)*RIGHT)\n",
        "            pi.shift(0.5*(random.random()-0.5)*UP)\n",
        "            pi.set_color(random.choice([\n",
        "                BLUE_B, BLUE_C, BLUE_D, BLUE_E,\n",
        "                MAROON_B, MAROON_C, MAROON_D, MAROON_E,\n",
        "                GREY_BROWN, GREY_BROWN, GREY,\n",
        "                YELLOW_C, YELLOW_D, YELLOW_E\n",
        "            ]))\n",
        "            pi.scale(random.random()+0.5)\n",
        "\n",
        "        self.play(FadeIn(\n",
        "            creatures,\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 3\n",
        "        ))\n",
        "        self.wait()\n",
        "        return creatures\n",
        "\n",
        "    def show_sum(self, creatures):\n",
        "        def is_valid(pi1, pi2, pi3):\n",
        "            if len(set([pi.get_color() for pi in (pi1, pi2, pi3)])) < 3:\n",
        "                return False\n",
        "            if pi1.is_flipped()^pi2.is_flipped():\n",
        "                return False\n",
        "            return True\n",
        "        pi1, pi2, pi3 = pis = [random.choice(creatures) for x in range(3)]\n",
        "        while not is_valid(pi1, pi2, pi3):\n",
        "            pi1, pi2, pi3 = pis = [random.choice(creatures) for x in range(3)]\n",
        "        creatures.remove(*pis)\n",
        "\n",
        "        transform = Transform(pi1.copy(), pi2.copy())\n",
        "        transform.update(0.5)\n",
        "        sum_pi = transform.mobject\n",
        "        sum_pi.set_height(pi1.get_height()+pi2.get_height())\n",
        "        for pi in pis:\n",
        "            pi.generate_target()\n",
        "        plus, equals = OldTex(\"+=\")\n",
        "        sum_equation = VGroup(\n",
        "            pi1.target, plus, pi2.target,\n",
        "            equals, sum_pi\n",
        "        )\n",
        "        sum_equation.arrange().center()\n",
        "\n",
        "        scaled_pi3 = pi3.copy().scale(2)\n",
        "        equals2 = OldTex(\"=\")\n",
        "        two = OldTex(\"2 \\\\cdot\")\n",
        "        scale_equation = VGroup(\n",
        "            two, pi3.target, equals2, scaled_pi3\n",
        "        )\n",
        "        scale_equation.arrange()\n",
        "\n",
        "        VGroup(sum_equation, scale_equation).arrange(\n",
        "            DOWN, buff = MED_SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(FadeOut(creatures))\n",
        "        self.play(*it.chain(\n",
        "            list(map(MoveToTarget, [pi1, pi2, pi3])),\n",
        "            list(map(Write, [plus, equals, two, equals2])),\n",
        "        ))\n",
        "        self.play(\n",
        "            Transform(pi1.copy(), sum_pi),\n",
        "            Transform(pi2.copy(), sum_pi),\n",
        "            Transform(pi3.copy(), scaled_pi3)\n",
        "        )\n",
        "        self.remove(*self.get_mobjects_from_last_animation())\n",
        "        self.add(sum_pi, scaled_pi3)\n",
        "        for pi in pi1, sum_pi, scaled_pi3, pi3:\n",
        "            self.play(Blink(pi))\n",
        "\n",
        "class MathematicianDoesntHaveToThinkAboutThat(Scene):\n",
        "    def construct(self):\n",
        "        mathy = Mathematician().to_corner(DOWN+LEFT)\n",
        "        bubble = mathy.get_bubble(ThoughtBubble, height = 4)\n",
        "        words = OldTexText(\"I don't have to worry\", \"\\\\\\\\ about that madness!\")\n",
        "        bubble.add_content(words)\n",
        "        new_words = OldTexText(\"So long as I\", \"\\\\\\\\ work abstractly\")\n",
        "        bubble.add_content(new_words)\n",
        "\n",
        "        self.play(\n",
        "            mathy.change_mode, \"hooray\",\n",
        "            ShowCreation(bubble),\n",
        "            Write(words)\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mathy.change_mode, \"pondering\",\n",
        "            Transform(words, new_words)\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "class TextbooksAreAbstract(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"\"\"\n",
        "            All the textbooks I found\n",
        "            are pretty abstract.\n",
        "            \"\"\",\n",
        "            target_mode = \"pleading\"\n",
        "        )\n",
        "        self.random_blink(3)\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            For each new concept, \n",
        "            contemplate it for 2d space\n",
        "            with grid lines...\n",
        "            \"\"\"\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\")\n",
        "        self.random_blink(2)\n",
        "        self.teacher_says(\n",
        "            \"...then in some different\\\\\\\\\",\n",
        "            \"context, like a function space\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*2)\n",
        "        self.random_blink()\n",
        "        self.teacher_says(\n",
        "            \"Only then should you\\\\\\\\\",\n",
        "            \"think from the axioms\",\n",
        "            target_mode = \"surprised\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.random_blink()\n",
        "\n",
        "class LastAskWhatAreVectors(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"So...what are vectors?\",\n",
        "            target_mode = \"erm\"\n",
        "        )\n",
        "        self.random_blink()\n",
        "        self.teacher_says(\n",
        "            \"\"\"\n",
        "            The form they take\n",
        "            doesn't really matter\n",
        "            \"\"\"\n",
        "        )\n",
        "        self.random_blink()\n",
        "\n",
        "class WhatIsThree(Scene):\n",
        "    def construct(self):\n",
        "        what_is, three, q_mark = words = OldTexText(\n",
        "            \"What is \", \"3\", \"?\",\n",
        "            arg_separator = \"\"\n",
        "        )\n",
        "        words.scale(1.5)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(what_is),\n",
        "            FadeOut(q_mark),\n",
        "            three.center\n",
        "        )\n",
        "\n",
        "        triplets = [\n",
        "            VGroup(*[\n",
        "                PiCreature(color = color).scale(0.4)\n",
        "                for color in (BLUE_E, BLUE_C, BLUE_D)\n",
        "            ]),\n",
        "            VGroup(*[HyperCube().scale(0.3) for x in range(3)]),\n",
        "            VGroup(*[Vector(RIGHT) for x in range(3)]),\n",
        "            OldTex(\"\"\"\n",
        "                \\\\Big\\\\{\n",
        "                    \\\\emptyset, \n",
        "                    \\\\{\\\\emptyset\\\\}, \n",
        "                    \\\\{\\\\{\\\\emptyset\\\\}, \\\\emptyset\\\\}\n",
        "                \\\\Big\\\\}\n",
        "            \"\"\")\n",
        "        ]\n",
        "        directions = [UP+LEFT, UP+RIGHT, DOWN+LEFT, DOWN+RIGHT]\n",
        "        for group, vect in zip(triplets, directions):\n",
        "            if isinstance(group, Tex):\n",
        "                pass\n",
        "            elif isinstance(group[0], Vector):\n",
        "                group.arrange(RIGHT)\n",
        "                group.set_color_by_gradient(YELLOW, MAROON_B)\n",
        "            else:\n",
        "                m1, m2, m3 = group\n",
        "                m2.next_to(m1, buff = MED_SMALL_BUFF)\n",
        "                m3.next_to(VGroup(m1, m2), DOWN, buff = MED_SMALL_BUFF)\n",
        "            group.next_to(three, vect, buff = LARGE_BUFF)\n",
        "            self.play(FadeIn(group))\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            Transform(\n",
        "                trip, three, \n",
        "                lag_ratio = 0.5,\n",
        "                run_time = 2\n",
        "            )\n",
        "            for trip in triplets\n",
        "        ])\n",
        "\n",
        "class IStillRecommendConcrete(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"\"\"\n",
        "            I still recommend \n",
        "            thinking concretely\n",
        "        \"\"\")\n",
        "        self.random_blink(2)\n",
        "        self.student_thinks(\"\")\n",
        "        self.zoom_in_on_thought_bubble()\n",
        "\n",
        "class AbstractionIsThePrice(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Abstractness\", \"is the price\\\\\\\\\"\n",
        "            \"of\", \"generality\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Abstractness\", YELLOW)\n",
        "        words.set_color_by_tex(\"generality\", BLUE)\n",
        "        self.play(Write(words))\n",
        "        self.wait()\n",
        "\n",
        "class ThatsAWrap(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"That's all for now!\")\n",
        "        self.random_blink(2)\n",
        "\n",
        "class GoodLuck(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\n",
        "            \"Good luck with \\\\\\\\ your future learning!\",\n",
        "            target_mode = \"hooray\"\n",
        "        )\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.random_blink(3)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}