{
    "topic": "The mathematical concept being demonstrated is the size of a monster and its transformation.",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "\n",
        "MONSTER_SIZE = 808017424794512875886459904961710757005754368000000000\n",
        "BABY_MONSTER_SIZE = 4154781481226426191177580544000000\n",
        "\n",
        "\n",
        "def get_monster(height=3):\n",
        "    monster = SVGMobject(\"monster\")\n",
        "    monster.set_fill(GREY_BROWN)\n",
        "    monster.set_stroke(BLACK, 0.1)\n",
        "    monster.set_height(height)\n",
        "    return monster\n",
        "\n",
        "\n",
        "def get_baby_monster():\n",
        "    return get_monster().stretch(0.7, 1)\n",
        "\n",
        "\n",
        "def blink_monster(monster):\n",
        "    monster.generate_target()\n",
        "    left_eye_points = monster.target[0].get_points()[498:528]\n",
        "    right_eye_points = monster.target[0].get_points()[582:612]\n",
        "    for points in left_eye_points, right_eye_points:\n",
        "        points[:, 1] = points[0, 1]\n",
        "    return MoveToTarget(monster, rate_func=squish_rate_func(there_and_back, 0.4, 0.6))\n",
        "\n",
        "\n",
        "def get_size_bars(mob, stroke_width=3, buff=SMALL_BUFF):\n",
        "    bars = VGroup(*[Line(UP, DOWN) for x in range(2)])\n",
        "    bars.match_height(mob)\n",
        "    bars[0].next_to(mob, LEFT, buff=buff)\n",
        "    bars[1].next_to(mob, RIGHT, buff=buff)\n",
        "    bars.set_stroke(WHITE, stroke_width)\n",
        "    return bars\n",
        "\n",
        "\n",
        "def get_monster_size_label():\n",
        "    size_label = OldTexText(\"{:,}\".format(MONSTER_SIZE))[0]\n",
        "    size_parts = VGroup(*[\n",
        "        size_label[i:i + 12]\n",
        "        for i in range(0, len(size_label), 12)\n",
        "    ])\n",
        "    size_parts.arrange(DOWN, buff=SMALL_BUFF, aligned_edge=LEFT)\n",
        "    return size_label\n",
        "\n",
        "\n",
        "def get_snowflake(height=2):\n",
        "    snowflake = SVGMobject(\"snowflake\")\n",
        "    snowflake.set_fill(GREY_C, 1)\n",
        "    snowflake.set_gloss(1)\n",
        "    snowflake.set_shadow(0.2)\n",
        "    snowflake.set_stroke(WHITE, 1)\n",
        "    snowflake.set_height(height)\n",
        "    return snowflake\n",
        "\n",
        "\n",
        "def get_cube(color=BLUE_D, opacity=1, height=2, frame=None):\n",
        "    poor_cube = Cube()\n",
        "    cube = Cube(square_resolution=(10, 10))\n",
        "    cube.set_color(color, opacity)\n",
        "    cube.center()\n",
        "\n",
        "    for face, p_face in zip(cube, poor_cube):\n",
        "        face.add(*[\n",
        "            Line3D(p_face.get_points()[i], p_face.get_points()[j], width=0.02, color=GREY_B)\n",
        "            for i, j in [(0, 1), (1, 3), (3, 2), (2, 0)]\n",
        "        ])\n",
        "\n",
        "    cube.set_height(height)\n",
        "    return cube\n",
        "\n",
        "\n",
        "def get_glassy_cube(frame):\n",
        "    verts = np.array(list(it.product(*3 * [[-1, 1]])))\n",
        "    edges = [\n",
        "        (v1, v2)\n",
        "        for v1, v2 in it.combinations(verts, 2)\n",
        "        if sum(v1 == v2) == 2\n",
        "    ]\n",
        "    corner_dots = Group(*[\n",
        "        Sphere(resolution=(51, 26),).set_height(0.25).move_to(vert)\n",
        "        for vert in verts\n",
        "    ])\n",
        "    corner_dots.set_color(GREY_B)\n",
        "    edge_rods = Group(*[\n",
        "        Line3D(v1, v2)\n",
        "        for v1, v2 in edges\n",
        "    ])\n",
        "\n",
        "    faces = Cube(square_resolution=(10, 10))\n",
        "    faces.set_height(2)\n",
        "    faces.set_color(BLUE_E, 0.3)\n",
        "    faces.add_updater(lambda m, f=frame: m.sort(lambda p: np.dot(p, [np.sign(f.euler_angles[0]) * 0.2, -1, 0.2])))\n",
        "\n",
        "    cube = Group(corner_dots, edge_rods, faces)\n",
        "    cube.corner_dots = corner_dots\n",
        "    cube.edge_rods = edge_rods\n",
        "    cube.faces = faces\n",
        "    return cube\n",
        "\n",
        "\n",
        "def get_rot_icon(degrees, mobject, mini_mob_height=1.25):\n",
        "    mini_mob = mobject.copy()\n",
        "    temp_height = 1.75\n",
        "    mini_mob.set_height(temp_height)\n",
        "    mini_mob.set_stroke(width=0)\n",
        "    mini_mob.center()\n",
        "    angle = min(degrees * DEGREES, 170 * DEGREES)\n",
        "    arc1 = Arrow(\n",
        "        RIGHT, rotate_vector(RIGHT, angle),\n",
        "        path_arc=angle,\n",
        "        buff=0\n",
        "    )\n",
        "    arc2 = arc1.copy().rotate(PI, about_point=ORIGIN)\n",
        "    label = Integer(degrees, unit=\"^\\\\circ\")\n",
        "    label.set_height(0.25)\n",
        "    half_vect = rotate_vector(RIGHT, angle / 2)\n",
        "    label.next_to(half_vect, half_vect, buff=MED_SMALL_BUFF)\n",
        "    icon = VGroup(mini_mob, arc1, arc2, label)\n",
        "    icon.scale(mini_mob_height / temp_height)\n",
        "    return icon\n",
        "\n",
        "\n",
        "def get_flip_icon(angle, mobject, opacity=0.75, mini_mob_height=1.25):\n",
        "    mini_mob = mobject.copy()\n",
        "    mini_mob.set_stroke(width=0)\n",
        "    mini_mob.set_fill(opacity=opacity)\n",
        "    mini_mob.set_height(mini_mob_height)\n",
        "    mini_mob.center()\n",
        "    sym_line = DashedLine(LEFT, RIGHT)\n",
        "    sym_line.set_stroke(WHITE, 2)\n",
        "    sym_line.set_width(1.2 * mini_mob_height)\n",
        "    sym_line.rotate(angle)\n",
        "    sym_line.move_to(mini_mob)\n",
        "    back_line = sym_line.copy()\n",
        "    back_line.set_stroke(BLACK, 5)\n",
        "    return VGroup(mini_mob, back_line, sym_line)\n",
        "\n",
        "\n",
        "def get_permutation_arrows(mobs, permutation, arc=PI / 2):\n",
        "    arrows = VGroup()\n",
        "    for i in range(len(permutation)):\n",
        "        j = permutation[i]\n",
        "        u = -1 if mobs[i].get_x() < mobs[j].get_x() else 1\n",
        "        arrow = Arrow(\n",
        "            mobs[i].get_edge_center(u * UP),\n",
        "            mobs[j].get_edge_center(u * UP),\n",
        "            buff=SMALL_BUFF,\n",
        "            path_arc=arc,\n",
        "        )\n",
        "        arrow.insert_n_curves(10)\n",
        "        arrow.set_stroke(BLACK, 2, background=True)\n",
        "        arrow.set_fill(BLUE, 0.8)\n",
        "        arrows.add(arrow)\n",
        "    return arrows\n",
        "\n",
        "\n",
        "def permutation_animation(mobs, perm=None, arc=PI / 2, lag_factor=3, run_time=None):\n",
        "    if perm is None:\n",
        "        targets = list(mobs)\n",
        "        random.shuffle(targets)\n",
        "    else:\n",
        "        targets = [mobs[i] for i in perm]\n",
        "\n",
        "    kw = {\"lag_ratio\": lag_factor / len(mobs)}\n",
        "    if run_time is not None:\n",
        "        kw[\"run_time\"] = run_time\n",
        "    return LaggedStart(\n",
        "        *[\n",
        "            ApplyMethod(m1.move_to, m2, path_arc=arc)\n",
        "            for m1, m2 in zip(mobs, targets)\n",
        "        ],\n",
        "        **kw\n",
        "    )\n",
        "\n",
        "\n",
        "def get_named_image(name, height=3):\n",
        "    image = ImageMobject(name)\n",
        "    image.set_height(height)\n",
        "\n",
        "    name = OldTexText(name)\n",
        "    name.match_width(image)\n",
        "    name.next_to(image, DOWN)\n",
        "    group = Group(image, name)\n",
        "    return group\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        monster = get_monster()\n",
        "        monster.set_height(7)\n",
        "        monster.to_edge(LEFT)\n",
        "        monster.set_gloss(0.2)\n",
        "\n",
        "        words = VGroup(\n",
        "            OldTexText(\"The\"),\n",
        "            OldTexText(\"Monster\"),\n",
        "            OldTexText(\"Group\"),\n",
        "        )\n",
        "        words.scale(3.5)\n",
        "        words.arrange(DOWN, buff=0.5, aligned_edge=LEFT)\n",
        "        words.set_stroke(BLACK, 3, background=True)\n",
        "        words.to_edge(RIGHT)\n",
        "\n",
        "        self.add(monster)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class AltThumbnail(ThreeDScene):\n",
        "    def construct(self):\n",
        "        lines = VGroup(*(Line(DOWN, UP) for x in range(2)))\n",
        "        lines.set_height(FRAME_HEIGHT)\n",
        "        lines.arrange(RIGHT, buff=FRAME_WIDTH / 3)\n",
        "        lines.set_stroke(GREY_B, 3)\n",
        "        self.add(lines)\n",
        "\n",
        "        mob_width = FRAME_WIDTH / 3 - 1\n",
        "\n",
        "        titles = VGroup(Text(\"Symmetry\"), Text(\"Abstraction\"), Text(\"Monsters\"))\n",
        "        titles.set_width(mob_width + 0.5)\n",
        "        for title, x in zip(titles, [-1, 0, 1]):\n",
        "            title.set_x(x * FRAME_WIDTH / 3)\n",
        "            title.to_edge(UP)\n",
        "        self.add(titles)\n",
        "\n",
        "        cube = Cube()\n",
        "        cubes = Group(cube)\n",
        "        for axis in [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1]]:\n",
        "            for angle in [60 * DEGREES]:\n",
        "                cubes.add(cube.copy().rotate(angle, axis))\n",
        "\n",
        "        cubes.rotate(95 * DEGREES, RIGHT)\n",
        "        cubes.rotate(30 * DEGREES, UP)\n",
        "        cubes.set_width(mob_width)\n",
        "        cubes.match_x(titles[0])\n",
        "        cubes.set_y(-0.5)\n",
        "        cubes.set_color(BLUE_D)\n",
        "        cubes.set_shadow(0.65)\n",
        "        cubes.set_gloss(0.5)\n",
        "\n",
        "        self.add(cubes)\n",
        "\n",
        "        eq = OldTex(\"f(gh)\", \"=\", \"(fg)h\")\n",
        "        eq[1].rotate(90 * DEGREES)\n",
        "        eq.arrange(DOWN)\n",
        "\n",
        "        eq.match_height(cubes)\n",
        "        eq.center()\n",
        "        eq.match_y(cubes)\n",
        "        self.add(eq)\n",
        "\n",
        "        monster = get_monster()\n",
        "        monster.set_fill(GREY_BROWN)\n",
        "        monster.set_gloss(0.5)\n",
        "        monster.set_width(mob_width)\n",
        "        monster.match_x(titles[2])\n",
        "        monster.match_y(cubes)\n",
        "        self.add(monster)\n",
        "\n",
        "\n",
        "class AskAboutFavoriteMegaNumber(TeacherStudentsScene):\n",
        "    CONFIG = {\n",
        "        \"background_color\": BLACK,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.remove(self.pi_creatures)\n",
        "        # YouTubers\n",
        "        title = OldTexText(\"What's your favorite number $> 1{,}000{,}000$?\")\n",
        "        title.set_width(FRAME_WIDTH - 1)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        images = Group(\n",
        "            ImageMobject(\"standupmaths\"),\n",
        "            ImageMobject(\"singingbanana\"),\n",
        "            ImageMobject(\"Ben Sparks\"),\n",
        "            ImageMobject(\"Zoe Griffiths\"),\n",
        "            ImageMobject(\"tomrocksmaths\"),\n",
        "            ImageMobject(\"James Tanton\"),\n",
        "            ImageMobject(\"blackpenredpen\"),\n",
        "            ImageMobject(\"Eddie Woo\"),\n",
        "        )\n",
        "        images.arrange_in_grid(2, 4, buff=MED_LARGE_BUFF)\n",
        "        images.set_width(FRAME_WIDTH - 2)\n",
        "        images.next_to(title, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(title, DOWN),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, images,\n",
        "                lambda m: (m, -0.1 * m.get_center()),\n",
        "                lag_ratio=0.3,\n",
        "                run_time=5,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Pi Creatures\n",
        "        self.teacher_says(\n",
        "            \"And we want\\\\\\\\you to join!\",\n",
        "            target_mode=\"surprised\",\n",
        "            bubble_config={\n",
        "                \"height\": 3,\n",
        "                \"width\": 4,\n",
        "            },\n",
        "            added_anims=[\n",
        "                VFadeIn(self.pi_creatures),\n",
        "                images.scale, 0.2,\n",
        "                images.space_out_submobjects, 10,\n",
        "                images.set_opacity, 0,\n",
        "            ],\n",
        "        )\n",
        "        self.remove(images)\n",
        "        self.play_student_changes(\"guilty\", \"hooray\", \"wave_2\")\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class IntroduceMonsterSize(Scene):\n",
        "    def construct(self):\n",
        "        # Show number\n",
        "        max_width = FRAME_WIDTH - 1\n",
        "        size_label = OldTexText(\"{:,}\".format(MONSTER_SIZE))[0]\n",
        "        size_label.set_width(max_width)\n",
        "\n",
        "        n_syms = len(size_label)\n",
        "        partials = VGroup()\n",
        "        for n in range(len(size_label) + 1):\n",
        "            partial = size_label[:n].copy()\n",
        "            partial.set_height(1.5)\n",
        "            if partial.get_width() > max_width:\n",
        "                partial.set_width(max_width)\n",
        "            partial.center()\n",
        "            partial.set_color(interpolate_color(BLUE, YELLOW, n / n_syms))\n",
        "            partials.add(partial)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(\n",
        "                size_label,\n",
        "                lambda m, a: m.set_submobjects(\n",
        "                    partials[int(a * n_syms)].submobjects\n",
        "                ),\n",
        "                run_time=6,\n",
        "                rate_func=bezier([0, 0, 1, 1])\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show factorization\n",
        "        factors = OldTex(\n",
        "            r\"= 2^{46} \\cdot 3^{20} \\cdot 5^{9} \\cdot 7^{6} \\cdot 11^{2} \\cdot 13^{3} \\cdot 17 \\cdot 19 \\cdot 23 \\cdot 29 \\cdot 31 \\cdot 41 \\cdot 47 \\cdot 59 \\cdot 71\"\n",
        "        )\n",
        "        factors.set_width(max_width)\n",
        "        approx = OldTex(\"\\\\approx 8\\\\times 10^{53}\")\n",
        "        approx.set_height(0.8)\n",
        "        approx.move_to(DOWN)\n",
        "        factors.next_to(approx, UP, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            size_label.next_to, factors, UP, MED_LARGE_BUFF,\n",
        "            FadeIn(factors, 0.5 * DOWN),\n",
        "            Write(approx),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        value_group = VGroup(size_label, factors, approx)\n",
        "\n",
        "        # Jupiter\n",
        "        jupiter = TexturedSurface(Sphere(), \"JupiterTexture\")\n",
        "        jupiter.rotate(90 * DEGREES, RIGHT)\n",
        "        jupiter.set_height(3.5)\n",
        "        jupiter.to_edge(DOWN)\n",
        "        jupiter.add_updater(lambda m, dt: m.rotate(-0.1 * dt, UP))\n",
        "        jupiter.set_shadow(0.9)\n",
        "\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(jupiter, lambda m, a: m.set_opacity(a)),\n",
        "            ApplyMethod(value_group.to_edge, UP, run_time=2)\n",
        "        )\n",
        "        self.wait(4)\n",
        "\n",
        "        # Alternate intelligences\n",
        "        alien = SVGMobject(\"alien\")\n",
        "        alien.set_height(3)\n",
        "        alien.to_corner(DL)\n",
        "        alien.set_stroke(GREEN, width=0)\n",
        "        alien.set_fill(GREEN_E, 1)\n",
        "\n",
        "        server = SVGMobject(\"server_stack\")\n",
        "        server.set_height(3)\n",
        "        server.to_corner(DR)\n",
        "        server.set_stroke(BLACK, 2)\n",
        "        server.set_fill(GREY, 1)\n",
        "        server.set_gloss(0.5)\n",
        "\n",
        "        alien_words = OldTexText(\"Interesting!\")\n",
        "        alien_words.set_color(GREEN)\n",
        "        alien_words.next_to(alien, UR, buff=-MED_SMALL_BUFF)\n",
        "        server_words = OldTexText(\"Very interesting\\\\\\\\indeed!\")\n",
        "        server_words.next_to(server, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(jupiter, DOWN),\n",
        "            DrawBorderThenFill(alien),\n",
        "        )\n",
        "        self.play(Write(server))\n",
        "        self.wait()\n",
        "        for words in alien_words, server_words:\n",
        "            self.play(Write(words, run_time=1))\n",
        "            self.wait()\n",
        "\n",
        "        # What is it?\n",
        "        question = OldTexText(\"What is it?\")\n",
        "        question.scale(2)\n",
        "        question.move_to(UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeOut,\n",
        "                VGroup(factors, approx, alien_words, alien, server_words, server),\n",
        "                lambda m: (m, DOWN),\n",
        "            ),\n",
        "            ApplyMethod(size_label.move_to, 0.5 * DOWN, run_time=2),\n",
        "            FadeIn(question, UP, run_time=2, rate_func=squish_rate_func(smooth, 0.5, 1)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        monster = get_monster()\n",
        "        monster.next_to(size_label, UP)\n",
        "        monster.to_edge(RIGHT, buff=2)\n",
        "        m_size_bars = get_size_bars(monster, buff=MED_SMALL_BUFF, stroke_width=5)\n",
        "\n",
        "        self.play(\n",
        "            question.shift, 2 * LEFT,\n",
        "            DrawBorderThenFill(monster),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.play(ShowCreation(m_size_bars, lag_ratio=0.4))\n",
        "        self.wait(2)\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeOut(mob, DOWN)\n",
        "            for mob in self.mobjects\n",
        "        ]))\n",
        "\n",
        "\n",
        "class IntroduceGroupTheory(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        over_title = OldTexText(\"An introduction\\\\\\\\to\")\n",
        "        over_title.scale(2.5)\n",
        "        over_title.move_to(ORIGIN, DOWN)\n",
        "\n",
        "        title = OldTexText(\"Group theory\")\n",
        "        title.scale(2.5)\n",
        "        title.next_to(over_title, DOWN, buff=0.5)\n",
        "\n",
        "        arrows = VGroup(Vector(DOWN), Vector(UP))\n",
        "        arrows.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        arrows.scale(2)\n",
        "        arrows.next_to(title, DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        sym_amb = SVGMobject(\"symmetry_ambigram\")\n",
        "        sym_amb.set_stroke(width=0)\n",
        "        sym_amb.set_fill(BLUE, 1)\n",
        "        sym_amb.match_width(title)\n",
        "        sym_amb.next_to(arrows, DOWN)\n",
        "        sym_amb_ghost = sym_amb.copy()\n",
        "        sym_amb_ghost.set_fill(WHITE, 0.2)\n",
        "\n",
        "        self.add(over_title, title)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            title.scale, 2.0 / 2.5,\n",
        "            title.to_edge, UP,\n",
        "            FadeOut(over_title, UP)\n",
        "        )\n",
        "\n",
        "        self.play(FadeIn(title, DOWN))\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows, run_time=1),\n",
        "            Write(sym_amb, run_time=2)\n",
        "        )\n",
        "        self.add(sym_amb_ghost, sym_amb)\n",
        "        self.play(Rotate(sym_amb, PI, run_time=2))\n",
        "        self.remove(sym_amb_ghost)\n",
        "        self.wait()\n",
        "\n",
        "        # Symmetries of a face\n",
        "        face = ImageMobject(\"average_face\")\n",
        "        face.set_height(5)\n",
        "\n",
        "        sym_word = OldTexText(\"Symmetric\")\n",
        "        sym_word.scale(2)\n",
        "        sym_word.to_edge(UP)\n",
        "        face.next_to(sym_word, DOWN, buff=MED_LARGE_BUFF)\n",
        "        sym_word.save_state()\n",
        "        sym_word.replace(sym_amb)\n",
        "        sym_word.set_opacity(0)\n",
        "\n",
        "        face_citation = OldTexText(\"``Average face'' from the Face Research Lab\\\\\\\\DeBruine, Lisa \\\\& Jones, Benedict (2017)\")\n",
        "        face_citation.set_height(0.4)\n",
        "        face_citation.next_to(face, DOWN)\n",
        "        face_citation.to_corner(DL)\n",
        "\n",
        "        sym_line = DashedLine(face.get_top(), face.get_bottom())\n",
        "        sym_line.scale(1.05)\n",
        "        sym_line.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(face, DOWN),\n",
        "            FadeIn(face_citation),\n",
        "            LaggedStartMap(FadeOut, VGroup(*arrows, title), lambda m: (m, UP)),\n",
        "            sym_amb.replace, sym_word.saved_state, {\"stretch\": True},\n",
        "            sym_amb.set_opacity, 0,\n",
        "            Restore(sym_word),\n",
        "        )\n",
        "        self.remove(sym_amb)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(sym_line), FadeOut(face_citation))\n",
        "        sym_line.rotate(PI)\n",
        "        self.play(ApplyMethod(face.stretch, -1, 0, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        sym_to_action = OldTexText(\"Symmetry\", \" $\\\\Rightarrow$ \", \"\\\\emph{Action}\")\n",
        "        sym_to_action.set_color_by_tex(\"Action\", YELLOW)\n",
        "        sym_to_action.replace(sym_word, dim_to_match=1)\n",
        "        self.play(\n",
        "            ReplacementTransform(sym_word[0], sym_to_action[0]),\n",
        "            Write(sym_to_action[1]),\n",
        "            FadeIn(sym_to_action[2], LEFT),\n",
        "        )\n",
        "        self.play(ApplyMethod(face.stretch, -1, 0, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Symmetries of a snowflake\n",
        "        snowflake = get_snowflake()\n",
        "        snowflake.set_height(5)\n",
        "        snowflake.next_to(sym_to_action, DOWN, MED_LARGE_BUFF)\n",
        "        self.play(\n",
        "            FadeOut(face),\n",
        "            Uncreate(sym_line),\n",
        "            ShowCreationThenFadeOut(snowflake.copy().set_stroke(WHITE, 2).set_fill(opacity=0)),\n",
        "            FadeIn(snowflake, run_time=2),\n",
        "        )\n",
        "\n",
        "        def get_flake_rot_icon(degrees, snowflake=snowflake):\n",
        "            return get_rot_icon(degrees, snowflake)\n",
        "\n",
        "        def get_flake_flip_icon(angle, snowflake=snowflake):\n",
        "            return get_flip_icon(angle, snowflake)\n",
        "\n",
        "        rot_icons = VGroup(\n",
        "            get_flake_rot_icon(60),\n",
        "            get_flake_rot_icon(120),\n",
        "        )\n",
        "        flip_icons = VGroup(\n",
        "            get_flake_flip_icon(60 * DEGREES),\n",
        "            get_flake_flip_icon(30 * DEGREES),\n",
        "        )\n",
        "        for icons, vect in [(rot_icons, LEFT), (flip_icons, RIGHT)]:\n",
        "            icons.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "            icons.to_edge(vect)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(rot_icons[0]),\n",
        "            Rotate(snowflake, 60 * DEGREES)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(rot_icons[1]),\n",
        "            Rotate(snowflake, 120 * DEGREES)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        sym_line = DashedLine(snowflake.get_bottom(), snowflake.get_top())\n",
        "        sym_line.scale(1.1)\n",
        "        sym_line.set_stroke(WHITE, 2)\n",
        "        sym_line.set_angle(60 * DEGREES)\n",
        "        sym_line.move_to(snowflake)\n",
        "        self.play(\n",
        "            ShowCreation(sym_line),\n",
        "            FadeIn(flip_icons[0]),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(snowflake, PI, axis=rotate_vector(RIGHT, 60 * DEGREES)),\n",
        "        )\n",
        "        self.play(\n",
        "            sym_line.set_angle, 30 * DEGREES,\n",
        "            sym_line.move_to, snowflake,\n",
        "            FadeIn(flip_icons[1]),\n",
        "        )\n",
        "        self.play(\n",
        "            Rotate(snowflake, PI, axis=rotate_vector(RIGHT, 30 * DEGREES)),\n",
        "        )\n",
        "\n",
        "        # Collection of all snowflake symmetries\n",
        "        rot_icons.generate_target()\n",
        "        flip_icons.generate_target()\n",
        "        d6_group = VGroup(\n",
        "            get_flake_rot_icon(0),\n",
        "            rot_icons.target[0],\n",
        "            rot_icons.target[1],\n",
        "            get_flake_rot_icon(180),\n",
        "            get_flake_rot_icon(-120),\n",
        "            get_flake_rot_icon(-60),\n",
        "            get_flake_flip_icon(0),\n",
        "            flip_icons.target[1],\n",
        "            flip_icons.target[0],\n",
        "            get_flake_flip_icon(90 * DEGREES),\n",
        "            get_flake_flip_icon(120 * DEGREES),\n",
        "            get_flake_flip_icon(150 * DEGREES),\n",
        "        )\n",
        "        d6_group.arrange_in_grid(2, 6)\n",
        "        d6_group.set_width(FRAME_WIDTH - 2)\n",
        "        d6_group.set_gloss(0)\n",
        "        d6_group.set_shadow(0)\n",
        "        for mob in d6_group.get_family():\n",
        "            if isinstance(mob, SVGMobject):\n",
        "                mob.set_fill(GREY_C, 1)\n",
        "                mob.set_stroke(WHITE, 0.25)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(rot_icons),\n",
        "            MoveToTarget(flip_icons),\n",
        "            ApplyMethod(snowflake.scale, 0, remover=True),\n",
        "            ApplyMethod(sym_line.scale, 0, remover=True),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, d6_group))\n",
        "        self.remove(rot_icons, flip_icons)\n",
        "        self.wait()\n",
        "\n",
        "        # Name groups\n",
        "        group_name = OldTexText(\"Group\", \"$^*$\")\n",
        "        group_name.scale(2)\n",
        "        group_name.to_edge(UP)\n",
        "        footnote = OldTexText(\"$^*$er...kind of.  Keep watching\")\n",
        "        footnote.set_height(0.3)\n",
        "        footnote.to_corner(UR)\n",
        "        footnote.add(group_name[1])\n",
        "        footnote.set_color(YELLOW)\n",
        "        group_name.remove(group_name[1])\n",
        "        d6_rect = SurroundingRectangle(d6_group)\n",
        "        d6_rect.set_stroke(BLUE, 2)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(sym_to_action, UP),\n",
        "            FadeIn(group_name, DOWN),\n",
        "            ShowCreation(d6_rect),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(\n",
        "                footnote,\n",
        "                rate_func=there_and_back_with_pause,\n",
        "                run_time=3,\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        anims = []\n",
        "        for icon, deg in zip(d6_group[1:], [60, 120, 180, -120, -60]):\n",
        "            anims.append(Rotate(icon[0], deg * DEGREES))\n",
        "        for icon, deg in zip(d6_group[6:], range(0, 180, 30)):\n",
        "            anims.append(Rotate(icon[0], PI, axis=rotate_vector(RIGHT, deg * DEGREES)))\n",
        "        random.shuffle(anims)\n",
        "        self.play(LaggedStart(*anims, lag_ratio=0.3, run_time=5))\n",
        "        self.play(LaggedStart(*reversed(anims), lag_ratio=0.3, run_time=5))\n",
        "\n",
        "        # Identity\n",
        "        id_rect = SurroundingRectangle(d6_group[0])\n",
        "        id_words = OldTexText(\"The do-nothing\", \"\\\\\\\\action\", alignment=\"\")\n",
        "        id_words.to_corner(UL)\n",
        "        id_arrow = Arrow(id_words[1].get_bottom(), id_rect.get_top(), buff=0.2)\n",
        "        id_arrow.match_color(id_rect)\n",
        "        self.play(\n",
        "            ShowCreation(id_rect)\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(id_words, lag_ratio=0.1),\n",
        "            GrowArrow(id_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Count d6\n",
        "        rects = VGroup(id_rect, *map(SurroundingRectangle, d6_group[1:]))\n",
        "        counter = Integer(0)\n",
        "        counter.set_height(0.8)\n",
        "        counter.next_to(d6_rect, DOWN, MED_LARGE_BUFF)\n",
        "        counter.set_color(YELLOW)\n",
        "        counter.add_updater(lambda m, rects=rects: m.set_value(len(rects)))\n",
        "\n",
        "        self.add(counter)\n",
        "        self.play(\n",
        "            FadeOut(id_words),\n",
        "            FadeOut(id_arrow),\n",
        "            ShowIncreasingSubsets(rects, int_func=np.ceil, run_time=2),\n",
        "            UpdateFromAlphaFunc(counter, lambda m, a: m.set_opacity(a))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        d6_name = OldTex(\"D_6\")\n",
        "        d6_name.scale(2)\n",
        "        d6_name.move_to(counter)\n",
        "        d6_name.set_color(BLUE)\n",
        "        self.play(\n",
        "            FadeOut(rects, lag_ratio=0.1),\n",
        "            FadeOut(counter, 0.2 * UP),\n",
        "            FadeIn(d6_name, 0.2 * DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Name C2\n",
        "        face_group = Group(face, face.deepcopy())\n",
        "        face_group.set_height(4)\n",
        "        face_group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        face_group.next_to(group_name, DOWN, MED_LARGE_BUFF)\n",
        "        sym_line = DashedLine(2 * UP, 2 * DOWN)\n",
        "        sym_line.set_stroke(WHITE, 2)\n",
        "        sym_line.move_to(face_group[1])\n",
        "        sym_line.set_height(face_group[1].get_height() * 1.1)\n",
        "        face_group[1].add(sym_line)\n",
        "\n",
        "        self.play(\n",
        "            d6_rect.replace, face_group, {\"stretch\": True},\n",
        "            d6_rect.scale, 1.1,\n",
        "            FadeOut(d6_group),\n",
        "            FadeOut(d6_name, DOWN),\n",
        "            *[\n",
        "                FadeIn(f, -0.5 * f.get_center())\n",
        "                for f in face_group\n",
        "            ],\n",
        "        )\n",
        "        self.play(face_group[1].stretch, -1, 0)\n",
        "        self.wait()\n",
        "\n",
        "        z2_name = OldTex(\"C_2\")\n",
        "        z2_name.match_color(d6_name)\n",
        "        z2_name.match_height(d6_name)\n",
        "        z2_name.next_to(d6_rect, DOWN, MED_LARGE_BUFF)\n",
        "        self.play(Write(z2_name))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ZooOfGroups(ThreeDScene):\n",
        "    def construct(self):\n",
        "        self.camera.light_source.move_to([-10, 5, 20])\n",
        "\n",
        "        dot_pair = VGroup(Dot(), Dot())\n",
        "        dot_pair.set_height(0.5)\n",
        "        dot_pair.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        dot_pair.set_color(GREY_B)\n",
        "\n",
        "        snowflake = get_snowflake(height=2)\n",
        "\n",
        "        k4_axes = Group(\n",
        "            Line3D(LEFT, RIGHT, color=RED),\n",
        "            Line3D(DOWN, UP, color=GREEN),\n",
        "            Line3D(IN, OUT, color=BLUE),\n",
        "        )\n",
        "        k4_axes.set_height(3)\n",
        "\n",
        "        quat_group = OldTex(\"\\\\{1, -1, i , -i\\\\\\\\j, -j, k, -k\\\\}\")\n",
        "\n",
        "        cube = get_cube(color=BLUE_D, opacity=1)\n",
        "        cube.rotate(15 * DEGREES, OUT)\n",
        "        cube.rotate(80 * DEGREES, LEFT)\n",
        "\n",
        "        sphere = Sphere()\n",
        "        sphere = Group(\n",
        "            sphere,\n",
        "            SurfaceMesh(sphere, resolution=(21, 11))\n",
        "        )\n",
        "        sphere[1].set_stroke(WHITE, 0.5, 0.5)\n",
        "        sphere.rotate(90 * DEGREES, LEFT)\n",
        "        sphere.rotate(0.2 * DEGREES, RIGHT)\n",
        "        sphere[0].sort_faces_back_to_front()\n",
        "        sphere.rotate(90 * DEGREES, UP)\n",
        "        sphere.set_height(3)\n",
        "\n",
        "        circle = Circle()\n",
        "        circle.set_height(3)\n",
        "\n",
        "        monster_object = OldTex(\"196{,}\", \"883\")\n",
        "        monster_object.arrange(DOWN, buff=0, aligned_edge=LEFT)\n",
        "        monster_object.set_height(1.5)\n",
        "        monster_object.add(Eyes(monster_object))\n",
        "        monster_object[-1].scale(0.8, about_edge=DR)\n",
        "\n",
        "        qubit = OldTex(\n",
        "            \"\\\\alpha|0\\\\rangle + \\\\beta|1\\\\rangle\",\n",
        "            tex_to_color_map={\"\\\\alpha\": BLUE, \"\\\\beta\": YELLOW}\n",
        "        )\n",
        "        qubit.set_height(1)\n",
        "        qubit.set_height(1)\n",
        "\n",
        "        groups = Group(\n",
        "            Group(OldTex(\"C_2\"), dot_pair),\n",
        "            Group(OldTex(\"D_6\"), snowflake),\n",
        "            Group(OldTex(\"K_4\"), k4_axes),\n",
        "            Group(OldTex(\"Q_8\"), quat_group),\n",
        "            Group(OldTex(\"S_4\"), cube),\n",
        "            Group(OldTex(\"SO(3)\"), sphere),\n",
        "            Group(OldTex(\"\\\\mathds{R}^+ / \\\\mathds{Z}\"), circle),\n",
        "            Group(OldTex(\"SU(2)\"), qubit),\n",
        "            Group(get_monster(), monster_object),\n",
        "        )\n",
        "\n",
        "        for group in groups:\n",
        "            group[0].set_height(1)\n",
        "            group.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        groups[-1][0].scale(2)\n",
        "\n",
        "        groups.arrange_in_grid(3, 3)\n",
        "        groups.set_width(FRAME_WIDTH - 1)\n",
        "        groups[:3].shift(0.5 * UP)\n",
        "        groups[-3:].shift(0.5 * DOWN)\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeIn(group[0], -0.5 * group.get_center())\n",
        "            for group in groups\n",
        "        ]))\n",
        "        self.play(LaggedStart(*[\n",
        "            FadeInFromLarge(group[1])\n",
        "            for group in groups\n",
        "        ]))\n",
        "        self.play(LaggedStart(\n",
        "            Rotate(dot_pair, PI),\n",
        "            Blink(monster_object[-1]),\n",
        "            Rotate(cube, PI / 2, axis=cube[0].get_center() - cube[-1].get_center()),\n",
        "            Rotate(snowflake, 120 * DEGREES),\n",
        "            Rotate(k4_axes, PI, axis=RIGHT),\n",
        "            Rotate(sphere, 170 * DEGREES, axis=UP),\n",
        "            run_time=3,\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            groups[-1].scale, 3,\n",
        "            groups[-1].center,\n",
        "            groups[-1].space_out_submobjects, 1.5,\n",
        "            *[\n",
        "                FadeOut(mob, mob.get_center() - groups[-1].get_center())\n",
        "                for mob in groups[:-1]\n",
        "            ]\n",
        "        )\n",
        "        self.play(monster_object[-1].look_at, groups[-1][0])\n",
        "        self.play(Blink(monster_object[-1]))\n",
        "        self.play(blink_monster(groups[-1][0]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SymmetriesOfACube(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        light = self.camera.light_source\n",
        "        light.move_to(5 * LEFT + 20 * DOWN + 10 * OUT)\n",
        "\n",
        "        plane = NumberPlane(x_range=(-10, 10), y_range=(-10, 10))\n",
        "        plane.shift(IN)\n",
        "\n",
        "        cube = get_cube(color=BLUE_D, opacity=1)\n",
        "        cube.set_gloss(0.5)\n",
        "        cube.set_shadow(0.2)\n",
        "\n",
        "        frame.set_euler_angles(\n",
        "            phi=70 * DEGREES,\n",
        "            theta=-30 * DEGREES,\n",
        "        )\n",
        "        frame.add_updater(lambda m, dt, sc=self: m.set_theta(-30 * DEGREES * np.cos(sc.time * 0.05)))\n",
        "        self.add(frame)\n",
        "\n",
        "        self.add(plane)\n",
        "        self.add(cube)\n",
        "\n",
        "        # Ask about structure\n",
        "        question = OldTexText(\"What structure is being preserved?\")\n",
        "        question.set_height(0.7)\n",
        "        question.to_edge(UP)\n",
        "        question.fix_in_frame()\n",
        "\n",
        "        def get_rotation(deg, axis, cube=cube):\n",
        "            return Rotate(cube, deg * DEGREES, axis=axis, run_time=1.5)\n",
        "\n",
        "        pairs = [\n",
        "            (90, UP),\n",
        "            (90, RIGHT),\n",
        "            (90, OUT),\n",
        "            (120, [1, 1, 1]),\n",
        "            (120, [1, -1, 1]),\n",
        "            (180, UP),\n",
        "        ]\n",
        "        for deg, axis in pairs:\n",
        "            self.play(get_rotation(deg, axis))\n",
        "            if axis is pairs[1][1]:\n",
        "                self.play(FadeIn(question, DOWN))\n",
        "            self.wait()\n",
        "\n",
        "        # Count cube symmetries\n",
        "        count_label = OldTexText(\"24 \", \"symmetries\")\n",
        "        count_label.set_color_by_tex(\"24\", YELLOW)\n",
        "        count_label.set_height(0.7)\n",
        "        count_label.fix_in_frame()\n",
        "        count_label.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(count_label, DOWN),\n",
        "            FadeOut(question, UP),\n",
        "        )\n",
        "        self.play(get_rotation(120, [1, -1, -1]))\n",
        "        self.wait()\n",
        "        self.play(get_rotation(90, LEFT))\n",
        "        self.wait()\n",
        "        self.play(get_rotation(120, [1, -1, -1]))\n",
        "        self.wait()\n",
        "        self.play(get_rotation(180, OUT))\n",
        "        self.wait()\n",
        "\n",
        "        # Bigger group\n",
        "        reflection_plane = Square3D(resolution=(10, 10))\n",
        "        reflection_plane.set_width(4)\n",
        "        reflection_plane.move_to(cube)\n",
        "        reflection_plane.set_color(GREY, opacity=0.75)\n",
        "        reflection_plane.rotate(PI / 2, DOWN)\n",
        "\n",
        "        cross24 = Cross(count_label[0])\n",
        "        cross24.fix_in_frame()\n",
        "        label48 = OldTex(\"48\")\n",
        "        label48.set_color(GREEN)\n",
        "        label48.match_height(count_label[0])\n",
        "        label48.move_to(count_label[0], DOWN)\n",
        "        label48.fix_in_frame()\n",
        "\n",
        "        self.play(FadeInFromLarge(reflection_plane))\n",
        "        self.play(\n",
        "            ShowCreation(cross24),\n",
        "            ApplyMethod(cube.stretch, -1, 0),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(reflection_plane, PI / 2, axis=UP)\n",
        "        )\n",
        "        self.play(\n",
        "            ApplyMethod(cube.stretch, -1, 2),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Rotate(reflection_plane, PI / 4, UP))\n",
        "        self.play(\n",
        "            cube.stretch, -1, 2,\n",
        "            cube.rotate, PI / 2, UP,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(count_label[0], cross24)\n",
        "        self.play(\n",
        "            count_label[0].shift, 2 * LEFT,\n",
        "            cross24.shift, 2 * LEFT,\n",
        "            FadeIn(label48, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            reflection_plane.rotate, PI / 4, UP,\n",
        "            reflection_plane.rotate, PI / 2, OUT,\n",
        "        )\n",
        "        self.play(\n",
        "            cube.stretch, -1, 1,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOut(reflection_plane))\n",
        "        self.wait()\n",
        "\n",
        "        # Permute faces\n",
        "        cross48 = Cross(label48)\n",
        "        cross48.fix_in_frame()\n",
        "        self.play(ShowCreation(cross48))\n",
        "        label48.add(cross48)\n",
        "\n",
        "        label24 = count_label[0]\n",
        "        label24.add(cross24)\n",
        "        count_label.remove(label24)\n",
        "\n",
        "        def explostion_transform(self=self, cube=cube):\n",
        "            cube_copy = cube.copy()\n",
        "            self.play(\n",
        "                cube.space_out_submobjects, 1.5,\n",
        "                cube.shift, 0.5 * OUT,\n",
        "            )\n",
        "            exploded_cube_copy = cube.copy()\n",
        "            self.play(LaggedStart(*[\n",
        "                Rotate(\n",
        "                    face,\n",
        "                    axis=face.get_center() - cube.get_center(),\n",
        "                    angle=random.choice([0, PI / 2, -PI / 2, PI])\n",
        "                )\n",
        "                for face in cube\n",
        "            ]))\n",
        "            perm = list(range(6))\n",
        "            random.shuffle(perm)\n",
        "            globals()['perm'] = perm  # TODO\n",
        "            self.play(LaggedStart(*[\n",
        "                Transform(face, cube[perm[i]])\n",
        "                for i, face in enumerate(cube)\n",
        "            ], lag_ratio=0.1))\n",
        "            cube.become(exploded_cube_copy)\n",
        "            self.play(Transform(cube, cube_copy))\n",
        "            self.wait()\n",
        "\n",
        "        for x in range(3):\n",
        "            explostion_transform()\n",
        "\n",
        "        # Largest size\n",
        "        count = Integer(188743680)\n",
        "        count.fix_in_frame()\n",
        "        old_counts = VGroup(label24, label48)\n",
        "        old_counts.generate_target()\n",
        "        old_counts.target.to_edge(LEFT)\n",
        "        count.match_height(old_counts)\n",
        "        count.next_to(old_counts.target, RIGHT, buff=LARGE_BUFF)\n",
        "        count.set_color(BLUE_B)\n",
        "        self.play(\n",
        "            MoveToTarget(old_counts),\n",
        "            FadeIn(count),\n",
        "            count_label.next_to, count, RIGHT,\n",
        "        )\n",
        "        for x in range(3):\n",
        "            explostion_transform()\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WeirdCubeSymmetryUnderbrace(Scene):\n",
        "    def construct(self):\n",
        "        brace = Brace(Line(LEFT, RIGHT).set_width(3), DOWN)\n",
        "        tex = brace.get_tex(\"(8^6)(6!)\")\n",
        "        VGroup(brace, tex).set_color(WHITE)\n",
        "        VGroup(brace, tex).set_stroke(BLACK, 8, background=True)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            FadeIn(tex, 0.25 * UP)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class PermutationGroups(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        question = OldTexText(\"What about no structure?\")\n",
        "        question.scale(1.5)\n",
        "        question.to_edge(UP)\n",
        "\n",
        "        perm_words = OldTexText(\"All \", \"permutations\")\n",
        "        perm_words.scale(1.5)\n",
        "        perm_words.next_to(question, DOWN, buff=0.7)\n",
        "        perm_words.set_color(BLUE)\n",
        "\n",
        "        dots = VGroup(*[Dot() for x in range(6)])\n",
        "        dots.set_fill(GREY_B)\n",
        "        dots.set_height(0.5)\n",
        "        dots.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        dots.shift(DOWN)\n",
        "        alt_dots = dots.copy()\n",
        "\n",
        "        self.add(question)\n",
        "        self.play(ShowIncreasingSubsets(dots))\n",
        "\n",
        "        # Permutations\n",
        "        def get_permutation(self=self, dots=dots, arc=PI / 2):\n",
        "            perm = list(range(len(dots)))\n",
        "            random.shuffle(perm)\n",
        "            arrows = get_permutation_arrows(dots, perm, arc)\n",
        "            for i, dot in enumerate(dots):\n",
        "                dot.target = dots[perm[i]]\n",
        "\n",
        "            arrows.set_opacity(0)\n",
        "            return Succession(\n",
        "                UpdateFromAlphaFunc(arrows, lambda m, a: m.set_opacity(a)),\n",
        "                LaggedStartMap(MoveToTarget, dots, path_arc=arc, lag_ratio=0.15, run_time=2),\n",
        "                UpdateFromAlphaFunc(arrows, lambda m, a: m.set_opacity(1 - a)),\n",
        "            )\n",
        "\n",
        "        permutations = Succession(*[\n",
        "            get_permutation()\n",
        "            for x in range(20)\n",
        "        ])\n",
        "        animated_perm_mob = cycle_animation(permutations)\n",
        "        self.add(animated_perm_mob)\n",
        "        self.wait(5)\n",
        "        self.play(FadeIn(perm_words, UP))\n",
        "        self.wait(10)\n",
        "\n",
        "        # Count perms\n",
        "        perm_count = OldTex(\"6!\")\n",
        "        perm_count.match_height(perm_words[0])\n",
        "        perm_count.match_color(perm_words[0])\n",
        "        perm_count.move_to(perm_words[0], RIGHT)\n",
        "        full_count = Integer(720, edge_to_fix=RIGHT)\n",
        "        full_count.match_height(perm_count)\n",
        "        full_count.move_to(perm_count, DR)\n",
        "        full_count.shift(0.7 * RIGHT)\n",
        "        full_count.match_color(perm_count)\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.scale(1.5)\n",
        "        equals.next_to(full_count, LEFT)\n",
        "        equals.match_color(perm_count)\n",
        "        perm_count.next_to(equals, LEFT)\n",
        "        full_count.set_value(0)\n",
        "\n",
        "        self.remove(animated_perm_mob)\n",
        "        dots = alt_dots\n",
        "        self.add(alt_dots)\n",
        "        self.play(\n",
        "            FadeIn(full_count, LEFT),\n",
        "            FadeOut(perm_words[0], RIGHT),\n",
        "            perm_words[1].shift, 0.7 * RIGHT,\n",
        "        )\n",
        "\n",
        "        all_perms = list(it.permutations(range(6)))\n",
        "        arrows = VGroup()\n",
        "        self.add(arrows)\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(full_count, 720),\n",
        "            UpdateFromAlphaFunc(\n",
        "                arrows,\n",
        "                lambda m, a, dots=dots, all_perms=all_perms: m.set_submobjects(\n",
        "                    get_permutation_arrows(dots, all_perms[int(np.round(719 * a))])\n",
        "                )\n",
        "            ),\n",
        "            run_time=20,\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(perm_count, RIGHT),\n",
        "            Write(equals),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        perm_label = VGroup(perm_count, equals, full_count, perm_words[1])\n",
        "\n",
        "        # Revisit snowflake symmetries\n",
        "        dots.generate_target()\n",
        "        for dot, point in zip(dots.target, compass_directions(6, UP)):\n",
        "            dot.move_to(2 * point)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(arrows),\n",
        "            FadeOut(perm_label, UP),\n",
        "            FadeOut(question, 0.5 * UP),\n",
        "            MoveToTarget(dots),\n",
        "        )\n",
        "\n",
        "        lines = VGroup()\n",
        "        for d1, d2 in it.combinations(dots, 2):\n",
        "            lines.add(Line(\n",
        "                d1.get_center(),\n",
        "                d2.get_center(),\n",
        "                buff=d1.get_width() / 4,\n",
        "            ))\n",
        "        lines.set_stroke(WHITE, 2)\n",
        "        hexy = VGroup(dots, lines)\n",
        "        hexy.unlock_unit_normal()\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, lines))\n",
        "        self.wait()\n",
        "        self.play(Rotate(hexy, 60 * DEGREES))\n",
        "        self.wait()\n",
        "        self.play(Rotate(hexy, -120 * DEGREES))\n",
        "        self.wait()\n",
        "        self.play(Rotate(hexy, PI, axis=UP))\n",
        "        self.wait()\n",
        "        self.play(Rotate(hexy, PI, axis=rotate_vector(RIGHT, 60 * DEGREES)))\n",
        "        self.wait()\n",
        "\n",
        "        # Back to a row\n",
        "        dots.generate_target()\n",
        "        dots.target.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        dots.target.move_to(0.5 * DOWN)\n",
        "        for line in lines:\n",
        "            line.generate_target()\n",
        "            line.target.set_angle(0)\n",
        "            line.target.set_stroke(WHITE, 0, 0)\n",
        "\n",
        "        perm_label.to_edge(UP, buff=LARGE_BUFF)\n",
        "        self.play(\n",
        "            MoveToTarget(dots),\n",
        "            FadeIn(perm_label),\n",
        "            LaggedStartMap(MoveToTarget, lines, run_time=1.5)\n",
        "        )\n",
        "\n",
        "        # Bump it up to 12\n",
        "        new_dots = dots.copy()\n",
        "        new_dots.shift(1.5 * DOWN)\n",
        "\n",
        "        new_perm_label = VGroup(\n",
        "            OldTex(\"12!\"),\n",
        "            OldTex(\"=\"),\n",
        "            Integer(math.factorial(12)),\n",
        "            OldTexText(\"permutations\")[0],\n",
        "        )\n",
        "        new_perm_label.arrange(RIGHT)\n",
        "        new_perm_label.match_height(perm_label)\n",
        "        new_perm_label.set_color(YELLOW)\n",
        "        new_perm_label.move_to(perm_label)\n",
        "        new_perm_label[0].align_to(perm_label[2][0], DOWN)\n",
        "\n",
        "        old_full_count_center = full_count.get_center()\n",
        "        self.play(\n",
        "            ChangeDecimalToValue(\n",
        "                perm_label[2], new_perm_label[2].get_value(),\n",
        "                run_time=3\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                perm_label[2], lambda m, a: m.move_to(interpolate(\n",
        "                    old_full_count_center,\n",
        "                    new_perm_label[2].get_center(),\n",
        "                    a\n",
        "                )).set_color(interpolate_color(BLUE, YELLOW, a))\n",
        "            ),\n",
        "            ShowIncreasingSubsets(new_dots),\n",
        "            *[\n",
        "                ReplacementTransform(perm_label[i], new_perm_label[i])\n",
        "                for i in [0, 1, 3]\n",
        "            ]\n",
        "        )\n",
        "        self.remove(perm_label)\n",
        "        perm_label = new_perm_label\n",
        "        self.add(perm_label)\n",
        "        dots.add(*new_dots)\n",
        "\n",
        "        self.wait()\n",
        "\n",
        "        for x in range(5):\n",
        "            perm = list(range(12))\n",
        "            random.shuffle(perm)\n",
        "            self.play(LaggedStart(*[\n",
        "                Transform(dots[i], dots[perm[i]], path_arc=PI / 2)\n",
        "                for i in range(12)\n",
        "            ]))\n",
        "            self.wait()\n",
        "\n",
        "        # Show 101 dots\n",
        "        new_perm_label = VGroup(\n",
        "            OldTex(\"101!\"),\n",
        "            OldTex(\"\\\\approx\"),\n",
        "            OldTex(\"9.43 \\\\times 10^{159}\"),\n",
        "            OldTexText(\"permutations\")[0]\n",
        "        )\n",
        "        new_perm_label.arrange(RIGHT)\n",
        "        new_perm_label.match_height(perm_label)\n",
        "        new_perm_label[2].align_to(new_perm_label[0], DOWN)\n",
        "        new_perm_label[3].shift(SMALL_BUFF * DOWN)\n",
        "        new_perm_label.move_to(perm_label, RIGHT)\n",
        "\n",
        "        new_dots = VGroup(*[dots[0].copy() for x in range(101)])\n",
        "        new_dots.arrange_in_grid(7, 13)\n",
        "        new_dots.set_height(5)\n",
        "        new_dots.to_edge(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(perm_label),\n",
        "            FadeIn(new_perm_label),\n",
        "            ReplacementTransform(dots, new_dots[-len(dots):]),\n",
        "            ShowIncreasingSubsets(new_dots[:-len(dots)], run_time=2)\n",
        "        )\n",
        "        self.add(new_dots)\n",
        "        perm_label = new_perm_label\n",
        "        dots = new_dots\n",
        "\n",
        "        labels = VGroup()\n",
        "        for i, dot in enumerate(new_dots):\n",
        "            label = Integer(i + 1, fill_color=BLACK)\n",
        "            label.replace(dot, dim_to_match=1)\n",
        "            label.scale(0.3)\n",
        "            labels.add(label)\n",
        "        labels.set_stroke(width=0)\n",
        "\n",
        "        self.play(FadeIn(labels))\n",
        "        self.remove(labels)\n",
        "        for dot, label in zip(dots, labels):\n",
        "            dot.add(label)\n",
        "\n",
        "        for x in range(6):\n",
        "            self.play(permutation_animation(dots, lag_factor=1))\n",
        "            self.wait(0.5)\n",
        "\n",
        "        # Name S_n\n",
        "        perm_label[3].generate_target()\n",
        "        new_perm_label = VGroup(\n",
        "            OldTex(\"n!\").match_height(perm_label[0]),\n",
        "            perm_label[3].target,\n",
        "        )\n",
        "        new_perm_label.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        new_perm_label[0].align_to(new_perm_label[1][-1], DOWN)\n",
        "        new_perm_label.next_to(perm_label[0], RIGHT, MED_LARGE_BUFF)\n",
        "        new_perm_label[0].save_state()\n",
        "        new_perm_label[0].replace(perm_label[0], stretch=True)\n",
        "        new_perm_label[0].set_opacity(0)\n",
        "\n",
        "        Sn_name = OldTex(\"S_n\")\n",
        "        Sn_name.match_height(new_perm_label)\n",
        "        Sn_name.next_to(new_perm_label, RIGHT, buff=LARGE_BUFF)\n",
        "        Sn_name.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            perm_label[0].replace, new_perm_label[0], {\"stretch\": True},\n",
        "            perm_label[0].set_opacity, 0,\n",
        "            FadeOut(perm_label[1:3], RIGHT),\n",
        "            MoveToTarget(perm_label[3]),\n",
        "            Restore(new_perm_label[0]),\n",
        "        )\n",
        "        self.play(FadeIn(Sn_name, LEFT))\n",
        "\n",
        "        self.remove(perm_label)\n",
        "        perm_label = new_perm_label\n",
        "        self.add(perm_label)\n",
        "\n",
        "        self.play(permutation_animation(dots))\n",
        "\n",
        "        # Down to a square\n",
        "        new_dots = dots[:4]\n",
        "        faders = dots[4:]\n",
        "        new_dots.generate_target()\n",
        "        for dot in new_dots.target:\n",
        "            dot.set_height(0.8)\n",
        "        new_dots.target.arrange_in_grid(2, 2, buff=LARGE_BUFF)\n",
        "        new_dots.target.center()\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(new_dots),\n",
        "            FadeOut(faders),\n",
        "        )\n",
        "        dots = new_dots\n",
        "        for x in range(2):\n",
        "            self.play(permutation_animation(dots, [2, 0, 3, 1], lag_factor=0))\n",
        "            self.wait()\n",
        "\n",
        "\n",
        "class IsItUseful(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Is any of\\\\\\\\this useful?\",\n",
        "            index=2,\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.play_student_changes(\"angry\", \"confused\")\n",
        "        self.wait(3)\n",
        "        self.teacher_says(\"Extremely!\")\n",
        "        self.play_student_changes(\"pondering\", \"thinking\", \"pondering\", look_at=self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class SolutionsToPolynomials(Scene):\n",
        "    def construct(self):\n",
        "        # Show quintic shuffling\n",
        "        colors = list(Color(BLUE).range_to(YELLOW, 5))\n",
        "        quintic = OldTex(\n",
        "            \"x^5 - x - 1\",\n",
        "            \"=\",\n",
        "            \"(x - r_0)\",\n",
        "            \"(x - r_1)\",\n",
        "            \"(x - r_2)\",\n",
        "            \"(x - r_3)\",\n",
        "            \"(x - r_4)\",\n",
        "            tex_to_color_map={\n",
        "                f\"r_{i}\": colors[i]\n",
        "                for i in range(5)\n",
        "            }\n",
        "        )\n",
        "        root_syms = VGroup(*[quintic.get_part_by_tex(f\"r_{i}\") for i in range(5)])\n",
        "        quintic.set_width(FRAME_WIDTH - 1)\n",
        "        quintic.to_edge(UP)\n",
        "\n",
        "        plane = ComplexPlane(x_range=(-2, 2), y_range=(-2, 2))\n",
        "        plane.set_height(6)\n",
        "        plane.to_edge(DOWN, buff=MED_SMALL_BUFF)\n",
        "        plane.add_coordinate_labels()\n",
        "        for label in plane.coordinate_labels:\n",
        "            label.scale(0.7, about_edge=UR)\n",
        "\n",
        "        def get_root_dots(roots, plane=plane, colors=colors):\n",
        "            return VGroup(*[\n",
        "                Dot(\n",
        "                    plane.n2p(root),\n",
        "                    radius=0.1,\n",
        "                    color=color,\n",
        "                ).set_stroke(BLACK, 2, background=True)\n",
        "                for root, color in zip(roots, colors)\n",
        "            ])\n",
        "\n",
        "        root_dots = get_root_dots([\n",
        "            1.1673,\n",
        "            0.181232 + 1.08395j,\n",
        "            0.181232 - 1.08395j,\n",
        "            -0.764884 + 0.352472j,\n",
        "            -0.764884 - 0.352472j,\n",
        "        ])\n",
        "\n",
        "        self.add(quintic)\n",
        "        self.add(plane)\n",
        "        self.play(LaggedStart(*[\n",
        "            ReplacementTransform(rs.copy(), rd)\n",
        "            for rs, rd in zip(root_syms, root_dots)\n",
        "        ], run_time=3, lag_ratio=0.3))\n",
        "        self.wait()\n",
        "\n",
        "        root_syms.save_state()\n",
        "        root_dots.save_state()\n",
        "\n",
        "        for x in range(5):\n",
        "            perm = list(range(5))\n",
        "            random.shuffle(perm)\n",
        "            self.play(*[\n",
        "                permutation_animation(mob, perm, arc=30 * DEGREES, lag_factor=0.5)\n",
        "                for mob in [root_syms, root_dots]\n",
        "            ])\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            Restore(root_syms, path_arc=60 * DEGREES),\n",
        "            Restore(root_dots, path_arc=60 * DEGREES),\n",
        "        )\n",
        "\n",
        "        # Down to quadratic\n",
        "        quadratic_lhs = OldTex(\"x^2 - x - 1\")\n",
        "        quadratic_lhs.match_height(quintic[0])\n",
        "        quadratic_lhs.move_to(quintic[0], RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(quintic[0], UP),\n",
        "            FadeIn(quadratic_lhs, DOWN),\n",
        "            FadeOut(quintic[8:], UP),\n",
        "            MaintainPositionRelativeTo(root_dots, plane),\n",
        "            UpdateFromAlphaFunc(root_dots, lambda m, a: m.set_opacity(1 - a)),\n",
        "            plane.to_edge, LEFT,\n",
        "        )\n",
        "        self.remove(root_dots)\n",
        "        root_dots.set_opacity(1)\n",
        "        root_dots.save_state()\n",
        "\n",
        "        quad_root_dots = get_root_dots([\n",
        "            (1 + u * np.sqrt(5)) / 2 for u in [-1, 1]\n",
        "        ])\n",
        "\n",
        "        self.play(LaggedStart(*[\n",
        "            ReplacementTransform(root_sym.copy(), root_dot)\n",
        "            for root_dot, root_sym in zip(quad_root_dots, root_syms)\n",
        "        ]))\n",
        "        self.wait()\n",
        "\n",
        "        # Quadratic formula\n",
        "        quadratic_formula = OldTex(\n",
        "            \"{-b \\\\pm \\\\sqrt{\\\\,b^2 - 4ac} \\\\over 2a}\",\n",
        "        )\n",
        "        quadratic_formula.set_height(1.5)\n",
        "        quadratic_formula.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        quad_form_name = OldTexText(\"Quadratic formula\")\n",
        "        quad_form_name.set_height(0.5)\n",
        "        quad_form_name.next_to(quadratic_formula, DOWN, LARGE_BUFF)\n",
        "        quad_form_name.set_color(GREY_B)\n",
        "\n",
        "        self.play(\n",
        "            Write(quadratic_formula),\n",
        "            FadeIn(quad_form_name, DOWN)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Cubic\n",
        "        cubic_lhs = OldTex(\"x^3 - x - 1\")\n",
        "        cubic_lhs.replace(quadratic_lhs)\n",
        "\n",
        "        cubic_root_dots = get_root_dots([\n",
        "            1.3247,\n",
        "            -0.66236 + 0.56228j,\n",
        "            -0.66236 - 0.56228j,\n",
        "        ])\n",
        "\n",
        "        cubic_formula = OldTex(\n",
        "            r\"\\sqrt[3]{-\\frac{q}{2}+\\sqrt{\\frac{q^{2}}{4}+\\frac{p^{3}}{27}}}+\\sqrt[3]{-\\frac{q}{2}-\\sqrt{\\frac{q^{2}}{4}+\\frac{p^{3}}{27}}}\",\n",
        "        )\n",
        "        cubic_formula.replace(quadratic_formula, dim_to_match=1)\n",
        "        cubic_formula.to_edge(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        cubic_formula.scale(0.8, about_edge=RIGHT)\n",
        "\n",
        "        cubic_form_name = OldTexText(\"Cubic formula (reduced)\")\n",
        "        cubic_form_name.replace(quad_form_name, dim_to_match=1)\n",
        "        cubic_form_name.match_style(quad_form_name)\n",
        "\n",
        "        self.play(\n",
        "            ReplacementTransform(quad_root_dots, cubic_root_dots),\n",
        "            FadeIn(quintic[8:11], DOWN),\n",
        "            FadeIn(cubic_lhs, DOWN),\n",
        "            FadeOut(quadratic_lhs, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(quadratic_formula, 2 * RIGHT),\n",
        "                FadeOut(quad_form_name, 2 * RIGHT),\n",
        "            ),\n",
        "            LaggedStart(\n",
        "                FadeIn(cubic_formula, 2 * LEFT),\n",
        "                FadeIn(cubic_form_name, 2 * LEFT),\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Quartic (largely copied from above)\n",
        "        quartic_lhs = OldTex(\"x^4 - x - 1\")\n",
        "        quartic_lhs.replace(quadratic_lhs)\n",
        "\n",
        "        quartic_root_dots = get_root_dots([\n",
        "            1.2207,\n",
        "            -0.72449,\n",
        "            -0.24813 + 1.0340j,\n",
        "            -0.24813 - 1.0340j,\n",
        "        ])\n",
        "\n",
        "        quartic_formula = OldTex(r\"\"\"\n",
        "            r_{i}&=-\\frac{b}{4 a}-S \\pm \\frac{1}{2} \\sqrt{-4 S^{2}-2 p \\pm \\frac{q}{S}}\\\\\\\\\n",
        "            &\\text{Where}\\\\\\\\\n",
        "            p&=\\frac{8 a c-3 b^{2}}{8 a^{2}} \\qquad \\qquad\n",
        "            q=\\frac{b^{3}-4 a b c+8 a^{2} d}{8 a^{3}}\\\\\\\\\n",
        "            S&=\\frac{1}{2} \\sqrt{-\\frac{2}{3} p+\\frac{1}{3 a}\\left(Q+\\frac{\\Delta_{0}}{Q}\\right)}\\\\\\\\\n",
        "            Q&=\\sqrt[3]{\\frac{\\Delta_{1}+\\sqrt{\\Delta_{1}^{2}-4 \\Delta_{0}^{3}}}{2}}\\\\\\\\\n",
        "            \\Delta_{0}&=c^{2}-3 b d+12 a e\\\\\\\\\n",
        "            \\Delta_{1}&=2 c^{3}-9 b c d+27 b^{2} e+27 a d^{2}-72 a c e\\\\\\\\\n",
        "        \"\"\")\n",
        "        quartic_formula.set_height(6)\n",
        "        quartic_formula.next_to(plane, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(cubic_formula, 2 * RIGHT),\n",
        "            FadeOut(cubic_form_name, 2 * RIGHT),\n",
        "            ReplacementTransform(cubic_root_dots, quartic_root_dots),\n",
        "            FadeIn(quintic[11:14], DOWN),\n",
        "            FadeIn(quartic_lhs, DOWN),\n",
        "            FadeOut(cubic_lhs, UP),\n",
        "        )\n",
        "        self.play(\n",
        "            Write(quartic_formula, run_time=3),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Back to quintic\n",
        "        self.play(\n",
        "            ReplacementTransform(quartic_root_dots, root_dots),\n",
        "            FadeIn(quintic[0], DOWN),\n",
        "            FadeOut(quartic_lhs, UP),\n",
        "            FadeIn(quintic[14:], DOWN),\n",
        "            FadeOut(quartic_formula, 0.1 * DOWN, lag_ratio=0.01),\n",
        "        )\n",
        "\n",
        "        # Wonder about the quintic\n",
        "        mathy = PiCreature(color=GREY)\n",
        "        mathy.flip()\n",
        "        mathy.next_to(quintic, DOWN, buff=1.5)\n",
        "        mathy.to_edge(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(mathy),\n",
        "            mathy.change, \"confused\", root_syms,\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            mathy.change, \"pondering\", root_syms[3]\n",
        "        )\n",
        "        self.play(Blink(mathy))\n",
        "        self.wait()\n",
        "\n",
        "        mathy.add_updater(lambda m, sym=root_syms[3]: m.look_at(sym))\n",
        "\n",
        "        # Show a few permutations\n",
        "        s5_name = OldTex(\"S_5\")\n",
        "        s5_name.scale(1.5)\n",
        "        s5_name.next_to(plane, RIGHT, MED_LARGE_BUFF, aligned_edge=UP)\n",
        "        s5_name.shift(DOWN)\n",
        "\n",
        "        s5_lines = VGroup()\n",
        "        for dot in root_dots:\n",
        "            line = Line(s5_name.get_left(), dot.get_center())\n",
        "            line.match_color(dot)\n",
        "            line.set_stroke(width=1)\n",
        "            line.dot = dot\n",
        "            line.start = line.get_start()\n",
        "            s5_lines.add(line)\n",
        "\n",
        "        s5_lines.set_stroke(opacity=0.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(s5_name),\n",
        "            ShowCreation(s5_lines, lag_ratio=0.5),\n",
        "        )\n",
        "        for line in s5_lines:\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(m.start, m.dot.get_center()))\n",
        "        self.add(*s5_lines)\n",
        "\n",
        "        for x in range(5):\n",
        "            perm = list(range(5))\n",
        "            random.shuffle(perm)\n",
        "            self.play(*[\n",
        "                permutation_animation(mob, perm, arc=30 * DEGREES, lag_factor=0.5)\n",
        "                for mob in [root_syms, root_dots]\n",
        "            ])\n",
        "            self.wait(0.5)\n",
        "\n",
        "        self.play(\n",
        "            VFadeOut(s5_lines),\n",
        "            Restore(root_syms),\n",
        "            Restore(root_dots),\n",
        "            FadeOut(mathy),\n",
        "        )\n",
        "\n",
        "        # No formula\n",
        "        r0_value = OldTex(\n",
        "            \"r_0\", \"=\", \"1.1673\\\\dots\",\n",
        "        )\n",
        "        r0_value.set_color_by_tex(\"r_0\", BLUE)\n",
        "        r0_value.scale(1.5)\n",
        "        r0_value.next_to(plane, RIGHT, MED_LARGE_BUFF)\n",
        "        r0_value.shift(DOWN)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                AnimationGroup(\n",
        "                    ShowCreationThenFadeAround(dot),\n",
        "                    ShowCreationThenFadeAround(sym),\n",
        "                )\n",
        "                for sym, dot in zip(root_syms, root_dots)\n",
        "            ], lag_ratio=0.3, run_time=3),\n",
        "        )\n",
        "        self.play(TransformFromCopy(root_syms[0], r0_value[0]))\n",
        "        self.play(Write(r0_value[1:]))\n",
        "        self.add(r0_value)\n",
        "        self.wait()\n",
        "\n",
        "        # Arithmetic symbols\n",
        "        symbols = VGroup(*[\n",
        "            OldTex(s)\n",
        "            for s in [\"+\", \"-\", \"\\\\times\", \"/\", \"\\\\sqrt[n]{\\\\qquad}\"]\n",
        "        ])\n",
        "        symbols[:4].arrange_in_grid(2, 2)\n",
        "        symbols[4].next_to(symbols[:4], RIGHT, MED_LARGE_BUFF)\n",
        "        symbols.move_to(s5_name)\n",
        "        symbols.to_edge(RIGHT)\n",
        "        symbols_rect = SurroundingRectangle(symbols, buff=MED_SMALL_BUFF)\n",
        "        symbols_rect.set_stroke(BLUE, 2)\n",
        "\n",
        "        arrow = Arrow(symbols_rect.get_corner(DL), r0_value[2][3].get_top())\n",
        "        cross = Cross(arrow)\n",
        "        cross.stretch(0.5, 1)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(symbols, lag_ratio=0.2, run_time=1.5),\n",
        "            ShowCreation(symbols_rect),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowArrow(arrow))\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MentionGroupsInPhysics(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Intro\n",
        "        self.teacher_says(\"Groups are ubiquitous\\\\\\\\in physics.\")\n",
        "        self.play_student_changes(\"thinking\", \"happy\", \"hesitant\")\n",
        "        self.wait(4)\n",
        "\n",
        "        noether = ImageMobject(\"EmmyNoether\")\n",
        "        noether.set_height(3)\n",
        "        noether.to_corner(UL)\n",
        "\n",
        "        nt_label = OldTexText(\"Noether's theorem\")\n",
        "        nt_label.set_height(0.5)\n",
        "        nt_label.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(nt_label, DOWN),\n",
        "            FadeIn(noether, DOWN),\n",
        "            FadeOut(VGroup(self.teacher.bubble, self.teacher.bubble.content)),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"pondering\", \"thinking\", look_at=nt_label)\n",
        "\n",
        "        # Theorem\n",
        "        nt_label.generate_target()\n",
        "        nt_label.target.center().to_edge(UP)\n",
        "        rule = VGroup(\n",
        "            OldTexText(\"Conservation law\", color=BLUE),\n",
        "            OldTex(\"\\\\Leftrightarrow\"),\n",
        "            OldTexText(\"Symmetry\", color=YELLOW),\n",
        "        )\n",
        "        rule.set_height(0.5)\n",
        "        rule.arrange(RIGHT)\n",
        "        rule.next_to(nt_label.target, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.look_at(\n",
        "            nt_label.target,\n",
        "            added_anims=[MoveToTarget(nt_label)]\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"happy\", rule,\n",
        "            *[\n",
        "                FadeIn(part, rule.get_center() - part.get_center())\n",
        "                for part in rule\n",
        "            ],\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Examples\n",
        "        examples = VGroup(\n",
        "            OldTexText(\"Momentum\", \" $\\\\Leftrightarrow$ \", \"Translation in space\"),\n",
        "            OldTexText(\"Energy\", \" $\\\\Leftrightarrow$ \", \"Translation in time\"),\n",
        "        )\n",
        "        examples.arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "        examples.next_to(rule, DOWN, buff=MED_LARGE_BUFF)\n",
        "        for example in examples:\n",
        "            example[0].set_color(BLUE)\n",
        "            example[2].set_color(YELLOW)\n",
        "            example.shift((rule[1].get_x() - example[1].get_x()) * RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeIn(examples[0], UP),\n",
        "            self.change_students(\"confused\", \"erm\", \"pondering\")\n",
        "        )\n",
        "        self.look_at(rule)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(examples[1], UP))\n",
        "        self.wait(4)\n",
        "        self.play_student_changes(\"thinking\", \"maybe\", \"thinking\")\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class AmbientDodecSymmetries(ThreeDScene):\n",
        "    def construct(self):\n",
        "        pass\n",
        "\n",
        "\n",
        "class NotGroupsGroupAction(Scene):\n",
        "    def construct(self):\n",
        "        words = VGroup(\n",
        "            OldTexText(\"Group\"),\n",
        "            OldTexText(\"Group\", \" action\"),\n",
        "        )\n",
        "        words.scale(2)\n",
        "        words.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        words.to_corner(UL)\n",
        "        group, group_action = words\n",
        "\n",
        "        cross = Cross(group)\n",
        "\n",
        "        self.add(group)\n",
        "        self.wait()\n",
        "        self.play(ShowCreation(cross))\n",
        "        self.play(\n",
        "            TransformFromCopy(group[0], group_action[0]),\n",
        "            Animation(cross.copy(), remover=True)\n",
        "        )\n",
        "        self.play(Write(group_action[1]))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ElementsAsAbstractions(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Three\n",
        "        self.teacher_says(\"Three\")\n",
        "        self.wait()\n",
        "\n",
        "        s_copies = self.students.copy()\n",
        "        s_copies.scale(0.3)\n",
        "        bubble = self.students[0].get_bubble(\n",
        "            s_copies,\n",
        "            width=5,\n",
        "            height=4,\n",
        "        )\n",
        "        self.play(\n",
        "            self.students[0].change, \"pondering\",\n",
        "            Write(bubble),\n",
        "            FadeIn(bubble.content, lag_ratio=0.3),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        numeral = Integer(3)\n",
        "        numeral.replace(bubble.content, dim_to_match=1)\n",
        "        bubble.content.generate_target()\n",
        "        for pi in bubble.content.target:\n",
        "            pi.change(\"horrified\")\n",
        "            pi.shift(UP)\n",
        "            pi.set_opacity(0)\n",
        "\n",
        "        self.play(MoveToTarget(bubble.content))\n",
        "        self.remove(bubble.content)\n",
        "        self.play(\n",
        "            Write(numeral),\n",
        "            self.students[0].change, \"happy\", numeral,\n",
        "        )\n",
        "        self.look_at(numeral)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Element of D6\n",
        "        self.camera.light_source.set_x(0)\n",
        "        snowflake = get_snowflake()\n",
        "        rot_icon = get_rot_icon(60, snowflake)\n",
        "        inclusion = VGroup(\n",
        "            rot_icon,\n",
        "            OldTex(\"\\\\in\").scale(2),\n",
        "            OldTex(\"D_6\").scale(2),\n",
        "        )\n",
        "        inclusion.arrange(RIGHT)\n",
        "        inclusion.next_to(self.hold_up_spot, UL, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(\n",
        "                FadeOut(self.teacher.bubble),\n",
        "                FadeOut(self.teacher.bubble.content),\n",
        "                FadeOut(bubble),\n",
        "                FadeOut(numeral),\n",
        "                FadeIn(inclusion, DOWN),\n",
        "            ),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.look_at(inclusion)\n",
        "        self.wait()\n",
        "        self.play(Rotate(rot_icon[0], 60 * DEGREES))\n",
        "        self.wait()\n",
        "\n",
        "        rot_icon.generate_target()\n",
        "        rot_icon.target.to_corner(UL)\n",
        "        r_sym = OldTex(\"r\").scale(2)\n",
        "        r_sym.move_to(rot_icon, RIGHT)\n",
        "\n",
        "        self.look_at(\n",
        "            rot_icon.target,\n",
        "            added_anims=[MoveToTarget(rot_icon)],\n",
        "        )\n",
        "        self.look_at(\n",
        "            r_sym,\n",
        "            added_anims=[Write(r_sym)]\n",
        "        )\n",
        "        self.play_all_student_changes(\n",
        "            \"confused\",\n",
        "            look_at=r_sym,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        inclusion.remove(rot_icon)\n",
        "        inclusion.add(r_sym)\n",
        "\n",
        "        # Back to 3\n",
        "        numeral.move_to(self.hold_up_spot, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            inclusion.to_edge, LEFT,\n",
        "            inclusion.set_color, GREY_B,\n",
        "            Write(numeral),\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=numeral),\n",
        "            self.teacher.change, \"tease\", numeral,\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Operations\n",
        "        add = OldTex(\"3\", \"+\", \"5\", \"=\", \"8\")\n",
        "        mult = OldTex(\"3\", \"\\\\cdot\", \"5\", \"=\", \"15\")\n",
        "        ops = VGroup(add, mult)\n",
        "        ops.match_height(numeral)\n",
        "        ops.arrange(DOWN, buff=LARGE_BUFF, aligned_edge=LEFT)\n",
        "        ops.to_corner(UR, buff=LARGE_BUFF)\n",
        "\n",
        "        self.remove(numeral)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                TransformFromCopy(numeral[0], form[0])\n",
        "                for form in ops\n",
        "            ]),\n",
        "            *[\n",
        "                ApplyMethod(pi.look_at, ops)\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                Write(form[1:])\n",
        "                for form in ops\n",
        "            ])\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        # Literal forms\n",
        "        quincunx = VGroup(*[Dot() for x in range(5)])\n",
        "        quincunx[:4].arrange_in_grid()\n",
        "        quincunx.space_out_submobjects(0.7)\n",
        "        triplet = VGroup(quincunx[0], quincunx[3], quincunx[4]).copy()\n",
        "        triplet.set_color(BLUE)\n",
        "        octet = VGroup(*[Dot() for x in range(9)])\n",
        "        octet.arrange_in_grid(3, 3)\n",
        "        octet.remove(octet[4])\n",
        "        octet.space_out_submobjects(0.5)\n",
        "\n",
        "        sum_dots = VGroup(triplet, quincunx, octet)\n",
        "        for sd, sym in zip(sum_dots, ops[0][0::2]):\n",
        "            sd.move_to(sym)\n",
        "\n",
        "        octet.shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        quincunx_trip = VGroup(*[quincunx.copy() for x in range(3)])\n",
        "        quincunx_trip.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        for quin in quincunx_trip:\n",
        "            rect = SurroundingRectangle(quin)\n",
        "            rect.set_stroke(BLUE, 3)\n",
        "            quin.add(rect)\n",
        "        quincunx_trip.move_to(ops[1][2], RIGHT)\n",
        "\n",
        "        fifteen = VGroup(*[Dot() for x in range(15)])\n",
        "        fifteen.arrange_in_grid(3, 5)\n",
        "        fifteen.space_out_submobjects(0.5)\n",
        "        fifteen.move_to(ops[1][4], LEFT)\n",
        "\n",
        "        mult_dots = VGroup(quincunx_trip, fifteen)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(ops[0][0::2], UP),\n",
        "            FadeIn(sum_dots, DOWN),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(VGroup(*ops[1][:3], ops[1][4]), UP),\n",
        "            FadeIn(mult_dots, DOWN),\n",
        "            self.change_students(*3 * [\"erm\"], look_at=mult_dots),\n",
        "        )\n",
        "        self.wait(4)\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyMethod(mob.scale, 0, remover=True)\n",
        "                for mob in [*sum_dots, *mult_dots]\n",
        "            ]),\n",
        "            LaggedStart(*[\n",
        "                FadeIn(mob)\n",
        "                for mob in [*ops[0][0::2], *ops[1][:3], ops[1][4]]\n",
        "            ]),\n",
        "            self.change_students(*3 * [\"happy\"]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show group sum\n",
        "        flip_icon = get_flip_icon(0, snowflake)\n",
        "        rhs_icon = get_flip_icon(30 * DEGREES, snowflake)\n",
        "        rot_icon.generate_target()\n",
        "\n",
        "        group_prod = VGroup(\n",
        "            rot_icon.target,\n",
        "            OldTex(\"\\\\times\").scale(2),\n",
        "            flip_icon,\n",
        "            OldTex(\"=\").scale(2),\n",
        "            rhs_icon\n",
        "        )\n",
        "        group_prod.set_gloss(0)\n",
        "        for icon in group_prod[::2]:\n",
        "            icon[0].set_stroke(width=0)\n",
        "            icon[0].set_fill(GREY_A, 1)\n",
        "        group_prod.arrange(RIGHT)\n",
        "        group_prod.to_edge(UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(ops, RIGHT),\n",
        "            FadeOut(inclusion, LEFT),\n",
        "            MoveToTarget(rot_icon),\n",
        "            LaggedStartMap(FadeIn, group_prod[1:], lag_ratio=0.5, run_time=2),\n",
        "            self.change_students(\n",
        "                \"sassy\", \"erm\", \"confused\",\n",
        "                look_at=group_prod,\n",
        "            ),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        group_prod.replace_submobject(0, rot_icon)\n",
        "        self.add(group_prod)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Show successive actions\n",
        "        snowflake = get_snowflake()\n",
        "        snowflake.move_to(0.5 * UP)\n",
        "        snowflake.match_x(group_prod[1])\n",
        "        alt_flake = snowflake.copy()\n",
        "        alt_flake.match_x(rhs_icon)\n",
        "\n",
        "        self.play(\n",
        "            TransformFromCopy(rot_icon[0], snowflake)\n",
        "        )\n",
        "\n",
        "        def get_numbers(flake):\n",
        "            vect = 1.2 * (flake.get_top() - flake.get_center())\n",
        "            points = VGroup(*[\n",
        "                VectorizedPoint(rotate_vector(vect, angle))\n",
        "                for angle in np.arange(0, TAU, TAU / 6)\n",
        "            ])\n",
        "            points.move_to(flake)\n",
        "            numbers = VGroup(*[Integer(i + 1) for i in range(6)])\n",
        "            numbers.scale(0.5)\n",
        "            for num, point in zip(numbers, points):\n",
        "                num.point = point\n",
        "                num.add_updater(lambda m: m.move_to(m.point))\n",
        "            flake.add(points)\n",
        "            return numbers\n",
        "\n",
        "        sn_nums = get_numbers(snowflake)\n",
        "        as_nums = get_numbers(alt_flake)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(sn_nums, lag_ratio=0.1),\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=snowflake)\n",
        "        )\n",
        "        self.add(*sn_nums)\n",
        "        self.play(\n",
        "            Rotate(snowflake, PI, RIGHT),\n",
        "            ShowCreationThenFadeAround(flip_icon),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Rotate(snowflake, 60 * DEGREES),\n",
        "            ShowCreationThenFadeAround(rot_icon),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.look_at(\n",
        "            alt_flake,\n",
        "            added_anims=[TransformFromCopy(rhs_icon[0], alt_flake)]\n",
        "        )\n",
        "        self.play(FadeIn(as_nums, lag_ratio=0.1))\n",
        "        self.add(*as_nums)\n",
        "\n",
        "        line = rhs_icon.submobjects[-1].copy()\n",
        "        line.scale(2)\n",
        "        line.set_stroke(YELLOW, 3)\n",
        "        line.move_to(alt_flake)\n",
        "        self.play(ShowCreation(line))\n",
        "        self.play(\n",
        "            Rotate(alt_flake, PI, axis=line.get_vector())\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(line),\n",
        "            self.change_students(*3 * [\"thinking\"])\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class MultiplicationTable(Scene):\n",
        "    def construct(self):\n",
        "        # Grid\n",
        "        grid = VGroup(*[Square() for x in range(64)])\n",
        "        grid.arrange_in_grid(8, 8, buff=0)\n",
        "        grid.set_stroke(WHITE, 2)\n",
        "        grid.set_height(6.5)\n",
        "        grid.to_edge(DOWN, buff=0.5)\n",
        "        self.add(grid)\n",
        "\n",
        "        # Action icons\n",
        "        square = Square()\n",
        "        square.rotate(45 * DEGREES)\n",
        "        square.set_height(1)\n",
        "        square.set_fill(BLUE_D, 1)\n",
        "        icons = VGroup(\n",
        "            *[\n",
        "                get_rot_icon(deg, square)\n",
        "                for deg in [0, 90, 180, -90]\n",
        "            ] + [\n",
        "                get_flip_icon(angle, square, opacity=1)\n",
        "                for angle in np.arange(0, PI, PI / 4)\n",
        "            ]\n",
        "        )\n",
        "        icons[0].remove(icons[0][-1])\n",
        "        icons.match_height(grid[0])\n",
        "        icons.scale(0.8)\n",
        "        for icon in icons:\n",
        "            icon[0].rotate(-45 * DEGREES)\n",
        "\n",
        "        left_icons = icons.copy()\n",
        "        top_icons = icons.copy()\n",
        "\n",
        "        for icon_group, grid_group, vect in [(left_icons, grid[0::8], LEFT), (top_icons, grid[:8], UP)]:\n",
        "            for gs, icon in zip(grid_group, icon_group):\n",
        "                icon.shift(gs.get_edge_center(vect) - icon[0].get_center())\n",
        "                icon.shift(0.6 * gs.get_width() * vect)\n",
        "\n",
        "        for icon in top_icons:\n",
        "            icon[0].set_fill(GREY_BROWN)\n",
        "\n",
        "        self.add(left_icons, top_icons)\n",
        "\n",
        "        # Figure out full table\n",
        "        def pmult(perm1, perm2):\n",
        "            return [perm1[i] for i in perm2]\n",
        "\n",
        "        r = [1, 2, 3, 0]\n",
        "        s = [3, 2, 1, 0]\n",
        "        r2 = pmult(r, r)\n",
        "        r3 = pmult(r2, r)\n",
        "        perms = [\n",
        "            list(range(4)), r, r2, r3,\n",
        "            s,\n",
        "            pmult(r, s),\n",
        "            pmult(r2, s),\n",
        "            pmult(r3, s),\n",
        "        ]\n",
        "\n",
        "        table = np.zeros((8, 8), dtype=int)\n",
        "        table_icons = VGroup()\n",
        "        for n, square in enumerate(grid):\n",
        "            i = n // 8\n",
        "            j = n % 8\n",
        "            perm = pmult(perms[i], perms[j])\n",
        "            index = perms.index(perm)\n",
        "            table[i, j] = index\n",
        "            icon = icons[index].copy()\n",
        "            icon[0].set_color(BLUE_E)\n",
        "            icon.set_opacity(1)\n",
        "            icon.shift(square.get_center() - icon[0].get_center())\n",
        "\n",
        "            pre_icon = VGroup(icon.copy(), icon.copy())\n",
        "            pre_icon.save_state()\n",
        "            pre_icon.set_opacity(0)\n",
        "            pre_icon[0].move_to(left_icons[i])\n",
        "            pre_icon[1].move_to(top_icons[j])\n",
        "            icon.pre_icon = pre_icon\n",
        "\n",
        "            table_icons.add(icon)\n",
        "\n",
        "        # Show all product\n",
        "        sorted_icons = list(table_icons)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "        frame.save_state()\n",
        "        frame.scale(0.6)\n",
        "        frame.move_to(top_icons.get_top() + MED_SMALL_BUFF * UL, UP)\n",
        "\n",
        "        turn_animation_into_updater(Restore(frame, run_time=20, rate_func=bezier([0, 0, 1, 1])))\n",
        "        self.add(frame)\n",
        "\n",
        "        for sorted_index, icon in enumerate(sorted_icons):\n",
        "            n = table_icons.submobjects.index(icon)\n",
        "            i = n // 8\n",
        "            j = n % 8\n",
        "            rects = VGroup(\n",
        "                SurroundingRectangle(left_icons[i]),\n",
        "                SurroundingRectangle(top_icons[j]),\n",
        "                grid[n].copy().set_fill(GREEN_E, 0.5)\n",
        "            )\n",
        "            rects.set_stroke(YELLOW, 2)\n",
        "            self.add(rects, *self.mobjects)\n",
        "            self.add(icon)\n",
        "            if sorted_index < 8:\n",
        "                pass  # Don't wait\n",
        "            elif sorted_index < 24:\n",
        "                self.wait(1)\n",
        "            else:\n",
        "                self.wait(0.15)\n",
        "            self.remove(rects)\n",
        "        self.add(table_icons)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Symbolically\n",
        "        symbols = VGroup(\n",
        "            OldTex(\"1\"),\n",
        "            OldTex(\"r\"),\n",
        "            OldTex(\"r^2\"),\n",
        "            OldTex(\"r^3\"),\n",
        "            OldTex(\"s\"),\n",
        "            OldTex(\"rs\"),\n",
        "            OldTex(\"r^2 s\"),\n",
        "            OldTex(\"r^3 s\"),\n",
        "        )\n",
        "        symbols.set_height(0.4 * grid[0].get_height())\n",
        "\n",
        "        left_symbols = symbols.copy()\n",
        "        top_symbols = symbols.copy()\n",
        "        for symbol_group, icon_group in [(left_symbols, left_icons), (top_symbols, top_icons)]:\n",
        "            for symbol, icon in zip(symbol_group, icon_group):\n",
        "                symbol.move_to(icon[0], DOWN)\n",
        "\n",
        "        table_symbols = VGroup()\n",
        "        for n, icon in enumerate(table_icons):\n",
        "            i = n // 8\n",
        "            j = n % 8\n",
        "            symbol = symbols[table[i, j]].copy()\n",
        "            symbol.move_to(icon[0], DOWN)\n",
        "            table_symbols.add(symbol)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStart(*[\n",
        "                ApplyMethod(mob.scale, 0, remover=True)\n",
        "                for mob in [*left_icons, *top_icons, *table_icons]\n",
        "            ]),\n",
        "            LaggedStart(*[\n",
        "                GrowFromCenter(mob)\n",
        "                for mob in [*left_symbols, *top_symbols, *table_symbols]\n",
        "            ]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show some products\n",
        "        last_rects = VGroup()\n",
        "        for x in range(10):\n",
        "            n = random.randint(0, 63)\n",
        "            i = n // 8\n",
        "            j = n % 8\n",
        "            rects = VGroup(\n",
        "                SurroundingRectangle(left_symbols[i]),\n",
        "                SurroundingRectangle(top_symbols[j]),\n",
        "                grid[n].copy().set_stroke(YELLOW, 4).set_fill(YELLOW, 0.5)\n",
        "            )\n",
        "            self.add(rects, *self.mobjects)\n",
        "            self.play(\n",
        "                FadeOut(last_rects),\n",
        "                FadeIn(rects),\n",
        "            )\n",
        "            self.wait(2)\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class UsualMultiplicationTable(Scene):\n",
        "    def construct(self):\n",
        "        # Setup grid\n",
        "        grid = VGroup(*[\n",
        "            VGroup(*[Square() for x in range(4)]).arrange(RIGHT, buff=0)\n",
        "            for y in range(4)\n",
        "        ]).arrange(DOWN, buff=0)\n",
        "        grid.set_height(6)\n",
        "        grid.to_edge(DOWN, buff=0.5)\n",
        "        grid.set_fill(GREY_E, 1)\n",
        "        dots = VGroup(\n",
        "            *[Tex(\"\\\\dots\").scale(2).next_to(row, RIGHT) for row in grid[:-1]],\n",
        "            *[Tex(\"\\\\vdots\").scale(2).next_to(square, DOWN) for square in grid[-1][:-1]],\n",
        "            OldTex(\"\\\\ddots\").scale(2).next_to(grid[-1][-1], DR),\n",
        "        )\n",
        "\n",
        "        self.add(grid)\n",
        "\n",
        "        # Setup abstract dots\n",
        "        table_dots = VGroup()\n",
        "        for i, row in zip(it.count(1), grid):\n",
        "            for j, square in zip(it.count(1), row):\n",
        "                dots = VGroup(*[Dot() for x in range(i * j)])\n",
        "                dots.arrange_in_grid(i, j, buff=SMALL_BUFF)\n",
        "                dots.scale(0.9)\n",
        "                dots.move_to(square)\n",
        "                table_dots.add(dots)\n",
        "\n",
        "        left_dots = table_dots[0::4].copy()\n",
        "        left_dots.shift(grid[0][0].get_width() * LEFT)\n",
        "        left_dots.set_color(BLUE)\n",
        "\n",
        "        top_dots = table_dots[0:4].copy()\n",
        "        top_dots.shift(grid[0][0].get_height() * UP)\n",
        "        top_dots.set_color(RED)\n",
        "\n",
        "        dot_groups = VGroup(left_dots, top_dots, table_dots)\n",
        "\n",
        "        # Numerals\n",
        "        sym_groups = VGroup()\n",
        "        for dot_group in dot_groups:\n",
        "            sym_group = VGroup()\n",
        "            for dots in dot_group:\n",
        "                numeral = Integer(len(dots))\n",
        "                numeral.set_height(0.6)\n",
        "                numeral.move_to(dots)\n",
        "                numeral.match_color(dots)\n",
        "                sym_group.add(numeral)\n",
        "            sym_groups.add(sym_group)\n",
        "\n",
        "        left_syms, top_syms, table_syms = sym_groups\n",
        "\n",
        "        # Add symbols\n",
        "\n",
        "        self.add(left_syms, top_syms)\n",
        "        self.play(LaggedStart(*[\n",
        "            AnimationGroup(\n",
        "                Transform(ls_copies[i].copy(), table_syms[4 * i + j].copy(), remover=True),\n",
        "                Transform(ts_copies[j].copy(), table_syms[4 * i + j].copy(), remover=True),\n",
        "            )\n",
        "            for i, j in it.product(range(4), range(4))\n",
        "        ], lag_ratio=0.3))\n",
        "        self.add(table_syms)\n",
        "        self.wait()\n",
        "\n",
        "        # To dots\n",
        "        self.play(\n",
        "            FadeOut(sym_groups),\n",
        "            FadeIn(dot_groups),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show a few products\n",
        "        last_rects = VGroup()\n",
        "        ns = random.sample(range(16), 5)\n",
        "        for n in ns:\n",
        "            i = n // 4\n",
        "            j = n % 4\n",
        "            rects = VGroup(\n",
        "                SurroundingRectangle(left_dots[i]),\n",
        "                SurroundingRectangle(top_dots[j]),\n",
        "                grid[i][j].copy().set_fill(YELLOW, 0.5),\n",
        "            )\n",
        "            rects.set_stroke(YELLOW, 4)\n",
        "            self.play(FadeIn(rects), FadeOut(last_rects), run_time=0.5)\n",
        "            self.wait()\n",
        "            last_rects = rects\n",
        "        self.play(FadeOut(last_rects))\n",
        "\n",
        "        # Back to syms\n",
        "        self.play(\n",
        "            dot_groups.fade, 0.8,\n",
        "            FadeIn(sym_groups),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Benefits\n",
        "        frame = self.camera.frame\n",
        "        frame.generate_target()\n",
        "        frame.target.set_x(grid.get_right()[0])\n",
        "        frame.target.scale(1.1)\n",
        "\n",
        "        benefit = VGroup(\n",
        "            OldTexText(\"Abstraction\").scale(1.5),\n",
        "            Vector(DOWN),\n",
        "            OldTexText(\"Less cumbersome\").scale(1.5),\n",
        "        )\n",
        "        benefit.arrange(DOWN)\n",
        "        benefit.next_to(grid, RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        turn_animation_into_updater(MoveToTarget(frame, run_time=3))\n",
        "        self.add(frame)\n",
        "\n",
        "        self.play(Write(benefit[0]))\n",
        "        self.play(GrowArrow(benefit[1]))\n",
        "        self.play(FadeIn(benefit[2], UP))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MentionTheMonster(Scene):\n",
        "    def construct(self):\n",
        "        monster = get_monster()\n",
        "        monster.set_height(6)\n",
        "\n",
        "        self.add(monster)\n",
        "        self.wait()\n",
        "        self.play(blink_monster(monster))\n",
        "        self.wait()\n",
        "\n",
        "        size_label = get_monster_size_label()\n",
        "        size_label.match_height(monster)\n",
        "        size_label.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ApplyMethod(monster.next_to, size_label, LEFT, LARGE_BUFF, run_time=2),\n",
        "            ShowIncreasingSubsets(size_label, run_time=6)\n",
        "        )\n",
        "        self.play(blink_monster(monster))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class FrustratedAtGroups(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        formula = OldTex(r\"|G|=|Z(G)|+\\sum i\\left[G: C_{G}\\left(x_{i}\\right)\\right]\")\n",
        "        formula.move_to(self.hold_up_spot, DOWN)\n",
        "        formula.shift(0.5 * UL)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeIn(formula, DOWN),\n",
        "        )\n",
        "        self.play_student_changes(\"confused\", \"horrified\", \"pleading\")\n",
        "        self.look_at(formula.get_left())\n",
        "        self.wait(2)\n",
        "        self.look_at(formula.get_right())\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class WikiPageOnGroups(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AnalogyWithCounts(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        line = Line(LEFT, RIGHT)\n",
        "        words = OldTexText(\"Abstraction of\")\n",
        "        words.match_width(line)\n",
        "        words.scale(0.9)\n",
        "        words.next_to(line, UP, SMALL_BUFF)\n",
        "        line.add(words)\n",
        "        line.rotate(-90 * DEGREES)\n",
        "        line.scale(0.5)\n",
        "\n",
        "        diagrams = VGroup(*[\n",
        "            VGroup(mob1, line.copy(), mob2)\n",
        "            for mob1, mob2 in [\n",
        "                (OldTexText(\"Groups\"), OldTexText(\"Symmetry actions\")),\n",
        "                (OldTex(\"D_6\"), get_snowflake(height=1)),\n",
        "                (OldTexText(\"Numbers\"), OldTexText(\"Counts\")),\n",
        "                (OldTex(\"9\").scale(1.5), VGroup(*[Dot() for x in range(9)]).arrange_in_grid(buff=SMALL_BUFF)),\n",
        "            ]\n",
        "        ])\n",
        "        for diagram, vect in zip(diagrams, [LEFT, LEFT, RIGHT, RIGHT]):\n",
        "            diagram[0].set_color(YELLOW)\n",
        "            diagram[2].set_fill(BLUE)\n",
        "            diagram.arrange(DOWN)\n",
        "            diagram.scale(1.5)\n",
        "            diagram.shift(3.5 * vect - diagram[1].get_center())\n",
        "\n",
        "        # Show diagrams\n",
        "        self.add(diagrams[0][0])\n",
        "        self.play(\n",
        "            Write(diagrams[0][1]),\n",
        "            FadeIn(diagrams[0][2], 2 * UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*[\n",
        "            AnimationGroup(\n",
        "                ReplacementTransform(\n",
        "                    m2.copy().replace(m1, stretch=True).set_opacity(0),\n",
        "                    m2,\n",
        "                ),\n",
        "                Transform(\n",
        "                    m1.copy(),\n",
        "                    m1.copy().replace(m2, stretch=True).set_opacity(0),\n",
        "                    remover=True\n",
        "                )\n",
        "            )\n",
        "            for m1, m2 in zip(diagrams[0], diagrams[2])\n",
        "        ])\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(diagrams[0]),\n",
        "            FadeIn(diagrams[1]),\n",
        "        )\n",
        "        flake = diagrams[1][2]\n",
        "        self.add(flake)\n",
        "        self.play(\n",
        "            FadeOut(diagrams[2]),\n",
        "            FadeIn(diagrams[3]),\n",
        "            Rotate(flake, 60 * DEGREES),\n",
        "        )\n",
        "        self.play(Rotate(flake, PI, UP))\n",
        "        self.play(Rotate(flake, -120 * DEGREES))\n",
        "        self.play(Rotate(flake, PI, RIGHT))\n",
        "        self.play(Rotate(flake, 120 * DEGREES))\n",
        "        self.play(Rotate(flake, PI, UP))\n",
        "        self.play(\n",
        "            VFadeOut(diagrams[1]),\n",
        "            Rotate(flake, 180 * DEGREES),\n",
        "            FadeIn(diagrams[0]),\n",
        "            FadeOut(diagrams[3]),\n",
        "            FadeIn(diagrams[2]),\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class ButWhy(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"But, why?\",\n",
        "            target_mode=\"maybe\",\n",
        "            added_anims=[LaggedStart(\n",
        "                ApplyMethod(self.teacher.change, \"guilty\"),\n",
        "                ApplyMethod(self.students[0].change, \"confused\"),\n",
        "                ApplyMethod(self.students[1].change, \"sassy\"),\n",
        "                lag_ratio=0.5,\n",
        "            )]\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "class CubeRotations(ThreeDScene):\n",
        "    def construct(self):\n",
        "        # Set frame motion\n",
        "        frame = self.camera.frame\n",
        "        frame.set_euler_angles(phi=80 * DEGREES)\n",
        "        frame.add_updater(lambda m, sc=self: m.set_euler_angles(theta=-20 * DEGREES * np.cos(0.1 * sc.time)))\n",
        "        self.add(frame)\n",
        "\n",
        "        # Setup cube\n",
        "        cube = get_glassy_cube(frame)\n",
        "        cube.set_height(3)\n",
        "        axes = ThreeDAxes(axis_config={\"include_tip\": False})\n",
        "        axes.apply_depth_test()\n",
        "\n",
        "        self.add(axes)\n",
        "        self.add(cube)\n",
        "\n",
        "        # Apply rotations\n",
        "        quats = self.get_quaternions()\n",
        "        self.wait()\n",
        "        for quat in quats:\n",
        "            angle, axis = angle_axis_from_quaternion(quat)\n",
        "\n",
        "            line = Line3D(-5 * axis, 5 * axis, prefered_creation_axis=0)\n",
        "            line.set_color(YELLOW)\n",
        "            if angle < 1e-6:\n",
        "                line.scale(0)\n",
        "            # line.apply_depth_test()\n",
        "            deg_label = Integer(int(np.round(angle / DEGREES)), unit=\"^\\\\circ\")\n",
        "            deg_label.scale(2)\n",
        "            deg_label.to_edge(UP)\n",
        "            deg_label.shift(2 * LEFT)\n",
        "            deg_label.fix_in_frame()\n",
        "\n",
        "            self.add(line, *self.mobjects)\n",
        "            self.play(ShowCreation(line), FadeIn(deg_label))\n",
        "            self.play(Rotate(cube, angle, axis=axis))\n",
        "            line.scale(-1)\n",
        "            self.play(Uncreate(line), FadeOut(deg_label))\n",
        "\n",
        "    def get_quaternions(self, n_rotations=30):\n",
        "        ijk = [\n",
        "            quaternion_from_angle_axis(90 * DEGREES, axis)\n",
        "            for axis in [RIGHT, UP, OUT]\n",
        "        ]\n",
        "        result = []\n",
        "        for x in range(n_rotations):\n",
        "            n = random.randint(1, 10)\n",
        "            curr = quaternion_from_angle_axis(0, RIGHT)\n",
        "            for y in range(n):\n",
        "                curr = quaternion_mult(curr, random.choice(ijk))\n",
        "            result.append(curr)\n",
        "\n",
        "        # Add on those rotations around diagonals for the end\n",
        "        for oi in [OUT, IN]:\n",
        "            for vect in [UL, UR, DR, DL]:\n",
        "                result.append(quaternion_from_angle_axis(120 * DEGREES, vect + oi))\n",
        "        return result\n",
        "\n",
        "\n",
        "class QuadrupletShufflings(CubeRotations):\n",
        "    def construct(self):\n",
        "        # Background\n",
        "        bg_rect = FullScreenFadeRectangle()\n",
        "        bg_rect.set_fill(GREY_E, 1)\n",
        "        bg_rect.set_stroke(width=0)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        # Setup dots\n",
        "        dots = VGroup(*[Dot() for x in range(4)])\n",
        "        dots.set_height(0.5)\n",
        "        dots.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        dots.set_color(GREY_B)\n",
        "\n",
        "        for n, dot in enumerate(dots):\n",
        "            label = Integer(n + 1)\n",
        "            label.set_height(0.25)\n",
        "            label.set_color(BLACK)\n",
        "            label.move_to(dot)\n",
        "            dot.add(label)\n",
        "\n",
        "        self.add(dots)\n",
        "        self.wait()\n",
        "\n",
        "        # Permutations\n",
        "        for quat in self.get_quaternions():\n",
        "            perm = self.quaternion_to_perm(quat)\n",
        "\n",
        "            arrows = get_permutation_arrows(dots, perm)\n",
        "            self.play(FadeIn(arrows))\n",
        "            self.play(permutation_animation(dots, perm, lag_factor=0.2, run_time=1))\n",
        "            self.play(FadeOut(arrows))\n",
        "\n",
        "    def quaternion_to_perm(self, quat):\n",
        "        angle, axis = angle_axis_from_quaternion(quat)\n",
        "\n",
        "        base_vects = [UL, UR, DR, DL]\n",
        "        rot_vects = [\n",
        "            rotate_vector(v + OUT, angle, axis)\n",
        "            for v in base_vects\n",
        "        ]\n",
        "        perm = []\n",
        "        for vect in rot_vects:\n",
        "            if vect[2] < 0:\n",
        "                vect *= -1\n",
        "            vect[2] = 0\n",
        "            i = np.argmin([get_norm(vect - bv) for bv in base_vects])\n",
        "            perm.append(i)\n",
        "        return perm\n",
        "\n",
        "\n",
        "class EightShufflingsOfOrderThree(Scene):\n",
        "    def construct(self):\n",
        "        bg_rect = FullScreenFadeRectangle()\n",
        "        bg_rect.set_fill(GREY_E, 1)\n",
        "        bg_rect.set_stroke(width=0)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        # Setup dots\n",
        "        dots_template = VGroup(*[Dot() for x in range(4)])\n",
        "        dots_template.set_height(0.5)\n",
        "        dots_template.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        dots_template.set_color(GREY_B)\n",
        "\n",
        "        for n, dot in enumerate(dots_template):\n",
        "            label = Integer(n + 1)\n",
        "            label.set_height(0.25)\n",
        "            label.set_color(BLACK)\n",
        "            label.move_to(dot)\n",
        "            dot.add(label)\n",
        "\n",
        "        all_dots = VGroup(*[dots_template.copy() for x in range(8)])\n",
        "        all_dots.arrange_in_grid(4, 2, buff=1.25)\n",
        "        VGroup(all_dots[0::2], all_dots[1::2]).arrange(RIGHT, buff=2)\n",
        "\n",
        "        d_gen = iter(all_dots)\n",
        "        for trip in it.combinations(range(4), 3):\n",
        "            trip = np.array(trip)\n",
        "            perm1 = np.array(list(range(4)))\n",
        "            perm2 = np.array(list(range(4)))\n",
        "            perm1[trip] = trip[[1, 2, 0]]\n",
        "            perm2[trip] = trip[[2, 0, 1]]\n",
        "            for perm in [perm1, perm2]:\n",
        "                dots = next(d_gen)\n",
        "                arrows = get_permutation_arrows(dots, perm)\n",
        "                dots.add(arrows)\n",
        "                dots.perm = perm\n",
        "                for i in trip:\n",
        "                    dots[i].set_stroke(YELLOW, 1)\n",
        "                    dots[i][1].set_stroke(width=0)\n",
        "\n",
        "        self.play(ShowIncreasingSubsets(all_dots, run_time=4, rate_func=linear))\n",
        "        self.wait()\n",
        "        for x in range(3):\n",
        "            self.play(*[\n",
        "                permutation_animation(dots, dots.perm, lag_factor=0)\n",
        "                for dots in all_dots\n",
        "            ])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class Isomorphism(Scene):\n",
        "    def construct(self):\n",
        "        # Frame\n",
        "        frame = self.camera.frame\n",
        "        frame.focal_distance = 20\n",
        "\n",
        "        # Rotation equation\n",
        "        def get_rot_icon(angle=0, axis=OUT, frame=frame):\n",
        "            cube = get_glassy_cube(frame)\n",
        "            cube.set_height(1)\n",
        "            arc_arrows = VGroup(*[\n",
        "                Arrow(\n",
        "                    u * RIGHT,\n",
        "                    u * rotate_vector(RIGHT, 160 * DEGREES),\n",
        "                    buff=0,\n",
        "                    path_arc=160 * DEGREES,\n",
        "                    width=0.05,\n",
        "                )\n",
        "                for u in [1, -1]\n",
        "            ])\n",
        "            arc_arrows.set_color(GREY_B)\n",
        "            axis_line = DashedLine(IN, OUT)\n",
        "            axis_line.set_stroke(YELLOW, 2)\n",
        "\n",
        "            rot_icon = Group(arc_arrows, axis_line, cube)\n",
        "            rot_icon.set_gloss(0.5)\n",
        "            rot_icon.apply_depth_test()\n",
        "\n",
        "            rot_icon.rotate(angle, axis)\n",
        "            rot_icon.rotate(-15 * DEGREES, OUT)\n",
        "            rot_icon.rotate(75 * DEGREES, LEFT)\n",
        "\n",
        "            return rot_icon\n",
        "\n",
        "        rot_icon_equation = Group(\n",
        "            get_rot_icon(90 * DEGREES, UP),\n",
        "            OldTex(\"\\\\times\").scale(2),\n",
        "            get_rot_icon(90 * DEGREES, RIGHT),\n",
        "            OldTex(\"=\").scale(2),\n",
        "            get_rot_icon(0, OUT),\n",
        "        )\n",
        "        rot_icons = rot_icon_equation[0::2]\n",
        "        rot_icon_equation.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        rot_icon_equation.shift(1.5 * UP)\n",
        "\n",
        "        icon_labels = VGroup(*[\n",
        "            OldTexText(f\"$180^\\\\circ$ about\\\\\\\\{axis} axis\")\n",
        "            for axis in \"xyz\"\n",
        "        ])\n",
        "        for icon, label in zip(rot_icon_equation[0::2], icon_labels):\n",
        "            icon[-1][-1].set_opacity(0.5)\n",
        "            label.scale(0.8)\n",
        "            label.move_to(icon)\n",
        "            label.to_edge(UP)\n",
        "            icon.add(label)\n",
        "\n",
        "        # Permutation equation\n",
        "        dots = VGroup(*[Dot() for x in range(4)])\n",
        "        dots.set_height(0.4)\n",
        "        dots.set_color(GREY_B)\n",
        "        dots.arrange(RIGHT)\n",
        "        # for n, dot in enumerate(dots):\n",
        "        #     label = Integer(n + 1)\n",
        "        #     label.set_color(BLACK)\n",
        "        #     label.set_height(0.6 * dot.get_height())\n",
        "        #     label.move_to(dot)\n",
        "        #     dot.add(label)\n",
        "\n",
        "        perms = [\n",
        "            [1, 0, 3, 2],\n",
        "            [3, 2, 1, 0],\n",
        "            [2, 3, 0, 1],\n",
        "        ]\n",
        "        perm_terms = VGroup()\n",
        "        for perm in perms:\n",
        "            perm_term = VGroup(dots.copy(), get_permutation_arrows(dots, perm))\n",
        "            perm_term.perm = perm\n",
        "            perm_terms.add(perm_term)\n",
        "        perm_equation = VGroup(\n",
        "            perm_terms[0],\n",
        "            OldTex(\"\\\\times\").scale(2),\n",
        "            perm_terms[1],\n",
        "            OldTex(\"=\").scale(2),\n",
        "            perm_terms[2],\n",
        "        )\n",
        "        perm_equation.arrange(RIGHT, buff=LARGE_BUFF)\n",
        "        perm_equation.move_to(2 * DOWN)\n",
        "\n",
        "        # Bijection lines\n",
        "        bij_lines = VGroup()\n",
        "        for m1, m2 in zip(rot_icons, perm_terms):\n",
        "            line = Line(m1.get_bottom(), m2.get_top(), buff=0.2)\n",
        "            line.set_angle(-PI / 2, about_point=line.get_center())\n",
        "            bij_lines.add(line)\n",
        "\n",
        "        bij_lines.set_color(GREEN)\n",
        "\n",
        "        rot_icons[-1].match_x(bij_lines[2])\n",
        "\n",
        "        # Add terms\n",
        "        self.add(rot_icons)\n",
        "        for rot_icon, line, perm_term in zip(rot_icons, bij_lines, perm_terms):\n",
        "            self.play(\n",
        "                # FadeIn(rot_icon),\n",
        "                GrowFromPoint(line, line.get_top()),\n",
        "                FadeIn(perm_term, 2 * UP),\n",
        "            )\n",
        "        self.wait()\n",
        "        self.play(Write(VGroup(\n",
        "            *rot_icon_equation[1::2],\n",
        "            *perm_equation[1::2],\n",
        "        )))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Composition\n",
        "        rot_anims = [\n",
        "            AnimationGroup(\n",
        "                Rotate(rot_icon[2], PI, axis=rot_icon[1].get_vector()),\n",
        "                ShowCreationThenFadeAround(rot_icon[-1]),\n",
        "            )\n",
        "            for rot_icon in rot_icons\n",
        "        ]\n",
        "        perm_anims = [\n",
        "            permutation_animation(perm_term[0], perm_term.perm, lag_factor=0.1)\n",
        "            for perm_term in perm_terms\n",
        "        ]\n",
        "\n",
        "        self.play(rot_anims[1])\n",
        "        self.play(rot_anims[0])\n",
        "        self.wait()\n",
        "        self.play(rot_anims[2])\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(ShowCreation, bij_lines, lag_ratio=0.5))\n",
        "        self.wait()\n",
        "        self.play(perm_anims[1])\n",
        "        self.play(perm_anims[0])\n",
        "        self.wait()\n",
        "        self.play(perm_anims[2])\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class IsomorphismWord(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"``Isomorphism''\")\n",
        "        word.scale(2)\n",
        "        word.to_edge(UP)\n",
        "        self.play(FadeIn(word, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AskAboutCubeDiagonals(QuadrupletShufflings):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        frame = self.camera.frame\n",
        "        frame.set_euler_angles(phi=80 * DEGREES)\n",
        "        frame.add_updater(lambda m, sc=self: m.set_euler_angles(theta=-20 * DEGREES * np.cos(0.1 * sc.time)))\n",
        "\n",
        "        cube = get_glassy_cube(frame)\n",
        "        cube.set_height(3)\n",
        "        axes = ThreeDAxes(axis_config={\"include_tip\": False})\n",
        "\n",
        "        colors = [RED, GREEN, BLUE, YELLOW]\n",
        "        diagonals = Group(*[\n",
        "            Line3D(vect + OUT, -vect - OUT, color=color)\n",
        "            for color, vect in zip(colors, [UL, UR, DR, DL])\n",
        "        ])\n",
        "        diagonals.match_height(cube.edge_rods)\n",
        "\n",
        "        diag_markers = Group(*[\n",
        "            Line3D(ORIGIN, UP, color=color)\n",
        "            for color in colors\n",
        "        ])\n",
        "        diag_markers.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        diag_markers.to_corner(UL, buff=LARGE_BUFF)\n",
        "        diag_markers.fix_in_frame()\n",
        "\n",
        "        # Color corners\n",
        "        cds = cube.corner_dots\n",
        "        for diag in diagonals:\n",
        "            globals()['diag'] = diag\n",
        "            Group(*[\n",
        "                cds[np.argmin([get_norm(cd.get_center() - diag.get_points()[i]) for cd in cds])]\n",
        "                for i in [0, -1]\n",
        "            ]).match_color(diag)\n",
        "\n",
        "        cube.add_to_back(diagonals)\n",
        "\n",
        "        # Rotations\n",
        "        self.add(axes, cube)\n",
        "        self.add(diag_markers)\n",
        "        self.add(frame)\n",
        "        for quat in self.get_quaternions():\n",
        "            angle, axis = angle_axis_from_quaternion(quat)\n",
        "            perm = self.quaternion_to_perm(quat)\n",
        "            perm_arrows = get_permutation_arrows(diag_markers, perm)\n",
        "            perm_arrows.fix_in_frame()\n",
        "\n",
        "            self.play(FadeIn(perm_arrows))\n",
        "            self.play(\n",
        "                Rotate(cube, angle, axis=axis),\n",
        "                permutation_animation(diag_markers, perm, lag_factor=0.1),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.play(FadeOut(perm_arrows))\n",
        "            self.wait()\n",
        "\n",
        "            inv_perm = self.quaternion_to_perm(quaternion_conjugate(quat))\n",
        "            diag_markers.set_submobjects([diag_markers[i] for i in inv_perm])\n",
        "\n",
        "\n",
        "class S4WithMultipleChildren(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        bg_rect = FullScreenFadeRectangle()\n",
        "        bg_rect.set_fill(GREY_E, 1)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        s_rects = VGroup(*[ScreenRectangle() for x in range(3)])\n",
        "        s_rects.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        s_rects.set_width(FRAME_WIDTH - 1)\n",
        "        s_rects.set_stroke(WHITE, 2)\n",
        "        s_rects.set_fill(BLACK, 1)\n",
        "        s_rects.move_to(DOWN)\n",
        "        self.add(s_rects)\n",
        "\n",
        "        s4_label = OldTex(\"S_4\")\n",
        "        s4_label.scale(2)\n",
        "        s4_label.to_edge(UP)\n",
        "\n",
        "        lines = VGroup(*[\n",
        "            Line(rect.get_top(), s4_label.get_bottom(), buff=0.2)\n",
        "            for rect in s_rects\n",
        "        ])\n",
        "\n",
        "        # Arising\n",
        "        self.play(LaggedStartMap(ShowCreation, lines, lag_ratio=0.5))\n",
        "        self.play(FadeIn(s4_label, DOWN))\n",
        "        self.wait(2)\n",
        "\n",
        "        # Triplets\n",
        "        three = Integer(3)\n",
        "        three.scale(2)\n",
        "        three.move_to(s4_label)\n",
        "\n",
        "        pis = VGroup(*[Randolph(color=c) for c in [BLUE_C, BLUE_E, BLUE_D]])\n",
        "        pis.arrange(RIGHT)\n",
        "        vects = VGroup(*[Vector(RIGHT) for x in range(3)])\n",
        "        vects.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        vects.rotate(30 * DEGREES)\n",
        "        vects.set_color(TEAL)\n",
        "        triangle = RegularPolygon(3)\n",
        "        triangle.set_stroke(BLUE_B, 4)\n",
        "        triangle.add(*[Dot(vert, color=BLUE_D) for vert in triangle.get_vertices()])\n",
        "        triangle.set_stroke(background=True)\n",
        "        triplets = VGroup(pis, vects, triangle)\n",
        "\n",
        "        for trip, rect in zip(triplets, s_rects):\n",
        "            trip.set_width(0.8 * rect.get_width())\n",
        "            if trip.get_height() > 0.8 * rect.get_height():\n",
        "                trip.set_height(0.8 * rect.get_height())\n",
        "            trip.move_to(rect)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(s4_label, UP),\n",
        "            FadeIn(three, DOWN),\n",
        "            LaggedStartMap(FadeIn, pis, lag_ratio=0.5, run_time=1),\n",
        "        )\n",
        "        for trip in triplets[1:]:\n",
        "            self.play(FadeIn(trip, lag_ratio=0.5))\n",
        "        self.play(Blink(pis[0]))\n",
        "        self.play(Blink(pis[2]))\n",
        "\n",
        "        # Back to s4\n",
        "        self.play(\n",
        "            FadeOut(three, DOWN),\n",
        "            FadeIn(s4_label, UP),\n",
        "            FadeOut(triplets, lag_ratio=0.2, run_time=2),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AutQ8(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTex(\"\\\\text{Aut}(Q_8)\", tex_to_color_map={\"Q_8\": BLUE})\n",
        "        tex.scale(2)\n",
        "        self.play(Write(tex))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class GroupsBeyondActions(Scene):\n",
        "    def construct(self):\n",
        "        groups = OldTexText(\"Groups\")\n",
        "        sym_acts = OldTexText(\"Symmetric\\\\\\\\Actions\")\n",
        "        others = OldTexText(\"Other things\\\\\\\\which ``multiply''\")\n",
        "        VGroup(groups, sym_acts, others).scale(1.5)\n",
        "        line = Line(UP, DOWN)\n",
        "\n",
        "        sym_acts.set_color(BLUE)\n",
        "        others.set_color(interpolate_color(GREY_BROWN, WHITE, 0.5))\n",
        "\n",
        "        VGroup(\n",
        "            groups, line, sym_acts\n",
        "        ).arrange(DOWN, buff=MED_LARGE_BUFF)\n",
        "\n",
        "        line.add_updater(lambda m: m.put_start_and_end_on(\n",
        "            groups.get_bottom() + 0.3 * DOWN,\n",
        "            sym_acts.get_top() + 0.3 * UP,\n",
        "        ))\n",
        "\n",
        "        others.move_to(sym_acts)\n",
        "        others.to_edge(RIGHT)\n",
        "        others_line = Line(groups.get_bottom(), others.get_top(), buff=0.3)\n",
        "\n",
        "        self.add(groups, line, sym_acts)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            sym_acts.to_edge, LEFT, LARGE_BUFF,\n",
        "            FadeIn(others, 2 * UL),\n",
        "            ShowCreation(others_line),\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RAddToRMult(ExternallyAnimatedScene):\n",
        "    pass\n",
        "\n",
        "\n",
        "class AskAboutAllTheGroups(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        # Ask\n",
        "        question = OldTexText(\"What are all the groups\", \"?\")\n",
        "        self.teacher_holds_up(question)\n",
        "        self.play_student_changes(\"pondering\", \"thinking\", \"erm\")\n",
        "        self.wait(2)\n",
        "\n",
        "        question.generate_target()\n",
        "        question.target.to_corner(UL)\n",
        "        self.teacher_says(\n",
        "            \"Now you can\\\\\\\\ask something\\\\\\\\more sophisticated.\",\n",
        "            target_mode=\"hooray\",\n",
        "            added_anims=[\n",
        "                MoveToTarget(question, run_time=2),\n",
        "                self.change_students(\n",
        "                    \"erm\", \"pondering\", \"pondering\",\n",
        "                    look_at=question.target\n",
        "                )\n",
        "            ]\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode=\"tease\",\n",
        "                look_at=question.get_right(),\n",
        "            ),\n",
        "            question.set_x, 0,\n",
        "        )\n",
        "\n",
        "        # Add up to isomorphism\n",
        "        caveat = OldTexText(\"up to \\\\emph{isomorphism}\")\n",
        "        caveat.next_to(question, DOWN)\n",
        "        caveat.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            Write(caveat, run_time=1),\n",
        "            question[1].next_to, caveat[0][-1], RIGHT, SMALL_BUFF, DOWN,\n",
        "            question[1].match_color, caveat,\n",
        "            self.change_students(*3 * [\"thinking\"], look_at=question)\n",
        "        )\n",
        "        question.add(caveat)\n",
        "        self.wait(2)\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(2)\n",
        "        self.look_at(question)\n",
        "\n",
        "        # Alt question\n",
        "        sym_question = OldTexText(\"What are all the\\\\\\\\\", \"symmetric\", \" things\", \"?\")\n",
        "        self.teacher_holds_up(sym_question)\n",
        "\n",
        "        cross = Cross(sym_question)\n",
        "        self.look_at(\n",
        "            cross,\n",
        "            added_anims=[\n",
        "                ShowCreation(cross),\n",
        "                self.change_students(\"erm\", \"sassy\", \"hesitant\")\n",
        "            ]\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        abs_question = OldTexText(\"What are all the\", \" \\\\emph{ways}\\\\\\\\\", \"things \", \"can be \", \"symmetric\", \"?\")\n",
        "        new_words = VGroup(abs_question[1], abs_question[3])\n",
        "        new_words.match_color(caveat)\n",
        "        abs_question.move_to(sym_question)\n",
        "        abs_question.shift_onto_screen()\n",
        "        self.play(\n",
        "            *[\n",
        "                ReplacementTransform(sym_question[i], abs_question[j], path_arc=10 * DEGREES)\n",
        "                for i, j in [(0, 0), (1, 4), (2, 2), (3, 5)]\n",
        "            ],\n",
        "            FadeOut(cross),\n",
        "            self.change_students(\"happy\", \"thinking\", \"tease\"),\n",
        "        )\n",
        "        self.play(\n",
        "            self.teacher.change, \"speaking\", abs_question,\n",
        "            Write(new_words),\n",
        "        )\n",
        "        self.look_at(abs_question)\n",
        "        self.wait(2)\n",
        "\n",
        "        # Formula\n",
        "        suggestions = VGroup(*[\n",
        "            OldTexText(\"Some \", word, \"?\", tex_to_color_map={word: color})\n",
        "            for word, color in [\n",
        "                (\"formula\", RED),\n",
        "                (\"procedure\", MAROON_B),\n",
        "                (\"algorithm\", PINK),\n",
        "            ]\n",
        "        ])\n",
        "        for words in suggestions:\n",
        "            words.move_to(abs_question, UP)\n",
        "            words.to_edge(LEFT, buff=LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(suggestions[0], DOWN),\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=suggestions),\n",
        "            self.teacher.change, \"happy\",\n",
        "        )\n",
        "        self.wait()\n",
        "        for words1, words2 in zip(suggestions, suggestions[1:]):\n",
        "            self.play(\n",
        "                FadeOut(words1[1], UP),\n",
        "                FadeIn(words2[1], DOWN),\n",
        "                ReplacementTransform(words1[2], words2[2])\n",
        "            )\n",
        "            self.remove(words1)\n",
        "            self.add(words2)\n",
        "            self.wait()\n",
        "        self.wait(3)\n",
        "        self.play(\n",
        "            FadeOut(\n",
        "                VGroup(question, abs_question, suggestions[-1]),\n",
        "                0.5 * DOWN,\n",
        "                lag_ratio=0.02,\n",
        "                run_time=2,\n",
        "            )\n",
        "        )\n",
        "\n",
        "\n",
        "class ThisQuestionIsHard(Scene):\n",
        "    def construct(self):\n",
        "        # Setup line\n",
        "        line = NumberLine(x_range=(0, 1, 0.1), width=12)\n",
        "        line.shift(UP)\n",
        "        arrows = VGroup(\n",
        "            Arrow(line.n2p(0.5), line.n2p(0), fill_color=GREEN),\n",
        "            Arrow(line.n2p(0.5), line.n2p(1), fill_color=RED),\n",
        "        )\n",
        "        arrows.shift(2.5 * DOWN)\n",
        "        words = VGroup(OldTexText(\"Easier\"), OldTexText(\"Harder\"))\n",
        "        for word, arrow in zip(words, arrows):\n",
        "            word.match_color(arrow)\n",
        "            word.next_to(arrow, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.add(line)\n",
        "        self.add(arrows)\n",
        "        self.add(words)\n",
        "\n",
        "        # Add problems\n",
        "        problems = VGroup(\n",
        "            OldTex(\"1 + 1\"),\n",
        "            VGroup(\n",
        "                OldTex(\"\\\\frac{2^{289}+1}{2^{17}+1}=2^{a_{1}}+\\\\ldots+2^{a_{k}}\"),\n",
        "                OldTex(\"a_1 < \\\\ldots < a_k\"),\n",
        "                OldTex(\"a_1, \\\\dots, a_k \\\\in \\\\mathds{Z}^+\"),\n",
        "            ),\n",
        "            VGroup(\n",
        "                OldTex(\"{a \\\\over b + c} + {b \\\\over c + a} + {c \\\\over b + c} = 4\"),\n",
        "                OldTex(\"a, b, c \\\\in \\\\mathds{Z}^+\"),\n",
        "            ),\n",
        "            VGroup(\n",
        "                OldTex(\"x^n + y^n = z^n\"),\n",
        "                OldTex(\"x, y, z \\\\in \\\\mathds{Z}\"),\n",
        "            ),\n",
        "        )\n",
        "        colors = Color(GREEN).range_to(RED, 4)\n",
        "        for prob, x, color in zip(problems, [0, 0.3, 0.7, 1], colors):\n",
        "            triangle = Triangle()\n",
        "            triangle.set_height(0.2)\n",
        "            triangle.set_stroke(width=0)\n",
        "            triangle.set_fill(color, 1)\n",
        "            triangle.move_to(line.n2p(x), UP)\n",
        "            prob.arrange(DOWN)\n",
        "            prob.scale(0.5)\n",
        "            prob.next_to(triangle, DOWN)\n",
        "            prob.add(triangle)\n",
        "            prob.set_color(color)\n",
        "\n",
        "        self.add(problems)\n",
        "\n",
        "        # Group question\n",
        "        tri = Triangle(start_angle=-90 * DEGREES)\n",
        "        tri.set_height(0.3)\n",
        "        tri.set_stroke(width=0)\n",
        "        tri.set_fill(GREY_B, 1)\n",
        "        tri.move_to(line.n2p(0.5), DOWN)\n",
        "        question = OldTexText(\"What are all\\\\\\\\the groups?\")\n",
        "        question.next_to(tri, UP)\n",
        "\n",
        "        ext_line = line.copy()\n",
        "        ext_line.move_to(line.get_right(), LEFT)\n",
        "\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        self.play(\n",
        "            DrawBorderThenFill(tri),\n",
        "            FadeIn(question, DOWN)\n",
        "        )\n",
        "        question.add(tri)\n",
        "        self.play(question.move_to, line.n2p(0.9), DOWN)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(ext_line),\n",
        "            question.move_to, line.n2p(1.3), DOWN,\n",
        "            ApplyMethod(frame.scale, 1.3, {\"about_edge\": LEFT}, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class AmbientSnowflakeSymmetries(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTex(\"D_6\")\n",
        "        title.scale(3)\n",
        "        title.to_edge(LEFT, buff=1)\n",
        "        title.set_color(BLUE)\n",
        "        self.add(title)\n",
        "\n",
        "        snowflake = get_snowflake()\n",
        "        snowflake.set_height(5)\n",
        "        snowflake.set_stroke(width=0)\n",
        "        snowflake.move_to(2 * RIGHT)\n",
        "        self.add(snowflake)\n",
        "\n",
        "        for n in range(10):\n",
        "            if random.choice([True, False]):\n",
        "                deg = random.choice([-120, -60, 60, 120])\n",
        "                icon = get_rot_icon(deg, snowflake, snowflake.get_height())\n",
        "                anim = Rotate(snowflake, deg * DEGREES)\n",
        "            else:\n",
        "                deg = random.choice(range(30, 180, 30))\n",
        "                angle = deg * DEGREES\n",
        "                icon = get_flip_icon(angle, snowflake, mini_mob_height=snowflake.get_height())\n",
        "                anim = Rotate(snowflake, PI, axis=rotate_vector(RIGHT, angle))\n",
        "            icon.shift(snowflake.get_center() - icon[0].get_center())\n",
        "            self.play(anim, FadeIn(icon[1:]))\n",
        "            self.play(FadeOut(icon[1:]))\n",
        "\n",
        "\n",
        "class IntroduceSimpleGroups(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        bg_rect = FullScreenFadeRectangle(fill_color=GREY_E, fill_opacity=1)\n",
        "        self.add(bg_rect)\n",
        "\n",
        "        groups = OldTexText(\"Groups\")\n",
        "        groups.scale(2)\n",
        "        groups.to_edge(UP)\n",
        "        inf_groups = OldTexText(\"Infinite groups\")\n",
        "        fin_groups = OldTexText(\"Finite groups\")\n",
        "        children = VGroup(inf_groups, fin_groups)\n",
        "        children.scale(1.5)\n",
        "        children.arrange(RIGHT, buff=2)\n",
        "        children.next_to(groups, DOWN, buff=2)\n",
        "        child_lines = VGroup(*[\n",
        "            Line(groups.get_bottom(), child.get_top(), buff=0)\n",
        "            for child in children\n",
        "        ])\n",
        "        child_lines.set_stroke(WHITE, 2)\n",
        "        s_rects = VGroup(*[\n",
        "            ScreenRectangle(height=3).move_to(child)\n",
        "            for child in children\n",
        "        ])\n",
        "        s_rects.next_to(children, DOWN)\n",
        "        s_rects.set_fill(BLACK, 1)\n",
        "\n",
        "        # Introductions\n",
        "        self.add(groups)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(child_lines[0]),\n",
        "            FadeIn(inf_groups, 2 * UR),\n",
        "            FadeIn(s_rects[0])\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            ShowCreation(child_lines[1]),\n",
        "            FadeIn(fin_groups, 2 * UL),\n",
        "            FadeIn(s_rects[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.add(s_rects, fin_groups)\n",
        "        self.play(\n",
        "            Uncreate(child_lines),\n",
        "            FadeOut(inf_groups, 3 * LEFT),\n",
        "            FadeOut(s_rects[0], 3 * LEFT),\n",
        "            FadeOut(groups, 2 * UP),\n",
        "            fin_groups.move_to, groups,\n",
        "            s_rects[1].replace, bg_rect,\n",
        "            s_rects[1].set_stroke, {\"width\": 0},\n",
        "            run_time=2,\n",
        "        )\n",
        "        self.remove(s_rects, bg_rect)\n",
        "\n",
        "        # Comparison titles\n",
        "        bg_rects = VGroup(*[\n",
        "            Rectangle(\n",
        "                height=FRAME_HEIGHT,\n",
        "                width=FRAME_WIDTH / 3,\n",
        "                fill_color=color,\n",
        "                fill_opacity=1,\n",
        "                stroke_width=0\n",
        "            )\n",
        "            for color in [GREY_D, GREY_E, BLACK]\n",
        "        ])\n",
        "        bg_rects.arrange(RIGHT, buff=0)\n",
        "        bg_rects.center()\n",
        "\n",
        "        fin_groups.generate_target()\n",
        "        titles = VGroup(\n",
        "            OldTexText(\"Integers\").scale(1.5),\n",
        "            OldTexText(\"Molecules\").scale(1.5),\n",
        "            fin_groups.target,\n",
        "        )\n",
        "        sub_titles = VGroup(*[\n",
        "            OldTexText(\"break down into\\\\\\\\\", word)\n",
        "            for word in (\"primes\", \"atoms\", \"simple groups\")\n",
        "        ])\n",
        "\n",
        "        for rect, title, sub_title in zip(bg_rects, titles, sub_titles):\n",
        "            title.move_to(rect, UP)\n",
        "            title.shift(0.5 * DOWN)\n",
        "            sub_title.next_to(title, DOWN)\n",
        "            sub_title[1].set_color(BLUE)\n",
        "            sub_title.align_to(sub_titles[0], UP)\n",
        "\n",
        "        # Comparison diagrams\n",
        "        H_sphere = Sphere()\n",
        "        H_sphere.set_height(0.5)\n",
        "        H_sphere.set_color(RED)\n",
        "        H_atom = Group(\n",
        "            H_sphere,\n",
        "            OldTexText(\"H\").scale(0.5).move_to(H_sphere)\n",
        "        )\n",
        "        O_sphere = Sphere()\n",
        "        O_sphere.set_height(1)\n",
        "        O_sphere.set_color(BLUE)\n",
        "        O_atom = Group(\n",
        "            O_sphere,\n",
        "            OldTexText(\"O\").scale(0.75).move_to(O_sphere)\n",
        "        )\n",
        "        H2O = Group(\n",
        "            O_atom.copy(),\n",
        "            H_atom.copy().move_to([-0.45, 0.35, 0]),\n",
        "            H_atom.copy().move_to([0.45, 0.35, 0]),\n",
        "        )\n",
        "\n",
        "        trees = Group(\n",
        "            VGroup(\n",
        "                Integer(60),\n",
        "                VGroup(*map(Integer, [2, 2, 3, 5])),\n",
        "            ),\n",
        "            Group(\n",
        "                H2O,\n",
        "                Group(H_atom.copy(), H_atom.copy(), O_atom.copy())\n",
        "            ),\n",
        "            VGroup(\n",
        "                OldTex(\"S_4\"),\n",
        "                VGroup(*[\n",
        "                    OldTex(\n",
        "                        \"C_\" + str(n),\n",
        "                        fill_color=(RED_B if n == 2 else BLUE)\n",
        "                    )\n",
        "                    for n in [2, 2, 2, 3]\n",
        "                ]),\n",
        "            )\n",
        "        )\n",
        "        for tree, rect in zip(trees, bg_rects):\n",
        "            root, children = tree\n",
        "            children.arrange(RIGHT, buff=0.35)\n",
        "            children.next_to(root, DOWN, buff=1.2)\n",
        "            lines = VGroup()\n",
        "            for child in children:\n",
        "                lines.add(Line(root.get_bottom(), child.get_top(), buff=0.1))\n",
        "            tree.add(lines)\n",
        "            tree.move_to(rect)\n",
        "            tree.shift(DOWN)\n",
        "\n",
        "        # Slice screen\n",
        "        self.add(bg_rects, fin_groups)\n",
        "        for rect in bg_rects:\n",
        "            rect.save_state()\n",
        "            rect.shift(LEFT)\n",
        "            rect.set_fill(BLACK, 1)\n",
        "        self.play(\n",
        "            MoveToTarget(fin_groups),\n",
        "            LaggedStartMap(Restore, bg_rects, lag_ratio=0.3)\n",
        "        )\n",
        "\n",
        "        # Breakdowns\n",
        "        for title, sub_title, tree in zip(titles, sub_titles, trees):\n",
        "            root, children, lines = tree\n",
        "            self.play(\n",
        "                FadeIn(title),\n",
        "                FadeIn(root),\n",
        "            )\n",
        "            globals()['root'] = root\n",
        "            self.play(\n",
        "                ShowCreation(lines),\n",
        "                LaggedStart(*[\n",
        "                    GrowFromPoint(child, root)\n",
        "                    for child in children\n",
        "                ]),\n",
        "                FadeIn(sub_title)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        # Theorem\n",
        "        theorem_name = OldTexText(\"(Jordan\u2013H\u00f6lder Theorem)\")\n",
        "        theorem_name.scale(0.7)\n",
        "        theorem_name.next_to(sub_titles[2], DOWN)\n",
        "        self.play(Write(theorem_name, run_time=1))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class SymmetriesOfCirleAndLine(Scene):\n",
        "    def construct(self):\n",
        "        line = NumberLine((0, 100, 1))\n",
        "        line.move_to(2 * UP)\n",
        "\n",
        "        circle = Circle(radius=1)\n",
        "        circle_ticks = VGroup(*[\n",
        "            Line(0.95 * vect, 1.05 * vect)\n",
        "            for vect in compass_directions(12)\n",
        "        ])\n",
        "        circle.add(circle_ticks)\n",
        "        circle.set_stroke(BLUE, 3)\n",
        "        circle.scale(1.5)\n",
        "        circle.next_to(line, DOWN, buff=2)\n",
        "        circle.shift(RIGHT)\n",
        "\n",
        "        R_label = OldTex(\"\\\\mathds{R}\")\n",
        "        RmodZ = OldTex(\"\\\\mathds{R} / \\\\mathds{Z}\")\n",
        "        R_label.set_height(0.9)\n",
        "        R_label.next_to(line, UP, MED_LARGE_BUFF)\n",
        "        RmodZ.set_height(0.9)\n",
        "        RmodZ.next_to(circle, LEFT, LARGE_BUFF)\n",
        "        R_label.match_x(RmodZ)\n",
        "\n",
        "        self.add(line)\n",
        "        self.add(circle)\n",
        "        self.add(R_label)\n",
        "        self.add(RmodZ)\n",
        "\n",
        "        # Rotations and shifts\n",
        "        for n in range(10):\n",
        "            x = interpolate(-20, 20, random.random())\n",
        "            self.play(\n",
        "                line.shift, x * RIGHT,\n",
        "                Rotate(circle, -x / PI),\n",
        "                run_time=2,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        self.embed()\n",
        "\n",
        "\n",
        "class QuinticImpliesCyclicDecomposition(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        title = OldTexText(\"Quintic formula\")\n",
        "        title.scale(1.5)\n",
        "        title.to_edge(UP)\n",
        "        details = OldTexText(\n",
        "            \"Solve \",\n",
        "            \"$a_5 x^5 + a_4 x^4 + a_3 x^3 + a_2 x^2 + a_1 x + a_0$\\\\\\\\\",\n",
        "            \" using only \",\n",
        "            \"+, -, $\\\\times$, $/$, and $\\\\sqrt[n]{\\\\quad}$\"\n",
        "        )\n",
        "        details[1].set_color(BLUE)\n",
        "        details[3].set_color(TEAL)\n",
        "        details.match_width(title)\n",
        "        details.scale(1.2)\n",
        "        details.next_to(title, DOWN)\n",
        "\n",
        "        self.clear()\n",
        "        self.add(title)\n",
        "        self.wait()\n",
        "        self.play(FadeIn(details, 0.5 * UP))\n",
        "        self.wait()\n",
        "\n",
        "        full_title = VGroup(title, details)\n",
        "\n",
        "        # Show Implication\n",
        "        implies = OldTex(\"\\\\Downarrow\").scale(2)\n",
        "        implies.next_to(details, DOWN, LARGE_BUFF)\n",
        "\n",
        "        s5 = OldTex(\"S_5\")\n",
        "        prime_children = VGroup(\n",
        "            OldTex(\"C_{p_1}\"),\n",
        "            OldTex(\"C_{p_2}\"),\n",
        "            OldTex(\"\\\\vdots\"),\n",
        "            OldTex(\"C_{p_n}\"),\n",
        "        )\n",
        "        prime_children.set_color(RED_B)\n",
        "\n",
        "        real_children = VGroup(\n",
        "            OldTex(\"A_5\"),\n",
        "            OldTex(\"C_2\"),\n",
        "        )\n",
        "        real_children.set_color(GREEN)\n",
        "\n",
        "        for children, buff in (prime_children, MED_LARGE_BUFF), (real_children, LARGE_BUFF):\n",
        "            children.arrange(DOWN, buff=buff, aligned_edge=LEFT)\n",
        "            children.next_to(s5, RIGHT, buff=0.5 + 0.25 * len(children))\n",
        "            children.lines = VGroup()\n",
        "            for child in children:\n",
        "                children.lines.add(\n",
        "                    Line(s5.get_right(), child.get_left(), buff=0.1)\n",
        "                )\n",
        "        prime_children[2].shift(SMALL_BUFF * RIGHT)\n",
        "\n",
        "        VGroup(\n",
        "            s5, prime_children.lines, prime_children,\n",
        "            real_children.lines, real_children,\n",
        "        ).next_to(implies, DOWN)\n",
        "\n",
        "        # Show decomps\n",
        "        implies.save_state()\n",
        "        implies.stretch(0, 1, about_edge=UP)\n",
        "        self.play(\n",
        "            Restore(implies),\n",
        "            GrowFromPoint(s5, implies.get_top()),\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, prime_children.lines, lag_ratio=0.3),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, prime_children,\n",
        "                lambda m: (m, s5.get_right() - m.get_center()),\n",
        "                lag_ratio=0.3,\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(prime_children, RIGHT),\n",
        "            *[\n",
        "                ApplyMethod(line.scale, 0, {\"about_point\": line.get_end()}, remover=True)\n",
        "                for line in prime_children.lines\n",
        "            ],\n",
        "            LaggedStartMap(ShowCreation, real_children.lines, lag_ratio=0.3),\n",
        "            LaggedStartMap(\n",
        "                FadeIn, real_children,\n",
        "                lambda m: (m, s5.get_right() - m.get_center()),\n",
        "                lag_ratio=0.3,\n",
        "            )\n",
        "        )\n",
        "        self.play(ShowCreationThenFadeAround(real_children[0]))\n",
        "\n",
        "        # Reverse implication\n",
        "        title_rect = SurroundingRectangle(full_title)\n",
        "        title_rect.set_stroke(RED, 2)\n",
        "        not_exists = OldTexText(\"No\\\\\\\\such\\\\\\\\thing\")\n",
        "        not_exists.match_height(title_rect)\n",
        "        not_exists.set_color(RED)\n",
        "        not_exists.next_to(title_rect, LEFT)\n",
        "        full_title.add(title_rect, not_exists)\n",
        "\n",
        "        self.play(\n",
        "            Rotate(implies, PI),\n",
        "            VFadeIn(title_rect),\n",
        "            VFadeIn(not_exists),\n",
        "            full_title.shift, 0.5 * RIGHT,\n",
        "        )\n",
        "\n",
        "\n",
        "class CommentOnNontrivialFactFromGroupDecomposition(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"I...don't\\\\\\\\get it.\",\n",
        "            target_mode=\"confused\",\n",
        "            index=2,\n",
        "            look_at=self.screen,\n",
        "            added_anims=[self.teacher.change, \"guilty\"],\n",
        "        )\n",
        "        self.play_student_changes(\"maybe\", \"tired\", look_at=self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "        fp_words = OldTexText(\"Fact about\\\\\\\\polynomials\")\n",
        "        fp_words.scale(1.25)\n",
        "        as_words = OldTexText(\"``Atomic structure''\\\\\\\\of a group\")\n",
        "        as_words.scale(1.25)\n",
        "        implies = OldTex(\"\\\\Rightarrow\").scale(2)\n",
        "\n",
        "        self.teacher_holds_up(\n",
        "            fp_words,\n",
        "            added_anims=[\n",
        "                RemovePiCreatureBubble(self.students[2]),\n",
        "            ]\n",
        "        )\n",
        "        self.play_student_changes(\"pondering\", \"hesitant\", \"plain\", look_at=fp_words)\n",
        "        self.wait()\n",
        "        as_words.next_to(fp_words, LEFT, buff=1.5)\n",
        "        implies.move_to(midpoint(as_words.get_right(), fp_words.get_left()))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(as_words, RIGHT),\n",
        "            Write(implies),\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=as_words)\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class TwoStepsToAllFiniteGroups(Scene):\n",
        "    def construct(self):\n",
        "        # List\n",
        "        title = OldTexText(\"How to categorize all finite groups\")\n",
        "        title.scale(1.5)\n",
        "        title.add(Underline(title))\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        steps = VGroup(\n",
        "            OldTexText(\"1. \", \"Find all the \", \"simple groups\", \".\"),\n",
        "            OldTexText(\"2. \", \"Find all the \", \"ways to\\\\\\\\\", \"combine \", \"simple groups\", \".\"),\n",
        "        )\n",
        "        steps[1][3:].next_to(steps[1][1], DOWN, SMALL_BUFF, aligned_edge=LEFT)\n",
        "        steps.arrange(DOWN, aligned_edge=LEFT, buff=2)\n",
        "        steps.set_y(-0.5)\n",
        "        steps.to_edge(LEFT)\n",
        "        for step in steps:\n",
        "            step.set_color_by_tex(\"simple groups\", TEAL)\n",
        "\n",
        "        self.add(title)\n",
        "        self.wait()\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, VGroup(steps[0][0], steps[1][0]),\n",
        "            lambda m: (m, RIGHT),\n",
        "            lag_ratio=0.4,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(steps[0][1:], lag_ratio=0.1))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            TransformFromCopy(steps[0][1], steps[1][1]),\n",
        "            TransformFromCopy(steps[0][2], steps[1][4]),\n",
        "            FadeIn(VGroup(*[steps[1][i] for i in (2, 3, 5)])),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Periodic table\n",
        "        table = VGroup(*[\n",
        "            VGroup(*[\n",
        "                Square() for x in range(n)\n",
        "            ]).arrange(DOWN, buff=0)\n",
        "            for n in [7, 6, *[4] * 10, *[6] * 5, 7]\n",
        "        ])\n",
        "        table.arrange(RIGHT, buff=0, aligned_edge=DOWN)\n",
        "        table.set_width(4)\n",
        "        table.to_edge(RIGHT)\n",
        "        table.match_y(steps[0])\n",
        "        table.set_stroke(GREY_A, 2)\n",
        "\n",
        "        table_arrow = Arrow(\n",
        "            steps[0].get_right(), table.get_left(),\n",
        "            buff=0.5,\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            GrowArrow(table_arrow),\n",
        "            FadeIn(table, lag_ratio=0.1, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Chemistry\n",
        "        chem_words = OldTexText(\"All of chemistry\")\n",
        "        chem_words.match_y(steps[1])\n",
        "        chem_words.match_x(table)\n",
        "        chem_words.set_color(RED)\n",
        "        chem_arrow = Arrow(\n",
        "            steps[1].get_right(), chem_words.get_left(),\n",
        "            buff=0.5\n",
        "        )\n",
        "        self.play(\n",
        "            GrowArrow(chem_arrow),\n",
        "            Write(chem_words),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Found all simples\n",
        "        top_group = VGroup(steps[0], table_arrow, table)\n",
        "        bottom_group = VGroup(steps[1], chem_arrow, chem_words)\n",
        "        frame = self.camera.frame\n",
        "\n",
        "        top_rect = SurroundingRectangle(top_group, buff=MED_LARGE_BUFF)\n",
        "        top_rect.set_stroke(GREEN, 4)\n",
        "        check = Checkmark()\n",
        "        check.set_height(0.7)\n",
        "        check.next_to(top_rect, UP, aligned_edge=LEFT)\n",
        "        check.shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            frame.scale, 1.1,\n",
        "            bottom_group.shift, 0.5 * DOWN,\n",
        "            bottom_group.set_opacity, 0.5,\n",
        "            ShowCreation(top_rect),\n",
        "            FadeOut(title, UP),\n",
        "        )\n",
        "        self.play(Write(check))\n",
        "        self.wait()\n",
        "\n",
        "        proof_words = OldTexText(\"(prove you have them all.)\")\n",
        "        proof_words.next_to(steps[0], DOWN)\n",
        "        proof_words.set_color(GREY_A)\n",
        "        self.play(Write(proof_words, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # What was involved\n",
        "        stats = VGroup(\n",
        "            OldTexText(\"1955-2004\"),\n",
        "            OldTexText(\"$10{,}000+$ pages\"),\n",
        "            OldTexText(\"100's of mathematicians\"),\n",
        "            OldTexText(\"Plenty of computation\"),\n",
        "        )\n",
        "        stats.arrange_in_grid(buff=1.5, aligned_edge=LEFT)\n",
        "        stats.next_to(top_rect, DOWN, buff=LARGE_BUFF)\n",
        "        for stat in stats:\n",
        "            dot = Dot()\n",
        "            dot.next_to(stat, LEFT)\n",
        "            stat.add(dot)\n",
        "\n",
        "        turn_animation_into_updater(ApplyMethod(frame.shift, DOWN, run_time=3))\n",
        "        self.add(frame)\n",
        "        for stat in stats:\n",
        "            self.play(FadeIn(stat), bottom_group.set_opacity, 0)\n",
        "            self.wait(0.5)\n",
        "        self.remove(bottom_group)\n",
        "\n",
        "        # 2004 paper mention\n",
        "        stats.generate_target()\n",
        "        stats.target.arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)\n",
        "        stats.target.move_to(stats, UL)\n",
        "\n",
        "        last_paper = OldTexText(\n",
        "            \"The Classification of Quasithin Groups\\\\\\\\\",\n",
        "            \"Aschbacher and Smith (2004)\\\\\\\\\",\n",
        "            \"(12{,}000 pages!)\",\n",
        "        )\n",
        "        last_paper.scale(0.7)\n",
        "        last_paper[:-1].set_color(YELLOW)\n",
        "        last_paper.move_to(stats, RIGHT)\n",
        "        last_paper.shift(RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(last_paper, DOWN),\n",
        "            MoveToTarget(stats),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Quote\n",
        "        quote = OldTexText(\n",
        "            \"\"\"\n",
        "            ``...undoubtedly one of the most\\\\\\\\\n",
        "            extraordinary theorems that pure\\\\\\\\\n",
        "            mathematics has ever seen.''\\\\\\\\\n",
        "            \"\"\",\n",
        "            \"-Richard Elwes\",\n",
        "            alignment=\"\",\n",
        "        )\n",
        "        quote.scale(0.9)\n",
        "        quote[0].set_color(YELLOW)\n",
        "        quote[-1].shift(MED_SMALL_BUFF * DR)\n",
        "        quote.move_to(last_paper, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(quote),\n",
        "            FadeOut(last_paper),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ClassificationOfSimpleGroups(Scene):\n",
        "    def construct(self):\n",
        "        # Title\n",
        "        class_title = OldTexText(\"Classification of finite simple groups\")\n",
        "        class_title.set_width(FRAME_WIDTH - 4)\n",
        "        class_title.add(Underline(class_title).set_color(GREY_B))\n",
        "        class_title.to_edge(UP)\n",
        "        self.add(class_title)\n",
        "\n",
        "        # 18 families\n",
        "        square_template = Square(side_length=0.3)\n",
        "        square_template.set_stroke(GREY_B, 2)\n",
        "        square_template.set_fill(BLUE_E, 0.5)\n",
        "        families_grid = VGroup(*[\n",
        "            VGroup(*[square_template.copy() for x in range(8)])\n",
        "            for y in range(18)\n",
        "        ])\n",
        "        for family in families_grid:\n",
        "            family.arrange(DOWN, buff=0)\n",
        "            dots = OldTex(\"\\\\vdots\")\n",
        "            dots.next_to(family, DOWN)\n",
        "            family.add(dots)\n",
        "        families_grid.arrange(RIGHT, buff=MED_SMALL_BUFF)\n",
        "        families_grid.to_edge(LEFT)\n",
        "        families_grid.set_y(-1)\n",
        "\n",
        "        families_title = OldTexText(\"18 infinite families\")\n",
        "        families_title.set_color(BLUE)\n",
        "        families_title.next_to(families_grid, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(families_title),\n",
        "            FadeIn(families_grid, lag_ratio=0.1, run_time=4),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Analogize to periodic table\n",
        "        families_grid.generate_target()\n",
        "        families_grid.save_state()\n",
        "        families_grid.target.arrange(RIGHT, buff=0)\n",
        "        families_grid.target.move_to(families_grid)\n",
        "        faders = VGroup(*[\n",
        "            column[:n]\n",
        "            for column, n in zip(families_grid.target, [\n",
        "                0, 1, *[3] * 10, *[1] * 5, 0,\n",
        "            ])\n",
        "        ])\n",
        "        faders.set_opacity(0)\n",
        "\n",
        "        self.play(MoveToTarget(families_grid, lag_ratio=0.001))\n",
        "        self.wait(2)\n",
        "        self.play(Restore(families_grid))\n",
        "\n",
        "        # Sporadic\n",
        "        sporadics = VGroup(*[square_template.copy() for x in range(26)])\n",
        "        buff = 0.1\n",
        "        sporadics[:20].arrange_in_grid(10, 2, buff=buff)\n",
        "        sporadics[20:].arrange(DOWN, buff=buff)\n",
        "        sporadics[20:].next_to(sporadics[:20], RIGHT, buff)\n",
        "        sporadics.next_to(families_grid, RIGHT, buff=1.5, aligned_edge=UP)\n",
        "        sporadics.set_fill(YELLOW_E)\n",
        "\n",
        "        pre_sporadics_title = OldTexText(\"26\", \" leftovers\")\n",
        "        sporadics_title = OldTexText(\"26\", \" ``sporadic''\\\\\\\\groups\")\n",
        "        for title in pre_sporadics_title, sporadics_title:\n",
        "            title.set_color(YELLOW)\n",
        "            title.next_to(sporadics, UP, MED_LARGE_BUFF)\n",
        "        sporadics_title.shift(MED_SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pre_sporadics_title, DOWN),\n",
        "            ShowIncreasingSubsets(sporadics, run_time=3),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(pre_sporadics_title[0], sporadics_title[0]),\n",
        "            FadeOut(pre_sporadics_title[1], UP),\n",
        "            FadeIn(sporadics_title[1], DOWN),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show prime cyclic groups\n",
        "        families_grid.save_state()\n",
        "        column = families_grid[0]\n",
        "\n",
        "        def prepare_column(column):\n",
        "            column.generate_target()\n",
        "            column.target.set_height(FRAME_HEIGHT)\n",
        "            column.target.move_to(5 * LEFT)\n",
        "            column.target.to_edge(UP)\n",
        "            column.target[-1].scale(0.5, about_point=column.target[-2].get_bottom())\n",
        "\n",
        "        prepare_column(column)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(column),\n",
        "            FadeOut(families_grid[1:], lag_ratio=0.1),\n",
        "            FadeOut(families_title),\n",
        "            FadeOut(class_title, UP),\n",
        "            FadeOut(sporadics, 2 * RIGHT),\n",
        "            FadeOut(sporadics_title, 2 * RIGHT),\n",
        "        )\n",
        "\n",
        "        # C5\n",
        "        c_names = VGroup(*[\n",
        "            OldTex(f\"C_{{{p}}}\")\n",
        "            for p in [2, 3, 5, 7, 11, 13, 17, 19]\n",
        "        ])\n",
        "\n",
        "        def put_in_square(mob, square, factor=0.4):\n",
        "            mob.set_height(factor * square.get_height())\n",
        "            mob.move_to(square)\n",
        "\n",
        "        def put_names_in_column(names, column):\n",
        "            for name, square in zip(names, column):\n",
        "                put_in_square(name, square)\n",
        "\n",
        "        put_names_in_column(c_names, column)\n",
        "\n",
        "        self.play(FadeIn(c_names, lag_ratio=0.1))\n",
        "        self.wait()\n",
        "\n",
        "        pentagon = RegularPolygon(5)\n",
        "        pentagon.set_height(3)\n",
        "        pentagon.set_fill(TEAL_E, 0.5)\n",
        "        pentagon.set_stroke(WHITE, 1)\n",
        "        pentagon.move_to(2 * RIGHT)\n",
        "        c_names.save_state()\n",
        "        c5 = c_names[2]\n",
        "        c5.generate_target()\n",
        "        c5.target.scale(2)\n",
        "        c5.target.next_to(pentagon, UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(c5),\n",
        "            DrawBorderThenFill(pentagon, run_time=1),\n",
        "        )\n",
        "        pcenter = center_of_mass(pentagon.get_vertices())\n",
        "        for n in [1, -2, 2]:\n",
        "            self.play(Rotate(pentagon, n * TAU / 5, about_point=pcenter))\n",
        "            self.wait(0.5)\n",
        "        self.play(\n",
        "            Restore(c_names),\n",
        "            FadeOut(pentagon)\n",
        "        )\n",
        "\n",
        "        c_names.generate_target()\n",
        "        c_names.target.replace(families_grid.saved_state[0])\n",
        "        c_names.target.scale(0.9)\n",
        "        c_names.target.set_opacity(0)\n",
        "        families_grid[1:].fade(1)\n",
        "\n",
        "        self.play(\n",
        "            Restore(families_grid),\n",
        "            MoveToTarget(c_names, remover=True)\n",
        "        )\n",
        "\n",
        "        # Alternating\n",
        "        column = families_grid[1]\n",
        "        prepare_column(column)\n",
        "        self.play(\n",
        "            MoveToTarget(column),\n",
        "            FadeOut(families_grid[0]),\n",
        "            FadeOut(families_grid[2:], lag_ratio=0.1),\n",
        "        )\n",
        "\n",
        "        a_names = VGroup(*[\n",
        "            OldTex(f\"A_{{{n}}}\")\n",
        "            for n in range(5, 5 + len(column) - 1)\n",
        "        ])\n",
        "        put_names_in_column(a_names, column)\n",
        "        self.play(FadeIn(a_names, lag_ratio=0.1))\n",
        "\n",
        "        dots = VGroup(*[Dot() for x in range(5)])\n",
        "        dots.set_height(0.5)\n",
        "        dots.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        dots.set_submobject_colors_by_gradient(RED, YELLOW)\n",
        "        dots.move_to(RIGHT)\n",
        "\n",
        "        a5 = a_names[0]\n",
        "        a5.save_state()\n",
        "        a5.generate_target()\n",
        "        a5.target.scale(2)\n",
        "        a5.target.next_to(dots, UP, buff=1.5)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dots, lag_ratio=0.1),\n",
        "            MoveToTarget(a5),\n",
        "        )\n",
        "        for x in range(5):\n",
        "            perm = list(range(5))\n",
        "            swaps = 1  # Lie\n",
        "            while swaps % 2 == 1:\n",
        "                random.shuffle(perm)\n",
        "                swaps = 0\n",
        "                for i, j in it.combinations(perm, 2):\n",
        "                    if j < i:\n",
        "                        swaps += 1\n",
        "            arrows = get_permutation_arrows(dots, perm)\n",
        "            self.play(\n",
        "                FadeIn(arrows),\n",
        "                permutation_animation(dots, perm, lag_factor=0.1),\n",
        "            )\n",
        "            self.play(FadeOut(arrows))\n",
        "        self.wait()\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(dots, lag_ratio=0.1),\n",
        "            Restore(a5),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        a_names.generate_target()\n",
        "        a_names.target.replace(families_grid.saved_state[1])\n",
        "        a_names.target.scale(0.9)\n",
        "        a_names.target.fade(1)\n",
        "\n",
        "        self.play(\n",
        "            Restore(families_grid),\n",
        "            MoveToTarget(a_names, remover=True),\n",
        "            FadeIn(families_title),\n",
        "            FadeIn(class_title),\n",
        "        )\n",
        "\n",
        "        # Others\n",
        "        others_rect = SurroundingRectangle(families_grid[2:])\n",
        "        others_rect.set_stroke(YELLOW, 2)\n",
        "        others_name = OldTexText(\"Groups of\\\\\\\\Lie type\")\n",
        "        others_name.set_color(YELLOW)\n",
        "        others_name.next_to(others_rect, RIGHT)\n",
        "        self.play(ShowCreation(others_rect))\n",
        "        self.play(FadeIn(others_name))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(others_name), FadeOut(others_rect))\n",
        "\n",
        "        # Back to sporadics\n",
        "        self.play(\n",
        "            ShowIncreasingSubsets(sporadics),\n",
        "            FadeIn(sporadics_title),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Look closer at sporadics\n",
        "        sporadics.generate_target()\n",
        "        sporadics.target.rotate(PI, axis=UL)\n",
        "        sporadics.target.set_width(FRAME_WIDTH - 1)\n",
        "        sporadics.target.center().to_edge(DOWN)\n",
        "\n",
        "        sporadics_title.save_state()\n",
        "        sporadics.save_state()\n",
        "\n",
        "        self.play(\n",
        "            sporadics_title.scale, 1.25,\n",
        "            sporadics_title.center,\n",
        "            sporadics_title.to_edge, UP,\n",
        "            MoveToTarget(sporadics),\n",
        "            FadeOut(families_grid, LEFT),\n",
        "            FadeOut(families_title, LEFT),\n",
        "            FadeOut(class_title, UP),\n",
        "        )\n",
        "\n",
        "        # Monster\n",
        "        monster = get_monster()\n",
        "        put_in_square(monster, sporadics[0], 0.9)\n",
        "        monster_name = OldTexText(\"Monster\", \" group\")\n",
        "        monster_name.next_to(sporadics[0], UP, LARGE_BUFF)\n",
        "        monster_name.shift_onto_screen()\n",
        "        monster_arrow = Arrow(monster_name.get_bottom(), monster.get_top())\n",
        "\n",
        "        size_label = OldTexText(\"{:,}\".format(MONSTER_SIZE))[0]\n",
        "        size_label.scale(0.8)\n",
        "        size_label.move_to(monster_name, LEFT)\n",
        "\n",
        "        self.play(\n",
        "            sporadics[0].set_fill, {\"opacity\": 0},\n",
        "            FadeIn(monster)\n",
        "        )\n",
        "        self.play(\n",
        "            Write(monster_name),\n",
        "            GrowArrow(monster_arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # sporadics_title.generate_target()\n",
        "        # sporadics_title.target.scale(1 / 1.5)\n",
        "        # sporadics_title.target.to_corner(UR)\n",
        "        self.play(\n",
        "            monster_name.shift, 0.6 * UP,\n",
        "            ShowIncreasingSubsets(size_label, run_time=2),\n",
        "            # MoveToTarget(sporadics_title, run_time=2, rate_func=squish_rate_func(smooth, 0.5, 1))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Baby monster\n",
        "        full_monster_label = VGroup(monster_name, size_label)\n",
        "        full_monster_label.save_state()\n",
        "        full_monster_label.generate_target()\n",
        "        full_monster_label.target.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        full_monster_label.target.set_opacity(0.7)\n",
        "\n",
        "        baby_name = OldTexText(\"Baby monster group\")\n",
        "        baby_name.move_to(size_label, LEFT)\n",
        "        baby_arrow = Arrow(baby_name.get_bottom(), sporadics[1].get_corner(UR) + SMALL_BUFF * DL)\n",
        "        baby_arrow.set_stroke(BLACK, 6, background=True)\n",
        "        baby_size_label = OldTexText(\"{:,}\".format(BABY_MONSTER_SIZE))[0]\n",
        "        baby_size_label.scale(0.8)\n",
        "        baby_size_label.move_to(baby_name, LEFT)\n",
        "\n",
        "        baby_monster = get_baby_monster()\n",
        "        baby_monster.set_width(0.9 * sporadics[1].get_width())\n",
        "        baby_monster.move_to(sporadics[1])\n",
        "        baby_monster.shift(SMALL_BUFF * DOWN)\n",
        "\n",
        "        self.remove(monster_arrow)\n",
        "        self.play(\n",
        "            MoveToTarget(full_monster_label),\n",
        "            TransformFromCopy(monster_arrow, baby_arrow),\n",
        "            FadeIn(baby_name, DOWN),\n",
        "            sporadics[1].set_fill, {\"opacity\": 0},\n",
        "            FadeIn(baby_monster),\n",
        "            FadeOut(sporadics_title, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            baby_name.shift, 0.6 * UP,\n",
        "            ShowIncreasingSubsets(baby_size_label, run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # 20 vs. 6\n",
        "        top_20 = sporadics[:20]\n",
        "        top_20.generate_target()\n",
        "        top_20.target.shift(2 * UP)\n",
        "        top_20.target[1:].set_fill(GREEN, 0.8)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(top_20),\n",
        "            MaintainPositionRelativeTo(monster, sporadics[0]),\n",
        "            MaintainPositionRelativeTo(baby_monster, sporadics[1]),\n",
        "            UpdateFromAlphaFunc(baby_monster, lambda m, a: m.set_opacity(1 - a), remover=True),\n",
        "            ApplyMethod(baby_arrow.scale, 0, {\"about_point\": baby_arrow.get_start()}, remover=True),\n",
        "            FadeOut(baby_size_label, UP),\n",
        "            FadeOut(baby_name, UP),\n",
        "            full_monster_label.set_fill, WHITE, 1,\n",
        "        )\n",
        "\n",
        "        monster_name.generate_target()\n",
        "        monster_name.target.arrange(DOWN, buff=MED_SMALL_BUFF, aligned_edge=LEFT)\n",
        "        monster_name.target.next_to(sporadics[0], UP, SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        happy_family_name = OldTexText(\"``Happy family''\")\n",
        "        happy_family_name.set_height(0.7)\n",
        "        happy_family_name.to_edge(UP)\n",
        "        happy_family_name.set_color(GREEN)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(monster_name),\n",
        "            FadeOut(size_label, DOWN),\n",
        "            FadeIn(happy_family_name, UP),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        pariahs = sporadics[20:]\n",
        "        pariahs_name = OldTexText(\"``Pariahs''\")\n",
        "        pariahs_name.set_height(0.7)\n",
        "        pariahs_name.next_to(pariahs, UP, MED_LARGE_BUFF)\n",
        "        pariahs_name.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(pariahs_name, UP),\n",
        "            pariahs.set_fill, YELLOW, 0.7,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ImSorryWhat(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"I'm sorry, what?!\",\n",
        "            target_mode=\"sassy\",\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.play_student_changes(\"angry\", \"maybe\", \"sassy\", look_at=self.screen)\n",
        "        self.wait(3)\n",
        "        self.play_student_changes(\"pleading\", \"confused\", \"erm\", look_at=self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class TellMeTheresAChildrensBook(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.student_says(\n",
        "            \"Please tell me\\\\\\\\there's a children's\\\\\\\\book about this!\",\n",
        "            target_mode=\"surprised\",\n",
        "            added_anims=[self.teacher.change, \"tease\"]\n",
        "        )\n",
        "        self.play_student_changes(\"happy\", \"coin_flip_1\", look_at=self.screen)\n",
        "        self.look_at(self.screen)\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class AskWhatTheMonsterActsOn(Scene):\n",
        "    def construct(self):\n",
        "        # Setup\n",
        "        question = OldTexText(\n",
        "            \"The monster group describes the symmetries of \",\n",
        "            \"$\\\\underline{\\\\qquad\\\\qquad\\\\qquad}$\",\n",
        "        )\n",
        "        question[1].set_color(YELLOW)\n",
        "        question.to_edge(UP)\n",
        "\n",
        "        monster = get_monster()\n",
        "        monster.set_height(5)\n",
        "        monster.to_corner(DL)\n",
        "\n",
        "        self.add(monster)\n",
        "        self.play(FadeIn(question, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Dimension counts\n",
        "        dim_words = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"Something in\\\\\\\\\",\n",
        "                \"{:,}\".format(n),\n",
        "                \" dimensions\",\n",
        "                \"?\"\n",
        "            )\n",
        "            for n in [2, 3, 4, 5, 196883]\n",
        "        ])\n",
        "        dim_words.scale(1.25)\n",
        "        dim_words.to_edge(RIGHT, buff=LARGE_BUFF)\n",
        "        dim_words.set_y(1.5)\n",
        "\n",
        "        final_words = dim_words[-1]\n",
        "        dim = Integer(196883, edge_to_fix=ORIGIN)\n",
        "        dim.replace(final_words[1])\n",
        "        dim.match_style(final_words[1])\n",
        "        final_words.replace_submobject(1, dim)\n",
        "        final_words[-1].set_opacity(0)\n",
        "\n",
        "        cross = Cross(dim_words)\n",
        "        cross.set_stroke(RED, 8)\n",
        "        for dim_word in dim_words[:-1]:\n",
        "            cross.replace(dim_word[1], stretch=True)\n",
        "            self.add(dim_word)\n",
        "            self.wait()\n",
        "            self.play(ShowCreation(cross, run_time=0.5))\n",
        "            self.wait(0.5)\n",
        "            self.remove(dim_word, cross)\n",
        "\n",
        "        penult = dim_words[-2]\n",
        "        dim.set_value(0)\n",
        "        for i in 0, 2:\n",
        "            final_words[i].save_state()\n",
        "            final_words[i].replace(penult[i])\n",
        "        self.play(\n",
        "            Restore(final_words[0]),\n",
        "            Restore(final_words[2]),\n",
        "            FadeOut(penult[3]),\n",
        "            ChangingDecimal(\n",
        "                dim,\n",
        "                lambda a: interpolate(5, 196883, a),\n",
        "                run_time=8,\n",
        "                rate_func=rush_from,\n",
        "            ),\n",
        "            UpdateFromAlphaFunc(\n",
        "                Mobject(),\n",
        "                lambda m, a, fw=final_words: fw.set_color(interpolate_color(WHITE, YELLOW, a)),\n",
        "                remover=True\n",
        "            )\n",
        "        )\n",
        "        final_words.add(dim)\n",
        "        self.add(final_words)\n",
        "        self.wait()\n",
        "        self.play(blink_monster(monster))\n",
        "        self.wait()\n",
        "\n",
        "        # Elements of the monster\n",
        "        in_sym = OldTex(\"\\\\in\")\n",
        "        in_sym.scale(2.5)\n",
        "\n",
        "        monster.generate_target()\n",
        "        monster.target.center().to_edge(RIGHT)\n",
        "        in_sym.next_to(monster.target, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            MoveToTarget(monster),\n",
        "            FadeOut(question, 3 * RIGHT),\n",
        "            FadeOut(final_words, 2 * RIGHT),\n",
        "            FadeIn(in_sym, 3 * LEFT),\n",
        "        )\n",
        "\n",
        "        matrix = IntegerMatrix(\n",
        "            np.random.randint(0, 2, size=(6, 6)),\n",
        "            v_buff=0.8,\n",
        "            h_buff=0.8,\n",
        "        )\n",
        "        matrix.set_height(4)\n",
        "        matrix.next_to(in_sym, LEFT, MED_LARGE_BUFF)\n",
        "\n",
        "        mob_matrix = matrix.get_mob_matrix()\n",
        "        groups_to_dots = [\n",
        "            (mob_matrix[4, :4], OldTex(\"\\\\vdots\")),\n",
        "            (mob_matrix[:4, 4], OldTex(\"\\\\ldots\")),\n",
        "            (VGroup(mob_matrix[4, 4]), OldTex(\"\\\\ddots\")),\n",
        "        ]\n",
        "        for group, dots in groups_to_dots:\n",
        "            for elem in group:\n",
        "                dots_copy = dots.copy()\n",
        "                dots_copy.move_to(elem)\n",
        "                elem.set_submobjects(dots_copy)\n",
        "\n",
        "        braces = VGroup(\n",
        "            Brace(matrix.get_entries(), DOWN),\n",
        "            Brace(matrix.get_entries(), LEFT),\n",
        "        )\n",
        "        braces[1].shift(MED_SMALL_BUFF * LEFT)\n",
        "        for brace in braces:\n",
        "            brace.add(brace.get_text(\"196{,}882\"))\n",
        "        braces.set_color(BLUE)\n",
        "\n",
        "        gigs_label = OldTexText(\"Each element $\\\\approx$ 4.5 Gigabytes of data!\")\n",
        "        gigs_label.next_to(matrix, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(matrix, run_time=1))\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces, lag_ratio=0.5, run_time=1),\n",
        "            FadeIn(gigs_label, DOWN)\n",
        "        )\n",
        "        self.play(blink_monster(monster))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class MonsterQuotes(Scene):\n",
        "    def construct(self):\n",
        "        images = [\n",
        "            get_named_image(\"John Conway\"),\n",
        "            get_named_image(\"Richard Borcherds\"),\n",
        "        ]\n",
        "\n",
        "        quotes = [\n",
        "            OldTexText(\n",
        "                \"\"\"\n",
        "                ``Nothing has given me the feeling\\\\\\\\\n",
        "                that I understand why the monster\\\\\\\\\n",
        "                is there.''\\\\\\\\\n",
        "                \"\"\",\n",
        "                alignment=\"\",\n",
        "            ),\n",
        "            OldTexText(\n",
        "                \"\"\"\n",
        "                ``The monster simple group . . . appears\\\\\\\\\n",
        "                to rely on numerous bizarre coincidences\\\\\\\\\n",
        "                to exist.''\\\\\\\\\n",
        "                \"\"\",\n",
        "                alignment=\"\",\n",
        "            ),\n",
        "        ]\n",
        "        faders = []\n",
        "        self.clear()\n",
        "        for image, quote, color in zip(images, quotes, [YELLOW, WHITE]):\n",
        "            quote[0].set_color(color)\n",
        "\n",
        "            image.set_height(5)\n",
        "            image.to_edge(LEFT)\n",
        "            image[1].set_color(GREY_B)\n",
        "            quote.next_to(image, RIGHT, buff=1, aligned_edge=UP)\n",
        "            quote.shift(DOWN)\n",
        "            quote.shift_onto_screen()\n",
        "\n",
        "            self.play(\n",
        "                FadeIn(image, DOWN),\n",
        "                FadeIn(quote, lag_ratio=0.1, run_time=3),\n",
        "                *faders,\n",
        "            )\n",
        "            self.wait(4)\n",
        "            faders = [FadeOut(image, UP), FadeOut(quote)]\n",
        "\n",
        "\n",
        "class MonstrousMoonshine(Scene):\n",
        "    def construct(self):\n",
        "        # Time line\n",
        "        decades = list(range(1970, 2030, 10))\n",
        "        timeline = NumberLine(\n",
        "            (decades[0], decades[-1], 1),\n",
        "            big_tick_numbers=decades,\n",
        "            tick_size=0.075,\n",
        "            width=13,\n",
        "        )\n",
        "        timeline.add_numbers(decades, group_with_commas=False)\n",
        "        timeline.move_to(DOWN)\n",
        "        self.add(timeline)\n",
        "\n",
        "        triangle = Triangle()\n",
        "        triangle.rotate(PI)\n",
        "        triangle.set_height(0.25)\n",
        "        triangle.set_fill(BLUE_C, 1)\n",
        "        triangle.set_stroke(WHITE, 0)\n",
        "        triangle.move_to(timeline.n2p(2020), DOWN)\n",
        "        self.add(triangle)\n",
        "\n",
        "        self.play(\n",
        "            triangle.move_to, timeline.n2p(1978), DOWN,\n",
        "            run_time=3,\n",
        "        )\n",
        "\n",
        "        # McKay\n",
        "        mckay = get_named_image(\"John McKay\")\n",
        "        mckay[0].flip()\n",
        "        mckay.next_to(triangle, UP)\n",
        "\n",
        "        self.play(FadeIn(mckay, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        theories = VGroup(\n",
        "            OldTexText(\"Finite group theory\"),\n",
        "            OldTexText(\"Galois theory\"),\n",
        "        )\n",
        "        theories.arrange(RIGHT, buff=1.5)\n",
        "        theories.next_to(mckay, RIGHT, LARGE_BUFF)\n",
        "        theories_line, theories_arrow = [\n",
        "            func(\n",
        "                *[theory.get_top() for theory in theories],\n",
        "                path_arc=-90 * DEGREES,\n",
        "                buff=0.2,\n",
        "            ).shift(0.25 * UP)\n",
        "            for func in [Line, Arrow]\n",
        "        ]\n",
        "        theories_line.set_stroke(BLUE_C, 6)\n",
        "        theories_arrow.set_fill(BLUE_C)\n",
        "\n",
        "        self.play(FadeIn(theories[0], LEFT))\n",
        "        self.play(\n",
        "            GrowFromPoint(theories[1], theories_line.get_start(), path_arc=-90 * DEGREES),\n",
        "            ShowCreationThenFadeOut(theories_line, run_time=2),\n",
        "            FadeIn(theories_arrow, rate_func=squish_rate_func(smooth, 0.3, 1), run_time=2)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        theories_group = VGroup(theories, theories_arrow)\n",
        "\n",
        "        # j function\n",
        "        j_func = OldTex(\n",
        "            \"j(\\\\tau)  =q^{-1}+744+196{,}884 q+21{,}493{,}760 q^{2}+864{,}299{,}970 q^{3}+\\\\cdots\\\\\\\\\",\n",
        "            \"\\\\big(q = e^{2\\\\pi i \\\\tau}\\\\big)\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\tau\": TEAL,\n",
        "                \"q\": BLUE,\n",
        "                \"196{,}884\": WHITE,\n",
        "            }\n",
        "        )\n",
        "        j_func.scale(0.7)\n",
        "        j_func[-5:].shift([-0.5, -0.25, 0])\n",
        "        j_func.next_to(mckay, RIGHT, aligned_edge=DOWN)\n",
        "        j_func.shift(0.5 * UP)\n",
        "\n",
        "        special_num = j_func.get_part_by_tex(\"196{,}884\")\n",
        "        special_num_underline = Underline(special_num)\n",
        "        special_num_underline.set_stroke(YELLOW, 3)\n",
        "\n",
        "        self.play(\n",
        "            theories_group.scale, 0.5, {\"about_edge\": UL},\n",
        "            theories_group.to_edge, UP,\n",
        "            Write(j_func)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(special_num_underline),\n",
        "            special_num.set_color, YELLOW,\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        j_coloring = ImageMobject(\"J_Invariant_Coloring\")\n",
        "        j_coloring.set_width(FRAME_WIDTH)\n",
        "        j_coloring.to_edge(DOWN, buff=0)\n",
        "        j_coloring.set_opacity(0.25)\n",
        "        self.add(j_coloring, *self.mobjects)\n",
        "        self.play(FadeIn(j_coloring))\n",
        "        self.wait(0.5)\n",
        "        self.play(FadeOut(j_coloring), FadeOut(special_num_underline))\n",
        "        self.wait()\n",
        "\n",
        "        # Conway\n",
        "        conway = get_named_image(\"John Conway\")\n",
        "        conway[0].flip()\n",
        "        conway.move_to(mckay)\n",
        "        conway.to_edge(RIGHT)\n",
        "        moonshine = OldTexText(\"Moonshine!\")\n",
        "        moonshine.set_height(0.6)\n",
        "        moonshine.next_to(conway, LEFT, MED_LARGE_BUFF, aligned_edge=UP)\n",
        "        moonshine.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(timeline, DOWN),\n",
        "            FadeOut(triangle, DOWN),\n",
        "            j_func.to_edge, DOWN,\n",
        "            FadeOut(theories_group),\n",
        "            FadeIn(conway, DOWN),\n",
        "        )\n",
        "        self.play(Write(moonshine))\n",
        "        self.wait()\n",
        "\n",
        "        # Conjecture\n",
        "        conjecture = OldTexText(\"Monstrous \", \"moonshine\\\\\\\\\", \" conjecture\")\n",
        "        conjecture_icon = VGroup(\n",
        "            get_monster().set_height(1),\n",
        "            OldTex(\"\\\\leftrightarrow\"),\n",
        "            OldTex(\"j(\\\\tau)\", tex_to_color_map={\"\\\\tau\": TEAL}),\n",
        "        )\n",
        "        conjecture_icon.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        conjecture_icon.set_height(1.5)\n",
        "        conjecture_icon.next_to(timeline.n2p(1979), UP, MED_LARGE_BUFF)\n",
        "        conjecture.next_to(conjecture_icon, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(timeline, DOWN),\n",
        "            FadeIn(triangle, DOWN),\n",
        "            FadeOut(mckay, UP),\n",
        "            Transform(\n",
        "                moonshine,\n",
        "                moonshine.copy().replace(conjecture[1], stretch=True).fade(1),\n",
        "                remover=True,\n",
        "            ),\n",
        "            ReplacementTransform(\n",
        "                conjecture[1].copy().replace(moonshine, stretch=True).fade(1),\n",
        "                conjecture[1],\n",
        "            ),\n",
        "            Write(conjecture[0::2]),\n",
        "        )\n",
        "        self.play(\n",
        "            FadeIn(conjecture_icon, lag_ratio=0.1),\n",
        "            triangle.move_to, timeline.n2p(1979), DOWN,\n",
        "        )\n",
        "        self.play(blink_monster(conjecture_icon[0]))\n",
        "        self.wait()\n",
        "\n",
        "        conjecture_group = VGroup(conjecture, conjecture_icon)\n",
        "\n",
        "        # Borcherds\n",
        "        borcherds = get_named_image(\"Richard Borcherds\")\n",
        "        borcherds.next_to(timeline.n2p(1992), UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            conjecture_group.scale, 0.5, {\"about_edge\": DOWN},\n",
        "            triangle.move_to, timeline.n2p(1992), DOWN,\n",
        "            FadeOut(conway, RIGHT),\n",
        "            FadeIn(borcherds, 2 * LEFT)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            triangle.move_to, timeline.n2p(1998), DOWN,\n",
        "            MaintainPositionRelativeTo(borcherds, triangle),\n",
        "        )\n",
        "\n",
        "        medal = ImageMobject(\"Fields Medal\")\n",
        "        medal.set_height(1)\n",
        "        medal.move_to(borcherds.get_corner(UR), LEFT)\n",
        "        self.play(FadeIn(medal, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class StringTheory(Scene):\n",
        "    def construct(self):\n",
        "        monster = get_monster()\n",
        "        monster.set_height(4)\n",
        "        arrow = OldTex(\"\\\\leftrightarrow\").scale(2)\n",
        "\n",
        "        n = 10\n",
        "        points = compass_directions(n)\n",
        "        freqs = np.random.random(n) + 0.3\n",
        "\n",
        "        string = VMobject()\n",
        "        string.set_stroke([BLUE, TEAL, BLUE, TEAL, BLUE, TEAL, BLUE], 4)\n",
        "\n",
        "        def update_string(string, points=points, freqs=freqs, sc=self):\n",
        "            for point, freq in zip(points, freqs):\n",
        "                point[:] = normalize(point) * (1 + 0.2 * np.sin(TAU * freq * sc.time))\n",
        "            string.set_points_smoothly([*points, points[0]])\n",
        "\n",
        "        string.add_updater(update_string)\n",
        "\n",
        "        arrow.next_to(string, LEFT, LARGE_BUFF)\n",
        "        monster.next_to(arrow, LEFT, LARGE_BUFF)\n",
        "        # self.camera.frame.move_to(arrow)\n",
        "        self.camera.frame.scale(0.5)\n",
        "\n",
        "        st_name = OldTexText(\"String theory\")\n",
        "        st_name.scale(1.5)\n",
        "        st_name.next_to(string, UP, LARGE_BUFF)\n",
        "\n",
        "        sg_name = OldTexText(\"Sporadic groups\")\n",
        "        sg_name.scale(1.5)\n",
        "        sg_name.next_to(monster, DOWN)\n",
        "\n",
        "        self.add(monster)\n",
        "        self.add(arrow)\n",
        "        self.add(string)\n",
        "        self.wait(2)\n",
        "        self.play(Write(sg_name))\n",
        "        self.play(Write(st_name))\n",
        "        for x in range(4):\n",
        "            self.play(blink_monster(monster))\n",
        "            self.wait(5)\n",
        "\n",
        "\n",
        "class MonsterThanks(PatreonEndScreen):\n",
        "    pass\n"
    ]
}