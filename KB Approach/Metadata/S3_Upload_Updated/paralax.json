{
    "topic": "The mathematical concept being demonstrated is the visualization of a triangle formed by three random points on a sphere",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2025.cosmic_distance.planets import *\n",
        "\n",
        "\n",
        "class SimpleDotsParalax(InteractiveScene):\n",
        "    show_pi_perspective = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Add stars\n",
        "        frame = self.frame\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        height = 4\n",
        "        cube = VCube(height)\n",
        "        cube.set_fill(opacity=0)\n",
        "        cube.set_stroke(BLUE, 2)\n",
        "\n",
        "        n_stars = 200\n",
        "        stars = GlowDots(np.random.uniform(-1, 1, (n_stars, 3)))\n",
        "        stars.scale(height / 2)\n",
        "        stars.set_color(WHITE)\n",
        "        stars.set_glow_factor(2)\n",
        "        stars.set_radii(np.random.uniform(0, 0.075, n_stars))\n",
        "\n",
        "        self.add(cube)\n",
        "        self.add(stars)\n",
        "\n",
        "        self.play(ShowCreation(stars, run_time=4))\n",
        "\n",
        "        # Add randy\n",
        "        randy = Randolph(height=1)\n",
        "        randy.next_to(cube, LEFT, buff=1)\n",
        "\n",
        "        self.play(\n",
        "            VFadeIn(randy),\n",
        "            randy.change(\"pondering\", look_at=RIGHT)\n",
        "        )\n",
        "\n",
        "        if self.show_pi_perspective:\n",
        "            self.play(\n",
        "                frame.animate.reorient(-89, -4, 0, (0.01, 0.21, 0.0), 3.05),\n",
        "                randy.animate.set_opacity(0),\n",
        "                cube.animate.set_stroke(width=5).set_anti_alias_width(10),\n",
        "                run_time=3,\n",
        "            )\n",
        "            frame.always.match_z(randy)\n",
        "        else:\n",
        "            self.play(frame.animate.reorient(-40, -26, 0), run_time=3)\n",
        "\n",
        "        # Move up and down\n",
        "        for dy in [1, -2, 2, -2, 1]:\n",
        "            self.play(randy.animate.shift(dy * 1.5 * IN), run_time=5)\n",
        "\n",
        "        return\n",
        "\n",
        "        # Show some triangle\n",
        "        star_points = np.array(list(filter(lambda p: get_norm(p) < 1, stars.get_points())))\n",
        "        star_points[0] *= 10\n",
        "        random.seed(1)\n",
        "        verts = random.sample(list(star_points), 3)\n",
        "        triangle = Polygon(*verts)\n",
        "        triangle.set_color(RED)\n",
        "        red_stars = DotCloud(verts)\n",
        "        red_stars.set_radius(0.02)\n",
        "        red_stars.set_color(RED)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(triangle),\n",
        "            FadeIn(red_stars),\n",
        "        )\n",
        "\n",
        "\n",
        "class SimpleDotsFromPerspective(SimpleDotsParalax):\n",
        "    show_pi_perspective = True\n",
        "\n",
        "\n",
        "class ParalxInSolarSystem(InteractiveScene):\n",
        "    show_celestial_sphere = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Add sun and earth\n",
        "        frame = self.frame\n",
        "        light_source = self.camera.light_source\n",
        "\n",
        "        earth = get_earth(radius=0.01)\n",
        "        earth.rotate(EARTH_TILT_ANGLE, UP)\n",
        "        earth_axis = rotate_vector(OUT, EARTH_TILT_ANGLE, UP)\n",
        "        sun = get_sun(radius=0.07, big_glow_ratio=10)\n",
        "\n",
        "        orbit_radius = 5\n",
        "        sun.move_to(ORIGIN)\n",
        "        light_source.move_to(sun)\n",
        "\n",
        "        orbit = Circle(radius=orbit_radius, n_components=100)\n",
        "        orbit.set_stroke(BLUE, width=(0, 3))\n",
        "        orbit.rotate(-30 * DEG)\n",
        "        orbit.add_updater(lambda m, dt: m.rotate(10 * dt * DEG))\n",
        "        orbit.set_stroke(flat=False)\n",
        "        orbit.set_anti_alias_width(5)\n",
        "        orbit.apply_depth_test()\n",
        "\n",
        "        earth.add_updater(lambda m: m.move_to(orbit.get_end()))\n",
        "        # earth.add_updater(lambda m, dt: m.rotate(2 * TAU * dt, axis=earth_axis))\n",
        "\n",
        "        self.add(orbit, earth, sun)\n",
        "        self.wait(3)\n",
        "\n",
        "        # Add stars\n",
        "        if self.show_celestial_sphere:\n",
        "            n_stars = 0\n",
        "            celestial_sphere = get_celestial_sphere()\n",
        "            self.add(celestial_sphere)\n",
        "        else:\n",
        "            n_stars = 3000\n",
        "        points = np.random.uniform(-1, 1, (n_stars, 3))\n",
        "        points = normalize_along_axis(points, 1)\n",
        "        distances = np.random.uniform(10, 50, n_stars)\n",
        "        radii = np.random.uniform(0, 0.2, n_stars)\n",
        "        points = points * distances[:, np.newaxis]\n",
        "        stars = GlowDots(points)\n",
        "        stars.set_color(WHITE)\n",
        "        stars.set_radii(radii)\n",
        "\n",
        "        self.add(stars, orbit, earth)\n",
        "        self.play(\n",
        "            ShowCreation(stars),\n",
        "            frame.animate.reorient(0, 71, 0, (2.29, -0.66, 0.52), 43.56),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_euler_angles(-10 * DEG, 86 * DEG, 0).set_height(0.25),\n",
        "            # frame.animate.set_height(0.1),\n",
        "            UpdateFromAlphaFunc(sun, lambda m, a: frame.move_to(interpolate(frame.get_center(), earth.get_center(), min(2 * a, 1)))),\n",
        "            run_time=5\n",
        "        )\n",
        "        frame.clear_updaters()\n",
        "        frame.add_updater(lambda m: m.move_to(earth))\n",
        "\n",
        "        self.wait(30)\n",
        "\n",
        "        # Zoom back out\n",
        "        self.play(\n",
        "            frame.animate.reorient(7, 74, 0, ORIGIN, 120),\n",
        "            stars.animate.set_radii(2 * radii),\n",
        "            run_time=3,\n",
        "        )\n",
        "        new_points = 1000 * normalize_along_axis(stars.get_points(), 1)\n",
        "        self.play(\n",
        "            stars.animate.set_points(new_points).set_radii(20 * radii),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.play(\n",
        "            frame.animate.reorient(-89, 74, 0),\n",
        "            run_time=12\n",
        "        )\n",
        "\n",
        "\n",
        "class ShowConstellationsDuringOrbit(ParalxInSolarSystem):\n",
        "    show_celestial_sphere = True\n",
        "\n",
        "\n",
        "class ParalaxMeasurmentFromEarth(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add earth\n",
        "        self.camera.light_source.move_to(500 * RIGHT)\n",
        "\n",
        "        radius = 3\n",
        "        earth = Circle(radius=radius)\n",
        "        earth.set_fill(BLUE_B, 0.5)\n",
        "        earth.set_stroke(WHITE, 3)\n",
        "        earth.to_edge(LEFT)\n",
        "        earth_back = earth.copy()\n",
        "        earth_back.set_fill(BLACK, 1).set_stroke(width=0)\n",
        "\n",
        "        earth_pattern = SVGMobject(\"earth\")\n",
        "        earth_pattern.replace(earth)\n",
        "        earth_pattern.set_fill(Color(hsl=(0.23, 0.5, 0.2)), 1)\n",
        "\n",
        "        self.add(earth_back, earth, earth_pattern)\n",
        "\n",
        "        # Add two observers\n",
        "        pi_height = 0.25\n",
        "        randy, morty = pis = VGroup(\n",
        "            Randolph(height=2, mode=\"hesitant\").look_at(10 * RIGHT),\n",
        "            Mortimer(height=2, mode=\"pondering\").look_at(10 * RIGHT),\n",
        "        )\n",
        "        angles = [45 * DEG, -55 * DEG]\n",
        "        labels = VGroup(\n",
        "            Text(\"Observer 1\", font_size=36),\n",
        "            Text(\"Observer 2\", font_size=36),\n",
        "        )\n",
        "        pis.arrange(DOWN, buff=1.0)\n",
        "        pis.move_to(3 * RIGHT)\n",
        "\n",
        "        obs_points = []\n",
        "        obs_dots = Group()\n",
        "\n",
        "        for pi, label, angle in zip(pis, labels, angles):\n",
        "            label.next_to(pi, DOWN, SMALL_BUFF)\n",
        "            target_point = earth.pfp((angle / TAU) % 1)\n",
        "\n",
        "            pi.target = pi.generate_target()\n",
        "            pi.target.set_height(pi_height)\n",
        "            pi.target.next_to(target_point, UP, buff=0)\n",
        "            pi.target.rotate(angle - 90 * DEG, about_point=target_point)\n",
        "\n",
        "            label.target = label.generate_target()\n",
        "            label.target.scale(0.5)\n",
        "            # label.target.next_to(pi.target, rotate_vector(RIGHT, angle), buff=SMALL_BUFF)\n",
        "            label.target.next_to(pi.target, UP * np.sign(angle), buff=SMALL_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "            obs_dots.add(TrueDot(target_point, color=pi.get_color()).make_3d())\n",
        "            obs_points.append(target_point)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, pis, shift=0.5 * UP, lag_ratio=0.5),\n",
        "            LaggedStartMap(FadeIn, labels, shift=0.25 * UP, lag_ratio=0.5),\n",
        "\n",
        "        )\n",
        "        self.play(LaggedStartMap(Blink, pis, lag_ratio=0.25))\n",
        "        self.play(\n",
        "            LaggedStartMap(MoveToTarget, pis, lag_ratio=0.7),\n",
        "            LaggedStartMap(MoveToTarget, labels, lag_ratio=0.7),\n",
        "            FadeIn(obs_dots, time_span=(0.75, 1.25)),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show lines to object\n",
        "        frame = self.frame\n",
        "        obj = GlowDot(12 * RIGHT, color=TEAL)\n",
        "\n",
        "        obs_lines = VGroup(\n",
        "            DashedLine(obs_points[0], obj.get_center()),\n",
        "            DashedLine(obs_points[1], obj.get_center()),\n",
        "        )\n",
        "        obs_lines.set_stroke(WHITE, 2)\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.set_width(20, about_edge=LEFT),\n",
        "            *map(ShowCreation, obs_lines),\n",
        "            FadeIn(obj),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Analogy with eyeballs\n",
        "        eyes = Randolph().eyes\n",
        "        eyes.set_height(1)\n",
        "        eyes.set_z_index(-1)\n",
        "\n",
        "        def look_at(eye, object, midpoint):\n",
        "            direction = normalize(object.get_center() - midpoint)\n",
        "            eye.pupil.move_to(midpoint + 0.8 * eye.pupil.get_width() * direction)\n",
        "\n",
        "        for eye, point, angle in zip(eyes, obs_points, angles):\n",
        "            eye.next_to(ORIGIN, UP, buff=-0.35)\n",
        "            eye.rotate(angle - 90 * DEG, about_point=ORIGIN)\n",
        "            eye.shift(point)\n",
        "            eye.point = point\n",
        "            eye.add_updater(lambda m: look_at(m, obj, m.point))\n",
        "\n",
        "        for line, dot in zip(obs_lines, obs_dots):\n",
        "            line.dot = dot\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(m.dot.get_center(), obj.get_center()))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(eyes),\n",
        "            FadeOut(pis),\n",
        "            FadeOut(labels),\n",
        "        )\n",
        "\n",
        "        obj.save_state()\n",
        "        for vect in [6 * LEFT, 4 * UP, 4 * DOWN + 20 * RIGHT]:\n",
        "            self.play(obj.animate.shift(vect), run_time=3)\n",
        "        self.play(Restore(obj, run_time=3))\n",
        "        self.play(\n",
        "            FadeOut(eyes),\n",
        "            FadeIn(pis),\n",
        "            FadeIn(labels),\n",
        "        )\n",
        "\n",
        "        # Add stars\n",
        "        conversion_factor = radius / EARTH_RADIUS\n",
        "        celestial_sphere = get_celestial_sphere(radius=JUPITER_ORBIT_RADIUS * conversion_factor, constellation_opacity=0.0)\n",
        "        celestial_sphere.set_z_index(-2)\n",
        "        low_obs_group = VGroup(obs_lines[1], pis[1], labels[1])\n",
        "        low_obs_group.save_state()\n",
        "        frame.save_state()\n",
        "        self.play(\n",
        "            FadeIn(celestial_sphere),\n",
        "            low_obs_group.animate.fade(0.75),\n",
        "            frame.animate.set_height(20, about_edge=LEFT).shift(2 * RIGHT),\n",
        "        )\n",
        "\n",
        "        # Show moving observer\n",
        "        self.play(\n",
        "            Rotate(Group(pis[0], obs_dots[0]), angles[1] - angles[0], about_point=earth.get_center()),\n",
        "            MaintainPositionRelativeTo(labels[0], pis[0]),\n",
        "            run_time=8,\n",
        "            rate_func=there_and_back,\n",
        "        )\n",
        "        self.play(\n",
        "            Restore(low_obs_group),\n",
        "            Restore(frame),\n",
        "        )\n",
        "\n",
        "        # Show line between\n",
        "        line_between = Line(*obs_points)\n",
        "        line_between.set_stroke(YELLOW, 3)\n",
        "        brace_between = LineBrace(line_between, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_between),\n",
        "            earth.animate.set_fill(opacity=0.35).set_stroke(width=2, opacity=1),\n",
        "            earth_pattern.animate.set_fill(opacity=0.75),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(GrowFromCenter(brace_between))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(brace_between))\n",
        "        self.wait()\n",
        "\n",
        "        # Move dot around\n",
        "        self.play(low_obs_group.animate.fade(0.9))\n",
        "        self.play(obj.animate.shift(3 * UP), rate_func=wiggle, run_time=5)\n",
        "        self.play(Restore(low_obs_group))\n",
        "\n",
        "        # Add angle labels\n",
        "        colors = [BLUE, RED]\n",
        "        angle_labels = self.get_angle_labels(obs_lines, obs_points, line_between, arc_props=[0.75, 0.5], colors=colors)\n",
        "\n",
        "        for angle_label in angle_labels:\n",
        "            self.play(Write(angle_label))\n",
        "            self.wait()\n",
        "\n",
        "        # Show remaining angle\n",
        "        tip_arc = Arc(\n",
        "            obs_lines[0].get_angle() + PI,\n",
        "            obs_lines[1].get_angle() - obs_lines[0].get_angle(),\n",
        "            arc_center=obj.get_center(),\n",
        "            radius=1\n",
        "        )\n",
        "        tip_arc_label = Tex(\n",
        "            R\"180^\\circ - \\alpha - \\beta\",\n",
        "            t2c={R\"\\alpha\": colors[0], R\"\\beta\": colors[1]}\n",
        "        )\n",
        "        tip_arc_label.next_to(tip_arc, LEFT, MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            ShowCreation(tip_arc),\n",
        "            FadeTransform(angle_labels[0][1].copy(), tip_arc_label[R\"\\alpha\"][0]),\n",
        "            FadeTransform(angle_labels[1][1].copy(), tip_arc_label[R\"\\beta\"][0]),\n",
        "            Write(tip_arc_label[R\"180^\\circ\"]),\n",
        "            Write(tip_arc_label[R\"-\"]),\n",
        "            run_time=2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        # Emphasize one distance\n",
        "        obs1_brace = LineBrace(obs_lines[0])\n",
        "\n",
        "        self.play(GrowFromCenter(brace_between))\n",
        "        self.wait()\n",
        "        self.play(Transform(brace_between, obs1_brace))\n",
        "        self.wait()\n",
        "        self.play(FadeOut(brace_between))\n",
        "\n",
        "        # Replace with true earth\n",
        "        frame.set_field_of_view(20 * DEG)\n",
        "        true_earth = get_earth(radius=radius)\n",
        "        true_earth.move_to(earth)\n",
        "        true_earth.set_z_index(-1)\n",
        "        true_earth.rotate(90 * DEG, LEFT)\n",
        "        true_earth.rotate(140 * DEG, UP)\n",
        "        true_earth.rotate(-EARTH_TILT_ANGLE, OUT)\n",
        "\n",
        "        new_obs_lines = VGroup(\n",
        "            Line(ol.get_start(), ol.get_end())\n",
        "            for ol in obs_lines\n",
        "        )\n",
        "        new_obs_lines.match_style(obs_lines)\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(true_earth),\n",
        "            FadeOut(earth_back),\n",
        "            FadeOut(earth),\n",
        "            FadeOut(earth_pattern),\n",
        "            FadeOut(tip_arc_label),\n",
        "            FadeOut(tip_arc),\n",
        "            FadeOut(obs_lines),\n",
        "            FadeIn(new_obs_lines),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        obs_lines = new_obs_lines\n",
        "\n",
        "        # Drag point very far away, show orbitss\n",
        "        self.set_floor_plane(\"xz\")\n",
        "\n",
        "        for line, dot in zip(obs_lines, obs_dots):\n",
        "            line.dot = dot\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(m.dot.get_center(), obj.get_center()))\n",
        "\n",
        "        angle_labels.add_updater(\n",
        "            lambda m: m.become(\n",
        "                self.get_angle_labels(\n",
        "                    obs_lines,\n",
        "                    obs_points=[obs_dots[0].get_center(), obs_dots[1].get_center()],\n",
        "                    line_between=line_between,\n",
        "                    arc_props=[0.75, 0.5]\n",
        "                )\n",
        "            )\n",
        "        )\n",
        "\n",
        "        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS * conversion_factor)\n",
        "        moon_orbit.set_stroke(GREY_B, width=(0, 3))\n",
        "        moon_orbit.move_to(earth)\n",
        "        moon_orbit.rotate(90 * DEG, LEFT)\n",
        "        moon = get_moon(radius=conversion_factor * MOON_RADIUS)\n",
        "        moon.move_to(moon_orbit.get_right())\n",
        "\n",
        "        frame.add_updater(lambda m, dt: m.set_phi(interpolate(m.get_phi(), -90 * DEG, 0.025 * dt)))\n",
        "\n",
        "        self.add(moon_orbit, moon)\n",
        "        self.play(\n",
        "            obj.animate.move_to(moon),\n",
        "            frame.animate.set_height(1.5 * moon_orbit.get_width()).move_to(moon_orbit.get_right()).set_field_of_view(35 * DEG),\n",
        "            FadeIn(moon_orbit),\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "        # Show Venus\n",
        "        sun = get_sun(SUN_RADIUS * conversion_factor, big_glow_ratio=20)\n",
        "        sun.move_to(earth.get_center() + EARTH_ORBIT_RADIUS * conversion_factor * RIGHT)\n",
        "\n",
        "        earth_orbit = Circle(radius=EARTH_ORBIT_RADIUS * conversion_factor)\n",
        "        venus_orbit = Circle(radius=VENUS_ORBIT_RADIUS * conversion_factor)\n",
        "        for orbit, color in zip([earth_orbit, venus_orbit], [BLUE, TEAL]):\n",
        "            orbit.rotate(PI)\n",
        "            orbit.set_stroke(color, width=(0, 3))\n",
        "            orbit.move_to(sun)\n",
        "            orbit.rotate(90 * DEG, LEFT)\n",
        "\n",
        "        self.add(sun)\n",
        "        self.play(\n",
        "            frame.animate.set_height(0.4 * earth_orbit.get_width()).move_to(interpolate(venus_orbit.get_left(), sun.get_center(), 0.25)),\n",
        "            FadeIn(earth_orbit, time_span=(2, 4)),\n",
        "            FadeIn(venus_orbit, time_span=(2, 4)),\n",
        "            obj.animate.move_to(venus_orbit.get_left()),\n",
        "            run_time=8,\n",
        "        )\n",
        "        self.wait(4)\n",
        "        frame.save_state()\n",
        "\n",
        "        # Zoom back in\n",
        "        frame.clear_updaters()\n",
        "        if False:\n",
        "            # This is for the transition to transit of Venus scene\n",
        "            frame.clear_updaters()\n",
        "            obs_lines.apply_depth_test()\n",
        "            self.remove(line_between, angle_labels, pis, labels)\n",
        "            # self.remove(obs_lines[1])\n",
        "            self.play(\n",
        "                frame.animate.reorient(-62, -2, 0, (4.64, 1.98, 2.86), 15.80),\n",
        "                FadeOut(moon_orbit, time_span=(3, 4)),\n",
        "                FadeOut(moon, time_span=(3, 4)),\n",
        "                FadeOut(earth_orbit, time_span=(3, 4)),\n",
        "                run_time=5,\n",
        "                rate_func=lambda t: smooth(rush_from(t)),\n",
        "            )\n",
        "            self.play(frame.animate.reorient(0, 0, 0, (5.93, 0.25, 0.0), 15.86), run_time=5)\n",
        "            self.wait()\n",
        "\n",
        "            self.play(obs_dots[0].animate.move_to(obs_dots[1]), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        self.play(\n",
        "            frame.animate.reorient(0, 1, 0, (3.02, 0.82, -0.03), 15.80),\n",
        "            FadeOut(moon_orbit, time_span=(3, 4)),\n",
        "            FadeOut(moon, time_span=(3, 4)),\n",
        "            FadeOut(earth_orbit, time_span=(3, 4)),\n",
        "            run_time=4,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.add(angle_labels, obs_lines)\n",
        "        self.play(\n",
        "            Rotate(Group(pis[0], obs_dots[0]), 90 * DEG - angles[0], about_point=earth.get_center()),\n",
        "            Rotate(Group(pis[1], obs_dots[1]), -90 * DEG - angles[1], about_point=earth.get_center()),\n",
        "            MaintainPositionRelativeTo(labels[0], pis[0]),\n",
        "            MaintainPositionRelativeTo(labels[1], pis[1]),\n",
        "            UpdateFromFunc(line_between, lambda m: m.put_start_and_end_on(obs_dots[0].get_center(), obs_dots[1].get_center())),\n",
        "            run_time=3\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Slow zoom out\n",
        "        self.play(\n",
        "            frame.animate.reorient(-33, -9, 0, (20739.48, 3596.8, 5435.71), 33171.78),\n",
        "            FadeIn(earth_orbit, time_span=(10, 12)),\n",
        "            run_time=30,\n",
        "            rate_func=lambda t: smooth(smooth(t))\n",
        "        )\n",
        "\n",
        "        # Zoom out to more of the solar system\n",
        "        # frame.restore()\n",
        "\n",
        "        new_orbits = VGroup(\n",
        "            Circle(radius=r * conversion_factor)\n",
        "            for r in [MERCURY_ORBIT_RADIUS, MARS_ORBIT_RADIUS, JUPITER_ORBIT_RADIUS, SATURN_ORBIT_RADIUS]\n",
        "        )\n",
        "\n",
        "        for orbit, color in zip(new_orbits, [GREY_B, RED, ORANGE, GREY_BROWN]):\n",
        "            orbit.set_stroke(color, (0, 3))\n",
        "            orbit.rotate(random.random() * TAU)\n",
        "            orbit.rotate(90 * DEG, LEFT)\n",
        "            orbit.move_to(sun)\n",
        "\n",
        "        all_orbits = VGroup(new_orbits[0], venus_orbit, earth_orbit, *new_orbits[1:])\n",
        "        periods = [\n",
        "            MERCURY_ORBIT_PERIOD,\n",
        "            VENUS_ORBIT_PERIOD,\n",
        "            EARTH_ORBIT_PERIOD,\n",
        "            MARS_ORBIT_PERIOD,\n",
        "            JUPITER_ORBIT_PERIOD,\n",
        "            SATURN_ORBIT_PERIOD,\n",
        "        ]\n",
        "        for orbit, period in zip(all_orbits, periods):\n",
        "            orbit.period = period\n",
        "            orbit.clear_updaters()\n",
        "            orbit.add_updater(lambda m, dt: m.rotate(20 * dt / m.period, axis=UP))\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(new_orbits, time_span=(0, 3)),\n",
        "            frame.animate.reorient(-29, -41, 0, ORIGIN, 753807.38),\n",
        "            celestial_sphere.animate.set_width(20 * JUPITER_ORBIT_RADIUS * conversion_factor),\n",
        "            run_time=20\n",
        "        )\n",
        "\n",
        "    def get_angle_labels(\n",
        "        self,\n",
        "        obs_lines,\n",
        "        obs_points,\n",
        "        line_between,\n",
        "        arc_props=[0.5, 0.5],\n",
        "        arc_radius=0.5,\n",
        "        colors=[BLUE, RED],\n",
        "        backstroke_width=4,\n",
        "    ):\n",
        "        arc_radius = 0.5\n",
        "        angle_syms = Tex(R\"\\alpha \\beta\")\n",
        "        angle_syms.set_backstroke(BLACK, backstroke_width)\n",
        "        colors = [BLUE, RED]\n",
        "        angle_labels = VGroup()\n",
        "        for obs_line, obs_point, angle_sym, arc_prop, color in zip(obs_lines, obs_points, angle_syms, arc_props, colors):\n",
        "            obs_angle = obs_line.get_angle()\n",
        "            line_angle = line_between.get_angle() + (PI if obs_angle > 0 else 0)\n",
        "            arc = Arc(obs_angle, line_angle - obs_angle, arc_center=obs_point, radius=arc_radius)\n",
        "            arc.set_stroke(color, 3)\n",
        "\n",
        "            angle_sym.next_to(arc.pfp(arc_prop), arc.pfp(arc_prop) - obs_point)\n",
        "            angle_sym.set_fill(color, border_width=1)\n",
        "\n",
        "            angle_labels.add(VGroup(arc, angle_sym))\n",
        "\n",
        "        angle_labels.set_stroke(behind=True)\n",
        "\n",
        "        return angle_labels\n",
        "\n",
        "\n",
        "class TransitOfVenus(InteractiveScene):\n",
        "    path_y = -1\n",
        "    include_image = False\n",
        "\n",
        "    def construct(self):\n",
        "        # Add image (just for development)\n",
        "        if self.include_image:\n",
        "            path = self.file_writer.get_output_file_rootname()\n",
        "            im_path = Path(path.parent.parent, \"Paul Animations/6. Transit Of Venus/New Transit of Venus scenes/JustSun.tif\")\n",
        "            image.set_height(FRAME_HEIGHT)\n",
        "            self.add(image)\n",
        "\n",
        "        # Add venus\n",
        "        path = Line(3 * LEFT, 3 * RIGHT)\n",
        "        path.set_y(self.path_y)\n",
        "        path.set_stroke(BLACK, 2)\n",
        "\n",
        "        venus = Dot(radius=0.05).set_fill(BLACK)\n",
        "        venus.move_to(path.get_start())\n",
        "        venus.set_fill(border_width=1)\n",
        "        venus.set_anti_alias_width(5)\n",
        "        self.add(venus)\n",
        "\n",
        "        # Show transit\n",
        "        venus.move_to(path.get_start())\n",
        "        velocity = 0.25\n",
        "        venus.clear_updaters()\n",
        "        venus.add_updater(lambda m, dt: m.shift(dt * velocity * RIGHT))\n",
        "        wait_time = 1.0\n",
        "        copies = VGroup()\n",
        "        self.add(copies)\n",
        "        for _ in range(int(path.get_length() / velocity / wait_time)):\n",
        "            self.wait(wait_time)\n",
        "            copies.add(venus.copy().clear_updaters())\n",
        "\n",
        "        self.remove(venus)\n",
        "        self.play(Transform(copies, VGroup(path)))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class TransitOfVenusHigher(TransitOfVenus):\n",
        "    path_y = +0.5\n",
        "\n",
        "\n",
        "class TransitOfVenusSlightlyHigher(TransitOfVenus):\n",
        "    path_y = -0.9\n",
        "\n",
        "\n",
        "class TransitOfVenusMiddle(TransitOfVenus):\n",
        "    path_y = 0\n",
        "\n",
        "\n",
        "class NearbyStars(InteractiveScene):\n",
        "    def construct(self):\n",
        "        # Add sun and earth\n",
        "        orbit_radius = 3.5\n",
        "        conversion_factor = orbit_radius / EARTH_ORBIT_RADIUS\n",
        "\n",
        "        sun = get_sun(radius=conversion_factor * SUN_RADIUS, big_glow_ratio=20)\n",
        "        sun.center()\n",
        "        orbit = Circle(radius=orbit_radius)\n",
        "        orbit.set_stroke(BLUE, (0, 4))\n",
        "        earth_glow = GlowDot(color=BLUE)\n",
        "        earth_glow.f_always.move_to(orbit.get_start)\n",
        "\n",
        "        celestial_sphere = get_celestial_sphere(constellation_opacity=0)\n",
        "        celestial_sphere[0].set_opacity(1)\n",
        "\n",
        "        self.add(celestial_sphere, sun, orbit, earth_glow)\n",
        "\n",
        "        # Show the astronomical unit\n",
        "        dist_line = Line()\n",
        "        dist_line.set_stroke(WHITE, 1)\n",
        "        dist_line.f_always.put_start_and_end_on(sun.get_center, orbit.get_start)\n",
        "\n",
        "        dist_label = Text(\"Astronomical\\nUnit\", font_size=36)\n",
        "        dist_label.f_always.move_to(\n",
        "            lambda: dist_line.get_center() + 0.5 * normalize(rotate_vector(dist_line.get_vector(), 90 * DEG))\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeIn(dist_line, time_span=(0, 1)),\n",
        "            FadeIn(dist_label, time_span=(0, 1)),\n",
        "            Rotate(orbit, TAU, about_point=ORIGIN, rate_func=linear, run_time=10),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Transition to initials\n",
        "        dist_label.clear_updaters()\n",
        "        au_label = Text(\"A.U.\", font_size=36)\n",
        "\n",
        "        def update_au_label(label):\n",
        "            point = dist_line.get_center()\n",
        "            direction = normalize(rotate_vector(point, 90 * DEG))\n",
        "            step = 0.65 * interpolate(label.get_width(), label.get_height(), abs(direction[1]))\n",
        "            label.move_to(point + step * direction)\n",
        "\n",
        "        au_label.add_updater(update_au_label)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            *(\n",
        "                ReplacementTransform(dist_label[t2][0], au_label[t1][i])\n",
        "                for t1, t2, i in zip(\"A.U.\", [\"A\", \"stronomical\", \"U\", \"nit\"], [0, 0, 0, 1])\n",
        "            ),\n",
        "            lag_ratio=0.2\n",
        "        ))\n",
        "        self.add(au_label)\n",
        "\n",
        "        # Position to the side\n",
        "        frame = self.frame\n",
        "        self.play(\n",
        "            Rotate(orbit, 90 * DEG),\n",
        "            frame.animate.reorient(0, 0, 0, 7 * RIGHT, 14),\n",
        "            run_time=2\n",
        "        )\n",
        "\n",
        "        # Zoom into and out of earth real quick\n",
        "        frame.save_state()\n",
        "        earth = get_earth(radius=orbit_radius * (EARTH_RADIUS / EARTH_ORBIT_RADIUS))\n",
        "        earth.move_to(earth_glow)\n",
        "        earth.rotate(EARTH_TILT_ANGLE, RIGHT)\n",
        "        frame.move_to(earth)\n",
        "        frame.set_height(2 * earth.get_height())\n",
        "        frame.reorient(-74, 79, 0)\n",
        "        self.camera.light_source.move_to(sun)\n",
        "\n",
        "        self.remove(earth_glow, orbit, dist_line)\n",
        "        self.add(earth)\n",
        "        self.wait()\n",
        "        srf = squish_rate_func(smooth, 0.7, 1)\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(frame, lambda m, a: m.reorient(\n",
        "                *interpolate(np.array([-74, 79, 0]), np.zeros(3), a),\n",
        "                interpolate(earth.get_center(), 7 * RIGHT, srf(a)),\n",
        "                np.exp(interpolate(np.log(2 * earth.get_height()), np.log(14), smooth(a))),\n",
        "            ), run_time=5),\n",
        "            FadeIn(earth_glow, time_span=(2.5, 4.5)),\n",
        "            FadeIn(orbit, time_span=(1, 4)),\n",
        "            FadeIn(dist_line, time_span=(1, 4)),\n",
        "            FadeIn(au_label, time_span=(4, 5)),\n",
        "            FadeOut(earth),\n",
        "            run_time=5,\n",
        "        )\n",
        "\n",
        "        # Show observations\n",
        "        star = Group(\n",
        "            ImageMobject('StarFourPoints').set_height(0.8).center(),\n",
        "            GlowDot(color=WHITE).center()\n",
        "        )\n",
        "        star[1].add_updater(lambda m: m.set_width(0.4 * ((1 + math.sin(1.5 * self.time)))))\n",
        "        star.move_to(50 * RIGHT)\n",
        "        obs_points = Group(\n",
        "            TrueDot(point, radius=0.1).set_color(GREEN).make_3d()\n",
        "            for point in [orbit.get_top(), orbit.get_bottom()]\n",
        "        )\n",
        "        obs_lines = VGroup(\n",
        "            self.get_obs_line(obs_point, star)\n",
        "            for obs_point in obs_points\n",
        "        )\n",
        "        obs_lines.set_stroke(WHITE, 2)\n",
        "        for line, point in zip(obs_lines, obs_points):\n",
        "            line.start_point = point\n",
        "            line.star = star\n",
        "            line.add_updater(lambda m: m.put_start_and_end_on(m.start_point.get_center(), m.star.get_center()))\n",
        "\n",
        "        obs_labels = VGroup(Text(f\"Observation {n}\") for n in [1, 2])\n",
        "        for label, point, vect in zip(obs_labels, obs_points, [UP, DOWN]):\n",
        "            label.next_to(point, vect, MED_SMALL_BUFF)\n",
        "\n",
        "        self.add(star)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(obs_lines[0], suspend_mobject_updating=True),\n",
        "            FadeIn(obs_labels[0], 0.25 * UP),\n",
        "            FadeIn(obs_points[0]),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Rotate(orbit, PI), run_time=2)\n",
        "        self.play(\n",
        "            ShowCreation(obs_lines[1], suspend_mobject_updating=True),\n",
        "            FadeIn(obs_labels[1], DOWN),\n",
        "            FadeIn(obs_points[1]),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Show the angle vary during the orbit\n",
        "        self.play(\n",
        "            star.animate.move_to(15 * RIGHT),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        obs_lines.suspend_updating()\n",
        "        sample_obs_line = self.get_obs_line(earth_glow, star)\n",
        "        self.play(\n",
        "            FadeIn(sample_obs_line),\n",
        "            obs_lines.animate.set_stroke(opacity=0.1)\n",
        "        )\n",
        "        self.play(Rotate(orbit, PI, run_time=10))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeOut(sample_obs_line),\n",
        "            obs_lines.animate.set_stroke(opacity=1),\n",
        "        )\n",
        "\n",
        "        # Pull it far away, then back\n",
        "        curr_center = star.get_center()\n",
        "        curr_angle = obs_lines[1].get_angle() - obs_lines[0].get_angle()\n",
        "        orbit_radius / math.tan(curr_angle / 2)\n",
        "\n",
        "        obs_lines.resume_updating()\n",
        "        self.play(\n",
        "            UpdateFromAlphaFunc(star, lambda m, a: m.move_to(\n",
        "                RIGHT * orbit_radius / math.tan(interpolate(curr_angle, 1e-5, there_and_back_with_pause(a)) / 2)\n",
        "            )),\n",
        "            run_time=6,\n",
        "        )\n",
        "\n",
        "        # Label the distance and angle\n",
        "        line_to_star = Line(sun.get_center(), star.get_center())\n",
        "        line_to_star.set_stroke(RED, 3)\n",
        "        dist_label = Tex(\"D\", font_size=60)\n",
        "        dist_label.next_to(line_to_star, UP, buff=2 * SMALL_BUFF)\n",
        "        dist_label.match_color(line_to_star)\n",
        "\n",
        "        arc = Arc(PI, -curr_angle / 2, arc_center=star.get_center(), radius=3)\n",
        "        arc_label = Tex(R\"\\theta / 2\", font_size=60)\n",
        "        arc_label.next_to(arc, LEFT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(line_to_star),\n",
        "            obs_lines.animate.set_stroke(width=1),\n",
        "            FadeIn(dist_label, RIGHT),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            Write(arc_label),\n",
        "        )\n",
        "        self.play(FlashAround(arc_label, run_time=2))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            Transform(obs_lines[0].copy().clear_updaters(), obs_lines[1].copy(), remover=True),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        # Write the tangent equation\n",
        "        kw = dict(\n",
        "            t2c={R\"\\text{A.U.}\": BLUE, \"D\": RED},\n",
        "            font_size=72\n",
        "        )\n",
        "        eq1, eq2 = equations = VGroup(\n",
        "            Tex(R\"\\tan\\left(\\theta / 2\\right) = {\\text{A.U.} \\over D}\", **kw),\n",
        "            Tex(R\"\\theta = 2 \\cdot \\tan^{-1}\\left({\\text{A.U.} \\over D}\\right)\", **kw),\n",
        "        )\n",
        "        equations.arrange(DOWN, buff=LARGE_BUFF)\n",
        "        equations.next_to(frame.get_top(), DOWN, buff=-0.5)\n",
        "        equations.align_to(dist_label, LEFT)\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            frame.animate.shift(UP),\n",
        "            Write(eq1[R\"\\tan\\left(\"]),\n",
        "            FadeTransform(arc_label.copy(), eq1[R\"\\theta / 2\"][0]),\n",
        "            Write(eq1[R\"\\right) = \"]),\n",
        "            FadeTransform(au_label.copy().clear_updaters(), eq1[\"A.U.\"][0]),\n",
        "            Write(eq1[R\"\\over\"]),\n",
        "            FadeTransform(dist_label.copy(), eq1[\"D\"][0]),\n",
        "            lag_ratio=0.25,\n",
        "            run_time=3\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(TransformMatchingTex(eq1.copy(), eq2, path_arc=90 * DEG, run_time=2))\n",
        "        self.wait()\n",
        "\n",
        "        # Throw in Proxima Centauri numbers\n",
        "        ac_labels = VGroup(\n",
        "            Text(text, font_size=60, t2c={\"D\": RED, \"A.U.\": BLUE})\n",
        "            for text in [\"Proxima Centauri\", \"D = 40.17 trillion km\", \"D = 268,553 A.U.\"]\n",
        "        )\n",
        "        for label in ac_labels:\n",
        "            label.add_background_rectangle()\n",
        "        ac_labels.arrange(DOWN, aligned_edge=LEFT, buff=MED_LARGE_BUFF)\n",
        "        ac_labels.next_to(star, DOWN, aligned_edge=LEFT, buff=0).shift(0.5 * LEFT)\n",
        "        ac_labels[2][0].set_opacity(0)\n",
        "\n",
        "        for label in ac_labels:\n",
        "            self.play(Write(label), frame.animate.set_x(8.5), run_time=2)\n",
        "            self.wait()\n",
        "\n",
        "        # Plug it in\n",
        "        shift_value = 2 * LEFT + 2 * UP\n",
        "        rhs = Tex(R\"= 2 \\cdot \\tan^{-1}\\left(1 \\over 268{,}553 \\right)\", font_size=72)\n",
        "        rhs.next_to(eq2, RIGHT)\n",
        "        rhs.shift(shift_value)\n",
        "\n",
        "        answer = Tex(R\"=0.000413^\\circ\", font_size=72)\n",
        "        answer.next_to(rhs, RIGHT)\n",
        "\n",
        "        answer_in_arc_seconds = Tex(R\"\\approx 1.5 \\text{ arc-seconds}\", font_size=72)\n",
        "        answer_in_arc_seconds.next_to(answer, DOWN, LARGE_BUFF, aligned_edge=LEFT)\n",
        "\n",
        "        for tex in [answer, answer_in_arc_seconds]:\n",
        "            tex.add_background_rectangle()\n",
        "\n",
        "        self.play(LaggedStart(\n",
        "            equations.animate.shift(shift_value),\n",
        "            frame.animate.move_to(11 * RIGHT + 3 * UP).set_height(16),\n",
        "            *(\n",
        "                TransformFromCopy(eq2[tex][0], rhs[tex][0])\n",
        "                for tex in [R\"2 \\cdot \\tan^{-1}\\left(\", R\"\\right)\"]\n",
        "            ),\n",
        "            FadeIn(rhs[R\"1 \\over\"]),\n",
        "            FadeIn(rhs[R\"=\"]),\n",
        "            FadeTransform(ac_labels[2][\"268,553\"].copy(), rhs[\"268{,}553\"].copy()),\n",
        "            run_time=2,\n",
        "            lag_ratio=0.1,\n",
        "        ))\n",
        "        self.wait()\n",
        "        self.play(Write(answer))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(answer_in_arc_seconds, DOWN))\n",
        "        self.wait()\n",
        "\n",
        "        # Fade out and push star away\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeOut,\n",
        "            VGroup(line_to_star, dist_label, arc, arc_label, *ac_labels),\n",
        "            shift=0.1 * DOWN,\n",
        "            lag_ratio=0.25\n",
        "        ))\n",
        "\n",
        "        obs_lines.resume_updating()\n",
        "        self.play(\n",
        "            star.animate.move_to(1000 * RIGHT),\n",
        "            rate_func=lambda t: t**4,\n",
        "            run_time=5\n",
        "        )\n",
        "\n",
        "    def get_obs_line(self, obj1, obj2, dash_length=0.1, stroke_color=WHITE, stroke_width=2):\n",
        "        # line = DashedLine(obj1.get_center(), obj2.get_center())\n",
        "        line = Line(obj1.get_center(), obj2.get_center())\n",
        "        line.set_stroke(stroke_color, stroke_width)\n",
        "        line.f_always.put_start_and_end_on(obj1.get_center, obj2.get_center)\n",
        "        return line\n"
    ]
}