{
    "topic": "the mathematical concept of a quaternion and its visualization using Manim",
    "code": [
        "from manim_imports_ext import *\n",
        "from _2018.quaternions import *\n",
        "\n",
        "W_COLOR = YELLOW\n",
        "I_COLOR = GREEN\n",
        "J_COLOR = RED\n",
        "K_COLOR = BLUE\n",
        "\n",
        "\n",
        "class QuaternionLabel(VGroup):\n",
        "    CONFIG = {\n",
        "        \"decimal_config\": {}\n",
        "    }\n",
        "\n",
        "    def __init__(self, quat, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        dkwargs = dict(self.decimal_config)\n",
        "        decimals = VGroup()\n",
        "        decimals.add(DecimalNumber(quat[0], color=W_COLOR, **dkwargs))\n",
        "        dkwargs[\"include_sign\"] = True\n",
        "        decimals.add(\n",
        "            DecimalNumber(quat[1], color=I_COLOR, **dkwargs),\n",
        "            DecimalNumber(quat[2], color=J_COLOR, **dkwargs),\n",
        "            DecimalNumber(quat[3], color=K_COLOR, **dkwargs),\n",
        "        )\n",
        "        self.add(\n",
        "            decimals[0],\n",
        "            decimals[1], OldTex(\"i\"),\n",
        "            decimals[2], OldTex(\"j\"),\n",
        "            decimals[3], OldTex(\"k\"),\n",
        "        )\n",
        "        self.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "\n",
        "        self.decimals = decimals\n",
        "\n",
        "    def set_value(self, quat):\n",
        "        for decimal, coord in zip(self.decimals, quat):\n",
        "            decimal.set_value(coord)\n",
        "        return self\n",
        "\n",
        "\n",
        "class RandyPrism(Cube):\n",
        "    CONFIG = {\n",
        "        \"height\": 0.25,\n",
        "        \"width\": 1,\n",
        "        \"depth\": 1.2,\n",
        "        \"fill_color\": BLUE_D,\n",
        "        \"fill_opacity\": 0.9,\n",
        "        \"stroke_color\": WHITE,\n",
        "        \"stroke_width\": 1,\n",
        "    }\n",
        "\n",
        "    def __init__(self, **kwargs):\n",
        "        Cube.__init__(self, **kwargs)\n",
        "        self.set_height(1)\n",
        "        randy = Randolph(mode=\"pondering\")\n",
        "        randy.set_height(0.8)\n",
        "        randy.rotate(TAU / 4, RIGHT)\n",
        "        randy.shift(0.7 * DOWN)\n",
        "        randy.set_shade_in_3d(True, z_index_as_group=True)\n",
        "        self.randy = randy\n",
        "        self.add(randy)\n",
        "        self.set_height(self.height, stretch=True)\n",
        "        self.set_width(self.width, stretch=True)\n",
        "        self.set_depth(self.depth, stretch=True)\n",
        "        self.center()\n",
        "\n",
        "\n",
        "class Gimbal(VGroup):\n",
        "    CONFIG = {\n",
        "        \"inner_r\": 1.2,\n",
        "        \"outer_r\": 2.6,\n",
        "    }\n",
        "\n",
        "    def __init__(self, alpha=0, beta=0, gamma=0, inner_mob=None, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "        r1, r2, r3, r4, r5, r6, r7 = np.linspace(\n",
        "            self.inner_r, self.outer_r, 7\n",
        "        )\n",
        "        rings = VGroup(\n",
        "            self.get_ring(r5, r6),\n",
        "            self.get_ring(r3, r4),\n",
        "            self.get_ring(r1, r2),\n",
        "        )\n",
        "        for i, p1, p2 in [(0, r6, r7), (1, r4, r5), (2, r2, r3)]:\n",
        "            annulus = rings[i]\n",
        "            lines = VGroup(\n",
        "                Line(p1 * UP, p2 * UP),\n",
        "                Line(p1 * DOWN, p2 * DOWN),\n",
        "            )\n",
        "            lines.set_stroke(RED)\n",
        "            annulus.lines = lines\n",
        "            annulus.add(lines)\n",
        "        rings[1].lines.rotate(90 * DEGREES, about_point=ORIGIN)\n",
        "        rings.rotate(90 * DEGREES, RIGHT, about_point=ORIGIN)\n",
        "        rings.set_shade_in_3d(True)\n",
        "        self.rings = rings\n",
        "        self.add(rings)\n",
        "\n",
        "        if inner_mob is not None:\n",
        "            corners = [\n",
        "                inner_mob.get_corner(v1 + v2)\n",
        "                for v1 in [LEFT, RIGHT]\n",
        "                for v2 in [IN, OUT]\n",
        "            ]\n",
        "            lines = VGroup()\n",
        "            for corner in corners:\n",
        "                corner[1] = 0\n",
        "                line = Line(\n",
        "                    corner, self.inner_r * normalize(corner),\n",
        "                    color=WHITE,\n",
        "                    stroke_width=1\n",
        "                )\n",
        "                lines.add(line)\n",
        "            lines.set_shade_in_3d(True)\n",
        "            rings[2].add(lines, inner_mob)\n",
        "\n",
        "        # Rotations\n",
        "        angles = [alpha, beta, gamma]\n",
        "        for i, angle in zip(it.count(), angles):\n",
        "            vect = rings[i].lines[0].get_vector()\n",
        "            rings[i:].rotate(angle=angle, axis=vect)\n",
        "\n",
        "    def get_ring(self, in_r, out_r, angle=TAU / 4):\n",
        "        result = VGroup()\n",
        "        for start_angle in np.arange(0, TAU, angle):\n",
        "            start_angle += angle / 2\n",
        "            sector = AnnularSector(\n",
        "                inner_radius=in_r,\n",
        "                outer_radius=out_r,\n",
        "                angle=angle,\n",
        "                start_angle=start_angle\n",
        "            )\n",
        "            sector.set_fill(GREY_B, 0.8)\n",
        "            arcs = VGroup(*[\n",
        "                Arc(\n",
        "                    angle=angle,\n",
        "                    start_angle=start_angle,\n",
        "                    radius=r\n",
        "                )\n",
        "                for r in [in_r, out_r]\n",
        "            ])\n",
        "            arcs.set_stroke(BLACK, 1, opacity=0.5)\n",
        "            sector.add(arcs)\n",
        "            result.add(sector)\n",
        "        return result\n",
        "\n",
        "\n",
        "# Scenes\n",
        "\n",
        "class ButFirst(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        for student in self.students:\n",
        "            student.change(\"surprised\")\n",
        "\n",
        "        self.teacher_says(\"But first!\")\n",
        "        self.play_all_student_changes(\"happy\")\n",
        "        self.play(RemovePiCreatureBubble(\n",
        "            self.teacher,\n",
        "            target_mode=\"raise_right_hand\"\n",
        "        ))\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"] * 3,\n",
        "            look_at=self.screen,\n",
        "        )\n",
        "        self.play(self.teacher.look_at, self.screen)\n",
        "        self.wait(4)\n",
        "\n",
        "\n",
        "class Introduction(QuaternionHistory):\n",
        "    CONFIG = {\n",
        "        \"names_and_quotes\": [\n",
        "            (\n",
        "                \"Oliver Heaviside\",\n",
        "                \"\"\"\\\\Huge ``the quaternion was not only not\n",
        "                required, but was a positive evil''\"\"\"\n",
        "            ),\n",
        "            (\n",
        "                \"Lord Kelvin\",\n",
        "                \"\"\"\\\\Huge ``Quaternions... though beautifully \\\\\\\\ ingenious,\n",
        "                have been an unmixed evil'' \"\"\"\n",
        "            ),\n",
        "        ]\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        title_word = OldTexText(\"Quaternions:\")\n",
        "        title_equation = OldTex(\n",
        "            \"i^2 = j^2 = k^2 = ijk = -1\",\n",
        "            tex_to_color_map={\n",
        "                \"i\": I_COLOR,\n",
        "                \"j\": J_COLOR,\n",
        "                \"k\": K_COLOR,\n",
        "            }\n",
        "        )\n",
        "        # label = QuaternionLabel([\n",
        "        #     float(str((TAU * 10**(3 * k)) % 10)[:4])\n",
        "        #     for k in range(4)\n",
        "        # ])\n",
        "        title = VGroup(title_word, title_equation)\n",
        "        title.arrange(RIGHT)\n",
        "        title.to_edge(UP)\n",
        "\n",
        "        images_group = self.get_dissenter_images_quotes_and_names()\n",
        "        images_group.to_edge(DOWN)\n",
        "        images, quotes, names = images_group\n",
        "        for pair in images_group:\n",
        "            pair[1].align_to(pair[0], UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(title_word),\n",
        "            Write(title_equation)\n",
        "        )\n",
        "        self.wait()\n",
        "        for image, name, quote in zip(images, names, quotes):\n",
        "            self.play(\n",
        "                FadeIn(image, 3 * DOWN),\n",
        "                FadeInFromLarge(name),\n",
        "                LaggedStartMap(\n",
        "                    FadeIn, VGroup(*it.chain(*quote)),\n",
        "                    lag_ratio=0.3,\n",
        "                    run_time=2\n",
        "                )\n",
        "            )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            title.shift, 2 * UP,\n",
        "            *[\n",
        "                ApplyMethod(mob.shift, FRAME_WIDTH * vect / 2)\n",
        "                for pair in images_group\n",
        "                for mob, vect in zip(pair, [LEFT, RIGHT])\n",
        "            ],\n",
        "        )\n",
        "\n",
        "\n",
        "class WhoCares(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        quotes = Group(*[\n",
        "            ImageMobject(\n",
        "                \"CoderQuaternionResponse_{}\".format(d),\n",
        "                height=2\n",
        "            )\n",
        "            for d in range(4)\n",
        "        ])\n",
        "        logos = Group(*[\n",
        "            ImageMobject(name, height=0.5)\n",
        "            for name in [\n",
        "                \"TwitterLogo\",\n",
        "                \"HackerNewsLogo\",\n",
        "                \"RedditLogo\",\n",
        "                \"YouTubeLogo\",\n",
        "            ]\n",
        "        ])\n",
        "        for quote, logo in zip(quotes, logos):\n",
        "            logo.move_to(quote.get_corner(UR))\n",
        "            quote.add(logo)\n",
        "\n",
        "        quotes.arrange_in_grid()\n",
        "        quotes.set_height(4)\n",
        "        quotes.to_corner(UL)\n",
        "\n",
        "        self.student_says(\n",
        "            \"Um...who cares?\",\n",
        "            target_mode=\"sassy\",\n",
        "            added_anims=[self.teacher.change, \"guilty\"]\n",
        "        )\n",
        "        self.play_student_changes(\"angry\", \"sassy\", \"sad\")\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change, \"raise_right_hand\"\n",
        "        )\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(\n",
        "        #         FadeInFromDown, quotes,\n",
        "        #         run_time=3\n",
        "        #     ),\n",
        "        #     self.change_students(*3 * [\"pondering\"], look_at=quotes)\n",
        "        # )\n",
        "        # self.wait(2)\n",
        "\n",
        "        # # Show HN\n",
        "        # hn_quote = quotes[1]\n",
        "        # hn_context = OldTexText(\"news.ycombinator.com/item?id=17933908\")\n",
        "        # hn_context.scale(0.7)\n",
        "        # hn_context.to_corner(UL)\n",
        "\n",
        "        # vr_headsets = VGroup()\n",
        "        # for pi in self.students:\n",
        "        #     vr_headset = SVGMobject(\"VR_headset\")\n",
        "        #     vr_headset.set_fill(GREY_B, opacity=0.9)\n",
        "        #     vr_headset.set_width(pi.eyes.get_width() + 0.3)\n",
        "        #     vr_headset.move_to(pi.eyes)\n",
        "        #     vr_headsets.add(vr_headset)\n",
        "\n",
        "        # self.play(\n",
        "        #     hn_quote.scale, 2, {\"about_edge\": DL},\n",
        "        #     FadeOut(quotes[0], 5 * UP),\n",
        "        #     FadeOut(quotes[2], UR),\n",
        "        #     FadeOut(quotes[3], RIGHT),\n",
        "        #     FadeInFromDown(hn_context),\n",
        "        # )\n",
        "        # hn_rect = Rectangle(\n",
        "        #     height=0.1 * hn_quote.get_height(),\n",
        "        #     width=0.6 * hn_quote.get_width(),\n",
        "        #     color=RED\n",
        "        # )\n",
        "        # hn_rect.move_to(hn_quote, UL)\n",
        "        # hn_rect.shift(0.225 * RIGHT + 0.75 * DOWN)\n",
        "        # self.play(\n",
        "        #     ShowCreation(hn_rect),\n",
        "        #     self.change_students(\n",
        "        #         \"erm\", \"thinking\", \"confused\",\n",
        "        #         look_at=hn_quote,\n",
        "        #     )\n",
        "        # )\n",
        "        # self.add_foreground_mobjects(vr_headsets)\n",
        "        # self.play(\n",
        "        #     LaggedStartMap(\n",
        "        #         FadeInFrom, vr_headsets,\n",
        "        #         lambda m: (m, UP),\n",
        "        #     ),\n",
        "        #     self.change_students(\n",
        "        #         *3 * [\"sick\"],\n",
        "        #         look_at=hn_quote,\n",
        "        #         run_time=3\n",
        "        #     )\n",
        "        # )\n",
        "        # self.wait(3)\n",
        "\n",
        "        # Show Twitter\n",
        "        t_quote = quotes[0]\n",
        "        # t_quote.next_to(FRAME_WIDTH * LEFT / 2 + FRAME_WIDTH * UP / 2, UR)\n",
        "        # t_quote.set_opacity(0)\n",
        "        # self.play(\n",
        "        #     FadeOut(hn_quote, 4 * LEFT),\n",
        "        #     FadeOut(hn_rect, 4 * LEFT),\n",
        "        #     FadeOut(hn_context, UP),\n",
        "        #     FadeOut(vr_headsets),\n",
        "        #     t_quote.set_opacity, 1,\n",
        "        #     t_quote.scale, 2,\n",
        "        #     t_quote.to_corner, UL,\n",
        "        # )\n",
        "        # self.remove_foreground_mobjects(vr_headsets)\n",
        "        t_quote.fade(1)\n",
        "        t_quote.to_corner(UL)\n",
        "        self.play(\n",
        "            self.change_students(*3 * [\"pondering\"], look_at=quotes),\n",
        "            t_quote.set_opacity, 1,\n",
        "            t_quote.scale, 2,\n",
        "            t_quote.to_corner, UL,\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"happy\", \"tease\",\n",
        "            look_at=t_quote\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(t_quote))\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ShowSeveralQuaternionRotations(SpecialThreeDScene):\n",
        "    CONFIG = {\n",
        "        \"quaternions\": [\n",
        "            [0, 1, 0, 0],\n",
        "            [1, 0, 0, 0],\n",
        "            [1, 0, 1, 0],\n",
        "            [1, 1, 1, -1],\n",
        "            [0, -1, 2, 1],\n",
        "            [1, 0, 0, -1],\n",
        "            [1, -1, 0, 0],\n",
        "            [1, -1, 1, 0],\n",
        "            [1, -1, 1, -1],\n",
        "            [1, 0, 0, 0],\n",
        "        ],\n",
        "        \"start_phi\": 70 * DEGREES,\n",
        "        \"start_theta\": -140 * DEGREES,\n",
        "        \"ambient_rotation_rate\": 0.01,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_q_tracker()\n",
        "        self.setup_labels()\n",
        "        self.setup_camera_position()\n",
        "        self.add_prism()\n",
        "        self.add_axes()\n",
        "        self.apply_quaternions()\n",
        "\n",
        "    def add_q_tracker(self):\n",
        "        self.q_tracker = QuaternionTracker()\n",
        "        self.q_tracker.add_updater(lambda m: m.normalize())\n",
        "        self.add(self.q_tracker)\n",
        "\n",
        "    def setup_labels(self):\n",
        "        left_q_label = QuaternionLabel([1, 0, 0, 0])\n",
        "        right_q_label = QuaternionLabel([1, 0, 0, 0])\n",
        "        for label in left_q_label, right_q_label:\n",
        "            lp, rp = OldTex(\"()\")\n",
        "            lp.next_to(label, LEFT, SMALL_BUFF)\n",
        "            rp.next_to(label, RIGHT, SMALL_BUFF)\n",
        "            label.add(lp, rp)\n",
        "        point_label = OldTex(\n",
        "            *\"(xi+yj+zk)\",\n",
        "            tex_to_color_map={\n",
        "                \"i\": I_COLOR,\n",
        "                \"j\": J_COLOR,\n",
        "                \"k\": K_COLOR,\n",
        "            }\n",
        "        )\n",
        "        left_q_label.next_to(point_label, LEFT)\n",
        "        right_q_label.next_to(point_label, RIGHT)\n",
        "        group = VGroup(left_q_label, point_label, right_q_label)\n",
        "        group.arrange(RIGHT)\n",
        "        group.set_width(FRAME_WIDTH - 1)\n",
        "        group.to_edge(UP)\n",
        "        self.add_fixed_in_frame_mobjects(BackgroundRectangle(group))\n",
        "\n",
        "        for label, text in zip(group, [\"$q$\", \"Some 3d point\", \"$q^{-1}$\"]):\n",
        "            brace = Brace(label, DOWN)\n",
        "            text_mob = OldTexText(text)\n",
        "            if text_mob.get_width() > brace.get_width():\n",
        "                text_mob.match_width(brace)\n",
        "            text_mob.next_to(brace, DOWN, buff=SMALL_BUFF)\n",
        "            text_mob.add_background_rectangle()\n",
        "            label.add(brace, text_mob)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(*group)\n",
        "\n",
        "        left_q_label.add_updater(\n",
        "            lambda m: m.set_value(self.q_tracker.get_value())\n",
        "        )\n",
        "        left_q_label.add_updater(lambda m: self.add_fixed_in_frame_mobjects(m))\n",
        "        right_q_label.add_updater(\n",
        "            lambda m: m.set_value(quaternion_conjugate(\n",
        "                self.q_tracker.get_value()\n",
        "            ))\n",
        "        )\n",
        "        right_q_label.add_updater(lambda m: self.add_fixed_in_frame_mobjects(m))\n",
        "\n",
        "    def setup_camera_position(self):\n",
        "        self.set_camera_orientation(\n",
        "            phi=self.start_phi,\n",
        "            theta=self.start_theta,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(self.ambient_rotation_rate)\n",
        "\n",
        "    def add_prism(self):\n",
        "        prism = self.prism = self.get_prism()\n",
        "        prism.add_updater(\n",
        "            lambda p: p.become(self.get_prism(\n",
        "                self.q_tracker.get_value()\n",
        "            ))\n",
        "        )\n",
        "        self.add(prism)\n",
        "\n",
        "    def add_axes(self):\n",
        "        axes = self.axes = always_redraw(self.get_axes)\n",
        "        self.add(axes)\n",
        "\n",
        "    def apply_quaternions(self):\n",
        "        for quat in self.quaternions:\n",
        "            self.change_q(quat)\n",
        "            self.wait(2)\n",
        "\n",
        "    #\n",
        "    def get_unrotated_prism(self):\n",
        "        return RandyPrism().scale(2)\n",
        "\n",
        "    def get_prism(self, quaternion=[1, 0, 0, 0]):\n",
        "        prism = self.get_unrotated_prism()\n",
        "        angle, axis = angle_axis_from_quaternion(quaternion)\n",
        "        prism.rotate(angle=angle, axis=axis, about_point=ORIGIN)\n",
        "        return prism\n",
        "\n",
        "    def get_axes(self):\n",
        "        prism = self.prism\n",
        "        centers = [sm.get_center() for sm in prism[:6]]\n",
        "        axes = VGroup()\n",
        "        for i in range(3):\n",
        "            for u in [-1, 1]:\n",
        "                vect = np.zeros(3)\n",
        "                vect[i] = u\n",
        "                dots = [np.dot(normalize(c), vect) for c in centers]\n",
        "                max_i = np.argmax(dots)\n",
        "                ec = centers[max_i]\n",
        "                prism.get_edge_center(vect)\n",
        "                p1 = np.zeros(3)\n",
        "                p1[i] = ec[i]\n",
        "                p1 *= dots[max_i]\n",
        "                p2 = 10 * vect\n",
        "                axes.add(Line(p1, p2))\n",
        "        axes.set_stroke(GREY_B, 1)\n",
        "        axes.set_shade_in_3d(True)\n",
        "        return axes\n",
        "\n",
        "    def change_q(self, value, run_time=3, added_anims=None, **kwargs):\n",
        "        if added_anims is None:\n",
        "            added_anims = []\n",
        "        self.play(\n",
        "            self.q_tracker.set_value, value,\n",
        "            *added_anims,\n",
        "            run_time=run_time,\n",
        "            **kwargs\n",
        "        )\n",
        "\n",
        "\n",
        "class PauseAndPlayOverlay(Scene):\n",
        "    def construct(self):\n",
        "        pause = OldTex(\"=\").rotate(TAU / 4)\n",
        "        pause.stretch(2, 0)\n",
        "        pause.scale(1.5)\n",
        "        arrow = Vector(RIGHT, color=WHITE)\n",
        "        interact = OldTexText(\"Interact...\")\n",
        "        group = VGroup(pause, arrow, interact)\n",
        "        group.arrange(RIGHT)\n",
        "        group.scale(2)\n",
        "\n",
        "        not_yet = OldTexText(\"...well, not yet\")\n",
        "        not_yet.scale(2)\n",
        "        not_yet.next_to(group, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(Write(pause))\n",
        "        self.play(\n",
        "            GrowFromPoint(\n",
        "                interact, arrow.get_left(),\n",
        "                rate_func=squish_rate_func(smooth, 0.3, 1)\n",
        "            ),\n",
        "            VFadeIn(interact),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(not_yet))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RotationMatrix(ShowSeveralQuaternionRotations):\n",
        "    CONFIG = {\n",
        "        \"start_phi\": 60 * DEGREES,\n",
        "        \"start_theta\": -60 * DEGREES,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_q_tracker()\n",
        "        self.setup_camera_position()\n",
        "        self.add_prism()\n",
        "        self.add_basis_vector_labels()\n",
        "        self.add_axes()\n",
        "\n",
        "        title = OldTexText(\"Rotation matrix\")\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UL)\n",
        "        self.add_fixed_in_frame_mobjects(title)\n",
        "\n",
        "        angle = 75 * DEGREES\n",
        "        axis = [0.3, 1, 0.3]\n",
        "        matrix = rotation_matrix(angle=angle, axis=axis)\n",
        "        matrix_mob = DecimalMatrix(matrix, h_buff=1.6)\n",
        "        matrix_mob.next_to(title, DOWN)\n",
        "        matrix_mob.to_edge(LEFT)\n",
        "        title.next_to(matrix_mob, UP)\n",
        "        self.add_fixed_in_frame_mobjects(matrix_mob)\n",
        "\n",
        "        colors = [I_COLOR, J_COLOR, K_COLOR]\n",
        "        matrix_mob.set_column_colors(*colors)\n",
        "\n",
        "        columns = matrix_mob.get_columns()\n",
        "        column_rects = VGroup(*[\n",
        "            SurroundingRectangle(c).match_color(c[0])\n",
        "            for c in columns\n",
        "        ])\n",
        "        labels = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"Where\", tex, \"goes\",\n",
        "                tex_to_color_map={tex: rect.get_color()}\n",
        "            ).next_to(rect, DOWN)\n",
        "            for letter, rect in zip([\"\\\\i\", \"\\\\j\", \"k\"], column_rects)\n",
        "            for tex in [\"$\\\\hat{\\\\textbf{%s}}$\" % (letter)]\n",
        "        ])\n",
        "        labels.space_out_submobjects(0.8)\n",
        "\n",
        "        quaternion = quaternion_from_angle_axis(angle, axis)\n",
        "\n",
        "        self.play(Write(matrix_mob))\n",
        "        self.change_q(quaternion)\n",
        "        self.wait()\n",
        "        last_label = VectorizedPoint(matrix_mob.get_bottom())\n",
        "        last_rect = VMobject()\n",
        "        for label, rect in zip(labels, column_rects):\n",
        "            self.add_fixed_in_frame_mobjects(rect, label)\n",
        "            self.play(\n",
        "                FadeIn(label),\n",
        "                FadeOut(last_label),\n",
        "                ShowCreation(rect),\n",
        "                FadeOut(last_rect)\n",
        "            )\n",
        "            self.wait()\n",
        "            last_label = label\n",
        "            last_rect = rect\n",
        "        self.play(FadeOut(last_label), FadeOut(last_rect))\n",
        "        self.wait(5)\n",
        "\n",
        "    def get_unrotated_prism(self):\n",
        "        prism = RandyPrism()\n",
        "        prism.scale(1.5)\n",
        "        arrows = VGroup()\n",
        "        for i, color in enumerate([I_COLOR, J_COLOR, K_COLOR]):\n",
        "            vect = np.zeros(3)\n",
        "            vect[i] = 1\n",
        "            arrow = Arrow(\n",
        "                prism.get_edge_center(vect), 2 * vect,\n",
        "                preserve_tip_size_when_scaling=False,\n",
        "                color=color,\n",
        "                buff=0,\n",
        "            )\n",
        "            arrows.add(arrow)\n",
        "        arrows.set_shade_in_3d(True)\n",
        "        prism.arrows = arrows\n",
        "        prism.add(arrows)\n",
        "        return prism\n",
        "\n",
        "    def add_basis_vector_labels(self):\n",
        "        labels = VGroup(\n",
        "            OldTex(\"\\\\hat{\\\\textbf{\\\\i}}\"),\n",
        "            OldTex(\"\\\\hat{\\\\textbf{\\\\j}}\"),\n",
        "            OldTex(\"\\\\hat{\\\\textbf{k}}\"),\n",
        "        )\n",
        "\n",
        "        def generate_updater(arrow):\n",
        "            return lambda m: m.move_to(\n",
        "                arrow.get_end() + 0.2 * normalize(arrow.get_vector()),\n",
        "            )\n",
        "\n",
        "        for arrow, label in zip(self.prism.arrows, labels):\n",
        "            label.match_color(arrow)\n",
        "            label.add_updater(generate_updater(arrow))\n",
        "            self.add_fixed_orientation_mobjects(label)\n",
        "\n",
        "\n",
        "class EulerAnglesAndGimbal(ShowSeveralQuaternionRotations):\n",
        "    def construct(self):\n",
        "        self.setup_position()\n",
        "        self.setup_angle_trackers()\n",
        "        self.setup_gimbal()\n",
        "        self.add_axes()\n",
        "        self.add_title()\n",
        "        self.show_rotations()\n",
        "\n",
        "    def setup_position(self):\n",
        "        self.set_camera_orientation(\n",
        "            theta=-140 * DEGREES,\n",
        "            phi=70 * DEGREES,\n",
        "        )\n",
        "        self.begin_ambient_camera_rotation(rate=0.015)\n",
        "\n",
        "    def setup_angle_trackers(self):\n",
        "        self.alpha_tracker = ValueTracker(0)\n",
        "        self.beta_tracker = ValueTracker(0)\n",
        "        self.gamma_tracker = ValueTracker(0)\n",
        "\n",
        "    def setup_gimbal(self):\n",
        "        gimbal = always_redraw(self.get_gimbal)\n",
        "        self.gimbal = gimbal\n",
        "        self.add(gimbal)\n",
        "\n",
        "    def add_title(self):\n",
        "        title = OldTexText(\"Euler angles\")\n",
        "        title.scale(1.5)\n",
        "        title.to_corner(UL)\n",
        "        angle_labels = VGroup(\n",
        "            OldTex(\"\\\\alpha\").set_color(YELLOW),\n",
        "            OldTex(\"\\\\beta\").set_color(GREEN),\n",
        "            OldTex(\"\\\\gamma\").set_color(PINK),\n",
        "        )\n",
        "        angle_labels.scale(2)\n",
        "        angle_labels.arrange(RIGHT, buff=MED_LARGE_BUFF)\n",
        "        angle_labels.next_to(title, DOWN, aligned_edge=LEFT)\n",
        "        self.angle_labels = angle_labels\n",
        "\n",
        "        gl_label = VGroup(\n",
        "            Arrow(LEFT, RIGHT, color=WHITE),\n",
        "            OldTexText(\"Gimbal lock\").scale(1.5),\n",
        "        )\n",
        "        gl_label.arrange(RIGHT)\n",
        "        gl_label.next_to(title, RIGHT)\n",
        "        self.gimbal_lock_label = gl_label\n",
        "\n",
        "        VGroup(title, angle_labels, gl_label).center().to_edge(UP)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(title, angle_labels, gl_label)\n",
        "        self.remove(angle_labels)\n",
        "        self.remove(gl_label)\n",
        "\n",
        "    def show_rotations(self):\n",
        "        gimbal = self.gimbal\n",
        "        alpha_tracker = self.alpha_tracker\n",
        "        beta_tracker = self.beta_tracker\n",
        "        gamma_tracker = self.gamma_tracker\n",
        "\n",
        "        angles = [-60 * DEGREES, 50 * DEGREES, 45 * DEGREES]\n",
        "        trackers = [alpha_tracker, beta_tracker, gamma_tracker]\n",
        "        in_rs = [0.6, 0.5, 0.6]\n",
        "        for i in range(3):\n",
        "            tracker = trackers[i]\n",
        "            angle = angles[i]\n",
        "            in_r = in_rs[i]\n",
        "            ring = gimbal.rings[i]\n",
        "\n",
        "            vect = ring.lines[0].get_vector()\n",
        "            line = self.get_dotted_line(vect, in_r=in_r)\n",
        "            angle_label = self.angle_labels[i]\n",
        "            line.match_color(angle_label)\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                FadeInFromDown(angle_label)\n",
        "            )\n",
        "            self.play(\n",
        "                tracker.set_value, angle,\n",
        "                run_time=3\n",
        "            )\n",
        "            self.play(FadeOut(line))\n",
        "            self.wait()\n",
        "        self.wait(3)\n",
        "        self.play(Write(self.gimbal_lock_label))\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 0,\n",
        "            beta_tracker.set_value, 0,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 90 * DEGREES,\n",
        "            gamma_tracker.set_value, -90 * DEGREES,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            FadeOut(self.gimbal_lock_label),\n",
        "            *[ApplyMethod(t.set_value, 0) for t in trackers],\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 30 * DEGREES,\n",
        "            beta_tracker.set_value, 120 * DEGREES,\n",
        "            gamma_tracker.set_value, -50 * DEGREES,\n",
        "            run_time=3\n",
        "        )\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 120 * DEGREES,\n",
        "            beta_tracker.set_value, -30 * DEGREES,\n",
        "            gamma_tracker.set_value, 90 * DEGREES,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.play(\n",
        "            beta_tracker.set_value, 150 * DEGREES,\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play(\n",
        "            alpha_tracker.set_value, 0,\n",
        "            beta_tracker.set_value, 0,\n",
        "            gamma_tracker.set_value, 0,\n",
        "            run_time=4\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    #\n",
        "    def get_gimbal(self):\n",
        "        self.prism = RandyPrism()\n",
        "        return Gimbal(\n",
        "            alpha=self.alpha_tracker.get_value(),\n",
        "            beta=self.beta_tracker.get_value(),\n",
        "            gamma=self.gamma_tracker.get_value(),\n",
        "            inner_mob=self.prism\n",
        "        )\n",
        "\n",
        "    def get_dotted_line(self, vect, in_r=0, out_r=10):\n",
        "        line = VGroup(*it.chain(*[\n",
        "            DashedLine(\n",
        "                in_r * normalize(u * vect),\n",
        "                out_r * normalize(u * vect),\n",
        "            )\n",
        "            for u in [-1, 1]\n",
        "        ]))\n",
        "        line.sort(get_norm)\n",
        "        line.set_shade_in_3d(True)\n",
        "        line.set_stroke(YELLOW, 5)\n",
        "        line.center()\n",
        "        return line\n",
        "\n",
        "\n",
        "class InterpolationFail(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\n",
        "            \"Sometimes interpolating 3d\\\\\\\\\"\n",
        "            \"orientations is tricky...\"\n",
        "        )\n",
        "        words.to_edge(UP)\n",
        "        self.add(words)\n",
        "\n",
        "\n",
        "class QuaternionInterpolation(ShowSeveralQuaternionRotations):\n",
        "    def construct(self):\n",
        "        self.add_q_tracker()\n",
        "        self.setup_camera_position()\n",
        "        self.add_prism()\n",
        "        self.add_axes()\n",
        "\n",
        "        self.change_q([1, 1, 1, 0], run_time=0)\n",
        "        self.wait(2)\n",
        "        self.change_q([1, 0.2, 0.6, -0.5], run_time=4)\n",
        "        self.wait(2)\n",
        "        self.change_q([1, -0.6, 0.2, -1], run_time=4)\n",
        "        self.wait(2)\n",
        "\n",
        "\n",
        "class QuaternionInterpolationScematic(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Slice of a hypersphere\")\n",
        "        title.to_edge(UP, buff=MED_SMALL_BUFF)\n",
        "        self.add(title)\n",
        "\n",
        "        radius = 3\n",
        "        circle = Circle(radius=radius)\n",
        "        circle.set_stroke(GREY_B, 1)\n",
        "        qs = [circle.point_from_proportion(p) for p in (0.55, 0.35, 0.15)]\n",
        "        colors = [YELLOW, PINK, RED]\n",
        "        q_dots = [Dot(q, color=c) for q, c in zip(qs, colors)]\n",
        "        q_labels = [\n",
        "            OldTex(\"q_{}\".format(i + 1)).next_to(\n",
        "                dot, normalize(dot.get_center()), SMALL_BUFF\n",
        "            ).match_color(dot)\n",
        "            for i, dot in enumerate(q_dots)\n",
        "        ]\n",
        "\n",
        "        q1, q2, q3 = qs\n",
        "        lines = [\n",
        "            DashedLine(q1, q2)\n",
        "            for q1, q2 in zip(qs, qs[1:])\n",
        "        ]\n",
        "        for color, line in zip([GREEN, BLUE], lines):\n",
        "            line.set_stroke(color, 3)\n",
        "            line.proj = line.copy().apply_function(\n",
        "                lambda p: radius * normalize(p)\n",
        "            )\n",
        "        dot = Dot(qs[0], color=WHITE)\n",
        "\n",
        "        self.add(circle)\n",
        "        self.add(dot)\n",
        "        self.add(*q_dots + q_labels)\n",
        "\n",
        "        self.wait(2)\n",
        "        for line, q in zip(lines, qs[1:]):\n",
        "            self.play(\n",
        "                ShowCreation(line),\n",
        "                ShowCreation(line.proj),\n",
        "                dot.move_to, q,\n",
        "                run_time=4\n",
        "            )\n",
        "            self.wait(2)\n",
        "\n",
        "\n",
        "class RememberComplexNumbers(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        complex_number = OldTex(\n",
        "            \"\\\\cos(\\\\theta) + \\\\sin(\\\\theta)i\",\n",
        "            tex_to_color_map={\n",
        "                \"\\\\cos(\\\\theta)\": GREEN,\n",
        "                \"\\\\sin(\\\\theta)\": RED\n",
        "            }\n",
        "        )\n",
        "        complex_number.scale(1.2)\n",
        "        complex_number.next_to(self.students, UP, MED_LARGE_BUFF)\n",
        "\n",
        "        self.teacher_says(\n",
        "            \"Remember how \\\\\\\\ complex numbers \\\\\\\\ compute rotations\"\n",
        "        )\n",
        "        self.play_all_student_changes(\"pondering\")\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(complex_number),\n",
        "            self.change_students(\n",
        "                \"thinking\", \"confused\", \"happy\",\n",
        "                look_at=complex_number.get_center() + UP\n",
        "            ),\n",
        "            run_time=2\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class ComplexNumberRotation(Scene):\n",
        "    CONFIG = {\n",
        "        \"angle\": 30 * DEGREES,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_plane()\n",
        "        self.add_number()\n",
        "        self.show_complex_unit()\n",
        "        self.show_product()\n",
        "\n",
        "    def add_plane(self):\n",
        "        plane = self.plane = ComplexPlane()\n",
        "        self.play(Write(plane))\n",
        "\n",
        "    def add_number(self):\n",
        "        plane = self.plane\n",
        "        origin = plane.coords_to_point(0, 0)\n",
        "        angle = self.angle\n",
        "\n",
        "        point = plane.coords_to_point(4, 1)\n",
        "        dot = Dot(point, color=YELLOW)\n",
        "        label = OldTex(\"(4, 1)\")\n",
        "        label.next_to(dot, UR, buff=0)\n",
        "        line = DashedLine(origin, point)\n",
        "        rotated_line = line.copy().rotate(angle, about_point=origin)\n",
        "        rotated_line.set_color(GREY)\n",
        "        rotated_dot = dot.copy().rotate(angle, about_point=origin)\n",
        "        rotated_dot.set_color(YELLOW_E)\n",
        "        mystery_label = OldTex(\"(?, ?)\")\n",
        "        mystery_label.next_to(rotated_dot, UR, buff=0)\n",
        "\n",
        "        arc = Arc(\n",
        "            start_angle=line.get_angle(),\n",
        "            angle=angle,\n",
        "            radius=0.75\n",
        "        )\n",
        "        angle_tex = str(int(np.round(angle / DEGREES))) + \"^\\\\circ\"\n",
        "        angle_label = OldTex(angle_tex)\n",
        "        angle_label.next_to(\n",
        "            arc.point_from_proportion(0.3),\n",
        "            UR, buff=SMALL_BUFF\n",
        "        )\n",
        "\n",
        "        self.play(\n",
        "            FadeInFromDown(label),\n",
        "            GrowFromCenter(dot),\n",
        "            ShowCreation(line)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(arc),\n",
        "            FadeInFromDown(angle_label),\n",
        "            TransformFromCopy(line, rotated_line),\n",
        "            TransformFromCopy(dot, rotated_dot),\n",
        "            path_arc=angle,\n",
        "        )\n",
        "        self.play(Write(mystery_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.rotation_mobs = VGroup(\n",
        "            arc, angle_label,\n",
        "            rotated_line, rotated_dot,\n",
        "            mystery_label\n",
        "        )\n",
        "        self.angle_tex = angle_tex\n",
        "        self.number_label = label\n",
        "\n",
        "    def show_complex_unit(self):\n",
        "        plane = self.plane\n",
        "        angle = self.angle\n",
        "        angle_tex = self.angle_tex\n",
        "        complex_coordinate_labels = plane.get_coordinate_labels()\n",
        "        unit_circle = Circle(radius=1, color=YELLOW)\n",
        "\n",
        "        origin = plane.number_to_point(0)\n",
        "        z_point = plane.coords_to_point(np.cos(angle), np.sin(angle))\n",
        "        one_point = plane.number_to_point(1)\n",
        "        z_dot = Dot(z_point, color=WHITE)\n",
        "        one_dot = Dot(one_point, color=WHITE)\n",
        "        one_dot.fade(1)\n",
        "        z_line = Line(origin, z_point)\n",
        "        one_line = Line(origin, one_point)\n",
        "        VGroup(z_dot, one_dot, z_line, one_line).set_color(BLUE)\n",
        "\n",
        "        cos_tex = \"\\\\cos(\" + angle_tex + \")\"\n",
        "        sin_tex = \"\\\\sin(\" + angle_tex + \")\"\n",
        "        label = OldTex(\n",
        "            cos_tex, \"+\", sin_tex, \"i\",\n",
        "            tex_to_color_map={cos_tex: GREEN, sin_tex: RED}\n",
        "        )\n",
        "        label.add_background_rectangle()\n",
        "        label.scale(0.8)\n",
        "        label.next_to(plane.coords_to_point(0, 1), UR, SMALL_BUFF)\n",
        "        arrow = Arrow(label.get_bottom(), z_point)\n",
        "\n",
        "        number_label = self.number_label\n",
        "        new_number_label = OldTex(\n",
        "            \"4 + 1i\", tex_to_color_map={\"4\": GREEN, \"1\": RED}\n",
        "        )\n",
        "        new_number_label.move_to(number_label, LEFT)\n",
        "        new_number_label.add_background_rectangle()\n",
        "\n",
        "        self.play(\n",
        "            Write(complex_coordinate_labels, run_time=2),\n",
        "            FadeOut(self.rotation_mobs)\n",
        "        )\n",
        "        self.play(ShowCreation(unit_circle))\n",
        "        self.play(\n",
        "            TransformFromCopy(one_dot, z_dot),\n",
        "            TransformFromCopy(one_line, z_line),\n",
        "            FadeInFromDown(label),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeOutAndShiftDown(number_label))\n",
        "        self.play(FadeInFromDown(new_number_label))\n",
        "        self.wait()\n",
        "\n",
        "        self.left_z_label = label\n",
        "        self.right_z_label = new_number_label\n",
        "        self.cos_tex = cos_tex\n",
        "        self.sin_tex = sin_tex\n",
        "        self.unit_z_group = VGroup(\n",
        "            unit_circle, z_line, z_dot, label, arrow\n",
        "        )\n",
        "\n",
        "    def show_product(self):\n",
        "        plane = self.plane\n",
        "        cos_tex = self.cos_tex\n",
        "        sin_tex = self.sin_tex\n",
        "        angle = self.angle\n",
        "\n",
        "        line = Line(\n",
        "            FRAME_WIDTH * LEFT / 2 + FRAME_HEIGHT * UP / 2,\n",
        "            plane.coords_to_point(-0.5, 1.5)\n",
        "        )\n",
        "        rect = BackgroundRectangle(line, buff=0)\n",
        "\n",
        "        left_z = self.left_z_label\n",
        "        right_z = self.right_z_label\n",
        "        new_left_z = left_z.copy()\n",
        "        new_right_z = right_z.copy()\n",
        "\n",
        "        lp1, rp1, lp2, rp2 = parens = OldTex(\"()()\")\n",
        "        top_line = VGroup(\n",
        "            lp1, new_left_z, rp1,\n",
        "            lp2, new_right_z, rp2,\n",
        "        )\n",
        "        top_line.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        top_line.set_width(rect.get_width() - 1)\n",
        "        top_line.next_to(rect.get_top(), DOWN, MED_SMALL_BUFF)\n",
        "\n",
        "        mid_line = OldTex(\n",
        "            \"\\\\big(\", \"4\", cos_tex, \"-\", \"1\", sin_tex, \"\\\\big)\", \"+\",\n",
        "            \"\\\\big(\", \"1\", cos_tex, \"+\", \"4\", sin_tex, \"\\\\big)\", \"i\",\n",
        "            tex_to_color_map={\n",
        "                cos_tex: GREEN,\n",
        "                sin_tex: RED,\n",
        "                \"4\": GREEN,\n",
        "                \"1\": RED,\n",
        "            }\n",
        "        )\n",
        "        mid_line.set_width(rect.get_width() - 0.5)\n",
        "        mid_line.next_to(top_line, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        new_z = np.exp(angle * complex(0, 1)) * complex(4, 1)\n",
        "        low_line = OldTex(\n",
        "            \"\\\\approx\",\n",
        "            str(np.round(new_z.real, 2)), \"+\",\n",
        "            str(np.round(new_z.imag, 2)), \"i\",\n",
        "        )\n",
        "        low_line.next_to(mid_line, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        self.play(FadeIn(rect))\n",
        "        self.play(\n",
        "            TransformFromCopy(left_z, new_left_z),\n",
        "            TransformFromCopy(right_z, new_right_z),\n",
        "            Write(parens)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(FadeIn(mid_line, UP))\n",
        "        self.wait()\n",
        "        self.play(FadeIn(low_line, UP))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(self.unit_z_group))\n",
        "        self.rotation_mobs.save_state()\n",
        "        self.rotation_mobs.rotate(-angle, about_point=ORIGIN)\n",
        "        self.rotation_mobs.fade(1)\n",
        "        self.play(self.rotation_mobs.restore)\n",
        "        self.wait()\n",
        "\n",
        "        mystery_label = self.rotation_mobs[-1]\n",
        "        result = low_line[1:].copy()\n",
        "        result.add_background_rectangle()\n",
        "        self.play(\n",
        "            result.move_to, mystery_label, LEFT,\n",
        "            FadeOutAndShiftDown(mystery_label),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class ISquaredRule(Scene):\n",
        "    def construct(self):\n",
        "        tex = OldTexText(\"Use\", \"$i^2 = -1$\")\n",
        "        tex[1].set_color(RED)\n",
        "        tex.scale(2)\n",
        "        self.add(tex)\n",
        "        self.play(Write(tex))\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "class RuleForQuaternionRotations(EulerAnglesAndGimbal):\n",
        "    CONFIG = {\n",
        "        \"start_phi\": 70 * DEGREES,\n",
        "        \"start_theta\": -120 * DEGREES,\n",
        "        \"ambient_rotation_rate\": 0.015,\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.add_q_tracker()\n",
        "        self.setup_camera_position()\n",
        "        self.add_prism()\n",
        "        self.add_axes()\n",
        "\n",
        "        self.show_axis()\n",
        "        self.construct_quaternion()\n",
        "        self.add_point_with_coordinates()\n",
        "        self.add_inverse()\n",
        "\n",
        "    def get_axes(self):\n",
        "        axes = EulerAnglesAndGimbal.get_axes(self)\n",
        "        for axis in axes:\n",
        "            vect = normalize(axis.get_vector())\n",
        "            perp = rotate_vector(vect, TAU / 3, axis=[1, 1, 1])\n",
        "            for i in range(1, 4):\n",
        "                tick = Line(-perp, perp).scale(0.1)\n",
        "                tick.match_style(axis)\n",
        "                tick.move_to(2 * i * vect)\n",
        "                axis.add(tick)\n",
        "        axes.set_shade_in_3d(True)\n",
        "        return axes\n",
        "\n",
        "    def show_axis(self):\n",
        "        vect = normalize([1, -1, -0.5])\n",
        "        line = self.get_dotted_line(vect, 0, 4)\n",
        "        quat = np.append(0, vect)\n",
        "\n",
        "        axis_label = OldTexText(\"Axis of rotation\")\n",
        "        axis_label.next_to(line.get_corner(DR), DOWN, MED_LARGE_BUFF)\n",
        "        axis_label.match_color(line)\n",
        "\n",
        "        self.add_fixed_orientation_mobjects(axis_label)\n",
        "        self.play(\n",
        "            ShowCreation(line),\n",
        "            Write(axis_label)\n",
        "        )\n",
        "        self.change_q(quat, run_time=2)\n",
        "        self.change_q([1, 0, 0, 0], run_time=2)\n",
        "\n",
        "        # Unit vector\n",
        "        vect_mob = Vector(2 * vect)\n",
        "        vect_mob.pointwise_become_partial(vect_mob, 0, 0.95)\n",
        "        pieces = VGroup(*vect_mob.get_pieces(25))\n",
        "        pieces.set_stroke(vect_mob.get_color(), 2)\n",
        "        vect_mob.set_stroke(width=0)\n",
        "        vect_mob.add_to_back(pieces)\n",
        "        vect_mob.set_shade_in_3d(True)\n",
        "\n",
        "        vect_label = OldTex(\n",
        "            \"{:.2f}\".format(vect[0]), \"i\",\n",
        "            \"{:+.2f}\".format(vect[1]), \"j\",\n",
        "            \"{:+.2f}\".format(vect[2]), \"k\",\n",
        "        )\n",
        "        magnitude_label = OldTex(\n",
        "            \"x\", \"^2 + \",\n",
        "            \"y\", \"^2 + \",\n",
        "            \"z\", \"^2 = 1\",\n",
        "        )\n",
        "        for label in vect_label, magnitude_label:\n",
        "            decimals = label[::2]\n",
        "            colors = [I_COLOR, J_COLOR, K_COLOR]\n",
        "            for d1, color in zip(decimals, colors):\n",
        "                d1.set_color(color)\n",
        "            label.rotate(TAU / 4, RIGHT).scale(0.7)\n",
        "            label.next_to(vect_mob.get_end(), RIGHT, SMALL_BUFF)\n",
        "\n",
        "        magnitude_label.next_to(vect_label, IN)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(line),\n",
        "            FadeOutAndShiftDown(axis_label),\n",
        "            ShowCreation(vect_mob)\n",
        "        )\n",
        "        # self.add_fixed_orientation_mobjects(vect_label)\n",
        "        self.play(FadeInFromDown(vect_label))\n",
        "        self.wait(3)\n",
        "        self.play(TransformFromCopy(vect_label, magnitude_label))\n",
        "        self.wait(3)\n",
        "\n",
        "        self.vect = vect\n",
        "        self.vect_mob = vect_mob\n",
        "        self.vect_label = vect_label\n",
        "        self.magnitude_label = magnitude_label\n",
        "\n",
        "    def construct_quaternion(self):\n",
        "        full_angle_q = self.get_quaternion_label(\"40^\\\\circ\")\n",
        "        half_angle_q = self.get_quaternion_label(\"40^\\\\circ / 2\")\n",
        "        for label in full_angle_q, half_angle_q:\n",
        "            label.to_corner(UL)\n",
        "        brace = Brace(half_angle_q, DOWN)\n",
        "        q_label = brace.get_tex(\"q\")\n",
        "        full_angle_q.align_data_and_family(half_angle_q)\n",
        "        rect = SurroundingRectangle(full_angle_q[5])\n",
        "\n",
        "        for mob in full_angle_q, half_angle_q, brace, q_label, rect:\n",
        "            self.add_fixed_in_frame_mobjects(mob)\n",
        "            self.remove(mob)\n",
        "        self.play(FadeInFromDown(full_angle_q[1]))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeInFromDown(full_angle_q[0]),\n",
        "            LaggedStartMap(FadeInFromDown, full_angle_q[2:]),\n",
        "        )\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(q_label)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait(2)\n",
        "        self.play(ReplacementTransform(full_angle_q, half_angle_q))\n",
        "        self.wait(6)\n",
        "        # TODO\n",
        "\n",
        "    def add_point_with_coordinates(self):\n",
        "        prism = self.prism\n",
        "        point = prism.get_corner(UR + OUT)\n",
        "        template_sphere = Sphere(radius=0.1)\n",
        "        template_sphere.set_stroke(width=0)\n",
        "        template_sphere.set_color(PINK)\n",
        "        ghost_sphere = template_sphere.copy()\n",
        "        ghost_sphere.fade(0.8)\n",
        "        for face in template_sphere:\n",
        "            c = face.get_center()\n",
        "            if c[0] < 0 and c[2] < 0:\n",
        "                template_sphere.remove(face)\n",
        "        template_sphere.move_to(point)\n",
        "        ghost_sphere.move_to(point)\n",
        "\n",
        "        def get_sphere():\n",
        "            result = template_sphere.copy()\n",
        "            quat = self.q_tracker.get_value()\n",
        "            angle, axis = angle_axis_from_quaternion(quat)\n",
        "            result.rotate(angle=angle, axis=axis, about_point=ORIGIN)\n",
        "            return result\n",
        "\n",
        "        sphere = always_redraw(get_sphere)\n",
        "\n",
        "        point_label = OldTex(\n",
        "            \"p\", \"=\",\n",
        "            \"{:.2f}\".format(point[0]), \"i\", \"+\"\n",
        "            \"{:.2f}\".format(point[1]), \"j\", \"+\"\n",
        "            \"{:.2f}\".format(point[2]), \"k\",\n",
        "        )\n",
        "        colors = [PINK, I_COLOR, J_COLOR, K_COLOR]\n",
        "        for part, color in zip(point_label[::2], colors):\n",
        "            part.set_color(color)\n",
        "        point_label.scale(0.7)\n",
        "        point_label.rotate(TAU / 4, RIGHT)\n",
        "        point_label.next_to(point, RIGHT)\n",
        "\n",
        "        self.stop_ambient_camera_rotation()\n",
        "        self.begin_ambient_camera_rotation(-0.01)\n",
        "        self.play(FadeInFromLarge(sphere))\n",
        "        self.play(Write(point_label))\n",
        "        self.wait(3)\n",
        "\n",
        "        # Rotate\n",
        "        quat = quaternion_from_angle_axis(40 * DEGREES, self.vect)\n",
        "        r = get_norm(point)\n",
        "        curved_arrow = Arrow(\n",
        "            r * RIGHT, rotate_vector(r * RIGHT, 30 * DEGREES, OUT),\n",
        "            buff=0,\n",
        "            path_arc=60 * DEGREES,\n",
        "            color=GREY_B,\n",
        "        )\n",
        "        curved_arrow.pointwise_become_partial(curved_arrow, 0, 0.9)\n",
        "        curved_arrow.rotate(150 * DEGREES, about_point=ORIGIN)\n",
        "        curved_arrow.apply_matrix(z_to_vector(self.vect))\n",
        "        self.add(ghost_sphere, sphere)\n",
        "        self.change_q(\n",
        "            quat,\n",
        "            added_anims=[ShowCreation(curved_arrow)],\n",
        "            run_time=3\n",
        "        )\n",
        "\n",
        "        mystery_label = OldTex(\"(?, ?, ?)\")\n",
        "        mystery_label.add_background_rectangle()\n",
        "        arrow = Vector(0.5 * DR, color=WHITE)\n",
        "        arrow.next_to(mystery_label, DR, buff=0)\n",
        "        # mystery_label.add(arrow)\n",
        "        mystery_label.rotate(TAU / 4, RIGHT)\n",
        "        mystery_label.next_to(sphere, OUT + LEFT, buff=0)\n",
        "        self.play(FadeInFromDown(mystery_label))\n",
        "        self.wait(5)\n",
        "\n",
        "    def add_inverse(self):\n",
        "        label = OldTex(\n",
        "            \"p\", \"\\\\rightarrow\",\n",
        "            \"q\", \"\\\\cdot\", \"p\", \"\\\\cdot\", \"q^{-1}\",\n",
        "            tex_to_color_map={\"p\": PINK}\n",
        "        )\n",
        "        label.to_corner(UR)\n",
        "        label.shift(2 * LEFT)\n",
        "        self.add_fixed_in_frame_mobjects(label)\n",
        "\n",
        "        self.play(FadeInFromDown(label))\n",
        "        self.wait(3)\n",
        "        self.change_q(\n",
        "            [1, 0, 0, 0],\n",
        "            rate_func=there_and_back,\n",
        "            run_time=5\n",
        "        )\n",
        "        self.wait(3)\n",
        "\n",
        "    #\n",
        "    def get_quaternion_label(self, angle_tex):\n",
        "        vect_label = self.vect_label.copy()\n",
        "        vect_label.rotate(TAU / 4, LEFT)\n",
        "        vect_label.replace(OldTex(vect_label.get_tex()))\n",
        "        vect_label.add_background_rectangle()\n",
        "        result = VGroup(\n",
        "            OldTex(\"\\\\big(\"),\n",
        "            OldTex(\"\\\\text{cos}(\", angle_tex, \")\"),\n",
        "            OldTex(\"+\"),\n",
        "            OldTex(\"\\\\text{sin}(\", angle_tex, \")\"),\n",
        "            OldTex(\"(\"),\n",
        "            vect_label,\n",
        "            OldTex(\")\"),\n",
        "            OldTex(\"\\\\big)\"),\n",
        "        )\n",
        "        for i in 1, 3:\n",
        "            result[i][1].set_color(YELLOW)\n",
        "        result.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        result.scale(0.7)\n",
        "        return result\n",
        "\n",
        "\n",
        "class ExpandOutFullProduct(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        product = OldTex(\n",
        "            \"\"\"\n",
        "            (w_0 + x_0 i + y_0 j + z_0 k)\n",
        "            (x_1 i + y_1 j + z_1 k)\n",
        "            (w_0 - x_0 i - y_0 j - z_0 k)\n",
        "            \"\"\",\n",
        "            tex_to_color_map={\n",
        "                \"w_0\": W_COLOR, \"(\": WHITE, \")\": WHITE,\n",
        "                \"x_0\": I_COLOR, \"y_0\": J_COLOR, \"z_0\": K_COLOR,\n",
        "                \"x_1\": I_COLOR, \"y_1\": J_COLOR, \"z_1\": K_COLOR,\n",
        "            }\n",
        "        )\n",
        "        product.set_width(FRAME_WIDTH - 1)\n",
        "        product.to_edge(UP)\n",
        "\n",
        "        n = 10\n",
        "        q_brace = Brace(product[:n], DOWN)\n",
        "        p_brace = Brace(product[n:-n], DOWN)\n",
        "        q_inv_brace = Brace(product[-n:], DOWN)\n",
        "        braces = VGroup(q_brace, p_brace, q_inv_brace)\n",
        "        for brace, tex in zip(braces, [\"q\", \"p\", \"q^{-1}\"]):\n",
        "            brace.add(brace.get_tex(tex))\n",
        "\n",
        "        words = OldTexText(\"= Rotation of $p$\")\n",
        "        words.next_to(braces, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "            FadeInFromDown(product)\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowFromCenter, braces),\n",
        "            self.change_students(\n",
        "                \"confused\", \"horrified\", \"confused\"\n",
        "            )\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(Write(words))\n",
        "        self.play_student_changes(\n",
        "            \"pondering\", \"confused\", \"erm\",\n",
        "            look_at=words\n",
        "        )\n",
        "        self.wait(5)\n",
        "\n",
        "\n",
        "class Link(Scene):\n",
        "    def construct(self):\n",
        "        word = OldTexText(\"eater.net/quaternions\")\n",
        "        word.add_background_rectangle()\n",
        "        rect = SurroundingRectangle(word)\n",
        "        rect.set_color(BLUE)\n",
        "        arrow = Vector(UR, color=GREEN)\n",
        "        arrow.next_to(rect, UP)\n",
        "        arrow.align_to(rect, RIGHT)\n",
        "        short_arrow = arrow.copy().scale(0.8, about_edge=DL)\n",
        "\n",
        "        self.add(word)\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            GrowArrow(arrow),\n",
        "        )\n",
        "        for x in range(10):\n",
        "            self.play(Transform(\n",
        "                arrow, short_arrow,\n",
        "                rate_func=there_and_back,\n",
        "                run_time=2\n",
        "            ))\n",
        "\n",
        "\n",
        "# Extra\n",
        "class QuaternionsDescribingRotation(EulerAnglesAndGimbal):\n",
        "    CONFIG = {\n",
        "        \"use_lightweight_axes\": True,\n",
        "        \"quaternions_and_imaginary_part_labels\": [\n",
        "            ([1, 1, 0, 0], \"{i}\"),\n",
        "            # ([1, 0, 1, 0], \"{j}\"),\n",
        "            # ([0, 0, 0, 1], \"{k}\"),\n",
        "            # ([1, 1, 1, 1], \"\\\\left({{i} + {j} + {k} \\\\over \\\\sqrt{3}}\\\\right)\"),\n",
        "        ],\n",
        "    }\n",
        "\n",
        "    def construct(self):\n",
        "        self.setup_position()\n",
        "        self.show_rotations()\n",
        "\n",
        "    def show_rotations(self):\n",
        "        for quat, ipl in self.quaternions_and_imaginary_part_labels:\n",
        "            quat = normalize(quat)\n",
        "            axis = quat[1:]\n",
        "            angle = 2 * np.arccos(quat[0])\n",
        "            label = self.get_label(angle, ipl)\n",
        "\n",
        "            prism = RandyPrism()\n",
        "            prism.scale(2)\n",
        "\n",
        "            self.play(\n",
        "                LaggedStartMap(FadeInFromDown, label),\n",
        "                FadeIn(prism),\n",
        "            )\n",
        "            self.play(Rotate(\n",
        "                prism,\n",
        "                angle=angle, axis=axis,\n",
        "                run_time=3,\n",
        "                about_point=ORIGIN,\n",
        "            ))\n",
        "\n",
        "\n",
        "    #\n",
        "    def get_label(self, angle, imaginary_part_label):\n",
        "        deg = int(angle / DEGREES)\n",
        "        ipl = imaginary_part_label\n",
        "        kwargs = {\n",
        "            \"tex_to_color_map\": {\n",
        "                \"{i}\": I_COLOR,\n",
        "                \"{j}\": J_COLOR,\n",
        "                \"{k}\": K_COLOR,\n",
        "            }\n",
        "        }\n",
        "        p_label = OldTex(\n",
        "            \"x{i} + y{j} + z{k}\", **kwargs\n",
        "        )\n",
        "        arrow = OldTex(\n",
        "            \"\\\\rightarrow\"\n",
        "        )\n",
        "        q_label = OldTex(\n",
        "            \"\\\\big(\\\\cos(%d^\\\\circ) + \\\\sin(%d^\\\\circ)%s \\\\big)\" % (deg, deg, ipl),\n",
        "            **kwargs\n",
        "        )\n",
        "        inner_p_label = OldTex(\n",
        "            \"\\\\left(x{i} + y{j} + z{k} \\\\right)\",\n",
        "            **kwargs\n",
        "        )\n",
        "        q_inv_label = OldTex(\n",
        "            \"\\\\big(\\\\cos(-%d^\\\\circ) + \\\\sin(-%d^\\\\circ)%s \\\\big)\" % (deg, deg, ipl),\n",
        "            **kwargs\n",
        "        )\n",
        "        equation = VGroup(\n",
        "            p_label, arrow, q_label, inner_p_label, q_inv_label\n",
        "        )\n",
        "        equation.arrange(RIGHT, buff=SMALL_BUFF)\n",
        "        equation.set_width(FRAME_WIDTH - 1)\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        parts_text_colors = [\n",
        "            (p_label, \"\\\\text{3d point}\", YELLOW),\n",
        "            (q_label, \"q\", PINK),\n",
        "            (inner_p_label, \"\\\\text{3d point}\", YELLOW),\n",
        "            (q_inv_label, \"q^{-1}\", PINK),\n",
        "        ]\n",
        "        braces = VGroup()\n",
        "        for part, text, color in parts_text_colors:\n",
        "            brace = Brace(part, DOWN, buff=SMALL_BUFF)\n",
        "            label = brace.get_tex(text, buff=MED_SMALL_BUFF)\n",
        "            label.set_color(color)\n",
        "            brace.add(label)\n",
        "            braces.add(brace)\n",
        "        braces[-1][-1].shift(0.2 * UR)\n",
        "\n",
        "        equation.add_to_back(BackgroundRectangle(equation))\n",
        "        equation.braces = braces\n",
        "        equation.add(*braces)\n",
        "\n",
        "        self.add_fixed_in_frame_mobjects(equation)\n",
        "        self.add_fixed_in_frame_mobjects(braces)\n",
        "        return equation\n"
    ]
}