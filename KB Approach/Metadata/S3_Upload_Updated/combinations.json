{
    "topic": "The mathematical concept being demonstrated is the Pascal's triangle, which is a triangular array of",
    "code": [
        "from manim_imports_ext import *\n",
        "\n",
        "#revert_to_original_skipping_status\n",
        "\n",
        "def get_stack(\n",
        "    obj1, obj2, n, k,\n",
        "    fixed_start = None,\n",
        "    fixed_end = None,\n",
        "    obj_to_obj_buff = SMALL_BUFF,\n",
        "    vertical_buff = MED_SMALL_BUFF,\n",
        "    ):\n",
        "    stack = VGroup()\n",
        "    for indices in it.combinations(list(range(n)), k):\n",
        "        term = VGroup(*[\n",
        "             obj1.copy() if i in indices else obj2.copy()\n",
        "            for i in range(n)\n",
        "        ])\n",
        "        if fixed_start:\n",
        "            term.add_to_back(fixed_start.copy())\n",
        "        if fixed_end:\n",
        "            term.add(fixed_end.copy())\n",
        "        term.arrange(RIGHT, buff = obj_to_obj_buff)\n",
        "        stack.add(term)\n",
        "    stack.arrange(DOWN, buff = vertical_buff)\n",
        "    return stack\n",
        "\n",
        "def get_stacks(obj1, obj2, n, **kwargs):\n",
        "    stacks = VGroup()\n",
        "    for k in range(n+1):\n",
        "        stacks.add(get_stack(obj1, obj2, n, k, **kwargs))\n",
        "    stacks.arrange(\n",
        "        RIGHT, \n",
        "        buff = MED_LARGE_BUFF,\n",
        "        aligned_edge = DOWN\n",
        "    )\n",
        "    return stacks\n",
        "\n",
        "class Male(Tex):\n",
        "    CONFIG = {\n",
        "        \"height\" : 0.4,\n",
        "        \"tex\" : \"\\\\male\",\n",
        "        \"color\" : BLUE,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        digest_config(self, kwargs)\n",
        "        Tex.__init__(self, self.tex, **kwargs)\n",
        "        self.set_height(self.height)\n",
        "        self.set_color(self.color)\n",
        "\n",
        "class Female(Male):\n",
        "    CONFIG = {\n",
        "        \"tex\" : \"\\\\female\",\n",
        "        \"color\" : MAROON_B,\n",
        "    }\n",
        "\n",
        "class PascalsTriangle(VGroup):\n",
        "    CONFIG = {\n",
        "        \"n_rows\" : 9,\n",
        "        \"distance\" : 0.8,\n",
        "        \"max_width_to_distance_ratio\" : 0.7,\n",
        "        \"angle\" : 0.2*np.pi,\n",
        "    }\n",
        "    def __init__(self, **kwargs):\n",
        "        VGroup.__init__(self, **kwargs)\n",
        "\n",
        "        distance = self.distance\n",
        "        angle = self.angle\n",
        "        max_width = self.max_width_to_distance_ratio * distance\n",
        "        t_down = rotate_vector(distance*DOWN, -angle)\n",
        "        t_right = 2*distance*np.sin(angle)*RIGHT\n",
        "\n",
        "        for n in range(self.n_rows):\n",
        "            row = VGroup()\n",
        "            for k in range(n+1):\n",
        "                num = OldTex(str(choose(n, k)))\n",
        "                num.shift(n*t_down + k*t_right)\n",
        "                row.add(num)\n",
        "            self.add(row)\n",
        "        self.center()\n",
        "\n",
        "######################\n",
        "\n",
        "class ExperienceProblemSolver(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        self.add_equation()\n",
        "        self.jenny_solves()\n",
        "        self.no_genius()\n",
        "        self.think_about_patterns()\n",
        "\n",
        "    def add_equation(self):\n",
        "        equation = OldTex(\n",
        "            \"\\\\frac{x^3 + y^3}{(x+y)^2} + \\\\frac{3xy}{x+y}\"\n",
        "        )\n",
        "        equation.to_edge(UP)\n",
        "\n",
        "        self.play(Write(equation))\n",
        "        self.wait()\n",
        "\n",
        "        self.equation = equation\n",
        "\n",
        "    def jenny_solves(self):\n",
        "        randy, jenny = self.randy, self.jenny\n",
        "        jenny_words = OldTexText(\"It's just $x+y$\")\n",
        "        randy_words = OldTexText(\"...wait...\")\n",
        "        randy_words.next_to(randy.get_corner(UP+RIGHT), RIGHT)\n",
        "\n",
        "        self.pi_creature_says(\n",
        "            jenny, jenny_words, \n",
        "            target_mode = \"hooray\",\n",
        "            bubble_config = {\"height\" : 2, \"width\" : 3}\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            randy.change, \"confused\", self.equation,\n",
        "            Write(randy_words)\n",
        "        )\n",
        "        self.play(randy.look_at, self.equation.get_left())\n",
        "        self.play(randy.look_at, jenny.eyes)\n",
        "        self.play(jenny.change, \"happy\")\n",
        "        self.play(randy.change, \"tired\")\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            jenny.bubble, jenny_words, randy_words\n",
        "        ])))\n",
        "\n",
        "    def no_genius(self):\n",
        "        randy, jenny = self.randy, self.jenny\n",
        "\n",
        "        lightbulb = Lightbulb()\n",
        "        lightbulb.next_to(jenny, UP)\n",
        "        cross = Cross(lightbulb)\n",
        "        cross.set_stroke(RED, 8)\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, lightbulb))\n",
        "        self.play(\n",
        "            ShowCreation(cross),\n",
        "            jenny.change, \"sassy\", cross,\n",
        "            randy.change, \"happy\"\n",
        "        )\n",
        "        self.wait(2)\n",
        "\n",
        "        self.to_fade = VGroup(lightbulb, cross)\n",
        "\n",
        "    def think_about_patterns(self):\n",
        "        randy, jenny = self.randy, self.jenny\n",
        "        rows = PascalsTriangle(\n",
        "            n_rows = 6,\n",
        "            distance = 0.6,\n",
        "        )\n",
        "        rows.scale(0.8)\n",
        "        for row in rows:\n",
        "            for num in row:\n",
        "                n = float(num.get_tex())\n",
        "                num.set_color(interpolate_color(\n",
        "                    BLUE, YELLOW, n/10.0\n",
        "                ))\n",
        "\n",
        "        self.pi_creature_thinks(\n",
        "            jenny, \"\",\n",
        "            bubble_config = {\"width\" : 5, \"height\" : 4.2},\n",
        "            added_anims = [\n",
        "                FadeOut(self.to_fade),\n",
        "                FadeOut(self.equation),\n",
        "                randy.change, \"plain\"\n",
        "            ]\n",
        "        )\n",
        "        rows.move_to(\n",
        "            jenny.bubble.get_bubble_center() + \\\n",
        "            MED_SMALL_BUFF*(UP+LEFT)\n",
        "        )\n",
        "        self.play(FadeIn(rows[0]))\n",
        "        for last_row, curr_row in zip(rows, rows[1:]):\n",
        "            self.play(*[\n",
        "                Transform(\n",
        "                    last_row.copy(), VGroup(*mobs),\n",
        "                    remover = True\n",
        "                )\n",
        "                for mobs in (curr_row[1:], curr_row[:-1])\n",
        "            ])\n",
        "            self.add(curr_row)\n",
        "        self.wait(3)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    ############\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        randy = Randolph()\n",
        "        randy.to_edge(DOWN)\n",
        "        randy.shift(4*LEFT)\n",
        "        jenny = PiCreature(color = BLUE_C).flip()\n",
        "        jenny.to_edge(DOWN)\n",
        "        jenny.shift(4*RIGHT)\n",
        "        self.randy, self.jenny = randy, jenny\n",
        "        return randy, jenny\n",
        "\n",
        "class InitialFiveChooseThreeExample(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 5,\n",
        "        \"zero_color\" : BLUE,\n",
        "        \"one_color\" : PINK,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_all_stacks()\n",
        "        self.add_title()\n",
        "        self.show_binomial_name()\n",
        "        self.issolate_single_stack()\n",
        "        self.count_chosen_stack()\n",
        "        self.count_ways_to_fill_slots()\n",
        "        self.walk_though_notation()\n",
        "        self.emphasize_pattern_over_number()\n",
        "\n",
        "    def show_all_stacks(self):\n",
        "        stacks = get_stacks(\n",
        "            self.get_obj1(), self.get_obj2(), self.n,\n",
        "            vertical_buff = SMALL_BUFF\n",
        "        )\n",
        "        stacks.to_edge(DOWN, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        for stack in stacks:\n",
        "            self.play(FadeIn(\n",
        "                stack, \n",
        "                run_time = 0.2*len(stack),\n",
        "                lag_ratio = 0.5\n",
        "            ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(stacks)\n",
        "\n",
        "    def add_title(self):\n",
        "        n = self.n\n",
        "        stacks = self.stacks\n",
        "\n",
        "        n_choose_k = OldTex(\"n \\\\choose k\")\n",
        "        n_choose_k_words = OldTexText(\"``n choose k''\")\n",
        "        nCk_group = VGroup(n_choose_k, n_choose_k_words)\n",
        "        nCk_group.arrange(RIGHT)\n",
        "        nCk_group.to_edge(UP)\n",
        "\n",
        "        binomials = VGroup(*[\n",
        "            OldTex(\"%d \\\\choose %d\"%(n, k))\n",
        "            for k in range(n+1)\n",
        "        ])\n",
        "        binomial_equations = VGroup()\n",
        "        for k, binomial in enumerate(binomials):\n",
        "            binomial.scale(0.75)\n",
        "            number = OldTex(str(choose(n, k)))\n",
        "            equation = VGroup(binomial, OldTex(\"=\"), number)\n",
        "            equation.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            equation.set_color(YELLOW)\n",
        "            equation[1].set_color(WHITE)\n",
        "            binomial_equations.add(equation)\n",
        "\n",
        "        for stack, eq in zip(stacks, binomial_equations):\n",
        "            eq.set_width(0.9*stack.get_width())\n",
        "            eq.next_to(stack, UP)\n",
        "\n",
        "        mover = VGroup()\n",
        "        for eq in binomial_equations:\n",
        "            point = VectorizedPoint(n_choose_k.get_center())\n",
        "            group = VGroup(n_choose_k, point, point).copy()\n",
        "            group.target = eq\n",
        "            mover.add(group)\n",
        "\n",
        "        self.play(FadeIn(nCk_group))\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, mover,\n",
        "            run_time = 3,\n",
        "        ))\n",
        "        self.remove(mover)\n",
        "        self.add(binomial_equations)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            n_choose_k, n_choose_k_words,\n",
        "            binomial_equations\n",
        "        )\n",
        "\n",
        "    def show_binomial_name(self):\n",
        "        new_words = OldTexText(\"``Binomial coefficients''\")\n",
        "        new_words.move_to(self.n_choose_k_words, LEFT)\n",
        "\n",
        "        self.play(Transform(self.n_choose_k_words, new_words))\n",
        "        self.wait(2)\n",
        "\n",
        "    def issolate_single_stack(self):\n",
        "        stack = self.stacks[3]\n",
        "        equation = self.binomial_equations[3]\n",
        "\n",
        "        to_fade = VGroup(*self.stacks)\n",
        "        to_fade.add(*self.binomial_equations)\n",
        "        to_fade.add(self.n_choose_k, self.n_choose_k_words)\n",
        "        to_fade.remove(stack, equation)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(to_fade),\n",
        "            equation.scale, 1.5, equation.get_bottom(),\n",
        "        )\n",
        "        self.wait()\n",
        "        for line in stack:\n",
        "            ones = VGroup(*[mob for mob in line if \"1\" in mob.get_tex()])\n",
        "            line.ones = ones\n",
        "            self.play(LaggedStartMap(\n",
        "                ApplyMethod, ones,\n",
        "                lambda mob : (mob.set_color, YELLOW),\n",
        "                rate_func = there_and_back,\n",
        "                lag_ratio = 0.7,\n",
        "                run_time = 1,\n",
        "            ))\n",
        "\n",
        "    def count_chosen_stack(self):\n",
        "        stack = self.stacks[3]\n",
        "        for i, line in enumerate(stack):\n",
        "            number = OldTex(str(i+1))\n",
        "            number.next_to(stack, LEFT)\n",
        "            brace = Brace(VGroup(*stack[:i+1]), LEFT)\n",
        "            number.next_to(brace, LEFT)\n",
        "            line.save_state()\n",
        "            line.set_color(YELLOW)\n",
        "            self.add(number, brace)\n",
        "            self.wait(0.25)\n",
        "            self.remove(number, brace)\n",
        "            line.restore()\n",
        "        self.add(number, brace)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            stack_brace = brace,\n",
        "            stack_count = number\n",
        "        )\n",
        "\n",
        "    def count_ways_to_fill_slots(self):\n",
        "        lines = VGroup(*[Line(ORIGIN, 0.25*RIGHT) for x in range(5)])\n",
        "        lines.arrange(RIGHT)\n",
        "        lines.next_to(self.stacks[3], LEFT, LARGE_BUFF, UP)\n",
        "\n",
        "        self.play(ShowCreation(lines))\n",
        "        count = 1\n",
        "        for indices in it.combinations(list(range(5)), 3):\n",
        "            ones = VGroup(*[\n",
        "                self.get_obj1().next_to(lines[i], UP)\n",
        "                for i in indices\n",
        "            ])\n",
        "            num = OldTex(str(count))\n",
        "            num.next_to(lines, DOWN)\n",
        "            self.add(ones, num)\n",
        "            self.wait(0.35)\n",
        "            self.remove(ones, num)\n",
        "            count += 1\n",
        "        self.add(num, ones)\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [lines, num, ones])))\n",
        "\n",
        "    def walk_though_notation(self):\n",
        "        equation = self.binomial_equations[3]\n",
        "        rect = SurroundingRectangle(equation[0])\n",
        "        rect.set_color(WHITE)\n",
        "        words = OldTexText(\"``5 choose 3''\")\n",
        "        words.next_to(rect, UP)\n",
        "\n",
        "        self.play(Write(words))\n",
        "        self.play(ShowCreation(rect))\n",
        "        self.play(FadeOut(rect))\n",
        "        self.wait(2)\n",
        "\n",
        "    def emphasize_pattern_over_number(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.to_corner(DOWN+LEFT)\n",
        "        words = OldTexText(\"Remember the pattern \\\\\\\\ not the number\")\n",
        "        words.next_to(morty, UP)\n",
        "        words.shift_onto_screen()\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(\n",
        "            morty.change, \"speaking\",\n",
        "            Write(words, run_time = 2)\n",
        "        )\n",
        "        self.play(\n",
        "            Blink(morty),\n",
        "            morty.change, \"happy\"\n",
        "        )\n",
        "        self.revert_to_original_skipping_status()\n",
        "        last_ones = VGroup()\n",
        "        last_ones.save_state()\n",
        "        for x in range(2):\n",
        "            for line in self.stacks[3]:\n",
        "                ones = line.ones\n",
        "                ones.save_state()\n",
        "                self.play(\n",
        "                    ones.set_color, YELLOW,\n",
        "                    last_ones.restore,\n",
        "                    morty.look_at, ones,\n",
        "                    run_time = 0.25\n",
        "                )\n",
        "                last_ones = ones\n",
        "            self.wait()\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_obj1(self):\n",
        "        return OldTex(\"1\").set_color(self.one_color)\n",
        "\n",
        "    def get_obj2(self):\n",
        "        return OldTex(\"0\").set_color(self.zero_color)\n",
        "\n",
        "class SixChooseThreeExample(InitialFiveChooseThreeExample):\n",
        "    CONFIG = {\n",
        "        \"n\" : 6,\n",
        "        \"k\" : 3,\n",
        "        \"stack_height\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_stack()\n",
        "        self.talk_through_one_line()\n",
        "        self.count_stack()\n",
        "        self.think_about_pattern()\n",
        "\n",
        "    def show_stack(self):\n",
        "        stack = get_stack(\n",
        "            self.get_obj1(), self.get_obj2(),\n",
        "            self.n, self.k,\n",
        "            vertical_buff = SMALL_BUFF\n",
        "        )\n",
        "        stack.set_height(self.stack_height)\n",
        "        stack.to_edge(DOWN)\n",
        "        for line in stack:\n",
        "            line.ones = VGroup(*[mob for mob in line if \"1\" in mob.get_tex()])\n",
        "\n",
        "        equation = OldTex(\n",
        "            \"{%d \\\\choose %d}\"%(self.n, self.k),\n",
        "            \"=\", str(choose(self.n, self.k))\n",
        "        )\n",
        "        equation.set_color(YELLOW)\n",
        "        equation.set_color_by_tex(\"=\", WHITE)\n",
        "        equation.next_to(stack, RIGHT, LARGE_BUFF)\n",
        "\n",
        "        self.add(equation)\n",
        "        self.play(LaggedStartMap(\n",
        "            FadeIn, stack,\n",
        "            lag_ratio = 0.1,\n",
        "            run_time = 10,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(stack)\n",
        "\n",
        "    def talk_through_one_line(self):\n",
        "        line = self.stack[8]\n",
        "        line.save_state()\n",
        "        distance = FRAME_X_RADIUS/2\n",
        "\n",
        "        self.play(line.shift, distance*LEFT)\n",
        "\n",
        "        brace = Brace(line, UP)\n",
        "        n_options = OldTexText(str(self.n), \"options\")\n",
        "        n_options.set_color_by_tex(str(self.n), YELLOW)\n",
        "        n_options.next_to(brace, UP)\n",
        "        arrows = VGroup(*[\n",
        "            Vector(0.5*UP).next_to(one, DOWN, SMALL_BUFF)\n",
        "            for one in line.ones\n",
        "        ])\n",
        "        arrows.set_color(self.one_color)\n",
        "        choose_k = OldTexText(\"Choose\", str(self.k), \"of them\")\n",
        "        choose_k.set_color_by_tex(str(self.k), YELLOW)\n",
        "        choose_k.next_to(arrows, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(n_options),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.play(\n",
        "            LaggedStartMap(GrowArrow, arrows),\n",
        "            Write(choose_k, run_time = 1)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            line.restore,\n",
        "            *list(map(FadeOut, [brace, n_options, arrows, choose_k]))\n",
        "        )\n",
        "\n",
        "    def count_stack(self):\n",
        "        stack = self.stack\n",
        "        for i, line in enumerate(stack):\n",
        "            brace = Brace(VGroup(*stack[:i+1]), LEFT)\n",
        "            num = OldTex(str(i+1))\n",
        "            num.next_to(brace, LEFT)\n",
        "            line.ones.save_state()\n",
        "            line.ones.set_color(YELLOW)\n",
        "            line.ones.set_stroke(RED, 1)\n",
        "            self.add(brace, num)\n",
        "            self.wait(0.15)\n",
        "            self.remove(brace, num)\n",
        "            line.ones.restore()\n",
        "        self.add(brace, num)\n",
        "        self.wait()\n",
        "\n",
        "        lhs = OldTex(\n",
        "            \"\\\\frac{6 \\\\cdot 5 \\\\cdot 3}{1 \\\\cdot 2 \\\\cdot 3} =\"\n",
        "        )\n",
        "        lhs.next_to(num, LEFT)\n",
        "        coming_soon = OldTexText(\"Coming soon...\")\n",
        "        coming_soon.next_to(lhs, UP)\n",
        "        coming_soon.set_color(MAROON_B)\n",
        "\n",
        "        self.play(*list(map(FadeIn, [lhs, coming_soon])))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ApplyMethod(\n",
        "                lhs.shift, 0.65*FRAME_X_RADIUS*(LEFT+UP),\n",
        "                path_arc = np.pi/2,\n",
        "                rate_func = running_start,\n",
        "                remover = True,\n",
        "            ),\n",
        "            *list(map(FadeOut, [brace, num, coming_soon]))\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def think_about_pattern(self):\n",
        "        self.revert_to_original_skipping_status()\n",
        "        last_ones = VGroup()\n",
        "        last_ones.save_state()\n",
        "        for x in range(2):\n",
        "            for line in self.stack:\n",
        "                ones = line.ones\n",
        "                ones.save_state()\n",
        "                self.play(\n",
        "                    ones.set_color, YELLOW,\n",
        "                    ones.set_stroke, RED, 1,\n",
        "                    last_ones.restore,\n",
        "                    run_time = 0.2\n",
        "                )\n",
        "                last_ones = ones\n",
        "        self.wait()\n",
        "\n",
        "class SixChooseThreeInOtherContext(Scene):\n",
        "    def construct(self):\n",
        "        self.add_dots()\n",
        "        self.count_paths_to_three_three()\n",
        "\n",
        "    def add_dots(self):\n",
        "        n = 4\n",
        "        dots = VGroup(*[Dot() for x in range(n**2)])\n",
        "        dots.arrange_in_grid(n, n, buff = LARGE_BUFF)\n",
        "        dots.next_to(ORIGIN, LEFT)\n",
        "        self.add(dots)\n",
        "\n",
        "        self.dots = dots\n",
        "        self.dot_to_dot_distance = get_norm(\n",
        "            dots[1].get_center() - dots[0].get_center()\n",
        "        )\n",
        "\n",
        "    def count_paths_to_three_three(self):\n",
        "        dots = self.dots\n",
        "        d = self.dot_to_dot_distance\n",
        "        lower_left = dots.get_corner(DOWN+LEFT)\n",
        "        lower_left += dots[0].radius*(UP+RIGHT)\n",
        "\n",
        "        right = Vector(d*RIGHT, color = PINK)\n",
        "        up = Vector(d*UP, color = BLUE)\n",
        "\n",
        "        last_rights = None\n",
        "        last_ups = None\n",
        "        last_line = None\n",
        "        for indices in it.combinations(list(range(6)), 3):\n",
        "            bools = [i in indices for i in range(6)]\n",
        "            arrows = VGroup(*[\n",
        "                right.deepcopy() if b else up.deepcopy()\n",
        "                for b in bools\n",
        "            ])\n",
        "            last_point = np.array(lower_left)\n",
        "            ups, rights = VGroup(), VGroup()\n",
        "            for arrow, b in zip(arrows, bools):\n",
        "                arrow.shift(last_point - arrow.get_start())\n",
        "                last_point = arrow.get_end()\n",
        "                group = rights if b else ups\n",
        "                group.add(arrow)\n",
        "\n",
        "            line = VGroup(*[arrow.tip.copy() for arrow in arrows])\n",
        "            line.arrange(RIGHT, buff = 0.5*SMALL_BUFF)\n",
        "            if last_line is None:\n",
        "                line.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "                line.to_edge(UP)\n",
        "                self.play(\n",
        "                    ShowCreation(arrows),\n",
        "                    ShowCreation(line)\n",
        "                )\n",
        "            else:\n",
        "                line.next_to(last_line, DOWN, SMALL_BUFF)\n",
        "                self.play(\n",
        "                    FadeIn(line),\n",
        "                    ReplacementTransform(last_rights, rights),\n",
        "                    ReplacementTransform(last_ups, ups),\n",
        "                )\n",
        "            last_rights = rights\n",
        "            last_ups = ups\n",
        "            last_line = line\n",
        "        self.wait()\n",
        "\n",
        "# class Introduction(Scene):\n",
        "#     CONFIG = {\n",
        "#         \"start_n\" : 4,\n",
        "#     }\n",
        "#     def construct(self):\n",
        "#         self.write_n_choose_k()\n",
        "#         self.show_binomial_coefficients()\n",
        "#         self.perform_shift()\n",
        "\n",
        "#     def write_n_choose_k(self):\n",
        "#         symbol = OldTex(\"n \\\\choose k\")\n",
        "#         words = OldTexText(\"``n choose k''\")\n",
        "#         group = VGroup(symbol, words)\n",
        "#         group.arrange(RIGHT)\n",
        "\n",
        "#         self.play(\n",
        "#             FadeIn(symbol),\n",
        "#             Write(words)\n",
        "#         )\n",
        "#         self.wait()\n",
        "\n",
        "#         self.set_variables_as_attrs(n_choose_k_group = group)\n",
        "\n",
        "#     def show_binomial_coefficients(self):\n",
        "#         n = self.start_n\n",
        "#         n_choose_k, n_choose_k_words = self.n_choose_k_group\n",
        "#         binomials = VGroup(*[\n",
        "#             OldTex(\"%d \\\\choose %d\"%(n, k))\n",
        "#             for k in range(n+1)\n",
        "#         ])\n",
        "#         binomial_equations = VGroup()\n",
        "#         for k, binomial in enumerate(binomials):\n",
        "#             binomial.scale(0.75)\n",
        "#             number = OldTex(str(choose(n, k)))\n",
        "#             equation = VGroup(binomial, OldTex(\"=\"), number)\n",
        "#             equation.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "#             equation.set_color(YELLOW)\n",
        "#             equation[1].set_color(WHITE)\n",
        "#             binomial_equations.add(equation)\n",
        "#         new_words = OldTexText(\"``Binomial coefficients''\")\n",
        "\n",
        "#         stacks = get_stacks(\n",
        "#             OldTex(\"x\").set_color(BLUE),\n",
        "#             OldTex(\"y\").set_color(RED),\n",
        "#             n\n",
        "#         )\n",
        "#         stacks.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "#         for stack, eq in zip(stacks, binomial_equations):\n",
        "#             eq.set_width(0.9*stack.get_width())\n",
        "#             eq.next_to(stack, UP)\n",
        "\n",
        "#         self.play(\n",
        "#             FadeIn(stacks, run_time = 2, lag_ratio = 0.5),\n",
        "#             self.n_choose_k_group.to_edge, UP\n",
        "#         )\n",
        "#         new_words.move_to(n_choose_k_words, LEFT)\n",
        "#         self.play(Transform(n_choose_k_words, new_words))\n",
        "#         for eq in binomial_equations:\n",
        "#             point = VectorizedPoint(n_choose_k.get_center())\n",
        "#             self.play(ReplacementTransform(\n",
        "#                 VGroup(n_choose_k, point, point).copy(),\n",
        "#                 eq\n",
        "#             ))\n",
        "#             self.wait()\n",
        "\n",
        "#         self.set_variables_as_attrs(stacks, binomial_equations)\n",
        "\n",
        "#     def perform_shift(self):\n",
        "#         n = self.start_n\n",
        "#         to_fade = VGroup(\n",
        "#             self.n_choose_k_group,\n",
        "#             self.binomial_equations\n",
        "#         )\n",
        "#         stacks = self.stacks\n",
        "#         top_stacks = stacks.copy()\n",
        "#         top_stacks.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "\n",
        "#         line = Line(LEFT, RIGHT, color = WHITE)\n",
        "#         line.scale(FRAME_X_RADIUS)\n",
        "#         line.next_to(top_stacks, DOWN)\n",
        "\n",
        "#         x = OldTex(\"x\").set_color(BLUE)\n",
        "#         y = OldTex(\"y\").set_color(RED)\n",
        "#         add_x, add_y = [\n",
        "#             OldTexText(\"Prepend\", \"$%s$\"%s).set_color_by_tex(s, color)\n",
        "#             for s, color in (\"x\", BLUE), (\"y\", RED)\n",
        "#         ]\n",
        "#         add_x.to_corner(UP+LEFT)\n",
        "#         add_y.to_edge(LEFT).shift(MED_SMALL_BUFF*DOWN)\n",
        "\n",
        "#         new_stacks, new_top_stacks = [\n",
        "#             get_stacks(x, y, n, fixed_start = var)\n",
        "#             for var in y, x\n",
        "#         ]\n",
        "#         new_top_stacks.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "#         new_stacks.to_edge(DOWN)\n",
        "#         for s in new_stacks, new_top_stacks:\n",
        "#             s.start_terms = VGroup()\n",
        "#             for stack in s:\n",
        "#                 for term in stack:\n",
        "#                     s.start_terms.add(term[0])\n",
        "\n",
        "#         s_to_s_distance = \\\n",
        "#             new_stacks[1].get_center()[0] - \\\n",
        "#             new_stacks[0].get_center()[0]\n",
        "\n",
        "#         self.play(\n",
        "#             FadeOut(to_fade),\n",
        "#             stacks.to_edge, DOWN,\n",
        "#             ReplacementTransform(stacks.copy(), top_stacks),\n",
        "#         )\n",
        "#         self.play(ShowCreation(line))\n",
        "#         self.play(Write(add_x, run_time = 1))\n",
        "#         self.play(Transform(top_stacks, new_top_stacks))\n",
        "#         self.play(LaggedStartMap(\n",
        "#             Indicate, new_top_stacks.start_terms,\n",
        "#             rate_func = there_and_back,\n",
        "#             run_time = 1,\n",
        "#             remover = True\n",
        "#         ))\n",
        "#         self.wait()\n",
        "#         self.play(Write(add_y, run_time = 1))\n",
        "#         self.play(Transform(stacks, new_stacks))\n",
        "#         self.play(LaggedStartMap(\n",
        "#             Indicate, new_stacks.start_terms,\n",
        "#             rate_func = there_and_back,\n",
        "#             run_time = 1,\n",
        "#             remover = True\n",
        "#         ))\n",
        "#         self.wait()\n",
        "\n",
        "#         self.play(\n",
        "#             top_stacks.shift, s_to_s_distance*RIGHT/2,\n",
        "#             stacks.shift, s_to_s_distance*LEFT/2,\n",
        "#         )\n",
        "#         self.play(*map(FadeOut, [add_x, add_y, line]))\n",
        "\n",
        "#         point = VectorizedPoint()\n",
        "#         point.move_to(top_stacks[0].get_bottom())\n",
        "#         point.shift(s_to_s_distance*LEFT)\n",
        "#         top_stacks.add_to_back(point)\n",
        "\n",
        "#         point = VectorizedPoint()\n",
        "#         point.move_to(stacks[-1].get_bottom())\n",
        "#         point.shift(s_to_s_distance*RIGHT)\n",
        "#         point.shift(MED_SMALL_BUFF*DOWN)\n",
        "#         stacks.add(point)\n",
        "\n",
        "#         for k, stack, top_stack in zip(it.count(), stacks, top_stacks):\n",
        "#             top_stack.generate_target()\n",
        "#             top_stack.target.next_to(stack, UP, MED_SMALL_BUFF)\n",
        "#             # term = OldTex(\n",
        "#             #     str(choose(n+1, k)),\n",
        "#             #     \"x^%d\"%(n+1-k),\n",
        "#             #     \"y^%d\"%k\n",
        "#             # )\n",
        "#             term = OldTex(\n",
        "#                 \"{%d \\\\choose %d}\"%(n+1, k),\n",
        "#                 \"=\",\n",
        "#                 str(choose(n+1, k))\n",
        "#             )\n",
        "#             term[0].scale(0.85, about_point = term[0].get_right())\n",
        "#             term[0].set_color(YELLOW)\n",
        "#             term[2].set_color(YELLOW)\n",
        "#             term.scale(0.85)\n",
        "#             term.next_to(top_stack.target, UP)\n",
        "\n",
        "#             self.play(MoveToTarget(top_stack))\n",
        "#             self.play(Write(term))\n",
        "#         self.wait()\n",
        "\n",
        "# class DifferentWaysToThinkAboutNChooseK(Scene):\n",
        "#     CONFIG = {\n",
        "#         \"n\" : 5,\n",
        "#         \"k\" : 3,\n",
        "#         \"stack_height\" : 5,\n",
        "#     }\n",
        "#     def construct(self):\n",
        "#         self.add_n_choose_k_term()\n",
        "#         self.add_stack()\n",
        "#         self.choose_k()\n",
        "#         self.split_stack_by_start()\n",
        "#         self.split_choices_by_start()\n",
        "\n",
        "#     def add_n_choose_k_term(self):\n",
        "#         term = OldTex(\"{5 \\\\choose 3} = 10\")\n",
        "#         term.to_edge(UP)\n",
        "#         self.play(FadeIn(term, lag_ratio = 0.5))\n",
        "#         self.wait()\n",
        "\n",
        "#         self.n_choose_k_term = term\n",
        "\n",
        "#     def add_stack(self):\n",
        "#         n, k = self.n, self.k\n",
        "#         x = OldTex(\"x\").set_color(BLUE)\n",
        "#         y = OldTex(\"y\").set_color(RED)\n",
        "#         stack = get_stack(x, y, n, k)\n",
        "#         stack.set_height(self.stack_height)\n",
        "#         stack.shift(FRAME_X_RADIUS*LEFT/2)\n",
        "#         stack.to_edge(DOWN)\n",
        "#         numbers = VGroup(*[\n",
        "#             OldTex(\"%d\"%(d+1))\n",
        "#             for d in range(choose(n, k))\n",
        "#         ])\n",
        "#         numbers.next_to(stack, UP)\n",
        "\n",
        "#         last_number = None\n",
        "#         for term, number in zip(stack, numbers):\n",
        "#             self.add(term, number)\n",
        "#             if last_number:\n",
        "#                 self.remove(last_number)\n",
        "#             self.wait(0.25)\n",
        "#             last_number = number\n",
        "#         self.wait()\n",
        "\n",
        "#         self.stack = stack\n",
        "#         self.stack_count = last_number\n",
        "#         self.numbers = numbers\n",
        "\n",
        "#     def choose_k(self):\n",
        "#         n, k = self.n, self.k\n",
        "\n",
        "#         letter_set = OldTex(\n",
        "#             \"(\",\n",
        "#             \"A\", \",\", \n",
        "#             \"B\", \",\",\n",
        "#             \"C\", \",\",\n",
        "#             \"D\", \",\",\n",
        "#             \"E\", \")\"\n",
        "#         )\n",
        "#         letters = VGroup(*letter_set[1::2])\n",
        "#         letter_set.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "#         letter_set.to_edge(UP)\n",
        "\n",
        "#         letter_subsets = list(it.combinations(letters, k))\n",
        "#         subset_mobs = VGroup(*[\n",
        "#             VGroup(*letter_subset).copy().arrange(\n",
        "#                 RIGHT, buff = SMALL_BUFF\n",
        "#             )\n",
        "#             for letter_subset in letter_subsets\n",
        "#         ]).arrange(DOWN, buff = MED_SMALL_BUFF)\n",
        "#         subset_mobs.set_height(self.stack_height)\n",
        "#         subset_mobs.shift(FRAME_X_RADIUS*RIGHT/2)\n",
        "#         subset_mobs.to_edge(DOWN)\n",
        "\n",
        "#         choose_words = OldTexText(\"Choose %d\"%k)\n",
        "#         choose_words.scale(0.9)\n",
        "#         choose_words.next_to(letter_set, DOWN)\n",
        "#         choose_words.set_color(YELLOW)\n",
        "\n",
        "#         self.revert_to_original_skipping_status()\n",
        "#         self.play(Write(letter_set, run_time = 1))\n",
        "#         self.play(\n",
        "#             Write(choose_words, run_time = 1),\n",
        "#             LaggedStartMap(FadeIn, subset_mobs)\n",
        "#         )\n",
        "#         self.wait()\n",
        "#         for subset, subset_mob in zip(letter_subsets, subset_mobs):\n",
        "#             VGroup(subset_mob, *subset).set_color(BLUE)\n",
        "#             self.wait(0.5)\n",
        "#             VGroup(*subset).set_color(WHITE)\n",
        "#         self.wait()\n",
        "\n",
        "#         self.set_variables_as_attrs(\n",
        "#             subset_mobs, letter_set, choose_words,\n",
        "#         )\n",
        "\n",
        "#     def split_stack_by_start(self):\n",
        "#         n, k = self.n, self.k\n",
        "#         stack = self.stack\n",
        "#         stack_count = self.stack_count\n",
        "\n",
        "#         top_num = choose(n-1, k-1)\n",
        "#         top_stack = VGroup(*stack[:top_num])\n",
        "#         bottom_stack = VGroup(*stack[top_num:])\n",
        "\n",
        "#         self.play(\n",
        "#             FadeOut(stack_count),\n",
        "#             top_stack.shift, UP\n",
        "#         )\n",
        "#         for stack, new_k in (top_stack, k-1), (bottom_stack, k):\n",
        "#             brace = Brace(stack, RIGHT)\n",
        "#             brace_tex = brace.get_tex(\n",
        "#                 \"{%d \\\\choose %d} = %d\"%(n-1, new_k, choose(n-1, new_k))\n",
        "#             )\n",
        "#             rect = SurroundingRectangle(VGroup(*[\n",
        "#                 VGroup(*term[1:])\n",
        "#                 for term in stack\n",
        "#             ]), buff = 0.5*SMALL_BUFF)\n",
        "#             rect.set_stroke(WHITE, 2)\n",
        "#             self.play(\n",
        "#                 GrowFromCenter(brace),\n",
        "#                 Write(brace_tex),\n",
        "#                 ShowCreation(rect)\n",
        "#             )\n",
        "#             self.wait()\n",
        "\n",
        "#     def split_choices_by_start(self):\n",
        "#         subset_mobs = self.subset_mobs\n",
        "#         subset_mobs.generate_target()\n",
        "#         subset_mobs.target.shift(LEFT)\n",
        "#         brace = Brace(subset_mobs.target, RIGHT)\n",
        "#         expression = brace.get_tex(\n",
        "#             \"\\\\frac{5 \\\\cdot 4 \\\\cdot 3}{1 \\\\cdot 2 \\\\cdot 3}\",\n",
        "#             \"= 10\"\n",
        "#         )\n",
        "\n",
        "#         self.play(\n",
        "#             MoveToTarget(subset_mobs),\n",
        "#             GrowFromCenter(brace)\n",
        "#         )\n",
        "#         self.play(Write(expression))\n",
        "#         self.wait()\n",
        "\n",
        "# class FormulaVsPattern(TeacherStudentsScene):\n",
        "#     def construct(self):\n",
        "#         self.show_formula()\n",
        "#         self.show_pattern()\n",
        "\n",
        "#     def show_formula(self):\n",
        "#         formula = OldTex(\n",
        "#             \"{n \\\\choose k} = {n! \\\\over (n-k)!k!}\", \n",
        "#         )\n",
        "#         for i in 1, 5, 9:\n",
        "#             formula[i].set_color(BLUE)\n",
        "#         for i in 2, 11, 14:\n",
        "#             formula[i].set_color(YELLOW)\n",
        "\n",
        "#         self.student_thinks(formula, index = 1)\n",
        "#         self.play(self.teacher.change, \"sassy\")\n",
        "#         self.wait(2)\n",
        "#         self.play(\n",
        "#             FadeOut(self.students[1].bubble),\n",
        "#             FadeOut(formula),\n",
        "#             self.teacher.change, \"raise_right_hand\",\n",
        "#             self.change_students(*[\"pondering\"]*3)\n",
        "#         )\n",
        "\n",
        "#     def show_pattern(self):\n",
        "#         words = OldTexText(\n",
        "#             \"What is the \\\\\\\\ probability of a flush?\"\n",
        "#         )\n",
        "#         values = random.sample(PlayingCard.CONFIG[\"possible_values\"], 5)\n",
        "#         cards = VGroup(*[\n",
        "#             PlayingCard(value = value, suit = \"hearts\")\n",
        "#             for value in values\n",
        "#         ])\n",
        "#         cards.arrange(RIGHT)\n",
        "#         cards.to_corner(UP+RIGHT)\n",
        "#         words.next_to(cards, LEFT)\n",
        "#         words.shift_onto_screen()\n",
        "\n",
        "#         self.play(LaggedStartMap(DrawBorderThenFill, cards))\n",
        "#         self.play(Write(words))\n",
        "#         self.wait(3)\n",
        "\n",
        "class ProbabilityOfKWomenInGroupOfFive(Scene):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 0,\n",
        "        \"n_people_per_lineup\" : 5,\n",
        "        \"n_examples\" : 18,\n",
        "        \"item_line_width\" : 0.4,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.ask_question()\n",
        "        self.show_all_possibilities()\n",
        "        self.stack_all_choices_by_number_of_women()\n",
        "        self.go_through_stacks()\n",
        "        self.remember_this_sensation()\n",
        "        self.show_answer_to_question()\n",
        "        self.ask_about_pattern()\n",
        "\n",
        "    def ask_question(self):\n",
        "        title = OldTexText(\"5 randomly chosen people\")\n",
        "        title.to_edge(UP)\n",
        "        self.add(title)\n",
        "\n",
        "        lineup_point = 1.5*UP\n",
        "        prob_words = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"Probability of\", str(n), \"women?\"\n",
        "            ).set_color_by_tex(str(n), YELLOW)\n",
        "            for n in range(self.n_people_per_lineup+1)\n",
        "        ])\n",
        "        prob_words.arrange(DOWN)\n",
        "        prob_words.next_to(lineup_point, DOWN, MED_LARGE_BUFF)\n",
        "\n",
        "        def get_lineup():\n",
        "            lineup = self.get_random_lineup_of_men_and_women()\n",
        "            lineup.scale(1.5)\n",
        "            lineup.move_to(lineup_point, DOWN)\n",
        "            return lineup\n",
        "\n",
        "        last_lineup = get_lineup()\n",
        "        self.play(LaggedStartMap(FadeIn, last_lineup, run_time = 1))\n",
        "\n",
        "        for x in range(self.n_examples):\n",
        "            lineup = get_lineup()\n",
        "            anims = [last_lineup.items.fade, 1]\n",
        "            anims += list(map(GrowFromCenter, lineup.items))\n",
        "            if x >= 12 and x-12 < len(prob_words):\n",
        "                anims.append(FadeIn(prob_words[x-12]))\n",
        "            self.play(*anims, run_time = 0.75)\n",
        "            self.remove(last_lineup)\n",
        "            self.add(lineup)\n",
        "            self.wait(0.25)\n",
        "            last_lineup = lineup\n",
        "\n",
        "        self.title = title\n",
        "        self.prob_words = prob_words\n",
        "        self.lineup = last_lineup\n",
        "\n",
        "    def show_all_possibilities(self):\n",
        "        man, woman = Male(), Female()\n",
        "\n",
        "        vects = [\n",
        "            1.5*UP,\n",
        "            0.65*UP,\n",
        "            0.25*UP,\n",
        "            3.5*RIGHT,\n",
        "            1.5*RIGHT,\n",
        "        ]\n",
        "        lineup_groups = VGroup()\n",
        "        for k in range(6):\n",
        "            lineup_group = VGroup()\n",
        "            for tup in it.product(*[[woman, man]]*k):\n",
        "                lineup = self.get_lineup(*list(tup) + (5-k)*[None])\n",
        "                lineup.scale(1.4*(0.9)**k)\n",
        "                lineup.move_to(0.5*DOWN)\n",
        "                for mob, vect in zip(tup, vects):\n",
        "                    if mob is woman:\n",
        "                        lineup.shift(vect)\n",
        "                    else:\n",
        "                        lineup.shift(-vect)\n",
        "                lineup_group.add(lineup)\n",
        "            lineup_groups.add(lineup_group)\n",
        "\n",
        "        n_possibilities = OldTex(\n",
        "            \"2 \\\\cdot\", \"2 \\\\cdot\", \"2 \\\\cdot\", \"2 \\\\cdot\", \"2\",\n",
        "            \"\\\\text{ Possibilities}\"\n",
        "        )\n",
        "        n_possibilities.next_to(self.title, DOWN)\n",
        "        twos = VGroup(*n_possibilities[-2::-1])\n",
        "        twos.set_color(YELLOW)\n",
        "        two_anims = [\n",
        "            ReplacementTransform(\n",
        "                VectorizedPoint(twos[0].get_center()), \n",
        "                twos[0]\n",
        "            )\n",
        "        ] + [\n",
        "            ReplacementTransform(t1.copy(), t2)\n",
        "            for t1, t2 in zip(twos, twos[1:])\n",
        "        ]\n",
        "\n",
        "        curr_lineup_group = lineup_groups[0]\n",
        "        self.play(\n",
        "            ReplacementTransform(self.lineup, curr_lineup_group[0]),\n",
        "            FadeOut(self.prob_words)\n",
        "        )\n",
        "        for i, lineup_group in enumerate(lineup_groups[1:]):\n",
        "            anims = [ReplacementTransform(curr_lineup_group, lineup_group)]\n",
        "            anims += two_anims[:i+1]\n",
        "            if i == 0:\n",
        "                anims.append(FadeIn(n_possibilities[-1]))\n",
        "            self.remove(twos)\n",
        "            self.play(*anims)\n",
        "\n",
        "            men, women = VGroup(), VGroup()\n",
        "            for lineup in lineup_group:\n",
        "                item = lineup.items[i]\n",
        "                if \"female\" in item.get_tex():\n",
        "                    women.add(item)\n",
        "                else:\n",
        "                    men.add(item)\n",
        "            for group in men, women:\n",
        "                self.play(LaggedStartMap(\n",
        "                    ApplyMethod, group,\n",
        "                    lambda m : (m.shift, MED_SMALL_BUFF*RIGHT),\n",
        "                    rate_func = there_and_back,\n",
        "                    lag_ratio = 0.9**i,\n",
        "                    run_time = 1,\n",
        "                ))\n",
        "            self.wait()\n",
        "            curr_lineup_group = lineup_group\n",
        "        self.lineups = curr_lineup_group\n",
        "\n",
        "        eq_32 = OldTex(\"=\", \"32\")\n",
        "        eq_32.move_to(twos.get_right())\n",
        "        eq_32.set_color_by_tex(\"32\", YELLOW)\n",
        "        self.play(\n",
        "            n_possibilities[-1].next_to, eq_32, RIGHT,\n",
        "            twos.next_to, eq_32, LEFT,\n",
        "            FadeIn(eq_32),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        n_possibilities.add(*eq_32)\n",
        "        self.set_variables_as_attrs(n_possibilities)\n",
        "\n",
        "    def stack_all_choices_by_number_of_women(self):\n",
        "        lineups = self.lineups\n",
        "        stacks = VGroup(*[VGroup() for x in range(6)])\n",
        "        for lineup in lineups:\n",
        "            lineup.women = VGroup(*[m for m in lineup.items if \"female\" in m.get_tex()])\n",
        "            stacks[len(lineup.women)].add(lineup)\n",
        "        stacks.generate_target()\n",
        "        stacks.target.scale(0.75)\n",
        "        for stack in stacks.target:\n",
        "            stack.arrange(DOWN, buff = 1.5*SMALL_BUFF)\n",
        "        stacks.target.arrange(\n",
        "            RIGHT, buff = MED_LARGE_BUFF, aligned_edge = DOWN\n",
        "        )\n",
        "        stacks.target.to_edge(DOWN)\n",
        "\n",
        "        self.play(MoveToTarget(\n",
        "            stacks, \n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.stacks = stacks\n",
        "\n",
        "    def go_through_stacks(self):\n",
        "        stacks = self.stacks\n",
        "        n = len(stacks) - 1\n",
        "        equations = VGroup()\n",
        "        for k, stack in enumerate(stacks):\n",
        "            items = VGroup()\n",
        "            lines = VGroup()\n",
        "            women = VGroup()\n",
        "            for lineup in stack:\n",
        "                items.add(lineup.items)\n",
        "                lines.add(lineup.lines)\n",
        "                for item in lineup.items:\n",
        "                    if \"female\" in item.get_tex():\n",
        "                        women.add(item)\n",
        "            equation = OldTex(\n",
        "                \"{%d \\\\choose %d}\"%(n, k),\n",
        "                \"=\",\n",
        "                str(len(stack))\n",
        "            )\n",
        "            equation[0].scale(0.6)\n",
        "            equation.arrange(RIGHT, SMALL_BUFF)\n",
        "            equation.set_color(YELLOW)\n",
        "            equation.set_color_by_tex(\"=\", WHITE)\n",
        "            equation.next_to(stack, UP)\n",
        "            equations.add(equation)\n",
        "\n",
        "            self.play(\n",
        "                items.set_fill, None, 1,\n",
        "                lines.set_stroke, WHITE, 3,\n",
        "                Write(equation, run_time = 1)\n",
        "            )\n",
        "            self.play(LaggedStartMap(Indicate, women, rate_func = there_and_back))\n",
        "        self.wait()\n",
        "\n",
        "        self.equations = equations\n",
        "        self.numbers = VGroup(*[eq[-1] for eq in equations])\n",
        "\n",
        "    def remember_this_sensation(self):\n",
        "        n_possibilities = self.n_possibilities\n",
        "        n_possibilities_rect = SurroundingRectangle(n_possibilities)\n",
        "        twos = VGroup(*n_possibilities[:5])\n",
        "        numbers = self.numbers\n",
        "\n",
        "        self.play(ShowCreation(n_possibilities_rect))\n",
        "        self.play(LaggedStartMap(\n",
        "            Indicate, twos, \n",
        "            rate_func = wiggle\n",
        "        ))\n",
        "        self.play(FadeOut(n_possibilities_rect))\n",
        "        for number in numbers:\n",
        "            self.play(Indicate(number, color = PINK, run_time = 0.5))\n",
        "        self.wait()\n",
        "\n",
        "    def show_answer_to_question(self):\n",
        "        stacks = self.stacks\n",
        "        numbers = self.numbers\n",
        "        n_possibilities = VGroup(\n",
        "            self.n_possibilities[-1],\n",
        "            self.n_possibilities[-3]\n",
        "        )\n",
        "        n_possibilities_part_to_fade = VGroup(\n",
        "            self.n_possibilities[-2],\n",
        "            *self.n_possibilities[:-3]\n",
        "        )\n",
        "        total = n_possibilities[-1]\n",
        "        title = self.title\n",
        "        n = self.n_people_per_lineup\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(title),\n",
        "            FadeOut(n_possibilities_part_to_fade),\n",
        "            n_possibilities.to_corner, UP+RIGHT\n",
        "        )\n",
        "        for k, stack, num in zip(it.count(), stacks, numbers):\n",
        "            rect = SurroundingRectangle(stack)\n",
        "            num.save_state()\n",
        "            prob_words = OldTex(\n",
        "                \"P(\", \"\\\\#\", \"\\\\female\", \"=\", str(k), \")\"\n",
        "                \"=\", \"{\\\\quad \\\\over\", \"32}\",\n",
        "                \"\\\\approx\", \"%0.3f\"%(choose(n, k)/32.0)\n",
        "            )\n",
        "            prob_words.set_color_by_tex_to_color_map({\n",
        "                \"female\" : MAROON_B,\n",
        "                \"32\" : YELLOW,\n",
        "            })\n",
        "            frac_line = prob_words.get_parts_by_tex(\"over\")\n",
        "            prob_words.to_corner(UP+LEFT)\n",
        "\n",
        "            self.play(\n",
        "                num.next_to, frac_line, UP, SMALL_BUFF,\n",
        "                FadeIn(prob_words)\n",
        "            )\n",
        "            self.play(ShowCreation(rect))\n",
        "            self.wait(2)\n",
        "            self.play(\n",
        "                num.restore,\n",
        "                FadeOut(rect),\n",
        "                FadeOut(prob_words)\n",
        "            )\n",
        "\n",
        "    def ask_about_pattern(self):\n",
        "        question = OldTexText(\"Where do these \\\\\\\\ numbers come from?\")\n",
        "        question.to_edge(UP)\n",
        "        numbers = self.numbers\n",
        "        circles = VGroup(*[\n",
        "            Circle().replace(num, dim_to_match = 1).scale(1.5)\n",
        "            for num in numbers\n",
        "        ])\n",
        "        circles.set_color(WHITE)\n",
        "\n",
        "        self.play(LaggedStartMap(FadeIn, question))\n",
        "        self.play(LaggedStartMap(ShowCreationThenDestruction, circles))\n",
        "        self.wait(2)\n",
        "\n",
        "    ######\n",
        "\n",
        "    def get_random_lineup_of_men_and_women(self):\n",
        "        man, woman = Male(), Female()\n",
        "        lineup = self.get_lineup(*[\n",
        "            woman if random.choice([True, False]) else man\n",
        "            for y in range(self.n_people_per_lineup)\n",
        "        ])\n",
        "        return lineup\n",
        "\n",
        "    def get_lineup(self, *mobjects, **kwargs):\n",
        "        buff = kwargs.get(\"buff\", MED_SMALL_BUFF)\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, self.item_line_width*RIGHT)\n",
        "            for mob in mobjects\n",
        "        ])\n",
        "        lines.arrange(RIGHT, buff = buff)\n",
        "        items = VGroup()\n",
        "        for line, mob in zip(lines, mobjects):\n",
        "            item = VectorizedPoint() if mob is None else mob.copy()\n",
        "            item.next_to(line, UP, SMALL_BUFF)\n",
        "            items.add(item)\n",
        "        result = VGroup(lines, items)\n",
        "        result.lines = lines\n",
        "        result.items = items\n",
        "        return result\n",
        "\n",
        "class AskAboutAllPossibilities(ProbabilityOfKWomenInGroupOfFive):\n",
        "    def construct(self):\n",
        "        man, woman = Male(), Female()\n",
        "        all_lineups = VGroup()\n",
        "        for bits in it.product(*[[False, True]]*5):\n",
        "            mobs = [\n",
        "                woman.copy() if bit else man.copy()\n",
        "                for bit in bits\n",
        "            ]\n",
        "            all_lineups.add(self.get_lineup(*mobs))\n",
        "        brace = Brace(all_lineups, UP)\n",
        "        question = brace.get_text(\"What are all possibilities?\")\n",
        "\n",
        "        self.add(brace, question)\n",
        "        for lineup in all_lineups:\n",
        "            self.add(lineup)\n",
        "            self.wait(0.25)\n",
        "            self.remove(lineup)\n",
        "\n",
        "class RememberThisSensation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.teacher_says(\"Remember this \\\\\\\\ sensation\")\n",
        "        self.play_student_changes(\"confused\", \"pondering\", \"erm\")\n",
        "        self.wait(2)\n",
        "\n",
        "class TeacherHoldingSomething(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        self.play(\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = 2*UP+2*RIGHT\n",
        "        )\n",
        "        self.wait(6)\n",
        "\n",
        "# class GroupsOf6(Scene):\n",
        "#     def construct(self):\n",
        "#         title = OldTex(\"2^6 =\", \"64\", \"\\\\text{ Possibilities}\")\n",
        "#         title.to_edge(UP, buff = MED_SMALL_BUFF)\n",
        "#         title.set_color_by_tex(\"64\", YELLOW)\n",
        "#         man, woman = Male(), Female()\n",
        "#         stacks = get_stacks(man, woman, 6, vertical_buff = SMALL_BUFF)\n",
        "#         stacks.set_height(6.25)\n",
        "#         stacks.to_edge(DOWN, buff = MED_SMALL_BUFF)\n",
        "#         women_groups = VGroup()\n",
        "#         for stack in stacks:\n",
        "#             for lineup in stack:\n",
        "#                 group = VGroup()\n",
        "#                 for item in lineup:\n",
        "#                     if \"female\" in item.get_tex():\n",
        "#                         group.add(item)\n",
        "#                 women_groups.add(group)\n",
        "\n",
        "#         numbers = VGroup()\n",
        "#         for stack in stacks:\n",
        "#             number = OldTex(str(len(stack)))\n",
        "#             number.next_to(stack, UP, SMALL_BUFF)\n",
        "#             numbers.add(number)\n",
        "\n",
        "#         self.add(title)\n",
        "#         self.play(LaggedStartMap(\n",
        "#             LaggedStartMap, stacks,\n",
        "#             lambda s : (FadeIn, s),\n",
        "#             run_time = 3,\n",
        "#         ))\n",
        "#         self.play(Write(numbers, run_time = 3))\n",
        "#         self.wait()\n",
        "#         self.play(LaggedStartMap(\n",
        "#             ApplyMethod, women_groups,\n",
        "#             lambda m : (m.set_color, PINK),\n",
        "#             lag_ratio = 0.1,\n",
        "#             rate_func = wiggle,\n",
        "#             run_time = 6,\n",
        "#         ))\n",
        "\n",
        "# class GroupsOf7(Scene):\n",
        "#     def construct(self):\n",
        "#         stack = get_stack(Male(), Female(), 7, 3)\n",
        "#         question = OldTexText(\n",
        "#             \"How many groups \\\\\\\\ of 7 with 3 \", \"$\\\\female$\", \"?\"\n",
        "#         )\n",
        "#         question.set_color_by_tex(\"female\", MAROON_B)\n",
        "#         question.shift(1.5*UP)\n",
        "\n",
        "#         self.add(question)\n",
        "#         for n, item in enumerate(stack):\n",
        "#             item.center()\n",
        "#             number = OldTex(str(n))\n",
        "#             number.next_to(ORIGIN, DOWN, LARGE_BUFF)\n",
        "#             self.add(item, number)\n",
        "#             self.wait(0.2)\n",
        "#             self.remove(item, number)\n",
        "#         self.add(item, number)\n",
        "#         self.wait(2)\n",
        "\n",
        "class BuildFiveFromFour(ProbabilityOfKWomenInGroupOfFive):\n",
        "    def construct(self):\n",
        "        self.show_all_configurations_of_four()\n",
        "        self.organize_into_stacks()\n",
        "        self.walk_through_stacks()\n",
        "        self.split_into_two_possibilities()\n",
        "        self.combine_stacks()\n",
        "\n",
        "    def show_all_configurations_of_four(self):\n",
        "        man, woman = Male(), Female()\n",
        "        n = 4\n",
        "        vects = [\n",
        "            1.5*UP,\n",
        "            0.5*UP,\n",
        "            3.5*RIGHT,\n",
        "            1.5*RIGHT,\n",
        "        ]\n",
        "        lineup_groups = VGroup()\n",
        "        for k in range(n+1):\n",
        "            lineup_group = VGroup()\n",
        "            for tup in it.product(*[[man, woman]]*k):\n",
        "                lineup = self.get_lineup(*list(tup) + (n-k)*[None])\n",
        "                lineup.scale(1.4*(0.9)**k)\n",
        "                lineup.move_to(0.5*DOWN)\n",
        "                for mob, vect in zip(tup, vects):\n",
        "                    if mob is woman:\n",
        "                        lineup.shift(vect)\n",
        "                    else:\n",
        "                        lineup.shift(-vect)\n",
        "                lineup_group.add(lineup)\n",
        "            lineup_groups.add(lineup_group)\n",
        "\n",
        "        n_possibilities = OldTex(\n",
        "            \"2 \\\\cdot\", \"2 \\\\cdot\", \"2 \\\\cdot\", \"2\",\n",
        "            \"\\\\text{ Possibilities}\"\n",
        "        )\n",
        "        n_possibilities.to_edge(UP)\n",
        "        twos = VGroup(*n_possibilities[-2::-1])\n",
        "        two_anims = [\n",
        "            ReplacementTransform(\n",
        "                VectorizedPoint(twos[0].get_center()), \n",
        "                twos[0]\n",
        "            )\n",
        "        ] + [\n",
        "            ReplacementTransform(t1.copy(), t2)\n",
        "            for t1, t2 in zip(twos, twos[1:])\n",
        "        ]\n",
        "\n",
        "        curr_lineup_group = lineup_groups[0]\n",
        "        self.play(\n",
        "            ShowCreation(curr_lineup_group[0]),\n",
        "        )\n",
        "        for i, lineup_group in enumerate(lineup_groups[1:]):\n",
        "            anims = [ReplacementTransform(curr_lineup_group, lineup_group)]\n",
        "            anims += two_anims[:i+1]\n",
        "            if i == 0:\n",
        "                anims.append(FadeIn(n_possibilities[-1]))\n",
        "            self.remove(twos)\n",
        "            self.play(*anims)\n",
        "            self.wait()\n",
        "            curr_lineup_group = lineup_group\n",
        "        self.lineups = curr_lineup_group\n",
        "\n",
        "        eq_16 = OldTex(\"=\", \"16\")\n",
        "        eq_16.move_to(twos.get_right())\n",
        "        eq_16.set_color_by_tex(\"16\", YELLOW)\n",
        "        self.play(\n",
        "            n_possibilities[-1].next_to, eq_16, RIGHT,\n",
        "            twos.next_to, eq_16, LEFT,\n",
        "            FadeIn(eq_16),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        n_possibilities.add(eq_16)\n",
        "        self.n_possibilities = n_possibilities\n",
        "\n",
        "    def organize_into_stacks(self):\n",
        "        lineups = self.lineups\n",
        "        stacks = VGroup(*[VGroup() for x in range(5)])\n",
        "        for lineup in lineups:\n",
        "            women = [m for m in lineup.items if \"female\" in m.get_tex()]\n",
        "            stacks[len(women)].add(lineup)\n",
        "        stacks.generate_target()\n",
        "        stacks.target.scale(0.75)\n",
        "        for stack in stacks.target:\n",
        "            stack.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        stacks.target.arrange(\n",
        "            RIGHT, buff = MED_LARGE_BUFF, aligned_edge = DOWN\n",
        "        )\n",
        "        stacks.target.to_edge(DOWN, buff = MED_SMALL_BUFF)\n",
        "\n",
        "        self.play(MoveToTarget(\n",
        "            stacks, \n",
        "            run_time = 2,\n",
        "            path_arc = np.pi/2\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.stacks = stacks\n",
        "\n",
        "    def walk_through_stacks(self):\n",
        "        stacks = self.stacks\n",
        "        numbers = VGroup()\n",
        "\n",
        "        for stack in stacks:\n",
        "            rect = SurroundingRectangle(stack)\n",
        "            rect.set_stroke(WHITE, 2)\n",
        "            self.play(ShowCreation(rect))\n",
        "            for n, lineup in enumerate(stack):\n",
        "                lineup_copy = lineup.copy()\n",
        "                lineup_copy.set_color(YELLOW)\n",
        "                number = OldTex(str(n+1))\n",
        "                number.next_to(stack, UP)\n",
        "                self.add(lineup_copy, number)\n",
        "                self.wait(0.25)\n",
        "                self.remove(lineup_copy, number)\n",
        "            self.add(number)\n",
        "            numbers.add(number)\n",
        "            self.play(FadeOut(rect))\n",
        "        self.wait()\n",
        "\n",
        "        stacks.numbers = numbers\n",
        "\n",
        "    def split_into_two_possibilities(self):\n",
        "        bottom_stacks = self.stacks\n",
        "        top_stacks = bottom_stacks.deepcopy()\n",
        "        top_group = VGroup(top_stacks, top_stacks.numbers)\n",
        "\n",
        "        h_line = DashedLine(FRAME_X_RADIUS*LEFT, FRAME_X_RADIUS*RIGHT)\n",
        "\n",
        "        #Initial split\n",
        "        self.play(\n",
        "            FadeOut(self.n_possibilities),\n",
        "            top_group.to_edge, UP, MED_SMALL_BUFF,\n",
        "        )\n",
        "        self.play(ShowCreation(h_line))\n",
        "\n",
        "        #Add extra slot\n",
        "        for stacks, sym in (top_stacks, Female()), (bottom_stacks, Male()):\n",
        "            sym.set_fill(opacity = 0)\n",
        "            new_stacks = VGroup()\n",
        "            to_fade_in = VGroup()\n",
        "            for stack in stacks:\n",
        "                new_stack = VGroup()\n",
        "                for lineup in stack:\n",
        "                    new_lineup = self.get_lineup(*[\n",
        "                        Female() if \"female\" in item.get_tex() else Male()\n",
        "                        for item in lineup.items\n",
        "                    ] + [sym], buff = SMALL_BUFF)\n",
        "                    new_lineup.replace(lineup, dim_to_match = 1)\n",
        "                    new_stack.add(new_lineup)\n",
        "                    for group in lineup.items, lineup.lines:\n",
        "                        point = VectorizedPoint(group[-1].get_center())\n",
        "                        group.add(point)\n",
        "                    to_fade_in.add(lineup.items[-1])\n",
        "                new_stacks.add(new_stack)\n",
        "            new_stacks.arrange(\n",
        "                RIGHT, buff = MED_LARGE_BUFF, aligned_edge = DOWN\n",
        "            )\n",
        "            new_stacks.move_to(stacks, DOWN)\n",
        "            stacks.target = new_stacks\n",
        "            stacks.to_fade_in = to_fade_in\n",
        "\n",
        "            stacks.numbers.generate_target()\n",
        "            for number, stack in zip(stacks.numbers.target, new_stacks):\n",
        "                number.next_to(stack, UP)\n",
        "\n",
        "        for stacks in top_stacks, bottom_stacks:\n",
        "            self.play(\n",
        "                MoveToTarget(stacks),\n",
        "                MoveToTarget(stacks.numbers)\n",
        "            )\n",
        "        self.wait()\n",
        "\n",
        "        #Fill extra slot\n",
        "        add_man = OldTexText(\"Add\", \"$\\\\male$\")\n",
        "        add_man.set_color_by_tex(\"male\", BLUE)\n",
        "        add_woman = OldTexText(\"Add\", \"$\\\\female$\")\n",
        "        add_woman.set_color_by_tex(\"female\", MAROON_B)\n",
        "\n",
        "        add_man.next_to(ORIGIN, DOWN).to_edge(LEFT)\n",
        "        add_woman.to_corner(UP+LEFT)\n",
        "\n",
        "        for stacks, words in (bottom_stacks, add_man), (top_stacks, add_woman):\n",
        "            to_fade_in = stacks.to_fade_in\n",
        "            to_fade_in.set_fill(opacity = 1)\n",
        "            to_fade_in.save_state()\n",
        "            Transform(to_fade_in, VGroup(words[-1])).update(1)\n",
        "\n",
        "            self.play(Write(words, run_time = 1))\n",
        "            self.play(to_fade_in.restore)\n",
        "            self.wait()\n",
        "\n",
        "        #Perform shift\n",
        "        dist = top_stacks[1].get_center()[0] - top_stacks[0].get_center()[0]\n",
        "        self.play(\n",
        "            top_stacks.shift, dist*RIGHT/2,\n",
        "            top_stacks.numbers.shift, dist*RIGHT/2,\n",
        "            bottom_stacks.shift, dist*LEFT/2,\n",
        "            bottom_stacks.numbers.shift, dist*LEFT/2,\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(*list(map(FadeOut, [add_man, add_woman, h_line])))\n",
        "\n",
        "        self.set_variables_as_attrs(top_stacks, bottom_stacks)\n",
        "\n",
        "    def combine_stacks(self):\n",
        "        top_stacks = self.top_stacks\n",
        "        bottom_stacks = self.bottom_stacks\n",
        "\n",
        "        rects = VGroup()\n",
        "        for stacks, color in (top_stacks, MAROON_C), (bottom_stacks, BLUE_D):\n",
        "            for stack in stacks:\n",
        "                rect = SurroundingRectangle(stack)\n",
        "                rect.set_stroke(color, 2)\n",
        "                rects.add(rect)\n",
        "                stack.add(rect)\n",
        "\n",
        "        new_numbers = VGroup()\n",
        "\n",
        "        self.play(LaggedStartMap(ShowCreation, rects, run_time = 1))\n",
        "        for i, top_stack in enumerate(top_stacks[:-1]):\n",
        "            bottom_stack = bottom_stacks[i+1]\n",
        "            top_number = top_stacks.numbers[i]\n",
        "            bottom_number = bottom_stacks.numbers[i+1]\n",
        "            movers = top_stack, top_number, bottom_number\n",
        "            for mob in movers:\n",
        "                mob.generate_target()\n",
        "            top_stack.target.move_to(bottom_stack.get_top(), DOWN)\n",
        "            plus = OldTex(\"+\")\n",
        "            expr = VGroup(top_number.target, plus, bottom_number.target)\n",
        "            expr.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            expr.next_to(top_stack.target.get_top(), UP)\n",
        "\n",
        "            new_number = OldTex(str(\n",
        "                len(top_stack) + len(bottom_stack) - 2\n",
        "            ))\n",
        "            new_number.next_to(expr, UP)\n",
        "            new_numbers.add(new_number)\n",
        "\n",
        "            self.play(\n",
        "                Write(plus),\n",
        "                *list(map(MoveToTarget, movers))\n",
        "            )\n",
        "        self.play(\n",
        "            VGroup(top_stacks[-1], top_stacks.numbers[-1]).align_to,\n",
        "            bottom_stacks, DOWN\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        new_numbers.add_to_back(bottom_stacks.numbers[0].copy())\n",
        "        new_numbers.add(top_stacks.numbers[-1].copy())\n",
        "        new_numbers.set_color(PINK)\n",
        "        self.play(Write(new_numbers, run_time = 3))\n",
        "        self.wait()\n",
        "\n",
        "class BuildUpFromStart(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_iterations\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        stacks = VGroup(VGroup(Male()), VGroup(Female()))\n",
        "        stacks.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "        stacks.numbers = self.get_numbers(stacks)\n",
        "\n",
        "        max_width = FRAME_WIDTH - 3\n",
        "        max_height = FRAME_Y_RADIUS - 1\n",
        "\n",
        "        self.add(stacks, stacks.numbers)\n",
        "        for x in range(self.n_iterations):\n",
        "            if x < 2:\n",
        "                wait_time = 1\n",
        "            else:\n",
        "                wait_time = 0.2\n",
        "            #Divide\n",
        "            low_stacks = stacks\n",
        "            low_group = VGroup(low_stacks, low_stacks.numbers)\n",
        "            top_stacks = stacks.deepcopy()\n",
        "            top_group = VGroup(top_stacks, top_stacks.numbers)\n",
        "            for group, vect in (top_group, UP), (low_group, DOWN):\n",
        "                group.generate_target()\n",
        "                if group[0].get_height() > max_height:\n",
        "                    group.target[0].stretch_to_fit_height(max_height)\n",
        "                    for stack, num in zip(*group.target):\n",
        "                        num.next_to(stack, UP)\n",
        "                group.target.next_to(ORIGIN, vect)\n",
        "            self.play(*list(map(MoveToTarget, [top_group, low_group])))\n",
        "            self.wait(wait_time)\n",
        "\n",
        "            #Expand\n",
        "            for stacks, i in (low_stacks, 0), (top_stacks, -1):\n",
        "                sym = stacks[i][i][i]\n",
        "                new_stacks = VGroup()\n",
        "                for stack in stacks:\n",
        "                    new_stack = VGroup()\n",
        "                    for line in stack:\n",
        "                        new_line = line.copy()\n",
        "                        new_sym = sym.copy()\n",
        "                        buff = 0.3*line.get_height()\n",
        "                        new_sym.next_to(line, RIGHT, buff = buff)\n",
        "                        new_line.add(new_sym)\n",
        "                        line.add(VectorizedPoint(line[-1].get_center()))\n",
        "                        new_stack.add(new_line)\n",
        "                    new_stacks.add(new_stack)\n",
        "                new_stacks.arrange(\n",
        "                    RIGHT, buff = LARGE_BUFF, aligned_edge = DOWN\n",
        "                )\n",
        "                if new_stacks.get_width() > max_width:\n",
        "                    new_stacks.stretch_to_fit_width(max_width)\n",
        "                if new_stacks.get_height() > max_height:\n",
        "                    new_stacks.stretch_to_fit_height(max_height)\n",
        "                new_stacks.move_to(stacks, DOWN)\n",
        "                stacks.target = new_stacks\n",
        "                stacks.numbers.generate_target()\n",
        "\n",
        "                for num, stack in zip(stacks.numbers.target, new_stacks):\n",
        "                    num.next_to(stack, UP)\n",
        "            self.play(*list(map(MoveToTarget, [\n",
        "                top_stacks, low_stacks,\n",
        "                top_stacks.numbers, low_stacks.numbers,\n",
        "            ])))\n",
        "            self.wait(wait_time)\n",
        "\n",
        "            #Shift\n",
        "            dist = top_stacks[1].get_center()[0] - top_stacks[0].get_center()[0]\n",
        "            self.play(\n",
        "                top_group.shift, dist*RIGHT/2,\n",
        "                low_group.shift, dist*LEFT/2,\n",
        "            )\n",
        "            self.wait(wait_time)\n",
        "\n",
        "            #Stack\n",
        "            all_movers = VGroup()\n",
        "            plusses = VGroup()\n",
        "            expressions = VGroup(low_stacks.numbers[0])\n",
        "            stacks = VGroup(low_stacks[0])\n",
        "            v_buff = 0.25*stacks[0][0].get_height()\n",
        "\n",
        "            for i, top_stack in enumerate(top_stacks[:-1]):\n",
        "                low_stack = low_stacks[i+1]\n",
        "                top_num = top_stacks.numbers[i]\n",
        "                low_num = low_stacks.numbers[i+1]\n",
        "                movers = [top_stack, top_num, low_num]\n",
        "                for mover in movers:\n",
        "                    mover.generate_target()\n",
        "                plus = OldTex(\"+\")\n",
        "                expr = VGroup(top_num.target, plus, low_num.target)\n",
        "                expr.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "                top_stack.target.next_to(low_stack, UP, buff = v_buff)\n",
        "                expr.next_to(top_stack.target, UP)\n",
        "\n",
        "                all_movers.add(*movers)\n",
        "                plusses.add(plus)\n",
        "                expressions.add(VGroup(top_num, plus, low_num))\n",
        "                stacks.add(VGroup(*it.chain(low_stack, top_stack)))\n",
        "\n",
        "            last_group = VGroup(top_stacks[-1], top_stacks.numbers[-1])\n",
        "            last_group.generate_target()\n",
        "            last_group.target.align_to(low_stacks, DOWN)\n",
        "            all_movers.add(last_group)\n",
        "            stacks.add(top_stacks[-1])\n",
        "            expressions.add(top_stacks.numbers[-1])\n",
        "\n",
        "            self.play(*it.chain(\n",
        "                list(map(MoveToTarget, all_movers)),\n",
        "                list(map(Write, plusses)),\n",
        "            ))\n",
        "\n",
        "            #Add\n",
        "            new_numbers = self.get_numbers(stacks)\n",
        "            self.play(ReplacementTransform(\n",
        "                expressions, VGroup(*list(map(VGroup, new_numbers)))\n",
        "            ))\n",
        "            self.wait(wait_time)\n",
        "            stacks.numbers = new_numbers\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_numbers(self, stacks):\n",
        "        return VGroup(*[\n",
        "            OldTex(str(len(stack))).next_to(stack, UP)\n",
        "            for stack in stacks\n",
        "        ])\n",
        "\n",
        "class IntroducePascalsTriangle(Scene):\n",
        "    CONFIG = {\n",
        "        \"max_n\" : 9,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.show_triangle()\n",
        "        self.show_sum_of_two_over_rule()\n",
        "        self.keep_in_mind_what_these_mean()\n",
        "        self.issolate_9_choose_4_term()\n",
        "        self.show_9_choose_4_pattern()\n",
        "        self.cap_off_triangle()\n",
        "\n",
        "    def show_triangle(self):\n",
        "        rows = PascalsTriangle(n_rows = self.max_n+1)\n",
        "        self.play(FadeIn(rows[1]))\n",
        "        for last_row, curr_row in zip(rows[1:], rows[2:]):\n",
        "            self.play(*[\n",
        "                Transform(\n",
        "                    last_row.copy(), VGroup(*mobs),\n",
        "                    remover = True\n",
        "                )\n",
        "                for mobs in (curr_row[1:], curr_row[:-1])\n",
        "            ])\n",
        "            self.add(curr_row)\n",
        "        self.wait()\n",
        "\n",
        "        self.rows = rows\n",
        "\n",
        "    def show_sum_of_two_over_rule(self):\n",
        "        rows = self.rows\n",
        "\n",
        "        example = rows[5][3]\n",
        "        ex_top1 = rows[4][2]\n",
        "        ex_top2 = rows[4][3]\n",
        "\n",
        "        rects = VGroup()\n",
        "        for mob, color in (example, GREEN), (ex_top1, BLUE), (ex_top2, YELLOW):\n",
        "            mob.rect = SurroundingRectangle(mob, color = color)\n",
        "            rects.add(mob.rect)\n",
        "\n",
        "        rows_to_fade = VGroup(*rows[1:4], *rows[6:])\n",
        "        rows_to_fade.save_state()\n",
        "\n",
        "        top_row = rows[4]\n",
        "        low_row = rows[5]\n",
        "        top_row_copy = top_row.copy()\n",
        "        top_row.save_state()\n",
        "        top_row.add(ex_top2.rect)\n",
        "        top_row_copy.add(ex_top1.rect)\n",
        "        h_line = Line(LEFT, RIGHT)\n",
        "        h_line.stretch_to_fit_width(low_row.get_width() + 2)\n",
        "        h_line.next_to(low_row, UP, 1.5*SMALL_BUFF)\n",
        "        plus = OldTex(\"+\")\n",
        "        plus.next_to(h_line.get_left(), UP+RIGHT, buff = 1.5*SMALL_BUFF)\n",
        "\n",
        "        self.play(ShowCreation(example.rect))\n",
        "        self.play(\n",
        "            ReplacementTransform(example.rect.copy(), ex_top1.rect),\n",
        "            ReplacementTransform(example.rect.copy(), ex_top2.rect),\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(rows_to_fade.fade, 1)\n",
        "        self.play(\n",
        "            top_row.align_to, low_row, LEFT,\n",
        "            top_row_copy.next_to, top_row, UP,\n",
        "            top_row_copy.align_to, low_row, RIGHT,\n",
        "        )\n",
        "        self.play(\n",
        "            ShowCreation(h_line),\n",
        "            Write(plus)\n",
        "        )\n",
        "        self.wait(2)\n",
        "        for row in top_row, top_row_copy:\n",
        "            row.remove(row[-1])\n",
        "        self.play(\n",
        "            rows_to_fade.restore,\n",
        "            top_row.restore,\n",
        "            Transform(\n",
        "                top_row_copy, top_row.saved_state,\n",
        "                remover = True\n",
        "            ),\n",
        "            FadeOut(VGroup(h_line, plus)),\n",
        "            FadeOut(rects),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def keep_in_mind_what_these_mean(self):\n",
        "        morty = Mortimer().flip()\n",
        "        morty.scale(0.7)\n",
        "        morty.to_edge(LEFT)\n",
        "        morty.shift(DOWN)\n",
        "\n",
        "        numbers = VGroup(*it.chain(*self.rows[1:]))\n",
        "        random.shuffle(numbers.submobjects)\n",
        "\n",
        "        self.play(FadeIn(morty))\n",
        "        self.play(PiCreatureSays(\n",
        "            morty, \"Keep in mind \\\\\\\\ what these mean.\",\n",
        "            bubble_config = {\n",
        "                \"width\" : 3.5,\n",
        "                \"height\" : 2.5,\n",
        "            }\n",
        "        ))\n",
        "        self.play(\n",
        "            Blink(morty),\n",
        "            LaggedStartMap(\n",
        "                Indicate, numbers,\n",
        "                rate_func = wiggle,\n",
        "                color = PINK,\n",
        "            )\n",
        "        )\n",
        "        self.play(*list(map(FadeOut, [\n",
        "            morty, morty.bubble, morty.bubble.content\n",
        "        ])))\n",
        "\n",
        "    def issolate_9_choose_4_term(self):\n",
        "        rows = self.rows\n",
        "\n",
        "        for n in range(1, self.max_n+1):\n",
        "            num = rows[n][0]\n",
        "            line = get_stack(Female(), Male(), n, 0)[0]\n",
        "            if n < self.max_n:\n",
        "                line.next_to(num, LEFT)\n",
        "            else:\n",
        "                line.next_to(num, DOWN, MED_LARGE_BUFF)\n",
        "            self.set_color_num(num)\n",
        "            self.add(line)\n",
        "            if n < self.max_n:\n",
        "                self.wait(0.25)\n",
        "            else:\n",
        "                self.wait(1.25)\n",
        "            self.dehighlight_num(num)\n",
        "            self.remove(line)\n",
        "        for k in range(1, 5):\n",
        "            num = rows[self.max_n][k]\n",
        "            line = get_stack(Female(), Male(), self.max_n, k)[0]\n",
        "            line.next_to(num, DOWN, MED_LARGE_BUFF)\n",
        "            self.set_color_num(num)\n",
        "            self.add(line)\n",
        "            self.wait(0.5)\n",
        "            self.dehighlight_num(num)\n",
        "            self.remove(line)\n",
        "        num.set_color(YELLOW)\n",
        "        num.scale(1.2)\n",
        "        self.add(line)\n",
        "        self.wait()\n",
        "\n",
        "        self.nine_choose_four_term = num\n",
        "        self.nine_choose_four_line = line\n",
        "\n",
        "    def show_9_choose_4_pattern(self):\n",
        "        rows = VGroup(*self.rows[1:])\n",
        "        all_stacks = get_stacks(Female(), Male(), 9)\n",
        "        stack = all_stacks[4]\n",
        "        all_lines = VGroup(*it.chain(*all_stacks))\n",
        "\n",
        "        self.play(\n",
        "            rows.shift, 3*UP,\n",
        "            self.nine_choose_four_line.shift, 2.5*UP,\n",
        "        )\n",
        "        self.remove(self.nine_choose_four_line)\n",
        "\n",
        "        for n, line in enumerate(stack):\n",
        "            line.next_to(self.nine_choose_four_term, DOWN, LARGE_BUFF)\n",
        "            num = Integer(n+1)\n",
        "            num.next_to(line, DOWN, MED_LARGE_BUFF)\n",
        "            self.add(line, num)\n",
        "            self.wait(0.1)\n",
        "            self.remove(line, num)\n",
        "        self.add(line, num)\n",
        "        self.wait()\n",
        "        self.curr_line = line\n",
        "\n",
        "        #Probability\n",
        "        expr = OldTex(\n",
        "            \"P(4\", \"\\\\female\", \"\\\\text{ out of }\", \"9\", \")\", \"=\"\n",
        "        )\n",
        "        expr.move_to(num.get_left())\n",
        "        expr.set_color_by_tex(\"female\", MAROON_B)\n",
        "        nine_choose_four_term = self.nine_choose_four_term.copy()\n",
        "        nine_choose_four_term.generate_target()\n",
        "        nine_choose_four_term.target.scale(1./1.2)\n",
        "        over_512 = OldTex(\"\\\\quad \\\\over 2^9\")\n",
        "        frac = VGroup(nine_choose_four_term.target, over_512)\n",
        "        frac.arrange(DOWN, buff = SMALL_BUFF)\n",
        "        frac.next_to(expr, RIGHT, SMALL_BUFF)\n",
        "        eq_result = OldTex(\"\\\\approx 0.246\")\n",
        "        eq_result.next_to(frac, RIGHT)\n",
        "\n",
        "        def show_random_lines(n, wait_time = 1):\n",
        "            for x in range(n):\n",
        "                if x == n-1:\n",
        "                    wait_time = 0\n",
        "                new_line = random.choice(all_lines)\n",
        "                new_line.move_to(self.curr_line)\n",
        "                self.remove(self.curr_line)\n",
        "                self.curr_line = new_line\n",
        "                self.add(self.curr_line)\n",
        "                self.wait(wait_time)\n",
        "\n",
        "        self.play(FadeOut(num), FadeIn(expr))\n",
        "        show_random_lines(4)\n",
        "        self.play(\n",
        "            MoveToTarget(nine_choose_four_term),\n",
        "            Write(over_512)\n",
        "        )\n",
        "        show_random_lines(4)\n",
        "        self.play(Write(eq_result))\n",
        "        show_random_lines(6)\n",
        "        self.play(\n",
        "            self.nine_choose_four_term.scale, 1./1.2,\n",
        "            self.nine_choose_four_term.set_color, WHITE,\n",
        "            *list(map(FadeOut, [\n",
        "                expr, nine_choose_four_term,\n",
        "                over_512, eq_result, self.curr_line\n",
        "            ]))\n",
        "        )\n",
        "        self.play(rows.shift, 3*DOWN)\n",
        "\n",
        "    def cap_off_triangle(self):\n",
        "        top_row = self.rows[0]\n",
        "        circle = Circle(color = YELLOW)\n",
        "        circle.replace(top_row, dim_to_match = 1)\n",
        "        circle.scale(1.5)\n",
        "\n",
        "        line_groups = VGroup()\n",
        "        for n in range(4, -1, -1):\n",
        "            line = VGroup(*[\n",
        "                random.choice([Male, Female])()\n",
        "                for k in range(n)\n",
        "            ])\n",
        "            if n == 0:\n",
        "                line.add(Line(LEFT, RIGHT).scale(0.1).set_stroke(BLACK, 0))\n",
        "            line.arrange(RIGHT, SMALL_BUFF)\n",
        "            line.shift(FRAME_X_RADIUS*RIGHT/2 + FRAME_Y_RADIUS*UP/2)\n",
        "            brace = Brace(line, UP)\n",
        "            if n == 1:\n",
        "                label = \"1 Person\"\n",
        "            else:\n",
        "                label = \"%d People\"%n\n",
        "            brace_text = brace.get_text(label)\n",
        "            line_group = VGroup(line, brace, brace_text)\n",
        "            line_groups.add(line_group)\n",
        "\n",
        "        self.play(ShowCreation(circle))\n",
        "        self.play(Write(top_row))\n",
        "        self.wait()\n",
        "        curr_line_group = line_groups[0]\n",
        "        self.play(FadeIn(curr_line_group))\n",
        "        for line_group in line_groups[1:]:\n",
        "            self.play(ReplacementTransform(\n",
        "                curr_line_group, line_group\n",
        "            ))\n",
        "            curr_line_group = line_group\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def set_color_num(self, num):\n",
        "        num.set_color(YELLOW)\n",
        "        num.scale(1.2)\n",
        "\n",
        "    def dehighlight_num(self, num):\n",
        "        num.set_color(WHITE)\n",
        "        num.scale(1.0/1.2)\n",
        "\n",
        "class StacksApproachBellCurve(Scene):\n",
        "    CONFIG = {\n",
        "        \"n_iterations\" : 30,\n",
        "    }\n",
        "    def construct(self):\n",
        "        bar = Square(side_length = 1)\n",
        "        bar.set_fill(BLUE)\n",
        "        bar.set_stroke(width = 0)\n",
        "        bars = VGroup(bar)\n",
        "\n",
        "        numbers = VGroup(Integer(1))\n",
        "        numbers.next_to(bars, UP, SMALL_BUFF)\n",
        "\n",
        "        max_width = FRAME_WIDTH - 2\n",
        "        max_height = FRAME_Y_RADIUS - 1.5\n",
        "\n",
        "        for x in range(self.n_iterations):\n",
        "            if x == 0:\n",
        "                distance = 1.5\n",
        "            else:\n",
        "                distance = bars[1].get_center()[0] - bars[0].get_center()[0]\n",
        "\n",
        "            bars_copy = bars.copy()\n",
        "\n",
        "            #Copy and shift\n",
        "            for mob, vect in (bars, DOWN), (bars_copy, UP):\n",
        "                mob.generate_target()\n",
        "                if mob.target.get_height() > max_height:\n",
        "                    mob.target.stretch_to_fit_height(max_height)\n",
        "                if mob.target.get_width() > max_width:\n",
        "                    mob.target.stretch_to_fit_width(max_width)\n",
        "                mob.target.next_to(ORIGIN, vect, MED_LARGE_BUFF)\n",
        "            colors = color_gradient([BLUE, YELLOW], len(bars)+1)\n",
        "            for color, bar in zip(colors, bars.target):\n",
        "                bar.set_fill(color)\n",
        "            for color, bar in zip(colors[1:], bars_copy.target):\n",
        "                bar.set_fill(color)\n",
        "            bars_copy.set_fill(opacity = 0)\n",
        "\n",
        "            numbers_copy = numbers.copy()\n",
        "            for bs, ns in (bars, numbers), (bars_copy, numbers_copy):\n",
        "                ns.generate_target()\n",
        "                for bar, number in zip(bs.target, ns.target):\n",
        "                    # if number.get_width() > bar.get_width():\n",
        "                    #     number.set_width(bar.get_width())\n",
        "                    number.next_to(bar, UP, SMALL_BUFF)\n",
        "\n",
        "            self.play(*list(map(MoveToTarget, [\n",
        "                bars, bars_copy,\n",
        "                numbers, numbers_copy\n",
        "            ])))\n",
        "            self.play(\n",
        "                bars.shift, distance*LEFT/2,\n",
        "                numbers.shift, distance*LEFT/2,\n",
        "                bars_copy.shift, distance*RIGHT/2,\n",
        "                numbers_copy.shift, distance*RIGHT/2,\n",
        "            )\n",
        "\n",
        "            #Stack\n",
        "            bars_copy.generate_target()\n",
        "            numbers.generate_target()\n",
        "            numbers_copy.generate_target()\n",
        "            new_numbers = VGroup()\n",
        "            min_scale_val = 1\n",
        "            for i in range(len(bars)-1):\n",
        "                top_bar = bars_copy.target[i]\n",
        "                low_bar = bars[i+1]\n",
        "                top_num = numbers_copy.target[i]\n",
        "                low_num = numbers.target[i+1]\n",
        "                new_num = Integer(top_num.number + low_num.number)\n",
        "                if new_num.get_width() > top_bar.get_width():\n",
        "                    min_scale_val = min(\n",
        "                        min_scale_val, \n",
        "                        top_bar.get_width() / new_num.get_width()\n",
        "                    )\n",
        "                new_numbers.add(new_num)\n",
        "\n",
        "                top_bar.move_to(low_bar.get_top(), DOWN)\n",
        "                new_num.next_to(top_bar, UP, SMALL_BUFF)\n",
        "                Transform(low_num, new_num).update(1)\n",
        "                Transform(top_num, new_num).update(1)\n",
        "            for group in new_numbers, numbers.target[1:], numbers_copy.target[:-1]:\n",
        "                for num in group:\n",
        "                    num.scale(min_scale_val, about_point = num.get_bottom())\n",
        "            if x > 1:\n",
        "                height = numbers.target[1].get_height()\n",
        "                for mob in numbers.target[0], numbers_copy.target[-1]:\n",
        "                    mob.set_height(height)\n",
        "\n",
        "            bars_copy.target[-1].align_to(bars, DOWN)\n",
        "            numbers_copy.target[-1].next_to(bars_copy.target[-1], UP, SMALL_BUFF)\n",
        "\n",
        "            self.play(*[\n",
        "                MoveToTarget(mob, lag_ratio = 0.5)\n",
        "                for mob in (bars_copy, numbers, numbers_copy)\n",
        "            ])\n",
        "            self.remove(numbers, numbers_copy)\n",
        "            numbers = VGroup(numbers[0])\n",
        "            numbers.add(*new_numbers)\n",
        "            numbers.add(numbers_copy[-1])\n",
        "\n",
        "            #Resize lower bars\n",
        "            for top_bar, low_bar in zip(bars_copy[:-1], bars[1:]):\n",
        "                bottom = low_bar.get_bottom()\n",
        "                low_bar.replace(\n",
        "                    VGroup(low_bar, top_bar),\n",
        "                    stretch = True\n",
        "                )\n",
        "                low_bar.move_to(bottom, DOWN)\n",
        "            bars.add(bars_copy[-1])\n",
        "            self.remove(bars_copy)\n",
        "            self.add(bars)\n",
        "\n",
        "        self.add(numbers)\n",
        "        self.wait()\n",
        "\n",
        "# class IsThereABetterWayToCompute(TeacherStudentsScene):\n",
        "#     def construct(self):\n",
        "#         self.student_says(\n",
        "#             \"Is there a better \\\\\\\\ way to compute these?\",\n",
        "#             target_mode = \"raise_left_hand\",\n",
        "#         )\n",
        "#         self.play_student_changes(\"confused\", \"raise_left_hand\", \"erm\")\n",
        "#         self.wait()\n",
        "#         self.play(self.teacher.change_mode, \"happy\")\n",
        "#         self.wait()\n",
        "#         self.teacher_says(\n",
        "#             \"There is!  But first...\",\n",
        "#             target_mode = \"hooray\"\n",
        "#         )\n",
        "#         self.wait(2)\n",
        "\n",
        "class ChooseThreeFromFive(InitialFiveChooseThreeExample, PiCreatureScene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 5,\n",
        "        \"k\" : 3,\n",
        "        \"pi_creature_scale_val\" : 0.3,\n",
        "        \"people_colors\" : [\n",
        "             PURPLE, BLUE, GREEN, GOLD_E, GREY,\n",
        "        ],\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.remove(self.people)\n",
        "        self.show_binary_strings()\n",
        "        self.add_people()\n",
        "        self.choose_triplets()\n",
        "        self.show_association_with_binary(3)\n",
        "        self.show_association_with_binary(5)\n",
        "        self.order_doesnt_matter()\n",
        "        self.that_phrase_is_confusing()\n",
        "        self.pattern_is_unambiguous()\n",
        "\n",
        "    def show_binary_strings(self):\n",
        "        n, k = self.n, self.k\n",
        "        stack = get_stack(\n",
        "            self.get_obj1(), self.get_obj2(), n, k,\n",
        "            vertical_buff = SMALL_BUFF,\n",
        "        )\n",
        "        stack.to_edge(DOWN, buff = LARGE_BUFF)\n",
        "        equation = OldTex(\n",
        "            \"{%d \\\\choose %d}\"%(n, k),\n",
        "            \"=\", str(choose(n, k)),\n",
        "        )\n",
        "        equation[0].scale(0.75, about_point = equation[0].get_right())\n",
        "        equation.next_to(stack, UP)\n",
        "\n",
        "        for i, line in enumerate(stack):\n",
        "            num = OldTex(str(i+1))\n",
        "            num.next_to(stack, UP)\n",
        "            self.add(line, num)\n",
        "            self.wait(0.25)\n",
        "            self.remove(num)\n",
        "        self.play(\n",
        "            Write(VGroup(*equation[:-1])),\n",
        "            ReplacementTransform(num, equation[-1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(stack, equation)\n",
        "\n",
        "    def add_people(self):\n",
        "        people = self.people\n",
        "\n",
        "        names = self.get_names(people)\n",
        "        braces = self.get_people_braces(people)\n",
        "\n",
        "        self.play(\n",
        "            Write(braces),\n",
        "            LaggedStartMap(FadeIn, people),\n",
        "            VGroup(self.stack, self.equation).to_edge, RIGHT, LARGE_BUFF\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, names))\n",
        "\n",
        "        self.set_variables_as_attrs(names, braces)\n",
        "\n",
        "    def choose_triplets(self):\n",
        "        movers = VGroup()\n",
        "        movers.generate_target()\n",
        "        max_name_width = max([n.get_width() for n in self.names])\n",
        "        for name_triplet in it.combinations(self.names, 3):\n",
        "            mover = VGroup(*name_triplet).copy()\n",
        "            mover.generate_target()\n",
        "            if hasattr(self, \"stack\"):\n",
        "                mover.target.set_height(self.stack[0].get_height())\n",
        "            for name in mover.target[:2]:\n",
        "                name[-1].set_fill(opacity = 1)\n",
        "            mover.target.arrange(RIGHT, MED_SMALL_BUFF)\n",
        "            movers.add(mover)\n",
        "            movers.target.add(mover.target)\n",
        "        movers.target.arrange(\n",
        "            DOWN, buff = SMALL_BUFF,\n",
        "            aligned_edge = LEFT,\n",
        "        )\n",
        "        movers.target.next_to(self.people, DOWN, MED_LARGE_BUFF)\n",
        "        if hasattr(self, \"stack\"):\n",
        "            movers.target.align_to(self.stack, UP)\n",
        "\n",
        "        self.play(LaggedStartMap(\n",
        "            MoveToTarget, movers,\n",
        "            lag_ratio = 0.2,\n",
        "            run_time = 4,\n",
        "        ))\n",
        "        self.wait()\n",
        "\n",
        "        self.name_triplets = movers\n",
        "        \n",
        "    def show_association_with_binary(self, index):\n",
        "        people = self.people\n",
        "        names = self.names\n",
        "        for mob in people, names:\n",
        "            mob.save_state()\n",
        "            mob.generate_target()\n",
        "\n",
        "        line = self.stack[index].copy()\n",
        "        triplet = self.name_triplets[index]\n",
        "        triplet.save_state()\n",
        "        line.generate_target()\n",
        "        for bit, name in zip(line.target, self.names):\n",
        "            bit.next_to(name, UP)\n",
        "\n",
        "        line_rect = SurroundingRectangle(line)\n",
        "        full_line_rect = SurroundingRectangle(VGroup(line, triplet))\n",
        "        people_rects = VGroup()\n",
        "        for pi, name, obj in zip(people.target, names.target, line):\n",
        "            if \"1\" in obj.get_tex():\n",
        "                rect = SurroundingRectangle(VGroup(pi, name))\n",
        "                people_rects.add(rect)\n",
        "                pi.change_mode(\"hooray\")\n",
        "            else:\n",
        "                pi.fade(0.5)\n",
        "                name.fade(0.5)\n",
        "\n",
        "        self.play(ShowCreation(line_rect))\n",
        "        self.play(MoveToTarget(line))\n",
        "        self.play(\n",
        "            LaggedStartMap(ShowCreation, people_rects),\n",
        "            MoveToTarget(people),\n",
        "            MoveToTarget(names),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ReplacementTransform(line_rect, full_line_rect),\n",
        "            triplet.set_color, YELLOW\n",
        "        )\n",
        "        self.wait(2)\n",
        "        self.play(\n",
        "            people.restore,\n",
        "            names.restore,\n",
        "            triplet.restore,\n",
        "            FadeOut(line),\n",
        "            FadeOut(full_line_rect),\n",
        "            FadeOut(people_rects),\n",
        "        )\n",
        "\n",
        "    def order_doesnt_matter(self):\n",
        "        triplet = self.name_triplets[0].copy()\n",
        "        triplet.set_fill(opacity = 1)\n",
        "        triplet.next_to(\n",
        "            self.name_triplets, RIGHT,\n",
        "            buff = LARGE_BUFF,\n",
        "            aligned_edge = UP,\n",
        "        )\n",
        "        updownarrow = OldTex(\"\\\\Updownarrow\")\n",
        "        updownarrow.set_color(YELLOW)\n",
        "        updownarrow.next_to(triplet, DOWN, SMALL_BUFF)\n",
        "        permutations = VGroup()\n",
        "        for indices in it.permutations(list(range(len(triplet)))):\n",
        "            perm = triplet.copy()\n",
        "            resorter = VGroup(*[\n",
        "                perm[i] for i in indices\n",
        "            ])\n",
        "            resorter.arrange(RIGHT, MED_SMALL_BUFF)\n",
        "            resorter.next_to(updownarrow, DOWN)\n",
        "            permutations.add(perm)\n",
        "\n",
        "        words = OldTexText(\"``Order doesn't matter''\")\n",
        "        words.scale(0.75)\n",
        "        words.set_color(BLUE)\n",
        "        words.next_to(permutations, DOWN)\n",
        "\n",
        "        self.play(ReplacementTransform(\n",
        "            self.name_triplets[0].copy(), triplet\n",
        "        ))\n",
        "        curr_perm = permutations[0]\n",
        "        self.play(\n",
        "            ReplacementTransform(triplet.copy(), curr_perm),\n",
        "            Write(updownarrow)\n",
        "        )\n",
        "        for i in range(8):\n",
        "            new_perm = permutations[i%(len(permutations)-1)+1]\n",
        "            anims = [\n",
        "                Transform(\n",
        "                    curr_perm, new_perm,\n",
        "                    path_arc = np.pi,\n",
        "                )\n",
        "            ]\n",
        "            if i == 1:\n",
        "                self.wait()\n",
        "            if i == 4:\n",
        "                anims.append(Write(words, run_time = 1))\n",
        "            self.play(*anims)\n",
        "        self.play(*list(map(FadeOut, [triplet, curr_perm, updownarrow])))\n",
        "\n",
        "        self.order_doesnt_matter_words = words\n",
        "\n",
        "    def that_phrase_is_confusing(self):\n",
        "        odm_words = self.order_doesnt_matter_words\n",
        "        odm_words_outline = VGroup()\n",
        "        for letter in odm_words:\n",
        "            mob = VMobject()\n",
        "            mob.set_points(letter.get_points())\n",
        "            odm_words_outline.add(mob)\n",
        "        odm_words_outline.set_fill(opacity = 0)\n",
        "        odm_words_outline.set_stroke(YELLOW, 1)\n",
        "\n",
        "        line = self.stack[0].copy()\n",
        "\n",
        "        q_marks = OldTexText(\"???\")\n",
        "        q_marks.next_to(odm_words, DOWN)\n",
        "        q_marks.set_color(YELLOW)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                ShowCreationThenDestruction, odm_words_outline,\n",
        "                lag_ratio = 0.2,\n",
        "                run_time = 1,\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, self.people,\n",
        "                lambda pi : (pi.change, \"confused\", odm_words,)\n",
        "            ),\n",
        "            LaggedStartMap(FadeIn, q_marks),\n",
        "        )\n",
        "        self.play(line.next_to, odm_words, UP)\n",
        "        for x in range(6):\n",
        "            line.generate_target()\n",
        "            resorter = VGroup(*line.target)\n",
        "            resorter.sort(lambda p : random.random())\n",
        "            resorter.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "            resorter.move_to(line)\n",
        "            self.play(MoveToTarget(line, path_arc = np.pi))\n",
        "        self.play(FadeOut(q_marks))\n",
        "\n",
        "        line.sort(lambda p : p[0])\n",
        "        words = VGroup(*list(map(TexText, [\"First\", \"Second\", \"Fifth\"])))\n",
        "        words.set_color(YELLOW)\n",
        "        words.scale(0.75)\n",
        "        word_arrow_groups = VGroup()\n",
        "        for i, word in zip([0, 1, 4], words):\n",
        "            arrow = Vector(0.5*DOWN)\n",
        "            arrow.set_color(YELLOW)\n",
        "            arrow.next_to(line[i], UP, SMALL_BUFF)\n",
        "            word.next_to(arrow, UP, SMALL_BUFF)\n",
        "            word_arrow_groups.add(VGroup(word, arrow))\n",
        "\n",
        "        for x in range(2):\n",
        "            for i in range(len(word_arrow_groups)+1):\n",
        "                anims = []\n",
        "                if i > 0:\n",
        "                    anims.append(FadeOut(word_arrow_groups[i-1]))\n",
        "                if i < len(word_arrow_groups):\n",
        "                    anims.append(FadeIn(word_arrow_groups[i]))\n",
        "                self.play(*anims)\n",
        "            self.wait()\n",
        "            word_arrow_groups.submobjects = [\n",
        "                word_arrow_groups[j]\n",
        "                for j in (1, 2, 0)\n",
        "            ]\n",
        "        self.play(*list(map(FadeOut, [line, odm_words])))\n",
        "\n",
        "    def pattern_is_unambiguous(self):\n",
        "        all_ones = VGroup()\n",
        "        for line in self.stack:\n",
        "            ones = VGroup(*[m for m in line if \"1\" in m.get_tex()]).copy()\n",
        "            ones.set_color(YELLOW)\n",
        "            all_ones.add(ones)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(\n",
        "                FadeIn, all_ones,\n",
        "                lag_ratio = 0.2,\n",
        "                run_time = 3,\n",
        "                rate_func = there_and_back\n",
        "            ),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, self.people,\n",
        "                lambda pi : (pi.change, \"happy\", ones),\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        for trip in it.combinations(self.people, 3):\n",
        "            rects = VGroup(*list(map(SurroundingRectangle, trip)))\n",
        "            self.add(rects)\n",
        "            self.wait(0.3)\n",
        "            self.remove(rects)\n",
        "        self.wait()\n",
        "\n",
        "    ###\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        people = VGroup(*[\n",
        "            PiCreature(color = color).scale(self.pi_creature_scale_val)\n",
        "            for color in self.people_colors\n",
        "        ])\n",
        "        people.arrange(RIGHT)\n",
        "        people.shift(3*LEFT)\n",
        "        people.to_edge(UP, buff = 1.25)\n",
        "        self.people = people\n",
        "        return people\n",
        "\n",
        "    def get_names(self, people):\n",
        "        names = VGroup(*[\n",
        "            OldTexText(name + \",\")\n",
        "            for name in (\"Ali\", \"Ben\", \"Cam\", \"Denis\", \"Evan\")\n",
        "        ])\n",
        "        for name, pi in zip(names, people):\n",
        "            name[-1].set_fill(opacity = 0)\n",
        "            name.scale(0.75)\n",
        "            name.next_to(pi, UP, 2*SMALL_BUFF)\n",
        "            pi.name = name\n",
        "        return names\n",
        "\n",
        "    def get_people_braces(self, people):\n",
        "        group = VGroup(people, *[pi.name for pi in people])\n",
        "        lb, rb = braces = OldTex(\"\\\\{ \\\\}\")\n",
        "        braces.scale(2)\n",
        "        braces.stretch_to_fit_height(1.3*group.get_height())\n",
        "        lb.next_to(group, LEFT, SMALL_BUFF)\n",
        "        rb.next_to(group, RIGHT, SMALL_BUFF)\n",
        "        return braces\n",
        "\n",
        "class SubsetProbabilityExample(ChooseThreeFromFive):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 1,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_people()\n",
        "        self.ask_question()\n",
        "        self.show_all_triplets()\n",
        "        self.circle_those_with_ali()\n",
        "\n",
        "    def setup_people(self):\n",
        "        people = self.people\n",
        "        names = self.get_names(people)\n",
        "        braces = self.get_people_braces(people)\n",
        "        group = VGroup(people, names, braces)\n",
        "\n",
        "        self.play(group.shift, -group.get_center()[0]*RIGHT)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(names, braces)\n",
        "\n",
        "    def ask_question(self):\n",
        "        pi_name_groups = VGroup(*[\n",
        "            VGroup(pi, pi.name)\n",
        "            for pi in self.people\n",
        "        ])\n",
        "\n",
        "        words = OldTexText(\n",
        "            \"Choose 3 people randomly.\\\\\\\\\",\n",
        "            \"Probability\", \"Ali\", \"is one of them?\"\n",
        "        )\n",
        "        words.set_color_by_tex(\"Ali\", self.people[0].get_color())\n",
        "        words.next_to(pi_name_groups, DOWN, 2*LARGE_BUFF)\n",
        "\n",
        "        checkmark = OldTex(\"\\\\checkmark\").set_color(GREEN)\n",
        "        cross = OldTex(\"\\\\times\").set_color(RED)\n",
        "        for mob in checkmark, cross:\n",
        "            mob.scale(2)\n",
        "            mob.next_to(self.braces, DOWN, aligned_edge = LEFT)\n",
        "            mob.shift(MED_SMALL_BUFF*LEFT)\n",
        "\n",
        "        ali = pi_name_groups[0]\n",
        "\n",
        "        self.play(FadeIn(words))\n",
        "        for x in range(4):\n",
        "            group = VGroup(*random.sample(pi_name_groups, 3))\n",
        "            group.save_state()\n",
        "            group.generate_target()\n",
        "            group.target.shift(LARGE_BUFF*DOWN)\n",
        "            for pi, name in group.target:\n",
        "                pi.change(\"hooray\", checkmark)\n",
        "            if ali in group:\n",
        "                symbol = checkmark\n",
        "                rect = SurroundingRectangle(\n",
        "                    group.target[group.submobjects.index(ali)]\n",
        "                )\n",
        "                rect.set_stroke(GREEN)\n",
        "            else:\n",
        "                symbol = cross\n",
        "                rect = VGroup()\n",
        "\n",
        "            run_time = 1\n",
        "            self.play(\n",
        "                MoveToTarget(group),\n",
        "                FadeIn(symbol),\n",
        "                ShowCreation(rect),\n",
        "                run_time = run_time,\n",
        "            )\n",
        "            self.wait(0.5)\n",
        "            self.play(\n",
        "                group.restore,\n",
        "                FadeOut(symbol),\n",
        "                FadeOut(rect),\n",
        "                run_time = run_time,\n",
        "            )\n",
        "\n",
        "        self.question = words\n",
        "        self.set_variables_as_attrs(pi_name_groups)\n",
        "\n",
        "    def show_all_triplets(self):\n",
        "        self.play(\n",
        "            self.question.scale, 0.75,\n",
        "            self.question.to_corner, UP+RIGHT,\n",
        "            VGroup(self.people, self.names, self.braces).to_edge, LEFT,\n",
        "        )\n",
        "        self.choose_triplets()\n",
        "\n",
        "        brace = Brace(self.name_triplets, RIGHT)\n",
        "        total_count = brace.get_tex(\n",
        "            \"{5 \\\\choose 3}\", \"=\", \"10\",\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        total_count.set_color(BLUE)\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(total_count),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(brace, total_count)\n",
        "\n",
        "    def circle_those_with_ali(self):\n",
        "        name_triplets = self.name_triplets\n",
        "        five_choose_three, equals, ten = self.total_count\n",
        "        names = self.names\n",
        "\n",
        "        with_ali = VGroup(*name_triplets[:6])\n",
        "        alis = VGroup(*[group[0] for group in with_ali])\n",
        "        rect = SurroundingRectangle(with_ali)\n",
        "\n",
        "        frac_lines = VGroup()\n",
        "        for vect in LEFT, RIGHT:\n",
        "            frac_line = OldTex(\"\\\\quad \\\\over \\\\quad\")\n",
        "            if vect is LEFT:\n",
        "                frac_line.stretch(1.5, 0)\n",
        "            frac_line.next_to(equals, vect)\n",
        "            frac_lines.add(frac_line)\n",
        "        four_choose_two = OldTex(\"4 \\\\choose 2\")\n",
        "        four_choose_two.next_to(frac_lines[0], UP, SMALL_BUFF)\n",
        "        six = OldTex(\"6\")\n",
        "        six.next_to(frac_lines[1], UP, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(rect),\n",
        "            alis.set_color, YELLOW\n",
        "        )\n",
        "        for pair in it.combinations(names[1:], 2):\n",
        "            arrows = VGroup()\n",
        "            for pi in pair:\n",
        "                arrow = Vector(0.5*DOWN, color = YELLOW)\n",
        "                arrow.next_to(pi, UP)\n",
        "                arrows.add(arrow)\n",
        "            self.add(arrows)\n",
        "            self.wait(0.5)\n",
        "            self.remove(arrows)\n",
        "        self.add(arrows)\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(frac_lines),\n",
        "            five_choose_three.next_to, frac_lines[0], DOWN, SMALL_BUFF,\n",
        "            ten.next_to, frac_lines[1], DOWN, SMALL_BUFF,\n",
        "            Write(four_choose_two)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(ReplacementTransform(\n",
        "            four_choose_two.copy(), six\n",
        "        ))\n",
        "        self.play(FadeOut(arrows))\n",
        "\n",
        "        for x in range(20):\n",
        "            name_rect = SurroundingRectangle(random.choice(name_triplets))\n",
        "            name_rect.set_color(BLUE)\n",
        "            name_rect.set_fill(BLUE, opacity = 0.25)\n",
        "            self.play(Animation(name_rect, run_time = 0))\n",
        "            self.wait(0.25)\n",
        "            self.remove(name_rect)\n",
        "\n",
        "class StudentsGetConfused(PiCreatureScene):\n",
        "    def construct(self):\n",
        "        pi1, pi2 = self.pi_creatures\n",
        "        line = VGroup(\n",
        "            Male(), Female(), Female(), Male(), Female()\n",
        "        )\n",
        "        width = line.get_width()\n",
        "        for i, mob in enumerate(line):\n",
        "            mob.shift((i*width+SMALL_BUFF)*RIGHT)\n",
        "        line.scale(1.5)\n",
        "        line.arrange(RIGHT, SMALL_BUFF)\n",
        "        line.move_to(self.pi_creatures, UP)\n",
        "\n",
        "        self.add(line)\n",
        "        self.play(\n",
        "            self.get_shuffle_anim(line),\n",
        "            PiCreatureSays(\n",
        "                pi1, \"Wait \\\\dots order matters now?\",\n",
        "                target_mode = \"confused\",\n",
        "                look_at = line\n",
        "            )\n",
        "        )\n",
        "        self.play(\n",
        "            self.get_shuffle_anim(line),\n",
        "            *[\n",
        "                ApplyMethod(pi.change, \"confused\", line)\n",
        "                for pi in self.pi_creatures\n",
        "            ]\n",
        "        )\n",
        "        for x in range(4):\n",
        "            self.play(self.get_shuffle_anim(line))\n",
        "        self.wait()\n",
        "\n",
        "    def create_pi_creatures(self):\n",
        "        pis = VGroup(*[\n",
        "            Randolph(color = color)\n",
        "            for color in (BLUE_D, BLUE_B)\n",
        "        ])\n",
        "        pis[1].flip()\n",
        "        pis.arrange(RIGHT, buff = 5)\n",
        "        pis.to_edge(DOWN)\n",
        "        return pis\n",
        "\n",
        "    def get_shuffle_anim(self, line):\n",
        "        indices = list(range(len(line)))\n",
        "        random.shuffle(indices)\n",
        "        line.generate_target()\n",
        "        for i, m in zip(indices, line.target):\n",
        "            m.move_to(line[i])\n",
        "        return MoveToTarget(line, path_arc = np.pi)\n",
        "\n",
        "class HowToComputeNChooseK(ChooseThreeFromFive):\n",
        "    CONFIG = {\n",
        "        \"n\" : 5,\n",
        "        \"k\" : 3,\n",
        "        \"line_colors\" : [GREEN, YELLOW],\n",
        "        \"n_permutaitons_to_show\" : 5,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.force_skipping()\n",
        "\n",
        "        self.setup_people()\n",
        "        self.choose_example_ordered_triplets()\n",
        "        self.count_possibilities()\n",
        "        self.show_permutations_of_ABC()\n",
        "        self.count_permutations_of_ABC()\n",
        "        self.reset_stage()\n",
        "        self.show_whats_being_counted()\n",
        "\n",
        "        self.revert_to_original_skipping_status()\n",
        "        self.indicate_final_answer()\n",
        "\n",
        "    def setup_people(self):\n",
        "        people = self.people\n",
        "        names = self.get_names(people)\n",
        "        braces = self.get_people_braces(people)\n",
        "        people_group = VGroup(people, names, braces)\n",
        "        people_group.center().to_edge(UP, buff = MED_LARGE_BUFF)\n",
        "\n",
        "        self.add(people_group)\n",
        "        self.set_variables_as_attrs(\n",
        "            names, people_group,\n",
        "            people_braces = braces\n",
        "        )\n",
        "\n",
        "    def choose_example_ordered_triplets(self):\n",
        "        n, k = self.n, self.k\n",
        "        names = self.names\n",
        "\n",
        "        lines, place_words = self.get_lines_and_place_words()\n",
        "\n",
        "        for x in range(3):\n",
        "            chosen_names = VGroup(*random.sample(names, k))\n",
        "            chosen_names.save_state()\n",
        "            for name, line, word in zip(chosen_names, lines, place_words):\n",
        "                name.generate_target()\n",
        "                name.target.next_to(line, UP, SMALL_BUFF)\n",
        "                anims = [MoveToTarget(name)]\n",
        "                if x == 0:\n",
        "                    anims += [ShowCreation(line), FadeIn(word)]\n",
        "                self.play(*anims)\n",
        "            self.wait()\n",
        "            self.play(chosen_names.restore)\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(lines, place_words)\n",
        "\n",
        "    def count_possibilities(self):\n",
        "        n, k = self.n, self.k\n",
        "        lines = self.lines\n",
        "\n",
        "        choice_counts = self.get_choice_counts(n, k)\n",
        "        arrows = self.get_choice_count_arrows(choice_counts)\n",
        "\n",
        "        name_rects = VGroup()\n",
        "        for name in self.names:\n",
        "            name.rect = SurroundingRectangle(name)\n",
        "            name_rects.add(name.rect)\n",
        "\n",
        "        chosen_names = VGroup(*random.sample(self.names, k))\n",
        "        self.names.save_state()\n",
        "\n",
        "        for name, line, count, arrow in zip(chosen_names, lines, choice_counts, arrows):\n",
        "            self.play(\n",
        "                FadeIn(count),\n",
        "                LaggedStartMap(\n",
        "                    FadeIn, name_rects,\n",
        "                    rate_func = there_and_back,\n",
        "                    remover = True,\n",
        "                )\n",
        "            )\n",
        "            self.play(\n",
        "                name.next_to, line, UP, SMALL_BUFF,\n",
        "                GrowArrow(arrow)\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "            name_rects.remove(name.rect)\n",
        "            name_rects.set_stroke(YELLOW, 3)\n",
        "\n",
        "        #Consolidate choice counts\n",
        "        choice_numbers = VGroup(*[\n",
        "            cc.submobjects.pop(1) \n",
        "            for cc in choice_counts\n",
        "        ])\n",
        "        choice_numbers.generate_target()\n",
        "        dots = VGroup(*[Tex(\"\\\\cdot\") for x in range(k-1)])\n",
        "        product = VGroup(*it.chain(*list(zip(choice_numbers.target, dots))))\n",
        "        product.add(choice_numbers.target[-1])\n",
        "        product.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        chosen_names_brace = Brace(chosen_names, UP)\n",
        "        product.next_to(chosen_names_brace, UP)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(choice_counts),\n",
        "            FadeOut(arrows),\n",
        "            MoveToTarget(choice_numbers),\n",
        "            Write(dots),\n",
        "            GrowFromCenter(chosen_names_brace),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            chosen_names, chosen_names_brace, choice_numbers,\n",
        "            choice_numbers_dots = dots,\n",
        "        )\n",
        "\n",
        "    def show_permutations_of_ABC(self):\n",
        "        chosen_names = self.chosen_names\n",
        "        lines = self.lines\n",
        "\n",
        "        n_perms = self.n_permutaitons_to_show + 1\n",
        "        for indices in list(it.permutations(list(range(3))))[1:n_perms]:\n",
        "            self.play(*[\n",
        "                ApplyMethod(\n",
        "                    name.next_to, lines[i], UP, SMALL_BUFF,\n",
        "                    path_arc = np.pi\n",
        "                )\n",
        "                for i, name in zip(indices, chosen_names)\n",
        "            ])\n",
        "            self.wait(0.5)\n",
        "\n",
        "    def count_permutations_of_ABC(self):\n",
        "        n, k = self.n, self.k\n",
        "        lines = self.lines\n",
        "\n",
        "        chosen_names = self.chosen_names\n",
        "        brace = self.chosen_names_brace\n",
        "        numerator = VGroup(\n",
        "            self.choice_numbers, self.choice_numbers_dots,\n",
        "        )\n",
        "        frac_line = Line(LEFT, RIGHT)\n",
        "        frac_line.replace(numerator, dim_to_match = 0)\n",
        "        frac_line.to_edge(RIGHT)\n",
        "\n",
        "        choice_counts = self.get_choice_counts(k, k)\n",
        "        arrows = self.get_choice_count_arrows(choice_counts)\n",
        "\n",
        "        self.play(\n",
        "            chosen_names.shift, UP,\n",
        "            chosen_names.to_edge, LEFT,\n",
        "            numerator.next_to, frac_line, UP, SMALL_BUFF,\n",
        "            FadeOut(brace),\n",
        "        )\n",
        "        shuffled_names = random.sample(chosen_names, k)\n",
        "        for line, name, count, arrow in zip(lines, shuffled_names, choice_counts, arrows):\n",
        "            self.play(FadeIn(count), GrowArrow(arrow))\n",
        "            self.play(\n",
        "                name.next_to, line, UP, SMALL_BUFF,\n",
        "                path_arc = -np.pi/3,\n",
        "            )\n",
        "            self.wait()\n",
        "\n",
        "        #Consolidate choice counts\n",
        "        choice_numbers = VGroup(*[\n",
        "            cc.submobjects.pop(1) \n",
        "            for cc in choice_counts\n",
        "        ])\n",
        "        choice_numbers.generate_target()\n",
        "        dots = VGroup(*[Tex(\"\\\\cdot\") for x in range(k-1)])\n",
        "        product = VGroup(*it.chain(*list(zip(choice_numbers.target, dots))))\n",
        "        product.add(choice_numbers.target[-1])\n",
        "        product.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        product.next_to(frac_line, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            FadeOut(choice_counts),\n",
        "            FadeOut(arrows),\n",
        "            MoveToTarget(choice_numbers),\n",
        "            Write(dots),\n",
        "            ShowCreation(frac_line),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.fraction = VGroup(\n",
        "            numerator, frac_line, VGroup(choice_numbers, dots)\n",
        "        )\n",
        "\n",
        "    def reset_stage(self):\n",
        "        n, k = self.n, self.k\n",
        "        n_choose_k_equals = OldTex(\n",
        "            \"{%d \\\\choose %d} =\"%(n, k)\n",
        "        )\n",
        "        n_choose_k_equals.next_to(ORIGIN, RIGHT, LARGE_BUFF)\n",
        "        n_choose_k_equals.to_edge(UP, LARGE_BUFF)\n",
        "\n",
        "        self.play(\n",
        "            self.names.restore,\n",
        "            FadeOut(self.lines),\n",
        "            FadeOut(self.place_words),\n",
        "        )\n",
        "        self.play(\n",
        "            self.people_group.to_edge, LEFT,\n",
        "            FadeIn(n_choose_k_equals),\n",
        "            self.fraction.next_to, n_choose_k_equals, RIGHT, SMALL_BUFF\n",
        "        )\n",
        "\n",
        "    def show_whats_being_counted(self):\n",
        "        n, k = self.n, self.k\n",
        "        letters = VGroup(*[name[0] for name in self.names])\n",
        "\n",
        "        rhs = OldTex(\"=\", \"{60\", \"\\\\over\", \"6}\")\n",
        "        rhs.next_to(self.fraction, RIGHT)\n",
        "\n",
        "        all_groups = VGroup()\n",
        "        lines = VGroup()\n",
        "        for ordered_triplet in it.combinations(letters, k):\n",
        "            line = VGroup()\n",
        "            for triplet in it.permutations(ordered_triplet):\n",
        "                group = VGroup(*triplet).copy()\n",
        "                group.save_state()\n",
        "                group.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "                line.add(group)\n",
        "                all_groups.add(group)\n",
        "            line.arrange(RIGHT, buff = LARGE_BUFF)\n",
        "            lines.add(line)\n",
        "        lines.arrange(DOWN)\n",
        "        lines.scale(0.8)\n",
        "        lines.to_edge(DOWN)\n",
        "        rects = VGroup(*[\n",
        "            SurroundingRectangle(\n",
        "                line, buff = 0,\n",
        "                stroke_width = 0,\n",
        "                fill_color = BLUE,\n",
        "                fill_opacity = 0.5,\n",
        "            )\n",
        "            for line in lines\n",
        "        ])\n",
        "\n",
        "        self.play(\n",
        "            Write(VGroup(*rhs[:-1])),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, all_groups,\n",
        "                lambda g : (g.restore,),\n",
        "                rate_func = lambda t : smooth(1-t),\n",
        "                run_time = 4,\n",
        "                lag_ratio = 0.2,\n",
        "            ),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, rects),\n",
        "            Write(rhs[-1])\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.ordered_triplets = lines\n",
        "        self.triplet_group_rects = rects\n",
        "        self.rhs = rhs\n",
        "\n",
        "    def indicate_final_answer(self):\n",
        "        ordered_triplets = self.ordered_triplets\n",
        "        rects = self.triplet_group_rects\n",
        "        fraction = VGroup(*self.rhs[1:])\n",
        "        frac_rect = SurroundingRectangle(fraction)\n",
        "\n",
        "        brace = Brace(rects, LEFT)\n",
        "        brace_tex = brace.get_tex(\"10\")\n",
        "\n",
        "        self.play(FocusOn(fraction))\n",
        "        self.play(ShowCreation(frac_rect))\n",
        "        self.play(FadeOut(frac_rect))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            GrowFromCenter(brace),\n",
        "            Write(brace_tex),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_choice_counts(self, n, k):\n",
        "        people_braces = self.people_braces\n",
        "        choice_counts = VGroup(*[\n",
        "            OldTexText(\n",
        "                \"(\", str(n0), \" choices\", \")\",\n",
        "                arg_separator = \"\"\n",
        "            )\n",
        "            for n0 in range(n, n-k, -1)\n",
        "        ])\n",
        "        choice_counts.arrange(RIGHT, buff = SMALL_BUFF)\n",
        "        choice_counts.set_color_by_gradient(*self.line_colors)\n",
        "        choice_counts.next_to(people_braces, DOWN)\n",
        "        return choice_counts\n",
        "\n",
        "    def get_choice_count_arrows(self, choice_counts):\n",
        "        lines = self.lines\n",
        "        return VGroup(*[\n",
        "            Arrow(\n",
        "                count.get_bottom(), \n",
        "                line.get_center() + MED_LARGE_BUFF*UP,\n",
        "                color = line.get_color()\n",
        "            )\n",
        "            for count, line in zip(choice_counts, lines)\n",
        "        ])\n",
        "\n",
        "    def get_lines_and_place_words(self):\n",
        "        n, k = self.n, self.k\n",
        "        width = max([n.get_width() for n in self.names]) + MED_SMALL_BUFF\n",
        "        lines = VGroup(*[\n",
        "            Line(ORIGIN, width*RIGHT)\n",
        "            for x in range(k)\n",
        "        ])\n",
        "        lines.arrange(RIGHT)\n",
        "        lines.next_to(ORIGIN, DOWN, buff = LARGE_BUFF)\n",
        "        place_words = VGroup(*[\n",
        "            OldTex(\"%d^\\\\text{%s}\"%(i+1, s))\n",
        "            for i, s in zip(\n",
        "                list(range(k)), \n",
        "                it.chain([\"st\", \"nd\", \"rd\"], it.repeat(\"th\"))\n",
        "            )\n",
        "        ])\n",
        "        for mob in place_words, lines:\n",
        "            mob.set_color_by_gradient(*self.line_colors)\n",
        "        for word, line in zip(place_words, lines):\n",
        "            word.next_to(line, DOWN, SMALL_BUFF)\n",
        "\n",
        "        self.set_variables_as_attrs(lines, place_words)\n",
        "        return lines, place_words\n",
        "\n",
        "class NineChooseFourExample(HowToComputeNChooseK):\n",
        "    CONFIG = {\n",
        "        \"random_seed\" : 2,\n",
        "        \"n\" : 9,\n",
        "        \"k\" : 4,\n",
        "        \"line_colors\" : [RED, MAROON_B],\n",
        "        \"n_permutaitons_to_show\" : 3,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_people()\n",
        "        self.show_n_choose_k()\n",
        "        self.show_n_choose_k_pattern()\n",
        "        self.choose_k_people()\n",
        "        self.count_how_to_choose_k()\n",
        "        self.show_permutations()\n",
        "        self.finish_computation()\n",
        "\n",
        "    def setup_people(self):\n",
        "        self.remove(self.people)\n",
        "        self.people = OldTexText(\" \".join([\n",
        "            chr(ord('A') + i )\n",
        "            for i in range(self.n)\n",
        "        ]))\n",
        "        self.people.set_color_by_gradient(BLUE, YELLOW)\n",
        "        self.names = self.people\n",
        "        self.people.to_edge(UP, buff = LARGE_BUFF + MED_SMALL_BUFF)\n",
        "        lb, rb = braces = OldTexText(\"\\\\{\\\\}\")\n",
        "        braces.scale(1.5)\n",
        "        lb.next_to(self.people, LEFT, SMALL_BUFF)\n",
        "        rb.next_to(self.people, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        self.people_group = VGroup(braces, self.people)\n",
        "        self.people_braces = braces\n",
        "\n",
        "    def show_n_choose_k(self):\n",
        "        n, k = self.n, self.k\n",
        "        n_choose_k = OldTex(\"{%d \\\\choose %d}\"%(n, k))\n",
        "        n_choose_k.to_corner(UP + LEFT)\n",
        "        self.play(FadeIn(n_choose_k))\n",
        "        self.set_variables_as_attrs(n_choose_k)\n",
        "\n",
        "    def show_n_choose_k_pattern(self):\n",
        "        n, k = self.n, self.k\n",
        "        stack = get_stack(\n",
        "            OldTex(\"1\").set_color(PINK),\n",
        "            OldTex(\"0\").set_color(BLUE),\n",
        "            n, k\n",
        "        )\n",
        "        l = len(stack)\n",
        "        n_stacks = 6\n",
        "        columns = VGroup(*[\n",
        "            VGroup(*stack[(i*l)/n_stacks:((i+1)*l)/n_stacks])\n",
        "            for i in range(n_stacks)\n",
        "        ])\n",
        "        columns.arrange(\n",
        "            RIGHT, \n",
        "            aligned_edge = UP,\n",
        "            buff = MED_LARGE_BUFF\n",
        "        )\n",
        "        columns.set_height(7)\n",
        "        columns.to_corner(DOWN + RIGHT)\n",
        "\n",
        "        for line in stack:\n",
        "            self.play(FadeIn(line, run_time = 0.1))\n",
        "        self.wait(2)\n",
        "        self.play(FadeOut(\n",
        "            stack, lag_ratio = 0.5, run_time = 2\n",
        "        ))\n",
        "\n",
        "    def choose_k_people(self):\n",
        "        n, k = self.n, self.k\n",
        "        people = self.people\n",
        "        braces = self.people_braces\n",
        "\n",
        "        n_items = OldTexText(\"%d items\"%n)\n",
        "        choose_k = OldTexText(\"choose %d\"%k)\n",
        "        n_items.next_to(people, UP, buff = MED_LARGE_BUFF)\n",
        "        choose_k.next_to(people, DOWN, buff = LARGE_BUFF)\n",
        "\n",
        "        chosen_subset = VGroup(*random.sample(people, k))\n",
        "\n",
        "        self.play(\n",
        "            Write(braces),\n",
        "            LaggedStartMap(FadeIn, people, run_time = 1),\n",
        "            FadeIn(n_items),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(choose_k),\n",
        "            LaggedStartMap(\n",
        "                ApplyMethod, chosen_subset,\n",
        "                lambda m : (m.shift, MED_LARGE_BUFF*DOWN)\n",
        "            )\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            chosen_subset.shift, MED_LARGE_BUFF*UP,\n",
        "            n_items.next_to, n_items.get_center(), LEFT,\n",
        "            choose_k.next_to, n_items.get_center(), RIGHT,\n",
        "        )\n",
        "\n",
        "    def count_how_to_choose_k(self):\n",
        "        lines, place_words = self.get_lines_and_place_words()\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, lines),\n",
        "            LaggedStartMap(FadeIn, place_words),\n",
        "            run_time = 1\n",
        "        )\n",
        "        self.count_possibilities()\n",
        "\n",
        "    def show_permutations(self):\n",
        "        self.show_permutations_of_ABC()\n",
        "        self.count_permutations_of_ABC()\n",
        "\n",
        "    def finish_computation(self):\n",
        "        equals = OldTex(\"=\")\n",
        "        equals.shift(2*LEFT)\n",
        "        fraction = self.fraction\n",
        "        six = fraction[0][0][3]\n",
        "        eight = fraction[0][0][1]\n",
        "        two_three = VGroup(*fraction[2][0][1:3])\n",
        "        four = fraction[2][0][0]\n",
        "\n",
        "        rhs = OldTex(\"= 9 \\\\cdot 2 \\\\cdot 7 = 126\")\n",
        "\n",
        "        self.play(\n",
        "            self.names.restore,\n",
        "            FadeOut(self.lines),\n",
        "            FadeOut(self.place_words),\n",
        "            self.n_choose_k.next_to, equals, LEFT,\n",
        "            self.fraction.next_to, equals, RIGHT,\n",
        "            FadeIn(equals),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        for mob in six, eight, two_three, four:\n",
        "            mob.cross = Cross(mob)\n",
        "            mob.cross.set_stroke(\"red\", 5)\n",
        "        two = OldTex(\"2\")\n",
        "        two.set_color(eight.get_fill_color())\n",
        "        two.next_to(eight, UP)\n",
        "        rhs.next_to(fraction, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(six.cross),\n",
        "            ShowCreation(two_three.cross),\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            ShowCreation(eight.cross),\n",
        "            ShowCreation(four.cross),\n",
        "            FadeIn(two)\n",
        "        )\n",
        "        self.wait()\n",
        "        self.play(Write(rhs))\n",
        "        self.wait()\n",
        "\n",
        "class WeirdKindOfCancelation(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        fraction = OldTex(\n",
        "            \"{5 \\\\cdot 4 \\\\cdot 3\", \n",
        "            \"\\\\text{ ordered}\", \"\\\\text{ triplets}\",\n",
        "            \"\\\\over\",\n",
        "            \"1 \\\\cdot 2 \\\\cdot 3\", \"\\\\text{ orderings \\\\;\\\\qquad}}\"\n",
        "        )\n",
        "        top_numbers, ordered, triplets, frac_line, bottom_numbers, orderings = fraction\n",
        "        for mob in top_numbers, bottom_numbers:\n",
        "            mob.set_color_by_gradient(GREEN, YELLOW)\n",
        "        fraction.next_to(self.teacher, UP+LEFT)\n",
        "\n",
        "        names = VGroup(*list(map(TexText, [\n",
        "            \"Ali\", \"Ben\", \"Cam\", \"Denis\", \"Evan\"\n",
        "        ])))\n",
        "        names.arrange(RIGHT)\n",
        "        names.to_edge(UP, buff = LARGE_BUFF)\n",
        "        names.save_state()\n",
        "        lb, rb = braces = OldTex(\"\\\\{\\\\}\")\n",
        "        braces.scale(2)\n",
        "        lb.next_to(names, LEFT, SMALL_BUFF)\n",
        "        rb.next_to(names, RIGHT, SMALL_BUFF)\n",
        "\n",
        "        chosen_names = VGroup(*random.sample(names, 3))\n",
        "        chosen_names.generate_target()\n",
        "        chosen_names.target.arrange(RIGHT)\n",
        "        chosen_names.target.next_to(top_numbers, UP, MED_LARGE_BUFF)\n",
        "        for name, name_target in zip(chosen_names, chosen_names.target):\n",
        "            name.target = name_target\n",
        "\n",
        "        self.teacher_says(\"It's like unit cancellation.\")\n",
        "        self.play_student_changes(*[\"confused\"]*3)\n",
        "        self.play(\n",
        "            RemovePiCreatureBubble(\n",
        "                self.teacher, target_mode = \"raise_right_hand\"\n",
        "            ),\n",
        "            LaggedStartMap(FadeIn, fraction, run_time = 1),\n",
        "            FadeIn(braces),\n",
        "            LaggedStartMap(FadeIn, names)\n",
        "        )\n",
        "        self.play_student_changes(\n",
        "            *[\"pondering\"]*3,\n",
        "            look_at = fraction\n",
        "        )\n",
        "\n",
        "        #Go through numerators\n",
        "        for num, name in zip(top_numbers[::2], chosen_names):\n",
        "            rect = SurroundingRectangle(num)\n",
        "            name.target.set_color(num.get_color())\n",
        "            self.play(\n",
        "                ShowCreationThenDestruction(rect),\n",
        "                MoveToTarget(name),\n",
        "            )\n",
        "        self.wait(2)\n",
        "\n",
        "        #Go through denominators\n",
        "        permutations = list(it.permutations(list(range(3))))[1:]\n",
        "\n",
        "        self.shuffle(chosen_names, permutations[:2])\n",
        "        self.play(LaggedStartMap(\n",
        "            ShowCreationThenDestruction,\n",
        "            VGroup(*list(map(SurroundingRectangle, bottom_numbers[::2])))\n",
        "        ))\n",
        "        self.shuffle(chosen_names, permutations[2:])\n",
        "        self.wait()\n",
        "\n",
        "        #Show cancelation\n",
        "        top_cross = Cross(ordered)\n",
        "        bottom_cross = Cross(orderings)\n",
        "\n",
        "        self.play(\n",
        "            ShowCreation(top_cross),\n",
        "            self.teacher.change, \"maybe\",\n",
        "        )\n",
        "        self.play(ShowCreation(bottom_cross))\n",
        "        self.play_student_changes(*[\"happy\"]*3)\n",
        "        self.wait(3)\n",
        "\n",
        "    ###\n",
        "\n",
        "    def shuffle(self, mobject, permutations):\n",
        "        for permutation in permutations:\n",
        "            self.play(*[\n",
        "                ApplyMethod(\n",
        "                    m.move_to, mobject[i].get_center(),\n",
        "                    path_arc = np.pi,\n",
        "                )\n",
        "                for i, m in zip(permutation, mobject)\n",
        "            ])\n",
        "\n",
        "class ABCNotBCA(Scene):\n",
        "    def construct(self):\n",
        "        words = OldTexText(\"If order mattered:\")\n",
        "        equation = OldTexText(\"(A, B, C) $\\\\ne$ (B, C, A)\")\n",
        "        equation.set_color(YELLOW)\n",
        "        equation.next_to(words, DOWN)\n",
        "        group = VGroup(words, equation)\n",
        "        group.set_width(FRAME_WIDTH - 1)\n",
        "        group.to_edge(DOWN)\n",
        "        self.add(words, equation)\n",
        "\n",
        "class ShowFormula(Scene):\n",
        "    def construct(self):\n",
        "        specific_formula = OldTex(\n",
        "            \"{9 \\\\choose 4}\", \"=\",\n",
        "            \"{9 \\\\cdot 8 \\\\cdot 7 \\\\cdot 6\", \"\\\\over\",\n",
        "            \"4 \\\\cdot 3 \\\\cdot 2 \\\\cdot 1}\"\n",
        "        )\n",
        "        general_formula = OldTex(\n",
        "            \"{n \\\\choose k}\", \"=\",\n",
        "            \"{n \\\\cdot (n-1) \\\\cdots (n-k+1)\", \"\\\\over\",\n",
        "            \"k \\\\cdot (k-1) \\\\cdots 2 \\\\cdot 1}\"\n",
        "        )\n",
        "        for i, j in (0, 1), (2, 0), (2, 3), (2, 11):\n",
        "            general_formula[i][j].set_color(BLUE)\n",
        "        for i, j in (0, 2), (2, 13), (4, 0), (4, 3):\n",
        "            general_formula[i][j].set_color(YELLOW)\n",
        "        formulas = VGroup(specific_formula, general_formula)\n",
        "        formulas.arrange(DOWN, buff = 2)\n",
        "        formulas.to_edge(UP)\n",
        "\n",
        "        self.play(FadeIn(specific_formula))\n",
        "        self.play(FadeIn(general_formula))\n",
        "        self.wait(3)\n",
        "\n",
        "class ConfusedPi(Scene):\n",
        "    def construct(self):\n",
        "        morty = Mortimer()\n",
        "        morty.scale(2.5)\n",
        "        morty.to_corner(UP+LEFT)\n",
        "        morty.look(UP+LEFT)\n",
        "\n",
        "        self.add(morty)\n",
        "        self.play(Blink(morty))\n",
        "        self.play(morty.change, \"confused\")\n",
        "        self.wait()\n",
        "        self.play(Blink(morty))\n",
        "        self.wait(2)\n",
        "\n",
        "class SumsToPowerOf2(Scene):\n",
        "    CONFIG = {\n",
        "        \"n\" : 5,\n",
        "        \"alt_n\" : 7,\n",
        "    }\n",
        "    def construct(self):\n",
        "        self.setup_stacks()\n",
        "        self.count_32()\n",
        "        self.show_sum_as_n_choose_k()\n",
        "        self.show_alternate_sum()\n",
        "\n",
        "    def setup_stacks(self):\n",
        "        stacks = get_stacks(\n",
        "            OldTex(\"1\").set_color(PINK),\n",
        "            OldTex(\"0\").set_color(BLUE),\n",
        "            n = self.n,\n",
        "            vertical_buff = SMALL_BUFF,\n",
        "        )\n",
        "        stacks.to_corner(DOWN+LEFT)\n",
        "        numbers = VGroup(*[\n",
        "            OldTex(str(choose(self.n, k)))\n",
        "            for k in range(self.n + 1)\n",
        "        ])\n",
        "        for number, stack in zip(numbers, stacks):\n",
        "            number.next_to(stack, UP)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeIn, stacks),\n",
        "            LaggedStartMap(FadeIn, numbers),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(stacks, numbers)\n",
        "\n",
        "    def count_32(self):\n",
        "        lines = VGroup(*it.chain(*self.stacks))\n",
        "        rhs = OldTex(\"= 2^{%d}\"%self.n)\n",
        "        rhs.to_edge(UP, buff = LARGE_BUFF)\n",
        "        rhs.to_edge(RIGHT, buff = 2)\n",
        "\n",
        "        numbers = self.numbers.copy()\n",
        "        numbers.target = VGroup(*[\n",
        "            OldTex(\"{%d \\\\choose %d}\"%(self.n, k))\n",
        "            for k in range(self.n + 1)\n",
        "        ])\n",
        "        plusses = VGroup(*[Tex(\"+\") for n in numbers])\n",
        "        plusses.remove(plusses[-1])\n",
        "        plusses.add(OldTex(\"=\"))\n",
        "        sum_group = VGroup(*it.chain(*list(zip(\n",
        "            numbers.target, plusses\n",
        "        ))))\n",
        "        sum_group.arrange(RIGHT, SMALL_BUFF)\n",
        "        sum_group.next_to(numbers, UP, LARGE_BUFF)\n",
        "        sum_group.shift(MED_LARGE_BUFF*RIGHT)\n",
        "\n",
        "        for i, line in zip(it.count(1), lines):\n",
        "            line_copy = line.copy().set_color(YELLOW)\n",
        "            number = Integer(i)\n",
        "            number.scale(1.5)\n",
        "            number.to_edge(UP)\n",
        "            VGroup(number, line_copy).set_color(YELLOW)\n",
        "            self.add(line_copy, number)\n",
        "            self.wait(0.15)\n",
        "            self.remove(line_copy, number)\n",
        "        sum_result = number\n",
        "        self.add(sum_result)\n",
        "        self.wait()\n",
        "\n",
        "        sum_result.target = OldTex(str(2**self.n))\n",
        "        sum_result.target.set_color(sum_result.get_color())\n",
        "        sum_result.target.next_to(sum_group, RIGHT)\n",
        "        rhs.next_to(sum_result.target, RIGHT, aligned_edge = DOWN)\n",
        "        self.play(\n",
        "            MoveToTarget(sum_result),\n",
        "            MoveToTarget(numbers),\n",
        "            Write(plusses),\n",
        "            Write(rhs),\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "        self.set_variables_as_attrs(\n",
        "            plusses, sum_result, rhs,\n",
        "            n_choose_k_terms = numbers\n",
        "        )\n",
        "\n",
        "    def show_sum_as_n_choose_k(self):\n",
        "        numbers = self.numbers\n",
        "        plusses = self.plusses\n",
        "        n_choose_k_terms = self.n_choose_k_terms\n",
        "        rhs = VGroup(self.sum_result, self.rhs)\n",
        "        n = self.n\n",
        "\n",
        "\n",
        "        fractions = self.get_fractions(n)\n",
        "        plusses.generate_target()\n",
        "        sum_group = VGroup(*it.chain(*list(zip(\n",
        "            fractions, plusses.target\n",
        "        ))))\n",
        "        sum_group.arrange(RIGHT, buff = 2*SMALL_BUFF)\n",
        "        sum_group.next_to(rhs, LEFT)\n",
        "        sum_group.shift(0.5*SMALL_BUFF*DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Transform(n_choose_k_terms, fractions),\n",
        "            MoveToTarget(plusses),\n",
        "            lag_ratio = 0.5,\n",
        "            run_time = 2\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "    def show_alternate_sum(self):\n",
        "        fractions = self.get_fractions(self.alt_n)\n",
        "        fractions.remove(*fractions[4:-1])\n",
        "        fractions.submobjects.insert(4, OldTex(\"\\\\cdots\"))\n",
        "        plusses = VGroup(*[\n",
        "            OldTex(\"+\") for f in fractions[:-1]\n",
        "        ] + [Tex(\"=\")])\n",
        "        sum_group = VGroup(*it.chain(*list(zip(\n",
        "            fractions, plusses\n",
        "        ))))\n",
        "        sum_group.arrange(RIGHT)\n",
        "        sum_group.next_to(\n",
        "            self.n_choose_k_terms, DOWN,\n",
        "            aligned_edge = LEFT, buff = LARGE_BUFF\n",
        "        )\n",
        "        sum_group.shift(SMALL_BUFF*DOWN)\n",
        "        rhs = OldTex(\n",
        "            str(2**self.alt_n), \n",
        "            \"=\", \"2^{%d}\"%(self.alt_n)\n",
        "        )\n",
        "        rhs[0].set_color(YELLOW)\n",
        "        rhs.next_to(sum_group, RIGHT)\n",
        "\n",
        "        self.play(\n",
        "            LaggedStartMap(FadeOut, self.stacks),\n",
        "            LaggedStartMap(FadeOut, self.numbers),\n",
        "            LaggedStartMap(FadeIn, sum_group),\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, rhs))\n",
        "        self.wait(2)\n",
        "\n",
        "    ####\n",
        "\n",
        "    def get_fractions(self, n):\n",
        "        fractions = VGroup(OldTex(\"1\"))\n",
        "        dot_str = \" \\\\!\\\\cdot\\\\! \"\n",
        "        for k in range(1, n+1):\n",
        "            ts = str(n)\n",
        "            bs = \"1\"\n",
        "            for i in range(1, k):\n",
        "                ts += dot_str + str(n-i)\n",
        "                bs += dot_str + str(i+1)\n",
        "            fraction = OldTex(\"{%s \\\\over %s}\"%(ts, bs))\n",
        "            fractions.add(fraction)\n",
        "        return fractions\n",
        "\n",
        "class AskWhyTheyAreCalledBinomial(TeacherStudentsScene):\n",
        "    def construct(self):\n",
        "        example_binomials = VGroup(*[\n",
        "            OldTex(\"(x+y)^%d\"%d)\n",
        "            for d in range(2, 7)\n",
        "        ])\n",
        "        example_binomials.arrange(UP)\n",
        "        example_binomials.next_to(\n",
        "            self.teacher.get_corner(UP+LEFT), UP \n",
        "        )\n",
        "\n",
        "        pascals = PascalsTriangle(n_rows = 6)\n",
        "        pascals.set_height(3)\n",
        "        pascals.to_corner(UP+LEFT, buff = MED_SMALL_BUFF)\n",
        "        pascals.set_color_by_gradient(BLUE, YELLOW)\n",
        "\n",
        "        binomial_word = OldTexText(\n",
        "            \"Bi\", \"nomials\",\n",
        "            arg_separator = \"\",\n",
        "        )\n",
        "        binomial_word.set_color_by_tex(\"Bi\", YELLOW)\n",
        "        binomial_word.set_color_by_tex(\"nomials\", WHITE)\n",
        "        binomial_word.next_to(example_binomials, LEFT, buff = 1.5)\n",
        "        arrows = VGroup(*[\n",
        "            Arrow(binomial_word.get_right(), binom.get_left())\n",
        "            for binom in example_binomials\n",
        "        ])\n",
        "        arrows.set_color(BLUE)\n",
        "\n",
        "        two_variables = OldTexText(\"Two\", \"variables\")\n",
        "        two_variables.next_to(binomial_word, DOWN)\n",
        "        two_variables.shift(SMALL_BUFF*LEFT)\n",
        "        for tv, bw in zip(two_variables, binomial_word):\n",
        "            tv.set_color(bw.get_color())\n",
        "\n",
        "        self.student_says(\n",
        "            \"Why are they called \\\\\\\\ ``binomial coefficients''?\"\n",
        "        )\n",
        "        self.play(LaggedStartMap(FadeIn, pascals))\n",
        "        self.wait()\n",
        "        self.play(\n",
        "            FadeIn(example_binomials[0]),\n",
        "            RemovePiCreatureBubble(self.students[1]),\n",
        "            self.teacher.change, \"raise_right_hand\",\n",
        "        )\n",
        "        moving_binom = example_binomials[0].copy()\n",
        "        for binom in example_binomials[1:]:\n",
        "            self.play(Transform(moving_binom, binom))\n",
        "            self.add(binom)\n",
        "        self.wait()\n",
        "\n",
        "        #Name themn\n",
        "        self.play(\n",
        "            Write(binomial_word),\n",
        "            LaggedStartMap(GrowArrow, arrows)\n",
        "        )\n",
        "        self.play_student_changes(*[\"pondering\"]*3)\n",
        "        self.play(Write(two_variables))\n",
        "        self.wait(2)\n",
        "\n",
        "class NextVideo(Scene):\n",
        "    def construct(self):\n",
        "        title = OldTexText(\"Next video: Binomial distribution\")\n",
        "        title.to_edge(UP)\n",
        "        screen = ScreenRectangle(height = 6)\n",
        "        screen.next_to(title, DOWN)\n",
        "\n",
        "        self.play(\n",
        "            Write(title),\n",
        "            ShowCreation(screen)\n",
        "        )\n",
        "        self.wait()\n",
        "\n",
        "class CombinationsPatreonEndScreen(PatreonEndScreen):\n",
        "    CONFIG = {\n",
        "        \"specific_patrons\" : [\n",
        "            \"Randall Hunt\",\n",
        "            \"Desmos\",\n",
        "            \"Burt Humburg\",\n",
        "            \"CrypticSwarm\",\n",
        "            \"Juan Benet\",\n",
        "            \"David Kedmey\",\n",
        "            \"Ali Yahya\",\n",
        "            \"Mayank M. Mehrotra\",\n",
        "            \"Lukas Biewald\",\n",
        "            \"Yana Chernobilsky\",\n",
        "            \"Kaustuv DeBiswas\",\n",
        "            \"Kathryn Schmiedicke\",\n",
        "            \"Yu Jun\",\n",
        "            \"Dave Nicponski\",\n",
        "            \"Damion Kistler\",\n",
        "            \"Jordan Scales\",\n",
        "            \"Markus Persson\",\n",
        "            \"Egor Gumenuk\",\n",
        "            \"Yoni Nazarathy\",\n",
        "            \"Ryan Atallah\",\n",
        "            \"Joseph John Cox\",\n",
        "            \"Luc Ritchie\",\n",
        "            \"Supershabam\",\n",
        "            \"James Park\",\n",
        "            \"Samantha D. Suplee\",\n",
        "            \"Delton Ding\",\n",
        "            \"Thomas Tarler\",\n",
        "            \"Jonathan Eppele\",\n",
        "            \"Isak Hietala\",\n",
        "            \"1stViewMaths\",\n",
        "            \"Jacob Magnuson\",\n",
        "            \"Mark Govea\",\n",
        "            \"Dagan Harrington\",\n",
        "            \"Clark Gaebel\",\n",
        "            \"Eric Chow\",\n",
        "            \"Mathias Jansson\",\n",
        "            \"David Clark\",\n",
        "            \"Michael Gardner\",\n",
        "            \"Mads Elvheim\",\n",
        "            \"Erik Sundell\",\n",
        "            \"Awoo\",\n",
        "            \"Dr. David G. Stork\",\n",
        "            \"Tianyu Ge\",\n",
        "            \"Ted Suzman\",\n",
        "            \"Linh Tran\",\n",
        "            \"Andrew Busey\",\n",
        "            \"John Haley\",\n",
        "            \"Ankalagon\",\n",
        "            \"Eric Lavault\",\n",
        "            \"Boris Veselinovich\",\n",
        "            \"Julian Pulgarin\",\n",
        "            \"Jeff Linse\",\n",
        "            \"Cooper Jones\",\n",
        "            \"Ryan Dahl\",\n",
        "            \"Robert Teed\",\n",
        "            \"Jason Hise\",\n",
        "            \"Meshal Alshammari\",\n",
        "            \"Bernd Sing\",\n",
        "            \"James Thornton\",\n",
        "            \"Mustafa Mahdi\",\n",
        "            \"Mathew Bramson\",\n",
        "            \"Jerry Ling\",\n",
        "            \"Shimin Kuang\",\n",
        "            \"Rish Kundalia\",\n",
        "            \"Achille Brighton\",\n",
        "            \"Ripta Pasay\",\n",
        "        ]\n",
        "    }\n",
        "\n",
        "class Thumbnail(Scene):\n",
        "    def construct(self):\n",
        "        n_choose_k = OldTex(\"n \\\\choose k\")\n",
        "        n_choose_k[1].set_color(YELLOW)\n",
        "        n_choose_k[2].set_color(YELLOW)\n",
        "        n_choose_k.scale(2)\n",
        "        n_choose_k.to_edge(UP)\n",
        "        stacks = get_stacks(\n",
        "            OldTex(\"1\").set_color(PINK),\n",
        "            OldTex(\"0\").set_color(BLUE),\n",
        "            n = 5, vertical_buff = SMALL_BUFF,\n",
        "        )\n",
        "        stacks.to_edge(DOWN)\n",
        "        stacks.shift(MED_SMALL_BUFF*LEFT)\n",
        "\n",
        "        self.add(n_choose_k, stacks)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n"
    ]
}